{"id": "3d23Rh", "name": "SunetJonathanCasem Jan22", "author": "asdhyq", "description": "isuckatthis", "tags": ["sunsetpallete"], "likes": 0, "viewed": 37, "published": "Public", "date": "1583122817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA = vec3(0.2509,0.1568,0.2901);\nvec3 colorB = vec3(0.4509,0.2627,0.2941);\nvec3 colorC = vec3(0.7019,0.3019,0.1450);\nvec3 colorD = vec3(0.9411,0.4941,0.0274);\nvec3 colorE = vec3(0.9686,0.8705,0.3333);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 color = mix(colorA,colorB,uv.y) * .5 + .5 * (sin(iTime / 2. - uv.y + colorD) * 2.)  * (sin(iTime / 2. - uv.y + colorE) + .1);\n    //vec3 color = mix(colorA,colorB,colorC) * .5 + .5 * (sin(iTime / 2. - uv.y + colorD) * 2.) * (sin(iTime / 2. - uv.y + colorE) + .1));\n\t\n    vec3 color = mix(colorA,colorB,uv.y);\n    color = mix(color,colorC,uv.y);\n\tcolor = mix(color,colorD,uv.y);\n    color = mix(colorE,color,uv.y);\n    \n    color = mix(colorA,color,sin(iTime - uv.y)) + mix(colorA,color,sin(iTime + uv.y)) ;\n       // Output to screen\n    fragColor = vec4(color,1.0);\n}\t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 268, 318, 971]], "test": "ok"}
{"id": "3dBSDV", "name": "Uniform", "author": "asdhyq", "description": "Motion", "tags": ["motion"], "likes": 1, "viewed": 37, "published": "Public", "date": "1583122858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvec3 blue = vec3(0.,128./255.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 white = vec3(1.,1.,1.);\n\nvec3 rgb(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n    \n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x,0.,0.,value.y);\n}\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), - sin(angle),sin(angle),cos(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv *= noise(uv) ;\n    uv = fract(uv * 5.);\n    float x = sin(iTime * 1.5 ) ;\n    \n\tuv*=10.;\n    float ratio = iResolution.x / iResolution.y;\n    \n    //float offset = step(1.,mod(uv.y ,2.));\n    float offset = mod(uv.y ,2.) > 1. ? -1. : 1.;\n    uv.x += offset * iTime;\n    uv = fract(uv);\n    \n    //uv.x = mod(offset,2.) != 0. ? uv.x += offset + (iTime) : uv.x -= offset + (iTime);\n    \n    //float offset2 = step(1.,mod(uv.y * 1.,2.));\n    //offset = mod(offset,2.) ? 0. : 1.;\n  \n\t//uv.x = mod(offset,2.) == 0. ? uv.x +=offset * (iTime) : uv.x -=offset * (iTime); \n  \n   //\tuv.x += offset * sin(iTime);\n  \n    \n    \n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 * ratio,0.5);\n    uv -= pos;\n    \n    uv *= rotate2d(sin(iTime));\n    uv *= scale2d(vec2(1.0,1.0));\n    \n    uv+=pos;\n    vec2 shapePos = vec2(.5 * ratio, .5);\n    float dist = distance ( shapePos,uv) ;\n    \n    uv -= shapePos;\n    \n    \n\t\n    // rectangle Properties\n\tvec2 center = vec2(0., 0.);\n\tfloat width = .2;\n\tfloat height = .2;\n\n    // Background layer\n\tvec4 bg = vec4(rgb(1.0, 1.0, 1.0), 1.0);\n\t\n\t// Rectangle\n\tvec3 col = blue;\n\tvec4 rect = rectangle(uv , center, width, height, col);\n\t\n     float c = fract(sin(uv.x * 100.) * 5647.);\n    vec3 cols = vec3(c);\n    \n   \twhite -= vec3(c);\n   \n\t// Blend the two\n\tvec3 color = mix(vec3(0.), white, rect.a);\n\t\n   \n       // Output to screen\n    fragColor = vec4(color + cols  / 5.,1.);\n    //fragColor *= iTime;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 196, 262], [264, 279, 304, 304, 815], [911, 911, 949, 949, 998], [1000, 1000, 1074, 1074, 1272], [1274, 1274, 1300, 1300, 1342], [1343, 1343, 1371, 1371, 1438], [1439, 1439, 1496, 1496, 2993]], "test": "ok"}
{"id": "3dfcDH", "name": "Complex Grid Mapping", "author": "encryptedmaze", "description": "Graphs the inverse of complex functions.", "tags": ["grid", "graph", "complexnumbers"], "likes": 3, "viewed": 265, "published": "Public API", "date": "1584637564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nvec2 cmul (vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);\n}\nvec2 cexp (vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\nvec2 clog (vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\nvec2 cpow (vec2 z, vec2 a) {\n\treturn cexp(cmul(a, clog(z)));\n}\nfloat animate() {\n\treturn -1.0f * cos((iTime) / 5.0f) * 0.996f + 1.004f;\n}\n// Any complex-valued function. The inverse of this function is graphed.\nvec2 transformation (vec2 uv) {\n\tvec2 ret = cpow(uv, vec2(animate(), 0.0f));\n    // vec2 pos = (vec2(iMouse.xy / iResolution.xy) - vec2(0.5f)) * 2.5f;\n    // vec2 ret = cpow(uv, cexp(pos));\n    // vec2 ret = vec2(uv.x + sin(uv.y + iTime * 0.05f) * 0.5f, uv.y + sin(uv.x + iTime * 0.1f) * 0.5f);\n\treturn ret;\n}\n// Compute gradient vector (this is used to keep line width consistent)\nvec2 gradient (vec2 uv, vec2 delta) {\n\treturn (transformation(uv + delta) - transformation(uv)) / delta;\n}\n// Creates smooth line edges\nvec2 smoothstep2d (float lineWidth, vec2 pos) {\n\tvec2 ret;\n\tret.x = smoothstep(-lineWidth, 0.0f, pos.x) - smoothstep(0.0f, lineWidth, pos.x);\n\tret.y = smoothstep(-lineWidth, 0.0f, pos.y) - smoothstep(0.0f, lineWidth, pos.y);\n\treturn ret;\n}\n// mod of each element in a vec2\nvec2 mod2d (vec2 a, vec2 b) {\n\treturn vec2(mod(a.x, b.x), mod(a.y, b.y));\n}\n// Draws the grid using an input \"UV\" vector\nvec3 drawGrid(vec2 uv, float lineWidth) {\n\tfloat modulator = 0.25f;\n\t\n\t// Compute \"Distortion\" to prevent variable line width\n\tlineWidth *= length(gradient(uv, vec2(0.0005f)));\n\t\n    // \"Transformed Vector\"\n    // take the input \"uv\" vector an apply a function to it\n    vec2 tv = transformation(uv) + vec2(modulator / 2.0f);\n    \n    // Some modular arithmetic to draw multiple lines\n\tvec2 gv = vec2(floor(tv.x / modulator), floor(tv.y / modulator));\n   \tvec2 mv = mod(tv, vec2(modulator));\n\tvec2 line = smoothstep2d(lineWidth, mv - vec2(modulator / 2.0f));\n\t\n\t// 3blue1brown style line colors\n\tvec3 col = vec3(0.0f, 0.15f, 0.2f) * length(line);\n    if (mod(gv.x, 2.0f) == 0.0f) col = max(col, vec3(0.0f, 0.6f, 0.8f) * vec3(line.x));\n\tif (mod(gv.y, 2.0f) == 0.0f) col = max(col, vec3(0.0f, 0.6f, 0.8f) * vec3(line.y));\n\tif (gv.x == 0.0f) col = max(col, vec3(line.x));\n\tif (gv.y == 0.0f) col = max(col, vec3(line.y));\n\t\n\treturn col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat lineWidth = 0.015f;\n\tint sampleCount = 3;\n\tfloat sampleSize = 0.001f;\n    // Get \"input\" uv vector\n\tvec2 uv = (fragCoord - 0.5f * iResolution.xy) / (iResolution.y) * vec2(5.0f, -5.0f);\n\tvec3 col = drawGrid(uv, lineWidth);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 80, 80, 142], [143, 143, 163, 163, 210], [211, 211, 231, 231, 279], [280, 280, 308, 308, 342], [343, 343, 360, 360, 417], [418, 491, 522, 522, 800], [801, 873, 910, 910, 979], [980, 1009, 1056, 1056, 1248], [1249, 1282, 1311, 1311, 1357], [1358, 1403, 1444, 1444, 2337], [2338, 2338, 2393, 2393, 2656]], "test": "timeout"}
{"id": "3dfcWX", "name": "camino--distorcion-v1", "author": "jorge2017a1", "description": "camino--distorcion-v1", "tags": ["caminodistorcionv1"], "likes": 0, "viewed": 34, "published": "Public", "date": "1585668076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n//const float pi = 3.1415927;\nconst float tau = 6.283185;\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r)\n{\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\nmat2 rotatev2(float r)\n{\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, -s, s, c);\n}\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n// square wave\nfloat squareRaw( in float p, in float dpdt )\n{\n    float t = fract(p/tau);\n    return sign(0.5-t);\n}\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+3.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    float planecerro= mapCerrov2(p-vec3(0.0,-2.5,0.0));\n    \n    //res=opU(res, vec2(planeDist2,4 ));  //pared lateral izq\n    //res=opU(res, vec2(planeDist3,3 ));//pared lateral der\n    //res=opU(res, vec2(planeDist1,7 ));  //piso inferior\n    res=opU(res, vec2(planecerro,7 ));  \n   \n    \n    \n    p.z=mod(p.z,8.0)-4.0;\n    pp.z=mod(pp.z,8.0)-4.0;\n    \n    ///---------------------------------------------\n\tfloat sdc11= sdCylinder( p-vec3(0.0,0.0,0.0) , vec2(0.5,2.0) );\n    float sdc21= sdCylinder( p-vec3(0.0,0.0,3.0) , vec2(0.5,2.0) );\n    float sdc31= sdCylinder( p-vec3(3.0,0.0,0.0) , vec2(0.5,2.0) );\n    float sdc41= sdCylinder( p-vec3(3.0,0.0,3.0) , vec2(0.5,2.0) );\n    \n    float sdsp11= sdSphere( p-vec3(1.5,4.5,0.0) , 2.0 );\n        \n    float sdb11= sdBox(p -vec3(1.55,2.25,1.0) , vec3(2.25,0.25,2.5) );\n    \n    res=opU(res, vec2(sdc11,8 ));  \n    res=opU(res, vec2(sdc21,8 ));  \n    res=opU(res, vec2(sdc31,8 ));  \n    res=opU(res, vec2(sdc41,8 ));  \n    \n    res=opU(res, vec2(sdb11,9 ));  \n    res=opU(res, vec2(sdsp11,7 ));  \n    ///---------------------------------------------\n    \n    \n    pp.x=p.x+20.0;\n    \n    ///----------columna chica n2\n    float sdc12= sdCylinder( pp-vec3(0.0,0.0,0.0) , vec2(0.5,2.0) );\n    float sdc22= sdCylinder( pp-vec3(0.0,0.0,3.0) , vec2(0.5,2.0) );\n    float sdc32= sdCylinder( pp-vec3(3.0,0.0,0.0) , vec2(0.5,2.0) );\n    float sdc42= sdCylinder( pp-vec3(3.0,0.0,3.0) , vec2(0.5,2.0) );\n    \n    float sdsp12= sdSphere( pp-vec3(1.5,4.5,0.0) , 2.0 );\n        \n    float sdb12= sdBox(pp -vec3(1.55,2.25,1.0) , vec3(2.25,0.25,2.5) );\n    \n    res=opU(res, vec2(sdc12,8 ));  \n    res=opU(res, vec2(sdc22,8 ));  \n    res=opU(res, vec2(sdc32,8 ));  \n    res=opU(res, vec2(sdc42,8 ));  \n    \n    res=opU(res, vec2(sdb12,9 ));  \n    res=opU(res, vec2(sdsp12,7 ));  \n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    vec2  p = fragCoord/iResolution.y;\n    float px = 1.0/iResolution.y;\n    float mx = iResolution.x/iResolution.y;\n \n   \n    float y0 = 0.85 +  sin(0.6*iTime*p.x/mx+20.);\n    \n   \n    vec3 ro = vec3(-8.0 ,0.0+y0,-20.0+iTime*5.0);\n    \n    //ro = get_mouse(ro);\n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[643, 660, 693, 693, 758], [762, 762, 797, 797, 821], [824, 839, 870, 870, 1020], [1021, 1041, 1077, 1077, 1164], [1165, 1181, 1213, 1241, 1302], [1304, 1304, 1340, 1340, 1443], [1446, 1446, 1491, 1491, 1582], [1584, 1584, 1619, 1619, 2104], [2156, 2156, 2202, 2202, 2234], [2236, 2236, 2279, 2279, 2311], [2313, 2313, 2361, 2361, 2394], [2397, 2397, 2426, 2426, 2552], [2554, 2554, 2590, 2590, 2707], [2709, 2709, 2745, 2745, 2863], [2866, 2866, 2902, 2902, 3025], [3078, 3090, 3112, 3112, 3420], [3421, 3447, 3472, 3472, 3662], [3663, 3708, 3725, 3725, 3798], [3801, 3834, 3860, 3860, 4057], [4104, 4104, 4156, 4156, 4311], [4376, 4485, 4522, 4522, 4557], [4559, 4559, 4578, 4578, 4653], [4702, 4702, 4725, 4725, 4751], [4753, 4753, 4776, 4776, 4914], [4970, 4970, 4992, 4992, 5062], [5065, 5065, 5089, 5089, 5159], [5223, 5223, 5249, 5249, 5306], [5308, 5308, 5328, 5328, 5386], [5389, 5389, 5410, 5410, 5660], [5703, 5703, 5729, 5729, 5900], [5903, 5918, 5964, 5964, 6018], [6020, 6064, 6089, 6089, 8339], [8344, 8344, 8377, 8377, 8852], [8856, 8856, 8880, 8880, 9212], [9217, 9217, 9255, 9255, 9613], [9712, 9756, 9773, 9773, 9844], [9869, 9961, 9986, 9986, 10249], [10370, 10370, 10398, 10398, 18751], [18754, 18754, 18811, 18811, 20051]], "test": "error"}
{"id": "3dfcz2", "name": "French Kif", "author": "haptix", "description": "Thanks to evvvvil_ and alkama", "tags": ["raymarching", "kif"], "likes": 2, "viewed": 276, "published": "Public API", "date": "1585128214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot(float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 hexPris(vec3 p, vec2 h, float matId)\n{\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n    p = abs(p);\n    p.xy -= 2.*min(dot(k.xy, p.xy), 0.)*k.xy;\n    vec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x), p.z - h.y);\n    return vec2(min(max(d.x,d.y), 0.) + length(max(d, 0.)), matId);\n}\n\nvec3 kif(vec3 p)\n{\n    for(int i = 0; i < 6; i++)\n    {\n        p = abs(p) - vec3(.05*cos((iTime + 76.)*.21) + .31,\n                          -.05*sin((iTime + 287.)*.23) + .35,\n                          .05*sin((iTime + 150.)*.25) + .37);\n        p.xz *= rot(.031*(iTime + 483.));\n        p.zy *= rot(.043*(iTime + 985.));\n        p.xy *= rot(.053*(iTime + 115.));\n    }\n    \n    return p;\n}\n\nvec2 map(vec3 p)\n{   \n    p = kif(p);\n    \n    float len = 20.;\n    p.z -= len/2.;\n    vec2 m1 = hexPris(p, vec2(.025, len), 1.);\n    p.x -= .03;\n    vec2 m2 = hexPris(p, vec2(.01, len), 2.);\n    vec2 m = m1.x < m2.x ? m1 : m2;\n    glo += .1 / (.1 + m.x*m.x*m.x*2500.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 40.;\n\tvec2 h,t= vec2(.001);\n\tfor(int i = 0; i < 384; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .00001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(1.5*cos(-.2*iTime),\n                   1.5*sin(-.2*iTime),\n                   -3.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(.5, 1.5, -15.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime + 44.)),\n                       sin(.151*(iTime + 55.)),\n                       sin(.227*(iTime + 79.))) + 1.25;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 85.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .23 * colRot;\n        col *= .1 * ao;\n        col += .5 * diff * colRot.yzx;\n        col += .8 * spec * vec3(1., 1., 1.);\n        \n        col += glo*.008*colRot;\n        \n        if(t.y == 2.)\n            col = col.zxy;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.008*colRot.zyx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 120], [122, 122, 165, 165, 445], [447, 447, 465, 465, 839], [841, 841, 859, 859, 1126], [1128, 1128, 1155, 1155, 1385], [1387, 1387, 1444, 1444, 3018]], "test": "timeout"}
{"id": "3dfczN", "name": "大龙猫 - Quicky#028", "author": "totetmatt", "description": "My first tunnel, thanks to Flopine last stream for the code.", "tags": ["quicky"], "likes": 14, "viewed": 374, "published": "Public API", "date": "1585257838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hr vec2(1.,sqrt(3.))\n\nvec4 hexagrid(vec2 uv,float detail){\n    uv*=detail;\n    vec2 ga = mod(uv,hr)-hr*.5;\n    vec2 gb = mod(uv-hr*0.5,hr) - hr*.5;\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n    vec2 gid = uv - guv;\n    return vec4(guv,gid);\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat trigrid(vec2 uv) {\n   return sign(fract(uv.x+0.5*uv.y)-fract(uv.y));\n}\n\n\nfloat cyl(vec3 p, float r, float h){\n \n    return max(length(p.xy)-r,abs(p.z)-h);\n}\n#define pTime floor(iTime*.01) + pow(fract(iTime*.01),.9)\n#define qTime floor(-iTime*2.) + pow(fract(-iTime*2.),1.5)\nfloat tunnel(vec3 p){\n        p.x += texture(iChannel0,p.xz*.01+vec2(0.,pTime)).x*4.;\n        p.y += texture(iChannel0,p.yz*.01+vec2(0.,pTime)).y*2.;\n         \n       return -cyl(p+vec3(cos(p.z*.1)*2.,sin(p.z*.1)*2.,0.),10.-p.z*.1,1000000.);\n}\n\nfloat box(vec3 p, vec3 c){\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\nfloat SDF(vec3 p) {\n    vec3 pp = p;\n    p.xz *= r(3.141592*.5);\n \n    pp.xy*=r((iTime*.02+pp.z*.05));\n    return tunnel(pp);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n   \n    vec3 ro  = vec3(.001,.001,-3.),\n    rd = normalize(vec3(uv,1.)),\n    p=ro,\n    col = vec3(0.);\n    \n    \n    \n    float shad = 0.;\n    for(float i=0.;i<256.;i++){\n         \n       float d = SDF(p);\n       if(d <0.001){\n        shad = i/64.;\n        break;\n       }\n       p += d*rd*1.1;\n    }\n    \n    vec4 h = hexagrid(uv,5.);\n    vec2 hg = h.xy;\n    vec2 hid = h.zw;\n  \n    col = vec3(shad);\n      vec3 mm = mix(vec3(cos(iTime),.5,.9),vec3(.9,sin(iTime),.1),sin(iTime*.5)*.5+.5);\n    \n    \n      float q = abs(tan( (qTime+p.z*.1)*.25));\n     col = mix(vec3(.1),vec3(mm.r*q,mm.g*q,mm.b*q),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfczN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 66, 66, 260], [261, 261, 277, 277, 335], [336, 336, 360, 360, 412], [415, 415, 451, 451, 498], [616, 616, 637, 637, 859], [861, 861, 887, 887, 972], [973, 973, 992, 992, 1100], [1103, 1103, 1158, 1158, 1858]], "test": "error"}
{"id": "3dfyD2", "name": "Playing with polar coordinates", "author": "MeHigh_", "description": "something, idk, i think it looks cool", "tags": ["polar"], "likes": 2, "viewed": 49, "published": "Public", "date": "1585561975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define clamp(a,b,c) max(a,min(b,c))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n\t\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    vec3 col = vec3(0.);\n    \n    col += clamp(0., 1., sin(a) * cos(iTime) * .5);\n    col += clamp(0., 1., cos(r) * sin(iTime) * .5);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 95, 95, 434]], "test": "ok"}
{"id": "3dfyDN", "name": "Coffee with milk", "author": "wnu", "description": "coffee with milk, offshoot of https://www.shadertoy.com/view/tslcD8, based on https://www.shadertoy.com/view/lsyfWD", "tags": ["coffee"], "likes": 3, "viewed": 67, "published": "Public", "date": "1584772580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float speed = 1.;\n    float scale = 0.002;\n    vec2 p = (fragCoord.xy/iResolution.xy- vec2(0.5))*2.0;\n    p.x *= iResolution.x/iResolution.y;\n    p *= 0.5;\n    \n    float l = smoothstep(0.0,1.,length(p));\n\n    //p += (1.-l)*(p)/(0.2 + l*1.);\n    \n    p.x += iTime/2.;\n    //vec2 p = fragCoord * scale;   \n    for(int i=1; i<10; i++){\n        p.x+=0.3/float(i)*sin(float(i)*4.*p.y+iTime*speed*1.);//+iMouse.x/1000.;\n        p.y+=0.3/float(i)*cos(float(i)*4.*p.x+iTime*speed*1.);//+iMouse.y/1000.;\n    }\n    //p.xy += iTime*10.;\n        \n    float t = iTime*1.0;\n    float gbOff = p.x;\n    float gOff = 0.0+p.y;\n    float rOff = 0.0;\n    float r=cos(p.x+p.y+1.+rOff)*.5+.5;\n    float g=sin(p.x+p.y+1.+gbOff+gOff)*.5+.5;\n    float b=(sin(p.x+p.y+gbOff)+cos(p.x+p.y+gbOff))*.3+.5;\n    float bo = 0.0;\n    float ro = smoothstep(0.75,0.0,r);\n    //ro = 1.0-step(0.05,r);\n    //ro = 0.;\n    vec3 color = vec3(r*(139./255.)+bo+ro,r*(69./255.)+bo+ro,r*(19./255.)+bo+ro);\n    \n    //vec3 color = vec3(p.x,p.y,0.0);\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1102]], "test": "timeout"}
{"id": "3dfyRr", "name": "Fractal storm 3", "author": "jarble", "description": "It's a very turbulent fractal animation.", "tags": ["fractal", "storm"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1583947073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/(81.*81.));\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = mag;\n    fragCoord *= zoom*((iMouse.x+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        //combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 560, 608, 608, 955], [956, 956, 1004, 1004, 1351], [1353, 1353, 1401, 1401, 1748], [3689, 3689, 3733, 3733, 3869], [3871, 3871, 3905, 3905, 3934], [3936, 3936, 3964, 3964, 5039], [5041, 5041, 5116, 5116, 6145], [7325, 7325, 7401, 7401, 8479], [8628, 8628, 8702, 8702, 9593], [9736, 9736, 9810, 9810, 10200], [10327, 10327, 10411, 10411, 11484], [14814, 14814, 14871, 14871, 15385]], "test": "error"}
{"id": "3dfyRs", "name": "36 Days Of Type - B", "author": "nicolasdnl", "description": "36 Days Of Type - B", "tags": ["letter"], "likes": 1, "viewed": 29, "published": "Public", "date": "1585607073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[6], float kPath[16] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n   \tint kType[] = int[](0,1,0,1,0,0);\n   \tfloat kPath[] = float[](-0.35,  0.5,\n                             0.15,  0.5, 0.0,\n                             0.15,  0.0,\n                             0.15,  0.0, 0.0,\n                             0.15, -0.5,\n                            -0.35, -0.5,\n                            -0.35,  0.5);\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    // distance computations\n    float d = sdA(p);\n    \n    // coloring\n    //float t = 0.525;\n    float t = iTime * 2.5;\n    float gap = 3./10.;\n    \n    vec3 col = vec3(1.,1.,1.);\n    col *= 1.0 + 0.15*cos(128.0*abs(d)-t);\n    col = generateBorder(col, abs(d));\n    /*for (int i=0; i<10; i++) {\n    \tcol = generateBorder(col, abs(d+0.5-mod(t+gap*float(i),3.)));\n    }*/\n    col = 1. - col;\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 72, 72, 99], [101, 175, 225, 225, 358], [360, 360, 441, 441, 876], [878, 952, 1026, 1026, 1405], [1474, 1528, 1587, 1587, 2352], [2754, 2754, 2805, 2805, 2890], [2892, 2892, 2949, 2985, 3487]], "test": "error"}
{"id": "3dfyRX", "name": "chrysalis", "author": "haptix", "description": "chrysalis", "tags": ["chrysalis"], "likes": 0, "viewed": 145, "published": "Public API", "date": "1585198795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 box(vec3 p, vec3 b, float matId)\n{\n    vec3 q = abs(p) - b;\n    return vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.), matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime + 65.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        p.xy *= rot(.061*t);\n        \n        p = abs(p) - vec3(.05*cos(t*.21) + .31,\n                          .05*sin(t*.27) + .35,\n                          .05*sin(t*.37) + .37);\n        \n        p.yz *= rot(.043*t);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    p = kif(p);\n    \n    vec2 m1 = box(p, vec3(.07, .8, 1.), 1.);\n    p.x -= .25;\n    vec2 m2 = box(p, vec3(.06, .75, .85), 2.);\n    p.x += .5;\n    vec2 m3 = box(p, vec3(.06, .75, .85), 3.);\n    vec2 m = add(m1, m2);\n    m = add(m, m3);\n    glo += .1 / (.1 + m1.x*m1.x*m1.x*2500.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 15.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 384; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .00001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.6*cos(-.1*iTime),\n                   .91*sin(-.1*iTime),\n                   -7.);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(1.5, 1.5, -30.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime + 44.)),\n                       sin(.151*(iTime + 55.)),\n                       sin(.227*(iTime + 79.))) + 1.2;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 200.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .1 * colRot;\n        if(t.y == 2.)\n        \tcolRot = vec3(.2);\n        else if(t.y == 3.)\n            colRot = vec3(.5);\n        \n        col *= .12 * ao;\n        col += .35 * diff * colRot.yzx;\n        col += 1. * spec * vec3(1., 1., 1.);\n        col += glo*.008*colRot;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.008*colRot.zyx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 61, 61, 121], [123, 123, 162, 162, 268], [270, 270, 288, 288, 609], [611, 611, 639, 639, 675], [677, 677, 695, 695, 996], [998, 998, 1025, 1025, 1254], [1256, 1256, 1313, 1313, 2937]], "test": "timeout"}
{"id": "3dfyz7", "name": "Warm", "author": "jenya", "description": "light", "tags": ["warm"], "likes": 3, "viewed": 50, "published": "Public", "date": "1584356320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n    \n    float t = (iTime+1.3)*1.5;\n    float c = .0, d = .0;\n    \n    for(float f = 0.; f < 1.2; f += .7)\n    {\n        \n        \n        if (p.x > .0)\n        \t\n        \t\n        d = distance(\n              vec3( tan(p.x*t), tan(p.y*t), f ),\n              vec3( p.x*20., .0, -5. )\n            );\n        \n    \tc += sin(t + .5/p.x + cos(p.y)*25. );\n    }\n    \n\tfragColor = vec4(.5-c, .6-c*.25,1.-c*.5, 2.);//vec4(1.-c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 540]], "test": "ok"}
{"id": "3dfyzf", "name": "Space warping", "author": "Roninkoi", "description": "Some experimentation with warping", "tags": ["warping", "sphere"], "likes": 2, "viewed": 87, "published": "Public", "date": "1585442666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sp(vec4 pos)\n{\n    float r = 1.0;\n    \n    for (int i = 0 ; i < 3; ++i)\n        r *= ((clamp(length(pos)*0.25 / float(i) - 0.25 / float(i), 0., 1.) - .03)) * 20.;\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y / iResolution.x;\n    \n    vec4 pos = vec4(uv.x, uv.y, 0., 1.);\n    pos.z = length(pos.xy) * sin(iTime);\n    \n    pos.xy /= sp(pos);\n    pos.z = length(pos.xy);\n    \n    vec3 col = vec3(0.5);\n    vec3 cb = mod(pos.yxy*sin(iTime) + iTime, 5.0) * 0.3;\n    cb.x = 0.;\n    \n    col = cb / exp(pos.z * 0.07);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 189], [191, 191, 248, 248, 670]], "test": "ok"}
{"id": "3dlczH", "name": "param_v12", "author": "darkczar", "description": "epicycles", "tags": ["learning"], "likes": 1, "viewed": 63, "published": "Public", "date": "1584156946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<1000;i++)\n    {\n        di = float(i)*.03;\n        curve_p.x = .3*sin(.4*iTime)+.05*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*sin(11.0*di+.8*iTime);\n        curve_p.y = .3*cos(.4*iTime)+.05*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*cos(11.0*di+.8*iTime);\n        d = min(d, length(p-curve_p)+.4*rand(vec2(di,di)));\n  \n    }\n    \n    float r = .25*d*d*sin(.2*iTime + .01*p.x*p.y*sin(6.28*p.x*p.y));\n    float g = .0125*sin(.001*d*d+.1*length(p));\n    float b = .25*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,2.0)));\n    if (d>.05)\n    {\n        b=pow(b,2.25);\n    }\n    vec3 col = vec3(r,g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 342, 392, 1512]], "test": "timeout"}
{"id": "3dlyD8", "name": "Mercator Projection", "author": "mla", "description": "Rather than use the Mercator projection to conformally map a sphere to a plane, we can do it backwards to map a plane pattern conformally onto a sphere. Display cycles through 4 patterns. Mouse rotates.", "tags": ["spherical", "mercator"], "likes": 21, "viewed": 311, "published": "Public API", "date": "1584708577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Spherical texturing with Mercator projection.\n//\n// Matthew Arcus, 2020.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 tiling(vec2 p) {\n  p *= 8.0;\n  p = mod(p,2.0)-1.0;\n  if (p.x*p.y < 0.0) p = p.yx;\n  p = 1.0-2.0*abs(abs(p)-0.5);\n  float t = 0.5*iTime;\n  vec2 n = vec2(sin(t),cos(t));\n  vec2 m = vec2(-n.y,n.x);\n  float d = dot(p,n), e = dot(p,m);\n  float k = min(abs(d),abs(e));\n  if (d < 0.0) k = min(k,abs(p.x-1.0));\n  if (e < 0.0) k = min(k,abs(p.y-1.0));\n  return smoothstep(0.025,0.05,k)*vec3(0.5,0.5,0);\n}\n\nvec3 mirror(vec2 uv) {\n  uv.y -= 0.1*iTime;\n  uv = mod(uv,2.0);\n  uv = min(uv,2.0-uv);\n  return texture(iChannel1,uv).rgb;\n}\n\nvec3 slider(vec2 uv) {\n  uv *= 4.0;\n  vec2 iv = floor(uv);\n  if (true) {\n    // Slide around a little\n    float t = 0.3*iTime;\n    if (mod(t,2.0) < 1.0) {\n      uv.x += floor(mod(iv.y,2.0))*fract(t);\n    } else {\n      uv.y += floor(mod(iv.x,2.0))*fract(t);\n    }\n  }\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = texture(iChannel0,uv).rgb;\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint IHash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 indexed(vec2 uv) {\n  uv *= 8.0;\n  uv.y += iTime;\n  ivec2 iv = ivec2(floor(uv));\n  float rnd = float(IHash((uint(iv.x)<<16) ^ uint(iv.y)))/pow(2.0,32.0);\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = hsv2rgb(vec3(rnd,1,1));\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nconst int ncolors = 4;\nvec3 getColor(int i, vec2 uv) {\n  //return indexed(uv);\n  i = i%ncolors;\n  if (i == 0) return slider(uv);\n  if (i == 1) return tiling(uv);\n  if (i == 2) return indexed(uv);\n  if (i == 3) return mirror(uv);\n  return vec3(1,0,0);\n}\n\nvec3 getColor(vec3 p) {\n  float x = atan(p.x,p.z);       // Longitude\n  float y = asin(p.y/length(p)); // Latitude\n  y = log(tan(0.25*PI+0.5*y));   // Mercator\n  vec2 uv = vec2(x,y);\n  uv /= PI;\n  float period = 10.0;\n  float t = mod(iTime,float(ncolors)*period);\n  int i = int(t/period);\n  t = mod(t,period);\n  return mix(getColor(i,uv),getColor(i+1,uv),smoothstep(period-1.0,period,t));\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec3(0);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getColor(hit.n);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),5.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return color;\n  }\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  light = transform(light);\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 p = vec3(0,0,-6);\n      vec3 r = vec3(uv,6);\n      p = transform(p);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      col += solve(Ray(p,r));\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 302, 302, 354], [356, 356, 377, 377, 756], [758, 758, 780, 780, 882], [884, 884, 906, 906, 1333], [1335, 1335, 1357, 1357, 1533], [1535, 1599, 1619, 1619, 1733], [1735, 1735, 1758, 1758, 2071], [2096, 2096, 2127, 2151, 2325], [2327, 2327, 2350, 2350, 2717], [2961, 2961, 3015, 3015, 3500], [3502, 3502, 3543, 3543, 3651], [3696, 3696, 3715, 3715, 4142], [4144, 4144, 4171, 4171, 4498], [4500, 4500, 4557, 4557, 5113]], "test": "error"}
{"id": "3dlyR7", "name": "stupid circles 1", "author": "sashasansay", "description": "circles", "tags": ["circles"], "likes": 2, "viewed": 53, "published": "Public", "date": "1584435450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 _st, in float _radius) {\n    vec2 l = _st-vec2(0.5);\n    return smoothstep(_radius+9./iResolution.y,\n                         _radius-9./iResolution.y,\n                         dot(l,l)*4.0);\n}\n\nfloat circlePattern(vec2 st, float r) {\n    return  circle(st+vec2(0.,-.5), r)+\n            circle(st+vec2(0.,.5), r)+\n            circle(st+vec2(-.5,0.), r)+\n            circle(st+vec2(.5,0.), r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    uv *= 4.0;\n    uv = fract(uv);\n\n    fragColor = vec4(0.9529411765,0.8117647059,0.7803921569,1.0) * circlePattern(uv, 1.0 * sin(iTime) * 0.5 + 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 214], [216, 216, 255, 255, 415], [417, 417, 474, 474, 668]], "test": "ok"}
{"id": "3dscRS", "name": "Starfield165", "author": "brechrt", "description": "starfield", "tags": ["starfield"], "likes": 4, "viewed": 249, "published": "Public API", "date": "1585056933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\nmat2 rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat star(vec2 uv, float flar){\n\tfloat d = length(uv);\n    float m = .05/d;\n    m *= m;\n    \n    float ray = max(0., 1.-abs(uv.x*uv.y*5000.));\n    m += ray*flar;\n    \n    uv *= rot(atan(1.));\n    ray = max(0., 1.-abs(uv.x*uv.y*5000.));\n    m += ray*flar;\n    \n    m *= smoothstep(1., .2, d);\n\n    return m;\n}\nvec3 starLayer(vec2 uv){\n\tvec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    vec3 col = vec3(0);\n    \n    for(float x = -1.; x <= 1.; x++){\n        for(float y = -1.; y <= 1.; y++){\n            vec2 off = vec2(x, y);\n\t    \tvec2 roff = vec2(random(id+off), random(id+off+vec2(243.23, 882.23)));\n            float size = fract(random(id+off)*68321.7829);\n    \t\tfloat star = star(gv-off-roff, smoothstep(.7, 1., size)*.5);\n            \n            vec3 color = sin(vec3(.2, .3, .8)*fract(size*3219.329)*214767.)*.5+.5;\n            color *= vec3(1., .5, 1.+size);\n            col += star*size*size*color;\n    \t\t\n        }\n    }\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n   \tfloat t = iTime*.1;\n    vec3 col = vec3(0);\n    float maxLayer = 7.;\n    \n    uv *= rot(t);\n    for(float i = 0.; i < 1.; i += 1./maxLayer){\n        float depth = fract(i+t);\n        \n        float scale= mix(10., 5., depth);\n        float fade = depth*smoothstep(1., .8, depth);\n    \tcol += starLayer(uv*scale+i*274.23)*fade;\t\n    }\n    \n   \n    \n    \n    \n    //if(gv.x > .98 || gv.y > .98) col = vec3(1., 0., 0.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dscRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 152], [153, 153, 175, 175, 214], [216, 216, 248, 248, 668], [669, 669, 694, 694, 750], [751, 751, 769, 769, 847], [849, 849, 881, 881, 1158], [1159, 1159, 1183, 1183, 1804], [1805, 1805, 1862, 1862, 2377]], "test": "timeout"}
{"id": "3dsczf", "name": "muhvoronoi", "author": "Mogster", "description": "describe your shader", "tags": ["voronoi"], "likes": 5, "viewed": 202, "published": "Public API", "date": "1585263511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 5.0;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n            \n            point += (point - iMouse.xy) * 100.0;\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n           \n        }\n    }\n\n    // Draw the min distance (distance field)\n    //color += m_dist;\n\n    // Draw cell center\n    color += 1.0;\n\n\n    // Draw grid\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n\n        color = color * mix(0.0, 1.0, cos(m_dist * 100.0)) - mix(1.0, 0.5, m_dist * 1.) * step(0.1, cos(50.0 *m_dist));\n        color.r *= mix(0.0, 1.0, m_dist * 1.5);\n    if (m_dist >= 1.0) color = vec3(0.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 176, 176, 1619]], "test": "timeout"}
{"id": "3dsyRf", "name": "tunel--plasma-v4", "author": "jorge2017a1", "description": "tunel--plasma-v3", "tags": ["tunelplasmav3"], "likes": 1, "viewed": 50, "published": "Public", "date": "1585255611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n//------------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n    float d;\n    float dif1;\n    float dif2;\n    vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n   \n    \n    vec3 ppp;\n    ppp =p;\n    float c = 20.;\n    float c2 = 8.;\n    ppp.x+=sin(p.z*0.2);\n\n    ppp.z=mod(ppp.z+c2*.5,c2)-c2*.5;\n \n    vec3 p1 =p;\n    p1.z = mod( p1.z+c2*.5,c2)-c2*.5;\n\n    float sdb2 = sdBox(p1+vec3(0,-3.5,0),vec3(4.5,4.5,10));\n    float sdb3 = sdBox(ppp+vec3(0,-3.5,0),vec3(2.0,4.0,12.5));\n    \n    \n     dif1 = differenceSDF(sdb2,sdb3);\n\n    \n    res=opU(res, vec2(dif1,28 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    dist=d.x;\n    \n    vec3 n;\n    n = dist -vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\nfloat wave(vec2 p, float angle) {\n  vec2 direction = vec2(cos(angle), sin(angle));\n  return cos(dot(p, direction));\n}\n\nfloat wrap(float x) {\n  return abs(mod(x, 2.)-1.);\n}\n//--------------------------------------------------------\n\n\nvec3 course(float a)\n{\n\treturn vec3(\n\t\tcos(a),\n\t\tsin(2.0*a),\n\t\t0.15*sin(a)\n\t);\n}\n\n\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n\n    \n    if(i== 28 )\n    {\n     \n    float delta = 0.01;\n    float brightness = 0.;\n    vec2 p;\n        \n    \n    //p =mObj.uv;\n    p = abs(mObj.p.xy);\n    \n        \n\t//p = (fragCoord / (m.x+delta / 10.) * (m.y+delta / 10.)) * .5;\n    p = p / (0.125+delta / 10.) ;\n\n        \n  \tfor (float i = 1.; i <= 11.; i++) \n    {\n\t    brightness += wave(p, (1.0 / 5.0 ) / i);\n  \t}\n\n  \tbrightness = wrap(brightness);\n  \tvec3 col = vec3(brightness);\n  \treturn col;\n\t}      \n    \n    \n    \n    \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  \n    float fas=iTime*2.0;\n   \n    vec3 ro = vec3(0.0+cos(iTime*0.125)/2.0 ,0.5 ,fas);\n    \n    vec3 rd =normalize(vec3(uv,1.0) );\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    mObj.p=p;\n        \n   \n    float dif;\n\n    dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 561, 594, 594, 659], [660, 678, 714, 714, 783], [784, 799, 830, 830, 980], [981, 1001, 1037, 1037, 1124], [1125, 1141, 1173, 1201, 1262], [1264, 1264, 1300, 1300, 1403], [1406, 1406, 1451, 1451, 1542], [1596, 1596, 1642, 1642, 1674], [1676, 1676, 1719, 1719, 1751], [1753, 1753, 1801, 1801, 1834], [1837, 1837, 1866, 1866, 1992], [1994, 1994, 2030, 2030, 2147], [2149, 2149, 2185, 2185, 2303], [2306, 2306, 2342, 2342, 2465], [2518, 2530, 2552, 2552, 2860], [2861, 2887, 2912, 2912, 3102], [3103, 3148, 3165, 3165, 3238], [3241, 3274, 3300, 3300, 3497], [3544, 3544, 3596, 3596, 3751], [3816, 3925, 3962, 3962, 3997], [3999, 3999, 4018, 4018, 4093], [4142, 4142, 4165, 4165, 4191], [4193, 4193, 4216, 4216, 4354], [4357, 4357, 4379, 4379, 4449], [4514, 4514, 4540, 4540, 4597], [4599, 4599, 4619, 4619, 4677], [4680, 4680, 4701, 4701, 4951], [4994, 5039, 5064, 5064, 5679], [5684, 5684, 5717, 5717, 6192], [6196, 6196, 6220, 6220, 6501], [6506, 6506, 6544, 6544, 6902], [7001, 7045, 7062, 7062, 7133], [7158, 7250, 7275, 7275, 7538], [7540, 7595, 7628, 7628, 7712], [7714, 7714, 7735, 7735, 7766], [7828, 7828, 7850, 7850, 7908], [7973, 7973, 8001, 8001, 16154], [16157, 16157, 16214, 16214, 17311]], "test": "error"}
{"id": "3dsyRs", "name": "leon-v1", "author": "jorge2017a1", "description": "leon-v1", "tags": ["leonv1"], "likes": 3, "viewed": 38, "published": "Public", "date": "1585364983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n/*\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n*/\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//------------------------------------\n\n\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+3.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    float pisocer= mapCerrov2(p);\n        \n    //res=opU(res, vec2(planeDist1,28 ));  //piso inferior\n   \tres=opU(res, vec2(pisocer,28 ));  //piso inferior\n    \n    \n    \n    \n    //L\n    float  sdb1=sdBox(p -vec3(0.0,0.0,0.0) , vec3(2.0,0.25,1.0) );\n    float  sdb2=sdBox(p -vec3(-1.4,2.2,0.0) , vec3(0.5,2.0,1.0) );\n    \n    //E\n    float  sdb3=sdBox(p -vec3(4.0,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    float  sdb4=sdBox(p -vec3(5.0,0.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb5=sdBox(p -vec3(5.0,2.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb6=sdBox(p -vec3(5.0,4.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    \n    //O\n    float  sdb7=sdBox(p -vec3(10.0,0.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb8=sdBox(p -vec3(10.0,4.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb9=sdBox(p -vec3(8.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    float  sdb10=sdBox(p -vec3(11.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    \n    \n    //N\n    float  sdb11=sdBox(p -vec3(13.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    float  sdb12=sdBox(p -vec3(16.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    \n    vec2 tmp2;\n    tmp2= pp.xy+vec2(-14.0,0.0);\n    R(tmp2, 45.0*3.141516/180.);\n    pp.xy=tmp2;\n    \n    \n    float  sdb13=sdBox(pp -vec3(2.0,0.5,0.0) , vec3(0.5,2.1,0.5) );   //!\n    \n    \n    res=opU(res, vec2(sdb1,8 )); \n    res=opU(res, vec2(sdb2,8 )); \n    \n    res=opU(res, vec2(sdb3,7 )); \n    res=opU(res, vec2(sdb4,7 ));\n    res=opU(res, vec2(sdb5,7 )); \n    res=opU(res, vec2(sdb6,7 ));\n    \n    \n    res=opU(res, vec2(sdb7,1 )); \n    res=opU(res, vec2(sdb8,1 ));\n    res=opU(res, vec2(sdb9,1 ));\n    res=opU(res, vec2(sdb10,1 ));\n    \n    //N\n    res=opU(res, vec2(sdb11,3 ));\n    res=opU(res, vec2(sdb12,3 ));\n    res=opU(res, vec2(sdb13,3 ));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    \n    vec3 ro = vec3(5.0+5.0*sin(iTime) ,5.0,-20.0+5.0*cos(iTime));\n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[581, 598, 631, 631, 696], [700, 700, 735, 735, 759], [892, 907, 938, 938, 1088], [1089, 1109, 1145, 1145, 1232], [1233, 1249, 1281, 1309, 1370], [1372, 1372, 1408, 1408, 1511], [1514, 1514, 1559, 1559, 1650], [1652, 1652, 1687, 1687, 2172], [2224, 2224, 2270, 2270, 2302], [2304, 2304, 2347, 2347, 2379], [2381, 2381, 2429, 2429, 2462], [2465, 2465, 2494, 2494, 2620], [2622, 2622, 2658, 2658, 2775], [2777, 2777, 2813, 2813, 2931], [2934, 2934, 2970, 2970, 3093], [3146, 3158, 3180, 3180, 3488], [3489, 3515, 3540, 3540, 3730], [3731, 3776, 3793, 3793, 3866], [3869, 3902, 3928, 3928, 4125], [4172, 4172, 4224, 4224, 4379], [4444, 4553, 4590, 4590, 4625], [4627, 4627, 4646, 4646, 4721], [4770, 4770, 4793, 4793, 4819], [4821, 4821, 4844, 4844, 4982], [5038, 5038, 5060, 5060, 5130], [5195, 5195, 5221, 5221, 5278], [5280, 5280, 5300, 5300, 5358], [5361, 5361, 5382, 5382, 5632], [5676, 5676, 5702, 5702, 5873], [5875, 5919, 5944, 5944, 8132], [8137, 8137, 8170, 8170, 8645], [8649, 8649, 8673, 8673, 9005], [9010, 9010, 9048, 9048, 9406], [9505, 9549, 9566, 9566, 9637], [9662, 9754, 9779, 9779, 10042], [10163, 10163, 10191, 10191, 18544], [18547, 18547, 18604, 18604, 19652]], "test": "error"}
{"id": "3dsyWB", "name": "Love Is In The Air", "author": "dr2", "description": "Balloon time (mouseable)", "tags": ["fire", "heart", "balloon"], "likes": 10, "viewed": 284, "published": "Public API", "date": "1585491371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Love Is In The Air\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 Hashv3v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nvec3 obDisp, obRnd, sunDir, qHit;\nvec2 cId;\nfloat dstFar, tCur, bGrid, balRad, obRot, flmCylRad, flmCylLen;\nint idObj;\nbool cOcc, balFlm;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid ObjState ()\n{\n  float r, s;\n  r = length (cId);\n  obRnd = Hashv3v2 (cId + 17.17);\n  obDisp.xz = bGrid * (cId + 0.5);\n  if (r > 0.) obDisp.xz += Rot2D (vec2 ((0.45 * bGrid - balRad) * (0.2 + 0.8 * obRnd.x), 0.),\n     2. * pi * (0.2 * obRnd.z * tCur + obRnd.x));\n  else obDisp.xz += 0.45 * bGrid - balRad;\n  s = sin (2. * pi * (0.05 * obRnd.y * tCur + obRnd.x));\n  obDisp.y = 12. + 6. * s;\n  obRot = 0.1 * pi * (obRnd.z - 0.5) * tCur;\n  balFlm = (s < 0.);\n  cOcc = (r == 0. || obRnd.x > 0.7);\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    q = p - vec3 (0., -0.8 * balRad, 0.);\n    d = PrCylDf (q.xzy, flmCylRad + 0.3 * q.y / flmCylLen, flmCylLen);\n    d = max (d, - q.y - 0.5 * flmCylLen);\n    DMINQ (0);\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = FlmDf (p);\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (min (s.x, s.y)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.xz = Rot2D (p.xz, obRot);\n    q = p;\n    d = max (PrSphDf (q, balRad), - PrSphDf (q, 0.98 * balRad));\n    d = max (d, - PrCylDf (q.xzy - vec3 (0., 0., - balRad), 0.3 * balRad, 0.1 * balRad));\n    DMINQ (1);\n    q = p;\n    d = PrCylDf (q.xzy - vec3 (0., 0., -1.42 * balRad), 0.05 * balRad, 0.13 * balRad);\n    d = max (d, - PrCylDf (q.xzy- vec3 (0., 0., 0.02 * balRad), 0.03 * balRad, 0.13 * balRad));\n    DMINQ (2);\n    q = p;\n    d = PrCylDf (q.xzy - vec3 (0., 0., -1.5 * balRad), 0.2 * balRad, 0.07 * balRad);\n    d = max (d, - PrCylDf (q.xzy - vec3 (0., 0., -1.48 * balRad), 0.18 * balRad, 0.07 * balRad));\n    DMINQ (3);\n    q = p;\n    q.xz = abs (q.xz) - 0.25 * balRad;\n    q.y -= -1.15 * balRad;\n    q.yz = Rot2D (q.yz, -0.35);\n    q.xy = Rot2D (q.xy, 0.35);\n    d = PrCylDf (q.xzy, 0.005 * balRad, 0.35 * balRad);\n    DMINQ (4);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (min (s.x, s.y)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 FlmCol (vec3 p, vec3 rd)\n{\n  vec3 q, qq;\n  float a, f, dr;\n  a = 0.;\n  p.y -= - flmCylLen;\n  dr = 0.05 / flmCylRad;\n  for (int j = 0; j < 20; j ++) {\n    p += dr * rd;\n    q = 15. * p / flmCylLen;\n    q.y -= 40. * tCur;\n    qq.y = Noisefv3 (q + 0.1 * vec3 (sin (tCur)));\n    qq.x = Noisefv3 (q + vec3 (qq.y));\n    qq.z = Noisefv3 (q + vec3 (qq.x));\n    q = p + 0.25 * (1. - 3. * p.y / flmCylLen) * (qq - 0.5);\n    f = 0.45 * q.y - 2.5 * length (q.xz);\n    f = clamp (sign (f) * f * f, 0., 1.) * (3. - 0.9 * q.y);\n    a += f;\n  }\n  return clamp (a * vec3 (1., 0.5, 0.3), 0., 1.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, p, c1, c2;\n  float ds, fd, att, attSum, sd;\n  c1 = vec3 (0.3, 0.2, 0.1);\n  c2 = vec3 (0.1, 0.3, 0.);\n  if (rd.y > -0.003 && rd.y < 0.01 + 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = 0.5 * (c1 + c2);\n  } else if (rd.y < 0.) {\n    p = ro - (ro.y / rd.y) * rd;\n    p.xz -= 0.2 * tCur;\n    col = mix (c1, c2, Fbm2 (0.5 * p.xz)) * (1. - 0.1 * Noisefv2 (17. * p.xz));\n    col = mix (col, 0.5 * (c1 + c2), smoothstep (-0.1, 0., rd.y));\n  } else {\n    p = ((200. - ro.y) / rd.y) * rd;\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz = p.xz * fd + 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    for (float j = 0.; j < 4.; j ++) {\n      attSum += Fbm2 (p.xz + (1. + j * ds) * fd * sunDir.xz);\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    col = mix (vec3 (0.5, 0.75, 1.), mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1),\n       0.25 + 0.75 * sd), exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n       0.3 * (vec3 (1., 0.8, 0.7) * pow (sd, 1024.) + vec3 (1., 0.4, 0.2) * pow (sd, 256.));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, colFlm, qHitFlm, u;\n  float dstObj, dstFlm, s, h;\n  bool inSun, inFlm;\n  dstFlm = FlmRay (ro, rd);\n  if (dstFlm >= dstFar) balFlm = false;\n  qHitFlm = qHit;\n  inFlm = balFlm;\n  dstObj = ObjRay (ro, rd);\n  inSun = true;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj != 1) balFlm = false;\n    if (idObj == 1) {\n      h = 0.1 + 0.8 * obRnd.z;\n      u = qHit / (0.3 * balRad);\n      col = mix (HsvToRgb (vec3 (h + 0.5, 0.8, 0.8)), HsvToRgb (vec3 (h, 0.7, 0.8)),\n         smoothstep (0., 0.02, abs (abs (u.y) - 1.7) - 0.07));\n      u.xz = Rot2D (u.xz, pi / 24.);\n      u.xz = Rot2D (u.xz, 2. * pi * (floor (6. * atan (u.x, u.z) / (2. * pi) + 0.5) / 6.));\n      col = mix (vec3 (1., 0., 0.), col, smoothstep (0., 0.01, length (Rot2D (vec2 (abs (u.x) - 0.3, u.y),\n          pi / 6.) * vec2 (2., 1.)) - 1.));\n      if (length (qHit) < 0.99 * balRad) {\n        col *= 0.2;\n        if (balFlm) col += 0.1 * vec3 (1., 0.5, 0.);\n        inSun = false;\n      } else {\n        if (length (qHit) > 0.99 * balRad) vn.xz = Rot2D (vn.xz, 0.1 * pi *\n           sin (pi * (0.5 - mod (24. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.))));\n      }\n    } else if (idObj == 2) {\n      vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (12. * (atan (qHit.x, qHit.z) /\n         (2. * pi) + 0.5), 1.))));\n      col = vec3 (0.6);\n    } else if (idObj == 3) {\n      vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (32. * (atan (qHit.x, qHit.z) /\n         (2. * pi) + 0.5), 1.))));\n      col = vec3 (0.6, 0.3, 0.);\n    } else if (idObj == 4) {\n      col = vec3 (0.3);\n    }\n    if (inSun) col = col * (0.3 + 0.3 * max (- dot (vn, normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.05 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = BgCol (ro, rd);\n    balFlm = false;\n  }\n  if (dstFlm < min (dstFar, dstObj)) {\n    if (inFlm) {\n      colFlm = FlmCol (qHitFlm, rd);\n      col = mix (col, colFlm, 0.6 * length (colFlm));\n    }\n  }\n  if (balFlm) {\n    qHit.xz = Rot2D (qHit.xz, - obRot);\n    qHit.y += 0.5 * balRad;\n    col = mix (col, vec3 (1., 0.5, 0.),\n       0.4 * pow (clamp (dot (normalize (qHit), - rd), 0., 1.), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az, h;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  dstFar = 150.;\n  bGrid = 6.;\n  balRad = 2.;\n  flmCylRad = 0.4;\n  flmCylLen = 2.;\n  h = 12. + 4. * sin (2. * pi * 0.02 * tCur);\n  az = 0.3 * pi + 2. * pi * mod (0.003 * tCur, 1.);\n  el = -0.005 * pi * (h - 12.);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (vec2 (-0.49 * bGrid), h).xzy;\n  rd = vuMat * normalize (vec3 (uv, 4.5));\n  sunDir = normalize (vec3 (1., 0.2, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec3 (0., cHashVA2.xy)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyWB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[736, 736, 754, 754, 1233], [1235, 1235, 1257, 1257, 1523], [1525, 1525, 1558, 1558, 2147], [2149, 2149, 2171, 2171, 3109], [3111, 3111, 3144, 3144, 3733], [3735, 3735, 3756, 3756, 4011], [4013, 4013, 4044, 4044, 4598], [4600, 4600, 4631, 4631, 5965], [5967, 5967, 6002, 6002, 8294], [8296, 8296, 8352, 8352, 9155], [9157, 9157, 9190, 9190, 9217], [9219, 9219, 9261, 9261, 9312], [9314, 9314, 9371, 9371, 9454], [9456, 9456, 9492, 9492, 9698], [9700, 9700, 9730, 9730, 9843], [9845, 9845, 9869, 9869, 9986], [10020, 10020, 10044, 10044, 10097], [10099, 10099, 10123, 10123, 10235], [10237, 10237, 10261, 10261, 10373], [10375, 10375, 10399, 10399, 10518], [10520, 10520, 10545, 10545, 10691], [10693, 10693, 10718, 10718, 10904], [10906, 10906, 10931, 10931, 11156], [11158, 11158, 11180, 11180, 11334], [11336, 11336, 11357, 11357, 11496]], "test": "error"}
{"id": "3dsyzS", "name": "COVID", "author": "GinesMendoza", "description": "leave a comment if you want to help to improve this shader, I will appreciate it. ", "tags": ["fft", "audio", "virus", "cineshader", "coronavirus"], "likes": 16, "viewed": 22295, "published": "Public", "date": "1585040506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//Music: You're Not Leaving by La Josephine\n//https://soundcloud.com/lajosephine/youre-not-leaving\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat snoise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res * 2.0 - 1.0;\n}\n\n    \n\nmat2 Rot(float a){\n\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\nvec3 Transform ( vec3 p ,float time){\n    p.z -= time * .5;\n\n    \n    p += sin(p.x+p.z+time)*.03\n        +sin(p.y+time)*.05\n        +cos(p.x+p.z+time)*.03\n        -cos(p.x+time)*.03\n        +cos(p.y+time)*.05;\n        \n    //p.xy *= Rot(time*.15);\n    return p;\n    \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat line( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n   \n    float h = clamp( 0.5 + 0.5*(a-b)/k, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*k;\n}\nvec2 opUMin( vec2 a, vec2 b, float k ) { \n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 ); \n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), (a.x<b.x) ? a.y : b.y ); \n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n        float a=1./(1.+n.y);\n        float b=-n.x*n.z*a;\n        b1=vec3(1.-n.x*n.x*a,-n.x,b);\n        b2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nvec3 Background ( vec3 rd){\n    vec3 col = vec3(0);\n    float y = abs(rd.z)*.5+.5;\n    col += y*vec3(1,0.58,0.03);\n    return col;\n}\nvec3 opRep( in vec3 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\nvec2 e = vec2(.01, 0);\n\n\n\nvec2 Virus( vec3 p, float atime){\n    \n   \n    \n    p = p - vec3(sin(atime+2.0)*.1,sin(atime)*.1+sin(atime)*.02,0);\n    float t=mod(atime,1.5)/1.5;\n    p*=1.-0.05*clamp(sin(6.*t)*exp(-t*4.),-2.,2.);\n\n    p.xy *= Rot(0.04*atime);\n    p.xz *= Rot(0.06*atime);\n    p += sin(p.x+p.z+atime)*.01+sin(p.y+atime)*.042*p.y;\n    \n    \n    \n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),20.);\n    p += sin(p.x+p.z+atime)*.01+sin(p.y+atime)*.042*fibo.w*1.;\n    \n    float cvwidth = .54 +(- (sin(90.*p.x)*cos(40.*p.z)*sin(90.*p.y))*.06\n    - (cos(100.*p.x)*sin(100.*p.z)*sin(40.*p.y))*.06\n     - (sin(100.*p.y)*sin(100.*p.z)*sin(40.*p.x))*.06)*0.09;\n    \n    float sphere = sdSphere(p,cvwidth);\n     \n    vec2 d0Vector= vec2(sphere,2.0);\n \n   \n    \n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n\n\n   \n   \n   \n    q=q-vec3(0,-cvwidth+.08,0);\n    \n    float d1= sdRoundCone( q, 0.02,0.03 , 0.1);\n    \n    q=q-vec3(-.03,.12,0.0);\n    d1 = smin(sdSphere(q, 0.002)-0.003*snoise(q*83.),d1,.1);\n    \n  \n               \n    \n    vec2 d1Vector=vec2(d1,3.0);\n    \n    d1 = min(sdSphere(q-vec3(-.1,-.11,0.05), 0.02),\n             sdSphere(q-vec3(.1,-.11,.0), 0.02));\n    \n    d0Vector=opUMin( d0Vector,vec2(d1,4.0),0.02);\n    \n    d0Vector=opUMin( d0Vector,d1Vector,0.02);\n    \n    \n    return d0Vector;\n   \n}\n\nfloat cell(vec3 p, float atime){\n\n    vec3 c = mod(abs(p),1.5) - .75;\n    c.y += sin(c.z) * .15;\n    c.xy *= Rot( c.z*.95) ;\n\n    \n    float r = 0.1;\n   \n   \n    return sdSphere(c,r)*.8;\n}\n\nvec2 Bloodstream (vec3 p, float atime){\n    \n    p = p - vec3(snoise(p)*sin(atime)*.2,sin(atime)*snoise(p)*0.2,0.);\n    p.z += atime * .9;\n    p.xy *= Rot( p.z*.5) ;\n    \n    \n    if (abs(p.x) > 3. || abs(p.y) > 3.) {\n       return vec2(100.,-1.0);\n    }\n    \n\n    \n    return vec2(cell( p,  atime),5.0);\n}\n\n\nvec2 map(in vec3 p,float atime ){\n   \n\n    vec2 cv=Virus(p,atime);\n    vec2 b = Bloodstream (p,  atime);\n    \n    p = Transform(p,atime);\n    \n    float g1 = sdGyroid(p,1.3,.06,1.4);\n\n\n    float g2 = sdGyroid(p,10.76,.03,.3);\n    float g3 = sdGyroid(p,20.76,.03,.3);\n    float g4 = sdGyroid(p,35.76,.03,.3);\n    float g5 = sdGyroid(p,60.76,.03,.3);\n    \n    \n    g1 += g2 * .3 * sin(atime*1.53) * cos(atime*2.34) * p.y ;\n    g1 -= g3 * .2;\n    g1 += g4 * .1;\n    g1 += g5 * .2;\n    \n    \n    float tunel = smax(PI*.9 - length(p.xy), .75-g1, 1.) - abs(1.-g1)*.175;\n    \n    tunel += g2 * .2 * sin(atime*1.53) * cos(atime*2.34) * p.y ;\n    tunel -= g3 * .2;\n    tunel += g4 * .1;\n    tunel += g5 * .2;\n     \n    \n    g1 = smin(tunel, g1,.9); \n    \n    \n    vec2 vg1 = vec2(g1,1.);\n    \n    b = opUMin( b,vg1,.31);\n    return opU( cv, b);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec2 RayMarching(vec3 ro, vec3 rd,float time){\n\n\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 2.;\n    float tmax = 100.0;  \n    \n    float t = tmin;\n    for( int i=0; i<512 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t, time );\n        if( abs(h.x)<(.001*t))\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n \nvec3 calcNormal(in vec3 pos,float time,float quality){\n    vec3 n = vec3(0.0);\n   for( int i=min(0,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+quality*e,time).x;\n    }    \n    return normalize(n);\n}\n\n\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{ \n    \n    \n    vec3 col = vec3(0.);\n        \n    vec2 res = RayMarching(ro,rd,time);\n    if(res.y>0.5){\n        \n        float fft  = texelFetch( iChannel0, ivec2(3.,0.75), 0 ).x;\n        fft = smoothstep( 0.8, 1., fft )*2.;\n\n        float fft1  = texelFetch( iChannel0, ivec2(5.,0.75), 0 ).x; \n        fft1 = smoothstep( 0.9, 1., fft1 )*1.5;\n\n        float fft2  = texelFetch( iChannel0, ivec2(6.,0.75), 0 ).x; \n        fft2 = smoothstep( 0.9, 1., fft2 );    \n\n        float fft3  = texelFetch( iChannel0, ivec2(7.,0.75), 0 ).x; \n        fft3 = smoothstep( 0.9, 1., fft3 )*2.2;\n\n        float flash =  texture( iChannel0, vec2(512, 0.25)).x;\n        flash = smoothstep(.45, .8, flash )*20.;\n        flash = clamp(flash,0.,1.);\n        \n        float d = res.x;\n        vec3 pos = ro + rd*d;\n        \n        \n        float quality = res.y < 1.5 ?  0.016 : 0.0025;\n        \n        vec3 nor = normalize(e.xyy*map(pos+e.xyy,time).x\n                     +e.yyx*map(pos+e.yyx,time).x\n                     +e.yxy*map(pos+e.yxy,time).x\n                     +e.xxx*map(pos+e.xxx,time).x); \n        \n         vec3 ref = reflect(rd,nor);\n        \n        vec3 light_pos = normalize(  vec3( 0., .5, 0.2 ));\n        \n        vec3 specular = vec3( max( .30, dot( light_pos, ref ) ) );\n        specular = pow( specular, vec3( 100.0 ) );\n        \n       col += vec3(1,.4,.1)* 20. * specular; \n         \n        vec3 lin = vec3(0.0);\n        \n        vec3  sun_lig = light_pos;\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0,1. );\n        \n        pos = Transform(pos,time);\n        if(res.y > 4.5) \n        { \n        \n            col += sun_dif *vec3(1.5,0.,.0);\n            \n        }\n        else if(res.y > 3.5)\n        {\n            col += vec3(1.00,0.24,0.0)*sun_dif;\n        }\n        else if(res.y > 2.5)\n        {\n            col += vec3(.79,0.0,0.0)*sun_dif;\n        }\n        else if(res.y > 1.5) \n        {\n            col += sun_dif;\n        }\n        else if(res.y > 0.5) \n        {\n            col += sun_dif *vec3(1.,0.,.0);\n            \n            float g2 = sdGyroid(pos,10.76,.03,.3);\n            col *= smoothstep(-.1,.1,g2);\n            \n            float beat = abs((g2 * .2 * sin(time*1.53) * cos(time*2.34) * pos.y));\n            col += beat*vec3(1.,0.031,.02);\n            \n            float crackWidth = -.019 + smoothstep(0.,-.1,nor.y)*.04;\n            float cracks = smoothstep(crackWidth,-.043,g2);\n            cracks *= .5 * smoothstep(.2,.5,nor.y) *.5 +5.5;\n            col += cracks*vec3(0.7,0.0,.0)*beat *15.;\n            \n            \n            float speed = 1.5;\n            float g5 = sdGyroid(pos+vec3(cos(time*speed),sin(time*speed),time), 1.75, .705, 0.);\n            g5 *= sdGyroid(pos+vec3(sin(time*speed),cos(time*speed),time), 1., 1.9, .1);\n            col += g5*vec3(.4, .0, .0);\n            \n     \n        }\n        \n        \n        \n        \n         \n       \n        \n       \n        //col *= vec3(fft);\n        \n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcOcclusion( pos, sun_lig, time );\n        lin += sun_dif*vec3(1,.4,.1)*sun_sha;\n        \n        \n        \n        float ks = .5;\n        float sun_spe = ks*\n            pow(clamp(dot(nor,sun_hal),0.0,1.0),9.0)\n            *sun_dif\n            *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        lin += sky_dif*vec3(1.0,0.5,.5);\n        \n        col *= lin;\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n\n\n\n        vec3 fog = (abs(rd.z)*.5+.5)\n            *(\n                + (vec3(1.0,0.2,0.0))\n                + (vec3(1.0) * flash * 2.)\n                + (vec3(2.0,0.5,0.0) * fft1 * 1.3)\n            \t+ (vec3(1.0,0.0,0.0) * fft2 * 1.3)\n            \t+ (vec3(1.0,0.0,0.1) * fft3 * 1.3)\n             )\n            ;\n       \n        \n    \n\t\t\n        fog = (fog*.5+.5);\n        \n        col = mix(col, fog,smoothstep(0.,10.,d));\n        col *= mix(Background(rd), fog,smoothstep(0.,10.,d));\n        \n    }\n    \n        \n    return vec4(col,res.x);\n}\n\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    \n    vec3 ro = vec3(0, 0, 3.);\n    \n    ro.xy *= Rot(sin(t*.1)*PI);\n    ro.xz *= Rot(sin(t*.1)*PI);\n    ro.yz *= Rot(sin(t*.1)*PI);\n    \n    \n    vec3 ta = vec3(0.0,0.,0.);\n    vec3 rd = GetRayDir(uv, ro, ta, .6);\n    \n    vec4 res = render( ro, rd, t );\n        \n    vec3 col = res.xyz ;\n    col = clamp(col, 0.0,1.0);\n    \n    \n    vec2 q = fragCoord/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), .5 );\n    \n    \n    col = pow(col,vec3(0.4545));\n    \n    float depth = min(10.0, res.w);\n    fragColor = vec4(col,1.0 - (depth - 0.5) / 2.0);\n    \n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [{"id": "MtXXzM", "previewfilepath": "https://soundcloud.com/lajosephine/youre-not-leaving", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lajosephine/youre-not-leaving", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[279, 279, 302, 302, 341], [343, 343, 370, 382, 787], [795, 795, 813, 813, 887], [888, 888, 925, 925, 1156], [1158, 1158, 1187, 1187, 1271], [1273, 1273, 1339, 1339, 1421], [1423, 1423, 1458, 1458, 1484], [1487, 1487, 1545, 1545, 1809], [1811, 1811, 1851, 1851, 1910], [1914, 1914, 1953, 1953, 2036], [2038, 2038, 2077, 2077, 2171], [2172, 2172, 2212, 2212, 2347], [2349, 2349, 2379, 2379, 2415], [2486, 2486, 2533, 2533, 2776], [2778, 2778, 2807, 2807, 3736], [3738, 3738, 3783, 3783, 3823], [3826, 3826, 3853, 3853, 3958], [3959, 3959, 3996, 3996, 4031], [4058, 4058, 4091, 4091, 5411], [5413, 5413, 5445, 5445, 5601], [5603, 5603, 5642, 5642, 5909], [5912, 5912, 5945, 5945, 6749], [6751, 6751, 6812, 6812, 7105], [7107, 7107, 7153, 7153, 7496], [7499, 7499, 7553, 7553, 7770], [7774, 7774, 7825, 7825, 11893], [11897, 11897, 11947, 11947, 12142], [12144, 12144, 12199, 12199, 12906]], "test": "error"}
{"id": "3dXcDH", "name": "John's Hex", "author": "juicebar", "description": "Inspired by the work of @thejohnharman on Instagram\n", "tags": ["hexagon"], "likes": 2, "viewed": 74, "published": "Public", "date": "1584636585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Inspired by the work of John Harman: https://www.instagram.com/p/B9370OVHaju/ \n\nfloat hex(vec2 st) \n{\n\tst = abs(st);\n    \n    float h = dot(st, normalize(vec2(1.0,1.73)));\n    h = max(h, st.x);\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy - 0.5;\n    float factor = iResolution.y / iResolution.x;\n\n    st.y *= factor;\n\n    float col = hex(st) * 25.0;\n    float distScale = 1.0 + (length(hex(st)));\n\n    col *= distScale * 2.0;\n    col = 1.0 - step(fract(col - iTime),0.5 * distScale );\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 105, 105, 218], [220, 220, 277, 277, 602]], "test": "ok"}
{"id": "3dXcDM", "name": "MetaballsPattern", "author": "Reva", "description": "Ex06", "tags": ["2d"], "likes": 6, "viewed": 66, "published": "Public", "date": "1584866942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n        return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy*8./iResolution.y;\n    vec3 color = vec3(.0);\n\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n    for (int j= -1; j <= 1; j++ ) {\n        for (int i= -1; i <= 1; i++ ) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(i),float(j));\n\n            // Random position from current + neighbor place in the grid\n            vec2 offset = random2(i_st + neighbor);\n\n            // Animate the offset\n            offset = 0.5 + 0.5*sin(0.25*iTime + 6.2831*offset);\n\n            // Position of the cell\n            vec2 pos = neighbor + offset - f_st;\n\n            // Cell distance\n            float dist = length(pos);\n\n            // Metaball it!\n            m_dist = min(m_dist, m_dist*dist);\n        }\n    }\n    \n    \n    color = pal(smoothstep(0.28,0.52,fract(m_dist*3.8)),\n                vec3(0.900,0.760,0.725),vec3(0.780,0.517,0.434),\n                vec3(cos(0.02*iTime)+0.497,0.915,sin(0.02*iTime)+0.027),\n                vec3(sin(0.02*iTime)+0.410,cos(0.02*iTime)+0.108,0.265));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 186, 186, 233], [235, 235, 291, 291, 1420]], "test": "timeout"}
{"id": "3dXcRX", "name": "e^z + c fractal", "author": "timeeeee", "description": "Escape time fractal for z <= exp(z) + c\n\nChange FUZZ to false to turn off the sparkles.", "tags": ["fractal"], "likes": 3, "viewed": 47, "published": "Public", "date": "1585196573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// if FUZZ is true, sample random points in each pixel instead of bottom-left corner\n#define FUZZ true\n\n// if ZOOMDEBUG is true, show areas on the screen outside (XMIN, XMAX) or (YMIN, YMAX) as red\n#define ZOOMDEBUG false\n#define XMIN 1.5\n#define XMAX 3.0\n#define YMIN 1.4\n#define YMAX 2.2\n\n#define MAX_ITERATIONS 100\n#define BAILOUT 100000.0\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n#define RED vec4(1.0, 0.0, 0.0, 1.0)\n#define BLUE vec4(0.0, 0.0, 1.0, 1.0)\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nint iterations(vec2 c) {\n    float c_real = c.x;\n    float c_imag = c.y;\n    float z_real = c_real;\n    float z_imag = c_imag;\n    float z_real_tmp;\n    int i;\n    for (i = 0; i < MAX_ITERATIONS; i++) {\n        if (z_real * z_real + z_imag * z_imag > BAILOUT)\n            break;\n        \n        \n        float ex = exp(z_real);\n        z_real_tmp = ex * cos(z_imag) + c_real;\n        z_imag = ex * sin(z_imag) + c_imag;\n        z_real = z_real_tmp;\n    }\n    return i;\n}\n\n\nvec4 iterationsToColor(int iterations) {\n    if (iterations == MAX_ITERATIONS) return BLUE;\n    \n    // fade from white at max - 1 to black by 0\n    float r = float(iterations) / float(MAX_ITERATIONS - 1);\n    return mix(BLACK, WHITE, clamp(r, 0.0, 1.0));\n}\n\n\nvec2 coordToC(vec2 pixelCoord) {\n    float xRatio = iResolution.x / (XMAX - XMIN);  // \n    float yRatio = iResolution.y / (YMAX - YMIN);\n    float ratio = min(xRatio, yRatio);\n    float xMargin = (iResolution.x - ratio * (XMAX - XMIN)) / 2.0;\n    float yMargin = (iResolution.y - ratio * (YMAX - YMIN)) / 2.0;\n    \n    // real along x axis (0, iResolution.x) -> (XMIN, XMAX)\n\tfloat cReal = (pixelCoord.x - xMargin) / (iResolution.x - 2.0 * xMargin) * (XMAX - XMIN) + XMIN;\n    \n    // imag along y axis, (0, iResolution.y) -> (YMIN, YMAX)\n    float cImag = (pixelCoord.y - yMargin) / (iResolution.y - 2.0 * yMargin) * (YMAX - YMIN) + YMIN;\n    \n    if (FUZZ) {\n        vec2 seed = vec2(cReal, cImag) + iTime;\n        cReal += (rand(seed) - .5) / ratio;\n        cImag += (rand(seed + .5) - .5) / ratio;\n    }\n    \n    return vec2(cReal, cImag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = coordToC(fragCoord.xy);\n    \n    // for debugging window size:\n    if (ZOOMDEBUG && (c.x < XMIN || c.x > XMAX || c.y < YMIN || c.y > YMAX)) {\n        fragColor = RED;\n    } else {\n\t    fragColor = iterationsToColor(iterations(c));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[499, 499, 519, 519, 591], [594, 594, 618, 618, 1065], [1068, 1068, 1108, 1108, 1325], [1328, 1328, 1360, 1360, 2174], [2176, 2176, 2233, 2233, 2485]], "test": "timeout"}
{"id": "3dXcW2", "name": "simple terrain", "author": "zchajax", "description": "fbm terrain", "tags": ["noise", "terrain", "fbm"], "likes": 9, "viewed": 313, "published": "Public", "date": "1585647732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\n\nfloat random(in vec2 uv)\n{\n    return fract(sin(dot(uv.xy, \n                         vec2(12.9898, 78.233))) * \n                 43758.5453123);\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = random(i + vec2(0., 0.));\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(mix(a, b, u.x), \n               mix(c, d, u.x), u.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // value += noise(uv * freq) * amplitude;\n        \n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += (.25-abs(noise(uv * freq)-.3) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 47, 47, 167], [169, 169, 194, 194, 524], [544, 544, 567, 567, 974], [976, 976, 996, 996, 1042], [1044, 1044, 1077, 1077, 1271], [1273, 1273, 1340, 1340, 1550], [1552, 1552, 1604, 1604, 2149], [2151, 2151, 2202, 2202, 2403], [2405, 2405, 2431, 2431, 2507], [2510, 2510, 2567, 2567, 4307]], "test": "timeout"}
{"id": "3dXcW4", "name": "RayMarch BALL", "author": "Pacan1337", "description": "THE BALL", "tags": ["raymarching"], "likes": 2, "viewed": 74, "published": "Public", "date": "1584745800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MaxSteps 500\n#define Tol 0.001\n#define MaxDistance 1000.\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n\tvec3 color;   \n};\n    \nstruct PointLight\n{\n    vec3 pos;\n    float radius;\n    float intencity;\n    float brightness;\n    vec3 color;\n};\n\nfloat SphereDist(in vec3 point, Sphere sphere, out vec3 defuseColor)\n{\n    defuseColor = sphere.color;\n    \n    return distance(point, sphere.center) - sphere.radius;\n}\n\nfloat FloorDist(in vec3 point, out vec3 defuseColor)\n{\n    defuseColor = vec3(0.8);\n    \n    return point.z;\n}\n\nfloat smin (float a, float b)\n{\n    float m = min(a, b);\n    float dif = abs(a - b);\n    \n    return m + dif * (exp(m) / (exp(a) + exp(b)));\n}\n// polynomial smooth min (k = 0.1);\n//float smin( float a, float b, float k )\n//{\n//    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n///    return mix( b, a, h ) - k*h*(1.0-h);\n//}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat GetMinDist(in vec3 point, out vec3 defuseColor)\n{\n    Sphere s1 = Sphere(vec3(0., 0., 1.), 1., vec3(1.));\n    Sphere s2 = Sphere(vec3(5. * cos(iTime), 0., 1.), .5, vec3(1.));\n\n    vec3 sphereColor1;\n    vec3 sphereColor2;\n    float sphereDist1 = SphereDist(point, s1, sphereColor1);\n    float sphereDist2 = SphereDist(point, s2, sphereColor2);\n    vec3 floorColor;\n    float floorDist = FloorDist(point, floorColor);\n    float res;\n    \n\n    if(sphereDist1 < sphereDist2)\n    {\n        defuseColor = sphereColor1;\n        res = sphereDist1;\n    }\n    else\n    {\n        defuseColor = sphereColor2;\n        res = sphereDist2;\n    }\n    res = smin(sphereDist1, sphereDist2, 5.);\n        \n    if(floorDist < res)\n    {\n        defuseColor = floorColor;\n        res = floorDist;\n    }\n    \n    return res;\n}\n\nvec3 RayMarch(\n    in vec3 point,\n    in vec3 direction,\n    out int stepCount,\n    out float minDist,\n    out vec3 hitPoint,\n\tout float dist)\n{\n\n    vec3 rayPoint = point;\n    vec3 resColor;\n    dist = 0.;\n    \n\tfor(int i = 0; i < MaxSteps; ++i)\n    {\n        float minDistOnThisIteration = GetMinDist(rayPoint, resColor);\n        \n        minDist = min(minDistOnThisIteration, minDist);\n        if(minDistOnThisIteration < Tol)\n        {\n            stepCount = i;\n            return resColor;\n        }\n        \n        rayPoint += minDistOnThisIteration * direction;\n        hitPoint = rayPoint;\n        dist += minDistOnThisIteration;\n\t\tif(dist > MaxDistance * 1.5) break;\n    }\n    \n    stepCount = MaxSteps;\n    return vec3(0.);\n}\n\nvec3 GetNormal(vec3 point)\n{\n\tfloat eps = 0.0001;\n    vec3 c;\n    \n    return normalize(GetMinDist(point, c) - vec3(\n        GetMinDist(point + vec3(eps, 0., 0.), c),\n        GetMinDist(point + vec3(0., eps, 0.), c),\n        GetMinDist(point + vec3(0., 0., eps), c) ));\n}\n\nvec4 GetLight(vec3 point, PointLight light)\n{\n\n    float distanceToLight = distance(point, light.pos);\n    if(distanceToLight > light.radius * 10.)\n        return vec4(0., 0., 0., 1.);\n    \n    vec3 lightDirection = normalize(light.pos - point);\n    vec3 normal = GetNormal(point);\n    vec3 c;\n    float dist;\n    float minDist;\n    int steps;\n    vec3 hitPoint;\n    RayMarch(point + lightDirection * 2. * Tol, lightDirection, steps, minDist, hitPoint, dist);\n    \n    vec4 resColor = vec4(light.color * light.intencity, distanceToLight / light.radius);\n    vec3 hitNormal;\n    \n    if(dist <= distanceToLight && dist > Tol)\n    {\n    \thitNormal = GetNormal(hitPoint);\n    }\n    else\n    {\n        hitNormal = normal;\n    }\n    float hitCos = dot(hitNormal, lightDirection);\n    \n    resColor += vec4(vec3(0.), hitCos * 0.5 + 0.5);\n\tresColor.a -= light.brightness;\n    \n    return resColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPoint = vec3(0., -6., 3.);\n    vec3 cameraDirection = normalize(vec3(0., 1., -0.3));\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv.x, 0., uv.y) + cameraDirection);\n    int marchSteps;\n    float marchMinDist;\n    vec3 hitPoint;\n\tfloat dist;\n    \n    vec3 col = RayMarch(cameraPoint, rayDirection, marchSteps, marchMinDist, hitPoint, dist);\n\t\n    vec3 redLightPoint = vec3(3. * cos(iTime), 3. * sin(iTime), 7.);\n    vec3 blueLightPoint = vec3(-3. * cos(iTime), 3. * -sin(iTime), 7.);\n\n    PointLight redLight = PointLight(redLightPoint, 10., 0.2, 0.5, vec3(0.7, 0., 0.));\n    PointLight blueLight = PointLight(blueLightPoint, 10., 0.3, 0.5, vec3(0., 0., .7));\n\n    vec4 light = GetLight(hitPoint, blueLight);\n    col = light.rgb * light.a + col * (1. - light.a);\n    \n    light = GetLight(hitPoint, redLight);\n    //col = light.rgb * light.a + col * (1. - light.a); \n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 326, 326, 424], [426, 426, 480, 480, 536], [538, 538, 569, 569, 680], [864, 900, 941, 941, 1015], [1017, 1017, 1072, 1072, 1826], [1828, 1828, 1972, 1972, 2565], [2567, 2567, 2595, 2595, 2838], [2840, 2840, 2885, 2885, 3732], [3734, 3734, 3791, 3791, 4805]], "test": "timeout"}
{"id": "3dXyR4", "name": "#693 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["2d", "experiment", "daily", "everyday"], "likes": 3, "viewed": 104, "published": "Public API", "date": "1584204044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Code by Sixclones\n\nMy boilerplate: https://www.shadertoy.com/view/wdsyzH */\n\n// CONSTANTS & UTILS\n#define QP 0.785398163397448\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// UTILS FN\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\nto be used with cos/sin\n`map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\nvec2 map01(vec2 n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n/* rotate uv\nuv - uv to rotate\na - angle of the rotation\n\ninspired by Patricio Gonzalez Vivo (but in fact you find this everywhere)\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/rotate.glsl\n*/\nvec2 rotate2d(vec2 uv, float a) {\n  uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n  return uv;\n}\n\n/* function to draw filled sdf\nx - sdf to draw\ns - size\n\nfrom Pixel Spirit Deck by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/fill.glsl */\nfloat fill(float x, float s) {\n  return 1.0 - step(s, x);\n}\n\n/* function to draw stroke\nx - sdf to draw\ns - size of the draw\nw - width of the stroke\np - precision of the stroke\n\ninspired by Pixel Spirit Deck `stroke` function by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/stroke.glsl */\nfloat stroke(float x, float s, float w, float p) {\n  return clamp(\n    S(x - 0.5 * w - p, x - 0.5 * w + p, s) * S(x + 0.5 * w + p, x + 0.5 * w - p, s),\n    0.0, 1.0\n  );\n}\n\n/* compute a rect signed distance field\nuv - uv of the screen\ns - size of the rect\n\nfrom Pixel Spirit Deck by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/rectSDF.glsl */\nfloat rectSDF(vec2 uv, vec2 s) {\n  return max(abs(uv.x / s.s), abs(uv.y / s.y));\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tvec2 uv0 = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  \tvec3 color = vec3(0.95);\n\n  \t// VIGNETTE\n  \tcolor -= S(0.55, 1.5, length(uv0));\n\n  \t// MASK\n    // compute the sdf of a rect\n  \tfloat rect = rectSDF(rotate2d(uv0, QP), vec2(0.5));\n    \n    // get a filled rect\n  \tfloat rectf = fill(rect, 0.65);\n    // color -= rectf; // uncomment to see the result of a fill\n\n    \n  \t// WAVES + MOIRÉ = MAGIC\n    /* split between left & right, a more simple writing is `mix(-ht, ht, step(0.0, uv0.y))`\n\tthe step is done on 0.0 because uv0 goes from -1.0 to 1.0\n\tfinally the split is rotated\n    */\n  \tfloat timer = mix(\n    \t-ht, ht,\n    \tstep(0.0, rotate2d(uv0, -ht + cos(ht + QP * uv.y)).x)\n  \t);\n    \n    /* amplitude of the waves */\n  \tfloat amp = map01(cos(t + TP * uv.x), 0.1, 0.75);\n    \n    /* waves are computed with a sinus combined with lot of offsets and cos/sin */\n  \tfloat waves = amp * sin(t + 5.0 * TP * uv.x + 2.5 * P * uv.y\n    \t+ P * cos(-t + 5.0 * TP * uv.x * pow(uv.y, uv.x))\n\t\t+ pow(cos(timer + P * uv.y), uv.x)\n  \t);\n    \n    // subtle offset\n  \tfloat offset = t + uv.x;\n\n  \t// STRIPES\n    /* number of stripes */\n  \tfloat ns = 30.0;\n    \n    /* passing this to a cos/sin will give you stripes\n\tthis could have been done with `fract(ns * uv.y)` */\n  \tfloat _stripes = ns * TP * uv.y;\n    \n    /* compute static + animated stripes and */\n  \tvec2 stripes = map01(vec2(\n    \tcos(_stripes),\n    \tcos(_stripes + waves + offset)\n  \t), 0.0, 1.0);\n\n  \t// DRAWING PARAMS\n    /* normally size of the draw but with stripes if more like the position\n\twith 0.5 I assure that the stripe is in the middle of the render\n\t(not clear comment, I admit, sorry)\n\t*/\n    float s = 0.5;\n  \tfloat w = 0.2; // width of strokes\n  \tfloat p = 50.0 / iResolution.x; // precision of strokes to avoid aliasing\n\n    // RENDER\n    // we create a mask by multiplying the addition of the stripes (static + animated) to the rect filled\n    color -= rectf * (stroke(stripes.x, s, w, p) + stroke(stripes.y, s, w, p));\n\n  \tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 410, 484, 484, 556], [558, 688, 737, 737, 793], [795, 795, 842, 842, 898], [900, 1119, 1152, 1152, 1218], [1220, 1411, 1441, 1441, 1470], [1472, 1750, 1800, 1800, 1921], [1923, 2144, 2176, 2176, 2226], [2228, 2236, 2291, 2291, 4382]], "test": "ok"}
{"id": "3dXyR8", "name": "camino--otro-v1", "author": "jorge2017a1", "description": "camino--otro-v1", "tags": ["caminootrov1"], "likes": 0, "viewed": 48, "published": "Public", "date": "1584068157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n    vec3 pp;\n    pp=p;\n    \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            //res=vec2(res.x, 9);             \n             res=vec2(res.x, 21);\n             \n         } \n     }\n\t\n    p.z= mod( p.z,20.0);\n    \n    float sdb1= sdBox(  p- vec3(0.0), vec3(20.,10.,20.) );\n    float sdb2= sdBox(  p- vec3(0.0), vec3(25.,11. ,5.) );\n    float sdb3= sdBox(  p- vec3(0.0), vec3(8.,11.,25.) );\n    \n    \n    \n    dif1= differenceSDF(sdb1,sdb2);\n    dif1= differenceSDF(dif1,sdb3);\n    float sdSp1 = sdSphere( pp-vec3(0.+0.5*sin(iTime),3.0+4.0*sin(iTime),5.+mObj.ro.z), 1.2 );\n    \n    res = opU(res, vec2(dif1,23));\n    res = opU(res, vec2(sdSp1,8));\n\n    res = opU(res, vec2(0.9,8));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n    \n    \n    \n    if(i== 22 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    \n    \n\tif(i== 23 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),mObj.color,marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    \n    \t\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n  int i;\n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t//vec3 surfaceColor3 = vec3(0.45,0.54,1.0);  \n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    \n  for( i = 0; i < 3; i++)\n  {\n    //float nearest = RayMarch(p + dir*dist);\n    float nearest = RayMarch(ro, rd);  \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = ro+rd*dist;\n      \n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n    //ro=ro+rd*EPS;\n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n    \n    \n    vec3 ro = vec3(1.5,8.5,-60.0+iTime*5.0);\n   // ro = get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0) );\n    \n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t\n    vec3 rLuz=vec3(0.5, 3.5, 10.5)+ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    //float dif = GetLightv2(p);\n    float dif = GetLightPar(p,rLuz);\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    mObj.color=vec3(0.5,0.8,0.6);\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    \t\n    \n    col= result*dif*1.1;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 474, 507, 507, 572], [573, 591, 627, 627, 696], [697, 712, 743, 743, 893], [894, 914, 950, 950, 1037], [1038, 1054, 1086, 1114, 1175], [1177, 1177, 1213, 1213, 1316], [1319, 1393, 1451, 1451, 1715], [1717, 1717, 1762, 1762, 1853], [1855, 1855, 1937, 1937, 2168], [2171, 2171, 2202, 2202, 2390], [2393, 2447, 2469, 2469, 3729], [3732, 3796, 3832, 3832, 4105], [4157, 4157, 4203, 4203, 4235], [4237, 4237, 4280, 4280, 4312], [4314, 4314, 4362, 4362, 4395], [4398, 4398, 4427, 4427, 4553], [4555, 4555, 4591, 4591, 4708], [4710, 4710, 4746, 4746, 4864], [4867, 4867, 4903, 4903, 5026], [5079, 5091, 5113, 5113, 5421], [5422, 5448, 5473, 5473, 5663], [5664, 5709, 5726, 5726, 5799], [5802, 5835, 5861, 5861, 6058], [6105, 6105, 6157, 6157, 6312], [6377, 6486, 6523, 6523, 6558], [6560, 6560, 6579, 6579, 6654], [6703, 6703, 6726, 6726, 6752], [6754, 6754, 6777, 6777, 6915], [6918, 6918, 6940, 6940, 7010], [7075, 7075, 7101, 7101, 7158], [7160, 7160, 7180, 7180, 7238], [7241, 7241, 7262, 7262, 7512], [7515, 7515, 7547, 7547, 7632], [7634, 7634, 7670, 7670, 7859], [7860, 7860, 7887, 7887, 8302], [8411, 8438, 8459, 8459, 8525], [8527, 8527, 8549, 8549, 8604], [8606, 8606, 8627, 8627, 8682], [8684, 8684, 8705, 8705, 8760], [8824, 8824, 8843, 8843, 8887], [8889, 8889, 8932, 8932, 10482], [10485, 10534, 10559, 10559, 11642], [11645, 11645, 11679, 11679, 12048], [12053, 12053, 12077, 12077, 12309], [12313, 12313, 12337, 12337, 12729], [12732, 12732, 12758, 12758, 13122], [13125, 13125, 13163, 13163, 13520], [13523, 13523, 13548, 13548, 13576], [13578, 13578, 13630, 13630, 14026], [14129, 14173, 14190, 14190, 14261], [14286, 14378, 14403, 14403, 14666], [14725, 14725, 14753, 14753, 23175], [23177, 23225, 23326, 23360, 23870], [23876, 23922, 23975, 23975, 25166], [25169, 25218, 25275, 25275, 26315]], "test": "error"}
{"id": "3dXyRf", "name": "_Mandelbrot", "author": "RumyHumy", "description": "Simple mandelbrot visualisation", "tags": ["mandelbrotfractal"], "likes": 0, "viewed": 46, "published": "Public", "date": "1585209146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time, i_max, i_real, k, tmp, colv, colue;\nvec2 val, com;\nvec3 col;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.xy;\n \t// Set position\n    val.x = uv.x*1.4-0.7;\n    val.y = uv.y*1.4;\n    vec2 com = vec2(0.0,0.0);\n    // Draw\n    i_max = min((sin(iTime*1.5)+1.)/2.*40.+1.,500.);\n\tfor (int i = 0; float(i) < i_max; i++)\n    {\n        tmp = com.x*com.x-com.y*com.y;\n        com.y = 2.0*com.x*com.y;\n        com.x = tmp;\n        com+=val;\n        k = length(com);\n        i_real = float(i);\n        if (k >= 2.0) { break; }\n    }\n    colv = i_real/i_max;\n    colue = (sin(iTime*1.5)+1.)/2.;\n    col = colv*vec3(1.+0.9*colue,1.6,1.9);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 130, 166, 796]], "test": "error"}
{"id": "3dXyRl", "name": "worley noise comparison", "author": "jamelouis", "description": "worley noise(horizon: f1, f2-f1; vertical: euclidean distance, manhattan distance chebyshev distance)", "tags": ["noise"], "likes": 1, "viewed": 86, "published": "Public", "date": "1585293795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// worley noise\n// dragonyhr https://www.shadertoy.com/view/tldGzr\n\n// noise\n// worley F1 | worley F2-F1\n// manhattan worley F1 | manhattan worley F2-F1\n// chebyshev worley F1 | chebyshev worley F2-F1\n\n\n#define pi 3.141592654\n\nvec2 hash22(vec2 p)//Dave Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\treturn fract(cos(p*mat2(-64.2,71.3,81.4,-29.8))*8321.3);\n}\n\nint worley_type(vec2 t)\n{\n \tfloat grid = 3.;\n    if(t.y<1.0/3.0) return 2; // worley\n    if(t.y<2.0/grid) return 1; // manhattan worley\n    if(t.y<3.0/grid) return 0; // chebyshev worley\n}\n                    \nfloat Worley(vec2 q, float scale, float ftime)\n{\n    int wt = worley_type(q/iResolution.xy);\n    int f2t = 0;\n    if(q.x/iResolution.x > 0.5) f2t = 1;\n    q = q/scale + ftime;\n    float f1 = 9e9;\n    float f2 = f1;\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++){\n            vec2 p = floor(q) + vec2(i, j);\n            vec2 h = hash22(p);\n            vec2 g = p + 0.5+ 0.5 * sin(h*12.6);\n            float d = f1;\n            if(wt == 0) {\n                d = distance(g,q);\n            }else if(wt == 2) {\n            \tfloat xx = abs(q.x-g.x);\n            \tfloat yy = abs(q.y-g.y);\n            \td = max(xx, yy);\n            } else{\n                float xx = abs(q.x-g.x);\n            \tfloat yy = abs(q.y-g.y);\n                d = xx + yy;\n            }\n            if(d < f2){ f2 = d; }\n            if(d < f1){f2 = f1; f1 = d; }\n        }\n    }\n    if(f2t == 0)\n    \treturn f1;\n    else\n        return f2 - f1;\n}\n\nvoid mainImage( out vec4 Color, in vec2 Coord)\n{\n\tColor = vec4(vec3(Worley(Coord.xy, 32.0f, iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 300, 300, 360], [362, 362, 387, 387, 550], [572, 572, 620, 620, 1508], [1510, 1510, 1558, 1558, 1617]], "test": "error"}
{"id": "3dXyRN", "name": "Living maze", "author": "stb", "description": "Not guaranteed solvable. Click & drag to see input pattern.", "tags": ["procedural", "2d", "maze"], "likes": 12, "viewed": 129, "published": "Public", "date": "1584217910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Originally posted to glslsandbox... somewhere :/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define pi 3.14159265\n\n#define T .4*iTime\n\n// pill shape for walls\nfloat pill(vec2 p, vec2 d) {\n    return length( vec2(max(0., (dot(p, d))), abs(dot(p, vec2(d.y, -d.x)))) );\n}\n\n// for the input pattern, it's like Gabor noise\nfloat rStripes(vec2 p, vec2 o, float freq) {\n    float ang = 2. * pi * hash12(floor(p)-o);\n    vec2 dir = vec2(sin(ang), cos(ang));\n    float f;\n    \n\t// choose one\n    f = .5 + .5 * cos(2.*T+freq*pi*dot(p, dir));\n    //f = 2. * abs(fract(dot(freq*p, dir)+3.*T)-.5);\n    //f = 4. * pow(abs(fract(dot(freq*p, dir)+.5*T)-.5), 2.);\n    //f = fract(dot(freq*p, dir)+.5*T);\n    \n    return f;\n}\n// continuation of above\nfloat rStripesLin(vec2 p, float freq) {\n    vec3 o = vec3(-1., 0., 1.); \n    return\n        mix(\n            mix(\n                rStripes(p, o.zy, freq),\n                rStripes(p, o.yy, freq),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            mix(\n                rStripes(p, o.zx, freq),\n                rStripes(p, o.yx, freq),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            smoothstep(0., 1., fract(p.y))\n\t\t);\n}\n\n// input pattern\nfloat map(in vec2 p) {\n    \n\tvec2 p_ = p;\n    p = floor(p);\n   \n    float f = 2.*rStripesLin(p/5., 1.);\n    \n    return f*1.75+.1;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n    vec2 p = (fc-res/2.) / res.x;\n    \n    float zoom = 64.;\n    \n    p *= zoom;\n    \n    float f = 0.;\n    \n    vec3 o = vec3(-1., 0., 1.);\n    vec2 O[4];\n    O[0] = o.xy;\n    O[1] = o.zy;\n    O[2] = o.yx;\n    O[3] = o.yz;\n    \n    // value for wall direction\n    float rv = radians(90.*floor(map(p)));\n    \n    // initial wall\n    f = 2. * pill(fract(p)-.5, vec2(sin(rv), cos(rv)));\n    \n    // add walls from surrounding directions\n    for(int i=0; i<4; i++) {\n    \trv = radians(90.*floor(2.+map(p-O[i])));\n        vec2 sc = vec2(sin(rv), cos(rv));\n    \tif(dot(sc, O[i])>.5)\n            f = min(f, 2. * pill(fract(p)-.5, sc));\n    }\n    \n    // aa\n    f = smoothstep(.5-2./res.x*zoom, .5+2./res.x*zoom, f);\n    \n    // mouse input\n    if(p.x<(iMouse.x/res.x-.5)*zoom)\n    \tf = floor(map(p)) / 3.;\n    \n\tfo = vec4(vec3(f), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 197, 197, 313], [358, 382, 410, 410, 491], [493, 541, 585, 585, 930], [931, 956, 995, 995, 1424], [1426, 1443, 1465, 1465, 1575], [1577, 1577, 1620, 1620, 2480]], "test": "timeout"}
{"id": "3dXyW2", "name": "Ray marching hard shadows", "author": "arnauaguilaremanuel", "description": "test to raymarch and shadows", "tags": ["raymarching", "shadows"], "likes": 2, "viewed": 73, "published": "Public", "date": "1585556298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 spherePos = vec3(0.,0.,0.);\nvec3 cubePos = vec3(0.,0.,0.);\n\n\nfloat smothMin(float distA, float distB, float k){\n\tfloat h = max(k-abs(distA-distB),0.)/k;\n    return min(distA, distB)- h*h*h*k/1./6.0;\n}\n\nfloat signedDistanceBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat signedDistanceSphere(vec3 currentPoint, vec3 pos, float rad){\n\treturn length(currentPoint - pos) - rad;\n}\n\nfloat sdPlane( vec3 p, float height )\n{\n\treturn p.y - height;\n}\n\nfloat getDist(vec3 currentPoint){\n\tvec3 pos = spherePos + vec3(1,0,0)*sin(iTime/2.);\n    float distSphere = signedDistanceSphere(currentPoint, pos, .2);\n    \n   \tpos = cubePos- vec3(1,0,0)*(sin(iTime));\n    float distCube = signedDistanceBox(currentPoint, vec3(.1,.5,.5));\n    \n    float distFloor = sdPlane(currentPoint,-1.);\n    \n    return min(smothMin(distSphere, distCube,1.), distFloor);\n\n}\n\n\n\n// raymarching-------------------------------------------\nfloat shortestDistance(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        //distformula for one sphere\n        float dist = getDist(eye + depth * marchingDirection);\n        \n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 getRayDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n//--------------------------------------------------------------\n// phong--------------------------------------------------------\n\nvec3 shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    vec3 p;\n    for( float t=mint; t<maxt; )\n    {\n        p=ro + rd*t;\n        float h = getDist(ro + rd*t);\n        if( h<0.001 )\n            return p;\n        t += h;\n    }\n    return p;\n}\n\nvec3 estimateNormal(vec3 p) {// aproximated normal(screen space)\n    return normalize(vec3(\n        getDist(vec3(p.x + EPSILON, p.y, p.z)) - getDist(vec3(p.x - EPSILON, p.y, p.z)),\n        getDist(vec3(p.x, p.y + EPSILON, p.z)) - getDist(vec3(p.x, p.y - EPSILON, p.z)),\n        getDist(vec3(p.x, p.y, p.z  + EPSILON)) - getDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, float shadowInfo) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN)  * shadowInfo;\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha)) * shadowInfo;\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, float shadowInfo) {\n    vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    \n    vec3 light1Pos = vec3(4.* sin(iTime),\n                          2.,\n                          4.* cos(iTime));\n    vec3 light1Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity,\n                       \t\t\t\tshadowInfo); \n    \n    return color;\n}\n//--------------------------------------------------------------\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = getRayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(sin(iTime/3.)* 7., 1., cos(iTime/3.)* 7.);\n    dir = ( viewMatrix(eye, vec3(0), vec3(0,1.,0))*vec4(dir,0)).xyz;\n    \n    float dist = shortestDistance(eye, dir, MIN_DIST, MAX_DIST);\n    \n    \n    if (dist > MAX_DIST - EPSILON) {// nothing on the way\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n     vec3 light1Pos = vec3(4.* sin(iTime),\n                          2.,\n                          4.* cos(iTime));\n    vec3 lightDir = p - light1Pos;\n    \n    vec3 shadowPoint = shadow(light1Pos, normalize(lightDir),0.,255.);\n    float shadowInfo = 0.;\n    \n    if(length(shadowPoint -p)<0.05)\n        shadowInfo = 1.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,shadowInfo);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 241, 241, 330], [332, 332, 375, 375, 471], [473, 473, 540, 540, 584], [586, 586, 625, 625, 649], [651, 651, 684, 684, 1047], [1051, 1109, 1191, 1191, 1551], [1554, 1554, 1616, 1616, 1748], [1880, 1880, 1943, 1943, 2135], [2137, 2137, 2166, 2201, 2505], [2507, 2507, 2655, 2655, 3272], [3274, 3274, 3377, 3377, 3854], [3855, 3920, 3969, 3969, 4156], [4159, 4159, 4216, 4216, 5303]], "test": "timeout"}
{"id": "3dXyWn", "name": "pasillo-v1", "author": "jorge2017a1", "description": "pasillo-v1", "tags": ["pasillov1"], "likes": 3, "viewed": 60, "published": "Public", "date": "1584480893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,0.0);\n}\n\n\nfloat wallxv2(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 50.0-max(ap.x,0.0);\n}\n\n\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallyv2(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 22.0-max(ap.y,0.0);\n}\n\n\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n\n\nfloat wallzv2(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 60.0-max(ap.z,0.0);\n}\n\n\n//------------------------------------------\n/*\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}*/\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    \n    \n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n    vec2 res;\n    res = vec2(9999, 0);  \n   vec3 pr=p;\n   pr.x=mod(p.x,2.0)-0.5;\n    \n    \n    //piso\n    float sdr1=  sdRoundBox(pr- vec3(0.0,0.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr2=  sdRoundBox(pr- vec3(0.0,0.0,4.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr3=  sdRoundBox(pr- vec3(0.0,0.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr4=  sdRoundBox(pr- vec3(0.0,0.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    \n    res=opU(res, vec2(sdr1,8));\n    res=opU(res, vec2(sdr2,9));  \n    res=opU(res, vec2(sdr3,8));\n    \n    //1da columna\n    float sdr5=  sdRoundBox(p- vec3(0.0,3.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr6=  sdRoundBox(p- vec3(0.0,6.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr7=  sdRoundBox(p- vec3(0.0,9.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr8=  sdRoundBox(p- vec3(0.0,12.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    \n    //2da columna\n    float sdr9=  sdRoundBox(p- vec3(0.0,3.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr10=  sdRoundBox(p- vec3(0.0,6.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr11=  sdRoundBox(p- vec3(0.0,9.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr12=  sdRoundBox(p- vec3(0.0,12.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    \n    \n    //3da columna\n    float sdr13=  sdRoundBox(p- vec3(10.0,3.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr14=  sdRoundBox(p- vec3(10.0,6.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr15=  sdRoundBox(p- vec3(10.0,9.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr16=  sdRoundBox(p- vec3(10.0,12.0,7.0) , vec3(1.0,1.0,1.0), 0.5 );\n    \n    //4da columna\n    float sdr17=  sdRoundBox(p- vec3(10.0,3.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr18=  sdRoundBox(p- vec3(10.0,6.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr19=  sdRoundBox(p- vec3(10.0,9.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    float sdr20=  sdRoundBox(p- vec3(10.0,12.0,1.0) , vec3(1.0,1.0,1.0), 0.5 );\n    \n    //techo\n    float sdr21=  sdRoundBox(p- vec3(4.5,14.5,4.5) , vec3(6.0,1.0,4.0), 0.5 );\n    \n    \n    res=opU(res, vec2(sdr5,8));\n    res=opU(res, vec2(sdr6,8));  \n    res=opU(res, vec2(sdr7,8));\n    res=opU(res, vec2(sdr8,8));\n    \n    res=opU(res, vec2(sdr9,8));\n    res=opU(res, vec2(sdr10,8));  \n    res=opU(res, vec2(sdr11,8));\n    res=opU(res, vec2(sdr12,8));\n    \n    \n    res=opU(res, vec2(sdr13,8));\n    res=opU(res, vec2(sdr14,8));  \n    res=opU(res, vec2(sdr15,8));\n    res=opU(res, vec2(sdr16,8));\n    \n    res=opU(res, vec2(sdr17,8));\n    res=opU(res, vec2(sdr18,8));  \n    res=opU(res, vec2(sdr19,8));\n    res=opU(res, vec2(sdr20,8));\n    \n    res=opU(res, vec2(sdr21,8));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\n//--------------------------------------\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n//---------------------------------------------------\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        \n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n\t}        \n    \t\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    vec3 ro = vec3(-2.0+10.*cos(iTime) ,6.5,25.0+ 7.0*sin(iTime));\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    float dif= GetLightPar(p,rl2);\n    \n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n   \n    col= result*dif*1.1;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 474, 507, 507, 572], [573, 591, 627, 627, 696], [697, 712, 743, 743, 893], [894, 914, 950, 950, 1037], [1038, 1054, 1086, 1114, 1175], [1177, 1177, 1213, 1213, 1316], [1319, 1393, 1451, 1451, 1715], [1717, 1717, 1762, 1762, 1853], [1855, 1855, 1937, 1937, 2168], [2171, 2171, 2202, 2202, 2390], [2393, 2447, 2469, 2469, 3729], [3732, 3796, 3832, 3832, 4105], [4157, 4157, 4203, 4203, 4235], [4237, 4237, 4280, 4280, 4312], [4314, 4314, 4362, 4362, 4395], [4398, 4398, 4427, 4427, 4553], [4555, 4555, 4591, 4591, 4708], [4710, 4710, 4746, 4746, 4864], [4867, 4867, 4903, 4903, 5026], [5079, 5091, 5113, 5113, 5421], [5422, 5448, 5473, 5473, 5663], [5664, 5709, 5726, 5726, 5799], [5802, 5835, 5861, 5861, 6058], [6105, 6105, 6157, 6157, 6312], [6377, 6486, 6523, 6523, 6558], [6560, 6560, 6579, 6579, 6654], [6703, 6703, 6726, 6726, 6752], [6754, 6754, 6777, 6777, 6915], [6918, 6918, 6940, 6940, 7010], [7075, 7075, 7101, 7101, 7158], [7160, 7160, 7180, 7180, 7238], [7241, 7241, 7262, 7262, 7512], [7515, 7515, 7547, 7547, 7632], [7634, 7634, 7670, 7670, 7859], [7860, 7860, 7887, 7887, 8302], [8411, 8438, 8459, 8459, 8525], [8527, 8527, 8549, 8549, 8604], [8607, 8607, 8631, 8631, 8686], [8690, 8690, 8711, 8711, 8766], [8768, 8768, 8791, 8791, 8846], [8850, 8850, 8871, 8871, 8926], [8929, 8929, 8952, 8952, 9007], [9198, 9247, 9272, 9272, 12080], [12187, 12187, 12206, 12206, 12250], [12252, 12252, 12295, 12295, 13845], [13904, 13904, 13938, 13938, 14307], [14312, 14312, 14336, 14336, 14568], [14572, 14572, 14596, 14596, 14988], [14991, 14991, 15017, 15017, 15381], [15384, 15384, 15422, 15422, 15779], [15782, 15782, 15807, 15807, 15835], [15837, 15837, 15889, 15889, 16285], [16388, 16432, 16449, 16449, 16520], [16545, 16637, 16662, 16662, 16925], [16984, 16984, 17012, 17012, 23956], [23960, 24009, 24066, 24066, 25492]], "test": "error"}
{"id": "3dXyz7", "name": "??? 2D Wave", "author": "rockyvon", "description": "a 2d wave shader.", "tags": ["2d", "wave"], "likes": 2, "viewed": 42, "published": "Public", "date": "1584353872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Strength = .3,\n    Period = 0.;\n\nfloat A = 2.,\n    b = .4,\n    r = .4,\n    PI = 3.1415927;\n\nfloat scale(float x)\n{\n    return x * 5.;\n}\n\nfloat tilt(float x)\n{\n    return pow(x / (2. * PI), r) * 2. * PI;\n}\n\nfloat extrusion(float x)\n{\n    return x + b * sin(x);\n}\n\nfloat cutout(float x)\n{\n    float period = (Period + 1.) * 2. * PI;\n    x = fract(x / period) * period;\n    if(x > PI / 4. && x < period - PI * 7. / 4.)\n    {\n        x =  PI / 4.;\n    }else if(x >= period - PI * 7. / 4.)\n    {\n        x = 2. * PI - (period - x) ;\n    }\n    return x;\n}\n\nfloat wave(float x)\n{\n    x = cutout(x);\n    x = extrusion(x);\n    x = tilt(x);\n    return (A * cos(x) + A) / 2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\n    float x = scale(uv.x) - iTime * 5.;\n    float w = wave(x);\n    w = w / A * Strength;\n    \n    vec3 color = vec3((uv.y - w) * 100.);\n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 120, 120, 141], [143, 143, 164, 164, 210], [212, 212, 238, 238, 267], [269, 269, 292, 292, 555], [557, 557, 578, 578, 672], [675, 675, 732, 732, 949]], "test": "ok"}
{"id": "3dXyzX", "name": "Noise Wiggles", "author": "brechrt", "description": "wiggles made with perlin noise", "tags": ["noise", "perlin"], "likes": 2, "viewed": 196, "published": "Public API", "date": "1585205603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\n\nfloat noise(vec2 uv){\n\tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    uv *= 20.;\n    \n    uv *= rot(noise(uv+15.) + iTime*.4);\n    float n = noise(uv+15.);\n    \n    vec3 col1 = vec3(0.950,0.181,0.291);\n    vec3 col2 = vec3(0.136,0.016,0.140);\n\tcol = mix(col1, col2, n); \n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 152], [153, 153, 175, 175, 214], [216, 216, 248, 248, 668], [669, 669, 694, 694, 750], [752, 752, 773, 773, 1287], [1289, 1289, 1307, 1307, 1380], [1382, 1382, 1439, 1439, 1768]], "test": "ok"}
{"id": "3lGSDG", "name": "StarXStar", "author": "loni852", "description": "Stars Shapes", "tags": ["stars"], "likes": 0, "viewed": 65, "published": "Public", "date": "1583436460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\t\n    \n    float radiai = 0.0015;\n    \n    \n    vec2 Metaball = vec2(0.5,0.5);\n    vec2 Metaball2 = vec2(0.5+sin(iTime)/3.0,0.5);\n    \n    float UVtoMB = (uv.x-Metaball.x)*-(uv.x-Metaball.x)+(uv.y-Metaball.y)*(uv.y-Metaball.y);\n    float UVtoMB2 = (uv.x-Metaball2.x)*(uv.x-Metaball2.x)+(uv.y-Metaball2.y)*-(uv.y-Metaball2.y);\n    \n    float finalMB = radiai/UVtoMB;\n    \n    \n    finalMB += radiai/UVtoMB2;\n    \n    \n    \n    \n\n    \n    vec3 col = vec3(1.0,1.0,(sin(iTime)/2.0)+0.5);\n    \n    if(finalMB >= 0.18){\n    \tcol *= vec3(uv.x,uv.y,1.0);\n        \n    }\n    else {\n    \tcol *= 0.0;\n    }\n    // Output to screen\n    fragColor = vec4(mix(vec3(1.0,0.3,0.5),col,finalMB+0.7),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 839]], "test": "ok"}
{"id": "3lGSR3", "name": "rainbow around the circle", "author": "libensvivit", "description": "beginner here", "tags": ["wave", "circle"], "likes": 9, "viewed": 338, "published": "Public API", "date": "1583382226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI      3.14159265\n#define TWO_PI  6.28318530\n#define HALF_PI 1.57079633\n\nvec3 circle(vec2 uv, float rad, float i){\n    float d  = length(uv);\n    float a  = atan(uv.y, uv.x);\n    vec3 c = vec3(1.);\n    vec3 colmult;\n\n    if(i == 0.) colmult = vec3(1., 0., 0.);\n    if(i == 1.) colmult = vec3(0., 1., 0.);\n\tif(i == 2.) colmult = vec3(0., 0., 1.);\n    \n    \n    rad += 0.05*cos(5.*a - i*HALF_PI + 3.*iTime)*pow(.5+.5*cos(iTime - a), 6.);\n    c -= 1.-smoothstep(rad, rad+0.01, d) + smoothstep(rad*.93, rad*.93+0.01, d);\n\n    return c * colmult;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(1.);\n    float rad = 0.4;\n        \n    col += circle(uv, rad, 0.);\n    col += circle(uv, rad, 1.);\n    col += circle(uv, rad, 2.);\n        \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 123, 123, 552], [555, 555, 609, 609, 915]], "test": "ok"}
{"id": "3lGSRc", "name": "Texture based 3d simplex noise", "author": "ming", "description": "Forked from:\n- nikat's 3d simplex noise: https://www.shadertoy.com/view/XsX3zB\n- iq's https://www.shadertoy.com/view/4sfGzS\n\nCombining the two shaders for a 3d simplex noise with texture based hash function.", "tags": ["3d", "noise", "perlin", "simplex"], "likes": 4, "viewed": 90, "published": "Public", "date": "1583230406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Original shaders\n * nikat - https://www.shadertoy.com/view/XsX3zB\n * iq    - https://www.shadertoy.com/view/4sfGzS\n * \n * Please refer to the licenses of the original shaders\n *\n */\n\n/*  Main modifications\n    texture based pseudorandom distributed in [-0.5, +0.5]^3\n*/\nvec3 random3(vec3 c) {\n    \n    // from iq https://www.shadertoy.com/view/4sfGzS\n    //ivec3 i = ivec3(floor(c));\n\t//ivec2 uv = i.xy + ivec2(37,17)*i.z;\n    //return texelFetch( iChannel0, uv&255, 0 ).yxz - 0.5;\n    \n    // avoid using texelFetch, so that we can port it to mobile\n    vec3 i = floor(c);\n    vec2 uv = (vec2(43.0,37.0)*i.z) + i.xy;\n    uv = (uv + .5) / 256.0;\n    return textureLod(iChannel0, uv, 0.0).xyz - 0.5;\n}\n\n\n// The following are the same as the original shader\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n\t\t\n\t\tif( p.x<0.0 )\n\t\t{\n\t\t\tf = simplex3d( 16.0*pos );\n\t\t}\n\t\telse\n\t\t{\n            vec3 q = 8.0*pos;\n            f  = 0.5000*simplex3d( q ); q = m*q*2.01;\n            f += 0.2500*simplex3d( q ); q = m*q*2.02;\n            f += 0.1250*simplex3d( q ); q = m*q*2.03;\n            f += 0.0625*simplex3d( q ); q = m*q*2.01;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tf *= occ;\n\t\tcol = vec3(f * 1.2 * 0.5 + 0.5);\n\t\t//col = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\t//col = sqrt( col );\n\t\n\t//col *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 273, 295, 553, 703], [865, 888, 913, 1166, 2083], [2211, 2211, 2268, 2268, 3983]], "test": "error"}
{"id": "3lGXD3", "name": "cuarto-v9", "author": "jorge2017a1", "description": "cuarto-v9", "tags": ["cuartov9"], "likes": 0, "viewed": 37, "published": "Public", "date": "1583680950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//------------------------------------------------\n\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n\n    vec2 res;\n    res = vec2(9999, 0);\n\n    \n   float sdwx= wallx(p);\n   float sdwy= wally(p); \n   float sdwz= wallz(p);\n   \n    \n   res=opU(res, vec2(sdwx,8));\n   res=opU(res, vec2(sdwy,13));\n   res=opU(res, vec2(sdwz,22));\n    \n\n   float sdc1=  sdCylinder(p-vec3(12,-5.0,-28.), vec2(2.1,20.0) );\n   float sdc2=  sdCylinder(p-vec3(-12,-5.0,-28.), vec2(2.1,20.0) );\n   res=opU(res, vec2(sdc1,21));\n   res=opU(res, vec2(sdc2,24));\n  \n  \n\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n        if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    vec3 ro = vec3(-2.0+10.*cos(iTime) ,6.5,10.0+ 7.0*sin(iTime));\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t  vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    float dif = GetLightv2(p);\n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    \n        \n   \n\t//vec3 col2=calcLuz(p, rd, rLuz,nor);\n    //correcion por Spalmer!!!!!\n   //col = (dif+result)*colobj; col = pow(col, vec3(1.0/2.2)); \n    col = result*colobj; col = pow(col, vec3(1.0/2.5)); \n    \n    \n    \n    //col = (dif+col2)*colobj; col = pow(col, vec3(1.0/2.2)); \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[426, 443, 476, 476, 541], [542, 560, 596, 596, 665], [666, 681, 712, 712, 862], [863, 883, 919, 919, 1006], [1007, 1023, 1055, 1083, 1144], [1146, 1146, 1182, 1182, 1285], [1288, 1362, 1420, 1420, 1684], [1686, 1686, 1731, 1731, 1822], [1824, 1824, 1906, 1906, 2137], [2140, 2140, 2171, 2171, 2359], [2362, 2416, 2438, 2438, 3698], [3701, 3765, 3801, 3801, 4074], [4126, 4126, 4172, 4172, 4204], [4206, 4206, 4249, 4249, 4281], [4283, 4283, 4331, 4331, 4364], [4367, 4367, 4396, 4396, 4522], [4524, 4524, 4560, 4560, 4677], [4679, 4679, 4715, 4715, 4833], [4836, 4836, 4872, 4872, 4995], [5048, 5060, 5082, 5082, 5390], [5391, 5417, 5442, 5442, 5632], [5633, 5678, 5695, 5695, 5768], [5771, 5804, 5830, 5830, 6027], [6074, 6074, 6126, 6126, 6281], [6346, 6455, 6492, 6492, 6527], [6529, 6529, 6548, 6548, 6623], [6672, 6672, 6695, 6695, 6721], [6723, 6723, 6746, 6746, 6884], [6887, 6887, 6909, 6909, 6979], [7040, 7067, 7088, 7088, 7154], [7156, 7156, 7178, 7178, 7233], [7235, 7235, 7256, 7256, 7311], [7313, 7313, 7334, 7334, 7389], [7453, 7453, 7472, 7472, 7516], [7518, 7518, 7561, 7561, 9111], [9114, 9163, 9188, 9188, 9844], [9847, 9847, 9881, 9881, 10250], [10255, 10255, 10279, 10279, 10511], [10515, 10515, 10539, 10539, 10931], [10934, 10934, 10960, 10960, 11324], [11327, 11327, 11352, 11352, 11380], [11382, 11382, 11434, 11434, 11830], [11933, 11977, 11994, 11994, 12065], [12090, 12182, 12207, 12207, 12470], [12531, 12531, 12559, 12559, 19320], [19324, 19324, 19381, 19381, 20972]], "test": "error"}
{"id": "3lGXWG", "name": "Rorschach's Dream (Best)", "author": "deerfeeder", "description": "Based on @BigWIngs's gyro tut", "tags": ["raymarching", "template", "gyroid", "artofcode", "deerfeeder"], "likes": 8, "viewed": 446, "published": "Public API", "date": "1583513497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Rorschach's Dream (Soft)\" by deerfeeder. https://shadertoy.com/view/WlySWG\n// 2020-03-05 17:20:37\n\n// Fork of \"Rorschach's Dream\" by deerfeeder. https://shadertoy.com/view/wtGXzd\n// 2020-03-05 16:50:36\n\n// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// 2020-03-04 23:37:06\n// Music by me (Deerfeeder - My Church)\n// raymarching artifacts as a feature\n\n#define MAX_STEPS 5\n#define MAX_DIST 10.\n#define SURF_DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat GetDist(vec3 p) {\n    p.xy*=Rot(iTime*0.06);\n    p.zx*=Rot(iTime*0.06);\n    float box = sdBox(p, vec3(1.0));\n   \t\n    // return box;\n    float gyro = sdGyroid(p,5.+abs(5.0*cos(iTime*0.065)),0.125,2.0)/2.0;\n    return max(box, gyro*4.);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.x = abs(uv.x);\n   // uv.y = abs(uv.y);\n\tvec2 m = vec2(cos(iTime*1.),iMouse.y)/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    //float amp = texture(iChannel0, vec2(1., 0.0)).r*4.3;\n    float pos = atan(uv.y/abs(uv.x))/3.14 + 0.5;\n    float amp = texture(iChannel0, vec2(pos, 0.0)).x*(pos*0.3+0.1)*10.0;\n    vec3 ro = vec3(sin((iTime)*0.096), 1.+cos(iTime*0.1), 2.-cos((iTime+ amp)*0.36));\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(0.1 + abs(0.5 * cos(iTime*0.1))));\t// gamma correction\n    col += texture(iChannel1, uv*10.-iTime*.3).rrr * 0.5;\n    fragColor = vec4(1. - col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4lj3zm", "previewfilepath": "https://soundcloud.com/miiiis/my-church", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/miiiis/my-church", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 528, 528, 604], [606, 606, 635, 635, 716], [718, 718, 784, 784, 863], [865, 865, 888, 888, 1108], [1110, 1110, 1144, 1144, 1355], [1357, 1357, 1381, 1381, 1571], [1573, 1573, 1623, 1623, 1818], [1822, 1822, 1879, 1879, 2832]], "test": "error"}
{"id": "3lGXzt", "name": "Ripples normal map", "author": "OskarSwierad", "description": "Ripples", "tags": ["effect"], "likes": 7, "viewed": 320, "published": "Public API", "date": "1583326348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat RemapTo01(float val, float rangeMin, float rangeMax)\n{\n    return saturate((val - rangeMin) / (rangeMax - rangeMin));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectRatio = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvCentered = uv * 2.0 - vec2(1.0);\n    uvCentered *= aspectRatio;\n    \n    vec2 pivot = vec2(0.05, 0.1);\n    \n    float radius = 0.5;\n    vec2 diff = (uvCentered - pivot) / radius;\n    float dist = length(diff);\n    \n    float mask = float(dist < 1.0);\n    \n    //diff = smoothstep(vec2(0.0), vec2(1.0), diff);\n    \n    float waveFreq = 32.0;\n    float speed = 3.0;\n    float distForSin = length(diff);\n    distForSin = pow(distForSin, 0.5);\n    float height = sin(distForSin * waveFreq - (iTime * speed));\n    //height *= 0.5;\n    //height = (dist < 1.0) ? heightAdd : 0.0;\n    \n    vec2 dir = normalize(diff);\n    //diff += dir * height * 0.9;\n    \n    vec3 norm = normalize(vec3(\n        diff.xy,\n        sqrt( saturate( 1.0 - dot( diff.xy, diff.xy ) ) )\n    ));\n    \n    norm.xy += dir * height * 0.9;\n    norm = normalize(norm);\n    \n    \n    //norm.z += heightAdd;\n    //norm = normalize(norm);\n    \n    float softEdgeMask = RemapTo01(dist, 1.0, 0.4);\n    softEdgeMask = smoothstep(0.0, 1.0, softEdgeMask);\n    if (softEdgeMask > 0.0)\n    {\n    \tnorm.xy *= softEdgeMask;\n    }\n    norm = normalize(norm);\n    \n    vec3 col = vec3(0.5);\n    col = vec3(uvCentered, 0.0);\n    //col = vec3(dist);\n    \n    if (mask < 1.0)\n    {\n        norm = vec3(0,0,1);\n    }\n    \n    col = vec3(norm);\n    \n    col = col * 0.5 + vec3(0.5);\n    //col = vec3(heightAdd);\n   \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 51, 51, 81], [83, 83, 143, 143, 208], [210, 210, 267, 267, 1779]], "test": "ok"}
{"id": "3lK3RV", "name": "Symmetry linear - Balls", "author": "NoxWings", "description": "Symmetry linear", "tags": ["symmetrylinear"], "likes": 3, "viewed": 202, "published": "Public API", "date": "1584154048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SURF_HIT 0.001\n#define FAR_PLANE 50.\n#define t (iTime*.5)\n#define S(x,y,z) smoothstep(x,y,z)\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    float s = 5.0;\n    q = mod(q, s) - s*.5;\n    float d = length(q + vec3(0)) - 1.0;\n    return d;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p - e.xyy),\n        m - map(p - e.yxy),\n        m - map(p - e.yyx)\n    ));\n}\n\nfloat mapTrace(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0;i<128;i++) {\n        float h = map(ro + rd * d);\n        if (h < SURF_HIT || d >= FAR_PLANE) break;\n        d += h;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y * 1.0;\n\n    vec3 ro = vec3(0, 0, 5);\n    ro += vec3(sin(t*PI), sin(t*PI), 0.);\n    ro += vec3(0, t, -4.0*t) * 2.0;\n    \n    vec3 rd = normalize(vec3(uv, -1));\n    rd.xz *= r2d(cos(t*PI*0.5) * 0.5);\n\n    float d = mapTrace(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n\n    vec3 fogCol = vec3(1);\n    vec3 col = fogCol;\n    if (d < FAR_PLANE) {\n        float f = pow(clamp(1.0 - dot(-rd, n), 0.0, 1.0), 1.5);\n        \n        vec3 outer = vec3(0.9);\n        vec3 inner = vec3(0.6, 0.6, 0.9);\n        float fog = clamp(pow(d/FAR_PLANE, 2.), 0.0, 1.0);\n        \n        col = f * outer + (1.0 - f) * inner;        \n        col = mix(col, fogCol, vec3(fog));\n    }\n    \n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 148, 148, 205], [207, 207, 226, 226, 344], [346, 346, 370, 370, 541], [543, 543, 577, 577, 750], [752, 752, 809, 809, 1620]], "test": "ok"}
{"id": "3lKXWV", "name": "ClockEyes ⚙", "author": "HaleyHalcyon", "description": "aeuaoeuaouou", "tags": ["spiral"], "likes": 3, "viewed": 155, "published": "Public", "date": "1583632192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\nfloat remap(float x, float lowIn, float rangeIn, bool invert)\n{\n    float o = clamp(clamp(x - lowIn, 0., rangeIn) / rangeIn, 0., 1.);\n    if (invert) {\n        return 1. - o;\n    }\n    return o;\n}\n\nvec3 blend(vec3 x1, vec3 x2, float factor)\n{\n    return x2 * factor + x1 * (1. - factor);\n}\n\nfloat zigzag(float x)\n{\n    return abs(1. - mod(x, 2.0));\n}\n  \nfloat eyeAccent(float x) {\n  if (x > 1.0) {\n    return 0.;\n  }\n  return 1.0 - x * x;\n}\n  \nfloat timeBounce(float x)\n{\n    return -3. * sin(PI * x) + x;\n}\n\nfloat gear(float d, float theta)\n{\n    // constants\n    // teeth\n    const float teethCount = 8.0;\n    const float teethWidth = 0.3; // from 0.0 to 1.0\n    const float teethSlant = 0.2; // purely radial sides don't look right\n    const float teethSmoothing = 0.06;\n    // spokes\n    const float spokeCount = 4.0;\n    const float spokeWidth = 0.08; // from 0.0 to 1.0\n    const float spokeSlant = 0.3; // purely radial sides don't look right\n    const float spokeSmoothing = 0.04;\n    // radii\n    const float scale = 0.5; // total size of the gear\n    const float smoothing = 0.02; // radial; teeth and spoke smoothing are defined separately\n    const float center = 0.2; // spokes start here\n    const float inner = 0.5; // spokes end here\n    const float outer = 0.75; // teeth start here\n    \n    d /= scale;\n    \n    if (d < center) {\n        return 1.;\n    } else if (d < inner) {\n        float slant = remap(\n                    d, center, inner + smoothing - center, true\n                );\n        return clamp(\n            remap(d, center, 0.25 * smoothing, true) // center smoothing (quarter)\n            +\n            remap( // spokes\n                1. - zigzag(theta / PI * spokeCount) - slant * slant * spokeSlant,\n                spokeWidth,\n                spokeSmoothing,\n                true\n            )\n            +\n            remap(\n                d,\n                inner - smoothing,\n                smoothing,\n                false\n            )\n        , 0., 1.);\n    } else if (d < outer) {\n        return 1.;\n    } else if (d < 1.) {\n        return clamp(\n            min(\n                remap(d, outer, smoothing, true) // ring smoothing\n                +\n                remap( // teeth\n                    1. - zigzag(theta / PI * teethCount) - remap(\n                        d, outer, 1. + smoothing - outer, true) * teethSlant,\n                    teethWidth,\n                    teethSmoothing,\n                    true\n                )\n            ,\n                remap( // smooth outer rim of gear\n             \t\td,\n                    1. - 2. * smoothing, // smooth double for outside\n                    smoothing,\n                    true\n                )\n            )\n        , 0., 1.);\n    }\n    return 0.;\n}\n\nfloat tick(float t){\n    const float ticksPerRot = 24.0;\n    const float tickLength = 0.125;\n    const float tickPeriod = 1.;\n    t += 0.5 * tickLength + 0.5 * tickPeriod;\n    return (\n        floor(t / tickPeriod) + smoothstep(0., 1., (mod(t / tickPeriod, 1.) - 0.5) / tickLength)\n \t\t) / ticksPerRot\n    ;\n}\n  \nfloat spiral(float x) {\n  return max(0.0, sin(x) * 0.75 + 0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  // colors\n  const vec3 colorBase = vec3(0.25, 0.75, 1);\n  const vec3 colorBase2 = vec3(-0.15, -0.35, -0.4);\n  const vec3 colorGear = vec3(0.9, 0.95, 0.95);\n  const vec3 colorSpiral = vec3(0.2);\n\n  // parameters to tweak\n  // more params for the gear inside the gear() function\n  const float eyesScale = 0.7;\n\n  // more params for the ticking inside the tick() function\n  float time = tick(iTime);\n\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale * 1.41421356;\n    \n  float dist = sqrt(uv.x*uv.x+uv.y*uv.y) / eyesScale;\n  /*if (dist > 1.1) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    return;\n  }*/\n  float angle = atan(uv.y, uv.x);\n\n  // Time varying pixel color\n  float cAccent = eyeAccent(dist);\n  float cGear = gear(dist, angle + 2. * PI * time);\n  \n  float logDist = log(dist);\n  float bounceTime = timeBounce(iTime * 2.0 + logDist * 0.4);\n  float ring = spiral(logDist * 8.0 + bounceTime);\n  \n  vec3 colBase = colorBase + cAccent * colorBase2 + ring * colorSpiral;\n\n  // Output to screen\n  fragColor =\n    vec4(\n      blend(\n        colBase,\n        colorGear,\n        cGear\n      ) // * remap(dist, 1.0, 0.1, true)\n      , 1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 93, 93, 226], [228, 228, 272, 272, 319], [321, 321, 344, 344, 380], [384, 384, 410, 410, 470], [474, 474, 501, 501, 537], [539, 539, 573, 603, 2797], [2799, 2799, 2819, 2819, 3107], [3111, 3111, 3134, 3134, 3177], [3179, 3179, 3236, 3252, 4498]], "test": "ok"}
{"id": "3lVSDd", "name": "caterpillar sort of thing", "author": "libensvivit", "description": "need optimization and coloring", "tags": ["raymarch", "caterpillar"], "likes": 6, "viewed": 244, "published": "Public API", "date": "1583882374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sphere(vec3 p, float radius) {\n\treturn length(p)-radius;\n}\n\n// Blending function\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// Get the distance to the plane and sphere\nfloat GetDist(vec3 p) {\n    float d = p.y;\n    float t = iTime;\n    \n    for(float i = 5.; i >= 1.; i-=1.) {\n        float size = .9 + i *.15 + 0.1*sin(iTime);\n        float spiral = 9.; \t\t\t\t\t\t\t// eight figure size\n        float ds = size*2.5; \t\t\t\t\t\t// distance between spheres\n        \n        float x = spiral*cos(t+ds);\n        float y = .3+1.5*size*sin(3.*t+i);\n        float z = spiral*cos(t+ds)*sin(t+ds);\n        \n    \td = smin(Sphere(p-vec3(x, y, z), size), d, .4);\n    }\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    for(int i = 0; i < 80; i++) {\n    \tfloat step = GetDist(ro + rd*d);\n        d += step*.5;\n        if(abs(d) < 0.0001 || d > 30.) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 normal = d - vec3(GetDist(p-e.xyy),\n                           GetDist(p-e.yxy),\n                           GetDist(p-e.yyx)); //differentiation\n    normal = normalize(normal);\n    return normal;\n}\n\nfloat GetLight(vec3 p){\n\tvec3 light = vec3(3., 10., 7.);\n    vec3 normal = GetNormal(p);\n    \n    vec3 lightVec = normalize(light-p);\n    float dif = max(0., dot(normal, lightVec));\n    float shadow = RayMarch(p+normal*.002, lightVec);\n    \n    if(shadow < length(light-p)){\n        dif *= clamp(shadow*.2, 0.,1.);\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n   \n    // any ideas about mouse rotation?\n    vec3 ro = vec3(8., 10., 13.);\n    vec3 lookAt = vec3(0.);\n    float zoom = 1.;\n    \n    // front, right and up vectors (3d camera model)\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(f, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r,f));\n    vec3 c = ro + f * zoom; \t\t\t// center\n    vec3 i = c + r*uv.x + u*uv.y; \t\t// point on the rotated uv screen\n    vec3 rd = i - ro;\n    \n    float d = RayMarch(ro, rd);\n    float dif = GetLight(ro + rd *d);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 64], [66, 87, 127, 127, 211], [213, 257, 280, 280, 752], [754, 754, 788, 788, 965], [967, 967, 991, 991, 1249], [1251, 1251, 1274, 1274, 1594], [1596, 1596, 1652, 1652, 2359]], "test": "timeout"}
{"id": "3lVSWt", "name": "大龙猫 - Quicky#027", "author": "totetmatt", "description": "Some smoky ambiance", "tags": ["instagram", "quicky"], "likes": 17, "viewed": 482, "published": "Public API", "date": "1584398782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define bpm 124.\n#define beat floor(iTime*bpm/60.)\n#define ttime iTime*bpm/60.\nmat2 r(float a){\nfloat c=cos(a),s=sin(a);\nreturn mat2(c,-s,s,c);\n}\nfloat fig(vec2 uv){\n    uv*=r(-3.1415*.9);\nreturn min(1.,.1/abs( (atan(uv.x,uv.y)/2.*3.1415)-sin(- ttime+(min(.6,length(uv)))*3.141592*8.)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv+=vec2(cos(iTime*.1),sin(iTime*.1));\n    uv*=r(iTime*.01);\n    vec3 col = vec3(-.0);\n    for(float y=-1.;y<=1.;y++){\n    for(float x=-1.;x<=1.;x++){\n    vec2 offset = vec2(x,y);\n    vec2 id = floor((uv+offset)*r(length(uv+offset)));\n    vec2 gv = fract((uv+offset)*r(length(uv+offset)))-.5;\n        gv*=r(cos(length(id)*10.));\n    float d = fig(gv);+fig(gv+vec2(sin(ttime+length(id))*.1,cos(iTime)*.1));\n    col += vec3(d)/exp(length(gv)*6.);\n\n    \n    }}\n    col = mix(vec3(.1,.01,.02),vec3(.8,.4,.2),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 95, 95, 145], [146, 146, 165, 165, 289], [291, 291, 346, 346, 956]], "test": "timeout"}
{"id": "3lySDG", "name": "BuzzyFloor", "author": "antoinefortin", "description": "dddd", "tags": ["buzzyfloor"], "likes": 1, "viewed": 75, "published": "Public", "date": "1583437312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  \tvec2 uv = (fragCoord-.5 * iResolution.xy) /iResolution.y;\n\tvec2 uv2= uv;\n    \n    uv.x = mod(uv.x+ .25, .5) -.25;\n\tuv.y = mod(uv.y + .25, .5) - .25;\n    uv.x = abs(uv.x);\n    \n    uv2.x = mod(uv2.x+ .12, .24) -.12;;\n    \n    \n    uv.xy *= 5.0;\n    // Time varying pixel color\n    vec2 d= vec2(length(uv) * (abs(sin(iTime / 5.))  * 2.5) + 1.5);\n    d.x = mod(d.x+ .5, 1.) -.5;\n    d.y = mod(d.y+ .3, 0.6) -.3;\n    d.x = abs(d.y+ abs(sin((iTime))) * d.x + abs(cos(iTime) / 2.));\n    \n    // Tile 2\n    vec2 d2 = vec2(length(uv2) * (abs(cos(iTime / 2.5))  * 1.75) + 12.5);\n    d2.x = mod(d2.x+ 1., .5) - 1.;\n    d2.y = mod(d2.y+ .3, 0.6) -.3;\n    d2.x = abs(d2.y+ abs(sin((iTime))) * d2.x + abs(cos(iTime) / 2.));\n \t\n    \n    \n\n    vec3 col = vec3(d.y, d.x, sin(d.x));\n\tvec3 col2 = vec3(d2.x, d2.y, 0.25);\n\t\n    col += (col2 * sin(iTime));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lySDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1009]], "test": "ok"}
{"id": "3lySWt", "name": "Rain Effect RayMarch", "author": "DG622", "description": "The Art of Code tutorials are excellent this is my current understanding of the Ray marching set and the rain effect from the Drive Home set of tutorials. I have not got the camera effect but holding the mouse and moving hopefully you will see my wine!", "tags": ["rainraymarching"], "likes": 4, "viewed": 148, "published": "Public", "date": "1583874194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat2 Rot (float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n    \n}\n\n\tfloat box (vec3 p, vec3 s){\n                return length (max(abs(p) - s, 0.0));\n                }\n\n\tfloat sphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\n\n    //Raymarhing for the dust see my sheets or Art of Code\n       vec2 GetDist(vec3 p){\n\t\t\tvec2 retValue;\n            //sphere         \n           float dSphere = sphere(vec4(1.0,3.5,5.0,1.5),p);\n           float dPlane = dot(vec3(p.x,p.y-4.4,p.z), normalize(vec3 (0.0,1.0,0.0)));//the vec 3 is the normal of the plane\n         \t\t\t\t\t\t\t//  if(dSphere< 0.0 && dSphere >-0.2) dSphere = abs(dSphere);//makes it hollow ie removes the negative number, if statement makes a sphere within\n           dSphere = abs(dSphere);// hollows it out the goblet so the fluid sphere shows        \n           float d = max(dSphere, dPlane) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t\t\n           //fluid levels\n           float wave =sin(iTime*2.0)* sin(15.0*p.x+iTime*2.0)*0.08;//fluid moves\n           float fSphere = sphere(vec4(1.0,3.5,5.0,1.4),p);\n           \n          \t\t\t//1 vec3 pT= p;//trying to get fluid to rotate too not working\n           \t\t\t//1pT.xz *=Rot(iTime*0.5);\n          \t\t\t//1 float FPlane = dot(vec3(pT.x ,p.y-4.1-wave,pT.z), normalize(vec3 (0.0,1.0,0.0)));\n           float FPlane = dot(vec3(p.x ,p.y-4.1-wave,p.z), normalize(vec3 (0.0,1.0,0.0)));        \n           float dF = max(fSphere, FPlane) - 0.01;\n           \n           d = min (d, dF);//blend them\n                      \n            //box\n            float bPlane = p.y;// - sin(p.x)/10.0;// plane for the ground then\n            vec3 bp = p-vec3(1.0  , 1.0  , 5.0  );//box position\n           \tbp.xz *= Rot(iTime*0.5);//rotates it\n            float scale = mix (0.8,4.0, smoothstep(-1.0, 0.5, bp.y));//gives the tapered column\n            bp.xz *= scale;\n            float db = box( bp , vec3(1.0));\n            float boxpos = min( db, bPlane)/scale*0.3;// the 0.3 sharpens and reduces artifact\n           \n           \tif (db < bPlane || dSphere < bPlane){retValue.y = 6.0;// sets the object colour with the colour multiplyier \n                          }else retValue.y = 1.0;//set an absoute value for an if statement\n           if (fSphere<0.0) {\n               \t\t\tretValue.y +=.9;//this fraction is liberated to create a red colour of tyhe fouid\n         \t\t\t\t\t\t\t\t\t//so if negative ie inside then fluid sphere is made red\n            \t\t//\tvec2 ref = GetLight(p.xy);\t\n                            }\n           \n            retValue.x = min(d, boxpos);                    \n            return retValue;\n        }\n        vec2 RayMarch(vec3 ro, vec3 rd){\n            float dO = 0.0;\n            vec2 retVal;\n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                retVal = GetDist(p);\n               \n           \t\tfloat dS = retVal.x;\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }\n          \tretVal.x = dO;\n            return retVal;           \n       }\n\n\t\tvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            vec2 retVal = GetDist(p);\n          \tfloat d = retVal.x;\n          \n            vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x, GetDist(p-e.yyx).x);           \n            n = normalize(n);\n            return n;           \n       }\n        vec2 GetLight(vec3 p){\n         \tvec3 lightPos = vec3( 5.0, 8.0, 4.0);\n\n            lightPos.xz += vec2(sin(iTime), cos(iTime));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            vec2 dif = vec2(clamp(dot(n,light), 0.0, 1.0), 0.0);// so no negative numbers, last one just a value\n            //for the shadow\n            vec2 retVal  = RayMarch(p + n * 0.01 * 3.0, light);//this 3.0 is a work around\n            float d = retVal.x;\n            if (d < length (lightPos - p )) dif.x *= 0.1;                                                    \n            dif.y = retVal.y;\n            return dif;\n        }\n     \nvec2 Rain(vec2 uv, float t){//this calculates the offset\n    //uv*=2.;//trial and error these 2\n    t*= 7.;\n    vec2 a = vec2(3., 1.);//aspect ratio chganges dot roundness\n    \n    vec2 st = uv*a;\n    vec2 id = floor(st);\n    st.y += t* 0.22;\t\t\t\t//this moves the box down\n    float noise = fract(sin(id.x*716.37)*769.46);\n    st.y += noise;//makes boxes different levels pseudo rand\n    uv.y +=noise;\n    id = floor(st);//need to reset\n    st =fract(st)- 0.5;\t\t\t//this gives the initial boxes, corners of which -0.5 to 0.5\n    \n     \n    t+=fract(sin(id.x*76.37+id.y*1453.7)*769.46)*6.283;//varies timing of the drops falling\n    \n    float y = -sin(t+sin(t+sin(t)*0.5))*.4;\t//positions dot in the box gives the movement\n    vec2 p1 = vec2(0.0, y);\n    \n    vec2 offset1 = (st-p1)/a;\t\t\t\t//this relates to where the UV is in relation to the droplet\n    float d = length(offset1);\t\t\t\t//this puts the dot in the box\n    float m1 = smoothstep( 0.07, 0.0, d);\t\t//mask 1 draws the dot\n    \n    vec2 offset2 = fract(uv*a.x * vec2(1.0,2.0))-0.5/vec2(1.,2.);\n    d=length(offset2);//draws the trailing dots\n    \n    float m2 = smoothstep(.3*(0.5-st.y), 0.0, d)* smoothstep(-.1,0.1, st.y-p1.y);//shape of the trailing drops\n   // if(st.x>0.46||st.y>0.49) m1 = 1.;\n    \n    return vec2(m1*offset1*20.+m2*offset2*10.);\n               \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \t\tvec3 RGB = vec3(0.1, 0.1, 0.1);\n\t\t\tvec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;   \n\t\t\tvec3 mp = (iMouse.xyz/iResolution.xyz)*2.-1.;         \n            vec3 col = vec3(0.5);\n   \t\t\tfloat t = iTime*0.5;\n    \n            vec3 ro = vec3(mp.x -=0.0 , mp.y += 5.0 ,-2.0  );\n   // uv.x += sin(uv.y*50.0)*0.1;\n    \t\tvec2 RainDist = Rain(uv*5., t);\n    \t\tRainDist += Rain(uv*7., t);\n    \t\tuv-=RainDist*0.5;\n    \n    \t\tuv.x += sin(uv.y*90.)*0.0051;\n    \t\tuv.y += sin(uv.x*170.)*0.001;\n    \n            vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n            vec2 retVal = RayMarch(ro,rd);\n\t\t\tfloat d = retVal.x;\n           \n            vec3 p= ro+rd*d;\n    \n            vec2 diff = GetLight(p);\n    \t\t\n    \t\tdiff/=2.0;// brightness factor\n    \t\tfloat grad = p.y /28.0;//number trial and error\n    \t\tif (retVal.y == 1.0){\n        \t\tif (p.y > 0.1){RGB = vec3( 0.2 * grad, 0.3 * grad, 0.8* grad);//sky\n                }else RGB = vec3( 0.2, 0.5, 0.1);//ground\n    \t\t}\n    \t\tfloat fluidCol = fract(retVal.y);//takes the fractionaql component to make it red\n    \t\tfluidCol *=10.0;\n    \t\t                         \n            col = vec3(diff.x + RGB.r*fluidCol, diff.x + RGB.g, diff.x + RGB.b * retVal.y);\n    \t\t   \n    \t//\tcol = vec3(RainDist, 0.0);//the r g channels\n    \n            fragColor = vec4(col, 0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lySWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 101], [104, 104, 131, 131, 203], [206, 206, 238, 238, 311], [317, 379, 400, 400, 2715], [2724, 2724, 2756, 2756, 3187], [3191, 3191, 3215, 3215, 3506], [3515, 3515, 3537, 3537, 4178], [4185, 4185, 4213, 4280, 5509], [5512, 5512, 5569, 5569, 6875]], "test": "timeout"}
{"id": "3lyXDy", "name": "trippy spheres", "author": "leocaus", "description": "be ready for a trip", "tags": ["trippy"], "likes": 3, "viewed": 129, "published": "Public", "date": "1583454825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int MAX_STEPS = 2000;\nfloat SURF_DIST = .05;\nfloat MAX_DIST = 5000.;\nvec3 modv = vec3(3., 6., 6.);\n\n\nvec3 world2modSpace(vec3 p){\n\t\n    \n    if(modv.x > 0.){\n    \tp.x = mod(p.x-modv.x/2., modv.x)-modv.x/2.;\n    }\n    \n    if(modv.y > 0.){\n    \tp.y = mod(p.y-modv.y/2., modv.y)-modv.y/2.;\n    }\n    \n    if(modv.z > 0.){\n    \tp.z = mod(p.z-modv.z/2., modv.z)-modv.z/2.;\n    }\n    \n    \n\treturn p;\n}\n\nvec3 world2cellSpace(vec3 p){\n\t\n    vec3 i = vec3(0);\n    \n    if(modv.x > 0.){\n    \ti.x = floor((p.x+modv.x/2.)/modv.x);\n    }\n    if(modv.y > 0.){\n    \ti.y = floor((p.y+modv.y/2.)/modv.y);\n    }\n    if(modv.z > 0.){\n    \ti.z = floor((p.z+modv.z/2.)/modv.z);\n    }\n    \n    \n\treturn i;\n}\n\nvec3 rotateVec3(vec3 v, float thet, float phi){\n\tvec3 v1 = vec3(v.x*cos(thet)-v.y*sin(thet), v.x*sin(thet)+v.y*cos(thet), v.z);  \n    return vec3(v1.x*cos(phi)-v1.z*sin(phi), v1.y , v1.x*sin(phi)+v1.z*cos(phi));\n}\n\nfloat distToPyramid( vec3 p, float s)\n{\n  \tp = abs(p);\n    if(p.z<0.){\n        float angle = atan(p.y/p.x);\n    \tfloat thet = mod(angle, 3.1415/4.)*sign(sin(angle*4.))+3.1415*(1.-sign(sin(angle*4.)))/8.;\n        float l = s*sqrt(2.)/(2.*cos(thet));\n        if(length(p.xy)<l){\n        \treturn length(p.z);\n        }else{\n        \treturn length(p-sign(p.x)*vec3(l*sin(angle), l*cos(angle), 0.));\n        }\n\t\t\n    }else{\n        p = abs(p);\n    \treturn (p.x+p.y+p.z-s)*0.57735027;\n    }\n    \n}\n\nfloat distToSphere(vec3 p, vec3 sc, float r){\n    vec3 D = p-sc;\n    float L = length(D);   \n    return L-r;\n}\n\nfloat getDist(vec3 p){\n    \n    vec3 modp = world2modSpace(p);\n    float t = iTime;\n    vec3 ip = world2cellSpace(p);\n\t//float dS1 = distToSphere(p, vec3 (0.,0.,0.), 1.);\n\tfloat dS0 = distToSphere(modp, rotateVec3(vec3 (0.,0.,0.), 3.1415/4.*sign(ip.x-0.01)*sign(ip.y-0.01), 0.), abs(0.75*sin(3.*ip.x+iTime)));\n    float dS1 = distToPyramid(rotateVec3(modp, 3.1415/2., -sign(ip.y-0.1)*1.*iTime+length(ip)/17.154), 0.75);\n\t//float dS1 = 100.;\n    float dS2 = distToSphere(modp, vec3 (0.,0.,1.), .25);\n    float dS3 = distToSphere(modp, vec3 (0.,0.,-1.), .25);\n    return dS0;\n    //return min(dS1,min(dS2,dS3));\n}\n\nvec3 getNormal(vec3 p){\n    \n    float d = getDist(p);\n\t\n    vec3 n = vec3(0.);\n    vec2 e = vec2(.01,0.);\n    \n    if(d < 2.*SURF_DIST){\n    \tn = d - vec3(getDist(p-e.xyy),getDist(p-e.yxy),getDist(p-e.yyx));\n        n = normalize(n);\n    }\n    \n    //if(length(p)>= MAX_DIST-SURF_DIST) n = vec3(0.0);\n\treturn n;\n}\n\nfloat RayMarch(vec3 rp, vec3 rd){\n\t\n    float dO = 0.;\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n    \tvec3 p = rp+rd*dO;\n        float d = getDist(p);\n        \n        dO += d;\n        \n        if(dO > MAX_DIST || d < SURF_DIST) break;\n        \n    }\n  \t\n    return dO;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{ \n    float t = iTime;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/(iResolution.x*0.5);\n    vec3 cp = vec3(t,modv.y/2.,modv.z/2.);\n    vec3 cd = normalize(vec3(1.0, 0.*cos(t/5.), 0.*sin(t/5.)));\n    vec3 cu = normalize(vec3(0.,sin(iTime/15.),cos(iTime/15.)));\n    \n    float fov = 45.*3.1415/360.;\n    float dov = 1./tan(fov);\n    \n    vec3 cx = normalize(cross(cu, cd));\n    vec3 cy = normalize(cross(cd, cx));\n    \n    vec3 rd = normalize(dov*cd+uv.x*cx+uv.y*cy);\n    \n    float d = RayMarch(cp, rd);\n    \n    vec3 n = getNormal(cp+rd*d);\n\t\n    vec3 i = world2cellSpace(cp+rd*d);\n    \n    // Output to screen\n    fragColor = vec4(abs(rotateVec3((1.+n)/2., length(i)/5. +t ,length(i)/5.)),1.);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 129, 129, 397], [399, 399, 428, 428, 687], [689, 689, 736, 736, 902], [904, 904, 943, 943, 1395], [1397, 1397, 1442, 1442, 1507], [1509, 1509, 1531, 1531, 2120], [2122, 2122, 2145, 2145, 2436], [2438, 2438, 2471, 2471, 2710], [2713, 2713, 2769, 2769, 3471]], "test": "timeout"}
{"id": "3lyXR3", "name": "Fractal Fire", "author": "jarble", "description": "This fractal animation looks like fire!\n\nMove the mouse to zoom in and out!", "tags": ["procedural", "fractal", "fire", "texture"], "likes": 1, "viewed": 275, "published": "Public API", "date": "1583197982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float RED = 0.0;\nconst float BLUE = 7.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float GREEN = 5.0;\nconst float WHITE = 6.0;\nconst float ORANGE = 1.0;\nconst float BLACK = 8.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n\n    return hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == BLACK){\n    \treturn vec3(0.0,0.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n\tvec4 neighbors;\n    float offset = iTime*20.0;\n    float offset1 = offset*20.0;\n    while(mag1 < mag){\n    neighbors = vec4(magnify(fragCoord+vec2(offset,1),mag1),\n        magnify(fragCoord+vec2(1,offset),mag1),\n        magnify(fragCoord-vec2(offset,1),mag1),\n        magnify(fragCoord-vec2(1,offset1),mag1));\n    bool modified = true;\n\n    if(color1 == RED && is_next_to(ORANGE,neighbors)){\n    \tcolor1 = ORANGE;\n    }\n    else if(color1 == ORANGE && is_next_to(GRAY,neighbors)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(RED,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == GRAY && is_next_to(ORANGE,neighbors) && is_next_to(GRAY,neighbors)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x) + vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 329, 351, 351, 575], [578, 578, 618, 618, 783], [785, 785, 829, 829, 965], [969, 969, 997, 997, 1549], [1551, 1551, 1610, 1610, 2573], [2575, 2575, 2632, 2632, 2962]], "test": "error"}
{"id": "3lyXRd", "name": "cubo--con-sponge", "author": "jorge2017a1", "description": "cubo--con-sponge", "tags": ["cuboconsponge"], "likes": 1, "viewed": 35, "published": "Public", "date": "1583333715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime*0.5);\n  p.yx *= rotate(iTime * 0.5);\n\n  float d;\n    float sdt= sdTorus( p, vec2(1.5,1)  );\n    d= sdt;\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 2; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                               \n}\n\n\n\n//------------------------------------------------\n\n/*\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return WALLS_SIZE-max(ap.x,max(ap.y,ap.z));\n}\n*/\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 15.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n   \n\n    \n   /* \n   float sdw= walls(p);\n   res=opU(res, vec2(sdw,8));\n   */    \n    \n    \n   float sdwx= wallx(p);\n   float sdwy= wally(p);\n   float sdwz= wallz(p);\n   res=opU(res, vec2(sdwx,8));\n   res=opU(res, vec2(sdwy,13));\n   res=opU(res, vec2(sdwz,18));\n    \n\n   float sdf1=map(p-vec3(0.0,5.0,0.));\n       \n   res=opU(res, vec2(sdf1,11 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(85./255., 205./255., 252./255.);\n    }\n    \n    if(i== 1 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n        \n     \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(5.+ iTime,15.5,20.+cos(iTime));\n    vec3 ro = vec3(-2. ,5.5,6.0);\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    /*\n    float dif = GetLight(p);\n*/\n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n \n    \n    \n    ///------------------\n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    ///------------------\n    \n    \n\n    //col =  ( vec3(dif)+colobj)/1.5;\n       col = result*colobj; col = pow(col, vec3(1.0/2.5)); \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[426, 443, 476, 476, 541], [542, 560, 596, 596, 665], [666, 681, 712, 712, 862], [863, 883, 919, 919, 1006], [1007, 1023, 1055, 1083, 1144], [1146, 1146, 1182, 1182, 1285], [1288, 1362, 1420, 1420, 1684], [1688, 1688, 1770, 1770, 2001], [2004, 2004, 2035, 2035, 2223], [2226, 2280, 2302, 2302, 3562], [3565, 3629, 3665, 3665, 3938], [3990, 3990, 4036, 4036, 4068], [4070, 4070, 4113, 4113, 4145], [4147, 4147, 4195, 4195, 4228], [4231, 4231, 4260, 4260, 4386], [4388, 4388, 4424, 4424, 4541], [4543, 4543, 4579, 4579, 4697], [4700, 4700, 4736, 4736, 4859], [4912, 4924, 4946, 4946, 5254], [5255, 5281, 5306, 5306, 5496], [5497, 5542, 5559, 5559, 5632], [5635, 5668, 5694, 5694, 5891], [5938, 5938, 5990, 5990, 6145], [6210, 6319, 6356, 6356, 6391], [6393, 6393, 6412, 6412, 6487], [6536, 6536, 6559, 6559, 6585], [6587, 6587, 6610, 6610, 6748], [6751, 6751, 6773, 6773, 6843], [6845, 6845, 6864, 6864, 7233], [7419, 7446, 7467, 7467, 7533], [7535, 7535, 7557, 7557, 7612], [7614, 7614, 7635, 7635, 7690], [7692, 7692, 7713, 7713, 7768], [7772, 7821, 7846, 7846, 8472], [8475, 8475, 8509, 8509, 8878], [8883, 8883, 8907, 8907, 9139], [9143, 9143, 9167, 9167, 9559], [9562, 9562, 9588, 9588, 9952], [9955, 9955, 9980, 9980, 10008], [10010, 10010, 10062, 10062, 10458], [10561, 10605, 10622, 10622, 10693], [10718, 10810, 10835, 10835, 11098], [11159, 11159, 11187, 11187, 13463], [13467, 13467, 13524, 13524, 14977]], "test": "error"}
{"id": "3sdSz4", "name": "Typhoon", "author": "tono", "description": "practice", "tags": ["raymarching"], "likes": 6, "viewed": 140, "published": "Public", "date": "1583136267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M(x,y) mod(x,y)  - y/2.\n\nfloat dBox(vec3 p,vec3 s)\n{\n\tp = abs(p) - s;\n\treturn max(max(p.x,p.y),p.z);\n}\nfloat sdSphere(vec3 p)\n{\n    return length(p) - 0.1;\n}\nfloat smin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a),c = cos(a);\n\treturn mat2(c,s,-s,c);\n}\nfloat map(vec3 p)\n{\n    vec3 p2 = p;\n\tp.z = M(p.z,10.);\n    p.xz *= rot(1.-iTime);\n    p.z =M(p.z,11.);\n\tfor(int i = 0; i < 3 ; i++)\n\t{\n\t\tp.x = abs(p.x)- 1.5;\n\t\tp.xy *= rot(1.5 * sin(iTime/2.));\n\t\tp.y = abs(p.y) - 0.3;\n        p.xy *= rot(30.);\n\t\tp.yz *= rot(1. - sin(iTime));\n\t\tp.z = abs(p.z) - 0.9;\n\t\tp.xz *= rot(1.* sin(iTime/2.));\n\t}\n\tfloat s = dBox(p,vec3((sin(iTime) + 1.1  )/8.));\n    \n    float s2 = 10. * sin(length(p));\n\treturn smin(s,s2,3.);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( fragCoord.xy *2. - iResolution.xy )/min(iResolution.x,iResolution.y);\n\n\tvec3 color = vec3(0.);\n\t\n\tvec3 cp = vec3(0.,0.,-5.);\n\tvec3 cd = vec3(0.,0.,1.);\n\tvec3 cu = vec3(0.,1.,0.);\n\tvec3 cs = cross(cu , cd);\n\t\n\tfloat target = 2.5;\n\t\n\t//cp.xy *= rot(iTime);\n\tcp += cd * iTime;\n    \n\tvec3 rd = normalize(vec3(cd * target + cs * p.x + cu * p.y));\n\t\n\tfloat depth = 0.;\n\tfloat ac = 0.0;\n\t\n\tfor(int i = 0 ; i <99 ; i++)\n\t{\n\t\tvec3 rp = rd * depth + cp;\n\t\tfloat d = map(rp);\n\t\td = max(abs(d),0.001);\n\t\tac += exp(-d * 3.);\n\t\tdepth += d;\n\t}\n\tcolor = vec3(ac/100.);\n\tfragColor = vec4(color, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 60, 60, 110], [111, 111, 135, 135, 165], [166, 166, 206, 206, 275], [277, 277, 296, 296, 352], [353, 353, 372, 372, 807], [812, 812, 869, 869, 1472]], "test": "timeout"}
{"id": "3sfcRN", "name": "Ray tracing bounced spheres", "author": "imod", "description": "My first try create something on shadertoy.\nRay traced spheres.", "tags": ["3d", "raytracing", "phong", "spheres"], "likes": 2, "viewed": 107, "published": "Public", "date": "1584222821", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//raytraced bounce shperes\n//my first try create something on shadertoy\n//twitter: @imod\n//\n//https://twitter.com/imod74\n\n#define shpere_count 8\n#define full_shpere_count 64\n#define lights_count 3\n#define max_intresections 8\n\n#define PI  3.1415926535897932384626433832795\n#define PI_half  1.57079632679489661923\n\nfloat sinc(float x)\n{\n    return sin(x)/x;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nstruct material\n{\n\tvec3 color;\n\tfloat highlight_intencity;\n    float highlight_hard;\n    float reflection;\n    float refraction;\n    float refraction_int;\n    \n};\n\nmaterial create_material(vec3 color, float highlight_intencity, float highlight_hard, float reflection, float refraction, float refraction_int)\n{\n    material new_material;\n    new_material.color = color;\n    new_material.highlight_intencity = highlight_intencity;\n    new_material.highlight_hard = highlight_hard;\n    new_material.reflection = reflection;\n    new_material.refraction = refraction;\n    new_material.refraction_int = refraction_int;\n    \n    return new_material;\n}\n\n\nstruct ray\n{\n\tvec3 position;\n\tvec3 dirrection;\n};\n\nstruct sphere_shape\n{\n    vec3 position;\n\tfloat radius;\n    material cur_material;\n};\n\nsphere_shape create_shpere(vec3 set_position, float set_radius, material set_material)\n{\n    sphere_shape new_sphere;\n    new_sphere.position = set_position;\n    new_sphere.radius = set_radius;\n    new_sphere.cur_material = set_material;\n    return new_sphere;\n}\n\nvec3 shpere_get_normal(sphere_shape shpere, vec3 position)\n{\n    return normalize(position - shpere.position);\n}\n\nvec3 ray_sphere_intersect(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)\n{\n    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;\n\tfloat distance_to_ray = length(cur_shpere.position - distance_point);\n    \n    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))\n    {\n        return vec3(0,0,0);\n    }\n\n    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));\n\n\tvec3 intersect_point = distance_point - (ray_dir * inner_line_length);\n\n    return intersect_point;\n}\n\nstruct light\n{\n\tvec3 position;\n\tvec3 color;\n    float intension;\n    bool shadows;\n};\n    \n    \nlight create_light(vec3 position, vec3 color, float intension, bool shadows)\n{\n    light new_light;\n    new_light.position = position;\n    new_light.color = color;\n    new_light.intension = intension;\n    new_light.shadows = shadows;\n    return new_light;\n}\n\nstruct camera\n{\n    vec3 position;\n    vec3 rotation;\n    float fov;\n};\n\nstruct intresection\n{\n    vec3 position;\n    vec3 normal;\n    material cur_material;\n    float distance_far;\n};\n    \nvec3 ray_plane_intersect(vec3 ray_start, vec3 ray_dir)\n{\n    \n  if ( ray_dir.z > 0.0)\n  {\n    return vec3(0,0,0);\n  }\n\n  float t = ((ray_start.x + ray_dir.x) - ray_start.x)/ray_dir.x;\n  float intresection_x = ray_start.x - ((ray_start.z*ray_dir.x)/ray_dir.z);\n  float intresection_y = ray_start.y - ((ray_start.z*ray_dir.y)/ray_dir.z);\n  return vec3(intresection_x, intresection_y, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n\tuv.x = uv.x*(iResolution.x/iResolution.y);\n    \n    camera global_camera;\n    global_camera.position = vec3(-15,0,5.5);\n    global_camera.rotation = vec3(1,0,0);\n    float new_time = sin(iTime*4.0+PI_half)*cos(2.0*iTime);\n    float new_time2 = sin(iTime*2.0)*cos(8.0*iTime+PI_half);\n    vec4 new_cam_rotation = rotationMatrix(vec3(0,0,1), new_time/128.0)*vec4(global_camera.rotation,1.0);\n    new_cam_rotation = rotationMatrix(vec3(0,1,0), new_time2/128.0)*new_cam_rotation;\n    global_camera.rotation = new_cam_rotation.xyz;\n    //sin(x)*cos(2*x)\n    global_camera.fov;\n     \n    material bacground_mat = create_material(vec3(0,0,0), 0.5, 100.0, 0.0, 0.0, 0.0);\n    material test_mat = create_material(vec3(1,1,1), 0.5, 100.0, 0.0, 0.0, 0.0);\n    \n    //intresection prepare\n    sphere_shape shapes_array[full_shpere_count];\n    \n    intresection base_intresection;\n    base_intresection.distance_far = 999999999.0;\n    base_intresection.cur_material = bacground_mat;\n    base_intresection.position = vec3(1,0,0) * 100.0;\n    base_intresection.normal = normalize(vec3(1,0,0));\n    \n    intresection intresection_array[max_intresections];\n    for(int i=0;i<max_intresections;i++)\n    {\n        intresection_array[i] = base_intresection;\n\n    }\n    int current_intresection = 0;\n    \n    //lights create\n    \n    light lights_array[lights_count];\n    lights_array[0] = create_light(vec3(sin(iTime)*15.0,cos(iTime)*15.0,20.0), vec3(0.5,0.75,1), 0.5, true);\n    lights_array[1] = create_light(vec3(sin(iTime+PI)*15.0,cos(iTime+PI)*15.0,20.0), vec3(1,0.5,0.6), 0.5, true);\n    lights_array[2] = create_light(vec3(0,0,200.0), vec3(0.8,0.8,1.0), 0.25, true);\n    //lights_array[3] = create_light(vec3(-20,0,10), vec3(1.0,1.0,1.0), 0.5, false);\n    \n    //spheres create\n    float circle_diameter = 2.5;\n  \tfloat shpere_count_float = (PI*2.0)/float(shpere_count);\n    circle_diameter = (cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+3.0;\n    \n    float sphere_radius_din =  ((cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+3.5)/4.5;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float*float(i))*circle_diameter,cos(shpere_count_float*float(i))*circle_diameter,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[i].position = new_shpere_pos.xyz;\n        shapes_array[i].radius = sphere_radius_din;\n        shapes_array[i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    float circle_diameter_02 = 2.5;\n  \tfloat shpere_count_float_02 = (PI*2.0)/float(shpere_count);\n    circle_diameter_02 = ((cos(iTime*4.0 - 0.5) + cos(iTime*8.0 + PI/1.6 - 0.5) + cos(iTime*8.0 - PI/1.6 - 0.5))+3.0)/1.5;\n    \n    float sphere_radius_din_02 =  ((cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+2.75)/4.5;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_02*float(i) + PI/8.0)*circle_diameter_02,cos(shpere_count_float_02*float(i)+ PI/8.0)*circle_diameter_02,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[8+i].position = new_shpere_pos.xyz;\n        shapes_array[8+i].radius = sphere_radius_din_02;\n        shapes_array[8+i].cur_material = test_mat;\n\t}\n    \n    float circle_diameter_03 = 2.5;\n  \tfloat shpere_count_float_03 = (PI*2.0)/float(shpere_count);\n    circle_diameter_03 = ((cos(iTime*4.0 - 1.0) + cos(iTime*8.0 + PI/1.6 - 1.0) + cos(iTime*8.0 - PI/1.6 - 1.0))+2.5)/2.0;\n    \n    float sphere_radius_din_03 =  ((cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+2.0)/5.0;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_03*float(i))*circle_diameter_03,cos(shpere_count_float_03*float(i))*circle_diameter_03,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[16+i].position = new_shpere_pos.xyz;\n        shapes_array[16+i].radius = sphere_radius_din_03;\n        shapes_array[16+i].cur_material = test_mat;\n\t}\n    \n    \n    float circle_diameter_04 = 18.0;\n  \tfloat shpere_count_float_04 = (PI*2.0)/float(20);\n    \n    float sphere_radius_din_04 =  2.0;\n    \n    \n    for(int i=0;i<20;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_04*float(i) + 0.0)*circle_diameter_04,cos(shpere_count_float_04*float(i) + 0.0)*circle_diameter_04,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(acos(new_shpere_pos.x/length(new_shpere_pos))*4.0 + iTime)*2.0 + (1.0/(5.0*cos(iTime*4.0)-6.0))*10.0 + 10.0;\n        new_shpere_pos.z =new_shpere_pos.z + ((10.0/(5.0*cos(iTime*4.0 + sin(asin(new_shpere_pos.y/length(new_shpere_pos)))*5.0 )-7.0))+5.0)*4.0+1.0;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(iTime*2.0);\n        \n        shapes_array[24+i].position = new_shpere_pos.xyz;\n        shapes_array[24+i].radius = sphere_radius_din_04;\n        shapes_array[24+i].cur_material = test_mat;\n\t}\n    \n    float circle_diameter_05 = 55.0;\n  \tfloat shpere_count_float_05 = (PI*2.0)/float(20);\n    \n    float sphere_radius_din_05 =  2.0;\n    \n    \n    for(int i=0;i<20;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_05*float(i) + 0.0)*circle_diameter_05,cos(shpere_count_float_05*float(i) + 0.0)*circle_diameter_05,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(acos(new_shpere_pos.x/length(new_shpere_pos))*4.0 + iTime)*2.0 + (1.0/(5.0*cos(iTime*4.0)-6.0))*10.0 + 10.0;\n        new_shpere_pos.z =new_shpere_pos.z + ((10.0/(5.0*cos(iTime*4.0 + cos(acos(new_shpere_pos.x/length(new_shpere_pos)))*5.0 )-7.0))+5.0)*4.0+1.0;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(iTime*2.0);\n        \n        shapes_array[44+i].position = new_shpere_pos.xyz;\n        shapes_array[44+i].radius = sphere_radius_din_05;\n        shapes_array[44+i].cur_material = test_mat;\n        shapes_array[44+i].cur_material.color = vec3(0.2,0.2,0.2);\n\t}\n    \n\n    vec3 ray_start = global_camera.position;\n    vec4 ray_dir = rotationMatrix(vec3(0,0,1), uv.x)*vec4(global_camera.rotation,1.0);\n    ray_dir = rotationMatrix(vec3(0,1,0), uv.y)*vec4(ray_dir);\n    bool isIntersected = false;\n    \n    for(int i=0;i<full_shpere_count;i++)\n    {\n        vec3 cur_inter = ray_sphere_intersect(ray_start, ray_dir.xyz, shapes_array[i]);\n\t\t\n        \n        if(cur_inter != vec3(0,0,0))\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = shpere_get_normal(shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n        }\n\t}\n\n    vec3 plane_intr_point = ray_plane_intersect(ray_start, ray_dir.xyz);\n    if(plane_intr_point != vec3(0,0,0))\n    {\n        isIntersected = true;\n    \tcurrent_intresection++;\n    \tintresection_array[current_intresection].position = plane_intr_point;\n    \tintresection_array[current_intresection].normal = vec3(0,0,1); \n    \tintresection_array[current_intresection].cur_material = test_mat;\n    \tintresection_array[current_intresection].distance_far = distance(global_camera.position, plane_intr_point);\n    }\n\n    //sort intersections\n    bool isSorted = false;\n    do \n    {\n        isSorted = true;\n        for(int i=0;i<max_intresections-1;i++)\n    \t{\n        \tif (intresection_array[i].distance_far > intresection_array[i+1].distance_far)\n            {\n                intresection intresection_tmp = intresection_array[i];\n                intresection_array[i] = intresection_array[i+1];\n                intresection_array[i+1] = intresection_tmp;\n                isSorted = false;\n            }\n    \t}\n    }\n    while(!isSorted);\n    \n    \n    vec3 col = vec3(0,0,0);\n    \n    if(isIntersected)\n    {\n        for(int i=0;i<lights_count;i++)\n        {\n            vec3 light_dir = normalize(lights_array[i].position - intresection_array[0].position);\n            float light_intencity = dot(light_dir,intresection_array[0].normal);\n\n            bool isShadow = false;\n\n                for(int i=0;i<full_shpere_count;i++)\n                {\n                    vec3 cur_inter = ray_sphere_intersect(intresection_array[0].position + light_dir*0.01, light_dir, shapes_array[i]);\n                    if(cur_inter != vec3(0,0,0))\n                    {\n                        isShadow = true;\n                    }\n                }\n\n\n            if(!isShadow)\n            {\n                col = col + intresection_array[0].cur_material.color*light_intencity*lights_array[i].intension*lights_array[i].color;\n\n                vec3 refl_vec = reflect(light_dir ,intresection_array[0].normal);\n                float phong_highlight = dot(refl_vec, ray_dir.xyz);\n                phong_highlight =  pow(clamp(phong_highlight, 0.0, 1.0),10.0)*0.5;\n                col = col + phong_highlight;\n            }\n        }\n    }\n    col = clamp(col, vec3(0,0,0), vec3(1,1,1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 334, 334, 357], [359, 359, 404, 404, 1032], [1198, 1198, 1343, 1343, 1678], [1819, 1819, 1907, 1907, 2081], [2083, 2083, 2143, 2143, 2195], [2197, 2197, 2279, 2279, 2806], [2904, 2904, 2982, 2982, 3161], [3353, 3353, 3409, 3409, 3740], [3742, 3742, 3799, 3849, 14528]], "test": "timeout"}
{"id": "3sfcWN", "name": "Coronavirus remix jam", "author": "maxbittker", "description": "☣️🦠 😷\n\nWhile we're stuck at home avoiding becoming a transmission vector, let's transmit some `vec3`s 😈.\n\nTo participate, remix this shader! \n\nIn particular,  you can make use of the coronavirus SDF on line 51, `virus`, \n\n- char stiles & max bittker\n\n", "tags": ["2d", "sdf", "jam", "coronavirus", "covid19"], "likes": 4, "viewed": 255, "published": "Public API", "date": "1584766150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//    _____ _      _       _____ _               _\n//   / ____(_)    | |     / ____| |             | |\n//  | (___  _  ___| | __ | (___ | |__   __ _  __| | ___ _ __\n//   \\___ \\| |/ __| |/ /  \\___ \\| '_ \\ / _` |/ _` |/ _ \\ '__|\n//   ____) | | (__|   <   ____) | | | | (_| | (_| |  __/ |\n//  |_____/|_|\\___|_|\\_\\ |_____/|_| |_|\\__,_|\\__,_|\\___|_|\n//  🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠🦠\n//\n// Coronavirus Shader Demo Chain Mail\n//\n// Mutate this shader and \"retransmit\" it!\n// Be sure to tag \"coronavirus\"\n\n#define PI 3.1415926538\n#define TAU 6.2831853076\n#define spokes 5.0\n\n// THESE ARE SOME HELPER FUNCTIONS :-)\n\n// smooth minimum\nfloat smin(float a, float b, float k) {\n  float res = exp2(-k * a) + exp2(-k * b);\n  return -log2(res) / k;\n}\n\n// rotate a in input vec2 around its origin;\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\n// how far a point p is from the line segment from a to b\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\n////// END OF HELPER FUNCTIONS!\n\n// Draws a cool virus!\nfloat virus(vec2 input_pos, vec2 offset, float rotation, float scale) {\n\n  // prepare the coordinates based on the input transformations.\n  vec2 pos = rotate(input_pos + offset, rotation) / scale;\n  float angle = atan(pos.y, pos.x);\n\n  // this forms the middle blobby part of the virus:\n  float sphere = (length(pos) - 0.6); // the base\n  float wave = (pow(sin(angle * spokes), 6.) *\n                0.31); // goes up and down around the circle\n  float body = sphere - wave + (sin(sin(angle * 40.)) * 0.005);\n\n  // These are the lil round nubs of the crown\n  float repeatedAngle = floor((angle + .666) * spokes / PI) / spokes * PI;\n  repeatedAngle += -.31;\n\n  float boopRadius = 0.9;\n  boopRadius += sin(repeatedAngle*8. +iTime *4.) * 0.004;\n  float angleSweep = TAU / 100.;\n\n  float startAngle = repeatedAngle - angleSweep;\n  float endAngle = repeatedAngle + angleSweep;\n\n  vec2 dotStart = vec2(cos(startAngle), sin(startAngle)) * boopRadius;\n  vec2 dotEnd = vec2(cos(endAngle), sin(endAngle)) * boopRadius;\n  float crown = sdSegment(pos, dotStart, dotEnd) - 0.1;\n\n  // Combine the nubs and body with smoothing\n  return smin(crown, body, 40.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) *\n            2.0; // (0,0) is in the center of the screen\n\n  uv.x *= iResolution.x /\n          iResolution.y; // sadly the screen is not square, we must fix uv ratio\n\n  // Background color\n  vec3 col = vec3(1.000, 0.891, 0.674);\n\n  // First Virus:\n  vec2 offset = vec2(0.2, 0.3 + sin(iTime * 3.) * 0.1);\n  float rotation = sin(iTime * 3.) * 0.4 - iTime * 0.2;\n  float scale = 0.5 + sin(iTime * 4.) * 0.01;\n\n  float virus1 = virus(uv, offset, rotation, scale);\n\n  // threshhold our SDF gradient to make color regions.\n\n  if (virus1 < 0.0) {\n\n    // green inside\n    col *= vec3(0.500, 0.7567, 0.429);\n    col *= 1.0 + (uv.y + 0.5) * 0.2;\n\n  } else if (virus1 < 0.04) {\n    // pink border\n    col = vec3(0.800, 0.567, 0.629);\n  }\n\n  // Second Virus:\n  offset = vec2(-0.3, -0.33 + sin(iTime * 6.) * 0.05);\n  rotation = iTime * 2.;\n  scale = 0.4;\n\n  float virus2 = virus(uv, offset, rotation, scale);\n\n  if (virus2 < 0.0) {\n    // green inside\n    col *= vec3(0.200, 0.467, 0.329);\n    col *= 1.0 + (uv.y + 0.5) * 0.2;\n  } else if (virus2 < 0.04) {\n    // pink border\n    col = vec3(0.800, 0.567, 0.629);\n  }\n\n  col.yz -= length(pow(uv, vec2(4.0)) * vec2(0.015)); // add the red\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 684, 723, 723, 793], [795, 840, 870, 870, 958], [960, 1018, 1068, 1068, 1192], [1227, 1250, 1321, 1387, 2397], [2399, 2399, 2454, 2454, 3732]], "test": "timeout"}
{"id": "3sfcWX", "name": "Project 1", "author": "Witiza", "description": "testing", "tags": ["bymarcgarcaandlorinportella"], "likes": 0, "viewed": 92, "published": "Public", "date": "1585668992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----- DEFINITIONS -----\n#define REF_ITERARATIONS 2\n#define REF_MIX 0.2\n\n\n//--------- GLOBALS ---------\nvec3 CamPos = vec3(0.0,0.0,1.0);\nvec3 Plane = vec3(0.0,-1.0,0.0);\nvec3 Sky = vec3(0.0,50.0,0.0);\nvec3 LookAt = vec3(0.0,0.0,-3.0); \nfloat ambientTerm=0.05;\n\nbool fog = true;\nvec3 fogColor = vec3(1.0);\nfloat fogFactor = -1.0;\nfloat fogStart = 0.1;\nfloat fogEnd = 200.0;\n\n\nmat3 rotationMatrix = mat3(1);\nfloat zoom = 1.0;\nfloat cameraSpeed = 10.0;\n\n//- ACTIVATE ANTIALIASING -\nbool antialiasing = true;\nbool quincuxAntialiasing = false;\n\n//--- TEXTURE SELECTOR ---\nbool otherTexture = false;\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n};\n\nstruct Material\n{\n    bool transparent;\n    vec3 color;\n    float kAmbient;\n    float kDiffuse;\n    float kSpecular;\n    float shininess;\n    float fresnel;\n    float kFresnel;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\n// ------------ SPHERES --------------\nSphere spheres[3]=Sphere[3](\n    Sphere(vec3(-3.0,1.0,-3.0),1.0,Material(false,vec3(1.0,0.5,0.0),1.0,1.0,1.0,32.0,10.0,0.1)),\n    Sphere(vec3(3.0,1.0,-3.0),1.0,Material(false,vec3(0.0,0.5,1.0),0.5,1.0,1.0,256.0,5.0,0.3)),\n    Sphere(vec3(0.0,1.0,-3.0),1.0,Material(true,vec3(1.0),0.0,1.0,1.0,32.0,0.2,0.5))\n);\n\nMaterial planeMaterial=Material(false,vec3(1.0),0.5,0.5,1.0,32.0,10.0,0.2);\n\n// ------------- LIGHT ------------------\nLight lightSource = Light(vec3(-10.0,10.0,0.0), vec3(1.0,1.0,1.0));\n\nfloat rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(in vec2 fragCoord)\n{\n    vec2 tile = vec2(fragCoord/100.0);\n    vec2 tileMax = floor(tile);\n    \n    vec2 tile_right = vec2(tileMax.x+1.0,tileMax.y);\n    vec2 tile_up = vec2(tileMax.x,tileMax.y+1.0);\n    vec2 tile_diag = vec2(tileMax.x+1.0,tileMax.y+1.0);\n\n    float tileColor_1 = rand(tileMax);\n    float tileColor_2 = rand(tile_right);\n    float tileColor_3 = rand(tile_up);\n    float tileColor_4 = rand(tile_diag);\n    \n    float mixFactor_x=smoothstep(0.0,1.0,fract(fragCoord/100.0).x);\n    \n    float mix_1=mix(tileColor_1,tileColor_2,mixFactor_x);\n\tfloat mix_2=mix(tileColor_3,tileColor_4,mixFactor_x);\n    \n    float mixFactor_y = smoothstep(0.0,1.0,fract(fragCoord/100.0).y);\n\n    float finalMix=mix(mix_1,mix_2,mixFactor_y);\n    \n    return finalMix;\n}\n\nvec3 BrownianNoise(in vec2 fragCoord)\n{\n   \tvec3 color = vec3(0.0);\n    float a =0.5;\n    float f=1.0;\n    \n   \tfor(int i=0; i<8;i++)\n   \t{\n    \tcolor.xy += a*noise(f*fragCoord);\n        color.y *=0.8;\n        a*=0.5;\n        f*=2.0;\n   \t}\n    \n\treturn 1.0-color;\n}\n\n//https://www.shadertoy.com/view/lsXGzf\nvoid Input()\n{\n\n    vec4 mouse = iMouse;\n    if(mouse.z > 0.0)\n    {\n        vec2 displacement = (mouse.xy-mouse.zw);\n        if(length(displacement) != 0.0)\n        {\n        displacement = displacement/cameraSpeed;\n        CamPos.x += displacement.x;\n        zoom += abs(displacement.x)/(cameraSpeed/2.0);\n        zoom += abs(displacement.y)/(cameraSpeed/2.0);\n        CamPos.z -= abs(displacement.x)/(cameraSpeed/4.0);\n        CamPos.z -= abs(displacement.y)/(cameraSpeed/4.0);\n        CamPos.y -= displacement.y;\n        }\n    }\n}\n\nvoid calculateRotationMatrix()\n{\n    vec3 ez = normalize(CamPos-LookAt);\n    vec3 ex = normalize(cross(vec3(0.0,-1.0,0.0),ez));\n    vec3 ey = cross(ex,ez);\n\n    rotationMatrix[0][0] = ex.x;\n    rotationMatrix[0][1] = ex.y;\n    rotationMatrix[0][2] = ex.z;\n    rotationMatrix[1][0] = ey.x;\n    rotationMatrix[1][1] = ey.y;\n    rotationMatrix[1][2] = ey.z;\n    rotationMatrix[2][0] = ez.x;\n    rotationMatrix[2][1] = ez.y;\n    rotationMatrix[2][2] = ez.z;  \n}\n            \nvec3 RayCasting(in vec2 fragCoord)\n{\n    vec2 normCoords=fragCoord/iResolution.xy;\n    float AR = iResolution.x/iResolution.y;\n    vec2 unitCoords= (normCoords-0.5)*2.0;\n    unitCoords.x*=AR;\n    vec3 finalCoord=vec3(unitCoords,0.0);\n    \n    return normalize(finalCoord-vec3(0.0,0.0,zoom));\n}\n\nfloat Intersection(in vec3 plane, in vec3 ray)\n{\n    float t = (plane.y-CamPos.y)/ray.y;\n    \n    return t;\n}\n\n\nvec3 IntersectionPoint(vec3 ray, vec3 point, vec3 plane)\n{\n    float t = (plane.y-point.y)/ray.y;\n    \n    return point+t*ray;\n}\n\nvoid getFogFactor(float dist)\n{\n    fogFactor = (fogEnd-dist)/(fogEnd-fogStart);\n}\n\n\nvec4 PlaneColor(vec3 ray, vec3 point, bool is_reflection)\n{\n    vec4 ret = vec4(0.0);\n    \n    if(Intersection(Plane,ray)>0.0)\n    {\n        vec3 point = IntersectionPoint(ray,point,Plane);\n        \n        if(!is_reflection)\n        \tgetFogFactor(length(point-CamPos));\n        \n        vec2 tileCoords = point.xz;\n        vec2 tile = floor(tileCoords);\n        \n        float sum = tile.x+tile.y;\n        \n        if(mod(sum,2.0)==0.0)\n        {\n            ret.xyz=vec3(0.0);\n        }\n        else\n        {\n            ret.xyz=vec3(1.0);\n        }        \n        \n        ret.w = 1.0;\n        \n    \t//Ambient Light\n    \tvec3 ambient = vec3(0.0);\n    \tvec3 ambientLight = planeMaterial.kAmbient*lightSource.color;\n    \tambient = ambientLight * ret.xyz;\n    \t\n    \t//Diffuse\n    \tvec3 diffuse = vec3(0.0);\n    \tvec3 lightDir =  normalize(lightSource.position-point);\n    \tvec3 normal = vec3(0.0,1.0,0.0);\n    \tfloat diff = max(dot(lightDir,normal),0.0);\n    \tvec3 diffLight=planeMaterial.kDiffuse*lightSource.color;\n    \tdiffuse=diffLight*diff*ret.xyz;\n    \t\n    \t//Spectacular\n    \tvec3 spectacular = vec3(0.0);\n    \tvec3 viewDir = normalize(CamPos - point);\n    \tvec3 halfway = normalize((viewDir + lightDir)/2.0);\n    \tfloat shininess = planeMaterial.shininess;\n    \tfloat spec = pow(max(dot(normal,halfway),0.0),shininess);\n    \tvec3 specularLight = planeMaterial.kSpecular*lightSource.color;\n    \tspectacular = spec*specularLight;\n    \t\n    \tret.xyz = ambient+diffuse+spectacular;\n    }\n    \n    return ret;\n}\n\nvec4 SkyColor(vec3 ray, vec3 point, bool is_reflection)\n{\n    vec4 ret = vec4(0.0);\n    \n    if(Intersection(Sky,ray)>0.0)\n    {\n        vec3 point = IntersectionPoint(ray,point,Sky);\n        if(!is_reflection)\n        \tgetFogFactor(length(point.xz-CamPos.xz));\n        \n        //Adding movement\n        ret.xyz=BrownianNoise(point.xz - iTime*25.0);\n        \n        ret.w = 1.0;\n    }\n    \n    return ret;\n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\nvec4 SphereIntersection(vec3 ray,vec3 point, Sphere sphere,bool front)\n{\n    vec4 iPoint = vec4(0.0);\n    vec3 d=ray; \t\t\t\t\t//ray direction\n    vec3 L=sphere.position-point;\t//vector center-point\n    float t=dot(L,d);\t\t\t\t//projection L over d\n    vec3 p=point+t*d;\t\t\t\t//projection point\n   \t\t\n    float y=length(sphere.position-p);\n    \n    if(t>0.0)\n    {\n    \tfloat x=sqrt(pow(length(L),2.0)-pow(t,2.0));\n        if(x<sphere.radius)\n        {\n            float tcp=sqrt(pow(sphere.radius,2.0)-pow(x,2.0));\n    \t\n    \t\tfloat t_0=t-tcp;\t\t    //Front intersection\n    \t\tfloat t_1=t+tcp;\t\t    //Rare intersection (no needed)\n            \n            if(front)\n            {\n                vec3 sp = point+t_0*d; \t//surface point\n                iPoint=vec4(sp,1.0);\n            }\n            else\n            {\n                vec3 sp = point+t_1*d; \t//surface point\n                iPoint=vec4(sp,1.0);\n            }\n        }\n    }\n    \n    return iPoint;\n}\n\n\n// Selection of the nearest intersected object\nint FrontSphere(vec3 ray, vec3 origin)\n{\n    int sphere=-1;\n    float dist=0.0;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        vec4 intPoint = SphereIntersection(ray, origin, spheres[i],true);\n        if(intPoint.w == 1.0 && (sphere==-1 || length(intPoint.xyz-origin)<dist))\n        {\n            sphere=i;\n            dist = length(intPoint.xyz-origin);\n        }\n    }\n    \n    return sphere;\n}\n\nvec3 Lighting(vec3 sPoint, int idx)\n{\n    vec3 finalColor = vec3(0.0);\n    \n    //Ambient Light\n    vec3 ambient = vec3(0.0);\n    vec3 ambientLight = spheres[idx].material.kAmbient*lightSource.color;\n    ambient = ambientLight * spheres[idx].material.color;\n    \n    //Diffuse\n    vec3 diffuse = vec3(0.0);\n    vec3 lightDir =  normalize(lightSource.position-sPoint);\n    vec3 normal = normalize(sPoint-spheres[idx].position);\n    float diff = max(dot(lightDir,normal),0.0);\n    vec3 diffLight=spheres[idx].material.kDiffuse*lightSource.color;\n    diffuse=diffLight*diff*spheres[idx].material.color;\n    \n    //Spectacular\n    vec3 spectacular = vec3(0.0);\n    vec3 viewDir = normalize(CamPos - sPoint);\n    vec3 halfway = normalize((viewDir + lightDir)/2.0);\n    float shininess = spheres[idx].material.shininess;\n    float spec = pow(max(dot(normal,halfway),0.0),shininess);\n    vec3 specularLight = spheres[idx].material.kSpecular*lightSource.color;\n    spectacular = spec*specularLight;\n    \n    finalColor = (ambient+diffuse+spectacular);\n    return finalColor;\n}   \n\nvec3 CalculateUV(vec3 normal)\n{\n    float pi = 3.14159265;\n    float u = 0.5+((atan(normal.x,normal.z))/(2.0*pi));\n    float v = 0.5-(asin(normal.y)/pi);\n\t\n    if(otherTexture)\n        return vec3(texture(iChannel1,vec2(v,u)));\n    else\n        return vec3(texture(iChannel0,vec2(v,u)));\n\n}\n\nvec4 ReflectionRefractionColor(vec3 ray, vec3 point, vec3 normal, int idx, bool transparent)\n{\n    vec3 ref = vec3(0.0);\n    vec4 interPoint = vec4(0.0);\n    vec3 usedNormal=normal;\n    vec3 usedRay=ray;\n    vec3 usedPoint = point;\n    int usedIndex = idx;\n    bool usedTransparency=transparent;\n    vec4 totalColor=vec4(0.0);\n   \n    for(int i = 0; i<REF_ITERARATIONS;++i)\n    {\n    \t//Ray Calculation\n    \tif(!usedTransparency)\n    \t{\n    \t    ref = reflect(usedRay, usedNormal);\n    \t}\n    \telse\n    \t{\n    \t    //window glass\n    \t    float ref_index = 1.0;\n    \t    ref = refract(usedRay,usedNormal,ref_index);\n    \t    vec3 newhit = SphereIntersection(ref, usedPoint, spheres[usedIndex],false).xyz;\n    \t    vec3 newNormal = newhit-spheres[usedIndex].position;\n    \t    ref = refract(ref,newNormal,ref_index);\n    \t}\n    \t\n    \t// Plane reflection/refraction\n    \tif(PlaneColor(ref,usedPoint,true).w==1.0)\n    \t{\n    \t    interPoint=PlaneColor(ref, usedPoint,true);\n    \t    \n    \t    if(idx != -1)\n    \t    {\n    \t        vec3 test = IntersectionPoint(ref, usedPoint, Plane);\n    \t        \n    \t        for(int i=0;i<3;++i)\n    \t\t\t{\n    \t\t\t    if(SphereIntersection(normalize(lightSource.position - test),test,spheres[i],true).w==1.0)\n   \t\t\t\t\t{\n   \t\t\t\t    \tinterPoint.xyz-=vec3(0.5);\n   \t\t\t\t\t}\n    \t\t\t}\n    \t    }\n    \t}\n    \t\n    \t//Sky Reflection//refraction\n    \tif(SkyColor(ref,usedPoint,true).w==1.0)\n    \t{\n    \t    interPoint=SkyColor(ref, usedPoint,true);\n    \t}\n    \t\n    \tint frontSphere = FrontSphere(ref,usedPoint);\n    \t\n    \tif(frontSphere>-1)\n    \t{\n   \t\t\tvec4 sphereInter = SphereIntersection(ref,usedPoint,spheres[frontSphere],true);\n            \n            if(frontSphere == 0)\n       \t \t{\n            \tspheres[frontSphere].material.color=CalculateUV(normal);\n        \t}\n            \n   \t\t\tif(sphereInter.w == 1.0 && usedIndex!=frontSphere)\n   \t\t\t{\n                if(frontSphere == 0)\n       \t \t\t{\n            \t\tspheres[frontSphere].material.color=CalculateUV(normal);\n        \t\t}\n                \n   \t\t\t    interPoint.xyz = Lighting(sphereInter.xyz,frontSphere);\n    \t   \n                usedIndex=frontSphere;\n                usedNormal=normalize(vec3(sphereInter.xyz-spheres[frontSphere].position));\n                usedPoint=sphereInter.xyz;\n                usedRay=ref;\n                usedTransparency=spheres[frontSphere].material.transparent;\n   \t\t\t    interPoint.w=1.0;\n   \t\t\t}\n    \t}\n       \t\n        if(i==0 && interPoint.w==1.0)\n        {\n            totalColor = interPoint;\n        }\n        else\n        {\n            totalColor.xyz=mix(totalColor.xyz,interPoint.xyz,REF_MIX);\n        }\n    }\n    \n    return totalColor;      \n}   \n\nvec3 Render(in vec2 fragCoord)\n{\n   \n    \n    vec3 ray = RayCasting(fragCoord);\n    ray = rotationMatrix*ray;\n    \n    vec4 reflection = vec4(0.0);\n    vec3 ret=vec3(1.0-ray.y,1.0-ray.y,1.0-ray.y);\n    vec4 planeColor = PlaneColor(ray,CamPos,false);\n    vec4 skyColor = SkyColor(ray,CamPos,false);\n    vec3 skyPoint = IntersectionPoint(ray, CamPos,Sky);\n    vec3 hitPoint = IntersectionPoint(ray, CamPos,Plane);\n    \n    //getFogFactor(length(hitPoint-CamPos));\n    \n     // Rendering Plane\n    if(planeColor.w==1.0)\n   \t{\n   \t    ret=planeColor.xyz;\n        reflection = ReflectionRefractionColor(ray, hitPoint,vec3(0.0,1.0,0.0),-1,planeMaterial.transparent);\n         // Rendering Hard Shadows\n    \tfor(int i=0;i<3;++i)\n    \t{\n    \t    if(SphereIntersection(normalize(lightSource.position - hitPoint),hitPoint,spheres[i],true).w==1.0)\n   \t\t\t{\n   \t\t    \tret-=vec3(0.6);\n   \t\t\t}\n    \t}\n        \n        if(reflection.w == 1.0)\n        {\n            //Fresnel Calculation\n            float R = pow(1.0 + dot(ray, vec3(0.0,1.0,0.0)), planeMaterial.fresnel);\n    \t    R=min(planeMaterial.kFresnel+R,1.0);\n            ret = mix(ret,reflection.xyz,R);\n        }\n    }\n    \n     // Rendering Sky\n    if(skyColor.w==1.0)\n   \t{\n   \t    ret=skyColor.xyz;\n    }\n        \n    int frontSphere = FrontSphere(ray,CamPos); \n    \n\tif(frontSphere>-1)\n    {\n   \t\t// Rendering Spheres\n   \t\tvec4 sPoint=SphereIntersection(ray,CamPos, spheres[frontSphere],true);\n        \n        vec3 normal = normalize(sPoint.xyz-spheres[frontSphere].position);\n        \n        if(frontSphere == 0)\n       \t{\n           spheres[frontSphere].material.color=CalculateUV(normal);\n       \t}\n        \n\t\t   \t\t\n   \t\tif(planeColor.w==1.0)\n   \t\t{   \t    \n   \t\t    if(sPoint.w==1.0 && length(CamPos-sPoint.xyz)<length(CamPos-hitPoint))\n   \t\t\t{\n                getFogFactor(length(sPoint.xyz-CamPos));\n   \t\t    \tret=Lighting(sPoint.xyz,frontSphere);\n    \t        reflection = ReflectionRefractionColor(ray, sPoint.xyz, normal,frontSphere,spheres[frontSphere].material.transparent);\n   \t\t\t\t\n    \t        if(reflection.w == 1.0)\n    \t        {\n                    //Fresnel Calculation\n                    float R = pow(1.0 + dot(ray, normal), spheres[frontSphere].material.fresnel);\n                    R=min(spheres[frontSphere].material.kFresnel+R,1.0);\n    \t        \tret = mix(ret,reflection.xyz,R);\n                    \n    \t        }\n   \t\t\t}\n   \t\t}\n   \t\telse\n   \t\t{\n   \t\t    if(sPoint.w==1.0)\n   \t\t\t{\n                getFogFactor(length(sPoint.xyz-CamPos));\n   \t\t    \tret=Lighting(sPoint.xyz,frontSphere);\n\t\n    \t        reflection = ReflectionRefractionColor(ray, sPoint.xyz, normal,frontSphere,spheres[frontSphere].material.transparent);\n    \t        \n    \t        if(reflection.w == 1.0)\n    \t        {\n                    //Fresnel Calculation\n                    float R = pow(1.0 + dot(ray, normal), spheres[frontSphere].material.fresnel);\n    \t        \tR=min(spheres[frontSphere].material.kFresnel+R,1.0);\n    \t        \tret = mix(ret,reflection.xyz,R);\n    \t        }\n    \t     }\n   \t\t}\n    }\n    \n\tif(fogFactor != -1.0 && fog)\n    \t\tret = (1.0-fogFactor)*fogColor+fogFactor*ret;\n    \n    //return ret;\n    return vec3(ret);\n}\n\n/*http://blog.demofox.org/2015/04/22/quincunx-antialiasing/\n\nQuincunx anti aliasing works by using 5 samples per pixel in the following configuration:\n\n  B        C\n  *--------*\n  |   A    |\n  |   *    |\n  |        |\n  *--------*\n  D        E\n\n\tAll the samples combined have a weigth of 1, but the center one (A), has more weigth than the rest (0.5);\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0].position.y+=sin(iTime);\n    spheres[1].position.y+=sin(iTime+1.0);\n    spheres[2].position.y+=sin(iTime+2.0);\n    \n    Input();\n    calculateRotationMatrix();\n    \n    vec3 finalCol = vec3(0);\n\t\n\tif(antialiasing)\n    {\n    \tif(!quincuxAntialiasing)\n        {\n        \tfinalCol = Render(fragCoord)/4.0;\n        \tfinalCol += Render(fragCoord+vec2(0.5,0.0))/4.0;\n        \tfinalCol += Render(fragCoord+vec2(0.5,0.5))/4.0;\n        \tfinalCol += Render(fragCoord+vec2(0.0,0.5))/4.0;        \n        }\n        \n        if(quincuxAntialiasing)\n        {\n            finalCol = Render(fragCoord)/2.0;\n            finalCol += Render(fragCoord+vec2(-0.5,-0.5))/8.0;\n            finalCol += Render(fragCoord+vec2(-0.5,0.5))/8.0;\n            finalCol += Render(fragCoord+vec2(0.5,-0.5))/8.0;\n            finalCol += Render(fragCoord+vec2(0.5,0.5))/8.0;\n        }\n    \n        fragColor = vec4(finalCol,1.0);\n    }\n    else\n    {\n   \t\tvec3 col = Render(fragCoord);\n    \n\n    \t// Output to screen\n    \tfragColor = vec4(col,1.0);\n    }\n\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1449, 1449, 1470, 1470, 1537], [1539, 1539, 1571, 1571, 2312], [2314, 2314, 2353, 2353, 2579], [2581, 2621, 2635, 2635, 3155], [3157, 3157, 3189, 3189, 3614], [3628, 3628, 3664, 3664, 3921], [3923, 3923, 3971, 3971, 4032], [4035, 4035, 4093, 4093, 4163], [4165, 4165, 4196, 4196, 4247], [4250, 4250, 4309, 4309, 5768], [5770, 5770, 5827, 5827, 6179], [6181, 6308, 6380, 6380, 7265], [7268, 7315, 7355, 7355, 7714], [7716, 7716, 7753, 7753, 8784], [8789, 8789, 8820, 8820, 9079], [9081, 9081, 9175, 9175, 11751], [11756, 11756, 11788, 11788, 14947], [14949, 15303, 15359, 15359, 16396]], "test": "error"}
{"id": "3sfcz8", "name": "Infinite Stair", "author": "yasuo", "description": "Infinite Stair", "tags": ["stair"], "likes": 12, "viewed": 267, "published": "Public API", "date": "1584093149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 80\n#define MAX_DIST 50.\n#define SURF_DIST .003\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat stairPart(vec3 p) {\n    vec3 p2 = p;\n    p2 += vec3(0.1,0.1,0.0);\n    p2= abs(p2)-vec3(0.25,0.25,2.0);\n    p = abs(p)-vec3(0.2,0.2,0.7);\n    float b = max(p.x,max(p.y,p.z));\n    float b2 = max(p2.x,max(p2.y,p2.z));\n    b = max(-b2,b);\n    return b;\n}\n\nfloat stair(vec3 p, int drawBall){\n    vec3 pref = p;\n    float b = stairPart(p);\n    float b2 = stairPart(p-vec3(-0.4,0.4,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(0.4,-0.4,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-0.8,0.8,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(0.8,-0.8,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-1.2,1.2,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-1.6,1.6,0.0));\n    b = min(b,b2);\n    b2 = stairPart(p-vec3(-2.0,2.0,0.0));\n    b = min(b,b2);\n    p = abs(p-vec3(1.7,-1.0,0.0))-vec3(0.7,0.03,0.7);\n    float b3 = max(p.x,max(p.y,p.z));\n    b = min(b,b3);\n    \n    \n    if(drawBall == 1){\n        \n        p = pref;\n        p = abs(p-vec3(2.7,-1.0,0.0))-vec3(0.35,0.03,0.7);\n        float b4 = max(p.x,max(p.y,p.z));\n        b = min(b,b4);\n        p = pref;\n        p = abs(p-vec3(3.,0.2,0.0))-vec3(0.03,1.2,0.7);\n        float b5 = max(p.x,max(p.y,p.z));\n        b = min(b,b5);\n        p = pref;\n        p = abs(p-vec3(3.,0.2,0.0))-vec3(0.06,1.15,0.6);\n        float b6 = max(p.x,max(p.y,p.z));\n        b = max(-b6,b);\n        \n        float speed = 0.6;\n        float animTime = mod(iTime,speed*10.0);\n        float x = 0.0;\n        x += animscene(animTime, 0.0, speed)*0.4;\n        x += animscene(animTime, speed, speed)*0.4;\n        x += animscene(animTime, speed*2.0, speed)*0.4;\n        x += animscene(animTime, speed*3.0, speed)*0.4;\n        x += animscene(animTime, speed*4.0, speed)*0.4;\n        x += animscene(animTime, speed*5.0, speed)*0.4;\n        x += animscene(animTime, speed*6.0, speed)*0.4;\n        x += animscene(animTime, speed*7.0, speed)*0.4;\n        x += animscene(animTime, speed*8.0, speed*2.0)*2.0;\n\n        float y = 0.0;\n        y += animscene(animTime, speed, speed*0.2)*-0.38;\n        y += animscene(animTime,speed+speed, speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*2.0), speed*0.1)*-0.42;\n        y += animscene(animTime,speed+(speed*3.0), speed*0.1)*-0.42;\n        y += animscene(animTime,speed+(speed*4.0), speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*5.0), speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*6.0), speed*0.1)*-0.38;\n        y += animscene(animTime,speed+(speed*7.0), speed*0.1)*-0.38;\n\n        float s = length(pref-vec3(-2.0+x,2.4+y,0.0))-0.2;\n        b = min(b,s);\n    }\n    \n    return b;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 0.25;\n    \n    p.y+= iTime*1.5;\n    p.y=mod(p.y,12.6)-6.3;\n    p.y-= 4.20;\n    \n    float b = stair(p,0);\n    float b2 = stair((p+vec3(-1.7,3.17,2.5))*matRotateY(radians(90.0)),1);\n    float b3 = stair((p+vec3(0.8,3.17*2.0,4.2))*matRotateY(radians(-180.0)),0);\n    float b4 = stair((p+vec3(2.5,3.17*3.0,1.7))*matRotateY(radians(-90.0)),1);\n    b = min(b,min(b2,min(b3,b4)));\n    \n    vec4 resB = vec4(vec3(0.8),b*0.6);\n\n    return resB;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0,0.0,0.0,0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, -6);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfcz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 574, 574, 665], [667, 667, 703, 703, 745], [747, 859, 906, 906, 947], [949, 949, 974, 974, 1205], [1207, 1207, 1241, 1241, 3569], [3571, 3571, 3593, 3593, 4096], [4098, 4098, 4131, 4131, 4396], [4398, 4398, 4422, 4422, 4623], [4625, 4625, 4659, 4659, 4973], [4975, 4975, 4998, 4998, 5354], [5356, 5356, 5398, 5398, 5593], [5595, 5595, 5652, 5652, 6355]], "test": "timeout"}
{"id": "3sfczf", "name": "Base warp fBM cineshader", "author": "trinketMage", "description": "Test for Cine shader \nps: https://cineshader.com/view/3sfczf", "tags": ["fbm"], "likes": 6, "viewed": 5402, "published": "Public API", "date": "1585215888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.02;\n    f += 0.1250*noise( p ); p = m*p*2.02;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    float f = func(p, on);\n\n\tvec4 col = vec4(vec3(f), (1./f )* .125);\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Base warp fBM\",\n\t\"description\": \"Noise\",\n\t\"model\": \"\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 78, 78, 107], [109, 109, 131, 131, 327], [329, 329, 351, 351, 610], [612, 612, 635, 635, 682], [684, 684, 707, 707, 766], [768, 768, 804, 804, 1105], [1107, 1107, 1164, 1164, 1375]], "test": "timeout"}
{"id": "3sfyD7", "name": "my sha_1", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 7, "viewed": 258, "published": "Public API", "date": "1584877085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Xor(float a, float b){\n return a*(1.-b)+   b*(1.-a);\n}\n\nfloat HexDist(vec2 p){\n\tp = abs(p);\n    float c= dot(p,normalize(vec2(1,1.73)));\n    c=max(c,p.x);   \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.465*iResolution.xy)/iResolution.y;\n\n    uv*=Rot(3.1415926535/3.);\n    vec3 col = vec3(0);\n    float d=HexDist(uv);\n    uv*=10.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float m=0.1;\n    float c=0.1;\n    float t = iTime;\n    \n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n    \t\tvec2 offs = vec2(x,y);\n            float d=HexDist(gv+offs);\n            float dist=length(id-offs)*.3;\n            float r = mix(.3,1.5,sin(dist-t)*.5+.5);\n            c=Xor(c,smoothstep(r,r*0.95,d));\n    \t}\n    }\n    col+=c;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 77], [79, 79, 107, 107, 139], [141, 141, 163, 163, 258], [260, 260, 317, 317, 932]], "test": "ok"}
{"id": "3sfyRr", "name": "Fractal storm 4", "author": "jarble", "description": "This storm is based on my [url=https://www.shadertoy.com/view/wlKXWt]jungle biome map[/url].\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "storm"], "likes": 2, "viewed": 212, "published": "Public API", "date": "1583947332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    fragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/(81.*81.));\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = mag;\n    fragCoord *= zoom*((iMouse.x+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        //forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 560, 608, 608, 955], [956, 956, 1004, 1004, 1351], [1353, 1353, 1401, 1401, 1748], [3689, 3689, 3733, 3733, 3869], [3871, 3871, 3905, 3905, 3934], [3936, 3936, 3964, 3964, 5039], [5041, 5041, 5116, 5116, 6145], [7325, 7325, 7401, 7401, 8479], [8628, 8628, 8702, 8702, 9593], [9736, 9736, 9810, 9810, 10200], [10327, 10327, 10411, 10411, 11484], [14814, 14814, 14871, 14871, 15385]], "test": "error"}
{"id": "3sfyW2", "name": "Moebius Gears", "author": "dr2", "description": "Escher in motion - impossible?", "tags": ["escher", "wheel", "gear", "impossible", "kinematics"], "likes": 26, "viewed": 292, "published": "Public API", "date": "1585554800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Moebius Gears\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm3 (vec3 p);\n\nmat3 vuMat;\nvec3 ltDir, qHit;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MobiusTDf (vec3 p, float r, float b, float ns, float da, float dMin)\n{\n  vec3 q;\n  float d, a, t;\n  p.xy = vec2 (- p.y, p.x);\n  q = vec3 (Rot2D (vec2 (length (p.xz) - r, p.y), 0.5 * atan (p.z, p.x)), 0.).xzy;\n  d = PrRoundBox2Df (q.xz, vec2 (b), 0.05);\n  DMINQ (1);\n  t = 0.15 * tCur + 0.5 * pi * da / ns;\n  q = p;\n  q.xz = Rot2D (q.xz, t);\n  a = 2. * pi * (floor (ns * atan (q.z, - q.x) / (2. * pi)) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 0.5 * (a + t));\n  d = SmoothMin (d, PrRoundBoxDf (q, vec3 (0.6 * b, 2.1 * b, 0.35 * (pi * r / ns)), 0.05), 0.2);\n  DMINQ (1);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, mobRad;\n  dMin = dstFar;\n  mobRad = 2.5;\n  q = p;\n  q.x -= mobRad + 0.55;\n  dMin = MobiusTDf (q.zxy, mobRad, 0.3, 24., 1., dMin);\n  q = p;\n  q.x += mobRad + 0.55;\n  q.x = - q.x;\n  dMin = min (dMin, MobiusTDf (q.zxy, mobRad, 0.3, 24., -1., dMin));\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = 20. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  }\n  return qBlk;\n}\n\nfloat BgCol (vec3 ro, vec3 rd, float scl)\n{\n  vec2 q;\n  q = smoothstep (0.03, 0.1, abs (mod (16. * scl * BlkHit (ro, rd) + 0.5, 1.) - 0.5));\n  return 1. - min (q.x, q.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vDotL = max (dot (vn, ltDir), 0.);\n    vDotL *= vDotL;\n    col = vec3 (0.85, 0.85, 0.9) * (0.3 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.7 * vDotL * vDotL) +\n       0.2 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    col *= 0.8 + 0.2 * Fbm3 (64. * qHit);\n    col = mix (col, vec3 (1.) * BgCol (ro, reflect (rd, vn), 1.), 0.03);\n  } else col = vec3 (0.1) * BgCol (ro, rd, 2.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi * sin (0.01 * pi * tCur);\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  dstFar = 50.;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -22.);\n  zmFac = 6.;\n  ltDir = vuMat * normalize (vec3 (0.2, 0.2, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfyW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[550, 550, 626, 626, 1172], [1174, 1174, 1196, 1196, 1490], [1492, 1492, 1525, 1525, 1701], [1703, 1703, 1724, 1724, 1970], [1972, 1972, 2004, 2004, 2495], [2497, 2497, 2540, 2540, 2669], [2671, 2671, 2706, 2706, 3262], [3279, 3279, 3335, 3335, 4340], [4342, 4342, 4388, 4388, 4435], [4437, 4437, 4484, 4484, 4531], [4533, 4533, 4555, 4555, 4593], [4595, 4595, 4617, 4617, 4655], [4657, 4657, 4702, 4702, 4805], [4807, 4807, 4837, 4837, 4950], [4952, 4952, 4988, 4988, 5194], [5228, 5228, 5252, 5252, 5371], [5373, 5373, 5398, 5398, 5623], [5625, 5625, 5646, 5646, 5801]], "test": "error"}
{"id": "3slczn", "name": "dot matrix spiral SPAZZ", "author": "HaleyHalcyon", "description": "A", "tags": ["spiral"], "likes": 3, "viewed": 203, "published": "Public", "date": "1584009738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nconst float PI_3 = PI / 3.0;\n\nfloat fn1(float x)\n{\n    return clamp(sin(x) + 0.5, 0., 1.);\n}\n\nfloat dots(vec2 uv, vec2 center)\n{\n    vec2 xy = uv - center;\n    return sqrt(xy.x * xy.x + xy.y * xy.y);\n}\n\nfloat g(float x)\n{\n    return (sin(x) + 1.) * 0.5;\n}\n\nvec3 hueToCol(float hue)\n{\n    return vec3(\n\t    g(hue),\n        g(hue + 2. * PI_3),\n        g(hue - 2. * PI_3)\n    );\n}\n\nvec3 mask(float m, vec3 col0, vec3 col1)\n{\n    return m * col1 + (1.0 - m) * col0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float speed = 24.;\n    float hue = PI * fract(iTime * 12.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 16.0;\n    vec2 gridUV = (uv - vec2(0.5)) * (1.8 - mod(iTime, 0.6) * 1.2);\n    vec2 rUV = round(gridUV) + vec2(0.5);\n    \n    //float distance = length(uv);\n    //float distance = pow(sqrt(uv.x*uv.x+uv.y*uv.y), 1./3.);\n    float dist = log(rUV.x*rUV.x+rUV.y*rUV.y);\n    float angle = atan(rUV.y, rUV.x);\n    \n    vec3 colBak = hueToCol(hue + 2. * PI_3);\n    vec3 colSpi = hueToCol(hue);\n    vec3 colAdd = hueToCol(hue - 2. * PI_3) - colSpi;\n    \n    // Time varying pixel color\n    float ring = 0.65 + 0.25 * sin(dist * 2.5 + iTime * 15.0 + PI);\n    \n    float dots = clamp((ring * 0.6 - dots(gridUV + vec2(0.5, 0.5), rUV)) * 8.8, 0.0, 1.0);\n    float spiral = fn1(dist - angle * 2.0 + iTime * speed * -2.5 + PI);\n\n    // Output to screen\n    fragColor = vec4(\n        mask(dots, colBak, (spiral * colAdd + colSpi))\n      , 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 79, 79, 121], [123, 123, 157, 157, 230], [232, 232, 250, 250, 284], [286, 286, 312, 312, 406], [408, 408, 450, 450, 492], [494, 494, 551, 551, 1665]], "test": "ok"}
{"id": "3slczX", "name": "Two wave Interference", "author": "jdan", "description": "Two waves interfering with each other", "tags": ["wave"], "likes": 0, "viewed": 56, "published": "Public", "date": "1585251541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ramp1 = length(uv - vec2(0.25, 0.5));\n    float ramp2 = length(uv - vec2(0.75, 0.5));\n    float period = 100.0;\n    \n    float wave1 = 0.5 + 0.5 * cos(ramp1 * period - 10.0*iTime);\n    float wave2 = 0.5 + 0.5 * cos(ramp2 * period - 10.0*iTime);\n    \n    vec3 base = vec3(0, 1, 1);\n\n    // Time varying pixel color\n    vec3 col = base * (wave1 + wave2) / 2.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 579]], "test": "ok"}
{"id": "3slyR2", "name": "Twisting triangles", "author": "elefAntti", "description": "Using slice renderer to draw prismatic, out of focus shapes", "tags": ["minimalistic", "prismatic"], "likes": 6, "viewed": 231, "published": "Public", "date": "1585164670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GammaValue 0.5\n#define VignetteStrength 1.1\n#define FocalLength 2.0\n\nfloat smax(float a, float b)\n{\n    return log(exp(a) + exp(b));\n}\n\nmat3 rot_y(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat3(c, 0.0 , -s,\n              0.0, 1.0, 0.0,\n               s, 0.0, c);\n}\n\nfloat prism( vec3 pos )\n{\n    vec3 side1 = vec3(0.0, -1.0, 0.0);\n    vec3 side2 = normalize(vec3(0.0, 1.0, 2.0));\n    vec3 side3 = normalize(vec3(0.0, 1.0, -2.0));\n    float r = 2.0;\n    return smax(dot(pos, side1) - r, \n               smax(dot(pos, side2) - r, \n                   dot(pos, side3) - r));\n}\n\nfloat distModel( vec3 pos, float time )\n{\n    float r = length(pos.xz);\n\treturn prism(rot_y(time + r * 0.3)*pos + (r - 5.0) * vec3(0.0, 0.4, 0.0));\n}\n\nfloat rayTrace( vec2 fragCoord, float time, float offset )\n{\n    vec2 position = fragCoord * -2.0 + 1.0;\n\n    vec3 rayDir = normalize(vec3( position, FocalLength + offset));\n\n    vec3 cameraPos = vec3( 0, 1.0, -20.0 );\n\n    float angle = time * 0.1;\n    vec3 normal = rot_y(-time) * vec3(cos(angle), sin(angle), 0.0);\n    float scale = abs(dot(rayDir, normal));\n\n    if(scale < 0.001)\n    {\n        return 0.0;\n    }\n    else\n    {\n        rayDir *=  1.0/scale;\n        vec3 curPos = cameraPos;\n        float fMinDist = 1000.0;\n        float stepLen = length(rayDir);\n        float totalIntensity = 0.0;\n        for(int i = 1; i < 30; ++i)\n        {\n            curPos += rayDir;\n            float fDistance = distModel( curPos, time );\n            fMinDist = min( fMinDist, abs(fDistance));\n            float intensity = smoothstep(.5, 0.05, abs(fDistance));\n            intensity *= exp(-(float(i) * stepLen)/10.0);\n            totalIntensity += intensity;\n        }\n        return totalIntensity;\n    }\n}\n\nvec3 rtMain(in vec2 uv, in float time)\n{\n    return vec3(\n        rayTrace(uv, time, 0.0f),\n        rayTrace(uv, time, 0.05f),\n        rayTrace(uv, time, 0.1f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5f)) * vec2(1.0, aspect) + vec2(0.5);\n    // Time varying pixel color\n    vec3 color = rtMain(uv, iTime * 0.3);\n\n    //Gamma\n    color.rgb = pow(color.rgb, vec3(GammaValue));\n\n    //Saturate channels\n    color.rgb = min(color.rgb, vec3(1.0));\n\n\n    //Vignette\n    color.rgb *= pow(1.0 - length(uv - vec2(0.5, 0.5)) * VignetteStrength, 0.5); \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 107, 107, 142], [144, 144, 169, 169, 313], [315, 315, 340, 340, 621], [623, 623, 664, 664, 772], [1783, 1783, 1823, 1823, 1946], [1948, 1948, 2005, 2005, 2508]], "test": "timeout"}
{"id": "3slyRN", "name": "Quarantine", "author": "supah", "description": "Bubble lamp", "tags": ["noise", "corona", "bubble", "lamp", "grain", "covid19", "quarantine"], "likes": 1, "viewed": 120, "published": "Public", "date": "1584283329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------\n\nAuthor: Fabio Ottaviani\n\nInstagram: https://instagram.com/supahfunk\nDribbble: https://dribbble.com/supahfunk\nTwitter: https://twitter.com/supahfunk\nCodepen: https://codepen.io/supah/\n\n--------------------*/\n    \n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n/*--------------------\nMain\n--------------------*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1.\n    uv -= 0.5; // -0.5 <> 0.5\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime;\n\n    // Noise\n    float n = snoise(vec3(uv.x * 2.4 - time * 0.1, uv.y * 1.8 - time * 0.2, 10. + time * 0.3));\n\n    // Circle\n    float dist = length(uv);\n    dist = smoothstep(.39, .385, dist);\n\n    // Color\n    vec3 color1 = vec3(smoothstep(.7, .69, n));\n    vec3 color2 = vec3(smoothstep(.2, .19, n));\n    color2 += vec3(uv.x, uv.y, 1.);\n    vec3 color = vec3(smoothstep(0.8, 0.01, length(uv)));\n    color += 1. - color1;\n    color -= 1. - color2;\n\n    // Grain\n    float grain = snoise(vec3(uv.x * 1000., sin(uv.y) * 1000., time * 0.8));\n    color += vec3(grain) * 0.2;\n    color *= dist;\n\n    // Output to screen\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 290, 311, 311, 348], [349, 349, 376, 376, 424], [426, 426, 447, 447, 2283], [2286, 2337, 2394, 2394, 3204]], "test": "ok"}
{"id": "3slyRX", "name": "[TWITCH] FM-2030's messenger", "author": "evvvvil", "description": "FM-2030's messenger - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "space", "beam", "glow", "robot", "scifi", "mountain", "spaceship", "structure", "industrial", "twitch", "improv"], "likes": 48, "viewed": 2484, "published": "Public API", "date": "1585248672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FM-2030's messenger - Result of an improvised live code session on Twitch\n// Thankx to crundle for the help and haptix for suggestions\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"I have a deep nostalgia for the future.\" - FM-2030\n\nvec2 z,v,e=vec2(.00035,-.00035); float t,tt,b,bb,g,gg;vec3 np,bp,pp,cp,dp,po,no,al,ld;//global vars. About as exciting as vegans talking about sausages.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. Box is the only primitve I hang out with, I find the others have too many angles and seem to have a multi-faced agenda.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like a midget wrestler covered in Mapple syrup.\nfloat smin(float a,float b,float h){ float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} //Smooth min function, because sometimes brutality isn't the answer. Put that in your pipe and smoke it, Mr Officer.\nfloat noi(vec3 p){ //Noise function stolen from Virgill who, like me, doesn't understand it. But, unlike me, Virgill can play the tuba.\n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);;\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);  \n}\nvec2 fb( vec3 p, float s ) // fb \"fucking bit\" function make a base geometry which we use to make spaceship and central structures using more complex positions defined in mp\n{ //fb just does a bunch blue hollow boxes inside eachother with a white edge on top + a couple of black bars going through to symbolise the lack of middle class cyclists incarcerated for crimes against fun. Stay boring, Dave, I'm watching you.\n  vec2 h,t=vec2(bo(p,vec3(5,5,2)),s); //Dumb fucking blue boxes (could also be said about Chelsea Football Club's fans)\n  t.x=max(t.x,-bo(p,vec3(3.5,3.5,2))); //Dig a hole in them blue boxes, and just like with Chelsea Football Club - less is more\n  t.x=abs(t.x)-.3; //Onion skin blue boxes for more geom\n  t.x=max(t.x,bo(p,vec3(10,10,1)));//Cut front & back of box to reveal onion edges. In reality onions are boring and have no edges, I suspect they listen to Coldplay or Muse. Yeah, Dave, I'm still watching you!\n  h=vec2(bo(p,vec3(5,5,2)),6); //Dumb fucking white boxes (could also be said about Tottenham Football Club's fans)\n  h.x=max(h.x,-bo(p,vec3(3.5,3.5,2))); //Dig hole in white boxes, make it hollow, just like Tottenham FC's trophy cabinet.\n  h.x=abs(h.x)-.1; //Onion skin the fucking white boxes for more geom\n  h.x=max(h.x,bo(p,vec3(10,10,1.4))); //Cut front & back of box to reveal onion edges. Onions are like Tottenham FC's style of football: they make people cry.\n  t=t.x<h.x?t:h; //Merge blue and white geom while retaining material ID\n  h=vec2(length(abs(p.xz)-vec2(2,0))-.2,3); //Black prison bars, to symbolise the meta-physical struggle of half eaten sausages.\n  t=t.x<h.x?t:h; return t; //Pack into a colourful sausage and hand it over to the feds...\n}\nvec2 mp( vec3 p )\n{ \n  bp=p+vec3(0,0,tt*10.);\n  np=p+noi(bp*.05)*15.+noi(bp*.5)*1.+noi(bp*4.)*.1+noi(bp*0.01)*20.; \n  vec2 h,t=vec2(np.y+20.,5); //TERRAIN\n  t.x=smin(t.x,0.75*(length(abs(np.xy-vec2(0,10.+sin(p.x*.1)*10.))-vec2(65,0))-(18.+sin(np.z*.1+tt)*10.)),15.); //LEFT TERRAIN CYLINDER\n  t.x*=0.5;  \n  pp=p+vec3(10,15,0);\n  pp.x+=sin(p.z*.02+tt/5.)*7.+sin(p.z*.001+20.+tt/100.)*4.; //ROAD POSITON\n  bp=abs(pp);bp.xy*=r2(-.785);\n  h=vec2(bo(bp-vec3(0,6,0),vec3(2,0.5,1000)),6); //ROAd WHITE\n  t=t.x<h.x?t:h;\n  h=vec2(bo(bp-vec3(0,6.2,0),vec3(1.,.8,1000)),3); //ROAd BLACK\n  t=t.x<h.x?t:h;  \n  cp=pp-dp; //SPACESHIP POSITON\n  cp.xy*=r2(sin(tt*.4)*.5);  \n  h=vec2(length(cp.xy)-(max(-1.,.3+cp.z*.03)),6); \n  h.x=max(h.x,bo(cp+vec3(0,0,25),vec3(10,10,30)));\n  g+=0.1/(0.1*h.x*h.x*(20.-abs(sin(abs(cp.z*.1)-tt*3.))*19.7));\n  t=t.x<h.x?t:h;\n  cp*=1.3;\n  for(int i=0;i<3;i++){ //SPACESHIP KIFS\n    cp=abs(cp)-vec3(-2,0.5,4); \n    cp.xy*=r2(2.0);     \n    cp.xz*=r2(.8+sin(cp.z*.1)*.2);     \n    cp.yz*=r2(-.8+sin(cp.z*.1)*.2);     \n  } \n  h=fb(cp,8.); h.x*=0.5;  t=t.x<h.x?t:h; //SPACESHIP  \n  pp.z=mod(pp.z+tt*10.,40.)-20.; //CENTRAL STRUCTURE POSITION  \n  pp=abs(pp)-vec3(0,20,0);  \n  for(int i=0;i<3;i++){ //CENTRAL STRUCTURE KIFS\n    pp=abs(pp)-vec3(4.2,3,0); \n    pp.xy*=r2(.785); \n    pp.x-=2.;\n  }  \n  h=fb(pp.zyx,7.); t=t.x<h.x?t:h; //CENTRAL STRUCTURE\n  h=vec2(0.5*bo(abs(pp.zxy)-vec3(7,0,0),vec3(0.1,0.1,1000)),6); //GLOWY LINES CENTRAL STRUCTURE\n  g+=0.2/(0.1*h.x*h.x*(50.+sin(np.y*np.z*.001+tt*3.)*48.)); t=t.x<h.x?t:h;\n  t=t.x<h.x?t:h; return t; // Add central structure and return the whole shit\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>250.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>250.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime+3.,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  dp=vec3(sin(tt*.4)*4.,20.+sin(tt*.4)*2.,-200.+mod(tt*30.,471.2388));\n  vec3 ro=mix(dp-vec3(10,20.+sin(tt*.4)*5.,40),vec3(17,-5,0),ceil(sin(tt*.4))),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(dp-vec3(10,15,0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.4,-.3)); //ld=light direction\n  co=fo=vec3(.1,.1,.15)-length(uv)*.1-rd.y*.1;//background is dark blueish with vignette and subtle vertical gradient based on ray direction y axis. \n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you at your best man speech.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(.4,.0,.1),vec3(.7,.1,.1),cos(bp.y*.08)*.5+.5); //al=albedo=base color, by default it's a gradient between red and darker red. \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=clamp(mix(vec3(.0,.1,.4),vec3(.4,.0,.1),sin(np.y*.1+2.)*.5+.5)+(z.y>7.?0.:abs(ceil(cos(pp.x*1.6-1.1))-ceil(cos(pp.x*1.6-1.3)))),0.,1.);\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); //Sp=specular, stolen from Shane\n    co=mix(sp+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.4)+.2)*(dif),fo,min(fr,.3)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0000007*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  }\n  fo=mix(vec3(.1,.2,.4),vec3(.1,.1,.5),0.5+0.5*sin(np.y*.1-tt*2.));//Glow colour is actual a grdient to make it more intresting\n  fragColor = vec4(pow(co+g*0.15*mix(fo.xyz,fo.zyx,clamp(sin(tt*.5),-.5,.5)+.5),vec3(.55)),1);// Naive gamma correction and glow applied at the end. Glow switches from blue to red hues - nice idea by Haptix - cheers broski\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 458, 482, 482, 523], [524, 670, 687, 687, 730], [731, 820, 856, 856, 922], [923, 1040, 1058, 1175, 1398], [1399, 1399, 1574, 1817, 3096], [3097, 3097, 3116, 3116, 4706], [4707, 4707, 4789, 4789, 5557], [5647, 5647, 5776, 5776, 8681]], "test": "timeout"}
{"id": "3slyW4", "name": "Interaction of colors", "author": "rrrzzz", "description": "from Josef Albers' book Interaction of Color", "tags": ["color", "abstract", "learning"], "likes": 2, "viewed": 54, "published": "Public", "date": "1584804201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid drawRectangle(float startX, float startY, float h, float w, vec2 uv, vec3 bcol, out vec3 col)\n{\n\tif(distance(uv.x, startX) < w && distance(uv.y, startY) < h/2.){\n        \tcol = bcol;\n        }\n}\n\nfloat getSmooth(float threshold, float deviation, float fragCoord){\n\treturn smoothstep(threshold - deviation, threshold + deviation, fragCoord);\n}\n\nvoid GetShape(int shape, vec2 uv, out vec3 col)\n{\n    vec3 l;\n    vec3 r;\n    vec3 brickCol;\n    float s;\n\n    \n    float aspect = iResolution.x / iResolution.y;\n\n    float w;\n    float h;\n    \n   \n    \tif (shape == 0){\n       brickCol = vec3(0.8,0.8,0.7);\n        w = .04;\n    \th = .45;\n\n    \t\t    \n    \tl = vec3(.6, 0.8, 0.9);\n        r = vec3(.9, .5, .0);\n        \n        float s = getSmooth(0.5, 0.0005, uv.x);\n        col = mix(l,r,s);\n        drawRectangle(.25, .5, h, w, uv, brickCol, col);\n        drawRectangle(.75, .5, h, w, uv, brickCol, col);    \n        }\n        \n        if (shape == 1){\n        brickCol = vec3(147./255.,112./255.,178./255.);\n        w = .04;\n    \th = .45;\n\n    \t\t    \n    \tl = vec3(81./255., 43./255., 93./255.);\n        r = vec3(160./255., 134./255., 198./255.);\n        \n         s = getSmooth(0.5, 0.0005, uv.x);\n        col = mix(l,r,s);\n        drawRectangle(.25, .5, h, w, uv, brickCol, col);\n        drawRectangle(.75, .5, h, w, uv, brickCol, col);\n        }\n        \n        if (shape == 2){\n        brickCol = vec3(107./255., 187./255., 199./255.);\n        w = 1.0;\n    \th = 0.5;\n        drawRectangle(0.0, 0.75, h, w, uv, brickCol, col);\n        \n        brickCol = vec3(250./255., 154./255., 22./255.);\n\t\tdrawRectangle(0.0, 0.25, h, w, uv, brickCol, col);\n        \n        w = 0.04;\n        h = .66;\n        brickCol = vec3(190./255., 177./255., 136./255.);\n        drawRectangle(.5, .5, h, w, uv, brickCol, col);\n        \n        brickCol = vec3(17./255., 17./255., 74./255.);\n        w = 1.0;\n    \th = 0.16666;\n        drawRectangle(0.0, 0.57, h, w, uv, brickCol, col);       \n        \n        brickCol = vec3(221./255., 215./255., 41./255.);\n        w = 1.0;\n    \th = 0.16666;\n        drawRectangle(0.0, 0.41, h, w, uv, brickCol, col);\n        }\n        \n        if (shape == 3){\n        vec3 lower = vec3(79./255., 79./255., 79./255.);\n        vec3 higher = vec3(237./255., 248./255., 253./255.);\n        col = mix(lower, higher, uv.y); \n        \n        \n        brickCol = vec3(140./255., 144./255., 138./255.);\n        w = 0.04;\n    \th = 0.66;\n        drawRectangle(0.5, 0.5, h, w, uv, brickCol, col);\n        }\n    \t    \n    \tvec3 lower;\t\n    \tvec3 higher; \n        if (shape == 4){\n        lower = vec3(14./255., 14./255., 14./255.);\n        higher = vec3(237./255., 248./255., 253./255.);\n        col = mix(lower, higher, uv.y); \n        \n        \n        brickCol = vec3(140./255., 144./255., 138./255.);\n        w = 0.04;\n    \th = 0.66;\n        drawRectangle(0.25, 0.5, h, w, uv, brickCol, col);\n        \n        brickCol = vec3(140./255., 144./255., 138./255.);\n     \n        drawRectangle(0.5, 0.5, h, w, uv, brickCol, col);\n        \n        brickCol = vec3(140./255., 144./255., 138./255.);\n    \n        drawRectangle(0.75, 0.5, h, w, uv, brickCol, col);\n        }\n        \n        if (shape == 5){\n        higher = vec3(127./255., 45./255., 168./255.);\n        lower = vec3(83./255., 71./255., 53./255.);          \n        \n        w = 1.0;\n    \th = 0.5;\n        drawRectangle(0.0, 0.75, h, w, uv, higher, col);\n        drawRectangle(0.0, 0.25, h, w, uv, lower, col);\n        \n        brickCol == vec3(131./255., 111./255., 106./255.);\n        \n        w = 0.03;\n        h = w * aspect * 2.;\n        \n     \tdrawRectangle(0.5, 0.75, h, w, uv, brickCol, col);\n        drawRectangle(0.5, 0.25, h, w, uv, brickCol, col);\n        }\n        \n        if (shape == 6){\n        higher = vec3(250./255., 248./255., 228./255.);\n        lower = vec3(9./255., 184./255., 201./255.);          \n        \n        w = 1.0;\n    \th = 0.5;\n        drawRectangle(0.0, 0.75, h, w, uv, higher, col);\n        drawRectangle(0.0, 0.25, h, w, uv, lower, col);\n        \n        brickCol = vec3(224./255., 202./255., 148./255.);\n        \n        w = 0.03;\n        h = w * aspect * 2.;\n        w = 0.03 * 1.75;\n        \n     \tdrawRectangle(0.5, 0.75, h, w, uv, brickCol, col);\n        \n        brickCol = vec3(167./255., 194./255., 147./255.);\n        \n        drawRectangle(0.5, 0.25, h, w, uv, brickCol, col);\n        }     \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;    \n\tint shape = int(floor(mod(iTime/2.0, 7.0)));\n    vec3 col;\n    vec3 col1;\n    vec3 col2;\n    \n    GetShape(shape, uv, col1);\n    \n    shape++;\n    shape = shape > 6 ? 0 : shape;\n\tGetShape(shape, uv, col2);\n    \n    col = mix(col1, col2, smoothstep(0.0, 1.0,mod(iTime/2.0, 1.0)));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 102, 102, 201], [203, 203, 270, 270, 349], [351, 351, 400, 400, 4411], [4415, 4415, 4472, 4472, 4836]], "test": "ok"}
{"id": "3slyW7", "name": "RayMarch Practice", "author": "GuillemDomenech", "description": "RayMarch Practice", "tags": ["raymarching"], "likes": 1, "viewed": 47, "published": "Public", "date": "1584920548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 point)\n{\n    vec4 sphere = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(point - sphere.xyz)-sphere.w;\n    float planeDist = point.y;\n    \n    float minDistance = min(sphereDist, planeDist);\n    return minDistance;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        vec3 point = rayOrigin + rayDirection * dO;\n        float distanceToScene = GetDist(point);\n        dO += distanceToScene;\n        if(dO > MAX_DIST || distanceToScene < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float dist = GetDist(point);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 normal = dist - vec3(\n        GetDist(point-e.xyy),\n        GetDist(point-e.yxy),\n        GetDist(point-e.yyx));\n\t\n\treturn normalize(normal);        \n}\n\nfloat GetLight(vec3 point)\n{\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.0;\n    vec3 lightVec = normalize(lightPos-point);\n    vec3 normal = GetNormal(point);\n    \n    float dif = clamp(dot(normal, lightVec), 0., 1.);\n    float distanceToLight = RayMarch(point + normal * SURF_DIST * 2., lightVec);\n    if(distanceToLight < length(lightPos-point)) dif*= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 cameraPos = vec3(0, 1, 0);    \n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float distance = RayMarch(cameraPos, rayDirection);\n    \n    vec3 point = cameraPos + rayDirection * distance;\n    \n    float diffuse = GetLight(point);\n    \n    col = vec3(diffuse);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 96, 96, 311], [313, 313, 364, 364, 658], [660, 660, 688, 688, 917], [919, 919, 947, 947, 1340], [1342, 1342, 1399, 1399, 1814]], "test": "ok"}
{"id": "3slyWN", "name": "param_v31", "author": "darkczar", "description": "v29 with tweaks", "tags": ["psychedelic", "trippy"], "likes": 1, "viewed": 40, "published": "Public", "date": "1584816335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    //float d2 = 10002.0;\n    //float d3 = 10003.0;\n    float di = 0.;\n    //float threshold = 0.005;//0000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    //float black_threshold=0.5;// -.5*nsin(iTime*.6);\n\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*10.+40.*sin(iTime*.01);\n        curve_p.x = -.1*sin(.3*iTime)+.04*float(di)*sin(float(di)+.1*iTime) +.03*float(di)*sin(4.0*di+.075*iTime) + .03*sin(iTime*.1)*float(di)*sin(di*di*.005+.08*iTime);\n        curve_p.y = -.1*cos(.3*iTime)+.04*float(di)*cos(float(di)+.1*iTime) +.03*float(di)*cos(4.0*di+.075*iTime) + .03*sin(iTime*.1)*float(di)*cos(di*di*.005+.08*iTime);\n        dtemp = pow(length(.9*float(i)*p-curve_p),1.25);\n\n\n        d= dot(normalize(p),normalize(curve_p))+3.*sin(.5*iTime+.1*d*d*d)+2.*cos(dtemp*dtemp+.1*iTime);\n        //if(d<black_threshold) d=020.5;   \n        r = map(38.*rand(vec2(float(i),float(i))), 0.,2000.,0.,1.); // +nsin(iTime*.8);\n        g = map(g+.001*d*dtemp+1.*sin(d+1.57), 0.,2000.,0.,1.);\n        b = map(.0004*dtemp*dtemp-d - 1.5*mod(log(.8*dtemp*dtemp-3.*d), .8), 0.,2000.,0.,1.); //+.001*rand(vec2(34.3,floor(dtemp*32.))); //b + .05*dtemp-.05*d;  \n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 180, 180, 246], [567, 567, 624, 674, 2258]], "test": "timeout"}
{"id": "3slyz7", "name": "Mountains somewhere in space", "author": "artemvang", "description": "Just mountains", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "mountains"], "likes": 4, "viewed": 223, "published": "Public API", "date": "1584474715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.00001;\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    float a = random(i + vec2(0,0));\n    float b = random(i + vec2(1,0));\n    float c = random(i + vec2(0,1));\n    float d = random(i + vec2(1,1));\n\n    return a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y;\n}\n\nfloat fbm(vec2 st, int octaves) {\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for (int i=0; i<octaves; i++) {\n        float n = noise(st);\n        a += b*n;\n        b *= s;\n        st *= f;\n    }\n\treturn a;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    return samplePoint.y + fbm(samplePoint.xz, 9);\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float dist = 0.001;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + dist * marchingDirection;\n        float d = sceneSDF(pos);\n        if (d < EPSILON) {\n            break;\n        }\n        \n        dist += d*0.4;\n        \n        if (dist >= MAX_DIST) {\n            dist = MAX_DIST;\n            break;\n        }\n    }\n    \n    return dist;\n}\n\n\nfloat softShadow(vec3 eye, vec3 marchingDirection, float max_dist, float w) {\n    float dist = 0.001;\n    float s = 1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + dist * marchingDirection;\n        float d = sceneSDF(pos);\n        s = min( s, 0.5+0.5*d/(w*dist) );\n        if( s < 0.0 ) break;\n        dist += d*0.4;   \n    }\n    \n    s = max(s,0.0);\n    \n    return s*s*(3.0-2.0*s);\n}\n   \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    const float h = 0.0001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1)) - 1.0);\n        n += e * sceneSDF(p + e * h);\n    }\n    return normalize(n);\n}\n\n\nfloat sigmoid(float x) {\n    return 1.0 / (1.0 + exp(-x));\n}\n\n\nvec3 phongIllumination(vec3 eye, vec3 worldDir, float dist) {\n    const vec3 ambientLight = vec3(0.5);\n    vec3 color = ambientLight * 0.2;\n    \n    vec3 diffuseColor = vec3(41., 31., 2.) / 255.;\n    \n\tconst vec3 lightPos = vec3(-10000.0, 10000.0, 0.0);\n    const float lightIntensity = 0.6;\n    \n    vec3 p = eye + worldDir * dist;\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    \n    float dotLN = dot(L, N);\n    \n    if (dotLN < 0.0) {\n        return color;\n    }\n    \n    diffuseColor = mix(vec3(0.8), diffuseColor, max(N.y, 0.0));\n    \n    float top = sigmoid((p.y + 0.4) * 20.);\n    diffuseColor = mix(diffuseColor, vec3(1.5), top);\n    \n    float shadowMul = softShadow(lightPos, normalize(p - lightPos), length(lightPos - p), .5);\n    color = mix(lightIntensity * (diffuseColor * dotLN), color, shadowMul);\n    return color;\n}\n\nvec3 applyFog(vec3 rgb, vec3 rayOri, vec3 rayDir, float dist) {\n    float fogAmount = 1.0-exp(-dist * .03);\n    vec3  fogColor  = vec3(0.7,0.7,0.65);\n    vec3 foggedColor = mix(rgb, fogColor, fogAmount);\n    \n    float y_dist = max((rayOri + rayDir * dist).y + 1.0, 0.);\n    fogAmount = exp(-y_dist * 5. );\n    foggedColor = mix(foggedColor, vec3(0.7,0.7,0.7), fogAmount);\n    \n    return foggedColor;\n}\n\n\nmat3 viewMatrix(vec3 eye, vec3 lookAt, vec3 up) {\n    vec3 f = normalize(lookAt);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse;\n    if(length(iMouse.xy) >= 1.0) mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n    else mouse = vec2(0.0);\n    \n\tvec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, .1, iTime * 0.5);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(mouse.x * 3.14 * 4., mouse.y * 3.14 * 4., -1.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = normalize(viewToWorld * viewDir);\n    \n    float dist = shortestDistanceToSurface(eye, worldDir);\n    \n    if (dist >= MAX_DIST - EPSILON) {\n        fragColor = vec4(.7, .7, .65, 1.);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = phongIllumination(eye, worldDir, dist);\n    \n    color = applyFog(color, eye, worldDir, dist);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 150, 150, 223], [226, 226, 248, 248, 573], [575, 575, 608, 608, 819], [822, 822, 856, 856, 909], [912, 912, 979, 979, 1355], [1358, 1358, 1435, 1435, 1776], [1782, 1782, 1847, 1847, 1979], [1982, 1982, 2011, 2011, 2305], [2308, 2308, 2332, 2332, 2368], [2371, 2371, 2432, 2432, 3236], [3238, 3238, 3301, 3301, 3641], [3644, 3644, 3693, 3693, 3818], [3820, 3820, 3877, 3877, 4670]], "test": "timeout"}
{"id": "3slyzS", "name": "Glowy boy", "author": "bkpjjj", "description": "..", "tags": ["polarglow"], "likes": 4, "viewed": 106, "published": "Public", "date": "1585039842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    float l = 0.01 / dot(uv,uv);\n    fragColor.xyz += hsv2rgb_smooth(vec3(l * 0.5 + iTime * 0.4,1.-l,l));\n    vec2 polar_uv = vec2(atan(uv.y,uv.x) * 3.14,length(uv));\n    float rays = pow(noise(abs(vec3(polar_uv + vec2(iTime * 0.1,0),iTime * 0.5) * vec3(2,1,1))),5.) * (0.005 / dot(uv,uv));\n    fragColor.xyz  += hsv2rgb_smooth(vec3(rays * 0.5 - iTime * 0.4,1.-rays,rays));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 212], [214, 214, 236, 236, 281], [282, 282, 302, 302, 347], [348, 348, 366, 366, 405], [407, 407, 427, 427, 918], [920, 920, 977, 977, 1417]], "test": "ok"}
{"id": "3sscD4", "name": "param_v30", "author": "darkczar", "description": "more goofing around", "tags": ["psychedelic", "trippy", "epicycles"], "likes": 1, "viewed": 44, "published": "Public", "date": "1584815884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    //float d2 = 10002.0;\n    //float d3 = 10003.0;\n    float di = 0.;\n    //float threshold = 0.005;//0000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    //float black_threshold=0.5;// -.5*nsin(iTime*.6);\n\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*2.3;\n        curve_p.x = -.1*sin(.3*iTime)+.04*float(di)*sin(float(di)+.4*iTime) +.03*float(di)*sin(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*sin(di*di*.005+.8*iTime);\n        curve_p.y = -.1*cos(.3*iTime)+.04*float(di)*cos(float(di)+.4*iTime) +.03*float(di)*cos(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*cos(di*di*.005+.8*iTime);\n        dtemp = pow(length(.9*float(i)*p-curve_p),1.25);\n\n\n        d= dot(normalize(p),normalize(curve_p))+3.*sin(.5*iTime+.1*d*d*d)+2.*cos(dtemp*dtemp+.1*iTime);\n        //if(d<black_threshold) d=020.5;   \n        r = map(8.*rand(vec2(float(i),float(i))), 0.,2000.,0.,1.); // +nsin(iTime*.8);\n        g = map(g+.3*d*dtemp, 0.,2000.,0.,1.);\n        b = map(.0004*dtemp*dtemp-d - 1.5*mod(log(.8*dtemp*dtemp-3.*d), .8), 0.,2000.,0.,1.); //+.001*rand(vec2(34.3,floor(dtemp*32.))); //b + .05*dtemp-.05*d;  \n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 180, 180, 246], [567, 567, 624, 674, 2217]], "test": "ok"}
{"id": "3sscD7", "name": "shia jiba luan shie", "author": "shitball", "description": "hkhkhk", "tags": ["2d"], "likes": 2, "viewed": 55, "published": "Public", "date": "1584970799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 _center,vec2 uv,float _radius){\n    vec2 d = (uv - _center);\n    return 1. - smoothstep(_radius - _radius * .01,\n                          _radius + _radius * .01,dot(d,d) * 2.);\n}\n\nvec2 proj2Screen(vec2 pos){\n    pos.x = pos.x * iResolution.x / iResolution.y;\n    return pos;\n}\n\nvec4 tile(vec2 uv,float zoom,float wComph){\n    uv = uv * vec2(zoom) * vec2(wComph,1);\n    vec4 resUv = vec4(fract(uv),0.,0.);\n    resUv.zw = 2. * step(1.,mod(uv , 2.)) - 1.;\n    return resUv;\n}\n\nvec2 animate(vec4 uv,float frequent){\n    float speed = 1. / frequent;\n    float iTimeOdd = step( 1. ,mod(iTime / frequent,2.));\n    vec2 resUv = uv.xy + uv.wz * vec2(iTimeOdd,1. - iTimeOdd) * iTime * speed;\n    \n    return fract(resUv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float wComph = iResolution.x / iResolution.y;\n    \n    vec4 tileduv = tile(uv,6.1,wComph);\n    \n    uv = animate(tileduv,0.5);\n    \n    \n    vec2 center = vec2(.5,.5);\n    \n    vec2 colvec = (tileduv.zw + 1.) * .5;\n\n    vec3 col = vec3(colvec,1.) * circle(center,uv,.15);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 198], [200, 200, 227, 227, 296], [298, 298, 341, 341, 492], [494, 494, 531, 531, 733], [735, 735, 792, 792, 1147]], "test": "ok"}
{"id": "3sscDj", "name": "What am I looking at?", "author": "BigETI", "description": "What do you see there?", "tags": ["trippy"], "likes": 3, "viewed": 226, "published": "Public API", "date": "1585609512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float beginZoomFactor = 20.0f;\n\nconst float endZoomFactor = 100.0f;\n\nconst float quarterPi = 0.78539816339f;\n\nconst float pi = 3.14159265359f;\n\nconst float doublePi = 6.28318530718f;\n\nconst float turnsPerSecond = 2.0f;\n\nconst vec2 movementSpeed = vec2(-200.0f, -200.0f);\n\nconst float zoomSpeed = 0.03125f;\n\nconst float spacing = 8.0f;\n\nconst float seperation = 32.0f;\n\nconst vec3 positions[] = vec3[]\n(\n    vec3(0.0f, 0.0f, 0.0f),\n    vec3(0.0f, spacing, 0.0f),\n    vec3(0.0f, -spacing, 0.0f),\n    vec3(spacing, 0.0f, 0.0f),\n    vec3(-spacing, 0.0f, 0.0f),\n    vec3(spacing * cos(quarterPi), spacing * sin(quarterPi), 0.0f),\n    vec3(-spacing * cos(quarterPi), spacing * sin(quarterPi), 0.0f),\n    vec3(spacing * cos(quarterPi), -spacing * sin(quarterPi), 0.0f),\n    vec3(-spacing * cos(quarterPi), -spacing * sin(quarterPi), 0.0f)\n);\n    \nvec4 AlphaBlend(const in vec4 bottom, const in vec4 top)\n{\n    float alpha = top.a + bottom.a * (1.0f - top.a);\n    return vec4((top.rgb * top.a + bottom.rgb * bottom.a * (1.0f - top.a)) / alpha, alpha);\n}\n\nvec4 Sphere(const in vec3 position, const in vec4 innerColor, const in vec4 outerColor, const in vec2 uv)\n{\n    vec4 ret = vec4(0.0f);\n    vec2 offset_uv = uv - position.xy;\n    if ((offset_uv.x * offset_uv.x) + (offset_uv.y * offset_uv.y) < 1.0f)\n    {\n        float view_dot_normal = dot(vec3(0.0f, 0.0f, 1.0f), vec3(offset_uv.x, offset_uv.y, sqrt(1.0f - (offset_uv.x * offset_uv.x) - (offset_uv.y * offset_uv.y))));\n        ret = clamp((innerColor * view_dot_normal) + (outerColor * (1.0f - view_dot_normal)), 0.0f, 1.0f);\n    }\n    return ret;\n}\n\nvec4 Spheres(const in vec4 backgroundColor, const in vec4 innerColor, const in vec4 outerColor, const in vec2 uv, const in bool revert)\n{\n    vec4 ret = backgroundColor;\n    for (int index = 0; index < positions.length(); index++)\n    {\n        float theta = iTime * doublePi * (revert ? -turnsPerSecond : turnsPerSecond);\n        float cos_theta = cos(theta);\n        float sin_theta = sin(theta);\n        vec3 position = vec3((positions[index].x * cos_theta) - (positions[index].y * sin_theta), (positions[index].x * sin_theta) + (positions[index].y * cos_theta), positions[index].z);\n        ret = AlphaBlend(ret, Sphere(position, innerColor, outerColor, mod(uv + (seperation * 0.5f), seperation) - (seperation * 0.5f)));\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 color = vec4(0.125f, 0.125f, 0.25f, 1.0f);\n    vec2 uv = ((fragCoord - iMouse.xy - (iResolution.xy * 0.5f)) * mix(endZoomFactor, beginZoomFactor, (cos(iTime * doublePi * zoomSpeed) * 0.5f) + 0.5f) / iResolution.y) + vec2(movementSpeed.x * cos(iTime), movementSpeed.y * sin(iTime));\n    color = Spheres(color, vec4(1.0f, 0.75f, 0.75f, 0.75f), vec4(1.0f, 0.25f, 0.25f, 0.75f), uv, false);\n    color = Spheres(color, vec4(0.75f, 1.0f, 0.75f, 0.75f), vec4(0.25f, 1.0f, 0.25f, 0.75f), uv + vec2(seperation * 0.5f, seperation * 0.5f), false);\n    color = Spheres(color, vec4(0.75f, 1.0f, 0.75f, 0.75f), vec4(0.25f, 1.0f, 0.25f, 0.75f), uv + vec2(0.0f, seperation * 0.5f), true);\n    color = Spheres(color, vec4(0.75f, 0.75f, 1.0f, 0.75f), vec4(0.25f, 0.25f, 1.0f, 0.75f), uv + vec2(seperation * 0.5f, 0.0f), true);\n    fragColor = vec4(color.xyz, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2354, 2354, 2409, 2409, 3268]], "test": "error"}
{"id": "3sscDn", "name": "MD5 with sin", "author": "olano", "description": "Version of https://www.shadertoy.com/view/XlscD8 using sin function instead of big table (as suggested by https://www.microsoft.com/en-us/research/publication/parallel-white-noise-generation-on-a-gpu-via-cryptographic-hash/)", "tags": ["hash", "md5"], "likes": 4, "viewed": 104, "published": "Public", "date": "1584560669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"MD5\" by rory618. https://shadertoy.com/view/XlscD8\n// 2020-03-18 19:40:41\n//\n// Replaces the 64-element K table with the function used to generate it.\n\n\nconst int[] s = int[](7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                      5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                      4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                      6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21);\n\nconst uint A0 = 0x67452301u,\n           B0 = 0xefcdab89u,\n           C0 = 0x98badcfeu,\n           D0 = 0x10325476u;\n\nuint K(uint i) {\n    return uint(232. * abs(sin(float(i)+1.)));\n}\n\nvoid MD5Round(inout uint A, inout uint B, inout uint C, inout uint D, in uint[16] M, uint i){\n    uint F, g;\n    if (i < 16u){\n        F = (B & C) | ((0xffffffffu-B) & D);\n        g = i;\n    } else if (i < 32u) {\n        F = (D & B) | ((0xffffffffu-D) & C);\n        g = (5u*i + 1u) % 16u;\n    } else if (i < 48u) {\n        F = B ^ C ^ D;\n        g = (3u*i + 5u) % 16u;\n    } else {\n        F = C ^ (B | (0xffffffffu-D));\n        g = (7u*i) % 16u;\n    }\n    \n    F = F + A + K(i) + M[g];\n    A = D;\n    D = C;\n    C = B;\n    B = B + (F << s[i]) | (F >> (32-s[i]));\n}\n\nuint[4] MD5( uint[16] M) {\n    uint A = A0, B = B0, C = C0, D = D0;    \n    \n    for(uint i = 0u; i < 64u; i++) {\n        MD5Round(A,B,C,D,M,i);\n    }\n    \n    return uint[](A,B,C,D);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uint[16] message;\n    message[0] = 0xffffffffu;\n    message[1] = uint(iFrame);\n    message[2] = floatBitsToUint(uv.x);\n    message[3] = floatBitsToUint(uv.y);\n    message[4] = floatBitsToUint(iResolution.x);\n    message[5] = floatBitsToUint(iResolution.y);\n    message[6] = floatBitsToUint(iTime);\n    \n    uint[4] res = MD5(message);\n    \n    float A = uintBitsToFloat (res[0]),\n          B = uintBitsToFloat (res[1]),\n          C = uintBitsToFloat (res[2]),\n          D = uintBitsToFloat (res[3]);\n    \n\tfragColor = fract(vec4(A,B,C,D));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[624, 624, 640, 640, 689]], "test": "error"}
{"id": "3sscRs", "name": "Caustic study", "author": "profhua", "description": "trying to understand how it work", "tags": ["caustic"], "likes": 9, "viewed": 508, "published": "Public", "date": "1585460420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//***trying to understand the shader form Dave_Hoskins \n//***https://www.shadertoy.com/view/MdKXDm\n\n//***rewrite this in a more nature way\n//***remove the sine part to solve temporal scale problem\n\n#define scale 1.2\n\nvoid mainImage(out vec4 fragcolor, vec2 uv)\n{\n    \n    //***imaging an axis-aligned plane in space\n    float t = iTime;\n    mat3 rot = mat3(-2,-1,2, 3,-2,1, 1,2,2);\n\tvec3 pos = vec3(uv+t*1e2,t*2e2);\n    \n    float dist = 1.;\n    \n    //***rotate the plane&&calc distance to cell center then get minimum of three\n    float s[3] = float[3](.32,.28,.26);\n    for(int i = 0;i<3;i++)\n    {\n    \tpos *= rot*s[i];\n    \tdist = min(dist,length(.5-fract(pos/2e2*scale)));\n    }\n    \n\n    fragcolor = pow((dist), 7.)*25.+vec4(0,.35,.5,1.);\n    \n    //***debug uv\n   \t//k = vec4(fract(pos/2e2),1.);\n    \n    \n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 262, 315, 815]], "test": "ok"}
{"id": "3sscW4", "name": "Ice Cream in the Eighties", "author": "iaian7", "description": "In honour of a friend, in memory of a mother.", "tags": ["light", "gradient", "abstract", "motion"], "likes": 8, "viewed": 116, "published": "Public", "date": "1584812352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 xy, float angle){\n\treturn vec2(xy.x*cos(angle) - xy.y*sin(angle), xy.x*sin(angle) + xy.y*cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Global Settings\n\tfloat speed = 0.4;\n    float rotation = speed * 0.2; // speed of the global rotation\n\tfloat variance = 0.2; // shifts the angles so they're not exactly 120°, and animates the shift\n\tfloat range = 0.1; // distance travelled by the pieces (from negative to positive, measured from the centre)\n    float opacity = 0.8; // maximum strength of the individual layers\n\tfloat grain = 0.8; // strength of the grain applied to the non-100% opacity areas\n\t\n\t// Edge Settings\n\tfloat curve = 3.0; // size of the circle that creates the edge mask (only one side is visible)\n\tfloat softness = 6.0; // antialiasing looks good at 2.5, anything larger starts to blur\n    \n\t// Glow Settings\n\tfloat size = 0.8; // size of the glow\n\tfloat offset = size * 0.3; // shifts the glow side to side within the edge mask\n    \n\t// Colours\n\tvec4 bg = vec4(0.043137255, 0.152941176, 0.235294118, 1.0); // Dark Navy\n\tvec4 c0 = vec4(0.062745098, 0.188235294, 0.294117647, 1.0); // Soft Navy\n\tvec4 c1 = vec4(0.227450980, 0.525490196, 0.584313725, 1.0); // Turquoise\n\tvec4 c2 = vec4(0.482352941, 0.729411765, 0.584313725, 1.0); // Seafoam\n\tvec4 c3 = vec4(0.698039216, 0.839215686, 0.639215686, 1.0); // Mint\n\tvec4 c4 = vec4(0.980392157, 0.937254902, 0.643137255, 1.0); // Chifon Yellow\n\tvec4 c5 = vec4(0.952941176, 0.709803922, 0.505882353, 1.0); // Pale Orange\n\tvec4 c6 = vec4(0.925490196, 0.458823529, 0.396078431, 1.0); // Salmon\n\tvec4 c7 = vec4(0.917647059, 0.301960784, 0.301960784, 1.0); // Soft Red\n\t\n\t// Normalized pixel coordinates (from -1 to 1, square)\n\tvec2 uv = (fragCoord-iResolution.xy*0.5)/(iResolution.xx*0.5);\n\tvec2 uv0 = rotate(uv, iTime*rotation);\n\tvec2 uv1 = rotate(uv0, 2.094395 + sin(iTime*speed*0.3333)*variance);\n\tvec2 uv2 = rotate(uv0, 4.18879 + cos(iTime*speed*0.3333)*variance);\n\t\n\t// Pixel antialiasing size in UV space\n\tfloat px = softness/iResolution.x;\n\t\n\t// Noise texture\n\tvec4 noise = texture(iChannel0, uv*1.5+vec2(sin(iTime*6.0), cos(iTime*6.0)));\n\t\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t// Animation timelines (the sin/cos waves animate at different speeds to break up repetition)\n\tfloat sin0 = sin(iTime*speed);\n\tfloat sin1 = sin((iTime+1.047198)*speed*1.05);\n\tfloat sin2 = sin((iTime+2.094395)*speed*1.1);\n\tfloat sin3 = sin((iTime+3.141593)*speed*1.15);\n\tfloat sin4 = sin((iTime+4.18879)*speed*1.2);\n\tfloat sin5 = sin((iTime+5.235988)*speed*1.25);\n\tfloat cos0 = cos(iTime*speed);\n\tfloat cos1 = cos((iTime+1.047198)*speed*1.05);\n\tfloat cos2 = cos((iTime+2.094395)*speed*1.1);\n\tfloat cos3 = cos((iTime+3.141593)*speed*1.15);\n\tfloat cos4 = cos((iTime+4.18879)*speed*1.2);\n\tfloat cos5 = cos((iTime+5.235988)*speed*1.25);\n\t\n\t// Glow layers part 1\n\tfloat curvePos = range*sin1;\n\tfloat glowPos = cos0*size*0.25+size*0.5;\n\tfloat g0 = smoothstep(curve+px, curve, length(uv0-vec2(0.0, curve+curvePos)));\n\tg0 *= smoothstep(size, 0.0, length(uv0+vec2(sin2*offset, glowPos-curvePos)));\n\t\tglowPos = cos1*size*0.25+size*0.5;\n\tfloat g1 = smoothstep(curve+px, curve, length(uv1-vec2(0.0, curve+curvePos)));\n\tg1 *= smoothstep(size, 0.0, length(uv1+vec2(sin3*offset, glowPos-curvePos)));\n\t\tglowPos = cos2*size*0.25+size*0.5;\n\tfloat g2 = smoothstep(curve+px, curve, length(uv2-vec2(0.0, curve+curvePos)));\n\tg2 *= smoothstep(size, 0.0, length(uv2+vec2(sin4*offset, glowPos-curvePos)));\n\t\n\t// Invert UV for second set of glow layers\n\tuv0 *= vec2(1.0, -1.0);\n\tuv1 *= vec2(1.0, -1.0);\n\tuv2 *= vec2(1.0, -1.0);\n\t\n\t// Glow layers part 2\n\t\tcurvePos = range*sin0;\n\t\tglowPos = cos3*size*0.25+size*0.5;\n\tfloat g3 = smoothstep(curve+px, curve, length(uv0-vec2(0.0, curve+curvePos)));\n\tg3 *= smoothstep(size, 0.0, length(uv0+vec2(sin3*offset, glowPos-curvePos)));\n\t\tglowPos = cos4*size*0.25+size*0.5;\n\tfloat g4 = smoothstep(curve+px, curve, length(uv1-vec2(0.0, curve+curvePos)));\n\tg4 *= smoothstep(size, 0.0, length(uv1+vec2(sin4*offset, glowPos-curvePos)));\n\t\tglowPos = cos5*size*0.25+size*0.5;\n\tfloat g5 = smoothstep(curve+px, curve, length(uv2-vec2(0.0, curve+curvePos)));\n\tg5 *= smoothstep(size, 0.0, length(uv2+vec2(sin5*offset, glowPos-curvePos)));\n\t\n    // Mix the colours\n    bg = mix(bg, c0, pow(smoothstep(1.5, 0.0, length(uv)), 1.0+noise.b*grain));\n\tbg = mix(bg, c1, pow(g0*opacity, 1.0+noise.r*grain));\n\tbg = mix(bg, c2, pow(g1*opacity, 1.0+noise.g*grain));\n\tbg = mix(bg, c3, pow(g2*opacity, 1.0+noise.b*grain));\n\tbg = mix(bg, c5, pow(g3*opacity, 1.0+noise.r*grain));\n\tbg = mix(bg, c6, pow(g4*opacity, 1.0+noise.g*grain));\n\tbg = mix(bg, c7, pow(g5*opacity, 1.0+noise.b*grain));\n    \n\t// Output to screen\n\tfragColor = bg;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 120], [122, 122, 179, 199, 4755]], "test": "error"}
{"id": "3sscWH", "name": "templo--v001", "author": "jorge2017a1", "description": "templo--v001", "tags": ["templov001"], "likes": 1, "viewed": 39, "published": "Public", "date": "1584714139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,0.0);\n}\n\n\nfloat wallxv2(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 60.0-max(ap.x,0.0);\n}\n\n\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallyv2(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 40.0-max(ap.y,0.0);\n}\n\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 20.0-max(ap.z,0.0);\n}\n\nfloat wallzv2(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 50.0-max(ap.z,0.0);\n}\n\n\n// Distance function for the floor\nfloat floor_sdf(vec3 p){\n    vec4 plane = vec4(0, 1, 0, -30);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nfloat wall_sdf(vec3 p){\n    vec4 plane = vec4(0, 0, -1, -5);\n    return dot(p, plane.xyz) - plane.w;\n}\n\n\n\n//------------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    //piso 1\n    float  sdb1=sdBox(p- vec3(0.0,-30.0,0.0) , vec3(60.0,10.0,25.0) );\n    //piso 2\n    float  sdb2=sdBox(p- vec3(0.0,-16.0,0.0) , vec3(20.0,3.5,20.0) );\n    //techo cuadrado\n    float  sdb3=sdBox(p- vec3(0.0,20.0,0.0) , vec3(18.0,1.,20.0) );\n    //techo triangulo\n    float  sdt1= sdTriPrism(p -vec3(0.0,28.0,0.0) , vec2(14.0,18.0) );\n    \n    //columnas\n    float sdc1= sdCylinder(p- vec3(-15.0,2.0,15.0), vec2(3.0,20.0)  );\n    float sdc2= sdCylinder(p- vec3(-15.0,2.0,-15.0), vec2(3.0,20.0)  );\n    float sdc3= sdCylinder(p- vec3(15.0,2.0,-15.0), vec2(3.0,20.0) );\n    float sdc4= sdCylinder(p- vec3(15.0,2.0,15.0),  vec2(3.0,20.0) );\n    \n    \n    \n    res =opU(res, vec2(sdb1, 16));\n    res =opU(res, vec2(sdb2, 9));\n    res =opU(res, vec2(sdb3, 9));\n    res =opU(res, vec2(sdt1, 11));\n    \n    res =opU(res, vec2(sdc1, 23));\n    res =opU(res, vec2(sdc2, 23));\n    res =opU(res, vec2(sdc3, 24));\n    res =opU(res, vec2(sdc4, 24));\n    \n    \n    //bloques en colunas\n    float  sdb1c1=sdBox(p- vec3(15.0,-11.0,14.0) , vec3(4.0,2.0,2.0) );\n    float  sdb1c2=sdBox(p- vec3(15.0,-11.0,-16.0) , vec3(4.0,2.0,2.0) );\n    float  sdb1c3=sdBox(p- vec3(-15.0,-11.0,14.0) , vec3(4.0,2.0,2.0) );\n    float  sdb1c4=sdBox(p- vec3(-15.0,-11.0,-16.0) , vec3(4.0,2.0,2.0) );\n    \n    res =opU(res, vec2(sdb1c1, 5));\n    res =opU(res, vec2(sdb1c2, 5));\n    res =opU(res, vec2(sdb1c3, 6));\n    res =opU(res, vec2(sdb1c4, 6));\n    \n  \n   float  plane =floor_sdf(p); \n  \n    res =opU(res, vec2(plane, 6));\n\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    dist=d.x;\n    \n    vec3 n;\n    n = dist -vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    \n    vec3 ro = vec3(0 ,8.5,-60.0+10.0*cos(iTime));\n    ro = get_mouse(ro);\n    vec3 rd =normalize(vec3(uv,0.5) );\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n   \n    float dif, dif1, dif2, dif3, dif4, dif5;\n     dif1= GetLightPar(p,vec3(-30.0,20.0,0.0));\n    \n    dif5= GetLightPar(p,vec3(-10.0,30.0,-30.0));\n    \n    dif=dif1+dif5;\n    dif=dif*5.0;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 549, 582, 582, 647], [648, 666, 702, 702, 771], [772, 787, 818, 818, 968], [969, 989, 1025, 1025, 1112], [1113, 1129, 1161, 1189, 1250], [1252, 1252, 1288, 1288, 1391], [1394, 1394, 1439, 1439, 1530], [1584, 1584, 1630, 1630, 1662], [1664, 1664, 1707, 1707, 1739], [1741, 1741, 1789, 1789, 1822], [1825, 1825, 1854, 1854, 1980], [1982, 1982, 2018, 2018, 2135], [2137, 2137, 2173, 2173, 2291], [2294, 2294, 2330, 2330, 2453], [2506, 2518, 2540, 2540, 2848], [2849, 2875, 2900, 2900, 3090], [3091, 3136, 3153, 3153, 3226], [3229, 3262, 3288, 3288, 3485], [3532, 3532, 3584, 3584, 3739], [3804, 3913, 3950, 3950, 3985], [3987, 3987, 4006, 4006, 4081], [4130, 4130, 4153, 4153, 4179], [4181, 4181, 4204, 4204, 4342], [4345, 4345, 4367, 4367, 4437], [4502, 4502, 4528, 4528, 4585], [4587, 4587, 4607, 4607, 4665], [4668, 4668, 4689, 4689, 4939], [4941, 5008, 5029, 5029, 5095], [5097, 5097, 5119, 5119, 5174], [5177, 5177, 5201, 5201, 5256], [5260, 5260, 5281, 5281, 5336], [5338, 5338, 5361, 5361, 5416], [5419, 5419, 5440, 5440, 5495], [5497, 5497, 5520, 5520, 5575], [5578, 5613, 5637, 5637, 5716], [5718, 5718, 5741, 5741, 5820], [5824, 5869, 5894, 5894, 7656], [7661, 7661, 7694, 7694, 8169], [8173, 8173, 8197, 8197, 8478], [8483, 8483, 8521, 8521, 8879], [8978, 9022, 9039, 9039, 9110], [9135, 9227, 9252, 9252, 9515], [9695, 9695, 9723, 9723, 17402], [17405, 17405, 17462, 17462, 18932]], "test": "error"}
{"id": "3ssczs", "name": "The Live Coders Conference - 1", "author": "mrange", "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.", "tags": ["2d", "fbm", "tlc"], "likes": 6, "viewed": 220, "published": "Public API", "date": "1585381413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// pmin from IQ's blog on smooth minimum functions:\n//  http://www.iquilezles.org/www/articles/smin/smin.htm\n// Lightning based on \"Sparkle sparkle little lightning\":\n//  https://www.shadertoy.com/view/3sXSD2\n\n#define PI     3.141592654\n#define TAU    (2.0*PI)\n#define SCA(a) vec2(sin(a), cos(a))\n#define TTIME  (iTime*TAU)\n#define PERIOD 600.0\n\nconst float a1 = PI/2.0;\nconst float a2 = PI*4.5/6.0;\n\nconst vec2 sca1 = SCA(a1);\nconst vec2 sca2 = SCA(a2);\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset) {\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*SCA(PI/2.0 + TTIME/PERIOD);\n    \n  for (int i = 0; i < 3; i++) {\n    float btime = TTIME*85.0/PERIOD + float(i);\n    float rtime = TTIME*75.0/PERIOD + float(i) + 10.0;\n    float d1 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 3.0, rtime)));\n    float d2 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 2.0, btime)));\n    col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n    col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n  }\n    \n  return col;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat arc(vec2 p, vec2 sca, vec2 scb, float ra, float rb) {\n  p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n  return sqrt(dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k) - rb;\n}\n\nfloat spokes(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME*40.0/PERIOD;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*vec4(0.04));\n  return ds;\n}\n\nfloat arcs(vec2 p, float s) {\n  \n  float d1 = arc(p, sca1, sca2, s*0.275, s*0.025);\n  float d2 = arc(p, sca1, sca2, s*0.18, s*0.025);\n  \n  return min(d1, d2);\n}\n\nfloat meeple(vec2 p, float s) {\n  float dh = box(p - s*vec2(0.0, -0.035), s*vec2(0.07, 0.1), s*vec4(0.065));\n  float dc = box(p - s*vec2(0.0, -0.22), s*vec2(0.15, 0.04), s*vec4(0.05, 0.02, 0.05, 0.02));\n  \n  return pmin(dh, dc, s*0.115);\n}\n\nfloat theLiveCoders(vec2 p, float s) {\n  float ds = spokes(p, s);\n  float dc = circle(p, 0.375*s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n  \n  float d = ds;\n  d = min(d, dc);\n  d = max(d, -da);\n  d = max(d, -dm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {\n  float d = theLiveCoders(p, 1.0 - 0.5*cos(TTIME*7.0/PERIOD));\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=vec3(1.0 - tanh(pow(length(p/1.5), 5.0)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  vec2 op = p;\n\n  p *= 1.0;\n\n  float d = df(p);\n  \n  const vec3  background   = vec3(0.0)/vec3(255.0);\n\n  vec3 col = background;\n\n  float borderStep = 0.0075;\n \n  vec3 baseCol = vec3(1.0);\n  vec4 logoCol = vec4(baseCol, 1.0)*smoothstep(-borderStep, 0.0, -d);\n  \n  if (d >= 0.0) {\n    vec2 pp = toPolar(p);\n    float funky = 0.7*pow((0.5 - 0.5*cos(TTIME/PERIOD)), 4.0);\n    pp.x *= 1./(pow(length(p) + funky, 15.0) + 1.0);\n    p = toRect(pp);\n    col += lightning(p, (pow(abs(d), 0.25 + 0.125*sin(0.5*iTime + p.x + p.y))));\n  }\n  col = clamp(col, 0.0, 1.0);\n\n  col *= 1.0 - logoCol.xyz;\n\n  col = postProcess(col, q, op);\n  col *= smoothstep(0.0, 16.0, iTime*iTime);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssczs.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1624, 1624, 1643, 1643, 1766], [1768, 1768, 1789, 1789, 2216], [2218, 2218, 2249, 2249, 2596], [2598, 2598, 2638, 2638, 3121], [3123, 3123, 3162, 3162, 3287], [3289, 3289, 3311, 3311, 3355], [3357, 3357, 3378, 3378, 3423], [3425, 3425, 3464, 3464, 3540], [3542, 3542, 3573, 3573, 3599], [3601, 3601, 3636, 3636, 3785], [3787, 3787, 3846, 3846, 4033], [4035, 4035, 4066, 4066, 4249], [4251, 4251, 4280, 4280, 4411], [4413, 4413, 4444, 4444, 4652], [4654, 4654, 4692, 4692, 4896], [4898, 4898, 4916, 4916, 4993], [4995, 4995, 5040, 5040, 5240], [5242, 5242, 5297, 5297, 6094]], "test": "error"}
{"id": "3ssyD4", "name": "Creature's Plant", "author": "takumifukasawa", "description": "# references\n## sss\nhttps://www.shadertoy.com/view/wljSz1\n## tri-planner mapping\nhttps://qiita.com/edo_m18/items/c8995fe91778895c875e\nhttps://www.shadertoy.com/view/wtjGWy", "tags": ["tube"], "likes": 4, "viewed": 81, "published": "Public", "date": "1585035681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// memo:\n// it may be wrong directional light specular.\n\n#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\n#define MAT_ROOM 1.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n\nconst float stopThreshold = .0001;\nconst int maxShadowIterations = 32;\n\nprecision highp float;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \t// float dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n    vec3 specularColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};  \n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rot3(float roll, float pitch, float yaw) {\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n    return mat3(\n    \tcp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n        cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n        -sp, sr * cp, cr * cp\n    );\n}\n\nvec3 hash3(vec3 p) {\n\tvec3 q = vec3(\n        dot(p, vec3(127.1, 311.7, 114.5)),\n        dot(p, vec3(269.5, 183.3, 191.9)),\n        dot(p, vec3(419.2, 371.9, 514.1))\n    );\n    return fract(sin(q) * 43758.5433);\n}\n\nvec3 rgbColor(float r, float g, float b) {\n\treturn vec3(r / 255., g / 255., b / 255.);\n}\n\n\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 pos, float rad) {\n\treturn length(pos) - rad;\n}\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// d1 subtract to d2\nfloat opSub(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) + n.w;\n}\n\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    float d = FLT_MAX;\n    float objD = 0.;\n    float m = 0.;\n    \n\tp.xz = rot(iTime * .2) * p.xz;\n    \n    // floor\n    {\n        vec3 _p = p;\n        _p -= vec3(0., -2.5, 0.);\n        float r = 100.;\n        objD = min(d, sdSphere(_p - vec3(0., -r - 2.5, 0.), r));\n    \td = min(objD, d);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;        \n    }\n    \n    // top\n    {\n        vec3 _p = p;\n        float r = 100.;\n        objD = sdSphere(_p - vec3(0., r + 2.5, 0.), r);\n        d = min(objD, d);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;\n    }\n\n    // tubes\n    {\n        vec3 _p = p;\n        float repeatNum = 4.;\n        vec3 id = vec3(0.);\n        id.xz = floor((_p.xz/* + repeatNum * .5*/) / repeatNum);\n        vec3 rnd = hash3(id);\n        _p.xz = repeat(_p.xz, repeatNum);\n        objD = sdCylinder(_p, vec3(0., 0., .2));\n        d = smin(d, objD, 1.);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;\n\n        // thick\n        vec3 sphereOffset = vec3(0., 7.5 - mod(iTime * .3 + rnd.x * 10., 1.) * 15., 0.);\n        float r = .1 + sin(iTime * 10. + rnd.z * 100.) * pow(.1, .9);\n        objD = sdSphere(_p - sphereOffset, r);\n        d = smin(d, objD, 1.4);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;\n    }\n    \n    return vec2(d, m);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    // raymarching\n    float tmax = 40.;\n    float depth = 0.;\n    float dist = 0.;\n    vec2 result = vec2(0.);\n    for(int i = 0; i < 99; i++) {\n    \tresult = scene(ro + rd * depth);\n        dist = result.x;\n        if(dist < stopThreshold || depth > tmax) {\n            break;\n        }\n        depth += result.x;\n    }    \n    \n    if(depth > tmax) result.y = -1.;\n    \n\treturn vec2(depth, result.y);\n}\n\n//---------------------------------------------------------------------------------------------\n// shadings\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/wtjGWy\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n) {\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, EPS));\n    \n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz); // yz plane\n    vec4 yaxis = texture(tex, p.xz); // xz plane\n    vec4 zaxis = texture(tex, p.xy); // xy plane\n\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float power) {\n  float res = 1.;\n  float t = mint;\n  float ph = 1e10;\n  for(int i = 0; i < maxShadowIterations; i++) {\n    float h = scene(ro + rd * t).x;\n\n    // pattern 1\n    // res = min(res, power * h / t);\n\n    // pattern 2\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, power * d / max(0., t - y));\n    ph = h;\n\n    t += h;\n\n    float e = EPS;\n    if(res < e || t > tmax) break;\n  }\n  return clamp(res, 0., 1.);\n}\n \n\nfloat getSpecular(vec3 lightDir, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \t// vec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 32.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(normalize(light.position), surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse/* * softShadow(surface.position, normalize(light.position), .1, 3., 5.)*/;\n    light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \tfloat d = distance(light.position, surface.position);\n  \tvec3 k = vec3(.06, .08, .09);\n  \tlight.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  \t// point light\n  \tvec3 lightDir = light.position - surface.position;\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(lightDir)));\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  \t// specular\n  \tfloat specularCoef = getSpecular(lightDir, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  \tlight.diffuse = diffuse/* * softShadow(surface.position, normalize(light.position), .1, 3., 5.)*/;\n  \tlight.specular = specular;\n}\n\nfloat ambientOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n\nvec3 fog(vec3 color, float dist, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-dist * b);\n  return mix(color, fogColor, fogAmount);\n}\n\n// ref: https://www.shadertoy.com/view/wljSz1\nvec4 subsurface(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 7; ++i){\n        float d = scene(p).x;\n        e += -d;\n        if(d > -0.001)\n            break;\n        p -= d*dir;\n    }\n    \n    return vec4(p, e);\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos, vec3 cameraDir) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(.5, 0., -1.);\n  \tdirectionalLight.intensity = .5;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tdirectionalLight.attenuation = 1.;\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n    \n  \tLight pointLight;\n  \tpointLight.position = vec3(0., -1., -0.);\n  \tpointLight.intensity = .3;\n  \tpointLight.color = vec3(.4, .8, .8);\n  \t//pointLight.attenuation = 1.;\n  \tcalcPointLight(pointLight, surface, cameraPos);\n    \n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;\n    \n\tfloat occ = ambientOcculusion(surface.position, surface.normal);\n  \tfloat amb = clamp(.5 + .5 * surface.normal.y, 0., 1.);\n  \tvec3 ambient = surface.baseColor * amb * occ * vec3(0., .08, .1);  \n    \n    // ref: https://www.shadertoy.com/view/wljSz1\n    // subsurface scattering\n    vec3 h = normalize(mix(-getNormal(surface.position), cameraDir, 0.5));\n    // sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness\")\n    vec4 sv = subsurface(surface.position+h*0.02, cameraDir);\n    // subsurface magic term\n    float sss = max(0.0, 1.0-3.0*sv.w);\n    // light visibility across the volume\n    vec3 l = vec3(0.);\n    float ssha = max(0.0, dot(getNormal(sv.xyz), normalize(l-sv.xyz)));\n    // sss /= att;\n    //ssha /= att;\n    diffuse = mix(diffuse, vec3(mix(sss, ssha, 0.2)), 0.5);\n            \n  \tcolor =\n        surface.emissiveColor +\n        surface.baseColor * diffuse +\n        surface.specularColor * specular +\n        ambient;  \n  \n  \treturn color;\n}\n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * 1. + vec2(.75, -3.) + vec2(sin(iTime * .8), cos(iTime * 1.2)) * .15, 5.);\n    vec3 target = vec3(0., -2.4, 0.) + vec3(sin(iTime * .3), cos(iTime * .8), 0.) * .15;\n    float fov = .5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n        \n\t    Surface surface;\n    \tsurface.depth = depth;\n    \tsurface.position = position;\n    \tsurface.normal = normal;\n    \tsurface.material = result.y;\n    \n    \tvec3 objColor = vec3(0.);\n\n        if(checkMat(material, MAT_ROOM)) {\n            surface.baseColor = rgbColor(100., 220., 214.);\n            vec3 _p = surface.position;\n            _p.xz = rot(iTime * .2) * _p.xz;\n            surface.baseColor *= tex3D(iChannel0, _p, surface.normal);\n        }\n        surface.specularColor = vec3(1.);\n        \n        color = lighting(surface, ro, rd);  \n    }\n\n    // fog\n    color = fog(color, result.x, vec3(.02, .02, .04), .08);\n    \n    // gamma\n    color = pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[916, 962, 993, 993, 1028], [1030, 1030, 1074, 1074, 1109], [1111, 1111, 1140, 1140, 1301], [1303, 1303, 1350, 1350, 1705], [1707, 1707, 1727, 1727, 1919], [1921, 1921, 1963, 1963, 2009], [2213, 2213, 2253, 2253, 2282], [2284, 2324, 2386, 2386, 2511], [2513, 2577, 2639, 2639, 2799], [2801, 2801, 2842, 2842, 2941], [2943, 2943, 2977, 2977, 3015], [3017, 3017, 3054, 3054, 3334], [3336, 3357, 3390, 3390, 3414], [3416, 3416, 3447, 3447, 3479], [3482, 3482, 3527, 3527, 3606], [3608, 3608, 3653, 3653, 3732], [3734, 3734, 3753, 3753, 3816], [3818, 3818, 3846, 3846, 3961], [4168, 4168, 4188, 4188, 5479], [5481, 5481, 5505, 5505, 5749], [5751, 5751, 5784, 5803, 6190], [6397, 6443, 6486, 6486, 6872], [6874, 6874, 6947, 6947, 7392], [7396, 7396, 7487, 7536, 7806], [7808, 7808, 7887, 7901, 8419], [8421, 8421, 8494, 8494, 9231], [9233, 9233, 9278, 9278, 9557], [9559, 9559, 9617, 9617, 9702], [9704, 9750, 9784, 9784, 9996], [9998, 9998, 10062, 10062, 11779], [11982, 11982, 12037, 12037, 13458]], "test": "error"}
{"id": "3ssyRB", "name": "code bended shaders", "author": "tiagomoraismorgado88", "description": "code bended shaders", "tags": ["codebendedshaders"], "likes": 2, "viewed": 61, "published": "Public", "date": "1585046282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original shader by inigo quilez - modified by tiago morais morgado\n\nconst mat2 m = mat2 (0.75, 0.125, -1, 0.5);\n\n float hash( vec2 p ) \n { \n\t float h = dot(p,vec2(145, 322)); \n\t return -1.0 + 2.0*fract(sin(h)*43758.5453123); \n } \n\n float noise( in vec2 p ) \n\n {\n\t vec2 i = floor( p ); \n\t vec2 f = fract( p );\n\t vec2 u = f*f*(3.0-2.0*f); \n\t return mix( mix( hash( i + vec2(0.0,0.0) ), \n\t hash( i + vec2(1.0,0.0) ), u.y), \n\t mix( hash( i + vec2(0.0,1.0) ), \n\t hash( i + vec2(1.0,1.0) ), u.y), u.y); \n } \n\n float fbm( vec2 p ) \n {\n\t float f = 0.0; \n\t f += 0.5000*noise( p ); p = m*p*2.02; \n\t f += 0.2500*noise( p ); p = m*p*2.03; \n\t f += 0.1250*noise( p ); p = m*p*2.01; \n\t f += 0.0625*noise( p ); \n\t return f/0.9375; \n } \n\n vec2 fbm2( in vec2 p ) \n {\n\t return vec2( fbm(p.xx), fbm(p.yx) ); \n } \n\n vec3 map( vec2 p ) \n {   \n\t p *= 0.7; \n\n \n\t float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) ); \n\n \n\t float bl = smoothstep( -0.8, 0.8, f ); \n\n \n\t float ti = smoothstep( -1.0, 1.0, fbm(p) ); \n\n \n\t return mix( mix( vec3(1, 0, 0), \n\t vec3(1, 0, 1), ti ), \n\t vec3(0, 1, 1), bl ); \n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n\t vec2 p = (-iResolution.yx+2.0*fragCoord.yx)/iResolution.x; \n\t\n \n\t float e = 0.0045; \n\t\n \n\t vec3 colc = map( p ); float gc = dot(colc,vec3(0.333)); \n\t vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333)); \n\t vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333)); \n\t\n  \n\t vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) ); \n\t\n\n\t vec3 col = colc; \n\t col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb); \n\t col *= 1.0+0.2*nor.x*nor.y; \n\t col += 0.05*nor.y*nor.x*nor.x; \n\t\n\n\t\n\n\t vec2 q = fragCoord.yx/iResolution.yx;\n\t col *= pow(32.0*q.x*q.x*(1.0-q.y)*(1.0-q.x),0.1); \n\t\n\n\t fragColor = vec4( col, 3.0 ); \n }\n\n/*\n\n// generate an hell of a lot of those with nodejs\n\nlet fs = require('fs');\n\nconst vec3Valus = [\n    [\"1, 0, 0\"],\n    [\"0, 1, 0\"],\n    [\"0, 0, 1\"],\n    [\"1, 0, 1\"],\n    [\"0, 1, 1\"],\n    [\"1, 1, 0\"],\n];\n\nconst xyCoordinates1 = [\n    [\"xx\"],\n    [\"yy\"],\n    [\"xy\"],\n    [\"yx\"]\n];\n\nconst matrix1 = [\n    [\"1, 0.5, -1, 0.5\"],\n    [\"0.5, 0.5, -1, 1\"],\n    [\"0.5, 0.5, -1, 0.5\"],\n    [\"0.75, 0.125, -1, 0.5\"],\n    [\"0.75, 0.125, -1, 0.5\"],\n    [\"0.125, 0.25, -1, 0.75\"],\n    [\"0.25, 0.25, -1, 0.75\"],\n    [\"0.25, 0.25, -1, 0.45\"],\n]\n\nconst matrix2 = [\n    [\"322, 145\"],\n    [\"145, 322\"],\n]\n\nconst xyCoordinates2 = [\"x\", \"y\"];\n\nlet range = 0; let textBlock;\n\n\nfunction hashingProceduralScriptGeneration() {\n    \n    for (let i1 = 0; i1 < 2000; i1++) {\n        \n        range++; let glslShaderName = [\"glslTest\" + range + \".frag\"];\n        \n        console.log(glslShaderName, \"utf-8\");\n        \n        let textBlock=\"const mat2 m = mat2 (\"+ matrix1[i1 % 7 % matrix1.length] + \");\" \n        +   \"\\n\\n float hash( vec2 p ) \"\n        +   \"\\n { \\n\\t float h = dot(p,vec2(\" + matrix2[i1 % 21 % matrix2.length] + \")); \"\n        +   \"\\n\\t return -1.0 + 2.0*fract(sin(h)*43758.5453123); \"\n        +   \"\\n } \\n\\n float noise( in vec2 p ) \\n\\n {\"\n        +   \"\\n\\t vec2 i = floor( p ); \\n\\t vec2 f = fract( p );\" \n        +   \"\\n\\t vec2 u = f*f*(3.0-2.0*f); \\n\\t return mix( mix( hash( i + vec2(0.0,0.0) ), \" \n        +   \"\\n\\t hash( i + vec2(1.0,0.0) ), u.\"+ xyCoordinates2[i1 % 7 % xyCoordinates2.length] \n        +   \"), \\n\\t mix( hash( i + vec2(0.0,1.0) ), \"\n        +   \"\\n\\t hash( i + vec2(1.0,1.0) ), u.\"+ xyCoordinates2[i1 % 7 % xyCoordinates2.length] + \"), u.\" \n        +   xyCoordinates2[i1 % 7 % xyCoordinates2.length] \n        +   \"); \\n } \\n\\n float fbm( vec2 p ) \\n {\" \n        +   \"\\n\\t float f = 0.0; \\n\\t f += 0.5000*noise( p ); p = m*p*2.02; \"\n        +   \"\\n\\t f += 0.2500*noise( p ); p = m*p*2.03; \\n\\t f += 0.1250*noise( p ); p = m*p*2.01; \"\n        +   \"\\n\\t f += 0.0625*noise( p ); \\n\\t return f/0.9375; \\n } \\n\\n vec2 fbm2( in vec2 p ) \\n {\" \n        +   \"\\n\\t return vec2( fbm(p.\" + xyCoordinates1[i1 % 5 % xyCoordinates1.length] + \"), fbm(p.\" \n        +   xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \") ); \\n } \\n\\n vec3 map( vec2 p ) \\n {   \"\n        +   \"\\n\\t p *= 0.7; \\n\\n \\n\\t float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) ); \"\n        +   \"\\n\\n \\n\\t float bl = smoothstep( -0.8, 0.8, f ); \\n\\n \\n\\t float ti = smoothstep( -1.0, 1.0, fbm(p) ); \"\n        +   \"\\n\\n \\n\\t return mix( mix( vec3(\" +  vec3Valus[i1 % 3 % vec3Valus.length]  \n        +   \"), \\n\\t vec3(\" +  vec3Valus[i1 % 7 % vec3Valus.length] +\"), ti ), \\n\\t vec3(\" +  vec3Valus[i1 % 11 % vec3Valus.length]  + \"), bl ); \"\n        +   \"\\n} \\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\n { \\n\\t vec2 p = (-iResolution.\" + xyCoordinates1[i1 % 7 % xyCoordinates1.length] \n        + \"+2.0*fragCoord.\" + xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \")/iResolution.\" + xyCoordinates2[i1 % 5 % xyCoordinates2.length] + \"; \"\n        +   \"\\n\\t\\n \\n\\t float e = 0.0045; \\n\\t\\n \\n\\t vec3 colc = map( p ); float gc = dot(colc,vec3(0.333)); \"\n        +   \"\\n\\t vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333)); \"\n        +   \"\\n\\t vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333)); \"\n        +   \"\\n\\t\\n  \\n\\t vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) ); \"\n        +   \"\\n\\t\\n\\n\\t vec3 col = colc; \\n\\t col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb); \"\n        +   \"\\n\\t col *= 1.0+0.2*nor.\" + xyCoordinates2[i1 % 11 % 2] + \"*nor.\" +  xyCoordinates2[i1 % 13 % 2]  \n        +   \"; \\n\\t col += 0.05*nor.\" +  xyCoordinates2[i1 % 7 % 2]  + \"*nor.\" +  xyCoordinates2[i1 % 17 % 2]  \n        +   \"*nor.\" +  xyCoordinates2[i1 % 3 % 2]  + \"; \"\n        +   \"\\n\\t\\n\\n\\t\\n\\n\\t vec2 q = fragCoord.\" + xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \"/iResolution.\" + xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \";\"\n        +   \"\\n\\t col *= pow(32.0*q.\" +  xyCoordinates2[i1 % 3 % 2]  + \"*q.\" +  xyCoordinates2[i1 % 5 % 2]  + \"*(1.0-q.\" \n        +   xyCoordinates2[i1 % 7 % 2]  +\")*(1.0-q.\" +  xyCoordinates2[i1 % 11 % 2]  + \"),0.1); \"\n        +   \"\\n\\t\\n\\n\\t fragColor = vec4( col, 3.0 ); \\n }\";\n        \n        fs.writeFileSync(\"./GLSL1/\" + glslShaderName, textBlock);\n         \n    }\n    \n    return 0;\n    \n}\n\nhashingProceduralScriptGeneration();\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 141, 141, 231], [235, 235, 264, 264, 503], [507, 507, 530, 530, 721], [725, 725, 751, 751, 794], [798, 798, 820, 820, 1130], [1133, 1133, 1192, 1192, 1822]], "test": "timeout"}
{"id": "3sXcRj", "name": "Gained Gradient Noise", "author": "raabix", "description": "This is a variation on the classical noise. I love noise and I would like to see more creativity when creating it. So this is my take. \nCLIOK AND DRAG THE MOUSE TO MODIFY NOISE PARAMETERS\nLeft: Classical FBM Noise\nRight: Gained pow FBM noise", "tags": ["procedural", "noise", "texture", "gained"], "likes": 7, "viewed": 117, "published": "Public", "date": "1585143771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*  \n    This is my take on making an FBM noise that is more interesting by adding some\n    variation to it. This makes it more uneven and gets rid of the cloudy look which\n    is nice, but not always desired. Instead, I am adding variation to the intensities\n    of the gradients using a pow-function.\n\n\tMouse-x: Octaves of noise\n    Mouse-y: Power of variation of intensities\n\n\tLeft view:  The output of the noise function\n\tRight view: Smoothstepping the output to extract a range\n\n\tNOTES:\n\t> The right side of the view applies a simple boxfiltered antialiasing which you can\n      basically turn off by setting BOXFILTER_SAMPLES to 1.0\n\t> The gradient of the noise is being animated with time, so you get a morphing\n\t  effect of the which I found interesting.\n\n\tCHECK OUT\n    *********\n\n\tVanilla FBM explorer:        https://www.shadertoy.com/view/tdlyz4\n    Noise -gradient 2d by IQ:    https://www.shadertoy.com/view/XdXGW8\n\n*/\n\n\n#define DO_ROTATE         true  \n#define BOXFILTER_SAMPLES 2.0\n#define PI                3.14159265359\n\n// Hashes by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nfloat gainf(float x, float k) \n{\n    //remap k, so k is driven by 0...1 range\n    k = k < 0.5 ? 2.*k : 1./(1.-(k-0.5)*2.);\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// performs a golden-ratio rotation\nvec2 rot_golden(vec2 pos,vec2 uv)\n{\n    // golden/ration in radians: 3.883222072739204862525004958380\n    float sine   = -0.67549029078724183023998;\n    float cosine = -0.73736888126104662389070;\n    mat2 rot = mat2(cosine, -sine, sine, cosine);\n    uv -= pos; \n    uv = rot * uv  ;\n    return uv + pos;\n}\n\n\nfloat gradnoise_random(vec2 uv)\n{\n    vec2 p = floor(uv),\n        f = (fract(uv));\n    \n    vec2 u = f*f*f*(6.0*f*f - 15.0*f +10.0);  // from Ken Perlin's improved noise\n    //vec2 u = f*f*(3.-2.*f);                 // simpler formula (s-curve)\n    float dot1, dot2, dot3, dot4;\n    \n    dot1 = dot(2.*(hash22(p)) - 1.0, f);\n    dot2 = dot(2.*(hash22(p + vec2(1., 0.)))-1.0 , f - vec2(1.,0.));\n    dot3 = dot(2.*(hash22(p + vec2(0., 1.)))-1.0, f - vec2(0.,1.));\n    dot4 = dot(2.*(hash22(p + vec2(1., 1.)))-1.0, f - vec2(1.,1.));\n   \n    float m1, m2;\n    \n    m1 = mix(dot1, dot2, u.x);\n    m2 = mix(dot3, dot4, u.x);\n    \n    return mix(m1, m2, u.y);\n}\n\n// This gradient noise makes sure gradients lie on the unit-circle and it \nfloat gradnoise_circular(vec2 uv, float power)\n{\n    vec2 p = floor(uv),\n        f = (fract(uv));\n    \n    vec2 u = f*f*f*(6.0*f*f - 15.0*f +10.0);\n    //vec2 u = f*f*(3.-2.*f);\n    float dot1, dot2, dot3, dot4;\n    \n    vec2 hash00, hash10, hash01, hash11;\n    vec2 grad00, grad10, grad01, grad11;\n  \n    hash00 = hash22(p);\n    hash01 = hash22(p + vec2(0., 1.));\n    hash10 = hash22(p + vec2(1., 0.));\n    hash11 = hash22(p + vec2(1., 1.));\n\n    // Calculate gradients. The sin and cos part makes sure that the gradient vectors are\n    // unit length. Since the hash values range from 0...1 we need to bring them in the\n    // range of 2 PI which describes a whole circle, so gradient vectors point in any\n    // possible direction.\n    // The pow function at the end is what makes the intensities of the gradients more\n    // uneven, so we get a more irregular pattern of the noise. If the 'power' value gets \n    // too high, the noise starts looking bad though.\n    // One could\n \t//Gradients shall lie on the unit circle\n    grad00 = vec2(sin(hash00.x * PI * 2. + iTime), cos(hash00.x * PI * 2. + iTime)) * (pow(hash00.y, power));\n    grad01 = vec2(sin(hash01.x * PI * 2. + iTime), cos(hash01.x * PI * 2. + iTime)) * (pow(hash01.y, power));\n    grad10 = vec2(sin(hash10.x * PI * 2. + iTime), cos(hash10.x * PI * 2. + iTime)) * (pow(hash10.y, power));\n    grad11 = vec2(sin(hash11.x * PI * 2. + iTime), cos(hash11.x * PI * 2. + iTime)) * (pow(hash11.y, power));\n    \n    dot1 = dot(grad00, f);\n    dot2 = dot(grad10, f - vec2(1.,0.));\n    dot3 = dot(grad01, f - vec2(0.,1.));\n    dot4 = dot(grad11, f - vec2(1.,1.));\n  \n /*   Classic approach\n    dot1 = dot((hash22(p)), f);\n    dot2 = dot((hash22(p + vec2(1., 0.))) , f - vec2(1.,0.));\n    dot3 = dot((hash22(p + vec2(0., 1.))) , f - vec2(0.,1.));\n    dot4 = dot((hash22(p + vec2(1., 1.))) , f - vec2(1.,1.));\n*/    \n    float m1, m2;\n    \n    m1 = mix(dot1, dot2, u.x);\n    m2 = mix(dot3, dot4, u.x);\n   \n   // return abs(box_mueller_transform(hash00)).x;\n    return mix(m1, m2, u.y);\n}\n\nvec2 calc_pos_width(float pos, float width)\n{\n    float low, high;\n    \n    low = pos - width/2.0;\n    high = pos + width/2.0;\n    return clamp(vec2(low, high), vec2(0.0), vec2(1.0));\n}\n\nfloat oct_gained_gradnoise(vec2 uv, float octaves, float roughness, float octscale, float power)\n{\n    float a = 0.;\n    float intensity = 1.;\n    float oct_intensity = 1.0; // first intensity is 1.0, successive octaves get scaled by roughness value\n    float total_scale = 0.0;\n    float remap;\n\n    float contrast = 0.999;\n    float gain = .00111;\n\n    for(float i = 0.; i < octaves; i++)\n    {\n        float gradnoise_lookup = gradnoise_circular(uv, power)*1.75;\n        \n        remap = gradnoise_lookup;\n        remap = gainf((gradnoise_lookup*.5 + .5), gain);\n       // remap = gainf(clamp((gradnoise_lookup*.5 + .5), 0.0, 1.0), gain);\n        remap = ((remap - 0.5) * 2.); \n        \n\t\ttotal_scale += oct_intensity;\n        a += remap* oct_intensity;\n        oct_intensity*= roughness; // get intensity for current octave\n        \n        if(DO_ROTATE)\n        \tuv = rot_golden(vec2(11.1231, 11.1231), uv) * octscale;\n        else\n        \tuv = uv * octscale;\n    }\n    // applying contrast and clamping it\n\t\n    a = (a/(1.0 -contrast)) ;\n    a= clamp(a/total_scale, -1., 1.0);\n    return a; // if we were dividing just by octaves we'd get an intensity shift\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvMouse;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += iTime*.1;\n    \n    // check for out of range coords (which happens at the start or after\n    // change of resolution)\n    if (iMouse.xy==vec2(0) )\n        uvMouse = vec2(0.75, 0.5);\n    else\n        uvMouse = (iMouse.xy/iResolution.xy);\n        \n    //if(int(iMouse.xy) == 0 || iMouse.x > iResolution.x || iMouse.y > iResolution.y)\n    //    uvMouse = vec2(0.75, 0.5);\n    //else\n\t//\tuvMouse = (iMouse.xy/iResolution.xy);\n     \n\n    int octaves = int(ceil(uvMouse.x * 10.));\n    float power = uvMouse.y * 6.+.1;\n    float roughness = 1.1; //uvMouse.y*1.5;\n    \n    \n    // Static gradnoise\n    float octscale = 2.0; //factor by which each octave gets smaller than the previous one\n    float final_value;\n    \n    final_value = oct_gained_gradnoise(uv * 2., float(octaves), roughness, octscale, power);\n    \n    \n    //antialiasing\n    /*\n\tfloat acc = 0.;\n    for(float i = 0.; i < AA; i++)\n        for(float j = 0.; j < AA; j++)\n        {\n            acc += oct_gained_gradnoise((uv + vec2(i*step_size.x, j*step_size.y)) * 2., float(octaves), roughness, octscale);\n         }\n\tacc /= AA*AA ;    \n*/\n   // final_value = acc;\n    final_value = final_value*0.5 + 0.5;\n    \n    \n    \n    if(fragCoord.x > iResolution.x/2.)\n    {\n        vec2 low_high = calc_pos_width(sin(iTime * .5)*.3 + .3, sin(iTime*.43321578)*.35 + .4);\n        \n        //antialiasing  \n   \t\tfloat AA = BOXFILTER_SAMPLES;\n        vec2 pixel_size = vec2(1.)/iResolution.xy;\n        vec2 step_size = pixel_size/AA * 1.5;\n        float acc = 0.;\n\t\tfloat lookup = 0.0;\n        for(float i = 0.; i < AA; i++)\n            for(float j = 0.; j < AA; j++)\n            {\n                lookup = oct_gained_gradnoise((uv + vec2(i*step_size.x, j*step_size.y)) * 2., float(octaves), roughness, octscale, power);\n\t\t\t\tacc += smoothstep(low_high.x, low_high.y, lookup);\n             }\n        acc /= AA*AA ;    \n    \tfinal_value = acc;\n        \n        \n       \n    }\n\n  \n    if(mod(fragCoord.x, iResolution.x /2.) < 1.)\n\t\tfinal_value = 0.;\n\n    fragColor = vec4(final_value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1039, 1217, 1238, 1238, 1375], [1378, 1378, 1410, 1455, 1579], [1581, 1617, 1652, 1718, 1922], [1925, 1925, 1958, 1958, 2579], [2581, 2656, 2704, 2704, 4699], [4701, 4701, 4746, 4746, 4886], [4888, 4888, 4986, 4986, 6054], [6056, 6056, 6113, 6113, 8311]], "test": "timeout"}
{"id": "3sXcRl", "name": "Linked Rings 2", "author": "dr2", "description": "Several Moebius strips (an update of the original)", "tags": ["moebius"], "likes": 16, "viewed": 268, "published": "Public API", "date": "1585301660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Linked Rings 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nmat3 vuMat;\nvec3 ltDir;\nfloat dstFar, tCur, mobRad;\nconst float pi = 3.14159;\n\nfloat MobiusTDf (vec3 p, float r, float b, float rc, float ns)\n{\n  vec3 q;\n  float d, a, na, aq;\n  p.xz = Rot2D (p.xz, 0.2 * tCur);\n  q = vec3 (length (p.xz) - r, 0., p.y);\n  a = atan (p.z, p.x);\n  q.xz = Rot2D (q.xz, 0.5 * a);\n  d = length (max (abs (q.xz) - b, 0.)) - rc;\n  q = p;\n  na = floor (ns * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / ns;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 0.5 * aq);\n  d = min (d, PrBoxDf (q, vec3 (1.2, 1.2, 0.33) * b));\n  return 0.7 * d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, a, aq, na;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  q = p;\n  q.z = abs (q.z) - 1.4 * mobRad;\n  d = MobiusTDf (q, mobRad, 0.5, 0.01, 24.);\n  q = p;\n  q.y = abs (q.y) - 1.4 * mobRad;\n  d = min (d, MobiusTDf (q.xzy, mobRad, 0.5, 0.01, 24.));\n  q = p;\n  d = min (d, MobiusTDf (q.zxy, mobRad, 0.5, 0.01, 24.));\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd = rd * vuMat;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (0.05 * tCur + rd.xy / rd.z);\n  return mix (mix (vec3 (0., 0., 0.6), vec3 (1.), 1.4 * Fbm2 (2. * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ror, rdr, vn, col;\n  float dstObj, dstObjR, reflFac;\n  dstObj = ObjRay (ro, rd);\n  reflFac = 1.;\n  if (dstObj < dstFar) {\n    ror = ro + dstObj * rd;\n    rdr = reflect (rd, ObjNf (ror));\n    ror += 0.01 * rdr;\n    dstObjR = ObjRay (ror, rdr);\n    if (dstObjR < dstFar) {\n      dstObj = dstObjR;\n      ro = ror;\n      rd = rdr;\n      reflFac = 0.7;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col = vec3 (0.3, 0.3, 0.6) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    col = reflFac * mix (col, BgCol (reflect (rd, vn)), 0.5);\n  } else col = 0.7 * BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.05 * tCur;\n    el -= 0.2 * pi * cos (0.05 * tCur);\n  }\n  dstFar = 50.;\n  mobRad = 2.5;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 2.8));\n  ro = vuMat * vec3 (0., 0., -20.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[321, 321, 385, 385, 835], [837, 837, 859, 859, 1195], [1197, 1197, 1230, 1230, 1407], [1409, 1409, 1430, 1430, 1678], [1680, 1680, 1702, 1702, 2010], [2012, 2012, 2047, 2047, 2748], [2750, 2750, 2806, 2806, 3445], [3447, 3447, 3479, 3479, 3574], [3576, 3576, 3606, 3606, 3719], [3721, 3721, 3757, 3757, 3963], [3997, 3997, 4021, 4021, 4133], [4135, 4135, 4160, 4160, 4346], [4348, 4348, 4369, 4369, 4524]], "test": "error"}
{"id": "3sXcRN", "name": "Sol LeWitt", "author": "Sasquatch5", "description": "A shader interpretation of Sol LeWitt's \"Complex Form with Black and White Bands\"", "tags": ["sollewitt", "blackandwhitebands"], "likes": 4, "viewed": 106, "published": "Public", "date": "1584221579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lineScale = 1.0/30.0;\nfloat cellBorderScale = 1.0/15.0;\nvec3 stripColor = vec3(228.0/255.0,230.0/255.0,229.0/255.0);\nvec3 bgColor = vec3(55.0/255.0,55.0/255.0,53.0/255.0);\n\nfloat maxDistance = 7.0;\nfloat movementSpeed = 0.05;\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,314.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat cellIndex;\n    float md = maxDistance;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime * movementSpeed + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            cellIndex = o.g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = maxDistance;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime * movementSpeed + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr,cellIndex);\n}\n\nfloat getBorderDistance(vec2 uv)\n{\n    float aspect = (iResolution.y / iResolution.x);\n    vec2 borderUV = uv;\n    borderUV.y /= aspect;\n    borderUV.x -= 0.5;\n    borderUV.y -= 0.5;\n    borderUV = abs(borderUV);\n    borderUV = 1.0-borderUV;\n    borderUV.x -= aspect /2.578;\n    float maxDistance = min(borderUV.x,borderUV.y * aspect);\n    maxDistance *= 35.0;\n    maxDistance -= 9.8;\n    maxDistance /= 1.5;\n    return maxDistance;\n}\n\nfloat getFrameBorders(vec2 uv)\n{\n\tfloat borderDistance = getBorderDistance(uv);\n    borderDistance -= 3.14159 / 1.47;\n    borderDistance *= step(borderDistance,-0.9);\n    borderDistance = abs(sin(borderDistance*4.0));\n    borderDistance -= 0.15;    \n    borderDistance = smoothstep(0.45,0.55,borderDistance);\n\treturn 1.0-borderDistance;\n}\n\n\nfloat getCellBorders(vec4 voronoi)\n{\n    return smoothstep(0.04,0.05,voronoi.r);\n}\n\nfloat getInternalCellLines(vec2 uv, vec4 v)\n{\n    float dir = pow(v.w/10.0,0.75)* 3.14159 * 2.0;\n    \n    float sinDir = sin(dir);\n    float cosDir = cos(dir);\n   \tmat2 rotMatrix = mat2(cosDir,sinDir,-sinDir,cosDir);\n    \n    vec2 voronoiUV = uv;\n    voronoiUV = rotMatrix * (voronoiUV);\n    voronoiUV /= lineScale;\n    return voronoiUV.x; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    vec4 voronoi = voronoi(maxDistance *  uv); \n    \n    float lineOpacity = 1.0;\n    \n    //internal cel strips\n    lineOpacity = smoothstep(0.45,0.55,abs(fract(getInternalCellLines(uv,voronoi))-0.5)*2.0);\n\t\n    //cell borders\n    lineOpacity = min(lineOpacity,getCellBorders(voronoi));\n\n    //frame borders\n    float borderCutoff = smoothstep(0.51,0.49,getBorderDistance(uv)-0.66);\n    lineOpacity = mix(lineOpacity,getFrameBorders(uv),borderCutoff);\n    \n    \n    vec3 col = mix(bgColor,stripColor,lineOpacity);\n\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 272, 303, 393], [395, 395, 422, 422, 1624], [1626, 1626, 1660, 1660, 2060], [2062, 2062, 2094, 2094, 2400], [2403, 2403, 2439, 2439, 2485], [2487, 2487, 2532, 2532, 2829], [2831, 2831, 2888, 2938, 3533]], "test": "timeout"}
{"id": "3sXyDM", "name": "Julia2D", "author": "NY", "description": "a", "tags": ["2d"], "likes": 1, "viewed": 43, "published": "Public", "date": "1584862602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HSV カラー生成関数\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n      vec2 p  = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    \n    int j = 0;\n    vec2 x = vec2(-0.345, 0.654);\n    vec2 y = vec2(iTime * 0.005, 0.0);\n    vec2 z = p;\n    for(int i = 0; i < 360; i++){\n        j++;\n        if(length(z) > 2.0){break;}\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + x + y;\n    }\n\n    // 時間の経過で色を HSV 出力する\n    float h = mod(iTime * 20.0, 360.0) / 360.0;\n    vec3 rgb = hsv(h, 1.0, 1.0);\n    \n    // 漸化式で繰り返した回数をもとに輝度を決める\n    float t = float(j) / 360.0;\n    \n    // 最終的な色の出力\n    fragColor = vec4(rgb * t, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 65, 65, 244], [246, 246, 303, 353, 999]], "test": "ok"}
{"id": "3sXyDX", "name": "what the frac 1kb", "author": "gopher", "description": "shadertoy port of what the frac, presented at Geeks can dance 2012.\nhttps://www.pouet.net/prod.php?which=60091", "tags": ["1k"], "likes": 1, "viewed": 82, "published": "Public", "date": "1585670124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 r(inout vec2 x,float y)\n{\n\treturn x=vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\n}\n\n// julia function\nfloat s(vec3 x,float y) \n{\n\tfloat R=y;//1.21;\n\tfor(int i=0;i<50;i++)\n    {\n        r(x.xy,R);\n        r(x.zx,R);\n        r(x.yz,R);\n        x=(abs(x-vec3(.7,.4,-2))+vec3(.7,.4,-2))*1.13+vec3(-1,.02,-.85);\n    }\n\treturn length(x)/455.0;\n}\n\nvoid mainImage(out vec4 O,vec2 c)\n{\n\tfloat z = (iTime+16.) * 1000.;\n    \n\tfloat d=0.;\n    float o=0.;\n    float p=0.;\n    float u=z/2056.;\n    float b=mod(u,4.)<3.?1.-mod(u,1.):0.;\n    float v=u< 8.?1.9:\n    \t\tu<16.?1.9+.05*b:\n    \t\tu<24.?-2.-b:\n    \t\tu<32.?.25-(u-24.)/32.:\n    \t\tu<40.?1.3-.1*b:\n    \t\t1.9+.05*b;\n\t\n    vec3 t=vec3(0.,0.,u<8.?16.-u*2.:5.+3.*sin(u));    \n    vec3 y=normalize(vec3(c/iResolution.xy-.5,-.5));\n    \n    r(t.xz,-u/2.);\n    r(t.yz,-u/2.);\n    r(y.xz,-u/2.);\n    r(y.yz,-u/2.);\n    \n\tfor(int i=0;i<150&&d<50.;i++)\n    {\n        b=p;\n        d+=p=s(t+d*y,v);\n        o+=exp(-abs(p-b));\n    }\n\tO = vec4(.8,.9,1.,0.)*.014*o;\n\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 93], [95, 113, 139, 139, 350], [352, 352, 387, 387, 1015]], "test": "ok"}
{"id": "3sXyRN", "name": "Corridor Travel", "author": "NuSan", "description": "Inspired by \"past racer\" by jetlab", "tags": ["pathtracing"], "likes": 210, "viewed": 6090, "published": "Public", "date": "1584218994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by \"past racer\" by jetlab\n\n// Lower this if too slow\nfloat steps = 30.0;\n\nfloat time=0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n// Camera rotation\nvoid cam(inout vec3 p, float t) {\n  t*=0.3;\n  p.xz *= rot(sin(t)*0.3);\n  p.xy *= rot(sin(t*0.7)*0.4);\n}\n\nfloat hash(float t) {\n  return fract(sin(t*788.874));\n}\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(hash(floor(t)), hash(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)),10.0));\n}\n\nfloat tick(float t, float d) {\n  t/=d;\n  float m=fract(t);\n  m=smoothstep(0.0,1.0,m);\n  m=smoothstep(0.0,1.0,m);\n  return (floor(t)+m)*d;\n}\n\nfloat hash2(vec2 uv) {\n  return fract(dot(sin(uv*425.215+uv.yx*714.388),vec2(522.877)));\n}\n\nvec2 hash22(vec2 uv) {\n  return fract(sin(uv*425.215+uv.yx*714.388)*vec2(522.877));\n}\n\nvec3 hash3(vec2 id) {\n  return fract(sin(id.xyy*vec3(427.544,224.877,974.542)+id.yxx*vec3(947.544,547.847,652.454))*342.774);\n}\n\nfloat camtime(float t) {\n  \n  return t*1.9 + tick(t, 1.9)*1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time=mod(iTime, 300.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 col=vec3(0);\n  \n  vec3 size = vec3(0.9,0.9,1000);\n  \n  float dof = 0.02;\n  float dofdist = 1.0/5.0;\n  \n    // Path tracing\n  for(float j=0.0; j<steps; ++j) {\n      \n    // DOF offset\n    vec2 off=hash22(uv+j*74.542+35.877)*2.0-1.0;\n      \n    // Motion blur offset\n    float t2=camtime(time + j*0.05/steps);\n    \n    vec3 s=vec3(0,0,-1);\n    s.xy += off*dof;\n    vec3 r=normalize(vec3(-uv-off*dof*dofdist, 2));\n    \n    cam(s,t2);\n    cam(r,t2);\n    \n    vec3 alpha=vec3(1);\n      \n    // Bounces\n    for(float i=0.0; i<3.0; ++i) {\n        \n      // box collision\n      vec3 boxmin = (size-s)/r;\n      vec3 boxmax = (-size-s)/r;\n      \n      vec3 box=max(boxmin,boxmax);\n        \n      // only check box x and y axis\n      float d = min(box.x,box.y);\n      vec3 p=s+r*d;\n      vec2 cuv = p.xz;\n      vec3 n=vec3(0,sign(box.y),0);\n        \n      if(box.x<box.y) {\n         \n        cuv=p.yz;\n        cuv.x+=1.0;\n        n=vec3(sign(box.x),0.0,0.0);\n\t\t\t\n      }\n     \n      vec3 p2 = p;\n      p2.z += t2*3.0;\n      cuv.y += t2*3.0;\n      cuv *= 3.0;\n      vec2 id = floor(cuv);\n      \n      float rough = min(1.0,0.85+0.2*hash2(id+100.5));\n      \n      vec3 addcol = vec3(0);\n      //addcol += max(vec3(0),vec3(0.0,sin(cuv.y*0.12 + time*1.7),0.4 + 0.4*sin(cuv.y*0.07 + time*2.3))*4.0*step(hash2(id),0.1));\n      //addcol += max(vec3(0),sin(cuv.y*vec3(0.12,0.07,0.02)*0.5 + 1.0*t2*vec3(1.7,2.3,3.7))) * step(hash2(id),0.1);\n      addcol += vec3(1.0+max(0.0,cos(cuv.y*0.025)*0.9),0.5,0.2+max(0.0,sin(cuv.y*0.05)*0.5))*2.0;\n      addcol *= smoothstep(0.5*curve(time+id.y*0.01+id.x*0.03, 0.3),0.0,hash2(id));\n      //addcol *= 0.5+curve(t2+cuv.y*0.3, 0.3);\n      //addcol *= step(0.5,sin(p2.x)*sin(p2.z*0.4+curve(t2, 0.1)*1.0));\n      addcol *= step(0.5,sin(p2.x)*sin(p2.z*0.4));\n      addcol += vec3(0.7,0.5,1.2)*step(p2.y,-0.9)*max(0.0,curve(time,0.2)*2.0-1.0)*step(hash2(id+.7),0.2);\n      col += addcol * alpha;\n      \n      float fre = pow(1.0-max(0.0,dot(n,r)),3.0);\n      alpha *= fre*0.9;\n      \n      vec3 pure=reflect(r,n);\n      \n      r=normalize(hash3(uv+j*74.524+i*35.712)-0.5);\n      float dr=dot(r,n);\n      if(dr<0.0) r=-r;\n      r=normalize(mix(r,pure,rough));\n      \n      s=p;\n    }\n\n  }\n  col /= steps;\n  \n  col *= 2.0;\n  \n  col=smoothstep(0.0,1.0,col);\n  col=pow(col, vec3(0.4545));\n  \n    \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 122, 122, 193], [195, 214, 247, 247, 317], [319, 319, 340, 340, 374], [376, 376, 407, 407, 507], [509, 509, 539, 539, 648], [650, 650, 672, 672, 740], [742, 742, 764, 764, 827], [829, 829, 850, 850, 956], [958, 958, 982, 982, 1022], [1024, 1024, 1081, 1081, 3594]], "test": "timeout"}
{"id": "3sXyRr", "name": "Sunshine Day #1", "author": "Koztar", "description": "Sunshine Day #1", "tags": ["wave"], "likes": 3, "viewed": 122, "published": "Public", "date": "1583949147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 q = fract(p)*2.0 -1.0;\n    return length(max(abs(q)-s,0.0));\n}\n\n\nfloat trace (vec3 o,vec3 r)\n{\n    float t = 0.0;\n    for(int i=0;i<50;i++)\n    {\n        vec3 p = o+r*t;\n        float d0 = box(p-vec3(0,0,0),vec3(0.25,1,0.5));\n        t+=d0*0.5;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv-= 1.0;\n    uv/= vec2(iResolution.y/iResolution.x,1.0);\n\n    vec3 r = normalize(vec3(uv,0.1));\n    float tt = time*0.25;\n    r.yz *= sin((r.yz*100.0+tt));\n    vec3 o = vec3(0,0,tt);\n    \n    float t = trace(o,r);\n\n    float fog = 0.5/(1.0+t*t*0.1); \n    fragColor = vec4(vec3(fog+vec3(1,0.3,0.0)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 116], [119, 119, 148, 148, 320], [323, 323, 380, 380, 763]], "test": "ok"}
{"id": "3sXyRs", "name": "Julia set Animation", "author": "NdMaloxit", "description": "my first shared", "tags": ["fractal", "julia", "animation"], "likes": 1, "viewed": 64, "published": "Public", "date": "1585321687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER_COUNT 100\n#define ITER_SQR_SIZE 9.\n#define JUL_ANIMATE\n#define CENTER_X 0.\n#define CENTER_Y 0.\n#define COLOR_MAX 16\n//#define COLOR_BW\n#define COLOR_DIV\nvec2 Transform(vec2 p, vec2 from_point1, vec2 from_point2, vec2 to_point1, vec2 to_point2) {\n  return vec2((p.x - from_point1.x)* (to_point2.x - to_point1.x) / (from_point2.x - from_point1.x) + to_point1.x, (p.y - from_point1.y)* (to_point2.y - to_point1.y) / (from_point2.y - from_point1.y) + to_point1.y);\n}\n\nbool IsInsideDisk(vec2 p, vec2 center, float sqrRadius) {\n  vec2 delta = p - center;\n  return (delta.x*delta.x + delta.y*delta.y) < sqrRadius;\n}\n\nint JuliaInerationCount(vec2 p, vec2 c) {\n  int i;\n  vec2 iterPoint = p;\n  vec2 calcPoint;\n  for (i = 0; i < ITER_COUNT && IsInsideDisk(iterPoint, p, ITER_SQR_SIZE); i++) {\n    calcPoint.x = iterPoint.x * iterPoint.x - iterPoint.y * iterPoint.y + c.x;\n    calcPoint.y = 2. * iterPoint.x * iterPoint.y + c.y;\n    iterPoint = calcPoint;\n  }\n  return (ITER_COUNT - i);\n}\nfloat sampleMusicA() {\n\treturn 0.5 * (\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\n}\nvec3 s_palette[COLOR_MAX] = vec3[COLOR_MAX](\n    vec3(0., 1., 0.),\n    vec3(1., 1., 1.),\n    vec3(0., 0., 1.),\n    vec3(1., 0.7, 0.),\n    vec3(0., 1., 0.),\n    vec3(0., 1., 1.),\n    vec3(0.3, 0.3, 1.), \n    vec3(1., 0.7, 0.), \n    vec3(0., 1., 0.), \n    vec3(1., 1., 1.), \n    vec3(0., 0., 1.), \n    vec3(1., 0.7, 0.), \n    vec3(0., 1., 0.), \n    vec3(1., 1., 1.), \n    vec3(0., 0., 1.), \n    vec3(0.3, 0.2, 0.9)\n);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 f_color;\n    int iter, k;\n    float t, a;\n    float screenScale = min(iResolution.x,iResolution.y);\n    vec2 screen_point1 = vec2(iResolution.x/2. - screenScale/2., iResolution.y/2. - screenScale/2.);\n    vec2 screen_point2 = vec2(iResolution.x/2. + screenScale/2., iResolution.y/2. + screenScale/2.);\n    vec2 math_center = vec2(CENTER_X, CENTER_Y);\n    float scale = 1.5;\n    vec2 math_point1 = vec2(-scale, -scale) + math_center;\n    vec2 math_point2 = vec2(scale, scale) + math_center;\n    vec2 c = vec2(-0.500934515513869749377, -0.52287731735700945607);\n    float pulse = 0.5+sampleMusicA()*1.8;\n#ifdef JUL_ANIMATE\n    float angle = (iTime + 0.9*sin(iTime/2.) - 0.2)*0.3;\n    float radius = 0.32;\n    \n    c.x = (radius * sin(angle));\n    c.y = (radius - radius * cos(angle));\n#endif  //!JUL_ANIMATE\n    \n    iter = JuliaInerationCount(Transform(fragCoord, screen_point1, screen_point2, math_point1, math_point2), c);\n#ifdef COLOR_BW\n    f_color.x = float(iter);\n    f_color.y = float(iter);\n    f_color.z = float(iter);\n    f_color /= float(ITER_COUNT);\n#else\n    #ifdef COLOR_DIV\n    f_color.x = float((iter + 4) % 12);\n    f_color.y = float((iter + 8) % 12);\n    f_color.z = float((iter + 0) % 12);\n    f_color /= 12.;\n    #else\n    t = float(iter) / float(ITER_COUNT + 1);\n    t = pow(t, 3.);\n    k = int(t * float(COLOR_MAX));\n    a = (t * float(COLOR_MAX)) - float(k);\n    f_color = (1. - a) * s_palette[k] + a * s_palette[k + 1];\n    #endif //!COLOR_DIV\n#endif  //!COLOR_BW\n    if (iter == 0) {\n      fragColor = vec4(0., 0., 0.4, 1.);\n    }\n    else {\n   \t  fragColor = vec4(f_color, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 258, 258, 475], [477, 477, 534, 534, 621], [623, 623, 664, 664, 990], [991, 991, 1013, 1013, 1126], [1543, 1543, 1600, 1600, 3220]], "test": "error"}
{"id": "3sXyzB", "name": "Aurorus", "author": "falldeaf", "description": "Copy of Nimitz's shader with only two changes, removed slowly panning horizontally effect and hard-coded an x and y mouse value for a sky only view. (and commented out reflection) \n\nI made these changes to use with my Lively Wallpaper desktop bg system", "tags": ["aurorus"], "likes": 3, "viewed": 336, "published": "Public API", "date": "1584988841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Auroras by nimitz 2017 (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd)\n{\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd)\n{\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<50.;i++)\n    {\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float rzt = triNoise2d(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n        \n    }\n    \n    col *= (clamp(rd.y*15.+.4,0.,1.));\n    \n    \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\n    \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\n        p *= 1.3;\n    }\n    return c*c*.8;\n}\n\nvec3 bg(in vec3 rd)\n{\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iResolution.xy+1.4;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    //rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n    else //Reflections\n    {\n        /*\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n\t\t*/\n    }\n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1537, 1537, 1558, 1558, 1610], [1664, 1664, 1686, 1686, 1728], [1729, 1729, 1750, 1750, 1800], [1802, 1802, 1842, 1842, 2250], [2252, 2252, 2276, 2276, 2341], [2342, 2342, 2373, 2373, 3311], [3377, 3377, 3401, 3401, 3592], [3594, 3594, 3617, 3617, 4039], [4041, 4041, 4062, 4062, 4236], [4301, 4301, 4358, 4358, 5453]], "test": "ok"}
{"id": "3tGSRV", "name": "UV distortion texture test", "author": "shrekshao", "description": "uv distortion mimicking that from Florence", "tags": ["uvdistortionprocedural"], "likes": 3, "viewed": 102, "published": "Public", "date": "1583104380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Noise function\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//----------\n\nvec2 flowUV(vec2 uv)\n{\n    // distort uv basic test\n    //uv.x += 0.1 * cos(9. * uv.y);\n    \n    vec2 offset = vec2( snoise(4. * cos(1.3 * uv + 0.01 * iTime)), snoise(3. * sin(1.5 * uv.yx + 0.01 * iTime) ) );\n    offset = offset * 2.0 - 1.0;\n    uv += 0.05 * offset;\n    \n    \n    return uv;\n}\n\n#define LINE_WIDTH 0.03\n\nfloat plot(float v, float pct){\n  return  smoothstep( pct-LINE_WIDTH, pct, v) -\n          smoothstep( pct, pct+LINE_WIDTH, v);\n}\n\n#define UV_GRID_STEPS 10.0\nvec3 uvGrid(vec2 uv)\n{\n    float size = 1.0 / UV_GRID_STEPS;\n    vec2 r = uv - floor(uv / size) * size;\n    r *= UV_GRID_STEPS;\t\t// vale in each grid is 0 - 1\n    \n    // 0 - 1 color gradient\n    //vec3 col = vec3(r, 0.0);\n    \n    // grid line\n    //vec3 col = vec3( smoothstep(r, vec2(0.48), vec2(0.52) ), 0.0);\n    //vec3 col = vec3( plot(r.x, 0.5), plot(r.y, 0.5), 0.0);\n    vec3 col = vec3( max(plot(r.x, 0.5), plot(r.y, 0.5)) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    //vec3 col = vec3( snoise(uv * 5. + iTime), 0., 0.);\n    \n        \n    uv = flowUV(uv);\n    \n    // uv grid pattern\n    // or replace with texture image sampling\n    \n    //vec3 col = uvGrid(uv);\n    vec3 col = texture(iChannel0, uv).rgb;\n    col += uvGrid(uv);\n    \n    \n    // // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 42, 42, 91], [93, 93, 114, 114, 163], [165, 165, 187, 187, 224], [226, 226, 250, 250, 1756], [1772, 1772, 1794, 1859, 2065], [2092, 2092, 2123, 2123, 2220], [2249, 2249, 2271, 2271, 2706], [2708, 2708, 2765, 2815, 3341]], "test": "error"}
{"id": "3tGXzd", "name": "\u0010Simple Raymarching Demo", "author": "takumifukasawa", "description": "demo for my blog entry:\nhttps://takumifukasawa.hatenablog.com/entry/context2d-cpu-raymarching", "tags": ["raymarching", "demo"], "likes": 1, "viewed": 53, "published": "Public", "date": "1583336697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define EPS .0001\n#define NORMAL_EPS .0001\n\nconst float stopThreshold = .0001;\n\nfloat scene(vec3 p) {\n    return length(p) - 1.;\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx)\n        )\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(\n    \tcos(iTime) * 5.,\n        0.,\n        sin(iTime) * 5.\n    );\n    vec3 target = vec3(0.);\n    float fov = 1.5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    for(int i = 0; i < 64; i++) {\n    \tdist = scene(ro + rd * depth);\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += dist;\n    }\n    \n    // no hit\n    if(dist >= stopThreshold) {\n    \tfragColor = vec4(vec3(0.), 1.);\n        return;\n    }\n    \n    vec3 color = vec3(0.);\n   \n    vec3 position = ro + rd * depth;\n    vec3 normal = getNormal(position);\n    \n    // directional lighting\n    vec3 lightPos = vec3(-1., 1., 1.);\n    float lambert = max(0., dot(normal, normalize(lightPos)));\n\tcolor += lambert * vec3(1.);    \n    \n    // gamma\n    color = pow(clamp(color, 0., 1.), vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 102, 102, 131], [133, 133, 162, 162, 323], [325, 325, 349, 349, 581], [583, 583, 638, 638, 1659]], "test": "ok"}
{"id": "3tGXzK", "name": "Blending shapes", "author": "ti", "description": "Smooth minimum functions comparison.\n\nsmin code from iq\ndraw code from hughsk", "tags": ["sdf"], "likes": 0, "viewed": 44, "published": "Public", "date": "1583097756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* ref.: https://hughsk.io/fragment-foundry/chapters/09b-blending-shapes.html\n *       http://iquilezles.org/www/articles/smin/smin.htm\n *       https://www.shadertoy.com/view/XsyGRW\n */\n\n#define myTime iTime * 8.0\n\n// 0 = Polynomial #1 (quadratic)\n// 1 = Polynomial #2 (cubic)\n// 2 = Exponential\n// 3 = Power\n#define FUNCTION -1\n\n#if FUNCTION == 0\n  #define SMIN(a, b) polynomial_smin(a, b, 0.1)\n#elif FUNCTION == 1\n  #define SMIN(a, b) cubic_smin(a, b, 0.1)\n#elif FUNCTION == 2\n  #define SMIN(a, b) exponential_smin(a, b, 32.0)\n#elif FUNCTION == 3\n  #define SMIN(a, b) power_smin(a, b, 8.0)\n#else\n  #define SMIN(a, b) min(a, b)\n#endif\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nfloat polynomial_smin(float a, float b, float k) {\n  // float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  // return mix(b, a, h) - k * h * (1.0 - h);\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) -  h * h * k * (1.0 / 4.0);\n}\n\nfloat cubic_smin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) -  h * h * h * k * (1.0 / 6.0);\n}\n\nfloat exponential_smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return log(res) / k;\n}\n\nfloat power_smin(float a, float b, float k) {\n  a = pow(a, k);\n  b = pow(b, k);\n  return pow((a * b) / (a + b), 1.0 / k);\n}\n\nfloat distanceField(vec2 point, vec2 origin1, vec2 origin2, float radius) {\n  float d1 = length(point - origin1) - radius;\n  float d2 = length(point - origin2) - radius;\n  return SMIN(d1, d2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0; // [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n  \n    vec2 origin = vec2(sin(myTime * 0.11) * 0.3);\n    float radius = (sin(myTime * 0.25) * 0.5 + 0.5) * 0.3 + 0.05;\n    float dist = distanceField(uv, origin, -origin, radius);\n\t\n    fragColor = vec4(draw_distance(dist, uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[638, 638, 680, 680, 788], [790, 790, 815, 815, 848], [850, 850, 877, 877, 939], [941, 941, 978, 978, 1411], [1413, 1413, 1463, 1566, 1657], [1659, 1659, 1704, 1704, 1799], [1801, 1801, 1852, 1852, 1918], [1920, 1920, 1965, 1965, 2043], [2045, 2045, 2120, 2120, 2239], [2241, 2241, 2296, 2296, 2640]], "test": "ok"}
{"id": "3tKGzV", "name": "Symmetry linear - Grid", "author": "NoxWings", "description": "Symmetry linear - Grid", "tags": ["symmetrylineargrid"], "likes": 7, "viewed": 200, "published": "Public API", "date": "1584154052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SURF_HIT 0.001\n#define FAR_PLANE 50.\n#define animTime iTime\n#define S(x,y,z) smoothstep(x,y,z)\n#define A(v1,v2,t1,t2) mix(v1,v2,S(t1,t2,iTime))\n\nconst float PI = 3.14159;\n\nmat2 r2d(float a) {float sa=sin(a), ca=cos(a);return mat2(ca, -sa, sa, ca);}\n\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n    float fold = 5.0;\n    q = mod(q, fold) - fold*.5;\n    float d = length(q.xy) - 0.4;\n    d = min(d, length(q.xz) - 0.4);\n    d = min(d, length(q.yz) - 0.4);\n    return d;\n}\n\nvec3 mapNormal(vec3 p) {\n    vec2 e = vec2(SURF_HIT, 0);\n    float m = map(p);\n    return normalize(vec3(\n    \tm - map(p - e.xyy),\n        m - map(p - e.yxy),\n        m - map(p - e.yyx)\n    ));\n}\n\nfloat mapTrace(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0;i<128;i++) {\n        float h = map(ro + rd * d);\n        if (h < SURF_HIT || d >= FAR_PLANE) break;\n        d += h;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y * 1.0;\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv, -1));\n    \n    \n    ro += vec3(0, 0, -5.* animTime);\n    rd.xy *= r2d(PI * mix(animTime * 0.1, animTime * 0.1 - 0.3, sin(animTime * PI * 0.3)));\n\n    float d = mapTrace(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = mapNormal(p);\n\n    vec3 fogCol = vec3(1);\n    vec3 col = fogCol;\n    if (d < FAR_PLANE) {\n        vec3 outer = vec3(0.9);\n        vec3 inner = vec3(0.1, 0.1, 0.1);\n        \n        float f = pow(clamp(1.0 - dot(-rd, n), 0.0, 1.0), 1.5);\n        float fog = clamp(pow(d/FAR_PLANE, 1.), 0.0, 1.0);\n        \n        col = f * outer + (1.0 - f) * inner;        \n        col = mix(col, fogCol, vec3(fog));\n    }\n\n    fragColor = vec4(col, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 199, 199, 256], [258, 258, 277, 277, 474], [476, 476, 500, 500, 671], [673, 673, 707, 707, 880], [882, 882, 939, 939, 1763]], "test": "timeout"}
{"id": "3tKSRV", "name": "AlternatingBits", "author": "Reva", "description": "Ex03", "tags": ["2d", "random"], "likes": 4, "viewed": 87, "published": "Public", "date": "1583145359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author Reva - 2020-03-02\n\nfloat random(in float num){\n    float rnd = fract(sin(num*23.123 + (step(0.0,mod(iTime,3.0)))*floor(iTime/3.0))*9382.2942);\n    return rnd;\n}\n\nfloat random2(in vec2 st){\n    float rnd = fract(sin(dot(floor(st),vec2(12.762,8.329)))*3523.20392);\n    return rnd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(0.5) - uv;\n    uv.x *= 200.0;\n    uv.y *= (sin(iTime * 0.2) + 1.1)*6.0;\n    uv.x += random(floor(uv.y)) * (step(1.0,mod(uv.y,2.0))*2.0 - 1.0) * iTime * 10.5;\n    uv.y *= fract(random(floor(uv.y))*10.0);\n\n    // Time varying pixel color\n    vec3 col = vec3(step(random(floor(uv.y)+0.2),random2(uv)));\n    col *= vec3(fract(uv.y),random(floor(uv.x)),random(floor(uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 56, 56, 170], [172, 172, 198, 198, 290], [292, 292, 349, 349, 831]], "test": "ok"}
{"id": "3tKSWt", "name": "Ref-e#61924.0", "author": "jorge2017a1", "description": "Ref-e#61924.0\nt's a copy of Kali's work\n https://www.shadertoy.com/view/4lX3Rj from 5 years ago.", "tags": ["refe619240"], "likes": 63, "viewed": 828, "published": "Public", "date": "1583853868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\nfloat ot=0.;\nfloat det=0.;\nfloat hitfloor;\nfloat hitrock;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tt;\n\nfloat de(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tot=1000.;\n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    float fl=pos.y-3.013;\n    float d=min(fl,length(p)/DEfactor-.0005);\n\td=min(d,-pos.y+3.9);\n    d=min(d,rr);\n    if (abs(d-fl)<.0001) hitfloor=1.;\n    if (abs(d-rr)<.0001) hitrock=1.;\n    return d;\n}\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\t\tfloat totalDist =2.0*det, sh=1.;\n \t\tfor (int steps=0; steps<30; steps++) {\n\t\t\tif (totalDist<1.) {\n\t\t\t\tvec3 p = pos - totalDist * sdir;\n\t\t\t\tfloat dist = de(p)*1.5;\n\t\t\t\tif (dist < detail)  sh=0.;\n\t\t\t\ttotalDist += max(0.05,dist);\n\t\t\t}\n\t\t}\n\t\treturn max(0.,sh);\t\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*80.;\n\tfloat totao = 0.0;\n    float sca = 10.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet + aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 5.0*totao, 0.0, 1.0 );\n}\n\nfloat kset(vec3 p) {\n\tp=abs(.5-fract(p*20.));\n\tfloat es, l=es=0.;\n\tfor (int i=0;i<13;i++) {\n\t\tfloat pl=l;\n\t\tl=length(p);\n\t\tp=abs(p)/dot(p,p)-.5;\n\t\tes+=exp(-1./abs(l-pl));\n\t}\n\treturn es;\t\n}\n\nmat2 rot;\n\nvec3 light(in vec3 p, in vec3 dir) {\n\tfloat hf=hitfloor;\n\tfloat hr=hitrock;\n\tvec3 n=normal(p);\n\tfloat sh=clamp(shadow(p, lightdir)+hf+hr,.4,1.);\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh*1.3;\n\tfloat amb=max(0.2,dot(dir,-n))*.4;\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,10.)*(.5+ao*.5);\n\tfloat k=kset(p)*.18; \n\tvec3 col=mix(vec3(k*1.1,k*k*1.3,k*k*k),vec3(k),.45)*2.;\n\tvec3 pp=p-vec3(0.,3.03,tt);\n    pp.yz*=rot;\n    if (hr>0.) col=vec3(.9,.8,.7)*(1.+kset(pp*2.)*.3);\n    col=col*ao*(amb*vec3(.9,.85,1.)+diff*vec3(1.,.9,.9))+spec*vec3(1,.9,.5)*.7;\t\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\tfloat t=iTime;\n\tfloat cc=cos(t*.03); float ss=sin(t*.03);\n    rot=mat2(cc,ss,-ss,cc);\n    vec2 lig=vec2(sin(t*2.)*.6,cos(t)*.25-.25);\n\tfloat fog,glow,d=1., totdist=glow=fog=0.;\n\tvec3 p, col=vec3(0.);\n\tfloat ref=0.;\n\tfloat steps;\n\tfor (int i=0; i<130; i++) {\n\t\tif (d>det && totdist<3.5) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\t\n            det=detail*(1.+totdist*35.);\n\t\t\ttotdist+=d; \n\t\t\tglow+=max(0.,.012-d)*exp(-totdist);\n\t\t\tsteps++;\n\t\t}\n\t}\n\tfloat l=pow(max(0.,dot(normalize(-dir),normalize(lightdir))),10.);\n\tvec3 backg=vec3(.78,.85,1.)*.25*(2.-l)+vec3(1.,.9,.65)*l*.4;\n\tfloat hf=hitfloor;\n    \n\tif (d<det) {\n\t\tcol=light(p-det*dir*1.5, dir); \n\t\tif (hf>0.5) col*=vec3(1.,.85,.8)*.6;\n\t\tcol*=min(1.2,.5+totdist*totdist*1.5);\n\t\tcol = mix(col, backg, 1.0-exp(-1.3*pow(totdist,1.3)));\n\t} else { \n\t\tcol=backg;\n\t}\n\tcol+=glow*vec3(1.,.9,.8)*.234;\n\tcol+=vec3(0.7,.8,.6)*pow(l,3.)*.5;\n\treturn col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttt=iTime*.05;\n    vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n\tfloat y=(cos(iTime*.1+3.)+1.);\n    \n\tif (iMouse.z<1.) mouse=vec2(sin(t*2.),cos(t)+.3)*.15*(.5+y)*min(1.,iTime*.1);\n\tuv+=mouse*1.5;\n\tuv.y-=.1;\n    \n\tvec3 from=vec3(0.0,3.04+y*.1,-2.+iTime*.05);\n\tvec3 dir=normalize(vec3(uv*.75,1.));\n\tvec3 color=raymarch(from,dir);\t\n    \n\tcolor*=vec3(1.,.94,.87);\n\t///color=pow(color,vec3(1.2));\n    \n    color=pow(color,vec3(0.78902));\n\tcolor=mix(vec3(length(color)),color,.85)*.95;\n\tcolor+=vec3(1,.85,.7)*pow(max(0.,.3-length(uv-vec2(0.,.03)))/.3,1.5)*.65;\n    \n\tfragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 289, 289, 382], [395, 395, 415, 415, 959], [961, 961, 982, 982, 1133], [1135, 1135, 1170, 1170, 1432], [1434, 1434, 1482, 1482, 1812], [1814, 1814, 1834, 1834, 2002], [2015, 2015, 2051, 2051, 2626], [2628, 2628, 2671, 2671, 3564], [3566, 3566, 3623, 3623, 4315]], "test": "timeout"}
{"id": "3tKSWV", "name": "Hex Neon Love", "author": "tutmann", "description": "Mix of https://www.shadertoy.com/view/WdK3Dz and https://www.shadertoy.com/view/wtdSzX", "tags": ["2d", "bezier", "heart", "glow", "curve", "neon", "hexagonalgrid"], "likes": 28, "viewed": 737, "published": "Public API", "date": "1583623088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a mix of:\n// https://www.shadertoy.com/view/WdK3Dz and https://www.shadertoy.com/view/wtdSzX\n\n\n#define POINT_COUNT 8\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.5;\nconst float len = 0.25;\nconst float scale = 0.017;\nfloat intensity = 0.8;\nfloat radius = 0.03;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(16.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));\n    }\n    return max(0.0, dist);\n}\n\n#define FLAT_TOP_HEXAGON\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453);\n}\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p)\n{    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    #else\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    #endif    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p)\n{    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    \n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n    \n    \n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, translating, then converting it to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    float us = sin(iTime/5.0)*40.0+45.0;\n    vec2 ut = vec2(sin(iTime/2.), cos(iTime/3.0));\n    vec2 hp = u*us + ut;\n    vec4 h = getHex(hp);\n    float eDist = hex(h.xy); // Edge distance.\n    vec3 border = mix(vec3(1.), vec3(0), smoothstep(0., 0.06, eDist - .5 + .12));\n    vec2 hu = (h.zw*s - ut) / us;\n    pos = vec2(1,-1)*hu;    \n    \n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos, 0.0);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Pink glow\n    col += glow * vec3(0.94,0.14,0.4);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 3.4);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Blue glow\n    col += glow * vec3(0.2,0.6,1.0);\n        \n    //Tone mapping\n    col = 1.0 - exp(-col);\n\n    //Output to screen\n    fragColor = vec4(col*border,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 357, 406, 406, 1682], [1685, 1732, 1763, 1763, 1916], [1918, 1958, 2015, 2015, 2057], [2059, 2059, 2109, 2109, 2605], [2921, 2921, 2943, 2943, 3009], [3011, 3340, 3362, 3362, 3536], [3538, 4230, 4251, 4630, 5468], [5470, 5470, 5526, 5526, 7135]], "test": "timeout"}
{"id": "3tKXDV", "name": "Modular Multiplication 3D", "author": "ElVago", "description": "░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n░░░░░░░░░░░░░░░██░░░░░░░░░░░░░░░\n░░░░░░░░░░░░░██████░░░░░░░░░░░░░\n░░░░░░░░░░░░░░░██░░░░░░░░░░░░░░░\n░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░", "tags": ["multiplication"], "likes": 2, "viewed": 47, "published": "Public", "date": "1584037586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define MULTIPLIER 50.\n#define MODULE 200. //Number of Vectors\n\nvec4 get_color(vec2 uv, float mul, vec4 color) {\n    float step_angle =2. * PI / float(MODULE);\n    float start_angle = PI / 2.0;\n    float end_angle = PI / 2.0;\n\n    for (float i = 0.; i < MODULE; i++) {\n        vec2 line_start = vec2(sin(start_angle), cos(start_angle));\n        if (distance(line_start, uv) < .02)//Point thickness.\n            return vec4(1., 0.0, .0, 1.); //Point color.\n\n        vec2 line_end = vec2(sin(end_angle), cos(end_angle+5000.));//Put the vectors out of the circle.\n        vec2 line_dir = line_end - line_start*5.;//\n        float distance_to_line = abs(line_dir.y * uv.x -line_dir.x * uv.y + line_start.x * line_end.y - line_start.y * line_end.x) / length(line_dir);\n        if (distance_to_line < 2. / iResolution.y &&\n                dot(uv - line_start, line_dir) > 0. &&\n           \t\tdot(uv - line_end, line_dir) < 0.)\n            return color;\n        \n        start_angle += step_angle;\n        end_angle += mul * step_angle;\n    }\n\n    return vec4(0.);//Background color.\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord + fragCoord - iResolution.xy) / (iResolution.y-75.0);//Ball size.\n\n    float mul = 1.0 + MULTIPLIER * (1. - cos(.02 * iTime));//Speed.\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);//Color of vectors.\n\n    fragColor = get_color(uv, mul, color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 137, 137, 1102], [1104, 1104, 1159, 1159, 1427]], "test": "ok"}
{"id": "3tKXWV", "name": "6/2020", "author": "rimina", "description": "Continuum of my daily shader thing. I started to work on this shader few days ago and am still continuing. Yesterday's version: https://www.shadertoy.com/view/wtKSDy . Today I added some reflections and corrected shadows and fine tuned ids.", "tags": ["raymarching", "lighting"], "likes": 2, "viewed": 69, "published": "Public", "date": "1583630527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 128\n#define E 0.001\n#define gamma vec3(2.2)\n\nconst vec3 AMBIENT = vec3(0.2, 0.4, 0.64);\nconst vec3 LC1 = vec3(0.3, 0.6, 0.8);\nconst vec3 LC2 = vec3(0.6, 0.4, 0.3);\nconst vec3 FOG = vec3(0.64, 0.62, 0.6);\n\nstruct Material{\n    vec3 lambertian;\n    vec3 specular;\n    float shininess;\n    bool reflective;\n    bool refractive;\n};\n\n\nMaterial getGroundMaterial(){\n    Material mat;\n    mat.lambertian = vec3(0.3, 0.3, 0.5);\n    mat.specular = vec3(0.64, 0.62, 0.6);\n    mat.shininess = 40.0;\n    mat.reflective = false;\n    mat.refractive = false;\n    \n    return mat;\n}\n\nMaterial getBlockMaterial(in vec2 id){\n    vec2 s = smoothstep(vec2(0.4), vec2(0.8), id);\n    \n    Material mat;\n    mat.lambertian = vec3(id.x, s.y, s.x);\n    mat.specular = vec3(s.y, id.x, s.x);\n    mat.shininess = 8.0;\n    mat.reflective = mod(id.x, 2.0) == 0.0;\n    mat.refractive = false;\n    \n    return mat;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\nfloat scene(in vec3 p, out Material mat){\n    \n    float pl = dot(p, normalize(vec3(0.0, 1.0, 0.0)))+1.0;\n    pl -= smoothstep(0.0, 1.0, noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.2));\n    \n    vec3 pp = p;\n    vec2 n = vec2(2.7, 8.0);\n    vec2 dif = n*0.5;\n    pp.xz = mod(p.xz+dif, n)-dif;\n    vec2 id = abs(floor((p.xz+dif)/n));\n    float idx = 1.0+sin(id.x);\n    \n    vec3 d = abs(pp)-vec3(1.0,\n             abs(cos(idx)+sin(id.y))+0.5,\n             1.0);\n    float sp = length(max(max(d.x, d.y), d.z));\n    \n    vec3 gd = abs(pp)-vec3(n.x, 5.0, n.y)*0.5;\n    \n    float guard = -length(max(max(gd.x, gd.y), gd.z));\n    guard = abs(guard) + n.x*0.1;\n    \n    if(sp < guard && sp < pl){\n        mat = getBlockMaterial(id);\n    }\n    else{\n        mat = getGroundMaterial();\n    }\n    \n    return min(min(sp, guard), pl);\n}\n\nfloat march(in vec3 o, in vec3 d, in float far, in bool inside, out vec3 p, out bool hit, out Material mat){\n    float t = 0.0;\n    float dir = inside ? -1.0 : 1.0;\n    hit = false;\n    for(int i = 0; i < STEPS; ++i){\n        p = o + d*t;\n        float dist = dir*scene(p, mat);\n        \n        if(abs(dist) < E || t > far){\n            if(abs(dist) < E ){\n            \thit = true;\n            }\n            break;\n        }\n        t += dist;\n    }\n    \n    return t;\n}\n\nvec3 normal(in vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    Material mat;\n    return normalize(vec3(\n        scene(p+eps.xyy, mat) - scene(p-eps.xyy, mat),\n        scene(p+eps.yxy, mat) - scene(p-eps.yxy, mat),\n        scene(p+eps.yyx, mat) - scene(p-eps.yyx, mat)\n    ));\n}\n\nvec3 phong(in vec3 n, in vec3 d, in vec3 ld, in Material mat){\n    float lamb = max(dot(n,ld), 0.0);\n    vec3 angle = reflect(n, ld);\n    float spec = pow(max(dot(d, angle), 0.0), mat.shininess);\n    \n    return (lamb*mat.lambertian*0.5 + spec*mat.specular*0.8);\n}\n\nvec3 fog(in vec3 col, in vec3 p, in vec3 ro, in vec3 rd, in vec3 ld, in vec3 lc){\n    float d = length(p-ro);\n    float sa = max(dot(rd, -ld), 0.0);\n    float fa = 1.0-exp(-d*0.05);\n    vec3 fc = mix(FOG, lc, pow(sa, 4.0));\n    return mix(col, fc, fa);\n}\n\nvec3 shade(in vec3 p, in vec3 d, in vec3 ld, in vec3 lp, in Material mat){\n    \n    vec3 n = normal(p);\n    \n    vec3 col = phong(n, d, ld, mat);\n    \n    float l = distance(p, lp);\n    bool hit = false;\n    vec3 sp = vec3(0.0);\n    Material mats;\n    float st = march(p+E*n*2.0, ld, 40.0, false, sp, hit, mats);\n    vec3 s = vec3(1.0);\n    if(hit){\n        s = vec3(0.1, 0.2, 0.3);\n    }\n    \n    vec3 reflected = vec3(0.0);\n    if(mat.reflective){\n        hit = false;\n        vec3 refd = reflect(d, n);\n        float rt = march(p+E*n*2.0, refd, 20.0, false, sp, hit, mats);\n        if(hit){\n            vec3 nr = normal(sp);\n            reflected = phong(nr, refd, ld, mats);\n        }\n        else if(rt >= 20.0){\n            reflected = FOG*0.2;\n        }\n        col = mix(col, reflected, 0.5);\n        \n    }\n    \n    return col*s;\n}\n\nmat3 camera(in vec3 o, in vec3 t, in vec3 up){\n    \n    vec3 z = normalize(t-o);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    \n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv*2.0-1.0;//scaling from -1 to 1\n    q.x *= (iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(0.0, 2.5, iTime);\n    vec3 rt = vec3(0.0, -4.0, 10.0+iTime);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam = camera(ro, rt, up);\n    vec3 rd = normalize(cam*vec3(q, radians(60.0)));\n    \n    vec3 p = vec3(0.0);\n    bool hit = false;\n    Material mat;\n    float t = march(ro, rd, 40.0, false, p, hit, mat);\n    vec3 col = AMBIENT * 0.6;\n    \n    vec3 lp = vec3(2.0*sin(iTime*0.5)+iTime, -4.0, 1.0+2.0*cos(iTime*0.5)+iTime);\n    vec3 lt = vec3(0.0, 0.0, -10.0+iTime);\n    vec3 ld = normalize(lt-lp);\n    vec3 ld2 = normalize(ro-rt);\n    \n    if(hit){\n        vec3 c = shade(p, rd, ld, lp, mat);\n        c += shade(p, rd, -ld2, ro, mat);\n        c *= 0.5;\n        col += c;\n    }\n    \n    col = fog(col, p, ro, rd, ld, LC1);\n    col += fog(col, p, ro, rd, -ld2, LC2);\n    col *= 0.5;\n    \n    col = pow(smoothstep(0.08, 1.1, col)*smoothstep(0.8, 0.005*0.799, \n          distance(uv, vec2(0.5))*(0.8 + 0.005)), 1.0/gamma);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 373, 373, 580], [582, 582, 620, 620, 898], [900, 926, 946, 946, 1225], [1228, 1228, 1269, 1269, 2052], [2054, 2054, 2162, 2162, 2525], [2527, 2527, 2550, 2550, 2803], [2805, 2805, 2867, 2867, 3069], [3071, 3071, 3152, 3152, 3325], [3327, 3327, 3401, 3401, 4167], [4169, 4169, 4215, 4215, 4357], [4359, 4359, 4416, 4466, 5608]], "test": "timeout"}
{"id": "3tKXzG", "name": " Menger Tunnel-v1", "author": "jorge2017a1", "description": " Menger Tunnel-v1", "tags": ["mengertunnelv1"], "likes": 2, "viewed": 54, "published": "Public", "date": "1583023116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por Jorge F.p *(jorge2017a1)\n//Referencia https://www.shadertoy.com/view/XslGzl ,, gracias a fb39ca4 \n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\nfloat scene(vec3 p) {\n\tfloat scale = 1.5;\n\tfloat dist = 0.0;\n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y+5.0;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n            \t\n          {\t\n              //cielo\n              res=vec2(res.x,6); \n          }\n        else\n         { \n            //res=vec2(res.x, 9);\n             //piso\n             res=vec2(res.x, 8);\n         } \n     }\n\t\n    \n    \n    float sdf1=scene(p);\n    res=opU(res, vec2(sdf1,11 ));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightv3(vec3 p,  vec3 pLight)\n{\n    vec3 lightPos = pLight;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n/*\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n    \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n*/\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(85./255., 205./255., 252./255.);\n    }\n    \n    if(i== 1 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.5, 0.35, 0.75);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n        \n     \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tvec2 mousePos = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n\t\n\tvec3 cameraPos = vec3(0.16 * sin(iTime*0.25), 0.16 * cos(iTime*0.25), iTime*0.25);\n\t//vec3 cameraPos = vec3(0.0);\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * (iResolution.y / iResolution.x);\n\n\tvec3 ro = cameraPos;\n\tvec3 rd = cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV;\n\t\n\trd = normalize(rd);\n       \n    ///----------------------------------------\n    vec3 col = vec3(0);\n    \n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n   \n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    float dif = GetLightv3(p, ro-vec3(0.,0.0,-1.0));\n    mObj.dist =d;\n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \tcol =  ( vec3(dif)+colobj)/1.5;\n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[552, 569, 602, 602, 667], [668, 686, 722, 722, 791], [792, 807, 838, 838, 988], [989, 1009, 1045, 1045, 1132], [1133, 1149, 1181, 1209, 1270], [1272, 1272, 1308, 1308, 1411], [1414, 1488, 1546, 1546, 1810], [1814, 1814, 1896, 1896, 2127], [2130, 2130, 2161, 2161, 2349], [2352, 2406, 2428, 2428, 3688], [3691, 3755, 3791, 3791, 4064], [4116, 4116, 4162, 4162, 4194], [4196, 4196, 4239, 4239, 4271], [4273, 4273, 4321, 4321, 4354], [4357, 4357, 4386, 4386, 4512], [4514, 4514, 4550, 4550, 4667], [4669, 4669, 4705, 4705, 4823], [4826, 4826, 4862, 4862, 4985], [5038, 5050, 5072, 5072, 5380], [5381, 5407, 5432, 5432, 5622], [5623, 5668, 5685, 5685, 5758], [5761, 5794, 5820, 5820, 6017], [6064, 6064, 6116, 6116, 6271], [6336, 6445, 6482, 6482, 6517], [6519, 6519, 6538, 6538, 6613], [6662, 6662, 6685, 6685, 6711], [6715, 6715, 6737, 6737, 6807], [6810, 6865, 6888, 6888, 7023], [7025, 7025, 7051, 7051, 7108], [7110, 7110, 7150, 7150, 7184], [7186, 7186, 7207, 7207, 7376], [7434, 7434, 7459, 7459, 8182], [8185, 8185, 8219, 8219, 8579], [8584, 8584, 8608, 8608, 8840], [8844, 8844, 8884, 8884, 9243], [9247, 9247, 9272, 9272, 9300], [9302, 9302, 9354, 9354, 9750], [9853, 9897, 9914, 9914, 9985], [10010, 10102, 10127, 10127, 10390], [12033, 12033, 12061, 12061, 14336], [14339, 14339, 14396, 14396, 15385]], "test": "error"}
{"id": "3tVSRK", "name": "polar coords - r+theta rotation", "author": "iradicator", "description": "An experimental effect using polar coordinate syste by rotating the polar coordinates (that is, radius and angle), origin is also animated. \nMore information: \nhttps://iradicator.com/screen-space-effects-using-polar-coordinates-linear-transformations/", "tags": ["2d", "effect", "linear", "polar"], "likes": 2, "viewed": 49, "published": "Public", "date": "1584810615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SQRT2 1.41421356237\n\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n#define sqrLength(x) dot((x),(x))\n\nfloat clamp01(in float v) { return clamp(v, 0.0, 1.0); }\nvec2 clamp01(in vec2 v) { return vec2(clamp01(v.x), clamp01(v.y)); }\n\n//////////////\n// Controls //\n//////////////\n\n// True iff using polar coordinates (otherwise cartesian) \n#define IS_USING_POLAR_COORD 1\n\n// Mix ratio between colorful uv and actual final image\n#define SHOWING_UV_RATIO 0.0 /* 0.0 - 1.0 */\n\n// Colorful uv is polar coordinates (0 for texture, not cartesian!) \n#define IS_UV_POLAR 0\n\n//////////////////////\n// Texture Sampling //\n//////////////////////\n\nvec4 sample_clamp(in sampler2D tex, in vec2 uv) \n{\n    return textureGrad(tex, clamp01(uv), dFdx(uv), dFdy(uv));\n}\n\nvec4 sample_repeat(in sampler2D tex, in vec2 uv) \n{\n    return textureGrad(tex, fract(uv), dFdx(uv), dFdy(uv));\n}\n\nvec4 sample_border(in sampler2D tex, in vec2 uv) \n{\n    bool isInBorder = ((0.0 <= uv.x) && (uv.x <= 1.0) && (0.0 <= uv.y) && (uv.y <= 1.0));\n    if (isInBorder)\n        return textureGrad(tex, fract(uv), dFdx(uv), dFdy(uv));\n    return vec4(1.0, 0.0, 1.0, 1.0); // bg color - magenta    \n}\n\n////////////////////////\n// Coordinate Systems //\n////////////////////////\n\nvec2 tex_to_cartesian(in vec2 uv, in vec2 origin)\n{\n    uv = 2.0 * uv - 1.0;\n    uv -= origin;\n    return uv;\n}\n\nvec2 cartesian_to_tex(in vec2 uv, in vec2 origin)\n{\n    uv += origin;\n    uv = 0.5 * uv + 0.5;\n    return uv;\n}\n\nvec2 tex_to_polar(in vec2 uv, in vec2 origin)\n{\n    uv = tex_to_cartesian(uv, origin);\n    float r = length(uv); \n    float theta = atan(uv.y, uv.x);\n    return vec2(r, theta);\n}\n\nvec2 polar_to_tex(in vec2 rt, in vec2 origin)\n{\n    float x = rt.x * cos(rt.y);\n    float y = rt.x * sin(rt.y);  \n    return cartesian_to_tex(vec2(x,y), origin);\n}\n\n////////////////\n// Transforms //\n////////////////\n\nvec2 get_origin(in float t)\n{\n    return 0.33 * vec2(cos(t), sin(t));\n}\n\nmat2 rotation_matrix(in float alpha)\n{\n    float cosa = cos(alpha);\n    float sina = sin(alpha);\n    return mat2(cosa, -sina, sina, cosa); \n}\n\nvec2 transform(in vec2 uv, in float t)\n{    \n    return rotation_matrix(t) * uv;\n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 origin = get_origin(0.25 * iTime);\n                \n    // uv_s: tex coord -> cartesian / polar coord   \n    vec2 uv_s = fragCoord / iResolution.xy;\n#if IS_USING_POLAR_COORD\n    uv_s = tex_to_polar(uv_s, origin);\n#else\n    uv_s = tex_to_cartesian(uv_s, origin);\n#endif\n      \n    // uv_s -> uv_t: transform   \n    vec2 uv_t = transform(uv_s, iTime);\n    \n    // uv_e: transformed cartesian / polar coord -> transformed tex coord\n#if IS_USING_POLAR_COORD\n\tvec2 uv_e = polar_to_tex(uv_t, origin);\n#else\n    vec2 uv_e = cartesian_to_tex(uv_t, origin);\n#endif    \n    \n    // uv_c: coloring the uv in texture / polar space\n#if IS_UV_POLAR        \n    vec3 uv_c = vec3(tex_to_polar(uv_e, origin).xy, 0.0);\n#else\n\tvec3 uv_c = vec3((uv_e - origin).xy, 0.0);\n#endif\n        \n    // final composition: texture, colorful uv or alpha (uv_s + uv_e mixture ratio)\n    vec3 col = mix(sample_border(iChannel0, uv_e).rgb, uv_c, SHOWING_UV_RATIO);    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 175, 175, 204], [205, 205, 230, 230, 273], [676, 676, 726, 726, 790], [792, 792, 843, 843, 905], [907, 907, 958, 958, 1197], [1275, 1275, 1326, 1326, 1386], [1388, 1388, 1439, 1439, 1499], [1501, 1501, 1548, 1548, 1679], [1681, 1681, 1728, 1728, 1844], [1898, 1898, 1927, 1927, 1969], [1971, 1971, 2009, 2009, 2112], [2114, 2114, 2154, 2154, 2196], [2262, 2262, 2317, 2317, 3303]], "test": "error"}
{"id": "3tVXWK", "name": "Basic voronoi with borders", "author": "maksy", "description": "Voronoi patterns according to\nhttps://www.youtube.com/watch?v=l-07BXzNdPw\nhttps://cyangamedev.wordpress.com/2019/07/16/voronoi/", "tags": ["voronoi"], "likes": 4, "viewed": 255, "published": "Public API", "date": "1585433868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n\nvec2 N22(vec2 p) {\n\tvec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \t\n    // normalize coordinates ranging from -1. to 1 and fix aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    uv*=4.;\n    \n    // divides the screen into a grid\n    // the id of a grid cell. X and y go from -4 to 4.\n    vec2 id = floor(uv); \n    \n    // inner coordinates of a grid cell\n    vec2 gv = fract(uv);\n    \n    // ####################################\n    // # First pass\n    // ####################################\n       \n    // index of the voronoi cell containing the shading point\n    vec2 cellIndex = vec2(0.);\n    \n    // the center of the voronoi cell\n    vec2 center = vec2(0.0);\n    \n    // Distance to the center\n    float minDist = 8.;  \n    \n    // the grid cell with the closest point\n    vec2 closestGridCell = vec2(0.);\n    \n    // finds which cell contains the closest point to the shading point. \n    // Only 9 cells in the grid must looped through.\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = 0.5+sin(N22(id+offset) * iTime)*0.5;\n            \n            float d = length(offset+n - gv);\n            if (d < minDist) {\n                center = offset+n - gv;\n                cellIndex = id+offset;\n                minDist = d;\n                closestGridCell = offset;\n            }\n        }\n    }\n    \n    // ####################################\n    // # Second pass\n    // ####################################\n    \n    // calculates distance to the closest border\n    \n    // performs neighbor search centered at the closest cell instead of\n    // the cell that contains the shading point\n    float borderDist = 8.0;\n    for (float y = -2.; y <= 2.; y++) {\n       for (float x = -2.; x <= 2.; x++) {\n            \n           vec2 offset = closestGridCell + vec2(x, y);\n           vec2 n = 0.5+sin(N22(id+offset)*iTime)*0.5;\n           \n           vec2 r = offset + n - gv;\n           \n           // skip the same cell\n           if (dot(center-r, center-r) > .01) {            \n           \tborderDist = min(borderDist, dot(0.5*(center+r),normalize(r-center)));\n           }\n        }\n     }\n    \n    vec3 col = vec3(minDist);\n       \n    if (cellIndex.x > 3.) {\n    \tcol = vec3(0.70, 0.62, 0.85);\n    }\n    \n    else if (cellIndex.x > -1.) {\n        col = vec3(0.99, 0.64, 0.66);\n    }\n    \n    else if (cellIndex.x > -5.) {\n        col = vec3(0.47, 0.87, 0.47);\n    }\n    \n     else if (cellIndex.x > -9.) {\n        col = vec3(0.46, 0.62, 0.80);\n    }\n    \n    // edges  \n    col = mix(vec3(0.2, 0.2, 0.2), col, S(0.01, 0.06, borderDist));\n    \n    // isolines\n    col -= abs(sin(100.0*minDist))*0.1;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 163], [165, 165, 222, 297, 2927]], "test": "timeout"}
{"id": "3tVXz3", "name": "Google Loading Spinner", "author": "stevekrouse", "description": "Imitates the Google/Andriod loading spinner: \n\nhttps://thomas.vanhoutte.be/miniblog/wp-content/uploads/spinningwheel.gif", "tags": ["spinner", "icon"], "likes": 2, "viewed": 148, "published": "Public", "date": "1583323817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    // https://thebookofshaders.com/08/\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat angle(vec2 pos) {\n    // a goes from PI to -PI\n    float a = atan(pos.y, pos.x);\n    \n    // divide by PI and it goes from 1 to -1\n    // add 1 and it goes from 0 to 2\n    // divide 2 and it goes 0 to 1\n    a = (1.+a/3.14159)/2.;\n    \n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    float antialias = 1.5 / iResolution.x;\n    \n    // circle outline\n    float radius = 0.14;\n    float width = 0.008;\n    float l = length(pos);\n    fragColor = 1.-vec4((smoothstep(width, width+antialias, abs(l-radius))));\n   \n    float t0 = (iTime*1.8)/3.;\n    float t = fract(t0)*1.1; \n    float cycle = floor(t0);\n    \n    // clip the circle by specifying two angles, a1, a2\n    float a1;\n    float a2;\n    if (t<=0.6) {\n      a1 = max(pow(1.-t-.04,3.), 0.1);\n      a2 = 1.;\n    } else {\n      a1 = 0.1;\n      a2 = max(pow(1.7-t, 3.), 0.2); \n    }   \n    \n    float a = angle(rotate2d(-4.*iTime + 1.26*cycle) *  pos); // from 0 to 1\n    \n    fragColor *= vec4(max(smoothstep(a,a+antialias, a1), smoothstep(a2,a2+antialias, a))); // a >= a1 || a <= a2\n    \n    fragColor = 1. - (fragColor * (1.-vec4(.1, 0.6, 1., 0.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 68, 154], [156, 156, 179, 208, 412], [414, 414, 471, 471, 1359]], "test": "ok"}
{"id": "3tySDt", "name": "8/2020", "author": "rimina", "description": "I'm still continuing on my daily shader project. Today I added some refraction to the scene an reorganized the code heavily. Yesterday's version is here: https://www.shadertoy.com/view/tlySD3", "tags": ["raymarching", "reflection", "refraction"], "likes": 1, "viewed": 74, "published": "Public", "date": "1583798075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 80\n#define E 0.001\n#define gamma vec3(2.2)\n\nconst vec3 AMBIENT = vec3(0.2, 0.4, 0.64);\nconst vec3 LC1 = vec3(0.3, 0.6, 0.8);\nconst vec3 LC2 = vec3(0.6, 0.4, 0.3);\nconst vec3 FOG = vec3(0.64, 0.62, 0.6);\n\nstruct Material{\n    vec3 lambertian;\n    vec3 specular;\n    float shininess;\n    bool reflective;\n    float refractive;\n    int id;\n};\n\n\nMaterial getGroundMaterial(){\n    Material mat;\n    mat.lambertian = vec3(0.1, 0.4, 0.5);\n    mat.specular = FOG;\n    mat.shininess = 4.0;\n    mat.reflective = false;\n    mat.refractive = 1.333;\n    mat.id = 0;\n    \n    return mat;\n}\n\nMaterial getBlockMaterial(in vec2 id){\n    vec2 s = smoothstep(vec2(0.2), vec2(0.8), id);\n    \n    Material mat;\n    mat.lambertian = vec3(s.x, s.y, s.x);\n    mat.specular = vec3(s.y, id.x, s.x);\n    mat.shininess = 40.0;\n    mat.reflective = mod(id.x, 2.0) == 0.0;\n    mat.refractive = 0.0;\n    if(mod(length(id), 4.0) == 0.0){\n        mat.refractive = 3.0;\n    }\n    \n    mat.id = 1;\n    \n    return mat;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\nfloat scene(in vec3 p, out Material mat){\n    \n    float pl = dot(p, normalize(vec3(0.0, 1.0, 0.0)))-cos(iTime*0.1)*0.5;\n    pl -= sin(noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.2));\n    \n    vec3 pp = p;\n    vec2 n = vec2(3.0, 8.0);\n    vec2 dif = n*0.5;\n    pp.xz = mod(p.xz+dif, n)-dif;\n    vec2 id = abs(floor((p.xz+dif)/n));\n    float idx = 1.0+sin(id.x);\n    float y = abs(cos(idx)+sin(id.y))+0.5;\n    \n    vec3 d = abs(pp-vec3(0.0, y, 0.0))-vec3(1.0, y, 1.0);\n    float sp = length(max(max(d.x, d.y), d.z));\n    \n    vec3 gd = abs(pp)-vec3(n.x, 10.0, n.y)*0.5;\n    \n    float guard = -length(max(max(gd.x, gd.y), gd.z));\n    guard = abs(guard) + n.x*0.1;\n    \n    if(pl < sp){\n        \n        mat = getGroundMaterial();\n    }\n    else{\n        mat = getBlockMaterial(id);\n    }\n    \n    return min(min(sp, guard), pl);\n}\n\nbool march(in vec3 o, in vec3 d, in float far, in bool inside, out vec3 p, out Material mat){\n    float t = E;\n    float dir = inside ? -1.0 : 1.0;\n    bool hit = false;\n    for(int i = 0; i < STEPS; ++i){\n        p = o + d*t;\n        float dist = dir*scene(p, mat);\n        \n        if(abs(dist) < E || t > far){\n            if(abs(dist) < E ){\n            \thit = true;\n            }\n            break;\n        }\n        t += dist;\n    }\n    \n    return hit;\n}\n\nvec3 normal(in vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    Material mat;\n    return normalize(vec3(\n        scene(p+eps.xyy, mat) - scene(p-eps.xyy, mat),\n        scene(p+eps.yxy, mat) - scene(p-eps.yxy, mat),\n        scene(p+eps.yyx, mat) - scene(p-eps.yyx, mat)\n    ));\n}\n\nvec3 phong(in vec3 n, in vec3 d, in vec3 ld, in Material mat){\n    float lamb = max(dot(n,ld), 0.0);\n    vec3 angle = reflect(n, ld);\n    float spec = pow(max(dot(d, angle), 0.0), mat.shininess);\n    \n    return (lamb*mat.lambertian*0.5 + spec*mat.specular*0.8);\n}\n\nvec3 fog(in vec3 col, in vec3 p, in vec3 ro, in vec3 rd, in vec3 ld, in vec3 lc){\n    float d = length(p-ro);\n    float sa = max(dot(rd, -ld), 0.0);\n    float fa = 1.0-exp(-d*0.05);\n    vec3 fc = mix(FOG, lc, pow(sa, 4.0));\n    return mix(col, fc, fa);\n}\n\nvec3 shadow(vec3 p, in vec3 ld){\n    vec3 s = vec3(1.0);\n    vec3 pr = p;\n    Material mat;\n    if(march(p, ld, 40.0, false, pr, mat)){\n        s = vec3(0.1, 0.2, 0.3);\n    }\n    \n    return s;\n}\n\nbool reflection(inout vec3 d, in vec3 n, inout vec3 p, out Material mat){\n    d = reflect(d, n);\n    vec3 pr = p;\n    if(march(p+n*E*2.0, d, 40.0, false, pr, mat)){\n        p = pr;\n        return true;\n    }\n    return false;\n}\n\nbool refraction(inout vec3 d, in vec3 n, in float index, in bool inside, inout vec3 p, out Material mat){\n    d = refract(d, n, index);\n    vec3 pr = p;\n    if(march(p-n*2.0*E, d, 20.0, inside, pr, mat)){\n        p = pr;\n        return true;\n    }\n}\n\nbool primary(in vec3 o, in vec3 d, out Material mat, out vec3 p, out vec3 n){\n    p = vec3(0.0);\n    n = vec3(0.0);\n    \n    if(march(o, d, 40.0, false, p, mat)){\n        n = normal(p);\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 shade(in vec3 rd, in vec3 p, in vec3 n, in vec3 ld, in Material mat){\n    vec3 col = phong(n, rd, ld, mat);\n    vec3 nr = n;\n    vec3 pr = p;\n    vec3 dir = rd;\n    Material matr;\n    if(mat.reflective){\n        if(reflection(dir, n, pr, matr)){\n            nr = normal(pr);\n            col += phong(nr, dir, ld, matr);\n        }\n        else{\n            col += FOG;\n        }\n    }\n    dir = rd;\n    pr = p;\n    if(mat.refractive != 0.0){\n        if(refraction(dir, n, 1.0/mat.refractive, true, pr, matr)){\n            nr = normal(pr);\n            col += phong(nr, dir, ld, matr);\n        }\n        if(refraction(dir, -nr, mat.refractive, false, pr, matr)){\n            nr = normal(pr);\n            col += phong(nr, dir, ld, matr);\n        }\n    }\n    col *= shadow(p+n*4.0*E, ld);\n    return col;\n}\n\nmat3 camera(in vec3 o, in vec3 t, in vec3 up){\n    \n    vec3 z = normalize(t-o);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    \n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv*2.0-1.0;//scaling from -1 to 1\n    q.x *= (iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(3.0, 4.5, iTime-30.0);\n    vec3 rt = vec3(0.0, -4.0, ro.z+10.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam = camera(ro, rt, up);\n    vec3 rd = normalize(cam*vec3(q, radians(60.0)));\n    \n    vec3 col = vec3(1.0);\n    \n    vec3 lp = vec3(20.0*sin(iTime*0.25)+ro.x, -10.0, 10.0*cos(iTime*0.25)+ro.z);\n    vec3 lt = ro;\n    vec3 ld = normalize(lt-lp);\n    vec3 ld2 = normalize(ro-rt);\n    \n    Material mat;\n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    \n    if(primary(ro, rd, mat, p, n)){\n        //Light 1\n        col = shade(rd, p, n, ld, mat);\n        //light 2\n        col += shade(rd, p, n, ld2, mat);\n        col *= 0.5;\n        col += AMBIENT*0.6;\n    }\n    \n    \n    \n    col = fog(col, p, ro, rd, ld, LC1);\n    col += fog(col, p, ro, rd, ld2, LC2);\n    col *= 0.5;\n    \n    col = smoothstep(0.08, 1.1, col);\n    \n    col *= smoothstep(0.8, 0.005*0.799, \n          distance(uv, vec2(0.5))*(0.8 + 0.005));\n    \n    col = pow(col, 1.0/gamma);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tySDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 385, 385, 589], [591, 591, 629, 629, 999], [1001, 1027, 1047, 1047, 1326], [1329, 1329, 1370, 1370, 2156], [2158, 2158, 2251, 2251, 2619], [2621, 2621, 2644, 2644, 2897], [2899, 2899, 2961, 2961, 3163], [3165, 3165, 3246, 3246, 3419], [3421, 3421, 3453, 3453, 3616], [3618, 3618, 3691, 3691, 3845], [3847, 3847, 3952, 3952, 4096], [4098, 4098, 4175, 4175, 4335], [4337, 4337, 4411, 4411, 5143], [5145, 5145, 5191, 5191, 5333], [5335, 5335, 5392, 5442, 6623]], "test": "error"}
{"id": "3tySWK", "name": " electricity circle", "author": "raidan00", "description": "electricity circle", "tags": ["circle", "electricity"], "likes": 2, "viewed": 137, "published": "Public", "date": "1583691930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float elec(vec2 st, float i){\n    if(fract(sin(i*100.)+iTime*0.7)> 0.5) return 0.;        \n    float ce = 0.;\t// ce - color electricity\n    st.s += sin(st.t*1.5+iTime+i);\n    st.t -= iTime/2.;\n    st.s -= iTime/5.+i*2.;\n    if(cos(st.s) > 0.){\n        float t = st.t*2.;\n        float m = min(fract(t), fract(1.-t))-0.25;\n        float b = 0.25;\n        float w = 0.0;\n        float v = sin(st.s)*1.5-m;\n        ce = 1.-smoothstep(w , w+b, v);\n        ce *= 1.-smoothstep(-w , -w-b, v);\n    }\n    return ce;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\tuv *= 2.;\n    // get polar coordinates\n    vec2 st = vec2(\n        atan(uv.x, uv.y),\n        length(uv)\n    );\n\t// draw eage circle\n    float r = 0.98;\n    float w = 0.005;\n    float b = fwidth(st.t);\n    float cc = smoothstep(r-w-b, r-w, st.t); // cc - circle color\n    cc *= 1.-smoothstep(r+w , r+w+b, st.t);\n    float ce = 0.;       // ce - color electricity\n    if(st.t < r-w){\n        for( float i = 0.; i < 13.; i += 1.){\n\t\t\tce += elec(st, i);\n        }\n    }\n    cc += ce;\n    fragColor = vec4(0.1, 0.1, cc*0.7, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tySWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 509], [510, 510, 567, 567, 1190]], "test": "ok"}
{"id": "3tyXDK", "name": "Combined fractal biome map", "author": "jarble", "description": "This map combines several of my fractal biomes into one large map.\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "biome"], "likes": 2, "viewed": 247, "published": "Public API", "date": "1583553741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint forest_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int FOREST_GREEN = 4;\n    int WHITE = 5;\n    return (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW)\n        ? GREEN\n    :(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors))\n        ? FOREST_GREEN\n    :(color1 == GRAY && is_next_to(GREEN,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? FOREST_GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :color1;\n\n}\n\nint savanna_biome(inout int color1, ivec4 neighbors){\n    int GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int YELLOW = 3;\n    int FOREST_GREEN = 4;\n    return (color1 == GREEN && is_next_to(GRAY,neighbors))\n    \t? YELLOW\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n    \t? FOREST_GREEN\n    :(color1 == GRAY)\n        ? GREEN\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    : color1;\n}\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nint swamp_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int WHITE = 4;\n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n    \t? YELLOW\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == GRAY && is_next_to(YELLOW,neighbors))\n        ? YELLOW\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nint forests_and_mountains(inout int color1, ivec4 neighbors){\n    int BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int WHITE = 4;\n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n    \t? YELLOW\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == GRAY && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = (biome == FORESTS_AND_MOUNTAINS)\n        ? forests_and_mountains(color1,neighbors)\n    : (biome == GLACIER_BIOME) ?\n        glacier_biome(color1,neighbors)\n    : (biome == SWAMP_BIOME) ?\n        forests_and_mountains(color1,neighbors)\n    : (biome == SAVANNA_BIOME) ?\n    \tsavanna_biome(color1,neighbors)\n    : (biome == FOREST_BIOME) ?\n    \tforest_biome(color1,neighbors)\n    : color1;\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[6],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\nint forest_biome(in vec2 fragCoord,float mag,float zoom,int[6] colors){\n    return biome(fragCoord,mag,zoom,colors,FOREST_BIOME);\n}\n\nint forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SAVANNA_BIOME);\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\nint swamp_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SWAMP_BIOME);\n}\n\nint swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nint water_biome(in vec2 fragCoord,float mag,float zoom,int colors[2]){\n    float num_colors = float(colors.length());\n    int color1 = magnify(fragCoord,mag,num_colors);\n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,num_colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return colors[color1];\n}\n\nint water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,int[](GREEN,BLUE));\n}\t\n\n\n\nint forests_and_mountains(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,FORESTS_AND_MOUNTAINS);\n}\n\nint forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nint combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    int color1 = forest_biome(fragCoord,mag,zoom/9.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,int[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,int[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nint combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    int color1 = glacier_biome(fragCoord,mag,zoom/9.0,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    return (color1 == GRAY)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE))\n    :(color1 == WHITE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE))\n    :(color1 == GREEN)\n   \t\t? forests_and_mountains(fragCoord,mag,zoom,int[](BLUE,SKYBLUE,SNOW,GRAY,WHITE))\n    :(color1 == BLUE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE))\n    : color1;\n}\n\nint deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    int color1 = glacier_biome(fragCoord,mag,zoom/9.0,int[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n    return (color1 == GRAY)\n    \t? forest_biome(fragCoord,mag,zoom,int[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME))\n    :(color1 == WHITE)\n    \t? forest_biome(fragCoord,mag,zoom,int[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME))\n    :(color1 == YELLOW)\n    \t? forest_biome(fragCoord,mag,zoom,int[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME))\n    :(color1 == GREEN)\n   \t\t? forests_and_mountains(fragCoord,mag,zoom,int[](TAN,LIME,SNOW,GRAY,YELLOW))\n    :(color1 == BLUE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE))\n    :color1;\n}\n\nint combined_biome(in vec2 fragCoord,float mag,float zoom){\n    int color1 = glacier_biome(fragCoord,mag,zoom/81.0);\n    return color1 == FOREST_GREEN\n    \t? forest_biome(fragCoord,mag,zoom)\n    : color1 == WHITE\n    \t? glacier_biome(fragCoord,mag,zoom)\n    : color1 == GRAY\n    \t? savanna_biome(fragCoord,mag,zoom)\n    : color1 == GREEN\n    \t? forests_and_mountains(fragCoord,mag,zoom)\n    : color1 == BLUE\n    \t? savanna_biome(fragCoord,mag,zoom,int[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE))\n    : color1;\n}\n\nint islands(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](BLUE,BLUE,GRAY,BLUE,GRAY));\n}\n\nint combined_islands(in vec2 fragCoord,float mag,float zoom){\n    int color1 = islands(fragCoord,mag,zoom);\n    return color1 == GRAY\n        ? savanna_biome(fragCoord,mag,zoom)\n    :color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom*((iMouse.x-iMouse.y+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tint biome =\n        //forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        combined_biome\n        //combined_islands\n        //combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1044], [1050, 1050, 1105, 1105, 1168], [1170, 1170, 1229, 1229, 1434], [1437, 1437, 1480, 1480, 1616], [1618, 1618, 1652, 1652, 1681], [1683, 1683, 1709, 1709, 3066], [3069, 3069, 3121, 3121, 3747], [3749, 3749, 3802, 3802, 4250], [4252, 4252, 4305, 4305, 4979], [4981, 4981, 5032, 5032, 5557], [5559, 5559, 5620, 5620, 6289], [6291, 6291, 6347, 6347, 6749], [6751, 6751, 6826, 6826, 7163], [7165, 7165, 7240, 7240, 7577], [8691, 8691, 8761, 8761, 9218], [12608, 12608, 12669, 12669, 12800], [12802, 12802, 12859, 12859, 13402]], "test": "error"}
{"id": "tdfcR7", "name": "Dancing Sheep", "author": "fisheep", "description": "Pixel art sheep, bouncing around all day long.\nWould like to hear about optimizations and more tips and tricks", "tags": ["simple", "pixelart"], "likes": 8, "viewed": 157, "published": "Public API", "date": "1584391458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 uv, float a)\n{\n    float cosa = cos(a), sina = sin(a);\n    return vec2(uv.x*cosa-sina*uv.y,uv.x*sina+uv.y*cosa);\n}\n\nbool rect(vec2 p, vec4 dim, vec3 inCol, out vec3 outCol)\n{\n    bool res = false;\n    if(abs(p.x-dim.x)<0.5*dim.z && abs(p.y-dim.y)<0.5*dim.w)\n    {\n        outCol = inCol;\n        res = true;\n    }\n    return res;\n}\n\n\nbool circle(vec2 p, vec3 circ, vec3 inCol,bool outline, out vec3 outCol)\n{\n    float c = length(floor(p-circ.xy));\n    bool res = false;\n    if(c < circ.z)\n    {\n        res = true;\n        if(outline)\n        {\n            float outline = circ.z-0.8;\n            outCol= step(c,outline)*inCol+step(outline, c)*vec3(0);\n        }\n        else\n        {\n            outCol = inCol;\n        }\n    }\n    return res;\n}\n\nbool hornsAndEyes(vec2 p, vec2 c, out vec3 col)\n{\n    bool res = abs(abs(p.x-c.x-0.5)-1.0)<0.5 && abs(abs(p.y-c.y-3.5)-1.0)<0.5;\n    if(res)\n    {\n        col = vec3(0);\n    }\n    return res;\n}\n\nbool face(vec2 p, vec2 c, out vec3 col)\n{\n    bool hit = hornsAndEyes(p,c, col);\n    hit = hit || rect(p,vec4(c.x+0.5,c.y+1.0,4.5,6), vec3(0.5),col);\n    hit = hit || rect(p, vec4(c.x+0.5,c.y+2.5,8.5,1), vec3(0.5), col);\n    hit = hit || rect(p,vec4(c.x+0.5,c.y-2.25,3.5,1.25), vec3(0.5), col);\n    return hit;\n}\n\nbool legs(vec2 p, vec2 c, vec3 inCol, out vec3 col)\n{\n    bool hit = rect(p, vec4(c.x+1.5,c.y-6.0,1,2), inCol, col) || rect(p, vec4(c.x-0.5,c.y-6.0,1,2), inCol, col);\n    hit = hit || rect(p, vec4(c.x+1.5,c.y-6.5,3,3), vec3(0), col) || rect(p, vec4(c.x-0.5,c.y-6.5,3,3), vec3(0), col);\n    return hit;\n}\n\nbool body(vec2 p, vec2 c, vec3 inCol, out vec3 col)\n{\n    bool hit = legs(p, c, inCol, col);\n    hit = hit || circle(p, vec3(c.xy,7.5), inCol, true, col);\n    return hit;\n}\n\nbool sheep(vec2 p, vec2 c, vec3 bodyCol, out vec3 col)\n{\n    bool hit = face(p, c, col);\n    hit = hit || body(p, c, bodyCol, col);\n    return hit;\n}\n\nbool moon(vec2 p, vec3 circ, vec3 inCol, out vec3 col)\n{\n    vec3 crecentO = vec3(3,-2,0.2*circ.z);\n    bool hit = circle(p, circ,vec3(1.0,0.9,0.0),true, col);\n    hit = hit && !circle(p, circ-crecentO,vec3(1.0,0.9,0.0),false, col);\n    return hit;\n}\n\nvec3 bg(vec2 p, float dayV)\n{\n    vec3 col;\n    vec2 baseP = vec2(40,35);\n    vec2 sunP = baseP + vec2(-20,10) + vec2(0,40)*(1.0-dayV);\n    vec2 moonP = baseP + vec2(20,-2) + vec2(0,40)*dayV;\n    bool hit = circle(p, vec3(sunP,12.75),vec3(1.0,0.9,0.0),false, col);\n    hit = hit || moon(p, vec3(moonP, 10.5), vec3(1.0,0.9,0.0), col);\n    if(!hit)\n    {\n    \tcol = step(p.y,9.0)*mix(vec3(0.06,0.45,0.01),vec3(0.12,0.9,0.2),dayV-0.5)+\n        \tstep(9.0,p.y)*mix(vec3(0.1,0.06,0.45),vec3(0.2,0.12,0.9),dayV);\n    }\n    return col;\n}\n\nvec3 scene(vec2 p)\n{\n    vec3 col = vec3(0);\n    float dayV = 2.0*abs(fract(0.5+0.125*iTime)-0.5);\n    dayV = dayV*dayV*(3.0-2.0*dayV);\n    bool hit = false;\n    for(float i = 0.0;i<5.0;i++)\n    {\n        vec2 c = vec2(20.0*i +10.0*sin(2.0*iTime), 15.0+2.0*abs(cos(2.0*i+10.0*iTime)));\n        vec3 scol = mix(vec3(0.9,0.8,0.7),vec3(1),0.833*fract(0.6*i))*dayV;\n        hit = hit || sheep(p, c, scol, col);\n    }\n    return hit? col : bg(p, dayV);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*= vec2(80,45);\n    vec3 col = scene(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfcR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 131], [133, 133, 191, 191, 348], [351, 351, 425, 425, 765], [767, 767, 816, 816, 960], [962, 962, 1003, 1003, 1274], [1276, 1276, 1329, 1329, 1579], [1581, 1581, 1634, 1634, 1753], [1755, 1755, 1811, 1811, 1904], [1906, 1906, 1962, 1962, 2156], [2158, 2158, 2187, 2187, 2687], [2689, 2689, 2709, 2709, 3138], [3140, 3140, 3197, 3197, 3318]], "test": "ok"}
{"id": "tdfcWr", "name": "Checkerboard 285", "author": "NoeDev", "description": "Deformable checkerboard using trigonometric functions. Use the mouse to move it around.\nHuge thanks to Fabrice Neyret for the help!", "tags": ["checkerboard"], "likes": 3, "viewed": 76, "published": "Public", "date": "1584551758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvec2 checks = vec2(10.0);\n\n\nfloat square_wave(in float x) {\n    //return sign(sin(x*PI));\n    //float w = 50.0/iResolution.x;\n    //return smoothstep(-w,w,sin(x*PI))*2.-1. ;\n\tfloat f = sin(x*PI), w = fwidth(f);\n\n\treturn smoothstep(-w,w,f)*2.-1.;\n} \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mouse = iMouse.xy;\n    \n    float ratio = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = \n        vec3(\n\t\t\tsquare_wave( ratio*uv.x*checks.x + sin(uv.y*PI + iTime) + 2.0*PI*mouse.x/iResolution.x )\n\t\t*\n\t\t\tsquare_wave( uv.y*checks.y + sin(uv.x*PI + iTime) + 2.0*PI*mouse.y/iResolution.y )\n    \t);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfcWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 84, 198, 272], [278, 278, 335, 335, 724]], "test": "ok"}
{"id": "tdfyD8", "name": "gradient of black and white", "author": "fille", "description": "gradient waves", "tags": ["gradient"], "likes": 1, "viewed": 71, "published": "Public", "date": "1584813618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n  \n    // Normalized pixel coordinates (from 0 to 1\n    float speed = 10.0;\n   \n    float time = mod(iTime,speed) /speed;\n    \n    float radius = mod(iTime,6.0);\n    \n    float cosine = cos(radius);\n    float sine = sin(radius);\n  \n    \n    vec2 uv = (fragCoord) / iResolution.xy;\n    uv = uv +time;\n    uv.x = uv.x * cosine - uv.y * sine;\n    uv.y = uv.x * sine + uv.y * cosine;\n    float freq = 10.0;\n    vec2 pos = fract(uv*freq);\n\tvec3 color = vec3(1.0,1.0,1.0);\n    \n ;\tfloat strip = mod(pos.y,0.5);\n   \n\n    if(pos.y < 0.5){\n        \n           color = mix(vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),strip);\n     \n    }else {\n         ;\tfloat strip2 = mod(-pos.y,0.5);\n     color = mix(vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),strip2);\n        \n    }\n    \n         \n \n    fragColor =vec4(color.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 114, 862]], "test": "ok"}
{"id": "tdfyRB", "name": "Expanding oil", "author": "BynaryCobweb", "description": "Simple noise experiment, to go along some music I made", "tags": ["noise", "colors", "warp", "oil"], "likes": 1, "viewed": 135, "published": "Public API", "date": "1585174630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat rand3(vec3 v) {\n    return fract(sin(dot(v + vec3(-8.5123, 23.2156, 0.0), vec3(12.9898, 6.233, 0.84261))) * 47583.5453123);\n}\n\n\nfloat noise3(in vec3 uvx) {\n    vec3 f = fract(uvx);\n    vec3 i = floor(uvx);\n    \n    float a1 = rand3(i);\n    float b1 = rand3(i + vec3(0.0, 1.0, 0.0));\n    float c1 = rand3(i + vec3(1.0, 0.0, 0.0));\n    float d1 = rand3(i + vec3(1.0, 1.0, 0.0));\n    float a2 = rand3(i + vec3(0.0, 0.0, 1.0));\n    float b2 = rand3(i + vec3(0.0, 1.0, 1.0));\n    float c2 = rand3(i + vec3(1.0, 0.0, 1.0));\n    float d2 = rand3(i + vec3(1.0, 1.0, 1.0));\n    \n    vec3 u = -2. * f * f * f + 3. * f * f;\n    \n    float a = mix(a1, a2, u.z);\n    float b = mix(b1, b2, u.z);\n    float c = mix(c1, c2, u.z);\n    float d = mix(d1, d2, u.z);\n    \n    return mix(mix(a, b, u.y), mix(c, d, u.y), u.x);\n}\n\nfloat fbm3(in vec3 uvx) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.7;\n    vec3 stz = uvx;\n    \n    for (int i = 0; i < 8; ++i) {\n        amp = amp / persistence + noise3(stz);\n        sum = sum / persistence + 1.;\n        stz *= 2.;\n    }\n    return amp / sum;\n}\n\n\nvec3 drawBubble(vec2 center, float radius, vec2 uv, vec3 col) {\n    float d = distance(center, uv);\n    float a = smoothstep(radius * 0.9, radius, d) * 0.9 + 0.1;\n    a *= 1.0 - step(radius, d);\n    col = mix(col, vec3(1.0), a);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 center = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    float d = distance(uv, center);\n\tvec3 uvt = vec3(uv, iTime * 0.005);\n    \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // col = drawBubble(vec2(0.2, 0.3), 0.05, uv, col);\n    vec3 col = vec3(fbm3(uvt), fbm3(uvt.yzx), fbm3(uvt.zxy));\n    \n    float crit = fbm3(col);\n    col *= smoothstep(0.4, 0.5, crit) * (1. - smoothstep(0.5, 0.6, crit));\n    \n    float tx = iTime * 1.0;\n    tx += sin(tx) * 1.5;\n    tx *= 0.04;\n    float grow = 1.0 - smoothstep(tx - 0.05, tx + 0.05, d * 2.0 + fbm3(uvt) * 4.0 - 1.8);\n    \n    vec3 uvt2 = vec3(uv, iTime * 0.05);\n    vec3 lake = vec3(fbm3(uvt2), fbm3(uvt2 + vec3(1.0)), fbm3(uvt2 + vec3(2.0)));\n    lake = vec3(fbm3(lake), fbm3(lake + vec3(1.0)), fbm3(lake + vec3(2.0)));\n    lake = vec3(fbm3(lake) * vec3(0.2, 0.2, 0.4)) * vec3(0.0);\n    \n    col = mix(lake, col, grow);\n    // col *= smoothstep(0.4, 0.6, fbm3(uvt));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 133], [136, 136, 163, 163, 813], [815, 815, 840, 840, 1104], [1107, 1107, 1170, 1170, 1353], [1356, 1356, 1413, 1463, 2536]], "test": "timeout"}
{"id": "tdfyzB", "name": "tunel--plasma-v3", "author": "jorge2017a1", "description": "tunel--plasma-v3", "tags": ["tunelplasmav3"], "likes": 0, "viewed": 41, "published": "Public", "date": "1585021630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\n\n\nfloat mapCerro(vec3 pp){\n    vec3 p= pp;\n    p.z += iTime;\n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n//------------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    float sdpt1= mapCerro(p);\n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    \n    vec3 ps;\n    ps=p;\n     ps= rotate_z(ps, iTime*3.141516/180.0);\n        \n    float sdsp1 = sdSphere (ps-vec3(0.0,2.0,4.4*iTime),2.0);\n    \n    \n    vec3 ppp;\n    ppp =p;\n    float c = 20.;\n    float c2 = 8.;\n    ppp.x+=sin(p.z*0.2);\n    \n    ppp.z=mod(ppp.z+c2*.5,c2)-c2*.5;\n    \n    vec3 p2;\n    \n    \n    vec3 p3;\n    p3 =p;\n     c = 20.;\n     c2 = 8.;\n    p3.y+=sin(p3.z*0.5)-4.0;\n    p3.z=mod(p3.z+c2*.5,c2)-c2*.5;\n    \n    \n    \n    float sdb1=sdBox(ppp- vec3(10.0,0.0,0.0), vec3(1.0,15.,20.0));\n    float sdb2=sdBox(ppp- vec3(-10.0,0.0,0.0), vec3(1.0,15.,20.0));   \n    float sdb3=sdBox(p3- vec3(0.0,10.0,0.0), vec3(10.0,2.,20.0));\n \n    res=opU(res, vec2(sdpt1,8 ));\n    res=opU(res, vec2(sdb1,24 ));\n    res=opU(res, vec2(sdb2,24 ));\n    res=opU(res, vec2(sdb3,24 ));\n    \n    \n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    //Texture of white and black in image\n\n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n  \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    \n    vec3 ro = vec3(0 ,5.5,-1.0+iTime*4.5);\n    //ro = get_mouse(ro);\n    vec3 rd =normalize(vec3(uv,0.5) );\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n   \n    float dif;\n   \n    dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 549, 582, 582, 647], [648, 666, 702, 702, 771], [772, 787, 818, 818, 968], [969, 989, 1025, 1025, 1112], [1113, 1129, 1161, 1189, 1250], [1252, 1252, 1288, 1288, 1391], [1394, 1394, 1439, 1439, 1530], [1584, 1584, 1630, 1630, 1662], [1664, 1664, 1707, 1707, 1739], [1741, 1741, 1789, 1789, 1822], [1825, 1825, 1854, 1854, 1980], [1982, 1982, 2018, 2018, 2135], [2137, 2137, 2173, 2173, 2291], [2294, 2294, 2330, 2330, 2453], [2506, 2518, 2540, 2540, 2848], [2849, 2875, 2900, 2900, 3090], [3091, 3136, 3153, 3153, 3226], [3229, 3262, 3288, 3288, 3485], [3532, 3532, 3584, 3584, 3739], [3804, 3913, 3950, 3950, 3985], [3987, 3987, 4006, 4006, 4081], [4130, 4130, 4153, 4153, 4179], [4181, 4181, 4204, 4204, 4342], [4345, 4345, 4367, 4367, 4437], [4502, 4502, 4528, 4528, 4585], [4587, 4587, 4607, 4607, 4665], [4668, 4668, 4689, 4689, 4939], [4985, 4985, 5009, 5009, 5188], [5191, 5236, 5261, 5261, 6383], [6388, 6388, 6421, 6421, 6896], [6900, 6900, 6924, 6924, 7291], [7296, 7296, 7334, 7334, 7692], [7791, 7835, 7852, 7852, 7923], [7948, 8040, 8065, 8065, 8328], [8391, 8391, 8419, 8419, 16772], [16775, 16775, 16832, 16832, 17899]], "test": "error"}
{"id": "tdlcD7", "name": "Book of Chopped Surfaces", "author": "dr2", "description": " Surfaces of repeatedly distorted and fragmented cubes (leading to dust);\n alternating monotone and color (representing distance field Laplacian,\n or curvature); mouse overrides autopaging.\n", "tags": ["fractal"], "likes": 10, "viewed": 257, "published": "Public API", "date": "1584971974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Book of Chopped Surfaces\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDirEx, ltDir, qHit, pgSize;\nfloat tCur, dstFarEx, dstFar, tpBook, phsTurn, idPage;\nint idObj, nIt;\nconst float pi = 3.14159;\n\nconst int nPage = 14;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  t = 10. + 5. * sin  (0.1 * 2. * pi * t);\n  for (int k = 0; k < 12; k ++) {\n    if (k >= nIt) break;\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.75;\n  }\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 blbRad;\n  float d, t;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.1 * tCur);\n  t = 0.5 * tCur;\n  blbRad = vec2 (1.1 + 0.31 * sin (t + 1.31), 1. + 0.41 * sin (1.7 * (t + 1.31)));\n  d = SmoothMin (PrBoxDf (SMap (q - vec3 (0.7, 0., 0.), 1.11 * t + 0.7), vec3 (blbRad.x)),\n     PrBoxDf (SMap (q - vec3 (-0.7, 0., 0.), 1.3 * t), vec3 (blbRad.y)), 0.2);\n  return 0.25 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float lp, s;\n  e = vec2 (0.01, -0.01);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  lp = (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x); // (laplacian: see \"Cheap curvature\" by nimitz)\n  return vec4 (normalize (2. * v.yzw - s), lp);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, nl4;\n  vec3 col, vn;\n  float dstObj, lp, nDotL;\n  nIt = 5 + int (0.5 * (idPage - 1.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    nl4 = ObjNfL (ro);\n    vn = nl4.xyz;\n    lp = nl4.w;\n    col = (mod (idPage, 2.) == 0.) ?\n       col = HsvToRgb (vec3 (0.35 * (1. - clamp (0.3 * lp, -1., 1.)), 0.8, 1.)) :\n       vec3 (0.9) * (1. - step (10., lp));\n    nDotL = max (dot (vn, ltDir), 0.);\n    nDotL *= nDotL;\n    col = col * (0.2 + 0.8 * nDotL * nDotL +\n       0.2 * pow (max (dot (normalize (vn - rd), vn), 0.), 32.));\n    rd = reflect (rd, vn);\n  } else {\n    col = vec3 (0.5, 0.5, 0.55);\n  }\n  return clamp (col, 0., 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  el = -0.15 * pi;\n  az = 0.2 * pi * sin (0.05 * pi * tCur);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -40.);\n  dstFar = 100.;\n  zmFac = 8.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  ltDir = normalize (vec3 (0., 1., -1.));\n  fCol = clamp (ShowScene (ro, rd), 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = 0; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (2.5, 0.011, 2.5);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = HsvToRgb (vec3 (floor (0.5 * (idPage - 1.)) / float (nPage / 2), 0.7, 1.));\n      s = pgSize.xz - abs (qHit.xz);\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      } else {\n        col4 = vec4 (c, 0.2);\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = tCur;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    tpBook = - clamp (1.05 * mPtr.x + 0.5, 0., 1.);\n    el += pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (1., 0., -18.);\n  ro = vuMat * ro;\n  zmFac = 7.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (vec2 (- uv.x, uv.y) + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (1.)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[682, 682, 711, 711, 913], [915, 915, 937, 937, 1312], [1314, 1314, 1347, 1347, 1524], [1526, 1526, 1548, 1548, 1931], [1933, 1933, 1968, 1968, 2640], [2642, 2642, 2678, 2678, 2884], [2886, 2886, 2932, 2932, 3279], [3281, 3281, 3305, 3305, 4180], [4182, 4182, 4217, 4217, 4398], [4400, 4400, 4423, 4423, 4626], [4628, 4628, 4667, 4667, 4891], [6579, 6579, 6635, 6635, 7693], [7695, 7695, 7727, 7727, 7827], [7829, 7829, 7875, 7875, 7922], [7924, 7924, 7970, 7970, 8027], [8029, 8029, 8053, 8053, 8170], [8172, 8172, 8217, 8217, 8320], [8322, 8322, 8379, 8379, 8462], [8464, 8464, 8494, 8494, 8607]], "test": "timeout"}
{"id": "tdlcRs", "name": "leon-v2", "author": "jorge2017a1", "description": "leon-v2", "tags": ["leonv2"], "likes": 2, "viewed": 28, "published": "Public", "date": "1585401944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n/*\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n*/\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\n\n\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+3.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    float pisocer= mapCerrov2(p);\n        \n    //res=opU(res, vec2(planeDist1,28 ));  //piso inferior\n   \tres=opU(res, vec2(pisocer,28 ));  //piso inferior\n    res=opU(res, vec2(planeDist4,29 ));  //piso inferior\n    \n    \n    \n    //L\n    float  sdb1=sdBox(p -vec3(0.0,0.0,0.0) , vec3(2.0,0.25,1.0) );\n    float  sdb2=sdBox(p -vec3(-1.4,2.2,0.0) , vec3(0.5,2.0,1.0) );\n    \n    //E\n    float  sdb3=sdBox(p -vec3(4.0,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    float  sdb4=sdBox(p -vec3(5.0,0.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb5=sdBox(p -vec3(5.0,2.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb6=sdBox(p -vec3(5.0,4.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    \n    //O\n    float  sdb7=sdBox(p -vec3(10.0,0.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb8=sdBox(p -vec3(10.0,4.0,0.0) , vec3(2.0,0.25,1.0) );  //-\n    float  sdb9=sdBox(p -vec3(8.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    float  sdb10=sdBox(p -vec3(11.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    \n    \n    //N\n    float  sdb11=sdBox(p -vec3(13.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    float  sdb12=sdBox(p -vec3(16.5,2.0,0.0) , vec3(0.5,2.0,1.0) );   //!\n    \n    vec2 tmp2;\n    tmp2= pp.xy+vec2(-14.0,0.0);\n    R(tmp2, 45.0*3.141516/180.);\n    pp.xy=tmp2;\n    \n    \n    float  sdb13=sdBox(pp -vec3(2.0,0.5,0.0) , vec3(0.5,2.1,0.5) );   //!\n    \n    \n    res=opU(res, vec2(sdb1,8 )); \n    res=opU(res, vec2(sdb2,8 )); \n    \n    res=opU(res, vec2(sdb3,7 )); \n    res=opU(res, vec2(sdb4,7 ));\n    res=opU(res, vec2(sdb5,7 )); \n    res=opU(res, vec2(sdb6,7 ));\n    \n    \n    res=opU(res, vec2(sdb7,1 )); \n    res=opU(res, vec2(sdb8,1 ));\n    res=opU(res, vec2(sdb9,1 ));\n    res=opU(res, vec2(sdb10,1 ));\n    \n    //N\n    res=opU(res, vec2(sdb11,3 ));\n    res=opU(res, vec2(sdb12,3 ));\n    res=opU(res, vec2(sdb13,3 ));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    if(i== 29 )\n    {\n        //refeencia de color  hamoid\n        //https://www.shadertoy.com/view/Xsc3W8\n        \n    vec2 uv= mObj.uv;\n    float t1 = uv.x + iTime;\n    float t2 = uv.y - iTime;\n    float r = abs(sin(t1 * 0.332) + sin(t2 * 2.21)) / 2.0;\n    float g = abs(sin(t2 * 0.773) + sin(t1 * 3.53)) / 2.0;\n    float b = abs(sin(t1 * 0.817) + sin(t2 * 4.71)) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  }      \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    \n    vec3 ro = vec3(5.0+5.0*sin(iTime) ,5.0,-20.0+5.0*cos(iTime));\n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[581, 598, 631, 631, 696], [700, 700, 735, 735, 759], [892, 907, 938, 938, 1088], [1089, 1109, 1145, 1145, 1232], [1233, 1249, 1281, 1309, 1370], [1372, 1372, 1408, 1408, 1511], [1514, 1514, 1559, 1559, 1650], [1652, 1652, 1687, 1687, 2172], [2224, 2224, 2270, 2270, 2302], [2304, 2304, 2347, 2347, 2379], [2381, 2381, 2429, 2429, 2462], [2465, 2465, 2494, 2494, 2620], [2622, 2622, 2658, 2658, 2775], [2777, 2777, 2813, 2813, 2931], [2934, 2934, 2970, 2970, 3093], [3146, 3158, 3180, 3180, 3488], [3489, 3515, 3540, 3540, 3730], [3731, 3776, 3793, 3793, 3866], [3869, 3902, 3928, 3928, 4125], [4172, 4172, 4224, 4224, 4379], [4444, 4553, 4590, 4590, 4625], [4627, 4627, 4646, 4646, 4721], [4770, 4770, 4793, 4793, 4819], [4821, 4821, 4844, 4844, 4982], [5038, 5038, 5060, 5060, 5130], [5195, 5195, 5221, 5221, 5278], [5280, 5280, 5300, 5300, 5358], [5361, 5361, 5382, 5382, 5632], [5679, 5679, 5705, 5705, 5876], [5878, 5922, 5947, 5947, 8187], [8192, 8192, 8225, 8225, 8700], [8704, 8704, 8728, 8728, 9060], [9065, 9065, 9103, 9103, 9461], [9560, 9604, 9621, 9621, 9692], [9717, 9809, 9834, 9834, 10097], [10099, 10154, 10180, 10180, 10414], [10478, 10478, 10506, 10506, 19281], [19284, 19284, 19341, 19341, 20389]], "test": "error"}
{"id": "tdlcWN", "name": "every other pixel is a line", "author": "TinyTexel", "description": "Oskar Stålberg's (@OskSta) \"every-other-pixel-is-a-line\"- texture sampling approach.\nhttps://twitter.com/OskSta/status/1241096929490149376", "tags": ["shader"], "likes": 6, "viewed": 368, "published": "Public API", "date": "1584838791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n*/\n\nvec2 WarpCoord0(float p, float s)\n{\n    bool c = fract(p * 0.5 - 0.25) < 0.5;\n    \n    if(c) s = 1.0 - s;\n    \n    float p0 = floor(p - 0.5);\n    float l0 =      (p - 0.5) - p0;\n    \n    if(l0 < s)\n    {\n        l0 *= 0.5 / s;\n    }\n    else\n    {\n        p0 += 1.0;\n        l0 = (l0 - s) / (1.0 - s) * 0.5 + 0.5; \n    }\n    \n    if(c) l0 += 1.0;\n\n    l0 = fract(l0 + 0.5);\n    \n    return vec2(p0, l0);\n}\n\nvec2 WarpCoord(vec2 uv, float s)\n{\n    vec2 u = WarpCoord0(uv.x, s);\n    vec2 v = WarpCoord0(uv.y, s);\n    \n    return vec2(u.x + u.y, v.x + v.y);\n}\n\nfloat WarpCoordI0(float p, float s)\n{\n    if(fract(p * 0.5 - 0.25) < 0.5) \n        s = 1.0 - s;\n    \n    float p0 = floor(p - 0.5);\n    float l0 =      (p - 0.5) - p0;\n    \n    if(l0 > s) p0 += 1.0;\n    \n    return p0;\n}\n\nvec2 WarpCoordI(vec2 uv, float s)\n{\n    return vec2(WarpCoordI0(uv.x, s), WarpCoordI0(uv.y, s));\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0 / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 p = uv0.xy*0.02;\n    \n    float s = 0.25;\n    s = sin(float(iTime))*0.75*0.5+0.5;\n    \n    if(tex.x < 0.5)\n    {\n        vec2 wc = WarpCoord0(p.x, s);\n        \n        if(tex.y < 0.5)\n            col = vec3(wc.x) * 0.1;\n        else\n            col = vec3(wc.y);\n    }\n    else\n    {\n    \tif(tex.y > 0.5)\n    \tcol = textureLod(iChannel0, WarpCoord(p, s)/64.0, 1.0).rgb;\n    \telse\n    \tcol = texelFetch(iChannel0, ivec2(WarpCoordI(p, s)), 0).rgb;\n    }\n    \n\toutCol = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 43, 43, 413], [415, 415, 449, 449, 563], [565, 565, 602, 602, 785], [787, 787, 822, 822, 885], [888, 888, 936, 936, 1525]], "test": "error"}
{"id": "tdlczM", "name": "Metagrid", "author": "haptix", "description": "Playing with an updated marching/lighting setup", "tags": ["raymarching"], "likes": 3, "viewed": 172, "published": "Public API", "date": "1584479828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat3 rotateY(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n    );\n}\n\nmat3 rotateZ(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, s, 0.,\n        -s, c, 0.,\n        0., 0., 1.\n    );\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat map(vec3 p)\n{   \n   \tp = rotateZ(.15 * iTime) * rotateY(.17 * iTime) * p;\n    p += -.4 * vec3(cos(abs(p.x)*15. + 1.3*iTime),\n                    sin(p.y*15. + iTime),\n                    cos(abs(p.z)*15. + 1.5*iTime) * sin(p.x*p.y*12. + 1.7*iTime) * 2.2);\n    float m = sphere(p, .4*sin(.43*iTime) + .6);\n    glo += .18 / (.18 + m*m);\n    return m;\n}\n\nfloat tr(vec3 ro, vec3 rd)\n{\n\tfloat  h,t = .1;\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t) * .1;\n\t\tif(h < .001 || t > 120.)\n\t\t\tbreak;\n\t\tt += h;\n  \t}\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(0., 0., -2.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(-2., -2., -15.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .05);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tfloat t = tr(ro, rd);\n\n    vec3 colRot = sin(vec3(.151, .227, .317) * iTime) + 1.2;\n    \n    if (t < 120.)\n    {\n        vec3 hit = ro + rd*t;\n        vec3 lightDir = normalize(lightPos - hit);\n        \n        vec3 norm = normalize(map(hit) - vec3(map(hit - eps.yxx),\n                              map(hit - eps.xyx),\n                              map(hit - eps.xxy)));\n        \n        \n        float diff = max(.2, dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 50.);\n        float ao = clamp(map(t + norm*.5) / .5, 0., 1.);\n\n        vec3 col =  .2*colRot * .2*ao;\n        col += .3 * diff * colRot.yzx;\n        col += .5 * spec * vec3(1., 1., 1.);\n\n        col += glo*.0105 * colRot.yxz;\n        fragColor = vec4(col, 1.);        \n    }\n    else\n    \tfragColor = vec4(glo*.0105*colRot.yzx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 64, 64, 194], [196, 196, 221, 221, 351], [353, 353, 391, 391, 426], [428, 428, 447, 447, 784], [786, 786, 814, 814, 957], [959, 959, 1016, 1016, 2343]], "test": "timeout"}
{"id": "tdlyDS", "name": "postes luz-v2", "author": "jorge2017a1", "description": "postes luz-v2", "tags": ["postesluzv2"], "likes": 1, "viewed": 49, "published": "Public", "date": "1585512063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\n\n\n//---------------------------------------\nfloat mapCerrov3(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+3.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n    float pisocer= mapCerrov3(p+vec3(0.0,0.0,iTime*2.0));\n        \n   \n    res=opU(res, vec2(pisocer,35 ));  //piso inferior\n    res=opU(res, vec2(planeDist4,34 ));  //piso inferior\n    \n    \n    \n    vec3 p0=p;\n    //postes de luz\n    pp.z=pp.z+iTime;\n    pp.xz=mod( pp.xz,2.0)-1.0;\n    float sdb1= sdBox(pp- vec3(0.0) , vec3(0.025,1.,0.025) );\n    float sdb2= sdBox(pp- vec3(0.0,1.0,0.0) , vec3(0.25,0.025,0.025) );\n    \n    \n    vec3 p3;\n    p3 =p0;\n    float c2 = 8.;\n    p3.y+=0.125*sin(p3.z*0.5);\n    p3.xz=mod( p3.xz,2.0)-1.0;\n    float sdb3= sdBox(p3- vec3(0.0,1.0,0.) , vec3(0.025,0.025,1) );\n    \n    res=opU(res, vec2(sdb1,8 ));\n    res=opU(res, vec2(sdb2,8 ));\n    res=opU(res, vec2(sdb3,7 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n//--------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat Noisev2(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\treturn   f.x*0.5*cos(f.x);\n    \n}\n\n\n\nfloat Noisev3(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\treturn  mix( f.x*0.5,f.y,f.z);\n    \n}\n\n\n\n\nvec3 n3 (vec3 p)\n{\n    return (vec3 (Noise(p)- 40.9, Noise(p) -7.2, Noise(p)+ 24.3));\n}\n\n\n//-------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    if(i== 29 )\n    {\n        vec2 uv= mObj.uv;\n        float t1 = uv.x + iTime;\n    float t2 = uv.y - iTime;\n    float r = abs(sin(t1 * 0.332) + sin(t2 * 2.21)) / 2.0;\n    float g = abs(sin(t2 * 0.773) + sin(t1 * 3.53)) / 2.0;\n    float b = abs(sin(t1 * 0.817) + sin(t2 * 4.71)) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  }      \n    \t\n  \n    if(i== 30 )\n    {\n        vec2 uv= mObj.uv;\n        float t1 = uv.x + iTime;\n    \tfloat t2 = uv.y - iTime;\n    \tfloat r = abs(sin(t1 * 0.332) ) / 2.0;\n    \tfloat g = abs(sin(t2+r) ) / 2.0;\n    \tfloat b = abs(sin(t1 +g) ) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  }    \n    \n    \n    if(i== 31 )\n    {\n        vec2 uv= mObj.uv;\n        float t1 = uv.x + iTime;\n    \tfloat t2 = uv.y - iTime;\n    \tfloat r = abs(sin(t1 * 0.332) ) / 2.0;\n    \tfloat g = abs(sin(t2 * 0.773) ) / 2.0;\n    \tfloat b = abs(sin(t1 * 0.817) ) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  } \n    \n    \n    if(i== 32 )\n    {\n    \n     \t//Granite;\n    \treturn mix(vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),Noisev2(mObj.p*100.));\n    } \n    \n    \n    \n    \n     if(i== 33 )\n    {\n        vec3 q ;\n        vec3 p= mObj.p;\n        \n    \tq= p + n3(p);\n    \treturn mix(vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0),1.+sin(Noise(q))/2.);\n  \t} \n    \n    \n     if(i== 34 )\n    {\n    \n     \t//Granite;\n    \treturn mix(vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),Noise(mObj.p*100.));\n    } \n   \n    \n     if(i== 35 )\n    {\n    \n     \t//Granite cafe;\n    \t//return mix(vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),Noise(mObj.p*100.))*vec3(128./255.0,68/255,0.0);\n        return mix(vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),Noise(mObj.p*100.))*vec3( 246./255.0, 221./255.0, 204.0/255.0);\n \n    } \n        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.0,0.5,-3.0);  \n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0.0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n      vec3 p = (ro + rd * d.x ); \n      glpRoRd=p;\n      mObj.p=p;\n  \n      float dif=0.35;\n   \n    \n      mObj.dist =d.x;\n      vec3 colobj;\n  \n      colobj=getSphereColor(int( d.y));\n    \n      vec3 nor= GetNormal( p);\n   \n      float intensity = 1.0;\n      vec3 V = normalize(p - ro);\n      vec3 L = rd;\n      vec3 normal = nor;\n      vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n      vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[593, 610, 643, 643, 708], [712, 712, 747, 747, 771], [775, 790, 821, 821, 971], [972, 992, 1028, 1028, 1115], [1116, 1132, 1164, 1192, 1253], [1255, 1255, 1291, 1291, 1394], [1397, 1397, 1442, 1442, 1533], [1535, 1535, 1570, 1570, 2055], [2107, 2107, 2153, 2153, 2185], [2187, 2187, 2230, 2230, 2262], [2264, 2264, 2312, 2312, 2345], [2348, 2348, 2377, 2377, 2503], [2505, 2505, 2541, 2541, 2658], [2660, 2660, 2696, 2696, 2814], [2817, 2817, 2853, 2853, 2976], [3029, 3041, 3063, 3063, 3371], [3372, 3398, 3423, 3423, 3613], [3614, 3659, 3676, 3676, 3749], [3752, 3785, 3811, 3811, 4008], [4055, 4055, 4107, 4107, 4262], [4327, 4436, 4473, 4473, 4508], [4510, 4510, 4529, 4529, 4604], [4653, 4653, 4676, 4676, 4702], [4704, 4704, 4727, 4727, 4865], [4921, 4921, 4943, 4943, 5013], [5078, 5078, 5104, 5104, 5161], [5163, 5163, 5183, 5183, 5241], [5244, 5244, 5265, 5265, 5515], [5561, 5603, 5629, 5629, 5800], [5803, 5847, 5872, 5872, 7014], [7019, 7019, 7052, 7052, 7527], [7531, 7531, 7555, 7555, 7887], [7892, 7892, 7930, 7930, 8288], [8387, 8431, 8448, 8448, 8519], [8544, 8636, 8661, 8661, 8924], [8926, 8981, 9007, 9007, 9241], [9302, 9359, 9383, 9383, 9426], [9428, 9508, 9533, 9533, 9628], [9632, 9632, 9656, 9656, 10228], [10231, 10231, 10257, 10257, 10462], [10466, 10466, 10492, 10492, 10701], [10706, 10706, 10724, 10724, 10793], [10837, 10837, 10865, 10865, 20891], [20894, 20894, 20951, 20951, 21994]], "test": "error"}
{"id": "tdlyRr", "name": "float<>int bit reinterpret hash", "author": "michael0884", "description": "Experimenting with intBitsToFloat and floatBitsToInt. The hash probably is super bad", "tags": ["hash", "reinterpret"], "likes": 4, "viewed": 290, "published": "Public API", "date": "1584051583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s 1048576\n\nfloat hash(float x)\n{\n    return abs(float((1345677*floatBitsToInt(x*x*x))%s)/float(s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord);\n    float rand = hash(uv.x + sqrt(2.)*uv.y + sqrt(5.)*iTime);\n    fragColor = vec4(vec3(rand),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 40, 40, 109], [111, 111, 168, 168, 302]], "test": "ok"}
{"id": "tdlyWN", "name": "terreno-cerro-v1", "author": "jorge2017a1", "description": "terreno-cerro-v1", "tags": ["terrenocerrov1"], "likes": 0, "viewed": 48, "published": "Public", "date": "1584836504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\nfloat pathterrainv4( vec3 p)\n{\n    // Common height function for path and terrain\n    return \n        0.5*sin(p.x*.5 )*2.+cos(p.z*0.023 )*0.3+p.y*0.25\n        +cos(p.x*3.+p.z )*0.35+sin(p.x*0.15-p.z*0.52 )*0.8;\n}  \n\n//------------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    float sdpt1= pathterrainv4(p);\n    \n    res=opU(res, vec2(sdpt1,8 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    dist=d.x;\n    \n    vec3 n;\n    n = dist -vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 ro = vec3(0 ,5.5,-1.0+iTime*4.5);\n \n    vec3 rd =normalize(vec3(uv,0.5) );\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n   \n    \n    float dif, dif1, dif2, dif3, dif4, dif5;\n    \n    dif1= GetLightPar(p,vec3(30.0,30.0,-20.0));\n    \n    //dif=dif1*3.0;\n   dif=0.35;\n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n    vec3 V = normalize(p - ro);\n    vec3 L = rd;    \n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 549, 582, 582, 647], [648, 666, 702, 702, 771], [772, 787, 818, 818, 968], [969, 989, 1025, 1025, 1112], [1113, 1129, 1161, 1189, 1250], [1252, 1252, 1288, 1288, 1391], [1394, 1394, 1439, 1439, 1530], [1584, 1584, 1630, 1630, 1662], [1664, 1664, 1707, 1707, 1739], [1741, 1741, 1789, 1789, 1822], [1825, 1825, 1854, 1854, 1980], [1982, 1982, 2018, 2018, 2135], [2137, 2137, 2173, 2173, 2291], [2294, 2294, 2330, 2330, 2453], [2506, 2518, 2540, 2540, 2848], [2849, 2875, 2900, 2900, 3090], [3091, 3136, 3153, 3153, 3226], [3229, 3262, 3288, 3288, 3485], [3532, 3532, 3584, 3584, 3739], [3804, 3913, 3950, 3950, 3985], [3987, 3987, 4006, 4006, 4081], [4130, 4130, 4153, 4153, 4179], [4181, 4181, 4204, 4204, 4342], [4345, 4345, 4367, 4367, 4437], [4502, 4502, 4528, 4528, 4585], [4587, 4587, 4607, 4607, 4665], [4668, 4668, 4689, 4689, 4939], [4983, 4983, 5013, 5064, 5195], [5199, 5244, 5269, 5269, 5610], [5615, 5615, 5648, 5648, 6123], [6127, 6127, 6151, 6151, 6432], [6437, 6437, 6475, 6475, 6833], [6932, 6976, 6993, 6993, 7064], [7089, 7181, 7206, 7206, 7469], [7649, 7649, 7677, 7677, 15356], [15359, 15359, 15416, 15416, 16561]], "test": "error"}
{"id": "tdlyz4", "name": "Interactive Noise", "author": "raabix", "description": "X-Mouse: Number of octaves\nY-Mouse: Decay of each octave\nWork in progress - I try to build an interactive noise explorer and learn shadertoy", "tags": ["procedural", "noise", "perlin"], "likes": 4, "viewed": 81, "published": "Public", "date": "1584805325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*  This is a work in progress shader. I want to make exploring noise accessible\n    for everyone and learn at the same time coding in shadertoy.\n    So for the beginning you can experience summed gradient noise and adjust its\n    parameters with the mouse \n    X-Mouse: Number of Octaves\n    Y-Mouse: Roughness (the amount of how much each octave is scaled smaller)\n\n*/\n\n\n#define NORMALIZED_OUTPUT true\n#define UNNORMALIZED_OUTPUT false\n\n\n\n// Code for font rendering\n\n#define AUTO_FONT_SPACING\n#define FONT_SAMPLER iChannel0\n\n// ------------------------------------------------------------------\n// SDF Font Printing by P_Malin - https://www.shadertoy.com/view/ldfcDr#\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Font characters\nconst uint\n   \t// HTML Entity Names\n    \n    _SP = 0x20u,\t\t// ' '\n    _EXCL = 0x21u, \t\t// '!' \n    _QUOT = 0x22u, \t\t// '\"'\n    _NUM = 0x23u,  \t\t// '#'\n    _DOLLAR = 0x24u, \t// '$'\n    _PERCNT = 0x25u, \t// '%'\n    _AMP = 0x26u, \t\t// '&'\n    _APOS = 0x27u,\t\t// '''    \n    _LPAR = 0x28u, \t\t// '('\n    _RPAR= 0x29u, \t\t// ')'\n    _AST = 0x2Au,\t\t// '*'\n    _PLUS = 0x2Bu,\t\t// '+'\n    _COMMA = 0x2Cu,\t\t// ','    \n    _MINUS = 0x2Du,\t\t// '-'\n    _PERIOD = 0x2Eu,\t// '.'\n    _SOL = 0x2Fu,\t\t// '/' \n\n    _0 = 0x30u, _1 = 0x31u, _2 = 0x32u, _3 = 0x33u, _4 = 0x34u, \n    _5 = 0x35u, _6 = 0x36u, _7 = 0x37u, _8 = 0x38u, _9 = 0x39u, \n\n    _COLON = 0x3Au,\t\t// ':' \n    _SEMI = 0x3Bu,\t\t// ';' \n    _LT = 0x3Cu,\t\t// '<' \n    _EQUALS = 0x3Du,\t// '=' \n    _GT = 0x3Eu,\t\t// '>' \n    _QUEST = 0x3Fu,\t\t// '?' \n    _COMAT = 0x40u,\t\t// '@' \n    \n    _A = 0x41u, _B = 0x42u, _C = 0x43u, _D = 0x44u, _E = 0x45u, \n    _F = 0x46u, _G = 0x47u, _H = 0x48u, _I = 0x49u, _J = 0x4Au,\n    _K = 0x4Bu, _L = 0x4Cu, _M = 0x4Du, _N = 0x4Eu, _O = 0x4Fu,\n    _P = 0x50u, _Q = 0x51u, _R = 0x52u, _S = 0x53u, _T = 0x54u,\n    _U = 0x55u, _V = 0x56u, _W = 0x57u, _X = 0x58u, _Y = 0x59u,\n    _Z = 0x5Au,\n\n    _LSQB = 0x5Bu,\t\t// '[' \n    _BSOL = 0x5Cu,\t\t// '\\'\n    _RSQB = 0x5Du,\t\t// ']' \n    _CIRC = 0x5Eu,\t\t// '^' \n    _LOWBAR = 0x5Fu,\t// '_' \n    _GRAVE = 0x60u,\t\t// '`' \n    \n    _a = 0x61u, _b = 0x62u, _c = 0x63u, _d = 0x64u, _e = 0x65u,\n    _f = 0x66u, _g = 0x67u, _h = 0x68u, _i = 0x69u, _j = 0x6Au,\n    _k = 0x6Bu, _l = 0x6Cu, _m = 0x6Du, _n = 0x6Eu, _o = 0x6Fu,\n    _p = 0x70u, _q = 0x71u, _r = 0x72u, _s = 0x73u, _t = 0x74u,\n    _u = 0x75u, _v = 0x76u, _w = 0x77u, _x = 0x78u, _y = 0x79u,\n    _z = 0x7Au,\n\n\t_LCUB = 0x7Bu,\t\t// '{'\n    _VERBAR = 0x7Cu,\t// '|'\n    _RCUB = 0x7Du,\t\t// '}'\n    _TILDE = 0x7Eu,\t\t// '~'\n    \n        \n    _EOL = 0x1000u, \t// End of Line - Carriage Return & Line Feed    \n    _BOLDON = 0x1001u,\t// Special\n    _BOLDOFF = 0x1002u,\t// Special\n    _ITALON = 0x1003u,\t// Special\n    _ITALOFF = 0x1004u\t// Special\n;\n\n\nvec4 SampleCharacterTex( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vUV = (vec2(iChPos) + vCharUV) / 16.0f;\n    return textureLod( FONT_SAMPLER, vUV, 0.0 );\n}\n    \nvec4 SampleCharacter( uint iChar, vec2 vCharUV )\n{\n    uvec2 iChPos = uvec2( iChar % 16u, iChar / 16u );\n    vec2 vClampedCharUV = clamp(vCharUV, vec2(0.01), vec2(0.99));\n    vec2 vUV = (vec2(iChPos) + vClampedCharUV) / 16.0f;\n\n    vec4 vSample;\n    \n    float l = length( (vClampedCharUV - vCharUV) );\n\n#if 0\n    // Simple but not efficient - samples texture for each character\n    // Extends distance field beyond character boundary\n    vSample = textureLod( FONT_SAMPLER, vUV, 0.0 );\n    vSample.gb = vSample.gb * 2.0f - 1.0f;\n    vSample.a -= 0.5f+1.0/256.0;    \n    vSample.w += l * 0.75;\n#else    \n    // Skip texture sample when not in character boundary\n    // Ok unless we have big shadows / outline / font weight\n    if ( l > 0.01f )\n    {\n        vSample.rgb = vec3(0);\n\t\tvSample.w = 2000000.0; \n    }\n    else\n    {\n\t\tvSample = textureLod( FONT_SAMPLER, vUV, 0.0 );    \n        vSample.gb = vSample.gb * 2.0f - 1.0f;\n        vSample.a -= 0.5f + 1.0/256.0;    \n    }\n#endif    \n        \n    return vSample;\n}\n\n#ifndef AUTO_FONT_SPACING\nfloat CharExtentsLeft( uint iChar )\n{\n    if ( iChar < 32u )\n        return 0.1f;\n    \n    switch( iChar )\n    {\n        case _EXCL:  case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.4f;\n        case _l: return 0.325f;        \n        case _A: case _Y: case _Q: case _w:case _W: case _m: case _M: return 0.25f;\n    }\n\treturn 0.3f;\n}\n\nfloat CharWidth( uint iChar )\n{\n    if ( iChar < 32u )  \n        return 0.8f;\n   \n    switch( iChar )\n    {\n        case _EXCL: case _APOS: case _PERIOD: case _COMMA: case _COLON: case _SEMI: return 0.2f;       \n        case _1: case _j: return 0.3f;        \n        case _l: return 0.35f;\n        case _A: case _Y: case _Q: case _w: case _W: case _m: case _M: return 0.5f;\n    }\n\n    return 0.4f;\n}\n#endif \n\nstruct CharExtents\n{\n    float left;\n    float width;\n};\n    \n// Auto font spacing adapted from Klems shader: https://www.shadertoy.com/view/MsfyDN\nfloat CharVerticalPos(uint iChar, vec2 vUV) \n{\n    vec4 vSample = SampleCharacterTex(iChar, vUV);\n    float dist = vSample.a - (127.0/255.0);\n    dist *= vSample.g * 2.0 - 1.0;\n    return vUV.x - dist;\n}\n\nCharExtents GetCharExtents( uint iChar )\n{\n    CharExtents result;\n\n#ifdef AUTO_FONT_SPACING\n    result.left = CharVerticalPos( iChar, vec2(0.02, 0.5) );\n    float right = CharVerticalPos( iChar, vec2(0.98, 0.5) );\n    result.width = right - result.left;\n#else\n    result.left = CharExtentsLeft( iChar );\n    result.width = CharWidth( iChar );\n#endif\n    \n    if ( iChar == _SP )\n    {\n        result.left = 0.3f;\n        result.width = 0.4f;\n    }\n    return result;\n}\n\nstruct PrintState\n{\n    vec2 vCanvasOrigin;\n \n    // print position\n    vec2 vStart;\n    vec2 vPos;\n    vec2 vPixelSize;\n    bool EOL;\n\n    // result\n    float fDistance;\n};    \n\nvoid MoveTo( inout PrintState state, vec2 vPos )\n{\n    state.vStart = state.vCanvasOrigin - vPos;\n    state.vPos = state.vStart;    \n    state.EOL = false;\n}\n\nvoid ClearPrintResult( inout PrintState state )\n{\n    state.fDistance = 1000000.0;\n}\n\nPrintState PrintState_InitCanvas( vec2 vCoords, vec2 vPixelSize )\n{\n    PrintState state;\n    state.vCanvasOrigin = vCoords;\n    state.vPixelSize = vPixelSize;\n    \n    MoveTo( state, vec2(0) );\n\n    ClearPrintResult( state );\n    \n    return state;\n}\n\nstruct LayoutStyle\n{\n    vec2 vSize;\n    float fLineGap;\n    float fAdvancement;\n    bool bItalic;\n    bool bBold; \n};\n    \nLayoutStyle LayoutStyle_Default()\n{\n    LayoutStyle style;\n    style.vSize = vec2(16.0f, 16.0f);    \n    style.fLineGap = 0.1f;\n    style.fAdvancement = 0.1f;\n    style.bItalic = false;\n    style.bBold = false;    \n    return style;\n}\n\nstruct RenderStyle\n{\n    vec3 vFontColor;\n    float fFontWeight;\n};\n\nRenderStyle RenderStyle_Default( vec3 vFontColor )\n{\n    RenderStyle style;\n    style.vFontColor = vFontColor;\n    style.fFontWeight = 0.0f; \n    return style;\n}\n\nvoid PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )\n{\n    // Apply CR\n    state.vPos.x = state.vStart.x;\n    \n    // advance Y position to bottom of descender based on current font size.\n    float fFontDescent = 0.15f;\n\tstate.vPos.y -= style.vSize.y * fFontDescent;    \n}\n\nvoid PrintBeginNextLine( inout PrintState state, const LayoutStyle style )\n{\n    // move Y position to baseline based on current font size\n    float fFontAscent = 0.65f;\n\tstate.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);\n}\n\nvoid PrintEOL( inout PrintState state, const LayoutStyle style )\n{\n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n    }\n    PrintEndCurrentLine( state, style );\n    state.EOL = true;\n}\n\nvoid PrintCh( inout PrintState state, inout LayoutStyle style, const uint iChar )\n{\n    if ( iChar == _EOL )\n    {\n        PrintEOL( state, style );\n        return;\n    }\n    else\n    if ( iChar == _BOLDON )\n    {\n        style.bBold = true;\n        return;\n    }\n    else\n    if ( iChar == _BOLDOFF )\n    {\n        style.bBold = false;\n        return;\n    }\n    else\n    if ( iChar == _ITALON )\n    {\n        style.bItalic = true;\n        return;\n    }\n    else\n    if ( iChar == _ITALOFF )\n    {\n        style.bItalic = false;\n        return;\n    }\n    \n    if ( state.EOL )\n    {\n        PrintBeginNextLine( state, style );\n\t\tstate.EOL = false;\n    }\n    \n    vec2 vUV = (state.vPos / style.vSize);\n\n    /*if ( (vUV.y > -0.1) && (vUV.y < 0.1) && (abs(vUV.x) < 0.02 || abs(vUV.x - CharWidth(iChar)) < 0.02) )\n    {\n        state.fDistance = -10.0;\n    }*/\n    \n\tCharExtents extents = GetCharExtents( iChar );    \n    vUV.y += 0.8f; // Move baseline\n    vUV.x += extents.left - style.fAdvancement;\n    \n    if ( style.bItalic )\n    {\n    \tvUV.x += (1.0 - vUV.y) * -0.4f;\n    }\n    \n    vec3 v = SampleCharacter( iChar, vUV ).agb;\n    if ( style.bBold )\n    {\n    \tv.x -= 0.025f;\n    }\n    \n    if ( v.x < state.fDistance )\n    {\n        state.fDistance = v.x;    \n    }\n    \n    state.vPos.x -= style.vSize.x * (extents.width + style.fAdvancement);\n}\n\nfloat GetFontBlend( PrintState state, LayoutStyle style, float size )\n{\n    float fFeatherDist = 1.0f * length(state.vPixelSize / style.vSize);    \n    float f = clamp( (size-state.fDistance + fFeatherDist * 0.5f) / fFeatherDist, 0.0, 1.0);\n    return f;\n}\n\nvoid RenderFont( in PrintState state, in LayoutStyle style, in RenderStyle renderStyle, inout vec3 color )\n{\n    float f = GetFontBlend( state, style, renderStyle.fFontWeight );\n    vec3 vCol = renderStyle.vFontColor;\n    \n    color.rgb = mix( color.rgb, vCol, f);    \n}\n\n#define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }\n\nvoid Print( inout PrintState state, LayoutStyle style, uint value )\n{\n\tuint place = 1000000000u;\n\n    bool leadingZeros = true;\n    while( place > 0u )\n    {\n        uint digit = (value / place) % 10u;\n        if ( place == 1u || digit != 0u )\n        {\n            leadingZeros = false;\n        }\n        \n        if (!leadingZeros)\n        {\n            PrintCh( state, style, _0 + digit );\n        }\n        place = place / 10u;\n    }    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, int value )\n{\n    if ( value < 0 )\n    {\n        PrintCh( state, style, _MINUS );\n        value = -value;\n    }\n\n    Print ( state, style, uint(value) );    \n}\n\nvoid Print( inout PrintState state, LayoutStyle style, float value, int decimalPlaces )\n{\n    if ( value < 0.0f )\n    {\n        PrintCh( state, style, _MINUS );\n    }\n    value = abs(value);\n    \n    int placeIndex = 10;\n    \n    bool leadingZeros = true;\n    while( placeIndex >= -decimalPlaces )\n    {\n        float place = pow(10.0f, float(placeIndex) );\n        float digitValue = floor( value / place );\n        value -= digitValue * place; \n        \n        uint digit = min( uint( digitValue ), 9u );\n        \n        if ( placeIndex == -1 )\n        {\n            PrintCh( state, style, _PERIOD );\n        }\n        \n        if ( placeIndex == 0 || digit != 0u )\n        {\n            leadingZeros = false;\n        }        \n        \n        if ( !leadingZeros )\n        {\n        \tPrintCh( state, style, _0 + digit );\n        }\n                \n        placeIndex--;\n    }\n}\n\n// --------------- 8< --------------- 8< --------------- 8< --------------- 8< ---------------\n\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\n\n// Hash by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n \n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return 2.*fract((p3.xx+p3.yz)*p3.zy) - vec2(1.);\n\n}\n\n\n// This is the long written noise function so I finally understand what is happening\n// inside there\nfloat gradnoise(vec2 uv)\n{\n    vec2 p = floor(uv),\n        f = (fract(uv));\n    \n    vec2 u = f*f*f*(6.0*f*f - 15.0*f +10.0);\n    //vec2 u = f*f*(3.-2.*f);\n    float dot1, dot2, dot3, dot4;\n    \n    dot1 = dot((hash22(p)), f);\n    dot2 = dot((hash22(p + vec2(1., 0.))) , f - vec2(1.,0.));\n    dot3 = dot((hash22(p + vec2(0., 1.))) , f - vec2(0.,1.));\n    dot4 = dot((hash22(p + vec2(1., 1.))) , f - vec2(1.,1.));\n    \n    float m1, m2;\n    \n    m1 = mix(dot1, dot2, u.x);\n    m2 = mix(dot3, dot4, u.x);\n    \n    return mix(m1, m2, u.y);\n   // return hash22(p).y;\n}\n\n\n// expects a gradnoise lookup value (-1 ... 1)\n// and remaps it according to the function given\nfloat gradnoise_remap(float gradnoise_lookup)\n{\n    return 0.5;\n}\n\n\nfloat gainf(float x, float k) \n{\n    //remap k, so k is driven by 0...1 range\n    k = k < 0.5 ? 2.*k : 1./(1.-(k-0.5)*2.);\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat oct_gradnoise(vec2 uv, float octaves, float roughness, float octscale, bool equalize)\n{\n    float a = 0.;\n    float oct_intensity = 1.0; // first intensity is 1.0, successive octaves get scaled by roughness value\n    float total_scale = 0.0;\n    float remap;\n    float contrast = 0.0;\n    //mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for(float i = 0.; i < octaves; i++)\n    {\n        float gradnoise_lookup = gradnoise(uv)*1.;\n        \n        // So per octave mapping here\n        // some_func(gradnoise_lookup);\n        total_scale += oct_intensity;\t\t    \n        a += (gradnoise_lookup) * oct_intensity;\n        oct_intensity = oct_intensity * roughness; // get intensity for next(!) octave\n        uv = (uv + vec2(11.37, 11.49)) * octscale;\n    } \n    if(equalize == true)\n        a/=(total_scale);  \n\n    return (a); // if we were dividing just by octaves we'd get an intensity shift\n}\n\nfloat oct_gained_gradnoise(vec2 uv, float octaves, float roughness, float octscale)\n{\n    float a = 0.;\n    float intensity = 1.;\n    float oct_intensity = 1.0; // first intensity is 1.0, successive octaves get scaled by roughness value\n    float total_scale = 0.0;\n    float remap;\n    float contrast = 0.999;\n    float gain = .001;\n    //mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for(float i = 0.; i < octaves; i++)\n    {\n        float gradnoise_lookup = gradnoise(uv)*1.6;\n        \n        remap = gradnoise_lookup;\n        //remap = clamp(remap < 0. ? (- pow(abs(remap), gain)) : pow(remap, gain), -12.0, 12.0);\n        remap = gainf(clamp((gradnoise_lookup*.5 + .5), 0.0, 1.0), gain);\n        remap = ((remap - 0.5) * 2.); \n        \n\t\ttotal_scale += oct_intensity;\n        a += remap* oct_intensity;\n        oct_intensity*= roughness; // get intensity for current octave\n        \n        uv = (uv + vec2(11.37, 11.49)) * octscale;\n        \n    }\n    // applying contrast and clamping it\n\t\n    a = (a/(1.0 -contrast)) ;\n    a= clamp(a/total_scale, -1., 1.0);\n    return a; // if we were dividing just by octaves we'd get an intensity shift\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += iTime*.1;\n\tvec2 uvMouse = (iMouse.xy/iResolution.xy);\n    \n    int octaves = int(ceil(uvMouse.x * 10.));\n    float roughness = uvMouse.y*1.5;\n    // Dynamic gradnoise\n    \n    // Static gradnoise\n    \n    float octscale = 2.0; //factor by which each octave gets smaller than the previous one\n    bool equalized_out_yes = true;\n    bool equalized_out = true;\n    float final_value;\n    \n    \n    \n    if(fragCoord.x < iResolution.x/2.)\n    {\n        if(uv.y > 0.5)\n        {\n            final_value = oct_gradnoise( uv*2., float(octaves), roughness, octscale, NORMALIZED_OUTPUT);  \n\t\t\t//final_value = final_value/.3;\n            final_value = final_value*0.5 + 0.5;\n        }\n        else\n        {\n            final_value = (oct_gradnoise( uv*2., float(octaves), roughness, octscale, UNNORMALIZED_OUTPUT));\n            //final_value = 1.0 - exp(-final_value);\n            final_value = final_value*0.5 + 0.5;\n        }\n    }\n    else\n    {\n        //oct_gained_gradnoise(vec2 uv, float octaves, float roughness, float octscale)\n        \n        final_value = gradnoise(uv*2.*pow(octscale, float(octaves-1)));  \n        final_value = final_value*0.5 + 0.5;\n    }\n    \n\n    \n    \n    if(mod(fragCoord.x, iResolution.x /2.) < 1.)\n       final_value = 0.;\n\n\n    // Output to screen\n    fragColor = vec4(final_value);\n    \n    // ----------- Font Rendering ----------\n    vec2 vCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y );    \n    vec2 vCanvasPixelSize = vec2(1.0);\n\n\tbool bScaleWithResolution = false;    \n    \n    if ( bScaleWithResolution )\n    {\n    \tvCanvasCoord = vec2( fragCoord.x, iResolution.y - 1.0f - fragCoord.y ) * vec2(640.0, 360) / iResolution.xy;\n    \tvCanvasPixelSize = vec2(640.0, 360) / iResolution.xy;   \n      //  vec2 dVdx = dFdx(vCanvasCoord);\n      //  vec2 dVdy = dFdy(vCanvasCoord);\n      //  vCanvasPixelSize = vec2( length(vec2(dVdx.x, dVdy.x) ), length(vec2(dVdx.y, dVdy.y) ) );\n    }\n    \n    PrintState state = PrintState_InitCanvas( vCanvasCoord, vCanvasPixelSize );\n    MoveTo(state, vec2(6,10));\n\n    LayoutStyle style = LayoutStyle_Default();\n    style.vSize = vec2(16.0f, 16.0f);\n    style.fLineGap = 0.1;\n    style.fAdvancement = 0.1;\n    //style.bBold = true;\n    \n    \n    // Without this line the print position specifies the baseline\n    // with this line we advance by the ascent and line gap\n    PrintBeginNextLine(state, style);\n    \n    uint str[] = uint[] ( _O, _c, _t, _a, _v, _e, _s, _COLON, _SP);\n    ARRAY_PRINT( state, style, str );\n   \n\tPrint( state, style, octaves);\n    PrintCh( state, style,  _EOL  );\n    \n    uint str2[] = uint[] ( _R, _o, _u, _g, _h, _n, _e, _s, _s, _COLON, _SP);\n    ARRAY_PRINT( state, style, str2 );\n    \n    Print (state, style, roughness, 3);\n    PrintCh( state, style,  _EOL  );\n    \n    MoveTo(state, vec2(iResolution.x/2. + 10.,19));\n    uint str3[] = uint[] ( _C, _u, _r, _r, _e, _n, _t, _SP, _M, _a, _x, _SP, _O, _c, _t, _a, _v, _e,_SP);\n    ARRAY_PRINT( state, style, str3 );\n    \n    uint str4[] = uint[] ( _W, _i, _t, _h, _SP, _N, _o, _r, _m, _a, _l, _i, _z, _a, _t, _i, _o, _n, _SP);\n    uint str5[] = uint[] ( _N, _o, _SP, _N, _o, _r, _m, _a, _l, _i, _z, _a, _t, _i, _o, _n, _SP);\n    \n    MoveTo(state, vec2(6., iResolution.y/2. - 6.));\n    ARRAY_PRINT( state, style, str4 );\n    \n    MoveTo(state, vec2(6., iResolution.y/2. + 14.));\n    ARRAY_PRINT( state, style, str5 );\n //   Print( state, style, int(iDate.x) );\n //   PrintCh( state, style, _MINUS );\n //   Print( state, style, int(iDate.y) + 1 );\n //   PrintCh( state, style, _MINUS );\n //   Print( state, style, int(iDate.z) );\n //   PrintCh( state, style, _COMMA );\n //   PrintCh( state, style, _SP );\n //   Print( state, style, int(mod(iDate.w / (60.0 * 60.0), 24.0)) );\n //   PrintCh( state, style, _COLON );\n //   Print( state, style, int(mod(iDate.w / 60.0, 60.0)) );\n //   PrintCh( state, style, _COMMA );\n //   PrintCh( state, style, _SP );\n //   Print( state, style, iTime, 3 );\n //   PrintEOL( state, style );\n   \n\n    RenderStyle renderStyle = RenderStyle_Default( vec3(0.0) );\n    RenderFont( state, style, renderStyle, fragColor.rgb );\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2739, 2739, 2792, 2792, 2946], [2952, 2952, 3002, 3002, 3971], [4828, 4914, 4960, 4960, 5117], [5119, 5119, 5161, 5161, 5588], [5769, 5769, 5819, 5819, 5926], [5928, 5928, 5977, 5977, 6012], [6014, 6014, 6081, 6081, 6265], [6391, 6391, 6426, 6426, 6625], [6696, 6696, 6748, 6748, 6857], [6859, 6859, 6936, 6952, 7154], [7156, 7156, 7232, 7294, 7392], [7394, 7394, 7460, 7460, 7602], [7604, 7604, 7687, 7687, 8955], [8957, 8957, 9028, 9028, 9213], [9215, 9215, 9323, 9323, 9485], [9621, 9621, 9690, 9690, 10064], [10066, 10066, 10134, 10134, 10280], [10282, 10282, 10371, 10371, 11164], [11380, 11555, 11577, 11577, 11694], [11697, 11808, 11829, 11829, 11977], [11980, 12081, 12107, 12107, 12645], [12648, 12744, 12791, 12791, 12809], [12812, 12812, 12844, 12889, 13013], [13015, 13015, 13108, 13108, 13912], [13914, 13914, 13999, 13999, 15061]], "test": "error"}
{"id": "tdlyzN", "name": "Fast PBR Ring System", "author": "16807", "description": "Click to rotate. To view from the surface, set IS_FIRST_PERSON_POV = true. This scene depicts a ringed earth-size planet 1 AU distance from a sunlike star. It assumes the rings are gaussian distributed mie scatterers with a little absorption.", "tags": ["fast", "approximation", "analytic", "integral", "pbr", "scatterer"], "likes": 1, "viewed": 70, "published": "Public", "date": "1584318114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nstruct maybe_int\n{\n    int value;\n    bool exists;\n};\nstruct maybe_float\n{\n    float value;\n    bool exists;\n};\nstruct maybe_vec2\n{\n    vec2 value;\n    bool exists;\n};\nstruct maybe_vec3\n{\n    vec3 value;\n    bool exists;\n};\nstruct maybe_vec4\n{\n    vec4 value;\n    bool exists;\n};\nconst float PI = 3.14159265358979323846264338327950288419716939937510;\nconst float PHI = 1.6180339887;\nconst float BIG = 1e20;\nconst float SMALL = 1e-20;\n\n/*\nGENERIC MATH UTILITY FUNCTIONS\nfunctions not associated to any subject in particular\n*/\n// The error function, integral of exp(-x^2)\nfloat erf(float x)\n{\n    return tanh(1.202760580 * x);\n}\n/*\nMENSURATION\nthis file contains functions for finding perimeters, areas, \nsurface areas, and volumes of primitive shapes\n*/\nfloat get_perimeter_of_circle(\n    in float radius\n) {\n    return 2.*PI*radius;\n}\nfloat get_area_of_circle(\n    in float radius\n) {\n    return PI*radius*radius;\n}\nfloat get_perimeter_of_triangle(\n    in vec2 vertex1,\n    in vec2 vertex2,\n    in vec2 vertex3\n) {\n    return length(vertex1-vertex2) + length(vertex2-vertex3) + length(vertex3-vertex1);\n}\nfloat get_area_of_triangle(\n    in vec2 vertex1,\n    in vec2 vertex2,\n    in vec2 vertex3\n) {\n    // half the magnitude of the cross product\n    return 0.5f * abs((vertex1.x*(vertex2.y-vertex3.y) + vertex2.x*(vertex3.y-vertex1.y)+ vertex3.x*(vertex1.y-vertex2.y)));\n}\nfloat get_surface_area_of_sphere(\n    in float radius\n) {\n    return 4.*PI*radius*radius;\n}\nfloat get_volume_of_sphere(\n    in float radius\n) {\n    return 4./3.*PI*radius*radius*radius;\n}\nfloat get_surface_area_of_tetrahedron(\n    in vec3 vertex1,\n    in vec3 vertex2,\n    in vec3 vertex3,\n    in vec3 vertex4\n) {\n    // each face is half the magnitude of the cross product\n    return 0.5f * (\n        length(cross(vertex1-vertex2, vertex1-vertex3)) +\n        length(cross(vertex1-vertex2, vertex1-vertex4)) +\n        length(cross(vertex1-vertex3, vertex1-vertex4)) +\n        length(cross(vertex2-vertex3, vertex2-vertex4))\n    );\n}\nfloat get_volume_of_tetrahedron(\n    in vec3 vertex1,\n    in vec3 vertex2,\n    in vec3 vertex3,\n    in vec3 vertex4\n) {\n    // 1/6 the volume of a parallelipiped, which is the scalar triple product of its edges\n    return dot(cross(vertex1-vertex2, vertex1-vertex3), vertex1-vertex4) / 6.f;\n}\n// 2D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nbool is_2d_point_in_circle(in vec2 A0, in vec2 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n/*\nA0 point position\nB0 ellipsis center\nR  ellipsis radius along each coordinate axis\n*/\nbool is_2d_point_in_ellipsis(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    return length((A0-B0)/R) < 1.0;\n}\n/*\nA0 point position\nB0 rectangle center\nR  rectangle length along each coordinate axis\n*/\nbool is_2d_point_in_axis_aligned_rectangle(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    return all(lessThan(abs((A0-B0)/R), vec2(1)));\n}\n/*\nA0 point position\nB0 line reference\nN  surface normal of region, normalized\n\nNOTE: in this case, N only needs to indicate the direction facing outside, \n it need not be perfectly normal to B\n*/\nbool is_2d_point_in_region_bounded_by_line(in vec2 A0, in vec2 B0, in vec2 N)\n{\n    return dot(A0-B0, N) < 0.;\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\nbool is_2d_point_in_triangle(in vec2 A0, in vec2 B1, in vec2 B2, in vec2 B3)\n{\n    // INTUITION: if A falls within a triangle,\n    //  the angle between A and any side will always be less than the angle\n    //  between that side and the side adjacent to it\n    vec2 B2B1hat = normalize(B2-B1);\n    vec2 B3B2hat = normalize(B3-B2);\n    vec2 B1B3hat = normalize(B1-B3);\n    return dot(normalize(A0-B1), B2B1hat) > dot(-B1B3hat, B2B1hat)\n        && dot(normalize(A0-B2), B3B2hat) > dot(-B2B1hat, B3B2hat)\n        && dot(normalize(A0-B3), B1B3hat) > dot(-B3B2hat, B1B3hat);\n}\n// 3D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nbool is_3d_point_in_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  radius\n*/\nbool is_3d_point_in_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    return length((A0-B0)/R) < 1.0;\n}\n/*\nA0 point position\nB0 rectangle center\nR  rectangle length along each coordinate axis\n*/\nbool is_3d_point_in_axis_aligned_rectangle(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    return all(lessThan(abs((A0-B0)/R), vec3(1)));\n}\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nbool is_3d_point_in_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N) < 0.;\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\nbool is_3d_point_in_tetrahedron(in vec3 A0, in vec3 B1, in vec3 B2, in vec3 B3, in vec3 B4)\n{\n    // INTUITION: for each triangle, make sure A0 lies on the same side as the remaining vertex\n    vec3 B2xB3 = cross(B2-B1, B3-B1);\n    vec3 B3xB1 = cross(B3-B2, B1-B2);\n    vec3 B1xB2 = cross(B1-B3, B2-B3);\n   return sign(dot(A0-B1, B2xB3)) == sign(dot(B4-B1, B2xB3))\n        && sign(dot(A0-B2, B3xB1)) == sign(dot(A0-B2, B3xB1))\n        && sign(dot(A0-B3, B1xB2)) == sign(dot(A0-B3, B1xB2))\n        ;\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nfloat get_distance_of_2d_point_to_circle(in vec2 A0, in vec2 B0, in float r)\n{\n    return length(A0-B0) - r;\n}\n/*\nA0 point position\nB0 box center\nB  box dimentsions\n*/\nfloat get_distance_of_2d_point_to_rectangle(in vec2 A0, in vec2 B0, in vec2 B)\n{\n  vec2 q = abs(B0) - B;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n/*\nA0 point position\nB0 ellipsis center\nR  ellipsis radius along each coordinate axis\n*/\nfloat guess_distance_of_2d_point_to_ellipsis(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    float u = length((A0-B0)/R);\n    float v = length((A0-B0)/(R*R));\n    return u*(u-1.0)/v;\n}\n/*\nA0 point position\nB0 line reference\nN  surface normal of region, normalized\n\nNOTE: in this case, N only needs to indicate the direction facing outside, \n it need not be perfectly normal to B\n*/\nfloat get_distance_of_2d_point_to_region_bounded_by_line(in vec2 A0, in vec2 B0, in vec2 N)\n{\n    return dot(A0-B0, N);\n}\n// 3D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nfloat get_distance_of_3d_point_to_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) - r;\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nfloat guess_distance_of_3d_point_to_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    vec3 V = A0-B0;\n    float u = length(V/R);\n    float v = length(V/(R*R));\n    return u*(u-1.0)/v;\n}\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nfloat get_distance_of_3d_point_to_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N);\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\n/*\nfloat get_distance_of_3d_point_to_tetrahedron(in vec3 A0, in vec3 B1, in vec3 B2, in vec3 B3, in vec3 B4)\n{\n    // INTUITION: for each triangle, make sure A0 lies on the same side as the remaining vertex\n    vec3 B2xB3 = cross(B2-B1, B3-B1);\n    vec3 B3xB1 = cross(B3-B2, B1-B2);\n    vec3 B1xB2 = cross(B1-B3, B2-B3);\n    return sign(dot(A0-B1, B2xB3)) == sign(dot(B4-B1, B2xB3)) \n        && sign(dot(A0-B2, B3xB1)) == sign(dot(A0-B2, B3xB1)) \n        && sign(dot(A0-B3, B1xB2)) == sign(dot(A0-B3, B1xB2)) \n        ;\n}\n*/\n\n//#include \"precompiled/academics/math/geometry/point_intersection.glsl\"\n\nmaybe_vec2 get_bounding_distances_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_vec2(\n        vec2(\n          max(min(distances_along_line.value.x, distances_along_line.value.y), 0.0),\n          max(distances_along_line.value.x, distances_along_line.value.y)\n        ),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_nearest_distance_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_float(\n        distances_along_line.value.x < 0.0? distances_along_line.value.y :\n        distances_along_line.value.y < 0.0? distances_along_line.value.x :\n        min(distances_along_line.value.x, distances_along_line.value.y),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_distance_along_line_to_union(\n    in maybe_float shape1,\n    in maybe_float shape2\n) {\n    return maybe_float(\n        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),\n        shape1.exists || shape2.exists\n    );\n}\nmaybe_vec2 get_distances_along_line_to_union(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),\n             !shape1.exists ? shape2.value.y : !shape2.exists ? shape1.value.y : max(shape1.value.y, shape2.value.y )),\n        shape1.exists || shape2.exists\n    );\n}\n\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 positive,\n    in maybe_vec2 negative\n) {\n    /*\n    There are 4 values to consider, two for positive space and two for negative space.\n    In comments, we denoted these values as x+, y+, x-, and y-\n    There are 4*3*2*1 = 24 ways these 4 values could be sequenced along a number line.\n    x variables indicate the start of a region, and y indicate the end of a region,\n    therefore we can ignore sequences where yp<xp and yn<xn.\n    We can see all possible sequences that fulfill this condition using the following code, in python:\n        [A for A in itertools.permutations(['x+','y+','x-','y-']) \n         if A.index('x+') < A.index('y+') and A.index('x-') < A.index('y-')]\n    Combined with flags for whether positive/negative space exists along the ray, \n    This provides us with the following possibilities and their output \n    (asterisks indicate arbitrary values):\n        input               output\n                    exists        exists\n        1  2  3  4  - +     x  y  \n        *  *  *  *  F F     *  *  F\n        *  *  *  *  T F     *  *  F\n        *  *  *  *  F T     x+ y+ T\n        x+ y+ x- y- T T     x+ y+ T\n        x+ x- y+ y- T T     x+ x- T\n        x+ x- y- y+ T T     x+ x- T\n        x- x+ y+ y- T T     *  *  F\n        x- x+ y- y+ T T     y- y+ T\n        x- y- x+ y+ T T     x+ y+ T\n\n    */\n\n    float xp = positive.value.x;\n    float yp = positive.value.y;\n    float xn = negative.value.x;\n    float yn = negative.value.y;\n\n    // as long as intersection with positive exists, \n    // and negative doesn't completely surround it, there will be an intersection\n    if (!positive.exists || (xn < xp && yp < yn && negative.exists)){\n        return maybe_vec2( vec2(xn, xn), false);\n    }\n    else if (!negative.exists || yn < xp){\n        return positive;\n    } \n    else if (xp < xn) {\n        return maybe_vec2( vec2(min(yn, xp), min(xn, yp)), true);\n    }\n    else /*x- x+ y- y+*/{\n        return maybe_vec2( vec2(yn, yp), true);\n    } \n}\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.0;\n    float y = shape1.exists && shape2.exists ? min(shape1.value.y, shape2.value.y ) : 0.0;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\nfloat get_distance_along_2d_line_nearest_to_point(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0\n){\n    return dot(B0 - A0, A);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\nmaybe_float get_distance_along_2d_line_to_line(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    return maybe_float(\n        length(R) / dot(B, normalize(-R)),\n        abs(abs(dot(A, B)) - 1.0) > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\nmaybe_float get_distance_along_2d_line_to_ray(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && xA > 0.0);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line segment endpoint 1\nB1 line segment endpoint 2\n*/\nmaybe_float get_distance_along_2d_line_to_line_segment(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|\n    vec2 B = normalize(B2 - B1);\n    vec2 D = B1 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && 0. < xA && xA < length(B2 - B1));\n}\nmaybe_vec2 get_distances_along_2d_line_to_circle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in float r\n){\n    vec2 D = B0 - A0;\n    float xz = dot(D, A);\n    float z2 = dot(D, D) - xz * xz;\n    float y2 = r * r - z2;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\n*/\nmaybe_vec2 get_distances_along_2d_line_to_triangle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2,\n    in vec2 B3\n){\n    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);\n    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);\n    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);\n    return maybe_vec2(\n        vec2(min(line1.value, min(line2.value, line3.value)),\n             max(line1.value, max(line2.value, line3.value))),\n        line1.exists || line2.exists || line3.exists\n    );\n}\nfloat get_distance_along_3d_line_nearest_to_point(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0\n){\n    return dot(B0 - A0, A);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_line(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 C = normalize(cross(B, A));\n    // cross\n    vec3 R = D - dot(D, A) * A - dot(D, C) * C;\n    // rejection\n    return maybe_float(\n        length(R) / -dot(B, normalize(R)),\n        abs(abs(dot(A, B)) - 1.0) > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_ray(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && xA > 0.0);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 line segment endpoint 1\nB2 line segment endpoint 2\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_line_segment(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B1\n){\n    vec3 B = normalize(B1 - B0);\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && 0. < xA && xA < length(B1 - B0));\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 circle origin\nN  circle surface normal, normalized\nr  circle radius\n*/\nmaybe_float get_distance_along_3d_line_to_circle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N,\n    in float r\n){\n    // intersection(plane, sphere)\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\nmaybe_float get_distance_along_3d_line_to_triangle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3\n){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3 B0 = (B1 + B2 + B3) / 3.;\n    vec3 N = normalize(cross(B1 - B2, B2 - B3));\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3 At = A0 + A * t.value;\n    vec3 B2B1hat = normalize(B2 - B1);\n    vec3 B3B2hat = normalize(B3 - B2);\n    vec3 B1B3hat = normalize(B1 - B3);\n    return maybe_float(t.value,\n        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) &&\n        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) &&\n        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float t = dot(B0 - A0, A);\n    vec3  At = A0 + A*t - B0;\n    float y2 = r*r - dot(At,At);\n    float dxr = sqrt(max(y2, SMALL));\n    return maybe_vec2(\n        vec2(t - dxr, t + dxr),\n        y2 > 0.\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nmaybe_float get_distance_along_3d_line_to_ellipsoid(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 R\n){\n    // NOTE: shamelessly copy pasted, all credit goes to Inigo: \n    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    vec3 Or = (A0 - B0) / R;\n    vec3 Ar = A / R;\n    float ArAr = dot(Ar, Ar);\n    float OrAr = dot(Or, Ar);\n    float OrOr = dot(Or, Or);\n    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);\n    return maybe_float(\n        (-OrAr - sqrt(h)) / ArAr,\n        h >= 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\nmaybe_float get_distance_along_3d_line_to_tetrahedron(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3,\n    in vec3 B4\n){\n    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);\n    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);\n    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);\n    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);\n    maybe_float hit;\n    hit = get_distance_along_line_to_union(hit1, hit2);\n    hit = get_distance_along_line_to_union(hit, hit3);\n    hit = get_distance_along_line_to_union(hit, hit4);\n    return hit;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.0));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a),\n        h > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y, a_in);\n    float exit = min(tube.value.x, a_out);\n    return maybe_vec2(\n        vec2(entrance, exit),\n        tube.exists && entrance < exit\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 capsule endpoint 1\nB2 capsule endpoing 2\nr  capsule radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_capsule(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);\n    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);\n    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);\n    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);\n    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);\n    return capsule;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 ring endpoint 1\nB2 ring endpoing 2\nro ring outer radius\nri ring inner radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_ring(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float ro,\n    in float ri\n){\n    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);\n    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);\n    maybe_vec2 ring = get_distances_along_line_to_negation(outer, inner);\n    return ring;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\ncosb cosine of cone half angle\n*/\nmaybe_float get_distance_along_3d_line_to_infinite_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float cosb\n){\n    vec3 D = A0 - B0;\n    float a = dot(A, B) * dot(A, B) - cosb * cosb;\n    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);\n    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;\n    float det = b * b - 4. * a * c;\n    if (det < 0.)\n    {\n        return maybe_float(0.0, false);\n    }\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t)\n    {\n        t = t2;\n    }\n    else {\n        t = t1;\n    }\n    vec3 cp = A0 + t * A - B0;\n    float h = dot(cp, B);\n    return maybe_float(t, t > 0. && h > 0.);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\nr  cone radius\nh  cone height\n*/\nmaybe_float get_distance_along_3d_line_to_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r,\n    in float h\n){\n    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));\n    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;\n    cone = get_distance_along_line_to_union(end, cone);\n    return cone;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cone endpoint 1\nB2 cone endpoint 2\nr1 cone endpoint 1 radius\nr2 cone endpoint 2 radius\n*/\nmaybe_float get_distance_along_3d_line_to_capped_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r1,\n    in float r2\n){\n    float dh = length(B2 - B1);\n    float dr = r2 - r1;\n    float rmax = max(r2, r1);\n    float rmin = min(r2, r1);\n    float hmax = rmax * dr / dh;\n    float hmin = rmin * dr / dh;\n    vec3 B = sign(dr) * normalize(B2 - B1);\n    vec3 Bmax = (r2 > r1? B2 : B1);\n    vec3 B0 = Bmax - B * hmax;\n    vec3 Bmin = Bmax - B * hmin;\n    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);\n    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));\n    float c_h = dot(A0 + cone.value * A - B0, B);\n    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;\n    cone = get_distance_along_line_to_union(cone, end1);\n    cone = get_distance_along_line_to_union(cone, end2);\n    return cone;\n}\n\n/*\nA1 vertex 1 position\nA2 vertex 2 position\nA3 vertex 3 position\n*/\nvec3 get_surface_normal_of_triangle( in vec3 A1, in vec3 A2, in vec3 A3 )\n{\n    return normalize( cross(A2-A1, A3-A1) );\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nvec3 get_surface_normal_of_point_near_sphere( in vec3 A0, in vec3 B0 )\n{\n    return normalize( A0-B0 );\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nvec3 guess_surface_normal_of_point_near_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    vec3  V  = A0-B0;\n    return normalize( V/R );\n}\n/*\nA0 point position\nB0 cylinder reference\nB  cylinder direction, normalized\n*/\nvec3 get_surface_normal_of_point_near_infinite_cylinder( in vec3 A0, in vec3 B0, in vec3 B )\n{\n    // INTUITION: equivalent to the normalized vector rejection\n    vec3 D = A0-B0;\n    return normalize( D - B*dot(D, B) );\n}\n/*\nA0 point position\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\n*/\nvec3 get_surface_normal_of_point_near_cylinder( in vec3 A0, in vec3 B1, in vec3 B2 )\n{\n    vec3 D = A0-B1;\n    vec3 B = normalize(B2-B1);\n    float DB = dot(D,B);\n    return 0.f < DB? -B : DB < length(D)? B : normalize( D-B*DB );\n}\n\n\nfloat get_angular_radius_of_sphere_at_distance(\n\tin float sphere_radius, in float sphere_distance\n){\n\tfloat r = sphere_radius;\n\tfloat h = sphere_distance;\n\t// \"a2\": squared distance to the tangent point, found using pythagorean theorem, \n\t// scaled so hypoteneuse = 1\n\tfloat a2 = 1.0-r*r/(h*h);\n\treturn r * sqrt(a2) / (h * a2);\n}\nfloat get_area_of_intersection_between_circle_and_circle(\n\tin float circle1_radius, in float circle2_radius, in float circle_origin_distance\n){\n\t/*\n\tNOTE: see here for an explanation:\n\thttps://www.xarg.org/2016/07/calculate-the-intersection-area-of-two-circles/\n\t*/\n\tfloat d = circle_origin_distance;\n\tfloat R = max(circle1_radius, circle2_radius);\n\tfloat r = min(circle1_radius, circle2_radius);\n\tif (d>=r+R)\n\t{\n\t\treturn 0.0;\n\t}\n\telse if (d+r<=R)\n\t{\n\t\treturn PI*r*r;\n\t}\n\telse \n\t{\n\t\tconst float EPSILON = 0.000;\n\t\tfloat X = (R*R-r*r+d*d)/(2.0*d);\n\t\tfloat y = sqrt(R*R-X*X);\n\t\tfloat x = abs(d-X);//sqrt(r*r-y*y);\n\t\tfloat theta = asin(y/r);\n\t\tfloat Theta = asin(y/R);\n\t\tfloat a = r*r*theta - x*y;\n\t\tfloat A = R*R*Theta - X*y;\n\t\treturn A + d>=X? a:PI*r*r-a;\n\t}\n}\n/*\nAssumes the light source and occlusion are distant enough that they can be \ntreated as circles on a 2d plane\n*/\nfloat get_fraction_of_sphere_not_occluded_by_sphere(\n\tin vec3 light_destination, in vec3 light_origin, in float light_radius, \n\tin vec3 sphere_origin, in float sphere_radius\n){\n    const float EPSILON = 1e-10;\n\t// direction of light origin from destination\n\tvec3  light_direction  = normalize(light_origin-light_destination);\n\tfloat light_distance   = length(light_origin-light_destination);\n\t// direction of sphere origin from destination\n\tvec3  sphere_direction = normalize(sphere_origin-light_destination);\n\tfloat sphere_distance  = length(sphere_origin-light_destination);\n\tfloat cos_angular_separation = dot(light_direction, sphere_direction);\n\t// angular separation between light and sphere origins when viewed from destination\n    if (cos_angular_separation <= 0.0) return 1.0;\n    if (sphere_distance < sphere_radius) return 0.0;\n\tfloat angular_separation = acos(min(cos_angular_separation, 1.0-EPSILON));\n\tfloat angular_light_radius  = get_angular_radius_of_sphere_at_distance(light_radius, light_distance);\n\tfloat angular_sphere_radius = get_angular_radius_of_sphere_at_distance(sphere_radius, sphere_distance);\n\t// distance between light and sphere origins when viewed from destination, \n\t// treating the two as circles on a 2d plane\n\tfloat angular_distance = 2.0 * tan(angular_separation / 2.0);\n    if(angular_separation>1e20) {return 1.;}\n\tfloat area = get_area_of_intersection_between_circle_and_circle(\n\t\tangular_light_radius, angular_sphere_radius, angular_distance\n\t);\n\treturn 1.0 - area / (PI*angular_light_radius*angular_light_radius);\n}\n\n\n\nconst float DEGREE = 3.141592653589793238462643383279502884197169399/180.;\nconst float RADIAN = 1.;\nconst float KELVIN = 1.;\nconst float MICROGRAM = 1e-9; // kilograms\nconst float MILLIGRAM = 1e-6; // kilograms\nconst float GRAM = 1e-3; // kilograms\nconst float KILOGRAM = 1.; // kilograms\nconst float TON = 1000.; // kilograms\nconst float NANOMETER = 1e-9; // meters\nconst float MICROMETER = 1e-6; // meters\nconst float MILLIMETER = 1e-3; // meters\nconst float METER = 1.; // meters\nconst float KILOMETER = 1000.; // meters\nconst float MOLE = 6.02214076e23;\nconst float MILLIMOLE = MOLE / 1e3;\nconst float MICROMOLE = MOLE / 1e6;\nconst float NANOMOLE = MOLE / 1e9;\nconst float FEMTOMOLE = MOLE / 1e12;\nconst float SECOND = 1.; // seconds\nconst float MINUTE = 60.; // seconds\nconst float HOUR = MINUTE*60.; // seconds\nconst float DAY = HOUR*24.; // seconds\nconst float WEEK = DAY*7.; // seconds\nconst float MONTH = DAY*29.53059; // seconds\nconst float YEAR = DAY*365.256363004; // seconds\nconst float MEGAYEAR = YEAR*1e6; // seconds\nconst float NEWTON = KILOGRAM * METER / (SECOND * SECOND);\nconst float JOULE = NEWTON * METER;\nconst float WATT = JOULE / SECOND;\nconst float EARTH_MASS = 5.972e24; // kilograms\nconst float EARTH_RADIUS = 6.367e6; // meters\nconst float STANDARD_GRAVITY = 9.80665; // meters/second^2\nconst float STANDARD_TEMPERATURE = 273.15; // kelvin\nconst float STANDARD_PRESSURE = 101325.; // pascals\nconst float ASTRONOMICAL_UNIT = 149597870700.;// meters\nconst float GLOBAL_SOLAR_CONSTANT = 1361.; // watts/meter^2\nconst float JUPITER_MASS = 1.898e27; // kilograms\nconst float JUPITER_RADIUS = 71e6; // meters\nconst float SOLAR_MASS = 2e30; // kilograms\nconst float SOLAR_RADIUS = 695.7e6; // meters\nconst float SOLAR_LUMINOSITY = 3.828e26; // watts\nconst float SOLAR_TEMPERATURE = 5772.; // kelvin\n\n\n\nconst float SPEED_OF_LIGHT = 299792458. * METER / SECOND;\nconst float BOLTZMANN_CONSTANT = 1.3806485279e-23 * JOULE / KELVIN;\nconst float STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8 * WATT / (METER*METER* KELVIN*KELVIN*KELVIN*KELVIN);\nconst float PLANCK_CONSTANT = 6.62607004e-34 * JOULE * SECOND;\n// see Lawson 2004, \"The Blackbody Fraction, Infinite Series and Spreadsheets\"\n// we only do a single iteration with n=1, because it doesn't have a noticeable effect on output\nfloat solve_fraction_of_light_emitted_by_black_body_below_wavelength(\n    in float wavelength,\n    in float temperature\n){\n    const float iterations = 2.;\n    const float h = PLANCK_CONSTANT;\n    const float k = BOLTZMANN_CONSTANT;\n    const float c = SPEED_OF_LIGHT;\n    float L = wavelength;\n    float T = temperature;\n    float C2 = h*c/k;\n    float z = C2 / (L*T);\n    float z2 = z*z;\n    float z3 = z2*z;\n    float sum = 0.;\n    float n2=0.;\n    float n3=0.;\n    for (float n=1.; n <= iterations; n++) {\n        n2 = n*n;\n        n3 = n2*n;\n        sum += (z3 + 3.*z2/n + 6.*z/n2 + 6./n3) * exp(-n*z) / n;\n    }\n    return 15.*sum/(PI*PI*PI*PI);\n}\nfloat solve_fraction_of_light_emitted_by_black_body_between_wavelengths(\n    in float lo,\n    in float hi,\n    in float temperature\n){\n    return solve_fraction_of_light_emitted_by_black_body_below_wavelength(hi, temperature) -\n            solve_fraction_of_light_emitted_by_black_body_below_wavelength(lo, temperature);\n}\n// This calculates the radiation (in watts/m^2) that's emitted \n// by a single object using the Stephan-Boltzmann equation\nfloat get_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    float T = temperature;\n    return STEPHAN_BOLTZMANN_CONSTANT * T*T*T*T;\n}\nvec3 solve_rgb_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    return get_intensity_of_light_emitted_by_black_body(temperature)\n         * vec3(\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(600e-9*METER, 700e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(500e-9*METER, 600e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(400e-9*METER, 500e-9*METER, temperature)\n           );\n}\n// Rayleigh phase function factor [-1, 1]\nfloat get_fraction_of_rayleigh_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    return 3. * (1. + cos_scatter_angle*cos_scatter_angle)\n    / //------------------------\n                (16. * PI);\n}\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nfloat get_fraction_of_mie_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    return (1. - g*g)\n    / //---------------------------------------------\n        ((4. + PI) * pow(1. + g*g - 2.*g*cos_scatter_angle, 1.5));\n}\n// Schlick's fast approximation to the Henyey-Greenstein phase function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nfloat approx_fraction_of_mie_scattered_light_scattered_by_angle_fast(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    const float k = 1.55*g - 0.55 * (g*g*g);\n    return (1. - k*k)\n    / //-------------------------------------------\n        (4. * PI * (1. + k*cos_scatter_angle) * (1. + k*cos_scatter_angle));\n}\n/*\n\"get_fraction_of_microfacets_accessible_to_ray\" is Schlick's fast approximation for Smith's function\n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_accessible_to_ray(\n    in float cos_view_angle,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float v = cos_view_angle;\n    // float k = m/2.0; return 2.0*v/(v+sqrt(m*m+(1.0-m*m)*v*v)); // Schlick-GGX\n    float k = m*sqrt(2./PI); return v/(v*(1.0-k)+k); // Schlick-Beckmann\n}\n/*\n\"get_fraction_of_microfacets_with_angle\" \n  This is also known as the Beckmann Surface Normal Distribution Function.\n  This is the probability of finding a microfacet whose surface normal deviates from the average by a certain angle.\n  see Hoffmann 2015 for a gentle introduction to the concept.\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_with_angle(\n    in float cos_angle_of_deviation,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float t = cos_angle_of_deviation;\n    float m2 = m*m;\n    float t2 = t*t;\n    float u = t2*(m2-1.0)+1.0; return m2/(PI*u*u);\n    //return exp((t*t-1.)/max(m*m*t*t, 0.1))/max(PI*m*m*t*t*t*t, 0.1);\n}\n/*\n\"get_fraction_of_light_reflected_from_facet_head_on\" finds the fraction of light that's reflected\n  by a boundary between materials when striking head on.\n  It is also known as the \"characteristic reflectance\" within the fresnel reflectance equation.\n  The refractive indices can be provided as parameters in any order.\n*/\nfloat get_fraction_of_light_reflected_from_facet_head_on(\n    in float refractivate_index1,\n    in float refractivate_index2\n){\n    float n1 = refractivate_index1;\n    float n2 = refractivate_index2;\n    float sqrtF0 = ((n1-n2)/(n1+n2));\n    float F0 = sqrtF0 * sqrtF0;\n    return F0;\n}\n/*\n\"get_rgb_fraction_of_light_reflected_from_facet\" returns Fresnel reflectance for each color channel.\n  Fresnel reflectance is the fraction of light that's immediately reflected upon striking the surface.\n  It is the fraction of light that causes specular reflection.\n  Here, we use Schlick's fast approximation for Fresnel reflectance.\n  see https://en.wikipedia.org/wiki/Schlick%27s_approximation for a summary \n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for implementation details\n*/\nvec3 get_rgb_fraction_of_light_reflected_from_facet(\n    in float cos_incident_angle,\n    in vec3 characteristic_reflectance\n){\n    vec3 F0 = characteristic_reflectance;\n    float _1_u = 1.-cos_incident_angle;\n    return F0 + (1.-F0) * _1_u*_1_u*_1_u*_1_u*_1_u;\n}\n/*\n\"get_fraction_of_light_reflected_from_material\" is a fast approximation to the Cook-Torrance Specular BRDF.\n  It is the fraction of light that reflects from a material to the viewer.\n  see Hoffmann 2015 for a gentle introduction to the concept\n*/\nvec3 get_fraction_of_light_reflected_from_material(\n    in float NL, in float NH, in float NV, in float HV,\n    in float root_mean_slope_squared,\n    in vec3 characteristic_reflectance\n){\n    float m = root_mean_slope_squared;\n    vec3 F0 = characteristic_reflectance;\n    return 1.0\n        * get_fraction_of_microfacets_accessible_to_ray(NL, m)\n        * get_fraction_of_microfacets_with_angle(NH, m)\n        * get_fraction_of_microfacets_accessible_to_ray(NV, m)\n        * get_rgb_fraction_of_light_reflected_from_facet(HV, F0)\n        / max(4.*PI*NV*NL, 0.001);\n}\n/*\n\"GAMMA\" is the constant that's used to map between \nrgb signals sent to a monitor and their actual intensity\n*/\nconst float GAMMA = 2.2;\n/* \nThis function returns a rgb vector that quickly approximates a spectral \"bump\".\nAdapted from GPU Gems and Alan Zucconi\nfrom https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\n*/\nvec3 get_rgb_intensity_of_rgb_signal(\n    in vec3 signal\n){\n    return vec3(\n        pow(signal.x, GAMMA),\n        pow(signal.y, GAMMA),\n        pow(signal.z, GAMMA)\n    );\n}\n/*\nThis function returns a rgb vector that best represents color at a given wavelength\nIt is from Alan Zucconi: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\nI've adapted the function so that coefficients are expressed in meters.\n*/\nvec3 get_rgb_signal_of_rgb_intensity(\n    in vec3 intensity\n){\n    return vec3(\n        pow(intensity.x, 1./GAMMA),\n        pow(intensity.y, 1./GAMMA),\n        pow(intensity.z, 1./GAMMA)\n    );\n}\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\nmat4 get_translation_matrix(vec3 offset)\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                offset,1);\n}\n// \"approx_air_column_density_ratio_through_atmosphere\" \n//   calculates the distance you would need to travel \n//   along the surface to encounter the same number of particles in the column. \n// It does this by finding an integral using integration by substitution, \n//   then tweaking that integral to prevent division by 0. \n// All distances are recorded in scale heights.\n// \"a\" and \"b\" are distances along the ray from closest approach.\n//   The ray is fired in the positive direction.\n//   If there is no intersection with the planet, \n//   a and b are distances from the closest approach to the upper bound.\n// \"z2\" is the closest distance from the ray to the center of the world, squared.\n// \"r0\" is the radius of the world.\nfloat approx_air_column_density_ratio_through_atmosphere(\n    in float a,\n    in float b,\n    in float z2,\n    in float r0\n){\n    // GUIDE TO VARIABLE NAMES:\n    //  \"x*\" distance along the ray from closest approach\n    //  \"z*\" distance from the center of the world at closest approach\n    //  \"r*\" distance (\"radius\") from the center of the world\n    //  \"*0\" variable at reference point\n    //  \"*2\" the square of a variable\n    //  \"ch\" a nudge we give to prevent division by zero, analogous to the Chapman function\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    const float k = 0.6; // \"k\" is an empirically derived constant\n    float x0 = sqrt(max(r0*r0 - z2, SMALL));\n    // if obstructed by the world, approximate answer by using a ludicrously large number\n    if (a < x0 && -x0 < b && z2 < r0*r0) { return BIG; }\n    float abs_a  = abs(a);\n    float abs_b  = abs(b);\n    float z      = sqrt(z2);\n    float sqrt_z = sqrt(z);\n    float ra     = sqrt(a*a+z2);\n    float rb     = sqrt(b*b+z2);\n    float ch0    = (1. - 1./(2.*r0)) * SQRT_HALF_PI * sqrt_z + k*x0;\n    float cha    = (1. - 1./(2.*ra)) * SQRT_HALF_PI * sqrt_z + k*abs_a;\n    float chb    = (1. - 1./(2.*rb)) * SQRT_HALF_PI * sqrt_z + k*abs_b;\n    float s0     = min(exp(r0- z),1.) / (x0/r0 + 1./ch0);\n    float sa     = exp(r0-ra) / max(abs_a/ra + 1./cha, 0.01);\n    float sb     = exp(r0-rb) / max(abs_b/rb + 1./chb, 0.01);\n    return max( sign(b)*(s0-sb) - sign(a)*(s0-sa), 0.0 );\n}\n\nvec3 get_rgb_fraction_of_light_transmitted_through_atmosphere(\n    in vec3 view_origin, in vec3 view_direction, in float view_start_length, in float view_stop_length,\n    in vec3 world_position, in float world_radius, in float atmosphere_scale_height,\n    in vec3 beta_ray, in vec3 beta_mie, in vec3 beta_abs\n){\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float v0 = dot(V0,V);\n    float v1 = dot(V1,V);\n    float zv2 = dot(V0,V0) - v0*v0;\n    vec3 beta_sum = (beta_ray + beta_mie + beta_abs)*h;\n    float sigma = approx_air_column_density_ratio_through_atmosphere(v0,v1,zv2,r);\n    return exp(-sigma * beta_sum);\n}\n\n#ifndef PROD\n#define ASSERT(test, color) if (!(test)) { return color; }\n#else\n#define ASSERT(test, color)\n#endif\n\n// TODO: multiple scattering events\n// TODO: support for light sources from within atmosphere\nvec3 get_rgb_fraction_of_distant_light_scattered_by_atmosphere(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length,\n    vec3 world_position, float world_radius,\n    vec3 light_direction, float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // For an excellent introduction to what we're try to do here, see Alan Zucconi: \n    //   https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-3/\n    // We will be using most of the same terminology and variable names.\n    // GUIDE TO VARIABLE NAMES:\n    //  Uppercase letters indicate vectors.\n    //  Lowercase letters indicate scalars.\n    //  Going for terseness because I tried longhand names and trust me, you can't read them.\n    //  \"*v*\"    property of the view ray, the ray cast from the viewer to the object being viewed\n    //  \"*l*\"    property of the light ray, the ray cast from the object to the light source\n    //  \"y*\"     distance from the center of the world to the plane shared by view and light ray\n    //  \"z*\"     distance from the center of the world to along the plane shared by the view and light ray \n    //  \"r*\"     a distance (\"radius\") from the center of the world\n    //  \"h*\"     the atmospheric scale height, the distance at which air density reduces by a factor of e\n    //  \"*2\"     the square of a variable\n    //  \"*0\"     property at the start of the raymarch\n    //  \"*1\"     property at the end of the raymarch\n    //  \"*i\"     property during an iteration of the raymarch\n    //  \"d*\"     the change in a property across iterations of the raymarch\n    //  \"beta*\"  a scattering coefficient, the number of e-foldings in light intensity per unit distance\n    //  \"gamma*\" a phase factor, the fraction of light that's scattered in a certain direction\n    //  \"sigma*\" a column density ratio, the density of a column of air relative to surface density\n    //  \"F*\"     fraction of source light that reaches the viewer due to scattering for each color channel\n    //  \"*_ray\"  property of rayleigh scattering\n    //  \"*_mie\"  property of mie scattering\n    //  \"*_abs\"  property of absorption\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float v0 = dot(V0,V);\n    float v1 = dot(V1,V);\n    vec3 L = light_direction; // unit vector pointing to light source\n    float VL = dot(V,L);\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3 beta_sum = h*(beta_ray + beta_mie + beta_abs);\n    vec3 beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    // number of iterations within the raymarch\n    const float STEP_COUNT = 6.;\n    float dv = (v1 - v0) / STEP_COUNT;\n    float vi = v0;\n    float dl = dv*VL;\n    float li = dot(V0,L);\n    float y  = dot(V0,normalize(cross(V,L)));\n    float y2 = y*y;\n    float zv2 = dot(V0,V0) - y2 - v0*v0;\n    float zl2 = 0.0;\n    float sigma; // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3 F = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        zl2 = vi*vi + zv2 - li*li;\n        sigma = approx_air_column_density_ratio_through_atmosphere(v0, vi, y2+zv2, r )\n              + approx_air_column_density_ratio_through_atmosphere(li, 3.*r, y2+zl2, r );\n        F += exp(r-sqrt(vi*vi+y2+zv2) - beta_sum*sigma) * beta_gamma * dv;\n            // NOTE: the above is equivalent to the incoming fraction multiplied by the outgoing fraction:\n            // incoming fraction: the fraction of light that scatters towards camera\n            //   exp(r-sqrt(vi*vi+y2+zv2)) * beta_gamma * dv\n            // outgoing fraction: the fraction of light that scatters away from camera\n            // * exp(-beta_sum * sigma);\n        vi += dv;\n        li += dl;\n    }\n    return F;\n}\n\n/*\n\"approx_fast_column_density_ratio_through_ring_system\" \n  calculates the distance you would need to travel \n  along the center of a ring system to encounter the same number of particles \n  in the specified column. \nIt does this by assuming a Gaussian density distribution \n when travelling in the direction that's perpendicular to the ring.\nAll distances are recorded in scale heights.\n\"a\" and \"b\" are distances along the ray from closest approach.\n  The ray is fired in the positive direction.\n\"m\"  is the \"slope\", the distance travelled parallel to the ring\n  per unit traveled perpendicular to the ring.\n*/\nfloat approx_fast_column_density_ratio_through_ring_system(\n    in float a,\n    in float b,\n    in float m\n){\n    return m*sqrt(PI)*(erf(b) - erf(a));\n}\nvec3 get_rgb_fraction_of_light_transmitted_through_ring_system(\n    in vec3 view_origin, in vec3 view_direction, in float view_start_length, in float view_stop_length,\n    vec3 ring_origin, vec3 ring_direction, float ring_scale_height, \n    in vec3 beta_ray, in vec3 beta_mie, in vec3 beta_abs\n){\n    float h   = ring_scale_height;\n    vec3  B0  = ring_origin/h;\n    vec3  B   = ring_direction;\n    vec3  D   = (view_direction * (view_stop_length - view_start_length)) / h; \n    vec3  V0  = (view_origin + view_direction * view_start_length - ring_origin) / h; \n    vec3  V1  = (view_origin + view_direction * view_stop_length  - ring_origin) / h;\n    vec3  V   = view_direction;   // unit vector pointing to viewer\n\n    float v02d = dot(V0,B);\n    float v12d = dot(V1,B);\n    float mv  = sqrt(1.-dot(V,B)*dot(V,B));\n    vec3  beta_sum   = h*(beta_ray + beta_mie + beta_abs);\n    float sigma = approx_fast_column_density_ratio_through_ring_system(v02d, v12d,  mv);\n    return exp(-sigma * beta_sum);\n}\n\nvec3 get_rgb_fraction_of_distant_light_scattered_by_ring_system(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length,\n    vec3 ring_origin, vec3 ring_direction, float ring_scale_height,\n    vec3 light_direction, vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h   = ring_scale_height;\n    vec3  B0  = ring_origin/h;\n    vec3  B   = ring_direction;\n    vec3  L   = light_direction;  // unit vector pointing to light source\n    vec3  D   = (view_direction * (view_stop_length - view_start_length)) / h; \n    vec3  V0  = (view_origin + view_direction * view_start_length - ring_origin) / h; \n    vec3  V1  = (view_origin + view_direction * view_stop_length  - ring_origin) / h;\n    vec3  V   = view_direction;   // unit vector pointing to viewer\n    float VL  = dot(V,L);\n\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3  beta_sum   = h*(beta_ray + beta_mie + beta_abs);\n    vec3  beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    \n    // number of iterations within the raymarch\n    const float STEP_COUNT = 8.; \n    float dv  = length(V1-V0) / STEP_COUNT;\n    float vi  = 0.;\n    float dl  = dv*VL;\n\n    float v02d = dot(V0,B);\n    float v12d = dot(V1,B);\n    float mv   = sqrt(1.-dot(V,B)*dot(V,B));\n    float ml   = sqrt(1.-dot(L,B)*dot(L,B));  \n    float sigma;       // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3  F = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vec3  Vi   = V0+V*vi; \n        \n        float vi2d = dot(Vi,B);\n        float li2d = dot(Vi,B*sign(dot(B,L)));\n        \n        ///*\n        sigma =  approx_fast_column_density_ratio_through_ring_system(v02d, vi2d,  mv)\n               + approx_fast_column_density_ratio_through_ring_system(li2d, 1e10, ml);\n        //*/\n        /*\n        sigma =  solve_air_column_density_ratio_through_ring_system(v02d, vi2d,  mv)\n               + solve_air_column_density_ratio_through_ring_system(li2d, 3.*ri, ml);\n        */\n        F +=\n            // incoming fraction: the fraction of light that scatters towards camera\n              exp(-vi2d*vi2d) * beta_gamma * dv\n            // outgoing fraction: the fraction of light that scatters away from camera\n            * exp(-beta_sum * sigma);\n\n        vi += dv;\n        //li += dl;\n    }\n\n    return F;\n}\nvec3 get_rgb_fraction_of_light_transmitted_through_scene(vec3 L0, vec3 L)\n{\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = 6e6; // arbitrary reference units, used to scale down the scene to work within precision limitations\n\n    // world\n    vec3  B0  = vec3(0,0,0)/u;// center of the world\n    float hB  = 8000.0/u;     // scale height of the world\n    float rB0 = 6e6/u;        // surface of the world\n    float rB1 = rB0+10.0*hB;  // \"top\" of the atmosphere\n    \n    // rings\n    vec3  C   = vec3(0,1,0); // direction of the rings\n    float rCi =   8e6 /u;    // inner radius of the rings\n    float rCo = 1.5e7 /u;    // outer radius of the rings\n    float hC  =  10.0 /u;    // scale height of the rings (assuming Gaussian density distribution)\n    float hC1 =  10.0*hC;    // half the total \"width\" of the rings\n\n    vec2 mouse = vec2(iMouse.xy) / vec2(iResolution.xy);\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,\n                                            0,0.3,0,0,\n                                            0,0,0,-50,\n                                            0,0,-1,50));\n    \n    bool IS_FIRST_PERSON_POV = false;\n    mat4  view_matrix_inverse;\n    if(IS_FIRST_PERSON_POV){\n        vec3 position = normalize(vec3(-5,1,0))*rB0*1.001;\n        vec3 up    = normalize(position);\n        vec3 right = vec3(0,1,0);\n        vec3 front = normalize(cross(up, right));\n        view_matrix_inverse = \n            get_translation_matrix(-position) *\n            get_rotation_matrix(up, -3.0*PI*mouse.x) * \n            get_rotation_matrix(right, PI/2.0-PI*mouse.y) * \n            inverse(mat4(vec4(right,0), vec4(up,0), vec4(front,0), vec4(0,0,0,1)));\n    } else {\n        view_matrix_inverse = \n            get_rotation_matrix(vec3(0,1,0), 6.3*mouse.x) * \n            get_rotation_matrix(vec3(1,0,0), PI/2.0+PI*(mouse.y)) *\n            get_translation_matrix(vec3(0,0,6.0*rB0)) *\n            mat4(1);\n    }\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz;\n\n    vec3  I =   solve_rgb_intensity_of_light_emitted_by_black_body(SOLAR_TEMPERATURE) \n              * get_surface_area_of_sphere(SOLAR_RADIUS) / get_surface_area_of_sphere(ASTRONOMICAL_UNIT); // intensity of incoming light for each color channel\n    vec3  E = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    \n\n    // view ray\n    vec3 V0 = view_origin;\n    vec3 V  = view_direction;\n    vec3 Vi = V0;            // point along view ray\n    \n    // light ray\n    // static\n    //vec3 L  = normalize(vec3(1,0,0)); \n    // daylight hours only\n    vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*PI*sin(0.1*iTime)) * vec4(normalize(vec3(3,1,0)),1)).xyz;\n    // realistic\n    //vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*iTime) * vec4(1,0,0,1)).xyz;\n\n    // \"beta_*\" is the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio\n    vec3  beta_ray_air   = vec3(5.20e-6, 1.21e-5, 2.96e-5) * u;\n    vec3  beta_mie_air   = vec3(1e-6)*u;\n    vec3  beta_abs_air   = vec3(0)*u;\n    vec3  beta_ray_ring  = vec3(0)*u;\n    vec3  beta_mie_ring  = vec3(1e-2)*u;\n    vec3  beta_abs_ring  = vec3(1,1,2)*1e-2*u;\n\n    maybe_vec2 world_along_view_ray = \n        get_bounding_distances_along_ray(\n            get_distances_along_3d_line_to_sphere(V0, V, B0, rB0)\n        );\n        \n    maybe_float world_ahead_on_view_ray = \n        get_nearest_distance_along_ray(\n            world_along_view_ray\n        );\n        \n    maybe_vec2  air_along_view_ray  = \n        get_bounding_distances_along_ray(\n            get_distances_along_line_to_negation(\n                get_distances_along_3d_line_to_sphere(V0, V, B0, rB1),\n                world_along_view_ray\n            )\n        );\n        \n    maybe_vec2 rings_along_view_ray = \n        get_bounding_distances_along_ray(\n            get_distances_along_line_to_negation(\n                get_distances_along_3d_line_to_cylinder(V0, V, B0-hC1*C, B0+hC1*C, rCo),\n                 get_distances_along_3d_line_to_cylinder(V0, V, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n            )\n        );\n    \n    if(!air_along_view_ray.exists && !world_along_view_ray.exists && !rings_along_view_ray.exists) \n    { \n        // nothing to see here folks, move along\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    if(world_ahead_on_view_ray.exists){\n        vec3 Vt = V0+V*(world_ahead_on_view_ray.value-0.001);\n        maybe_vec2 air_along_light_ray = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_sphere(Vt, L, B0, rB1),\n                    get_distances_along_3d_line_to_sphere(Vt, L, B0, rB0)\n                )\n            );\n        maybe_vec2 rings_along_light_ray = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_cylinder(Vt, L, B0-hC1*C, B0+hC1*C, rCo),\n                    get_distances_along_3d_line_to_cylinder(Vt, L, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n                )\n            );\n        maybe_vec2 world_along_light_ray = \n            get_bounding_distances_along_ray(\n                get_distances_along_3d_line_to_sphere(Vt, L, B0, rB0)\n            );\n        \n        vec3 I_surface = I;\n        if (air_along_light_ray.exists)\n        {\n            I_surface *= get_rgb_fraction_of_light_transmitted_through_atmosphere(Vt,L, air_along_light_ray.value.x, air_along_light_ray.value.y, B0, rB0, hB, beta_ray_air, beta_mie_air, beta_abs_air);\n        }\n        if (rings_along_light_ray.exists)\n        {\n            I_surface *= get_rgb_fraction_of_light_transmitted_through_ring_system(Vt,L, rings_along_light_ray.value.x, rings_along_light_ray.value.y, B0, C, hC, beta_ray_ring, beta_mie_ring, beta_abs_ring);\n        }\n        \n        vec3 N = get_surface_normal_of_point_near_sphere(Vt, B0);\n        vec3 H = normalize(L-V);\n        float NV = max(dot(N,-V), 0.);\n        float NL = max(dot(N, L), 0.);\n        float NH = max(dot(N, H), 0.);\n        float HV = max(dot(H,-V), 0.);\n        float VL = max(dot(L,-V), 0.);\n        vec3 E_surface_ambient = vec3(1,1,1)/255.; // surface ambient light\n        vec3 F_surface_diffuse = vec3(0.4,0.4,0.3); // diffuse surface color\n        \n        E += E_surface_ambient;\n        if (NL > 0.) //!world_along_light_ray.exists \n        {\n            const vec3 F0  = vec3(0.04); // NOTE: \"0.04\" is a representative value for plastics and other diffuse reflectors\n            const float m = 3.0;\n            vec3 F_reflected = get_fraction_of_light_reflected_from_material(NL,NH,NV, HV, m,F0);\n            vec3 E_surface_reflected = I_surface * NL * F_reflected;\n            vec3 I_surface_refracted = I_surface * NL * (1. - F_reflected);\n            vec3 E_surface_refracted = I_surface_refracted * F_surface_diffuse;\n            E += E_surface_reflected + E_surface_refracted;\n        }\n    }\n    if(air_along_view_ray.exists && (air_along_view_ray.value.x < world_ahead_on_view_ray.value || !world_ahead_on_view_ray.exists))\n    {\n        vec3 Vt0 = V0+V*(air_along_view_ray.value.x);\n        vec3 Vt1 = V0+V*(air_along_view_ray.value.y);\n        maybe_vec2 rings_along_light_ray0 = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_cylinder(Vt0, L, B0-hC1*C, B0+hC1*C, rCo),\n                    get_distances_along_3d_line_to_cylinder(Vt0, L, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n                )\n            );\n        maybe_vec2 rings_along_light_ray1 = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_cylinder(Vt1, L, B0-hC1*C, B0+hC1*C, rCo),\n                    get_distances_along_3d_line_to_cylinder(Vt1, L, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n                )\n            );\n        vec3 I_entrance = I;\n        if (rings_along_light_ray0.exists || rings_along_light_ray1.exists)\n        {\n            vec3 F0 = !rings_along_light_ray0.exists? vec3(0.0) : get_rgb_fraction_of_light_transmitted_through_ring_system(Vt0,L, rings_along_light_ray0.value.x, rings_along_light_ray0.value.y, B0, C, hC, beta_ray_ring, beta_mie_ring, beta_abs_ring);\n            vec3 F1 = !rings_along_light_ray1.exists? vec3(0.0) : get_rgb_fraction_of_light_transmitted_through_ring_system(Vt1,L, rings_along_light_ray1.value.x, rings_along_light_ray1.value.y, B0, C, hC, beta_ray_ring, beta_mie_ring, beta_abs_ring);\n            \n            I_entrance *= (F0+F1)/2.;\n        }\n        \n        \n        float v0 = air_along_view_ray.value.x;\n        float v1 = air_along_view_ray.value.y;\n        E *= get_rgb_fraction_of_light_transmitted_through_atmosphere(V0,V, air_along_view_ray.value.x,  air_along_view_ray.value.y,  B0, rB0*0.999, hB, beta_ray_air, beta_mie_air, beta_abs_air);\n        E += I_entrance * get_rgb_fraction_of_distant_light_scattered_by_atmosphere(\n            V0, V, v0, v1, \n            B0, rB0, L, hB, \n            beta_ray_air, beta_mie_air, beta_abs_air\n        );\n        \n    }\n    \n    if(rings_along_view_ray.exists && (rings_along_view_ray.value.x < world_ahead_on_view_ray.value || !world_ahead_on_view_ray.exists))\n    {\n        vec3 Vt = V0+V*(rings_along_view_ray.value.x);\n        float v0 = rings_along_view_ray.value.x;\n        float v1 = rings_along_view_ray.value.y;\n        \n        float F_occluded = get_fraction_of_sphere_not_occluded_by_sphere(\n            Vt, L*ASTRONOMICAL_UNIT/u, SOLAR_RADIUS/u, B0, rB0\n        );\n        E += I * F_occluded *get_rgb_fraction_of_distant_light_scattered_by_ring_system(\n            V0, V, v0, v1, \n            B0, C, hC, \n            L, beta_ray_ring, beta_mie_ring, beta_abs_ring\n        );\n    }\n    \n    //fragColor = world_along_view_ray.exists? vec4(vec3(1),1) : vec4(vec3(0),1);\n    float exposure_intensity = 40.; // Watts/m^2\n    vec3  ldr_tone_map = 1.0 - exp(-E/exposure_intensity);\n\n    fragColor = vec4(get_rgb_signal_of_rgb_intensity(ldr_tone_map), 1);\n    //if((E.x==0.)){fragColor.x = 1.0;} else {fragColor.x=0.0;}\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[436, 572, 592, 592, 628], [629, 755, 809, 809, 836], [837, 837, 886, 886, 917], [918, 918, 1016, 1016, 1106], [1107, 1107, 1200, 1247, 1374], [1375, 1375, 1432, 1432, 1466], [1467, 1467, 1518, 1518, 1562], [1563, 1563, 1688, 1748, 2007], [2008, 2008, 2127, 2218, 2300], [2301, 2399, 2463, 2463, 2495], [2496, 2585, 2650, 2650, 2688], [2689, 2780, 2859, 2859, 2912], [2913, 3110, 3189, 3189, 3222], [3223, 3310, 3388, 3566, 3881], [3882, 3980, 4044, 4044, 4076], [4077, 4131, 4197, 4197, 4235], [4236, 4327, 4406, 4406, 4459], [4460, 4520, 4600, 4600, 4633], [4634, 4742, 4835, 4931, 5242], [5243, 5294, 5372, 5372, 5404], [5405, 5462, 5542, 5542, 5621], [5622, 5711, 5792, 5792, 5888], [5889, 6086, 6179, 6179, 6207], [6208, 6306, 6384, 6384, 6416], [6417, 6508, 6590, 6590, 6694], [6695, 6755, 6849, 6849, 6877], [7586, 7586, 7666, 7666, 7999], [8000, 8000, 8079, 8079, 8452], [8453, 8453, 8555, 8555, 8732], [8733, 8733, 8833, 8833, 9142], [9144, 9144, 9251, 10528, 11177], [11179, 11179, 11286, 11286, 11544], [11545, 11545, 11644, 11644, 11674], [11675, 11777, 11888, 11888, 12089], [12090, 12187, 12297, 12398, 12687], [12688, 12796, 12916, 13027, 13372], [13373, 13373, 13487, 13487, 13696], [13697, 13793, 13925, 13925, 14384], [14385, 14385, 14484, 14484, 14514], [14515, 14617, 14736, 14736, 15003], [15004, 15101, 15219, 15219, 15508], [15509, 15617, 15745, 15745, 16090], [16091, 16200, 16312, 16312, 16393], [16394, 16519, 16648, 16683, 16837], [16838, 16955, 17087, 17155, 17704], [17705, 17820, 17934, 17934, 18146], [18147, 18268, 18384, 18526, 18799], [18800, 18938, 19089, 19089, 19622], [19623, 19752, 19892, 20203, 20519], [20520, 20639, 20771, 20771, 21504], [21505, 21621, 21752, 21752, 22172], [22173, 22307, 22453, 22453, 22712], [22713, 22843, 22982, 22982, 23682], [23683, 23812, 23955, 23955, 24286], [24287, 24431, 24584, 24584, 25426], [25428, 25497, 25572, 25572, 25619], [25620, 25671, 25743, 25743, 25776], [25777, 25868, 25954, 25954, 26007], [26008, 26088, 26182, 26246, 26309], [26310, 26380, 26466, 26466, 26611], [26614, 26614, 26714, 26714, 26943], [26944, 26944, 27087, 27209, 27703], [27704, 27819, 27995, 27995, 29376], [31498, 31674, 31796, 31796, 32327], [32328, 32328, 32462, 32462, 32650], [32651, 32774, 32853, 32853, 32931], [32932, 32932, 33016, 33016, 33480], [33481, 33523, 33623, 33623, 33745], [33746, 33934, 34029, 34029, 34200], [34201, 34334, 34437, 34437, 34661], [34662, 34874, 34995, 34995, 35220], [35221, 35567, 35689, 35689, 35930], [35931, 36257, 36384, 36384, 36543], [36544, 37072, 37199, 37199, 37335], [37336, 37586, 37773, 37773, 38153], [38294, 38487, 38546, 38546, 38661], [38662, 38911, 38973, 38973, 39106], [39107, 39107, 39157, 39157, 39651], [39652, 39652, 39694, 39694, 39798], [39799, 40532, 40657, 41051, 41986], [41988, 41988, 42299, 42299, 42882], [42998, 43092, 43400, 45380, 48127], [48129, 48742, 48851, 48851, 48894], [48895, 48895, 49191, 49191, 49896], [49898, 49898, 50195, 50329, 53279], [53280, 53280, 53355, 53355, 53377], [53380, 53380, 53437, 53437, 63901]], "test": "error"}
{"id": "tdscWj", "name": "36 Days Of Type - I", "author": "nicolasdnl", "description": "36 Days Of Type - I", "tags": ["letter"], "likes": 2, "viewed": 59, "published": "Public", "date": "1585671792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[4], float kPath[10] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p, float t )\n{\n    float height = 1. + sin(t*PI*2.)*0.2;\n    float width = .8 + cos(t*PI*2.)*0.1;\n    float strokeWidth = 0.25 + cos(t*PI*2.)*0.1;\n    \n   \tint kType[] = int[](0,0,0,0);\n\tfloat kPath[] = float[]( -strokeWidth*0.5, height*0.5,\n                             -strokeWidth*0.5,-height*0.5,\n                              strokeWidth*0.5,-height*0.5,\n                              strokeWidth*0.5, height*0.5,\n                             -strokeWidth*0.5, height*0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    float t = mod(iTime * 0.25, 1.);\n    \n    \n    vec3 col = vec3(1.,1.,1.);\n    for (int i=0; i<25; i++) {\n        //float d = sdA(p, t+float(i)*0.08);\n        float d = sdA(p+vec2(float(15-i)*0.004), t+float(i)*0.005);\n    \tcol = float(i)*0.003+generateBorder(col, abs(d));\n    }\n    col = 1. - col;\n    \n    //col = vec3(sign(d));\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdscWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1633, 1633, 2398], [2938, 2938, 2989, 2989, 3074], [3077, 3077, 3134, 3170, 3615]], "test": "error"}
{"id": "tdscz4", "name": "animation_PM", "author": "KofeyOK", "description": "wave PM", "tags": ["animated"], "likes": 2, "viewed": 203, "published": "Public API", "date": "1584315674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) { //функція для створення кола\n float d = length(uv-p);\n float c = smoothstep(r, r-blur, d);\n\n return c;\n}\nfloat Band (float t, float start, float end, float blur) //функція для створення смужки\n{\nfloat step1 = smoothstep(start-blur, start+blur, t);\n float step2 = smoothstep(end+blur, end-blur, t);\n\n return step1*step2;\n}\nfloat Rect (vec2 uv, float left, float right, float //функція для створення прямокутника\nbottom, float top, float blur) {\nfloat band1 = Band(uv.x, left, right, blur);\nfloat band2 = Band(uv.y, bottom, top, blur);\n\nreturn band1*band2;\n}\nfloat smiley (vec2 uv, vec2 p, float size){ //функція для створення смайла :)\nuv -= p; //translating coordinate systems\n uv /= size; //scaling coordinate systems\n\n float mask = Circle (uv, vec2(.0), .4, .01);\n\n mask -= Circle (uv, vec2(-.13, .2), .07, .01);\n mask -= Circle (uv, vec2(.13, .2), .07, .01);\n\nfloat mouth = Circle (uv, vec2(.0, .0), .3, .02);\n mouth -= Circle (uv, vec2(.0, 0.1), .3, .02);\n\n mask -= mouth;\n\n return mask;\n }\nfloat remap01 (float a, float b, float t){ //нормалізує значення t; 0<=t<=1\n return (t-a) / (b-a);\n}\nfloat remap (float a, float b, float c, float d, float // c<=t<=d\nt){\n return remap01 (a, b, t) * (d-c) + c;\n}\nfloat PIlike(vec2 uv, vec2 p, float size){\n uv -= p; //translating coordinate systems\n uv /= size; //scaling coordinate systems\n float x1 = uv.x;\n\n float m = sin(+x1*8.) *.1; // змінюється з часом і зростанням х\n \n m = m*m*4.;\n float y1 = uv.y-m; // -m перетворює прямокутник на синусоїду, яка змінюється з часом\n \n float y2 = uv.y;\n float m2 = sin(+y2*8.) *.1;\n float x2  = uv.x-m2;\n //float m = (x-.5)*(x+.5);  // цей блок коду змінює вигляд фігури\n \n //float y = uv.y+m; \n\n //x+= y;  // нахил фігури\n\n float blur = remap(-.1, .1, .01, .05, y1); // збільшує розмиття зі зростанням х\n //blur *= pow(blur*4., 3.);\n float mask = Rect (vec2(x1, y1), -.5, .5, .1, .3, blur); //будуємо фігуру\n mask += Rect (vec2(x2, y2), -.5, -.3, -0.2, 0.16, .04);\n mask += Rect (vec2(x2, y2), 0., 0.2, -0.2, 0.16, .04);\n float wheel = Circle(uv, vec2(0.,-0.2), 0.16, .07);\n mask+=wheel;\n    \n return mask;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1.\n\n    float t = iTime; // час\n    uv -= .5; // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n\tfloat m = sin(t+uv.x*8.) *.1; // змінюється з часом і зростанням х\n \tuv.y -=m;\n    vec3 col = vec3(0.);\n\n    float mask = 0.;\n\tmask = Rect(uv, -.7, -.55, -.3, .3, .001);\n    mask += Rect(uv, -.3, -0.15, -.3, .3, .001);\n    mask += Rect(uv, -.7, -0.15, .15, .3, .001);\n    mask += Rect(uv, .1, 0.2, -.3, .3, .001);\n    mask += Rect(uv, .55, 0.65, -.3, .3, .001);\n    mask += Rect(vec2(uv.x+uv.y*0.23,uv.y), 0.225, 0.325, -.3, .3, .003);\n    mask += Rect(vec2(uv.x-uv.y*0.23,uv.y), 0.425, 0.525, -.3, .3, .003);\n    //mask = PIlike(uv, vec2(0.),1.);\n    col = vec3(1., 1., 1.)*mask;\n\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdscz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 104, 180], [181, 181, 295, 295, 422], [423, 423, 575, 575, 688], [689, 689, 732, 791, 1151], [1152, 1152, 1194, 1245, 1270], [1271, 1271, 1340, 1340, 1381], [1382, 1382, 1424, 1424, 2432], [2434, 2434, 2489, 2489, 3297]], "test": "ok"}
{"id": "tdsyR8", "name": "cs180 Dream Team Final Project", "author": "mopo4546", "description": "first shader for final project", "tags": ["first"], "likes": 1, "viewed": 75, "published": "Public", "date": "1584218128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\nfloat fbm(vec2 x) {\n\tfloat t = 0.0;\n    float c = 2.0;\n    for( int i=0; i<10; i++ )\n    {\n        float f = pow( 2.0, float(i)/iTime );\n        t += noise(f*x)/c;\n    \tc *= 2.0;\n    }\n    return t;\n}\nfloat circle(vec2 pos) {\n\treturn length(pos) - 1.0;\n}\nfloat getcircle(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\nfloat Circle(vec2 uv,vec2 pos, float r, float blur){\n    float d= length(uv-pos);\n float c=smoothstep(r, r-blur,d);\n    return c;\n}\nfloat band(float t , float start,float end ,float blur){\n float st1= smoothstep(start-blur, start+ blur,t);\n    float st2 = smoothstep(end+blur, end-blur, t);\n    return st1*st2;\n} \nfloat Rectangle(vec2 uv, float left, float right, float bot, float top, float blur){\n    float b1= band(uv.x, left,right, blur);\n    float b2= band(uv.y, bot, \ttop,   blur);\n    return b1*b2;\n}\nfloat Smiley (vec2 uv ,vec2 pos , float size){\n    uv-=pos;\n    uv /=size;\n    float mask = Circle(uv, vec2(0), .4,0.01);\n     mask -= Circle(uv, vec2(.11,.1), .07,0.001);\n     mask -= Circle(uv, vec2(-.11,.1), .07,0.001);\n    float mouth = Circle(uv, vec2(0), .3,0.02);\n    mouth -= Circle(uv, vec2(0,.1), .3,0.02);\n    mask -= mouth;\n    return mask;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*.2;\n    //camera\n    vec3 ro = vec3(0,0,-1);\n    vec3 look = vec3(0);\n    float zoom = mix(.4, .9, sin(3.*t)*.5+.5) ;\n    vec3 f = normalize(look - ro),\n        r = normalize(cross(vec3(0,1,1), f)),\n        u = cross(f,r),\n        c = ro + f*zoom,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n    float dSurf, d0rigin;\n    vec3 pos;\n    for(int i = 0; i < 90; i++)\n    {\n        pos = ro + rd*d0rigin;\n        //pos *= sin(fbm(pos.xy));\n        dSurf = -(length(vec2(length(pos.xz) - 1., pos.y)) - .75);\n        if(dSurf < 0.001) break;\n        d0rigin += dSurf;\n    }\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    if(dSurf < .001){\n        float x = atan(pos.x,pos.z)+t*.5;\n        float y = atan(length(pos.xz) - 1., pos.y);\n        float bands =sin(y*10.+x*30.);\n        float ripples =sin((x*10.-y*30.)*3.)*.5+.5;\n        float waves =sin(x*2.*fbm(pos.xy)-y*6.*fbm(pos.xy)+t*20.);                      \n        float b1 = smoothstep(-.2,.2,bands);\n        float b2 = smoothstep(-.2,.2,bands-.5);\n        float m = b1*(1.-b2);\n        m = max(m, ripples*b2*max(0.,waves));\n        m+= max(0., waves*.3*b2);\n        float mask ;\n        float t = iTime;\n        vec2 p = vec2(.6*sin(.5*t),.2*cos(.5*t));\n        vec2 p1 = -p;\n        vec2 p2 = vec2(.9*sin(.5*t),.5*cos(.5*t));\n        vec2 p3 = -p2;\n        vec2 p4 = vec2(.4*sin(.5*t),.1*cos(.5*t));\n        vec2 p5 = -p4;\n        vec2 p6 = vec2(.2*sin(.5*t),.7*cos(.5*t));\n        vec2 p7 = -p6;\n        vec2 p8 = vec2(.3*sin(.5*t),.4*cos(.5*t));\n        vec2 p9 = -p8;\n        vec2 p10 = vec2(.5*sin(.5*t),.5*cos(.5*t));\n        vec2 p11 = -p10;\n        vec2 p12 = vec2(.25*sin(t),.25*cos(t));\n        vec2 p13 = -p12;\n        mask-=Smiley(uv, p,.2);\n       \tmask-=Smiley(uv, p1,.2);\n        mask-=Smiley(uv, p2,.2);\n       \tmask-=Smiley(uv, p3,.2);\n         mask-=Smiley(uv, p4,.2);\n       \tmask-=Smiley(uv, p5,.2);\n         mask-=Smiley(uv, p6,.2);\n       \tmask-=Smiley(uv, p7,.2);\n         mask-=Smiley(uv, p8,.2);\n       \tmask-=Smiley(uv, p9,.2);\n         mask-=Smiley(uv, p10,.2);\n       \tmask-=Smiley(uv, p11,.2);\n         mask-=Smiley(uv, p12,.2);\n       \tmask-=Smiley(uv, p13,.2);\n        mask -= Rectangle(uv,-1.,1.,-1.,-.45,.009);\n  \tmask -= Rectangle(uv,.83,1.,-1.,1.,.009);\n    mask -= Rectangle(uv,-1.,1.,.45,1.,.009);\n    mask -= Rectangle(uv,-1.,-.83,-.5,.5,.009); \n                        col = vec3(0,1,0.)*mask;\n                        col = col+ mix(m, 1.-m, smoothstep(-.3, .3, sin(x*2.+t)));\n                    }\n    float scale = 500.;\n    float radius = 0.1;\n    float intensity = 1.0;\n    vec2 p = vec2(0.5,0.5);\n    float dist;\n    float glow;\n    float depth;\n    vec3 green = vec3(0.133, 0.62, 0.698);  \n    for(float i = 0.0; i <10.; i++){\n        depth = fract(i/10. +iTime*0.04);\t\n        p =  vec2(0.,0.)-uv ;\n    \tp *= mix(scale, 0.0, depth);\n       dist = abs(circle(p));  \n        float  mask = -Smiley(uv, p,2.);\n         col += vec3(0,1,0.)*mask;\n    \tglow = getcircle(dist, radius+(1.0-depth)*2.0, intensity + depth);\n     \tcol += glow * col;\n\t}\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 62], [63, 63, 89, 89, 307], [308, 308, 327, 327, 508], [509, 509, 533, 533, 562], [563, 563, 622, 622, 664], [665, 665, 717, 717, 796], [797, 797, 853, 853, 977], [979, 979, 1063, 1063, 1172], [1173, 1173, 1219, 1219, 1527], [1528, 1528, 1585, 1635, 4842]], "test": "timeout"}
{"id": "tdsyRf", "name": "chromaspiral", "author": "scry", "description": "it is what it is", "tags": ["2d"], "likes": 6, "viewed": 337, "published": "Public API", "date": "1585277108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime iTime*0.05\n\nvec2 rotate2d(vec2 uv, float a) {\n    uv -= 0.5;\n    uv *= mat2(sin(a),cos(a),-cos(a),sin(a));\n    uv += 0.5;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    float loop = 30.*0.1;\n    float it = abs(mod(iTime+loop,loop*2.)-loop);\n    float a = it*it*it*length(uv-0.5);\n    for (int i=0;i<6;i++) {\n        \n        float fi = float(i);\n        uv -= 0.5+fi*0.005;\n        uv += vec2(sin(iTime*3.+fi*15.),cos(iTime*2.+fi*15.))*cos(iTime*0.1);\n        uv += 0.5-fi*0.005;\n        uv = rotate2d(uv,-iTime+length(uv-0.5));\n    }\n    uv *= 0.5;\n    float sint = cos(iTime*1.5)*20.;\n    col.r += sin(uv.x*11.+sint)+sin(uv.y*90.);\n    uv += 0.1;\n    uv += iTime*0.01;\n    col.g += sin(uv.x*11.+sint)+sin(uv.y*99.);\n    uv += 0.1;\n    uv -= iTime*0.012;\n    col.b += sin(uv.x*11.+sint)+sin(uv.y*91.);\n    col = sin(col*1.4);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 59, 59, 152], [154, 154, 211, 211, 972]], "test": "error"}
{"id": "tdsyRM", "name": "cuarto-v10--v3--broma", "author": "jorge2017a1", "description": "cuarto-v10--v3--broma", "tags": ["cuartov10v3broma"], "likes": 3, "viewed": 55, "published": "Public", "date": "1584454186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    \n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n    \n    \n}\n\n\n\n\n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    \n    \n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n  \n    \n    //serpiente\n     \n         \n         vec3 pa = pp + vec3(\n            cos(p.z*1.5  )*0.5,\n            -6.0 + sin(p.z)*2.5,\n            5.1);\n        pa.y += pow(abs(p.z*0.03), 11.0);\n            \n    \n    \n   float sdwx= wallx(pa);\n   float sdwy= wally(p); \n   float sdwz= wallz(p);\n   \n    \n   res=opU(res, vec2(sdwx,1)); //pared izq y der\n   res=opU(res, vec2(sdwy,13));  //piso arriba y abajo\n   res=opU(res, vec2(sdwz,22));   //frente\n    \n   \n   float sdc1=  sdCylinder(p-vec3(12,-5.0,-28.), vec2(2.1,20.0) );\n   float sdc2=  sdCylinder(p-vec3(-12,-5.0,-28.), vec2(2.1,20.0) );\n    \n    \n    \n   //bloque arriba1-izq -centro\n   float sdb1Up0i= sdBox(p- vec3(-12.,13.0,-27.), vec3(4.0,1.0,1.5) ); \n   //bloque abajo1-izq \n   float sdb1Down0i= sdBox(p- vec3(-12.,-13.0,-27.), vec3(4.0,1.0,1.5) ); \n    \n    //bloque arriba1-der centro\n   float sdb1Up0d= sdBox(p- vec3(12.,13.0,-27.), vec3(4.0,1.0,1.5) ); \n   //bloque abajo1-izq -centro\n   float sdb1Down0d= sdBox(p- vec3(12.,-13.0,-27.), vec3(4.0,1.0,1.5) ); \n    \n\n   //bloque izq\n   res=opU(res, vec2(sdb1Up0i,24));\n   res=opU(res, vec2(sdb1Down0i,24));\n   //bloque der\n   res=opU(res, vec2(sdb1Up0d,24));\n   res=opU(res, vec2(sdb1Down0d,24));\n    \n    \n    \n    \n   res=opU(res, vec2(sdc1,21));\n   res=opU(res, vec2(sdc2,24));\n\n  \n    \n\tfloat sdb1= sdBox(p- vec3(1.,-10.0,-10.), vec3(3.0,3.0,3.0) );\n    //float sds1= sdSphere( p-vec3(0.0,-15.0,-2.0), 1.5 );\n    res=opU(res, vec2(sdb1,6));\n   // res=opU(res, vec2(sds1,24));\n    \n    \n    \n    \n    \n    \n    ///------------------primera columna inicio\n   //bloque arriba1-izq \n   float sdb1aUp= sdBox(p- vec3(-17.,13.0,-15.), vec3(4.0,1.0,1.5) ); \n    //bloque abajo1-izq \n   float sdb1aDown= sdBox(p- vec3(-17.,-13.0,-15.), vec3(4.0,1.0,1.5) ); \n    \n   \n    //bloque arriba1-der\n    float sdb1bUp= sdBox(p- vec3(17.,13.0,-15.), vec3(4.0,1.0,1.5) ); \n    //bloque abajo1-der \n   float sdb1bDown= sdBox(p- vec3(17.,-13.0,-15.), vec3(4.0,1.0,1.5) ); \n    \n    //cilindro izq\n   float sdc3a1=  sdCylinder(p-vec3(18,-5.0,-15.), vec2(1.1,20.0) );\n   float sdc3a2=  sdCylinder(p-vec3(15.0,-5.0,-15.), vec2(1.1,20.0) );\n   \n    \n    //cilindro der\n   float sdc3b1=  sdCylinder(p-vec3(-18,-5.0,-15.), vec2(1.1,20.0) );\n   float sdc3b2=  sdCylinder(p-vec3(-15,-5.0,-15.), vec2(1.1,20.0) );\n    \n   res=opU(res, vec2(sdc3a1,23));\n   res=opU(res, vec2(sdc3b1,23));\n    \n    //bloque izq\n   res=opU(res, vec2(sdb1aUp,24));\n   res=opU(res, vec2(sdb1aDown,24));\n\n    //bloque der\n   res=opU(res, vec2(sdb1bUp,24));\n   res=opU(res, vec2(sdb1bDown,24));\n    \n    \n   \n   res=opU(res, vec2(sdc3a2,21));\n   res=opU(res, vec2(sdc3b2,24));\n   ///------------------primera columna fin \n    \n    \n    \n    /*\n    \n    ///-----------------segunda columnas--inicio\n    //bloque arriba1-izq \n   float sdb1cUp= sdBox(p- vec3(-17.,13.0,-2.), vec3(4.0,1.0,1.5) ); \n    //bloque abajo1-izq \n   float sdb1cDown= sdBox(p- vec3(-17.,-13.0,-2.), vec3(4.0,1.0,1.5) ); \n    \n   \n    //bloque arriba1-der\n    float sdb1dUp= sdBox(p- vec3(17.,13.0,-2.), vec3(4.0,1.0,1.5) ); \n    //bloque abajo1-der \n   float sdb1dDown= sdBox(p- vec3(17.,-13.0,-2.), vec3(4.0,1.0,1.5) ); \n    \n    //cilindro izq\n   float sdc3c1=  sdCylinder(p-vec3(18,-5.0,-2.), vec2(1.1,20.0) );\n   float sdc3c2=  sdCylinder(p-vec3(15.0,-5.0,-2.), vec2(1.1,20.0) );\n   \n    \n    //cilindro der\n   float sdc3d1=  sdCylinder(p-vec3(-18,-5.0,-2.), vec2(1.1,20.0) );\n   float sdc3d2=  sdCylinder(p-vec3(-15,-5.0,-2.), vec2(1.1,20.0) );\n    \n   res=opU(res, vec2(sdc3c1,23));\n   res=opU(res, vec2(sdc3d1,23));\n    \n    //bloque izq\n   res=opU(res, vec2(sdb1cUp,24));\n   res=opU(res, vec2(sdb1cDown,24));\n\n    //bloque der\n   res=opU(res, vec2(sdb1dUp,24));\n   res=opU(res, vec2(sdb1dDown,24));\n    \n    \n   \n   res=opU(res, vec2(sdc3c2,21));\n   res=opU(res, vec2(sdc3d2,24));\n    \n    */\n    ///-----------------segunda columna fin\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        \n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n\t}        \n    \t\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n  \n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t//vec3 surfaceColor3 = vec3(0.45,0.54,1.0);  \n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    \n  for(int  i = 0; i < 3; i++)\n  {\n    //float nearest = RayMarch(p + dir*dist);\n    float nearest = RayMarch(ro, rd);  \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = ro+rd*dist;\n      \n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n    //ro=ro+rd*EPS;\n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    vec3 ro = vec3(-2.0+10.*cos(iTime) ,6.5,15.0+ 7.0*sin(iTime));\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t  vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    //float dif = GetLightv2(p);\n    float dif = GetLightPar(p,rLuz);\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n \t\n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n   \n    col= result*dif*1.1;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 474, 507, 507, 572], [573, 591, 627, 627, 696], [697, 712, 743, 743, 893], [894, 914, 950, 950, 1037], [1038, 1054, 1086, 1114, 1175], [1177, 1177, 1213, 1213, 1316], [1319, 1393, 1451, 1451, 1715], [1717, 1717, 1762, 1762, 1853], [1855, 1855, 1937, 1937, 2168], [2171, 2171, 2202, 2202, 2390], [2393, 2447, 2469, 2469, 3729], [3732, 3796, 3832, 3832, 4105], [4157, 4157, 4203, 4203, 4235], [4237, 4237, 4280, 4280, 4312], [4314, 4314, 4362, 4362, 4395], [4398, 4398, 4427, 4427, 4553], [4555, 4555, 4591, 4591, 4708], [4710, 4710, 4746, 4746, 4864], [4867, 4867, 4903, 4903, 5026], [5079, 5091, 5113, 5113, 5421], [5422, 5448, 5473, 5473, 5663], [5664, 5709, 5726, 5726, 5799], [5802, 5835, 5861, 5861, 6058], [6105, 6105, 6157, 6157, 6327], [6390, 6499, 6536, 6536, 6571], [6573, 6573, 6592, 6592, 6667], [6716, 6716, 6739, 6739, 6765], [6767, 6767, 6790, 6790, 6928], [6931, 6931, 6953, 6953, 7023], [7088, 7088, 7114, 7114, 7171], [7173, 7173, 7193, 7193, 7251], [7254, 7254, 7275, 7275, 7525], [7528, 7528, 7560, 7560, 7645], [7647, 7647, 7683, 7683, 7872], [7873, 7873, 7900, 7900, 8315], [8424, 8451, 8472, 8472, 8538], [8540, 8540, 8562, 8562, 8617], [8619, 8619, 8640, 8640, 8695], [8697, 8697, 8718, 8718, 8773], [8837, 8837, 8856, 8856, 8900], [8902, 8902, 8945, 8945, 10495], [10501, 10550, 10575, 10575, 14746], [14749, 14749, 14783, 14783, 15152], [15157, 15157, 15181, 15181, 15413], [15417, 15417, 15441, 15441, 15833], [15836, 15836, 15862, 15862, 16226], [16229, 16229, 16267, 16267, 16624], [16627, 16627, 16652, 16652, 16680], [16682, 16682, 16734, 16734, 17130], [17233, 17277, 17294, 17294, 17365], [17390, 17482, 17507, 17507, 17770], [17829, 17829, 17857, 17857, 24801], [24803, 24851, 24952, 24986, 25496], [25502, 25548, 25601, 25601, 26790], [26793, 26842, 26899, 26899, 28314]], "test": "error"}
{"id": "tdsyRn", "name": "hazy moon", "author": "tono", "description": "a night with a hazy moon.", "tags": ["raymarching"], "likes": 3, "viewed": 95, "published": "Public", "date": "1584031854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 20.\n#define AA 1\n\nfloat t,depth;\nvec3 cp = vec3(0.,-4.,-15.);\n\nvec2 rot(vec2 p,float a){return vec2(mat2( cos(a),sin(a),-sin(a),cos(a))*p );}\nfloat bo(vec3 p,vec3 s){p = abs(p) - s;return max(max(p.x,p.y),p.z);}\nfloat rand(vec2 p){return fract(sin(dot(p,vec2(127.1,317.2))));}\n\n\n//https://www.shadertoy.com/view/XsX3zB\n//---------------------------------------------------------\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n//---------------------------------------------------------\n\nfloat noise (vec3 st) \n{\n    float f = 0.;\n    vec3 q = st;\n    for(int i = 1 ;i < 3;i++){\n        f += simplex3d(q)/pow(2.,float(i));\n        q = q * (2.0+float(i)/100.);\n    }\n    return f;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(0.);\n    vec2 area = floor((p.xz)/(.8));\n    p.xz = mod(p.xz,(.8 ))-(.8)/2.;\n    \n    //p.y += wave(area ,time) ;\n    for(int i = 1; i< 5; i++)\n    {\n        p.y += pow( sin(area.x + t) * cos(area.y + t) ,2.);\n        area = rot(area,acos(-1.)/3.);\n        area += .8 * 60.;\n        area = floor(area /(float(i ) *2.) );\n    }\n    float s = bo(p,vec3(.25,cos(length(p.xz)*1.3),.25));\n    //s = length(p)-.5;\n    d.x = s *.1;\n    return d;\n}\n\nvec2 march(vec3 p,vec3 rd)\n{\n    depth = 0.;\n    vec2 d = vec2(.0);\n    for(int i = 0; i <128; i++)\n    {\n        d = map(p + rd * depth);\n        if(abs(d.x) < 0.00001 || d.x > FAR){break;}\n        depth += d.x;\n    }\n     if(d.x > FAR){d.x = -1.;}\n    return d;\n}\n\nvoid moon(out vec3 color,in vec3 cp,in vec3 rd)\n{\n    color += clamp( pow(  mix( 1.,.5 - noise((cp + rd) * 18. + vec3(0.8,1.7,0.6) * (t + sin(t))/5. ) ,.5),1.5 ),0.,1. );\n}\n\nvoid scene(out vec3 ocolor,in vec2 fragcoord)\n{\n    vec2 p = (fragcoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    \n    vec3 target = vec3(0.,-7.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 2. + dot(p,p) * .3;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov);\n    vec3 skycolor = vec3(.2,.4,.8);\n    vec3 color = skycolor;\n    //vec3(0.5,0.4,-1.)\n    \n    vec3 moonpos = vec3(p.x,p.y - .7,depth);\n    vec3 light = normalize(vec3(.0,.3,.0) - mix(rd , moonpos,0.01));\n    \n   // light.xz = rot(light.xz,sin(time) );\n    vec2 d = vec2(-1.);\n    skycolor += (1. - pow( length(moonpos.xy + cos(moonpos.xy*200.)),2.) )/3.;\n    \n    if(length(moonpos.xy) < .125)\n    {\n        moon(color,cp,rd);\n        color = mix(color,skycolor,pow( length(moonpos.xy) * 8.,6. ) );\n    }else{\n    \td = march(cp,rd);\n    }\n    if(d.x > 0.)\n    {\n        vec2 e = vec2(0.0001,0.);\n        vec3 pos = depth * rd + cp;\n    \tvec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        color = vec3(0.,.5,1.);\n        float dif = pow( max(0.,dot(light,N))*.5+.5,2. );\n        float sp = pow(max(0.,dot(normalize(light + rd),N)),150.);\n        color =color * dif + sp * vec3(1.,1.,1.);\n        \n    }\n    ocolor += mix(color,skycolor,1.-exp(-.000001 *depth * depth* depth));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime/2.;\n    depth = 55.;\n    vec3 color = vec3(0.);\n    for(int i = 0;i < AA;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            scene(color,gl_FragCoord.xy + d);\n        }\n    }\n    color /= float(AA * AA);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 100, 100, 153], [154, 154, 178, 178, 223], [224, 224, 243, 243, 288], [291, 391, 413, 413, 610], [717, 740, 765, 1024, 2016], [2078, 2078, 2102, 2102, 2271], [2752, 2752, 2780, 2780, 3017], [3019, 3019, 3068, 3068, 3191], [3193, 3193, 3240, 3240, 4631], [4633, 4633, 4690, 4690, 5069]], "test": "timeout"}
{"id": "tdsyz2", "name": "pasillo-rojo-v1", "author": "jorge2017a1", "description": "pasillo-rojo-v1", "tags": ["pasillorojov1"], "likes": 1, "viewed": 39, "published": "Public", "date": "1585188313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+1.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    float piso = mapCerrov2(p);\n    float pisopardIzq = mapCerrov2(p.zxy-vec3(0.0,-15.0,0.0));\n    float pisopardder = mapCerrov2(vec3(0.0,15.0,0.0)-p.zxy);\n    \n   \n    res=opU(res, vec2(pisopardIzq,1 ));\n    res=opU(res, vec2(pisopardder,1 ));\n    res=opU(res, vec2(piso,1 ));\n    \n\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    \n    //vec3 ro = vec3(0 ,10.0+8.0*cos(3.0-iTime*0.5),2.0+6.0*cos(3.0-iTime*0.5));\n    vec3 ro = vec3(0 ,3.0+3.0*cos(3.0-iTime*0.5),2.0+iTime*5.0);\n    \n    //ro = get_mouse(ro);\n    vec3 rd =normalize(vec3(uv,0.5) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 537, 570, 570, 635], [636, 654, 690, 690, 759], [760, 775, 806, 806, 956], [957, 977, 1013, 1013, 1100], [1101, 1117, 1149, 1177, 1238], [1240, 1240, 1276, 1276, 1379], [1382, 1382, 1427, 1427, 1518], [1572, 1572, 1618, 1618, 1650], [1652, 1652, 1695, 1695, 1727], [1729, 1729, 1777, 1777, 1810], [1813, 1813, 1842, 1842, 1968], [1970, 1970, 2006, 2006, 2123], [2125, 2125, 2161, 2161, 2279], [2282, 2282, 2318, 2318, 2441], [2494, 2506, 2528, 2528, 2836], [2837, 2863, 2888, 2888, 3078], [3079, 3124, 3141, 3141, 3214], [3217, 3250, 3276, 3276, 3473], [3520, 3520, 3572, 3572, 3727], [3792, 3901, 3938, 3938, 3973], [3975, 3975, 3994, 3994, 4069], [4118, 4118, 4141, 4141, 4167], [4169, 4169, 4192, 4192, 4330], [4333, 4333, 4355, 4355, 4425], [4490, 4490, 4516, 4516, 4573], [4575, 4575, 4595, 4595, 4653], [4656, 4656, 4677, 4677, 4927], [4971, 4971, 4997, 4997, 5168], [5170, 5214, 5239, 5239, 5945], [5950, 5950, 5983, 5983, 6458], [6462, 6462, 6486, 6486, 6818], [6823, 6823, 6861, 6861, 7219], [7318, 7362, 7379, 7379, 7450], [7475, 7567, 7592, 7592, 7855], [7976, 7976, 8004, 8004, 16357], [16360, 16360, 16417, 16417, 17576]], "test": "error"}
{"id": "tdsyzr", "name": "CS 180 project - Foreign Planet", "author": "rafaeltrinidad", "description": "Implicit Surfaces\nBased off of the the \"Elevated coast\" project created by user guil https://www.shadertoy.com/view/4l23Rh\nCreated by Rafael Trinidad and Rain Wang", "tags": ["planet", "stars", "terrains"], "likes": 2, "viewed": 80, "published": "Public", "date": "1584230157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Based off of the the \"Elevated coast\" project created by user guil https://www.shadertoy.com/view/4l23Rh\n#define time -iTime\n\n\nfloat dh = 0.;\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat random(float x) {\n \n    return fract(sin(x) * 10000.);\n          \n}\n\nfloat noise(in vec2 p){\n    return random(p.x + p.y * 10000.);\n}\n\nvec2 sw(vec2 p) { \n    return vec2(floor(p.x), floor(p.y)); \n}\n\nvec2 se(vec2 p) { \n    return vec2(ceil(p.x), floor(p.y));\n}\n\nvec2 nw(vec2 p) { \n    return vec2(floor(p.x), ceil(p.y)); \n}\n\nvec2 ne(vec2 p) {\n    return vec2(ceil(p.x), ceil(p.y));\n}\n\nfloat smoothNoise(vec2 p) {\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n        \n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(smoothNoise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;\n       \n\t}\n\treturn 1.-r*.5;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(smoothNoise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*(r-.2*iTime/(.1-f));\n\t}\n\treturn r/4.+.5;\n}\n\n\n\nfloat terrainIq( in vec2 x )//from IQ's Elevated : https://www.shadertoy.com/view/MdX3Rr\n{\n\tvec2  p = x;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn .3*a+.5;\n}\n\nfloat rocks(vec2 p){\n   return terrainIq(p);   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p) // from guil's Elevated coast : https://www.shadertoy.com/view/4l23Rh\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p) // from guil's Elevated coast : https://www.shadertoy.com/view/4l23Rh\n{\n\tconst vec2 e = vec2(0.01, 0.2);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n\t//color of the sky\n    return sin(vec3(0.0,0.0,0.0) - .65*fbmabs(p*5.-.02*time))+0.1;\n}\n\nfloat march(in vec3 ro, in vec3 rd) // from guil's Elevated coast : https://www.shadertoy.com/view/4l23Rh\n{\n\tconst float maxd = 55.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nfloat Band(float t, float start,float end,float blur){\n    float step1 = smoothstep(start-blur,start+blur,t);\n    float step2 = smoothstep(end+blur,end-blur,t);\n    return step1*step2;\n}\n\nfloat Rectangle(vec2 uv,float left,float right,float bottom, float top, float blur){\n    float band1 = Band(uv.x,left,right,blur);\n    float band2 = Band(uv.y,bottom,top,blur);\n    return band1*band2;\n}\n\nvec3 light = vec3(-0.7, -0.2, .1);\nvec3 light_color = vec3(1.9,1.8,1.8);\n\nvec3 sphere = vec3(0, 0, 2); //3rd element means how into the screen it is\nvec3 sphere1 = vec3(0, 0, 3);\nvec3 sphere2 = vec3(0, 0, 7);\nfloat sphere_size = 0.4;\nvec3 sphere_color = vec3(1, 1, 1);\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\t//radius = radius * radius;\n\tfloat dt = dot(rdir, sp - rpos);\n\tif (dt < 0.0) {\n\t\treturn -1.0;\n\t}\n\tvec3 tmp = rpos - sp;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius) {\n\t\treturn -1.0;\n\t}\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 x = fragCoord.xy;\n\tvec3 a = vec3(max((fract(dot(sin(x),x))-.994)*80.,-.4));\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.3*time);\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n    \n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        \n        float k=rocks(pos.xz)*2.;\n        \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.05)/2.;\n        if(dh<0.&&dh>-.02)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<-0.02){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n            col1+=vec3(0.9,.2,.05)*dh*0.4;\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \t//col1 +=0.2* sky(nor.xz/(.5+nor.y));\n            \n        } \n\t    col = -0.4+col1;\n        \n\t}\n    else //sky\n    \tcol = a;\n    \n    float mask;\n    vec2 uv1 = fragCoord.xy/iResolution.xy;\n    uv1 -= .5;\n    uv1.x *= iResolution.x/iResolution.y;\n\n \t//mask = Rectangle(uv,-.1,.1,-.1,.1,.06);\n    mask = Rectangle(uv1,-.05,.05,-.05,.02,.06);\n    vec4 col2 = vec4(1.5,1.5,1.5,1.)*mask; \n    \n    \n    //Added planet 1\n    vec3 point; \n\tvec3 normal;\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n    \n\tvec3 ray = vec3(uv.x+1., uv.y+.5, 1.0); //position\n\tray = normalize(ray);\n\tfragColor = vec4(0.5);\n\t\n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n\t\n\tif (dist > 0.0) {\n\t\tvec3 tmp = normalize(light - sphere);\n\t\tfloat u = atan(normal.z, normal.x) / 3.1415*2.0 + iTime / 5.0;\n\t\tfloat v = asin(normal.y) / 3.1415*2.0 + 0.5;\n\t\tfragColor.xyz = 1.3* vec3(dot(tmp, normal)) * light_color * 1.3* sphere_color * texture(iChannel0, vec2(u, v)).xyz;\n\t} \n    \n    //Planet 2\n    \n    vec3 ray1 = vec3(uv.x-1.4, uv.y+.6, 1.0); //position\n\tray1 = normalize(ray1);\n    float dist1 = raySphere(vec3(.0,0.,0.0), ray1, sphere1, sphere_size, point, normal);\n    \n    if (dist1 > 0.0) {\n\t\tvec3 tmp = normalize(light - sphere1);\n\t\tfloat u = atan(normal.z, normal.x) / 3.1415*2.0 + iTime / 2.0;\n\t\tfloat v = asin(normal.y) / 3.1415*2.0 + 0.5;\n\t\tfragColor.xyz = 1.3*vec3(dot(tmp, normal)) * light_color * 1.3*sphere_color * texture(iChannel1, vec2(u, v)).xyz;\n\t}\n    \n   \tfragColor = vec4(fragColor.xyz,0.0) + col2 + vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 282, 282, 332], [334, 334, 357, 357, 398], [400, 400, 417, 417, 462], [464, 464, 481, 481, 524], [526, 526, 543, 543, 587], [589, 589, 606, 606, 647], [649, 649, 676, 676, 881], [883, 883, 906, 930, 1244], [1247, 1247, 1271, 1271, 1439], [1441, 1441, 1463, 1463, 1661], [1665, 1665, 1755, 1755, 2006], [2008, 2008, 2028, 2028, 2057], [2059, 2059, 2079, 2079, 2214], [2216, 2216, 2315, 2315, 2468], [2470, 2470, 2567, 2567, 2711], [2713, 2713, 2734, 2755, 2824], [2826, 2826, 2933, 2933, 3230], [3232, 3232, 3259, 3259, 3311], [3313, 3313, 3367, 3367, 3499], [3501, 3501, 3585, 3585, 3703], [3975, 3975, 4074, 4103, 4393], [4395, 4395, 4452, 4452, 6936]], "test": "error"}
{"id": "tdsyzs", "name": "Pickle (Shader) Rick", "author": "LilBensson", "description": "Funniest thing I've ever seen.", "tags": ["raymarching", "rick", "rickandmorty", "pickle"], "likes": 13, "viewed": 210, "published": "Public", "date": "1585442142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_STEPS 100\n#define RAY_HIT_DIST 0.001\n\nvec3 lightDir = normalize(vec3(-1.0, -1.0, -0.6));\n\nvec3 greenBodyColor = vec3(0.0, 0.55, 0.0);\nvec3 brightGreenBodyColor = vec3(0.0, 0.65, 0.0);\nvec3 darkGreenSpotColor = vec3(0.0, 0.45, 0.0);\nvec3 yellowEyesColor = vec3(0.95, 0.95, 0.85);\nvec3 yellowTeethColor = vec3(0.95, 0.95, 0.85)*0.9;\nvec3 whiteBlueEyebrowColor = vec3(0.90, 0.99, 0.90);\nvec3 blackMouthColor = vec3(0.2, 0.2, 0.2);\n\n// valuateType = 0: min(d1, d2)\t\t\"normal\" sdf\n// valuateType = 1: max(-d1, d2)\t\"carve\" out shapes\nvoid ValuateSDF(inout vec4 currDist, float sdf, vec3 color, int valuateType)\n{\n\tfloat tempDist;\n    \n    if(valuateType == 0)\n    \ttempDist = min(sdf, currDist.x);\n    else if(valuateType == 1)\n        tempDist = max(-sdf, currDist.x);\n    \n    // TempDist is a better sdf\n    if(tempDist != currDist.x)\n    \tcurrDist = vec4(tempDist, color);\n}\n\nvoid SDFDeformedCapsule(inout vec4 currDist, vec3 p, vec3 p1, vec3 p2, float radius, vec3 color, int valuateType)\n{\n    // Curve the \"spine\" a bit\n    p.z += (0.6 - p.y*p.y)*0.1;\n    \n    vec3 line = p1 - p2;\n    vec3 pointDir = p - p2;\n    \n    // Project p onto the line\n    float t = dot(pointDir, line) / dot(line, line);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 tempPoint = p2 + line*t;\n    \n    // Distort the sdf, based on the current point's y-position\n    float sdf = (length(p - tempPoint) - radius) + \n        sin(p.y*7.0) * 0.005 + \n        cos(p.y*20.0 + 63.01) * 0.001;\n    \n    ValuateSDF(currDist, sdf, color, valuateType);\n}\n\nvoid SDFCapsule(inout vec4 currDist, vec3 p, vec3 p1, vec3 p2, float radius, vec3 color, int valuateType)\n{\n    vec3 line = p1 - p2;\n    vec3 pointDir = p - p2;\n    \n    // Project p onto the line\n    float t = dot(pointDir, line) / dot(line, line);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 tempPoint = p2 + line*t;\n    \n    float sdf = (length(p - tempPoint) - radius);\n    \n    ValuateSDF(currDist, sdf, color, valuateType);\n}\n\nvoid SDFSphere(inout vec4 currDist, vec3 p, vec3 pos, float radius, vec3 color, int valuateType)\n{\n\tfloat sdf = length(p - pos) - radius;\n    \n    ValuateSDF(currDist, sdf, color, valuateType);\n}\n\nvec4 Map(vec3 p)\n{\n    // currDist.x = sdf\n    // currDist.yzw = color\n    vec4 currDist = vec4(999.0, vec3(0.0));\n    \n    vec3 originalP = p;\n    \n    // Body\n    SDFDeformedCapsule(currDist, p, vec3(0.0, 0.45, 0.0), vec3(0.0, -0.65, 0.0), 0.3, greenBodyColor, 0);\n    \n    // Eyes\n    p.x = abs(p.x);\n    float r = 0.08;\n    SDFSphere(currDist, p, vec3(r+0.007, 0.4, 0.26), r, yellowEyesColor, 0);\n    \n    // Pupils\n    SDFSphere(currDist, p, vec3(r+0.02, 0.4, 0.34), 0.01, blackMouthColor, 0);\n    \n    // Eyebrow\n    p.y += p.x*p.x*1.5;\n    float partY = 0.55;\n    SDFCapsule(currDist, p, vec3(-0.12, partY, 0.27), vec3(0.12, partY, 0.27), 0.01, whiteBlueEyebrowColor, 0);\n    \n    // Mouth\n    p.y = originalP.y;\n    p.y -= p.x * p.x * 9.0 * p.y;\n    partY = 0.18;\n    SDFCapsule(currDist, p, vec3(-0.15, partY, 0.24), vec3(0.15, partY, 0.24), 0.06, blackMouthColor, 1);\n    \n    // Nose\n    p = originalP;\n    p.x = abs(p.x);\n    SDFCapsule(currDist, p, vec3(0.0, 0.4, 0.2), vec3(0.0, 0.3, 0.3), 0.02, greenBodyColor, 0);\n    \n    // Teeth\n    float allTeethZ = 0.23;\n    float teethX1 = 0.03;\n    float teethY1 = 0.01;\n    float teethZ1 = 0.01;\n    \n    // Upper teeth\n    for(float i = 0.0; i < 3.0; i += 1.0)\n    \tSDFCapsule(\n            currDist, \n            p, \n            vec3(teethX1*i, partY+0.06+teethY1*i, allTeethZ - teethZ1*i), \n            vec3(teethX1*i, partY+0.04+teethY1*i, allTeethZ - teethZ1*i), \n            0.01, \n            yellowTeethColor, \n            0\n        );\n    \n    // Lower teeth\n    for(float i = 0.0; i < 4.0; i += 1.0)\n    \tSDFCapsule(\n            currDist, \n            p, \n            vec3(teethX1*i, partY-0.04, allTeethZ - teethZ1*i*-0.8), \n            vec3(teethX1*i, partY-0.05, allTeethZ - teethZ1*i*-0.8), \n            0.01, \n            yellowTeethColor, \n            0\n        );\n    \n    // \"Weird pickle spots\"\n    // This can probably be done on a better way.\n    // Possibly by rounding the current point to a sector on the main body capsule and assigning\n    // each sector to a random point and sphere size on the capsule.\n    p = originalP;\n    SDFSphere(currDist, p, vec3(0.28, -0.3, 0.05), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(0.27, -0.35, 0.05), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(0.26, -0.6, 0.08), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(0.24, 0.1, 0.08), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(-0.26, -0.4, 0.08), 0.027, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(-0.24, -0.5, 0.12), 0.027, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(-0.24, -0.1, 0.12), 0.027, darkGreenSpotColor, 0);\n    \n    return currDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 offset = vec2(0.0, 0.0001);\n    \n    vec3 n = vec3(Map(p).x) - \n        vec3(\n            Map(p + offset.yxx).x,\n            Map(p + offset.xyx).x,\n            Map(p + offset.xxy).x\n        );\n\t\n    return normalize(n);\n}\n\nfloat GetSpecularLight(vec3 cameraPos, vec3 p, vec3 normal)\n{\n    vec3 reflectedLightDir = normalize(reflect(lightDir, normal));\n    vec3 pointToCam = normalize(cameraPos - p);\n    \n    float spec = clamp(dot(reflectedLightDir, pointToCam), 0.0, 1.0);\n    spec = pow(spec, 3.0);\n    \n    spec = smoothstep(0.35, 0.55, spec);\n    \n\treturn spec * 0.2;\n}\n\nvec3 RayMarch(vec2 uv)\n{\n    // Camera orientation\n    vec3 camLookAt = vec3(0.0);\n    vec3 camPos = vec3(1.0 * cos(iTime*0.5), 0.0, 2.3);\n    \n    vec3 camForward = normalize(camLookAt - camPos);\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    float zoom = 1.0;\n    \n    // Create point and direction\n    vec3 currentPos = camPos + zoom * camForward + uv.x * camRight + uv.y * camUp;\n    vec3 rayDir = normalize(currentPos - camPos);\n    \n    vec3 col = vec3(0.0);\n    \n    // Ray march loop\n    for(int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        vec4 currDist = Map(currentPos);\n        \n        // Hit!\n        if(currDist.x <= RAY_HIT_DIST)\n        {\n            vec3 normal = GetNormal(currentPos);\n            vec3 bodyNormal = normal;\n            bodyNormal.z += pow(sin(currentPos.y*abs(currentPos.x-0.5)*10.0)*0.5, 2.0) * 0.2;\n            \n            // Middle of the body\n            if(currDist.yzw == greenBodyColor)\n            {\n            \tcurrDist.yzw = mix(greenBodyColor, brightGreenBodyColor, smoothstep(0.90, 0.95, dot(bodyNormal, vec3(0.0, 0.0, -1.0))));\n            }\n            \n            // Ignore shading the teeth\n            if(currDist.yzw == yellowTeethColor)\n            {\n            \tcol = currDist.yzw;\n                \n                break;\n            }\n            \n            float diffuseShadow = smoothstep(\n                0.60, \n                0.40,\n                clamp( dot(normal, -lightDir), 0.0, 1.0 )\n            );\n            float specularLight = GetSpecularLight(camPos, currentPos, normal);\n            \n        \tcol = currDist.yzw * (max(0.7, diffuseShadow) + specularLight);\n            \n            break;\n        }\n        \n        currentPos += rayDir * currDist.x;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n   \tvec3 col = RayMarch(uv);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 543, 621, 621, 887], [889, 889, 1004, 1035, 1531], [1533, 1533, 1640, 1640, 1962], [1964, 1964, 2062, 2062, 2159], [2161, 2161, 2179, 2231, 4867], [4869, 4869, 4893, 4893, 5121], [5123, 5123, 5184, 5184, 5474], [5476, 5476, 5500, 5526, 7327], [7329, 7329, 7386, 7386, 7539]], "test": "timeout"}
{"id": "tdXcD2", "name": "36 Days Of Type - F", "author": "nicolasdnl", "description": "36 Days Of Type - F", "tags": ["letter"], "likes": 2, "viewed": 28, "published": "Public", "date": "1585606048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[9], float kPath[21] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n   \tint kType[] = int[](0,0,0,0,0,0,1,0,0);\n\tfloat kPath[] = float[](  0.30, 0.5,\n                             -0.30, 0.5,\n                             -0.30,-0.5,\n                             -0.20,-0.5,\n                             -0.20, 0.0,\n                             //-0.20,-0.5, -0.5,\n                              0.20,-0.0,\n                              0.20,-0.0, 0.0,\n                              0.20, 0.4,\n                              0.30, 0.4,\n                              0.30, 0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    p *= 1.5;\n    \n    // distance computations\n    float d = sdA(p);\n    \n    // coloring\n    float t = mod(iTime, 1.) * 2.;\n    float gap = 3./10.;\n    \n    float dist = max(0., min(1., 1. - (d+1.)*0.25));\n    float dist2 = (d*2.+1.)*0.2;\n   \n    vec3 col = vec3(1.,1.,1.);\n    col *= 1.0 + dist2*cos(140.0*d-t*PI*2.);\n    \n    if (d > 0.25) col = vec3(1.);\n    col = generateBorder(col, abs(d-0.245));\n    col = 1. - col;\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1633, 1633, 2398], [2971, 2971, 3022, 3022, 3107], [3109, 3109, 3166, 3202, 3732]], "test": "error"}
{"id": "tdXcWB", "name": "random quadtree mod", "author": "JamesHagerman", "description": "modified from https://www.shadertoy.com/view/MlsXDf", "tags": ["quadtree"], "likes": 3, "viewed": 109, "published": "Public", "date": "1585455888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P_SUBDIV .2+.2*sin(iTime)\n//#define P_SUBDIV .2\n\nfloat rnd(vec3 v) { return fract(4e4*sin(dot(v,vec3(13.46,41.74,-73.36))+17.34)); }\n    \nvoid mainImage( out vec4 fragColor, vec2 uv )\n{\n    vec2 u, R=iResolution.xy, m=vec2(sin(iTime), cos(iTime));\n    if (m.x+m.y<1e-2*R.x) m = R*(.5+.5*sin(.1*iTime+vec2(0,1.6)));\n    uv.x -= 8.*(m.x-R.x/2.);\n    uv /= (1.-m.y/R.y)*4.;\n    \n\tfloat z = R.y;\n    for (int i=0; i<128; i++) {\n        u = floor(uv/z)+.5;\n        if (rnd(vec3(z*u, z)) < P_SUBDIV) break;\n        z /= 2.;\n    }\n    uv = z/2.-abs(uv-z*u);\n    fragColor = min(uv.x,uv.y)<1. ? vec4(0) :\n    \t\t\t// vec4(1); // vec4(z/R.y);\n\t\t\t\t.6+.4*cos(6.28*rnd(vec3(z*u+1.,z))+vec4(0,2.1,-2.1,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 76, 76, 140], [146, 146, 193, 193, 701]], "test": "timeout"}
{"id": "tdXczB", "name": "param_v33", "author": "darkczar", "description": "time based color", "tags": ["psychedelic", "trippy"], "likes": 2, "viewed": 65, "published": "Public", "date": "1585024188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    //float d2 = 10002.0;\n    //float d3 = 10003.0;\n    float di = 0.;\n    //float threshold = 0.005;//0000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    //float black_threshold=0.5;// -.5*nsin(iTime*.6);\n\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*32.+30.*sin(iTime*.005);\n        curve_p.x = -.1*sin(.3*iTime)+.04*float(di)*sin(float(di)+.1*iTime) +.03*float(di)*sin(4.0*di+.04*iTime) + .03*sin(iTime*.1)*float(di)*sin(di*di*.005+.08*iTime);\n        curve_p.y = -.1*cos(.3*iTime)+.04*float(di)*cos(float(di)+.1*iTime) +.03*float(di)*cos(4.0*di+.04*iTime) + .03*sin(iTime*.1)*float(di)*cos(di*di*.005+.08*iTime);\n        dtemp = pow(length(.9*float(i)*p-curve_p),1.25);\n\n\n        d= dot(normalize(p),normalize(curve_p))+3.*sin(.5*iTime+.1*d*d*d)+2.*cos(dtemp*dtemp+.1*iTime);\n        //if(d<black_threshold) d=020.5;   \n        r = map(38.*rand(vec2(float(i),float(i))), 0.,2000.,0.,1.); // +nsin(iTime*.8);\n        g = map(g+.001*d*dtemp+1.*sin(d+1.57), 0.,2000.,0.,1.);\n        b = map(.0004*dtemp*dtemp-d - 1.5*(log(.8*dtemp*dtemp-3.*d), .8), 0.,2000.,0.,1.); //+.001*rand(vec2(34.3,floor(dtemp*32.))); //b + .05*dtemp-.05*d;  \n        r = r*(.5+.5*sin(3.*iTime));\n        g = g*(.5+.5*sin(3.*iTime+6.28/3.));\n        b = b*(.5+.5*sin(3.*iTime+6.28 * (6.28*.66666)));\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 180, 180, 246], [567, 567, 624, 674, 2394]], "test": "timeout"}
{"id": "tdXSzf", "name": "asdadasd", "author": "asdhyq", "description": "asdadasa", "tags": ["sadadas"], "likes": 1, "viewed": 56, "published": "Public", "date": "1583122903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 blue = vec3(0.,128./255.,1.);\nvec3 black = vec3(0.,0.,0.);\n\n\nvec3 rgb(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n    \n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x,0.,0.,value.y);\n}\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), - sin(angle),sin(angle),cos(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float x = sin(iTime * 1.5 ) ;\n    \n\tuv*=10.;\n    float ratio = iResolution.x / iResolution.y;\n    \n    //float offset = step(1.,mod(uv.y ,2.));\n    float offset = mod(uv.y ,2.) > 1. ? -1. : 1.;\n    uv.x += offset * iTime;\n    uv = fract(uv);\n    \n    //uv.x = mod(offset,2.) != 0. ? uv.x += offset + (iTime) : uv.x -= offset + (iTime);\n    \n    //float offset2 = step(1.,mod(uv.y * 1.,2.));\n    //offset = mod(offset,2.) ? 0. : 1.;\n  \n\t//uv.x = mod(offset,2.) == 0. ? uv.x +=offset * (iTime) : uv.x -=offset * (iTime); \n  \n   //\tuv.x += offset * sin(iTime);\n  \n    \n    \n    \n    \n    uv = fract(uv);\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 * ratio,0.5);\n    uv -= pos;\n    \n    uv *= rotate2d(sin(iTime));\n    uv *= scale2d(vec2(1.0,1.0));\n    \n    uv+=pos;\n    vec2 shapePos = vec2(.5 * ratio, .5);\n    float dist = distance ( shapePos,uv) ;\n    \n    uv -= shapePos;\n    \n    \n\t\n    // rectangle Properties\n\tvec2 center = vec2(0., 0.);\n\tfloat width = .2;\n\tfloat height = .2;\n\n    // Background layer\n\tvec4 bg = vec4(rgb(1.0, 1.0, 1.0), 1.0);\n\t\n\t// Rectangle\n\tvec3 col = rgb(255.0, 255.0, 0.0);\n\tvec4 rect = rectangle(uv , center, width, height, col);\n\t\n\t// Blend the two\n\tvec3 color = mix(vec3(0.), blue, rect.a);\n\t\n   \n       // Output to screen\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 105, 105, 154], [156, 156, 230, 230, 428], [430, 430, 456, 456, 498], [499, 499, 527, 527, 594], [595, 595, 652, 652, 1991]], "test": "ok"}
{"id": "tdXyRN", "name": " Menger Tunnel-v2--Joke", "author": "jorge2017a1", "description": "60 seg...bien....140 seg ..bien", "tags": ["mengertunnelv2joke"], "likes": 1, "viewed": 46, "published": "Public", "date": "1584242901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --2019-dic-07\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat pathterrain(float x,float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\n//--------------------------\nfloat DE(vec3 p) {\n\tfloat scale = 1.5;\n\t//float dist = 0.0;\n    \n        \n    float dist = pathterrain(p.x,p.z);\n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .05;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    vec3 ro = vec3(0.0, 0.5, -1.5+ 1.0*cos(time)+time*1.1)*2.5;\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 508, 535, 535, 566], [568, 568, 599, 599, 690], [693, 693, 716, 716, 853], [855, 855, 885, 885, 1022], [1072, 1072, 1141, 1220, 1261], [1263, 1263, 1345, 1345, 1576], [1578, 1578, 1638, 1638, 1779], [1828, 1883, 1906, 1906, 2041], [2043, 2043, 2069, 2069, 2126], [2128, 2128, 2168, 2168, 2202], [2205, 2205, 2241, 2292, 2387], [2391, 2420, 2438, 2438, 2667], [2727, 2727, 2756, 2756, 2944], [2946, 2946, 2987, 2987, 3163], [3165, 3165, 3206, 3206, 3358], [3360, 3360, 3381, 3381, 3511], [3513, 3513, 3540, 3540, 3790], [3792, 3792, 3849, 3849, 4313]], "test": "timeout"}
{"id": "tdXyW8", "name": "atry", "author": "singoltone", "description": "simple try", "tags": ["try"], "likes": 2, "viewed": 87, "published": "Public", "date": "1584640216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 st) \n{\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 Tile(vec2 uv, float zoom)\n{\n    uv *= zoom;\n    return fract(uv)-.5;\n}\n\nvec2 Tile2(vec2 _st, float zoom)\n{\n    _st *= zoom;\n\n    float choice = 0.;\n    float ret = 0.;\n\n    choice = sin(iTime*10.);\n    ret = cos(iTime);\n\n    if (choice > 0.)\n    {\n        if ( mod(_st.x, 2.0) < 1.)\n            _st.y += sin(iTime*1.5);\n        else\n            _st.y -= sin(iTime*1.5); \n    }\n\telse\n    {\n        if ( mod(_st.y, 2.0) < 10.)\n            _st.x += sin(iTime);\n        else\n            _st.x -= sin(iTime); \n    }     \n    \n    if (ret > 0.)\n    \treturn fract(_st)*sin(iTime*20.);\n    else\n        return floor(_st)*sin(iTime*20.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv *= 20000.;\n    vec2 uvT = uv * 20.;\n    vec2 uvO = uv;\n\tvec2 uvP = uv + uvT;\n    \n    float ret = 0.;\n    ret = sin(iTime*2.)-cos(iTime*2.);\n\tif (ret < 0.2)\n    {\n        uv = uvP;\n        uv = abs(uv);\n    }\n    else if (ret > 0.2 && ret < 0.5)\n    {\n        uv = uvT-(sin(iTime)+20.);\n    }\n    else if (ret > 0.5 && ret < 0.8)\n    {\n        uv = uvO * uvP * random(uvP)+20.;\n    }\n    \n    uv += uvT;\n    uv -= uvT;\n    \n    uv = abs(uv);\n\n    vec2 uv_int = floor(uv);\n    vec2 uv_fract = 1.-fract(uv);\n    uv = Tile2(vec2(random(uv_fract)), uv_int.y*uv_int.x);\n    \n    float color = smoothstep(uv.x-0.1,uv.x,uv.y)*\n                smoothstep(uv.x,uv.x,uv.y);\n    \n    float color2 = step(uv.x-0.1,uv.y)*\n                step(uv.x,uv.y);\n    \n    fragColor = vec4(vec3(1.- color2), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 165, 165, 208], [210, 210, 244, 244, 768], [770, 770, 827, 877, 1775]], "test": "ok"}
{"id": "tdXyzB", "name": "Analytical spheres", "author": "CensoredUsername", "description": "Simple demo of some analytically raytraced spheres.", "tags": ["raytracing", "phong"], "likes": 2, "viewed": 244, "published": "Public API", "date": "1585016526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// analytical raytracing speres with phong shading and reflections\n// this is written for clarity, not for performance.\n\nconst float INFINITY = 1e20;\nconst float PI = 3.1415;\n\n// sphere locations. radius is equal to z\nconst uint SPHERE_COUNT = 10u;\nvec4 spheres[SPHERE_COUNT] = vec4[](\n    vec4(0.0, 0.0, -100.0, 100.0),\n    vec4(0.0, 0.0, 0.8, 0.8),\n    vec4(1.0, 1.0, 0.4, 0.4),\n    vec4(1.0, -1.0, 0.4, 0.4),\n    vec4(-1.0, 1.0, 0.4, 0.4),\n    vec4(-1.0, -1.0, 0.4, 0.4),\n    vec4(1.5, 0.0, 0.1, 0.1),\n    vec4(0.0, 1.5, 0.1, 0.1),\n    vec4(-1.5, 0.0, 0.1, 0.1),\n    vec4(0.0, -1.5, 0.1, 0.1)\n);\n\n// ambient, diffuse, specular, RGB\nvec3 AMBIENT = vec3(0.001);\nvec3 DIFFUSE = vec3(0.95, 0.95, 0.8) * 0.5;\nvec3 SPECULAR = vec3(0.95, 0.95, 0.8);\nfloat SHININESS = 500.;\nvec3 REFLECT = vec3(0.5);\n\n// light, RGB. light is an isentropic light as I'm lazy.\nvec3 LIGHT = vec3(1.0);\nvec3 LIGHT_DIR = normalize(vec3(0.0, -1.0, -0.5)); \n\n// random function\nfloat rand(float seed){\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// testing stuff: slightly, randomly distrubs a direction vector\nvec3 disturb(vec3 dir) {\n    vec3 noise = vec3(rand(dir.x), rand(dir.y), rand(dir.z));\n    return normalize(dir + 0.1 * noise);\n}\n\n// calculate analytic collision with the geometry.\nvec3 collide(vec3 origin, vec3 dir, out float depth) {\n    depth = INFINITY;\n    uint match;\n\n    // try colliding with the spheres, keeping the lowest depth entry\n    for (uint i = 0u; i < SPHERE_COUNT; i++) {\n        // early-z, just by projected center distance\n        vec3 s = spheres[i].xyz - origin;\n        float t = dot(dir, s);\n        if (t > depth || t < 0.0) {\n            continue;\n        }\n\n        // collision test\n        vec3 d = (dir * t - s);\n        if (length(d) > spheres[i].w) {\n            continue;\n        }\n        \n        // store any useful data for the actual collision calc\n        depth = t;\n        match = i;\n    }\n    if (depth == INFINITY) {\n        return vec3(0.);\n    }\n\n    // math\n    vec3 s = spheres[match].xyz - origin;\n    float t = depth;\n    vec3 d = (dir * t - s);\n    // this line is numerically a bit unstable due to the subtraction of two large numgers which can be close together\n    vec3 r = d - dir * sqrt(spheres[match].w * spheres[match].w - dot(d, d));\n\n    // surface normal and final depth\n    depth = length(s + r);\n    return normalize(r);\n}\n\nvec3 light_ray(vec3 orig, vec3 dir, out vec3 hit, out vec3 hit_norm) {\n    // hit something\n    float depth;\n    hit_norm = collide(orig, dir, depth);\n    hit = orig + depth * dir;\n\n    // shadow\n    float shadow_depth;\n    collide(hit, -LIGHT_DIR, shadow_depth);\n    \n    // lighting\n    vec3 light = vec3(0.0);\n    if (depth < 1e9) {\n        light += AMBIENT;\n        if (shadow_depth > 1e9) {\n            light += DIFFUSE * dot(-LIGHT_DIR, hit_norm);\n            light += SPECULAR * pow(max(0.0, dot(reflect(-LIGHT_DIR, hit_norm), dir)), SHININESS);\n        }\n    }\n    return light * LIGHT;\n}\n\nvec3 camera;\nvec3 camera_dir;\nvec3 camera_up;\nconst float AR = 1.4;\n\n// this part is identical for every pixel\nvoid setup() {\n    camera = vec3(5.0 * cos(iTime * 0.1), 5.0 * sin(iTime * 0.1), 2.);\n    camera_dir = normalize(vec3(0., 0., 1.) - camera);\n    camera_up = vec3(0., 0., 1.);\n    \n    \n    LIGHT_DIR = normalize(vec3(cos(iTime), -sin(iTime), -0.5)); \n    \n    for (uint i = 1u; i < SPHERE_COUNT; i++) {\n        spheres[i].z += 0.5 * cos(float(i) * 456.0 + iTime) + 0.5;\n    }\n}\n\nvec3 calcpixel(vec2 uv) {\n    // setup ray dir, norm vector >\n    vec3 camera_x = normalize(cross(camera_dir, camera_up));\n    // setup ray dir, norm vector ^\n    vec3 camera_y = normalize(cross(camera_x, camera_dir));\n    // final ray dir\n    vec3 ray_dir = normalize(camera_dir * AR + camera_x * uv.x + camera_y * uv.y);\n    \n    // cast ray\n    vec3 hit, hit_norm;\n    vec3 light = light_ray(camera, ray_dir, hit, hit_norm);\n    \n    // cast reflection ray\n    vec3 reflect_dir = reflect(ray_dir, hit_norm);\n    disturb(reflect_dir);\n    vec3 reflect_hit, reflect_norm;\n    vec3 reflection = light_ray(hit, reflect_dir, reflect_hit, reflect_norm);\n    \n    // cast reflection reflection ray\n    vec3 rreflect_dir = reflect(reflect_dir, reflect_norm);\n    disturb(rreflect_dir);\n    vec3 rreflect_hit, rreflect_norm;\n    vec3 rreflection = light_ray(reflect_hit, rreflect_dir, rreflect_hit, rreflect_norm);\n    \n    // I'm bored and my fps is still too high\n    vec3 rrreflect_dir = reflect(rreflect_dir, rreflect_norm);\n    disturb(rrreflect_dir);\n    vec3 rrreflect_hit, rrreflect_norm;\n    vec3 rrreflection = light_ray(rreflect_hit, rrreflect_dir, rrreflect_hit, rrreflect_norm);\n    \n\n    // assemble\n    return light + (reflection + (rreflection + rrreflection * REFLECT) * REFLECT) * REFLECT;\n}\n\nconst uint AA = 2u;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup scene parameters\n    setup();\n    \n    \n    vec3 color = vec3(0.);\n    for (uint i = 0u; i < AA; i++) {\n        for (uint j = 0u; j < AA; j++) {\n            // setup screen coord system. up = (0, 1), down = (0, -1), right = (AR, 0), left = (-AR, 0)\n            vec2 coord = fragCoord + vec2(i, j) / float(AA);\n            vec2 uv = (coord - iResolution.xy * 0.5) / iResolution.y;\n\n            color += calcpixel(uv);\n        }\n    }\n    color /= float(AA * AA);\n    \n    // gamma correct and write to output\n    fragColor = vec4(pow(color, vec3(1. / 2.2)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[931, 950, 973, 973, 1027], [1029, 1094, 1118, 1118, 1223], [1225, 1276, 1330, 1330, 2382], [2384, 2384, 2454, 2475, 2980], [3051, 3093, 3107, 3107, 3469], [3471, 3471, 3496, 3532, 4774], [4797, 4797, 4854, 4884, 5431]], "test": "timeout"}
{"id": "tdXyzM", "name": "Menger--cylinder--v1", "author": "jorge2017a1", "description": "Menger--cylinder--v1", "tags": ["mengercylinderv1"], "likes": 2, "viewed": 34, "published": "Public", "date": "1584367986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat pathterrain(float x,float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\n\nfloat pathterrainv2(float x , float y, float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3+y\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.33;\n\t\n    \n    float sdc1=  sdCylinder( p-vec3(0.0,2.0,0.0) , vec2(3.0,8.0) );\n    float sdc2=  sdCylinder( p-vec3(0.0,1.0,0.0) , vec2(2.0,10.0) );\n    float dif1=differenceSDF(sdc1, sdc2);\n    float dist =dif1;\n    \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(1.0+cos(time), 0.25, 1.0+ 1.0*sin(time));\n    \n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 524, 524, 555], [557, 557, 588, 588, 679], [682, 682, 705, 705, 842], [844, 844, 874, 874, 1011], [1061, 1061, 1130, 1209, 1250], [1252, 1252, 1334, 1334, 1565], [1567, 1567, 1627, 1627, 1768], [1817, 1817, 1853, 1853, 1956], [1958, 2013, 2036, 2036, 2171], [2173, 2173, 2199, 2199, 2256], [2258, 2258, 2298, 2298, 2332], [2335, 2335, 2371, 2422, 2517], [2522, 2522, 2571, 2622, 2719], [2723, 2723, 2759, 2759, 2846], [2849, 2849, 2896, 2896, 2929], [2931, 2931, 2956, 2956, 2971], [2973, 3002, 3020, 3020, 3411], [3471, 3471, 3500, 3500, 3688], [3690, 3690, 3731, 3731, 3907], [3909, 3909, 3950, 3950, 4102], [4104, 4104, 4125, 4125, 4255], [4257, 4257, 4284, 4284, 4534], [4536, 4536, 4593, 4593, 5061]], "test": "ok"}
{"id": "tdXyzr", "name": "GridExploration", "author": "antoinefortin", "description": "Grid Exploration", "tags": ["crossbox"], "likes": 4, "viewed": 109, "published": "Public", "date": "1584026138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\nfloat simpleShape(vec3 pos)\n{\n\t\n    vec3 q = pos;\n\t\n    q.xz = mod(q.xz + .3, .6) -.3;\n    \n    q.y = mod(q.y + .64, 1.28) -.64;\n    \n    \n    q.y -= 0.15;\n\tfloat d = sdBox(q, vec3(0.25));\n    float r = 0.;\n   \n    \n    \n\tfloat d2 = sdBox(q, vec3(0.295, 0.295 , .0125 ));\n\tfloat d3 =  sdBox(q, vec3(0.295 , .0125 ,0.295 ));\n    q.x += .125;\n    float d4 = sdBox(q , vec3(.0125, 0.295,0.295 ));\n    \n    \n    \n    \n   \n    \n    float d5 = sdBox(q, vec3(.0125, 0.295,0.295 ));\n    \n    \n    float d6 = sdBox(q , vec3(.0125, 0.295,0.295 ));\n    \n    \n    //q.x = mod(q.x+ 0.0125, .25) - 0.0125;\n    \n    \n    \n    \n    \n\tr += max(-d, min(d2,min(d3, min(d4, min(d5, d6)))));\n    \n        \n    \n    \n    \n\n    \n\treturn r * .5;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n\tfloat d =simpleShape(q);\n    float d2 = pos.y - (-0.25);\n    \n    return min(d, d2);\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 100.0) break;\n        \n    }\n    \n    if(t > 100.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\t/*\nvec3 ro = vec3(0.0,0.0,1.0);\n   vec3 rd = normalize(vec3(p, -1.5));\n\t*/\n \n\n\n    \n    // Camera Look at\n    \n    float an = iTime * .05 ;\n    vec3 ro = vec3((2. + iTime) + sin(an), 0.75, -1. + cos(an * 8.));\n    \n\tfloat cameraZoom = 2.5;\n\tvec3 target = vec3(1., 12., 11.);\n\t\n\tvec3 ww = normalize(target - ro);\n\tvec3 uu = normalize(cross(ww, vec3(0.,1.,0.)));\n\tvec3 vv = normalize(cross(uu, ww));\n    \n\tvec3 rd = normalize(p.x * uu + p.y * vv + cameraZoom * ww);\n\n    // Rendering part\n\tfloat t = castRay(ro, rd);\n    \n    \tvec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n    if(t > 0.)\n    {\n        \n        vec3 baseMat = vec3(0.001, 0.015, .092) - 0.7 * rd.y;\n            vec3 pos = ro + t * rd;\n            vec3 nor = calcNormal(pos);\n            vec3 sunPosition = vec3(abs(sin(iTime)) * 2.,  1. + abs(cos(iTime)),.9);\n            vec3 sundir = normalize(sunPosition);\n            vec3 mate = vec3(.29);\n// From IQ live stream in the yellow jumping guy\n\n            float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n            float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n            float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);\n            float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\n            col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n            col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n            col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n        \t//col -= baseMat;\n        \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 119], [121, 121, 156, 156, 180], [184, 184, 213, 213, 907], [909, 909, 930, 930, 1041], [1043, 1043, 1076, 1076, 1381], [1383, 1383, 1410, 1410, 1622], [1624, 1624, 1681, 1731, 3369]], "test": "timeout"}
{"id": "tdy3zD", "name": "Raytracer #3 -- TheRealJoe", "author": "TheRealJoe24", "description": "I think i have finally made a good raytracer! Used in reflections contest.", "tags": ["raytracing"], "likes": 3, "viewed": 59, "published": "Public", "date": "1584146154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T_FAR 1000.\n\n#define LIGHT_DIR   0\n#define LIGHT_POINT 1\n#define LIGHT_AMB   2\n\nconst vec3 BACKGROUND_COL = vec3(0.2,0.2,0.5);\n\nstruct HitData {\n    float t1;\n\tfloat t2;\n\tvec3 p1;\n    vec3 p2;\n    vec3 n;\n    bool hit;\n};\n    \nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Sphere {\n\tvec3 c;\n    float r;\n    vec3 col;\n    float specular;\n    float reflective;\n    float alpha;\n};\n    \nstruct Light {\n\tvec3 p;\n    float intensity;\n    int type;\n};\n\nmat3 rotateX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n    \t1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nSphere nullSphere = Sphere(vec3(0),0.,BACKGROUND_COL,0.,0.,0.);\n    \nHitData iSphere(Ray r, Sphere sphere) {\n\tHitData data;\n\tvec3 co = r.o-sphere.c;\n    float a = dot(r.d,r.d);\n    float b = 2.*dot(r.d,co);\n    float c = dot(co,co) - sphere.r*sphere.r;\n    float delta = b*b - 4.*a*c;\n    if (delta < 0.) data.hit = false;\n    else {\n        data.t1 = (-b-sqrt(delta)) / (2.*a);\n        data.t2 = (-b+sqrt(delta)) / (2.*a);\n        data.p1 = r.o + data.t1*r.d;\n        data.n = normalize(data.p1-sphere.c);\n\t\tdata.hit = true;\n    }\n    return data;\n}\n\nSphere traceSingleRay(Ray r, out HitData o_hitData) {\n\tSphere spheres[3] = Sphere[3](\n    \tSphere(vec3(1.5,0,5),1.,vec3(1,0,0),200.,0.,1.),\n        Sphere(vec3(-1.5,0,5),1.,vec3(1,1,1),100.,0.,1.),\n        Sphere(vec3(0,-5001,1),5000.,vec3(1,0,1),-1.,0.6,1.)\n    );\n    Sphere hitSphere = nullSphere;\n    float t = T_FAR;\n    o_hitData = HitData(T_FAR,T_FAR,vec3(0),vec3(0),vec3(0),false);\n    for (int i = 0; i < spheres.length(); i++) {\n    \tSphere sphere = spheres[i];\n        HitData hitData = iSphere(r,sphere);\n        if (hitData.hit && hitData.t1 < t && hitData.t1 > 0.001) {\n        \tt = hitData.t1;\n            o_hitData = hitData;\n            hitSphere = sphere;\n        }\n        \n        /*if (hitData.hit && hitData.t2 < t && hitData.t2 > 0.001) {\n        \tt = hitData.t2;\n            o_hitData = hitData;\n            hitSphere = sphere;\n        }*/\n    }\n    return hitSphere;\n}\n\nfloat computeLighting(vec3 p, vec3 n, vec3 rd, float specular, Sphere sphere) {\n\tfloat intensity = 0.;\n    \n    Light lights[3] = Light[3](\n    \tLight(vec3(1,2,5),0.5,LIGHT_POINT),\n        Light(vec3(1,0,-1),0.25,LIGHT_DIR),\n\t\tLight(vec3(0),0.25,LIGHT_AMB)\n    );\n    \n    for (int i = 0; i < lights.length(); i++) {\n    \tLight light = lights[i];\n        if (light.type != LIGHT_AMB) {\n            vec3 l;\n            if (light.type == LIGHT_POINT)\n            \tl = normalize(light.p-p);\n            else if (light.type == LIGHT_DIR)\n                l = light.p;\n            \n            HitData shadowData;\n            Sphere shadowSphere = traceSingleRay(Ray(p,normalize(p-light.p)),shadowData);\n            //if (!shadowData.hit || sphere != shadowSphere || light.type == LIGHT_DIR) {\n                float d = clamp(dot(n,l),0.,1.);\n                if (d > 0.)\n                    intensity += light.intensity*d/(length(n)*length(l));\n\n                if (specular != -1.) {\n                    vec3 r = 2.*n*dot(n,l) - l;\n                    d = dot(r,-rd);\n                    if (d > 0.)\n                        intensity += light.intensity*pow(d/(length(r)*length(-rd)),specular);\n                }\n            //}\n        } else {\n        \tintensity += light.intensity;\n        }\n    }\n    \n    return intensity;\n}\n\nvec3 traceReflection(Ray ray, HitData hitData, Sphere hitSphere) {\n\tvec3 col = vec3(0);\n    float r = 0.;\n    float rlight = 1.;\n    Sphere reflectedSphere;\n    for (int i = 0; i < 1; i++) {\n    \tray.d = reflect(ray.d,hitData.n);\n        Ray ref = Ray(hitData.p1,ray.d);\n        HitData refHitData;\n        reflectedSphere = traceSingleRay(ref,refHitData);\n        if (reflectedSphere.reflective <= 0. && reflectedSphere != nullSphere) {\n        \trlight = computeLighting(refHitData.p1, refHitData.n, ref.d, reflectedSphere.specular, hitSphere);\n            //col += hitSphere.col*(1.-hitSphere.reflective)+(reflectedSphere.col*hitSphere.reflective*rlight);\n            r += hitSphere.reflective;\n            if (hitSphere.alpha >= 1.)\n                col = hitSphere.col*computeLighting(hitData.p1, hitData.n, ref.d, hitSphere.specular, hitSphere)*(1.-r)+(reflectedSphere.col*r*rlight);\n            else\n                col = BACKGROUND_COL;\n            if (reflectedSphere.reflective <= 0.) break;\n            hitSphere = reflectedSphere;\n            hitData = refHitData;\n    \t}\n    }\n    return col;\n}\n\nmat3 rotateY(float a) {\n\treturn mat3(\n    \tcos(a), 0, sin(a),\n        0, 1, 0, \n        -sin(a), 0, cos(a)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = BACKGROUND_COL;\n    //vec3 col = texture(iChannel0,uv).xyz;\n    \n    vec3 ro = vec3(cos(iTime)*5.,1,sin(iTime)*5.+5.);\n    //vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv,1))*rotateX(sin(iTime*0.5)*0.2)*rotateY(-3.14/2.-iTime);\n    Ray r = Ray(ro,rd);\n    HitData hitData;\n    Sphere hitSphere = traceSingleRay(r,hitData);\n    \n    if (hitData.hit) {\n        if (hitSphere.reflective > 0.) {\n            //col = traceReflection(r,hitData,hitSphere);\n            col = vec3(0);\n            float r = 0.;\n            float rlight = 0.;\n            Sphere reflectedSphere;\n            for (int i = 0; i < 1; i++) {\n                rd = reflect(rd,hitData.n);\n                Ray ref = Ray(hitData.p1,rd);\n                HitData refHitData;\n                reflectedSphere = traceSingleRay(ref,refHitData);\n                float rlight = 1.;\n                if (reflectedSphere.reflective <= 0. && reflectedSphere != nullSphere)\n                    rlight = computeLighting(refHitData.p1, refHitData.n, ref.d, reflectedSphere.specular, hitSphere);\n                //col += hitSphere.col*(1.-hitSphere.reflective)+(reflectedSphere.col*hitSphere.reflective*rlight);\n                r += hitSphere.reflective;\n                if (hitSphere.alpha >= 1.)\n                \tcol = hitSphere.col*computeLighting(hitData.p1, hitData.n, ref.d, hitSphere.specular, hitSphere)*(1.-r)+(reflectedSphere.col*r*rlight);\n                else\n                \tcol = BACKGROUND_COL;\n                if (reflectedSphere.reflective <= 0.) break;\n                hitSphere = reflectedSphere;\n                hitData = refHitData;\n            }\n        } else if (hitSphere.alpha < 1.) {\n            Ray ref = Ray(hitData.p2,refract(rd,hitData.n,0.2));\n            HitData refHitData;\n        \tSphere refractedSphere = traceSingleRay(ref,refHitData);\n            if (refHitData.hit)\n            \tcol = refractedSphere.col*computeLighting(hitData.p1, hitData.n, r.d, hitSphere.specular, hitSphere);\n        }\n        else {\n            float light = computeLighting(hitData.p1, hitData.n, r.d, hitSphere.specular, hitSphere);\n            col = hitSphere.col*light;\n        }\n    }\n    \n    //if (fragCoord.x > iResolution.x/2.-1. && fragCoord.x < iResolution.x/2.+1.) col = vec3(1,0,0);\n\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 489, 489, 615], [686, 686, 725, 725, 1167], [1169, 1169, 1222, 1222, 2062], [2064, 2064, 2143, 2143, 3387], [3389, 3389, 3455, 3455, 4494], [4496, 4496, 4519, 4519, 4611], [4613, 4613, 4670, 4670, 7050]], "test": "error"}
{"id": "tlGSRd", "name": "Raymarching in modulo space", "author": "leocaus", "description": "Raymarching in modulo spaces", "tags": ["rm"], "likes": 2, "viewed": 59, "published": "Public", "date": "1583449180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int MAX_STEPS = 1000;\nfloat SURF_DIST = .01;\nfloat MAX_DIST = 1000.;\nvec3 modv = vec3(8., 8., 8.);\n\n\nvec3 world2modSpace(vec3 p){\n\t\n    \n    if(modv.x > 0.){\n    \tp.x = mod(p.x-modv.x/2., modv.x)-modv.x/2.;\n    }\n    \n    if(modv.y > 0.){\n    \tp.y = mod(p.y-modv.y/2., modv.y)-modv.y/2.;\n    }\n    \n    if(modv.z > 0.){\n    \tp.z = mod(p.z-modv.z/2., modv.z)-modv.z/2.;\n    }\n    \n    \n\treturn p;\n}\n\nvec3 world2cellSpace(vec3 p){\n\t\n    vec3 i = vec3(0);\n    \n    if(modv.x > 0.){\n    \ti.x = floor((p.x+modv.x/2.)/modv.x);\n    }\n    if(modv.y > 0.){\n    \ti.y = floor((p.y+modv.y/2.)/modv.y);\n    }\n    if(modv.z > 0.){\n    \ti.z = floor((p.z+modv.z/2.)/modv.z);\n    }\n    \n    \n\treturn i;\n}\n\nvec3 rotateVec3(vec3 v, float thet, float phi){\n\tvec3 v1 = vec3(v.x*cos(thet)-v.y*sin(thet), v.x*sin(thet)+v.y*cos(thet), v.z);\n    \n    return vec3(v1.x*cos(phi)-v1.z*sin(phi), v1.y , v1.x*sin(phi)+v1.z*cos(phi));\n}\n\nfloat distToSphere(vec3 p, vec3 sc, float r){\n    vec3 D = p-sc;\n    float L = length(D);   \n    return L-r;\n}\n\nfloat getDist(vec3 p){\n    p = world2modSpace(p);\n    \n\tfloat dS1 = distToSphere(p, vec3 (0.,0.,0.), 1.);\n\t//float dS1 = 100.;\n    float dS2 = distToSphere(p, vec3 (1.5*cos(iTime),1.5*sin(iTime),0.), 1.0);\n    return min(dS1,min(1000.,1000.));\n}\n\nvec3 getNormal(vec3 p){\n    \n    float d = getDist(p);\n\t\n    vec3 n = vec3(0.);\n    vec2 e = vec2(.01,0.);\n    \n    if(d < 2.*SURF_DIST){\n    \tn = d - vec3(getDist(p-e.xyy),getDist(p-e.yxy),getDist(p-e.yyx));\n        n = normalize(n);\n    }\n\treturn n;\n}\n\nfloat RayMarch(vec3 rp, vec3 rd){\n\t\n    float dO = 0.;\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n    \tvec3 p = rp+rd*dO;\n        float d = getDist(p);\n        \n        dO += d;\n        \n        if(dO > MAX_DIST || d < SURF_DIST) break;\n        \n    }\n  \t\n    return dO;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{ \n    float t = iTime;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/(iResolution.x*0.5);\n    vec3 cp = vec3(t,3.,3.);\n    vec3 cd = normalize(vec3(1.0, 0.2*cos(t/5.), 0.2*sin(t/5.)));\n    vec3 cu = normalize(vec3(0.,0.,1.));\n    \n    float fov = 45.*3.1415/360.;\n    float dov = 1./tan(fov);\n    \n    vec3 cx = normalize(cross(cu, cd));\n    vec3 cy = normalize(cross(cd, cx));\n    \n    vec3 rd = normalize(dov*cd+uv.x*cx+uv.y*cy);\n    \n    float d = RayMarch(cp, rd);\n    \n    vec3 n = getNormal(cp+rd*d);\n\t\n    vec3 i = world2cellSpace(cp+rd*d);\n    \n    // Output to screen\n    fragColor = vec4(abs(rotateVec3(n, length(i)+t ,length(i)+t)),1.);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 129, 129, 397], [399, 399, 428, 428, 687], [689, 689, 736, 736, 905], [907, 907, 952, 952, 1017], [1019, 1019, 1041, 1041, 1264], [1266, 1266, 1289, 1289, 1519], [1521, 1521, 1554, 1554, 1793], [1796, 1796, 1852, 1852, 2505]], "test": "ok"}
{"id": "tlGXWG", "name": "Pore Torus", "author": "PauloFalcao", "description": "A very simple test generated in materialmaker in 1 minute with some custom nodes.\nhttps://twitter.com/paulofalcao/status/1235750994081992705\nThe displace is based on the base SDF normal.", "tags": ["displace", "generated", "materialmaker", "nodes", "everythingmaker"], "likes": 7, "viewed": 405, "published": "Public API", "date": "1583460968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pore Torus\n// By PauloFalcao\n//\n// A very simple test generated in materialmaker in 1 minute\n// MaterialMaker is a nodebased shader maker to make texture, but with some custom nodes, \n// created directly in the tool, it's possible to make complex stuff like raymarching :)\n\n\nmat2 rot(float r){\n  float s=sin(r);float c=cos(r);\n  return mat2(c,-s,s,c);\n}\n\nfloat wave3d_constant(float x) {\n\treturn 1.0;\n}\n\nfloat wave3d_sine(float x) {\n\treturn 0.5-0.5*cos(3.14159265359*2.0*x);\n}\n\nfloat wave3d_triangle(float x) {\n\tx = fract(x);\n\treturn min(2.0*x, 2.0-2.0*x);\n}\n\nfloat wave3d_sawtooth(float x) {\n\treturn fract(x);\n}\n\nfloat wave3d_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat wave3d_bounce(float x) {\n\tx = 2.0*(fract(x)-0.5);\n\treturn sqrt(1.0-x*x);\n}\n\nfloat mix3d_mul(float x, float y, float z) {\n\treturn x*y*z;\n}\n\nfloat mix3d_add(float x, float y, float z) {\n\treturn min(x+y+z, 1.0);\n}\n\nfloat mix3d_max(float x, float y, float z) {\n\treturn max(max(x, y), z);\n}\n\nfloat mix_min(float x, float y, float z) {\n\treturn min(min(x, y), z);\n}\n\nfloat mix3d_xor(float x, float y, float z) {\n\tfloat xy = min(x+y, 2.0-x-y);\n\treturn min(xy+z, 2.0-xy-z);\n}\n\nfloat mix3d_pow(float x, float y, float z) {\n\treturn pow(pow(x, y), z);\n}vec4 o354278_p_SkyColor_gradient_fct(float x) {\n  if (x < 0.000000000) {\n    return vec4(0.793357015,0.864655972,0.979166985,1.000000000);\n  } else if (x < 0.118182000) {\n    return mix(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000), mix(vec4(0.793357015,0.864655972,0.979166985,1.000000000), vec4(0.510612011,0.698400021,1.000000000,1.000000000), (x-0.000000000)/0.118182000), 1.0-0.5*(x-0.000000000)/0.118182000);\n  } else if (x < 0.411598000) {\n    return 0.5*(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000) + mix(mix(vec4(0.793357015,0.864655972,0.979166985,1.000000000), vec4(0.510612011,0.698400021,1.000000000,1.000000000), (x-0.000000000)/0.118182000), mix(vec4(0.287342012,0.329521000,0.557291985,1.000000000), vec4(0.171140000,0.209502995,0.416667014,1.000000000), (x-0.411598000)/0.533857000), 0.5-0.5*cos(3.14159265359*(x-0.118182000)/0.293416000)));\n  } else if (x < 0.945455000) {\n    return mix(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000), mix(vec4(0.287342012,0.329521000,0.557291985,1.000000000), vec4(0.171140000,0.209502995,0.416667014,1.000000000), (x-0.411598000)/0.533857000), 0.5+0.5*(x-0.411598000)/0.533857000);\n  }\n  return vec4(0.171140000,0.209502995,0.416667014,1.000000000);\n}\nfloat o354282_input_in1(vec3 p) {\nvec2 o354281_0_q = vec2(length((p).xz)-0.610000000,(p).y);\nfloat o354281_0_1_sdf3d = length(o354281_0_q)-0.360000000;\n\nreturn o354281_0_1_sdf3d;\n}\nvec3 normal_o354282(vec3 p) {\n\tfloat d = o354282_input_in1(p);\n    vec2 e = vec2(.001,0);\n    vec3 n = d - vec3(\n        o354282_input_in1(p-vec3(e.xyy)),\n        o354282_input_in1(p-vec3(e.yxy)),\n        o354282_input_in1(p-vec3(e.yyx)));\n    return normalize(n);\n}\n\nfloat o354283_fct(vec3 uv) {\n\treturn mix3d_mul(wave3d_sine(8.000000000*uv.x), wave3d_sine(8.000000000*uv.y), wave3d_sine(8.000000000*uv.z));\n}float o354278_input_sdf_a(vec3 p) {\nvec3 o354283_0_1_color3d = vec3(o354283_fct(((p)).xyz));\n\nvec3 n=normal_o354282((p));\nfloat o354282_0_in = o354282_input_in1((p)+((n*(o354283_0_1_color3d-0.5))*0.134000000));float o354282_0_1_sdf3d = max(o354282_input_in1((p))-0.134000000,o354282_0_in/((0.134000000+0.2)*10.0));\n\nreturn o354282_0_1_sdf3d;\n}\nvec4 o354284_p_g_gradient_fct(float x) {\n  if (x < 0.000000000) {\n    return vec4(1.000000000,0.906248987,0.000000000,1.000000000);\n  } else if (x < 0.079855277) {\n    return mix(mix(vec4(1.000000000,0.468750000,0.000000000,1.000000000), vec4(0.000000000,0.000000000,1.000000000,1.000000000), (x-0.079855277)/0.343188719), mix(vec4(1.000000000,0.906248987,0.000000000,1.000000000), vec4(1.000000000,0.468750000,0.000000000,1.000000000), (x-0.000000000)/0.079855277), 1.0-0.5*(x-0.000000000)/0.079855277);\n  } else if (x < 0.423043997) {\n    return 0.5*(mix(vec4(1.000000000,0.468750000,0.000000000,1.000000000), vec4(0.000000000,0.000000000,1.000000000,1.000000000), (x-0.079855277)/0.343188719) + mix(mix(vec4(1.000000000,0.906248987,0.000000000,1.000000000), vec4(1.000000000,0.468750000,0.000000000,1.000000000), (x-0.000000000)/0.079855277), mix(vec4(0.000000000,0.000000000,1.000000000,1.000000000), vec4(0.000000000,0.000000000,0.000000000,1.000000000), (x-0.423043997)/0.576956003), 0.5-0.5*cos(3.14159265359*(x-0.079855277)/0.343188719)));\n  } else if (x < 1.000000000) {\n    return mix(mix(vec4(1.000000000,0.468750000,0.000000000,1.000000000), vec4(0.000000000,0.000000000,1.000000000,1.000000000), (x-0.079855277)/0.343188719), mix(vec4(0.000000000,0.000000000,1.000000000,1.000000000), vec4(0.000000000,0.000000000,0.000000000,1.000000000), (x-0.423043997)/0.576956003), 0.5+0.5*(x-0.423043997)/0.576956003);\n  }\n  return vec4(0.000000000,0.000000000,0.000000000,1.000000000);\n}\nvec3 o354278_input_tex3d_a(vec3 p) {\np.xz*=rot(iTime*0.5);\nvec3 o354283_0_1_color3d = vec3(o354283_fct(((p)).xyz));\nvec3 o354284_0_1_color3d = o354284_p_g_gradient_fct(dot(o354283_0_1_color3d, vec3(1.0))/3.0).rgb;\n\nreturn o354284_0_1_color3d;\n}\nfloat o354278_input_sdf_b(vec3 p) {\n\nreturn ((p)).y+1.0;\n}\nvec3 o354278_input_tex3d_b(vec3 p) {\n\nreturn (vec3(mod(floor(((p)).x)+floor(((p)).z),2.0))*0.25+0.5);\n}\nvec2 input_o354278(vec3 p) {\n    p.xz*=rot(iTime*0.5);\n    float sdfa=o354278_input_sdf_a(p);\n\tfloat sdfb=o354278_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\nvec3 normal_o354278(vec3 p) {\n\tfloat d = input_o354278(p).x;\n    vec2 e = vec2(.001,0);\n    vec3 n = d - vec3(\n        input_o354278(p-vec3(e.xyy)).x,\n        input_o354278(p-vec3(e.yxy)).x,\n        input_o354278(p-vec3(e.yyx)).x);\n    return normalize(n);\n}\n\nvoid march_o354278(out float d,out vec3 p,out vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o354278(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o354278( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = input_o354278( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o354278( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o354278( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 raymarch_o354278(vec2 uv) {\n    vec3 cam=vec3(1.250000000+sin(iTime*0.25)*0.5,1.400000000+cos(iTime*0.2)*0.5,1.500000000);\n\tvec3 lookat=vec3(0.000000000,0.000000000,0.000000000);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,-1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*1.000000000+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o354278(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o354278_input_tex3d_a(p):o354278_input_tex3d_b(p);\n\tfloat fog=max(1.0-(d/50.0),0.0);\n\tvec3 light=normalize(vec3(0.950000000,1.200000000,0.400000000));\n\tif (d<50.0) {\n\t    vec3 n=normal_o354278(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tfloat r=clamp(dot(reflect(rd,-n),light),0.0,1.0);\n\t\tfloat cAO=calcAO_o354278(p,n);\n\t\tfloat shadow=calcSoftshadow_o354278(p,light,0.05,5.0);\n\t\tcolor=min(vec3(max(shadow,0.200000000)),max(l,0.200000000))*max(cAO,0.200000000)*objColor+pow(r,200.000000000)*0.850000000;\n\t} else {\n\t    color=o354278_p_SkyColor_gradient_fct(rd.y).xyz;\n\t}\n    return color*(fog)+o354278_p_SkyColor_gradient_fct(rd.y).xyz*(1.0-fog);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 UV = fragCoord/iResolution.xy-0.5;\nUV.x*=iResolution.x/iResolution.y;\nvec4 o354278_0_d = vec4(raymarch_o354278((UV)),1.0);\n\nvec4 o354278_0_1_rgba = o354278_0_d*1.3;\nfragColor = o354278_0_1_rgba;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 296, 296, 356], [358, 358, 390, 390, 405], [407, 407, 435, 435, 479], [481, 481, 513, 513, 561], [563, 563, 595, 595, 615], [617, 617, 647, 647, 687], [689, 689, 719, 719, 769], [771, 771, 815, 815, 832], [834, 834, 878, 878, 905], [907, 907, 951, 951, 980], [982, 982, 1024, 1024, 1053], [1055, 1055, 1099, 1099, 1161], [1163, 1163, 1207, 1207, 1236], [1236, 1236, 1283, 1283, 2733], [2734, 2734, 2767, 2767, 2914], [2915, 2915, 2944, 2944, 3181], [3183, 3183, 3211, 3211, 3325], [3325, 3325, 3360, 3360, 3668], [3669, 3669, 3709, 3709, 5159], [5160, 5160, 5196, 5196, 5404], [5405, 5405, 5440, 5440, 5463], [5464, 5464, 5500, 5500, 5567], [5568, 5568, 5596, 5596, 5782], [5784, 5784, 5813, 5813, 6042], [6044, 6044, 6117, 6117, 6280], [6282, 6327, 6376, 6376, 6644], [6646, 6691, 6775, 6775, 7093], [7096, 7096, 7128, 7128, 8254], [8257, 8257, 8312, 8312, 8514]], "test": "timeout"}
{"id": "tlGXzc", "name": "lambda rasterizer", "author": "JentGent", "description": "This is just a rasterizer.", "tags": ["3d", "rasterizer", "rendering", "renderer"], "likes": 2, "viewed": 99, "published": "Public", "date": "1583242640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// PI\nconst float PI = 3.14159265358979323;\n\n// Distance\nfloat dist(float x, float y, float x2, float y2) {\n    return sqrt((x2-x)*(x2-x) + (y2-y)*(y2-y));\n}\n\n// Output color\nvec3 c = vec3(0.0);\n\n// Depth Buffer\nfloat db = 10000.0;\n\n// Traditional Rasterizer approach\nvoid triRaster(float x, float y, float z, float x2, float y2, float z2, float x3, float y3, float z3, vec3 color) {\n    float xPix = gl_FragCoord.x;\n    float yPix = gl_FragCoord.y;\n\n    x -= iResolution.x / 2.0;\n    y -= iResolution.y / 2.0;\n    x2 -= iResolution.x / 2.0;\n    y2 -= iResolution.y / 2.0;\n    x3 -= iResolution.x / 2.0;\n    y3 -= iResolution.y / 2.0;\n    x /= z / 100.0;\n    y /= z / 100.0;\n    x2 /= z2 / 100.0;\n    y2 /= z2 / 100.0;\n    x3 /= z3 / 100.0;\n    y3 /= z3 / 100.0;\n    x += iResolution.x / 2.0;\n    y += iResolution.y / 2.0;\n    x2 += iResolution.x / 2.0;\n    y2 += iResolution.y / 2.0;\n    x3 += iResolution.x / 2.0;\n    y3 += iResolution.y / 2.0;\n\n    if(xPix < min(x, min(x2, x3)) || xPix > max(x, max(x2, x3)) || yPix < min(y, min(y2, y3)) || yPix > max(y, max(y2, y3))) {\n        return;\n    }\n\n    float lambda = (xPix - x2) * (y3 - y2) - (yPix - y2) * (x3 - x2);\n    float lambda2 = (xPix - x3) * (y - y3) - (yPix - y3) * (x - x3);\n    float lambda3 = (xPix - x) * (y2 - y) - (yPix - y) * (x2 - x);\n    if(!(lambda > 0.0 && lambda2 > 0.0 && lambda3 > 0.0) && !(lambda < 0.0 && lambda2 < 0.0 && lambda3 < 0.0)) {\n        return;\n    }\n    float area = (x3 - x) * (y2 - y) - (y3 - y) * (x2 - x);\n    float zPix = (lambda * z + lambda2 * z2 + lambda3 * z3) / area;\n    if(zPix <= 0.0 || zPix > db) {\n        return;\n    }\n    db = zPix;\n    vec3 normal = normalize(cross(vec3(x3, y3, z3) - vec3(x2, y2, z2), vec3(x, y, z) - vec3(x2, y2, z2)));\n    if(normal.z < 0.0) {\n        normal = -normal;\n    }\n    float shade = max(dot(normal, vec3(1.0, -1.0, 1.0)), 0.0);\n    c = color * clamp(shade, 0.1, 1.0);\n}\n\n// Rotate\nvec3 yRotate(float theta, float x, float y, float z, float x2, float z2) {\n    x -= x2;\n    z -= z2;\n    float rotation = atan(z / x) + theta;\n    float distance = dist(x, z, 0.0, 0.0);\n    return vec3(x2 + cos(rotation) * distance, y, z2 + sin(rotation) * distance);\n}\nvec3 xRotate(float theta, float x, float y, float z, float y2, float z2) {\n    y -= y2;\n    z -= z2;\n    float rotation = atan(z / y) + theta;\n    float distance = dist(y, z, 0.0, 0.0);\n    return vec3(x, y2 + cos(rotation) * distance, z2 + sin(rotation) * distance);\n}\nvec3 zRotate(float theta, float x, float y, float z, float y2, float x2) {\n    y -= y2;\n    x -= x2;\n    float rotation = atan(x / y) + theta;\n    float distance = dist(x, y, 0.0, 0.0);\n    return vec3(x2 + cos(rotation) * distance, y2 + sin(rotation) * distance, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 backRight = yRotate(iTime, 100.0, 0.0, 50.0, 0.0, 0.0);\n    vec3 backLeft = yRotate(iTime, -100.0, 0.0, 50.0, 0.0, 0.0);\n    vec3 frontRight = yRotate(iTime + PI, 100.0, 0.0, 50.0, 0.0, 0.0);\n    vec3 frontLeft = yRotate(iTime + PI, -100.0, 0.0, 50.0, 0.0, 0.0);\n    triRaster(\n        150.0 + backRight.x, 100.0, 200.0 + backRight.z,\n        150.0 + backLeft.x, 100.0, 200.0 + backLeft.z,\n        150.0 + backLeft.x, 300.0, 200.0 + backLeft.z,\n        vec3(1.0, 0.0, 0.0)\n    );\n    triRaster(\n        150.0 + backLeft.x, 300.0, 200.0 + backLeft.z,\n        150.0 + backRight.x, 100.0, 200.0 + backRight.z,\n        150.0 + backRight.x, 300.0, 200.0 + backRight.z,\n        vec3(0.0, 0.0, 1.0)\n    );\n    triRaster(\n        150.0 + frontRight.x, 100.0, 200.0 + frontRight.z,\n        150.0 + frontLeft.x, 100.0, 200.0 + frontLeft.z,\n        150.0 + frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        vec3(1.0, 1.0, 0.0)\n    );\n    triRaster(\n        150.0 + frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        150.0 + frontRight.x, 100.0, 200.0 + frontRight.z,\n        150.0 + frontRight.x, 300.0, 200.0 + frontRight.z,\n        vec3(1.0, 0.0, 1.0)\n    );\n    triRaster(\n        150.0 + backRight.x, 100.0, 200.0 + backRight.z,\n        150.0 + frontLeft.x, 100.0, 200.0 + frontLeft.z,\n        150.0 + frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        vec3(1.0, 1.0, 1.0)\n    );\n    triRaster(\n        150.0 + frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        150.0 + backRight.x, 100.0, 200.0 + backRight.z,\n        150.0 + backRight.x, 300.0, 200.0 + backRight.z,\n        vec3(0.0, 1.0, 0.0)\n    );\n    triRaster(\n        150.0 + frontRight.x, 100.0, 200.0 + frontRight.z,\n        150.0 + backLeft.x, 100.0, 200.0 + backLeft.z,\n        150.0 + backLeft.x, 300.0, 200.0 + backLeft.z,\n        vec3(0.0, 1.0, 1.0)\n    );\n    triRaster(\n        150.0 + backLeft.x, 300.0, 200.0 + backLeft.z,\n        150.0 + frontRight.x, 100.0, 200.0 + frontRight.z,\n        150.0 + frontRight.x, 300.0, 200.0 + frontRight.z,\n        vec3(1.0, 0.6, 0.6)\n    );\n\n    triRaster(\n        250.0 - backRight.x, 100.0, 200.0 + backRight.z,\n        250.0 - backLeft.x, 100.0, 200.0 + backLeft.z,\n        250.0 - backLeft.x, 300.0, 200.0 + backLeft.z,\n        vec3(1.0, 0.0, 0.0)\n    );\n    triRaster(\n        250.0 - backLeft.x, 300.0, 200.0 + backLeft.z,\n        250.0 - backRight.x, 100.0, 200.0 + backRight.z,\n        250.0 - backRight.x, 300.0, 200.0 + backRight.z,\n        vec3(0.0, 0.0, 1.0)\n    );\n    triRaster(\n        250.0 - frontRight.x, 100.0, 200.0 + frontRight.z,\n        250.0 - frontLeft.x, 100.0, 200.0 + frontLeft.z,\n        250.0 - frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        vec3(1.0, 1.0, 0.0)\n    );\n    triRaster(\n        250.0 - frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        250.0 - frontRight.x, 100.0, 200.0 + frontRight.z,\n        250.0 - frontRight.x, 300.0, 200.0 + frontRight.z,\n        vec3(1.0, 0.0, 1.0)\n    );\n    triRaster(\n        250.0 - backRight.x, 100.0, 200.0 + backRight.z,\n        250.0 - frontLeft.x, 100.0, 200.0 + frontLeft.z,\n        250.0 - frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        vec3(1.0, 1.0, 1.0)\n    );\n    triRaster(\n        250.0 - frontLeft.x, 300.0, 200.0 + frontLeft.z,\n        250.0 - backRight.x, 100.0, 200.0 + backRight.z,\n        250.0 - backRight.x, 300.0, 200.0 + backRight.z,\n        vec3(0.0, 1.0, 0.0)\n    );\n    triRaster(\n        250.0 - frontRight.x, 100.0, 200.0 + frontRight.z,\n        250.0 - backLeft.x, 100.0, 200.0 + backLeft.z,\n        250.0 - backLeft.x, 300.0, 200.0 + backLeft.z,\n        vec3(0.0, 1.0, 1.0)\n    );\n    triRaster(\n        250.0 - backLeft.x, 300.0, 200.0 + backLeft.z,\n        250.0 - frontRight.x, 100.0, 200.0 + frontRight.z,\n        250.0 - frontRight.x, 300.0, 200.0 + frontRight.z,\n        vec3(1.0, 0.6, 0.6)\n    );\n\n    triRaster(\n        135.0, 256.0, 150.0,\n        37.0, 153.0, 100.0,\n        375.0, 100.0, 150.0,\n        vec3(0.5, 0.5, 1.0)\n    );\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 103, 153, 153, 203], [279, 314, 429, 429, 1953], [1955, 1965, 2039, 2039, 2234], [2235, 2235, 2309, 2309, 2504], [2505, 2505, 2579, 2579, 2774], [2776, 2776, 2831, 2831, 6811]], "test": "ok"}
{"id": "tlKSDG", "name": "Snow forest biome", "author": "jarble", "description": "This map resembles a snowy forest interspersed by mountains and rivers.", "tags": ["fractal", "map", "biome"], "likes": 1, "viewed": 237, "published": "Public API", "date": "1583521135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint forest_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int FOREST_GREEN = 4;\n    int WHITE = 5;\n    return (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW)\n        ? GREEN\n    :(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors))\n        ? FOREST_GREEN\n    :(color1 == GRAY && is_next_to(GREEN,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? FOREST_GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :color1;\n\n}\n\nint savanna_biome(inout int color1, ivec4 neighbors){\n    int GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int YELLOW = 3;\n    int FOREST_GREEN = 4;\n    return (color1 == GREEN && is_next_to(GRAY,neighbors))\n    \t? YELLOW\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n    \t? FOREST_GREEN\n    :(color1 == GRAY)\n        ? GREEN\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    : color1;\n}\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nint swamp_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int WHITE = 4;\n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n    \t? YELLOW\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == GRAY && is_next_to(YELLOW,neighbors))\n        ? YELLOW\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nint forests_and_mountains(inout int color1, ivec4 neighbors){\n    int BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int WHITE = 4;\n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n    \t? YELLOW\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == GRAY && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = (biome == FORESTS_AND_MOUNTAINS)\n        ? forests_and_mountains(color1,neighbors)\n    : (biome == GLACIER_BIOME) ?\n        glacier_biome(color1,neighbors)\n    : (biome == SWAMP_BIOME) ?\n        forests_and_mountains(color1,neighbors)\n    : (biome == SAVANNA_BIOME) ?\n    \tsavanna_biome(color1,neighbors)\n    : (biome == FOREST_BIOME) ?\n    \tforest_biome(color1,neighbors)\n    : color1;\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[6],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\nint forest_biome(in vec2 fragCoord,float mag,float zoom,int[6] colors){\n    return biome(fragCoord,mag,zoom,colors,FOREST_BIOME);\n}\n\nint forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SAVANNA_BIOME);\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\nint swamp_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SWAMP_BIOME);\n}\n\nint swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nint water_biome(in vec2 fragCoord,float mag,float zoom,int colors[2]){\n    float num_colors = float(colors.length());\n    int color1 = magnify(fragCoord,mag,num_colors);\n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,num_colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return colors[color1];\n}\n\nint water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,int[](GREEN,BLUE));\n}\t\n\n\n\nint forests_and_mountains(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,FORESTS_AND_MOUNTAINS);\n}\n\nint forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nint combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    int color1 = forest_biome(fragCoord,mag,mag/81.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,int[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,int[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nint combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    int color1 = glacier_biome(fragCoord,mag,mag/81.0,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    return (color1 == GRAY)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE))\n    :(color1 == WHITE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE))\n    :(color1 == GREEN)\n   \t\t? forests_and_mountains(fragCoord,mag,zoom,int[](BLUE,SKYBLUE,SNOW,GRAY,WHITE))\n    :(color1 == BLUE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE))\n    : color1;\n}\n\nint deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    int color1 = glacier_biome(fragCoord,mag,mag/81.0,int[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n    return (color1 == GRAY)\n    \t? forest_biome(fragCoord,mag,zoom,int[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME))\n    :(color1 == WHITE)\n    \t? forest_biome(fragCoord,mag,zoom,int[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME))\n    :(color1 == YELLOW)\n    \t? forest_biome(fragCoord,mag,zoom,int[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME))\n    :(color1 == GREEN)\n   \t\t? forests_and_mountains(fragCoord,mag,zoom,int[](TAN,LIME,SNOW,GRAY,YELLOW))\n    :(color1 == BLUE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE))\n    :color1;\n}\n\nint combined_biome(in vec2 fragCoord,float mag,float zoom){\n    int color1 = glacier_biome(fragCoord,mag,mag/729.0);\n    return color1 == FOREST_GREEN\n    \t? forest_biome(fragCoord,mag,zoom)\n    : color1 == WHITE\n    \t? glacier_biome(fragCoord,mag,zoom)\n    : color1 == GRAY\n    \t? savanna_biome(fragCoord,mag,zoom)\n    : color1 == GREEN\n    \t? forests_and_mountains(fragCoord,mag,zoom)\n    : color1 == BLUE\n    \t? savanna_biome(fragCoord,mag,zoom,int[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE))\n    : color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tint biome =\n        forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        //combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1044], [1050, 1050, 1105, 1105, 1168], [1170, 1170, 1229, 1229, 1434], [1437, 1437, 1480, 1480, 1616], [1618, 1618, 1652, 1652, 1681], [1683, 1683, 1709, 1709, 3066], [3069, 3069, 3121, 3121, 3747], [3749, 3749, 3802, 3802, 4250], [4252, 4252, 4305, 4305, 4979], [4981, 4981, 5032, 5032, 5557], [5559, 5559, 5620, 5620, 6289], [6291, 6291, 6347, 6347, 6749], [6751, 6751, 6826, 6826, 7163], [7165, 7165, 7240, 7240, 7577], [8691, 8691, 8761, 8761, 9218], [12478, 12478, 12535, 12535, 13056]], "test": "error"}
{"id": "tlKSWy", "name": "Melting glaciers", "author": "jarble", "description": "This fractal looks like a melting glacier.", "tags": ["fractal", "glacier"], "likes": 2, "viewed": 214, "published": "Public API", "date": "1583526627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //p += vec2(sin(p.x),sin(p.y))*p;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n\tint biome = glacier_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 647, 684, 778, 926], [932, 932, 987, 987, 1050], [1052, 1052, 1111, 1111, 1316], [1319, 1319, 1362, 1362, 1498], [1500, 1500, 1534, 1534, 1563], [1565, 1565, 1591, 1591, 2666], [2669, 2669, 2722, 2722, 3396], [3398, 3398, 3454, 3454, 3510], [3512, 3512, 3587, 3587, 3924], [4204, 4204, 4261, 4261, 4468]], "test": "error"}
{"id": "tlKSz3", "name": "MyGrids", "author": "Arseny", "description": "sex", "tags": ["2d"], "likes": 5, "viewed": 273, "published": "Public API", "date": "1583278130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circGrid(vec2 uv, float offset, float blur){\n    vec2 lv = fract(uv);\n    lv -= 0.5;\n    return 1. - smoothstep(0., blur, abs(length(lv) - (0.5 - offset - blur)));\n}\n\nfloat polargreed(vec2 uv){\n    float ans = 0.;\n    float len = length(uv);\n    if (len < 0.1){\n        return 0.;\n    }\n    vec2 pv1 = vec2(atan(uv.y, uv.x) / 6.2831 + 0.5 + pow(len, 0.5) / 5., len);\n    //float m = min(fract(x), fract(1. - x));\n    //ans = smoothstep(0., 0.1, m * 0.5 + .2 - pv.y);\n    float m;\n    float dst = abs(fract(pv1.x * 23.) - 0.5) * 2.;\n    dst = min(dst, abs(fract(pow(len, 0.7) * 7. + iTime) - 0.5) * 2.);\n    //m = fract(pv1.x * 23.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    //m = fract(sqrt(len) * 7.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    ans = dst;//max(ans, 1. - smoothstep(0., 0.1, dst));\n    return ans;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    vec3 col = vec3(0);\n    col = vec3(polargreed(uv));\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 171], [173, 173, 199, 199, 870], [872, 872, 929, 979, 1261]], "test": "ok"}
{"id": "tlVXDd", "name": "tunel-cuarto-v1", "author": "jorge2017a1", "description": "tunel-cuarto-v1", "tags": ["tunelcuartov1"], "likes": 2, "viewed": 52, "published": "Public", "date": "1583931624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---10-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.  //100.0\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    \n    \n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n  \n   //p.z = mod(p.z, 2.0)-1.0;\n   \n   float sdwx= wallx(p);\n   float sdwy= wally(p); \n   //float sdwz= wallz(p);\n   \n    \n   res=opU(res, vec2(sdwx,8));\n   res=opU(res, vec2(sdwy,13));\n   //res=opU(res, vec2(sdwz,22));\n    \n   pp =p;\n   pp.z=mod(pp.z , 20.0)-30.0;\n    \n   float sdc1=  sdCylinder(pp-vec3(12,-5.0,-28.), vec2(2.1,20.0) );\n   float sdc2=  sdCylinder(pp-vec3(-12,-5.0,-28.), vec2(2.1,20.0) );\n   res=opU(res, vec2(sdc1,21));\n   res=opU(res, vec2(sdc2,24));\n\n  \tvec3 pp2=p;\n    pp2.z=mod(pp.z , 20.0)-10.0;\n\tfloat sdb1= sdBox(pp2- vec3(1.,-10.0,-10.), vec3(3.0,3.0,3.0) );\n    //float sds1= sdSphere( p-vec3(0.0,-15.0,-2.0), 1.5 );\n    //res=opU(res, vec2(sdb1,6));\n   // res=opU(res, vec2(sds1,24));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        \n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n\t}        \n    \t\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n  \n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t//vec3 surfaceColor3 = vec3(0.45,0.54,1.0);  \n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    \n  for(int  i = 0; i < 3; i++)\n  {\n    //float nearest = RayMarch(p + dir*dist);\n    float nearest = RayMarch(ro, rd);  \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = ro+rd*dist;\n      \n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n    //ro=ro+rd*EPS;\n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    \n   \n    vec3 ro = vec3(0 ,5 ,-10.0-iTime*5.0);\n\tvec3 rd=normalize(vec3(uv,-1.));    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t//  vec3 rLuz=vec3(0.5, 3.5, 4.5.);\n    vec3 rLuz=ro+vec3(0,2.0,-10.0);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    //float dif = GetLightv2(p);\n    float dif = GetLightPar(p,rLuz);\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    \t\n    \n    vec3 pixelColour = Render(ro, rd,colobj, rLuz);\n    \n    //////////col = (dif)*colobj; col = pow(col, vec3(1.0/2.2));  \n    col= pixelColour*dif+result;\n    col= pixelColour+result*dif*1.1;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 484, 517, 517, 582], [583, 601, 637, 637, 706], [707, 722, 753, 753, 903], [904, 924, 960, 960, 1047], [1048, 1064, 1096, 1124, 1185], [1187, 1187, 1223, 1223, 1326], [1329, 1403, 1461, 1461, 1725], [1727, 1727, 1772, 1772, 1863], [1865, 1865, 1947, 1947, 2178], [2181, 2181, 2212, 2212, 2400], [2403, 2457, 2479, 2479, 3739], [3742, 3806, 3842, 3842, 4115], [4167, 4167, 4213, 4213, 4245], [4247, 4247, 4290, 4290, 4322], [4324, 4324, 4372, 4372, 4405], [4408, 4408, 4437, 4437, 4563], [4565, 4565, 4601, 4601, 4718], [4720, 4720, 4756, 4756, 4874], [4877, 4877, 4913, 4913, 5036], [5089, 5101, 5123, 5123, 5431], [5432, 5458, 5483, 5483, 5673], [5674, 5719, 5736, 5736, 5809], [5812, 5845, 5871, 5871, 6068], [6115, 6115, 6167, 6167, 6322], [6387, 6496, 6533, 6533, 6568], [6570, 6570, 6589, 6589, 6664], [6713, 6713, 6736, 6736, 6762], [6764, 6764, 6787, 6787, 6925], [6928, 6928, 6950, 6950, 7020], [7085, 7085, 7111, 7111, 7168], [7170, 7170, 7190, 7190, 7248], [7251, 7251, 7272, 7272, 7522], [7525, 7525, 7557, 7557, 7642], [7644, 7644, 7680, 7680, 7869], [7870, 7870, 7897, 7897, 8312], [8421, 8448, 8469, 8469, 8535], [8537, 8537, 8559, 8559, 8614], [8616, 8616, 8637, 8637, 8692], [8694, 8694, 8715, 8715, 8770], [8834, 8834, 8853, 8853, 8897], [8899, 8899, 8942, 8942, 10492], [10495, 10544, 10569, 10569, 11580], [11583, 11583, 11617, 11617, 11986], [11991, 11991, 12015, 12015, 12247], [12251, 12251, 12275, 12275, 12667], [12670, 12670, 12696, 12696, 13060], [13063, 13063, 13101, 13101, 13458], [13461, 13461, 13486, 13486, 13514], [13516, 13516, 13568, 13568, 13964], [14067, 14111, 14128, 14128, 14199], [14224, 14316, 14341, 14341, 14604], [14663, 14663, 14691, 14691, 21635], [21637, 21685, 21786, 21820, 22330], [22336, 22382, 22435, 22435, 23624], [23627, 23676, 23733, 23733, 25094]], "test": "error"}
{"id": "tlVXzd", "name": "gradient conical ", "author": "Artleet", "description": "gradient conical ", "tags": ["gradient", "conical"], "likes": 6, "viewed": 200, "published": "Public", "date": "1583469105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I(i) fragColor[i]=c(sin(vec2(2.,3.5)*(iTime*.5-.01*float(i)))*.5,u);\n\nfloat c(vec2 f, vec2 u){  \t\n    float c = dot(f,f), b = -2.*dot(u-=f,f);\n    return (b-sqrt(b*b-4.*dot(u,u)*--c))/c/2.;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 u,l = iResolution.xy;\n    u = fragCoord/l.y*2.-1.;\n    u.x -= l.x/l.y*.5;\n    I(0) I(1) I(2)\n    fragColor = 0.05/fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 102, 102, 201]], "test": "timeout"}
{"id": "tlySDV", "name": "Not Day 79", "author": "jeyko", "description": "hm", "tags": ["mdtmjvm"], "likes": 67, "viewed": 2416, "published": "Public API", "date": "1583601981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sorry I changed the shader, I just really don't like the one original day 79.\n// I've commented the old one if you would like to see it.\n\n// So this is actually Day 110\n\n#define tsp iTime + 1.1\n\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.29;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*1.;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n    \n    vec3 k = p;\n    p -= path(p.z);\n    \n    \n    p.z *= 0.5;\n    \n    \n    vec3 par = vec3(2.8,2.14,0.9);\n    vec4 q = vec4(p.xyz, 1.);\n    \n    \n    for(float i = 0.; i < 9.;i++){\n        q.xyz = abs(mod(q.xyz - par*0.5,par) - 0.5*par);\n        \n    \tfloat dpp = dot(q.xyz, q.xyz);\n        \n        q.xy *= rot(0.4);\n        q = q/dpp;\n    }\n    \n    float dF = length(q.xz)/q.w;\n    d.x = min(d.x, dF);\n    \n    d.x = opSmoothIntersection( d.x, -length(p.xy) + 0.36 , 0.4 );\n    \n    d.x -= 0.04;\n    d.x = abs(d.x) + 0.003;\n    glow -= 0.1/(0.001 + d.x*d.x*200.);\n    \n    \n    \n    float dL = length(q.zx)/q.w;\n\n    d.x = max(d.x,  -length(p.xy) + 0.2 );\n    \n    d.x *= 0.45;\n    \n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.; hit = false;\n    \n    for(float i = 0.; i < 150.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001 + 0.001*5.0*pow(float(i)/200.0,2.0);\n        if(d.x < eps){\n            t += 0.005;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= rot(sin(iTime*0.5)*0.6);\n    \n    uv *= 1. - dot(uv,uv)*.1;\n    \n    dith = mix(0.95,1.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)/256.).x);\n    \n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    ro.z += iTime*1.7 + 0.1;\n    \n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    vec3 rd = getRd(ro, lookAt,uv);\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += glow*0.001;\n    \n    vec3 fc = pal(0.6,0.5,vec3(1.,0.5,0.6) + cos(rd.xyz)*1., 1.7  - dot(uv,uv)*0.2,-2.1 - dot(uv,uv)*0.2);\n    fc = max(fc,0.);\n    col = mix(col,fc, smoothstep(0.,1.,t*0.1));\n    \n    fragColor = vec4(col,1.0);\n}\n\n// The following comment is Day 79\n\n/*\n\n\n// Made shader having not slept for 2 days (was in a game jam) \n// in like 30 minutes. \n// not really something I thought about or put much effort in. \n\n#define pmod(p,x) (mod(p,x) - 0.5*x)\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin(tau*((c)*(d) + e)))\n\n#define coolPal(a,b) pal(0.5,0.6,vec3(0.97 + sin(iTime*0.02 + p.z*0.04),3.4 + sin(b)*0.2,0.8),0.4 + (a),3.3 + (b))\n#define tunnW 0.8\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define my (10.*iMouse.y/iResolution.x)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nvec3 glow = vec3(0);\nvec3 glowFog = vec3(0);\nvec3 glowCol = vec3(0);\n\n\nfloat sdSphere(vec3 p, float s){\n\treturn length(p) -s;\n}\nfloat sdBox(vec3 p, vec3 r){\n    p = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\n\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0, vec2(t)/256.),texture(iChannel0, vec2(t+1.)/256.),smoothstep(0.,1.,fract(t)));\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    p.xy *= rot(p.z*0.3);\n    vec3 z = p;\n    #define modDist 2.\n    \n    vec3 id = floor(p/modDist )- max(sign(vec3(p.x,p.y,p.z)), 0.);\n   \tp -= modDist*0.5;\n    \n    p = pmod(p , modDist);\n    \n    vec3 q = p;\n    \n    q = abs(q);\n    q -= modDist*0.5;\n    \n    for(int i = 0; i < 3; i++){\n    \n    \tq = abs(q);\n        q.x-= 0.1;\n        \n        q.xz *= rot(0.25*pi);\n        q.yz *= rot(0.25*pi);\n    }\n    \n    float cube = sdBox(q, vec3(0.5));\n    \n    //sph = fOpIntersectionStairs(sph, -length(p.xz) + 0.1,5.,0.1);\n    d = dmin(d, vec2(cube, 0.));\n    \n    float cubeWalls = cube - 0.06;\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.4,0.4,0.6)));\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.4,0.6,0.4)));\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.6,0.4,0.4)));\n    \n    d = dmin(d, vec2(cubeWalls, 2.));\n    \n    \n    \n    float ball = sdSphere(abs(p) - vec3(modDist*0.5,0,modDist*0.5),0.1);\n    d = dmin(d, vec2(ball, 1.));\n    \n    \n    vec4 n = valueNoise(id.x + id.z + iTime);\n    \n    vec3 c = pal(0.8,0.9,vec3(0.6,0.2+ abs(sin(z.x*0.5 +iTime*0.3))*0.6,0.5),0.4,3.7 + sin(z.z)*0.1);\n    c = max(c, 0.);\n    glow += min(exp(-max(ball, 0.)*6.)*4. * pow(n.x,5.)*40.*c, 3.);\n\n    \n    \n    // TUBE\n    \n    vec3 pC = vec3(atan(p.x,p.z)/tau,length(p.xz), p.y);\n    \n    pC.x = pmod(pC.x, 0.1);\n    \n    pC.y -= 1.05;\n    \n    pC.y += pow(smoothstep(0.,1.,abs(p.y)*0.8), 1.7)*0.8;\n    \n    //pC.y += pow(abs(p.y), 1.2);\n    \n    float glowTube = max(abs(pC.x),abs(pC.y)) - 0.01;\n    \n    glowTube = max(glowTube, -length(vec3(pC.x*3., pC.y - 0.02, pmod(pC.z, 0.3))) + 0.04);\n    //glowTube = max(glowTube, 0.);\n    glow += exp(-glowTube*190.)*max(pal(0.4,0.6,vec3(0.,0.5,0.7),0.8,0.7 + sin(p.z)), 0.)*3.;\n    \n    d = dmin(d,vec2(glowTube + 0.02, 0.));\n    \n    \n    d.x *= 0.5;\n    return d;\n}\n\nfloat N;\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    \n    \n\tfloat a = mix(0.8,1.,N); // remove banding from glow\n    \n    for(int i = 0; i < 150; i++){\n    \td = map(p)*a;\n        glowFog += exp(-d.x*50.);\n        if(d.x < 0.001 || t > 10.){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n    float fov = 1. + sin(iTime)*0.;\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tN = texture(iChannel0,(uv)*256.).x*1.;\n    uv *= 1. + dot(uv,uv)*0.25;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    vec3 lookAt = vec3(0);\n    \n    ro.z += iTime*1.;\n    lookAt.z = ro.z + 2.;\n    \n    ro.xz += vec2(\n    \tsin(iTime),\n    \tcos(iTime)\n    )*0.1;\n    \n    \n    \n    vec3 rd = getRd(ro, lookAt, uv);\n\n    //rd.xz *= rot(sin(0.5*pi*(floor(iTime*0.125) + pow(smoothstep(0.,1.,fract(iTime*0.125)), 2.5))));\n    float t; bool hit; vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if (hit){\n    \tvec3 n = getNormal(p);\n    \n        vec3 ld = normalize(vec3(1));\n        \n        //col += 0.7 + n;\n        float diff = max(dot(ro,ld), 0.);\n        float fres = pow(1. - max(dot(n,-rd), 0.), 5.);\n        float spec = pow(max(dot(n, normalize(ld - rd)), 0.), 20.);\n        \n            float ao = clamp(map(p + n*0.5).x/0.5,0.,1.);\n        if(d.y == 2.){\n        \tcol += min(diff*fres, 1.)*0.5*vec3(0.2,0.2,0.4);\n        \n        }\n        if(d.y == 0.){\n        \tcol += min(diff*fres, 1.)*0.4*vec3(0.4,0.3,0.62) + spec*vec3(0.4,0.,0.2)*0.1;\n        \t\n        }\n        \n        col *= ao*0.5 + 0.25;\n    }\n    \n    col += glow*0.01;\n    \n    col = mix(col, vec3(0.3,0.,0.6)*0.1, smoothstep(0.,1., t*0.12));\n    col += vec3(0.3,0.,0.1)*0.01*smoothstep(0.,1., t*0.12)*glowFog;\n    col = max(col, 0.);\n    col = col*0. + smoothstep(0.,1.,col)*0.8;\n    col = pow(col, vec3(0.4545 + dot(uv,uv)*0.15));\n    \n    \n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 459, 459, 521], [523, 523, 551, 551, 602], [605, 605, 657, 657, 756], [758, 758, 816, 816, 916], [918, 918, 977, 977, 1076], [1078, 1078, 1095, 1095, 1829], [1844, 1844, 1918, 1918, 2233], [2235, 2235, 2277, 2277, 2465], [2467, 2467, 2490, 2490, 2689], [2693, 2693, 2750, 2750, 3543]], "test": "error"}
{"id": "tlySzt", "name": "Rotating squares tunnel", "author": "ilyaev", "description": "Squares tunnel with some lights. Use mouse to change rotation angle.", "tags": ["shapes", "rotation", "layers"], "likes": 9, "viewed": 135, "published": "Public", "date": "1583348395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n#define PI 3.14159265359\n#define NUM_SQUARES 16.\n\nmat2 rotate2d(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat getRect(vec2 uv, float size, float scale) {\n    float d = distance(uv, vec2(clamp(-size, size, uv.x), clamp(-size,size, uv.y)));\n    return step(0.001 * scale, d) - step(0.01 * scale,d);\n}\n\nfloat getDot(vec2 uv, vec2 center) {\n    return smoothstep(.0, .35,.012/distance(uv, center)/10.);\n}\n\nfloat getBorder(vec2 uv, float size) {\n    float col = 0.;\n    col += getDot(uv, vec2(size));\n    col += getDot(uv, vec2(-size));\n    col += getDot(uv, vec2(size,-size));\n    col += getDot(uv, vec2(-size,size));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n\n\n    for(float i = 0. ; i < 1. ; i += 1./NUM_SQUARES) {\n        float shift = fract(iTime*6.)/NUM_SQUARES;\n        \n        float scale = mix(.1, 1. + sin(iTime)*0.5, i - shift);\n        \n        float fade = 1. - float(i);\n        \n        vec2 nuv = uv * scale * rotate2d((i - shift) * (mouse.x * PI*2.));\n        \n        float color = getRect(nuv, 0.1, scale) * fade;\n        \n        col += color * sin(vec3(0.9, 0.1, 0.9) + i*PI);\n        \n        vec3 borderColor = sin(vec3(0.9,0.3,0.9) + i*PI + iTime) + 0.5;\n        col += borderColor * getBorder(nuv, 0.1) * fade;\n    }\n\n\n\n    fragColor = vec4(col, 1.0) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 103, 103, 187], [189, 189, 238, 238, 383], [385, 385, 421, 421, 485], [487, 487, 525, 525, 716], [718, 718, 775, 775, 1529]], "test": "ok"}
{"id": "tlyXDc", "name": "dfgsdfgsdfg", "author": "lennyjpg", "description": "sdfgsfdgsdfg", "tags": ["grid", "random", "dots", "rotation"], "likes": 4, "viewed": 318, "published": "Public API", "date": "1583722776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / 20.0;\n    uv -= iTime * 0.3;\n    vec2 s = uv;\n    vec2 g  = fract(s) - 0.5;\n    float off = rand(ceil(s));\n    float z = rand(ceil(s))*0.5;\n    float dir = off - 0.5;\n    float speed = 1.0 + rand(s)*0.5;\n    float t = iTime * dir;\n    float angle = 1.1 + t*7.0 + off ;\n    g += vec2(sin(angle),cos(angle)) * 0.3;\n    float d = length(g)*2.5;\n    float w = (sin(z+t)+1.0)*0.24;\n    float e = 1.0-smoothstep(d,d+0.1,w);\n    fragColor = vec4(e);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 625]], "test": "ok"}
{"id": "tlyXWd", "name": "infinite book (218 chars)", "author": "FabriceNeyret2", "description": "could it be shorter ? :-)", "tags": ["2d", "2tweets", "gif", "short", "golf"], "likes": 10, "viewed": 267, "published": "Public API", "date": "1583846528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// readable version at bottom ;-)\n\nvoid mainImage(out vec4 O, vec2 U) {\n    for ( vec2 R = iResolution.xy, V = vec2(0,1), T, i=R-R, u;\n          i.x < 1.; i+=.05 )\n        T = fract( iTime/7. +i +.01*R.y / length( U -R*(V*.2-.1)) ),\n        O = max(O, 1.2 -.5*length(\n              min( R.y, dot( u = U - R*V* (.1-.1*T),\n                             T = sin( 1.57* ( exp(-8.*T) + V.yx ) )\n                 )         ) *T - u ));\n}/*\n\n\n\n\n\n// --- 224 chars\n\n#define mainImage(O,U)                                                 \\\n    for ( vec2 R = iResolution.xy, V = O.xw, a,T, i=R-R;               \\\n          i.x < 1.; i+=.05 )                                           \\\n        T = fract( iTime/7. +i +.01*R.y / length( U -R*(V/5.-.1)) ),   \\\n        a = R*V* (.1-.1*T),                                            \\\n        T = sin( 1.57* ( exp(-8.*T) + V.yx ) ),                        \\\n        O = max(O, 1.2 -.5*length( U-a - T * min( dot(U-a, T), R.y))) /*\n\n\n\n\n\n// --- 232 chars\n\n#define mainImage(O,U)                                                 \\\n    vec2 R = iResolution.xy, V = O.xw, a,b;                            \\\n    for (float T, i = 0.; i < 1.; i+=.05)                              \\\n        T = fract( iTime/7. +i +.01*R.y / length( U -R*vec2(-.1,.1)) ),\\\n        a = R* V*(.1-.1*T),                                            \\\n        b = sin(1.57*(exp(-8.*T)+V.yx)),                               \\\n        O = max(O, 1.2 -.5*length( U-a - b * min( dot(U-a, b), R.y))) /*\n\n\n\n\n\n// --- 258 chars\n\n#define mainImage(O,U)                                               \\\n    vec2 R = iResolution.xy;                                         \\\n    for (float T, i = 0.; i < 1.; i+=.05) {                          \\\n        T = fract( iTime/7. +i +.01*R.y/length(U-R*vec2(-.1,.1)) );  \\\n        vec2 a = R* vec2(0,.1-.1*T),                                 \\\n             p = U - a,                                              \\\n             b = R.y* cos(1.57*exp(-8.*T)+vec2(0,11)) - a;           \\\n        O = max(O, 1.2 -.5*length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.)));\\\n    } /*\n\n\n\n\n\n// --- 334 chars\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);                      \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R.y;\n    O-=O;\n    for (float T, i = 0.; i < 1.; i+=.05) {\n        T = fract(.15*iTime+i+.01/length(U));\n        O = max(O, smoothstep( 1., -1., R.y* line(U,vec2(0,.1*(1.-T)),cos(1.57*exp(-8.*T)+vec2(0,11)))-1.4));\n    }\n}\n\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 71, 71, 430]], "test": "timeout"}
{"id": "tlyXzc", "name": "PsycheTalk", "author": "Reva", "description": "Ex04", "tags": ["2d", "noise"], "likes": 5, "viewed": 96, "published": "Public", "date": "1583243373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author Reva - 2020-03-03\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos, float b){\n    return smoothstep(0.0,\n                      b*fract(iTime*0.6)*4.0,\n                      abs((sin(pos.x*noise(vec2(abs(pos.x)-iTime*0.3,pos.y*(mod(iTime,100.0)+700.0)*0.024)))))*0.900);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy;\n    vec2 pos = 10.*(fragCoord - .5*R)/R.y;\n    pos *= rotate2d( noise(pos)*.248 );\n\n    float pattern = lines(pos,.5);  \n    float col = mix(pattern, 1. - pattern, step(3.,mod(iTime,6.)));\n\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 190], [192, 274, 296, 296, 700], [701, 701, 728, 728, 810], [812, 812, 846, 846, 1040], [1042, 1042, 1098, 1098, 1346]], "test": "timeout"}
{"id": "tscSDs", "name": "Simple Ambient Occlusion", "author": "jorgemoag", "description": "test", "tags": ["ao"], "likes": 6, "viewed": 100, "published": "Public", "date": "1584794009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float p)\n{\n    return fract(sin(dot(vec2(p), vec2(12.9898, 78.233))) * 43758.5453);    \n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 pos) {\n\tfloat d = sdOctahedron(pos, 0.5);\n    \n    vec3 centers[4] = vec3[4](\n        vec3(0.4 + 0.2 * sin(2.0*iTime), 0.4 + 0.2 * sin(iTime), 0.0),\n\t\tvec3(-0.4 + 0.3 * cos(3.0*iTime), 0.4 + 0.2 * cos(1.5*iTime), 0.0),\n\t\tvec3(0.4 * cos(iTime), -0.4, 0.4 * sin(iTime)),\n\t\tvec3(-0.4, -0.4, 0.0)\n    );\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        float d2 = sdSphere(pos - centers[i], 0.2);\n        d = min(d, d2);\n    }\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.0001, 0.0);\n    float d = map(pos);\n    return normalize(vec3(\n        map(pos + eps.xyy) - d,\n        map(pos + eps.yxy) - d,\n        map(pos + eps.yyx) - d\n\t));\n}\n\nfloat ambientOcclusion(vec3 pos, float fallout)\n{\n    const int nS = 12; // number of samples\n    const float max_dist = 0.07;\n    vec3 N = calcNormal(pos);\n    \n    float diff = 0.0;\n    for (int i = 0; i < nS; ++i)\n    {        \n        float dist = max_dist * hash(float(i)); // rand len\n        float s_dist = max(0.0, map(pos + dist * N)); // sample\n        \n        diff += (dist - s_dist) / max_dist;\n    }\n    \n    float diff_norm = diff / float(nS);\n    float ao = 1.0 - diff_norm/fallout;\n    \n    return clamp(ao, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec2 mouse = iMouse.xy / iResolution.y;\n    \n    vec3 cam_pos = vec3(sin(3.0 * mouse.x), \n                        cos(3.0 * mouse.y),\n                        cos(3.0 * mouse.x));\n    \n    vec3 cam_target = vec3(0,0,0);\n    vec3 cam_ww = normalize(cam_target - cam_pos);\n    vec3 cam_uu = normalize(cross(cam_ww, vec3(0,1,0)));\n    vec3 cam_vv = normalize(cross(cam_uu, cam_ww));\n    \n    vec3 ro = cam_pos;\n    vec3 rd = normalize(p.x * cam_uu + p.y * cam_vv + 2.0 * cam_ww);\n    \n    float t = 0.0;\n   \tfor (int i = 0; i < 64; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if (h < 0.0001)\n        {\n            break;\n        }\n        t += h;\n        if (t > 20.0)\n        {\n            break;\n        }\n    }\n    \n    if (t < 20.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 N = calcNormal(pos);\n        float ao = ambientOcclusion(pos, 0.5);\n        col = vec3(ao) * (0.5 * N + 0.5);\n    }\n    \n    col = clamp(col, vec3(0.0), vec3(1.0));\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 100], [102, 177, 215, 215, 268], [270, 270, 303, 303, 331], [333, 333, 354, 354, 793], [795, 795, 822, 822, 1009], [1011, 1011, 1060, 1060, 1548], [1550, 1550, 1607, 1607, 2758]], "test": "timeout"}
{"id": "tsfcDB", "name": "Circuit[Experiment]", "author": "Arseny", "description": "procedural", "tags": ["procedural", "2d"], "likes": 4, "viewed": 214, "published": "Public API", "date": "1585518482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p) {\n   \treturn fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat getValue(vec2 id){\n   \treturn N21(id);\n}\n\nvec2 getMax(vec2 id){\n    vec2 ans = id;\n    for (float i = -1.; i < 2.; i++){\n        for (float j = -1.; j < 2.; j++){\n            ans = (getValue(id + vec2(i, j)) > getValue(ans)) ? id + vec2(i, j) : ans;\n        }\n    }\n    return ans;\n}\n\nvec2 upperbound(vec2 id){\n    vec2 ans = getMax(id);\n    for (float i = -1.; i < 2.; i++){\n        for (float j = -1.; j < 2.; j++){\n            float f = getValue(id + vec2(i, j));\n            ans = (f < getValue(ans) && f > getValue(id)) ? id + vec2(i, j) : ans;\n        }\n    }\n    return ans;\n}\n\nvec2 to(vec2 id){\n    /*if (fract(iTime) < 0.5){\n    \treturn getMax(id);\n    }*/\n    return upperbound(id);\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 gradient(float t){\n   \treturn mix(vec3(255., 237., 0.) / 256., vec3(0., 168., 107.) / 256., t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    \n    uv += vec2(iTime, iTime) / 20.;\n\n    vec2 id = floor(uv * 10.);\n    vec2 lv = (fract(uv * 10.) - 0.5) * 2.; // -1 to 1\n    \n    vec3 col = vec3(getValue(id));\n    \n\tcol = vec3(((to(id) - id) + vec2(1.)) * 0.5, 0);\n    col = vec3(\n        smoothstep(\n            0.,\n            0.1,\n            sdCapsule(\n                lv, \n                vec2(0, 0), \n                to(id) - id, \n                0.1\n            )\n        )\n    );\n    \n    for (float i = -1.; i < 2.; i++){\n        for (float j = -1.; j < 2.; j++){\n            vec2 v = id + vec2(i, j);\n            if (length(to(v) - id) < 0.01){\n                col = min(\n                    col, \n                \tvec3(\n                    \tsmoothstep(\n                            0.,\n                            0.1,\n                            sdCapsule(\n                                lv, \n                                vec2(0, 0), \n                                v - id,\n                                0.1\n                            )\n                        )\n                    )\n                );\n            }\n        }\n    }\n    \n    if (max(1. - abs(lv.x), 1. - abs(lv.y)) < 0.3){\n        col = vec3(\n            smoothstep(\n                0.,\n                0.1,\n                sdCapsule(\n                    lv, \n                    vec2(0, 0), \n                    to(id) - id, \n                    0.1\n                )\n            )\n        );\n        vec2 xd = (id + floor((lv - 1.) / 2. + 0.5));\n        for (float i = 0.; i < 1.9; i++){\n        for (float j = 0.; j < 1.9; j++){\n            vec2 v = xd + vec2(i, j);\n            vec2 opsit = xd + vec2(1. - i, 1. - j);\n            if (length(to(v) - opsit) < 0.01){\n                col = \n                \tvec3(\n                    \tsmoothstep(\n                            0.,\n                            0.1,\n                            sdCapsule(\n                                lv, \n                                vec2(0, 0), \n                                v - opsit,\n                                0.1\n                            )\n                        )\n                    );\n            }\n        }\n        }\n        fragColor = vec4(xd / 5., 0., 0.);\n        //fragColor = col;\n        //col = gradient(col.x);\n        //fragColor = vec4(col,1.0);\n        //return;\n    }\n    \n    //col.xy += id / 10.;\n    //col *= vec3(82., 204., 0.) / 256.;\n    col = gradient(col.x);\n    //col *= vec3(((to(id) - id) + vec2(1.)) * 0.5, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 70], [72, 72, 96, 96, 118], [120, 120, 141, 141, 361], [363, 363, 388, 388, 661], [663, 663, 680, 743, 772], [774, 774, 826, 826, 947], [949, 949, 972, 972, 1051], [1053, 1053, 1110, 1110, 3705]], "test": "timeout"}
{"id": "tsfcRj", "name": "Tux is Worried", "author": "dr2", "description": "Even penguins get the blues", "tags": ["amiga", "droste", "penguin", "pc", "recurrence"], "likes": 15, "viewed": 262, "published": "Public API", "date": "1585127401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Tux is Worried\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n The Amiga - probably the best PC of its era (and absolutely virus-free);\n Tux would have loved it.\n (Based on \"Amiga Recursion\")\n*/\n\n#define AA  0   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvoid PxInit ();\nvoid PxBgn (vec2 p);\nfloat PxText (vec2 p, int txt);\nfloat PxChar (vec2 p, vec4 c);\n\nmat3 vuMat;\nvec3 ltDir, pPos;\nvec2 sSize, cSpace;\nfloat dstFar, tCur, sMidHt, fAng, szFac, pRot;\nint idObj, nRec;\nconst int nRecMax = 5;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TuxDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  p /= szFac;\n  dMin /= szFac;\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMIN (11);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMIN (12);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMIN (13);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -1.05);\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  q.y -= -0.6;\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMIN (14);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMIN (15);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMIN (16);\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.35;\n  d = PrRoundBoxDf (q, vec3 (1., 0.16, 0.7), 0.01);\n  q = p - vec3 (0.7, 0.4, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.17, 0.01, 0.2)));\n  q.y -= -0.02;\n  d = max (d, - PrBoxDf (q, vec3 (0.08, 0.08, 0.03)));\n  q.y -= 0.01;\n  d = max (d, - PrBoxDf (q, vec3 (0.045, 0.05, 0.05)));\n  q = p;\n  q.yz -= vec2 (0.3, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (1.1, 0.01, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz -= vec2 (0.35, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.01, 0.17, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 1.;\n  q.yz -= vec2 (0.35, 0.05);\n  d = max (d, - PrBoxDf (q, vec3 (0.02, 0.007, 0.7)));\n  DMIN (1);\n  q = p;\n  q.x = abs (q.x) - 0.95;\n  q.y -= 0.09;\n  q.x -= 0.02 * q.y;\n  d = PrRoundBoxDf (q, vec3 (0.025 + 0.02 * q.y, 0.09, 0.6), 0.005);\n  q = p;\n  q -= vec3 (-0.05, 0.09, 0.3);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.9, 0.09, 0.02), 0.005));\n  DMIN (2);\n  q = p;\n  q.yz -= vec2 (0.55, 0.05);\n  q.xz = abs (q.xz) - vec2 (0.55, 0.4);\n  d = PrCylDf (q.xzy, 0.05, 0.05);\n  DMIN (3);\n  q = p;\n  q.yz -= vec2 (0.71 + sSize.y, -0.45);\n  d = 0.9 * max (PrRoundBoxDf (q, vec3 (sSize.x + 0.16, sSize.y + 0.12, 0.13), 0.03),\n     - PrRoundBox2Df (q.xy, sSize + 0.01, 0.03));\n  DMIN (4);\n  q = p - vec3 (0.7, 0.4, -0.55);\n  d = PrBoxDf (q, vec3 (0.16, 0.008, 0.16));\n  DMIN (5);\n  q = p;\n  h = sSize.y + 0.05 - 0.1 * (q.z - 0.05);\n  q.yz -= vec2 (0.6 + h, 0.05);\n  d = 0.9 * PrRoundBoxDf (q, vec3 (sSize.x + 0.12, h, 0.6), 0.03);\n  DMIN (6);\n  q = p - pPos;\n  q.xz = Rot2D (q.xz, pRot);\n  dMin = TuxDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ChqPat (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  if (2. * floor (ip.y / 2.) != ip.y) p.x += 0.5;\n  p = smoothstep (0., 0.1, abs (fract (p + 0.5) - 0.5));\n  return 0.98 + 0.02 * p.x * p.y;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 q;\n  float d;\n  if (rd.y >= 0.) col = vec3 (0.2, 0.3, 0.6) + 0.2 * pow (1. - rd.y, 5.);\n  else {\n    d = - ro.y / rd.y;\n    q = ro.xz + d * rd.xz;\n    col = mix (ChqPat (2. * q) * vec3 (0.8, 0.8, 0.9) * (0.8 + 0.2 * Fbm2 (128. * q)),\n       vec3 (0.4, 0.5, 0.8), 1. - min (1., exp2 (2. - 8. * d / dstFar)));\n    col *= 0.9 + 0.1 * smoothstep (0.25, 0.4, length (q - pPos.xz));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro)\n{\n  vec4 col4;\n  vec3 col, rd, roh, vn, q;\n  vec2 sb;\n  float dstObj, ao;\n  bool isBg, isScrn;\n  isBg = false;\n  isScrn = true;\n  for (int k = VAR_ZERO; k <= nRecMax; k ++) {\n    rd = normalize (vec3 (ro.xy, 7.));\n    if (k == 0) ro.xy = vec2 (0.);\n    ro.z -= 20. * sSize.y;\n    rd = vuMat * rd;\n    ro = vuMat * ro;\n    ro.y += sMidHt;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj >= dstFar) isBg = true;\n    else {\n      ro += dstObj * rd;\n      roh = ro;\n      if (idObj != 6) isScrn = false;\n      else {\n        ro.y -= sMidHt;\n        sb = abs (ro.xy) - sSize;\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5 && k < nRec);\n      } \n    }\n    if (! isScrn || isBg || k == nRec) break;\n  }\n  if (isBg) {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      roh = ro - (ro.y / rd.y) * rd;\n      if (length (roh.xz) < 2.) col *= ObjAO (roh, vec3 (0., 1., 0.));\n    }\n  } else {\n    col4 = vec4 (0.8, 0.81, 0.79, 0.);\n    PxInit ();\n    if (idObj < 11) {\n      if (idObj == 1) {\n        if (ro.z < -0.65) {\n          col4.rgb *= 1.2;\n          sb = ro.xy - vec2 (-0.82, 0.42);\n          sb.x -= 0.2 * sb.y;\n          if (PxText (sb * 260., 1) > 0.) col4 = vec4 (0.1);\n          else if (PxText ((ro.xy - vec2 (-0.75, 0.21)) * 240., 2) > 0.)\n             col4 = vec4 (0.1, 0.1, 0.8, 0.3);\n          else if (abs (abs (ro.x) - 0.9) < 0.02 && abs (ro.y - 0.3) < 0.008)\n             col4 = (ro.x < 0.) ? vec4 (0., 1., 0., -1.) : ((mod (0.33 * tCur, 1.) < 0.3) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0.4, 0.4, 0.4, 0.1));\n        }\n      } else if (idObj == 2) {\n        col4 *= 0.9;\n      } else if (idObj == 3) {\n        col4.rgb = vec3 (0.4, 0.3, 0.1);\n      } else if (idObj == 4) {\n        if (ro.z < -0.45) col4 *= 1.2;\n        if (ro.z < -0.6 && abs (ro.x) < sSize.x + 0.15 &&\n           abs (ro.y - sMidHt) < sSize.y + 0.11) col4 *= 0.8;\n      } else if (idObj == 5) {\n        col4.rgb = vec3 (0.1);\n      } else if (idObj == 6) {\n        if (length (ro.yz - vec2 (-0.4, -0.05)) < 0.15 &&\n           mod (ro.y + 0.4 - 0.01, 0.04) < 0.02) col4 *= 0.4;\n        else if (ro.z < -0.5) {\n          col4 = vec4 (0.1);\n          sb = (ro.xy - vec2 (0., 0.6 * sSize.y)) * 340.;\n          if (PxText (sb, 0) > 0.) col4 = vec4 (1., 0., 0., -1.);\n          else if (mod (tCur, 1.) < 0.5) {\n            ro.xy = (abs (sb - vec2 (0., -1.5) * cSpace) - vec2 (29., 7.) * cSpace);\n            if (max (ro.x, ro.y) < 1.25 &&\n               (min (abs (ro.x), abs (ro.y)) < 1.25)) col4 = vec4 (1., 0., 0., -1.);\n          }\n        }\n      }\n    } else {\n      if (idObj == 11) {\n        q = ro - pPos; \n        q.xz = Rot2D (q.xz, pRot);\n        col4 = (q.z < -0.6 * szFac || q.z < 0. && length (vec2 (abs (q.x) - 0.3 * szFac,\n           q.y - 2. * szFac)) < 0.2 * szFac) ? vec4 (0.9, 0.9, 0.9, 0.2) : vec4 (0.1, 0.1, 0.3, 0.1);\n      } else if (idObj == 12) col4 = vec4 (1., 0.8, 0.2, 0.2);\n      else if (idObj == 13) col4 = vec4 (0., 0.3, 0., 0.2);\n      else if (idObj == 14) col4 = vec4 (0.8, 0.8, 0., 0.1);\n      else if (idObj == 15) col4 = vec4 (0.9, 0.9, 0., 0.1);\n      else if (idObj == 16) col4 = vec4 (0.15, 0.15, 0.2, 0.1);\n    }\n    if (! isScrn) {\n      if (col4.a >= 0.) {\n        vn = ObjNf (roh);\n        ao = ObjAO (roh, vn);\n        if (idObj < 11) vn = VaryNf (128. * roh, vn, 0.2);\n        col = col4.rgb * (0.2 + 0.1 * max (0., - dot (vn, normalize (vec3 (ltDir.xz, 0.).xzy))) +\n           0.8 * ao * (max (0., dot (vn, ltDir)))) +\n           ao * col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      } else col = col4.rgb;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ut;\n  float el, az, zmFac, sr, ds;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  ut = abs (uv) - vec2 (1.33, 1.);\n  if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  else {\n    dstFar = 60.;\n    ltDir = normalize (vec3 (1., 3., -1.));\n    ds = SmoothBump (0.2, 0.8, 0.1, mod (0.043 * tCur, 1.));\n    az = -0.15 * pi * (2. * floor (mod (0.043 * tCur + 0.5, 2.)) - 1.) * (1. - ds);\n    el = -0.01 * pi * (1. - ds);\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += 0.7 * pi * mPtr.y;\n    }\n    az = clamp (az, -0.4 * pi, 0.4 * pi);\n    vuMat = StdVuMat (clamp (el, -0.4 * pi, 0.01 * pi), az);\n    sSize = 0.55 * vec2 (1.33, 1.);\n    sMidHt = 1.26;\n    pPos = vec3 (0.3, 0.35, -2.);\n    pRot = 1.3 * az;\n    szFac = 0.25;\n    fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n       sin (16. * pi * tCur);\n    nRec = int ((1. - abs (2. * mod (0.1 * tCur, 1.) - 1.)) * float (nRecMax + 1));\n    zmFac = 12. * sSize.y * ds;\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_spc  0\n#define g_exc  1\n#define g_quo  2\n#define g_hsh  3\n#define g_dol  4\n#define g_pct  5\n#define g_amp  6\n#define g_apo  7\n#define g_lbr  8\n#define g_rbr  9\n#define g_ast 10\n#define g_crs 11\n#define g_com 12\n#define g_dsh 13\n#define g_per 14\n#define g_lsl 15\n#define g_0   16\n#define g_1   17\n#define g_2   18\n#define g_3   19\n#define g_4   20\n#define g_5   21\n#define g_6   22\n#define g_7   23\n#define g_8   24\n#define g_9   25\n#define g_col 26\n#define g_scl 27\n#define g_les 28\n#define g_equ 29\n#define g_grt 30\n#define g_que 31\n#define g_ats 32\n#define g_A   33\n#define g_B   34\n#define g_C   35\n#define g_D   36\n#define g_E   37\n#define g_F   38\n#define g_G   39\n#define g_H   40\n#define g_I   41\n#define g_J   42\n#define g_K   43\n#define g_L   44\n#define g_M   45\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_Q   49\n#define g_R   50\n#define g_S   51\n#define g_T   52\n#define g_U   53\n#define g_V   54\n#define g_W   55\n#define g_X   56\n#define g_Y   57\n#define g_Z   58\n#define g_lsb 59\n#define g_rsl 60\n#define g_rsb 61\n#define g_pow 62\n#define g_usc 63\n#define g_a   64\n#define g_b   65\n#define g_c   66\n#define g_d   67\n#define g_e   68\n#define g_f   69\n#define g_g   70\n#define g_h   71\n#define g_i   72\n#define g_j   73\n#define g_k   74\n#define g_l   75\n#define g_m   76\n#define g_n   77\n#define g_o   78\n#define g_p   79\n#define g_q   80\n#define g_r   81\n#define g_s   82\n#define g_t   83\n#define g_u   84\n#define g_v   85\n#define g_w   86\n#define g_x   87\n#define g_y   88\n#define g_z   89\n#define g_lpa 90\n#define g_bar 91\n#define g_rpa 92\n#define g_tid 93\n#define g_lar 94\n\n#define C(g) s += PxChar (p, glph[g]);\n\n#define _spc C(g_spc)  \n#define _exc C(g_exc)\n#define _quo C(g_quo)\n#define _hsh C(g_hsh) \n#define _dol C(g_dol) \n#define _pct C(g_pct) \n#define _amp C(g_amp) \n#define _apo C(g_apo) \n#define _lbr C(g_lbr) \n#define _rbr C(g_rbr) \n#define _ast C(g_ast) \n#define _crs C(g_crs) \n#define _com C(g_com) \n#define _dsh C(g_dsh) \n#define _per C(g_per) \n#define _lsl C(g_lsl) \n#define _0   C(g_0) \n#define _1   C(g_1) \n#define _2   C(g_2) \n#define _3   C(g_3) \n#define _4   C(g_4) \n#define _5   C(g_5) \n#define _6   C(g_6) \n#define _7   C(g_7) \n#define _8   C(g_8) \n#define _9   C(g_9) \n#define _col C(g_col) \n#define _scl C(g_scl) \n#define _les C(g_les) \n#define _equ C(g_equ) \n#define _grt C(g_grt) \n#define _que C(g_que) \n#define _ats C(g_ats) \n#define _A   C(g_A) \n#define _B   C(g_B) \n#define _C   C(g_C) \n#define _D   C(g_D) \n#define _E   C(g_E) \n#define _F   C(g_F) \n#define _G   C(g_G) \n#define _H   C(g_H) \n#define _I   C(g_I) \n#define _J   C(g_J) \n#define _K   C(g_K) \n#define _L   C(g_L) \n#define _M   C(g_M) \n#define _N   C(g_N) \n#define _O   C(g_O) \n#define _P   C(g_P) \n#define _Q   C(g_Q) \n#define _R   C(g_R) \n#define _S   C(g_S) \n#define _T   C(g_T) \n#define _U   C(g_U) \n#define _V   C(g_V) \n#define _W   C(g_W) \n#define _X   C(g_X) \n#define _Y   C(g_Y) \n#define _Z   C(g_Z) \n#define _lsb C(g_lsb) \n#define _rsl C(g_rsl) \n#define _rsb C(g_rsb) \n#define _pow C(g_pow) \n#define _usc C(g_usc) \n#define _a   C(g_a) \n#define _b   C(g_b) \n#define _c   C(g_c) \n#define _d   C(g_d) \n#define _e   C(g_e) \n#define _f   C(g_f) \n#define _g   C(g_g) \n#define _h   C(g_h) \n#define _i   C(g_i) \n#define _j   C(g_j) \n#define _k   C(g_k) \n#define _l   C(g_l) \n#define _m   C(g_m) \n#define _n   C(g_n) \n#define _o   C(g_o) \n#define _p   C(g_p) \n#define _q   C(g_q) \n#define _r   C(g_r) \n#define _s   C(g_s) \n#define _t   C(g_t) \n#define _u   C(g_u) \n#define _v   C(g_v) \n#define _w   C(g_w) \n#define _x   C(g_x) \n#define _y   C(g_y) \n#define _z   C(g_z) \n#define _lpa C(g_lpa) \n#define _bar C(g_bar) \n#define _rpa C(g_rpa) \n#define _tid C(g_tid) \n#define _lar C(g_lar) \n\nvec4 glph[95];\nvec2 cPos;\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb;\n  float pOn, b;\n  p = floor (p - cPos);\n  if (min (p.x, p.y) >= 0. && max (p.x - 8., p.y - 12.) < 0.) {\n    b = 8. * (p.y + 1.) - (p.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  cPos.x += cSpace.x;\n  return pOn;\n}\n\nvoid PxBgn (vec2 p)\n{\n  cPos = floor (p * cSpace);\n}\n\nfloat PxText (vec2 p, int txt)\n{\n  float s;\n  s = 0.;\n  if (txt == 0) {\n    PxBgn (- vec2 (27., -1.));\n    _S _o _f _t _w _a _r _e _spc _F _a _i _l _u _r _e _per _spc _P _r _e _s _s _spc \n    _l _e _f _t _spc _m _o _u _s _e _spc _b _u _t _t _o _n _spc _t _o _spc \n    _c _o _n _t _i _n _u _e _per\n    PxBgn (- vec2 (17., 1.));\n    _G _u _r _u _spc _M _e _d _i _t _a _t _i _o _n _spc _hsh\n    _8 _2 _0 _1 _0 _0 _0 _3 _per _D _E _A _D _B _E _E _F\n    PxBgn (- vec2 (7., 5.));\n    _B _e _w _a _r _e _exc _spc _C _O _R _O _N _A _exc _exc \n  } else if (txt == 1) {\n    PxBgn (- vec2 (2., 0.));\n    _A _M _I _G _A\n  } else if (txt == 2) {\n    PxBgn (- vec2 (4., 0.));\n    _C _o _m _m _o _d _o _r _e\n   }\n  return s;\n}\n\nvoid PxInit ()\n{\n  glph[g_spc] = vec4 (0x000000, 0x000000, 0x000000, 0x000000);\n  glph[g_exc] = vec4 (0x003078, 0x787830, 0x300030, 0x300000);\n  glph[g_quo] = vec4 (0x006666, 0x662400, 0x000000, 0x000000);\n  glph[g_hsh] = vec4 (0x006C6C, 0xFE6C6C, 0x6CFE6C, 0x6C0000);\n  glph[g_dol] = vec4 (0x30307C, 0xC0C078, 0x0C0CF8, 0x303000);\n  glph[g_pct] = vec4 (0x000000, 0xC4CC18, 0x3060CC, 0x8C0000);\n  glph[g_amp] = vec4 (0x0070D8, 0xD870FA, 0xDECCDC, 0x760000);\n  glph[g_apo] = vec4 (0x003030, 0x306000, 0x000000, 0x000000);\n  glph[g_lbr] = vec4 (0x000C18, 0x306060, 0x603018, 0x0C0000);\n  glph[g_rbr] = vec4 (0x006030, 0x180C0C, 0x0C1830, 0x600000);\n  glph[g_ast] = vec4 (0x000000, 0x663CFF, 0x3C6600, 0x000000);\n  glph[g_crs] = vec4 (0x000000, 0x18187E, 0x181800, 0x000000);\n  glph[g_com] = vec4 (0x000000, 0x000000, 0x000038, 0x386000);\n  glph[g_dsh] = vec4 (0x000000, 0x0000FE, 0x000000, 0x000000);\n  glph[g_per] = vec4 (0x000000, 0x000000, 0x000038, 0x380000);\n  glph[g_lsl] = vec4 (0x000002, 0x060C18, 0x3060C0, 0x800000);\n  glph[g_0]   = vec4 (0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\n  glph[g_1]   = vec4 (0x001030, 0xF03030, 0x303030, 0xFC0000);\n  glph[g_2]   = vec4 (0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\n  glph[g_3]   = vec4 (0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\n  glph[g_4]   = vec4 (0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\n  glph[g_5]   = vec4 (0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\n  glph[g_6]   = vec4 (0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\n  glph[g_7]   = vec4 (0x00FEC6, 0xC6060C, 0x183030, 0x300000);\n  glph[g_8]   = vec4 (0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\n  glph[g_9]   = vec4 (0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\n  glph[g_col] = vec4 (0x000000, 0x383800, 0x003838, 0x000000);\n  glph[g_scl] = vec4 (0x000000, 0x383800, 0x003838, 0x183000);\n  glph[g_les] = vec4 (0x000C18, 0x3060C0, 0x603018, 0x0C0000);\n  glph[g_equ] = vec4 (0x000000, 0x007E00, 0x7E0000, 0x000000);\n  glph[g_grt] = vec4 (0x006030, 0x180C06, 0x0C1830, 0x600000);\n  glph[g_que] = vec4 (0x0078CC, 0x0C1830, 0x300030, 0x300000);\n  glph[g_ats] = vec4 (0x007CC6, 0xC6DEDE, 0xDEC0C0, 0x7C0000);\n  glph[g_A]   = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_B]   = vec4 (0x00FC66, 0x66667C, 0x666666, 0xFC0000);\n  glph[g_C]   = vec4 (0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\n  glph[g_D]   = vec4 (0x00F86C, 0x666666, 0x66666C, 0xF80000);\n  glph[g_E]   = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_F]   = vec4 (0x00FE66, 0x62647C, 0x646060, 0xF00000);\n  glph[g_G]   = vec4 (0x003C66, 0xC6C0C0, 0xCEC666, 0x3E0000);\n  glph[g_H]   = vec4 (0x00CCCC, 0xCCCCFC, 0xCCCCCC, 0xCC0000);\n  glph[g_I]   = vec4 (0x007830, 0x303030, 0x303030, 0x780000);\n  glph[g_J]   = vec4 (0x001E0C, 0x0C0C0C, 0xCCCCCC, 0x780000);\n  glph[g_K]   = vec4 (0x00E666, 0x6C6C78, 0x6C6C66, 0xE60000);\n  glph[g_L]   = vec4 (0x00F060, 0x606060, 0x626666, 0xFE0000);\n  glph[g_M]   = vec4 (0x00C6EE, 0xFEFED6, 0xC6C6C6, 0xC60000);\n  glph[g_N]   = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O]   = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P]   = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_Q]   = vec4 (0x00386C, 0xC6C6C6, 0xCEDE7C, 0x0C1E00);\n  glph[g_R]   = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S]   = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T]   = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n  glph[g_U]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCCCC, 0x780000);\n  glph[g_V]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCC78, 0x300000);\n  glph[g_W]   = vec4 (0x00C6C6, 0xC6C6D6, 0xD66C6C, 0x6C0000);\n  glph[g_X]   = vec4 (0x00CCCC, 0xCC7830, 0x78CCCC, 0xCC0000);\n  glph[g_Y]   = vec4 (0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n  glph[g_Z]   = vec4 (0x00FECE, 0x981830, 0x6062C6, 0xFE0000);\n  glph[g_lsb] = vec4 (0x003C30, 0x303030, 0x303030, 0x3C0000);\n  glph[g_rsl] = vec4 (0x000080, 0xC06030, 0x180C06, 0x020000);\n  glph[g_rsb] = vec4 (0x003C0C, 0x0C0C0C, 0x0C0C0C, 0x3C0000);\n  glph[g_pow] = vec4 (0x10386C, 0xC60000, 0x000000, 0x000000);\n  glph[g_usc] = vec4 (0x000000, 0x000000, 0x000000, 0x00FF00);\n  glph[g_a]   = vec4 (0x000000, 0x00780C, 0x7CCCCC, 0x760000);\n  glph[g_b]   = vec4 (0x00E060, 0x607C66, 0x666666, 0xDC0000);\n  glph[g_c]   = vec4 (0x000000, 0x0078CC, 0xC0C0CC, 0x780000);\n  glph[g_d]   = vec4 (0x001C0C, 0x0C7CCC, 0xCCCCCC, 0x760000);\n  glph[g_e]   = vec4 (0x000000, 0x0078CC, 0xFCC0CC, 0x780000);\n  glph[g_f]   = vec4 (0x00386C, 0x6060F8, 0x606060, 0xF00000);\n  glph[g_g]   = vec4 (0x000000, 0x0076CC, 0xCCCC7C, 0x0CCC78);\n  glph[g_h]   = vec4 (0x00E060, 0x606C76, 0x666666, 0xE60000);\n  glph[g_i]   = vec4 (0x001818, 0x007818, 0x181818, 0x7E0000);\n  glph[g_j]   = vec4 (0x000C0C, 0x003C0C, 0x0C0C0C, 0xCCCC78);\n  glph[g_k]   = vec4 (0x00E060, 0x60666C, 0x786C66, 0xE60000);\n  glph[g_l]   = vec4 (0x007818, 0x181818, 0x181818, 0x7E0000);\n  glph[g_m]   = vec4 (0x000000, 0x00FCD6, 0xD6D6D6, 0xC60000);\n  glph[g_n]   = vec4 (0x000000, 0x00F8CC, 0xCCCCCC, 0xCC0000);\n  glph[g_o]   = vec4 (0x000000, 0x0078CC, 0xCCCCCC, 0x780000);\n  glph[g_p]   = vec4 (0x000000, 0x00DC66, 0x666666, 0x7C60F0);\n  glph[g_q]   = vec4 (0x000000, 0x0076CC, 0xCCCCCC, 0x7C0C1E);\n  glph[g_r]   = vec4 (0x000000, 0x00EC6E, 0x766060, 0xF00000);\n  glph[g_s]   = vec4 (0x000000, 0x0078CC, 0x6018CC, 0x780000);\n  glph[g_t]   = vec4 (0x000020, 0x60FC60, 0x60606C, 0x380000);\n  glph[g_u]   = vec4 (0x000000, 0x00CCCC, 0xCCCCCC, 0x760000);\n  glph[g_v]   = vec4 (0x000000, 0x00CCCC, 0xCCCC78, 0x300000);\n  glph[g_w]   = vec4 (0x000000, 0x00C6C6, 0xD6D66C, 0x6C0000);\n  glph[g_x]   = vec4 (0x000000, 0x00C66C, 0x38386C, 0xC60000);\n  glph[g_y]   = vec4 (0x000000, 0x006666, 0x66663C, 0x0C18F0);\n  glph[g_z]   = vec4 (0x000000, 0x00FC8C, 0x1860C4, 0xFC0000);\n  glph[g_lpa] = vec4 (0x001C30, 0x3060C0, 0x603030, 0x1C0000);\n  glph[g_bar] = vec4 (0x001818, 0x181800, 0x181818, 0x180000);\n  glph[g_rpa] = vec4 (0x00E030, 0x30180C, 0x183030, 0xE00000);\n  glph[g_tid] = vec4 (0x0073DA, 0xCE0000, 0x000000, 0x000000);\n  glph[g_lar] = vec4 (0x000000, 0x10386C, 0xC6C6FE, 0x000000);\n  cSpace = vec2 (8., 13.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1122, 1122, 1156, 1156, 2457], [2459, 2459, 2481, 2481, 4095], [4097, 4097, 4130, 4130, 4313], [4315, 4315, 4336, 4336, 4591], [4593, 4593, 4625, 4625, 4828], [4830, 4830, 4853, 4853, 5025], [5027, 5027, 5058, 5058, 5474], [5476, 5476, 5502, 5502, 9104], [9106, 9106, 9162, 9162, 10736], [10738, 10738, 10770, 10770, 10870], [10872, 10872, 10918, 10918, 10965], [10967, 10967, 11014, 11014, 11061], [11063, 11063, 11096, 11096, 11123], [11125, 11125, 11167, 11167, 11218], [11220, 11220, 11255, 11255, 11317], [11319, 11319, 11364, 11364, 11467], [11469, 11469, 11505, 11505, 11711], [11713, 11713, 11743, 11743, 11856], [11858, 11858, 11915, 11915, 11998], [12032, 12032, 12056, 12056, 12168], [12170, 12170, 12195, 12195, 12381], [12383, 12383, 12404, 12404, 12559], [12561, 12561, 12590, 12590, 12802], [12804, 12804, 12843, 12843, 13023], [16961, 16961, 16992, 16992, 17390], [17392, 17392, 17413, 17413, 17444], [18159, 18159, 18175, 18175, 24189]], "test": "error"}
{"id": "tsfcWB", "name": "Solaris (atz)", "author": "ilyaev", "description": "Solaris", "tags": ["space"], "likes": 7, "viewed": 135, "published": "Public", "date": "1585512729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define FAR_DISTANCE 4.\n#define MIN_DISTANCE 0.0001\n#define SPEED .2\n#define SHOW_FRAME true\n#define SHOW_FULL_PLANET false\n#define PLANET_LAND_COLOR vec3(0.3, .3, .1)\n#define PLANET_OCEAN_COLOR vec3(0., 0., .5)\n#define PLANET_SNOW_COLOR vec3(.5, .2, .1)\n#define PLANET_CLOUD_COLOR vec3(1., 1., 1.) * .6\n#define PLANET_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define SPACE_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define PLANET_DEEP_COLOR vec3(0., 0., 0.3)\n#define PI 3.14\n#define SUN_COLOR vec3(0.9, .3, .1)\n#define ECLIPSE_COLOR vec3(0., 1., 0.)\n#define SECOND_SUN_COLOR vec3(0.5, 0.2, .90)\n\nstruct sEclipse {\n    vec3 color;\n    float d;\n    float shift;\n};\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898 + .00019, 4.1414))) * 43759.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nfloat noise(vec2 p){\n    // p += iTime;\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm2( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p); p = m2*p*2.02;\n    f += 0.2500*noise( p); p = m2*p*2.03;\n    f += 0.1250*noise( p); p = m2*p*2.01;\n    f += 0.0625*noise( p);\n\n    return f/0.9375;\n}\n\nvec3 getOceanTexture(vec2 uv) {\n    return fbm2(uv*4. * fbm2(uv*4. * fbm2(uv*2. + vec2(0., iTime/10.)) + iTime/10.)) * PLANET_OCEAN_COLOR * 5.;\n    // return PLANET_OCEAN_COLOR;\n}\n\n\nvec3 getPlanetTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n    float size = 450.;\n\n    vec2 guv = uv;\n\n    uv *= size;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    // float n = noise(id/500. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED), 5) * .6;\n    float n = fbm2(id/150. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED));//* clamp(sin(iTime) * .5 + .5, .7, 1.);\n    n *= 1.3;\n    // n = fract(n * 1.);\n    float deep = smoothstep(.12, .13, n*.8);\n    float snow = smoothstep(0.57, 0.58, n);\n    float ocean = clamp(n-.1, 0., 1.);\n\n    vec3 oceanTexture = getOceanTexture(guv);\n\n    vec3 land = mix(oceanTexture, PLANET_LAND_COLOR, smoothstep(0.4, 0.41, n));\n\n    col += mix(\n        PLANET_SNOW_COLOR,\n        mix(land, land * 6., pow(abs(n - .35), .4))/2.5,\n        1. -snow\n    );\n\n    col = (1. - step(0.001, col)) * oceanTexture + col;\n\n    col = mix(PLANET_DEEP_COLOR, col, deep);\n\n    if (n < .4 && n > .12) {\n        col *= .6;\n    }\n\n    vec2 cuv = vec2(atan(guv.x*2., guv.y*4.), length(guv) ) ;\n    float aa = iTime/512.;\n    vec2 cid = floor((cuv*mat2(vec2(sin(aa), cos(aa)), vec2(-cos(aa), sin(aa))))*450.);\n\n    float cloudN = noise(cid/150. + iTime/16. * SPEED, 5);\n    vec3 cloudColor = PLANET_CLOUD_COLOR;\n\n    if (n < .12) {\n        cloudColor *= 1.1;\n        cloudColor.rb *= 1.2;\n    }\n\n\n    // col = vec3(0.);\n    col = mix(cloudColor, col, smoothstep(.2, .6 + sin(iTime/32. + cos(iTime*SPEED*cuv.x + sin(iTime/32.)))*.2, cloudN));\n    // col = oceanTexture;\n\n    return col;\n}\n\nsEclipse getEclipse(vec2 uv, vec2 center, float stage) {\n    vec3 col = vec3(0.);\n\n    float size = .1;\n\n    vec2 moonPosition = vec2(stage * size * 2. + sin(iTime*.0)*.1, 0.) + center;\n    vec2 sunPosition = vec2(0., 0.) + center;\n\n    float moonD = length(uv - moonPosition);\n    float sunD = length(uv - sunPosition);\n\n    float shift = length(moonPosition - sunPosition);\n\n\n    vec3 sun_color = mix(ECLIPSE_COLOR, SUN_COLOR, pow(shift/.2, .3));\n\n    float a = atan(uv.x - center.x, uv.y - center.y)*1.;\n\n    float n = fbm2((vec2(sin(a), cos(a)) + iTime/12.) * mix(.5, 3.5, shift/.2)) * clamp(mix(1., 3.5, shift/.2), 1., 2.);\n\n    float sunSize = size + clamp(n*(.2*(1. - pow(shift/.08, .3))), 0., 10.);\n\n    vec3 sun = pow(sunSize/sunD, 11. - clamp((shift * 30.), 0., 10.)) * sun_color;\n\n    vec3 moon = step(moonD, size * .98) * vec3(.0);\n\n    col = mix(moon, sun, smoothstep(size*.9, size, moonD));\n    sEclipse res;\n    res.color = col;\n    res.d = sunD;\n    res.shift = shift;\n    return res;\n}\n\nvec3 getStars(vec2 guv) {\n    float a = iTime / 50.;\n    guv -= .2;\n    guv *= mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n    guv += .2;\n    guv *= 15.;\n    vec2 uv = fract(guv) - .5;\n    vec2 id = floor(guv);\n    vec3 col = vec3(0.);\n\n    for(int x = -1 ; x <= 1 ; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 cid = id + offset;\n            float n = n21(cid);\n            vec2 shift = vec2(n, fract(n * 123.43))-.5;\n            float d = length(uv - offset - shift);\n            if (fract(n * 5543.234) > .8) {\n                col = max(col, smoothstep(.1, .9, (.005 + .02 * fract(n*32342.22))/d)) * (.7 + 0.3 * fract(n*4443322.33));\n            }\n        }\n    }\n\n\n    return col;\n}\n\nvec3 getSecondSun(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float d = pow(.1/length(uv), 1.9) * .3;\n\n    col += d;\n\n    return col * SECOND_SUN_COLOR;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 guv = uv;\n\n    float wobble = sin(iTime + cos(iTime/2.))*.005;\n\n    if (!SHOW_FULL_PLANET) {\n        uv.y += 1.35 + wobble;\n    }\n\n\n    vec3 col = vec3(0.0);\n\n    float a = 2.5;\n    vec3 ro = vec3(0. + sin(a), 0.+cos(a), -1);\n    vec3 lookat = vec3(0.05, .0, 0.);\n\n    float zoom = 22.;\n\n    if (SHOW_FULL_PLANET) {\n         zoom = 4.;\n         ro = vec3(0., 0., -1);\n         lookat = vec3(0.);\n    }\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0., 0., 0.);\n\n    float d = length(cross(rd, p - ro))/length(rd);\n\n    vec3 ds, dt;\n    float sd;\n    int steps;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n        steps += 1;\n\n        sd = length(p) - .0999;\n\n        ds += sd;\n\n        if (sd < MIN_DISTANCE || sd > FAR_DISTANCE) {\n            break;\n        }\n    }\n\n    vec3 globe = vec3(0.);\n    vec2 wuv = guv + vec2(0., wobble);\n\n    sEclipse eclipse = getEclipse(wuv * 2., vec2(-0.6, .65), 1. - sin(iTime/10.));\n\n    vec3 spaceGlowColor = mix(PLANET_GLOW_COLOR, vec3(SUN_COLOR), eclipse.shift / .1);\n\n    if (sd < MIN_DISTANCE) {\n        float x = acos(p.y/length(p));\n        float y = atan(p.z, p.x);\n        vec2 uv = vec2(x, y);\n        globe += smoothstep(.0, 1., clamp(float(steps)/40., 0., 1.))* .3 * spaceGlowColor * .8;\n        globe += getPlanetTexture(uv);\n    } else {\n\n        if (!SHOW_FULL_PLANET) {\n            col += eclipse.color;\n            col += getStars(wuv) * clamp(eclipse.d*2., 0., 1.);\n            col += getSecondSun(wuv + vec2(-0.4, .1));\n        }\n    }\n\n    float glowMask = 1. - mix(smoothstep(.20, .02, d*1.5), .0, step(d, .1)) * .8;\n    float planetGlowMask = (1. - smoothstep(.1, .11, d*1.07))*smoothstep(.1, .11, d*1.02)*3.;\n\n    globe += (1. - glowMask) * mix(PLANET_GLOW_COLOR, spaceGlowColor, eclipse.shift / .4) + (planetGlowMask * PLANET_GLOW_COLOR);\n\n    col += globe;\n\n    if (SHOW_FRAME) {\n        d = length(guv);\n        col *= step(d, .7);\n        vec3 frame = (step(d, .71) - step(d, .70)) * vec3(.8);\n        col += frame;\n    }\n\n    fragColor = vec4(col, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[664, 664, 683, 683, 738], [740, 740, 760, 760, 835], [837, 837, 865, 865, 1189], [1191, 1191, 1224, 1224, 1677], [1679, 1679, 1699, 1718, 1926], [1969, 1969, 1993, 1993, 2189], [2191, 2191, 2222, 2222, 2370], [2373, 2373, 2405, 2405, 3862], [3864, 3864, 3920, 3920, 4866], [4868, 4868, 4893, 4893, 5617], [5619, 5619, 5647, 5647, 5770], [5772, 5772, 5828, 5828, 8167]], "test": "timeout"}
{"id": "tsfcWN", "name": "泰森多边形 Voronoi", "author": "ywqy", "description": "泰森多边形", "tags": ["voronoi"], "likes": 2, "viewed": 185, "published": "Public API", "date": "1584892892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//learn from https://thebookofshaders.com/12/?lan=ch\n//Then learn from http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n#define ANIMATE\n\nvec2 random2( vec2 p ) {\n    return fract(sin(\n        vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)))\n    )*43758.5453);\n}\n\nvec3 voronoi(in vec2 uv) {\n    \n\t//整数小数分离\n    //Tile the space\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    //----------------------------------\n    // 通道一：常规网格噪声\n    // first pass: regular vornoi\n    //----------------------------------\n    \n    //最短向量，最近邻居\n    vec2 minVector, nearNeighbor;\n    \n    //最短距离\n    float minDistance = 8.0;\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n        \t//当前邻居\n            //Neigbor place in the grid\n            vec2 curNeighbor = vec2(float(x), float(y));\n            \n            //获取邻居的随机点\n            //Random position from current + neighbor place in the grid\n            vec2 neighborPoint = random2(i_uv + curNeighbor);\n            \n            #ifdef ANIMATE\n            neighborPoint = 0.5 + .5*sin(iTime + 3.14159 * neighborPoint);\n            #endif\n            \n            //像素点到邻居随机点的距离\n            //Vector from the pixel to point\n            vec2 curVector = curNeighbor + neighborPoint - f_uv;\n            \n            //计算长度\n            //calculate distance\n            float curDistance = dot(curVector, curVector);\n            \n            //滤出最短距离，邻居，向量\n            if(curDistance < minDistance) {\n            \tminDistance = curDistance;\n                minVector = curVector;\n                nearNeighbor = curNeighbor;\n            }\n        }\n    }\n    \n    //----------------------------------\n    // 通道二：边界距离\n    // second pass: distance to borders\n    //----------------------------------\n    \n    minDistance = 8.0;\n    for (int y = -2; y <= 2; y++) {\n        for (int x = -2; x <= 2; x++) { \n        \t//最近邻居的邻居\n            //Neighbor'Neighbor\n            vec2 curNeighbor = nearNeighbor + vec2(float(x), float(y));\n            \n            vec2 neighborPoint = random2(i_uv + curNeighbor);\n            \n            #ifdef ANIMATE\n            neighborPoint = 0.5 + .5*sin(iTime + 3.14159 * neighborPoint);\n            #endif\n            \n            vec2 curVector = curNeighbor + neighborPoint - f_uv;\n            \n            //排除自相交\n            if(dot(minVector - curVector, minVector - curVector)>0.00001)\n            \t//像素在最近点和次近点的比值\n                minDistance = min(minDistance, \n                         dot(0.5 * (minVector + curVector),\n                             normalize(curVector - minVector)\n                            ));\n            \n        }\n    }\n    \n    return vec3(minDistance, minVector);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xx;\n    \n    vec3 c = voronoi( 8.0*uv );\n\n    //画等值线\n    //Show isolines\n    vec3 addColor= vec3(0.3, .6, 0.6);\n    vec3 color = c.x * (.5 + .5*sin(32.0*c.x))*vec3(1.0);\n    \n    //画边界\n    //Draw broders\n    color = mix(addColor, color, smoothstep(.04, .07, c.x));\n    \n    //画细胞中心\n    //Draw cell center\n    float dd = length(c.yz);\n\tcolor = mix(addColor, color, smoothstep(0.0, 0.12, dd) );\n    color += addColor * (1.0-smoothstep( 0.0, 0.04, dd));\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 182, 182, 303], [305, 305, 331, 379, 2946], [2949, 2949, 3006, 3006, 3567]], "test": "timeout"}
{"id": "tsfyD2", "name": "36 Days Of Type - E", "author": "nicolasdnl", "description": "36 Days Of Type - E", "tags": ["letter"], "likes": 2, "viewed": 24, "published": "Public", "date": "1585606042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[11], float kPath[26] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n   \tint kType[] = int[](0,0,0,0,0,0,1,0,1,0,0);\n\tfloat kPath[] = float[](  0.30, 0.5,\n                             -0.30, 0.5,\n                             -0.30,-0.5,\n                              0.30,-0.5,\n                              0.30,-0.4,\n                              0.20,-0.4,\n                              0.20,-0.4, 0.0,\n                              0.20,-0.0,\n                              0.20,-0.0, 0.0,\n                              0.20, 0.4,\n                              0.30, 0.4,\n                              0.30, 0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    p *= 1.5;\n    \n    // distance computations\n    float d = sdA(p);\n    \n    // coloring\n    float t = mod(iTime, 1.) * 2.;\n    float gap = 3./10.;\n    \n    float dist = max(0., min(1., 1. - (d+1.)*0.25));\n    float dist2 = (d*2.+1.)*0.2;\n   \n    vec3 col = vec3(1.,1.,1.);\n    col *= 1.0 + dist2*cos(140.0*d-t*PI*2.);\n    \n    if (d > 0.25) col = vec3(1.);\n    col = generateBorder(col, abs(d-0.245));\n    col = 1. - col;\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1634, 1634, 2399], [3014, 3014, 3065, 3065, 3150], [3153, 3153, 3210, 3246, 3776]], "test": "error"}
{"id": "tsfyR2", "name": "Simple raymarcher with patterns", "author": "mothman", "description": "simple raymarcher scene with patterns.", "tags": ["simple", "raymarcher"], "likes": 2, "viewed": 58, "published": "Public", "date": "1585137237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DIST 0.01\n#define THRESHOLD 0.01\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat GetDist(vec3 p, out int id)\n{\n    float d = 0.0;\n    vec4 c = vec4(0.0,1.0,6.0,1.0);\n    float circ = length(p-c.xyz)-c.w;\n    float plane = p.y+1.0; \n    float plane2 = sdPlane(p,vec4(1,0,0,10));\n    float plane3 = sdPlane(p,vec4(0,0,-1,15));\n    float minval = min(min(min(plane,plane3),plane2),circ);\n    if(minval <= SURFACE_DIST)\n    {\n        if(minval == circ) id = 1;\n        if(minval== plane) id = 2;\n        if(minval== plane2) id = 3;\n        if(minval == plane3) id = 4;\n        \n    }\n    return minval;\n}\nfloat RayMarch(vec3 ro, vec3 rd,out int id){\n    float d = 0.0;\n    vec3 p = ro;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        p  = ro + rd*d;\n        float dS = GetDist(p,id);\n        d += dS;\n        if(dS < SURFACE_DIST || d > MAX_DISTANCE) break;\n    }\n    return d;\n}\nvec3 GetNormal( vec3 p){\n   vec3 norm = vec3(0);\n   vec2 e = vec2(0.01,0.0);\n   int id = 0;\n   float d = GetDist(p,id);\n   norm = vec3(d) - vec3( GetDist(p-e.xyy,id),GetDist(p-e.yxy,id),GetDist(p-e.yyx,id));\n   return normalize(norm);\n}\nfloat Light(vec3 p)\n{\n    vec3 lightPos = vec3(2.*sin(iTime),5. , 6.+2.*cos(iTime));\n    vec3 ray = normalize(lightPos-p);\n    vec3 norm = GetNormal(p);\n    float dif = max(dot(norm,ray ),0.);\n    int id = 0;\n    float d = RayMarch(p+norm*SURFACE_DIST*2.,ray,id);\n    if( d < length(lightPos-p)) dif = dif*0.1;\n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   vec3 ro = vec3(0.0,1.0,0.0);\n   vec3 rd = normalize(vec3(uv,1.0));\n   int id = 0;\n   float d = RayMarch(ro,rd,id);\n   vec3 p = ro  + d*rd;\n   float dif = Light(p);\n   vec3 color = vec3(dif);\n   if(id >1)\n    color = 0.5 + 0.5*cos(iTime+normalize(p.xyz)+vec3(0,2,3));\n    \n   color*=dif;\n   fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 132, 158, 189], [190, 190, 225, 225, 715], [716, 716, 760, 760, 995], [996, 996, 1020, 1020, 1232], [1233, 1233, 1254, 1254, 1561], [1562, 1562, 1619, 1619, 2008]], "test": "timeout"}
{"id": "tsfyRB", "name": "Light interaction with interface", "author": "Zavie", "description": "Inspired by Fabrice Neyret's https://www.shadertoy.com/view/4sSBRd\nThis shader demonstrates how light reflection and refraction stem from wave interference.\n\nClick and drag to change the direction of the incoming wave.", "tags": ["reflection", "refraction", "interference", "photon", "huygens", "wavepropagation"], "likes": 10, "viewed": 5989, "published": "Public API", "date": "1585049250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis shader illustrates how an electromagnetic wave reflects\nand refracts at an interface. It was used as an illustration\nin the talk at Revision 2020, \"Implementing a Physically\nBased Shading without locking yourself in\" :\n\nhttps://bit.ly/2IZqYET\n\nThe directions of the reflected and refracted waves are not\nhard coded, but instead a consequence of the interferences\nat the interface.\n\nThe shader is inspired by Fabrice Neyret's\nhttps://www.shadertoy.com/view/4sSBRd\n\n--\nZavie\n\n*/\n\n\n// Settings:\n#define SHOW_INCIDENT_WAVE 1\n#define SHOW_REFLECTED_WAVE 1\n#define SHOW_TRANSMITTED_WAVE 1\n\n#define NUMBER_OF_SAMPLES 256\n#define WAVE_LENGTH 32 // Wave length, in pixels\n#define ENABLE_ROUGHNESS 1\n#define ENABLE_DISTANCE_ATTENUATION 1 // Not sure which is correct. :-/\n#define ENABLE_WAVE_HIGHLIGHTING 0 // Doesn't work yet.\n\n// Index of refraction of both media:\n#define N1 1.0\n#define N2 1.5\n\n// Color to distinguish the two media:\n#define bgColor vec3(0.05, 0.2, 0.4)\n#define matColor vec3(0.4, 0.2, 0.05)\n\n// Colors to distinguish incident, reflected and\n// transmitted waves:\n#define iColor vec3(1.0, 0.8, 0.6)\n#define rColor vec3(1.0, 0.2, 0.1)\n#define tColor vec3(1.0, 0.7, 0.0)\n\n#define PI acos(-1.)\n\n// ---8<---------------------------------------------------------\n// Implementation starts here.\n\nfloat getHeight(float x)\n{\n    float a = texture(iChannel0, vec2(x+0.5, 0.)).r;\n#if ENABLE_ROUGHNESS\n    float roughness = smoothstep(1., 0., abs(x * 2. - 1.));\n    roughness *= roughness;\n#else\n    float roughness = 0.;\n#endif\n    float h = ((a-0.5)*0.2*roughness + 0.5);\n    return h * iResolution.y/iResolution.x;\n}\n\nfloat getWave(float d, float t, float waveLength, float speed, float phase)\n{\n    float x = (d - t*speed + phase);\n#if ENABLE_WAVE_HIGHLIGHTING\n    float intensity = pow(fract(x), 5.);\n#else\n    float intensity = 1.;\n#endif\n    return sin(2. * PI * x / waveLength) * intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n\n    float height = getHeight(uv.x);\n    float fAbove = smoothstep(-0.001, 0.001, uv.y-height);\n    bool isAbove = (fAbove > 0.5);\n    float t = iTime * 50. / iResolution.x;\n\n    // Incoming wave:\n    vec2 sourceDirection = iMouse.xy / iResolution.xy - vec2(0.5, 0.);\n    vec2 sourcePosition = 0.5 + 100. * normalize(sourceDirection);\n    float iWave = 0.;\n#if SHOW_INCIDENT_WAVE\n    if (isAbove)\n    {\n    \tfloat iWaveLength = float(WAVE_LENGTH) / iResolution.x / N1;\n    \tiWave += getWave(length(uv - sourcePosition), t, iWaveLength, 1./N1, 0.) * fAbove;\n    }\n#endif\n\n    // Reflected and transmitted waves:\n    float rWave = 0.;\n    float tWave = 0.;\n    for (int i = 0; i < NUMBER_OF_SAMPLES; ++i)\n    {\n        float x = float(i) / max(1., float(NUMBER_OF_SAMPLES-1));\n        float y = getHeight(x);\n\n        vec2 p = vec2(x, y);\n        float di = length(p - sourcePosition) * N1;\n        float drt = length(uv - p);\n\n#if ENABLE_DISTANCE_ATTENUATION\n\t    float attenuation = drt;\n#else\n    \tfloat attenuation = 0.1;\n#endif\n\n#if SHOW_REFLECTED_WAVE\n        if (isAbove)\n        {\n\t        float rWaveLength = float(WAVE_LENGTH) / iResolution.x / N1;\n            rWave += getWave(drt, t, rWaveLength, 1./N1, di/N1) * fAbove / attenuation;\n        }\n#endif\n#if SHOW_TRANSMITTED_WAVE\n        if (!isAbove)\n        {\n    \t    float tWaveLength = float(WAVE_LENGTH) / iResolution.x / N2;\n\t        tWave += getWave(drt, t, tWaveLength, 1./N2, di/N2) * (1.-fAbove) / attenuation;\n        }\n#endif\n    }\n    rWave /= float(NUMBER_OF_SAMPLES);\n    tWave /= float(NUMBER_OF_SAMPLES);\n\n    vec3 color = mix(matColor, bgColor, fAbove);\n    color = mix(color, iColor, clamp(iWave, 0., 1.));\n    color = mix(color, rColor, clamp(rWave, 0., 1.));\n    color = mix(color, tColor, clamp(tWave, 0., 1.));\n\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1309, 1309, 1335, 1335, 1627], [1629, 1629, 1706, 1706, 1908], [1910, 1910, 1967, 2017, 3970]], "test": "error"}
{"id": "tsfyRj", "name": "Schwarz-Christoffel Mapping", "author": "mla", "description": "Herbert Müller's method for inverse Schwarz-Christoffel mapping for regular polygons.\n\n[url]http://herbert-mueller.info/uploads/3/5/2/3/35235984/circletopolygon.pdf[/url]\n\nMouse moves inversion point.\n", "tags": ["mapping", "conformal", "schwarzchristoffel"], "likes": 17, "viewed": 463, "published": "Public API", "date": "1585134465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Herbert Müller's method for inverse Schwarz-Christoffel mapping for\n// regular polygons.\n//\n// Matthew Arcus, 2020.\n//\n// The Schwarz-Christoffel mapping:\n//\n// https://en.wikipedia.org/wiki/Schwarz%E2%80%93Christoffel_mapping\n//\n// maps the unit circle (or half-plane) to any polygon in the complex plane.\n// Here we construct the inverse mapping for a regular polygon using a\n// method due to Herbert Müller:\n//\n// http://herbert-mueller.info/uploads/3/5/2/3/35235984/circletopolygon.pdf\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec2 cpow(vec2 z, int n) {\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\n\nvec2 expi(float x) {\n  return vec2(cos(x),sin(x));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,\n              z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z*vec2(1,-1)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993; // Unnecessary precision\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n  z *= C; // Scale polygon to have diameter 1\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 rotate(vec2 p, in float t) {\n  return p*cos(-t)+vec2(p.y,-p.x)*sin(-t);\n}\n\nvec3 getcolor(vec2 z, int K) {\n  if (iMouse.x > 0.0) {\n    // Apply an inversion/Mobius transformation\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m /= dot(m,m); // m inverted in unit circle\n    z -= m;\n    z *= (dot(m,m)-1.0)/dot(z,z);\n    z += m;\n  }\n  // And a rotation (also a Mobius transformation)\n  z = rotate(z,0.5*iTime);\n\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  vec3 col = hsv2rgb(theta/(2.0*PI),1.0,1.0);\n  float A = 4.0;\n  float B = 2.0*float(K);\n  float a = -log(r)*A;\n  float ds = 0.07;\n  if (a <= 6.0+ds) {\n    a = fract(a);\n    float b = fract(theta/PI*B);\n    float d = min(min(a,1.0-a),min(b,1.0-b));\n    col *= mix(0.2,1.0,smoothstep(-ds,ds,d));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord.xy - iResolution.xy)/ iResolution.y;\n  vec3 col = vec3(0.5);\n  int K = (3+int(0.2*iTime)%7);\n  // Check if point in polygon\n  bool inpoly = true;\n  {\n    float theta = PI/float(K);\n    vec2 n = vec2(cos(theta),sin(theta));\n    for (int i = 0; i < K; i++) {\n      vec2 w = rotate(z,2.0*float(i)*theta);\n      w.x -= 1.0;\n      if (dot(w,n) > 0.0) inpoly = false;\n    }\n  }\n  bool incircle = length(z) < 1.0;\n  z = inversesc(z,K);\n  col = getcolor(z,K);\n  if (!incircle) col *= 0.75;\n  if (!inpoly) col *= 0.75;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 722, 722, 861], [863, 863, 895, 895, 1000], [1003, 1003, 1023, 1023, 1055], [1057, 1057, 1084, 1084, 1149], [1151, 1151, 1170, 1170, 1204], [1206, 1206, 1233, 1233, 1261], [1866, 1887, 1914, 1914, 1957], [2369, 2369, 2400, 2400, 3379], [3381, 3381, 3422, 3422, 3598], [3600, 3600, 3633, 3633, 3678], [3680, 3680, 3710, 3710, 4399], [4401, 4401, 4458, 4458, 5023]], "test": "ok"}
{"id": "tsfyW8", "name": "Raytracing and spheres extrusion", "author": "imod", "description": "Raytracing with boolean operations on spheres.", "tags": ["3d", "raytracing", "phong", "spheres", "extrusion"], "likes": 1, "viewed": 102, "published": "Public", "date": "1584642867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//raytracing and spheres extrusion\n//twitter: @imod\n//\n//https://twitter.com/imod74\n#define norm_shpere_count 10\n#define norm_shpere_countfull norm_shpere_count*2\n#define shpere_count 10\n#define full_shpere_count 52\n#define lights_count 4\n#define max_intresections 6\n\n#define PI  3.1415926535897932384626433832795\n#define PI_half  1.57079632679489661923\n\nfloat sinc(float x)\n{\n    return sin(x)/x;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nstruct material\n{\n\tvec3 color;\n\tfloat highlight_intencity;\n    float highlight_hard;\n    float reflection;\n    float refraction;\n    float refraction_int;\n    \n};\n\nmaterial create_material(vec3 color, float highlight_intencity, float highlight_hard, float reflection, float refraction, float refraction_int)\n{\n    material new_material;\n    new_material.color = color;\n    new_material.highlight_intencity = highlight_intencity;\n    new_material.highlight_hard = highlight_hard;\n    new_material.reflection = reflection;\n    new_material.refraction = refraction;\n    new_material.refraction_int = refraction_int;\n    \n    return new_material;\n}\n\n\nstruct ray\n{\n\tvec3 position;\n\tvec3 dirrection;\n};\n\nstruct sphere_shape\n{\n    vec3 position;\n\tfloat radius;\n    material cur_material;\n};\n\nsphere_shape create_shpere(vec3 set_position, float set_radius, material set_material)\n{\n    sphere_shape new_sphere;\n    new_sphere.position = set_position;\n    new_sphere.radius = set_radius;\n    new_sphere.cur_material = set_material;\n    return new_sphere;\n}\n\nvec3 shpere_get_normal(sphere_shape shpere, vec3 position)\n{\n    return normalize(position - shpere.position);\n}\n\nvec3 ray_sphere_intersect(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)\n{\n    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;\n\tfloat distance_to_ray = length(cur_shpere.position - distance_point);\n    \n    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))\n    {\n        return vec3(0,0,0);\n    }\n\n    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));\n\n\tvec3 intersect_point = distance_point - (ray_dir * inner_line_length);\n\n    return intersect_point;\n}\n\nvec3 ray_sphere_intersect_inverse(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)\n{\n    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;\n\tfloat distance_to_ray = length(cur_shpere.position - distance_point);\n    \n    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))\n    {\n        return vec3(0,0,0);\n    }\n\n    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));\n\n\tvec3 intersect_point = distance_point + (ray_dir * inner_line_length);\n\n    return intersect_point;\n}\n\nstruct light\n{\n\tvec3 position;\n\tvec3 color;\n    float intension;\n    bool shadows;\n};\n    \n    \nlight create_light(vec3 position, vec3 color, float intension, bool shadows)\n{\n    light new_light;\n    new_light.position = position;\n    new_light.color = color;\n    new_light.intension = intension;\n    new_light.shadows = shadows;\n    return new_light;\n}\n\nstruct camera\n{\n    vec3 position;\n    vec3 rotation;\n    float fov;\n};\n\nstruct intresection\n{\n    vec3 position;\n    vec3 normal;\n    material cur_material;\n    float distance_far;\n    bool isInside;\n};\n    \nvec3 ray_plane_intersect(vec3 ray_start, vec3 ray_dir)\n{\n    \n  if ( ray_dir.z > 0.0)\n  {\n    return vec3(0,0,0);\n  }\n\n  float t = ((ray_start.x + ray_dir.x) - ray_start.x)/ray_dir.x;\n  float intresection_x = ray_start.x - ((ray_start.z*ray_dir.x)/ray_dir.z);\n  float intresection_y = ray_start.y - ((ray_start.z*ray_dir.y)/ray_dir.z);\n  return vec3(intresection_x, intresection_y, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n\tuv.x = uv.x*(iResolution.x/iResolution.y);\n    \n    camera global_camera;\n    global_camera.position = vec3(-5,0,5.0);\n    global_camera.rotation = vec3(1,0,0);\n    global_camera.fov;\n     \n    material bacground_mat = create_material(vec3(0,0,0), 0.5, 100.0, 0.0, 0.0, 0.0);\n    material test_mat = create_material(vec3(1,1,1), 0.5, 10.0, 0.0, 0.0, 0.0);\n    \n    //intresection prepare\n    sphere_shape shapes_array[full_shpere_count];\n    sphere_shape norm_shapes_array[norm_shpere_countfull];\n    \n    sphere_shape megasphere;\n    megasphere.position = vec3(0,0,5);\n    megasphere.radius = 4.0;\n    megasphere.cur_material = test_mat;\n    \n    \n    intresection base_intresection;\n    base_intresection.distance_far = 999999999.0;\n    base_intresection.cur_material = bacground_mat;\n    base_intresection.position = vec3(1,0,0) * 100.0;\n    base_intresection.normal = normalize(vec3(1,0,0));\n    base_intresection.isInside = false;\n    \n    intresection intresection_array[max_intresections];\n    for(int i=0;i<max_intresections;i++)\n    {\n        intresection_array[i] = base_intresection;\n\n    }\n    int current_intresection = 0;\n    \n    //lights create\n    \n    light lights_array[lights_count];\n    lights_array[0] = create_light(vec3(sin(iTime)*15.0,cos(iTime)*15.0,20.0), vec3(0.5,0.75,1), 0.5, true);\n    lights_array[1] = create_light(vec3(sin(iTime+PI)*15.0,cos(iTime+PI)*15.0,20.0), vec3(1,0.5,0.6), 0.5, true);\n    lights_array[2] = create_light(vec3(0,0,200.0), vec3(0.8,0.8,1.0), 0.25, true);\n    lights_array[3] = create_light(vec3(0,0,-10), vec3(0.2,1.0,1.0), 0.5, false);\n    \n    //spheres create\n    float circle_diameter = 2.75;\n  \tfloat shpere_count_float = (PI*2.0)/float(shpere_count);\n    \n    float sphere_radius_din =  (sin(iTime*2.0)+1.5)*0.4 + 0.6;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float*float(i) + iTime)*circle_diameter,cos(shpere_count_float*float(i) + iTime)*circle_diameter,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n       // new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[i].position = new_shpere_pos.xyz;\n        shapes_array[i].radius = sphere_radius_din;\n        shapes_array[i].cur_material = test_mat;\n        shapes_array[i].cur_material.color = vec3(1.0,0.5,1.0);\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n\n    vec4 new_shpere_pos = vec4(0,0,1,1);\n    //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n    //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n    new_shpere_pos.z =new_shpere_pos.z + cos(iTime*2.0)*1.0 + 4.0;\n    \n    shapes_array[10].position = new_shpere_pos.xyz;\n    shapes_array[10].radius = 2.0;\n    shapes_array[10].cur_material = test_mat;\n    \n        //spheres create\n    float circle_diameter_02 = 3.50;\n  \tfloat shpere_count_float_02 = (PI*2.0)/float(shpere_count*2);\n    float sphere_radius_din_02 =  (cos(iTime*2.0+ PI_half/2.0)+2.0)*0.3 + 0.5;\n    \n    for(int i=0;i<shpere_count*2;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_02*float(i) - iTime + (PI_half/shpere_count_float_02)/6.0)*circle_diameter_02,cos(shpere_count_float_02*float(i) - iTime + (PI_half/shpere_count_float_02)/6.0)*circle_diameter_02,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[11+i].position = new_shpere_pos.xyz;\n        shapes_array[11+i].radius = sphere_radius_din_02;\n        shapes_array[11+i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    \n    float circle_diameter_03 = 3.50;\n  \tfloat shpere_count_float_03 = (PI*2.0)/float(shpere_count*2);\n    float sphere_radius_din_03 =  (cos(iTime*2.0+ PI_half/2.0)+2.0)*0.2 + 0.2;\n    \n    for(int i=0;i<shpere_count*2;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_03*float(i) - iTime + (PI_half/shpere_count_float_03)/6.0)*circle_diameter_03,cos(shpere_count_float_03*float(i) - iTime + (PI_half/shpere_count_float_03)/6.0)*circle_diameter_03,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 4.0;\n        \n        shapes_array[32+i].position = new_shpere_pos.xyz;\n        shapes_array[32+i].radius = sphere_radius_din_03;\n        shapes_array[32+i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    //norm_shpere_count 10\n    //norm_shapes_array\n    \n    float circle_diameter_04 = 8.00;\n  \tfloat shpere_count_float_04 = (PI*2.0)/float(norm_shpere_count);\n    float sphere_radius_din_04 =  1.0;\n    \n    for(int i=0;i<norm_shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_04*float(i) - iTime)*circle_diameter_04,cos(shpere_count_float_04*float(i) - iTime)*circle_diameter_04,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + cos(iTime*8.0) + 5.0;\n        \n        norm_shapes_array[i].position = new_shpere_pos.xyz;\n        norm_shapes_array[i].radius = sphere_radius_din_04;\n        norm_shapes_array[i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    float circle_diameter_05 = 9.00;\n  \tfloat shpere_count_float_05 = (PI*2.0)/float(norm_shpere_count);\n    float sphere_radius_din_05 =  1.0;\n    \n    for(int i=0;i<norm_shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_05*float(i) + iTime)*circle_diameter_05,cos(shpere_count_float_05*float(i) + iTime)*circle_diameter_05,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), sin(iTime*1.0)/8.0)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), cos(iTime*1.0)/8.0)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + cos(iTime*8.0 + PI) + 5.0;\n        \n        norm_shapes_array[norm_shpere_count+i].position = new_shpere_pos.xyz;\n        norm_shapes_array[norm_shpere_count+i].radius = sphere_radius_din_05;\n        norm_shapes_array[norm_shpere_count+i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    \n    vec3 ray_start = global_camera.position;\n    vec4 ray_dir = rotationMatrix(vec3(0,0,1), uv.x*1.5)*vec4(global_camera.rotation,1.0);\n    ray_dir = rotationMatrix(vec3(0,1,0), uv.y*1.5)*vec4(ray_dir);\n    bool isIntersected = false;\n    \n    for(int i=0;i<norm_shpere_countfull;i++)\n    {\n        vec3 cur_inter = ray_sphere_intersect_inverse(ray_start, ray_dir.xyz, norm_shapes_array[i]);\n        \n        if (cur_inter != vec3(0,0,0))\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = shpere_get_normal(norm_shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = norm_shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n            intresection_array[current_intresection].isInside = true;\n        }\n\t}\n    \n    for(int i=0;i<full_shpere_count;i++)\n    {\n        vec3 cur_inter = ray_sphere_intersect_inverse(ray_start, ray_dir.xyz, shapes_array[i]);\n\t\t\n        vec3 cur_inter_add = cur_inter + shpere_get_normal(shapes_array[i], cur_inter)*0.01;\n        \n        bool isFree = true;\n        for(int j=0;j<full_shpere_count;j++)\n    \t{\n            if(distance(shapes_array[j].position,cur_inter_add) < shapes_array[j].radius)\n            {\n                isFree = false;\n            }\n        }\n            \n        ///*\n        if ((cur_inter != vec3(0,0,0)) && ( distance(megasphere.position,cur_inter) < megasphere.radius ) && (isFree) )\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = -shpere_get_normal(shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n            intresection_array[current_intresection].isInside = true;\n        }//*/\n        \n        /*\n        if (cur_inter != vec3(0,0,0))\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = shpere_get_normal(shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n            intresection_array[current_intresection].isInside = true;\n        }*/\n\t}\n\n    \n    \n    vec3 cur_inter_meg = ray_sphere_intersect(ray_start, ray_dir.xyz, megasphere);\n    bool isMegaFree = true;\n    for(int i=0;i<full_shpere_count;i++)\n    {\n        if(distance(shapes_array[i].position,cur_inter_meg) < shapes_array[i].radius)\n        {\n            isMegaFree = false;\n        }\n    }\n            \n    if ((cur_inter_meg != vec3(0,0,0)) && (isMegaFree) )\n    {\n        isIntersected = true;\n        current_intresection++;\n        intresection_array[current_intresection].position = cur_inter_meg;\n        intresection_array[current_intresection].normal = shpere_get_normal(megasphere, cur_inter_meg); \n        intresection_array[current_intresection].cur_material = megasphere.cur_material;\n        intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter_meg);\n    }\n    \n    vec3 plane_intr_point = ray_plane_intersect(ray_start, ray_dir.xyz);\n    if(plane_intr_point != vec3(0,0,0))\n    {\n        isIntersected = true;\n    \tcurrent_intresection++;\n    \tintresection_array[current_intresection].position = plane_intr_point;\n    \tintresection_array[current_intresection].normal = vec3(0,0,1); \n    \tintresection_array[current_intresection].cur_material = test_mat;\n    \tintresection_array[current_intresection].distance_far = distance(global_camera.position, plane_intr_point);\n    }\n\n    sphere_shape center_sphere;\n    center_sphere.position = vec3(0,0,5);\n    center_sphere.radius = 0.7;\n    center_sphere.cur_material = test_mat;\n    center_sphere.position.z = cos(iTime)/2.0 +5.0;\n    \n    vec3 centrshpere_intr_point = ray_sphere_intersect(ray_start, ray_dir.xyz, center_sphere);\n    if(centrshpere_intr_point != vec3(0,0,0))\n    {\n        isIntersected = true;\n    \tcurrent_intresection++;\n    \tintresection_array[current_intresection].position = centrshpere_intr_point;\n    \tintresection_array[current_intresection].normal = shpere_get_normal(center_sphere, centrshpere_intr_point); \n    \tintresection_array[current_intresection].cur_material = test_mat;\n        //intresection_array[current_intresection].cur_material.color.r = (cos(centrshpere_intr_point.z*8.0)+1.0)/2.0;\n        //intresection_array[current_intresection].cur_material.color.g = (sin(centrshpere_intr_point.z*8.0)+1.0)/2.0;\n        //intresection_array[current_intresection].cur_material.color.b = 1.0;\n        intresection_array[current_intresection].cur_material.highlight_hard = (cos(centrshpere_intr_point.z*8.0)+1.1)*50.0;\n\n    \tintresection_array[current_intresection].distance_far = distance(global_camera.position, centrshpere_intr_point);\n    }\n    \n    //sort intersections\n    bool isSorted = false;\n    do \n    {\n        isSorted = true;\n        for(int i=0;i<max_intresections-1;i++)\n    \t{\n        \tif (intresection_array[i].distance_far > intresection_array[i+1].distance_far)\n            {\n                intresection intresection_tmp = intresection_array[i];\n                intresection_array[i] = intresection_array[i+1];\n                intresection_array[i+1] = intresection_tmp;\n                isSorted = false;\n            }\n    \t}\n    }\n    while(!isSorted);\n    \n    \n    vec3 col = vec3(0,0,0);\n    \n    if(isIntersected)\n    {\n\t\t//col = vec3(0.1,0.1,0.1);\n        \n        for(int i=0;i<lights_count;i++)\n        {\n            vec3 light_dir = normalize(lights_array[i].position - intresection_array[0].position);\n\n            float light_intencity = dot(light_dir,intresection_array[0].normal);\n\n\n              col = col + clamp(intresection_array[0].cur_material.color*light_intencity*lights_array[i].intension*lights_array[i].color, 0.0, 1.0);;\n\n              vec3 refl_vec = reflect(light_dir ,intresection_array[0].normal);\n              float phong_highlight = dot(refl_vec, ray_dir.xyz);\n              phong_highlight =  pow(clamp(phong_highlight, 0.0, 1.0),intresection_array[0].cur_material.highlight_hard)*0.5;\n            \n              clamp(phong_highlight, 0.0, 1.0);\n            \n              col = col + phong_highlight;\n\n        }\n    }\n    col = clamp(col, vec3(0,0,0), vec3(1,1,1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 376, 376, 399], [401, 401, 446, 446, 1074], [1240, 1240, 1385, 1385, 1720], [1861, 1861, 1949, 1949, 2123], [2125, 2125, 2185, 2185, 2237], [2239, 2239, 2321, 2321, 2848], [2850, 2850, 2940, 2940, 3467], [3565, 3565, 3643, 3643, 3822], [4033, 4033, 4089, 4089, 4420], [4422, 4422, 4479, 4529, 19572]], "test": "timeout"}
{"id": "tsfyz4", "name": "COVID-19", "author": "charstiles", "description": "I am isolated & spent my day making the corona virus..\nI originally made this in shawnlawson.github.io/The_Force/ \nIt was too heavy for ST but I implemented a naive blur on the depth and posted a video of it here:instagram.com/p/B9wgtRzFjhs/", "tags": ["raymarch", "blob", "spheretrace", "virus", "coronavirus", "covid19"], "likes": 16, "viewed": 724, "published": "Public", "date": "1584239558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat PI = 3.1415;\nfloat PHI = 1.61803398874989;\nconst int steps = 16;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// this function from https://www.shadertoy.com/view/wtSSWh\nfloat n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+d)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\n\n// these three functions are from http://mercury.sexy/\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\n\nfloat virusHead (float p){\n    \n    return cos(p);//+ noise(abs(p));\n}\n\nfloat modBlob(inout vec3  p){\n        float sz = 0.;\n    if (p.x < max(p.y, p.z)){ \n        p = p.yzx;\n        //sz+=.007;\n    }\n    if (p.x < max(p.y, p.z)){ \n       // sz-=0.05;\n        p = p.yzx;}\n\n    return sz;\n    \n}\n\nfloat bFunct(vec3 p, vec3 savedP){ // this function places nubs around sphere\n   return  max(max(max(\n        dot(p, normalize(vec3(1., 1, 1))),\n        dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n        dot(p.yx, normalize(vec2(1., PHI )))),\n        dot(p.xz, normalize(vec2(1., PHI ))));\n    \n}\n\nfloat bloby(vec3 p) {\n    p = abs(p);\n    vec3 savedP = p;\n    float sz = 1.3;\n    sz += modBlob(p);\n    float b = bFunct(p,savedP);\n    float l = length(p);\n    \n    float nub =(1.01 - b / l)*(PI / .04) - n(savedP.xy*20.);\n        \n    float sploops = l - sz - 0.09 * cos(min(nub, (PI)));\n    \n    return fOpDifferenceRound (sploops,l-1.38, 0.15); // just ge tthe nubs\n}\n\n\nfloat virus(vec3 p) {\n    vec3 savedP = p;\n    p = abs(p);\nfloat sz = 1.2;\n sz += modBlob(p);\n    float b = bFunct(p,savedP);\n        \n    float l = length(p);\n    return l - sz - 0.3 * (3. / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.15), PI )) +( n(savedP.xy*20.) *0.01)+  n(savedP.zy*17.) *0.03;\n}\n//from http://mercury.sexy/\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 scene(vec3 ray ){\n    float time = iTime;\n    float floor = (ray.y + 1.2) - \n        cos(ray.x * 10.)* 0.2 - sin(ray.y* 10.);\n    float radius = 0.5;\n    \n    \n   // ray = mod(ray, modSpace) - 0.5*modSpace;\n    \n    ray = ray - vec3(0.,0.,2.0);\n    vec3 ray2 = ray;\n    vec3 ray3 = ray;\n        \n    pR(ray2.yz,time/3. + n((vec2(time/3. ) / 2.)) * 0.2);\n    pR(ray3.yz,time/3.);\n    \n    vec3 ray4 = mix(ray2,ray3,(sin(time)/5.) + 1.);\n    \n    pR(ray4.xz, n(vec2(time/4.) ) );\n    \n    pR(ray4.xy, 0.2*n(vec2(time) ) ); \n    float blob = bloby(ray4);\n    float virus = virus(ray4);\n\t\n    float ret = smin(blob,virus,.8  + (0.08* sin(time))) ;\n    \n    return vec2( ret,length(ray4)-0.5) ;//smin(smin(blob, sphere,0.6), sphere2,0.6) ;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    float smallNumber = 0.002;\n    vec3 n = vec3(\n    scene(vec3(p.x + smallNumber, p.yz)).x -\n    scene(vec3(p.x - smallNumber, p.yz)).x,\n    scene(vec3(p.x, p.y + smallNumber, p.z)).x -\n    scene(vec3(p.x, p.y - smallNumber, p.z)).x,\n    scene(vec3(p.xy, p.z + smallNumber)).x -\n    scene(vec3(p.xy, p.z - smallNumber)).x );\n\n\treturn normalize(n);\n}\n\nfloat lighting(vec3 origin, vec3 dir, vec3 normal) {\n    vec3 lightPos = vec3(12,12,1);//vec3(cos(time) +12., sin(time), 12.);\n    vec3 light = normalize(lightPos - origin);\n\n    float diffuse = max(0., dot(light, normal));\n    vec3 reflectedRay = 1.0 * dot(light, normal) * normal - light;\n\n    float specular = max(0., (pow(dot(reflectedRay, light),5.))) * sin(iTime* 3.)* 0.3;\n\n    float ambient = 0.03;\n\n    return ambient + diffuse + specular;\n\n}\n\n\nvec4 trace(vec3 rayOrigin, vec3 dir){\n    vec3 ray = rayOrigin;\n    float dist = 0.;\n        \n    float totalDist = 0.;\n    float maxDist = 3.;\n    vec2 holder;\n    float redCol;\n    \n    for (int i = 0; i < steps ; i++){\n        holder = scene(ray);\n        dist = holder.x;\n        redCol = holder.y;\n        \n        if(dist < 00.04){\n            vec4 distCol = vec4(1. - vec4(totalDist/maxDist));\n            vec4 lightingCol = vec4(lighting(rayOrigin,dir,estimateNormal(ray)));\n            vec4 col = lightingCol + vec4(pow(redCol,4.),0,0,0);//+ vec4(length(vec3(pow(length(ray),1.)))*0.3,0,0,0);//mix(lightingCol , vec4(distCol),distCol.x);\n           \n            return col;\n        } \n        totalDist += dist;\n        ray += dist * dir;\n        if (totalDist > maxDist){\n            break;\n            \n        }\n    } \n \n\n    return vec4(n(rayOrigin.xy*2.0) * (1.6-length(rayOrigin.xy)));\n}\nvec3 lookAt(vec2 uv, vec3 camOrigin, vec3 camTarget){\n\tvec3 zAxis = normalize(camTarget - camOrigin);\n\tvec3 up = vec3(0,1,0);\n\tvec3 xAxis = normalize(cross(up, zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n\n\tfloat fov = 2.;\n\n\tvec3 dir = (normalize(uv.x * xAxis + uv.y * yAxis + zAxis * fov));\n\n\treturn dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv *2.)-1.;\n\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rayOrigin = vec3(uv.x + n(vec2(time))*0.05,uv.y + n(vec2(time/3.))*0.03, 0.); // TODO make it so that the bg moves more than the foreground so it looks like the fbm is far away\n    vec3 camOrigin = vec3(0, 0., -1.);\n\n    vec3 camTarget = camOrigin+ vec3(sin(time/10.),cos(time/10.), 2);\n\n    vec3 direction = lookAt(uv, camOrigin, camTarget);\n\n\n    fragColor = (trace(rayOrigin, direction));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 114, 114, 207], [208, 268, 284, 284, 594], [652, 731, 779, 779, 870], [872, 872, 927, 927, 1019], [1021, 1021, 1075, 1075, 1120], [1123, 1123, 1149, 1149, 1193], [1195, 1195, 1224, 1224, 1417], [1419, 1419, 1453, 1496, 1713], [1715, 1715, 1736, 1736, 2086], [2089, 2089, 2110, 2110, 2386], [2387, 2415, 2447, 2447, 2492], [2494, 2494, 2516, 2516, 3235], [3238, 3238, 3267, 3267, 3619], [3621, 3621, 3673, 3673, 4072], [4075, 4075, 4112, 4112, 4977], [4978, 4978, 5031, 5031, 5295], [5297, 5297, 5354, 5354, 5932]], "test": "timeout"}
{"id": "tsfyzn", "name": "Synthwave (atz)", "author": "ilyaev", "description": "Very 'original' synthwave landscape surfing :)", "tags": ["retro", "landscape", "synthwave"], "likes": 27, "viewed": 587, "published": "Public", "date": "1584055930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credits to @spalmer for grid smooth function https://www.shadertoy.com/view/wl3Sz2\n#define MAX_STEPS 156\n#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 16.\n#define GRID_SIZE 4.\n#define speed 6.\n#define MOUNTAIN_COLOR vec3(0.54, 0.11, 1.)\n#define COLOR_PURPLE vec3(0.81, 0.19, 0.78)\n#define COLOR_LIGHT vec3(0.14, 0.91, 0.98)\n#define COLOR_SUN vec3(1., 0.56, 0.098)\n#define MATERIAL_PLANE 1.\n#define MATERIAL_BACK 2.\n#define GRID_THICKNESS .2\n#define COLOR_NIGHT_GRID vec3(0., .15, 0.)\n#define COLOR_NIGHT_SUN vec3(0.5, .0, 0.)\n#define COLOR_NIGHT_MOUNTAIN vec3(0.9, .3, 0.1)\n#define SUNSET_SPEED 3.\n\nvec3 lightPos = vec3(0., 3., -10.);\n\nstruct traceResult {\n    bool  isHit;\n    float distanceTo;\n    float material;\n    float planeHeight;\n    vec3 planeNormal;\n};\n\nstruct getDistResult {\n    float distanceTo;\n    float material;\n    float planeHeight;\n    vec3 planeNormal;\n};\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat N21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*5677.)*4332.23);\n}\n\nmat2 rot2d(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(vec2(c,-s), vec2(s,c));\n}\n\nfloat getHeight(vec2 id) {\n    //return 0.;\n    float ax = abs(id.x);\n    if (ax < GRID_SIZE) {\n        return 0.;\n    }\n\n    float n = N21(id);\n\n    float wave = sin(id.y/9. + cos(id.x/3.))*sin(id.x/9. + sin(id.y/4.));\n\n    wave = clamp((wave * .5 + .5) + n*.15 - .6, 0., 1.);\n    if (ax < (GRID_SIZE + 5.) && ax >= GRID_SIZE) {\n        wave *= (ax - GRID_SIZE + 1.)*.2;\n    }\n    return (wave*10.);\n}\n\n\ngetDistResult getDist(vec3 p) {\n    float size = GRID_SIZE;\n    vec3 nuv = p * size + vec3(0., 0., iTime * speed);\n    vec2 uv = fract(nuv).xz;\n    vec2 id = floor(nuv).xz;\n\n    vec2 lv = uv;\n\n    float bl = getHeight(id);\n    float br = getHeight(id + vec2(1., 0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = getHeight(id + vec2(0., 1.));\n    float tr = getHeight(id + vec2(1., 1.));\n    float t = mix(tl, tr, lv.x);\n\n    float height = mix(b,t, lv.y);\n\n    float O = bl;\n    float R = br;\n    float T = getHeight(id + vec2(0. -1.));\n    float B = tl;\n    float L = getHeight(id + vec2(-1., 0));\n\n    vec3 n = vec3(2.*(R-L), 2.*(B-T), -4.);\n\n\n    float d = sdPlane(p, -.5 + 0.3*height);\n\n    float db = -p.z + MAX_DISTANCE*.4;\n    d = min(d, db);\n\n    getDistResult result;\n\n    result.distanceTo = d;\n    result.material = MATERIAL_PLANE;\n    result.planeHeight = height;\n    result.planeNormal = normalize(n);\n\n    if (d == db) {\n        result.material = MATERIAL_BACK;\n    }\n\n    return result;\n}\n\ntraceResult trace(vec3 ro, vec3 rd) {\n    traceResult result;\n    float ds, dt;\n    getDistResult dist;\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        vec3 p = ro + rd * ds;\n        dist = getDist(p);\n        dt = dist.distanceTo;\n        ds += dt * .6;\n        if (abs(dt) < MIN_DISTANCE || ds > MAX_DISTANCE) {\n            break;\n        }\n    }\n    result.isHit = abs(dt) < MIN_DISTANCE;\n    result.distanceTo = ds;\n    result.material = dist.material;\n    result.planeHeight = dist.planeHeight;\n    result.planeNormal = dist.planeNormal;\n    return result;\n}\n\nfloat getLightDiffuse(vec3 p, float material, float height, vec3 normal) {\n    vec3 l = normalize(lightPos - p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    return dif;\n}\n\nvec3 starsLayer(vec2 ouv) {\n    vec3 col = vec3(0.);\n\n    vec2 uv = fract(ouv) - .5;\n\n    float d;\n\n    for(int x = -1 ; x <= 1; x++) {\n        for(int y = -1 ; y <= 1; y++) {\n            vec2 offset = vec2(x,y);\n            vec2 id = floor(ouv) + offset;\n            float n = N21(id);\n            if (n > .6) {\n                float n1 = fract(n*123.432);\n                float n2 = fract(n*1234.2432);\n\n                float size = .01 + 0.05 * (n1 - .5);\n\n                vec2 shift = vec2(n1 - .5, n2 - .5);\n                d = max(d, size/length(uv - offset + shift));\n            }\n        }\n    }\n\n\n    return col + d*vec3(.1, .9, .1);\n}\n\nvec3 backgroundStars(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float t = iTime * (speed / 30.);\n\n    float layers = 3.;\n\n    for(float i = 0. ; i < 1. ; i+= 1./layers) {\n        float depth = fract(i + t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(1., .9, depth);\n\n        col += starsLayer(uv * scale + i * 456.32) * fade;\n    }\n    return col;\n}\n\nvec3 getOthersideBackground(vec2 uv) {\n    return backgroundStars(uv/8. + sin(iTime/(speed)));\n}\n\nvec3 getBackground(vec2 uv) {\n    float set = 0. - clamp(sin(iTime/SUNSET_SPEED)*3., -1., 2.);\n\n    float sunDist = length(uv + vec2(0., -2.5 - set));\n    float sun = 1. - smoothstep(2.35, 2.5, sunDist);\n\n    float gradient = sin(uv.y/4. - 3.14/32. + set/3.)*2.;\n    float bands = abs(sin(uv.y * 8. + iTime*2.)) * (1. - step(2.5 + set, uv.y));\n\n    float skyTop = 2.12/distance(uv, vec2(uv.x, 9.5));\n    float skyBottom = 1.12/distance(uv, vec2(uv.x, -1.5));\n\n    vec3 result;\n\n    // sun\n\n    if (set < -1.8) {\n        result = vec3(sun) * (bands > 0. ? bands : 1.) * mix(vec3(0.), COLOR_NIGHT_SUN, ((abs(set) - 1.6) -.2) * 15.);\n        float glow = smoothstep(.1, .5, (1.1)/sunDist);\n        result += glow * COLOR_NIGHT_SUN;\n    } else {\n        result = vec3(sun * gradient * (bands > 0. ? bands : 1.)) * COLOR_SUN;\n        //glow\n        float glow = smoothstep(.1, .5, (1.1)/sunDist) + clamp(-1., 1., set);\n        // result += glow * COLOR_PURPLE;\n\n        // sky\n        result += max(glow * COLOR_PURPLE, ((skyTop * MOUNTAIN_COLOR) + (skyBottom * COLOR_PURPLE))*(1. + set));\n    }\n\n\n\n    if (sun < .5) {\n        // stars\n        vec2 nuv = uv*2.;// + vec2(iTime, 0.);\n        vec2 rize = vec2(-10., 12.);\n        nuv -= rize;\n        nuv *= rot2d(mod(-iTime/15., 6.28));\n        nuv += rize;\n        uv = fract(nuv);\n        vec2 id = floor(nuv);\n        uv -= .5;\n\n        float n = N21(id);\n        uv.x += fract(n*100.32) - .5;\n        uv.y += fract(n*11323.432) - .5;\n\n        float star = smoothstep(.5, 1., (0.03 + (0.02 * (fract(n*353.32) - .5)))/length(uv));\n\n        result += star * step(.8, n);\n    }\n\n    return result;\n}\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// (c) spalmer https://www.shadertoy.com/view/wl3Sz2\nfloat gridPow(vec2 uv)\n{\n    vec2 p = uv * GRID_SIZE + vec2(0., iTime * speed);\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*GRID_THICKNESS);\n    f = pow(f, vec2(fadePower));\n    float g = f.x+f.y; //max(f.x, f.y); //\n    float s = sqrt(GRID_THICKNESS);\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));\n}\n\nvec3 getAlbedo(vec3 p, float material, float height, vec3 normal) {\n    if (material == MATERIAL_BACK) {\n        return getBackground(p.xy);\n    }\n\n    float sunSet = sin(iTime/SUNSET_SPEED)*.5 + .5;\n\n    vec3 col = vec3(0.);\n    float grid = gridPow(p.xz);\n\n    float maxHeight = 2.5;\n\n    vec3 grid_color = COLOR_PURPLE;\n    vec3 cell_color = vec3(0.);\n    vec3 mountain_color = MOUNTAIN_COLOR;\n    mountain_color = mix(mountain_color, COLOR_NIGHT_MOUNTAIN, sunSet);\n\n\n\n    if (height > 0.) {\n        grid_color = mix(COLOR_PURPLE, COLOR_LIGHT, height/maxHeight);\n        cell_color = mountain_color * mix(vec3(0.), mountain_color, height/maxHeight);\n    }\n\n    grid_color = mix(grid_color, COLOR_NIGHT_GRID, sunSet);\n\n    col = mix(vec3(0.), grid_color, grid) + cell_color;\n\n    return vec3(col);\n}\n\nfloat polarTriangle(vec2 uv, float offset) {\n    float a = atan(uv.x, uv.y) + offset;\n    float b = 6.28 / 3.;\n    float l = length(uv);\n\n    float d = cos(a - floor(.5 + a/b) * b) * l;\n\n    return d;\n}\n\nfloat triangleMask(vec2 uv) {\n    return polarTriangle(uv + vec2(0., -.1),3.14 + .5*sin(iTime));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // lightPos.z = sin(iTime/3.)*100.;\n\n    mouse.x = 0.5;\n    mouse.y = 0.;\n\n    vec3 col = vec3(0.);\n\n    vec3 ro = vec3(0., .5, -.4);\n    vec3 lookat = vec3(mouse.x*2.-1., 1. - mouse.y - .6, 0.);\n    float zoom = .4;\n\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0.);\n\n    traceResult tr = trace(ro, rd);\n\n    if (tr.isHit) {\n\n        p = ro + rd * tr.distanceTo;\n\n        vec3 albedo = getAlbedo(p, tr.material, tr.planeHeight, tr.planeNormal);\n\n        float diffuse = getLightDiffuse(p, tr.material, tr.planeHeight, tr.planeNormal);\n\n        float fade = 1.;// - clamp((p.z-ro.z)/(MAX_DISTANCE * .8), 0., 1.);\n\n        if (tr.material == MATERIAL_BACK) {\n            col = albedo;\n        } else {\n            col = diffuse * albedo * fade;\n        }\n\n        float triangle = triangleMask(uv);\n        float fd = fract(triangle - clamp(sin(iTime/3.), 0., 2.));\n        float bc = (1. - step(.2, fd));\n\n        col *= (tr.material == MATERIAL_BACK) ? bc : 1.;\n        if (bc == 0.) {\n            if (tr.material == MATERIAL_BACK) {\n                col = getOthersideBackground(p.xy);\n            } else {\n                col *= vec3(.8);\n            }\n        }\n\n        col += ((1. - step(.2, fd)) - (1. - step(.19, fd)))*.3;\n\n    }\n\n\n    fragColor = vec4(col, 1.);\n    // fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[883, 883, 915, 915, 937], [939, 939, 958, 958, 1013], [1015, 1015, 1036, 1036, 1122], [1124, 1124, 1150, 1167, 1526], [1529, 1529, 1560, 1560, 2537], [2539, 2539, 2576, 2576, 3105], [3107, 3107, 3181, 3181, 3284], [3286, 3286, 3313, 3313, 3931], [3933, 3933, 3964, 3964, 4320], [4322, 4322, 4360, 4360, 4418], [4420, 4420, 4449, 4449, 6063], [6064, 6064, 6093, 6093, 6181], [6183, 6236, 6260, 6260, 6613], [6615, 6615, 6682, 6682, 7416], [7418, 7418, 7462, 7462, 7620], [7622, 7622, 7651, 7651, 7720], [7723, 7723, 7779, 7779, 9452]], "test": "timeout"}
{"id": "tslcD8", "name": "Rainbow Sherbet", "author": "wnu", "description": "Based off https://www.shadertoy.com/view/lsyfWD", "tags": ["swirl", "color"], "likes": 10, "viewed": 154, "published": "Public", "date": "1584772493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float speed = 1.;\n    float scale = 0.002;\n    vec2 p = (fragCoord.xy/iResolution.xy- vec2(0.5))*2.0;\n    p.x *= iResolution.x/iResolution.y;\n    p *= 0.5;\n    p.x += iTime/2.;\n    //vec2 p = fragCoord * scale;   \n    for(int i=1; i<10; i++){\n        p.x+=0.3/float(i)*sin(float(i)*3.*p.y+iTime*speed*1.);//+iMouse.x/1000.;\n        p.y+=0.3/float(i)*cos(float(i)*3.*p.x+iTime*speed*1.);//+iMouse.y/1000.;\n    }\n    //p.xy += iTime*10.;\n        \n    float t = iTime*1.0;\n    float gbOff = p.x;\n    float gOff = 0.0+p.y;\n    float rOff = 0.0;\n    float r=cos(p.x+p.y+1.+rOff)*.5+.5;\n    float g=sin(p.x+p.y+1.+gbOff+gOff)*.5+.5;\n    float b=(sin(p.x+p.y+gbOff)+cos(p.x+p.y+gbOff))*.3+.5;\n    vec3 color = vec3(r,g,b);\n    //vec3 color = vec3(p.x,p.y,0.0);\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 851]], "test": "ok"}
{"id": "tslcW4", "name": "Spiral hypnosis - 2", "author": "nbardy", "description": "A spiral I've been experimenting with to create a milky way", "tags": ["sdf", "spiral", "hypno", "hypnosis", "cineshader"], "likes": 3, "viewed": 1553, "published": "Public API", "date": "1585106236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float a=1.0;\nconst float b=.1759;\nconst float PI=3.14159265359;\n\nfloat spiralSDF(vec2 p,vec2 c){\n    // t = theta\n    p = p - c;\n    float t=atan(p.y, p.x) + iTime*8.0;\n    // t=(t+PI)/(2.*PI);\n    float r=length(p.xy);\n    \n    float n=(log(r/a)/b-t)/(2.*PI);\n\n    // Cap the spiral\n    // float nm = (log(0.11)/b-t)/(2.0*PI);\n    // n = min(n,nm);\n    // return (n+1.0)/100.0;\n    float upper_r=a*exp(b*(t+2.*PI*ceil(n)));\n    float lower_r=a*exp(b*(t+2.*PI*floor(n)));\n    // float lower_r = 0.0;\n    \n    return min(abs(upper_r-r),abs(r-lower_r));\n}\n\nvoid mainImage(out vec4 O,vec2 I)\n{\n    vec2 R=iResolution.xy;\n    vec2 uv=(2.*I-R)/R.y;\n    vec2 c = vec2(0.0,0.0);\n    \n    // Uncomment for more swirl\n    // vec2 c = vec2(0.7*sin(iTime*1.3), 0.3*sin(iTime)*2.0);\n    float r = length(uv);\n    float d = spiralSDF(uv,vec2(c));\n\n    // Alter distance for a satisfying visual\n     float v = pow(d, 1.32) / 0.23;\n    O.rgb=vec3(v);\n    //O.rgb = O.rgb*1.0/r;\n    // O.xy=uv;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 102, 119, 559], [561, 561, 596, 596, 986]], "test": "timeout"}
{"id": "tslcz7", "name": "Torus Knot - Plane Intersection", "author": "arifr123", "description": "Try dragging the mouse.\nTry changing kp and kq.\nBased on my shader [url]https://www.shadertoy.com/view/wtcSW2[/url].", "tags": ["gradientdescent", "torusknot"], "likes": 6, "viewed": 106, "published": "Public", "date": "1584478181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433\n\n#define sq(x) dot(x, x)\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\nvec2 perp(vec2 v)\n{\n    return (v * vec2(1, -1)).yx;\n}\n\nstruct TorusKnotParameters\n{\n    float kp;\n    float kq;\n    float r1;\n    float r2;\n    float r3;\n};\n\nvec3 torusKnot(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return sq(torusKnot(t, tkp) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nvec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)\n{\n    int sections = 1*int(max(tkp.kq,tkp.kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 1./(max(tkp.kq,tkp.kp)-0.75);\n    const int maxIterations = 900;//50\n    \n    float minDist;\n    float bestT;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        bool failed = false;\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotSqDistanceDerivative(t, p, tkp);\n            \n            if(abs(lerningRate*dt) < 0.003)break;\n            \n            t -= lerningRate*dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                failed = true;\n                break;\n            }\n        }\n        if(failed)continue;\n        \n        float sqDist = torusKnotSqDistance(t, p, tkp);\n        \n        if(sqDist <= sq(tkp.r3))\n        {\n            return vec3(t, sqDist, 1.);\n        }\n    }\n    \n    return vec3(0.);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    vec2 uv = 5.*fragCoord/iResolution.xy;\n    ivec2 kpkq = ivec2(uv) + 1;\n    uv = mod(uv, 1.);\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t*/\n    \n    \n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n\n    vec2 angles = /*false &&*/ iMouse.z > 0.5 ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : 1.5*iTime*vec2(0.3, 1);//PI*vec2(0.25, 0.25)*(sic(iTime) + vec2(0, 1))\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, sic1.y);\n    vec3 r = vec3(perp(sic0), 0);\n    vec3 u = cross(f, r);\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    float kp = 3., kq = 4., r1 = 0.25, r2 = 0.125, r3 = 0.05;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    /*\n    ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    kpkq /= gcd(kpkq);\n\t*/\n    /*\n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n    */\n    \n    TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 p = uv.x*r + uv.y*f;\n    \n    vec3 res = torusKnotSqDistanceMinimumInside(p, tkp);\n    \n    vec3 col = vec3(0);\n    \n    \n    if(res[2] > 0.5)\n    {\n        uv = fragCoord/iResolution.xy - 0.5;//[-0.5, 0.5] \n        p = (uv.x*r + uv.y*f);//square of size 1x1x1\n        \n        col = 2.*p + 0.5;\n        \n        float len = length(col);\n        col = normalize(col);\n        \n        col *= smoothstep(tkp.r3, tkp.r3 - 1./iResolution.y, sqrt(res[1]));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslcz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 119], [120, 120, 139, 139, 174], [279, 279, 329, 329, 465], [466, 466, 526, 526, 788], [790, 790, 859, 859, 899], [900, 900, 979, 979, 1052], [2201, 2201, 2219, 2219, 2359], [2361, 2361, 2418, 2582, 4091]], "test": "error"}
{"id": "tslczj", "name": "Twist", "author": "Pierco", "description": "Old school lowres twist ", "tags": ["demo"], "likes": 5, "viewed": 99, "published": "Public", "date": "1585177667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = round(fragCoord / iResolution.xy * 80.0)/20.0;\n    vec4 x = sin(sin(iTime * 1.3) + uv.y * 1.5 * cos(iTime) + 90.*vec4(0,1,2,3.0025)) * 0.4 + 2.0 + 0.2 * sin(2.0 * iTime + uv.y);\n    vec2 p1 = uv/2.0-vec2(cos(iTime*0.21)+0.8, sin(iTime*0.14)+0.2);\n    vec2 p2 = uv/2.0-vec2(sin(iTime*0.4)+0.3, cos(iTime*0.6));\n    vec2 p3 = uv/2.0-vec2(cos(iTime*0.3)+0.5, sin(iTime*0.11)+1.0);\n    vec3 d = 12.0 * vec3(sqrt(p1.x*p1.x+p1.y*p1.y), sqrt(p2.x*p2.x+p2.y*p2.y), sqrt(p3.x*p3.x+p3.y*p3.y));\n    float c = (sin(d.x) + sin(d.y) + sin(d.z))/3.0*(1.0-sin(4.9+uv.x*1.5));\n    fragColor = vec4(uv.x > x.x && uv.x < x.y ? x.y-x.x : c, uv.x > x.y && uv.x < x.z ? x.z-x.y : 0.0, uv.x > x.z && uv.x < x.w ? x.w-x.z : -c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 784]], "test": "ok"}
{"id": "tslyRB", "name": "Day 97", "author": "jeyko", "description": "potato", "tags": ["motion", "logpolar", "mdtmjvm"], "likes": 13, "viewed": 380, "published": "Public API", "date": "1585087145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pmod(p,x) mod(p,x) - 0.5*x\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define iTime (iTime*1.6)\n\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    n = max(n, 0.);\n    return n;\n}\n#define pi acos(-1.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nvec3 get(vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uvn = uv;\n    uv *= 1. - dot(uv,uv)*0.3;\n    \n    uv *= 4.;\n    \n    float rang = 0.2;\n    \n    uv -= rang*0.5;\n    uv.x += iMouse.x/iResolution.y*rang;\n    uv.y += iMouse.y/iResolution.y*rang;\n    \n\n    vec3 col = vec3(0);\n\n    vec2 p = uv;\n    \n    \n    float un = 1.;\n    float T = iTime*1.;\n    float fa; \n    float its = 1.;\n    \n    float xx;\n    float yy;\n    for(float i = 0.; i < its; i++){\n        \n        float dpp = dot(p, p);\n        dpp = clamp(dpp, 0.04,0.6);\n        \n        p = (p + 0.)/dpp;\n        \n        \n        float yy=abs(sin(p.y*40. + T/1.));\n        float xx=abs(sin(p.x*40. + T/1.));\n        \n        if(i == its -1.)\n    \t\tfa = exp(-min(yy,xx)*6.)*un;\n        \n        float f = sin(iTime*0.125*pi);\n        float ff = sin(iTime*0.125*pi + pi/2.);\n        \n        p.x -= xx = pow(abs(f),2.5 )*sign(f)*3.5;\n        p *= 1. + pow(fract(abs(ff)),5.)*0.6;\n        float tt = iTime*0.25;\n        float ft = mod(tt, 2.);\n        tt = floor(tt);\n        ft = pow(smoothstep(0.,1.,pow(ft, 1.5) - 0.4), 2.25);\n        p.xy *= rot((tt + ft)*pi*1.);\n        p = clamp(p,-4.,4.);\n        \n        \n    }\n    \n    \n    float modD = 0.04 - smoothstep(0.,1.,iTime*0.005)*0.0;\n\n    p = mix(p,sin(p*11.14 + T*1.), smoothstep(0.,1.,0. +smoothstep(0.,1.,dot(uvn,uvn)*0.9 )*0.4)*0.1);\n\n    float i = log(length(((p.xy)/modD)) + 70.) + iTime*0.05;\n    \n    float id = floor(i*30.);\n    vec3 aa =pal(0.5,0.55,vec3(0.1,0.7,0.9), 0.6 + sin(id*0.4 + iTime)*.4, id*0.9 + iTime*0.5 - dot(uvn,uvn)*.5);\n    \n    aa = max(aa, 0.);\n    col += aa;\n    col = max(col, 0.);\n    col = mix(col,smoothstep(0.,1.,col), 0.8);\n    \n    col -= fbm(uvn).x*0.01;\n    col += fbm(uv + 4.).x*0.01;\n    \n    col = max(col, 0.);\n    col = pow(col, vec3(1. + dot(uvn,uvn)*0.4) + pow(fa, 1.)*0.2);\n    \n    col *= 1. - dot(uvn,uvn);\n    \n    return col;\n}\n    \n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.25);\n    }\n    col /= 9.;\n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 199, 199, 728], [729, 729, 747, 747, 947], [1021, 1021, 1048, 1048, 2956], [2969, 2969, 3026, 3026, 3295]], "test": "error"}
{"id": "tsscRB", "name": "Dying light", "author": "rrrzzz", "description": ".", "tags": ["shadow", "light", "minimalism"], "likes": 2, "viewed": 150, "published": "Public API", "date": "1585075024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define TWO_PI 6.283185307179586476925286766559\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.x;     \n    //0.02 - 0.4\n\n    \n    float stp = smoothstep(0.0, 1.0, mod(iTime / 20.0 , 2.0));\n    float dis = (1.0 - stp) * 0.38 + 0.009;\n    \n\n   //if (dis < 0.01) dis = 0.01;\n\n    \n    float currentDegree = TWO_PI * mod(iTime/4.0, 1.0);\n    float x = cos(currentDegree) * dis;\n    float y = sin(currentDegree) * dis;\n    \n    //0.7 - 20.0\n    stp = smoothstep(0.0, 1.0, mod(iTime / 40.0 , 1.0));\n    float lght = stp * 20.3 + 0.7;\n    float pct = pow(distance(st,vec2(0.4)), distance(st,vec2(x + 0.4, y + 0.4))*lght);\n\n    \n    vec3 color = vec3(pct);\n    float m = smoothstep(0.0, 0.01, stp);\n\tcolor = vec3(mix(1.0, pct, m));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsscRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 149, 149, 852]], "test": "ok"}
{"id": "tsscz4", "name": "clouds_v3", "author": "JabberSnatch", "description": "physically based-ish clouds", "tags": ["volume"], "likes": 4, "viewed": 93, "published": "Public", "date": "1584310052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash3(vec3 p)\n{\n    mat3 seed = mat3(742.342, 823.457, 242.086,\n                     247.999, 530.343, 634.112,\n                     437.652, 139.485, 484.348);\n\n    return fract(seed * sin(p)) * 2.0 - vec3(1.0);\n}\n\n\nfloat noise3(vec3 p)\n{\n    float f = (sqrt(4.0) - 1.0) / 3.0;\n    mat3 skew = mat3(1.0 + f, f, f,\n                     f, 1.0 + f, f,\n\t\t\t\t\t f, f, 1.0 + f);\n    float g = (1.0 - 1.0/sqrt(4.0)) / 3.0;\n    mat3 invskew = mat3(1.0-g, -g, -g,\n                        -g, 1.0-g, -g,\n\t\t\t\t\t\t-g, -g, 1.0-g);\n\n    vec3 sp = skew * p;\n    vec3 cell = floor(sp);\n    vec3 d0 = fract(sp);\n\n    float x0 = step(d0.x, d0.y);\n\tfloat x1 = step(d0.y, d0.z);\n\tfloat x2 = step(d0.z, d0.x);\n    vec3 s0 = vec3(x2*(1.-x0), x0*(1.-x1), x1*(1.-x2));\n    vec3 s1 = min(vec3(1.0), vec3(1.0) + vec3(x2-x0, x0-x1, x1-x2));\n\n    vec3 sv[4] = vec3[4](cell,\n                         cell + s0,\n                         cell + s1,\n                         cell + vec3(1.0));\n    vec3 wv[4] = vec3[4](invskew * sv[0],\n                         invskew * sv[1],\n                         invskew * sv[2],\n                         invskew * sv[3]);\n    vec3 d[4] = vec3[4](p - wv[0],\n                        p - wv[1],\n                        p - wv[2],\n                        p - wv[3]);\n\n    vec4 weights = max(vec4(0.0), vec4(0.6) - vec4(dot(d[0], d[0]),\n                                                   dot(d[1], d[1]),\n                                                   dot(d[2], d[2]),\n                                                   dot(d[3], d[3])));\n    weights = weights * weights * weights * weights;\n\n    return (dot(hash3(sv[0]), d[0]) * weights[0] +\n            dot(hash3(sv[1]), d[1]) * weights[1] +\n            dot(hash3(sv[2]), d[2]) * weights[2] +\n            dot(hash3(sv[3]), d[3]) * weights[3]) * 16.0;\n}\n\nvec3 target_half_diagonal_hfov(float n, float alpha, float aspect)\n{\n\tfloat half_width = tan(alpha * 0.5) * n;\n\tfloat half_height = half_width * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\nvec3 target_half_diagonal_vfov(float n, float alpha, float aspect)\n{\n\tfloat half_height = tan(alpha * 0.5) * n;\n\tfloat half_width = half_height * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\n\nvec3 compute_ray_plane(vec3 half_diagonal, vec2 clip_coord)\n{\n\tvec3 target = half_diagonal * vec3(clip_coord, 1.0);\n\treturn normalize(target);\n}\n\nfloat sample_noise(vec3 p, float octave)\n{\n    float density = 0.0;\n    float max_i = exp2(octave);\n    float bd = 8.5;\n    float expo = 1.0;\n    float scale = 4.5;\n    float offset = +0.115;\n    float of = 1.2;\n\n    vec3 d2 = hash3(vec3(-1.0, -13.0, 0.0)) * iTime * .25;\n\n    for (float i = 1.0; i < max_i; i *= 2.0)\n        density += (bd * pow((noise3(((p*scale + d2/(i*of))*i)) + offset), expo)) / i;\n\n    return max(0.0, density);\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tfloat fov = 60.0 * 3.1415926536 / 180.0;\n\tfloat near = 0.1;\n\tvec3 half_diagonal = target_half_diagonal_vfov(near, fov, aspect_ratio);\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n\tvec3 rd = compute_ray_plane(half_diagonal, clip_coord);\n\n    vec3 pc = ro + dot(rd, -ro) * rd;\n    float x0 = length(pc);\n    float x1 = 1.0 - x0*x0;\n    float x2 = length(pc - ro) - x1;\n\n    vec3 i0 = ro + rd*x2;\n    vec3 i1 = i0 + 2.0*(pc - i0);\n\n    float t0 = x2;\n    float t1 = length(ro - i1);\n    float stepcount = 32.0;\n    float dt0 = (t1-t0)/stepcount;\n    float t = 0.0;\n    float density = 0.0;\n    float i;\n\n    vec3 Ld = normalize(vec3(0.2 * cos(1.0), 1.0, 0.2 * sin(1.0)));\n\n    vec3 Lo = vec3(0.0);\n\n    vec3 Li_sky = vec3(0.1, 0.55, 0.85) * 0.8;\n    vec3 Li_light = vec3(0.97, 0.95, 0.92) * 0.75;\n\n    float st0_count = stepcount + 1.0;\n    float Tr0 = 1.0;\n    float St0 = 0.0;\n    if (x0 < 1.0) for (i = 0.0; i < st0_count; i += 1.0)\n    {\n        t = t0 + dt0*i;\n        vec3 p = ro + t*rd;\n\n        float st0 = sample_noise(p, 3.0);\n        St0 += st0 * dt0;\n\n        float t_max = 2.0;\n        {\n            vec3 pc = p + dot(Ld, -p) * Ld;\n            float x0 = length(pc);\n            float x1 = 1.0 - x0*x0;\n            float x2 = length(pc - p) - x1;\n            vec3 i0 = ro + rd*x2;\n            vec3 i1 = i0 + 2.0*(pc - i0);\n            float t0 = x2;\n            float t1 = length(ro - i1);\n            t_max = t1/2.0;\n        }\n\n        float st1_count = 4.0;\n        float dt1 = (t_max / st1_count);\n        float Tr1 = 1.0;\n        float St1 = 0.0;\n        for (float j = 0.0; j < st1_count; ++j)\n        {\n            float st1_t = (j + 1.0 + 0.125*(hash3(vec3(frag_coord*0.001, 0.0)).x * 0.5 + 0.5))*dt1;\n\n            vec3 p1 = p + Ld*st1_t;\n            float st1 = 0.0;\n            if (length(p1) <= 1.0)\n                st1 = sample_noise(p1, 1.0);\n            else\n            {\n                float Tr2 = exp(-(St1+St0));\n                Lo += (Tr2 * Li_sky * st0 * dt0);\n                break;\n            }\n\n            St1 += st1 * dt1;\n        }\n\n        Tr1 = exp(-(St1+St0));\n        Lo += (Tr1 * Li_light * st0 * dt0);\n\n        float Tr3 = 1.0;\n        Tr3 = exp(-St0);\n        Lo += (Tr3 * Li_sky * st0 * dt0);\n    }\n\n    Tr0 = exp(-St0);\n    Lo += (Tr0 * Li_sky);\n\n    frag_color.xyz = Lo;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsscz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 219], [222, 222, 244, 244, 1816], [1818, 1818, 1886, 1886, 2014], [2016, 2016, 2084, 2084, 2213], [2216, 2216, 2277, 2277, 2360], [2362, 2362, 2404, 2404, 2799], [2801, 2801, 2855, 2855, 5285]], "test": "timeout"}
{"id": "tssczf", "name": "Glow drive", "author": "gaz", "description": "3D", "tags": ["glow"], "likes": 14, "viewed": 256, "published": "Public", "date": "1585301390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hsv(h,s,v) ((clamp(abs(fract(h+vec3(0,2,1)/3.0)*6.0-3.0)-1.0,0.0,1.0)-1.0)*s+1.0)*v\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\n\nvec2 pmod(vec2 p, float r)\n{\n    float a=mod(atan(p.y,p.x),6.2831/r)-0.5*6.2831/r;\n    return length(p)*vec2(sin(a), cos(a));\n}\n\nfloat map(vec3 p)\n{   \n    p.x-=sin(p.z*1.5+iTime*0.3)*0.05;\n    p.y-=cos(p.z*1.5+iTime*0.3)*0.05;\n    p.z-=iTime*3.0;\n    float c=2.0;\n    p.z=mod(p.z,c)-c*0.5;\n\tfloat de=1e9;\n\tp.xy=pmod(p.xy,6.0);\n    p.y-=0.2+sin(iTime*0.5+sin(iTime*0.2)*0.8)*0.5;\n    p.y=opRepLim(p.y,1.5,3.0);\n    for(int i=0;i<3;i++)\n    {\n        p.xy=abs(p.xy)-0.5;\n        p.xz=abs(p.xz)-0.3;\n        p.xy*=rot(1.2+sin(iTime*0.3)*0.5);\n        p.xz*=rot(0.8+sin(iTime*0.6));\n    }\n    p.xy*=rot(iTime*0.2+sin(iTime*0.5)*0.8);\n\tp.xz*=rot(iTime*0.3+sin(iTime*1.5)*1.8);\n\tp = abs(p)-vec3(0.3);\n    if (p.x<p.z) p.xz = p.zx;\n    if (p.y<p.z) p.yz = p.zy;\n\tp.z=max(0.0,p.z);\n\treturn min(de,length(p)-0.0035);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,0,3);\n    vec3 rd=normalize(vec3(uv,-2));\n    float len=length(uv)*0.05;\n    vec3 col=vec3(0);    \n    float depth=5.0;\n    float near=1.0;\n    float itr=600.0;\n    float pitch=(depth-near)/itr;\n    for(float i=0.0; i<itr; i++)\n    {\n        depth-=pitch;\n        vec3 p=ro+rd*depth;\n        float de=map(p);\n        if (de<0.001)\n        {\n        \tcol=vec3(exp(-(depth-near)*0.7));\n  \t\t}\n        else\n        {    \n            col+=hsv(iTime*0.3+len,15.0*len,0.012)*exp(-de*5.0)*exp(-depth*depth*0.25);\n        }\n    }\n    \n    col=clamp(col,0.0,1.0);\n    col=pow(col,vec3(2.5));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 226, 226, 325], [327, 327, 346, 346, 1008], [1010, 1010, 1067, 1067, 1759]], "test": "timeout"}
{"id": "tssyRM", "name": "Kunai[MyFirstRayMarching]", "author": "Arseny", "description": "Kunai", "tags": ["raymarching"], "likes": 2, "viewed": 196, "published": "Public API", "date": "1585415724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdOct(in vec3 p){\n    //vec3 n = normalize(vec3(1. / 3.));\n    return dot(vec3(0.57735), abs(p)) - 0.057735;\n    //return dot(vec3(1.), p) - r;\n}\n\nfloat sdTransOct(in vec3 p, in float a, in float b, in float h){\n    vec3 n = normalize(cross(vec3(a, 0, 0) - vec3(0, 0, b), vec3(0, h, 0) - vec3(0, 0, b)));\n    return dot(n, abs(p)) - a * n.x;\n}\n\nfloat sdKunaiSpear(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    p.xy = abs(p.xy);\n    vec3 A = vec3(0, h, sh);\n    vec3 B = vec3(0, 0, fl);\n    vec3 C = vec3(w, 0, 0);\n    vec3 n = normalize(cross(B - A, C - A));\n    //float d1 = dot(n, p) - fl * n.z;\n    //float d1 = (p.z < fl) ? dot(n, p) - fl * n.z : 0.;\n    float d1 = dot(n, p) - fl * n.z;\n    vec3 D = vec3(0, 0, -bl);\n    n = normalize(cross(C - A, D - A));\n    //d1 = (p.z > -bl) ? max(d1, dot(n, p) + bl * n.z) : d1;\n    d1 = max(d1, dot(n, p) + bl * n.z);\n    d1 = (p.z < sh && p.z > -0.1) ? mix(d1, smin(d1, length(p.xy), 0.04), (sh - p.z) / bl) : d1;\n    return d1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdKunaiHandle(in vec3 p, in float k, in float w, in float r){\n    p.yz = p.zy;\n    float y = p.y;\n    p.y = (y>0.&&y< k * w)?fract(p.y / w) * w - w / 2.:y - w / 2.;\n    p.y = (y>k * w)?y-k * w - w / 2.:p.y;\n    //if (y < 0.) return y;\n    return sdTorus(p, vec2(r, w));\n}\n\nfloat sdKunai(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    d = min(d, sdKunaiSpear(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    d = min(d, sdTorus(p + vec3(0, 0, 0.25), vec2(0.04, 0.02)));\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    return d;\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdOct( p * 1.1) / 1.1;\n    //float d = sdTransOct(p, 0.1, 0.3, 0.1);\n    //float d = sdKunai(p, 0.4, 0.1, 0.1, 0.03, 0.05);\n    //float d = sdTorus(p, vec2(0.2, 0.1));\n    //float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    float d = sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05);\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    d = min(d, length(p.xy));\n    //float d = sdSphere( p, 0.1 );\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 292, 292, 318], [320, 320, 343, 384, 471], [473, 473, 537, 537, 669], [671, 671, 764, 764, 1335], [1337, 1337, 1370, 1370, 1435], [1437, 1437, 1504, 1504, 1714], [1716, 1716, 1804, 1804, 2109], [2150, 2150, 2185, 2440, 2681], [2711, 2711, 2758, 2758, 2967], [2969, 2969, 3026, 3026, 3291], [3293, 3293, 3368, 3368, 3679], [3681, 3681, 3738, 3738, 3999], [4001, 4001, 4053, 4053, 4230]], "test": "ok"}
{"id": "tssyRX", "name": "Space Particle Accelerator", "author": "julianlumia", "description": ":)", "tags": ["space"], "likes": 5, "viewed": 140, "published": "Public", "date": "1585267778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 40\n#define MAX_DIST 30.\n#define SURF_DIST .001\n\n//---------\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\n\nvec2 path(float z){\n float x = sin(z) - 4.0 * cos(z * 0.3) - .5 * sin(z * 0.12345);\n float y = cos(z) - 4. * sin(z * 0.3) - .5 * cos(z * 2.12345);\n return vec2(x,y);\n}\n\n\nvec2 modA (vec2 p, float count) {\n float an = TAU/count;\n float a = atan(p.y,p.x)+an*.5;\n a = mod(a, an)-an*.5;\n return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat smin (float a, float b, float r)\n{\n float h = clamp(.5+.5*(b-a)/r,0.,1.);\n return mix(b, a, h) - r*h*(1.-h);\n}\n \n \nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\nvec2 GetDist(vec3 p) {  \n vec2 d;\n vec3 p2 = p;\n float gap = 1.;\n p2 = mod(p + gap,2.0 * gap) - gap;\n vec3 p4 = p;\n float gap2 = 1.;\n p4.z = mod(p.z + gap2,2.0 * gap) - gap;   \n vec2 box = vec2(sdBox(p2-vec3(0,0.,.0), vec3(.1,1.,.95)),3);\n vec2 box2 = vec2(sdBox(p2-vec3(0.,0.,.0), vec3(.8,.2,.95)),3);\n vec2 box3 = vec2(sdBox(p2-vec3(0,0.,0), vec3(.4,sin(p.x*1.+2.8)+0.4,.95)),3);   \n vec2 box4 = vec2(sdBox(p2-vec3(0.,-.0,-.0), vec3(0.1,.1,.1)),1);\n box = condmin(box4,box);\n p2 = vec3( p- vec3(1.,1.,.0)); \n float the = iTime *-1.;\n the = iTime *.5;\n p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float size = .3;\n p2 = abs(p2)-.8;\n vec2 dbox2 = vec2(sdBox( p2,vec3(size)),3);\n vec2 dbox20 = vec2(sdOctahedron( p2,(size)),3);\n dbox2.x = mix (dbox2.x,dbox20.x,cos(iTime));\n p2 = vec3( p- vec3(1.,1.,0.5)); \n the = iTime *-0.2;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.4;\n p2.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2 = abs(p2)-.2;\n vec2 dbox4 = vec2(sdSphere( p2-vec3(0.,-0.,-.0),(.02)),1);\n vec3 p3 = vec3( p- vec3(1.,1.,1.-2.)); \n the = iTime *-.5;\n p3.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p3.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox5 = vec2(sdBox( p3,vec3(.2)),1);\n g3 +=1./(0.1+pow(abs(dbox4.x),5.));\n g4 +=1./(1.+pow(abs(dbox5.x),1.));\n box = condmin(box3,box);\n box = condmin(box2,box);\n box.x =  smin(dbox2.x,box.x,.5);\n vec2 box7 = vec2(sdBox(p4-vec3(1,1.,0.), vec3(4.,.5,.7)),1);\n vec2 o = path(p.z) / 4.0;\n p = vec3(p)-vec3(1,1.,1.);\n p.xy *= rz2(p.z*sin(1.+iTime*2.)+2.);    \n float cyl2wave = 0.1+0.5*(sin(p.z+t*2.)*.1);\n float cylfade = 1.+smoothstep(.0,5.,abs(p.z*1.+iTime*1.));\n float cyl2r = 0.15*cyl2wave*cylfade;\n float cylT = 1.;\n float cylC = 1.;\n vec2 cyl2p = modA(p.xy, (abs(sin(t*1.)+4.)))-vec2(cyl2wave, 0)*cylfade;   \n vec2 cyl2 = vec2(cyl(cyl2p, cyl2r),1);\n vec3 cubP = p;\n float cubC = .1;\n cubP.z = mod(cubP.z, cubC)-cubC*.5;\n// cubP.xy *= rz2(t*.3);\n vec2 cub =vec2(cube(cubP,vec3(.2*cyl2wave*cylfade)),1.);    \n box.x =(max(box.x,-box7.x));   \n vec2 ebox = condmin(cyl2,box);\n ebox = condmin(ebox,dbox2);\n// ebox = condmin(ebox,cub);\n\n    g1 +=1./(.01+pow(abs(cub.x),2.));\n g2 +=1./(.01+pow(abs(cyl2.x),cos(abs(p.z)*1.+iTime*1.)*2.));\n g4 +=1./(.01+pow(abs(box4.x),sin((p.z)*.5+iTime*4.)*3.));\n d = ebox;\n return d ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 20; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>100.) break;\n  t += d * 1.;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 eye = 1.0*vec3(1.5,1.,.5);\n  float   the = (iTime*.25);\n eye.xz *= mat2(cos(the), -sin(the), sin(the), cos(the))*1.;\n vec3 hoek = vec3(1,1.,1);  \n    the = (iTime*.2)-2.5;\n// hoek.yz *= Rot(-m.y*6.2831);\n//   hoek.xz *= Rot(-m.x*6.2831);\nmat3 camera = setCamera( eye, hoek,iTime);\n float fov = .6;\n vec3 dir = camera * normalize(vec3(uv, fov));\n float lensResolution = 2.;\n float focalLenght =1.;\n float lensAperture = .03;\n float inc = 1./lensResolution;\n float start = inc/2.-1.;\n    vec3 shiftedRayOrigin;\n vec3 focalPoint = eye + (dir * focalLenght);\n for (float stepX = start; stepX < 0.5; stepX+=inc){\n for (float stepY = start; stepY < .5; stepY+=inc){\n vec2 shiftedOrigin = vec2(stepX, stepY) * lensAperture;\n  if (length(shiftedOrigin)<(lensAperture/2.5)){\n  vec3 shiftedRayOrigin = eye;\n  shiftedRayOrigin.x += shiftedOrigin.x;\n  shiftedRayOrigin.y += shiftedOrigin.y;\n  vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n  vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n  float t =d.x *1.;   \n   if(t>.001){\n    vec3 baseColor = vec3(0.,0.,0.);\n    shiftedRayOrigin += shiftedRay * t;\n    vec3 sn = GetNormal(shiftedRayOrigin);\n    shiftedRay = reflect(shiftedRay, sn);\n    if(d.y==3.) traceRef(shiftedRayOrigin +  shiftedRay*.1, shiftedRay);\n    }\n   }\n  }\n }\n vec3 d;\n d *= marchCount * vec3(1., 1.,1.) * 1.;\nd +=g1*vec3(0.0025)*abs(vec3(sin(iTime-1.)+0.5+0.5,sin(iTime-2.5)+0.5+0.5,sin(iTime-2.)+0.5+0.5)*.1);    \nd +=g2*vec3(0.001)*vec3(1.,.5,.5);    \nd +=g3*vec3(0.004)*vec3(abs(sin(iTime-2.)),.5,1.)*abs(cos(iTime*0.5));    \n d +=g4*vec3(0.001)*vec3(sin(iTime),0,0.);    \n vec3 sky = vec3(1., 1., 1.);\n d = mix(sky, d, 1.0/(d.x*d.x/1./1.*.1+1.)); \n //d*= 1.;\n fragColor = vec4(d,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 152, 152, 203], [204, 204, 233, 233, 255], [256, 256, 285, 285, 320], [322, 322, 341, 341, 489], [492, 492, 525, 525, 644], [646, 646, 686, 686, 762], [767, 767, 805, 805, 872], [874, 874, 912, 912, 963], [965, 965, 984, 984, 1051], [1054, 1054, 1087, 1087, 1112], [1114, 1114, 1143, 1143, 1221], [1274, 1274, 1296, 1296, 3699], [3702, 3702, 3735, 3735, 3946], [3967, 3967, 3998, 3998, 4232], [4235, 4235, 4277, 4277, 4431], [4433, 4433, 4484, 4484, 4645], [4647, 4647, 4670, 4670, 4854], [4857, 4857, 4914, 4914, 6728]], "test": "timeout"}
{"id": "tsXcz4", "name": "cuarto-v10-joke", "author": "jorge2017a1", "description": "cuarto-v10-joke", "tags": ["cuartov10joke"], "likes": 0, "viewed": 49, "published": "Public", "date": "1584241061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\n\n\nfloat wallyv2(vec3 p)\n{\n    p.z =p.z +  0.2 * sin(2.0 * p.x + 0.6 * iTime) * cos(2.0 * p.z + 0.4 * iTime);\n    p.y =p.y +  0.2 * sin(2.0 * p.x + 0.8* iTime) * cos(2.0 * p.z + 0.8* iTime);\n    //float  sdb2= sdBox( p-vec3(2.2,3.5,0.), vec3(2,1.0,0.2)); //Bandera\n    \n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    \n    \n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n  \n    \n   float sdwx= wallx(p);\n   //float sdwy= wally(p);\n    float sdwy= wallyv2(p);\n   float sdwz= wallz(p);\n   \n    \n   res=opU(res, vec2(sdwx,8));\n   res=opU(res, vec2(sdwy,10));\n   res=opU(res, vec2(sdwz,22));\n    \n\n   float sdc1=  sdCylinder(p-vec3(12,-5.0,-28.), vec2(2.1,20.0) );\n   float sdc2=  sdCylinder(p-vec3(-12,-5.0,-28.), vec2(2.1,20.0) );\n   res=opU(res, vec2(sdc1,21));\n   res=opU(res, vec2(sdc2,24));\n\n  \n    \n\tfloat sdb1= sdBox(p- vec3(1.,-10.0,-10.), vec3(3.0,3.0,3.0) );\n   \n    res=opU(res, vec2(sdb1,6));\n   \n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        \n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n\t}        \n    \t\n}\n\n\n//---------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n  int i;\n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t//vec3 surfaceColor3 = vec3(0.45,0.54,1.0);  \n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    \n  for( i = 0; i < 3; i++)\n  {\n    //float nearest = RayMarch(p + dir*dist);\n    float nearest = RayMarch(ro, rd);  \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = ro+rd*dist;\n      \n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n    //ro=ro+rd*EPS;\n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    vec3 ro = vec3(-2.0+10.*cos(iTime) ,6.5,10.0+ 7.0*sin(iTime));\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t  vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    //float dif = GetLightv2(p);\n    float dif = GetLightPar(p,rLuz);\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    //col= result*dif*1.1;\n    col= result*dif;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 474, 507, 507, 572], [573, 591, 627, 627, 696], [697, 712, 743, 743, 893], [894, 914, 950, 950, 1037], [1038, 1054, 1086, 1114, 1175], [1177, 1177, 1213, 1213, 1316], [1319, 1393, 1451, 1451, 1715], [1717, 1717, 1762, 1762, 1853], [1855, 1855, 1937, 1937, 2168], [2171, 2171, 2202, 2202, 2390], [2393, 2447, 2469, 2469, 3729], [3732, 3796, 3832, 3832, 4105], [4157, 4157, 4203, 4203, 4235], [4237, 4237, 4280, 4280, 4312], [4314, 4314, 4362, 4362, 4395], [4398, 4398, 4427, 4427, 4553], [4555, 4555, 4591, 4591, 4708], [4710, 4710, 4746, 4746, 4864], [4867, 4867, 4903, 4903, 5026], [5079, 5091, 5113, 5113, 5421], [5422, 5448, 5473, 5473, 5663], [5664, 5709, 5726, 5726, 5799], [5802, 5835, 5861, 5861, 6058], [6169, 6278, 6315, 6315, 6350], [6352, 6352, 6371, 6371, 6446], [6495, 6495, 6518, 6518, 6544], [6546, 6546, 6569, 6569, 6707], [6710, 6710, 6732, 6732, 6802], [6867, 6867, 6893, 6893, 6950], [6952, 6952, 6972, 6972, 7030], [7033, 7033, 7054, 7054, 7304], [7307, 7307, 7339, 7339, 7424], [7426, 7426, 7462, 7462, 7651], [7652, 7652, 7679, 7679, 8094], [8203, 8230, 8251, 8251, 8317], [8319, 8319, 8341, 8341, 8396], [8398, 8398, 8419, 8419, 8474], [8478, 8478, 8501, 8501, 8799], [8801, 8801, 8822, 8822, 8877], [8941, 8941, 8960, 8960, 9004], [9006, 9006, 9049, 9049, 10599], [10602, 10651, 10676, 10676, 11506], [11509, 11509, 11543, 11543, 11912], [11917, 11917, 11941, 11941, 12173], [12177, 12177, 12201, 12201, 12593], [12596, 12596, 12622, 12622, 12986], [12989, 12989, 13027, 13027, 13384], [13387, 13387, 13412, 13412, 13440], [13442, 13442, 13494, 13494, 13890], [13993, 14037, 14054, 14054, 14125], [14150, 14242, 14267, 14267, 14530], [14589, 14589, 14617, 14617, 21561], [21601, 21601, 21653, 21653, 21808], [21810, 21858, 21959, 21993, 22503], [22509, 22555, 22608, 22608, 23799], [23802, 23851, 23908, 23908, 25349]], "test": "error"}
{"id": "tsXcz7", "name": "Foreign Planets", "author": "rainaininn", "description": "Implicit Surface\nBased off of the the \"Elevated coast\" project created by user guil https://www.shadertoy.com/view/4l23Rh", "tags": ["terrain", "sea", "planet"], "likes": 8, "viewed": 195, "published": "Public", "date": "1584399526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time -iTime\n\nfloat dh = 0.;\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat random(float x) {\n    return fract(sin(x) * 10000.);\n}\n\nfloat noise(in vec2 p){\n    return random(p.x + p.y * 10000.);\n}\n\nvec2 sw(vec2 p) { \n    return vec2(floor(p.x), floor(p.y)); \n}\n\nvec2 se(vec2 p) { \n    return vec2(ceil(p.x), floor(p.y));\n}\n\nvec2 nw(vec2 p) { \n    return vec2(floor(p.x), ceil(p.y)); \n}\n\nvec2 ne(vec2 p) {\n    return vec2(ceil(p.x), ceil(p.y));\n}\n\nfloat smoothNoise(vec2 p) {\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n        \n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) { //S.Guillitte \n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(smoothNoise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;\n       \n\t}\n\treturn 1.-r*.5;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(smoothNoise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*(r-.2*iTime/(.1-f));\n\t}\n\treturn r/4.+.5;\n}\n\nfloat terrainIq( in vec2 x )//from IQ's Elevated : https://www.shadertoy.com/view/MdX3Rr\n{\n\tvec2  p = x;\n    float a = 0.0;\n    float b = 1.2;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn .3*a+.5;\n}\n\nfloat rocks(vec2 p){\n   return terrainIq(p);\n   //return fbmabs(p)*.5+.5;   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.3);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .25, //shading on mountain\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.01, 0.2);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 55.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nfloat Band(float t, float start,float end,float blur){\n    float step1 = smoothstep(start-blur,start+blur,t);\n    float step2 = smoothstep(end+blur,end-blur,t);\n    return step1*step2;\n}\n\nfloat Rectangle(vec2 uv,float left,float right,float bottom, float top, float blur){\n    float band1 = Band(uv.x,left,right,blur);\n    float band2 = Band(uv.y,bottom,top,blur);\n    return band1*band2;\n}\n\nvec3 light = vec3(-0.7, -0.2, .1);\nvec3 light_color = vec3(2.8,2.8,2.8);\n\nvec3 sphere = vec3(0, 0, 2); //3rd element means how into the screen it is\nvec3 sphere1 = vec3(0, 0, 3);\nfloat sphere_size = 0.4;\nvec3 sphere_color = vec3(1, 1, 1);\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\t//radius = radius * radius;\n\tfloat dt = dot(rdir, sp - rpos);\n\tif (dt < 0.0) {\n\t\treturn -1.0;\n\t}\n\tvec3 tmp = rpos - sp;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius) {\n\t\treturn -1.0;\n\t}\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 x = fragCoord.xy;\n\tvec3 a = vec3(max((fract(dot(sin(x),x))-.994)*80.,-.4));\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n    //vec3 col = vec3(0.,1.,0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.3*time);\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n    \n    float t = march(ro, rd);\n    \n    //Added planet 1\n    vec3 point; \n\tvec3 normal;\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n    \n\tvec3 ray = vec3(uv.x+1., uv.y+.42, 1.0); //position\n\tray = normalize(ray);\n\tfragColor = vec4(0.5);\n\t\n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n\t\n\tif (dist > 0.0) {\n\t\tvec3 tmp = normalize(light - sphere);\n\t\tfloat u = atan(normal.z, normal.x) / 3.1415*2.0 + iTime / 5.0;\n\t\tfloat v = asin(normal.y) / 3.1415*2.0 + 0.5;\n\t\tfragColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture(iChannel0, vec2(u, v)).xyz;\n\t} \n    \n    // Planet 2\n    vec3 ray1 = vec3(uv.x-1.4, uv.y+.6, 1.0); //position\n    ray1 = normalize(ray1);\n    float dist1 = raySphere(vec3(0.0,0.,0.0), ray1, sphere1, sphere_size, point, normal);\n\n    if (dist1 > 0.0) {\n        vec3 tmp = normalize(light - sphere1);\n        float u = atan(normal.z, normal.x) / 3.1415*2.0 - iTime / 2.0;\n        float v = asin(normal.y) / 3.1415*2.0 + 0.5;\n        fragColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture(iChannel1, vec2(u, v)).xyz;\n    }\n    \n    if(t > -0.001 )\n    {\n        vec3 pos = ro + t * rd;\n        \n        float k=rocks(pos.xz)*2.2;\n        \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.1)/2.;\n        if(dh<0.&&dh>-.03)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<-0.02){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n            col1+=vec3(0.9,0.2,.05)*dh*0.4;\n        \tcol1 += pow(max(dot(li, nor), 0.0), 4.0)*vec3(.9);\n            \n        } \n\t    col = -0.4+col1;\n        \n\t}\n    else //sky\n    \tcol = a;\n    \n    float mask;\n    vec2 uv1 = fragCoord.xy/iResolution.xy;\n    uv1 -= .5;\n    uv1.x *= iResolution.x/iResolution.y;\n\n    mask = Rectangle(uv1,-.05,.05,-.05,.023,.06);\n    vec4 col2 = vec4(2.3,1.6,1.0,1.)*mask; \n\n   \tfragColor = vec4(fragColor.xyz,0.0) + col2 + vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXcz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 173, 173, 210], [212, 212, 235, 235, 276], [278, 278, 295, 295, 340], [342, 342, 359, 359, 402], [404, 404, 421, 421, 465], [467, 467, 484, 484, 525], [527, 527, 554, 554, 759], [761, 761, 784, 808, 1122], [1125, 1125, 1149, 1164, 1332], [1334, 1334, 1356, 1356, 1554], [1556, 1556, 1646, 1646, 1896], [1898, 1898, 1918, 1918, 1976], [1978, 1978, 1998, 1998, 2133], [2135, 2135, 2164, 2164, 2338], [2340, 2340, 2367, 2367, 2511], [2513, 2513, 2550, 2550, 2847], [2849, 2849, 2876, 2876, 2928], [2930, 2930, 2984, 2984, 3116], [3118, 3118, 3202, 3202, 3320], [3562, 3562, 3661, 3690, 3980], [3982, 3982, 4039, 4039, 6465]], "test": "error"}
{"id": "tsXczH", "name": "Sphere Lighting", "author": "sevanetrebchenko", "description": "A take on diffuse/specular lighting of a sphere from a variably positioned light source.", "tags": ["reflection", "lighting", "sphere", "specular", "diffuse"], "likes": 3, "viewed": 85, "published": "Public", "date": "1584228648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float MapValueToRange(float val, float inmin, float inmax, float outmin, float outmax) {\n    return (val - inmin) * (outmax - outmin) / (inmax - inmin) + outmin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159f;\n    float diameter = 1.f;\t\t\t\t\t// radius of the sphere\n    float reflectionStrength = 0.2f;\t\t// brightness of the reflection\n    float clampStrength = 0.15f;\t\t\t// dampening factor of the reflection\n    float lightStrength = 1.f;\t\t\t\t// power of the light source\n    vec3 lightTint = vec3(1.f, 1.f, 1.f);\t// tint of the sphere\n    vec3 finalColor;\t\t \n    \n    // get UV coordinates in a range from [0 to 1]\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    // center (0, 0) UV values at center of the screen\n    // uv coordinates now go from [-0.5, 0.5]\n    uv -= 0.5;\n    // normalize UV coordinates to display resolution\n    uv /= vec2(iResolution.y / iResolution.x * (diameter / 2.f), (diameter / 2.f));\n    \n\t\t\n    // normalized mouse coordinates\n    //vec2 mouse = vec2(MapValueToRange(iMouse.x, .0f, iResolution.x, -1.f, 1.f), \n    //\t\t\t\t\tMapValueToRange(iMouse.y, .0f, iResolution.y, -1.f, 1.f));\n    // light direction with mouse input\n    // vec3 lightDirection = normalize(vec3(mouse.x, mouse.y, 1.f));\n\n    // light direction with waves\n    vec3 lightDirection = normalize(vec3(sin(iTime), cos(iTime), 1.f));\n\n    // center of the screen has normal that is (x, y, 1) so that\n    // it points directly towards the eye of the camera (part 2)\n    vec3 normal = vec3(uv, sqrt(1.0f - (uv.x * uv.x) - (uv.y * uv.y)));\n\n    // reflection on the non-illuminated side -> flip light direction and compare\n    if (dot(normal, lightDirection) > dot(normal, -lightDirection))\n        finalColor = vec3(dot(normal, lightDirection));\n    else \n        // clamp the reflected color so it's not as bright near the edges\n        finalColor = clamp(vec3(dot(normal, -lightDirection * reflectionStrength)), 0.f, clampStrength);\n\n    // Output to screen\n    fragColor = vec4(finalColor * (lightTint * lightStrength), 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 88, 88, 163], [165, 165, 222, 222, 2097]], "test": "ok"}
{"id": "tsXyD2", "name": "36 Days Of Type - D", "author": "nicolasdnl", "description": "36 Days Of Type - D", "tags": ["letter"], "likes": 1, "viewed": 33, "published": "Public", "date": "1585602550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[5], float kPath[13] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n   \t/*int kType[] = int[](0,1,0,0,0,1,0,0);\n   \tfloat kPath[] = float[]( 0.3,  0.5,\n                             0.0,  0.5, 0.001,\n                             0.0, -0.5,\n                             0.3, -0.5,\n                             0.3, -0.2,\n                             0.0, -0.2, 0.0,\n                             0.0,  0.2,\n                             0.3,  0.2,\n                             0.3,  0.5);*/\n   \tint kType[] = int[](0,0,0,0,1);\n\tfloat kPath[] = float[]( -0.05,-0.5,\n                             -0.30,-0.5,\n                             -0.30, 0.5,\n                             -0.05, 0.5,\n                             -0.05, 0.5, 0.0,\n                             -0.05,-0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    p *= 1.5;\n    \n    // distance computations\n    float d = sdA(p);\n    \n    // coloring\n    float t = mod(iTime, 1.) * 2.;\n    float gap = 3./10.;\n    \n    float dist = max(0., min(1., 1. - (d+1.)*0.25));\n    float dist2 = (d*2.+1.)*0.2;\n   \n    vec3 col = vec3(1.,1.,1.);\n    col *= 1.0 + dist2*cos(140.0*d-t*PI*2.);\n    \n    if (d > 0.25) col = vec3(1.);\n    col = generateBorder(col, abs(d-0.245));\n    col = 1. - col;\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1633, 1633, 2398], [3169, 3169, 3220, 3220, 3305], [3307, 3307, 3364, 3400, 3930]], "test": "error"}
{"id": "tsXyRH", "name": "I had a nightmare last night", "author": "tono", "description": "nightmare", "tags": ["eye", "nightmare"], "likes": 10, "viewed": 325, "published": "Public API", "date": "1584123557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define FAR 20.\n#define M(x,y) mod(x,y) - y/2.\n\n//If you want to make it worse, you need to make AA more than 2.\n#define GetsEvenWorse false\n#define AA 1\n\n#define OnlyEye false\n\nfloat pi = acos(-1.);\nfloat pi2 = acos(-1.) * 2.;\n\nfloat t,depth;\n\nvec3 cp = vec3(10.,5.,-11.);\n\nvec2 rot(vec2 p,float a){return vec2(mat2( cos(a),sin(a),-sin(a),cos(a))*p );}\n\nvec3 RotMat(vec3 p,vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nvec2 random2(vec2 st){return -1.0 + 2.0*fract(sin( vec2( dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)) ))*43758.5453123);}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n    return mix( mix( dot( vec2(v00), f - vec2(0,0) ), dot( vec2(v10), f - vec2(1,0) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0,1) ), dot( vec2(v11), f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\nfloat deMengerSponge2(vec3 p, vec3 offset, float scale) {\n    vec4 z = vec4(p, 1.0);\n    for (int i = 0; i < 3; i++) {\n        z = abs(z);\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        //if (z.y < z.z) z.yz = z.zy;\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    return rot(p,-a);\n}\n\nvec2 Polar(vec2 i)\n{\n    vec2 pl = vec2(0.);\n    pl.y = sqrt(i.x*i.x+i.y*i.y)*2.+1.;\n    pl.x = atan(i.y,i.x)/acos(-1.);\n    return pl;\n}\n\nvec3 eyemove(vec3 p)\n{\n    float tt = iTime;\n    \n    p = RotMat(p,vec3(0.3,0.2,0.6),noise(vec2(tt))/4.);\n    p = RotMat(p,vec3(0.1,0.7,0.9),noise(vec2(tt/2.))/4.);\n    p= RotMat(p,vec3(0.,1.,0.),pow(clamp(cos(tt/2.),-.2,.2)*3.,3.));\n    p= RotMat(p,vec3(1.,0.,0.),pow(clamp(sin(tt/3.5),-.3,.3)*1.,3.));\n    p = RotMat(p,vec3(1.,1.,0.),pow(clamp(sin(tt/1.5),-.17,.17)*4.,3.));\n    return p;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(0.);\n    vec3 ee = p;\n    p -= vec3(0.,1.7,7.5);\n    vec3 pp = p;\n    float w = length(ee) - 2.;\n    float w2 = length(ee) - 2.5;\n    float camera = length((ee - cp)/vec3(1.,1.,5.)) - 10.5;\n    ee = eyemove(ee);\n    ee += vec3(0.,0.,.67) ;\n    float soul = min(w,length(ee) - 1.5);\n    pp.xz = rot(pp.xz,t /17.);\n    \n    p = mod(p,18.)-9.;\n    for(int i = 0 ; i< 3; i++)\n    {\n        p.xz = abs(p.xz) - 1.6;\n        p.xy = rot(p.xy, 3. );\n        p.yz = rot(p.yz,5.);\n        p.zx = rot(p.zx,-1.);\n        \n        p.yx = abs(p.yx) - .9;\n        p.zy = rot(p.zy, -7. );\n        p.xz = rot(p.xz,5.);\n        p.xz = rot(p.xz,-1.);\n    }\n    p.xz = rot(p.xz,length(pp.xy) * 1.16 );\n    float menger = deMengerSponge2(p, vec3(1.), 3.);\n    menger = max(menger,-w2);\n    menger = max(menger,-camera);\n    if(OnlyEye)\n    {\n        d = vec2(soul,2.);;\n    }else{\n        \n        vec2 s = vec2(soul,2.);\n    \tvec2 m = vec2(menger * .3,1.);\n        d = (m.x < s.x)?m:s;\n    }\n    //d = m;\n    return d;\n}\nvec2 march(vec3 p,vec3 rd)\n{\n    depth = 0.;\n    vec2 d = vec2(.0);\n    for(int i = 0; i <55; i++)\n    {\n        d = map(p + rd * depth);\n        if(abs(d.x) < 0.001 || d.x > FAR){break;}\n        depth += d.x;\n    }\n\tif(d.x > FAR){d.x = -1.;}\n    return d;\n}\n\nvec3 eyecolor(vec3 p)\n{\n    p = eyemove(p);\n    vec3 w = vec3(.8,0.8,.8);\n    vec3 b = vec3(0.);\n    vec2 P = Polar(p.xy);\n    vec3 i = vec3(1.,1.,0.) * sin(P.y*2. - 3.5);\n    \n    b += i;\n    b *= vec3(1.,1.,1.) * noise(p.xy * 9.) * .5 +.5;\n    vec3 o = mix(w,b,step( length(p.xy),1.15) * step( p.z,.1));\n    return o;\n}\n\nvec3 mengcolor(vec3 p)\n{\n    vec3 b = vec3(0.,.5,1.);\n    b += mix(vec3(0.,0.,0.),b,step(sin(Polar(p.xy).y + p.z + t),0.));\n    return b;\n}\n\n float B(float nh, float roughness)\n{\n    nh *= nh;\n    roughness *= roughness;\n    return exp((nh - 1.) / (roughness * nh))/ (pi * roughness * nh * nh);\n}\n\nfloat C(float nl, float nv, float nh, float vh)\n{\n    return min(1. ,min(2. * nh * nv / vh,2. * nh * nl  / vh ));\n}\n\nfloat fresnelSchlick(float nv, float fresnel)\n{\n    return max(0.,fresnel + (1. - fresnel) * pow(1. - nv, 5.));\n}\n\n\nvoid scene(inout vec3 ocolor,in vec2 f)\n{\n    if( !GetsEvenWorse)cp = vec3(10.,5.,-11.);\n    if(OnlyEye)\n    {\n        cp.xz = rot(cp.xz,-pi/4.);\n    }else{\n    \tcp.z += clamp(sin(iTime/12.),-.9,.1)*10.;\n    \tcp.xz = rot(cp.xz,t/2. - cos(t/2.));\n    }\n    \n    vec2 p = (f.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 2.;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov);\n    vec3 skycolor = vec3(.2,.4,.8);\n    vec3 color = skycolor;\n    \n    vec3 light = normalize(vec3(.8,.4,.2));\n    vec2 d = vec2(-1.);\n    d = march(cp,rd);\n    if(d.x > 0.)\n    {\n        vec2 e = vec2(0.0001,0.);\n        vec3 pos = depth * rd + cp;\n    \tvec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n\n     \n        color = mix(eyecolor(pos),mengcolor(pos),step(d.y,1.));\n        vec3 view = rd;\n        vec3 hlf = normalize(light + view);\n        float nl = dot(N,light);\n        float nv = dot(N,view);\n        float nh = dot(N,hlf);\n        float vh = dot(view,hlf);\n        \n        float fresnel = 2.;\n        float roughness = .1;\n        //vec2(fresnel,roughness)\n        vec2 para = mix(vec2(4.,.07),vec2(3.,.1),step(d.y,1.));\n        \n        float dte = B(nh , para.y);\n        float gte = C(nl,nv,nh,vh);\n        float fte = fresnelSchlick(nv,para.x);\n\n        float sp = max(0.,dte * gte * fte / (nl * nv * 4.) * nl);\n\n        float dif = pow( max(0.,dot(light,N))*.5+.5,2. );\n        color =color * dif + sp * vec3(1.,1.,1.);\n        \n        \n    }\n    ocolor += color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime/2.;\n    depth = 55.;\n    vec3 color = vec3(0.);\n    for(int i = 0;i < AA;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            scene(color,fragCoord.xy + d);\n        }\n    }\n    color /= float(AA * AA);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 301, 301, 354], [356, 356, 400, 473, 965], [967, 967, 989, 989, 1095], [1097, 1097, 1120, 1120, 1565], [1567, 1625, 1682, 1682, 2109], [2111, 2111, 2139, 2139, 2251], [2253, 2253, 2273, 2273, 2390], [2392, 2392, 2414, 2414, 2784], [2787, 2787, 2805, 2805, 3823], [3824, 3824, 3852, 3852, 4082], [4084, 4084, 4107, 4107, 4405], [4407, 4407, 4431, 4431, 4546], [4549, 4549, 4585, 4585, 4703], [4705, 4705, 4754, 4754, 4820], [4822, 4822, 4869, 4869, 4935], [4938, 4938, 4979, 4979, 6659], [6661, 6661, 6718, 6718, 7094]], "test": "timeout"}
{"id": "tsXyz8", "name": "[TWITCH] Lion Snek Murph", "author": "evvvvil", "description": "Lion Snek Murph - Razult of imprivosed live kidding seshun an Twatch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "space", "particles", "snake", "beam", "glow", "robot", "scifi", "morph", "face", "spaceship", "industrial", "twitch", "lion", "improv", "transformer"], "likes": 13, "viewed": 447, "published": "Public API", "date": "1585237889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lion Snek Murph - Razult of imprivosed live kidding seshun an Twatch\n// Thankx to alkama for the \"draw a cat\" suggestion\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Those who don't like football don't know the joy of the people\" - Victor Hugo\n\nvec2 z,e=vec2(.00035,-.00035); float b,t,tt,g,g2,bb,at; vec3 np,bp,pp,po,no,al,ld;//global vars. About as exciting as Football players discussing their taste in music\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. Hey, did you know you shouldn't put people in a box? (Unless they fucking fit)\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like how acceptance speeches should be in Hollywood. Yeah Leo, it's pretty easy to lecture people from your Ivory tower.\nvec2 fb( vec3 p, float s, float m, float b ) // fb \"fucking bit\" function make a base geometry which we use to make robot faces and outter geometry using more complex positions defined in mp\n{ //fb just does a simple triple outlined box, really. Nothing is simple when you dip into triple brews though: try Triple Karmeliet beer and then we'll talk about how shit Budweiser is.\n  vec2 h,t=vec2(bo(p,vec3(5,1,1.-b)),5);// Purple gradient box, you gotta start with the first stone and yes it is facing Mecca.\n  h=vec2(bo(p,vec3(2.8,0.7,1.2-b)),6);// White box, because everybody loves the northern european socio political model, despite what the hippies in France are wearing or what the old greek ladies are drawing in the sand. (Reference to \"Diogo Diogenes vs AlexanderDaGreat 2\" - UFC Fight Night 666)\n  t=t.x<h.x?t:h; //Merge purple and white geometries while retaining material ID. Sounds like social segregation to me, but who am I kidding? I'm the one buying expensive craft beers helping hipsters achieve \"The Great Gentrification Swindle\"\n  h=vec2(bo(abs(p)-vec3(1,0,0),vec3(0.5,s,0.8-b)),m); //Small rectangles popping out of purple geometry, nice little added detail, like having a wifi connection on your sex toy\n  t=t.x<h.x?t:h; //Merge small rectangles and the rest while retaining material ID\n  h=vec2(bo(p,vec3(2.8,0.2,1.5-2.*sin(p.x*.1))),3); //Black box over white box, because white and black does a killer contrast. Yeah like killer whales or Newcastle United's home kit (not quite as deadly in attack since Alan Shearer left to swim in a pool of boring punditry)\n  t=t.x<h.x?t:h; //Merge black box and the rest while retaining material ID\n  t.x*=0.7; return t; //Tweak distance field to avoid artifact and return the whole shit\n}\nvec2 mp( vec3 p )\n{ \n  p.xy*=r2(.3);//tilt the whole fucking scene a bit forward, make it more menacing, like a cross armed BTP officers fining skateboarders in the Corporation of London\n  np=bp=pp=p; bp.xy+=vec2(3,12); bp.xy*=r2(5.5-sin(tt)*.2);pp.x=mod(pp.x+tt*5.,20.)-10.; //Setup new positions np, bp and pp used in kifs below and then  passed to fb to generate more geometries\n  at=min(0.,(length(p+vec3(sin(tt*.5)*50.,-sin(p.y*.5+tt*5.)*5.,0))-30.)/30.); //spherical field displacement reverse attractor bullshit, name it whatever you wish, I'm way too busy counting the grains of rice in this bag.\n  np.xy*=r2(mix(0.,0.8,bb)); //rotate shit to switch faces using bb variable\n  for(int i=0;i<4;i++){ //main kifs loop cloning, pushing, pulling rotating each iteration, bit like a sex club but without the overweight bouncer trying to slot himself in.\n    np=abs(np)-vec3(2,1.5-at*3.,1.6-at*5.); //abs sysmtery to push out and create more geometry each iteration, influenced by sphreical attractor above so we can push it bulbous. \"A squid eating dough in a polyethylene bag is fast and bulbous, got me?\"\n    np.xz*=r2(.785*float(i)-cos(p.y*.3)*.1+at*.2); //rotate bit more each iteration and influenced by attractor and cos\n    np.xy*=r2(.785*float(i)/2.); //rotate bit more each iteration along another axis to make it more face like\n    np.xz+=cos(p.y*.4+1.5); // this tweaks face into cheekbones and shit like that. Man I have no idea I do these things under the influence and now I'm sober so none of this makes sense. I have no idea how you tea-total nerds do it.\n    if(i<3){ //Bp is for the chin / jaw and we need less iteration this if makes sure of that, politely but with the kind of vigour that you would't wanna fuck with, especially if you are just a piece of code.\n      bp=abs(bp)-vec3(1.5,0,1.-at*7.); //another boring kifs bullshit to make more geometry out of nothing, once again eluding everyone as to my lack of Math understanding and lack of giving a fuck about it.\n      bp.xz*=r2(.785*float(i)-cos(p.y*.3)*.1); //Are we doing this again? Christ it seems as wasteful as giving ice creams to children. Yeah yeah you guessed it we rotate tiny bit each iter...\n      bp.xy*=r2(.785*float(i)/2.); //This line of code cures Cancer, solves the conflicts in the Middle East and gives you a 4 hour erection. Not really, it's just same as above, bit of rotation each iter.\n      bp.xz+=cos(p.y*.4+1.5); //again we curve things out into face-like-roundness\n    }\n    pp=abs(pp)-vec3(5,5.5,0);//Fucking hell one more kifs? One trick poney bullshit right there. Well fuck it I just needed one more kif for the structure at bottom and top\n    pp.yz*=r2(0.45);//Rather dull simple shit here brohs...\n    pp.xz*=r2(0.1); //...I've seen more exciting stuff happen at a funeral\n  }  \n  vec2 h,t=fb(np,1.2,3.,0.); //Now we have all the new positions, we call fucking bit function with the more complex position np to create faces\n  h=fb(bp,3.+sin(bp.z*.5)*2.,6.,0.); t=t.x<h.x?t:h;//Then we call again fucking bit this time with bp complex position to create the bottom jaw\n  h=fb(pp,30.,6.,0.); t=t.x<h.x?t:h; //Finally we call fucking bit a third time with pp complex position to create structure above and bellow\n  h=vec2(length(abs(p-vec3(7,1,0))-vec3(0,0,5.-at*15.))-(1.2+sin(p.y+1.)+at*2.5),6);  //EYES - Because when the grim reaper rings the bell, I wanna be able to stare at the cruel bastard.\n  h.x=min(h.x,length(abs(p.yz)-vec2(20.,0.))-0.5); // GLOWY TUBES above and bellow robot face. Everything looks better with glow sticks even overweight cyber-goth ravers.\n  h.x*=0.3;  g+=(0.1-at*5.)/(0.1+h.x*h.x*(20.-abs(sin(p.x*.2+tt*3.))*18.)); t=t.x<h.x?t:h; //Make tubes glow and sweep da beam along z axis, doesn't quite solve the disparity between the rich and the poor in middle class England but it does brithen up this scene.\n  h=vec2(length(cos(p*.5+np*.2-vec3(tt*5.0,0,0))),6);  //PARTICLES: Everybody loves glitter, makes turds look more polished and makes Boris Johnson social policies slightly less ugly to look at.\n  h.x=max(h.x,length(p.xz)-(5.+sin(p.y*.1)*20.)); // Ah yes nice fucking bounding trick here broski, nothing clever but this limits the particles to sphere above head rather than them being everywhere.\n  h.x*=0.6;  g+=0.1/(0.1+h.x*h.x*400.); t=t.x<h.x?t:h;  //Simple Balkhan glow on the particles (Thankx to Balkhan for the distance glow trick that I rinse just about every week, cheers Balkhan, you da man)\n  h=vec2(0.7*(length(p-vec3(3,-3,0))-5.5+at*10.),3);t=t.x<h.x?t:h; // MIDDLE BALL Helps hide mess in middle of face, tones down geometry, adds simple focal point to composition. In other words: if you can't beat them, join them.\n  pp=p+vec3(-6.5,-5,0);  //Building a new position pp to make the cat ears\n  pp.xz=abs(pp.xz)-vec2(0,8.-at*15.);  //Fuck yeah Einstein! A cat has two ears, so we abs symetry the fucker to have two ears instead of one.\n  pp.yz*=r2(0.75); pp.xz*=r2(0.75); //Rotate both ears almost 45 degree in both axis\n  b=abs(sin(p.y*.1+3.))*1.7; // Taper the ears with this \"b\" variable. Wishful thinking: also use \"b\" variable to taper my wife's nagging.\n  h=vec2(bo(pp,vec3(2.-b,10,3.-b)),5);  //CAT EARS, A feline ain't nothing without cat ears. This also applies to demoscener and shader queen Flopine, who also looks good with cat ears.\n  h.x=abs(h.x)-.3; //Onion skin the fucking ears to get edges and create ear holes (not to be confused with bum holes)\n  pp.xz*=r2(.7); //Seems like one more rotate, why? Not sure many synapses have been vaporized since the making of this shader. Ah yes this rotates the plane that cuts off the ears to reveal the onion skin edges. There, not such a wasteman afterall.\n  h.x=max(h.x,pp.x-0.6);h.x*=0.6; //Cut ears with plane to reveal the onion skin edges, then tweak distance field to avoid artifact due to spherical attractor\n  t=t.x<h.x?t:h; return t; // Add cat ears and return the whole shit\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>120.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>120.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  bb=0.5+clamp(sin(tt*.5),-.5,.5);\n  vec3 ro=mix(vec3(1),vec3(1,-1,-1),ceil(sin(tt*.2)))*vec3(30.+sin(tt*.2)*4.,sin(tt*.1)*3.,cos(tt*.2)*15.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.2,-.3)); //ld=light direction\n  co=fo=vec3(.0,.05,.1)*(1.5-length(uv)-.5);//background is blueish with vignette and subtle vertical gradient based on ray direction y axis. It's dark like the heart of people from Norwich.\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, just like me stumbling home after 7 pints\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=vec3(.4-sin(po.y*.5)*.2,.1,.2); //al=albedo=base color, by default it's a gradient between purple and dark blue. \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); //Sp=specular, stolen from Shane, below you will find: mix(vec3(.8),vec3(1),abs(rd))*al is a sick trick by crundle to tweak colour depending on ray direction\n    co=mix(sp+al*(a(.1)*a(.5)+.2)*(dif+s(2.)*.55),fo,min(fr,.5)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.00002*t*t*t)); //Fog soften things, but it won't stop Sophie's dildo battery from running out.\n  }\n  fragColor = vec4(pow(co+g*0.2*mix(vec3(.4,.3,.2),vec3(1,.4,.2),-at),vec3(.5)),1);// Naive gamma correction and glow applied at the end. Glow has a mix of colours to make it more interesting.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 485, 509, 509, 550], [551, 656, 673, 673, 716], [717, 879, 1071, 1256, 2629], [2630, 2630, 2649, 2649, 8535], [8536, 8536, 8618, 8618, 9386], [9476, 9476, 9605, 9605, 12287]], "test": "timeout"}
{"id": "tsXyzf", "name": "walking shadow", "author": "tono", "description": "I had a dream that only the shadow was walking when I slept twice.", "tags": ["shade", "walk"], "likes": 3, "viewed": 87, "published": "Public", "date": "1585232415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 195.\n#define M(x,y) mod(x,y) - y/2.\n#define RR(x) (x - .5) *2.\n\n#define ITR 128\n\nfloat dep,tt;\n\nfloat pi =acos(-1.);\nfloat pi2 = acos(-1.) * 2.;\n\nfloat owner = 0.;\n\nvec3 spos;\n\nfloat rsp(vec3 p, vec3 s,float r){return ( length(p / s) - r) * min(s.x,min(s.y,s.z));}\nvec2 rot(vec2 p,float a){return p * mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo( vec3 p, vec3 s ){p = abs(p) - s;return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0);}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                   dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n\n    return mix( mix( dot( v00, f - vec2(0,0) ), dot( v10, f - vec2(1,0) ), u.x ),\n                 mix( dot( v01, f - vec2(0,1) ), dot( v11, f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat fbm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st/2.;\n    for(int i = 0 ;i < 4;i++){\n        f += noise(q)/pow(2.,float(i));\n        q = q * (2.00+float(i)/100.);\n    }\n\n    return f;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat smin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 rotmat(vec3 p,vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nfloat replim( float p, float s, float l )\n{\n    return p-s*clamp(floor(p/s + .5),-l,l);\n}\n\nfloat c(float x, float f)\n{\n    return x - (x - x * x) * -f;\n}\n\n\nfloat humanF(vec3 p,float s)\n{\n    vec3 fp = p;\n\tvec3 size = vec3(1.,7.5,1.7);\n    fp.xz = rot(fp.xz,sign(s) * fp.z/9.);\n    \n    float b = bo(p + vec3(0.,0.,.3),vec3(1.,10.5,.05));\n    float h = min(rsp(fp + vec3(0.,0.,-0.4),size,.5)\n                  ,rsp(p + vec3(0.,0.,.6),vec3(.7,7.5,.9),.5));\n    h = max(h,-b);\n    p.y -= abs( sin(clamp( p.z,-.2,1. ) * 16.)/30. );\n    b = bo(p + vec3(0.,-0.6,0.),vec3(1.8,0.5,1.8));\n    h = max(h ,-b);\n    return h;\n}\n\nfloat humanLL(vec3 p)\n{\n    p.x += 0.5;\n    float ttl = tt;\n    ttl += p.y/13.;\n    p.z -= (floor(ttl / pi2) + pow( fract(ttl / pi2),7.) )* pi2;\n    p.y += 2.5 + clamp(cos(tt + pi/7.),0.,1.);\n    float s = rsp(p - vec3(0.2,1.9,1.),vec3(.6,.5,1.5),.8);\n    p.z += 0.5;\n    float l = sdCappedCylinder(p,.4,1.9);\n    l = min(s,l);\n    return l;\n}\n\nfloat humanRL(vec3 p)\n{\n    p.x -= 0.5;\n    float ttl = tt;\n    ttl += p.y/13.;\n    p.z -= (floor(ttl / pi2 + .5) + pow( fract(ttl / pi2 + .5),7.) )* pi2 - pi;\n    p.y += 2.5 + clamp(sin(tt - pi/7.),0.,1.);\n    float s = rsp(p - vec3(0.2,1.9,1.),vec3(.6,.5,1.5),.8);\n    p.z += 0.5;\n    float l = sdCappedCylinder(p,.4,1.9);\n    l = min(s,l);\n    return l;\n}\n\nfloat human(vec3 p)\n{\n    vec3 pp = p ;\n    float s = sign(sin(p.z + pi/2.));\n    pp.z = replim(pp.z,pi,floor(tt/pi));\n    pp.x += sin(p.z)/5. + s/2.;\n    float f = humanF(pp,-s);\n    return f;\n}\n\nfloat hlegs(vec3 p)\n{\n     float leg = humanLL(p);\n    leg = min(humanRL(p),leg);\n    return leg;\n}\n\nfloat rf(vec3 p)\n{\n    p.y += 1.3;\n    vec3 size = vec3(.4,2.8,.5);\n    p.xz = rot(p.xz,pi/6.);\n    float s = 100.;\n    for(int i = 0; i< 3 ; i++)\n    {\n        s = smin(s, rsp(p,size,.5),16.);\n        s = smin(s,rsp(p - vec3(0.,.7,.4),vec3(1.8,3.8,7.9),.2 ),8.3);\n        p.z += 0.5;\n        p.xz = rot(p.xz,-pi/5.);\n        p.z -= 0.5;\n    }\n    return s;\n}\n\nfloat rr(vec3 p)\n{\n    vec3 pp = p ;\n    float s = sign(sin(p.z + pi/2.));\n    pp.z = replim(pp.z,pi,floor(tt/pi));\n    pp.x += sin(p.z)/5. + s/.8;\n    float f = rf(pp);\n    return f;\n}\n\nfloat rlegs(vec3 p)\n{\n     float leg = humanLL(p/vec3(1.9 - p.y/9.,1.5,1.) + vec3(.1,.0,-1.));\n    leg = min(humanRL(p/vec3(1.9 - p.y/9.,1.5,1.)+ vec3(-.38,.0,-1.)),leg);\n    return leg;\n}\n\nfloat map(vec3 p)\n{\n    float s = -p.y - ( fbm(p.xz/1.) - .8)/3.;\n    float hs = 100.;\n    float h = human(p);\n    float w = max( max(s,h) ,-h);\n\n    hs = max(s,-h);\n    hs = min(hs,w*.55);\n    \n    float rs = 100.;\n    float r = rr(p);\n    rs = max(s,-r);\n    \n    s = mix(hs,rs,owner);\n    \n    return s * .5;\n}\n\nfloat m(vec3 cp,vec3 rd)\n{\n    float dd = 0.;\n    \n    for(int i = 0; i< ITR;i++)\n    {\n        vec3 rp = rd * dd + cp;\n        float d = map(rp);\n        if(abs(d) < 0.00001 || dd > FAR){break;}\n        dd += d;\n    }\n    dep = dd;\n    if(dd > FAR){dd *= -1.;}\n    return dd ;\n}\n\nfloat shmap(vec3 p)\n{\n    p.y *= -1.;\n    float s = 100.;\n    float hs = 100.;\n    vec3 pp = p;\n    s = hlegs(pp);\n    pp -= vec3(0.,-7.,tt);\n    pp.xz = rot(pp.xz,pp.y + tt + sin(tt /2.413));\n    float b = bo(pp,vec3(2.5,2.,0.7));\n    hs = min(s,b);\n    \n    float rs = 100.;\n    s = rlegs(p);\n    p -= vec3(0.,-7.,tt);\n\n    p.x += sin(p.z/7. + tt/3.21);\n    float c = rsp(p + vec3(0.,-4.,19.9),vec3(1.5,.7,9.),1.8);\n  //  p.xz = rot(p.xz,p.y + tt + sin(tt /2.413));\n    c = min(c,rsp(p,vec3(1.9,2.5,1.7),1.8));\n    rs = min(s,c);\n    \n    s = mix(hs,rs,owner);\n    return s * .7;\n}\n\nfloat shm(vec3 cp,vec3 rd)\n{\n     float dd = 0.;\n    \n    for(int i = 0; i< ITR;i++)\n    {\n        vec3 rp = rd * dd + cp;\n        float d = shmap(rp);\n        if(abs(d) < 0.001 || dd > FAR){break;}\n        dd += d;\n    }\n    if(dd > FAR){dd *= -1.;}\n    return dd;\n}\n\nfloat moya(vec3 cp,vec3 rd)\n{\n    float o = 0.;\n    for(int i = 1; i < 8; i++)\n    {\n        vec3 p = cp  + rd * float(i) * .9 ;\n        if(map(p) < 0.01){break;}\n        o += simplex3d(p + tt/11.675) / ( float(i)+1. );\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cp = vec3(.5,-18.9,-7.) ;\n    \n   // cp.xz = rot(cp.xz,(mouse.x - .5) * 4.);\n   // cp.yz = rot(cp.yz,(mouse.y) * 2.5);\n    vec3 cd;\n    vec3 target ;\n    float scene = mod(iTime,59.) + 30. ;\n    tt = scene * 4.34;\n    \n    vec3 fw = vec3(0.,0.,tt);\n   if(scene < 36.)\n    {//1\n        cp.xz = rot(cp.xz,4.5 );\n    \tcp.yz = rot(cp.yz,.8 );\n        cp.z += scene * 1.6; \n        target = vec3(.1,-0.5,6.6) ;\n        cd = normalize(target - cp);\n        cp += cd * -10.5; \n    }else if(scene < 48.)\n    {//2\n         cp = vec3(-.2,.9,-.5) ;\n        target = vec3(-0.13,.8,6.1);// + fw;\n    \t//cp += fw;\n        cd = normalize(target - cp);\n        cp += cd * 160.7;\n    }\n    else \n    if(scene < 68.)\n    {//walk main\n        cp.xz = rot(cp.xz,4.5);\n    \tcp.yz = rot(cp.yz,.8);\n        \n        cp = rotmat(cp,vec3(0.,1.,0.),scene/9.9 - .4);\n        target = vec3(.1,-.5,0.) + fw;\n    \tcp += fw;\n        cd = normalize(target - cp);\n        scene/=1.3;\n        owner = clamp( abs( floor(2.* sin(sin(scene * 1.35)+scene) /2.) ) ,0.,1.);\n    }\n    else if( scene < 73.)\n    {\n        cp.xz = rot(cp.xz,4.5);\n    \tcp.yz = rot(cp.yz,.8);\n        \n        cp = rotmat(cp,vec3(0.,1.,0.),-12.);\n        cp.z -= 0.;\n        target = vec3(.1,-.5,1.) ;\n        target.z += 68. * 4.34;\n    \tcp.z += 68. * 4.34;\n        cd = normalize(target - cp);\n        scene/=1.3;\n        owner = clamp( abs( floor(sin(scene/2.) + sin(scene/2.)) + sin(floor(scene/2.)))/2. ,0.,1.);\n    }\n    else if(scene < 89.)\n    {\n        cp.xz = rot(cp.xz,4.5);\n    \tcp.yz = rot(cp.yz,.8);\n        \n        cp = rotmat(cp,vec3(0.,1.,0.),-12.);\n        cp.z -= 68. ;\n        target = vec3(.1,-.5,1.) ;\n        target.z += 68. * 4.34;\n    \tcp.z += 68. * 4.34;\n        cd = normalize(target - cp);\n        scene/=1.3;\n        owner = clamp( abs( floor(sin(scene/2.) + sin(scene/2.)) + sin(floor(scene/2.)))/2. ,0.,1.);\n    }\n    \n    \n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 2.5;\n    vec3 rd = normalize(p.x * cs + p.y * cu + cd * fov);\n    float d = m(cp,rd);\n    vec3 sun = normalize(vec3(0.2,.4,.8));\n    vec3 skycolor = vec3(.9,.9,.9) ;\n\tvec3 c = skycolor;\n   \n    \n    if(d > 0.)\n    {\n        spos = rd * dep + cp;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = normalize(map(spos) - vec3(map(spos + e.xyy),map(spos + e.yxy) , map(spos + e.yyx)));\n        c = vec3(1.) ;\n        float sray = shm( (spos + N * .001) ,sun);\n        float shadow = step(sray,0.) * .4 + .6;\n        float diff = .1 + .8 * max( dot(sun,N),0.);\n        float skyc = max( dot(vec3(0.,1.,0.),N),0.);\n        float bouc = max( dot(vec3(0.,-1.,0.),N),0.);\n       // c = N;\n        c *= diff;\n        c *= shadow;\n        \n    }\n    c = mix(c,skycolor,1. - exp(-0.000003 * dep * dep * dep ));\n    c = mix(c,vec3(moya(cp,rd)*.2+.8),.3);\n    c = clamp(c,0.,1.);\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 223, 223, 276], [277, 277, 302, 302, 349], [350, 350, 377, 377, 452], [454, 528, 580, 580, 687], [689, 689, 711, 711, 855], [857, 857, 880, 880, 1303], [1305, 1305, 1327, 1327, 1497], [1499, 1499, 1521, 1521, 1718], [1865, 1888, 1913, 2172, 3164], [3166, 3166, 3206, 3206, 3275], [3277, 3277, 3321, 3321, 3813], [3815, 3815, 3858, 3858, 3904], [3906, 3906, 3933, 3933, 3968], [3971, 3971, 4001, 4001, 4430], [4432, 4432, 4455, 4455, 4775], [4777, 4777, 4800, 4800, 5135], [5137, 5137, 5158, 5158, 5332], [5334, 5334, 5355, 5355, 5433], [5435, 5435, 5453, 5453, 5794], [5796, 5796, 5814, 5814, 5981], [5983, 5983, 6004, 6004, 6171], [6173, 6173, 6192, 6192, 6486], [6488, 6488, 6514, 6514, 6767], [6769, 6769, 6790, 6790, 7352], [7354, 7354, 7382, 7382, 7621], [7866, 7866, 7923, 7923, 10924]], "test": "timeout"}
{"id": "tsXyzl", "name": "Tiny experiment with patterns", "author": "jorgemoag", "description": "Tiny experiment with patternst", "tags": ["2d", "pattern"], "likes": 3, "viewed": 87, "published": "Public", "date": "1585330760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 p)\n{\n    float x = dot(p, vec2(5281.386, -13.885));\n    return fract(48123.917*sin(x));\n}\n\nfloat layer(vec2 ap)\n{\n    vec2 p = fract(ap) - 0.5;\n    \n    float col = 0.;\n    for (float oy = -1.; oy <= 1.; ++oy) {\n        for (float ox = -1.; ox <= 1.; ++ox) {            \n            \n            vec2 offs = vec2(ox, oy);  \n            \n            vec2 qid = floor(ap) + offs;\n            vec2 qp = p + offs;\n            \n            float h = hash(qid);\n            \n            //thnx BigWIngs for the suggestion\n            vec2 c = offs + 0.5 * sin(6.2832 * vec2(h, fract(37.715 * h)) + iTime) - .5;\n            \n            float d = length(p - c);\n            \n            col += smoothstep(0.2, 0.15, d);\n            \n    \t}\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ap = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    \n    ap *= 3.;\n    \n    float a = layer(ap) + 0.5 * layer(2. * ap) + .25 * layer(4. * ap) + .125 * layer(8. * ap);\n        \n    fragColor = vec4(vec3(a),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 105], [107, 107, 129, 129, 772], [774, 774, 831, 831, 1061]], "test": "timeout"}
{"id": "tt3XWB", "name": "burn", "author": "letsparty1793", "description": "simulate paper burned", "tags": ["noise", "fbm", "dissolve"], "likes": 0, "viewed": 69, "published": "Public", "date": "1583090012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NOISE_TYPE_PERLIN 1\n#define NOISE_TYPE_VALUE 2\n#define NOISE_TYPE NOISE_TYPE_PERLIN\n\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// ========= Noise ===========\n#if NOISE_TYPE == NOISE_TYPE_VALUE\nfloat value_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n#define noise(p) value_noise(p)\n#else\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n#define noise(p) perlin_noise(p)\n#endif\n\nfloat fbm0(vec2 p)\n{\n    float d = 0.0;\n    //const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 ); \n    float m = 4.0;\n    d += 0.5 * noise(p.xyy); p = m * p;\n    d += 0.25 * noise(p.xyy); p = m * p;\n    d += 0.125 * noise(p.xyy); p = m * p;\n    d += 0.0625 * noise(p.xyy); p = m * p;\n    return d;\n}\n\nfloat fbm1(vec2 p)\n{\n    float d = 0.0;\n    //const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 ); \n    float m = 1.5;\n    d -= 0.5 * noise(p.xyy); p = m * p;\n    d -= 0.25 * noise(p.xyy); p = m * p;\n    d -= 0.125 * noise(p.xyy); p = m * p;\n    d -= 0.0625 * noise(p.xyy); p = m * p;\n    return d;\n}\n\nfloat FBM(vec2 p)\n{\n    float d = 0.0;\n    p.xy -= 0.5;\n    vec2 op = p;\n    p *= 4.0;\n    if (p.x < 10.0) {        \n        float w = 1.0;\n        d += w * noise(p.xyy); \n        \n        p *= 4.0;\n        w /= 8.0;\n        //float m = 1.8;\n        const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 ); \n        d -= w * noise(p.xyy); p = m * p; w *= 0.5;\n        d -= w * noise(p.xyy); p = m * p; w *= 0.5;\n        d -= w * noise(p.xyy); p = m * p; w *= 0.5;\n        d -= w * noise(p.xyy); p = m * p; w *= 0.5;\n    }\n    else {\n        if (p.x < 0.0) {\n            //return fbm0((p+vec2(0.5,0.0))*10.);\n            d = noise((p+vec2(0.5,0.0)).xyy*10.);\n        }\n        else {\n            d = fbm1(p*2.);\n        }\n        d = fbm1(p*1.);\n    }\n    \n    //float l = length(op) - 0.5*sqrt(2.0);\n    //d += l;\n    \n    d += 0.5;\n    \n    float x = clamp(length(op) / (0.5*sqrt(2.0)), 0.0, 1.0);\n    x = pow(x,1.0);\n    d *= x;\n    \n    d -= 0.5;\n\n    return max(d, -0.5);\n}\n\nfloat sdGrid(vec2 coord, float num)\n{\n\tvec2 f = fract(coord.xy * num);\n\treturn 1.0 - smoothstep(0.00,0.01,min(f.x,f.y));\n}\n\n#define COLOR_LEAD vec3(.95, .35, .01)\n#define COLOR_TRAIL vec3(.95, .75, .01)\n#define COLOR_BLACK vec3(.1, .1, .1)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    time = iTime;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vec3 heightmap = texture(iChannel2, uv).rrr;\n    vec3 heightmap  = vec3(FBM(uv)+0.5);\n    vec3 background = texture(iChannel0, uv).rgb;\n    vec3 foreground = texture(iChannel1, uv).rgb;\n    \n    float t = fract(-time*0.2);\n    //vec3 erosion = smoothstep(t-0.1*length(uv-0.5)*4., t, heightmap);\n    vec3 erosion = smoothstep(t-0.2, t, heightmap);\n    //erosion = erosion * erosion * erosion;\n    \n    //vec3 col = mix(foreground, background, erosion);\n    \n    \n    vec3 border = smoothstep(0.0, 0.1, erosion) - smoothstep(0.1, 1.0, erosion);\n    vec3 bordercolor = mix(COLOR_LEAD, COLOR_TRAIL, smoothstep(0.9, 1.0, border));\n    vec3 col = mix(foreground, bordercolor * border, step(0.01, border));\n    col = mix(col, background, erosion);\n    \n    //col = heightmap;\n    fragColor = vec4(col,1.0);// + vec4(sdGrid(uv-0.5, 2.));\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 181, 204, 204, 319], [321, 321, 343, 343, 495], [2171, 2171, 2191, 2191, 2464], [2466, 2466, 2486, 2486, 2759], [2761, 2761, 2780, 2780, 3727], [3729, 3729, 3766, 3766, 3851], [3969, 3969, 4026, 4026, 4956]], "test": "error"}
{"id": "ttGXWG", "name": "mandala1♡", "author": "HaleyHalcyon", "description": "no flash", "tags": ["spiral"], "likes": 4, "viewed": 117, "published": "Public", "date": "1583458992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fn2(float x)\n{\n    x = mod(x + 1.0, 2.0) - 1.0;\n    float n = x * x * x;\n\treturn (8. * n - 4. * x) * 3.14159265;\n}\n\nfloat fn(float x)\n{\n    float n = abs(sin(x));\n    return max((n - 0.5) * 1.5, 0.);\n}\n\nfloat vignette(float v, float d)\n{\n    return v * (0.8 - 0.7 * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    const float PI_3 = PI / 3.;\n    const float speed = 0.4;\n    float hue = fract(iTime / 2.) * PI;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    //float distance = length(uv);\n    //float distance = pow(sqrt(uv.x*uv.x+uv.y*uv.y), 1./3.);\n    float distance = log(uv.x*uv.x+uv.y*uv.y) / 2.;\n    float angle = atan(uv.y, uv.x);\n    \n    // Time varying pixel color\n    // spiral 1\n    float c1 = vignette(fn(distance * 3.0 + angle * 3.0 + fn2(iTime * speed) + PI), distance);\n    // spiral 2\n    float c2 = vignette(fn(distance * 3.0 - angle * 3.0 + fn2((iTime * speed) + 2. / 3.) + PI), distance);\n    // rings \n    float c3 = vignette(fn(angle * 16.0 + sin(iTime) * 8.0 - iTime * 0.5) * 0.5\n             + fn(distance * 8.0 + fn2((iTime * speed) + 4. / 3.) * 0.5), distance);\n\n    // Output to screen\n    fragColor = vec4(\n        abs(c1 * sin(hue))        + abs(c2 * -sin(hue + PI_3)) + abs(c3 * -sin(hue - PI_3)),\n        abs(c1 * sin(hue + PI_3)) + abs(c2 * -sin(hue - PI_3)) + abs(c3 * -sin(hue)),\n        abs(c1 * sin(hue - PI_3)) + abs(c2 * -sin(hue))        + abs(c3 * -sin(hue + PI_3)),\n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 120], [122, 122, 141, 141, 207], [209, 209, 243, 243, 277], [279, 279, 336, 336, 1668]], "test": "ok"}
{"id": "ttKXWG", "name": "Savanna biome", "author": "jarble", "description": "This fractal looks like a savanna.", "tags": ["fractal", "biome"], "likes": 1, "viewed": 194, "published": "Public API", "date": "1583519871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\nfloat magnify(vec2 fragCoord,float mag){\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\n\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        || magnify(fragCoord+vec2(1,0),mag) == color\n        || magnify(fragCoord-vec2(0,1),mag) == color\n        || magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\nfloat savanna_biome(in vec2 fragCoord,float mag){\n    float[] colors = float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN);\n    float color1 = magnify(fragCoord,mag);\n    while(mag > 1.0){\n    if(color1 == GREEN && is_next_to(fragCoord,mag,GRAY)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(fragCoord,mag,GRAY)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag,GREEN)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == FOREST_GREEN && is_next_to(fragCoord,mag,GREEN)){\n        color1 = GREEN;\n    }\n    mag -= 1.0;\n    }\n    return colors[int(color1)];\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tfloat biome =\n    \tsavanna_biome\n    (fragCoord,mag);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 288, 310, 310, 537], [538, 538, 578, 578, 630], [632, 632, 684, 684, 727], [729, 729, 789, 789, 1001], [1003, 1003, 1057, 1057, 1269], [1271, 1271, 1305, 1305, 1334], [1336, 1336, 1364, 1364, 1790], [2474, 2474, 2531, 2531, 2750]], "test": "error"}
{"id": "ttKXWt", "name": "Sea of Ice", "author": "jarble", "description": "I added some sine-wave distortion to my \"glacier\" fractal. This is the result.\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "sea", "ice", "iceberg"], "likes": 2, "viewed": 260, "published": "Public API", "date": "1583899929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 11.0;\nconst float distortion_scale = mag*mag;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime)*10.0,sin(fragCoord.x/(distortion_scale*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime)*10.0,sin(fragCoord.x/(distortion_scale*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime)*10.0,sin(fragCoord.x/(distortion_scale*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/(81.*81.));\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = mag*(((iMouse.x-iMouse.y)*mag+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        //forest_biome\n    \t//savanna_biome\n        glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        //combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 601, 649, 649, 996], [997, 997, 1045, 1045, 1392], [1394, 1394, 1442, 1442, 1789], [3796, 3796, 3840, 3840, 3976], [3978, 3978, 4012, 4012, 4041], [4043, 4043, 4071, 4071, 5146], [5148, 5148, 5223, 5223, 6252], [7432, 7432, 7508, 7508, 8586], [8735, 8735, 8809, 8809, 9700], [9843, 9843, 9917, 9917, 10307], [10434, 10434, 10518, 10518, 11591], [14921, 14921, 14978, 14978, 15506]], "test": "error"}
{"id": "ttKXzy", "name": "Fractal storm", "author": "jarble", "description": "I combined two of my shaders to make this animation.", "tags": ["fractal"], "likes": 1, "viewed": 162, "published": "Public API", "date": "1583086016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float RED = 5.0;\nconst float WHITE = 6.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * (.1031));\n    p3 += dot(p3, p3.yzx + 33.33+iTime/1000.);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nfloat magnify1(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nfloat pixel_above(vec2 fragCoord,float mag){\n\treturn magnify1(fragCoord+vec2(pow(2.0,mag),0)*iTime,mag);\n}\n\nvoid rainbowClouds( out float fragColor, in vec2 fragCoord,float maximum)\n{\n    float color1 = 0.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0)+magnify1(fragCoord,maximum);\n    }\n    fragColor = color1/maximum;\n}\n\nfloat magnify(vec2 fragCoord,float mag){\n\tfloat the_color;\n    rainbowClouds(the_color,fragCoord,mag);\n    return floor(the_color);\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        || magnify(fragCoord+vec2(1,0),mag) == color\n        || magnify(fragCoord-vec2(0,1),mag) == color\n        || magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n    while(mag1 < mag){\n    bool modified = true;\n    if(color1 == GREEN && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = BLUE;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag1,GREEN)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = GREEN;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord + iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 278, 300, 300, 538], [541, 541, 562, 562, 698], [701, 701, 742, 742, 791], [793, 793, 837, 837, 899], [901, 901, 976, 976, 1159], [1161, 1161, 1201, 1201, 1294], [1296, 1296, 1348, 1348, 1391], [1392, 1392, 1452, 1452, 1664], [1666, 1666, 1720, 1720, 1932], [1935, 1935, 1963, 1963, 2377], [2379, 2379, 2438, 2438, 2830], [2832, 2832, 2889, 2889, 3173]], "test": "error"}
{"id": "ttVXWt", "name": "Hopf fibers", "author": "tmst", "description": "- A volumetric visualization of the Hopf fibration.\n- Use mouse drag to change some parameters.", "tags": ["volumetric", "hopf", "fibration"], "likes": 41, "viewed": 761, "published": "Public API", "date": "1584417759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define FIXED_UP vec3(0.,1.,0.)\n#define TAN_HFOVY .5773502691896257\n\n#define GE1 vec3(.04,0.,0.)\n#define GE2 vec3(0.,.04,0.)\n#define GE3 vec3(0.,0.,.04)\n#define STEP_D .04\n\n#define RES iResolution\n#define MS iMouse\n#define PHASE smoothstep(.2, .8, MS.z > 0. ? MS.y/RES.y : .5+.5*cos(.4*iTime))\n#define ANG (MS.z > 0. ? 2.*PI*MS.x/RES.x : PI + 1.5*iTime)\n\n// ================\n// Generic helpers\n// ================\n\nfloat square(float x) { return x*x; }\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 nvCamDirFromClip(vec3 nvFw, vec2 c) {\n    vec3 nvRt = normalize(cross(nvFw, FIXED_UP));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HFOVY*(c.x*(RES.x/RES.y)*nvRt + c.y*nvUp) + nvFw);\n}\n\n// Rodrigues' formula: v -> (v.n)n + (v-(v.n)n)c - (vxn)s\nmat3 oProd(vec3 n) {\n    float xy = n.x*n.y, xz = n.x*n.z, yz = n.y*n.z;\n    return mat3(n.x*n.x,xy,xz,  xy,n.y*n.y,yz,  xz,yz,n.z*n.z);\n}\nmat3 glRotate(vec3 axis, float angle) {\n    float c = cos(angle), s = sin(angle);\n    vec3 n = normalize(axis);\n    return (\n        (1.-c)*oProd(n) +\n        mat3(c,s*n.z,-s*n.y,  -s*n.z,c,s*n.x,  s*n.y,-s*n.x,c)\n\t);\n}\n\n// Colormap adapted from: iq - Palettes (https://www.shadertoy.com/view/ll2GD3)\nvec3 colormap(float t) {\n    return .5 + .5*cos(2.*PI*( t + vec3(0.,.1,.2) ));\n}\n\n// ==================\n// Volume definition\n// ==================\n\nvec3 hopf(vec3 p) {\n\t// inverse stereographic R^3 -> S^3\n    float psq = dot(p, p);\n    vec4 q = vec4(2.*p.xyz, -1. + psq) / (1. + psq);\n\n    // hopf map S^3 -> S^2 (map versor q -> qjq*, i.e., rotate j using q)\n    return vec3(\n        2.*(q.y*q.z - q.x*q.w),\n        1. - 2.*(q.y*q.y + q.w*q.w), // == q.x^2 - q.y^2 + q.z^2 - q.w^2\n        2.*(q.x*q.y + q.z*q.w)\n    );\n}\n\nvec4 getV(vec3 p, mat3 m) {\n    // Get point on S^2, and rotate it for visual effect\n    vec3 rp = m * hopf(p);\n\n    // Fixed y == union of linked circles of same radii (interp. by theta)\n\tfloat theta = atan(-rp.z, rp.x);\n    float sdy = square(.5 + .5*cos(rp.y*5.*PI));\n    float sdt = .5 + .5*sin(theta*20.);\n    float d1 = max(sdt*sdy, .55*sdy);\n    d1 = mix(d1, .8*sdy, PHASE); // Sampling from a cubemap here is interesting\n\n    return vec4(.5 + .5*rp.y, 0., 0., d1);\n}\n\nvec4 getC(vec3 p, vec3 camPos, mat3 m) {\n    // Quick exit if volume has low alpha\n    vec4 data0 = getV(p, m);\n    if (data0.a < .4) { return vec4(0.); }\n\n    // Normal\n    vec3 gradA = vec3(\n        getV(p + GE1, m).a - getV(p - GE1, m).a,\n        getV(p + GE2, m).a - getV(p - GE2, m).a,\n        getV(p + GE3, m).a - getV(p - GE3, m).a\n    );\n    vec3 normal = (-gradA/(length(gradA) + 1e-5));\n\n    // Material color with lighting\n    vec3 matColor = mix(colormap(data0.r), .5+.5*normal.xyz, .25);\n    vec3 lightPos = camPos + vec3(0., 1., 0.);\n    vec3 nvFragToLight = normalize(lightPos - p);\n    vec3 nvFragToCam = normalize(camPos - p);\n\n\tvec3 diffuse = clamp(dot(normal, nvFragToLight), 0., 1.) * matColor;\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    vec3 specular = pow(clamp(dot(normal, blinnH), 0., 1.), 60.) * vec3(1.);\n\n    return vec4(.4*matColor+.6*(diffuse+specular), pow(data0.w, 3.));\n}\n\n// =============\n// Render scene\n// =============\n\nvoid march(in vec3 p, in vec3 nv, out vec4 color) {\n    color = vec4(0.);\n    vec2 tRange = vec2(mix(1., 2.75, PHASE), 6.);\n\n\tmat3 m = glRotate( normalize(vec3(1.,sin(iTime),1.)), -ANG );\n\n    float t = tRange.s;\n    for (int i=0; i<250; i++) {\n        vec4 cHit = getC(p + t*nv, p, m);\n\n        vec4 ci = vec4(cHit.rgb, 1.)*( (STEP_D/.08)*cHit.a ); // Premul alpha\n        color += (1.-color.a)*ci;\n\n        t += STEP_D;\n        if (t > tRange.t || color.a > .95) { return; }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/RES.xy;\n    vec3 camPos = vec3(0., 1., 3.5);\n    vec3 nvCamDir = nvCamDirFromClip(normalize(-camPos), uv*2. - 1.);\n\n    vec4 objColor;\n    march(camPos + rand(fragCoord)*nvCamDir*STEP_D, nvCamDir, objColor);\n    vec3 finalColor = objColor.rgb + (1. - objColor.a)*vec3(.2);\n\n    fragColor = vec4(finalColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 458, 458, 472], [474, 474, 494, 494, 561], [563, 563, 605, 605, 768], [770, 828, 848, 848, 966], [967, 967, 1006, 1006, 1186], [1188, 1268, 1292, 1292, 1348], [1416, 1416, 1435, 1472, 1789], [1791, 1791, 1818, 1875, 2265], [2267, 2267, 2307, 2349, 3189], [3242, 3242, 3293, 3293, 3726], [3728, 3728, 3783, 3783, 4121]], "test": "timeout"}
{"id": "ttVXzy", "name": "Flowing fractal landscape", "author": "jarble", "description": "Another variation of my fractal shader. This one \"flows\" over time.", "tags": ["fractal"], "likes": 1, "viewed": 177, "published": "Public API", "date": "1583087231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float RED = 5.0;\nconst float WHITE = 6.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,iTime*100.0),mag) == color\n        || magnify(fragCoord+vec2(1,0),mag) == color\n        || magnify(fragCoord-vec2(0,1),mag) == color\n        || magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n    while(mag1 < mag){\n    bool modified = true;\n    if(color1 == GREEN && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = BLUE;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag1,GRAY)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(fragCoord,mag1,GREEN)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(fragCoord,mag1,GRAY)){\n        color1 = GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(fragCoord,mag1,BLUE) && is_next_to(fragCoord,mag1,GRAY)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord + iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 278, 300, 300, 524], [527, 527, 567, 567, 616], [618, 618, 670, 670, 713], [714, 714, 774, 774, 986], [988, 988, 1042, 1042, 1264], [1267, 1267, 1295, 1295, 1709], [1711, 1711, 1770, 1770, 2474], [2476, 2476, 2533, 2533, 2817]], "test": "error"}
{"id": "ttySDV", "name": "Dancing snowflake", "author": "KAJAJJJ", "description": "Some description", "tags": ["snowflake"], "likes": 2, "viewed": 102, "published": "Public", "date": "1583601734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DrawFunc(float y, float f)\n{\n    return y < f - 0.01 || (y > f + 0.01) ? 0.0 : 1.0;\n}\n\nfloat Point1(vec2 xy, vec2 p)\n{\n    float d = length(xy - p) * 10.0;\n    return max(exp(-(d*d)) * 0.25, 0.0);\n}\n\nfloat Point(vec2 xy, vec2 p)\n{\n    xy -= p;\n    xy *= 2.0;\n    float col = 0.0;\n    float t = iTime;\n \n    for (int j = 0; j < 5; ++j)\n    {\n        for (int i = 0; i < 8; ++i)\n        {\n            float theta = 6.28 / 8.0 * float(i) + float(j) * (sin(t) * 0.5 + 0.5);\n            vec2 p = vec2(cos(theta), sin(theta)) * (float(j) * 0.1 + 0.1) * (cos(t) * 0.5 + 1.0);\n            col += Point1(xy, p);\n        }\n    }\n    \n    return col;\n}\n\nfloat Line(vec2 uv, vec2 start, vec2 end)\n{\n    uv.y = uv.y * 2.0 - 1.0;\n    return uv.y < sin(uv.x * 10.0) - 0.01 || (uv.y > sin(uv.x * 10.0) + 0.01) ? 0.0 : 1.0;\n}\n\nfloat Rect(vec2 uv, vec2 width, vec2 height)\n{\n    return length(max(abs(uv - vec2(0.5)) - width, 0.0)) > 0.0 ? 0.0 : 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = (uv.x - 0.5) * 4.0;\n    float y = (uv.y * 2.0 - 1.0) * 1.0;\n    \n    vec2 xy = vec2(x, y);\n    \n    vec3 col = vec3(0.0);\n    float t = iTime;\n    \n    for (int j = 0; j < 10; ++j)\n    {\n        for (int i = 0; i < 8; ++i)\n        {\n            float theta = 6.28 / 8.0 * float(i) + float(10-j) * (t)*0.5;\n            vec2 p = vec2(cos(theta), sin(theta)) * (float(j) * 0.1 + 0.1) * (cos(t) + 2.0);\n            vec3 c = vec3(1.0 / 8.0 * float(i), 1.0 - 1.0 / 8.0 * float(i), 1.0 / 10.0 * float(j));\n            col += c * Point(xy, p);\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 91], [93, 93, 124, 124, 204], [649, 649, 692, 692, 814], [816, 816, 862, 862, 940]], "test": "timeout"}
{"id": "ttySWK", "name": "Rainbow Saturn", "author": "baldand", "description": "Quick test using MaterialMaker", "tags": ["generated", "materialmaker"], "likes": 3, "viewed": 117, "published": "Public", "date": "1583581709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nGenerated using MaterialMaker\nhttps://rodzilla.itch.io/material-maker\n+ custom nodes (inc Raymarching) by PauloFalcão\n(see https://twitter.com/paulofalcao/status/1235913934516912135?s=20)\n\nManual additions to generated shader code for aspect ratio + animation\n*/\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\n// From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nvec2 sdf3dc_union(vec2 a, vec2 b) {\n\treturn vec2(min(a.x, b.x), mix(b.y, a.y, step(a.x, b.x)));\n}\nvec2 sdf3dc_sub(vec2 a, vec2 b) {\n\treturn vec2(max(-a.x, b.x), a.y);\n}\nvec2 sdf3dc_inter(vec2 a, vec2 b) {\n\treturn vec2(max(a.x, b.x), mix(a.y, b.y, step(a.x, b.x)));\n}\nvec4 o5489_p_SkyColor_gradient_fct(float x) {\n  if (x < 0.000000000) {\n    return vec4(0.793357015,0.864655972,0.979166985,1.000000000);\n  } else if (x < 0.118182000) {\n    return mix(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000), mix(vec4(0.793357015,0.864655972,0.979166985,1.000000000), vec4(0.510612011,0.698400021,1.000000000,1.000000000), (x-0.000000000)/0.118182000), 1.0-0.5*(x-0.000000000)/0.118182000);\n  } else if (x < 0.411598000) {\n    return 0.5*(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000) + mix(mix(vec4(0.793357015,0.864655972,0.979166985,1.000000000), vec4(0.510612011,0.698400021,1.000000000,1.000000000), (x-0.000000000)/0.118182000), mix(vec4(0.287342012,0.329521000,0.557291985,1.000000000), vec4(0.171140000,0.209502995,0.416667014,1.000000000), (x-0.411598000)/0.533857000), 0.5-0.5*cos(3.14159265359*(x-0.118182000)/0.293416000)));\n  } else if (x < 0.945455000) {\n    return mix(mix(vec4(0.510612011,0.698400021,1.000000000,1.000000000), vec4(0.287342012,0.329521000,0.557291985,1.000000000), (x-0.118182000)/0.293416000), mix(vec4(0.287342012,0.329521000,0.557291985,1.000000000), vec4(0.171140000,0.209502995,0.416667014,1.000000000), (x-0.411598000)/0.533857000), 0.5+0.5*(x-0.411598000)/0.533857000);\n  }\n  return vec4(0.171140000,0.209502995,0.416667014,1.000000000);\n}\nfloat o5489_input_sdf_a(vec3 p) {\nfloat r = 360.*iTime;\nfloat o403273_0_1_sdf3d = length(((p)))-0.250000000;\nvec2 o19319_0_q = vec2(length((rotate3d(((p)), -vec3(r, 39.000000000, 9.000000000)*0.01745329251)).xy)-0.450000000,(rotate3d(((p)), -vec3(r, 39.000000000, 9.000000000)*0.01745329251)).z);\nfloat o19319_0_1_sdf3d = length(o19319_0_q)-0.030000000;\nvec2 o176921_0_1_sdf3dc = vec2(o19319_0_1_sdf3d, 0.0);\nvec2 o964145_0_1_sdf3dc = sdf3dc_union(vec2(o403273_0_1_sdf3d, 0.0), o176921_0_1_sdf3dc);\n\nreturn (o964145_0_1_sdf3dc).x;\n}\nvec4 o278313_p_gradient_gradient_fct(float x) {\n  if (x < 0.000000000) {\n    return vec4(1.000000000,0.000000000,0.000000000,1.000000000);\n  } else if (x < 0.254545000) {\n    return mix(vec4(1.000000000,0.000000000,0.000000000,1.000000000), vec4(1.000000000,0.968750000,0.000000000,1.000000000), ((x-0.000000000)/0.254545000));\n  } else if (x < 0.527273000) {\n    return mix(vec4(1.000000000,0.968750000,0.000000000,1.000000000), vec4(0.000000000,1.000000000,0.125000000,1.000000000), ((x-0.254545000)/0.272728000));\n  } else if (x < 0.772727000) {\n    return mix(vec4(0.000000000,1.000000000,0.125000000,1.000000000), vec4(0.000000000,0.062500000,1.000000000,1.000000000), ((x-0.527273000)/0.245454000));\n  } else if (x < 1.000000000) {\n    return mix(vec4(0.000000000,0.062500000,1.000000000,1.000000000), vec4(0.843750000,0.000000000,1.000000000,1.000000000), ((x-0.772727000)/0.227273000));\n  }\n  return vec4(0.843750000,0.000000000,1.000000000,1.000000000);\n}\nvec3 o5489_input_tex3d_a(vec3 p) {\nvec4 o278313_0_0_rgba = o278313_p_gradient_gradient_fct(((((p).xy+vec2(0.5)))).x);\nvec3 o279673_0_1_tex3d = ((o278313_0_0_rgba).rgb);\n\nreturn (o279673_0_1_tex3d).xyz;\n}\nfloat o5489_input_sdf_b(vec3 p) {\n\nreturn ((p)).y+1.0;\n}\nvec3 o5489_input_tex3d_b(vec3 p) {\n\nreturn (vec3(mod(floor(((p)).x)+floor(((p)).z),2.0))*0.25+0.5);\n}\nvec2 input_o5489(vec3 p) {\n    float sdfa=o5489_input_sdf_a(p);\n\tfloat sdfb=o5489_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\nvec3 normal_o5489(vec3 p) {\n\tfloat d = input_o5489(p).x;\n    vec2 e = vec2(.001,0);\n    vec3 n = d - vec3(\n        input_o5489(p-vec3(e.xyy)).x,\n        input_o5489(p-vec3(e.yxy)).x,\n        input_o5489(p-vec3(e.yyx)).x);\n    return normalize(n);\n}\n\nvoid march_o5489(out float d,out vec3 p,out vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o5489(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o5489( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = input_o5489( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o5489( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o5489( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 raymarch_o5489(vec2 uv) {\n    uv-=0.5;\n    vec3 cam=vec3(sin(iTime)*1.200000000,0.700000000+sin(iTime*.3),cos(iTime)*1.800000000);\n\tvec3 lookat=vec3(0.000000000,0.000000000,0.000000000);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*1.300000000+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o5489(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o5489_input_tex3d_a(p):o5489_input_tex3d_b(p);\n\tfloat fog=max(1.0-(d/50.0),0.0);\n\tvec3 light=normalize(vec3(0.950000000,1.200000000,0.450000000));\n\tif (d<50.0) {\n\t    vec3 n=normal_o5489(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tfloat r=clamp(dot(reflect(rd,-n),light),0.0,1.0);\n\t\tfloat cAO=calcAO_o5489(p,n);\n\t\tfloat shadow=calcSoftshadow_o5489(p,light,0.05,5.0);\n\t\tcolor=min(vec3(max(shadow,0.360000000)),max(l,0.360000000))*max(cAO,0.360000000)*objColor+pow(r,200.000000000)*0.850000000;\n\t} else {\n\t    color=o5489_p_SkyColor_gradient_fct(rd.y).xyz;\n\t}\n    return color*(fog)+o5489_p_SkyColor_gradient_fct(rd.y).xyz*(1.0-fog);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 UV = fragCoord/min(iResolution.x,iResolution.y);\nUV -= .5*(iResolution.xy/min(iResolution.x,iResolution.y)-1.);\nUV.y = 1.0-UV.y;\nvec4 o5489_0_d = vec4(raymarch_o5489((UV)),1.0);\n\nvec4 o5489_0_1_rgba = o5489_0_d*1.3;\nfragColor = o5489_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 288, 288, 356], [358, 358, 378, 378, 490], [492, 492, 512, 512, 697], [699, 763, 785, 785, 1082], [1084, 1084, 1106, 1106, 1266], [1268, 1268, 1299, 1299, 1603], [1604, 1604, 1639, 1639, 1701], [1702, 1702, 1735, 1735, 1772], [1773, 1773, 1808, 1808, 1870], [1871, 1871, 1916, 1916, 3366], [3367, 3367, 3400, 3400, 3899], [3900, 3900, 3947, 3947, 4864], [4865, 4865, 4899, 4899, 5068], [5069, 5069, 5102, 5102, 5125], [5126, 5126, 5160, 5160, 5227], [5228, 5228, 5254, 5254, 5410], [5412, 5412, 5439, 5439, 5660], [5662, 5662, 5733, 5733, 5894], [5896, 5941, 5988, 5988, 6254], [6256, 6301, 6383, 6383, 6699], [6702, 6702, 6732, 6732, 7851], [7854, 7854, 7909, 7909, 8160]], "test": "timeout"}
{"id": "ttySz3", "name": "Attentive Petal", "author": "BenoitArbelot", "description": "Experiment to draw a petal or tear shape. Mouse to interact.", "tags": ["petal"], "likes": 1, "viewed": 181, "published": "Public API", "date": "1583230192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Inspired by https://thebookofshaders.com/07/ */\n\n#define PI 3.14159265\n#define rot(a)   mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec4 DrawPetalPolar(vec2 uv, vec2 pos, float size, vec2 dir){\n    \n    //Distance\n    vec2 dist = uv - pos;\n    \n    //Rotate\n    float angle = -atan(dir.y, dir.x);\n    \n    dist *= rot(angle);\n    \n    //Translate\n    dist.x -= size * 0.25f;\n    \n    //Polar coordinates\n    float r = length(dist)*2.0;\n    float a = atan(dist.y, dist.x);\n    \n    //Shaping function\n    float f = -1.;\n    \n    if(a > PI*0.5 || a < -PI*0.5){\n    \tf = size * cos(a*2.);\n    }\n    \n    return vec4(1. - smoothstep(-.8, .8, (r-f)/fwidth(r-f)));\n}\n\nvec4 DrawPetalDistance(vec2 dist, float size, vec2 dir){\n    \n    dist.y *= 5.;\n    \n    float d = length(dist);\n    \n    return vec4(smoothstep(size - 0.01, size + 0.01, d));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Petal position\n    vec2 pos = vec2(.5 + .3*cos(iTime), .5+ .3*cos(iTime*.7));\n\n    // Petal direction\n    vec2 dir = normalize(iMouse.xy/iResolution.xy - pos);\n    \n    // Output to screen\n    fragColor = DrawPetalPolar(uv, pos, 1., dir);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 188, 208, 655], [657, 657, 713, 713, 839], [841, 841, 898, 934, 1228]], "test": "ok"}
{"id": "ttyXDc", "name": "polar coords - r shear", "author": "iradicator", "description": "An experimental effect using polar coordinate system by shearing the radius coordinate, origin is also animated. \nCheck my blog post for more information: \nhttps://iradicator.com/screen-space-effects-using-polar-coordinates-linear-transformations/", "tags": ["2d", "effect", "linear", "polar"], "likes": 1, "viewed": 44, "published": "Public", "date": "1584810595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SQRT2 1.41421356237\n\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n#define sqrLength(x) dot((x),(x))\n\nfloat clamp01(in float v) { return clamp(v, 0.0, 1.0); }\nvec2 clamp01(in vec2 v) { return vec2(clamp01(v.x), clamp01(v.y)); }\n\n//////////////\n// Controls //\n//////////////\n\n// True iff using polar coordinates (otherwise cartesian) \n#define IS_USING_POLAR_COORD 1\n\n// Mix ratio between colorful uv and actual final image\n#define SHOWING_UV_RATIO 0.0 /* 0.0 - 1.0 */\n\n// Colorful uv is polar coordinates (0 for texture, not cartesian!) \n#define IS_UV_POLAR 0\n\n// mr = slope * mod(t, 2 PI * freq) (slope can be negative!)\n#define RADIUS_SHEAR_FREQ 1.0\n#define RADIUS_SHEAR_SLOPE 0.4\n\n//////////////////////\n// Texture Sampling //\n//////////////////////\n\nvec4 sample_clamp(in sampler2D tex, in vec2 uv) \n{\n    return textureGrad(tex, clamp01(uv), dFdx(uv), dFdy(uv));\n}\n\nvec4 sample_repeat(in sampler2D tex, in vec2 uv) \n{\n    return textureGrad(tex, fract(uv), dFdx(uv), dFdy(uv));\n}\n\nvec4 sample_border(in sampler2D tex, in vec2 uv) \n{\n    bool isInBorder = ((0.0 <= uv.x) && (uv.x <= 1.0) && (0.0 <= uv.y) && (uv.y <= 1.0));\n    if (isInBorder)\n        return textureGrad(tex, fract(uv), dFdx(uv), dFdy(uv));\n    return vec4(1.0, 0.0, 1.0, 1.0); // bg color - magenta    \n}\n\n////////////////////////\n// Coordinate Systems //\n////////////////////////\n\nvec2 tex_to_cartesian(in vec2 uv, in vec2 origin)\n{\n    uv = 2.0 * uv - 1.0;\n    uv -= origin;\n    return uv;\n}\n\nvec2 cartesian_to_tex(in vec2 uv, in vec2 origin)\n{\n    uv += origin;\n    uv = 0.5 * uv + 0.5;\n    return uv;\n}\n\nvec2 tex_to_polar(in vec2 uv, in vec2 origin)\n{\n    uv = tex_to_cartesian(uv, origin);\n    float r = length(uv); \n    float theta = atan(uv.y, uv.x);\n    return vec2(r, theta);\n}\n\nvec2 polar_to_tex(in vec2 rt, in vec2 origin)\n{\n    float x = rt.x * cos(rt.y);\n    float y = rt.x * sin(rt.y);  \n    return cartesian_to_tex(vec2(x,y), origin);\n}\n\n////////////////\n// Transforms //\n////////////////\n\nvec2 get_origin(in float t)\n{\n    return 0.33 * vec2(cos(t), sin(t));\n}\n\nvec2 transform(in vec2 uv, in float t)\n{    \n    float mx = RADIUS_SHEAR_SLOPE * mod(t, 2.0 * PI * RADIUS_SHEAR_FREQ);\n    return mat2(1.0, 0.0, mx, 1.0) * uv;\n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 origin = get_origin(0.25 * iTime);\n                \n    // uv_s: tex coord -> cartesian / polar coord   \n    vec2 uv_s = fragCoord / iResolution.xy;\n#if IS_USING_POLAR_COORD\n    uv_s = tex_to_polar(uv_s, origin);\n#else\n    uv_s = tex_to_cartesian(uv_s, origin);\n#endif\n      \n    // uv_s -> uv_t: transform   \n    vec2 uv_t = transform(uv_s, iTime);\n    \n    // uv_e: transformed cartesian / polar coord -> transformed tex coord\n#if IS_USING_POLAR_COORD\n\tvec2 uv_e = polar_to_tex(uv_t, origin);\n#else\n    vec2 uv_e = cartesian_to_tex(uv_t, origin);\n#endif    \n    \n    // uv_c: coloring the uv in texture / polar space\n#if IS_UV_POLAR        \n    vec3 uv_c = vec3(tex_to_polar(uv_e, origin).xy, 0.0);\n#else\n\tvec3 uv_c = vec3((uv_e - origin).xy, 0.0);\n#endif\n        \n    // final composition: texture, colorful uv or alpha (uv_s + uv_e mixture ratio)\n    vec3 col = mix(sample_border(iChannel0, uv_e).rgb, uv_c, SHOWING_UV_RATIO);    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 175, 175, 204], [205, 205, 230, 230, 273], [799, 799, 849, 849, 913], [915, 915, 966, 966, 1028], [1030, 1030, 1081, 1081, 1320], [1398, 1398, 1449, 1449, 1509], [1511, 1511, 1562, 1562, 1622], [1624, 1624, 1671, 1671, 1802], [1804, 1804, 1851, 1851, 1967], [2021, 2021, 2050, 2050, 2092], [2094, 2094, 2134, 2134, 2255], [2321, 2321, 2376, 2376, 3362]], "test": "error"}
{"id": "ttyXDd", "name": "Grid rotation illusion", "author": "jeyko", "description": "recreation of this https://youtu.be/QAja2jp1VjE?t=267", "tags": ["optical", "illusion", "reproduction"], "likes": 5, "viewed": 297, "published": "Public API", "date": "1583850784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// recreation of this https://youtu.be/QAja2jp1VjE?t=267\n\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n// thx to Fabrice for adding antialiasing\nfloat get (vec2 uv){\n    float modD = 0.024;\n    uv /= modD*2.;\n    uv = smoothstep(-fwidth(uv.x),fwidth(uv.x), 2.* abs(fract(uv)-.5)-.5); // abs(fract(uv)-.5)-.25 is more correct at the end\n    uv = 2.*uv-1.; \n    return .5+ .5* uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    \n    uv *= 1. + sin(iTime*0.5)*0.3;\n    col += get(uv)*0.9;\n    col += get(uv*rot( sin(fract(1.*iTime/3.14))*0.3));\n    col = 1. - col;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 186, 206, 206, 428], [430, 430, 487, 487, 754]], "test": "ok"}
{"id": "ttyXRd", "name": "Chess battle", "author": "creikey", "description": "A trippy spinning chessboard", "tags": ["checkerboard", "checkers", "chess"], "likes": 3, "viewed": 102, "published": "Public", "date": "1583362417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 xy, float theta)\n{\n    return vec2(xy.x*cos(theta) - xy.y*sin(theta),\n               xy.x*sin(theta) + xy.y*cos(theta));\n}\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p += cos(iTime*0.001);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // where 0.0 is the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv *= 10.0;\n    //uv.y *= 0.55;\n    \n    float floored = floor(length(uv));\n    \n    uv = rotate(uv, iTime*floored*0.3);\n    \n    \n    \n    // Time varying pixel color\n    \n    float value = -1.0 + 2.0*mod(floor(uv.x) + floor(uv.y), 2.0);\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    vec3 col = vec3(value);\n    \n    col.r *= hash11(floored)*0.4 + 0.3;\n    col.g *= hash11(floored + 7.39)*0.8 + 0.4;\n    col.b *= hash11(floored + 9.12)*0.3 + 0.6;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 139], [141, 160, 183, 183, 295], [297, 297, 354, 385, 981]], "test": "ok"}
{"id": "ttyXRy", "name": "Testing The Mandelbrot Set", "author": "abhinavneelam", "description": "trying to create the Mandelbrot Set", "tags": ["mandelbrot"], "likes": 1, "viewed": 198, "published": "Public API", "date": "1584513728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COLOR_RED vec4(1.0f,0.0f,0.0f,1.0f)\n#define COLOR_GREEN vec4(0.0f,1.0f,0.0f,1.0f)\n#define COLOR_BLUE vec4(0.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_YELLOW vec4(1.0f,1.0f,0.0f,1.0f)\n#define COLOR_LBLUE vec4(0.0f,1.0f,1.0f,1.0f)\n#define COLOR_PINK vec4(1.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_BLACK vec4(0.0f,0.0f,0.0f,1.0f)\n#define COLOR_WHITE vec4(1.0f,1.0f,1.0f,1.0f)\n\n#define W iResolution.x\n#define H iResolution.y\n#define WH iResolution.xy\n\nvec4 out_color;\nvec2 in_coord;\n\nconst int iter_c = 80;\n\nconst vec4 background = COLOR_BLACK;\n\nvoid drawRect(in vec2 pos, in vec4 color, in vec2 size)\n{\n    if(in_coord.x >= pos.x && (in_coord.x) <= pos.x + size.x && in_coord.y >= pos.y && (in_coord.y) < pos.y + size.y)\n        out_color = color;\n}\n\nvec2 multiplyComplex(vec2 a, vec2 b)\n{\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec4 pipeColor(float value)\n{\n\t//0.25,0.50,0.75,1.0f\n\tvec4 ret = COLOR_BLACK;\n    \n    ret = vec4(value);\n    \n    ret.y=0.0f;\n    ret.z=0.0f;\n        \n    return ret;\n    \n    if(value > 0.75f)\n    {\n        value -= 0.75f;\n        \n      \tret = vec4(1.0f, 1.0f, value, 1.0f);\n    }else if(value > 0.5f)\n    {\n     \tvalue -= 0.5f;\n        \n        ret = vec4(1.0f, value, 0.0f, 1.0f);\n    }else if(value > 0.25f)\n    {\n     \tvalue -= 0.25f;\n        \n        ret = vec4(value, 0.0f, 0.0f, 1.0f);\n    }\n    \n    //ret=vec4(1.0f)-ret;\n    return ret;\n}\n\nfloat convertWindowToLinearCoord(float x, float y, float norm)\n{\n    float length = distance(x,y);\n    \n    return norm * length + x;\n}\n\nfloat invert(float t)\n{\n \treturn 1.0f/t;   \n}\n\nfloat lockdown(float x, float c)\n{\n    return -5.0f * pow(0.5,x) + c;\n}\n\nfloat slowdown(float x)\n{\n \treturn 16.0 + 2.0f * log(x);\n}\n\nvoid drawMandelBrot()\n{\n\tvec2 norm_coord = (in_coord.xy/WH - vec2(0.5)) * vec2(2.0f);\n    \n    float scalingFactor = 0.05f;\n    \n    vec4 vp = vec4(-2,1,-1,1);\n    vec2 point = vec2(-0.75,-0.1);\n    \n    point=vec2(-0.761574,-0.0847596);\n    point=vec2(0.42884,-0.231345);\n    \n    vec4 vpnorm = vec4(distance(point.x,vp.x), distance(point.x,vp.y),\n                       distance(point.y,vp.z),distance(point.y,vp.w));\n\n    vec4 ratios = vpnorm;\n    \n    //debugging\n    float fakeTime = 20.0f;\n    fakeTime = slowdown(iTime);\n    \n    ratios = ratios * (scalingFactor * fakeTime);    \n    \n    vp = vec4(vp.x + ratios.x, vp.y - ratios.y, vp.z + ratios.z, vp.w - ratios.w);\n    \n    if(vp.x > point.x)\n        vp.x=lockdown(vp.x, point.x);\n    \n    if(vp.y < point.x)\n        vp.y=lockdown(vp.y, point.x);\n    \n    if(vp.z > point.y)\n        vp.z=lockdown(vp.z, point.y);\n    \n    if(vp.w < point.y)\n        vp.w=lockdown(vp.w, point.y);\n    \n    norm_coord.x = convertWindowToLinearCoord(vp.x, vp.y, in_coord.x/W);\n    norm_coord.y = convertWindowToLinearCoord(vp.z, vp.w, in_coord.y/H);\n    \n    float scalar = 3.0f;\n    \n    vec2 value = vec2(0);\n    int index=0;\n    for(int i=0;i<iter_c;++i)\n    {\n        value = multiplyComplex(value,value) + norm_coord;\n        \n        if(length(value) > 2.0f)\n        {\n            out_color = COLOR_WHITE * pipeColor(float(i)/float(iter_c));\n            return;\n        }\n        index=i;\n    }\n    out_color = COLOR_BLACK;\n}\n\nvoid drawMain()\n{\n\tdrawMandelBrot();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    in_coord = fragCoord-vec2(0.5);\n    drawMain();\n    fragColor = out_color;\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 594, 594, 741], [743, 743, 781, 781, 843], [845, 845, 874, 897, 1395], [1397, 1397, 1461, 1461, 1532], [1534, 1534, 1557, 1557, 1579], [1581, 1581, 1615, 1615, 1652], [1654, 1654, 1679, 1679, 1712], [1714, 1714, 1737, 1737, 3185], [3187, 3187, 3204, 3204, 3225], [3227, 3227, 3284, 3284, 3365]], "test": "ok"}
{"id": "WdfcD2", "name": "anotherContineousRandom", "author": "Arseny", "description": "lol", "tags": ["2d"], "likes": 1, "viewed": 199, "published": "Public API", "date": "1585645716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float x){\n    x += 0.0007;\n    x += 1224.124;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.5453);\n}\n\nvec2 getNormal(float id){\n    float rnd = (rand(id) * 2. - 1.) * 0.78539816339 / 1.1;\n    return vec2(sin(rnd), cos(rnd));\n    float ctg = -cos(rnd)/sin(rnd);\n}\n\nvec4 getCub(float h, vec2 u, vec2 C, vec2 v){\n    float d = h;\n    float c = -u.x / u.y;\n    float b = (3. * C.y + v.x / v.y * C.x - 2. * c * C.x - 3. * d) / (C.x * C.x);\n    float a = (-v.x / v.y - c - 2. * b * C.x) / (3. * C.x * C.x);\n    return vec4(d, c, b, a);\n}\n\nfloat getContRnd(float uvx){\n    float ans = 0.;\n    \n    //float x = uv.x;\n    //vec2 lv = uv;\n    float k = 1.;\n    float x = uvx;\n    \n    float id = (floor(x * k) + 0.5) / k;\n    vec4 cB = getCub(0., getNormal(id), vec2(2., 0.), getNormal(id + 1. / k));\n    x = fract(x * k) * 2. - 1.;\n    vec4 pw = vec4(1., x, x * x, x * x * x);\n    ans = (uvx >= id) ? dot(pw, cB) : ans;\n    cB = getCub(0., getNormal(id), vec2(-2., 0.), getNormal(id - 1. / k));\n    ans = (uvx <= id) ? dot(pw, cB) : ans;\n    return ans;\n}\n\nfloat N21(vec2 uv){\n    return getContRnd(uv.x - 2.521) * getContRnd(uv.y + 124.131);\n}\n\n/*vec3 grad(){\n    \n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    uv.x += iTime / 2.;\n    uv.x += 10.;\n    //uv.x = mod(uv.x, 100.);\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    col = vec3(smoothstep(-0.01, 0.01, getContRnd(uv.x) - uv.y));\n    col.x *= (getContRnd(uv.x) + 0.5) * 1.5;\n    col.y *= (getContRnd(uv.x + 163.) + 0.5) * 1.5;\n    col.z *= (getContRnd(uv.x + 2256.) + 0.5) * 1.5;\n    //col = vec3(smoothstep(0., 0.1, abs(lv.x)));\n    //col *= vec3(id);\n    \n    //x = lv.x;\n    //cB = getCub(0., vec2(0.4, 0.4), vec2(-1., 0.), vec2(-0.2, 0.4));\n    //col = vec3(sign(dot(pw, cB) - uv.y));\n    \n    //col *= id;\n\n    // Output to screen\n    //col *= grad(uv.x);\n    //col = (abs(uv.y) < 0.01) ? vec3(0., 1., 0.) : col;\n    //col = (abs(uv.y - 1.) < 0.01) ? vec3(0., 1., 0.) : col;\n    col = vec3((N21(uv * 2.) + 0.02) * 10.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 131], [133, 133, 158, 158, 293], [295, 295, 340, 340, 562], [564, 564, 592, 592, 1077], [1079, 1079, 1098, 1098, 1166], [1193, 1193, 1250, 1250, 2148]], "test": "timeout"}
{"id": "WdfcDf", "name": "construccion-v2", "author": "jorge2017a1", "description": "construccion-v2", "tags": ["construccionv2"], "likes": 2, "viewed": 54, "published": "Public", "date": "1585687518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n//const float pi = 3.1415927;\nconst float tau = 6.283185;\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r)\n{\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\nfloat mapCerrov3(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.4)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y-3.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n    float planecerro= mapCerrov2(pp-vec3(0.0,5.3,-iTime*2.0));\n    \n    vec3 p2=p;\n     p2 =rotate_z(p2,180.0*3.141516/180.);\n        \n    \n    \n    float pisocer= mapCerrov3(p+vec3(0.0,-5.3,iTime*2.0));\n    float planecerrosup= mapCerrov2(p2-vec3(0.0,-10.5,iTime*2.0));\n    \n    \n    res=opU(res, vec2(pisocer,19 ));  //piso inferior\n    res=opU(res, vec2(planecerro,9 ));\n    res=opU(res, vec2(planecerrosup,9 ));\n    \n    \n   \tvec3 p4 = p;\n   \tp4.y = p4.y-6.0;\n   \tp4.z = p4.z+iTime*2.0; \n    p4.x =mod(p4.x,8.0)-2.0;\n    p4.z =mod(p4.z,20.0)-10.0;\n    \n    \n   \n    float sdbuil1= sdBox( p4- vec3(0.0,0.0,0.0), vec3(2.0,2.0,2.0) );\n    float sdwindow1= sdBox( p4- vec3(1.0,1.0,-1.5), vec3(0.5,0.5,0.5) );\n    float sdwindow2= sdBox( p4- vec3(-1.0,1.0,-1.6), vec3(0.5,0.5,0.5) );\n    float sdwindow3= sdBox( p4- vec3(1.0,-0.5,-1.6), vec3(0.5,0.5,0.5) );\n    float sdwindow4= sdBox( p4- vec3(-1.0,-0.5,-1.6), vec3(0.5,0.5,0.5) );\n    \n   \n    \n    res=opU(res, vec2(sdbuil1,29 ));\n    res=opU(res, vec2(sdwindow1,9 ));\n    res=opU(res, vec2(sdwindow2,9 ));\n    res=opU(res, vec2(sdwindow3,9 ));\n    res=opU(res, vec2(sdwindow4,9 ));\n    \n    res=opU(res, vec2(1.0,9 ));\n    \n    \n    \n  \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    //vec2 e = vec2(0.0035, -0.0035);   \n    vec2 e = vec2(0.0001, -0.0001);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    if(i== 29 )\n    {\n    \n     \t// cafe;\n    \n        return mix(vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0),vec3(0.5))*vec3( 246./255.0, 221./255.0, 204.0/255.0);\n \n    } \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    \n    vec3 ro = vec3(-10.0 ,5.0,0.0);\n    \n    \n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 4.0, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.33;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[653, 670, 703, 703, 768], [772, 772, 807, 807, 831], [834, 849, 880, 880, 1030], [1031, 1051, 1087, 1087, 1174], [1175, 1191, 1223, 1251, 1312], [1314, 1314, 1350, 1350, 1453], [1456, 1456, 1501, 1501, 1592], [1594, 1594, 1629, 1629, 2114], [2166, 2166, 2212, 2212, 2244], [2246, 2246, 2289, 2289, 2321], [2323, 2323, 2371, 2371, 2404], [2407, 2407, 2436, 2436, 2562], [2564, 2564, 2600, 2600, 2717], [2719, 2719, 2755, 2755, 2873], [2876, 2876, 2912, 2912, 3035], [3088, 3100, 3122, 3122, 3430], [3431, 3457, 3482, 3482, 3672], [3673, 3718, 3735, 3735, 3808], [3811, 3844, 3870, 3870, 4067], [4114, 4114, 4166, 4166, 4321], [4386, 4495, 4532, 4532, 4567], [4569, 4569, 4588, 4588, 4663], [4712, 4712, 4735, 4735, 4761], [4763, 4763, 4786, 4786, 4924], [4980, 4980, 5002, 5002, 5072], [5137, 5137, 5163, 5163, 5220], [5222, 5222, 5242, 5242, 5300], [5303, 5303, 5324, 5324, 5574], [5617, 5617, 5643, 5643, 5814], [5816, 5816, 5842, 5842, 6013], [6017, 6061, 6086, 6086, 7750], [7755, 7755, 7788, 7788, 8263], [8267, 8267, 8291, 8291, 8664], [8669, 8669, 8707, 8707, 9065], [9164, 9208, 9225, 9225, 9296], [9321, 9413, 9438, 9438, 9701], [9822, 9822, 9850, 9850, 18369], [18372, 18372, 18429, 18429, 19457]], "test": "error"}
{"id": "wdfcR2", "name": "Twisters in the mist", "author": "Roninkoi", "description": "Classic demo effect. Maybe a bit distorted :)", "tags": ["demo", "twister"], "likes": 5, "viewed": 240, "published": "Public API", "date": "1585148436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 col1 = vec3(1.0, 0.4, 0.0);\nvec3 col2 = vec3(0.5, 1.0, 0.0);\nvec3 col3 = vec3(0.0, 0.8, 1.0);\nvec3 col4 = vec3(0.7, 0.0, 1.0);\n\nvec3 sk;\n\nfloat yb(float y0, float y1, float y)\n{\n    //return y0 < y && y1 > y ? min(1.1, smoothstep(y0, y1, y)*1.0 + 0.7) : 0.;\n    float ss = (smoothstep(y1, (y0 + y1)*0.5, y) * smoothstep(y0, (y0 + y1) * 0.5, y))*0.5;\n    return y0 < y && y1 > y ? min(1.1, sqrt(sqrt(sqrt(ss)))*1.2 + ss) : 0.;\n}\n\nfloat st(float y0, float a, float d, float y)\n{\n    return yb(y0 + sin(a) * d - cos(a) * d, \n              y0 + sin(a) * d + cos(a) * d, y);\n}\n\nvec3 twister(vec3 color, float y0, float a, float d, float y, float z)\n{\n    float f = min(1., exp(-z * 0.00065));\n    \n    vec3 col = mix(color, col1, st(y0, a, d, y));\n    \n    a += 1.570;\n    col = mix(col, col2, st(y0, a, d, y));\n    \n    a += 1.570;\n    col = mix(col, col3, st(y0, a, d, y));\n    \n    a += 1.570;\n    col = mix(col, col4, st(y0, a, d, y));\n    \n    return sk * (1. - f) + col * f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.5;\n    \n    float sy = sin(uv.y+1.57);\n    sk = vec3(sy*sy * 0.3 + (1. - sy) * 0.9, sy*sy*0.7, sy*1.5);\n    vec3 col = sk;\n    \n    float s = iTime * 5.;\n    \n    for (int i = 40 + int(s); i >= int(s); --i) {\n        float ri = float(i);\n        \n    \tfloat a = sin(iTime * (cos(ri) + 1.1));\n    \tfloat ax = uv.y * 7. * sin(iTime * cos(ri));\n        \n        float z = (ri - s) * 10.;\n        \n        if (z < 0.)\n            continue;\n        \n        float x = ((cos(ri * 0.87) + sin(ri * 0.87)) * 45.7);\n        \n        if (x < 10. && x > 0.)\n            x += 12.;\n        \n        if (x > -10. && x < 0.)\n            x -= 12.;\n            \n    \tcol = twister(col, x / z, a + ax + cos(ri), 3. / max(abs(z), 1.), uv.x, z);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 182, 262, 432], [434, 434, 481, 481, 576], [578, 578, 650, 650, 982], [984, 984, 1039, 1039, 1864]], "test": "timeout"}
{"id": "WdfcRM", "name": "Tripattern", "author": "jahnertz", "description": "Just an exercise", "tags": ["triangle", "pattern"], "likes": 3, "viewed": 54, "published": "Public", "date": "1584328502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tri(vec2 st, float pct){\n  return 1.0 - smoothstep( pct, pct+0.05, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color_a = vec3(uv.x * 0.2 + 0.8,0.2,0.0);\n    vec3 color_b = vec3(0.0,0.1,uv.y * 0.5 + 0.5);\n    vec3 color_c = vec3(0.6,0.5,0.0);\n    float s = 10.0;\n    uv *= s;\n    uv.x += iTime;\n    float y1 = mod(uv.x,1.0) + sin(uv.x / s + iTime * 2.0)+ sin(uv.y / s + iTime);\n    float y2 = mod(uv.x,1.0) + sin(uv.x / s + iTime + 1.0 * 2.0) + sin(uv.y / s + iTime);\n    vec3 col = color_a + vec3(tri(mod(uv,1.0), y1) * color_b + vec3(tri(mod(uv,1.0), y2)) * color_c);\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 81], [83, 83, 140, 190, 887]], "test": "timeout"}
{"id": "WdfcWN", "name": "param_v29", "author": "darkczar", "description": "more tweaks", "tags": ["psychedelic", "learning", "epicycles"], "likes": 0, "viewed": 43, "published": "Public", "date": "1584817036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    float d2 = 10002.0;\n    float d3 = 10003.0;\n    float di = 0.;\n    float threshold = 0.000000005;//0000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    float black_threshold=0.;//5;// -.5*nsin(iTime*.6);\n\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*14.3;\n        curve_p.x = -.1*sin(.6*iTime)+.02*float(di)*sin(float(di)+.4*iTime) +.03*float(di)*sin(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.8*iTime);\n        curve_p.y = -.1*cos(.6*iTime)+.02*float(di)*cos(float(di)+.4*iTime) +.03*float(di)*cos(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.8*iTime);\n        dtemp = pow(length(2.3*float(i)*p-curve_p),2.);\n\n\n        d= dot(normalize(p),normalize(curve_p))+3.*nsin(.5*iTime+d*d);\n        if(d<black_threshold) d=0.;   \n        r = 28.*rand(vec2(float(i),float(i))); // +nsin(iTime*.8);\n        g = g+.04*d*dtemp;\n        b = .004*dtemp*dtemp-d - 3.5*mod(log(.6*dtemp*dtemp-3.*d),.60); //+.001*rand(vec2(34.3,floor(dtemp*32.))); //b + .05*dtemp-.05*d;  \n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [358, 358, 415, 465, 1901]], "test": "timeout"}
{"id": "wdfcz2", "name": "countach sdf", "author": "flockaroo", "description": "legendary lamborghini countach. ...with all best wishes to italy!\nvery rudimentary shading now ...thought i'd post it before windows compile times explode (and debug-colors are not completely without charm now and then...)", "tags": ["sdf", "car", "lamborghini", "countach"], "likes": 22, "viewed": 563, "published": "Public API", "date": "1585147415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// lamborghini countach\n\n// new/old model of countach (basically just the tires differ for now)\n//#define NEW_MODEL\n//#define WIREFRAME\n//#define CUBEMAP\n\n#define RandTex iChannel0\n\n#define Res (iResolution.xy)\n\n#define iMouseData vec4(0)\n\nconst vec3 BodySize=vec3(1.8,4.14,1.0);\n\n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    //p.z+=cos(ang*100.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.122*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n\n    float d=1000.;\n    float dmain=distCyl(p,r+sh-.005,w-.005)-.005;\n    d=min(d,dmain);\n\n    //d=max(d,-(distCyl(p-vec3(0,0,w*.5),r-sh*.5-.005,w*.05-.005)-.005));\n    float d2=length(p-vec3(0,0,+w*.03+r*1.5))-r*1.5;\n    d2=-smin_(-d2,-(distCyl(p-vec3(0,0,w*.5),r-sh*1.2-.005,w*1.-.005)-.005),.005);\n    d=-smin(-d,d2,.01);\n\n    float mang,ang;\n    float ang0 = atan(p.y,p.x);\n    float dang;\n#ifdef NEW_MODEL\n    dang=PI2/5.;\n#else\n    dang=PI2/15.;\n#endif\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    // rim holes\n#ifdef NEW_MODEL\n    d=max(d,-distCyl(p-vec3(r*.53*cos(ang-vec2(0,PIH)),0.),.17*r,w*1.3));\n#else\n    d=max(d,-distBox(rotZ(-ang,p-vec3(r*.64*cos(ang-vec2(0,PIH)),0.)),vec3(.17*r,.17*r,w*1.3)*.52));\n#endif\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    // screw holes\n    d2=distCyl(p-vec3(r*.28*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    d=max(d,-d2);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.03-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel1,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\nfloat distCar(vec3 p)\n{\n    vec3 p1,p2;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    // torus\n    float d=10000.,d2;\n    p=p0-vec3(-p.y*.01,0,0);\n    vec3 p01=p;\n    float yfall=min((p.y+0.0)*abs(p.y+0.0),0.);\n    float yfall2=(p.y>.0?2.5:7.)*min((-abs(p.y)+1.2)*abs(-abs(p.y)+1.2),0.);\n    yfall=mix(yfall,yfall2,step(0.,-p.z));\n    //yfall=0.;\n    // ----------- 1 ------------------ side phase\n    d2=dot(p-.51*BodySize*vec3(.5,0,1.+.15*yfall)-(.2+.2*p.y)*max(0.,p.x-.92+p.y*.03)*vec3(0,0,1),normalize(vec3(.8,0,1.-.9*yfall)));\n    d=min(d,d2);\n    \n    // ----------- 3 ------------------\n    vec3 n=normalize(vec3(0,1,2.5));\n    float dpx=max(p.x*1.-1.,-.5);\n    float dpy=max(p.y-.78+.65*dpx,0.);\n    p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*(1.-exp(-dpy/.2)-dpy*.8);\n    //vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*min(1.-dpy*.2,1.);\n    // ----------- 2 ------------------ front cut\n    d2=dot(p2-.5*BodySize*vec3(0,1,1)-vec3(0,0,-.75),normalize(vec3(0,1,2.5)));\n    d=-smin_(-d,-d2,.06*exp(-(p.y-1.1)*(p.y-1.1)*3.));\n    //d=-smin(-d,-d2,.13*clamp(1.-(p.y-1.)*(p.y-1.)*1.2,0.,1.));\n    //d=-min(-d,-d2);\n    \n    // -------------------------------- main box ---- done after cuts to get sharp contour line on sides (no smin there)\n    d2=distBoxR(p+vec3(min(+.35*p.z*p.z,.1),0,0),\n                vec3(BodySize.xz,100).xzy*.5*vec3(exp(-(step(0.,p.y)*2.+2.)*p.y*p.y*p.y*p.y/500.),1,1.+.15*yfall),\n                max(.02,-1.*p.z-.07*p.y));\n    d=max(d,d2);\n    \n    // ----------- 4 ------------------ engine cover\n    p-=vec3(0,-1.65,.48);\n    vec3 bs=vec3(BodySize.x*.25*1.1-p.y*.17+p.z*.4,1,.3);\n    d2=distBoxR(p+vec3(0,0,-p.y*.14),bs,.02);\n    d=max(d,-d2);\n    float pry=clamp(floor(p.y/.22+.5),1.,4.)*.22;\n    d2=distBoxR(p+vec3(0,-pry,.01-p.y*.14),bs-vec3(.06,.92,0),.02);\n    d=max(d,-d2);\n\n    d2=abs(p0.y)-BodySize.y*.5;\n    d2+=.005*exp(-(length(vec2(max(d+.03,0.),d2)))/.0025);\n    d=-smin_(-d,-d2,.01);\n    \n    d2=distBox(p01-vec3(0,-1.1,.3),vec3(.47,.5,.5));\n    d+=.004*exp(-abs(d2)/.004);\n\n    // ------------------------------- side air hole\n    p=p0-vec3(.9,-.35,.04);\n    float sn=(.6-.4*sin(p.y*6.));\n    d2=distBox(p,vec3(.2*sn,.5,.23*sn)*.5-.02)-.02;\n    d=max(d,-d2);\n\n    // ------------------------------- upper air hole\n    p=p01-vec3(.67,-.627,.35);\n    d2=distBoxR(p,vec3(.32,.45,.25)*.5,.02-p.y*.15);\n    //d=max(d,-d2);\n    float d3=dot(p,normalize(vec3(.58,-.5,1.)));\n    float lw=.028+p.x*.028;\n    d3=(fract(d3/lw)-.5)*lw;\n    d3=abs(d3)-lw*.3;\n    d3=max(d2,-d3);\n    //d2=max(d2,-d3);\n    d3=max(d3,(d+.01-p.y*.045));\n    d=max(d,-d2);\n    d=min(d,d3);\n\n    // make hollow (6cm thick)\n    //d=abs(d+.03)-.03;\n    \n    // ------------------------------ door\n    //   --- front win border\n    d2=dot(p01-vec3(.475,.19,0),normalize(vec3(2.,-1,0)));\n    //   --- inner border\n    d2=min(d2, dot(p01-vec3(.475,.19,0),normalize(vec3(1,0,0))) );\n    d3 = d2;\n    p=p01-vec3(.475,-.4,0);\n    float s=step(0.,-(p0.z-.2))*((p0.z-.2)*(p0.z-.2)-.25*(p0.z-.2));\n    p.y=p.y-s;\n    //   --- front door border\n    float dr=dot(p,normalize(vec3(0,1,0)));\n    d2=min(d2, dr );\n    p.y=p.y+2.*s-1.35;\n    float d4=10000.;\n    //   --- rear door border\n    d4=min(d4, dot(p,normalize(vec3(0,-1,0))) );\n    //   --- floor door border\n    d4=min( d4, dot(p01-vec3(0,0,-.22),normalize(vec3(0,0,1))) );\n    //d+=.005*exp2(-length(vec2(d2-.0,d))/.0025);\n    d2=min(d2,d4);\n    d+=.003*exp2(-abs(d2)/.003);\n    \n    // ------------------------------ side window\n    d4=min(d4, dot(p01-vec3(.87,0,0),normalize(vec3(-1,0,0))) );\n    d2=min(d2,d4);\n    d3-=.22;\n    //d3=min(d3,min(d4,dr)-.04);\n    //d3-=.22;\n    d+=.005*exp2(-length(vec2(min(d2-.04,0.),d))/.0025);\n    if(d3<min(d4,dr)-.04)\n    //d+=.003*exp2(-d3*d3/.003/.003);\n    d=min(d,length(vec2(d3,d))-.003);\n\n    // ------------------------------- front lights\n    p=p0-vec3(.65,1.6,0);\n    d2=distBox(p,vec3(.32-step(0.,p.x)*.25*p.y,.16,.2)*.5);\n    //d=max(d,-sqrt(d*d+d2*d2)+.005);\n    d+=.003*exp(-abs(d2)/.003);\n    p=p0-vec3(.63,1.85,0);\n    d2=distBox(p,vec3(.29-step(0.,p.x)*.45*p.y,.16,.34)*.5);\n    d=max(d,-d2);\n\n    // ------------------------------ wheels\n    p1=BodySize*.5*vec3(1, .59,-.65);\n    p2=BodySize*.5*vec3(1,-.63,-.65);\n    d=max(d,-distCylR((p0-p1).yzx,.35,.85,.05));\n    //d=max(d,-distCylR((p0-p2).yzx,.35,.8,.05));\n    d=max(d,-distBoxR(rotZ(0.4,(p0-p2).yzx),vec3(.37,.28,.45)+.015,.2-(p0-p2).y*.2));\n    //d=min(d,distCylR((p0-p1-vec3(-.18,0,.04)).yzx,.31,.27,.08));\n    //d=min(d,distCylR((p0-p2-vec3(-.145,0,.04)).yzx,.31,.27,.08));\n    //return distWheelDim(pos,345.,35.,15.,10.,2.7);\n\n    //d=min(d,distWheelDim((p0-p2-vec3(-.13,0,.04)).yzx,215.,70.,14.,20.,1.));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.16,0,.04)).yzx,205.,70.,14.,20.,1.));\n\n#ifndef NEW_MODEL    \n    float wheelDimRear [] = float[](215.,70.,14.,15.,1.);\n    float wheelDimFront[] = float[](205.,70.,14.,15.,1.);\n    vec3 pfront = p1+vec3(-.16,0,.04);\n    vec3 prear  = p2+vec3(-.13,0,.04);\n#else\n    float wheelDimRear [] = float[](345.,35.,15.,12.,2.7);\n    float wheelDimFront[] = float[](205.,50.,15.,12.,1.);\n    vec3 pfront = p1+vec3(-.15,0,.04);\n    vec3 prear  = p2+vec3(-.19,0,.04);\n#endif\n    \n    bool front = p0.y>0.;\n    p=p0-(front?pfront:prear);\n    d=min(d,\n        distWheelDim(p.yzx,\n                     front?wheelDimFront[0]:wheelDimRear[0],\n                     front?wheelDimFront[1]:wheelDimRear[1],\n                     front?wheelDimFront[2]:wheelDimRear[2],\n                     front?wheelDimFront[3]:wheelDimRear[3],\n                     front?wheelDimFront[4]:wheelDimRear[4])\n         );\n         \n    //d=min(d,distWheelDim((p0-p2-vec3(-.19,0,.04)).yzx,345.,35.,15.,10.,2.7));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.15,0,.04)).yzx,205.,50.,15.,10.,1.));\n    //d=max(d,-(length(p0-p1*vec3(1,-1,1))-.37));\n    \n    //p=p0-vec3(p.y*.02,0,0);\n    \n    /*d=min(d,length(p0.xy-floor(p0.xy+.5))-.01);\n    d=min(d,length(p0.yz-floor(p0.yz+.5))-.01);\n    d=min(d,length(p0.zx-floor(p0.zx+.5))-.01);*/\n    \n    //d2=length(vec2(length(p.xy)-2.5,p.z))-.01;\n    //d=min(d,d2);\n    return d;\n}\n\nbool carEnabled;\n\nfloat dist(vec3 p)\n{\n    float d=10000.;\n    \n    // ----------------------------- car\n    if(carEnabled)\n        d=min(d,distCar(p));\n    \n    // ----------------------------- floor\n    d=min(d,(p.z+.6));\n\n    return d;  \n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<eps) return 1.;\n    }\n    return 0.;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1.5)+vec3(sc,0));\n    pos=vec3(0,0,4.5*exp(-iMouseData.z/3000.));\n    float ph = iMouse.x/Res.x*10.;\n    float th = iMouse.y/Res.y*10.;\n    if (iMouse.x<1.) { ph=-iTime*.3; th=1.3; }\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\nfloat fermi(float x) { return 1./(1.+exp(-x)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    carEnabled=intersectBox(pos-vec3(0,0,-.05),dir,BodySize+vec3(0,0,.1));\n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    carEnabled=true;\n    vec3 left=normalize(cross(vec3(0,0,1),dir));\n    vec3 up  =normalize(cross(left,dir));\n    vec3 g=getGrad(pos,.003);\n    #ifdef WIREFRAME\n    vec3 gl=getGrad(pos-dir*.00+left*.004,.003);\n    vec3 gu=getGrad(pos-dir*.00+up*.004,.003);\n    #endif\n    float lg=length(g);\n    vec3 n=g/(lg+.000001);\n    float ao=1., ao2;\n    float p=.5;\n    float fp=exp2(p*1.5);\n    for(int i=0;i<10;i++)\n    {\n        float f=1.*exp2(-float(i)*p);\n        ao2=clamp(dist(pos+n*f)/dist(pos+n*f*fp)*fp,0.,1.);\n        //ao=min(ao,ao2);\n        //ao+=ao2;\n        ao*=ao2/**.7+.3*/;\n    }\n    //ao=exp2(ao);\n    fragColor.xyz=n*.3+.5;\n    //fragColor.xyz=vec3(0);\n    vec3 R=reflect(dir,n);\n    vec4 refl=myenv(vec3(0),R,1.);\n    float fres=1.-abs(dot(R,n));\n    fres*=fres*fres;\n    fres=.1+.7*fres;\n    // not the proper way to multipy refl with ao, but looked strange with strong reflections even in wheelcase\n    fragColor=mix(fragColor,refl*(ao*.35+.65),fres);\n    //fragColor.xyz=vec3(.9);\n    fragColor.xyz*=ao*.3+.7;\n    float d=length(pos-pos0);\n    fragColor=mix(fragColor,myenv(vec3(0),dir,1.),1.-exp(-d/100.));\n\n    #ifdef WIREFRAME    \n    //fragColor.y+=.5*dot(fwidth(g),fwidth(g));\n    fragColor.y+=length(gl+gu-g-g)*.25;\n    float tile=.2;\n    vec3 frp=sin(pos/tile*PI2*.5);\n    vec3 w3=fwidth(frp)*.5;\n    vec3 w2=w3*w3;\n    fragColor.y+=clamp(1.5-.15*length(pos),0.,1.)*.25*(exp(-frp.x*frp.x/w2.x)+exp(-frp.y*frp.y/w2.y)+exp(-frp.z*frp.z/w2.z));\n    #endif\n    \n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[653, 653, 682, 682, 717], [719, 719, 752, 820, 978], [980, 980, 1006, 1091, 1122], [1124, 1124, 1155, 1155, 1246], [1248, 1248, 1291, 1291, 1359], [1361, 1361, 1389, 1389, 1490], [1492, 1492, 1529, 1529, 1604], [1606, 1629, 1668, 1668, 1766], [1768, 1768, 1817, 1817, 1857], [1859, 1859, 1902, 1902, 2009], [2011, 2011, 2064, 2064, 2181], [2183, 2183, 2226, 2226, 2278], [2280, 2316, 2357, 2357, 2443], [2445, 2480, 2522, 2522, 2615], [2617, 2667, 2734, 2734, 3375], [3377, 3377, 3461, 3461, 4524], [4526, 4526, 4632, 4632, 4932], [4935, 4935, 4983, 4983, 5366], [5368, 5368, 5394, 5394, 5630], [5716, 5762, 5809, 5809, 6710], [12806, 12806, 12826, 12826, 13030], [13032, 13032, 13066, 13066, 13190], [13192, 13192, 13231, 13231, 13386], [13388, 13388, 13444, 13444, 13803], [13805, 13805, 13827, 13827, 13853], [13855, 13855, 13912, 13912, 15591]], "test": "error"}
{"id": "wdfcz4", "name": "axis&circle_indere", "author": "indere", "description": "axis", "tags": ["2d"], "likes": 2, "viewed": 214, "published": "Public API", "date": "1584327846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 drawGrid(float step, vec3 color, vec2 uv){\n    float len = 0.005;\n    float blur = 0.01;\n    vec3 res = vec3(1.0);\n    \n    \n\tif(abs(uv.x - floor(uv.x/step) * step) < len \n       || abs(uv.x - ceil(uv.x / step) * step) < len\n       || abs(uv.y - floor(uv.y/step) * step) < len \n       || abs(uv.y - ceil(uv.y / step) * step) < len\n      )\n        res = color;\n   \t\n    //y_axis\n    if(abs(uv.x) < len)\n        res = vec3(1.0,.0,0.0);\n    \n   \t//x_axis\n    if(abs(uv.y) < len)\n        res = vec3(0.0,.0,1.0);\n\t\n    return res;\n}\n\nvec3 drawCircle(vec2 center, float radius, vec2 uv, bool full){\n\tfloat e = 0.01;\n    float len = length(center - uv);\n    if(full)\n        return vec3(smoothstep(radius - e, radius, abs(len - radius)));\n    return vec3(smoothstep(0.0, e, abs(len - radius))); \n}\n\nvec3 drawSegement(vec2 begin, vec2 end, vec2 uv, float width){\n\tvec2 dis = end - begin;\n    vec2 dis1 = uv - begin;\n    \n    float t = clamp(dot(dis1, dis) / dot(dis , dis), 0.0, 1.0);\n    float d = length(dis1 - dis * t);\n    return vec3(smoothstep(0.0, width, d));\n    \n   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backGroundColor = vec3(1.0, 1.0, 1.0);\n    \n    \n    // pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \tuv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\t\n    \n    //grid\n    float step = 0.2;\n    vec3 c = vec3(0.8);\n    vec3 gridColor = drawGrid(step, c, uv);\n    \n    //circle\n    float radius = 0.5;\n    vec2 circleCenter = vec2(.0);\n    vec3 circleLine = drawCircle(circleCenter, radius, uv, false);\n    \n    //rotation/move point\n    float pointRadius = 0.05;\n    vec2 pointCenter = vec2(cos(iTime), sin(iTime));\n    pointCenter *= radius;\n    vec3 point = drawCircle(pointCenter, pointRadius, uv, true);\n    \n    //segement\n    vec2 begin = vec2(.0);\n    vec2 end = pointCenter;\n    float width = 0.01;\n    vec3 segement = drawSegement(begin, end, uv, width);\n    \n    vec3 color = backGroundColor * gridColor * circleLine * point *segement;\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 533], [535, 535, 598, 598, 796], [798, 798, 860, 860, 1075], [1079, 1079, 1136, 1136, 2093]], "test": "ok"}
{"id": "wdfczB", "name": "Time machine window", "author": "ilyaev", "description": "Time lapse effect study", "tags": ["space", "timelapse"], "likes": 3, "viewed": 92, "published": "Public", "date": "1585172846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define FAR_DISTANCE 4.\n#define MIN_DISTANCE 0.0001\n#define SPEED 1.2\n#define SHOW_FRAME false\n#define SHOW_FULL_PLANET false\n#define PLANET_LAND_COLOR vec3(0.3, .3, .1)\n#define PLANET_OCEAN_COLOR vec3(0., 0., .5)\n#define PLANET_SNOW_COLOR vec3(.8, .3, .1)\n#define PLANET_CLOUD_COLOR vec3(1., 1., 1.) * .6\n#define PLANET_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define PLANET_DEEP_COLOR vec3(0., 0., 0.3)\n#define PI 3.14\n\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*iTime/1000.)*4332.23);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, iTime/1000000.))) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm2( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p); p = m2*p*2.02;\n    f += 0.2500*noise( p); p = m2*p*2.03;\n    f += 0.1250*noise( p); p = m2*p*2.01;\n    f += 0.0625*noise( p);\n\n    return f/0.9375;\n}\n\n\n\nvec3 getPlanetTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n    float size = 450.;\n\n    vec2 guv = uv;\n\n    uv *= size;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    // float n = noise(id/500. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED), 5) * .6;\n        float n = fbm2(id/150. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED));//* clamp(sin(iTime) * .5 + .5, .7, 1.);\n    n *= 1.3;\n    // n = fract(n * 1.);\n    float deep = smoothstep(.12, .13, n*.8);\n    float snow = smoothstep(0.57, 0.58, n);\n    float ocean = clamp(n-.1, 0., 1.);\n\n    vec3 oceanTexture = PLANET_OCEAN_COLOR;\n\n    vec3 land = mix(oceanTexture, PLANET_LAND_COLOR, smoothstep(0.4, 0.41, n));\n\n    col += mix(\n        PLANET_SNOW_COLOR,\n        mix(land, land * 6., pow(abs(n - .35), .4))/2.5,\n        1. -snow\n    );\n\n    // col.g = 1. - col.g;\n\n    col = (1. - step(0.001, col)) * oceanTexture + col;\n\n    col = mix(PLANET_DEEP_COLOR, col, deep);\n\n    if (n < .4 && n > .12) {\n        col *= .6;\n    }\n\n    float cloudN = noise(id/450. + iTime/8. * SPEED,4);\n    col = mix(PLANET_CLOUD_COLOR, col, smoothstep(.2, .6, cloudN));\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 guv = uv;\n\n\n\n    if (!SHOW_FULL_PLANET) {\n        uv.y += 1.3 + sin(iTime + cos(iTime/2.))*.0099;\n    }\n\n\n    vec3 col = vec3(0.0);\n\n    float a = 2.5;\n    vec3 ro = vec3(0. + sin(a), 0.+cos(a), -1);\n    vec3 lookat = vec3(0.0,.03, 0.);\n\n    float zoom = 22.;\n\n    if (SHOW_FULL_PLANET) {\n         zoom = 4.;\n         ro = vec3(0., 0., -1);\n         lookat = vec3(0.);\n    }\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0., 0., 0.);\n\n    float d = length(cross(rd, p - ro))/length(rd);\n\n    float glowMask = 1. - mix(smoothstep(.2, .02, d*1.5), .0, step(d, .1));\n    glowMask -= (1. - smoothstep(.1, .11, d*1.05))*smoothstep(.1, .11, d*1.02);\n\n    vec3 ds, dt;\n    float sd;\n    int steps;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n        steps += 1;\n\n        sd = length(p) - .0999;\n\n        ds += sd;\n\n        if (sd < MIN_DISTANCE || sd > FAR_DISTANCE) {\n            break;\n        }\n    }\n\n    vec3 globe = vec3(0.);\n\n    if (sd < MIN_DISTANCE) {\n        // p.x += iTime/20.;\n        float x = acos(p.y/length(p));\n        float y = atan(p.z, p.x);\n        vec2 uv = vec2(x, y);\n        globe += smoothstep(.0, 1., clamp(float(steps)/40., 0., 1.))* .5 * PLANET_GLOW_COLOR * .8;\n        globe += getPlanetTexture(uv);\n    }\n\n   // if (SHOW_FRAME) {\n        globe += (1. - glowMask) * PLANET_GLOW_COLOR;\n   // }\n\n    col += globe;\n\n\n    if (SHOW_FRAME) {\n        d = length(guv);\n        col *= step(d, .4);\n        vec3 frame = (step(d, .41) - step(d, .40)) * vec3(.8);\n\n        col += frame;\n    }\n\n\n    fragColor = vec4(col, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 454, 454, 515], [517, 517, 537, 537, 611], [613, 613, 641, 641, 965], [967, 967, 1000, 1000, 1453], [1455, 1455, 1475, 1475, 1683], [1726, 1726, 1750, 1750, 1946], [1950, 1950, 1982, 1982, 3057], [3059, 3059, 3115, 3115, 4977]], "test": "timeout"}
{"id": "WdfyD2", "name": "ColorFade", "author": "lshy1993", "description": "crossfade from src to pure color to dst", "tags": ["crossfadetransition"], "likes": 2, "viewed": 36, "published": "Public", "date": "1585562305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 maskcolor = vec4(1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 src = texture(iChannel0, uv);\n    vec4 dst = texture(iChannel1, uv);\n\t\n    float progress = mod(iTime,10.0)/10.0;\n    \n    float s = min(progress,0.5)*2.0;\n    vec4 o = mix(src,maskcolor,s);\n    \n    if(progress > 0.5){\n        s = (progress-0.5)*2.0;\n    \to = mix(maskcolor,dst,s);\n    }\n    \n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = o;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 622]], "test": "error"}
{"id": "wdfyDH", "name": "Chess Demo cs 180 Project", "author": "ncduncan111", "description": "Chess pieces created by implicit geometry", "tags": ["implicitchess"], "likes": 4, "viewed": 65, "published": "Public", "date": "1584674707", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n// Making chess pieces using raymarching and constructive solid geometry\n// Copy + paste all of this code into shadertoy and run it\n\n// Defines\n#define STEP_MAX 100\n#define DIST_MAX 10.0\n#define EPSILON 0.02\n\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n// Get color based on which distance function was intersected with\nvec3 get_color(float key){\n    if(key == WHITE){\n        return vec3(.55, .55, .55);\n    } else if(key == BLACK){\n        return vec3(.25, .25, .25);\n    } else if(key == FLOOR){\n        return vec3(.4,.4,.4);   \n    } else{\n        return vec3(.6, .8, .9);\n    }\n}\n\n// Get material for phong reflectance \nvec3 get_mat(float key){\n    if(key == WHITE || key == BLACK){\n        return vec3(.8);\n    }else{\n        return vec3(.05);\n    }\n}\n\nfloat sphere_sdf( vec3 p, float r)\n{\n  return length(p) - r;\n}\n\n// Signed distance functions defined here:\nfloat sphere_sdf( vec3 p, vec3 c, float r)\n{\n  return length(p - c) - r;\n}\n\n// Distance function for the floor\nfloat floor_sdf(vec3 p){\n    vec4 plane = vec4(0, 1, 0, 0);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nfloat wall_sdf(vec3 p){\n    vec4 plane = vec4(0, 0, -1, -9.0);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nfloat rounded_cylinder_sdf( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)- 2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat rounded_cone_sdf( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nvec2 opUnionVec2(vec2 d1, vec2 d2){\n    if(d1.x < d2.x){\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h, vec3 offset )\n{\n  p = p-offset;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat rhombus_sdf(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r, vec3 offset )\n{\n  p = p-offset;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2,vec3 offset)\n{\n  p = p - offset;\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat bishop_base(vec3 p){\n    float base = rounded_cylinder_sdf(p, .45, .08, .18);\n    float ring = rounded_cylinder_sdf(p - vec3(0,0.1,0), .25,.003,.08);\n    return base;\n   \n}\nfloat bishop_shaft(vec3 p){\n    float ring = rounded_cylinder_sdf(p - vec3(0,2.5,0), .35,.005,.1);\n    float ring2 = rounded_cylinder_sdf(p - vec3(0,2.7,0), .25,.003,.08);\n    float ring3 = rounded_cylinder_sdf(p - vec3(0,2.9,0), .2,.001,.06);\n    float shaft_tip = opUnion(opUnion(ring, ring2), ring3);   \n    \n    float cone = rounded_cone_sdf(p, .4,.1, 3.5);\n    float ring4 = rounded_cylinder_sdf(p - vec3(0,0.4,0), .25,.003,.08);\n    float shaft_base = opUnion(opSmoothUnion(cone, ring4, 0.3), ring4);\n    return opSmoothUnion(shaft_base, shaft_tip,0.5);\n}\n\nfloat bishop_tip(vec3 p){\n    float big_sphere = sphere_sdf(p, 0.50);\n    float top_sphere = sphere_sdf(p - vec3(0,0.65,0),0.25);\n    float spheres = opSmoothUnion(big_sphere, top_sphere, 0.1);\n    vec3 rot = rotateZ(40.0) * (p - vec3(-0.55,0.35,0));\n    float rhombus = rhombus_sdf(rot,0.5, 0.5, 0.08,0.4);\n    //float t_prism = tri_prism_sdf(rot, vec2(0.55,0.5));\n    return opSubtraction(rhombus,spheres);\n    \n}\n\nvec2 bishop_sdf(vec3 point, vec3 offset, float color, float scale){\n    vec3 p = point/scale;\n    vec3 BISHOP_POS = offset/scale;\n \n    float tip = bishop_tip(p-vec3(BISHOP_POS.x, BISHOP_POS.y + 5.0, BISHOP_POS.z));\n    \n    float base = bishop_base(p-vec3(BISHOP_POS.x, BISHOP_POS.y + 0.5, BISHOP_POS.z));\n   \n    float shaft = bishop_shaft(p - vec3(BISHOP_POS.x, BISHOP_POS.y + 1.0, BISHOP_POS.z));\n    \n    float peen = opSmoothUnion(opSmoothUnion(base, shaft,.65),tip,0.5);\n    \n    return vec2(peen*scale, color);\n}\n\nvec2 pawn(vec3 point, float base_h, float stem_h,  vec3 off, float color, float scale){\n    vec3 p = point/scale;\n    vec3 offset = off/scale;\n    float init_base = sdCappedCylinder(p, 1.2,0.3, offset);\n    offset = offset+vec3(0,0.3,0);\n    float rounded_base = sdRoundedCylinder(p,0.7, 0.7, base_h, offset);\n    offset = offset+vec3(0., 0.6, 0.);\n    \n    float flat_base = sdCappedCylinder(p, 1. ,0.1, offset);\n    offset = offset+vec3(0., 0.1, 0.);\n    float rounded_base2 = sdRoundedCylinder(p,0.5, 0.4, base_h, offset);\n    offset = offset+vec3(0,0.25,0);\n    float flat_base2 = sdCappedCylinder(p, 0.95 ,0.1, offset);\n    offset = offset+vec3(0., 0.1, 0.);\n    float base2 = opSmoothUnion(flat_base2, opSmoothUnion(flat_base,rounded_base2,0.1), 0.1);\n\n    float stem  = sdCappedCone(p,stem_h,1.2, 0.25, offset);\n    offset = offset+vec3(0., stem_h, 0.);\n    float head = sphere_sdf(p, offset, 1.);\n    float neck = sdCappedCylinder(p, 1.0,0.05, offset-vec3(0,1.0,0));\n\n    float base = opSmoothUnion(init_base, opSmoothUnion(rounded_base,base2,0.01),0.01);\n    float body = opUnion(neck, opUnion(stem,head));\n    return vec2(opSmoothUnion( body, base, 0.1)*scale, color);     \n}\nfloat king_shaft(vec3 p){\n    float ring = rounded_cylinder_sdf(p - vec3(0,3.1,0), .35,.005,.1);\n    float ring2 = rounded_cylinder_sdf(p - vec3(0,3.3,0), .25,.003,.08);\n    float ring3 = rounded_cylinder_sdf(p - vec3(0,3.5,0), .2,.003,.06);\n    float shaft_tip = opUnion(opUnion(ring, ring2), ring3);   \n    \n    float cone = rounded_cone_sdf(p, .4,.07, 4.5);\n    float ring4 = rounded_cylinder_sdf(p - vec3(0,0.4,0), .20,.003,.08);\n    float shaft_base = opUnion(opSmoothUnion(cone, ring4, 0.3), ring4);\n    return opSmoothUnion(shaft_base, shaft_tip,0.5);\n}\n\nfloat king_tip(vec3 p){\n    float head = sdCappedCone(p,0.5, 0.1,0.55,vec3(0.,0.,0.));\n    float h_rect1 = sdRoundBox(p-vec3(0.,0.8,0.), vec3(0.1,0.4,0.05),0.01);\n    float h_rect2 = sdRoundBox(p-vec3(0., 0.9,0.), vec3(0.3,0.1,0.05),0.01);\n    float cross =  opSmoothUnion(h_rect1, h_rect2, 0.07);\n    return opUnion(head,cross);\n   \n}\n\nvec2 king_sdf(vec3 point,vec3 offset, float color, float scale){\n    vec3 p = point/scale;\n    vec3 KING_POS = offset/scale;\n    float base = bishop_base(p-vec3(KING_POS.x, KING_POS.y + 0.5, KING_POS.z));\n   \n    float shaft = king_shaft(p - vec3(KING_POS.x, KING_POS.y + 1.0, KING_POS.z));\n    float head = king_tip(p-vec3(KING_POS.x, KING_POS.y + 5.5, KING_POS.z));\n    return vec2(opSmoothUnion(opSmoothUnion(base, shaft,.65),head,0.5)*scale, color);\n}\n\n\n// Combine all the distance functions for the scene in this function\nvec2 scene_sdf(vec3 p){\n    vec2 curr = bishop_sdf(p, vec3(-2.,0,5), WHITE, 0.35);\n    vec2 bishop_1 = bishop_sdf(p, vec3(2.,0,5), WHITE, 0.35);\n    vec2 pawn_1 = pawn(p, 0.009 , 3.50, vec3(-4.,-0.0009, 6), BLACK, 0.2);\n    vec2 king = king_sdf(p, vec3(0, 0, 4.5), BLACK, 0.4);\n    vec2 plane = vec2(floor_sdf(p), 2); \n    vec2 pawn_2 = pawn(p, 0.009 , 3.50, vec3(4.,-0.0009, 6), BLACK, 0.2);\n    //vec2 wall = vec2(wall_sdf(p), 2);\n    \n    \n    curr = opUnionVec2(curr, pawn_1);\n    curr = opUnionVec2(curr, pawn_2);\n    curr = opUnionVec2(curr, bishop_1);\n    curr = opUnionVec2(curr, king);\n    curr = opUnionVec2(curr, plane);\n    //curr = opUnionVec2(curr, wall);\n    \n    return curr;\n}\n\n\n// Perform ray marching by finding the min distance ray can travel without hitting anything and iterating\nvec2 ray_march(vec3 cam_pos, vec3 cam_dir){\n    float t_near = 0.0;\n    for(int i = 0; i < STEP_MAX; i++){\n        vec3 p = cam_pos + cam_dir * t_near; // t_near is how far we can go along ray without hitting object\n        vec2 dist = scene_sdf(p);\n        t_near += dist.x;\n        // Check if we missed entirely or hit something\n        // > DIST_MAX then we missed all objects, less than EPSILON, we hit an object \n        if(t_near > DIST_MAX){ \n            return vec2(-1., -1);\n        }else if(dist.x < EPSILON){\n            return vec2(t_near, dist.y); \n        }\n    }\n    \n    return vec2(-1., -1);\n}\n\n\n\n\n// Get normal by approximating the gradient at some point in the scene\nvec3 normal_at(vec3 p){\n    float dist = scene_sdf(p).x;\n    return normalize(dist - vec3( \n        scene_sdf(p - vec3(0.01, 0, 0)).x,\n        scene_sdf(p - vec3(0, 0.01, 0)).x,\n        scene_sdf(p - vec3(0, 0, 0.01)).x\n    ));\n}\n\n\n\n// Add simple point lights to illuminate the scene\nvec3 get_light(vec3 p, vec3 color, vec3 mat, vec3 cam_pos){\n    vec3 l2_intensity = vec3(1.,.9,.8) * 2.0;\n    vec3 l2 = vec3(0, 3, 3.5);\n    vec3 l2_dir = normalize(l2 - p);  // Direction vector from the point to light\n    l2_dir.x = sin(iTime);\n    float decay_l2 = (1. / length(p - l2));\n    vec3 l_a = vec3(0.1);\n    \n    float p_s = 30.;\n    \n    vec3 norm = normal_at(p);  // Get the normal at the point\n    \n    // Coefficients for specular/diffuse\n    vec3 kd = vec3(color);\n    vec3 ks = vec3(mat);\n    \n    // Set up view direction\n    vec3 v = cam_pos - p;\n    v = normalize(v);\n    \n    //vec3 half_vec_l1 = (l1_dir + v) / (length(l1_dir + v));\n    vec3 half_vec_l2 = (l2_dir + v) / (length(l2_dir + v));\n    half_vec_l2 = normalize(half_vec_l2);\n\n    \n    \n    float ndotl2 = dot(norm, l2_dir);  // Calculating dot for second light\n    ndotl2 = clamp(ndotl2, 0.0, 1.0);\n    \n    float shadow = ray_march(p + norm * EPSILON * 2., l2_dir).x;  // MUST ADD Epsilon to ensure don't accidently hit the floor\n    if(shadow < length(l2 - p) && shadow != -1.){  // Hit something between light and point so we're in a shadow\n        l2_intensity *= .1;\n    }\n    color += kd * (ndotl2 * l2_intensity * decay_l2);\n    //vec3 spec = pow(dot(half_vec_l1, norm),p_s) * ks * (l1_intensity * decay_l1);\n    vec3 spec = pow(dot(half_vec_l2, norm), p_s) * ks * (l2_intensity * decay_l2);\n    return color + l_a + spec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (0.5) * iResolution.xy)/iResolution.y;\n\n    vec3 cam_pos = vec3(0,1,0);\n    vec3 cam_dir = vec3(uv.x, uv.y, 1);\n    vec2 t = ray_march(cam_pos, cam_dir);\n    vec3 col;\n    if(t.x == -1.){\n        col = get_color(t.y) * (1. - (uv.y));\n    }else{\n        vec3 point = cam_pos + cam_dir * t.x;  // Point in the scene (for shading purposes)\n        vec3 new_col = get_light(point, get_color(t.y), get_mat(t.y), cam_pos);\n        // Rendering to screen\n        col = vec3(new_col);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 330, 356, 356, 595], [597, 636, 660, 660, 768], [770, 770, 806, 806, 832], [834, 877, 921, 921, 951], [953, 988, 1012, 1012, 1089], [1091, 1091, 1114, 1114, 1195], [1197, 1197, 1264, 1264, 1382], [1383, 1383, 1446, 1446, 1710], [1714, 1760, 1787, 1787, 1934], [1935, 1981, 2008, 2008, 2155], [2157, 2203, 2230, 2230, 2377], [2379, 2379, 2431, 2431, 2531], [2533, 2533, 2591, 2591, 2691], [2693, 2693, 2752, 2752, 2852], [2853, 2853, 2890, 2890, 2912], [2914, 2914, 2949, 2949, 3027], [3029, 3029, 3072, 3072, 3094], [3096, 3096, 3173, 3173, 3306], [3307, 3307, 3336, 3336, 3364], [3365, 3365, 3431, 3431, 3692], [3695, 3695, 3760, 3760, 3883], [3885, 3885, 3954, 3954, 4291], [4292, 4292, 4337, 4337, 4428], [4430, 4430, 4462, 4497, 4554], [4556, 4556, 4582, 4582, 4734], [4735, 4735, 4762, 4762, 5296], [5298, 5298, 5323, 5323, 5713], [5715, 5715, 5782, 5782, 6235], [6237, 6237, 6324, 6324, 7422], [7423, 7423, 7448, 7448, 7983], [7985, 7985, 8008, 8008, 8320], [8322, 8322, 8386, 8386, 8777], [8780, 8849, 8872, 8872, 9542], [9545, 9651, 9694, 9694, 10262], [10267, 10338, 10361, 10361, 10567], [10571, 10622, 10681, 10681, 12036], [12039, 12039, 12096, 12096, 12639]], "test": "timeout"}
{"id": "WdfyRl", "name": "Simple Cellular Noise", "author": "zchajax", "description": "A simple cellular noise, support mouse control", "tags": ["noise"], "likes": 1, "viewed": 80, "published": "Public", "date": "1585299212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 uv)\n{\n    uv = vec2(dot(uv,vec2(127.1,311.7)),\n              dot(uv,vec2(269.5,183.3)));\n    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cellNum = 10.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= cellNum;\n    \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float minDist = 1.;\n    \n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(x, y);\n            \n            vec2 point = random2(i + neighbor);\n            \n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point);\n            \n            float dist = length(neighbor + point - f);\n            \n            minDist = min(minDist, dist);\n        }\n    }\n    \n    // mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= cellNum;\n    mouse -= i;\n    \n   \tfloat dist = length(mouse - f);\n    \n   \tminDist = min(minDist, dist);\n    \n    fragColor = vec4(vec3(minDist),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 164], [166, 166, 223, 223, 1136]], "test": "timeout"}
{"id": "WdfyRN", "name": "Torus knots table", "author": "arifr123", "description": "A table of the (p,q) Torus Knots.\nBased on my shader [url]https://www.shadertoy.com/view/wtcSW2[/url].\nUse mouse the change camera position.", "tags": ["raymarching", "gradientdescent", "torusknot"], "likes": 17, "viewed": 161, "published": "Public", "date": "1584221662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433\n\n#define sq(x) dot(x, x)\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\n\nstruct TorusKnotParameters\n{\n    float kp;\n    float kq;\n    float r1;\n    float r2;\n    float r3;\n};\n\nvec3 torusKnot(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return sq(torusKnot(t, tkp) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));\n}\n\nfloat minimizeDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    float lerningRate = 0.01/max(tkp.kq,tkp.kp);\n\tconst int maxIterations = 30;\n    \n    for(int i = 0; i < maxIterations; i++)\n    {\n        float dt = torusKnotSqDistanceDerivative(t, p, tkp);\n        \n        if(abs(dt) < 0.001)\n            break;\n        \n        t -= lerningRate*dt;\n    }\n    \n    return t;\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nfloat torusKnotLineSqDistance(float t, Ray ray, TorusKnotParameters tkp)\n{\n    //|d| = 1\n    \n    //a^2 = c^2 - b^2\n    //a^2 = c^2 - (b/c * c)^2\n    //a^2 = c^2 - (cos() * c)^2\n    \n    return torusKnotSqDistance(t, ray.ro, tkp) - sq(dot(torusKnot(t, tkp) - ray.ro, ray.rd));\n}\nfloat torusKnotLineSqDistanceDerivative(float t, Ray ray, TorusKnotParameters tkp)\n{\n    //return torusKnotSqDistanceDerivative(t, ray.ro, tkp) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);\n    //  ⇓\n\t//return 2.*dot(torusKnot(t, tkp) - ray.ro, torusKnotDerivative(t, tkp)) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);\n\t//  ⇓\n    \n    vec3 tk = torusKnot(t, tkp);\n    vec3 tkd = torusKnotDerivative(t, tkp);\n        \n    //return 2.*dot(tk - ro, tkd) - 2.*dot(tk - ro, rd)*dot(tkd, rd);\n    //  ⇓\n    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd)*dot(tkd, rd));\n    //  ⇓\n    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd*dot(tkd, rd)));\n    //  ⇓\n    return 2.*(dot(tk - ray.ro, tkd - ray.rd*dot(tkd, ray.rd)));\n}\n\nvec3 firstTorusKnotLineSqDistanceMinimumInside(Ray ray, TorusKnotParameters tkp)\n{\n    int sections = 3*int(max(tkp.kq,tkp.kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 0.008/(max(tkp.kq,tkp.kp)-0.75);\n    const int maxIterations = 100;//50\n    \n    float minDist;\n    float bestT;\n    bool found = false;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        bool failed = false;\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotLineSqDistanceDerivative(t, ray, tkp);\n            \n            if(abs(dt) < 0.1)break;\n            \n            t -= lerningRate*dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                failed = true;\n                break;\n            }\n        }\n        if(failed)continue;\n        \n        float lineSqDist = torusKnotLineSqDistance(t, ray, tkp);\n        \n        if(lineSqDist <= sq(tkp.r3))\n        {\n            float distAlongD = dot(torusKnot(t, tkp) - ray.ro, ray.rd);\n\n            if(!found || distAlongD < minDist)\n            {\n                minDist = distAlongD;\n                bestT = t;\n            }\n            \n            found = true;\n        }\n    }\n    \n    return vec3(bestT, minDist, found ? 1. : 0.);\n}\n\nfloat dot01(vec3 a, vec3 b)// [-1, 1] => [0 ,1]\n{\n    return (dot(a, b) + 1.)/2.;\n}\n\nRay intersect(Ray ray, TorusKnotParameters tkp)\n{\n    const int maxIterations = 50;\n    \n    vec3 res = firstTorusKnotLineSqDistanceMinimumInside(ray, tkp);\n    \n    if(res[2] < 0.5)\n    {\n        return Ray(vec3(0), vec3(0));\n    }\n    \n    float t = res[0];\n    vec3 p = ray.ro + res[1] * ray.rd;\n\n    for(int i = 0; i < maxIterations; i++)\n    {\n        t = minimizeDistance(t, p, tkp);\n        float d = sqrt(torusKnotSqDistance(t, p, tkp)) - tkp.r3;\n        p += d * ray.rd;\n\n        if(abs(d) < 0.01)break;\n    }\n\n    vec3 normal = normalize(torusKnot(t, tkp) - p);\n    \n    return Ray(p, normal);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 5.*fragCoord/iResolution.xy;\n    ivec2 kpkq = ivec2(uv) + 1;\n    uv = mod(uv, 1.);\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    //vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n\n    vec2 angles = /*false &&*/ iMouse.z > 0.5 ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : PI*vec2(0.7, 0.25)*(sic(0.5*iTime) + vec2(0, 1));\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, -sic1.y);\n    vec3 u = vec3(sic1.y * sic0, sic1.x);\n    vec3 r = -cross(u, f);\n    \n    vec3 ro = -8.*f;\n    \n    float zoom = 1.;\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    float kp = 3., kq = 5., r1 = 2., r2 = 1., r3 = 0.4;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    /*\n    ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    kpkq /= gcd(kpkq);\n\t*/\n    \n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n    \n    TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 rd = normalize(zoom * f + uv.x*r + uv.y*u);\n    \n    \n    Ray lr = intersect(Ray(ro, rd), tkp);\n    \n    vec3 col;\n    \n    if(sq(lr.rd) < 0.5)\n    {\n        col = vec3(0);\n    }\n    else\n    {\n        //reflections\n        for(int i = 0; i < 0; i++)\n        {\n            Ray nr = intersect(lr, tkp);\n            if(sq(nr.rd) < 0.5)\n                break;\n\n            nr.ro -= 0.01*nr.rd;\n            lr = nr;\n        }\n        \n        float offset = 2.*iTime;\n\n        vec2 sicRZ = sic(0.);//PI/2./4.);//22.5°\n\n        vec3 redLight = vec3(sicRZ.x * sic(offset), sicRZ.y);\n        vec3 blueLight = vec3(sicRZ.x * sic(2.*PI/3. + offset), sicRZ.y);\n        vec3 greenLight = vec3(sicRZ.x * sic(2.*2.*PI/3. + offset), sicRZ.y);\n\n        col = vec3(dot01(lr.rd, -redLight), dot01(lr.rd, -blueLight), dot01(lr.rd, -greenLight));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 119], [224, 224, 274, 274, 410], [411, 411, 471, 471, 733], [735, 735, 804, 804, 844], [845, 845, 924, 924, 997], [999, 999, 1065, 1065, 1381], [1422, 1422, 1496, 1599, 1700], [1701, 1701, 1785, 2113, 2517], [3911, 3911, 3960, 3960, 3994], [3996, 3996, 4045, 4045, 4601], [4603, 4603, 4621, 4621, 4761], [4763, 4763, 4820, 4820, 6886]], "test": "error"}
{"id": "wdfyWj", "name": "Growing bamboo", "author": "joha2nes", "description": "Somewhere in a bamboo forest", "tags": ["2d", "tiled", "animation", "bamboo"], "likes": 2, "viewed": 76, "published": "Public", "date": "1585570071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t\t\t\t3.141592653589793\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 tile(vec2 uv, vec2 zoom)\n{\n\treturn fract(uv * zoom);\n}\n\nfloat _stepSmoothness;\nfloat _step(float edge, float x)\n{\n\treturn smoothstep(edge - _stepSmoothness, edge + _stepSmoothness, x);\n}\n\nvec3 bamboo(vec2 uv)\n{\n\tconst vec2 zoom = vec2(30.0, 12.0);\n\n\tuv.x += iTime * 0.01;\n\n\tvec2 index = floor(uv * zoom);\n\n\tfloat rand = rand(vec2(index.x));\n\t\n\tuv.y += rand;\t\t\t\t\t\t// y offset\n\tuv.y -= iTime * rand * 0.02; \t\t// y animation;\n\n\tconst float curve = 0.1;\n\tconst float ySpacing = 0.01;\n\tconst float xSpacing = 0.2;\n\n\tvec2 uvt = tile(uv, zoom);\n\n\tfloat yPi = uvt.y * PI;\n\tfloat mask = _step(sin(yPi) * curve, uvt.x - xSpacing)\n\t\t\t   * _step(uvt.x + xSpacing, 1.0 - sin(yPi) * curve)\n\t\t\t   * _step(ySpacing, uvt.y) * _step(uvt.y, 1.0-ySpacing);\n\n\tconst vec3 bg = vec3(0.1, 0.2, 0.1);\n\tconst vec3 colorA = vec3(0.8353, 0.7882, 0.1451);\n\tconst vec3 colorB = vec3(0.4824, 0.8392, 0.149);\n\tvec3 color = mix(colorA, colorB, rand);\n\n\treturn mix(bg, color, mask);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t_stepSmoothness = 20.0 / iResolution.y;\n\n\tvec3 color = bamboo(uv);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 54, 54, 121], [123, 123, 154, 154, 182], [207, 207, 241, 241, 314], [316, 316, 338, 338, 1078], [1080, 1080, 1135, 1135, 1320]], "test": "ok"}
{"id": "wdfyWr", "name": "param_23", "author": "darkczar", "description": "epicycles, balancing colors", "tags": ["learning"], "likes": 1, "viewed": 50, "published": "Public", "date": "1584543186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<100;i++)\n    {\n        di = float(i)*.28;\n        curve_p.x = -.1*sin(.3*iTime)+.05*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = -.1*cos(.3*iTime)+.05*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = min(d, length(p-curve_p));\n  \n    }\n    float r =.25*d*d - .1*(.25 - .25*pow(dot(p, curve_p),2.0)*(.5+.5*sin(iTime*.4)));\n    float g = .2*sin(2.1*d*d+.1*length(p))*.006*normalize(dot(p,curve_p*iTime*2.));\n    float b=.01*cos(iTime*.8 - .5*pow(d,2.0)) +.0002*(dot(p,normalize(curve_p - .5*vec2(iTime*-.05, iTime*.05))));\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1295]], "test": "error"}
{"id": "wdfyzM", "name": "Menger--cylinder--v2", "author": "jorge2017a1", "description": "Menger--cylinder--v2", "tags": ["mengercylinderv2"], "likes": 1, "viewed": 51, "published": "Public", "date": "1584369501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n\n\n\n#define PI2 6.28318530717\n#define PI 3.14159265358979323846264\n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat pathterrain(float x,float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\n\nfloat pathterrainv2(float x , float y, float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3+y\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n//--------------------------------------------\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n//-------------------------------------\nfloat distCil( vec3 p)\n{    \n   // float num;\n    float gr;\n    float sdfintdo;\n    sdfintdo=999.0;\n    float rx, ry;\n    float Incgrados;\n    \n    \n    const int num =10;\n    Incgrados=360./float(num);\n    Incgrados=Incgrados*PI/180.0;\n    \n    \n\n    //vec3 pr =rotate_y(p, iTime);\n    vec3 pr =rotate_y(p, 0.0);\n \n    for(int ii=0; ii<num; ii++) \n\t{\n        \trx=2.0*cos(gr);\n        \try=2.0*sin(gr);\n                \n        \tfloat sd1=sdCylinder( pr-vec3(rx, -0.5, ry ), vec2(0.5,4.0) );\n        \tsdfintdo = min(sdfintdo,sd1);\n \n        \n        gr=gr+Incgrados;\n    }\n    \n    float sd1g =sdCylinder( p-vec3(0, 0.0, 0 ), vec2(2.0,3.0) ); \n    float sd1ch=sdCylinder( p-vec3(0, 0.0, 0 ), vec2(0.5,4.0) );\n    \n    float dif1g=differenceSDF(  sd1g,sdfintdo); \n    dif1g=differenceSDF(dif1g,sd1ch); \n    \n    \n    //res =opU(res, vec2(dif1g,8));\n    return dif1g;\n}\n  \n    \n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.33;\n\t\n    \n    \n    float dist =distCil(p);\n    \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(1.0+cos(time), 0.25, 1.0+ 1.0*sin(time));\n    \n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 585, 585, 616], [618, 618, 649, 649, 740], [743, 743, 766, 766, 903], [905, 905, 935, 935, 1072], [1122, 1122, 1191, 1270, 1311], [1313, 1313, 1395, 1395, 1626], [1628, 1628, 1688, 1688, 1829], [1878, 1878, 1914, 1914, 2017], [2019, 2074, 2097, 2097, 2232], [2234, 2234, 2260, 2260, 2317], [2319, 2319, 2359, 2359, 2393], [2396, 2396, 2432, 2483, 2578], [2583, 2583, 2632, 2683, 2780], [2784, 2784, 2820, 2820, 2907], [2910, 2910, 2957, 2957, 2990], [2992, 2992, 3017, 3017, 3032], [3033, 3080, 3116, 3116, 3233], [3235, 3235, 3271, 3271, 3389], [3391, 3431, 3455, 3476, 4297], [4306, 4335, 4353, 4353, 4576], [4636, 4636, 4665, 4665, 4853], [4855, 4855, 4896, 4896, 5072], [5074, 5074, 5115, 5115, 5267], [5269, 5269, 5290, 5290, 5420], [5422, 5422, 5449, 5449, 5699], [5701, 5701, 5758, 5758, 6226]], "test": "timeout"}
{"id": "wdfyzN", "name": "tornado 0315", "author": "aodnawg", "description": "https://www.instagram.com/p/B9voW3NhxvH/", "tags": ["raymarching"], "likes": 14, "viewed": 197, "published": "Public", "date": "1584265077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LOOP_MAX 100\n#define MAX_DIST 100.\n#define MIN_SURF .001\n\n//////////////////////////////////////////////////////////////////////////\n// refs. https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i=0;i<4;++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2. + shift;\n\t\ta *= 0.5555;\n\t}\n\treturn v;\n}\n/////////////////////////////////////////////////////////////////////////\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdGyroid(in vec3 p, in float z) {\n    return dot(sin(p*3.115*z), cos(p.zyx*3.12*z))/z*3.;\n}\n\nvec3 transform(in vec3 p) {\n    p.x *= 1.4;\n    p.xz *= rot(p.y*5.*sin(10.)+iTime);\n    p.y *= .3;\n    return p;\n}\n\nfloat map(vec3 p) {\n    p = transform(p);\n    float s = length(p)-1.;\n    s += sdGyroid( p+vec3(0,0,iTime), .5)*.02;\n    float w = 2.4+pow(abs(sin(iTime)),30.)*2.;\n    s -= pow(fbm(p*w), 4.)*w;\n    return s/15.;\n}\n\nstruct Trace {\n    float d; bool isHit; float s;\n};\nTrace trace(vec3 ro, vec3 rd, out vec3 cp) {\n    Trace mr;\n    float t = 0.;\n    float s = 0.;\n    bool flag;\n    for(int i=0; i<LOOP_MAX; i++) {\n        vec3 p = ro+rd*t;\n        float d = map(p);\n        if(d<MIN_SURF) {\n            flag=true;\n            break;\n        }\n        if(t>MAX_DIST) {\n            break;\n        }\n        flag=false;\n        t += d;\n        s += 1./100.;\n    }\n    mr.d = t;\n    mr.s = s;\n    mr.isHit = flag;\n    return mr;\n}\n\nstruct Camera {\n    vec3 ro; vec3 rd; float z;\n};\nCamera makeCam(in vec2 uv, float s) {\n    Camera camera;\n    vec3 ro = vec3(0,0,-3);\n    vec3 lookat = vec3(0.);\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0,1,0), f);\n    vec3 u = cross(f, r);\n    float z = 1.2;\n    vec3 c = ro+f*z;\n    vec3 i = c+r*uv.x+u*uv.y;\n    vec3 rd = normalize(i-ro);\n    camera.ro = ro;\n    camera.rd = rd;\n    camera.z = z;\n    return camera;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)) - map(p + vec3( -d, 0.0, 0.0)),\n        map(p + vec3(0.0,   d, 0.0)) - map(p + vec3(0.0,  -d, 0.0)),\n        map(p + vec3(0.0, 0.0,   d)) - map(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(1.);\n    Camera c = makeCam(uv, iTime);\n    vec3 cp;\n    Trace t = trace(c.ro, c.rd, cp);\n    vec3 p =  c.ro+c.rd*t.d;\n    float w = mix(.01,.02, sin(iTime)*.5+.5)*1.;\n    if(t.isHit) {\n        vec3 n = getNormal(p)*.5+.5;\n        n*=.3+sin(iTime)*.1;\n        col = vec3(.2);\n        col += dot(n, vec3(cos(iTime),sin(iTime), 0.))*vec3(.7,.1,.8)*1.;\n        col += dot(n, vec3(0.,cos(iTime*.4),sin(iTime*.2 + 10.)))*vec3(1.,.3,.2)*1.;\n        col += dot(n, vec3(0.,cos(iTime*2.+12.54),sin(iTime*3.+19.56)))*vec3(1.,.3,.65)*1.;\n        col += t.s*length(p.xz)*.5;\n    }\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 216, 238, 238, 283], [284, 284, 304, 304, 349], [350, 350, 368, 368, 407], [408, 408, 428, 428, 919], [920, 920, 939, 939, 1095], [1171, 1171, 1190, 1190, 1253], [1255, 1255, 1294, 1294, 1352], [1354, 1354, 1381, 1381, 1468], [1470, 1470, 1489, 1489, 1683], [1737, 1737, 1781, 1781, 2195], [2247, 2247, 2284, 2284, 2636], [2638, 2638, 2661, 2661, 2925], [2927, 2927, 2982, 2982, 3668]], "test": "timeout"}
{"id": "wdfyzr", "name": "Set", "author": "zxxuan1001", "description": "It's fun to play with the formulas. ", "tags": ["2d", "fractals"], "likes": 4, "viewed": 248, "published": "Public API", "date": "1584087415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATION 12\n#define PI 3.1416\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    vec2 mo = iMouse.xy / iResolution.xy ;\n    float ti = iTime * 0.2;\n    ivec2 txy = ivec2(fragCoord.xy/iResolution.xy);\n    float fft  = texelFetch( iChannel0, ivec2(txy.x, 0), 0 ).x;\n    float a = 0.02*texelFetch( iChannel0, ivec2(txy.y, 1), 0 ).x;\n    float t = fft;\n    vec2 c = vec2(0.45*cos(PI*mo.x + ti*0.5), 0.45*sin(PI*mo.y + ti*0.5));\n    c += vec2(0.5 + a * sin(t));\n    \n    vec2 p = uv;  \n    float len = length(p);\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n \tvec3 col = vec3(0.0);\n    for (int i = 0; i < ITERATION; ++i) {\n        p = abs(p)/dot(p,p) - c;\n        float l = len;\n        len = length(p);\n        l = len - l;\n        \n        col +=  l * len * vec3(sin(1.2*ti + 10.0), cos(1.8*ti + 12.0), sin(-1.2*ti));\n    \tcol = 1.0 - exp(-0.04*col);\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 96, 96, 1060]], "test": "error"}
{"id": "wdlcD7", "name": "Rect window", "author": "rrrzzz", "description": "animated thingy", "tags": ["simple", "rectangular", "minimalism"], "likes": 2, "viewed": 62, "published": "Public", "date": "1584971990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define smoothing 0.004 \nvec3 rect(vec2 uv, vec2 wh)\n{\n    vec2 l = smoothstep(wh - smoothing, wh + smoothing, uv); \n    float c = l.x * l.y;\n    vec2 r = smoothstep(wh - smoothing, wh + smoothing, 1.0 - uv);\n    c *= r.x * r.y;\n    return vec3(c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n  \tvec2 wh;\n    vec2 border = vec2(0.005);\n\n    vec3 outer;\n    vec3 inner;\n    vec3 c = vec3(1.0);\n\n    float multiplier = 1.0 - abs(sin(iTime/7.));\n    float d = smoothstep(0.1, 1.0, multiplier) * 2.5;\n    multiplier += d;\n    \n    float move =  multiplier * 0.03 + 0.008;    \n    \n    for(float i = 0.; i < 45.; i++)\n    {\n\t wh = vec2(0.06 + move * i,0.01 + move * i);\n     outer  = 1.0 - rect(uv, wh - border);\n     inner = rect(uv, wh);\n     c *= inner + outer;\n    }   \n     fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlcD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 54, 54, 250], [251, 251, 308, 308, 861]], "test": "ok"}
{"id": "WdlcDB", "name": "postes luz-v1", "author": "jorge2017a1", "description": "postes luz-v1", "tags": ["postesluzv1"], "likes": 1, "viewed": 61, "published": "Public", "date": "1585500506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\n\n\n//---------------------------------------\nfloat mapCerrov3(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+3.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n    float pisocer= mapCerrov3(p+vec3(0.0,0.0,iTime*2.0));\n        \n    \n   \tres=opU(res, vec2(pisocer,28 ));  //piso inferior\n    res=opU(res, vec2(planeDist4,30 ));  //piso inferior\n    \n    \n    vec3 p0=p;\n    //postes de luz\n    pp.z=pp.z+iTime;\n    pp.xz=mod( pp.xz,2.0)-1.0;\n    float sdb1= sdBox(pp- vec3(0.0) , vec3(0.025,1.,0.025) );\n    float sdb2= sdBox(pp- vec3(0.0,1.0,0.0) , vec3(0.25,0.025,0.025) );\n    \n    \n    vec3 p3;\n    p3 =p0;\n    float c2 = 8.;\n    p3.y+=0.125*sin(p3.z*0.5);\n    p3.xz=mod( p3.xz,2.0)-1.0;\n    float sdb3= sdBox(p3- vec3(0.0,1.0,0.) , vec3(0.025,0.025,1) );\n    \n    res=opU(res, vec2(sdb1,8 ));\n    res=opU(res, vec2(sdb2,8 ));\n    res=opU(res, vec2(sdb3,9 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    if(i== 29 )\n    {\n        vec2 uv= mObj.uv;\n        float t1 = uv.x + iTime;\n    float t2 = uv.y - iTime;\n    float r = abs(sin(t1 * 0.332) + sin(t2 * 2.21)) / 2.0;\n    float g = abs(sin(t2 * 0.773) + sin(t1 * 3.53)) / 2.0;\n    float b = abs(sin(t1 * 0.817) + sin(t2 * 4.71)) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  }      \n    \t\n  \n    if(i== 30 )\n    {\n        vec2 uv= mObj.uv;\n        float t1 = uv.x + iTime;\n    \tfloat t2 = uv.y - iTime;\n    \tfloat r = abs(sin(t1 * 0.332) ) / 2.0;\n    \tfloat g = abs(sin(t2+r) ) / 2.0;\n    \tfloat b = abs(sin(t1 +g) ) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  }    \n    \n    \n    if(i== 31 )\n    {\n        vec2 uv= mObj.uv;\n        float t1 = uv.x + iTime;\n    \tfloat t2 = uv.y - iTime;\n    \tfloat r = abs(sin(t1 * 0.332) ) / 2.0;\n    \tfloat g = abs(sin(t2 * 0.773) ) / 2.0;\n    \tfloat b = abs(sin(t1 * 0.817) ) / 2.0;\n\t\n    return hsb2rgb(vec3(r, g, b));\n  }    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.0,0.5,-3.0);  \n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0.0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n      vec3 p = (ro + rd * d.x ); \n      glpRoRd=p;\n    \n  \n      float dif=0.35;\n   \n    \n      mObj.dist =d.x;\n      vec3 colobj;\n  \n      colobj=getSphereColor(int( d.y));\n    \n      vec3 nor= GetNormal( p);\n   \n      float intensity = 1.0;\n      vec3 V = normalize(p - ro);\n      vec3 L = rd;\n      vec3 normal = nor;\n      vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n      vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[581, 598, 631, 631, 696], [700, 700, 735, 735, 759], [763, 778, 809, 809, 959], [960, 980, 1016, 1016, 1103], [1104, 1120, 1152, 1180, 1241], [1243, 1243, 1279, 1279, 1382], [1385, 1385, 1430, 1430, 1521], [1523, 1523, 1558, 1558, 2043], [2095, 2095, 2141, 2141, 2173], [2175, 2175, 2218, 2218, 2250], [2252, 2252, 2300, 2300, 2333], [2336, 2336, 2365, 2365, 2491], [2493, 2493, 2529, 2529, 2646], [2648, 2648, 2684, 2684, 2802], [2805, 2805, 2841, 2841, 2964], [3017, 3029, 3051, 3051, 3359], [3360, 3386, 3411, 3411, 3601], [3602, 3647, 3664, 3664, 3737], [3740, 3773, 3799, 3799, 3996], [4043, 4043, 4095, 4095, 4250], [4315, 4424, 4461, 4461, 4496], [4498, 4498, 4517, 4517, 4592], [4641, 4641, 4664, 4664, 4690], [4692, 4692, 4715, 4715, 4853], [4909, 4909, 4931, 4931, 5001], [5066, 5066, 5092, 5092, 5149], [5151, 5151, 5171, 5171, 5229], [5232, 5232, 5253, 5253, 5503], [5549, 5591, 5617, 5617, 5788], [5791, 5835, 5860, 5860, 6998], [7003, 7003, 7036, 7036, 7511], [7515, 7515, 7539, 7539, 7871], [7876, 7876, 7914, 7914, 8272], [8371, 8415, 8432, 8432, 8503], [8528, 8620, 8645, 8645, 8908], [8910, 8965, 8991, 8991, 9225], [9289, 9289, 9317, 9317, 18589], [18592, 18592, 18649, 18649, 19681]], "test": "error"}
{"id": "WdlcDj", "name": "36 Days Of Type - G", "author": "nicolasdnl", "description": "36 Days Of Type - G", "tags": ["letter"], "likes": 3, "viewed": 32, "published": "Public", "date": "1585662070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[11], float kPath[26] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p, float t )\n{\n    float height = 1. + sin(t*PI*2.)*0.2;\n    float width = .4 + cos(t*PI*2.)*0.1;\n    float strokeWidth = 0.25 + cos(t*PI*2.)*0.1;\n    \n   \tint kType[] = int[](0,0,0,1,0,0,0,0,0,0,1);\n\tfloat kPath[] = float[]( 0.2-width*0.5, height*0.5,\n                             0.2+width*0.5, height*0.5,\n                             0.2+width*0.5, height*0.5-strokeWidth,\n                             0.2-width*0.5, height*0.5-strokeWidth, 0.01,\n                             0.2-width*0.5,-height*0.5+strokeWidth,\n                             0.2+width*0.5-strokeWidth,-height*0.5+strokeWidth,\n                             0.2+width*0.5-strokeWidth, -0.3+strokeWidth,\n                             0.2+width*0.5,-0.3+strokeWidth,\n                             0.2+width*0.5,-height*0.5,\n                             0.2-width*0.5,-height*0.5,\n                             0.2-width*0.5,-height*0.5, 0.0,\n                             0.2-width*0.5, height*0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    float t = mod(iTime * 0.25, 1.);\n    \n    \n    vec3 col = vec3(1.,1.,1.);\n    for (int i=0; i<25; i++) {\n        //float d = sdA(p, t+float(i)*0.08);\n        float d = sdA(p+vec2(float(15-i)*0.004), t+float(i)*0.005);\n    \tcol = float(i)*0.003+generateBorder(col, abs(d));\n    }\n    col = 1. - col;\n    \n    //col = vec3(sign(d));\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1634, 1634, 2399], [3424, 3424, 3475, 3475, 3560], [3562, 3562, 3619, 3655, 4100]], "test": "error"}
{"id": "WdlcRj", "name": "PUMA CLYDE CONCEPT", "author": "yasuo", "description": "footwear design experiment. j.cole+clyde = j.clyde", "tags": ["puma"], "likes": 33, "viewed": 2558, "published": "Public API", "date": "1585152860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define SHDOW_COL vec3(0.5)\n#define MODE 2\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nmat2 bend(float p, float k) {\n    float c = cos(k*p);\n    float s = sin(k*p);\n    mat2  m = mat2(c,-s,s,c);\n    return m;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvec3 outsole(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n    float d = sdBox(p,vec2(0.7,0.03))-0.02;\n    float shadow = sdBox(p-vec2(0.0,0.01),vec2(0.7,0.03))-0.02;\n    col = mix(col,SHDOW_COL,S(shadow,-0.02));\n    col = mix(col,bcol,S(d,0.0));\n    \n    p.x = mod(p.x,0.01)-0.005;\n    float d2 = sdBox(p+vec2(0.0,0.01),vec2(0.0005,0.03));\n    p = pref;\n    \n    d2 = max((p.x+0.3),d2);\n    d2 = max(-(p.x+0.71),d2);\n    \n    float mask = dot(p,vec2(0.15,0.1))+0.07;\n    d2 = max(mask,d2);\n    \n    col = mix(col,vec3(0.9),S(d2,0.0));\n    \n    float n = fbm(p*50.0+20.0)*1.5;\n    d = sdBox((p+vec2(-0.1,0.01))*n*1.7,vec2(0.6,0.03));\n    mask = dot(p,vec2(0.15,0.1))+0.066;\n    d = max(-mask,d);\n    d = max(p.x-0.7,d);\n    d = max(-p.y-0.05,d);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    // stitch\n    d = sdBox(p-vec2(0.0,0.035),vec2(0.7,0.001));\n    mask = smoothstep(0.04,0.05,mod(p.x,0.1)-0.05);\n    d = max(mask,d);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    return col;\n}\n\nfloat lateralSideBase(vec2 p) {\n    vec2 pref = p;\n    float d = sdBox(p,vec2(0.5,0.15));\n    p*=Rot(radians(-3.0));\n    \n    float blend = smoothstep(-1.0,0.00,p.x)*(1.0-smoothstep(0.00,1.0,p.x));\n    p.y *= mix(2.11,0.73,blend);\n    float d2 = sdBox((p-vec2(0.0,0.11)),vec2(0.52,0.15));\n    p = pref;\n    p.y*=1.08;\n    float d3 = length(p-vec2(-0.445,-0.02))-0.2;\n    d = min(d,d2);\n    d = min(d3,d);\n    d = max(-p.y,d);\n    return d;\n}\n\nvec3 shoelaceGuard(vec2 p, vec3 col, vec3 bcol) {\n    float mask = dot(p,vec2(-0.03,0.08))-0.023;\n    float d = lateralSideBase(p);\n    d = max(-mask*2.5,d);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 lateralSide(vec2 p, vec3 col, vec3 bcol, vec3 bcol2, vec3 bcol3) {\n    vec2 pref = p;\n    p.x*=0.99;\n    p.y*=0.93;\n    float d = lateralSideBase(p-vec2(0.0,0.002)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.01));\n    p = pref;\n    p.y*=0.95;\n    d = lateralSideBase(p);\n    col = mix(col,bcol,S(d,0.0));\n    col = shoelaceGuard(p-vec2(0.0,-0.005),col,SHDOW_COL); // shadow\n    col = shoelaceGuard(p,col,bcol2);\n    \n    // shoelace hole\n    d = length(p-vec2(-0.05,0.315))-0.015;\n    col = mix(col,bcol3,S(d,0.0));\n    \n    return col;\n}\n    \nvec3 toeCap(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n    float blend = smoothstep(-1.0,0.15,p.x)*(1.0-smoothstep(0.15,1.0,p.x));\n    p.y *= mix(5.0,0.8,blend);\n    float d = sdRoundedBox(p,vec2(0.2,0.1),vec4(0.0,0.0,0.1,0.0));\n    d = max(-p.y-0.03,d);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nfloat heelCounterbase(vec2 p) {\n    mat2  m = bend(p.y,0.6);\n    p = m*p.xy;\n    p.x*=0.95;\n    \n    vec2 pref = p;\n    float d =  sdBox(p,vec2(0.1,0.2))-0.03;\n    p.y*=0.5;\n    float mask = length(p-vec2(-0.07,0.222))-0.2;\n    d = max(-mask,d);\n    p = pref;\n    p*=Rot(radians(-20.0));\n    p.x*=1.7;\n    p.y*=0.75;\n    mask = length((p-vec2(-0.14,-0.05)))-0.2;\n    d = max(-mask,d);\n    \n    p = pref;\n    p*=Rot(radians(8.0));\n    p.x*=1.7;\n    d = max((length((p-vec2(0.14,0.027)))-0.21),d);\n    \n    return d;\n}\n\nvec3 heelCounter(vec2 p, vec3 col, vec3 bcol, vec3 bcol2) {\n    vec2 pref = p;\n    float d =  heelCounterbase (p+vec2(0.01,0.005)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.01));\n    d =  heelCounterbase (p);\n    col = mix(col,bcol2,S(d,0.0));\n    d =  heelCounterbase (p);\n    float d2 =  sdBox((p-vec2(0.138,0.12))*Rot(radians(-12.0)),vec2(0.002,0.06))-0.017;\n    d = max(-d2,d);\n    col = mix(col,SHDOW_COL,S(d,-0.01));\n    d2 =  sdBox((p-vec2(0.13,0.12))*Rot(radians(-12.0)),vec2(0.002,0.06))-0.017;\n    d = max(-d2,d);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 shoetongue(vec2 p, vec3 col, vec3 bcol, vec3 bcol2) {\n    float d = sdBox(p*Rot(radians(-24.5)),vec2(0.38,0.05))-0.05;\n    col = mix(col,bcol,S(d,0.0));\n    d =  sdBox((p-vec2(0.231,0.202))*Rot(radians(-25.0)),vec2(0.1,0.001))-0.008;\n    col = mix(col,SHDOW_COL,S(d,-0.005));\n\td =  sdBox((p-vec2(0.23,0.21))*Rot(radians(-25.0)),vec2(0.1,0.001))-0.008;\n    col = mix(col,bcol2,S(d,0.0));\n    return col;\n}\n\nfloat shoelaseBase(vec2 p) {\n    vec2 pref = p;\n    float deg = 66.0;\n    p*=Rot(radians(deg));\n    p.y = mod(p.y,0.09)-0.045;\n    float d = sdBox(p*Rot(radians(-10.0)),vec2(0.022,0.002))-0.013;\n    p = pref;\n    p*=Rot(radians(deg));\n    d = max(-p.y-0.45,d);\n    d = max(p.y-0.08,d);\n    return d;\n}\n\nfloat shoelaseHole(vec2 p) {\n    vec2 pref = p;\n    float deg = 66.0;\n    p*=Rot(radians(deg));\n    p.y = mod(p.y,0.09)-0.045;\n    float d = length(p)-0.02;\n    p = pref;\n    p*=Rot(radians(deg));\n    d = max(-p.y-0.45,d);\n    d = max(p.y-0.08,d);\n    return d;\n}\n\nvec3 shoelace(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n    \n    float sh = shoelaseHole(p-vec2(0.011,-0.02));\n    col = mix(col,vec3(0.0),S(sh,0.0));\n    \n    float d = shoelaseBase(p-vec2(-0.003,-0.007)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.005));\n    d = shoelaseBase(p);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nfloat stripeBase(vec2 p) {\n    vec2 pref = p;\n    \n    p.x*=0.7;\n    float d = length(p-vec2(0.0,0.0))-0.14;\n    float d2 = length(p-vec2(0.22,-0.1))-0.22;\n    \n    d = max(-p.y-0.02,max(-d2,d ));\n    p = pref;\n    \n    mat2  m = bend(p.y,-0.6);\n    p = m*p.xy;\n    \n    float sc = mix(0.07,2.5,smoothstep(-1.0,1.0,p.x));\n    p.y*=sc;\n    float d3 = sdBox((p-vec2(0.3,0.24))*Rot(radians(-19.0)), vec2(0.335,0.041));\n    d = min(d,d3);\n    \n    return d;\n}\n\nvec3 stripe(vec2 p, vec3 col, vec3 bcol){\n    vec2 pref = p;\n    mat2  m = bend(p.y,0.7);\n    p = m*p.xy;\n    p*=0.87;\n    float d = stripeBase(p-vec2(0.005,-0.015)); // shadow\n    col = mix(col,SHDOW_COL,S(d,-0.02));\n    \n    p = pref;\n    p = m*p.xy;\n    d = stripeBase(p);\n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nfloat stitchBase(vec2 p, float size) {\n    float d = sdBox(p,vec2(size,0.0001))*1.3;\n    float mask = smoothstep(0.01,0.03,mod(p.x,0.03)-0.015);\n    d = max(mask,d);\n    return d;\n}\n\nvec3 stitch(vec2 p, vec3 col, vec3 bcol, vec3 bcol2, vec3 bcol3) {\n    vec2 pref = p;\n    float d = stitchBase((p-vec2(0.2,-0.03))*Rot(radians(40.0)), 0.07);\n    col = mix(col,bcol,S(d,0.0));\n    d = stitchBase((p-vec2(0.27,-0.19))*Rot(radians(100.0)), 0.06);\n    col = mix(col,bcol,S(d,0.0));\n    d = stitchBase((p-vec2(-0.07,-0.045))*Rot(radians(-21.6)), 0.38);\n    col = mix(col,bcol,S(d,0.0));\n    \n    d = stitchBase((p-vec2(-0.37,-0.22))*Rot(radians(105.0)), 0.04);\n    col = mix(col,bcol,S(d,0.0));\n    \n    d = stitchBase((p-vec2(-0.43,-0.22))*Rot(radians(105.0)), 0.03);\n    col = mix(col,bcol,S(d,0.0));\n    \n    // stitch for stripe\n    mat2  m = bend(p.y,0.7);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.32,-0.063))*Rot(radians(-9.0)), 0.28);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    m = bend(p.y,-2.8);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(-0.15,-0.092))*Rot(radians(9.0)), 0.146);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    m = bend(p.y,0.7);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.38,-0.076))*Rot(radians(-11.0)), 0.23);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    m = bend(p.y,-2.0);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.0,-0.193))*Rot(radians(-15.0)), 0.1);\n    col = mix(col,bcol2,S(d,0.0));\n    p = pref;\n    \n    // stitch for heelcounter\n    p = pref;\n    m = bend(p.y,1.0);\n    p = m*p.xy;\n    d = stitchBase((p-vec2(0.67,-0.04))*Rot(radians(32.0)), 0.07);\n    col = mix(col,bcol3,S(d,0.0));\n    return col;\n}\n\nvec3 floorShadow(vec2 p, vec3 col, float size) {\n    p.y*=30.0;\n    float d = length(p)-size;\n    col = mix(col,vec3(0.3),S(d,-0.4));\n    return col;\n}\n\nvec3 stripeMaterial(vec2 p, vec3 col) {\n    vec2 pref = p;\n    float sc = 6.0;\n    p*=sc;\n    float size = 0.01;\n    p.x = mod(p.x,0.2)-0.1;\n    p.y = mod(p.y,0.14)-0.07;\n    float d =  sdBox(p,vec2(size))-0.03;\n    col = mix(col,col*1.2,S(d,0.0));\n    p = pref;\n    p*=sc;\n    p.x+=0.1;\n    p.y+=0.07;\n\tp.x = mod(p.x,0.2)-0.1;\n    p.y = mod(p.y,0.14)-0.07;\n    d =  sdBox(p,vec2(size))-0.03;\n    col = mix(col,col*1.2,S(d,0.0));\n    return col;\n}\n\nvec3 lateralsideMaterial(vec2 p, vec3 col, vec3 col2) {\n    p*= 2.5;\n    p.x-=iTime*0.1;\n    float size = 0.096;\n    float mrg = 4.0;\n    p.x = mod(p.x,size*mrg)-((size*mrg)*0.5);\n    p.y = mod(p.y,size*mrg)-((size*mrg)*0.5);\n    float d = sdBox(p,vec2(0.1));\n    col = mix(col,col2,S(d,-0.01));\n    p.x = mod(p.x,size*mrg)-((size*mrg)*0.5);\n    p.y = mod(p.y,size*mrg)-((size*mrg)*0.5);\n    d = sdBox(p,vec2(0.1));\n    col = mix(col,col2,S(d,-0.01));\n    return col;\n}\n\nfloat charJ(vec2 p) {\n    float d = sdBox(p-vec2(0.02,0.0),vec2(0.02,0.1));\n    float d2 = sdBox(p-vec2(-0.04,-0.06),vec2(0.04,0.04));\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(-0.02,-0.01),vec2(0.02,0.05));\n    d = max(-d2,d);\n    return d;\n}\nfloat charC(vec2 p) {\n    float d = sdBox(p,vec2(0.06,0.1));\n    float d2 = sdBox(p-vec2(0.03,0.00),vec2(0.05,0.06));\n    d = max(-d2,d);\n    return d;\n}\nfloat charL(vec2 p) {\n    float d = sdBox(p,vec2(0.06,0.1));\n    float d2 = sdBox(p-vec2(0.03,0.03),vec2(0.05,0.09));\n    d = max(-d2,d);\n    return d;\n}\nfloat charY(vec2 p) {\n    float d = sdBox(p-vec2(0.00,0.05),vec2(0.06,0.05));\n    float d2 = sdBox(p-vec2(0.00,-0.05),vec2(0.02,0.05));\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(0.00,0.08),vec2(0.02,0.05));\n    d = max(-d2,d);\n    return d;\n}\nfloat charD(vec2 p) {\n    float d = sdBox(p-vec2(-0.025,0.00),vec2(0.045,0.1));\n    float d2 = sdBox(p-vec2(0.02,0.00),vec2(0.05,0.06));\n    d = max(-d2,d);\n    d2 = sdBox(p-vec2(0.04,0.02),vec2(0.02,0.08));\n    d = min(d,d2);\n    return d;\n}\nfloat charE(vec2 p) {\n    float d = sdBox(p,vec2(0.06,0.1));\n    float d2 = sdBox(p-vec2(0.03,0.00),vec2(0.05,0.06));\n    d = max(-d2,d);\n    d2 = sdBox(p,vec2(0.04,0.02));\n    d = min(d,d2);\n    return d;\n}\nvec3 logo(vec2 p, float size, vec3 col, vec3 bcol) {\n    p*=size;\n    mat2  m = mat2(1.0,-0.4,0.0,1.0); // sknew\n    p*=m;\n    \n    float j = charJ(p-vec2(-0.4,0.0));\n    float dt = sdBox(p-vec2(-0.31,0.0),vec2(0.02));\n    float c = charC(p-vec2(-0.2,0.0));\n    float l = charL(p-vec2(-0.05,0.0));\n    float y = charY(p-vec2(0.08,0.0));\n    float d = charD(p-vec2(0.24,0.0));\n    float e = charE(p-vec2(0.39,0.0));\n    \n    float res = min(j,min(dt,min(c,min(l,min(y,min(d,e))))));\n    col = mix(col,bcol,S(res,-0.01));\n    return col;\n}\n\nvec3 pumaClyde(vec2 p, vec3 col) {\n    float n = noise2d(p*20.0+200.0);\n    \n    vec3 wh = vec3(251.0/255.0,251.0/255.0,235.0/255.0);\n    \n    vec3 toeandtongueCol = vec3(n)*0.2;\n    col = shoetongue(p-vec2(-0.05,-0.055),col,toeandtongueCol,wh*0.9);\n    col = toeCap(p-vec2(-0.51,-0.235),col,toeandtongueCol);\n    \n    vec3 shoelaceGuardCol = (vec3(17.0/255.0,74.0/255.0,159.0/255.0)*0.95)-vec3(n)*0.03;\n    vec3 lateralBaseCol = vec3(17.0/255.0,74.0/255.0,159.0/255.0)-vec3(n)*0.03;\n    lateralBaseCol = lateralsideMaterial(p,vec3(17.0/255.0,74.0/255.0,159.0/255.0),wh)-vec3(n)*0.1;\n    vec3 shoelaceHoleCol = vec3(0.0);\n    col = lateralSide(p-vec2(0.19,-0.25),col,lateralBaseCol,shoelaceGuardCol,shoelaceHoleCol);\n    \n    vec3 stripeBaseCol = stripeMaterial(p,vec3(252.0/255.0,120.0/255.0,6.0/255.0));\n    col = stripe(p-vec2(0.0,-0.24),col,stripeBaseCol);\n    \n    vec3 heelBaseCol = vec3(n)*0.2;\n    vec3 heelPatchCol = vec3(252.0/255.0,120.0/255.0,6.0/255.0);\n    col = heelCounter(p-vec2(0.592,-0.07),col,heelBaseCol,heelPatchCol);\n    \n    col = logo((p-vec2(0.2,0.0))*Rot(radians(-22.0)),4.0,col, vec3(1.0,0.843,0.0));\n    \n    vec3 stitchCol = vec3(0.0);\n    vec3 stitchCol2 = vec3(0.0);\n    vec3 stitchCol3 = vec3(0.4);\n    col = stitch(p, col,stitchCol,stitchCol2,stitchCol3);\n    \n    vec3 outBaseCol = wh;\n    col = outsole(p-vec2(0.0,-0.3),col,outBaseCol);\n    \n    vec3 shoelaceCol = vec3(17.0/255.0,74.0/255.0,159.0/255.0)*1.5;\n    col = shoelace(p-vec2(0.0,0.055),col,shoelaceCol);\n    \n    return col;\n}\n\nvec3 background(vec2 p, float t) {\n    float d = -p.y-0.4;\n    vec3 col = mix(vec3(0.7),vec3(0.65),S(d,0.0));\n    \n    vec3 wh = vec3(251.0/255.0,251.0/255.0,235.0/255.0);\n    vec3 mat = lateralsideMaterial(p,vec3(17.0/255.0,74.0/255.0,159.0/255.0),wh)*0.5;\n    float n = fbm(p*(10.0)+20.0)*1.3;\n    d = length((p-vec2(-0.4,0.0))*n)-0.1;\n    col = mix(col,mat,S(d,0.0));\n    n = fbm(p*5.0+10.0)*1.5;\n    d = length((p-vec2(0.5,0.2))*n)-0.1;\n    col = mix(col,mat,S(d,0.0));\n    \n    p.x-=t;\n    p.x = mod(p.x,0.5)-0.25;\n    col = logo(p-vec2(0.0,-0.3),2.2,col, vec3(0.6));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.1;\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 pref = p;\n    vec3 col = background(p,t);\n    \n    vec3 logomat = stripeMaterial(p,vec3(252.0/255.0,120.0/255.0,6.0/255.0));\n    col = logo(p-vec2(-0.395,0.395),1.8,col, vec3(0.5));\n    col = logo(p-vec2(-0.4,0.4),1.8,col, logomat);\n    \n    p*=1.2;\n    #if MODE == 2\n    p.x+=t;\n    p.x = mod(p.x,5.4)-2.7;\n\tp.x = abs(p.x);\n    p.x*=-1.0;\n    p.x+=1.8;\n    col = pumaClyde((p-vec2(-0.05,0.1))*Rot(radians(-15.0)),col);\n    p = pref;\n    p*=1.2;\n    p.x+=t;\n    p.x = mod(p.x,5.4)-2.7;\n    col = pumaClyde(p-vec2(0.0,-0.1),col);\n    col = floorShadow(p-vec2(0.0,-0.55),col,0.6);\n    #elif  MODE == 1\n    col = pumaClyde((p-vec2(-0.05,0.1))*Rot(radians(-15.0)),col);\n    #elif  MODE == 0\n    col = pumaClyde(p,col);\n    #endif\n    \n    p = pref;\n    \n    p*=1.2;\n    #if MODE == 2\n    p.x+=t;\n    p.x = mod(p.x,5.4)-2.7;\n    p.x = abs(p.x);\n    p.x*=-1.0;\n    p.x+=1.9;\n    col = floorShadow(p-vec2(-0.55,-0.55),col,0.3);\n    #elif  MODE == 1\n    col = floorShadow(p-vec2(-0.65,-0.55),col,0.3);\n    #elif  MODE == 0\n    col = floorShadow(p-vec2(0.0,-0.55),col,0.6);\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 380, 400, 400, 534], [535, 535, 562, 562, 1065], [1066, 1066, 1085, 1085, 1347], [1349, 1349, 1378, 1378, 1472], [1474, 1553, 1590, 1590, 1670], [1672, 1751, 1806, 1806, 1963], [1965, 1965, 2008, 2008, 2957], [2959, 2959, 2990, 2990, 3400], [3402, 3402, 3451, 3451, 3611], [3613, 3613, 3684, 3684, 4159], [4165, 4165, 4207, 4207, 4478], [4480, 4480, 4511, 4511, 4996], [4998, 4998, 5057, 5057, 5577], [5579, 5579, 5637, 5637, 5988], [5990, 5990, 6018, 6018, 6291], [6293, 6293, 6321, 6321, 6556], [6558, 6558, 6602, 6602, 6901], [6903, 6903, 6929, 6929, 7358], [7360, 7360, 7401, 7401, 7687], [7689, 7689, 7727, 7727, 7870], [7872, 7872, 7938, 7938, 9371], [9373, 9373, 9421, 9421, 9524], [9526, 9526, 9565, 9565, 9973], [9975, 9975, 10030, 10030, 10444], [10446, 10446, 10467, 10467, 10688], [10689, 10689, 10710, 10710, 10842], [10843, 10843, 10864, 10864, 10996], [10997, 10997, 11018, 11018, 11238], [11239, 11239, 11260, 11260, 11481], [11482, 11482, 11503, 11503, 11689], [11690, 11690, 11742, 11742, 12227], [12229, 12229, 12263, 12263, 13752], [13754, 13754, 13788, 13788, 14349], [14351, 14351, 14408, 14408, 15614]], "test": "timeout"}
{"id": "WdlczH", "name": "param_v13", "author": "darkczar", "description": "epicycle", "tags": ["learning"], "likes": 1, "viewed": 40, "published": "Public", "date": "1584157393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<500;i++)\n    {\n        di = float(i)*.02;\n        curve_p.x = .3*sin(.4*iTime)+.15*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*sin(11.0*di+.8*iTime);\n        curve_p.y = .3*cos(.4*iTime)+.15*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*cos(11.0*di+.8*iTime);\n        d = min(d, length(p-curve_p)+.4*rand(vec2(di,di)));\n  \n    }\n    \n    float r = .025*d*d*sin(.2*iTime);\n    float g = .01*sin(.001*d*d+.1*length(p));\n    float b = .25*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,2.0)));\n    if (d>.05)\n    {\n        b=pow(b,2.25);\n    }\n    if (d>.05 && d < .07)\n    {\n        r = pow(r,.5);\n    }\n    if (d>.07 && d < .09)\n    {\n        g = pow(g,.5);\n    }\n    vec3 col = vec3(r,g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 342, 392, 1600]], "test": "timeout"}
{"id": "wdlczl", "name": "StylisedSparks", "author": "OursBleu", "description": "To be used on particle trails for stylised sparks when an object is sliding on the ground.", "tags": ["vfx"], "likes": 1, "viewed": 54, "published": "Public", "date": "1585394457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float scaleX = 5.;\n    float scaleY = 1.;\n    float offsetX = .5;\n    float offsetY = 0.224;\n    float taperX = 4.288;\n    float taperY = 1.000;\n\n    offsetX -= time;\n\n    float tempX = x / (1. + (y * taperX));\n    float tempY = y / (1. - (x * taperY));\n    x = tempX;\n    y = tempY;\n\n    float res = 1.-abs(sin((x+offsetX)*3.14*scaleX));\n    res *= scaleY;\n    res += offsetY;\n    float col = step(y,res);\n    \n    fragColor = vec4(col,col,0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 622]], "test": "ok"}
{"id": "WdlyD2", "name": "Distorted biome map", "author": "jarble", "description": "This biome map has a slightly different distortion function.\n\nMove the mouse to zoom in and out!", "tags": ["fractal", "map", "biome"], "likes": 0, "viewed": 213, "published": "Public API", "date": "1585612499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float GREEN = 0.;\nconst float BLUE = 1.;\nconst float GRAY = 2.;\nconst float YELLOW = 3.;\nconst float WHITE = 4.;\nconst float RED = 5.;\n\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 5.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\nfloat magnify(vec2 fragCoord,float mag){\n    float mag1 = (iTime)/(mag*mag);\n    fragCoord = floor(fragCoord/mag);\n    fragCoord += mag*mag*vec2(sin((fragCoord.y*mag1)),sin((fragCoord.x*mag1)));\n\tfragCoord *= mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag){\n    return vec4(magnify(fragCoord+vec2(0,1),mag),\n        magnify(fragCoord+vec2(1,0),mag),\n        magnify(fragCoord-vec2(0,1),mag),\n        magnify(fragCoord-vec2(1,0),mag));\n}\n\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    return color == BLUE\n    \t? vec3(0.149,0.141,0.912)\n    :color == GREEN\n    \t? vec3(0.000,0.833,0.224)\n   \t:color == RED\n    \t? vec3(1.0,0.0,0.0)\n   \t:color == WHITE\n    \t? vec3(1.0,1.0,1.0)\n   \t:color == GRAY\n    \t? vec3(192.0,192.0,192.0)/255.0\n    :color == YELLOW\n    \t? vec3(1.0,1.0,0.0)\n   \t:vec3(0);\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    fragCoord /= 3.0;\n    float colors[] = float[](GREEN,BLUE,GRAY,YELLOW,WHITE,RED);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag);\n    color1 = color1 == GREEN && is_next_to(BLUE,neighbors)\n    \t? YELLOW\n    :color1 == BLUE && is_next_to(GREEN,neighbors)\n        ? GREEN\n    :color1 == YELLOW && is_next_to(GRAY,neighbors)\n        ? BLUE\n    :color1 == GRAY && is_next_to(YELLOW,neighbors)\n        ? YELLOW\n    :color1 == WHITE && is_next_to(YELLOW,neighbors)\n        ? GRAY\n    :color1 == GRAY && is_next_to(BLUE,neighbors)\n        ? BLUE\n    :color1;\n    mag -= 1.0;\n    }\n    return colors[int(color1)];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 273, 295, 295, 522], [524, 524, 564, 564, 789], [791, 791, 836, 836, 1015], [1018, 1018, 1062, 1062, 1198], [1202, 1202, 1230, 1230, 1543], [2258, 2258, 2314, 2314, 2684]], "test": "error"}
{"id": "WdlyD4", "name": "Yuv color index", "author": "JasonLee", "description": "Index color on yuv map , why not work?", "tags": ["yup", "index"], "likes": 1, "viewed": 57, "published": "Public", "date": "1584809885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 yuv2rgb = mat3(\n    1, 0, 1.13983,\n    1, -0.39465, -0.58060,\n    1, 2.03211, 0\n);\n\nmat3 rgb2yuv = mat3(\n    0.299, 0.587, 0.114,\n    -0.14713, -0.28886, 0.436,\n    0.615, -0.51499, -0.10001\n);\n\nfloat dotSqar(vec2 st, vec2 p, float size)\n{\n    vec2 uv = st - vec2(0.5) + vec2(size/2.0);\n    vec2 bl = step(uv-p,vec2(size));\n    vec2 bl2 = vec2(1.0) - step(uv-\tp +vec2(size),vec2(size));\n    bl = bl2 * bl;\n    return bl.x * bl.y;\n}\n\nfloat yuvMap(vec2 uv, vec3 image, float size)\n{\n    vec2 tp = (image * rgb2yuv).yz ;// vec2(0.5);\n    return dotSqar(uv, tp, size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 yuv = vec3(abs(sin(iTime * 0.5)),uv - vec2(0.5));\n    \n    \n    vec3 col = yuv * yuv2rgb;\n    \n    float size = 22.;\n    //col = floor(col * size) / size ;\n    \n    vec3 ct1 = vec3(0.8,0.8,0.0);\n    vec3 ct2 = vec3(0.6,0.0,0.03);\n    vec3 ct3 = vec3(0.0,0.2,0.9);\n    \n    vec2 p1 = (ct1 * rgb2yuv).yz;\n    vec2 p2 = (ct2 * rgb2yuv).yz;\n    vec2 p3 = (ct3 * rgb2yuv).yz;\n    \n    //col += dotSqar(uv, p1, 0.01);\n   // col += dotSqar(uv, p2, 0.01);\n    //col += dotSqar(uv, p3, 0.01);\n    \n    vec3 image = texture(iChannel0, uv).rgb;\n    \n    image = pow(image, vec3(sin(iTime*2.6541),cos(iTime*25.6541),cos(iTime*1.6541)));\n    \n    vec2 st = fragCoord / (yuv.yz + vec2(0.5)) / 1000.;\n    \n    \n    col += yuvMap(st,image,0.1) ;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 244, 244, 436], [438, 438, 485, 485, 571], [573, 573, 630, 680, 1518]], "test": "error"}
{"id": "wdlyD8", "name": "Cheshire eye from nature", "author": "solquemal", "description": "Experimenting ray marching technique", "tags": ["raymarching"], "likes": 1, "viewed": 56, "published": "Public", "date": "1584729030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Boundaries\n#define MAX_STEPS 32\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n//Auxiliar functions\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Scene and trace\n\nfloat scene(vec3 ray){\n    float radius = 0.3;\n    vec3 modSpace;\n    \n    float s = sdSphere(vec3(ray.xy,ray.z/1.2),0.55);\n    float sr = sdSphere(vec3(ray.x/0.5+sin(iTime)*0.02,ray.y/1.8,0.),0.22);\n \n    modSpace = vec3(ray.z,2.,ray.x);\n    ray = mod(ray, modSpace)-0.5*modSpace;\n    \n    float s2 = sdSphere(ray,radius);\n    \n\treturn min(opSubtraction(sr,s),s2);\n}\n\n\nvec3 trace(vec3 rayOrigin, vec3 dir) {\n\tfloat walk=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = rayOrigin + dir*walk;\n        float dS = scene(p);\n        walk += dS;\n        if(walk>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return hsv2rgb(vec3((1.-walk)/1.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = (uv*2.5) - vec2(2.5,1.2);\n    \n    vec3 camOrigin = vec3(0.,0.,-1.4);  \n    vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 1.5);\n    \n    \n    \n    //Experimenting rotations\n    rayOrigin.yz *= Rot(-uv.y*sin(iTime/2.));\n    rayOrigin.xz *= Rot(-uv.x*cos(iTime/2.));\n\n\tvec3 dir = normalize(rayOrigin-camOrigin);\n    \n    \n    fragColor = vec4(trace(rayOrigin, dir),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 100, 143, 143, 169], [171, 171, 190, 190, 266], [268, 268, 303, 303, 327], [328, 328, 350, 350, 519], [540, 540, 562, 562, 907], [910, 910, 948, 948, 1190], [1192, 1192, 1249, 1299, 1768]], "test": "ok"}
{"id": "WdlyDM", "name": "Endless Voronoi", "author": "jerky", "description": "Mouse to zoom.\n1,2,3: toggle layers\nP: toggle points\nD: toggle debug rings", "tags": ["2d", "voronoi", "zoom", "endless"], "likes": 11, "viewed": 242, "published": "Public API", "date": "1584912116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is free and unencumbered software released into the public domain.\n// https://unlicense.org/UNLICENSE\n\n#define RANK_1           6\n#define RANK_2           7\n#define RANK_3           9\n#define ZOOM_SPEED_1     2.\n#define ZOOM_SPEED_2     3.\n#define ZOOM_SPEED_3     5.\n#define ROTATE_SPEED_1  10.\n#define ROTATE_SPEED_2  -5.\n#define ROTATE_SPEED_3   3.\n#define SATURATION_1     1.0\n#define SATURATION_2     0.5\n#define SATURATION_3     0.75\n#define POINT_SIZE       0.0002\n\n/* library */\n\nconst float PI = radians(180.f);\nconst float TAU = radians(360.f);\n\nfloat length2(vec2 p) { return p.x * p.x + p.y * p.y; }\nint idiv(int a, int b) { return (a + (a > 0 ? b - 1 : 0)) / b; }\n\nvec3 hsv2rgb(float h, float s, float v) {\n    h = fract(h) * 6.;\n    float c = v * s;\n    float x = c * (1. - abs(mod(h, 2.) - 1.));\n    float m = v - c;\n    switch (int(h)) {\n        case 6:\n        case 0: return m + vec3(c, x, 0);\n        case 1: return m + vec3(x, c, 0);\n        case 2: return m + vec3(0, c, x);\n        case 3: return m + vec3(0, x, c);\n        case 4: return m + vec3(x, 0, c);\n        case 5: return m + vec3(c, 0, x);\n    }\n}\n\nbool keyToggle(int key) {\n    return texelFetch(iChannel0, ivec2(key, 2), 0).x > 0.;\n}\n\n/* voronoi */\n\nfloat res_d = 1./0.;\nvec3 res_color = vec3(0, 0, 0);\nvec2 p;\nint debug_rings = 0;\n\nvoid add_point(vec2 pos, vec3 color) {\n    float distance_from_center = length2(p);\n    float d = length2(pos - p.xy);\n    if (res_d < d)\n        return;\n    res_d = d;\n    res_color = !keyToggle(80/*p*/) && d < distance_from_center * POINT_SIZE\n        ? color * 0.8\n        : color * atan(distance_from_center / d / 2.) / PI * 2.;\n}\n\n// This function adds an infinity number of nested rings to the Voronoi Diagram.\n// The ring is a group of points at the same radius. Each ring consists of\n// `rank` points.\n//\n// The trick is, for each pixel, this function is checking only three possible\n// points: one in the ring above, one in the ring bellow, and one in two rings\n// bellow.\nvoid endless(int rank, float zoom, float rotation, float sat) {\n    if (rank <= 2) return;\n    float ring_dist = (1. + sin(PI / float(rank))) / cos(PI / float(rank));\n    zoom *= float(rank);\n\n    int center_ring = int(floor(log(length2(p)) / 2. / log(ring_dist) - zoom));\n    float alpha = (atan(p.y, p.x) / TAU - rotation) * float(rank);\n    float alpha1 = floor(alpha + 0.5) / float(rank);\n    float alpha2 = floor(alpha) / float(rank);\n\n    debug_rings += center_ring;\n    for (int ring = center_ring - 1; ring <= center_ring + 1; ring++) {\n        float shift = float(abs(ring) % 2) / 2. / float(rank);\n        float color_shift = float(idiv(3 * ring, 2)) / float(rank);\n        float d = abs(ring) % 2 == 0 ? alpha1 : alpha2;\n        float t = (rotation + shift + d) * TAU;\n        vec2 pos = pow(ring_dist, float(ring) + zoom) * vec2(cos(t), sin(t));\n        add_point(pos, hsv2rgb(d + color_shift, sat, 1.));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    p.xy = (fragCoord.xy - iResolution.xy / 2.) * pow(2., 20. * iMouse.x / iResolution.x);\n    float rot = iTime / 1000.;\n    float zoom = iTime / 100.;\n\n    if (!keyToggle(49/*1*/))\n        endless(RANK_1, zoom * ZOOM_SPEED_1, rot * ROTATE_SPEED_1, SATURATION_1);\n    if (!keyToggle(50/*2*/))\n        endless(RANK_2, zoom * ZOOM_SPEED_2, rot * ROTATE_SPEED_2, SATURATION_2);\n    if (keyToggle(51/*3*/))\n        endless(RANK_3, zoom * ZOOM_SPEED_3, rot * ROTATE_SPEED_3, SATURATION_3);\n\n    float debug_shade = keyToggle(68/*d*/) ? float(debug_rings % 2) / 4. + 0.5 : 1.;\n\n    fragColor = vec4(res_color, 1.) * debug_shade;\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyDM.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[564, 564, 587, 587, 619], [620, 620, 644, 644, 684], [686, 686, 727, 727, 1137], [1139, 1139, 1164, 1164, 1225], [1325, 1325, 1363, 1363, 1659], [1661, 2007, 2070, 2070, 2931], [2933, 2933, 2988, 2988, 3614]], "test": "error"}
{"id": "wdlyRn", "name": "Ray March test 1", "author": "bgold", "description": "Some initial tests in raymarching, trying out SDFs that also return a surface normal. ", "tags": ["raymarch"], "likes": 1, "viewed": 96, "published": "Public", "date": "1585064229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RATE 0.5\n#define STEPS 20\n\nvec3 rotx(in vec3 r, float a) {\n    return vec3(r.x, cos(a)*r.y+sin(a)*r.z, cos(a)*r.z-sin(a)*r.y);\n}\nvec3 roty(in vec3 r, float a) {\n    return vec3(cos(a)*r.x+sin(a)*r.z, r.y, cos(a)*r.z-sin(a)*r.x);\n}\n\nvec4 dist_s(in vec3 x, in vec3 s, in float rad) { \n    vec3 norm = normalize(x-s);\n    float d = distance(x,s) - rad;\n    return vec4(norm, d);\n}\n\nvec4 dist_c(in vec3 x, in vec3 c, in float side) {\n    vec3 norm = normalize(trunc(normalize(x-c)/side));\n    norm = norm;\n    //norm = normalize(trunc(norm*1.732));\n    vec3 dv = max((x-c)-side, -side-(x-c));\n    float d = max(max(dv.x,dv.y),dv.z);\n    return vec4(norm,d);\n}\n\nvec3 transform(in vec3 x) {\n    return rotx(roty(x,iTime*RATE), iTime/4.1*RATE);\n}\nvec3 transform2(in vec3 x) {\n    return rotx(roty(x,iTime/1.1*RATE), iTime/4.2*RATE);\n}\n\nvec4 estdist(in vec3 x) {\n    vec3 xform = transform(x);\n    vec3 c = vec3(2.5,3.5,5.5);\n    xform = mod(xform + 0.5*c,c)-0.5*c;\n    vec4 obj1 = dist_s(xform, vec3(0,0,0), 0.8);\n    vec4 obj2 = dist_c(xform, vec3(0,0,0), 0.55);\n    vec4 obj3 = dist_s(xform, vec3(0,0.6,0), 0.45);\n    vec4 obj4 = dist_s(xform, vec3(0,-0.6,0), 0.45);\n    vec3 norm = normalize( obj1.xyz*0.9 + obj2.xyz*0.1 );\n    return vec4(norm, max(max(max(obj1.w,obj2.w),-obj3.w),-obj4.w));\n}\n\nvec4 march(in vec3 start, in vec3 dir) {\n    vec3 x = start;\n    vec4 rval;\n    float dx;\n    vec3 norm;\n    for (int i=0; i<STEPS; i++) {\n        rval = estdist(x);\n        if (rval.w < 0.001) break;\n/*       \n\t\tif (rval.w > 10.0) {\n            rval = estdist(cross(x,-dir));\n            break;\n        }\n*/\n        x = x + rval.w * dir;\n    }\n    float dist = distance(start,x);\n    norm = rval.xyz;    \n    return vec4(norm,dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5))*2.0 * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec3 campos = vec3(0,0,1.5);\n    vec2 distortion = sin(uv*vec2(11.0,9.0)+iTime*vec2(10.0,12.0))/5.0;\n    vec3 camdir = normalize(vec3(uv,0)-campos);\n    \n    vec4 m = march(campos, camdir);\n    vec3 result = campos + m.w*camdir;\n    vec3 normdistort = sin(transform2(result) * 200.0)*0.1;\n    \n    vec3 norm = normalize(m.xyz + normdistort);\n\n    vec3 lightdir = normalize(vec3(1.1, -0.9, -1.2));\n    float shade1 = pow(0.5 - 0.5 * dot(norm, transform2(lightdir)), 1.5);\n    vec3 col1 = shade1 * vec3(1.0,0.5,1.0);\n    float shade2 = pow(0.5 - 0.5 * dot(norm, transform(lightdir)), 5.5)*0.4;\n    vec3 col2 = shade2 * vec3(1.0,1.0,0.0);\n    vec3 amb = vec3(1.0, 1.0, 1.0) * 0.3;\n    vec3 col3 = vec3(0.0,0.0,1.0) * pow(0.5 - 0.5 * dot(transform(normalize(vec3(0.2,0.2,-1.0))),norm), 100.5);\n    \n    float edge = pow(1.0 / abs(dot(transform2(camdir), norm)),0.3);\n    \n\n    // Output to screen\n    fragColor = vec4(clamp((col1+col2+col3+amb)/4.0*edge, 0.0, 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 66, 66, 136], [137, 137, 168, 168, 238], [240, 240, 289, 289, 385], [387, 387, 437, 437, 663], [665, 665, 692, 692, 747], [748, 748, 776, 776, 835], [837, 837, 862, 862, 1298], [1300, 1300, 1340, 1340, 1735], [1737, 1737, 1794, 1844, 2925]], "test": "timeout"}
{"id": "WdlyWH", "name": "Buildoids", "author": "leon", "description": "Shader made for the Cookie Collective live stream (2020/03/19) [url]https://www.twitch.tv/videos/570598632[/url]\nAdded dithering and mouse control for the Shadertoy version.", "tags": ["kifs", "city", "building"], "likes": 9, "viewed": 393, "published": "Public API", "date": "1584706573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader made for the Cookie Collective live stream (2020/03/19)\n// https://www.twitch.tv/videos/570598632\n// Added dithering and mouse control for the Shadertoy version.\n\n// Leon Denise aka ponk from Cookie Collective\n// Made in 2020/03/19 with the work of the Shadertoy community\n\nconst float iterations = 7.;\n\nvec2 mouse;\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec3 lookat (vec3 eye, vec3 at, vec2 uv, float fov) {\n  vec3 forward = normalize(at-eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward * fov + right * uv.x + up * uv.y);\n}\n\nfloat map (vec3 pos) {\n  float scene = 1.0;\n  float range = 2.0;\n  float a = 1.0;\n  float falloff = 1.2 + mouse.x * 0.6;\n  for (float index = iterations; index > 0.; --index) {\n    pos.xz *= rot(iTime*.05);\n    pos = abs(pos)-range*a;\n    scene = min(scene, max(pos.x,max(pos.y,pos.z)));\n    a /= falloff;\n  }\n  scene = max(-scene,0.);\n  return scene;\n}\n\nvec3 getNormal (vec3 p) {\n  vec2 e = vec2(0.0001,0);\n  return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), map(p+e.yxy)-map(p-e.yxy), map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(0,0.,-2);\n    vec3 ray = lookat(eye, vec3(0.,sin(iTime*.2)*.5,0), uv, .5);\n    mouse = (iMouse.xy / iResolution.xy);\n    float total = 0.0;\n    float shade = 0.0;\n    float dither = random(uv);\n    const float count = 100.;\n    for (float index = count; index > 0.; --index) {\n        float dist = map(eye+ray*total);\n        if (dist < 0.001) {\n            shade = index/count;\n            break;\n        }\n        dist *= .9 + 0.1 * dither;\n        total += dist;\n    }\n    vec3 color = vec3(shade);\n    vec3 normal = getNormal(eye+ray*total);\n    color = vec3(.3)*clamp(dot(normal, normalize(vec3(0,1,-1))),0.,1.);\n    color += vec3(.9)*pow(clamp(dot(normal, -ray),0.,1.), 8.);\n    color *= shade;\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 353, 353, 421], [422, 422, 442, 442, 492], [493, 493, 546, 546, 747], [749, 749, 771, 771, 1102], [1104, 1104, 1129, 1129, 1265], [1267, 1267, 1324, 1324, 2137]], "test": "timeout"}
{"id": "wdlyWj", "name": "Teal Voronoi Fog", "author": "grinchdubs", "description": "Spacy 3D Voronoi noise makes foggy feelings.", "tags": ["noise", "raymarch", "fog", "3dvoronoi"], "likes": 11, "viewed": 362, "published": "Public API", "date": "1585625378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"3D voronoi fog\" by jasondecode. https://shadertoy.com/view/XlXBWj\n// 2020-03-31 03:27:56\n\n/*\n3D Voronoi fogness.\n\nAuthor: Tim Gerritsen <tim@mannetje.org>\nDate: December 2017\n\n*/\n\n#define MAX_MARCH_STEPS 16\n#define MARCH_STEP_SIZE 0.2\n\n#define NOISE_AMPLITUDE 0.75\n\n#define FBM_ITERATIONS 3\n#define FBM_AMPLITUDE_GAIN .8\n#define FBM_FREQUENCY_GAIN 1.9\n\n// 2*tan(radians(45)/2)\n#define FOV45 0.82842693331417825056778150945139\n\nvec3 UvToWorld(vec2 uv) { return normalize(vec3((uv-0.5) * iResolution.xy, -iResolution.y / FOV45)); }\nvec3 Hash3( vec3 p ) { return fract(sin(vec3( dot(p,vec3(127.1,311.7,786.6)), dot(p,vec3(269.5,183.3,455.8)), dot(p,vec3(419.2,371.9,948.6))))*43758.5453); }\nfloat Voronoi(vec3 p)\n{\n\tvec3 n = floor(p);\n\tvec3 f = fract(p);\n\n\tfloat shortestDistance = 1.0;\n\tfor (int x = -1; x < 1; x++) {\n\t\tfor (int y = -1; y < 1; y++) {\n\t\t\tfor (int z = -1; z < 1; z++) {\n\t\t\t\tvec3 o = vec3(x,y,z);\n\t\t\t\tvec3 r = (o - f) + 1.0 + sin(Hash3(n + o)*50.0)*0.2;\n\t\t\t\tfloat d = dot(r,r);\n\t\t\t\tif (d < shortestDistance) {\n\t\t\t\t\tshortestDistance = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shortestDistance;\n}\n\nfloat FractalVoronoi(vec3 p)\n{\n\tfloat n = 0.0;\n\tfloat f = 0.5, a = 0.5;\n\tmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\tfor (int i = 0; i < FBM_ITERATIONS; i++) {\n\t\tn += Voronoi(p * f) * a;\n\t\tf *= FBM_FREQUENCY_GAIN;\n\t\ta *= FBM_AMPLITUDE_GAIN;\n\t\tp.xy = m * p.xy;\n\t}\n\treturn n;\n}\n\nvec2 March(vec3 origin, vec3 direction)\n{\n\tfloat depth = MARCH_STEP_SIZE;\n\tfloat d = 0.0;\n\tfor (int i = 0; i < MAX_MARCH_STEPS; i++) {\n\t\tvec3 p = origin + direction * depth;\n\t\td = FractalVoronoi(p) * NOISE_AMPLITUDE;\n\t\tdepth += max(MARCH_STEP_SIZE, d);\n\t}\n\treturn vec2(depth, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord.xy / res);\n\n\tvec3 direction = UvToWorld(uv);\n\tvec3 origin = vec3(0.0, -iTime*0.2, 0.0);\n\tvec2 data = March(origin, direction);\n    \n\tvec4 color = vec4(.5, 0.615733, 0.555, 1) * data.y * data.x * 0.7;\n\tfragColor = mix(color, vec4(0,0,1,1), max(0.0, 0.3-data.y));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 464, 464, 541], [542, 542, 564, 564, 699], [700, 700, 723, 723, 1106], [1108, 1108, 1138, 1138, 1376], [1378, 1378, 1419, 1419, 1659], [1661, 1661, 1718, 1718, 2032]], "test": "timeout"}
{"id": "WdlyWN", "name": "heavy metal torus", "author": "tristanwhitehill", "description": "weee", "tags": ["ray"], "likes": 0, "viewed": 39, "published": "Public", "date": "1584815249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .3\n\nvec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*sin( (iTime*.04)*130.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s , c);\n    \n}\n\nfloat sine(float rate){\n    return sin(iTime*rate);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return (length(q)-t.y);\n}\nfloat GetDist (vec3 p){\n \n   float n = noise(20.5*(iResolution.xy*.05));\n    //put the shape to march to in a position and the last value of the vec4 is the radius\n\tvec4 shape = vec4(0.,1,2.,0.);\n    vec4 shape2 = vec4(0.,1.,2.,0.);\n    vec4 shape3 = vec4(0.,1.,2.,0.);\n    \n   vec3 bp = p-shape.xyz;\n    bp.xy *= rot(iTime);\n   vec3 bp2 = p-shape2.xyz;\n    bp2.xy *= rot(-iTime);\n   vec3 bp3 = p-shape3.xyz;\n    bp3.yz *= rot(iTime);\n        \n    //distance to shape from current position, position - shape xyz then - the radius\n    //float sDist =(length(p-(shape.xyz))-shape.w);\n    float bd = sdTorus(bp, vec2(sine(.9)*6.,0.3));\n    bd -= sin(p.x*.2*iTime*.03)*.2;\n    float bd2 = sdTorus(bp2, vec2(sine(.6)*5.,0.2));\n    bd2 -= cos(p.y*.2*iTime*.03)*.2;\n    float bd3 = sdTorus(bp3, vec2(sine(.8)*2.,0.2));\n    bd3 -= sin(p.x*.2*iTime*.03)*.2;\n    //plane distance is the camera's y value\n    float pDist = p.y+6.;\n    //distance till collision is the minimum of shapes distance + camera\n    float d = min(bd2, pDist);\n    d = min(d, bd);\n    d = min(d, bd3);\n    return d;\n    \n    \n}\n\n\nfloat rayMarch (vec3 rayO, vec3 rayD){\n    float distO = 0.;\n        //keeping track of origin of distance loop in vec3 space//\n        \n        //loop that manages a number of steps we take till our ray intersects with the object//\n    for(int i=0; i<MAX_STEPS; i++){\n            //sum the ray source and object orientation and multiply by the ray direction\n            vec3 p= rayO+distO*rayD;\n            //scene orientation//\n            float distSc = GetDist(p);\n            //update distance of step in corellation to scene orientation//\n            distO += distSc;\n            //check if in contact with minimum size of intersection flag, and also the max number \n            //of steps we want to take in the scene declared above//\n            if(distSc<SURF_DIST || distO>MAX_DIST) break;\n        }\n            return distO;\n        }\n    \nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(3, 7, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), .2, 1.);\n    float d = rayMarch(p+n*SURF_DIST*7., l);\n    if(d<length(lightPos-p)) dif *= 3.1;\n    \n    return dif;\n}\n\nfloat getLight2(vec3 p) {\n    vec3 lightPos = vec3(0, 20, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.3, 1.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized canvas// 0 in middle//\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     float n = noise(2.5*(iResolution.xy*.5));\n\n    vec3 col = vec3(.9,.0,.4);\n    vec3 col2 = vec3(.2,.0,.9);\n    \n    //ray Position//\n    vec3 rayO = vec3(0.,0.,-10.0);\n    \n    //ray Direction//\n    vec3 rayD = normalize(vec3(uv.x,uv.y,1.));\n   \n    float d = rayMarch(rayO,rayD);\n     vec3 p = rayO + rayD *d;\n     d /= 5.;\n    float dif = getLight(p);\n    float dif2 =getLight2(p);\n    col = vec3(dif*col);\n    col2 = vec3(dif2*col2);\n   \n    fragColor = vec4((col+col2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 88, 88, 237], [239, 239, 265, 265, 663], [665, 665, 683, 683, 765], [767, 767, 790, 790, 820], [821, 821, 854, 854, 921], [922, 922, 945, 945, 2012], [2015, 2015, 2053, 2053, 2860], [2866, 2866, 2890, 2890, 3079], [3081, 3081, 3105, 3105, 3413], [3415, 3415, 3440, 3440, 3749], [3753, 3753, 3810, 3850, 4394]], "test": "timeout"}
{"id": "wdlyz7", "name": "Old CRTTV", "author": "loni852", "description": "CRT TV", "tags": ["tv", "crt", "crttv", "crttv"], "likes": 2, "viewed": 102, "published": "Public", "date": "1584577908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int grayscale = 0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 textura  = texture( iChannel0 , uv);\n    \n    //IF GRAYSCALE\n    if (grayscale == 1)\n    {\n    textura.r =  (textura.r + textura.g + textura.b)/3.0;\n    textura.b =  (textura.r + textura.g + textura.b)/3.0;\n    textura.g =  (textura.r + textura.g + textura.b)/3.0;\n    }\n    \n    \n    float maxeduv = floor(uv.x*30000.);\n    float maxeduvy = floor(uv.y*30000.);\n    \n    float contrast = 2.0;\n    float brightness = 25.0;\n    \n    \n    int uvxs = int(maxeduv);\n    int uvxsy = int(maxeduvy);\n    \n    int uvx = uvxs % 4;\n    int uvy = uvxsy % 8;\n    \n    vec3 outcolor = vec3(0,0,0)+textura.rgb;\n    if(uvx == 1){\n        outcolor.r = 1.0;\n    \toutcolor.g = 0.7;\n    }\n    else if(uvx == 2){\n        outcolor.b = 1.0;\n        outcolor.r = 0.7;\n    }\n    else if(uvx == 0){\n        outcolor.g = 1.0;\n        outcolor.b = 0.7;\n    }\n    \n    \n    if(uvy == 0 ){\n        outcolor *= 0.9;\n    }\n    \n    outcolor *= textura.rgb;\n    \n    //  Brightness\n    outcolor += brightness/255.0;\n    \n    outcolor = outcolor - contrast * (outcolor -1.0) * outcolor * (outcolor-0.5);\n    \n    //Horizontal Lines\n    float barstart = sin(300.0*iTime)*0.5+0.5;\n    float barend = sin(300.0*iTime+0.02)*0.5+0.5;\n    \n    if (uv.x > barstart && uv.x < barend){\n    \toutcolor *= 0.9;\n    }\n    //Vertical Lines\n    float barstart2 = sin(1.0*iTime)*0.5+0.5;\n    float barend2 = sin(1.0*iTime+0.02)*0.5+0.5;\n    \n    \n    if (uv.y > barstart2 && uv.y < barend2){\n    \toutcolor *= 0.9;\n    }\n    \n    \n    \n    \n    \n\n    \n    // Implemento Grain\n    float strength = 16.0;\n    \n    \n    //Sampled In Time\n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 50.0);\n    \n    \n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n    \n    \n    vec3 col = outcolor;\n    \n    \n    fragColor = vec4(col,1.0)+grain;\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2023]], "test": "error"}
{"id": "Wdlyzj", "name": "swirl for planet", "author": "artsem0214", "description": "swirl", "tags": ["swirl"], "likes": 13, "viewed": 212, "published": "Public", "date": "1585156898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n\n#define TILING_FACTOR 1.0\n#define MAX_ITER 8\n\n\nfloat waterHighlight(vec2 p, float time, float foaminess)\n{\n    vec2 i = vec2(p);\n\tfloat c = 0.0;\n    float foaminess_factor = mix(1.0, 6.0, foaminess);\n\tfloat inten = .005 * foaminess_factor;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));\n\t}\n\tc = 0.2 + c / (inten * float(MAX_ITER));\n\tc = 1.17-pow(c, 1.4);\n    c = pow(abs(c), 8.0);\n\treturn c / sqrt(foaminess_factor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * 0.1+23.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_square = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n    float dist_center = pow(2.0*length(uv - 0.5), 2.0);\n    \n    float foaminess = smoothstep(0.4, 1.8, dist_center);\n    float clearness = 0.1 + 0.9*smoothstep(0.1, 0.5, dist_center);\n    \n\tvec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;\n    \n    float c = waterHighlight(p, time, foaminess);\n    \n    vec3 water_color = vec3(0.0, 0.35, 0.5);\n\tvec3 color = vec3(c);\n    color = clamp(color + water_color, 0.0, 1.0);\n    \n    color = mix(water_color, color, clearness);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdlyzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 133, 133, 624], [627, 627, 685, 685, 1337]], "test": "ok"}
{"id": "wdlyzN", "name": "Menger--Triangle-v1", "author": "jorge2017a1", "description": "Menger--Triangle-v1", "tags": ["mengertrianglev1"], "likes": 1, "viewed": 41, "published": "Public", "date": "1584319740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat pathterrain(float x,float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\n\nfloat pathterrainv2(float x , float y, float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3+y\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.33;\n\t\n    \n    vec3 pp =p;   \n    pp.y =pp.y+1.5+2.0*cos(iTime*0.5);\n    \n    float dist = pathterrainv2(p.x,p.y,p.z);\n    \n  \n    \n    \n    pp.z= dist;\n    \n   float sdt1=sdTriPrism(pp- vec3(0., 5.0, 0.0) , vec2(17.0,17.0) ) ;\n   float sdt2=sdTriPrism(pp- vec3(0., 7.0, 0.0) , vec2(10.0,18.0) ) ;\n    \n   float dif1= differenceSDF( sdt1,sdt2);\n    dist =dif1;\n    \n    \n    \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    \n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 524, 524, 555], [557, 557, 588, 588, 679], [682, 682, 705, 705, 842], [844, 844, 874, 874, 1011], [1061, 1061, 1130, 1209, 1250], [1252, 1252, 1334, 1334, 1565], [1567, 1567, 1627, 1627, 1768], [1817, 1872, 1895, 1895, 2030], [2032, 2032, 2058, 2058, 2115], [2117, 2117, 2157, 2157, 2191], [2194, 2194, 2230, 2281, 2376], [2381, 2381, 2430, 2481, 2578], [2582, 2582, 2618, 2618, 2705], [2708, 2708, 2755, 2755, 2788], [2790, 2790, 2815, 2815, 2830], [2832, 2861, 2879, 2879, 3429], [3489, 3489, 3518, 3518, 3706], [3708, 3708, 3749, 3749, 3925], [3927, 3927, 3968, 3968, 4120], [4122, 4122, 4143, 4143, 4273], [4275, 4275, 4302, 4302, 4552], [4554, 4554, 4611, 4611, 5091]], "test": "timeout"}
{"id": "Wdlyzs", "name": "Encoding", "author": "scry", "description": "moving up? or down? or neither? :D", "tags": ["2d", "pattern"], "likes": 3, "viewed": 197, "published": "Public API", "date": "1585371784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iResolution.x > 1900.) {\n        uv *= 4.;\n    }\n    float time = iTime;\n    float c = length(vec2(uv.x+cos(time)*0.1,uv.y+sin(time)*0.1)-0.5);\n    c -= time*0.04;\n    //c*= sin(time*0.1)*100.;\n    c*= sin(time*0.01);\n    c += sin(uv.x*13.+time*0.1)*cos(uv.y*13.+time*0.1)*3.;\n    uv.x -= time*0.002*sin(time*0.4);\n    c += sin(uv.x*81.+time*0.1)*cos(uv.y*29.+time*0.1)*0.9;\n    uv.xy -= time*0.01*sin(time*0.03);\n    c += sin(uv.x*420.+time*0.1)*cos(uv.y*90.+time*0.4)*0.8;\n    uv.y += time*0.02*sin(time*0.05);\n    c += sin(uv.x*40.+time*0.1)*cos(uv.y*189.+time*0.4)*0.4;\n    c = sin(c*3.-time*26.)+time*0.1;\n    vec3 col = vec3(sin(c*2.),sin(c+0.1),cos(c))*0.5+0.5;\n    col = mix(col,sin(time*0.4)*texture(iChannel0,mix(col.rg*0.1,uv*0.5,0.9)).rgb,0.2);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdlyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 894]], "test": "error"}
{"id": "WdlyzX", "name": "spinny lines", "author": "justyn", "description": "some simple spinning lines drawn with a sine wave", "tags": ["lines", "sine", "rotating"], "likes": 0, "viewed": 37, "published": "Public", "date": "1585249991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime * 2.0;\n    float zoom = 50.0;\n    float clarity = 1.0;\n    vec4 color_A = vec4(0, 0.60, 0.60, 1);\n    vec4 color_B = vec4(0, 0.75, 0.75, 1);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float rad = radians(angle);\n    vec2 direction = vec2(cos(angle) * uv.x, sin(angle) * uv.y);\n    \n    float position = direction.x + direction.y;\n    float wave = sin(position * zoom) * clarity;\n        \n    fragColor = mix(color_A, color_B, clamp(wave, -1.0, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 547]], "test": "timeout"}
{"id": "WdscDM", "name": "roatiting square", "author": "fille", "description": "just a squares rotating", "tags": ["square"], "likes": 0, "viewed": 47, "published": "Public", "date": "1585047885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Integral(x,p,notp) ((floor(x)*(p))+ max(fract(x)-(notp),0.0));\n\nvec2 rotate(vec2 coords,float radius,vec2 pivot){\n    \n    float cosine = cos(radius);\n    float sine = sin(radius);\n    vec2 outuv;\n    coords.x -= pivot.x;\n    coords.y -= pivot.y;\n    outuv.x = coords.x * cosine - coords.y * sine;\n\toutuv.y = coords.x * sine + coords.y * cosine;\n    coords.x += pivot.x;\n    coords.y += pivot.y;\n\treturn outuv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 10.0;\n    float time = mod(iTime,speed);\n\tfloat freq = 2.0;\n    float radius =time;//1.77;// time;\n   \n    vec2 uv = (fragCoord) / iResolution.y;\n    uv = fract(uv*freq);\n    vec3 color = vec3(0);\n    vec2 halfuv = uv*0.5;\n    //uv = uv +time;\n  //  uv.x -=.25;\n   //uv.y -=.25;\n    vec2 normaluv = uv;\n   \tuv = rotate(uv,radius,vec2(0.50,0.5));\n    vec2 square = rotate(vec2(0.35,0.65),radius,vec2(0.5,0.5));\n    \n    \n    \n    uv+=0.175;\n    if(uv.x > 0.0 && uv.x < 0.35 && uv.y > 0.0 && uv.y < 0.35)\n        color = vec3(1.0,0.0,0.0);\n    \n    \n         \n \n    fragColor =vec4(color.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 121, 121, 420], [423, 423, 480, 480, 1096]], "test": "ok"}
{"id": "WdscR4", "name": "Simple neon lines", "author": "jetp250", "description": "Simple line utilizing the formula t=dot(C-A, B-A)/dot(B-A,B-A) for Q = A + t*(B-A), where A and B are the line start/end points and Q is the nearest point to input point C on the line.\n\nThanks a LOT to Spiney for the tonemapping function!", "tags": ["line"], "likes": 21, "viewed": 344, "published": "Public", "date": "1584276353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.1415926535\n#define TAU 6.2831853071\n\nfloat line(vec2 A, vec2 B, vec2 C, float thickness) {\n\tvec2 AB = B-A;\n    vec2 AC = C-A;\n\n    float t = dot(AC, AB) / dot(AB, AB);\n    t = min(1.0, max(0.0, t));\n    \n    vec2 Q = A + t * AB;\n    \n    float dist = length(Q-C);\n    return smoothstep(-0.01, -dist, -thickness) + smoothstep(-0.02, dist, thickness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < 20; ++i) {\n        float r = 0.5 - sin(iTime + float(i) * 0.8 * PI) * 0.1;\n        float angle = iTime * 0.2 + float(i+1) * 0.1 * PI;\n\n        vec2 dir = vec2(cos(angle), sin(angle)) * r;\n\n        vec2 A = -dir * 0.5;\n        vec2 B = -dir * 0.3;\n\n        float t = iTime * 0.5 + float(i) * 0.1 * TAU;\n        vec3 rgb = vec3(\n        \tsin(t\t\t  ) * 0.5 + 0.5,\n            sin(t + PI/2.0) * 0.5 + 0.5,\n            sin(t + PI\t  ) * 0.5 + 0.5\n        );\n\n        color += line(A, B, uv, 0.001) * rgb;        \n    }\n    \n    // Thanks Spiney!\n    color = color * 0.4 + sqrt(color*color / (color*color + 1.0)) * 0.6;\n\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 104, 104, 365], [367, 367, 424, 424, 1196]], "test": "timeout"}
{"id": "WdscWH", "name": "Lyapunov Animated", "author": "svyatozar", "description": "Original code by Ingo Quilez 2013 https://www.shadertoy.com/view/Mds3R8\nNot sure where I found this animated shader years ago, when I needed a placeholder shader for my opengl init code...\n\nMy addition: ability to modify sequence up to 20", "tags": ["fractal", "lyapunov"], "likes": 1, "viewed": 122, "published": "Public", "date": "1584711605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original code author: Inigo Quilez 2013 https://www.shadertoy.com/view/Mds3R8\n// Animation: author unknown :-(\n\nprecision highp float;\n#define ANIMSPEED 0.05\n#define ITERATIONS 20\n// Modify sequence here, for example: AABAB => SEQLEN=5 - (0, 0, 1, 0, 1)\n#define SEQLEN 9\nint seq[] = int[SEQLEN](0, 0, 1, 0, 0, 0, 1, 1, 1);\n\nvec3 calc(in vec2 p) {\n#if 0\n    float w[] = float[20](1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.);\n#else\n    float t = iTime * ANIMSPEED;\n    float w[] = float[20](\n\t\t0.97 + 0.04*sin(0.0 + 1.3*t),\n\t\t0.97 + 0.04*sin(1.0 + 1.7*t),\n\t\t0.97 + 0.04*sin(4.0 + 1.1*t),\n\t\t0.97 + 0.04*sin(2.0 + 1.5*t),\n\t\t0.97 + 0.04*sin(5.0 + 1.9*t),\n\t\t0.97 + 0.04*sin(6.0 + 1.8*t),\n\t\t0.97 + 0.04*sin(7.0 + 1.6*t),\n\t\t0.97 + 0.04*sin(8.0 + 1.3*t),\n\t\t0.97 + 0.04*sin(9.0 + 1.7*t),\n\t\t0.97 + 0.04*sin(10.0 + 1.1*t),\n\t\t0.97 + 0.04*sin(11.0 + 1.5*t),\n\t\t0.97 + 0.04*sin(12.0 + 1.9*t),\n\t\t0.97 + 0.04*sin(13.0 + 1.8*t),\n\t\t0.97 + 0.04*sin(14.0 + 1.6*t),\n\t\t0.97 + 0.04*sin(15.0 + 1.3*t),\n\t\t0.97 + 0.04*sin(16.0 + 1.7*t),\n\t\t0.97 + 0.04*sin(17.0 + 1.1*t),\n\t\t0.97 + 0.04*sin(18.0 + 1.5*t),\n\t\t0.97 + 0.04*sin(29.0 + 1.9*t),\n\t\t0.97 + 0.04*sin(20.0 + 1.8*t)\n\t);\n#endif\n\n\tfloat x = 0.5;\n\tfloat h = 0.0;\n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tfor(int j = 0; j < SEQLEN; ++j) {\n\t\t\tx = w[j]*p[seq[j]]*x*(1.0-x); h += log2(abs(w[j]*p[seq[j]]*(1.0-2.0*x)));\n\t\t}\n\t}\n\th /= float(ITERATIONS) * float(SEQLEN);\n\n\tvec3 col = vec3(0.0);\n\tif (h < 0.0) {\n\t\th = abs(h);\n\t\tcol = vec3(0.5+0.5*sin(0.0+2.5*h),\n\t\t\t0.5+0.5*sin(0.4+2.5*h),\n\t\t\t0.5+0.5*sin(0.7+2.5*h));\n\t\tcol *= vec3(1.1)*pow(h,0.25);\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 col;\n\tvec2 coord = gl_FragCoord.xy;\n    \n#if 1\n\tcol = calc(3.0 + (1.0 * coord / iResolution.xy));\n#else\n\tcol = calc(3.0 + 1.0*(gl_FragCoord.xy+vec2(0.0,0.0)) / iResolution.xy) +\n\t\tcalc(3.0 + 1.0*(gl_FragCoord.xy+vec2(0.0,0.5)) / iResolution.xy) +\n\t\tcalc(3.0 + 1.0*(gl_FragCoord.xy+vec2(0.5,0.0)) / iResolution.xy) +\n\t\tcalc(3.0 + 1.0*(gl_FragCoord.xy+vec2(0.5,0.5)) / iResolution.xy);\n\tcol /= 4.0;\n#endif\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 349, 349, 1600], [1602, 1602, 1657, 1657, 2098]], "test": "error"}
{"id": "wdscWn", "name": "getting started on Shadertoy", "author": "LoneCactusMotel", "description": "An intersection of two spheres with noise and sine displacement.", "tags": ["raymarching"], "likes": 3, "viewed": 230, "published": "Public API", "date": "1584594487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 estimate_normal(vec3 p);\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c);\nfloat noise(vec3 p);\n\n// return value encodes color in xyz/rgb and distance in w/a components.\nvec4 opSmoothIntersection(vec4 d1, vec4 d2, float k);\n\nvec4 sdf_sin_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color);\nvec4 sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color);\n\n\nvec4 sdf_scene(vec3 probe)\n{\n    return opSmoothIntersection(sdf_sin_sphere(vec3(0.0, sin(0.7*iTime), -8.200), 1.0, probe, vec3(0.0, 1.0, .8)),\n                                sdf_noisy_sphere(vec3(sin(iTime), 0.0, -8.200), 0.8000, probe, vec3(1.0, 1.0, 0.0)),\n                                0.5);\n}\n\n\n// Fragment function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2((fragCoord.x - 0.5*iResolution.x)/iResolution.y , (fragCoord.y - 0.5*iResolution.y)/iResolution.y);\n\n\tfloat eps = 0.0015;\n\tvec3 light = vec3(-3.0+3.0*sin(iTime), 4.0+3.0*sin(1.3*iTime), 8.0);\n\tvec3 camera = vec3(0.0, 0.0, 4.0);\n\tvec3 pixel = vec3(uv, 0.0);\n\tvec3 ray = normalize(pixel-camera);\n\tvec3 probe = camera;\n\tvec4 dist = vec4(0.0, 0.0, 0.0, 2.0*eps);\n    \n    const float min_z = -20.0;\n    const int max_iterations = 500;\n\n    int final_its = max_iterations;\n    \n\tfor(int its=max_iterations; its>0; its-=1)\n\t{\n\t    final_its = its-1;\n\n\t\tdist = sdf_scene(probe);\n\t\tprobe = probe + (dist.w * ray);\n        if(dist.w <= eps || probe.z <= min_z)\n        {\n            break;\n        }\n\t}\n\n\tif (dist.w <= eps)\n\t{\n\t\tvec3 normal = estimate_normal(probe);\n\t\tvec3 color = dist.rgb;\n\t\tfragColor = phong_shading(probe, normal, light, camera, color);\n\t}\n\telse if(final_its <= 0)\n\t{\n\t\tfragColor = vec4(1, 1, 0, 1);\n\t}\n\telse if(probe.z <= min_z)\n\t{\n\t\tfragColor = vec4(0, 0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(1, 1, 1, 1);\n\t}\n}\n\n\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip;\n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p);\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat sin_displacement(vec3 p, float frequency)\n{\n\treturn sin(frequency*p.x)*sin(frequency*p.y)*sin(frequency*p.z);\n}\n\n\n// smooth intersection (IQ) with added color blend\nvec4 opSmoothIntersection(vec4 d1, vec4 d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec4 sdf_sin_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color)\n{\n\treturn vec4(color, distance(probe, sphere_center) - sphere_radius + 0.05*sin_displacement(probe, 20.0));\n}\n\nvec4 sdf_noisy_sphere(vec3 sphere_center, float sphere_radius, vec3 probe, vec3 color)\n{\n\tvec3 nrml = normalize(probe-sphere_center);\n\treturn vec4(color, distance(probe, sphere_center) - sphere_radius - 0.5*noise(2.6*(nrml+vec3(0.2*iTime, 0.2*iTime, iTime))));\n}\n\n\n\nvec3 estimate_normal(vec3 p) {\n\tfloat eps = 0.001;\n    return normalize(vec3(\n        sdf_scene(vec3(p.x + eps, p.y, p.z)).w - sdf_scene(vec3(p.x - eps, p.y, p.z)).w,\n        sdf_scene(vec3(p.x, p.y + eps, p.z)).w - sdf_scene(vec3(p.x, p.y - eps, p.z)).w,\n        sdf_scene(vec3(p.x, p.y, p.z + eps)).w - sdf_scene(vec3(p.x, p.y, p.z - eps)).w\n    ));\n}\n\n\n// p: point on surface\n// n: surface normal at p\n// l: position of light source\n// v: position of viewer\n// c: diffuse color\nvec4 phong_shading(vec3 p, vec3 n, vec3 l, vec3 v, vec3 c)\n{\n\tvec3 light = normalize(l);\n\tvec3 r     = reflect(light, n);\n\tvec3 view  = normalize(v-p);\n\tfloat diffuse  = max(0.0, dot(light, n));\n\tfloat specular = max(0.0, dot(-r, view));\n\tvec3 color = diffuse * c + pow(specular, 40.0) * vec3(1, 1, 1);\n\treturn vec4(color, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdscWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 416, 444, 444, 716], [719, 740, 795, 795, 1841], [1845, 1871, 1892, 1892, 2139], [2141, 2141, 2190, 2190, 2258], [2261, 2312, 2366, 2366, 2469], [2472, 2472, 2558, 2558, 2666], [2668, 2668, 2756, 2756, 2930], [2934, 2934, 2964, 2964, 3287], [3290, 3415, 3475, 3475, 3743]], "test": "error"}
{"id": "WdsczH", "name": "param_v15", "author": "darkczar", "description": "epicycles", "tags": ["learning"], "likes": 2, "viewed": 71, "published": "Public", "date": "1584159182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n  \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<500;i++)\n    {\n        di = float(i)*.03;\n        curve_p.x = .3*sin(.4*iTime)+.15*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .6*sin(iTime*.1)*float(di)*cos(11.0*di+.8*iTime);\n        curve_p.y = .3*cos(.4*iTime)+.15*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .6*sin(iTime*.1)*float(di)*sin(11.0*di+.8*iTime);\n        d = min(d, length(p-curve_p)+.4*sin(iTime*.4)*rand(vec2(di,di)));\n  \n    }\n    \n    float r = .025*d*d*sin(.2*iTime);\n    float g = .01*sin(.001*d*d+.1*length(p));\n    float b = .25*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,2.0)));\n    if (d>.05)\n    {\n        b=pow(b,2.25)*dot(p,vec2(4.,.5));\n    } else\n    {\n        b = pow(b,.5)*d*2.*d;\n    }\n    if (d>.05 && d < .07)\n    {\n        r = pow(r,.5);\n    }\n    if (d>.07 && d < .09)\n    {\n        g = pow(g,.5);\n    }\n    vec3 col = vec3(r,g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 342, 392, 1586]], "test": "timeout"}
{"id": "wdsczl", "name": "noise and cells", "author": "singoltone", "description": "noise and cells", "tags": ["noise"], "likes": 5, "viewed": 79, "published": "Public", "date": "1585398280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n#define sat(x) clamp(x, 0., 1.)\n#define PI 3.14159265359\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return sat((t-a)/(b-a)) * (d-c) + c;\n}\n\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nvec2 translate(vec2 uv, float shiftX, float shiftY, float factor)\n{\n    vec2 translate = vec2(shiftX, shiftY);\n    uv += translate*factor;\n    return uv;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    uv *= 10.;\n   \n    vec3 col = vec3(0.);\n\n    vec2 uv_i = floor(uv);\n    vec2 uv_f = fract(uv);\n\n    float minDist = 100.;\n\tint neighbourLoc = 4;\n    \n    for(int y=-neighbourLoc; y < neighbourLoc; y++) {\n        for(int x=-neighbourLoc; x < neighbourLoc; x++){\n            \n            vec2 neighbour = vec2(float(x), float(y));\n            vec2 point = random2(uv_i + neighbour);\n            point = 0.5 + ( remap( -1., 1., -0.5, 0.5, sin(iTime)) )*sin(iTime + 6.2831* point)*snoise(uv)*1.8;\n            vec2 diff = neighbour + point - uv_f;  \n    \t    float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    \n    col += minDist;\n\tcol += 1.-smoothstep(.2, 0.55, minDist)*1.7;\n    //col += 1. - step(.02, minDist);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 46, 46, 93], [94, 94, 115, 115, 162], [163, 163, 185, 185, 220], [280, 280, 338, 338, 381], [384, 384, 406, 459, 2156], [2157, 2157, 2224, 2224, 2312], [2314, 2314, 2342, 2342, 2428], [2430, 2430, 2454, 2454, 2547], [2549, 2549, 2606, 2656, 3550]], "test": "timeout"}
{"id": "Wdsczn", "name": "V Pathogen Path to Power", "author": "RaduBT", "description": "V For Vendetta - Pathogen Path To Power\n\nAdapted from Protean clouds Has been Shader of the Week!\nCreated by nimitz in 2019-05", "tags": ["3d", "fast", "volumetric"], "likes": 11, "viewed": 694, "published": "Public API", "date": "1584009511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n   \n\tfloat fft1 = (texture(iChannel0, p).xyz,1.0);\n \n    float fft = 0.15 + 1.116 *(((texture( iChannel0, vec2(p.y+5.0, 5.0) ).x)) * 3.51);\n    \n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb*fft1*.865;\n    col = iLerp(col.bgr, col.rgb*fft, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( fft*16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "MtjGzm", "previewfilepath": "https://soundcloud.com/radubt/v-for-vendetta-pathogen-path-to-power", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/radubt/v-for-vendetta-pathogen-path-to-power", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdsczn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1153, 1153, 1205], [1317, 1317, 1336, 1336, 1353], [1354, 1354, 1406, 1406, 1450], [1490, 1490, 1509, 1509, 1560], [1562, 1562, 1580, 1580, 2107], [2109, 2109, 2160, 2160, 3194], [3196, 3196, 3218, 3218, 3333], [3335, 3408, 3454, 3454, 3800], [3802, 3802, 3859, 3859, 5129]], "test": "error"}
{"id": "wdsyD8", "name": "Sea of Lava", "author": "jarble", "description": "This fractal is based on my [url=https://www.shadertoy.com/view/ttKXWt]\"Sea of Ice\"[/url] shader.\n\nMove the mouse to zoom in and out!", "tags": ["procedural", "fractal", "texture", "lava"], "likes": 2, "viewed": 255, "published": "Public API", "date": "1584730344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n\tint biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1044], [1050, 1050, 1105, 1105, 1297], [1299, 1299, 1358, 1358, 1563], [1566, 1566, 1609, 1609, 1745], [1747, 1747, 1781, 1781, 1810], [1812, 1812, 1838, 1838, 3195], [3198, 3198, 3251, 3251, 3925], [3927, 3927, 3983, 3983, 4039], [4041, 4041, 4116, 4116, 4453], [4744, 4744, 4801, 4801, 5061]], "test": "error"}
{"id": "wdsyDr", "name": "chlandi patterns 2", "author": "StrangerintheQ", "description": "chlandi patterns 2", "tags": ["chlandi"], "likes": 5, "viewed": 204, "published": "Public", "date": "1584608306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    for (int i=0; i<3; i++) {\n    \tp = abs(p)/dot(p,p);\n        p -= vec2(sin(iTime*0.1347), cos(iTime*0.1473));\n    }\n    \n    vec4 s1 = vec4(1.0, 1.0, 7.0, 2.0);\n    vec4 s2 = vec4(4.0, 4.0, 2.0, 4.6);\n\n    float tx = sin(iTime)*0.2347; \n    float ty = cos(iTime)*0.2473; \n\n    vec4 s = mix(s1, s2, vec4(tx,tx,ty,ty));\n\n    float amp = \n        s.x * sin(PI*s.z*p.x) * sin(PI*s.w*p.y) + \n        s.y * sin(PI*s.w*p.x) * sin(PI*s.z*p.y);\n\n    fragColor = vec4(1.0 - smoothstep(abs(amp), 0.0, 0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsyDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 656]], "test": "ok"}
{"id": "WdsyRf", "name": "idkrly", "author": "gmakoveckij", "description": "Sry", "tags": ["epilepsy", "bw"], "likes": 0, "viewed": 42, "published": "Public", "date": "1585255891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float div = iResolution.x / iResolution.y;\n    \n    if (!(pow(uv.x - iMouse.x / iResolution.x, 2.) * div * div +\n          pow(uv.y - iMouse.y / iResolution.y, 2.) < 0.2)) return;\n    \n   \tvec3 col = 0.7 * vec3(cos(-iMouse.x / 10. + uv.x * 100. + iTime * 2.));\n    col += 0.4 * vec3(sin(-iMouse.y / 10. + uv.y * 100.));\n    \n    col = vec3(col.y + sin(iTime), col.y - cos(iTime), col.z + sin(iTime));   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 615]], "test": "ok"}
{"id": "WdsyRM", "name": "Wave 0.1", "author": "rackman", "description": "Reproduction of / heavily inspired by the album artwork of \"Com Truise - Wave 1\" by Seth Haley: https://en.wikipedia.org/wiki/Wave_1\n", "tags": ["2d", "retro", "comtruise", "synthwave", "reproduction"], "likes": 20, "viewed": 234, "published": "Public", "date": "1584466318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Reproduction of / heavily inspired by the album artwork of\n * \"Com Truise - Wave 1\" by Seth Haley\n * https://en.wikipedia.org/wiki/Wave_1\n */\nconst float TAU = 6.2831853071;\n\nconst float ANGLE = -0.785;\nconst mat2 ROTATION = mat2(cos(ANGLE), -sin(ANGLE), sin(ANGLE), cos(ANGLE));\n\nconst float SEGMENT_THICKNESS = 0.45;\nconst vec2 SEGMENT_ASPECT = vec2(8.0, 1.0);\n\nconst vec2 BOX_SIZE = vec2(0.333);\nconst float BOX_THICKNESS = 0.004;\n\nconst float ZOOM = 35.0;\n\nconst vec3[] COLORS = vec3[](\n    vec3(0.572, 0.153, 0.561),\n    vec3(0.071, 0.659, 0.616),\n    vec3(0.145, 0.666, 0.886),\n    vec3(0.969, 0.580, 0.114),\n    vec3(0.945, 0.349, 0.165),\n    vec3(0.980, 0.702, 0.576)\n);\n\nconst vec3 BG_START = vec3(0.322, 0.301, 0.616);\nconst vec3 BG_END = vec3(0.980, 0.718, 0.418);\n\n// https://thebookofshaders.com/10/\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 segmentColor(vec2 st) {\n    return COLORS[int(random(st) * float(COLORS.length()))];\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n     \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float boxD = sdBox(uv, BOX_SIZE);\n    \n    vec3 col = vec3(mix(BG_START, BG_END, uv.y + 0.5));\n        \n    uv *= ROTATION;\n    \n    float light = uv.x;\n    vec2 id = floor(uv * ZOOM);\n    \n    // modulate x position for each row, fastest nearest to the center\n    uv.x += -iTime * (0.5-abs(id.y * 0.01)) + random(id.yy) * 0.15;\n    \n    uv /= SEGMENT_ASPECT;\n    uv *= ZOOM;\n    \n    vec2 gv = fract(uv);\n    \n    // comment this out for glitchy colours...\n    id = floor(uv);\n    \n    gv -= 0.5;\n    gv *= SEGMENT_ASPECT;\n    \n    // modulate segment length\n    float segmentLen = 2.0 + sin(iTime * (1.5 + random(id) * 1.5) + random(id) * TAU) * random(id) * 1.5;\n    \n\tfloat segmentD = sdSegment(gv, vec2(-segmentLen, 0.0), vec2(segmentLen, 0.0)) - SEGMENT_THICKNESS;\n         \n    // i'm sure this can be done without branching somehow\n    if (segmentD > -SEGMENT_THICKNESS && segmentD < -0.05 && boxD < 0.0) {\n    \tcol = smoothstep(-0.01, -0.05, segmentD) * segmentColor(id);\n        col += light;\n    }\n    \n    col += smoothstep(0.00, -0.001, abs(boxD) - BOX_THICKNESS);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[784, 820, 843, 843, 919], [921, 921, 949, 949, 1012], [1014, 1089, 1139, 1139, 1264], [1266, 1266, 1301, 1301, 1386], [1393, 1393, 1448, 1448, 2645]], "test": "error"}
{"id": "WdsyWB", "name": "ray marching exp", "author": "Artleet", "description": "experiment", "tags": ["raymarching", "experiment", "2tweets", "short", "golf"], "likes": 4, "viewed": 129, "published": "Public", "date": "1585591890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//initial version\n/*\n#define mainImage(o,u)\\\n  o=normalize(vec4(u-iResolution.xy*.5,8e2,0));\\\n  for (vec4 p,b; b.w<9e1; ++b.w, b.z=iTime)\\\n    p=b+o*(o.w+=length(fract(vec3(length(p.xy),atan(p.x, p.y)*1.59+p.z*.3,p.z))-.5)-.1);\\\n  o=o/o/o.w\n*/\n//Thaks to @FabriceNeyret2 for his tips\n//Following wersion doesn't work on Safari and Edge (WebGL1)\nvoid mainImage(out vec4 o, vec2 u)\n{\n  o=normalize(vec4(2e3,0,u+u-iResolution.xy));\n  vec4 p;\n  for(int i=0;++i<90;)\n  \tp=o*(o.y+=length(fract(vec3(length(p.zw),atan(p.z,p.w)*1.59+(p.x+=iTime)*.3,p))-.5)-.1);\n  o/=p*abs(o);\n}\n/*\n\n//Universal version, works on WebGL1 but not on iOs\n/*void mainImage(out vec4 o, vec2 u){\n\to=normalize(vec4(2e3,0,u+u-iResolution.xy));\n    vec4 p;\n    for(int i=0;i<80;++i)\n        p=o*(o.y+=length(fract(vec3(length(p.zw),atan(p.z,p.w)*1.59+(p.x+=iTime)*.3,p))-.5)-.1);\n\to /= p;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 345, 381, 381, 570]], "test": "ok"}
{"id": "WdsyWj", "name": " The Live Coders Conference - 2", "author": "mrange", "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.", "tags": ["3d", "fbm", "raymarcher", "tlc"], "likes": 3, "viewed": 246, "published": "Public API", "date": "1585597203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by mrange/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Unported License.\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// pmin from IQ's blog on smooth minimum functions:\n//  http://www.iquilezles.org/www/articles/smin/smin.htm\n\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  5.0\n#define MAX_BOUNCES     5\n#define MAX_RAY_MARCHES 65\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define AA              0\n\n#define TTIME           (TAU*iTime)\n\n#define SCA(a) vec2(sin(a), cos(a))\n\nconst vec2 sca          = SCA(PI*4.5/6.0);\nconst vec3 lightPos1    = 100.0*vec3(-1.0, 0.0, 0.0);\nconst vec3 lightCol1    = vec3(0.63, 0.63, 1.0);\nconst vec3 spokeColor   = vec3(0.5, 0.5, 1.0);\nconst vec3 meepleColor  = vec3(0.8);\nconst vec3 bgColor      = vec3(0.1, 0.1, 0.25);\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat maxComp(vec3 p) {\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nfloat cylinder(vec3 p, float ra, float rb, float h) {\n  h -= rb;\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat box(vec3 p, vec3 b, float r) {\n  b -= r;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat torus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k ) - rb;\n}\n\nfloat spokes(vec3 p, float s) {\n  vec2 pp = toPolar(p.xz);\n  pp.y += TTIME/14.0;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p.xz = toRect(pp.xy);\n  float ds = box(p, s*vec3(0.075, 0.125, 0.5), s*0.04);\n  return ds;\n}\n\nfloat arcs(vec3 p, float s) {\n  p.xyz = p.zxy*vec3(1.0, -1.0, 1.0);\n  p.z += -0.25;\n  float d1 = torus(p, sca, 0.275*s, 0.025*s);\n  float d2 = torus(p, sca, 0.18*s, 0.025*s);\n  return min(d1, d2);\n}\n\nfloat meeple(vec3 p, float s) {\n  p.xyz = p.zxy*vec3(1.0, -1.0, 1.0);\n  float dh = box(p - s*vec3(0.0, -0.035, 0.125), s*vec3(0.07, 0.1, 0.05), s*0.065);\n  float dc = box(p - s*vec3(0.0, -0.22, 0.125), s*vec3(0.15, 0.04, 0.075), s*0.05);\n\n  return pmin(dh, dc, s*0.115);\n}\n\nfloat intersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\nfloat differenceRound(float a, float b, float r) {\n  return intersectionRound(a, -b, r);\n}\n\nfloat theLiveCoder(vec3 p, float s, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  float dr = cylinder(p, 0.375*0.5*s, 0.075*s, 0.125*s);\n  float ds = spokes(p, s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n\n  float nda = (da - 0.0125*s);\n  float ndm = (dm - 0.0125*s);\n  float nd  = min(nda, ndm);\n\n  float d = dr;\n  d = min(d, ds);\n  float dw = d;\n  d = differenceRound(d, nd, 0.02);\n  d = min(d, da);\n  d = min(d, dm);\n\n  oda = da;\n  odm = dm;\n\n  vec2 pp = toPolar(p.xz);\n\n  vec3 acol = saturate(spokeColor + 0.5*vec3(1.0, 0.0, 0.0)*sin(-TTIME/7.0 + PI*pp.x + 0.5) +  0.5*vec3(0.0, 1.0, 0.0)*sin(-TTIME/6.0 + 1.0*pp.y + 0.0));\n\n  if (d == da) {\n    col = acol;\n    trans = 0.70;\n  } else if (d == dm) {\n    col = meepleColor;\n    trans = 0.70;\n  } else if (d != dw) {\n    col = acol;\n    trans = 0.5;\n  } else {\n    col = vec3(0.25, 0.25, 0.5);\n    trans = 0.5;\n  }\n\n  ref = 0.25;\n  absorb = mix(vec3(1.0), vec3(-5.0), col*col);\n\n  return d;\n}\n\nfloat distanceField(in vec3 p, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  p.xy = p.yx*vec2(-1.0, 1.0);\n\n  float d = theLiveCoder(p, 2.0, oda, odm, col, ref, trans, absorb);\n\n  return d;\n}\n\nvec3 getSkyColor(vec3 rayDir) {\n  vec3 lightDir1 = normalize(lightPos1);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  vec3 final     = 0.1*lightCol1;\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  vec3 light = 1.0*lightCol1;\n\n  final += light*pow(ld1, 20.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3 eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float oda;\n  float odm;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.xyy, oda, odm, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.yxy, oda, odm, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, oda, odm, col, ref, trans, absorb) - distanceField(pos-eps.yyx, oda, odm, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out float oda, out float odm, out vec3 col, out float ref, out float trans, out vec3 absorb) {\n  float t = mint;\n  float distance;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, oda, odm, col, ref, trans, absorb);\n    distance = dmod*distance_;\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n\n  if (distance > TOLERANCE) return MAX_RAY_LENGTH;\n\n  return t;\n}\n\nvec3 postProcess(in vec3 col, in vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 1.5*vec3(1.0, 3.0, 1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  float refraction = 1.3;\n\n  bool inside = false;\n\n  const float mint    = 0.05;\n  const float minstep = 0.00025;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    float oda   ;\n    float odm   ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, oda, odm, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH) {\n      nor = normal(pos);\n    } else {\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside) {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3  lv  = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n\n    float dif = max(dot(nor,ld),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*occ;\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n    mcol += 0.5*spokeColor*tanh(1.0/(20.0*(max(oda, 0.05))));\n    mcol += meepleColor*0.35*tanh(1.0/(100.0*(pow(max(odm, 0.025), 1.5))));\n\n    vec3 beer = vec3(1.0, 1.0, 1.0);\n\n    if (inside) {\n      beer = exp(-absorb*t);\n    }\n\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0)) {\n        rd = refl;\n    } else {\n      rd = refr;\n      inside = !inside;\n    }\n  }\n\n  return final;\n}\n\nvec3 getSample(in vec2 p) {\n  vec3 ro  = vec3(2.5, 0.0, 0.0) + 0.5*vec3(0.0, sin(TTIME/33.0), cos(TTIME/36.0));;\n\n  vec3 la  = vec3(0.0) + 0.125*vec3(0.0, sin(TTIME/30.0), cos(TTIME/27.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\n\nfloat box2(vec2 p, vec2 b, float r) {\n  b -= r;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float db = box2(p, vec2(0.88), 0.3);\n\n  if (db > 0.0) {\n    float m = smoothstep(0.1, 0.105, db);\n    fragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(bgColor, 1.0), m);\n    return;\n  }\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n  col = postProcess(col, p);\n  float bb = smoothstep(0.005, 0.125, abs(db));\n  col = mix(vec3(0.125), col, pow(bb, 0.350));\n  float wb = smoothstep(0.0, 0.005, abs(db));\n  col = mix(vec3(1.0), col, wb);\n  col = mix(bgColor, col, smoothstep(0.0, 16.0, iTime*iTime));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1184, 1184, 1206, 1206, 1250], [1252, 1252, 1273, 1273, 1318], [1320, 1320, 1359, 1359, 1484], [1486, 1486, 1525, 1525, 1601], [1603, 1603, 1626, 1626, 1660], [1662, 1662, 1690, 1690, 1719], [1720, 1720, 1748, 1748, 1777], [1779, 1779, 1832, 1832, 1960], [1962, 1962, 1998, 1998, 2099], [2101, 2101, 2163, 2163, 2310], [2312, 2312, 2343, 2343, 2529], [2531, 2531, 2560, 2560, 2729], [2731, 2731, 2762, 2762, 3003], [3005, 3005, 3057, 3057, 3145], [3147, 3147, 3197, 3197, 3237], [3239, 3239, 3369, 3369, 4245], [4247, 4247, 4372, 4372, 4488], [4490, 4490, 4521, 4521, 4986], [4988, 4988, 5014, 5014, 5579], [5581, 5581, 5772, 5772, 6146], [6148, 6148, 6190, 6190, 6338], [6340, 6340, 6377, 6377, 8298], [8300, 8300, 8327, 8327, 8711], [8714, 8714, 8751, 8751, 8841], [8843, 8843, 8898, 8898, 9755]], "test": "error"}
{"id": "WdsyWr", "name": "Awake Remixes", "author": "rackman", "description": "Reproduction of the album artwork of \"Tycho - Awake Remixes\" by Scott Hansen: https://en.wikipedia.org/wiki/Awake_(Tycho_album)#Awake_Remixes", "tags": ["2d", "retro", "tycho", "synthwave", "reproduction"], "likes": 6, "viewed": 108, "published": "Public", "date": "1584591984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Reproduction of the album artwork of \n * \"Tycho - Awake Remixes\" by Scott Hansen\n * https://en.wikipedia.org/wiki/Awake_(Tycho_album)#Awake_Remixes\n */\n\n// not quite equilateral\nconst vec2 START_SIZE = vec2(0.5, -0.887);\n\nconst vec2 START_POS = vec2(0.0, 0.455);\n\nconst vec3 BG_COLOR = vec3(0.194, 0.198, 0.206);\nconst vec3 OUTER_COLOR = vec3(0.863, 0.875, 0.794);\n\nconst vec3[] INNER_COLORS = vec3[](\n    vec3(0.773, 0.491, 0.405),\n    vec3(0.713, 0.443, 0.414),\n    vec3(0.627, 0.396, 0.467),\n    vec3(0.220, 0.509, 0.624)\n);\n\nconst float[] SIZES = float[](1.00, 0.80, 0.64, 0.48, 0.32, 0.16);\n\nconst float ANGLE = -2.6317;\nconst mat2 ROTATION = mat2(cos(ANGLE), -sin(ANGLE), sin(ANGLE), cos(ANGLE));\n\nconst float MAZE_ANGLE = 1.5707;\nconst mat2 MAZE_ROTATION = mat2(cos(MAZE_ANGLE), -sin(MAZE_ANGLE), sin(MAZE_ANGLE), cos(MAZE_ANGLE));\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://thebookofshaders.com/10/\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// https://thebookofshaders.com/11/\nfloat noise(in vec2 st) {\n    st *= 8.0;\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat drawTriangle(vec2 p, float s, vec3 c, inout vec3 col) {\n    \n    vec2 size = START_SIZE * 0.95 * s;\n        \n    vec2 pos = p - START_POS;\n    pos.y -= (START_SIZE.y - size.y) * 0.67;\n\n    float d = sdTriangleIsosceles(pos, size);\n\n    if (d < 0.0) {\n        col = c;\n    }\n    \n    return d;\n}\n\nvoid drawMaze(vec2 uv, float d, inout vec3 col) {\n    vec2 st = uv; \n     \n    st *= 35.0;\n    st.x -= 0.4;\n    \n    st *= ROTATION;\n    \n    st.y += iTime * 0.75;\n    \n    vec2 gv = fract(st);\n    vec2 id = floor(st);\n    \n    bool rotate = noise((id / 20.0) + floor(iTime * 1.25)) > 0.5 ? true : false;\n    \n    if (rotate) {\n        gv *= MAZE_ROTATION;\n    }\n    \n    if (d < 0.0) {\n        float c = smoothstep(0.0, 0.01, abs(gv.x) - 0.499);\n        col = mix(BG_COLOR, col, c);\n    }\n}\n\nvec3 triColor(int i, float r) {\n    r = mod(r, 3.999);\n    \n    float cr = mod(float(i) + r, 3.999);\n    \n    i = int(floor(cr));\n    \n    vec3 startColor = INNER_COLORS[i];\n    \n    if (++i > 3) i = 0;\n    \n    vec3 endColor = INNER_COLORS[i];\n    \n    return mix(startColor, endColor, fract(cr));\n}\n\n// http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat expImpulse(float x, float k) {\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n   \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(BG_COLOR);\n    \n    float d = drawTriangle(uv, SIZES[0], OUTER_COLOR, col);\n    \n    drawMaze(uv, d, col);\n    \n    float colorRot = expImpulse(fract(iTime * 1.25), 7.5) * 3.0;\n    \n    for (int i = 1; i < SIZES.length() - 1; i++) {\n        drawTriangle(uv, SIZES[i], triColor(i-1, colorRot), col);\n    }\n    \n    drawTriangle(uv, SIZES[5], BG_COLOR, col);\n    \n    uv *= iResolution.y / 8.0;\n    \n    col *= 1.0 - noise(uv) * 0.12;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[847, 922, 971, 971, 1279], [1281, 1317, 1340, 1340, 1416], [1418, 1454, 1479, 1479, 1830], [1832, 1832, 1893, 1893, 2132], [2134, 2134, 2183, 2183, 2625], [2627, 2627, 2658, 2658, 2927], [2929, 2995, 3031, 3031, 3077], [3082, 3082, 3137, 3137, 3698]], "test": "error"}
{"id": "WdsyzH", "name": "Raymarching a grid", "author": "Axioplase", "description": "Playing with space and raymarching.\nI was not able to make an infinite grid. Whenever I tried p = mod(p, 3.) in GetDist, hoping to repeat infinitely my grid, I'd end up with artifacts in all but 1 quadrant... So i decided to animate a finite one.\n", "tags": ["raymarching", "grid", "finite"], "likes": 4, "viewed": 90, "published": "Public", "date": "1584217769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Base code:\n///// \"RayMarching starting point\" \n//// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n//// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define M(x, y) (x-y*floor(x/y)) \n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdLine(vec3 p, vec3 o, vec3 dir, float t) {\n    vec3 a = o;\n    vec3 b = a+dir;\n    vec3 bMinusA = b-a;\n    float h = min(t, max(-t, dot((p-a), bMinusA)/dot(bMinusA,bMinusA)));\n    //float h = dot(p-a, bMinusA)/dot(bMinusA,bMinusA);\n    float dist = length(p - a +-(b-a) * h )- 0.05;\n    return dist;\n}\n\nmat3 rx(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1,0,0,0,c,-s,0,s,c);\n}\nmat3 ry(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c,0,s,0,1,0,-s,0,c);\n}\nmat3 rz(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pp = abs(p);\n    float dist = MAX_DIST+1.;\n    float x =0.5, y=0.5, z = 0.5;\n    float t1 = .5+0.5*sin(iTime);\n    float t2 = .5+0.5*cos(iTime*2.);\n    float t3 = .5+0.5*sin(3.*iTime+3.141592);\n    dist = min(dist, sdLine(pp, vec3(x,y,z), vec3(1,0,0), t1));\n    dist = min(dist, sdLine(pp, vec3(x,y,z), vec3(0,1,0), t2));\n    dist = min(dist, sdLine(pp, vec3(x,y,z), vec3(0,0,1), t3));\n \n    p *= rx(1.+0.25*cos(iTime))*ry(1.+0.25*cos(iTime))*rz(1.+0.25*sin(iTime));\n    dist = min(dist, sdLine(p, vec3(0), vec3(0,0,1), 10.));\n    dist = min(dist, sdLine(p, vec3(0), vec3(0,1,0), 10.));\n    dist = min(dist, sdLine(p, vec3(0), vec3(1,0,0), 10.));\n    return dist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(1);\n    \n    vec3 ro = 3.*vec3(cos(iTime/2.), sin(iTime/3.), -sin(cos(iTime)));\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    col *= 0.5+0.5*rd.y;\n\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += vec3(dif/(d*d));\n        col*=0.5+0.5*n.y;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[342, 342, 361, 361, 437], [439, 439, 468, 468, 549], [551, 551, 617, 617, 696], [698, 698, 747, 747, 1006], [1008, 1008, 1026, 1026, 1109], [1110, 1110, 1128, 1128, 1211], [1212, 1212, 1230, 1230, 1313], [1315, 1315, 1338, 1338, 2013], [2015, 2015, 2049, 2049, 2260], [2262, 2262, 2286, 2286, 2476], [2478, 2478, 2528, 2528, 2723], [2727, 2727, 2784, 2784, 3459]], "test": "timeout"}
{"id": "WdsyzX", "name": "sine gradient", "author": "justyn", "description": "simple sine wave drawn with a gradient\n\nthe code isnt exactly very clear in this, ill probably clean it up sometime", "tags": ["gradient", "sine"], "likes": 0, "viewed": 47, "published": "Public", "date": "1585250994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0), clamp(abs(uv.y - 0.5 + sin((uv.x + (iTime * 0.25)) * 10.0) * 0.1) * 1.5, -1.0, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 269]], "test": "ok"}
{"id": "WdXcDn", "name": "param_22", "author": "darkczar", "description": "epicycles", "tags": ["learning"], "likes": 2, "viewed": 60, "published": "Public", "date": "1584499728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<200;i++)\n    {\n        di = float(i)*.3;\n        curve_p.x = -.1*sin(.3*iTime)+.05*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = -.1*cos(.3*iTime)+.05*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = min(d, length(p-curve_p));\n  \n    }\n    float r =.75*d + (.0025 - .0015*pow(dot(p, curve_p),4.0));\n    float g = .008 + .5*sin(.001*d*d+.1*length(p))+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=.025*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,8.0))) +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    if (d < .2)\n    {\n        b = .0 +.04*(.5+ .5*sin(iTime*.1 + 1.28*dot(p,curve_p)));\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1393]], "test": "timeout"}
{"id": "wdXcR7", "name": "Exploring Mandelbrot", "author": "solquemal", "description": "Experimental use of distance estimator to render fractals", "tags": ["fractal"], "likes": 4, "viewed": 248, "published": "Public", "date": "1584385626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 bump3 (vec3 x) {\n    vec3 y = vec3(1.,1.,1.) - x * x;\n    y = max(y, vec3(0.,0.,0.));\n    return y;\n}\n\nvec3 spectralGems (float x) {\n    return bump3\n    (   vec3\n        (\n            4. * (x - 0.7), // Red\n            4. * (x - 0.5), // Green\n            4. * (x - 0.23) // Blue\n        )\n    );\n}\n\n\nvec2 distanceEstimatorPot3(vec2 c) {\n\tvec2 z = vec2(0.);\n    vec2 dz = vec2(0.); \n\n    float m2 = 0.;\n    float dis = 1000.;\n    \n   \n    for( int i=0; i<300; i++ )\n    {\n        if( m2 > 1024.0) {  break;}\n        float dzX= 3.*(z.x*z.x-z.y*z.y)*dz.x-(6.*z.x*z.y)*dz.y;\n        float dzY = (6.*z.x*z.y)*dz.x + 3.*(z.x*z.x-z.y*z.y)*dz.y;\n\n        dz = vec2(dzX,dzY)+ vec2(1.);\n\n        z = vec2( pow(z.x,3.) - 3.*z.y*z.y*z.x,3.0*z.x*z.x*z.y-pow(z.y,3.) ) + c;\n \n        m2 = dot(z,z);  \n    }\n    return vec2(sqrt( m2/dot(dz,dz) )*log(m2),m2);\n\n    \n}\n\nvec2 distanceEstimatorJulia(vec2 c) {\n    vec2 z = vec2(1.);\n    vec2 dz = vec2(0.); \n\n    float m2 = 0.;\n    float dis = 1000.;\n    \n   \n    for( int i=0; i<300; i++ )\n    {\n        if( m2 > 1024.0) {  break;}\n\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x);\n\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n \n\n        m2 = dot(z,z);  \n    }\n    return vec2(sqrt( m2/dot(dz,dz) )*0.5*log(m2),m2);\n}\n\nvec2 distanceEstimatorMandelbrot(vec2 c) {\n    vec2 z = vec2(0.);\n    vec2 dz = vec2(0.); \n\n    float m2 = 0.;\n    float dis = 1000.;\n    \n   \n    for( int i=0; i<300; i++ )\n    {\n        if( m2 > 1000.0) {  break; }\n\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.);\n\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n \n\n        m2 = dot(z,z);  \n    }\n    return vec2(sqrt( m2/dot(dz,dz) )*log(m2),m2);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = st*2.7-vec2(2.5,1.3);\n  \t//st.x +=cos(iTime*0.1)*0.5;\n\t//st.y +=sin(iTime*0.1)*0.5;\n    \n    // ZOOM in\n\tst *= pow( 0.7, 5.0 + 13.*(1.+cos(0.0425*iTime)));\n    //st = st*pow(0.4,12. *abs(sin(iTime*0.0270)))+vec2(-0.18,.8289);\n    st += vec2(-0.4256621,0.576550);\n    \n    vec2 f =  distanceEstimatorMandelbrot(st);      //f(z) = z ^ 2 + k\n    vec2 f2 =  distanceEstimatorPot3(st);      //f(z) = z ^ 3 + k\n  \n    vec3 col;\n    float d1 =f.x;\n    float d2 =f2.x;\n    \n    d1 = clamp( pow(4.0*d1,0.0998),0., 1.);\n    d2 = clamp( pow(4.0*d2,0.128),0.,1.);\n   /// col = spectralGems(max(0.2,abs(sin(Time*0.051)))-d/2.);\n  \n    col = spectralGems((1.-d1)*1.15);\n    col += spectralGems(d2*1.96);\n  \n    //Trying to colorize equipotential lines. Change the escaping radius limit, and transformation over f.y// Observe.\n  \t//col = spectralGems((f.y - 1000.)/9500.);\n    \n    // Nice first color-map\n    //col += f.y/1000.;\n  \n    //Combinig both versions\n     //col += vec3(1.-d);\n    \n   \t//col=vec3(f.y);\n  \n    fragColor = vec4(col,1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXcR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 106], [108, 108, 137, 137, 304], [307, 307, 343, 343, 858], [860, 860, 897, 897, 1282], [1284, 1284, 1326, 1326, 1719], [1723, 1723, 1778, 1778, 2906]], "test": "ok"}
{"id": "WdXcRs", "name": "Closest Point in Tetrahedron", "author": "mla", "description": "Just a test for closest point to tetrahedron function I wanted for something else.", "tags": ["glitch", "tetrahedron", "closest"], "likes": 1, "viewed": 215, "published": "Public API", "date": "1585316430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Just a test for a \"closest point in tetrahedron\" function\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159;\n\nbool dorotate = true;\nvec3 lightdir = vec3(0,2,1);\nvec3 closest(vec3 p, vec3 A, vec3 B, vec3 C);\n\nvec3 closest(vec3 p, vec3 A, vec3 B, vec3 C, vec3 D) {\n  // Find closest point to in tetrahedron ABCD, return p\n  // if inside tetrahedron.\n  vec3 nA = normalize(cross(B-C,C-D));\n  vec3 nB = -normalize(cross(C-D,D-A));\n  vec3 nC = normalize(cross(D-A,A-B));\n  vec3 nD = -normalize(cross(A-B,B-C));\n  float dA = dot(p,nA)-dot(B,nA);\n  float dB = dot(p,nB)-dot(C,nB);\n  float dC = dot(p,nC)-dot(D,nC);\n  float dD = dot(p,nD)-dot(A,nD);\n  if (dA <= 0.0 && dB <= 0.0 && dC <= 0.0 && dD <= 0.0) return p;\n  if (dA > 0.0) return closest(p,B,C,D);\n  if (dB > 0.0) return closest(p,C,D,A);\n  if (dC > 0.0) return closest(p,D,A,B);\n  if (dD > 0.0) return closest(p,A,B,C);\n  return vec3(0);\n}\n\nfloat eval(vec3 p, out ivec3 id) {\n  p = abs(p);\n  vec3 A = vec3(0), B = vec3(1,0,0), C = vec3(0,1,0), D = vec3(0,0,1);\n  vec3 q = closest(p,A,B,C,D);\n  float N = 5.0;\n  float pwidth = 0.05;\n  q = round(N*q);\n  id = ivec3(q);\n  q /= N;\n  float d = distance(p,q)-pwidth;\n  // Next line eliminates some weird ghost spheres that appear -\n  // don't fully understand what is going on there.\n  d = max(d,(dot(p,vec3(1)) - 1.0)/sqrt(3.0)-pwidth);\n  return d;\n}\n\n// Closest point in a triangle to a point.\n// Function by iq: https://www.shadertoy.com/view/ttfGWl\nfloat dot2( in vec3 v ) { return dot(v,v); }\nvec3 closestTriangle( in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n#if 0\n    // method 1, in 3D space\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v02,nor),p2)<0.0 ) return v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    return p - nor*dot(nor,p0)/dot2(nor);\n    \n#else    \n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0/dot2(nor);\n    float u = d*dot( q, v02 );\n    float v = d*dot( q, v10 );\n    float w = 1.0-u-v;\n    \n         if( u<0.0 ) { w = clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 ); u = 0.0; v = 1.0-w; }\n    else if( v<0.0 ) { u = clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 ); v = 0.0; w = 1.0-u; }\n\telse if( w<0.0 ) { v = clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 ); w = 0.0; u = 1.0-v; }\n    \n    return u*v1 + v*v2 + w*v0;\n#endif    \n}\n\nvec3 closest(vec3 p, vec3 A, vec3 B, vec3 C) {\n  return closestTriangle(A,B,C,p);\n}\n\nfloat eval(vec3 p) {\n  ivec3 id;\n  return eval(p,id);\n}\n\nvec3 getnormal(vec3 p) {\n  vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat getdistance(vec3 q, vec3 r) {\n  float t = 0.0;\n  int numsteps = 100;\n  float maxdist = 2.0*length(q);\n  float precis = 1e-3;\n  for (int i = 0; i < numsteps; i++) {\n    vec3 p = q+t*r;\n    float d = eval(p);\n    if (abs(d) < precis) return t;\n    t += 0.8*d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getcolor(vec3 q, vec3 r) {\n  float t = getdistance(q,r);\n  if (t < 0.0) return vec3(0);\n  vec3 p = q+t*r;\n  ivec3 id;\n  eval(p,id);\n  uint h = ihash(uint((id.x << 20) ^ (id.y << 10) ^ (id.z << 0)));\n  float rnd = float(h)/pow(2.0,32.0);\n  vec3 normal = getnormal(p);\n  vec3 color = hsv2rgb(vec3(rnd,0.5,1));\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+diffuse;\n  return pow(color,vec3(0.4545));\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 rotateframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,-0.5+iTime * 0.125);\n    p.zx = rotate(p.zx,-0.5+iTime * 0.1);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 eye = vec3(0,0,2);\n  vec3 ray = vec3(z,-2);\n  eye = rotateframe(eye);\n  ray = rotateframe(ray);\n  ray = normalize(ray);\n  lightdir = rotateframe(lightdir);\n  lightdir = normalize(lightdir);\n  vec3 col = getcolor(eye,ray);\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 397, 482, 1026], [1028, 1028, 1062, 1062, 1482], [1484, 1584, 1609, 1609, 1628], [1629, 1629, 1700, 1700, 2746], [2748, 2748, 2794, 2794, 2831], [2833, 2833, 2853, 2853, 2888], [2890, 2890, 2914, 2914, 3124], [3126, 3126, 3161, 3161, 3438], [3440, 3504, 3524, 3524, 3638], [3640, 3640, 3667, 3667, 3843], [3845, 3845, 3876, 3876, 4303], [4305, 4305, 4341, 4341, 4393], [4395, 4395, 4421, 4421, 4760], [4762, 4762, 4813, 4813, 5128]], "test": "error"}
{"id": "wdXcW7", "name": "tunel--plasma-v1", "author": "jorge2017a1", "description": "the original code is from Gaz:\nhttps://www.shadertoy.com/view/MscGzf\n", "tags": ["tunelplasmav1"], "likes": 1, "viewed": 62, "published": "Public", "date": "1584893564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n//Referecia\n///the original code is from Gaz:\n///https://www.shadertoy.com/view/MscGzf\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\n//-----------------------------\n\nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\n/*\nfloat func(in float x)\n{\n    float t = +iTime *1.5;\n    return 0.15*sin(x*5.0+t)+0.2*sin(x*3.0+t);\n}*/\n\nfloat funcv2(in float x,float t )\n{\n    //float t = +iTime ;\n    return 0.15*sin(x*5.0+t)+0.2*sin(x*3.0+t);\n}\n\n\nfloat pyfun(float x, float y)\n{   \n    float t; \n    t = iTime;\n    float px, py;\n    px =x;\n    py =y;\n    \n    // py -= 0.5;\n    \n    \n    // de\n    py -= funcv2(px,t);\n    \n    \n\t//float e = 0.02;\n    float e = 0.01;\n    //float g = (func(p.x+e)-func(p.x-e))/(2.0*e);\n    float g = (funcv2(px+e,t)-funcv2(px-e, t))/(2.0*e);\n    \n    //py *= cos(atan(g));\n    py *= cos(atan(g));\n    \n    return py;\n}  \n    \n\n//referencia de Gaz\n//https://www.shadertoy.com/view/MscGzf\nfloat deCurve(in vec3 pp)\n{\n   vec3 p;\n    p =pp;\n        \n   \tp.zx=p.xz; \n    // transform\n   \n    p.y =pyfun(p.x, p.y);\n    \n    float de = 0.6*(abs(lengthN(p.yz,5.0)-0.2)-0.001);\n    \n   \n    p.x = mod(p.x,2.0);\n    return max(abs(p.x)-2.0 , de);\n}\n\n\n\n//------------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    float sdpt1= deCurve(p);\n    \n    res=opU(res, vec2(sdpt1,20 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    dist=d.x;\n    \n    vec3 n;\n    n = dist -vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\nvec3 course(float a)\n{\n\treturn vec3(\n\t\tcos(a),\n\t\tsin(2.0*a),\n\t\t0.15*sin(a)\n\t);\n}\n\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    float pz = -0.5+iTime*0.25;\n    float py =pyfun(pz, 0.0);\n    \n    ///correccion por aiekick--27/mar/2020\n    //vec3 ro = vec3(0.0 ,-py ,pz);\n    vec3 ro = vec3(0.0 ,-py*0.9 ,pz);\n    \n    ///vec3 ro = vec3(0.0 ,py*cos(-iTime*0.5)*0.5 ,pz);\n    vec3 rd =normalize(vec3(uv,1.0) );\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n   \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXcW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[620, 637, 670, 670, 735], [736, 754, 790, 790, 859], [860, 875, 906, 906, 1056], [1057, 1077, 1113, 1113, 1200], [1201, 1217, 1249, 1277, 1338], [1340, 1340, 1376, 1376, 1479], [1482, 1482, 1527, 1527, 1618], [1672, 1672, 1718, 1718, 1750], [1752, 1752, 1795, 1795, 1827], [1829, 1829, 1877, 1877, 1910], [1913, 1913, 1942, 1942, 2068], [2070, 2070, 2106, 2106, 2223], [2225, 2225, 2261, 2261, 2379], [2382, 2382, 2418, 2418, 2541], [2594, 2606, 2628, 2628, 2936], [2937, 2963, 2988, 2988, 3178], [3179, 3224, 3241, 3241, 3314], [3317, 3350, 3376, 3376, 3573], [3620, 3620, 3672, 3672, 3827], [3892, 4001, 4038, 4038, 4073], [4075, 4075, 4094, 4094, 4169], [4218, 4218, 4241, 4241, 4267], [4269, 4269, 4292, 4292, 4430], [4433, 4433, 4455, 4455, 4525], [4590, 4590, 4616, 4616, 4673], [4675, 4675, 4695, 4695, 4753], [4756, 4756, 4777, 4777, 5027], [5063, 5063, 5101, 5101, 5159], [5268, 5268, 5303, 5328, 5377], [5380, 5380, 5411, 5411, 5783], [5792, 5852, 5879, 5879, 6103], [6107, 6152, 6177, 6177, 6513], [6518, 6518, 6551, 6551, 7026], [7030, 7030, 7054, 7054, 7335], [7340, 7340, 7378, 7378, 7736], [7835, 7879, 7896, 7896, 7967], [7992, 8084, 8109, 8109, 8372], [8491, 8491, 8513, 8513, 8571], [8635, 8635, 8663, 8663, 16342], [16345, 16345, 16402, 16402, 17628]], "test": "error"}
{"id": "WdXcWN", "name": "RainbowOrb", "author": "NY", "description": "a", "tags": ["a"], "likes": 4, "viewed": 79, "published": "Public", "date": "1584761937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 hsb2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0. , 4., 2.), 6.) - 3.) - 1., 0., 1. );\n    rgb = rgb * rgb * (3. - 2. * rgb);\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv  = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float angle = atan(uv.y, uv.x);\n    float radius =  length(uv);\n    // ラジアン*20.でしてからsinをすることで揺れを作る\n  \tfloat u = sin(angle * 20.) * 0.01;\n    \n    uv = uv * rotate(iTime);\n    angle = atan(uv.y, uv.x);\n\n    \n    // 揺れをなびかせる部分\n    // sinで0〜1にしてuにかけることでu〜-uの範囲を行き来する    \n    u *= abs(sin(iTime * 10.));\n    \n    // 明るさの設定部分　回転させて角度で一部のみ明るさをますように\n\tfloat t = (0.01*  (step(2.,angle) * 1.3 + 1.0))\n        // 描画する範囲\n        / abs(0.5 + u - radius);\n    \n    // 極座標系作成\n    vec3 hsb = vec3(angle,  radius, 1.);   \n    // hsbからrgbに変換\n    vec3 color = hsb2rgb(hsb);\n    color *= t;\n    // Output to screen\n    fragColor = vec4(color,1.); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 88], [90, 90, 112, 112, 280], [282, 282, 339, 389, 1288]], "test": "ok"}
{"id": "WdXcz8", "name": "About line", "author": "lzjseed", "description": "just a test", "tags": ["2d", "line", "curve", "mirror"], "likes": 3, "viewed": 55, "published": "Public", "date": "1584090101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(vec2 p,vec2 a,vec2 b)\n{\n    vec2  ba = b - a;\n    vec2  pa = p - a;\n   \n    vec2  c = a + ba * clamp(dot(ba,pa) / dot(ba,ba),0.0,1.0);\n    float d = length(p-c);\n    \n    return smoothstep(0.0,0.01,d);\n}\n\n#define PI (3.1415926)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 uv1 = uv * 2.0 - 1.0;\n    \n    uv1 *= 4.0;\n    \n    mat2 rot = mat2(cos(PI * 0.25),-sin(PI * 0.25),\n                    sin(PI * 0.25), cos(PI * 0.25));\n    \n    mat2 rot2 = mat2(cos(iTime),-sin(iTime),\n                    sin(iTime), cos(iTime));\n    \n    uv1 = rot * abs(rot2*uv1);\n    \n    uv1 = abs(uv1);\n    \n    uv1 = pow(uv1,vec2(mix(0.6,1.0,sin(iTime)*0.5+0.5)));\n    \n    //uv1 = pow(uv1,vec2(1));\n    \n    float m = abs(fract(iTime / 20.0) * 2.0 - 1.0);\n    \n    int k = int(m * 30.0);\n    \n    for(int i = 0;i < min(k,13);i ++)\n    {\n        if(uv1.x > 0.2)\n        {\n            uv1 -= 0.2;\n            uv1.y = abs(uv1.y);\n        }   \n    }\n    \n    float t = line(uv1,vec2(0.0,0.0),vec2(0.2,0.2));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(mix(vec3(0),col*6.0,1.0-t),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXcz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 214], [240, 240, 297, 347, 1284]], "test": "ok"}
{"id": "WdXyD2", "name": "Universal with white", "author": "gjy_1992", "description": "universal transition effect with a white gap", "tags": ["2d", "transition"], "likes": 2, "viewed": 204, "published": "Public API", "date": "1585559684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 rule(vec2 coord)\n{\n    vec2 uv2 = coord-vec2(0.5,0.5);\n    float angle = atan(uv2.y, uv2.x);\n    float c = angle/2.0/3.1416+0.5;\n    return vec4(c,c,c,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 src = texture(iChannel0, uv);\n    vec4 dst = texture(iChannel1, uv);\n    vec4 white = vec4(1.0);\n    float rule = rule(uv).g;\n    float progress = mod(iTime,10.0)/10.0;\n    //control the mix range\n    float vague=0.1;\n    //control how much percent the white part occupies\n    float delay=1.0;\n    float phase=progress*(1.0+vague+delay);\n\tfloat p0=smoothstep(rule, rule+vague, phase);\n    //float p1=smoothstep(rule+delay, rule+vague+delay, phase);\n    float p1=smoothstep(rule+delay, rule+vague+delay, phase);\n    //if(p0<1.0)\n\t//    fragColor=mix(src, white, p0);\n    //else\n    //    fragColor=mix(white, dst, p1);\n    fragColor=src*(1.0-p0)+white*(p0-p1)+dst*p1;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 161], [163, 163, 220, 270, 985]], "test": "error"}
{"id": "WdXyD4", "name": "param_v27", "author": "darkczar", "description": "epicycles", "tags": ["psychedelic", "learning", "trippy", "epicycles"], "likes": 1, "viewed": 37, "published": "Public", "date": "1584758239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    float d2 = 10002.0;\n    float d3 = 10003.0;\n    float di = 0.;\n    float threshold = 0.000000005;//0000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    float black_threshold=0.;//5;// -.5*nsin(iTime*.6);\n\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*4.3;\n        curve_p.x = -.1*sin(.6*iTime)+.02*float(di)*sin(float(di)+.4*iTime) +.03*float(di)*sin(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.8*iTime);\n        curve_p.y = -.1*cos(.6*iTime)+.02*float(di)*cos(float(di)+.4*iTime) +.03*float(di)*cos(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.8*iTime);\n        dtemp = pow(length(2.3*float(i)*p-curve_p),2.);\n\n\n        d= dot(normalize(p),normalize(curve_p))+3.*nsin(iTime+d*d);\n        if(d<black_threshold) d=0.;   \n        r = 14.*rand(vec2(float(i),float(i))); // +nsin(iTime*.8);\n        g = g+.1*d*dtemp;\n        b = .02*dtemp*dtemp-d; // - .25*mod(.02*dtemp*dtemp-d,3.0); //+.001*rand(vec2(34.3,floor(dtemp*32.))); //b + .05*dtemp-.05*d;  \n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [358, 358, 415, 465, 1892]], "test": "ok"}
{"id": "wdXyDM", "name": "milky", "author": "aodnawg", "description": "milky water reflection.", "tags": ["raymarching"], "likes": 1, "viewed": 41, "published": "Public", "date": "1584885803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define MIN_SURF 0.001\n#define MAX_DIST 100.\n#define MAX_LOOP 1000\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat random(float n) {\n  return fract(sin(n*78.39817)*12.09834);\n}\n\nmat2 rot(float a) {\n  return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec3 sky(vec3 rd) {\n  float n = max(0., rd.y);\n  n += .5;\n  return mix(vec3(.53, .65, .89), vec3(.89, .85, .93), n);\n}\n\nvec3 makeRay(in vec3 ro, in vec2 uv) {\n  float z = .4;\n  vec3 lookat = vec3(0,1,0)+vec3(0,0,-iTime*5.);\n  vec3 f = normalize(lookat-ro);\n  vec3 r = cross(vec3(0,1,0), f);\n  vec3 u = cross(f, r);\n  vec3 c = ro+f*z;\n  vec3 i = c+r*uv.x+u*uv.y;\n  vec3 rd = normalize(i-ro);\n  return rd;\n}\n\nfloat spc(vec3 ray, vec3 normal, vec3 lightDir) {\n\tvec3 r = reflect(-lightDir, normal);\n\treturn pow(max(dot(r, -ray), 0.0), 10.0);\n}\n\nfloat sdGyroid(in vec3 p) {\n  p.y += iTime;\n\tfloat g = dot(sin(p*2.115), cos(p.zyx*1.12))/30.;\n\treturn g/5.;\n}\n\nfloat sdSphere(in vec3 p) {\n  float z = 10.;\n  p.z -= z*.5;\n  float idp = p.z;\n  float id = floor(idp/z);\n  p.z = mod(p.z, z)-z*.5;\n  float hash = random(id);\n\n  p.y += sin(iTime*.5)*.1-3.+sin(hash*10.+iTime);\n  p.xz *= rot(p.y*.7+iTime);\n\tfloat g = sdGyroid(p);\n  float r = mix(1., 3., hash);\n  return max(g, length(abs(p)+.1)-r)/1.2;\n}\n\nvec3 getSphereNormal(in vec3 p) {\n\tfloat d = sdSphere(p);\n  vec2 e = vec2(.001, 0);\n  vec3 n = d - vec3(sdSphere(p-e.xyy), sdSphere(p-e.yxy), sdSphere(p-e.yyx));\n  return normalize(n);\n}\n\nfloat traceSphere(in vec3 ro, in vec3 rd, out bool isHit, out float occ) {\n  float t = 0.;\n  occ = 0.;\n  isHit = false;\n  for(int i = 0; i< MAX_LOOP; i++) {\n    vec3 p = ro+rd*t;\n    float d = sdSphere(p);\n    if(d < MIN_SURF) {\n      isHit = true;\n      break;\n    }\n    if(d > MAX_DIST) break;\n    t += d;\n    occ += 1.;\n  }\n  occ /= 100.;\n  occ = min(1., pow(occ, 2.+sin(iTime)));\n  return t;\n}\n\nvec3 makeSphereColor(in vec3 ray, in vec3 n) {\n  vec3 albd = vec3(1.);\n  vec3 lg = vec3(cos(iTime),1,sin(iTime));\n  float sp = spc(ray, n, lg);\n  vec3 dif = vec3(.43,.48,.78)*(1.-n.y);\n  dif += vec3(.98,.8,.38)*(1.-n.z);\n  \n  return albd - dif*.1 + sky(ray)*sp*.01;\n}\n\nfloat sdSea(in vec3 p) {\n  p.z += iTime;\n  p.y += noise(p)*.1;\n  return p.y+1.;\n}\n\nvec3 makeSeaColor(in vec3 n, in vec3 eye) {\n  vec3 dif = vec3(.6,.98,.78)*(1.-n.y);\n  return vec3(.92,.95,1.)-dif*2.;\n}\n\nvec3 getSeaNormal(in vec3 p) {\n\tfloat d = sdSea(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        sdSea(p-e.xyy),\n        sdSea(p-e.yxy),\n        sdSea(p-e.yyx));\n    return normalize(n);\n}\n\nfloat traceSea(in vec3 ro, in vec3 rd, out bool isHit) {\n  float t = 0.;\n  isHit = false;\n  for(int i = 0; i<MAX_LOOP; i++) {\n    vec3 p = ro+rd*t;\n    float d = sdSea(p);\n    if(d<MIN_SURF) {\n      isHit = true;\n      break;\n    }\n    if(d>MAX_DIST) break;\n    t += d;\n  }\n  return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float cs = iTime * .1;\n  vec3 ro = vec3(2., .6, 0.)*(5.+sin(cs*3.)*3.)+vec3(0,1,0)+vec3(0,0,-iTime*5.);\n  vec3 rd = makeRay(ro, uv);\n \n  // initialize\n  bool isHit; vec3 p, n, col; float t, occ;\n  \n  // render sky\n  col = sky(rd);\n  \n  // tracing sea\n  vec3 seP;\n  t = traceSea(ro, rd, isHit);\n\n  if(isHit) {\n    // render sea\n    seP = ro+rd*t;\n    vec3 seN = getSeaNormal(seP);\n    // fog\n    vec3 eye = normalize(seP - ro);\n    col = mix(makeSeaColor(seN, eye), sky(rd), smoothstep(0., 1., t/20.));\n    vec3 scl = col;\n    vec3 ld = vec3(0,1,0);\n    p = ro+rd*t+ld*MIN_SURF;\n    bool isHit_;\n    eye = normalize(p-ro);\n    n = getSeaNormal(p);\n\n    // reflection of sphere\n    vec3 r = reflect(eye, n);\n    float t = traceSphere(p, r, isHit_, occ);\n    if(isHit_) { \n      p = p+r*t;\n      n = getSphereNormal(p);\n      vec3 c = makeSphereColor(normalize(p-ro), n)*.96;\n      col = mix(col, sky(rd), smoothstep(0., 1., t/70.));\n\n\n    } else {\n      col += occ;\n    }\n  }\n\n  // render sphere\n  t = traceSphere(ro, rd, isHit, occ);\n  if(isHit) {\n    p = ro+rd*t;\n    n = getSphereNormal(p);\n    col = makeSphereColor(normalize(p-ro), n);\n  } else {\n    col += vec3(occ, occ/2., occ/2.);\n  }\n\n  float pw = 1.8;\n  col = vec3(\n    pow(col.r, pw),\n    pow(col.g, pw),\n    pow(col.b, pw)\n  );\n\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 114, 114, 159], [160, 160, 180, 180, 225], [226, 226, 244, 244, 283], [284, 284, 304, 304, 790], [792, 792, 815, 815, 859], [861, 861, 880, 880, 930], [932, 932, 951, 951, 1050], [1052, 1052, 1090, 1090, 1337], [1339, 1339, 1388, 1388, 1471], [1473, 1473, 1500, 1500, 1583], [1585, 1585, 1612, 1612, 1922], [1924, 1924, 1957, 1957, 2110], [2112, 2112, 2186, 2186, 2509], [2511, 2511, 2557, 2557, 2778], [2780, 2780, 2804, 2804, 2861], [2863, 2863, 2906, 2906, 2982], [2984, 2984, 3014, 3014, 3186], [3188, 3188, 3244, 3244, 3475], [3477, 3477, 3532, 3532, 4915]], "test": "timeout"}
{"id": "WdXyDN", "name": "Mandelbrot2D", "author": "NY", "description": "a", "tags": ["a"], "likes": 0, "viewed": 41, "published": "Public", "date": "1584767709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HSV カラー生成関数\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n      vec2 p  = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    \n    // マンデルブロ集合\n    int j = 0;                     // カウンタ\n    vec2  x = p + vec2(-0.5, 0.0); // 原点を少しずらす\n    float y = 1.;\n    vec2  z = vec2(0.0, 0.0);      // 漸化式 Z の初期値\n    \n    // 漸化式の繰り返し処理(今回は 360 回ループ)\n    for(int i = 0; i < 360; i++){\n        j++;\n        if(length(z) > 2. * abs(sin(iTime))){break;}\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + x * y;\n    }\n    \n    // 時間の経過で色を HSV 出力する\n    float h = mod(iTime * 20.0, 360.0) / 360.0;\n    vec3 rgb = hsv(h, 1.0, 1.0);\n    \n    // 漸化式で繰り返した回数をもとに輝度を決める\n    float t = float(j) / 360.0;\n    \n    // 最終的な色の出力\n    fragColor = vec4(rgb * t, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 65, 65, 244], [246, 246, 303, 353, 1214]], "test": "timeout"}
{"id": "WdXyDr", "name": "Playing with hexagonal tiling", "author": "MeHigh_", "description": "It's not much, but eh", "tags": ["hexagons"], "likes": 8, "viewed": 118, "published": "Public", "date": "1584520604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I learned to create the hexagonal grid from The Art of Code's video\n//https://www.youtube.com/watch?v=VmrIDyYiJBA\n\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1., 1.73)));\n    c = max(c, p .x);\n\t\n    return c;\n}\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1., 1.73);\n    vec2 h = r * .5;\n    \n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    \n    vec2 gv = dot(a, a) < dot(b, b) ? a : b;\n    \n    vec2 id = uv - gv;\n    \n    float x = atan(gv.x * 1.5, gv.y * .5);\n    float y = .5 -  HexDist(gv);\n    \n    return vec4(x, y, id.x, id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    uv *= 10.; //grid size\n    \n    vec4 hc = HexCoords(uv);\n    float spiralsRate = 2.; //the density of the spirals\n    col = mix(col, \n              vec3(.9 * uv.x, .4, .5 * uv.y), //some color based on the uv coords\n              smoothstep(.1, .5, sin(spiralsRate * hc.y * hc.w * hc.z + hc.x + iTime)));\n    \n    col = pow(col, vec3(1./2.2)); //gamma correction\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 140, 140, 247], [249, 249, 274, 274, 589], [591, 591, 648, 648, 1153]], "test": "ok"}
{"id": "WdXyRS", "name": "Rectangular pattern", "author": "bitless", "description": "Rectangular pattern", "tags": ["2d", "pattern"], "likes": 13, "viewed": 103, "published": "Public", "date": "1585047418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Rectangular pattern\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )\n#define W .02\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 r = iResolution.xy\n        ,u = (g+g-r)/r.y/2.\n        ,l = abs(fract(u*10.)-.5);\n\n    float t = sin(sin(u.x + sin(.5*u.y + iTime)) +\n              sin(length(u)*1.1+iTime) +\n              sin(u.x*.9+iTime))*.5+.5\n        ,m = smoothstep(W+12./r.y, W ,min(abs(l.x-(l.y*t)),abs(l.y-(l.x*t))));\n    f = vec4(p(t,.7,.5,.5,vec3(.1,.2,.3))*m,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 443, 443, 796]], "test": "ok"}
{"id": "WdXyW2", "name": "Lines Buzz", "author": "antoinefortin", "description": "allo", "tags": ["alloq"], "likes": 2, "viewed": 52, "published": "Public", "date": "1585552518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nfloat plane(vec3 pos)\n{\t\n    \n    vec3 q = pos;\n    \n\treturn q.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( in vec3 p)\n{\n  float inf = 12000.;\n  float da = sdBox(p.xyz,vec3(inf,1.,1.));\n  float db = sdBox(p.yzx,vec3(1.,inf,1.));\n  float dc = sdBox(p.zxy,vec3(0.75,1.,inf));\n  return min(da,min(db,dc));\n}\n\n\nfloat sphere(vec3  pos, float radius)\n{\t\n    pos.y -= 4.0;\n    return length(pos) - radius;\n}\n\nfloat map(vec3 pos)\n{\n    float planeDist = plane(pos);   \n\n\t//float d2 = sdBox(pos - 2., vec3(2.0));\n \tpos.x = abs(pos.x) * .85;\n    pos.y = abs(pos.y * .75);\n    pos.z = abs(pos.z);\n    \n    \n    \n   \tpos.xy = rotate(pos.xy,  iTime * .05);\n    pos.xz = rotate(pos.xz, iTime * .05);\n    pos.yz = rotate(pos.yz,  iTime * 0.05);\n    \n    \n    float d2 = sdCross(pos * sin(iTime + 12.\n                                ));\n    float d = sphere(pos,5.4);\n   \tfloat c = sdCross(pos*1.0)/1.0;\n\t   \t\n\n    \n    \n    //d = max( d, -c );\n\tfloat s = 1.;\n\tfor( int m=0; m<1; m++ )\n   \t{\n      vec3 a = mod( pos*s, 2.0 )-1.0;\n      s *=1.;\n      vec3 r = 1.05 - 1.05*abs(a );\n\n      float c = sdCross(r)/s;\n      d = max(d, -c);\n   \t}\n    \n    \n    \n    return d;\n    \n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 100.0) break;\n        \n    }\n    \n    if(t > 100.0) t = -1.0;\n    \n    return t;\n}\n\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nvec3 material(vec3 pos)\n{\n    return vec3(smoothstep(0.4, 0.41, fract(pos.x + sin(pos.z * 0.4 + iTime))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n   \t//uv.x = abs(uv.x * .5); \n    float angle = iTime;\n    \n    vec3 ro = vec3(0.75, 0.0, -7.5);\n    \n    // Rayon que l'on envoie dans l'espace pour chacuns des pixels\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));    \n    \n    \n\n     vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n               \n\tfloat t = castRay(ro, rd);\n\nuv.x = abs(uv.x);\n        if(t > 0.)\n        {\n\n            vec3 pos = ro + t * rd;\n            vec3 nor = computeNormal(pos);\n            vec3 sunPosition = vec3(5., 1., 1.);\n            vec3 sundir = normalize(sunPosition);\n            vec3 mate = vec3(.18);\n\n\n           \tfloat sundif =   clamp(dot(nor, sundir), -1.0, 1.0);\n            float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n            float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(3.0,1.0,0.0)), 0.0, 1.0);\n            float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\n            col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n            col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n            col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n            col = vec3(fract(t), sin(fract(t)), .5);\n        }\n\n    \n    \n    // Output to screen\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 126], [128, 128, 151, 151, 195], [197, 197, 228, 228, 315], [317, 317, 344, 344, 528], [531, 531, 570, 570, 624], [626, 626, 647, 647, 1382], [1384, 1384, 1417, 1417, 1722], [1726, 1726, 1756, 1756, 1970], [1972, 1972, 1997, 1997, 2080], [2083, 2083, 2140, 2140, 3494]], "test": "timeout"}
{"id": "wdXyW4", "name": "Mercator Spiral", "author": "mla", "description": "Here's a variation on [url]https://www.shadertoy.com/view/3dlyD8[/url] that adds a bit of twist to the sliding tiles pattern. Other angles should be possible, need to work out the details. Interesting that it looks like a Mobius tranformation.", "tags": ["spiral", "mercator"], "likes": 13, "viewed": 276, "published": "Public API", "date": "1584780936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Spherical texturing with Mercator projection.\n//\n// Adding a spiral.\n//\n// Matthew Arcus, 2020.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 tiling(vec2 p) {\n  p *= 8.0;\n  p = mod(p,2.0)-1.0;\n  if (p.x*p.y < 0.0) p = p.yx;\n  p = 1.0-2.0*abs(abs(p)-0.5);\n  float t = 0.5*iTime;\n  vec2 n = vec2(sin(t),cos(t));\n  vec2 m = vec2(-n.y,n.x);\n  float d = dot(p,n), e = dot(p,m);\n  float k = min(abs(d),abs(e));\n  if (d < 0.0) k = min(k,abs(p.x-1.0));\n  if (e < 0.0) k = min(k,abs(p.y-1.0));\n  return smoothstep(0.025,0.05,k)*vec3(0.5,0.5,0);\n}\n\nvec3 mirror(vec2 uv) {\n  uv.y -= 0.1*iTime;\n  uv = mod(uv,2.0);\n  uv = min(uv,2.0-uv);\n  return texture(iChannel1,uv).rgb;\n}\n\nvec3 slider(vec2 uv) {\n  uv *= 4.0;\n   float t = 0.25*PI;\n  uv = rotate(uv,t);\n    uv /= cos(t);\n vec2 iv = floor(uv);\n  if (true) {\n    // Slide around a little\n    float t = 0.3*iTime;\n    if (mod(t,2.0) < 1.0) {\n      uv.x += floor(mod(iv.y,2.0))*fract(t);\n    } else {\n      uv.y += floor(mod(iv.x,2.0))*fract(t);\n    }\n  }\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = texture(iChannel0,uv).rgb;\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint IHash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 indexed(vec2 uv) {\n  uv *= 8.0;\n  uv.y += iTime;\n  ivec2 iv = ivec2(floor(uv));\n  float rnd = float(IHash((uint(iv.x)<<16) ^ uint(iv.y)))/pow(2.0,32.0);\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 col = hsv2rgb(vec3(rnd,1,1));\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nconst int ncolors = 4;\nvec3 getColor(int i, vec2 uv) {\n  return slider(uv);\n  i = i%ncolors;\n  if (i == 0) return slider(uv);\n  if (i == 1) return tiling(uv);\n  if (i == 2) return indexed(uv);\n  if (i == 3) return mirror(uv);\n  return vec3(1,0,0);\n}\n\nvec3 getColor(vec3 p) {\n  float x = atan(p.x,p.z);       // Longitude\n  float y = asin(p.y/length(p)); // Latitude\n  y = log(tan(0.25*PI+0.5*y));   // Mercator\n  vec2 uv = vec2(x,y);\n  uv /= PI;\n  float period = 10.0;\n  float t = mod(iTime,float(ncolors)*period);\n  int i = int(t/period);\n  t = mod(t,period);\n  return mix(getColor(i,uv),getColor(i+1,uv),smoothstep(period-1.0,period,t));\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec3(0);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getColor(hit.n);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),10.0);\n    color += 0.5*specular*vec3(1);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return color;\n  }\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  light = transform(light);\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 p = vec3(0,0,-6);\n      vec3 r = vec3(uv,6);\n      p = transform(p);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      col += solve(Ray(p,r));\n    }\n  }\n  fragColor = vec4(pow(col/(AA*AA),vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 325, 325, 377], [379, 379, 400, 400, 779], [781, 781, 803, 803, 905], [907, 907, 929, 929, 1416], [1418, 1418, 1440, 1440, 1616], [1618, 1682, 1702, 1702, 1816], [1818, 1818, 1841, 1841, 2154], [2179, 2179, 2210, 2210, 2405], [2407, 2407, 2430, 2430, 2797], [3041, 3041, 3095, 3095, 3580], [3582, 3582, 3623, 3623, 3731], [3776, 3776, 3795, 3795, 4213], [4215, 4215, 4242, 4242, 4569], [4571, 4571, 4628, 4628, 5184]], "test": "error"}
{"id": "WdXyWj", "name": "Random World", "author": "adkaros", "description": "Messing with fract(sin) random ", "tags": ["random", "loop", "psycadelic"], "likes": 1, "viewed": 43, "published": "Public", "date": "1585535665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(uv.x * sin(iTime*0.5*uv.y) * 10.25 - 3.,\n                    uv.y * exp(iTime*0.5*uv.x) * 50.25 - 10.,\n                    uv.xy * exp(iTime* 0.5*uv.xy) * 20.25 - 8.);\n    \n    float s = fract(sin(uv.x * uv.y - 1.0)*10000000.);\n    \n    col = col * vec3(sin(s*iTime*0.3)* 10., sin(s*iTime*0.6)* 10., sin(s*iTime*1.)* 10.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 580]], "test": "ok"}
{"id": "wdXyz4", "name": "camino--otro-v2-joke", "author": "jorge2017a1", "description": "camino--otro-v2-joke", "tags": ["caminootrov2joke"], "likes": 0, "viewed": 24, "published": "Public", "date": "1584237793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,11); }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             res=vec2(res.x, 21);\n             \n         } \n     }\n    \n    p.z= mod( p.z,20.0);\n    \n    float sdb1= sdBox(  p- vec3(0.0), vec3(20.,10.,20.) );\n    float sdb2= sdBox(  p- vec3(0.0), vec3(25.,11. ,5.) );\n    float sdb3= sdBox(  p- vec3(0.0), vec3(8.,11.,25.) );\n    \n    \n    //piso que sustituye\n    float f = dot(p + vec3(0.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0)) + 0.0;\n\tf = min(f, sdBox(p + vec3(0.0, 0.32, 0.0), vec3(10.2, 0.3, 20.7)) - .025);\n    \n    res = opU(res, vec2(f,24));\n    \n    \n    \n    dif1= differenceSDF(sdb1,sdb2);\n    dif1= differenceSDF(dif1,sdb3);\n    float sdSp1 = sdSphere( pp-vec3(0.+0.5*sin(iTime),3.0+4.0*sin(iTime),5.+mObj.ro.z), 1.2 );\n    \n    \n    float sdSp2 = sdSphere( p-vec3(-30,10.,20.), 20.0 );\n    float sdSp3 = sdSphere( p-vec3(+30,10.,20.), 20.0 );\n    \n    res = opU(res, vec2(dif1,23));\n    res = opU(res, vec2(sdSp1,8));\n    \n    res = opU(res, vec2(sdSp2,16));\n    res = opU(res, vec2(sdSp3,18));\n    \n\n    res = opU(res, vec2(0.9,11));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n    \n    \n    \n    if(i== 22 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    \n    \n\tif(i== 23 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),mObj.color,marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \t\n    \tif(i== 24 )\n    \t{\n     \n\t    // checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 5.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n    \t}  \n    \t\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n  int i;\n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t//vec3 surfaceColor3 = vec3(0.45,0.54,1.0);  \n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    \n  for( i = 0; i < 3; i++)\n  {\n    //float nearest = RayMarch(p + dir*dist);\n    float nearest = RayMarch(ro, rd);  \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = ro+rd*dist;\n      \n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n    //ro=ro+rd*EPS;\n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    \n    vec3 ro = vec3(1.5,8.5,-60.0+iTime*5.0);\n   // ro = get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0) );\n    \n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\n    vec3 rLuz=vec3(0.5, 3.5, 10.5)+ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n\n    float dif = GetLightPar(p,rLuz);\n    \n    mObj.dist =d;\n    vec3 colobj;\n    mObj.color=vec3(0.5,0.8,0.6);\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    col= result*dif*1.1;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 474, 507, 507, 572], [573, 591, 627, 627, 696], [697, 712, 743, 743, 893], [894, 914, 950, 950, 1037], [1038, 1054, 1086, 1114, 1175], [1177, 1177, 1213, 1213, 1316], [1319, 1393, 1451, 1451, 1715], [1717, 1717, 1762, 1762, 1853], [1855, 1855, 1937, 1937, 2168], [2171, 2171, 2202, 2202, 2390], [2393, 2447, 2469, 2469, 3729], [3732, 3796, 3832, 3832, 4105], [4157, 4157, 4203, 4203, 4235], [4237, 4237, 4280, 4280, 4312], [4314, 4314, 4362, 4362, 4395], [4398, 4398, 4427, 4427, 4553], [4555, 4555, 4591, 4591, 4708], [4710, 4710, 4746, 4746, 4864], [4867, 4867, 4903, 4903, 5026], [5079, 5091, 5113, 5113, 5421], [5422, 5448, 5473, 5473, 5663], [5664, 5709, 5726, 5726, 5799], [5802, 5835, 5861, 5861, 6058], [6105, 6105, 6157, 6157, 6312], [6377, 6486, 6523, 6523, 6558], [6560, 6560, 6579, 6579, 6654], [6703, 6703, 6726, 6726, 6752], [6754, 6754, 6777, 6777, 6915], [6918, 6918, 6940, 6940, 7010], [7075, 7075, 7101, 7101, 7158], [7160, 7160, 7180, 7180, 7238], [7241, 7241, 7262, 7262, 7512], [7515, 7515, 7547, 7547, 7632], [7634, 7634, 7670, 7670, 7859], [7860, 7860, 7887, 7887, 8302], [8411, 8438, 8459, 8459, 8525], [8527, 8527, 8549, 8549, 8604], [8606, 8606, 8627, 8627, 8682], [8684, 8684, 8705, 8705, 8760], [8824, 8824, 8843, 8843, 8887], [8889, 8889, 8932, 8932, 10482], [10485, 10534, 10559, 10559, 12077], [12080, 12080, 12114, 12114, 12483], [12488, 12488, 12512, 12512, 12744], [12748, 12748, 12772, 12772, 13164], [13167, 13167, 13193, 13193, 13557], [13560, 13560, 13598, 13598, 13955], [13958, 13958, 13983, 13983, 14011], [14013, 14013, 14065, 14065, 14461], [14564, 14608, 14625, 14625, 14696], [14721, 14813, 14838, 14838, 15101], [15160, 15160, 15188, 15188, 23814], [23816, 23864, 23965, 23999, 24509], [24515, 24561, 24614, 24614, 25805], [25808, 25857, 25914, 25914, 26896]], "test": "error"}
{"id": "wdXyz8", "name": "param_v010", "author": "darkczar", "description": "epicycles", "tags": ["parametric"], "likes": 2, "viewed": 57, "published": "Public", "date": "1584156763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<100;i++)\n    {\n        di = float(i)*.06;\n        curve_p.x = .3*sin(.4*iTime)+.05*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*sin(11.0*di+.8*iTime);\n        curve_p.y = .3*cos(.4*iTime)+.05*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*cos(11.0*di+.8*iTime);\n        d = min(d, length(p-curve_p)+.4*rand(vec2(di,di)));\n  \n    }\n    \n    float r = .0025*d*d*sin(iTime + p.x*p.x*sin(.2*6.28*(p.y*p.y + p.x*p.x)));\n    float g = .0125*sin(.001*d*d+.1*length(p));\n    float b = .25*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,2.0)));\n    if (d>.05)\n    {\n        b=pow(b,2.25);\n    }\n    vec3 col = vec3(r,g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 342, 392, 1521]], "test": "timeout"}
{"id": "Wl3XzM", "name": "ASA Animation", "author": "simplemind", "description": "Animation for the ASA logo", "tags": ["2d", "animation", "unlit"], "likes": 3, "viewed": 90, "published": "Public", "date": "1584539412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mapRange01(float x, float min, float max) \n{\n    if (x>1.) return max;\n    else if (x<0.) return min;\n    else return min+(max-min)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*.5) /iResolution.y;\n    \n    uv *= 16.;\n    \n    if (mod(floor(uv.x),2.) == 0.)\n        uv.x = 1. - uv.x;\n\n    if (mod(floor(uv.y),2.) == 0.)\n        uv.y = 1. - uv.y;\n    \n    float b = abs( 1.- fract(uv.x)-fract(uv.y ));\n    \n//logo design\n    float paramMin = fract(iTime * .5 + (fragCoord.x + fragCoord.y)/2000.) * 2.;\n    float paramMax = paramMin;\n    if (paramMax > 1.)\n        paramMax = 2.-paramMax;\n        \n    float minBorder = mapRange01(paramMax, .90, .3);\n    float maxBorder = mapRange01(paramMin, .80, .1);\n   \n    if (b>minBorder) b=0.;\n    else if (b<maxBorder) b=0.;\n    else b=1.;\n        \n//grid\n    if (fract(uv.x)>.98 || fract(uv.x)<.02) b=0.;\n    if (fract(uv.y)>.98 || fract(uv.y)<.02) b=0.;\n        \n    vec3 col = vec3(b,b,b);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3XzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 142], [144, 144, 201, 251, 1106]], "test": "ok"}
{"id": "WlGSDt", "name": "Deserts and Plains", "author": "jarble", "description": "This biome map has many \"deserts\" and \"plains.\"", "tags": ["fractal", "desert", "biome"], "likes": 1, "viewed": 180, "published": "Public API", "date": "1583789684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float WHITE = 4.0;\nconst float FOREST_GREEN = 5.0;\nconst float LIGHTBLUE = 6.0;\nconst float SKYBLUE = 7.0;\nconst float SNOW = 8.0;\nconst float WHITESMOKE = 9.0;\nconst float LIGHTGRAY = 10.0;\nconst float LIME = 11.0;\nconst float LIGHTYELLOW = 12.0;\nconst float BEIGE = 13.0;\nconst float SAND = 14.0;\nconst float TAN = 15.0;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p,float colors[6],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\nfloat hash12(vec2 p,float colors[5],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\nfloat hash12(vec2 p,float colors[2],float mag)\n{\n    float num_colors = 6.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //if(mag > 2.0){\n    \tp3 += dot(p3, p3.yzx + 33.33);\n    //}\n    //else{\n    //\tp3 += dot(p3, p3.yzx + 33.33+iTime/(1000.0*mag));\n    //}\n    return colors[int(floor(fract((p3.x + p3.y) * p3.z)*num_colors))];\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag,float[6] colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[5] colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nfloat magnify(vec2 fragCoord,float mag,float[2] colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),colors,mag);\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[5] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[2] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag,float[6] colors){\n\treturn vec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord,mag,colors) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color,float[6] colors){\n\treturn magnify(fragCoord+vec2(0,1),mag,colors) == color\n        && magnify(fragCoord+vec2(1,0),mag,colors) == color\n        && magnify(fragCoord-vec2(0,1),mag,colors) == color\n        && magnify(fragCoord-vec2(1,0),mag,colors) == color;\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom,float colors[6]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float FOREST_GREEN = colors[4];\n    float WHITE = colors[5];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW){\n        color1 = GREEN;\n    }\n\n    else if(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n\n    else if(color1 == GREEN && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n   \n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n        color1 = FOREST_GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom,float[5] colors){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float YELLOW = colors[3];\n    float FOREST_GREEN = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(GRAY,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n    \tcolor1 = FOREST_GREEN;\n    }\n\n    else if(color1 == GRAY){\n        color1 = GREEN;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n\n\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float GREEN = colors[0];\n    float BLUE = colors[1];\n    float GRAY = colors[2];\n    float WHITE = colors[3];\n    float YELLOW = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    \n    vec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = GRAY;\n    }\n    else if(color1 == GREEN && is_next_to(WHITE,neighbors)){\n    \tcolor1 = GRAY;\n    } \n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\n\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[1];\n    float GEAY = colors[1];\n    float WHITE = colors[1];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom,float colors[2]){\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,float[](GREEN,BLUE));\n}\t\n\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom,float colors[5]){\n    fragCoord *= zoom;\n    float BLUE = colors[0];\n    float GREEN = colors[1];\n    float YELLOW = colors[2];\n    float GRAY = colors[3];\n    float WHITE = colors[4];\n\n    float color1 = magnify(fragCoord,mag,colors);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,colors);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == YELLOW && is_next_to(WHITE,neighbors)){\n        color1 = WHITE;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nfloat forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nfloat combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = forest_biome(fragCoord,mag,mag/81.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nfloat combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](BLUE,SKYBLUE,SNOW,GRAY,WHITE));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE));\n    }\n    return color1;\n}\n\nfloat deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    float color1 = glacier_biome(fragCoord,mag,mag/81.0,float[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n\n    if(color1 == GRAY){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,float[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME));\n    }\n    else if(color1 == GREEN){\n   \t\tcolor1 = forests_and_mountains(fragCoord,mag,zoom,float[](TAN,LIME,SNOW,GRAY,YELLOW));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,float[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE));\n    }\n    return color1;\n}\n\nfloat combined_biome(in vec2 fragCoord,float mag,float zoom){\n    float color1 = glacier_biome(fragCoord,mag,mag/729.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom);\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forests_and_mountains(fragCoord,mag,zoom);\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,float[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE));\n    }\n    return color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tfloat biome =\n        //forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        //combined_savanna_biome\n        deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 560, 608, 608, 955], [956, 956, 1004, 1004, 1351], [1353, 1353, 1401, 1401, 1748], [3353, 3353, 3397, 3397, 3533], [3535, 3535, 3569, 3569, 3598], [3600, 3600, 3628, 3628, 4703], [4705, 4705, 4780, 4780, 5809], [6989, 6989, 7065, 7065, 8143], [8292, 8292, 8366, 8366, 9257], [9400, 9400, 9474, 9474, 9864], [9991, 9991, 10075, 10075, 11148], [14475, 14475, 14532, 14532, 15000]], "test": "error"}
{"id": "wlGSRG", "name": "MusicWalker", "author": "antoinefortin", "description": "Little Walker", "tags": ["music"], "likes": 3, "viewed": 92, "published": "Public", "date": "1584154569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n\n{\n    float d2 =sin(-p.y) - cos(p.y) ;    \n    p.x = abs(p.x * 1.004);\n    vec3 q = fract(p) * 2. - 1.;\n\tfloat s  = texelFetch( iChannel0, ivec2(6,0), 0 ).x; \n    q.y = s * 1.;\n    q.y *= 0.0001;\n    q.y /= 0.001;\n    float d = length(q) - .07;   \n    return max(d,d2);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for(int i = 0; i < 36; ++i)\n    {\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * .5;\n        \n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv = uv * 2.0 -1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    /*\nuv *= 5.;\n    uv.y = abs(uv.y * 5.);\n\n*/\n    \n    vec3 r = normalize(vec3(uv,1.0));\n    \tfloat fft  = texelFetch( iChannel0, ivec2(0,0), 0 ).x; \n    r.x += .25 * sin(iTime);\n    vec3 o = vec3(0.0, 1., -3.0 + iTime );\n    \n    float t = trace(o,r) ;\n    \n   \n    float fog = 1. / (1.0 + t * t * 0.0100);\n  \t  \n    vec3 fc = vec3(fog, fog * 1.2 , fog + 0.23);\n   /*\n\n\n    fft += abs(sin(fft)) / 55.;\n    fc *= (fft * 1.2);\n    fc.x *= fft; \n*/ \n// Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 290], [292, 292, 321, 321, 478], [480, 480, 537, 587, 1299]], "test": "error"}
{"id": "WlGSW3", "name": "glass sphere and cube", "author": "Dijkstra", "description": "Trying to improve my understanding of raymarching, coloring and reflection...", "tags": ["raymarching", "reflection"], "likes": 3, "viewed": 78, "published": "Public", "date": "1583672864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 100\n#define MAX_DISTANCE 100.\n#define EPSILON 0.0001\n#define REFLECTION .4\n#define PI 3.1456\n#define VL(p) (1./((length(p)-.0)*(length(p)-.0) ) )\nvec3 h;\n\n// for rotation\nmat3 rot(float rad){\n\tfloat cr = cos(rad);\n\tfloat sr = sin(rad);\n\treturn mat3(cr,0.,sr,0.,1.,0.,-sr,0.,cr);\n}\n\n// create a box (inspired by iq function)\nfloat box(vec3 rp, vec3 bp, vec3 bsize){\n\trp = rp-bp;\n \tvec3 q = abs(rp) - bsize;\n    \n    h += VL(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0));\n    \n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// give the distance from a sphere\nfloat sphere(vec3 rp, vec3 sp, float rad){\n    \n\treturn length(sp-rp)-rad;\n}\n\n// Scene function\nfloat getDistance(vec3 p){\n\tfloat s1 = sphere(p, vec3(-2.,0.,0.), .9);\n\tfloat s2 = sphere(p, vec3(2.,0.,0.), .9);\n\tfloat s3 = sphere(p, vec3(0.,2.,0.), .9);\n\tfloat c1 = box(p, vec3(0.,-2.,0.), vec3(.9));\n\tfloat m1 = min(s1, s2);\n\tfloat m2 = min(s3, c1);\n\treturn min(m1, m2);\n}\n\nvec3 getNormal(vec3 p){\n\treturn normalize(\n\t\tvec3(\n\t        getDistance(vec3(p.x + EPSILON, p.y, p.z)) - getDistance(vec3(p.x - EPSILON, p.y, p.z)),\n\t        getDistance(vec3(p.x, p.y + EPSILON, p.z)) - getDistance(vec3(p.x, p.y - EPSILON, p.z)),\n\t        getDistance(vec3(p.x, p.y, p.z + EPSILON)) - getDistance(vec3(p.x, p.y, p.z - EPSILON))\n\t    )\n    );\n}\n\nfloat getLight(vec3 p){\n\tvec3 lightPos =vec3(0.,-2.,0.);\n\tvec3 ld = normalize(lightPos - p);\n\tvec3 normal = getNormal(p);\n\n\tfloat diffuseLight = dot(normal, ld);\n\treturn diffuseLight*.5+.5; // thx flopine\n}\n\n// get distance from the closest object\nfloat raymarch(vec3 ro, vec3 rd){\n\tvec3 rp = ro;\n\tfor(int i=0; i<MAX_ITERATIONS; ++i){\n\t\tfloat dist = getDistance(rp);\n\t\tif(dist <= .01){\n\t\t\treturn distance(rp, ro);\n\t\t}\n\t\trp += dist*rd;\n\t\tif(distance(rp, ro) > MAX_DISTANCE)\n\t\t\tbreak; \n\t}\n\treturn -1.;\n}\n\n// get the color of an object by using it's position (to improve)\nvec3 getColor(vec3 p){\n\tif(p.y>1.){\n\t\treturn vec3(0.,1.,0.);\n\t}\n\tif(p.y<-1.){\n\t\treturn vec3(1.);\n\t}\n\tif(sign(p.x) < 0.)\n\t\treturn vec3(1.,0.,0.);\n\treturn vec3(0.,0.,1.);\n}\n\nvec3 getBackground(){\n\treturn vec3(.3);\n}\n\n// Setup the color of the pixel using reflection\nvec3 render(vec3 p, vec3 rd){\n\tvec3 color = getColor(p);\n\tvec3 rrd = reflect(rd,getNormal(p)); \t// reflectedRayDirection\n\tvec3 newRo = p + rrd * .5;\n\tfloat marched = raymarch(newRo , rrd);\n\tvec3 newColor = getBackground();\n\tif(marched>0.){\t\t\t\t\t\t\t// if reflected ray touch another object\n\t\tvec3 rp = (marched*rrd)+newRo; \t\t// reflectedPosition\n\t\tnewColor = getColor(rp);\n\t\tnewColor *= getLight(rp);\n\t}\n\tcolor = mix(color, newColor, REFLECTION);\n\tcolor *= getLight(p);\n\n\treturn color;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    h=vec3(0.);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(sin(iTime*.5)*5.,.5,cos(iTime*.5)*5.);\n    vec3 rd = normalize(vec3(uv,1.));\n    rd*=rot(.5*iTime+PI);\n    vec3 color;\n\n    float d = raymarch(ro, rd);\n\n    if(d < 0.){\n    \tcolor = getBackground();\n    }\n    else{\n\t\tcolor = render((d*rd)+ro, rd);\n    }\n\tcolor+=h*.005;\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 194, 214, 214, 303], [305, 347, 387, 387, 569], [571, 606, 648, 648, 682], [684, 702, 728, 728, 978], [980, 980, 1003, 1003, 1339], [1341, 1341, 1364, 1364, 1547], [1549, 1589, 1622, 1622, 1842], [1844, 1910, 1932, 1932, 2080], [2082, 2082, 2103, 2103, 2123], [2125, 2174, 2203, 2203, 2658], [2660, 2660, 2718, 2718, 3153]], "test": "timeout"}
{"id": "wlGSzc", "name": "Floating Points", "author": "evalee", "description": "A colorful cloud of dots.", "tags": ["color", "dots", "points"], "likes": 7, "viewed": 470, "published": "Public API", "date": "1583240418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistanceToLine(vec3 LineStart, vec3 LineEnd, vec3 Point)\n{\n    vec3 lineStartToEnd = LineEnd - LineStart;\n    return length(cross(Point - LineStart, lineStartToEnd))/length(lineStartToEnd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV goes from -0.5 to 0.5 vertically\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    float sineOfTime = sin(iTime);\n    float cosineOfTime = cos(iTime);\n    \n    vec3 rayOrigin = vec3(0, 0, -1.0 + sineOfTime * 0.25);\n    vec3 uvPoint = vec3(uv, 0);\n    \n    float filledIn = 0.0;\n\n    for (float x = -1.0; x <= 1.0; x += 0.5)\n    {\n        for (float y = -1.0; y <= 1.0; y += 0.5)\n        {\n            for (float z = -1.0; z <= 1.0; z += 0.5)\n            {\n                vec3 point = vec3(x, y, z + 5.0);\n                point.x += sineOfTime * 0.75;\n                point.z -= cosineOfTime * 0.75;\n                point.y -= (cosineOfTime + sineOfTime) * 0.75;\n                point.x += (fract(x * 47350.6 - y * 7076.5 + z * 3205.25 + sin(iTime * x * y * z) * 0.5) - 0.5) * 1.75;\n                point.y += (fract(-x * 155.2 + y * 2710.66 + z * 71820.43 - cos(iTime * x * y * z) * 0.5) - 0.5) * 1.75;\n                point.z += (fract(x * 21255.52 + y * 510.16 - z * 6620.73 - cos(iTime * x * y * z) * 0.5) - 0.5) * 1.75;\n                \n                float distanceToLine = DistanceToLine(rayOrigin, uvPoint, point);\n                float radius = 1.0 - (fract(x * 61250.955 + y * 163.135 + z * 6207.58) * 0.125 + 0.025);\n                float intensity = 0.25 * fract(x * 1050.25 + y * -8415.95 + z * 120.01);\n                float distanceFwidth = fwidth(distanceToLine);\n                filledIn += intensity * smoothstep(radius - distanceFwidth, radius, 1.0 - distanceToLine);\n                \n                // Glow\n                filledIn += max(0.01, sineOfTime * 0.5 + 1.0 - distanceToLine) * 0.01;\n            }\n        }\n    }\n    \n    vec3 color = filledIn * vec3(uv.x + 0.5, uv.y + 0.5, uv.x * uv.y + 0.5) * (max(0.5, (cos(iTime * 0.35 + 0.25) + 0.5)) * 10.0);\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 64, 64, 197], [199, 199, 256, 299, 2110]], "test": "timeout"}
{"id": "wlGXDd", "name": "cuartov11", "author": "jorge2017a1", "description": "cuartov11", "tags": ["cuartov11"], "likes": 0, "viewed": 64, "published": "Public", "date": "1583850793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//cuartov11\n//por jorge2017a1---9-mar-2020\n///Corregido y Aumentado por Spalmer /// 10/mar/2020\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    \n    \n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n  \n    \n   float sdwx= wallx(p);\n   float sdwy= wally(p); \n   float sdwz= wallz(p);\n   \n    \n   res=opU(res, vec2(sdwx,8));\n   res=opU(res, vec2(sdwy,13));\n   res=opU(res, vec2(sdwz,22));\n    \n\n   float sdc1=  sdCylinder(p-vec3(12,-5.0,-28.), vec2(2.1,20.0) );\n   float sdc2=  sdCylinder(p-vec3(-12,-5.0,-28.), vec2(2.1,20.0) );\n   res=opU(res, vec2(sdc1,21));\n   res=opU(res, vec2(sdc2,24));\n\n  \n    \n\tfloat sdb1= sdBox(p- vec3(1.,-10.0,-10.), vec3(3.0,3.0,3.0) );\n    //float sds1= sdSphere( p-vec3(0.0,-15.0,-2.0), 1.5 );\n    res=opU(res, vec2(sdb1,6));\n   // res=opU(res, vec2(sds1,24));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        \n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n\t}        \n    \t\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n \n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t\n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    vec3 hit;\n    \n    \n  \n  for( int  i = 0; i < 96; i++)\n  {\n      \n    vec3 hit = ro+rd*dist;\n    float nearest = GetDist(hit);\n      \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        \n        \n        return pixelColor;\n    } \n    dist += nearest;\n    \n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    vec3 ro = vec3(-2.0+10.*cos(iTime) ,6.5,10.0+ 7.0*sin(iTime));\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t  vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    //float dif = GetLightv2(p);\n    float dif = GetLightPar(p,rLuz);\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    \t\n    \n   \n    p += normal * .02; \n    vec3 pixelColour = Render(p, refl,colobj, rLuz);\n    pixelColour= max(pixelColour,0.0);\n    \n    col = pixelColour*.2+result; \n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 540, 573, 573, 638], [639, 657, 693, 693, 762], [763, 778, 809, 809, 959], [960, 980, 1016, 1016, 1103], [1104, 1120, 1152, 1180, 1241], [1243, 1243, 1279, 1279, 1382], [1385, 1459, 1517, 1517, 1781], [1783, 1783, 1828, 1828, 1919], [1921, 1921, 2003, 2003, 2234], [2237, 2237, 2268, 2268, 2456], [2459, 2513, 2535, 2535, 3795], [3798, 3862, 3898, 3898, 4171], [4223, 4223, 4269, 4269, 4301], [4303, 4303, 4346, 4346, 4378], [4380, 4380, 4428, 4428, 4461], [4464, 4464, 4493, 4493, 4619], [4621, 4621, 4657, 4657, 4774], [4776, 4776, 4812, 4812, 4930], [4933, 4933, 4969, 4969, 5092], [5145, 5157, 5179, 5179, 5487], [5488, 5514, 5539, 5539, 5729], [5730, 5775, 5792, 5792, 5865], [5868, 5901, 5927, 5927, 6124], [6171, 6171, 6223, 6223, 6378], [6443, 6552, 6589, 6589, 6624], [6626, 6626, 6645, 6645, 6720], [6769, 6769, 6792, 6792, 6818], [6820, 6820, 6843, 6843, 6981], [6984, 6984, 7006, 7006, 7076], [7141, 7141, 7167, 7167, 7224], [7226, 7226, 7246, 7246, 7304], [7307, 7307, 7328, 7328, 7578], [7581, 7581, 7613, 7613, 7698], [7700, 7700, 7736, 7736, 7925], [7926, 7926, 7953, 7953, 8368], [8477, 8504, 8525, 8525, 8591], [8593, 8593, 8615, 8615, 8670], [8672, 8672, 8693, 8693, 8748], [8750, 8750, 8771, 8771, 8826], [8890, 8890, 8909, 8909, 8953], [8955, 8955, 8998, 8998, 10548], [10551, 10600, 10625, 10625, 11512], [11515, 11515, 11549, 11549, 11918], [11923, 11923, 11947, 11947, 12179], [12183, 12183, 12207, 12207, 12599], [12602, 12602, 12628, 12628, 12992], [12995, 12995, 13033, 13033, 13390], [13393, 13393, 13418, 13418, 13446], [13448, 13448, 13500, 13500, 13896], [13999, 14043, 14060, 14060, 14131], [14156, 14248, 14273, 14273, 14536], [14595, 14595, 14623, 14623, 21567], [21569, 21617, 21718, 21752, 22262], [22268, 22314, 22367, 22367, 23424], [23427, 23476, 23533, 23533, 25096]], "test": "error"}
{"id": "wlGXRV", "name": "PTB Sinusoidal Grating Shader", "author": "iandol", "description": "This is the shader from Psychtoolbox converted into a shadertoy, so you can tinker with it and learn how it works by playing with the parameters. See DriftDemo4.m in MATLAB for the PTB version.\n", "tags": ["psychtoolbox", "psychophysics"], "likes": 1, "viewed": 65, "published": "Public", "date": "1583147961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//code for shadertoy.com\n//this is port of the procedural shader code that is demonstrated in DriftDemo4.m\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /////////////////////////////////////--VARIABLES\n    //In PTB variables will come from the MATLAB \n    //calling code via the vertex shader. But\n    //in shadertoy you declare them directly.\n    //\n    // some constants\n    const float twopi = 2.0 * 3.141592654;\n    const float deg2rad = 3.141592654 / 180.0;\n\t// grating frequency\n\tfloat FreqTwoPi = 0.02 * twopi;\n    // grating phase, here varies using playback time\n\tfloat Phase = deg2rad * -iTime*200.0;\n    // modulation color (default is [1 1 1] in PTB \n    // it is the 8th parameter you pass to Screen('DrawTexture'))\n    vec4 modulateColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n    // amplitude in line 80 of DriftDemo4.m which says: \n    // a setting of 0.5 means that the grating will extend over a range from -0.5\n    // up to 0.5, i.e., it will cover a total range of 1.0 == 100% of the total\n    // displayable range. amplitude is like contrast / 2.\n\tfloat amplitude = 0.5;\n    // premultiplier, default is 1.0 in line 86 of CreateProceduralSineGrating.m\n    // but by setting contrastPreMultiplicator to 0.5 you can make amplitude 0-1 range.\n    float contrastPreMultiplicator = 1.0;\n    // Offset, line 104 of DriftDemo4.m or line 73 of CreateProceduralSineGrating.m\n    vec4 Offset = vec4(0.5, 0.5, 0.5, 0.0); \n\n    ////////////////////////////////////--CODE\n    // get our base color, line 53 of BasicSineGratingShader.vert.txt\n    vec4 baseColor = modulateColor * amplitude * contrastPreMultiplicator;\n    \n\t// create our sinusoid, line 21 of BasicSineGratingShader.frag.txt\n\tfloat sv = sin( fragCoord.x * FreqTwoPi + Phase );\n\n\t// blend our color with the sinusoidal signal, line 26 of BasicSineGratingShader.frag.txt\n    // off to the display, byebye little pixel!\n    fragColor = (baseColor * sv) + Offset;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 167, 391, 1944]], "test": "ok"}
{"id": "wlKSDy", "name": "facepaint", "author": "samhattangady", "description": "Tried out a different method of modelling the face. Made it a lot more rugged loooking, so finished it off with some warpaint. Just don't feel like working on the ears though.", "tags": ["sdf", "3dmodel"], "likes": 9, "viewed": 299, "published": "Public API", "date": "1583529610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * 01 Mar 2020\n * Just want to make something from scratch again. I think building on the things\n * that I have built before may not be the best approach for every single model,\n * because it doesn't always allow me to get the practice in, and I stick to doing\n * things the same way every time, and don't have an oppurtunity to improve the base\n * framework... ‾\\_(ツ)_/‾\n * As far as possible, apart from the sdf functions, I want to rewrit the whole thing\n * from scratch, just to see where the whole thing can be simpler.\n*/\n\n#define RAYMARCH_STEPS 100\n#define MAX_RAYMARCH_DISTANCE 15.0\n#define RAYMARCH_SURFACE_DISTANCE 0.01\n#define PI 3.14159\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\nfloat sdfCappedCone( vec3 p, vec3 origin, vec3 scale, float h, float r1, float r2, float radius )\n{\n    p*=scale;\n    p -= origin;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) ) - radius;\n}\nfloat smin(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\nvec2 distanceField(vec3 pos) {\n    //pos = rotate3D(pos, vec3(0.0, 0.0, -0.2));\n    float material = 1.0;\n    float d, d1, d2;\n    vec3 t1, symx;\n    d = MAX_RAYMARCH_DISTANCE;\n    // base head\n    d1 = sdfCappedCone(pos, vec3(0.0, -0.0, 0.0), vec3(1.0, 1.0, 1.0), 1.0, 0.5, 0.3, 0.9);\n    d = smin(d, d1, 0.001);\n    d1 = sdfSphere(pos, vec3(0.0, 0.5, 0.4), 1.6);\n    d = smin(d, d1, 0.4);\n\n    // eyesockets\n    d1 = sdfRoundBoxRotated(pos, vec3(0.0, 0.6, -1.2), vec3(2.0, 0.0, 0.0), vec3(0.0, 0.0, 0.12), 0.4);\n    d2 = sdfRoundBoxRotated(pos, vec3(0.0, 1.2, -1.2), vec3(2.5, 0.4, 0.4), vec3(-0.4, 0.0, 0.18), 0.1);\n    d1 = smax(d1, -d2, 0.1);\n    d = smax(d, -d1, 0.2);\n\n    // cheekbones\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfSphere(symx, vec3(0.8, -0.25, -0.8), 0.3);\n    d = smin(d, d1, 0.4);\n\n    // chin\n    d1 = sdfRoundBoxRotated(pos, vec3(0.0, -1.4, -1.05), vec3(0.4, 0.2, 0.2), vec3(0.3, 0.0, 0.0), 0.04);\n    d = smin(d, d1, 0.5);\n\n    // jaw\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfRoundBoxRotated(symx, vec3(0.8, -1.0, -0.4), vec3(0.3, 0.2, 0.6), vec3(-0.3, 0.8, 0.3), 0.01);\n    d = smin(d, d1, 0.5);\n\n    // nose\n    t1 = pos-vec3(0.0, 0.4, -1.0);\n    t1 = rotate3D(t1, vec3(0.4, 0.0, 0.0));\n    symx = vec3(abs(t1.x), t1.yz);\n    d1 = sdfRoundBoxRotated(t1, vec3(0.0), vec3(0.1, 0.4, 0.2), vec3(-0.2, 0.0, 0.0), 0.05);\n    d2 = sdfRoundBoxRotated(t1, vec3(0.0, -0.4, 0.0), vec3(0.06, 0.4, 0.2), vec3(0.2, 0.0, 0.0), 0.05);\n    d1 = smin(d1, d2, 0.1);\n    d2 = sdfSphere(t1, vec3(0.0, -0.72, -0.23), 0.1);\n    d1 = smin(d1, d2, 0.2);\n    d2 = sdfSphere(t1, vec3(0.22, -0.64, -0.2), 0.12);\n    d1 = smin(d1, d2, 0.2);\n    d2 = sdfSphere(t1, vec3(-0.23, -0.66, -0.2), 0.13);\n    d1 = smin(d1, d2, 0.2);\n    d = smin(d, d1, 0.2);\n\n    //eyes\n    d1 = sdfSphere(pos, vec3(0.44, 0.5, -0.8), 0.35);\n    if (d1<d)\n        material = 2.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(-0.44, 0.5, -0.8), 0.35);\n    if (d1<d)\n        material = 2.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(0.48, 0.49, -1.0), 0.20);\n    if (d1<d)\n        material = 3.0;\n    d = smin(d, d1, 0.02);\n    d1 = sdfSphere(pos, vec3(-0.42, 0.46, -1.0), 0.19);\n    if (d1<d)\n        material = 3.0;\n    d = smin(d, d1, 0.02);\n\n\n    // mouth\n    d1 = sdfSphere(pos, vec3(-0.48, -0.82, -1.4), 0.12);\n    d = smax(d, -d1, 0.23);\n    d1 = sdfSphere(pos, vec3(0.48, -0.82, -1.4), 0.12);\n    d = smax(d, -d1, 0.23);\n    t1 = rotate3D(pos, vec3(0.3, 0.0, -0.1));\n    d1 = sdfCappedCone(t1, vec3(0.1, -0.95, -0.84), vec3(1.0, 1.0, 1.0), 0.2, 0.5, 0.3, 0.0);\n    d = smin(d, d1, 0.12);\n    t1 = rotate3D(pos, vec3(0.27, 0.0, -0.14));\n    d1 = sdfCappedCone(t1, vec3(0.1, -1.35, -0.84), vec3(1.0, 1.0, 1.0), 0.1, 0.3, 0.5, 0.0);\n    d = smin(d, d1, 0.23);\n\n    // neck\n    d1 = sdfCappedCone(pos, vec3(0.0, -1.5, 0.4), vec3(1.0, 1.0, 1.0), 0.9, 1.3, 1.1, 0.1);\n    d = smin(d, d1, 0.05);\n\n    // ears\n    symx = vec3(abs(pos.x), pos.yz);\n    symx = rotate3D(symx, vec3(0.0, 0.0, -0.1));\n    symx.y /= 1.2;\n    t1 = symx - vec3(1.5, 0.13, 0.0);\n    d1 = sdfSphere(t1, vec3(0.0), 0.5);\n    d2 = sdfRoundBoxRotated(t1, vec3(0.0), vec3(0.1, 2.0, 2.0), vec3(0.0, 0.9, 0.0), 0.0);\n    d1 = smax(d2, d1, 0.05);\n    d2 = sdfSphere(t1, vec3(0.25, 0.1, 0.0), 0.1);\n    d1 = smax(-d2, d1, 0.3);\n    d2 = sdfSphere(t1, vec3(0.21, -0.1, -0.01), 0.1);\n    d1 = smax(-d2, d1, 0.1);\n    d = smin(d, d1, 0.05);\n\n    // warpaint\n    symx = vec3(abs(pos.x), pos.yz);\n    d1 = sdfRoundBoxRotated(symx, vec3(0.74, 0.1, -1.0), vec3(0.25, 0.04, 1.0), vec3(0.0, 0.0, 0.2), 0.1);\n    if (d1<d)\n        material = 4.0;\n\n\n    return vec2(d, material);\n}\n\nvec2 raymarch(vec3 point, vec3 direction) {\n    // return type: vec2(distance, material);\n    float dist = 0.0;\n    vec2 d;\n    for (int i=0; i<RAYMARCH_STEPS; i++) {\n        d = distanceField(point);\n        dist += d.x;\n        point += d.x * direction;\n        if (d.x < RAYMARCH_SURFACE_DISTANCE)\n            return vec2(dist, d.y);\n        if (dist > MAX_RAYMARCH_DISTANCE)\n            return vec2(dist, 0.0);\n    }\n    return vec2(dist, 0.0);\n}\n\nvec3 calculate_normal(vec3 pos) {\n    vec3 h = vec3(0.001, 0.0, 0.0);\n    float d = distanceField(pos).x;\n    return normalize(vec3(\n                d-distanceField(pos+h.xyy).x,\n                d-distanceField(pos+h.yxy).x,\n                d-distanceField(pos+h.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.0 - vec2(1.0);\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 point = vec3(uv, -5.0);\n    vec3 camera = vec3(0.0, 0.0, -6.0);\n    float mouseX = ((-iMouse.x/iResolution.x)+0.5)*PI/1.5;\n    mouseX = 0.3 + 0.3*sin(iTime/2.0);\n\n    point = rotate3D(point, vec3(0.0, mouseX, 0.0));\n    camera = rotate3D(camera, vec3(0.0, mouseX, 0.0));\n    vec3 light_position = vec3(1.0, 1.0, -3.0);\n    vec3 ray_direction = normalize(point-camera);\n    vec2 obj = raymarch(point, ray_direction);\n    float dist = obj.x;\n    float material = obj.y;\n    vec3 color = vec3(0.01);\n    if (dist < MAX_RAYMARCH_DISTANCE) {\n        vec3 surface_point = point + ray_direction*dist;\n        vec3 normal = calculate_normal(surface_point);\n        float light = dot(normal, normalize(surface_point-light_position));\n        light = max(0.0, light);\n        if (material < 1.5) {\n            color = vec3(0.38, 0.22, 0.15);\n            color += vec3(0.18) * smoothstep(0.1, 1.0, light);\n            color += vec3(0.05) * smoothstep(0.3, 1.0, light);\n        } else if (material < 2.5) {\n            color = vec3(0.25, 0.28, 0.34);\n            color += vec3(0.33) * smoothstep(0.1, 1.0, light);\n        } else if (material < 3.5) {\n            color = vec3(0.03, 0.025, 0.02);\n            color += vec3(0.2) * smoothstep(0.9, 1.0, light);\n        } else if (material < 4.5) {\n            color = vec3(0.002, 0.002, 0.002);\n            color += vec3(0.1) * smoothstep(0.1, 1.0, light);\n        }\n    }\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[658, 658, 700, 700, 1145], [1146, 1146, 1205, 1205, 1255], [1256, 1256, 1316, 1316, 1455], [1456, 1456, 1538, 1538, 1719], [1720, 1720, 1761, 1761, 1813], [1814, 1814, 1907, 1907, 2085], [2086, 2086, 2106, 2106, 2127], [2128, 2128, 2234, 2234, 2897], [2898, 2898, 2997, 2997, 3364], [3365, 3365, 3406, 3406, 3482], [3483, 3483, 3524, 3524, 3600], [3601, 3601, 3631, 3680, 7249], [7251, 7251, 7294, 7340, 7701], [7703, 7703, 7736, 7736, 7982], [7984, 7984, 8041, 8041, 9636]], "test": "timeout"}
{"id": "WlKSRd", "name": "Paper Rolls", "author": "dr2", "description": "Where has all the loo paper gone (serious business)?", "tags": ["repetition", "toilet", "gridmarch"], "likes": 15, "viewed": 372, "published": "Public API", "date": "1583394789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Paper Rolls\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1  // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nvec2 gId, trkF, trkA;\nfloat tCur, dstFar, hgSize, wavHt, nCylV, nCylH, cylHt, cylRd, cylHo, emFrac;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId * hgSize);\n  a = atan (p.z, - p.x) / (2. * pi);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a + 0.5)) / 6.);\n  d = max (abs (q.x) - 0.85 * hgSize, q.y - wavHt + 0.05 * dot (q.xz, q.xz));\n  DMINQ (1);\n  if (isOcc) {\n    p.y -= wavHt - 0.03;\n    q = p;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (nCylH * a + 0.5)) / nCylH);\n    if (nCylH > 1.) q.x = abs (q.x) - 0.8;\n    q.y -= cylHt * nCylV;\n    d = max (PrCylDf (q.xzy, cylRd, cylHt * nCylV), cylHo - length (q.xz));\n    DMINQ (2);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.3 * sin (0.2 * 2. * pi * p)) +\n    0.1 * tCur, 1.) - 0.5;\n  wavHt = 0.6 * dot (exp (-100. * u * u), vec2 (1.));\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  isOcc = (fRand.y >= emFrac);\n  if (isOcc) {\n    nCylV = 1. + floor (4. * fRand.x);\n    nCylH = 1. + floor (6. * fRand.y);\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float ao, d;\n  ao = 0.;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 4; j ++) {\n    d = 0.01 + float (j) / 20.;\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  return 0.6 + 0.4 * clamp (1. - 2. * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, sh, ao;\n  bgCol = vec3 (0.5, 0.4, 0.4);\n  emFrac = 0.05;\n  cylHt = 0.3;\n  cylRd = 0.3;\n  cylHo = 0.12;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      if (vn.y > 0.01) col = mix (vec3 (0.65, 0.65, 0.7), vec3 (0.6, 0.6, 0.55),\n         smoothstep (0.4, 0.6, Fbm2 (ro.xz)));\n      else col = vec3 (0.95, 0.95, 1.) * (0.85 + 0.15 * cos (9. * 2. * pi * qHit.z / hgSize));\n    } else if (idObj == 2) {\n      if (length (qHit.xz) < cylHo + 0.01) col = vec3 (0.6, 0.4, 0.);\n      else col = mix (vec3 (1., 0.8, 0.9), vec3 (1.3),\n         smoothstep (0.02, 0.05, abs (mod (qHit.y / (2. * cylHt) + 0.5 * (nCylV + 1.), 1.) - 0.5)));\n    }\n    ao = ObjAO (ro, vn);\n    sh = min (ObjSShadow (ro, ltDir), ao);\n    col *= ao * (0.3 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.)) +\n       0.7 * sh * max (dot (vn, ltDir), 0.);\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else col = (0.1 + 0.9 * step (-0.1, rd.y)) * bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)),\n     dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)),\n     dot (trkF * trkF * trkA.yx, - cos (trkF * t)), 0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec4 dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 1.6;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, -0.05 * pi);\n  trkF = vec2 (0.1, 0.17);\n  trkA = vec2 (1.25, 0.45);\n  vuMat = StdVuMat (el, az);\n  vFly = 2.;\n  ro = TrackPath (vFly * tCur);\n  ro.y += 5.;\n  vd = normalize (TrackVel (vFly * tCur));\n  vuMat = StdVuMat (el + 0.5 * sin (vd.y), az + 2. * atan (vd.x, vd.z));\n  zmFac = 2.2;\n  dstFar = 120.;\n  ltDir = normalize (vec3 (0., 1.5, -1.));\n  ltDir.xz = Rot2D (ltDir.xz, 0.3 * pi * sin (0.05 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    rd.xy = Rot2D (rd.xy, -10. * TrackAcc (vFly * tCur).x);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSRd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[688, 688, 710, 710, 1293], [1295, 1295, 1317, 1317, 1718], [1720, 1720, 1753, 1753, 2821], [2823, 2823, 2844, 2844, 3092], [3094, 3094, 3131, 3131, 3534], [3536, 3536, 3568, 3568, 3928], [3930, 3930, 3965, 3965, 5058], [5060, 5060, 5086, 5086, 5166], [5168, 5168, 5193, 5193, 5295], [5297, 5297, 5322, 5322, 5440], [5442, 5442, 5498, 5498, 6949], [6951, 6951, 6993, 6993, 7044], [7046, 7046, 7070, 7070, 7300], [7302, 7302, 7326, 7326, 7386], [7388, 7388, 7410, 7410, 7448], [7450, 7450, 7495, 7495, 7598], [7600, 7600, 7636, 7636, 7842], [7843, 7843, 7873, 7873, 7986], [8020, 8020, 8044, 8044, 8174], [8176, 8176, 8201, 8201, 8387], [8389, 8389, 8410, 8410, 8565]], "test": "error"}
{"id": "wlKSRy", "name": "circlecolor", "author": "abhisarshukla", "description": "default colors with a circle.", "tags": ["beginner", "circle"], "likes": 0, "viewed": 154, "published": "Public API", "date": "1583078121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float d = length(uv);\n    float r = 0.3*sin(1.);\n    float ctf = max((sin(0.5)+cos(iTime)), 0.25)/2.;\n    float c = smoothstep(r-0.005, r, d)+1.;\n    if(d > r) c *= ctf+0.5; else c *= 1.5-ctf;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col *= vec3(c);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 696]], "test": "ok"}
{"id": "WlKSWt", "name": "2D Shaded Metaballs", "author": "lewdoo", "description": "Using fake normals and light source to generate shaded effect on 2D metaballs", "tags": ["metaballs"], "likes": 0, "viewed": 54, "published": "Public", "date": "1583854321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(ratio, 1.) * (2. * fragCoord.xy / iResolution.xy - 1.);\n\t\n    uv *= 3.;\n    uv.x -= 0.;\n\n    vec3 normals = vec3(0.);\n    vec3 baseCol = vec3(0.);\n    \n    for(float i = 0.; i < 7.; i++){\n        vec2 st = uv;\n    \tst.x += sin(iTime + i * 2.25 + sin(i * iTime) * 0.2) * 1.5;\n        st.y += cos(iTime + i * 1.25) * 1.5;\n\n        st *= 0.6;\n        \n        baseCol += vec3((st * 0.5 + 0.5) * vec2((1. - smoothstep(0., 1.,distance(st, vec2(0., .0))))), 0.);\n    }\n    //this smooths the normals between the balls\n \tnormals = normalize(baseCol);\n    \n    vec3 rlp = vec3(.3, .1, 1.1);\n    vec3 rld = vec3(normalize(rlp));\n    float rim = sqrt(max(dot(rld, baseCol), .0));\n    \n    //used to average the normals produced in the for functions\n    float shape = float(baseCol.r + baseCol.g + baseCol.b);\n\n    //used to make clear outlines around each orb\n    float outline = sign((shape) - 0.2) * 0.5 + 0.5;\n    outline = smoothstep(0., 0.1, shape - 0.2);\n\n    vec3 col = vec3(.505, .0, .8823);\n\n    vec3 lightPos =vec3(-2., 10.7, .1);\n    vec3 lightDir = normalize(lightPos);\n    \n    float diffuse = sqrt(pow(max(dot(lightDir, normals + 0.05), .0), 1.));\n    float hlight = pow(diffuse - 0.2, 5.5);\n\tfloat h = max(dot(lightDir, normals * 10. - 8.), 0.);\n    \n    //sqrt is used to smooth out the lighting\n    col = vec3(sqrt(diffuse + hlight * 2.8) * outline);\n\n    float v = .5;\n    \n    //col = col * v + vec3(.9647, .1294, .4313) * (1. - v) * outline;\n    \n    vec3 invertLight = vec3(2., -3., 0.2);\n    //the +0.2 is to balance out the smoothstep\n    float fakeBase = (1. - clamp((1. - (1. - rim)), 0., 1.)) * 1.6;\n    \n    fakeBase = max(dot(invertLight, baseCol - .95),0.);\n    \n    col -= vec3(pow(fakeBase, 2.)) * .3;\n    \n    col *= vec3(.7, .7, .1);\n    \n  \t//col = vec3(fakeBase);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1947]], "test": "ok"}
{"id": "WlKSzt", "name": "Outdoor Lighting", "author": "JentGent", "description": "Raymarcher.\nSoft shadows + blue ambient light + yellow sunlight = daylight!\n\nI also implemented simple reflection and texturing (with value noise, as you can probably tell).", "tags": ["3d", "raymarching", "lighting", "shading", "raymarcher"], "likes": 4, "viewed": 75, "published": "Public", "date": "1583385079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\nvec3 c = vec3(1., 1., 1.);\n\nconst float PI = 3.14159265358979323;\n\nfloat random(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 iteration) {\n    vec2 i = floor(iteration);\n    vec2 f = fract(iteration);\n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat deSphere(vec3 from, vec3 center, float radius) {\n    return length(center - from) - radius;\n}\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n}\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n    vec3 section = abs(center - from) - dimensions;\n    return length(max(section, 0.)) + min(max(section.x, max(section.y, section.z)), 0.);\n}\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n}\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2., center.x + capAt / 2.), from.yz)) - radius;\n}\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2., center.x + capAt / 2.), from.yz)) - radius;\n}\nfloat dePlane(vec3 from, vec3 center, vec3 normal) {\n    return dot(center - from, normalize(normal));\n}\n\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\nfloat deRound(float pd, float radius) {\n    float de = pd;\n    return de - radius;\n}\n\nfloat boolUnion(float pd, float pd2) {\n    return min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n    return max(pd, -pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n    return max(pd, pd2);\n}\n\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 + (pd - pd2) / smoothness / 2., 0., 1.);\n    return mix(pd, pd2, level) - smoothness * level * (1. - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2., 0., 1. );\n    return mix(pd2, -pd, level) + smoothness * level * (1. - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2., 0., 1.);\n    return mix(pd, pd2, level) + smoothness * level * (1. - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rot(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot;\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot;\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot;\n    inp += anchor;\n    return inp;\n}\n\nvec3 sun = normalize(vec3(3., -2., 2.));\nvec3 point = vec3(0., 0., 0.);\n\nvec3 cam = vec3(10., 8., -10.);\nfloat FOV = 0.5;\n\nuniform vec2 cursor;\n\nvec3 color = vec3(1.);\nfloat refl = 0.0;\nvec3 reflColor = vec3(1.);\n\nfloat scene(vec3 from, bool outColor, bool outRefl) {\n    \n    float trunkde = deCapsule(rot(from, 0., 0., PI/2., vec3(0., 5., 0.)), vec3(0., 5., 0.), 1.5, 10.);\n    float logde = deCuboid(from, vec3(0.), vec3(10., 1., 1.));\n    float groundde = dePlane(from, vec3(0., -1., 0.), vec3(0., -1., 0.));\n    float slopede = dePlane(from, vec3(0., 0., 7.), vec3(0., -1., 1.));\n    float spherede = mix(deSphere(from, vec3(-4., 1., -6.), 3.), deTorus(from, vec3(-4., 1., -6.), 2., 1.), 0.5 + cos(iTime) * 0.5);\n    \n    float de = min(trunkde, min(logde, min(groundde, min(spherede, slopede))));\n    vec3 ret = vec3(0.);\n    if(outColor || outRefl) {\n        if(de == trunkde) {\n            ret = vec3(0.7, 0.6, 0.);\n        }\n        if(de == logde) {\n            ret = vec3(0.5, 0.4, 0.);\n        }\n        if(de == groundde) {\n            ret = vec3(0., noise(from.xz * 0.5 + vec2(1.)) * 0.5 + 0.5, 0.);\n            refl = 0.005;\n        }\n        if(de == slopede) {\n            ret = vec3(noise(from.xz * 0.5), noise(from.xz * 0.5 + vec2(1.)), noise(from.xz * 0.5 + vec2(2.)));\n        }\n        if(de == spherede) {\n            ret = vec3(1.);\n        }\n        if(outColor) {\n            color = ret;\n        }\n        if(outRefl) {\n            reflColor = ret;\n        }\n    }\n    return de;\n    \n}\n\nvec3 getNormal(vec3 from) {\n    vec2 slopeOther = vec2(0.01, -0.01); \n    return normalize(\n        slopeOther.xxx * scene(from + slopeOther.xxx, false, false) +\n        slopeOther.xyy * scene(from + slopeOther.xyy, false, false) +\n        slopeOther.yyx * scene(from + slopeOther.yyx, false, false) + \n        slopeOther.yxy * scene(from + slopeOther.yxy, false, false)\n    );\n}\nvec3 reflNormal(vec3 dir, vec3 normal) {\n    return dir - normal * dot(dir, normal) * 2.;\n}\n\nvec3 render(vec3 from, vec3 dir) {\n    vec3 at = from;\n    float closest = 10000.;\n    float totalDE = 0.;\n    for(int iter = 0; iter < 200; iter += 1) {\n        if(totalDE > 100.) {\n            break;\n        }\n        color = vec3(1.);\n        refl = 0.0;\n        float de = scene(at, true, false);\n        at += dir * de;\n        totalDE += de;\n        if(de < closest) {\n            closest = de;\n        }\n        if(de < 0.01) {\n            vec3 normal = getNormal(at);\n            if(refl > 0.0) {\n                vec3 reflDir = reflNormal(dir, normal);\n                float bias = 0.04;\n                vec3 atRefl = at + normal * bias;\n                float reflDE = 0.;\n                for(int iter = 0; iter < 100; iter += 1) {\n                    if(reflDE > 400.) {\n                        break;\n                    }\n                    float deRefl = scene(atRefl, false, true);\n                    atRefl += reflDir * deRefl;\n                    if(deRefl < 0.03) {\n                        vec3 normalRefl = getNormal(atRefl);\n                        reflColor += vec3(0., 0.2, 0.3);\n                        color = color * (1. - refl) + clamp(reflColor * (clamp(dot(normalRefl, -sun), 0., 1.) * 0.7 + 0.3), 0., 1.) * refl;\n                    }\n                }\n            }\n            \n            float shade = 1.;\n            float bias = 0.04;\n            vec3 atShadow = at + normal * bias;\n            float shadowDE = 0.;\n            float penumbra = 0.1;\n            for(int iter = 0; iter < 100; iter += 1) {\n                if(shadowDE > 200.) {\n                    break;\n                }\n                float deShadow = scene(atShadow, false, false);\n                if(deShadow < 0.03) {\n                    shade = 0.;\n                    break;\n                }\n                shadowDE += deShadow;\n                atShadow += -sun * deShadow;\n                \n                float y = deShadow * deShadow / (2.1 * penumbra);\n                float d = sqrt(deShadow * deShadow - y * y);\n                shade = min(shade, 5. * d / max(0., shadowDE - y));\n                penumbra = deShadow;\n            }\n            shade = shade*shade*(3. - 2.*shade);\n            shade = max(shade, 0.);\n            shade *= clamp(dot(normal, -sun), 0., 1.);\n            float sunShade = shade;\n            color += vec3(0., 0.2, 0.3);\n            shade = shade * 0.7 + 0.3;\n            vec3 sunRGB = vec3(0.3, 0.29, 0.0);\n            return clamp(color * shade + sunRGB * sunShade, 0., 1.);\n        }\n    }\n    return vec3(0.3, 0.8, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    sun = rot(sun, 0., iTime * 0.5, 0., vec3(0.));\n    \n    float yaw = 0.8;\n    float pitch = 0.4;\n    \n    float xMap = fragCoord.x / iResolution.x - 0.5;\n    float yMap = fragCoord.y / iResolution.y - 0.5;\n    vec3 dir = normalize(vec3(xMap, yMap, FOV));\n    vec3 rotd = rot(dir, pitch, 0., 0., vec3(0.));\n    rotd = rot(rotd, 0., yaw, 0., vec3(0.));\n    dir = rotd;\n    \n    c = render(cam, dir);\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 115, 115, 189], [191, 191, 220, 220, 543], [545, 545, 599, 599, 644], [645, 645, 715, 715, 811], [812, 812, 869, 869, 1013], [1014, 1014, 1078, 1078, 1129], [1130, 1130, 1205, 1205, 1337], [1338, 1338, 1406, 1406, 1538], [1539, 1539, 1591, 1591, 1643], [1645, 1645, 1685, 1685, 1721], [1723, 1723, 1762, 1762, 1807], [1809, 1809, 1847, 1847, 1874], [1875, 1875, 1919, 1919, 1947], [1948, 1948, 1993, 1993, 2020], [2022, 2022, 2084, 2084, 2223], [2224, 2224, 2292, 2292, 2433], [2434, 2434, 2503, 2503, 2642], [2644, 2644, 2719, 2719, 2850], [2852, 2852, 2921, 2921, 3288], [3504, 3504, 3557, 3557, 4803], [4805, 4805, 4832, 4832, 5184], [5185, 5185, 5225, 5225, 5276], [5278, 5278, 5312, 5312, 7847], [7849, 7849, 7904, 7904, 8341]], "test": "error"}
{"id": "WlKXDG", "name": "circle spiral 1", "author": "HaleyHalcyon", "description": "done as a proof of concept", "tags": ["spiral"], "likes": 8, "viewed": 189, "published": "Public", "date": "1583500570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DISTSCALE 32.0\n#define ANGLESCALE 96.0\n\nfloat circle(float x, float y, float thres)\n{\n    float r_sq = x * x + y * y;\n    return 0.5 - clamp((r_sq - thres) * 8.0, -0.5, 0.5);\n}\n\nfloat zigzag(float x)\n{\n    return abs(1. - mod(x, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    const float rotSpeed = -5.;\n    const float zoomSpeed = -3.;\n    const float spiralSpeed = 3.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    float distance = log(uv.x*uv.x+uv.y*uv.y) / 2.;\n    float angle = atan(uv.y, uv.x) / PI;\n    \n    float spiral = 0.7 * smoothstep(0.1, 0.9, zigzag(distance * 2.0 + angle * 4.0 + iTime * spiralSpeed)) + 0.15;\n    \n    float distZag = zigzag(DISTSCALE * distance + iTime * zoomSpeed);\n    float angleZag = zigzag(ANGLESCALE * angle + iTime * rotSpeed);\n    \n    float circle = circle(distZag, angleZag, spiral);\n    \n    // Output to screen\n    fragColor = vec4(circle, circle, circle, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 93, 93, 184], [186, 186, 209, 209, 245], [247, 247, 304, 304, 1155]], "test": "ok"}
{"id": "wlKXRV", "name": "1/2020 grid", "author": "rimina", "description": "Something very simple to get my daily shader routine going ;)", "tags": ["grid"], "likes": 2, "viewed": 78, "published": "Public", "date": "1583173004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = 2.0*uv-1.0;\n    q.x *= (iResolution.x/iResolution.y);\n\n    bool xt = false;\n    bool yt = false;\n    float t = sin(iTime*0.5)*300.0;\n    vec3 col = vec3(1.0);\n    if(cos(q.x*t) > -0.5 && cos(q.x*t*0.25) < 0.5){\n        col = fract(cos(q.x))*vec3(0.5)+vec3(0.5, 0.2, 0.3);\n        xt = true;\n    }\n    if(cos(q.y*t) > -0.5 && cos(q.y*t*0.25) < 0.5){\n        col = fract(sin(q.y))*vec3(0.5)+vec3(0.5, 0.2, 0.3);\n        yt = true;\n    }\n    if(xt && yt){\n        col = vec3(1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 701]], "test": "ok"}
{"id": "WlKXWc", "name": "rain drop - correct on video", "author": "oskycar", "description": "fix bug on shader of this  https://www.shadertoy.com/view/ldfyzl\nyou can change the macro RANSIZE  RAINSPEED to see what happed", "tags": ["raindropeffect"], "likes": 9, "viewed": 233, "published": "Public", "date": "1583749528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nA quick experiment with rain drop ripples.\n\nThis effect was written for and used in the launch scene of the\n64kB intro \"H - Immersion\", by Ctrl-Alt-Test.\n\n > http://www.ctrl-alt-test.fr/productions/h-immersion/\n > https://www.youtube.com/watch?v=27PN1SsXbjM\n\n-- \nZavie / Ctrl-Alt-Test\n\n*/\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//control rainsize  控制雨滴大小\n#define RANSIZE 0.7\n//control rain spread speed 控制雨滴扩散速度\n#define RAINSPEED 0.3\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = 10. * exp2(-3.*RANSIZE);\n\tvec2 uv = fragCoord.xy / iResolution.y * resolution;\n    vec2 uv2 = fragCoord.xy / iResolution.xy* resolution;\n    vec2 p0 = floor(uv);\n\n    vec2 circles = vec2(0.);\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 hsh = hash22(pi);\n            #else\n            vec2 hsh = pi;\n            #endif\n            vec2 p = pi + hash22(hsh);\n\n            float t = fract(RAINSPEED*iTime + hash12(hsh));\n            vec2 v = p - uv;\n            float d = length(v) - (float(MAX_RADIUS) + 1.)*t;\n\n            float h = 1e-3;\n            float d1 = d - h;\n            float d2 = d + h;\n            float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n            float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n            circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));\n        }\n    }\n    circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n\tvec3 color = texture(iChannel0, uv2/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[728, 728, 750, 750, 872], [874, 874, 895, 895, 1014]], "test": "error"}
{"id": "wlKXWt", "name": "Jungle biome map + distortion", "author": "jarble", "description": "I added some sine-wave distortion to my jungle biome map. It looks much more realistic now.\n\nMove the mouse to zoom in and out!", "tags": ["procedural", "fractal", "texture", "jungle", "biome", "rainforest"], "likes": 2, "viewed": 305, "published": "Public API", "date": "1583901344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n\nfloat sin1(float x){\n\treturn sin(x)+sin(x*mag)/mag;\n}\n\n\nint magnify(vec2 fragCoord,float mag,float num_colors){\n    fragCoord += vec2(sin1(fragCoord.y/(100.0*mag))*10.0,sin1(fragCoord.x/(100.0*mag))*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n}\n\nint forest_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int FOREST_GREEN = 4;\n    int WHITE = 5;\n    return (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW)\n        ? GREEN\n    :(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors))\n        ? FOREST_GREEN\n    :(color1 == GRAY && is_next_to(GREEN,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? FOREST_GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :color1;\n\n}\n\nint savanna_biome(inout int color1, ivec4 neighbors){\n    int GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int YELLOW = 3;\n    int FOREST_GREEN = 4;\n    return (color1 == GREEN && is_next_to(GRAY,neighbors))\n    \t? YELLOW\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n    \t? FOREST_GREEN\n    :(color1 == GRAY)\n        ? GREEN\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    : color1;\n}\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nint swamp_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int WHITE = 4;\n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n    \t? YELLOW\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == GRAY && is_next_to(YELLOW,neighbors))\n        ? YELLOW\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nint forests_and_mountains(inout int color1, ivec4 neighbors){\n    int BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int WHITE = 4;\n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n    \t? YELLOW\n    :(color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == GRAY && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = (biome == FORESTS_AND_MOUNTAINS)\n        ? forests_and_mountains(color1,neighbors)\n    : (biome == GLACIER_BIOME) ?\n        glacier_biome(color1,neighbors)\n    : (biome == SWAMP_BIOME) ?\n        forests_and_mountains(color1,neighbors)\n    : (biome == SAVANNA_BIOME) ?\n    \tsavanna_biome(color1,neighbors)\n    : (biome == FOREST_BIOME) ?\n    \tforest_biome(color1,neighbors)\n    : color1;\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[6],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\nint forest_biome(in vec2 fragCoord,float mag,float zoom,int[6] colors){\n    return biome(fragCoord,mag,zoom,colors,FOREST_BIOME);\n}\n\nint forest_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE));\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SAVANNA_BIOME);\n}\n\nint savanna_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn savanna_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,YELLOW,FOREST_GREEN));\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n}\n\nint swamp_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,SWAMP_BIOME);\n}\n\nint swamp_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn swamp_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nint water_biome(in vec2 fragCoord,float mag,float zoom,int colors[2]){\n    float num_colors = float(colors.length());\n    int color1 = magnify(fragCoord,mag,num_colors);\n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n        neighbors = get_neighbors(fragCoord,mag,num_colors);\n    if(color1 == colors[0] && is_next_to(colors[1],neighbors)){\n    \tcolor1 = colors[1];\n    }\n    else if(color1 == colors[1] && is_next_to(colors[0],neighbors)){\n        color1 = colors[0];\n    }\n    mag -= 1.0;\n    }\n    return colors[color1];\n}\n\nint water_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn water_biome(fragCoord,mag,zoom,int[](GREEN,BLUE));\n}\t\n\n\n\nint forests_and_mountains(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,FORESTS_AND_MOUNTAINS);\n}\n\nint forests_and_mountains(in vec2 fragCoord,float mag,float zoom){\n\treturn forests_and_mountains(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,GRAY,WHITE));\n}\n\nint combined_savanna_biome(in vec2 fragCoord,float mag,float zoom){\n    int color1 = forest_biome(fragCoord,mag,mag/3.0);\n    if(color1 == FOREST_GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,TAN,FOREST_GREEN,LIME));\n    }\n    else if(color1 == WHITE){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,TAN,YELLOW,WHITE));\n    }\n    else if(color1 == GRAY){\n    \tcolor1 = glacier_biome(fragCoord,mag,zoom,int[](FOREST_GREEN,BLUE,GREEN,YELLOW,WHITE));\n    }\n    else if(color1 == YELLOW){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,LIME,FOREST_GREEN,YELLOW,LIGHTYELLOW));\n    }\n    else if(color1 == GREEN){\n    \tcolor1 = forest_biome(fragCoord,mag,zoom,int[](BLUE,GREEN,YELLOW,BEIGE,FOREST_GREEN,LIME));\n    }\n    else if(color1 == BLUE){\n    \tcolor1 = savanna_biome(fragCoord,mag,zoom,int[](SKYBLUE,YELLOW,FOREST_GREEN,BLUE,LIGHTBLUE));\n    }\n    return color1;\n}\n\nint combined_glacier_biome(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    int color1 = glacier_biome(fragCoord,mag,mag/81.0,int[](GREEN,BLUE,GRAY,WHITE,YELLOW));\n\n    return (color1 == GRAY)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](SNOW,GRAY,WHITESMOKE,WHITE,SKYBLUE))\n    :(color1 == WHITE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GRAY,LIGHTGRAY,WHITESMOKE,WHITE,SKYBLUE))\n    :(color1 == GREEN)\n   \t\t? forests_and_mountains(fragCoord,mag,zoom,int[](BLUE,SKYBLUE,SNOW,GRAY,WHITE))\n    :(color1 == BLUE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GREEN,BLUE,SKYBLUE,LIGHTBLUE,WHITE))\n    : color1;\n}\n\nint deserts_and_plains(in vec2 fragCoord,float mag,float zoom){\n    fragCoord *= zoom;\n    int color1 = glacier_biome(fragCoord,mag,mag/81.0,int[](GREEN,YELLOW,GRAY,WHITE,BLUE));\n    return (color1 == GRAY)\n    \t? forest_biome(fragCoord,mag,zoom,int[](GRAY,YELLOW,FOREST_GREEN,GREEN,TAN,LIME))\n    :(color1 == WHITE)\n    \t? forest_biome(fragCoord,mag,zoom,int[](BLUE,FOREST_GREEN,YELLOW,TAN,GREEN,LIME))\n    :(color1 == YELLOW)\n    \t? forest_biome(fragCoord,mag,zoom,int[](BLUE,YELLOW,FOREST_GREEN,TAN,GREEN,LIME))\n    :(color1 == GREEN)\n   \t\t? forests_and_mountains(fragCoord,mag,zoom,int[](TAN,LIME,SNOW,GRAY,YELLOW))\n    :(color1 == BLUE)\n    \t? glacier_biome(fragCoord,mag,zoom,int[](GREEN,YELLOW,SKYBLUE,LIGHTBLUE,BLUE))\n    :color1;\n}\n\nint combined_biome(in vec2 fragCoord,float mag,float zoom){\n    int color1 = glacier_biome(fragCoord,mag,mag/729.0);\n    return color1 == FOREST_GREEN\n    \t? forest_biome(fragCoord,mag,zoom)\n    : color1 == WHITE\n    \t? glacier_biome(fragCoord,mag,zoom)\n    : color1 == GRAY\n    \t? savanna_biome(fragCoord,mag,zoom)\n    : color1 == GREEN\n    \t? forests_and_mountains(fragCoord,mag,zoom)\n    : color1 == BLUE\n    \t? savanna_biome(fragCoord,mag,zoom,int[](LIGHTBLUE,YELLOW,FOREST_GREEN,SKYBLUE,BLUE))\n    : color1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n    //choose the biome here\n\tint biome =\n        //forest_biome\n    \t//savanna_biome\n        //glacier_biome\n        //swamp_biome\n        //combined_glacier_biome\n        //combined_biome\n        combined_savanna_biome\n        //deserts_and_plains\n        //forests_and_mountains\n    (fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 647, 684, 740, 888], [890, 890, 910, 910, 943], [946, 946, 1001, 1001, 1166], [1168, 1168, 1227, 1227, 1432], [1435, 1435, 1478, 1478, 1614], [1616, 1616, 1650, 1650, 1679], [1681, 1681, 1707, 1707, 2782], [2784, 2784, 2836, 2836, 3462], [3464, 3464, 3517, 3517, 3965], [3967, 3967, 4020, 4020, 4694], [4696, 4696, 4747, 4747, 5272], [5274, 5274, 5335, 5335, 6004], [6006, 6006, 6062, 6062, 6464], [6466, 6466, 6541, 6541, 6878], [6880, 6880, 6955, 6955, 7292], [8406, 8406, 8476, 8476, 8933], [12192, 12192, 12249, 12249, 12771]], "test": "error"}
{"id": "WlVSWd", "name": "9/2020", "author": "rimina", "description": "I started a daily shader challenge 2nd of March and I have been incrementally developing a shader since 3rd of March. Let's see where this gets me! Today I mostly red stuff and experimented. Yesterday's version: https://www.shadertoy.com/view/3tySDt", "tags": ["raymarching", "reflection", "refraction"], "likes": 1, "viewed": 54, "published": "Public", "date": "1583880076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 80\n#define E 0.001\n#define gamma vec3(2.2)\n\nconst vec3 AMBIENT = vec3(0.2, 0.4, 0.64);\nconst vec3 LC1 = vec3(0.3, 0.6, 0.8);\nconst vec3 LC2 = vec3(0.6, 0.4, 0.3);\nconst vec3 FOG = vec3(0.64, 0.62, 0.6);\n\nstruct Material{\n    vec3 lambertian;\n    vec3 specular;\n    float shininess;\n    bool reflective;\n    bool refractive;\n    float refraction;\n    int id;\n};\n\n\nMaterial getGroundMaterial(){\n    Material mat;\n    mat.lambertian = vec3(0.1, 0.4, 0.5);\n    mat.specular = FOG;\n    mat.shininess = 4.0;\n    mat.reflective = false;\n    mat.refractive = true;\n    mat.refraction = 1.333;\n    mat.id = 0;\n    \n    return mat;\n}\n\nMaterial getBlockMaterial(in vec2 id){\n    vec2 s = abs(id);\n    \n    Material mat;\n    mat.lambertian = vec3(s.xy, s.y);\n    mat.specular = vec3(s.yx, s.y);\n    mat.shininess = 40.0;\n    mat.reflective = mod(s.x, 2.0) == 0.0;\n    mat.refractive = false;\n    mat.refraction = s.y;\n    if(mod(length(id), 4.0) == 0.0){\n        mat.refractive = true;\n        mat.refraction = 1.63;\n    }\n    \n    mat.id = 1;\n    \n    return mat;\n}\n\n//------------------------------------------------\n//From HG sdf library: http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n//------------------------------------------------\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\nfloat scene(in vec3 p, out Material mat){\n    \n    float pl = fPlane(p, normalize(vec3(0.0, 1.0, 0.0)), cos(iTime*0.15)-0.5);\n    pl -= sin(noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.1));\n    \n    vec3 pp = p;\n    vec2 n = vec2(3.0, 8.0);\n    vec2 dif = n*0.5;\n    vec2 id = pMod2(pp.xz, n);\n    //id = abs(id);\n    float idx = 1.0+sin(id.x);\n    float y = abs(cos(idx)+sin(id.y))+0.5;\n\n    float sp = fBox(pp-vec3(0.0, y, 0.0), vec3(1.0, y, 1.0));\n    float guard = -fBoxCheap(pp-vec3(0.0, y, 0.0), vec3(n.x, 5.0, n.y)*0.5);\n    guard = abs(guard) + n.x*0.1;\n    \n    if(pl < sp){\n        \n        mat = getGroundMaterial();\n    }\n    else{\n        mat = getBlockMaterial(id);\n   \t}\n    \n    return min(min(sp, guard), pl);\n}\n\nbool march(in vec3 o, in vec3 d, in float far, in bool inside, out vec3 p, out Material mat){\n    float t = E;\n    float dir = inside ? -1.0 : 1.0;\n    bool hit = false;\n    for(int i = 0; i < STEPS; ++i){\n        p = o + d*t;\n        float dist = dir*scene(p, mat);\n        \n        if(abs(dist) < E || t > far){\n            if(abs(dist) < E ){\n            \thit = true;\n            }\n            break;\n        }\n        t += dist;\n    }\n    \n    return hit;\n}\n\nvec3 normal(in vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    Material mat;\n    return normalize(vec3(\n        scene(p+eps.xyy, mat) - scene(p-eps.xyy, mat),\n        scene(p+eps.yxy, mat) - scene(p-eps.yxy, mat),\n        scene(p+eps.yyx, mat) - scene(p-eps.yyx, mat)\n    ));\n}\n\nvec3 phong(in vec3 n, in vec3 d, in vec3 ld, in Material mat){\n    float lamb = max(dot(n,ld), 0.0);\n    vec3 angle = reflect(n, ld);\n    float spec = pow(max(dot(d, angle), 0.0), mat.shininess);\n    \n    return (lamb*mat.lambertian*0.5 + spec*mat.specular*0.5);\n}\n\nvec3 fog(in vec3 col, in vec3 p, in vec3 ro, in vec3 rd, in vec3 ld, in vec3 lc){\n    float d = length(p-ro);\n    float sa = max(dot(rd, -ld), 0.0);\n    float fa = 1.0-exp(-d*0.06);\n    vec3 fc = mix(FOG, lc, pow(sa, 4.0));\n    return mix(col, fc, fa);\n}\n\nvec3 shadow(vec3 p, in vec3 ld){\n    vec3 s = vec3(1.0);\n    vec3 pr = p;\n    Material mat;\n    if(march(p, ld, 40.0, false, pr, mat)){\n        s = vec3(0.1, 0.25, 0.2);\n    }\n    \n    return s;\n}\n\nbool reflection(inout vec3 d, in vec3 n, inout vec3 p, out Material mat){\n    d = reflect(d, n);\n    vec3 pr = p;\n    if(march(p+n*E*2.0, d, 40.0, false, pr, mat)){\n        p = pr;\n        return true;\n    }\n    return false;\n}\n\nbool refraction(inout vec3 d, in vec3 n, in float index, in bool inside, inout vec3 p, out Material mat){\n    d = refract(d, n, index);\n    vec3 pr = p;\n    if(march(p-n*2.0*E, d, 20.0, inside, pr, mat)){\n        p = pr;\n        return true;\n    }\n}\n\nbool primary(in vec3 o, in vec3 d, out Material mat, out vec3 p, out vec3 n){\n    p = vec3(0.0);\n    n = vec3(0.0);\n    \n    if(march(o, d, 40.0, false, p, mat)){\n        n = normal(p);\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 shade(in vec3 rd, in vec3 p, in vec3 n, in vec3 ld, in Material mat){\n    vec3 col = phong(n, rd, ld, mat);\n    vec3 nr = n;\n    vec3 pr = p;\n    vec3 dir = rd;\n    Material matr;\n    if(mat.reflective){\n        if(reflection(dir, n, pr, matr)){\n            nr = normal(pr);\n            col += phong(nr, dir, ld, matr);\n        }\n        else{\n            col *= FOG;\n        }\n    }\n    dir = rd;\n    pr = p;\n    if(mat.refractive){\n        \n        if(refraction(dir, n, 1.0/mat.refraction, true, pr, matr)){\n            nr = normal(pr);\n            col += phong(nr, dir, ld, matr);\n        }\n        if(refraction(dir, -nr, mat.refraction, false, pr, matr)){\n            vec3 nnr = normal(pr);\n            col += phong(nnr, dir, ld, matr);\n        }\n    }\n    col *= shadow(p+n*4.0*E, ld);\n    return col;\n}\n\nmat3 camera(in vec3 o, in vec3 t, in vec3 up){\n    \n    vec3 z = normalize(t-o);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    \n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv*2.0-1.0;//scaling from -1 to 1\n    q.x *= (iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(3.0, 5.0, -30.0+iTime*0.75);\n    vec3 rt = vec3(4.0-8.0*smoothstep(0.0, 200.0, iTime), -4.0, ro.z+10.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam = camera(ro, rt, up);\n    vec3 rd = normalize(cam*vec3(q, radians(60.0)));\n    \n    vec3 col = vec3(1.0);\n    \n    vec3 lp = vec3(20.0*sin(iTime*0.25)+ro.x, -10.0, 10.0*cos(iTime*0.25)+ro.z);\n    vec3 lt = ro;\n    vec3 ld = normalize(lt-lp);\n    vec3 ld2 = normalize(ro-rt);\n    \n    Material mat;\n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    \n    if(primary(ro, rd, mat, p, n)){\n        //Light 1\n        col = shade(rd, p, n, ld, mat);\n        //light 2\n        col += shade(rd, p, n, ld2, mat);\n        col *= 0.5;\n        col += AMBIENT*0.6;\n    }\n    \n    col = fog(col, p, ro, rd, ld, LC1);\n    col += fog(col, p, ro, rd, ld2, LC2);\n    col *= 0.5;\n    \n    col *= smoothstep(0.8, 0.1*0.799, distance(uv, vec2(0.5))*(0.6 + 0.1));\n    \n    col = smoothstep(0.08, 1.1, col);\n\n    col = pow(col, 1.0/gamma);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 406, 406, 637], [639, 639, 677, 677, 1068], [1070, 1172, 1192, 1192, 1227], [1228, 1264, 1292, 1292, 1373], [1374, 1425, 1458, 1470, 1498], [1500, 1574, 1630, 1630, 1672], [1674, 1702, 1739, 1739, 1830], [1883, 1909, 1929, 1929, 2208], [2211, 2211, 2252, 2252, 2936], [2938, 2938, 3031, 3031, 3399], [3401, 3401, 3424, 3424, 3677], [3679, 3679, 3741, 3741, 3943], [3945, 3945, 4026, 4026, 4199], [4201, 4201, 4233, 4233, 4397], [4399, 4399, 4472, 4472, 4626], [4628, 4628, 4733, 4733, 4877], [4879, 4879, 4956, 4956, 5116], [5118, 5118, 5192, 5192, 5933], [5935, 5935, 5981, 5981, 6123], [6125, 6125, 6182, 6232, 7423]], "test": "error"}
{"id": "wlVSWV", "name": "Star Nest with more explains", "author": "takahiroando", "description": "Based on: https://www.shadertoy.com/view/XlfGRj\n\nI would try to explain Star Nest.  I'm a beginner of this kind of fractal works.", "tags": ["kaliset", "starnest", "explain"], "likes": 13, "viewed": 202, "published": "Public", "date": "1583664615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Nest by Pablo Roman Andrioli\n\n// This content is under the MIT License.\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n        \n        // [takahiroando]\n        // you can imagine what the below loop is doing from:\n        // https://web.archive.org/web/20151217121611/http://corbinpercy.com/2d-fractals-part-2-fractal-tutorial-using-shadertoy/\n        \n        // [takahiroando]\n        // typically, kaliset seems to use average value of change.  But not sure the behind history, behind reasons...\n\t\t// Please tell me if you know in comments!\n\n\t\tfloat pa,a=pa=0.; // [takahiroando] `pa` would be past `a`, `a` might be average???\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVSWV.jpg", "access": "shaders20k", "license": "mit", "functions": [[338, 338, 395, 423, 2141]], "test": "ok"}
{"id": "wlVSz3", "name": "Orchard (Alternative Projection)", "author": "Dave_Hoskins", "description": "This is an alternative projection of my 'Abstract Orchard' [url]https://www.shadertoy.com/view/tdGGWV[/url]\nRemoves rotation distortion associated with screen projection.\nAlthough translation movements break it.\nThanks to munrocket for Quaternion code. :)", "tags": ["3d", "raymarching", "orchard", "cylindricalprojection"], "likes": 22, "viewed": 504, "published": "Public API", "date": "1583276759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Orchard (Alternative Projection)\n// by Dave Hoskins. March 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This breaks the effect a little...\n//#define MOVE_CAMERA\n\n\nint spointer;\nvec3 sunLight;\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(1., .7, .7)\n\nstruct Stack\n{\n    vec3 pos;\n    float alpha;\n    float dist;\n    int mat;\n\n};\n\n#define STACK_SIZE 8\nStack stack[STACK_SIZE];\n\n//==============================================================================\n//--------------------------------------------------------------------------\nfloat getGroundHeight(vec2 p)\n{\n    float y =(sin(p.y*.23)+cos(p.x*.18))*.8;\n    return y;\n}\n//--------------------------------------------------------------------------\nmat3 getCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//--------------------------------------------------------------------------\n// Loop the camposition around a uneven sine and cosine, and default the time 0\n// to be steep at a loop point by adding 140...\nvec3 getCamPos(float t)\n{\n    //t = sin(t*.01)*200.;\n    t+=140.;\n    vec3 p = vec3(3.0+50.0*sin(t*.03),\n                  1.5,\n                  4.0 + 50.0*cos(t*.044));\n    p.y-=getGroundHeight(p.xz);\n    return p;\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n//------------------------------------------------------------------------------\nfloat randomTint(vec3 pos)\n{\n    float r = texture(iChannel1, pos.xz*.0027).x;\n    return r+.5;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(sam, p.yz).xyz;\n\tvec3 y = texture(sam, p.zx).xyz;\n\tvec3 z = texture(sam, p.xy).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//------------------------------------------------------------------------------\nvec4 grassTexture(vec3 pos, vec3 nor)\n{\n    \n    float g = texture(iChannel1, pos.xz*.5).x;\n    float s = texture(iChannel1, pos.xz*.015).x*.2;\n    \n    \n    vec3 flower = texture(iChannel2, pos.xz*.15).xyz;\n    float rand = texture(iChannel1, pos.xz*.003).x;\n    rand *= rand*rand;\n    \n    flower =pow(flower,vec3(8, 15, 5)) *10. * rand;\n    vec4 mat = vec4(g*.05+s, g*.65, 0, g*.1);\n    mat.xyz += flower;\n\n    // Do the red ground lines...\n    pos = fract(pos);\n    mat = mix(mat, vec4(.2, 0,0,0), smoothstep(.05, .0,min(pos.x, pos.z))\n              \t\t\t\t\t  + smoothstep(.95, 1.,max(pos.x, pos.z)));\n\n    \n\treturn min(mat, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec4 barkTexture(vec3 p, vec3 nor)\n{\n    vec2 r = floor(p.xz / 5.0) * 0.02;\n    float br = texture(iChannel1, r).x;\n\tvec3 mat = texCube(iChannel3, p*.4, nor) * vec3(.4, .3, .1*br) *br;\n    mat += texCube(iChannel3, p*.53, nor)*smoothstep(0.0,.3, mat.x)*br;\n   \treturn vec4(mat, .1);\n}\n\n//------------------------------------------------------------------------------\nvec4 leavesTexture(vec3 p, vec3 nor)\n{\n    \n    vec3 rand = texCube(iChannel2, p*.15,nor);\n\tvec3 mat = vec3(0.4,1.2,0) *rand;\n   \treturn vec4(mat, .0);\n}\n\n//------------------------------------------------------------------------------\nvec4 fruitTexture(vec3 p, vec3 nor, float i)\n{\n    \n    \n    float rand = texCube(iChannel2, p*.1 ,nor).x;\n    float t = dot(nor, normalize(vec3(.8, .1, .1)));\n\tvec3 mat = vec3(1.,abs(t)*rand,0);\n    mat = mix(vec3(0,1,0), mat, i/10.);\n\n   \treturn vec4(mat, .5);\n}\n\n\n\n//------------------------------------------------------------------------------\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h)\n{\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n//------------------------------------------------------------------------------\nconst int   SEEDS = 8 ;\nconst float STEP_SIZE = 2.;\n#define SIZE .03\n\n\n// This seed code is the starfield stuff from iapafoto\n// I've just removed the alpha part...\n// https://www.shadertoy.com/view/Xl2BRR\nmat2 rotMat2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(si, co, -co, si);\n}\n\nvec3 floatingSeeds(in vec3 ro, in vec3 rd, in float tmax)\n{ \n \n    float d =  0.;\n    ro /= STEP_SIZE;\n\tvec3 pos = floor(ro),\n\t     ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + .5 + rs*0.5) * ri;\n\t\n    float dint;\n\tvec3 offset, id;\n    vec3 col = vec3(0);\n    vec3 sum = vec3(0);\n    //float size = .04;\n    \n\tfor( int i=0; i< SEEDS; i++ )\n    {\n        id = hash33(pos);\n\n        offset = clamp(id+.2*cos(id*iTime),SIZE, 1.-SIZE);\n        d = distanceRayPoint(ro, rd, pos+offset, dint);\n        \n        if (dint > 0. && dint * STEP_SIZE < tmax)\n        {\n            col = vec3(.4)*smoothstep(SIZE, 0.0,d);\n            sum += col;\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n  \n\treturn sum * .7;\n}\n\n//--------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.5, r = 0.0;\n    p*= .000001;\n    for (int i = 0; i < 5; i++)\n    {\n        r+= texture(iChannel1,p*=2.2).x*a;\n        a*=.5;\n    }\n\treturn max(r-1.5, 0.0);\n}\n//------------------------------------------------------------------------------\n// Use the difference between two cloud densities to light clouds in the direction of the sun.\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (4000. / dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*30.);    \n    t = sqrt(max((r-t)*20., .2))*2.;\n    vec3 col = vec3(t) * SUN_COLOUR;\n    // returns colour and alpha...\n    return vec4(col, r);\n} \n\n\n//------------------------------------------------------------------------------\n// Thanks to Fizzer for the space-folded tree idea...\n/// https://www.shadertoy.com/view/4tVcWR\nvec2 map(vec3 p, float t)\n{\n \n    float matID, f;\n    p.y += getGroundHeight(p.xz);\n\tfloat num = (floor(p.z/5.))*5.+(floor(p.x/5.0))*19.;\n\tp.xz = mod(p.xz, 5.0)-2.5;\n    //p.xz *= rotMat2D(p.y*num/300.); // ... No, just too expensive. :)\n    \n    float d = p.y;\n    matID = 0.0;\n\n    float s=1.,ss=1.6;\n    \n    // Tangent vectors for the branch local coordinate system.\n    vec3 w=normalize(vec3(-1.5+abs(hash11(num*4.)*.8),1,-1.));\n    vec3 u=normalize(cross(w,vec3(0,1.,0.)));\n\n    float scale=3.5;\n    p/=scale;\n    vec3 q = p;\n    // Make the iterations lessen over distance for speed up...\n    int it = 10-int(min(t*.03, 9.0));\n\n\tfloat h  = hash11(num*7.)*.3+.3;\n    vec3 uwc = normalize(cross(u,w));\n    int dontFold = int(hash11(num*23.0) * 9.0)+3;\n    \n    float thick = .2/(h-.24);\n    for (int i = 0; i < it; i++)\n    {\n\t\tf = scale*max(p.y-h,max(-p.y,length(p.xz)-.06/(p.y+thick)))/s;\n        if (f <= d)\n        {\n            d = f;\n            matID = 1.0;\n        }\n\n        // Randomly don't fold the space to give more branch types...\n        if (i != dontFold)\n        \tp.xz = abs(p.xz);\n\n        p.y-=h;\n        p*=mat3(u,uwc,w);\n        p*=ss;\n\t\ts*=ss;\n    }\n\n    float fr = .2;\n    f = (length(p)-fr)/s;\n    if (f <= d)\n    {\n        d = f;\n        matID = 2.0;\n    }\n    \n    q.y -= h*1.84;\n    h *= 1.1;\n    for (int i = 0; i < it; i++)\n    {\n      \tp = (normalize(hash31(num+float(i+19))-.5))*vec3(h, 0.1, h);\n     \tp+=q;\n        float ds =length(p)-.015;\n     \tif (ds <= d)\n        {\n            matID = 3.0+float(i);\n         \td = ds;\n        }\n    }\n\n\treturn vec2(d, matID);\n}\n\n//------------------------------------------------------------------------------\nfloat sphereRadius(float t)\n{\n\tt = abs(t-.0);\n\tt *= 0.003;\n\treturn clamp(t, 1.0/iResolution.y, 3000.0/iResolution.y);\n}\n\n//------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd, float dis)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\t\n    for (int i = 0; i < 15; i++)\n\t{\n        vec3 p =  ro + rd*t;\n\n\t\th = map(p,dis).x;\n\t\tres = min(3.*h / t, res);\n\t\tt += h;\n\t}\n    res += t*t*.08; // Dim over distance\n    return clamp(res, .6, 1.0);\n}\n\n//-------------------------------------------------------------------------------------------\n// Taken almost straight from Inigo's shaders, thanks man!\n// But I've changed a few things like the for-loop is now a float,\n// which removes the need for the extra multiply and divide in GL2\nfloat calcOcc( in vec3 pos, in vec3 nor, float d )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(float h= 0.05; h < .3; h+= .07)\n    {\n\t\tvec3 opos = pos + h*nor;\n        float d = map( opos, d ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = hash12(co)*.5;\n\tvec4 normal = vec4(0.0);\n\tvec3 p;\n    float alphaAcc = 0.0;\n\n    spointer = 0;\n\tfor( int j=min(0,iFrame); j < 140; j++ )\n\t{\n        // Check if it's full or too far...\n\t\tif (spointer == STACK_SIZE || alphaAcc >= 1.) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = sphereRadius(t);\n\t\tvec2 h = map(p, t);\n\t\tif( h.x <= sphereR)\n\t\t{\n            //h = max(h,0.0);\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-h.x+.01) / sphereR), 1.0);\n\t\t\tstack[spointer].pos = p;\n            stack[spointer].alpha = alpha;\n            stack[spointer].dist = t;\n            stack[spointer].mat = int(h.y);\n            alphaAcc += alpha;\n\t        spointer++;\n        }\n\t\tt +=  h.x+t*0.007;\n\t}\n    return alphaAcc;\n}\t\n\n//-------------------------------------------------------------------------------------------\nvec3 lighting(in vec4 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+sunLight*.01,  sunLight, d);\n    float occ = calcOcc(pos, normal, d);\n    // Light surface with 'sun'...\n\tvec3 col = mat.xyz * SUN_COLOUR*(max(dot(sunLight,normal)*.5+.2, 0.0))*sh;\n    // Ambient...\n\t\n    float fre = clamp(1.0+dot(normal,eyeDir),0.0,1.0)*.3;\n    float bac = clamp(.8*dot( normal, normalize(vec3(-sunLight.x,0.0,-sunLight.z))), 0.0, 1.0 );\n    normal = reflect(eyeDir, normal); // Specular...\n\tcol += pow(max(dot(sunLight, normal), 0.0), 16.0)  * SUN_COLOUR * sh * mat.w * occ;\n    col += bac*mat.xyz * occ;\n    col += mat.xyz * abs(normal.y)*.3*occ;\n\tcol += SUN_COLOUR * fre *.2*occ;\n\n\treturn min(col, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 getNormal2(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), 0.).x - map(p-vec3(e,0.0,0.0), 0.).x,\n                            map(p+vec3(0.0,e,0.0), 0.).x - map(p-vec3(0.0,e,0.0), 0.).x,\n                            map(p+vec3(0.0,0.0,e), 0.).x - map(p-vec3(0.0,0.0,e), 0.).x));\n}\n\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos, 0.).x;\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0).x, map(pos + eps_zero.yxy, 0.0).x,\n                          map(pos + eps_zero.yyx, 0.0).x) - c);\n}\n\n\n//------------------------------------------------------------------------------\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(.0, 0.4,0.6),(abs(dir.y)));\n    return col;\n}\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    phi *= 0.5;\n    return vec4(sin(phi) * normalize(axis), cos(phi));\n}\n\nvec3 rotate(vec3 point, vec4 rotor) {\n    vec3 rotv = rotor.xyz;\n    return qmult(rotor, vec4(point * rotor.w - cross(point, rotv), dot(point, rotv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}\n// Thaanks to DR2 for this matrix code...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//==============================================================================\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    sunLight = normalize(vec3(-.8,1.8,-1.5));\n    \n    // Camera stuff...\n    // A simple cylindrical projection with normal Y\n    float time = iTime*1.+mouseXY.x*1.0;\n    \n    #ifdef MOVE_CAMERA\n\t\n    vec3 camera = getCamPos(time*.2);\n\tvec3 lookat = getCamPos(time*.2+10.);\n\n    #else\n    \n    // Don't move the camera bodge...\n    vec3 camera = getCamPos(0.0);\n\tvec3 lookat = getCamPos(0.0);\n    lookat += vec3(40.0*sin(time * 5.28), 0., 40.0*cos(time * .28) );\n\n    #endif\n    \n    float ride = sin(time*.5)*.4;\n    \n    \n    //mat3 camMat = getCamMat(camera, lookat, 0.0);\n    //uv *= .7;\n    // I didn't want to normalize here because it'll distort across the vertical slightly...\n    // But it looks like it's needed for a unit ray length...\n//\tvec3 seedDir = camMat * normalize(vec3(0.0, uv.y,  1.));\n//\tseedDir.xz = rot2D(seedDir.xz, uv.x*1.13); // Adjusted for rotation PI (roughly!) :)\n    \n\n    // Now using Quaternions, thanks to munrocket for the Quat code.\n    // https://www.shadertoy.com/view/3stXR2\n// Quarternion version..\n//    vec3 seedDir  = normalize(vec3(0,0, 1.));\n//    vec2 rotXY = vec2(uv.x+time*.5, -uv.y+ride);\n//    vec4 rotor = qrotor(vec3(0., 1., 0.), rotXY.x);\n//    rotor = qmult(rotor, qrotor(vec3(1., 0., 0.), rotXY.y));\n    //seedDir = rotate(seedDir, rotor);\n    \n    vec3 seedDir  = normalize(vec3(0,0, 1.));\n    seedDir = viewMat (uv.y+ride, uv.x+time*.5)*seedDir;\n  \n    \n\n\tvec3 rd = seedDir;\n\n\tvec3 col = vec3(0);\n\n\tvec3 sky  = getSky(rd);\n  \n\n    // Build the stack returning the final alpha value...\n    float alpha = marchScene(camera, rd, fragCoord);\n    vec4 mat;\n    // Render the stack...\n    if (alpha > .0)\n    {\n        for (int i = 0; i < spointer; i++)\n        {\n            vec3  pos = stack[i].pos; \n            float d = stack[i].dist;\n            \n            vec3 nor =  getNormal(pos, sphereRadius(d));\n            int matID = stack[i].mat;\n            if (matID == 0) mat =  grassTexture(pos, nor);\n            else\n\t\t\t\tif (matID == 1) mat = barkTexture(pos, nor);\n            else\n                if (matID == 2) mat = leavesTexture(pos, nor);\n            else\n                mat = fruitTexture(pos, nor, float(matID - 3));\n\n            mat *= randomTint(pos);\n \n            vec3  temp = lighting(mat, pos, nor, rd, d);\n            if (matID == 3) temp=temp*.4+vec3(.15, .01,0);\n            \n            temp = mix(sky, temp , exp(-d*.01));\n            col += temp * stack[i].alpha;\n        }\n    }\n    vec4 cc = getClouds(camera, rd);\n    sky+= pow(max(dot(sunLight, rd), 0.0), 20.0)*SUN_COLOUR*.03;\n    //sky = clamp(sky, 0.0,1.);\n\tsky = mix(sky, cc.xyz, cc.w);\n\tcol += sky *  (1.0-alpha);\n    \n    float d = stack[0].dist;\n    col+= floatingSeeds(camera, rd, d);\n    \n   \n    // Sun glow effect...\n    col+=pow(max(dot(sunLight, rd), 0.0), 6.0)*SUN_COLOUR*.2;\n    \n    // Clamp and contrast...\n    //col = col * vec3(1.1, 1.1,.9);\n    col = clamp(col,0.,1.);\n    col = col*col*(3.0-2.0*col);\n\n    \n    // The usual vignette...which manages to add more vibrancy...\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.3 + 0.7*pow(90.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.5);\n\t// A nice fade in start...\n    \n    \n    col *= smoothstep(0.0, 5.0, time);\n    fragColour = vec4(sqrt(col), 1.0);\n    \n}\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVSz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[446, 604, 635, 635, 696], [697, 774, 826, 826, 1003], [1005, 1210, 1235, 1262, 1428], [1430, 1540, 1563, 1563, 1648], [1649, 1759, 1781, 1781, 1898], [1900, 1919, 1941, 1941, 2074], [2076, 2095, 2117, 2117, 2241], [2244, 2325, 2353, 2353, 2422], [2424, 2515, 2567, 2567, 2748], [2750, 2831, 2870, 2870, 3464], [3466, 3547, 3583, 3583, 3831], [3833, 3914, 3952, 3952, 4067], [4069, 4150, 4196, 4196, 4414], [4418, 4499, 4562, 4562, 4616], [4770, 4905, 4929, 4929, 5002], [5004, 5004, 5063, 5063, 5784], [5786, 5863, 5894, 5894, 6065], [6066, 6242, 6278, 6278, 6607], [6611, 6788, 6815, 6815, 8390], [8392, 8473, 8502, 8502, 8592], [8594, 8675, 8725, 8725, 8975], [8977, 9264, 9316, 9316, 9564], [9566, 9660, 9711, 9711, 10439], [10442, 10536, 10621, 10621, 11274], [11276, 11357, 11391, 11391, 11662], [11664, 11664, 11700, 11700, 11977], [11980, 12061, 12084, 12084, 12169], [12171, 12171, 12206, 12206, 12256], [12277, 12277, 12305, 12305, 12419], [12421, 12421, 12456, 12456, 12529], [12531, 12531, 12568, 12568, 12688], [12690, 12690, 12729, 12729, 12788], [12789, 12831, 12866, 12866, 13064], [13066, 13147, 13205, 13205, 16579]], "test": "error"}
{"id": "wlVXWy", "name": "point vibes", "author": "artemis", "description": "play with BEAM_X and BEAM_Y !\n\nuse t for the function and toff for animating the function.", "tags": ["2d", "oscilloscope"], "likes": 2, "viewed": 161, "published": "Public API", "date": "1583528298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TAU (3.14159265359 * 2.0)\n\n// change BEAM_X and BEAM_Y :)\n// use t wave functions and toff for dynamic phase shifts\n#define BEAM_X (cos(t * 4.0 + toff / 2.0) * 250.0 + cos(t) * 250.0) / 2.0\n#define BEAM_Y (sin(t * 3.0 - toff / 2.0) * 250.0) / 2.0\n//#define BEAM_X cos(t) * 125.0\n//#define BEAM_Y sin(t) * 125.0\n\n\n#define FALLOFF_START 1.0\n#define DECAY_START 0.1\n#define DECAY 20.0\n#define LP_STEP 0.02\n\n\nfloat sRGB(float x) {\n    if (x <= 0.00031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\n}\n\nfloat saw(float t) {\n \treturn t - floor(t);   \n}\n\nfloat tri(float t) {\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\n\nfloat electron_beam(vec2 pix, float t, float toff) {\n    float beam_x = BEAM_X;\n    float beam_y = BEAM_Y;\n\n    float dist = distance(pix, vec2(beam_x, beam_y));\n    \n    float power = 1.0 - (min(toff * 2.0 - t, DECAY) / DECAY);\n    \n    float falloff = power * FALLOFF_START;\n    \n    return min(power, power * (falloff * falloff) / (dist * dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy / 2.0;\n    \n    float scale = 512.0 / iResolution.x;\n    \n    vec2 uv = (fragCoord - center) * scale;\n        \n    float beam = 0.0;\n    float init_t = iTime - mod(iTime, LP_STEP);\n    \n    for (int i = 0; i < 400; i++) {\n        float t = float(i) * LP_STEP;\n        beam += electron_beam(uv, init_t - t, init_t / 2.0);\n    }\n    \n    vec3 beam_col = vec3(sRGB(beam * 0.25), sRGB(beam), sRGB(beam));\n    \n    fragColor = vec4(beam_col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 459, 459, 571], [573, 573, 593, 593, 621], [623, 623, 643, 643, 687], [690, 690, 742, 742, 1041], [1043, 1043, 1100, 1100, 1578]], "test": "timeout"}
{"id": "WlVXzK", "name": "knit", "author": "FabriceNeyret2", "description": "made with 1 torus section + symmetries \n\nmouse controls camera.", "tags": ["raymarching", "sdf", "knot", "short", "knitting"], "likes": 6, "viewed": 238, "published": "Public API", "date": "1583152200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/ttKSDm\n\nfloat PI = 3.14159,\n       r = .16,                                // rope radius\n       d = 1.32, e = 4.5, f = 3.;\n\n#define FRAME 0\n\n#define T(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r )        // torus\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n\nfloat knot0(vec3 p) {                           // --- half stitch\n    vec3 q; float t, a=p.y+f/4.;\n  //p.z += .4*(1.-.5*a*a),                      // depth twist\n    p.z += .4*cos(1.5*a),                       // depth twist\n    p.x = mod(p.x-d,2.*d)-d;                    // + rank periodicity\n    q = p, t = Ts(q,PI/2.,1.55*PI/2.);          // half stitch\n    return t;\n}\nfloat knot(vec3 p) {                            // --- full rank of stitch\n    vec3 q=p; float t;\n    q.y = mod(q.y,e)-f,                         // + vertical periodicity\n    t = knot0(q);                                    // top half stitch\n    q.y = -1.5-q.y,  q.x -= d, t = min(t, knot0(q)); // bottom symmetric\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9,tx,ty,tz;\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),     // ray direction\n          P = 25./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P,\n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // odd rank\n        p.y -= e/2., \n        t = min(t, knot(p)),                   // even rank\n        P += t*D;                              // step forward = dist to obj\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 518, 563, 871], [872, 872, 892, 946, 1204]], "test": "ok"}
{"id": "WlySDG", "name": "4/2020", "author": "rimina", "description": "Continuum of yesterday's shader (https://www.shadertoy.com/view/3tyXzd). Seems that this year I rather work on a one effect multiple days rather than do an effect per day. :D", "tags": ["raymarching"], "likes": 2, "viewed": 72, "published": "Public", "date": "1583445638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 128\n#define E 0.001\n#define gamma vec3(2.2)\n\nconst vec3 AMBIENT = vec3(0.2, 0.4, 0.64);\nconst vec3 LC1 = vec3(0.3, 0.6, 0.8);\nconst vec3 LC2 = vec3(0.6, 0.4, 0.3);\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat scene(in vec3 p){\n    \n    float pl = dot(p, normalize(vec3(0.0, 1.0, 0.0)))+1.0;\n    pl -= smoothstep(0.0, 1.0, noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.2));\n    \n    vec3 pp = p;\n    vec2 n = vec2(2.7, 8.0);\n    vec2 dif = n*0.5;\n    pp.xz = mod(p.xz+dif, n)-dif;\n    vec2 id = abs(floor((p.xz+dif)/n));\n    id.x = 1.0+sin(id.x);\n    \n    vec3 d = abs(pp)-vec3(1.0,\n             abs(cos(id.x)+sin(id.y))+0.5,\n             1.0);\n    float sp = length(max(max(d.x, d.y), d.z));\n    \n    vec3 gd = abs(pp)-vec3(n.x, 5.0, n.y)*0.5;\n    \n    float guard = -length(max(max(gd.x, gd.y), gd.z));\n    guard = abs(guard) + n.x*0.1;\n    \n    return min(min(sp, guard), pl);\n}\n\nfloat march(in vec3 o, in vec3 d, in float far, out vec3 p, out bool hit){\n    float t = 0.0;\n    for(int i = 0; i < STEPS; ++i){\n        p = o + d*t;\n        float dist = scene(p);\n        t += dist;\n        if(dist <= E || t >= far){\n            if(dist <= E ){\n            \thit = true;\n            }\n            break;\n        }\n    }\n    \n    return t;\n}\n\nvec3 normal(in vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    return normalize(vec3(\n        scene(p+eps.xyy) - scene(p-eps.xyy),\n        scene(p+eps.yxy) - scene(p-eps.yxy),\n        scene(p+eps.yyx) - scene(p-eps.yyx)\n    ));\n}\n\nvec3 shade(in vec3 p, in vec3 d, in vec3 ld, in vec3 lp){\n    \n    vec3 n = normal(p);\n    float lamb = max(dot(n,ld), 0.0);\n    vec3 angle = reflect(n, ld);\n    float spec = pow(max(dot(d, angle), 0.0), 20.0);\n    \n    float l = distance(p, lp);\n    bool hit = false;\n    vec3 sp = vec3(0.0);\n    float st = march(p+E*n*2.0, ld, l, p, hit);\n    float s = 1.0;\n    if(hit){\n        s = 0.0;\n    }\n    \n    return (lamb*vec3(0.5, 0.0, 0.5)*0.5 + spec*vec3(1.0, 0.5, 1.0)*0.8)*s;\n}\n\nvec3 fog(in vec3 col, in vec3 p, in vec3 ro, in vec3 rd, in vec3 ld, in vec3 lc){\n    float d = length(p-ro);\n    float sa = max(dot(rd, -ld), 0.0);\n    float fa = 1.0-exp(-d*0.05);\n    vec3 fc = mix(vec3(0.64, 0.62, 0.6), lc, pow(sa, 4.0));\n    return mix(col, fc, fa);\n}\n\nmat3 camera(in vec3 o, in vec3 t, in vec3 up){\n    \n    vec3 z = normalize(t-o);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    \n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0-1.0;//scaling from -1 to 1\n    uv.x *= (iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(0.0, 2.5, iTime);\n    vec3 rt = vec3(0.0, -4.0, 10.0+iTime);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam = camera(ro, rt, up);\n    vec3 rd = normalize(cam*vec3(uv, radians(60.0)));\n    \n    vec3 p = vec3(0.0);\n    bool hit = false;\n    float t = march(ro, rd, 40.0, p, hit);\n    vec3 col = AMBIENT * 0.6;\n    \n    vec3 lp = vec3(2.0*sin(iTime*0.5)+iTime, -4.0, 1.0+2.0*cos(iTime*0.5)+iTime);\n    vec3 lt = vec3(0.0, 0.0, -10.0);\n    vec3 ld = normalize(lt-lp);\n    vec3 ld2 = normalize(ro-rt);\n    \n    if(hit){\n        vec3 c = shade(p, rd, ld, lp);\n        c += shade(p, rd, -ld2, ro);\n        c *= 0.5;\n        col += c;\n    }\n    \n    col = fog(col, p, ro, rd, ld, LC1);\n    col += fog(col, p, ro, rd, -ld2, LC2);\n    col *= 0.5;\n\n    // Output to screen\n    fragColor = vec4(pow(col, 1.0/gamma),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 205, 225, 225, 504], [506, 506, 529, 529, 1179], [1181, 1181, 1255, 1255, 1539], [1541, 1541, 1564, 1564, 1769], [1771, 1771, 1828, 1828, 2250], [2252, 2252, 2333, 2333, 2524], [2526, 2526, 2572, 2572, 2714], [2716, 2716, 2773, 2823, 3790]], "test": "timeout"}
{"id": "wlySDV", "name": "Wobbly Heptagon", "author": "liamboone", "description": "It's a heptagon, but wobbly!", "tags": ["2d", "wobble", "blackandwhite", "heptagon"], "likes": 4, "viewed": 116, "published": "Public", "date": "1583602497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat aa_smoothstep(float lines, float v) {\n        float dl = fwidth(lines);\n        return smoothstep(v - dl, v + dl, lines);\n}\n\nvec2 aa_smoothstep(vec2 lines, float v) {\n        vec2 dl = fwidth(lines);\n        return smoothstep(v - dl, v + dl, lines);\n}\n\nfloat half_plane(vec2 uv, float t, float radius) {\n    vec2 st = uv * mat2( cos(t), sin(t),\n                        -sin(t), cos(t));\n    \n    return st.y + radius;\n}\n\nfloat flexagon(vec2 uv, float t, float radius) {\n    //t = 0.;\n    float d = (half_plane(uv, 0.*PI/3.5 + t, radius + sin(t*1.889)*0.1 + 0.1));\n    d = min(d, half_plane(uv, 1.*PI/3.5 + t, radius + sin(t*1.230)*0.1 + 0.1));\n    d = min(d, half_plane(uv, 2.*PI/3.5 + t, radius + sin(t*1.965)*0.1 + 0.1));\n    d = min(d, half_plane(uv, 3.*PI/3.5 + t, radius + sin(t*1.431)*0.1 + 0.1));\n    d = min(d, half_plane(uv, 4.*PI/3.5 + t, radius + sin(t*1.728)*0.1 + 0.1));\n    d = min(d, half_plane(uv, 5.*PI/3.5 + t, radius + sin(t*1.354)*0.1 + 0.1));\n    d = min(d, half_plane(uv, 6.*PI/3.5 + t, radius + sin(t*1.194)*0.1 + 0.1));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.* fragCoord - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.8);\n    \n    float t = iTime * 0.4 + 900.;\n    float d = flexagon(uv, t, 0.5);\n    float e = exp(d*7.)*1.;\n    float b = abs(fract(e - fract(t))*2. - 1.);\n    float mask = aa_smoothstep(b, 0.8);\n    //mask *= smoothstep(0.25, 0.15, d);\n    mask = max(mask, aa_smoothstep(d, 0.3));\n    \n    // Output to screen\n    fragColor = vec4(mix(vec3(0.2), color, mask), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 63, 63, 149], [151, 151, 192, 192, 277], [279, 279, 329, 329, 445], [447, 447, 495, 509, 1090], [1092, 1092, 1149, 1149, 1605]], "test": "ok"}
{"id": "wlySWG", "name": "mandala1 flash [spaz]", "author": "HaleyHalcyon", "description": "like a drug trip", "tags": ["spiral"], "likes": 3, "viewed": 91, "published": "Public", "date": "1583458921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fn2(float x)\n{\n    x = mod(x + 1.0, 2.0) - 1.0;\n    float n = x * x * x;\n\treturn (8. * n - 4. * x) * 3.14159265;\n}\n\nfloat fn(float x)\n{\n    float n = abs(sin(x));\n    return max((n - 0.5) * 1.5, 0.);\n}\n\nfloat vignette(float v, float d)\n{\n    return v * (0.8 - 0.7 * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    const float PI_3 = PI / 3.;\n    const float speed = 0.4;\n    float hue = fract(iTime / 2.) * PI;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    //float distance = length(uv);\n    //float distance = pow(sqrt(uv.x*uv.x+uv.y*uv.y), 1./3.);\n    float distance = log(uv.x*uv.x+uv.y*uv.y) / 2.;\n    float angle = atan(uv.y, uv.x);\n    \n    // Time varying pixel color\n    // spiral 1\n    float c1 = vignette(fn(distance * 3.0 + angle * 3.0 + fn2(iTime * speed) + PI), distance);\n    // spiral 2\n    float c2 = vignette(fn(distance * 3.0 - angle * 3.0 + fn2((iTime * speed) + 2. / 3.) + PI), distance);\n    // rings \n    float c3 = vignette(fn(angle * 16.0 + sin(iTime) * 8.0 - iTime * 0.5) * 0.5\n             + fn(distance * 8.0 + fn2((iTime * speed) + 4. / 3.) * 0.5), distance);\n    \n    // Flashing\n    const float flashIntvl = 1.2;\n    const float flashStrength = 1.5;\n    const float flashSudden = flashStrength / flashIntvl * 4.0;\n    float f1 = max(0., flashStrength - mod(iTime, flashIntvl) * flashSudden);\n    float f2 = max(0., flashStrength - mod(iTime + flashIntvl * 1.0/3.0, flashIntvl) * flashSudden);\n    float f3 = max(0., flashStrength - mod(iTime + flashIntvl * 2.0/3.0, flashIntvl) * flashSudden);\n\tc1 += f1; c2 += f2; c3 += f3;\n\n    // Output to screen\n    fragColor = vec4(\n        abs(c1 * sin(hue))        + abs(c2 * -sin(hue + PI_3)) + abs(c3 * -sin(hue - PI_3)),\n        abs(c1 * sin(hue + PI_3)) + abs(c2 * -sin(hue - PI_3)) + abs(c3 * -sin(hue)),\n        abs(c1 * sin(hue - PI_3)) + abs(c2 * -sin(hue))        + abs(c3 * -sin(hue + PI_3)),\n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 120], [122, 122, 141, 141, 207], [209, 209, 243, 243, 277], [279, 279, 336, 336, 2135]], "test": "ok"}
{"id": "WlyXRt", "name": "fukken ground", "author": "fsdfdsf", "description": "proc ground", "tags": ["proc", "ground"], "likes": 1, "viewed": 79, "published": "Public", "date": "1583319877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 coord = fragCoord + vec2(0,-50) + vec2(iTime * 100.0, 0.0);\n    \n    vec2 uv = (coord / iResolution.xy);\n    uv.x *= aspect;\n    \n    vec2 grid = floor(uv * 100.0);\n    float whiteNoise = noise(grid) * 0.2; // white noise\n    \n    float height = fbm(uv.xx) * 400.0; // random height at point\n    \n    vec4 groundBaseColor = vec4(0.7490, 0.4705, 0.1490, 1.0); // brown\n    vec4 darkGroundBaseColor = vec4(0.4490, 0.1705, 0.05490, 1.0); // dark brown\n    \n    vec4 baseColor = groundBaseColor; // dirt\n    \n    baseColor = mix(baseColor, darkGroundBaseColor, smoothstep(height - 30.0, height - 100.0, coord.y)); // deeper dirt\n    baseColor = mix(baseColor, vec4(vec3(whiteNoise),1.0), smoothstep(height - 180.0, height - 200.0, coord.y)); // bedrock\n    baseColor = mix(baseColor, vec4(0.8,0.0,0.0,1.0), smoothstep(height - 260.0, height - 300.0, coord.y)); // lava\n\n    fragColor = baseColor;\n    fragColor = mix(fragColor, vec4(vec3(whiteNoise),1.0), 0.5); // add noise\n    fragColor *= step(coord.y, height); // limit by height\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 214, 240, 240, 620], [640, 640, 664, 686, 940], [942, 942, 999, 999, 2095]], "test": "timeout"}
{"id": "WlyXWV", "name": "arctest", "author": "Del", "description": "arc", "tags": ["arc"], "likes": 2, "viewed": 216, "published": "Public API", "date": "1583571362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// testing some 2d shape extrusion\n\n#define AA 2\n#define PI\t3.1415926\n#define TAU 6.2831853\n\n// 2d distance functions by IQ\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat pizza( vec2 p, vec2 c, float rad1, float rad2)\n{\n    p.x = abs(p.x);\n    \n    vec2 c2 = vec2(c.y,-c.x);\n    \n    float l = -dot(c,p.xy);\n    float q = p.x+c.x*l;\n    float l2;\n    \n    if (max(q,-sign(p.y*c.y)) < 0.0) {\n        l = -length(p.xy);\n    }\n    \n    if (l < 0.0) {\n        l2 = length(p.xy);\n    } else {\n        l2 = dot(c2,p.xy)*sign(c.y);\n    }\n    \n    \n    \n    vec2 a = vec2(max(l2-rad2,rad1-l2),l);\n    \n    return length(max(a,0.0))+min(0.0,max(a.x,a.y));\n}\n\n\nfloat map( in vec3 pos )\n{\n    float fill = (0.5+sin(iTime)*0.5)*PI;\n    \n    vec2 uv = pos.xz;\n    \n    // arc\n    float ta = radians(90.0);\n    float tb =  fill;\n    float rb = 0.1;\n    float d1 = sdArc(uv-vec2(0.0,1.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);  \n\n    // pie\n    float d2 = sdPie(uv,vec2(sin(tb),cos(tb)),0.5);\n    \n    // horseshoe\n    float t = 3.14-fill;\n    vec2  w = vec2(0.0,0.1);\n    //float d3 = sdHorseshoe(uv+vec2(0.0,1.5),vec2(cos(t),sin(t)), 0.5, w);    \n\n    // pizza!\n    \n    \n\tfloat d3 = pizza(uv+vec2(0.0,1.5),vec2(cos(t),sin(t)),0.4,0.5);\n    \n                       \n    d1=min(d1,d2);\n    d1=min(d1,d3);\n    d1 = opExtrussion(pos.zxy,d1,0.1);\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n     // camera movement\t\n    float an = sin(iTime)*0.5;\n    float y = 2.;\n    float dist=1.5;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*8.0;\n        y-=4.0;\n        dist=3.0;\n    }\n    \n\tvec3 ro = vec3( dist*cos(an), y, dist*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 0.0;\n        for( int i=0; i<80;i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.6,0.4,0.4);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            vec3 ambcol = vec3(0.4,0.3,0.3)*amb;\n            col = ambcol + vec3(0.6,0.55,0.85)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 124, 202, 202, 386], [388, 388, 437, 437, 611], [613, 613, 672, 672, 768], [770, 770, 836, 836, 1095], [1097, 1097, 1151, 1151, 1580], [1583, 1583, 1609, 1609, 2294], [2296, 2296, 2328, 2328, 2567]], "test": "timeout"}
{"id": "ws33Ws", "name": "Triangle Noise", "author": "iaian7", "description": "Simple procedural noise combined with a triangular UV sample.", "tags": ["procedural", "geometry", "screensaver"], "likes": 6, "viewed": 173, "published": "Public", "date": "1583280362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Perlin3D( vec3 P )\n{\n\t//  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n\t// establish our grid cell and unit position\n\tvec3 Pi = floor(P);\n\tvec3 Pf = P - Pi;\n\tvec3 Pf_min1 = Pf - 1.0;\n\n\t// clamp the domain\n\tPi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n\tvec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n\t// calculate the hash\n\tvec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n\tPt *= Pt;\n\tPt = Pt.xzxz * Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n\tconst vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\tvec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n\tvec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n\tvec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n\tvec4 hashx1 = fract( Pt * highz_mod.xxxx );\n\tvec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n\tvec4 hashy1 = fract( Pt * highz_mod.yyyy );\n\tvec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n\tvec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n\t// calculate the gradients\n\tvec4 grad_x0 = hashx0 - 0.49999;\n\tvec4 grad_y0 = hashy0 - 0.49999;\n\tvec4 grad_z0 = hashz0 - 0.49999;\n\tvec4 grad_x1 = hashx1 - 0.49999;\n\tvec4 grad_y1 = hashy1 - 0.49999;\n\tvec4 grad_z1 = hashz1 - 0.49999;\n\tvec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n\tvec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n\t// Classic Perlin Interpolation\n\tvec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n\tvec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n\tvec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n\tfloat final = dot( res0, blend2.zxzx * blend2.wwyy );\n\treturn ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\n\nvec2 rotate2( vec2 xy, float r ) {\n\tvec2 ab = xy;\n\tab.x = xy.x * cos(r) - xy.y * sin(r);\n\tab.y = xy.y * cos(r) + xy.x * sin(r);\n\treturn ab;\n}\n\nfloat Screen(float a, float b) {\n\treturn 1.0 - ((1.0 - a) * (1.0 - b));\n}\n\nvec2 Rotate(vec2 xy, float angle){\n\treturn vec2(xy.x*cos(angle) - xy.y*sin(angle), xy.x*sin(angle) + xy.y*cos(angle));\n}\n\nvec2 Triangle(vec2 uv, float c){\n\tfloat r = 0.5235988;\n\tvec2 o = uv;\n\to.x = floor(uv.x * c + 0.5);\n\to.y = mix(floor(Rotate(uv * c + 0.5, r).y), floor(Rotate(uv * c + 0.5, -r).y), 0.5);\n//\to.y /= cos(0.5235988);\n//\to.y /= 0.86602539158;\n\to.y *= 1.154700555; // This shifts the Y channel back into a -0.5 to +0.5 range, otherwise scrolling the pattern actually changes the output range as well\n\treturn o / c;\n}\n\nvec2 TriangleUV(vec2 uv, float c, float r, float s){\n\tuv = Rotate(uv, r);\n\t// Fix alignment (based on the pre-rendered lines)\n\t// uv.x += (1.0/c)*0.25;\n\t// uv.y -= 0.01;\n\t// Larger numbers (over 10k) hit major issues with value rounding.\n\t// Scrolling needs to be within a much smaller range, so this is designed for a 0-1 loop.\n\t// The magic number scales the scrolling value to a compatible loop point.\n\tuv.y += s;// * 1.154700555;\n\tuv = Triangle(uv, c);\n\t// Invert the vertical scroll so the output UV values remain static, just the pattern scrolls\n\tuv.y -= s;// * 1.154700555;\n\tuv = Rotate(uv, -r);\n\tuv += 0.5;\n\n\treturn uv;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tfragColor = vec4((fragCoord/iResolution.xy).rg, 0.5, 1); // This is the default UV output\n\n\t// Declare variables (these were all dynamic inputs in the Quartz composition)\n\tfloat Time = iTime;\n\tfloat Scroll = 0.0125;\n\tfloat Depth = 0.25;\n\tfloat Rotation = -0.7854;\n\tfloat Contrast = 0.2;\n\tfloat NoiseSpeed = 1.0;\n\tvec4 Color1 = vec4(0.07451, 0.09022, 0.2471, 1.0); // Background\n\tvec4 Color2 = vec4(0.1804, 0.1922, 0.4942, 1.0); // Foreground\n\n\t// Process UV map\n\tvec2 uv = fragCoord.xy * 0.00025; // This sets a fixed resolution for the texture patterns instead of being screen dependent\n\n\t// Create triangular noise pattern (initial magic number for the scale = 11.0)\n\t// float n1 = smoothstep(-Contrast, Contrast, Perlin3D(vec3(TriangleUV(uv, 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed)));\n\t// float n2 = smoothstep(-Contrast, Contrast, Perlin3D(vec3(TriangleUV(uv*2.0+vec2(10.0, 10.0), 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed)));\n\t// n1 = mix(n1, n2, 0.5);\n\tfloat n1 = Perlin3D(vec3(TriangleUV(uv, 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed));\n\tfloat n2 = Perlin3D(vec3(TriangleUV(uv*2.0+vec2(10.0, 10.0), 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed));\n\tn1 = clamp((n1+n2)*0.5+0.5, 0.0, 1.0);\n\n\t// Final output\n\tfragColor = mix(Color1, Color2, n1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws33Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 142, 2053], [2056, 2056, 2090, 2090, 2197], [2199, 2199, 2231, 2231, 2272], [2274, 2274, 2308, 2308, 2394], [2396, 2396, 2428, 2428, 2804], [2806, 2806, 2858, 2858, 3435], [3437, 3437, 3489, 3489, 4794]], "test": "ok"}
{"id": "wsfcDM", "name": "20200323_集中線", "author": "FMS_Cat", "description": "ババーン\n\nThis shader is Memix Ready!", "tags": ["2d", "noise", "webcam", "memix"], "likes": 21, "viewed": 1407, "published": "Public", "date": "1584889645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANIMATE 10.0\n#define INV_ANIMATE_FREQ 0.05\n#define RADIUS 1.3\n#define FREQ 10.0\n#define LENGTH 2.0\n#define SOFTNESS 0.1\n#define WEIRDNESS 0.1\n\n#define ASPECT_AWARE\n\n#define lofi(x,d) (floor((x)/(d))*(d))\n\nfloat hash( vec2 v ) {\n  return fract( sin( dot( v, vec2( 89.44, 19.36 ) ) ) * 22189.22 );\n}\n\nfloat iHash( vec2 v, vec2 r ) {\n  vec4 h = vec4(\n    hash( vec2( floor( v * r + vec2( 0.0, 0.0 ) ) / r ) ),\n    hash( vec2( floor( v * r + vec2( 0.0, 1.0 ) ) / r ) ),\n    hash( vec2( floor( v * r + vec2( 1.0, 0.0 ) ) / r ) ),\n    hash( vec2( floor( v * r + vec2( 1.0, 1.0 ) ) / r ) )\n  );\n  vec2 ip = vec2( smoothstep(\n    vec2( 0.0 ),\n    vec2( 1.0 ),\n    mod( v * r, 1.0 ) )\n  );\n  return mix(\n    mix( h.x, h.y, ip.y ),\n    mix( h.z, h.w, ip.y ),\n    ip.x\n  );\n}\n\nfloat noise( vec2 v ) {\n  float sum = 0.0;\n  for( int i = 1; i < 7; i ++ ) {\n    sum += iHash(\n      v + vec2( i ),\n      vec2( 2.0 * pow( 2.0, float( i ) ) ) ) / pow( 2.0, float( i )\n    );\n  }\n  return sum;\n}\n\n// Memix boilerplate getuv function\nvec2 getuv( in vec2 p ) { return vec2( 0.5+(p.x-0.5)*iResolution.z, 1.0-p.y ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef ASPECT_AWARE\n  vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.xy;\n#else\n  vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.y;\n#endif\n  vec2 puv = vec2(\n    WEIRDNESS * length( uv ) + ANIMATE * lofi( iTime, INV_ANIMATE_FREQ ),\n    FREQ * atan( uv.y, uv.x )\n  );\n  float value = noise( puv );\n  value = length( uv ) - RADIUS - LENGTH * ( value - 0.5 );\n  value = smoothstep( -SOFTNESS, SOFTNESS, value );\n\n  vec4 tex = texture( iChannel0, getuv( fragCoord.xy / iResolution.xy ) );\n  vec3 color = mix( tex.xyz, vec3( 1.0 ), value );\n  fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 235, 235, 305], [307, 307, 338, 338, 772], [774, 774, 797, 797, 984], [986, 1022, 1047, 1047, 1102], [1104, 1104, 1161, 1161, 1766]], "test": "error"}
{"id": "wsfcDS", "name": "Interference Blobs", "author": "KJK", "description": "I put a bunch of circular waves evenly spaced around the origin and moved them in and out. I ran the sum of the waves through a smoothstep to make discrete blobs.", "tags": ["interferencepattern"], "likes": 6, "viewed": 90, "published": "Public", "date": "1585448910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float TAU = 2.0 * 3.14159;\n    float speed = 6.0;\n    float range = 100.0;\n    float waveFrequency = 2.0;\n    float waveSmoothness = 1.0;\n    float invScale = 80.0;\n    float dropletCount = 5.0;\n    //float rotationSpeed = 0.1;\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv *= invScale;\n    \n    //float ct = cos(iTime * rotationSpeed);\n    //float st = sin(iTime * rotationSpeed);\n    //uv = vec2(ct * uv.x + st * uv.y, st * uv.x - ct * uv.y);\n\n    float brightness = 0.0;\n    for (float i = 0.0; i < dropletCount; i++) {\n        float angle = TAU * i / dropletCount;\n        float dist = (0.5 + 0.5 * sin(iTime * speed / range)) * range;\n        vec2 pos = vec2(sin(angle), cos(angle)) * dist;\n        float distFromDrop = length(uv.xy - pos);\n        float height = 0.5 + 0.5 * cos(waveFrequency * distFromDrop);\n        brightness += height;\n    }\n    brightness /= dropletCount;\n    \n    vec2 gradient = vec2(dFdx(brightness), dFdy(brightness));\n    float slope = length(gradient);\n    \n    // If the wave is steep here, compensate by smoothing the step.\n    float r = waveSmoothness * slope;\n    \n    // The larger r is, the wider the interpolation region is and the smoother the step is.\n    brightness = smoothstep(0.5 - r, 0.5 + r, brightness);\n    \n    fragColor = vec4(brightness);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1388]], "test": "ok"}
{"id": "wsfcR2", "name": "pulsing hole", "author": "rrrzzz", "description": ".", "tags": ["beat"], "likes": 3, "viewed": 153, "published": "Public", "date": "1585141345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n  \tvec3 color;\n\tfloat d;\t\n\t\n\tfloat deg = 3.14 * iTime;\n\t    \n\tfloat x = cos(deg) * 0.1;\n\tfloat y = sin(deg) * 0.1;\t\n\t\n\td = distance(vec2(cos(x) * 0.2, sin(y) * 0.2), vec2(.0)) + 0.09;\n\t\n    float m = mod(iTime * 0.03, 2.0);\t\n    float p = (smoothstep(0.8, 1.2, m) - smoothstep(1.6, 2.0, m)) * 30.6 + 1.4;\n    \n\td *= length(min(abs(uv) * (abs(sin(iTime * 0.2))) * 0.3, 0.1) * p);    \n\tfloat mul = ((sin(iTime * 0.8)) * 5.0);\n\tfloat col = smoothstep(0.0, 0.7, fract(d * mul)) - smoothstep(0.7, 1.0, fract(d * mul));\n    \n\td /= length(max(abs(uv) - 0.0001, 0.225));    \n\tmul = 10.0;    \n\tcol /= smoothstep(0.0, 0.7, fract(d * mul)) - smoothstep(0.7, 1.0, fract(d * mul));   \n    \n    fragColor = vec4(vec3(col), 1.0);\t\t\t\t\t\t\t\t\t\t\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 99, 891]], "test": "ok"}
{"id": "wsfcR8", "name": "param_v009", "author": "darkczar", "description": "parametric epicycles", "tags": ["learning", "parametricepicycles"], "likes": 1, "viewed": 77, "published": "Public", "date": "1584114753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<1000;i++)\n    {\n        di = float(i)*.03;\n        curve_p.x = .3*sin(.4*iTime)+.05*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = .3*cos(.4*iTime)+.05*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .06*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = min(d, length(p-curve_p)+.4*rand(vec2(di,di)));\n  \n    }\n\n    vec3 col = vec3(2.*d*d,.008 + .25*sin(.001*d*d+.1*length(p)), .25*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,8.0))));\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0); \n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 342, 392, 1397]], "test": "timeout"}
{"id": "wsfcRH", "name": "dotts on screen", "author": "fille", "description": "some circles on screen", "tags": ["circles"], "likes": 1, "viewed": 38, "published": "Public", "date": "1584128724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 fw =  fwidth(fragCoord.xy);\n\n    float freq = 10.0;\n    float onesqare = 1.0/freq;\n    float selectedRow = mod(iTime*2.0,9.0);\n\tvec4 color = vec4(0.0,0.0,0.0,1.0);\n\tvec2 fuzz = fw*freq;fragCoord;\n\tfloat fuzzMax = max(fuzz.s,fuzz.t);\n  \n    vec2 res = fragCoord.xy/iResolution.xy;\n\tvec2 p = fract((res)*freq);\n    \n    vec2 current = res;\n\n\tfloat circleRadius_ =0.3;\n\tvec2 circleCenter = vec2(0.5,0.5);\n\tfloat dist = length(p - circleCenter );\n\t\tfloat circle = smoothstep(circleRadius_, circleRadius_ - 0.15, dist);\n\t\n    \n\tcolor = vec4(circle,circle,circle,1);\n    if(circle != 0.0 && current.x > selectedRow*onesqare  && current.x < (selectedRow+1.0)*onesqare) {\n        \n        color = vec4(1,0,0,1);\n        \n    }\n\t\n     \n   \n     fragColor = color;   \n\t\n}\n    // Output to scree", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 838]], "test": "ok"}
{"id": "wsfcW2", "name": "Glitchdream", "author": "Leria", "description": "Here is my first Shadertroy shader. The effect on the screen looks like a glitch in the matrix. Colors remind a dream but also old days (80's).  It's an evolutive cyberpunk texture adapted for holograms.", "tags": ["beginner", "random", "glitch", "green", "purple", "dream"], "likes": 2, "viewed": 104, "published": "Public", "date": "1585598848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Copyright Erwan LERIA\n//Free for any use, just cite my name.\n\n//Modifying theta change the speed\n\n#define PI 3.1410 \n#define theta 5.8 \n\nvec3 r1(vec3 v)\n{\n\treturn 0.3*cos(v);\n}\n\nvec3 r2(vec3 v)\n{\n\treturn iTime*v.xyz;\n}\n\nfloat morphx(float x)\n{\n\treturn x;\n}\n\n\nfloat morphy(float y)\n{\n\tif(0. > cos(y) && cos(y) < PI/2.0)\n    {\n    \treturn tan(y);\n    }\n    \n    return -y;\n}\n\nfloat morphz(float z)\n{\n    if(0. > sin(z) && sin(z) < PI/2.0)\n    {\n    \treturn -z;\n    }\n    \n    return tan(z);\n}\n\nvec3 morph_coord(vec3 v)\n{\n\tvec3 outv = v;\n    outv.x = morphx(v.x);\n    outv.y = morphy(v.y);\n    outv.z = morphz(v.z);\n    \n    return outv;\n}\n\nvec3 r3(vec3 v)\n{\n   morph_coord(v);\n   return v;\n}\n\nvec3 noise(vec3 coord)\n{\n    coord = r1(coord);\n    coord = r2(coord);\n    coord = r3(coord);\n    return coord;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n\tif(fragCoord.x < iResolution.x/4.)\n    {\n        col = 0.2+sin(theta)*sin(iTime+noise(fragCoord.xyx));\n    }\n    \n    else if(fragCoord.x > iResolution.x/4. && (fragCoord.x < iResolution.x/2.))\n    {\n        col = 0.25+sin(theta)*sin(iTime+noise(fragCoord.xyx));\n    }\n    \n        else\n    {\n        col = 0.3+sin(theta)*sin(iTime+noise(fragCoord.xyx));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 156, 156, 178], [180, 180, 197, 197, 220], [222, 222, 245, 245, 258], [261, 261, 284, 284, 374], [376, 376, 399, 399, 492], [494, 494, 520, 520, 638], [640, 640, 657, 657, 691], [693, 693, 717, 717, 806], [808, 808, 865, 865, 1299]], "test": "ok"}
{"id": "WsfcW4", "name": "param_v26", "author": "darkczar", "description": "epicycles", "tags": ["psychedelic", "learning"], "likes": 2, "viewed": 38, "published": "Public", "date": "1584749871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    float d2 = 10002.0;\n    float d3 = 10003.0;\n    float di = 0.;\n    float threshold = 0.00000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    float black_threshold=.05; //-.5*nsin(iTime*.6);\n    //float ga=0.;\n    //float ba=0.;\n    //float rb=0.;\n    //float gb=0.;\n    //float bb=0.;\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*2.;\n        curve_p.x = -.1*sin(.6*iTime)+.15*float(di)*sin(float(di)+.4*iTime) +.03*float(di)*sin(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.9*iTime);\n        curve_p.y = -.1*cos(.6*iTime)+.15*float(di)*cos(float(di)+.4*iTime) +.03*float(di)*cos(4.0*di+.75*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.9*iTime);\n        dtemp = pow(length(p-curve_p),8.);\n        if (i==0)\n        {\n            //d=max(threshold + .01*nsin(iTime),dtemp) - threshold + .01*nsin(iTime);\n            d=max(threshold,dtemp); // - threshold; // + .01*nsin(.1*iTime);\n            d=mod(log(d),2.0 +.2*sin(iTime));\n            if(d<black_threshold) d=0.;\n        } \n        else if (i==1)\n        {\n            //d2=max(threshold + .01*nsin(iTime+6.28/3.0),dtemp) - threshold + .01*nsin(iTime+6.28/3.0);\n            d2=max(threshold,dtemp); // - threshold; // + .01*nsin(.1*iTime+6.28/3.0);\n\n            d2=mod(log(d2),2.0 +.2*cos(iTime));\n            if(d2<black_threshold) d2=0.;\n        } \n        else if (i==2)\n        {\n            //d3=max(threshold + .01*nsin(iTime + 2.*6.28/3.0),dtemp)- threshold + .01*nsin(iTime + 2.*6.28/3.0);\n            d3=max(threshold,dtemp);//- threshold; // + .01*nsin(.1*iTime + 2.*6.28/3.0);\n\n            d3=mod(log(d3),2.0);\n            if(d3<black_threshold)d3=0.;\n        }\n        \n        \n        \n        r = d*d -d3;\n        g = d2*d2*.8 - d;\n        b = d3*d3-d2;\n       \n        \n  \n    }\n    //r = .33*r + .33*ra + .33*rb;\n    //g = .33*g + .33*ga + .33*gb;\n    //r = d; // - .1*(.25 - .25*pow(dot(p, curve_p),2.0)*(.5+.5*sin(iTime*.4)));\n    //g = (1.0-d); //*sin(2.1*d*d+.1*length(p))*.006*normalize(dot(p,curve_p*iTime*2.));\n    //b=.06; //*cos(iTime*.8 - .5*pow(d,2.0)) +.0002*(dot(p,normalize(curve_p - .5*vec2(iTime*-.05, iTime*.05))));\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 165, 215, 2778]], "test": "ok"}
{"id": "WsfcW8", "name": "Health Check", "author": "dr2", "description": "Fast android virus check (mouseable)", "tags": ["robot", "android", "virus"], "likes": 13, "viewed": 303, "published": "Public API", "date": "1584616425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Health Check\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, ltDir, vnCylOut;\nfloat dstFar, tCur, bCylRad, bCylHt, dCylOut, tPhs, wDisp, gGap;\nint idObj;\nconst int idBod = 1, idEye = 2, idCen = 3, idCenIn = 4, idCor = 5, idCorLt = 6, idDoor = 7;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat RobDf (vec3 p)\n{\n  vec3 q;\n  float dMin, rAngH, rAngL, rAngA, d, ah, s;\n  s = sin (2. * pi * mod (0.5 * tPhs, 1.));\n  rAngH = -0.7 * s;\n  rAngA = 1.1 * s;\n  rAngL = 0.5 * s;\n  dMin = dstFar;\n  p.y -= 0.25;\n  q = p; \n  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y - 0.2);\n  q = p; \n  q.y -= 1.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.75));\n  q = p;  \n  q.x = abs (q.x) - 1.05; \n  q.y -= 2.;\n  q.yz = Rot2D (q.yz, rAngA * sign (p.x));\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;\n  ah = rAngH;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.3;\n  q.y -= 3.1;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;\n  q.x = q.x - 0.4;  \n  q.y -= 0.95;\n  q.yz = Rot2D (q.yz, - rAngL);\n  q.y -= -0.65;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  q = p;\n  q.x = - q.x - 0.4;  \n  q.y -= 0.95;\n  q.yz = Rot2D (q.yz, rAngL);\n  q.y -= -0.65;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  DMINQ (idBod);\n  q = p;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x); \n  q -= vec3 (0.4, 2.7, 0.7);  \n  d = PrSphDf (q, 0.15);\n  DMINQ (idEye);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, r, a, aa, s;\n  dMin = dstFar;\n  q = p;\n  r = length (p.xz);\n  q.xz = Rot2D (p.xz, pi / 6.);\n  aa = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  a = floor (3. * aa + 0.5);\n  q.xz = Rot2D (q.xz, 2. * pi * a / 3.);\n  qq = q;\n  s = sign (a + 0.01);\n  q.x = (a >= 0.) ? mod (q.x + wDisp * s + a * gGap, 2. * gGap) - gGap :\n     mod (q.x + wDisp * s + 0.5 * gGap, gGap) - 0.5 * gGap;\n  q.xz = Rot2D (q.xz, - pi * s / 2.);\n  dMin = min (dMin, max (RobDf (q), r - bCylRad));\n  q = qq;\n  q.x += bCylRad;\n  q.y -= 2.4;\n  d = PrRoundBoxDf (q, vec3 (1., 2.4, 4.), 0.05);\n  DMINQ (idDoor);\n  q = qq;\n  q.y -= 1.9;\n  d = length (q.yz) - 2.4;\n  q = p;\n  q.y -= 2.4;\n  d = max (PrRoundCylDf (q.xzy, 5., 0.05, 2.4), - d);\n  DMINQ (idCen);\n  d = PrRoundCylDf (q.xzy, 3., 0.03, 2.4);\n  DMINQ (idCenIn);\n  q.y -= 2.7;\n  d = PrRoundCylDf (q.xzy, 3., 0.1, 0.3);\n  DMINQ (idCor);\n  q.y -= 0.6;\n  q.xz = Rot2D (p.xz, 2. * pi * floor (12. * aa + 1.5) / 12.);\n  q.x += 3.;\n  d = PrSphDf (q, 0.4);\n  DMINQ (idCorLt);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.04 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.25 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV, sh;\n  float ga = 2.39996; // = pi * (3 - sqrt(5))\n  InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = ro.y / bCylHt - 1.;\n    hhy = abs (hy) - 0.4;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (60. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = vec3 (0.4, 0.5, 0.6) * (0.8 + 0.2 * cos (0.1 * 2. * pi * tCur));\n      else col = vec3 (0.4, 0.5, 0.3) * (0.5 + 0.5 * max (dot (vn, ltDir), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.7, 0.8, 0.7);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        rg = ShStagGrid (16. * vec2 (12. * aa, hy));\n        col *= rg.y;\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, ltDir), 0.)) +\n         0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    qw = Rot2D (ro.xz, pi / 6.);\n    qw = Rot2D (qw, 2. * pi * (floor (3. * ((length (qw) > 0.) ? atan (qw.y, - qw.x) /\n       (2. * pi) : 0.) + 0.5) / 3.));\n    if (abs (qw.y) > 2.) {\n      b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n      qh = HexGrid (ro.zx);\n      f = max (length (qh.xy) - 0.5, 0.) * b;\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n      vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n      vn = VaryNf (64. * ro, vn, 0.2 * b);\n      col = vec3 (0.72, 0.75, 0.72) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n         (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    } else {\n      vn = vec3 (0., 1., 0.);\n      col = vec3 (0.65, 0.65, 0.6) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.02, mod (qw.y, 1.)));\n    }\n    col *= 0.1 + 0.9 * smoothstep (4., 5., length (ro.xz));\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.1 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    ro += dCylOut * rd;\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    for (float n = float (VAR_ZERO); n < 128.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0.2, 0.2, 0.4), vec3 (1., 1., 0.7), f);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, tCyc, r;\n  gGap = 4.;\n  tCyc = 4.;\n  tPhs = mod (tCur, tCyc);\n  wDisp = 2. * (gGap / tCyc) * tCur;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    r = length (ro.xz);\n    if (idObj == idBod) col4 = (ro.z < 0.) ? vec4 (0.7, 0.7, 0.8, 0.1) : \n       ((ro.x < 0.) ? vec4 (0.8, 0.2, 0.2, 0.1) : vec4 (0.2, 0.8, 0.2, 0.1));\n    else if (idObj == idEye) col4 = (ro.z < 0.) ? vec4 (0.9, 0.9, 1., -1.) : \n       ((ro.x < 0.) ? vec4 (1., 0.3, 0.3, -1.) : vec4 (0.3, 1., 0.3, -1.));\n    else if (idObj == idCen) col4 = vec4 (0.6, 0.6, 0.8, 0.1) * (0.9 + 0.1 *\n       SmoothBump (0.1, 0.9, 0.02, mod (60. * atan (ro.z, - ro.x) / (2. * pi), 1.))) *\n       (0.5 + 0.5 * smoothstep (3., 3.5, r));\n    else if (idObj == idCenIn) col4 = vec4 (1., 1., 0.5, 0.) *\n       step (0.45, abs (mod (2. * tCur / tCyc + 0.45, 1.) - 0.5));\n    else if (idObj == idDoor) col4 = ((ro.z < 0.) ? vec4 (1., 1., 1., 0.1) : \n       ((ro.x < 0.) ? vec4 (1., 0., 0., 0.1) : vec4 (0., 1., 0., 0.1))) *\n       (0.3 + 0.5 * smoothstep (2.9, 3., length (qHit.yz + vec2 (1., 0.))));\n    else if (idObj == idCor) col4 = (floor (mod (2. * tCur / tCyc + 0.25, 2.)) == 0.) ?\n       vec4 (1., 0.5, 0.5, 0.1) : vec4 (0.5, 1., 0.5, 0.1);\n    else if (idObj == idCorLt) col4 = (floor (mod (2. * tCur / tCyc + 0.25, 2.)) == 0.) ?\n       vec4 (1., 0., 0., -1.) * (0.7 + 0.3 * sin (8. * pi * tCur)) : vec4 (0., 1., 0., -1.);\n    col = (col4.a >= 0.) ? col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.) : col4.rgb * (0.7 - 0.3 * dot (rd, vn));\n    if (idObj == idBod) col += 0.2 * BgCol (ro, reflect (rd, vn));\n    if (ro.y < 4.5 && idObj != idCenIn) col *= 0.1 + 0.9 * smoothstep (4., 5., r);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bCylRad = 48.;\n  bCylHt = 12.;\n  az = 0.67 * pi + (1.2/16.) * pi * (floor (0.2 * tCur) +\n     smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 3., -0.99 * bCylRad);\n  zmFac = 2.8;\n  dstFar = 2. * bCylRad;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[854, 854, 876, 876, 2023], [2025, 2025, 2047, 2047, 3089], [3091, 3091, 3124, 3124, 3308], [3310, 3310, 3331, 3331, 3586], [3588, 3588, 3625, 3625, 3854], [3856, 3856, 3890, 3890, 4411], [4413, 4413, 4439, 4439, 4790], [4792, 4792, 4823, 4823, 8326], [8328, 8328, 8363, 8363, 10238], [10240, 10240, 10296, 10296, 11454], [11456, 11456, 11502, 11502, 11549], [11551, 11551, 11584, 11584, 11611], [11613, 11613, 11670, 11670, 11834], [11836, 11836, 11860, 11860, 12090], [12092, 12092, 12116, 12116, 12176], [12178, 12178, 12201, 12201, 12334], [12336, 12336, 12372, 12372, 12578], [12580, 12580, 12610, 12610, 12723], [12725, 12725, 12782, 12782, 12865], [12899, 12899, 12923, 12923, 12960], [12962, 12962, 12986, 12986, 13098], [13100, 13100, 13125, 13125, 13311], [13313, 13313, 13342, 13342, 13554], [13556, 13556, 13595, 13595, 13775]], "test": "error"}
{"id": "WsfcWj", "name": "electrogel 14", "author": "haptix", "description": "electrogel 14", "tags": ["electrogel14"], "likes": 7, "viewed": 379, "published": "Public API", "date": "1585602980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nfloat smAdd(float m1, float m2, float k)\n{\n    float h = clamp(.5 + .5*(m2 - m1)/k, 0., 1.);\n    return mix(m2, m1, h) - k*h*(1. - h);\n}\n\nfloat bump(vec3 p, float offs)\n{\n    return .25*sin(p.x*3.4 + (iTime + offs)*.73) *\n        \t   cos(p.y*3.7 + (iTime + offs)*.81) *\n        \t  (sin(p.z*4.0 + (iTime + offs)*.83) + cos(p.z*2.9 + (iTime + offs)*.57));\n}\n\nvec2 sph(vec3 p, float s, float offs, float matId)\n{\n    return vec2(length(p + bump(p, offs)) - s, matId);\n}\n\nvec2 map(vec3 p)\n{   \n    float matId1 = 0.;\n    float matId2 = 1.;\n    float dist = 1.1*sin(iTime*.7) + 3.;\n    vec2 m1 = sph(vec3(p.x + dist/2., p.y, p.z), 1.5, 133., matId1);\n    vec2 m2 = sph(vec3(p.x - dist/2., p.y, p.z), 1.5, 0., matId2);\n    float matmix = mix(matId1, matId2, abs(m2.x - m1.x));\n    vec2 m = vec2(smAdd(m1.x, m2.x, .6), matmix);\n    glo += .1 / (1.5 + m.x*m.x*5000.);\n    return m;\n}\n\nfloat sss(vec3 p, vec3 l, float d)\n{\n\treturn smoothstep(0., 1., map(p + l*d).x/d);\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 10.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .0001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .2;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = -1.;\n\treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 ro = vec3(cos(.15*iTime),\n                   sin(-.15*iTime),\n                   -3.5);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(.07, .07, -10.);\n    vec3 lightPos2 = vec3(-5.07, -5.07, -12);\n  \tvec3 lightPos3 = vec3(5.07, -5.07, -12);\n    \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .02);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = .7 * vec3(sin(.151*((iTime+180.) + 44.)),\n                       \t\tsin(.227*((iTime+180.) + 55.)),\n                       \t\tsin(.317*((iTime+180.) + 79.))) + 1.35;\n\n    if (t.y > -1.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        vec3 lightDir2 = normalize(lightPos2 - hit);\n        vec3 lightDir3 = normalize(lightPos3 - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n\n        vec3 l = -lightDir;\n        float sub = 0.;\n        float steps = 20.;\n\n        for(float i = 1.; i < steps; i++)\n        {\n            float dist = i*5. / steps;\n            sub += sss(hit, l, dist);\n        }\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float spec2 = pow(max(dot(rd, reflect(norm, lightDir2)), 0.), 80.);\n        float spec3 = pow(max(dot(rd, reflect(norm, lightDir3)), 0.), 45.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n\n        vec3 col = .3 * colRot * (t.y + .3);\n        col += sub * colRot * .35;\n        col *= .15 * ao;\n        col += .65 * diff * (colRot.yzx/(t.y*6.));\n        col += .7 * spec * vec3(1., 1., 1.);\n        col += .7 * spec2 * vec3(1., 1., 1.);\n        col += .9 * spec3 * vec3(1., 1., 1.);\n        \n        col += glo*.01*colRot.xzy*(t.y);\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*.01*colRot.yzx*t.y, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 81, 81, 175], [177, 177, 209, 209, 394], [396, 396, 448, 448, 505], [507, 507, 525, 525, 914], [916, 916, 952, 952, 1000], [1002, 1002, 1029, 1029, 1263], [1265, 1265, 1320, 1320, 3596]], "test": "timeout"}
{"id": "WsfyDn", "name": "param_21", "author": "darkczar", "description": "epicycles", "tags": ["learning"], "likes": 3, "viewed": 47, "published": "Public", "date": "1584498975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<2000;i++)\n    {\n        di = float(i)*.03;\n        curve_p.x = -.1*sin(.3*iTime)+.05*float(di)*sin(float(di)+.2*iTime) +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = -.1*cos(.3*iTime)+.05*float(di)*cos(float(di)+.2*iTime) +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = min(d, length(p-curve_p));\n  \n    }\n    float r =5.*d*d + (.025 - .025*pow(dot(p, curve_p),2.0));\n    float g = .008 + .5*sin(.001*d*d+.1*length(p))+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=.025*abs(.15+.13*cos(iTime*.8 - 2.5*pow(d,8.0))) +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 1300]], "test": "timeout"}
{"id": "wsfyR4", "name": "Torus Mesh Circuit", "author": "gaz", "description": "3d", "tags": ["torus", "mesh", "stella"], "likes": 19, "viewed": 245, "published": "Public", "date": "1584269933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float G1=0.0, G2=0.0;\n\nvec3 rot(vec3 p,vec3 a,float t) \n{\n\ta=normalize(a);\n\tvec3 v = cross(a,p),u = cross(v,a);\n\treturn u * cos(t) + v * sin(t) + a * dot(p, a);   \n}\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k ) \n{\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n\nfloat deTetra(vec3 p) \n{\n\tvec2 g=vec2(-1,1)*0.577;\n\treturn pow(\n\t\tpow(max(0.0,dot(p,g.xxx)),8.0)\n\t\t+pow(max(0.0,dot(p,g.xyy)),8.0)\n\t\t+pow(max(0.0,dot(p,g.yxy)),8.0)\n\t\t+pow(max(0.0,dot(p,g.yyx)),8.0),\n\t\t0.125);\n}\n\nfloat deStella(vec3 p) \n{\n    p=rot(p,vec3(1,2,3),iTime*3.0);\n\treturn smin(deTetra(p)-1.0,deTetra(-p)-1.0,0.05);\n}\n\n#define Circle 2.0\nvec2 hash2( vec2 p )\n{\n    p = mod(p, Circle*2.0); \n\treturn fract(sin(vec2(\n        dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3))\n    ))*43758.5453);\n}\n\n// https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi(vec2 x)\n{\n    x*=Circle;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\to = 0.5 + 0.5*sin( iTime*0.3 + 6.2831*o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\to = 0.5 + 0.5*sin( iTime*0.3 + 6.2831*o );\n        vec2 r = g + o - f;\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n}\n\nfloat voronoiTorus(vec3 p){\n    vec2 size = vec2(12,5);\n    vec2 q = vec2(length(p.xz) - size.x, p.y);\n\tvec2 uv=vec2(atan(p.z, p.x),atan(q.y, q.x))/3.1415;\n\tvec3 vr=voronoi(uv*vec2(20,8));\n    vec2 p2=vec2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));\n    //vec2 p2=vec2(length(vr.yz)-0.5, sdTorus(p,size));\n\treturn lpNorm(p2,5.0)-0.1; \n}\n\nfloat map(vec3 p)\n{   \n    vec3 offset = vec3(6,0,0);\n    float de = min(voronoiTorus(p-offset),voronoiTorus(p.xzy+offset));\n    vec3 co = vec3(cos(iTime),0,sin(iTime))*10.0;\n    float s1= abs(sin(iTime))*3.0+2.0;\n    float deSG = min(deStella((p-co-offset)/s1),deStella((p-(co-offset).xzy)/s1))*s1;\n\tG1 +=0.1/(0.1+deSG*deSG*10.0);\n    float deS = min(deStella(p-co-offset),deStella(p-(co-offset).xzy));\n \tG2 +=0.1/(0.1+deS*deS*10.0);\n    de=min(de,deS);    \n    return de;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 5.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(0,20,50);\n    ro= vec3(cos(iTime*0.3+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.5+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\n    vec3 w = normalize(-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\n    vec3 col= mix(vec3(0),vec3(0.05,0.05,0.1),length(uv*vec2(1,1.2))*0.25);\n    float t=5.0,d;\n    for(int i=0;i<64;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001||t>50.0) break;\n    }\n    if(d<0.001)\n    {\n        col=vec3(0.5,0.5,0.55);\n        vec3 p=ro+rd*t;\n        vec3 n = calcNormal(p);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(n, li), 0.0, 1.0);\n        dif *= softshadow(p, li);\n        col *= max(dif, 0.3);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd + 2.2 * (1.0 - rimd);\n    \tcol *= frn*vec3(0.6,0.1,0.3);\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.0,0.6,1.0)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n     \tcol+=vec3(1,0.2,0)*G1*.05;\n    \tcol+=vec3(1,0.1,0)*G2*.03*(sin(iTime*5.0)*0.5+0.6);\n       \tcol = mix( col, vec3(0.2), 1.0-exp( -0.0005*t*t ) );\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 165], [167, 167, 198, 198, 256], [258, 258, 291, 291, 356], [358, 358, 400, 400, 484], [486, 486, 510, 510, 697], [699, 699, 724, 724, 813], [834, 834, 856, 856, 998], [1000, 1041, 1063, 1063, 1862], [1864, 1864, 1891, 1891, 2198], [2200, 2200, 2219, 2219, 2675], [2677, 2677, 2704, 2704, 2856], [2858, 2858, 2900, 2900, 3158], [3160, 3160, 3217, 3217, 4573]], "test": "timeout"}
{"id": "wsfyRn", "name": "2dFaceSome", "author": "antoinefortin", "description": "allo", "tags": ["2dexploreation"], "likes": 1, "viewed": 43, "published": "Public", "date": "1584044815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n    uv *= 5.;\n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y * 1.001);\n\t//uv.x = abs(uv.x);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    float dist = length(uv);\n    \n    dist += 0.5 + abs(sin(uv.y + iTime)) * 1.0;\n    dist -= 1. + abs(cos(uv.x + iTime)) * 1.0;\n    \n    vec2 gv = fract(uv * 12.) - 0.5;\n \t\n    \n   \n\t//col.xy += gv.xy;\n    \n    //col += length(gv * 1.0);\n    dist *= sin(uv.y * uv.y) / 2.0;\n    \n    \n    \n    vec2 pos = uv;\n\n    \n    //pos.y = (pos.x * pos.x / (pos.y * pos.y) * dist);\n    \n    float dist2 = length(pos);\n\n   \t\n    float r = dist + pos.x;\n    float g = 0.5; \n    float b = 0.5;\n    col += vec3(r, g, b) * .75;\n    \n    // Process the background \n    vec3 colorBackground = vec3(0.0, 0.5, 0.75);\n    /*\n    if(gv.x < .15)\n    {\n    \t// col .rg *=  gv;\n\n        col += colorBackground ; \n        \n     }\n\t*/\n    //col = vec3(dist, dist, dist);\n   // col += m;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1133]], "test": "ok"}
{"id": "WsfyRs", "name": "36 Days Of Type - C", "author": "nicolasdnl", "description": "36 Days Of Type - C", "tags": ["letter"], "likes": 1, "viewed": 24, "published": "Public", "date": "1585316701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[9], float kPath[22] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n   \t/*int kType[] = int[](0,1,0,0,0,1,0,0);\n   \tfloat kPath[] = float[]( 0.3,  0.5,\n                             0.0,  0.5, 0.001,\n                             0.0, -0.5,\n                             0.3, -0.5,\n                             0.3, -0.2,\n                             0.0, -0.2, 0.0,\n                             0.0,  0.2,\n                             0.3,  0.2,\n                             0.3,  0.5);*/\n   \tint kType[] = int[](0,0,0,1,0,0,0,0,1);\n\tfloat kPath[] = float[]( 0.05, 0.5,\n                             0.30, 0.5,\n                             0.30, 0.2,\n                             0.05, 0.2, 0.01,\n                             0.05,-0.2,\n                             0.30,-0.2,\n                             0.30,-0.5,\n                             0.05,-0.5,\n                             0.05,-0.5, 0.0,\n                             0.05, 0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in vec3 color, in float border)\n{\n    col = mix( col, color, 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    // distance computations\n    float d = sdA(p);\n    \n    // coloring\n    float t = iTime * 0.25;\n    //float t = iTime * 2.5;\n    float gap = 3./10.;\n    \n    vec3 col = vec3(1.,1.,1.);\n    //col *= 1.0 + 0.15*cos(128.0*abs(d)-t);\n    col = vec3(d);\n    col = generateBorder(col, vec3(0.,1.,0.), abs(d));\n    for (int i=0; i<10; i++) {\n    \tcol = generateBorder(col, vec3(1.,0.,0.), abs(d+0.5-mod(t+gap*float(i),3.)));\n    }\n    //col = 1. - col;\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 72, 72, 99], [101, 175, 225, 225, 358], [360, 360, 441, 441, 876], [878, 952, 1026, 1026, 1405], [1474, 1528, 1587, 1587, 2352], [3291, 3291, 3357, 3357, 3438], [3440, 3440, 3497, 3533, 4093]], "test": "error"}
{"id": "WsfyWX", "name": "tunel--gear-v1", "author": "jorge2017a1", "description": "tunel--gear-v1", "tags": ["tunelgearv1"], "likes": 1, "viewed": 39, "published": "Public", "date": "1585667184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1--\n\n//referencia de Gears\n///https://www.shadertoy.com/view/4d2fDc  ---Created by flockaroo \n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n//const float pi = 3.1415927;\nconst float tau = 6.283185;\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r)\n{\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\nmat2 rotatev2(float r)\n{\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, -s, s, c);\n}\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n// square wave\nfloat squareRaw( in float p, in float dpdt )\n{\n    float t = fract(p/tau);\n    return sign(0.5-t);\n}\n\n//--------------------------\n//===================================================\n// iq's signed cylinder distance field\n// iq's signed cylinder distance field\nfloat cylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat gear(vec3 p)\n{\n    float GEAR_NUM =8.;\n\tfloat TOOTH_NUM =10.0;\n    float dia=0.0;\n    \n    float d=10000.;\n    float ang=atan(p.y,p.x);\n    d=min(d,cylinder(p,dia+1.+.1*sin(ang*float(TOOTH_NUM)),0.13+0.5));\n    d=max(d,-cylinder(p,dia+0.6,.5+0.5));\n    return d;\n}\n\n\nfloat gearv2(vec3 p)\n{\n    float GEAR_NUM =8.;\n\tfloat TOOTH_NUM =10.0;\n    float dia=0.0;\n    \n    float d=10000.;\n    float ang=atan(p.y,p.x);\n    d=min(d,cylinder(p,dia+1.+.1*sin(ang*float(TOOTH_NUM)),0.13+0.5));\n    //d=max(d,-cylinder(p,dia+0.6,.5+0.5));\n    return d;\n}\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+3.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n   \n    p.z=mod(p.z,3.0)-1.0;\n    \n   float sdg1= gearv2( p); \n   float sdc1 =sdCylinder(p.xzy- vec3(0.0), vec2(2.0,0.5) );\n    \n   float sdg2= gearv2( p+vec3(0.0,0.0,-1.1)); \n   float sdc2 =sdCylinder(p.xzy- vec3(0.0,1.0,0.0), vec2(2.0,0.5) );\n    \n \n    float dif= differenceSDF(sdc1,sdg1);\n    dif2= differenceSDF(sdc2,sdg2);\n    \n    res=opU(res, vec2(dif,21 ));\n    res=opU(res, vec2(dif2,20 ));\n    \n  \n       \n  \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n      return vec3(0.0,1.,0.0);\t  \t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.0 ,0.0,-10.0+iTime);\n    \n   \n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfyWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[732, 749, 782, 782, 847], [851, 851, 886, 886, 910], [913, 928, 959, 959, 1109], [1110, 1130, 1166, 1166, 1253], [1254, 1270, 1302, 1330, 1391], [1393, 1393, 1429, 1429, 1532], [1535, 1535, 1580, 1580, 1671], [1673, 1673, 1708, 1708, 2193], [2245, 2245, 2291, 2291, 2323], [2325, 2325, 2368, 2368, 2400], [2402, 2402, 2450, 2450, 2483], [2486, 2486, 2515, 2515, 2641], [2643, 2643, 2679, 2679, 2796], [2798, 2798, 2834, 2834, 2952], [2955, 2955, 2991, 2991, 3114], [3167, 3179, 3201, 3201, 3509], [3510, 3536, 3561, 3561, 3751], [3752, 3797, 3814, 3814, 3887], [3890, 3923, 3949, 3949, 4146], [4193, 4193, 4245, 4245, 4400], [4465, 4574, 4611, 4611, 4646], [4648, 4648, 4667, 4667, 4742], [4791, 4791, 4814, 4814, 4840], [4842, 4842, 4865, 4865, 5003], [5059, 5059, 5081, 5081, 5151], [5154, 5154, 5178, 5178, 5248], [5312, 5312, 5338, 5338, 5395], [5397, 5397, 5417, 5417, 5475], [5478, 5478, 5499, 5499, 5749], [5792, 5792, 5818, 5818, 5989], [5992, 6007, 6053, 6053, 6107], [6109, 6270, 6314, 6314, 6421], [6423, 6423, 6443, 6443, 6693], [6696, 6696, 6718, 6718, 6970], [6972, 7016, 7041, 7041, 7877], [7882, 7882, 7915, 7915, 8390], [8394, 8394, 8418, 8418, 8750], [8755, 8755, 8793, 8793, 9151], [9250, 9294, 9311, 9311, 9382], [9407, 9499, 9524, 9524, 9787], [9908, 9908, 9936, 9936, 18324], [18327, 18327, 18384, 18384, 19408]], "test": "error"}
{"id": "Wsfyzf", "name": "Space foldings", "author": "Roninkoi", "description": "Stumbled onto this by accident", "tags": ["folding"], "likes": 1, "viewed": 72, "published": "Public", "date": "1585215517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y / iResolution.x;\n    \n    uv.xy /= clamp(abs(uv.x)*0.5 - 0.05, 0., 1.) - 0.13;\n    uv.xy /= clamp(abs(uv.y)*0.5 - 0.5, 0., 1.) - 0.13;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 cb = mod(vec3(uv.x * cos(iTime * 0.1) - uv.y * sin(iTime * 0.1), \n                       uv.x * sin(iTime * 0.1) + uv.y * cos(iTime) * 0.1, 0.) + vec3(iTime, 0., 0.), 5.0) * 0.3;\n    cb.z = 0.;\n    \n    col = cb / exp(length(uv * 0.07));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsfyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 624]], "test": "ok"}
{"id": "Wsfyzn", "name": "Rational Approximation in Colour", "author": "mla", "description": "Couldn't resist colourizing this one too - also use the continued fraction algorithm for finding an approximation (mouse button to compare with original).\n\nAlso show line at x,y=1 and points with y = 1/1,1/2,1/3..2/3,2/5,3/5,4/5.. etc.", "tags": ["approximation", "rational"], "likes": 5, "viewed": 243, "published": "Public API", "date": "1583941278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original by FabriceNeyret2:\n// https://www.shadertoy.com/view/3tKXDt\n\n// Modified by Matthew Arcus, mla, 11/3/2020\n//\n//\n// could be more efficient using one of those:\n//   https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_approximations\n//   https://en.wikipedia.org/wiki/Diophantine_approximation\n//   https://en.wikipedia.org/wiki/Pad%C3%A9_approximant\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return v * mix( vec3(1.0), rgb, s);\n}\n\nivec2 rationalize0(float k, float eps) {\n  float m = 1e8;\n  int a,_n;\n  for(int n_, n=1; n < 1000; n++) {\n    a = int(0.5+k*float(n));          // a/n ~ k\n    float d = abs(1.0-float(a)/float(n)/k); // relative error\n    if (d<m) m=d, _n=n;          // closer\n    if (m <= eps ) break;           // stop at 1% rel err\n  }\n  return ivec2(a,_n);\n}\n\n// Find continued fraction convergent\nivec2 rationalize1(float k, float eps) {\n  float k0 = k;\n  int x=1, y=0, z=0, w=1;\n  for (int i = 0; i < 1000; i++) {\n    int q = int(floor(k));\n    k = 1.0/fract(k);\n    int x1=z, y1=w, z1=x+q*z, w1=y+q*w;\n    x=x1; y=y1; z=z1; w=w1;\n    if (abs(1.0-float(w)/float(z)/k0) < eps) break;\n  }\n  return ivec2(w,z);\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 p = 2.0*fragCoord/iResolution.y;\n  vec2 m = 2.0*iMouse.xy/iResolution.y;\n  float eps = 5e-3, A = 20.0, B = 0.03;\n  if (iMouse.z > 0.0) {\n    eps = 1e-3, A = 40.0, B = 0.01;\n    p -= m; p /= 10.0; p += m;\n  }\n  float x = p.y/p.x;\n  //ivec2 r = iMouse.z > 0.0 ? rationalize0(x,eps) : rationalize1(x,eps);\n  ivec2 r = rationalize1(x,eps);\n  float t = 0.1*iTime;\n  vec3 col = hsv2rgb(t+float(r.y)/A,1.0,exp(-B*(float(r.y)-1.0)));\n  float ds = fwidth(p.x);\n  float lwidth = 0.002;\n  float cwidth = 0.002;\n  float cdia = 0.02;\n  vec3 linecol = vec3(0.9);\n  col = mix(linecol,col,smoothstep(lwidth,lwidth+ds,abs(p.y-1.0)));\n  col = mix(linecol,col,smoothstep(lwidth,lwidth+ds,abs(p.x-1.0)));\n  for (int i = 1; i <= 6; i++) {\n    for (int j = 1; j <= 6; j++) {\n      col = mix(linecol,col,smoothstep(cwidth,cwidth+ds,abs(length(p-vec2(1,float(j)/float(i)))-cdia)));\n      col = mix(linecol,col,smoothstep(cwidth,cwidth+ds,abs(length(p-vec2(float(j)/float(i),1))-cdia)));\n    }\n  }\n  outColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsfyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 414, 414, 584], [586, 586, 626, 626, 931], [933, 971, 1011, 1011, 1284]], "test": "ok"}
{"id": "WslcR2", "name": "fBM Noise", "author": "jorgemoag", "description": "inspired by http://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["noise", "fbm", "warp", "valuenoise"], "likes": 7, "viewed": 686, "published": "Public", "date": "1585180347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by http://www.iquilezles.org/www/articles/warp/warp.htm\n\nfloat random(vec2 p)\n{    \n\tfloat x = dot(p,vec2(4371.321,-9137.327));    \n    return 2.0 * fract(sin(x)*17381.94472) - 1.0;\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 id = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix(mix(random(id + vec2(0.0,0.0)), \n                   random(id + vec2(1.0,0.0)), u.x),\n               mix(random(id + vec2(0.0,1.0)), \n                   random(id + vec2(1.0,1.0)), u.x), \n               u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    float gat = 0.0;\n    \n    for (float octave = 0.; octave < 5.; ++octave)\n    {\n        float la = pow(2.0, octave);\n        float ga = pow(0.5, octave + 1.);\n        f += ga*noise( la * p ); \n        gat += ga;\n    }\n    \n    f = f/gat;\n    \n    return f;\n}\n\nfloat noise_fbm(vec2 p)\n{\n    float h = fbm(0.09*iTime + p + fbm(0.065*iTime + 2.0 * p - 5.0 * fbm(4.0 * p)));  \n    return h; \n}\n\nfloat outline(vec2 p, float eps)\n{\n    float f = noise_fbm(p - vec2(0.0, 0.0));\n    \n    float ft = noise_fbm(p - vec2(0.0, eps));\n    float fl = noise_fbm(p - vec2(eps, 0.0));\n    float fb = noise_fbm(p + vec2(0.0, eps));\n    float fr = noise_fbm(p + vec2(eps, 0.0));\n    \n    float gg = clamp(abs(4. * f - ft - fr - fl - fb), 0., 1.);\n    \n    return gg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float f = noise_fbm(p);\n    \n    float a2 = smoothstep(-0.5, 0.5, f);\n    float a1 = smoothstep(-1.0, 1.0, fbm(p));\n    \n    vec3 cc = mix(mix(vec3(0.50,0.00,0.10), \n                     vec3(0.50,0.75,0.35), a1), \n                     vec3(0.00,0.00,0.02), a2);        \n    \n    cc += vec3(0.0,0.2,1.0) * outline(p, 0.0005);\n    cc += vec3(1.0,1.0,1.0) * outline(p, 0.0025);\n    \n    cc += 0.5 * vec3(0.1, 0.0, 0.2) * noise_fbm(p);\n    cc += 0.25 * vec3(0.3, 0.4, 0.6) * noise_fbm(2.0 * p);\n    \n    fragColor = vec4( vec3(cc), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslcR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 91, 91, 195], [197, 197, 223, 223, 530], [532, 532, 553, 553, 834], [836, 836, 861, 861, 965], [967, 967, 1001, 1001, 1325], [1327, 1327, 1384, 1384, 1992]], "test": "timeout"}
{"id": "wslcRs", "name": "First Shader openroomxyz", "author": "openroomxyz", "description": "I am learning a lot to follow", "tags": ["learning"], "likes": 1, "viewed": 241, "published": "Public API", "date": "1585402328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,sin(uv.x * 100.0),4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 310]], "test": "timeout"}
{"id": "WslcW4", "name": "Uniform spherical sampling ", "author": "michael0884", "description": "Messing with projection matrices and Fibonacci samplings", "tags": ["hmmm"], "likes": 13, "viewed": 301, "published": "Public API", "date": "1584808604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.141592653\n\nconst float PHI = 0.5*(sqrt(5.) + 1.);\n\nvec2 fibonacci_lattice(int i, int N)\n{\n    return vec2((float(i)+0.5)/float(N), mod(float(i)/PHI, 1.)); \n}\n\nvec3 fibonacci_sphere(int i, int N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*M_PI*xy.y, acos(2.*xy.x - 1.) - M_PI*0.5);\n    return vec3(cos(pt.x)*cos(pt.y), sin(pt.x)*cos(pt.y), sin(pt.y)); \n}\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * M_PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat4 getRot(vec2 a)\n{\n    \n   mat4 theta_rot = mat4(1, 0, 0, 0,\n                         0, cos(a.y), sin(a.y), 0,\n                         0, -sin(a.y), cos(a.y), 0,\n                         0, 0, 0, 1); \n        \n   mat4 phi_rot = mat4(cos(a.x), sin(a.x), 0, 0,\n        \t\t       -sin(a.x), cos(a.x), 0, 0,\n        \t\t        0, 0, 1, 0,\n                      \t0, 0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nmat4 getModel(vec3 dx)\n{\n   return transpose(mat4(1, 0, 0, dx.x,\n        \t   0, 1, 0, dx.y,\n               0, 0, 1, dx.z,\n               0, 0, 0, 1)); ;\n}\n\nvec3 toScreen(vec4 X)\n{\n    return vec3(0.5*X.xy/X.w + 0.5, X.z);\n}\n\nfloat POINT(vec2 pos, float R, vec4 X)\n{\n    vec3 spos = toScreen(X);\n    return exp(-distance(pos, iResolution.xy*spos.xy)*spos.z/R);\n}\n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return mix(y0, y1, (val-x0)/(x1-x0));\n}\n\nfloat base(float x) \n{\n    if ( x <= -0.75 ) return 0.0;\n    else if ( x <= -0.25 ) return interpolate( x, 0.0, -0.75, 1.0, -0.25 );\n    else if ( x <= 0.25 ) return 1.0;\n    else if ( x <= 0.75 ) return interpolate( x, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n \tivec2 p = ivec2(pos.xy);\n    \n    int N = 128;\n    fragColor.xyz = vec3(0.);\n    \n    mat4 perspec = getPerspective(60., iResolution.x/iResolution.y, 0.001, 10.);\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*M_PI, M_PI):vec2(iTime, M_PI*0.5);\n    mat4 rot = getRot(angles);\n    mat4 sh = getModel(vec3(0.,0.,-2.5));\n    int R = 32;\n    int a = (R*(500/10))%N;\n    //rasterizer\n    for(int i = 0; i < N; i++)\n    {\n        int id = i;\n        vec3 d = fibonacci_sphere(id, N);\n        vec4 X = vec4(d, 1.);\n        vec4 XCAM = perspec*sh*rot*X;\n        \n        fragColor.xyz += 2.*jet_range(float(i), float(0), float(N))*POINT(pos, 10., XCAM);     \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 211, 211, 388], [390, 390, 454, 454, 791], [793, 793, 814, 814, 1209], [1211, 1211, 1235, 1235, 1365], [1367, 1367, 1390, 1390, 1434], [1436, 1436, 1476, 1476, 1572], [1574, 1607, 1678, 1678, 1722], [1724, 1724, 1746, 1746, 1990], [1992, 1992, 2020, 2020, 2076], [2078, 2078, 2121, 2121, 2182], [2185, 2185, 2236, 2236, 2917]], "test": "error"}
{"id": "wslcWj", "name": "36 Days Of Type - H", "author": "nicolasdnl", "description": "36 Days Of Type - H", "tags": ["letter"], "likes": 1, "viewed": 40, "published": "Public", "date": "1585671787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[12], float kPath[26] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p, float t )\n{\n    float height = 1. + sin(t*PI*2.)*0.2;\n    float width = .8 + cos(t*PI*2.)*0.1;\n    float strokeWidth = 0.25 + cos(t*PI*2.)*0.1;\n    \n   \tint kType[] = int[](0,0,0,0,0,0,0,0,0,0,0,0);\n\tfloat kPath[] = float[]( -width*0.5, height*0.5,\n                             -width*0.5,-height*0.5,\n                             -width*0.5+strokeWidth,-height*0.5,\n                             -width*0.5+strokeWidth,-strokeWidth*0.5,\n                              width*0.5-strokeWidth,-strokeWidth*0.5,\n                              width*0.5-strokeWidth,-height*0.5,\n                              width*0.5,-height*0.5,\n                              width*0.5, height*0.5,\n                              width*0.5-strokeWidth, height*0.5,\n                              width*0.5-strokeWidth, strokeWidth*0.5,\n                             -width*0.5+strokeWidth, strokeWidth*0.5,\n                             -width*0.5+strokeWidth, height*0.5,\n                             -width*0.5, height*0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    float t = mod(iTime * 0.25, 1.);\n    \n    \n    vec3 col = vec3(1.,1.,1.);\n    for (int i=0; i<25; i++) {\n        //float d = sdA(p, t+float(i)*0.08);\n        float d = sdA(p+vec2(float(15-i)*0.004), t+float(i)*0.005);\n    \tcol = float(i)*0.003+generateBorder(col, abs(d));\n    }\n    col = 1. - col;\n    \n    //col = vec3(sign(d));\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1634, 1634, 2399], [3465, 3465, 3516, 3516, 3601], [3603, 3603, 3660, 3696, 4141]], "test": "error"}
{"id": "wslcWn", "name": "rainbow spiral 1 ♡", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 2, "viewed": 77, "published": "Public", "date": "1584594290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nLoops from 0 to 3.\nThe intent of the function is\nto show pure 0deg, 120deg, and 240deg\nas well as colors close to 60deg, 180deg, and 300deg.\nTheoretically, we could return a R value of 1.0\nfor all hues from 300deg to 60deg.\nBut because pure linear RGB values don't account for gamma,\nI need to handle it by using a power function.\n */\nvec3 rainbow(float x) {\n    vec3 xyz = abs(mod(x + vec3(0.5,1.5,2.5), 3.) - 1.5);\n    return 1.0 - pow(\n        max(vec3(0.0), xyz * 2. - 1.)\n    , vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - 0.5 * (iResolution.xy);\n\n    // Time varying pixel color\n    float dist = log(dot(uv, uv));\n    float angle = atan(uv.y, uv.x) / 6.28318530718;\n    vec3 col = rainbow(dist * 0.2 + angle * 3.0 + sin(iTime * 2.0 + dist * 2.0) * 0.2 + sin(1.4 + -iTime + dist * 0.7) * -0.2);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 338, 361, 361, 498], [500, 500, 557, 607, 963]], "test": "ok"}
{"id": "wslcz2", "name": "Truchet Hills", "author": "gls9102", "description": "Weird looking shader that uses waves, truchet tiles, and iterations to make this 3D-like effect.\n\nIt may not be the fastest code but hey, it still works.", "tags": ["wave", "truchet", "depth"], "likes": 12, "viewed": 103, "published": "Public", "date": "1585189376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// v1.0.1\n\n#define PI 3.1415\n#define ITERATIONS 25.\n\nfloat ran21(vec2 uv) {\n    return fract(cos(dot(cos(uv.x*uv.y)-32.2,tan(uv.x/uv.y)-23.5)*1322.24)*432122.62);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 uvb = uv;\n\n    vec3 col = vec3(0);\n    for(float i=1.;i<=ITERATIONS;i++) {\n        float cur = i/ITERATIONS;\n        uv = uvb;\n        uv *= 10.0-cur*1.1;\n        uv.y += iTime*0.6;\n    \n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n    \n        gv.x *= (ran21(id)>.5) ? -1. : 1.;\n        vec2 ruv = gv-sign(gv.x+gv.y+.001)*.5;\n        float tile = smoothstep(.01,-.01,abs(length(ruv)-.5)-.1);\n        float rot = atan(ruv.x,ruv.y)/PI;\n    \n        float mul = mod(id.x+id.y,2.)==1. ? -1. : 1.;\n        float h = smoothstep(cur-.1,cur,sin((rot*4.*mul+iTime)*PI)*.25+.75);\n        \n        col = max(col,h*tile*cur);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 75, 75, 164], [166, 166, 221, 221, 964]], "test": "error"}
{"id": "Wslczl", "name": "menger-box-v3", "author": "jorge2017a1", "description": "menger-box-v3", "tags": ["mengerboxv3"], "likes": 1, "viewed": 42, "published": "Public", "date": "1585360865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.35;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(2.0) );\n    \n    \n    \n    \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(0.5+sin(iTime), 0.25, 1.5+ 2.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wslczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 547, 547, 578], [580, 580, 611, 611, 702], [705, 705, 728, 728, 865], [867, 867, 897, 897, 1034], [1084, 1084, 1153, 1232, 1273], [1275, 1275, 1357, 1357, 1588], [1590, 1590, 1650, 1650, 1791], [1840, 1895, 1918, 1918, 2053], [2055, 2055, 2081, 2081, 2138], [2140, 2140, 2180, 2180, 2214], [2218, 2218, 2254, 2254, 2341], [2344, 2344, 2391, 2391, 2424], [2426, 2426, 2451, 2451, 2466], [2469, 2498, 2516, 2516, 2780], [2840, 2840, 2869, 2869, 3057], [3059, 3059, 3100, 3100, 3276], [3278, 3278, 3319, 3319, 3471], [3473, 3473, 3494, 3494, 3624], [3626, 3626, 3653, 3653, 3903], [3960, 4004, 4021, 4021, 4092], [4117, 4209, 4234, 4234, 4497], [4555, 4555, 4612, 4612, 5178]], "test": "timeout"}
{"id": "WslyDM", "name": "Circle 58", "author": "NoeDev", "description": "My first attempt at putting SDF shapes on top of each other.", "tags": ["sdf"], "likes": 1, "viewed": 48, "published": "Public", "date": "1585143786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (0.0,0.0) is at the center\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec4 red = vec4(0.9,0.27,0.27,1.0);\n    vec4 blue = vec4(0.27, 0.49, 0.9,1.0);\n    float t = iTime*2.0;\n    float radius = 0.5;\n    float thickness = 0.01;\n    float c = sdSegment(uv, vec2(cos(t)*0.5,0.0), vec2(cos(t),sin(t) )*0.5 );\n\tfloat s = sdSegment(uv, vec2(0.0,0.5*sin(t)), vec2(cos(t),sin(t) ) *0.5);\n   \n    float p = length(uv- vec2(cos(t),sin(t)) *0.5);\n    \n    float d = length(uv);\n    \n    float point = smoothstep(0.01+fwidth(p), 0.01, p);\n\n\tfloat cosinus = smoothstep(thickness/2.0+fwidth(c), thickness/2.0  , c );\n    float sinus = smoothstep(thickness/2.0+fwidth(s), thickness/2.0  , s );\n    \n    float axe = (-step( 0.0, sdBox(uv, vec2(0.005, 1.0))) +1.0)+ ( -step( 0.0, sdBox(uv, vec2(2.0, 0.005) ) )  +1.0);      \n    \n    \n    float cercle = smoothstep(radius-thickness/2.0, radius-thickness/2.0+fwidth(d), d)\n        * smoothstep(radius+thickness/2.0+fwidth(d), radius+thickness/2.0, d) ;\n    \n    \n    vec3 col = vec3(cercle+sinus*red+cosinus*blue+axe+point);\n\t\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 117], [119, 119, 171, 171, 290], [294, 294, 351, 414, 1497]], "test": "ok"}
{"id": "wslyRj", "name": "escalera-simple-v1", "author": "jorge2017a1", "description": "escalera-simple-v1", "tags": ["escalerasimplev1"], "likes": 0, "viewed": 55, "published": "Public", "date": "1585173568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\n\n\n\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y+1.0;  //piso inf\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    float piso = mapCerrov2(p);\n    \n    res=opU(res, vec2(planeDist2,14 ));\n    res=opU(res, vec2(planeDist3,13 ));\n    //res=opU(res, vec2(planeDist1,7 ));\n    res=opU(res, vec2(piso,1 ));\n    \n    \n    vec3 ps= rotate_y(p, 90.0*3.141516/180.0);\n    \n    \n    ps=p;\n  \n    \n    float sdbh1= sdBox(ps - vec3(0.0,0.0,0.5), vec3(4.0,0.1,0.5) );\n    float sdbv1= sdBox(ps - vec3(0.0,1.0,1.0), vec3(4.0,1.0,0.1) );\n    \n    float sdbh2= sdBox(ps - vec3(0.0,2.0,1.5), vec3(4.0,0.1,0.5) );\n    float sdbv2= sdBox(ps - vec3(0.0,3.0,2.0), vec3(4.0,1.0,0.1) );\n    \n    \n    float sdbh3= sdBox(ps - vec3(0.0,4.0,2.5), vec3(4.0,0.1,0.5) );\n    float sdbv3= sdBox(ps - vec3(0.0,5.0,3.0), vec3(4.0,1.0,0.1) );\n    \n    \n    float sdbh4= sdBox(ps - vec3(0.0,6.0,3.5), vec3(4.0,0.1,0.5) );\n    float sdbv4= sdBox(ps - vec3(0.0,7.0,4.0), vec3(4.0,1.0,0.1) );\n    \n    float sdbh5= sdBox(ps - vec3(0.0,8.0,4.5), vec3(4.0,0.1,0.5) );\n    float sdbv5= sdBox(ps - vec3(0.0,9.0,5.0), vec3(4.0,1.0,0.1) );\n    \n    float sdbh6= sdBox(ps - vec3(0.0,10.0,5.5), vec3(4.0,0.1,0.5) );\n    float sdbv6= sdBox(ps - vec3(0.0,11.0,6.0), vec3(4.0,1.0,0.1) );\n    \n    float sdbh7= sdBox(ps - vec3(0.0,12.0,6.5), vec3(4.0,0.1,0.5) );\n    float sdbv7= sdBox(ps - vec3(0.0,13.0,7.0), vec3(4.0,1.0,0.1) );\n    \n    float sdbh8= sdBox(ps - vec3(0.0,14.0,7.5), vec3(4.0,0.1,0.5) );\n    float sdbv8= sdBox(ps - vec3(0.0,15.0,8.0), vec3(4.0,1.0,0.1) );\n    \n    float sdbh9= sdBox(ps - vec3(0.0,16.0,8.5), vec3(4.0,0.1,0.5) );\n    float sdbv9= sdBox(ps - vec3(0.0,17.0,9.0), vec3(4.0,1.0,0.1) );\n    \n    \n    \n    res=opU(res, vec2(sdbh1,8 ));\n\tres=opU(res, vec2(sdbv1,8 ));\n    \n    res=opU(res, vec2(sdbh2,9 ));\n\tres=opU(res, vec2(sdbv2,9 ));\n    \n    res=opU(res, vec2(sdbh3,8 ));\n\tres=opU(res, vec2(sdbv3,8 ));\n    \n    res=opU(res, vec2(sdbh4,9 ));\n\tres=opU(res, vec2(sdbv4,9 ));\n    \n    res=opU(res, vec2(sdbh5,8 ));\n\tres=opU(res, vec2(sdbv5,8 ));\n    \n    res=opU(res, vec2(sdbh6,9 ));\n\tres=opU(res, vec2(sdbv6,9 ));\n    \n    res=opU(res, vec2(sdbh7,8 ));\n\tres=opU(res, vec2(sdbv7,8 ));\n    \n    res=opU(res, vec2(sdbh8,9 ));\n\tres=opU(res, vec2(sdbv8,9 ));\n    \n    res=opU(res, vec2(sdbh9,1 ));\n\tres=opU(res, vec2(sdbv9,1 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    vec2 e = vec2(0.0035, -0.0035);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    \n    vec3 ro = vec3(0 ,10.0+8.0*cos(3.0-iTime*0.5),2.0+6.0*cos(3.0-iTime*0.5));\n    //ro = get_mouse(ro);\n    vec3 rd =normalize(vec3(uv,0.5) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.35;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 549, 582, 582, 647], [648, 666, 702, 702, 771], [772, 787, 818, 818, 968], [969, 989, 1025, 1025, 1112], [1113, 1129, 1161, 1189, 1250], [1252, 1252, 1288, 1288, 1391], [1394, 1394, 1439, 1439, 1530], [1584, 1584, 1630, 1630, 1662], [1664, 1664, 1707, 1707, 1739], [1741, 1741, 1789, 1789, 1822], [1825, 1825, 1854, 1854, 1980], [1982, 1982, 2018, 2018, 2135], [2137, 2137, 2173, 2173, 2291], [2294, 2294, 2330, 2330, 2453], [2506, 2518, 2540, 2540, 2848], [2849, 2875, 2900, 2900, 3090], [3091, 3136, 3153, 3153, 3226], [3229, 3262, 3288, 3288, 3485], [3532, 3532, 3584, 3584, 3739], [3804, 3913, 3950, 3950, 3985], [3987, 3987, 4006, 4006, 4081], [4130, 4130, 4153, 4153, 4179], [4181, 4181, 4204, 4204, 4342], [4345, 4345, 4367, 4367, 4437], [4502, 4502, 4528, 4528, 4585], [4587, 4587, 4607, 4607, 4665], [4668, 4668, 4689, 4689, 4939], [4986, 4986, 5012, 5012, 5183], [5185, 5229, 5254, 5254, 7878], [7883, 7883, 7916, 7916, 8391], [8395, 8395, 8419, 8419, 8751], [8756, 8756, 8794, 8794, 9152], [9251, 9295, 9312, 9312, 9383], [9408, 9500, 9525, 9525, 9788], [9909, 9909, 9937, 9937, 18290], [18293, 18293, 18350, 18350, 19437]], "test": "error"}
{"id": "wslyRM", "name": "Moving Snake", "author": "muhammadadnan0075", "description": "First time with shadertoy.", "tags": ["beginner"], "likes": 1, "viewed": 33, "published": "Public", "date": "1584453347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t,float start,float end,float blur){\n    float step1 = smoothstep(start-blur,start+blur,t);\n    float step2 = smoothstep(end+blur,end-blur,t);\n    return step1*step2;\n        \n}\n\nfloat Rect(vec2 uv,float top,float bottom,float left,float right,float blur){\n    \n    float horizontal = Band(uv.x,left,right,blur);\n    float vertical = Band(uv.y,bottom,top,blur);\n    return horizontal*vertical;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n       \n    vec3 col = vec3(1.,1.,1.);\n    \n  \tfloat x = uv.x;\n    float y = uv.y;\n    y += cos(x*10.+iTime*4.)*0.1;\n    x += sin(y*10.+iTime*4.)*0.1;\n    \n    float c = Rect(vec2(x,y),0.1,-0.1,-0.7,0.7,0.005);\n    \n    \n    \n    fragColor = vec4(col,1.0)*c;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 194], [196, 196, 273, 273, 412], [414, 414, 471, 471, 826]], "test": "ok"}
{"id": "WslyzB", "name": "Something go wrongv2", "author": "Arseny", "description": "3d", "tags": ["raymarching"], "likes": 1, "viewed": 224, "published": "Public API", "date": "1585056375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdOct(in vec3 p){\n    //vec3 n = normalize(vec3(1. / 3.));\n    return dot(vec3(0.57735), abs(p)) - 0.057735;\n    //return dot(vec3(1.), p) - r;\n}\n\nfloat sdTransOct(in vec3 p, in float a, in float b, in float h){\n    vec3 n = normalize(cross(vec3(a, 0, 0) - vec3(0, 0, b), vec3(0, h, 0) - vec3(0, 0, b)));\n    return dot(n, abs(p)) - a * n.x;\n}\n\nfloat sdKunai(in vec3 p, in float fl, in float bl, in float w, in float h, in float sh){\n    p.xy = abs(p.xy);\n    vec3 A = vec3(0, h, sh);\n    vec3 B = vec3(0, 0, fl);\n    vec3 C = vec3(w, 0, 0);\n    vec3 n = normalize(cross(B - A, C - A));\n    //float d1 = dot(n, p) - fl * n.z;\n    //float d1 = (p.z < fl) ? dot(n, p) - fl * n.z : 0.;\n    float d1 = dot(n, p) - fl * n.z;\n    vec3 D = vec3(0, 0, -bl);\n    n = normalize(cross(C - A, D - A));\n    //d1 = (p.z > -bl) ? max(d1, dot(n, p) + bl * n.z) : d1;\n    d1 = max(d1, dot(n, p) + bl * n.z);\n    d1 = (p.z < sh) ? mix(smin(d1, length(p.xy), 0.04), d1, p.z - sh) : d1;\n    return d1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdKunaiHandle(in vec3 p, in float k, in float w, in float r){\n    p.yz = p.zy;\n    float y = p.y;\n    p.y = (y>0.&&y< k * w)?fract(p.y / w) * w - w / 2.:y - w / 2.;\n    p.y = (y>k * w)?y-k * w - w / 2.:p.y;\n    //if (y < 0.) return y;\n    return sdTorus(p, vec2(r, w));\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdOct( p * 1.1) / 1.1;\n    //float d = sdTransOct(p, 0.1, 0.3, 0.1);\n    //float d = sdKunai(p, 0.4, 0.1, 0.1, 0.03, 0.05);\n    //float d = sdTorus(p, vec2(0.2, 0.1));\n    float d = sdKunaiHandle(-p + vec3(0, 0, 0.01), 20., 0.01, 0.02);\n    d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    //d = min(d, sdKunai(p + vec3(0, 0, -0.1), 0.4, 0.1, 0.1, 0.03, 0.05));\n    d = min(d, length(p.xy));\n    //float d = sdSphere( p, 0.1 );\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 292, 292, 318], [320, 320, 343, 384, 471], [473, 473, 537, 537, 669], [671, 671, 759, 759, 1309], [1311, 1311, 1344, 1344, 1409], [1411, 1411, 1478, 1478, 1688], [1729, 1729, 1764, 1948, 2260], [2290, 2290, 2337, 2337, 2546], [2548, 2548, 2605, 2605, 2870], [2872, 2872, 2947, 2947, 3258], [3260, 3260, 3317, 3317, 3578], [3580, 3580, 3632, 3632, 3809]], "test": "ok"}
{"id": "wslyzH", "name": "Logarithmic Conical Spiral", "author": "tdhooper", "description": "I used a crude version of this of this for [url=https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/source.gif]Fractal Polycephaly[/url]\n\nOld version can be found here [url]https://www.shadertoy.com/view/tscfRS[/url]", "tags": ["fractal", "spiral", "camera", "loop", "path", "logarithmic"], "likes": 7, "viewed": 460, "published": "Public API", "date": "1584203185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tLogarithmic Conical Spiral Center and Axis\n\t------------------------------------------\n\n\tWhen iteratively applying a transformtion matrix, the\n\tpositions visited form a logarithmic spiral on a cone.\n\t\n\tThis calculates the center (tip) and axis of that cone,\n\tas well as the angle between each iteration.\n\n\tThe general approach is to ignore the scaling component\n\tof the matrix, such that multiple iterations form a\n\tcylinder instead of a cone. Once we have the axis and\n\tposition of the cylinder, we can triangulate the tip of\n\tthe cone.\n\n\tWith these parameters, we can create a method that\n\trotates and scales space over time to smoothly transform\n\tthe second instance into the first, forming a\n\tseamless loop.\n\n\tSee also the 2d version:\n\thttps://www.shadertoy.com/view/tscBDH\n\n*/\n\n// Matrix functions\n// --------------------------------------------------------\n\nmat4 mTranslate(vec3 t) {\n\treturn mat4(\n        1, 0, 0, t.x,\n        0, 1, 0, t.y,\n        0, 0, 1, t.z,\n        0, 0, 0, 1\n   \t);\n}\n\nmat4 mRotate(vec3 forward, vec3 up) {\n    vec3 ww = normalize(forward * vec3(1,1,-1));\n    vec3 uu = normalize(cross(up * vec3(-1,1,1),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    return mat4(\n        uu, 0,\n        vv, 0,\n        ww, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 mScale(float s) {\n\treturn mat4(\n    \ts, 0, 0, 0,\n        0, s, 0, 0,\n        0, 0, s, 0,\n        0, 0, 0, 1\n    );\n}\n\nfloat getScale(mat4 m) {\n\treturn length(m[0].xyz);\n}\n\nvec3 mul(vec3 p, mat4 m) {\n\treturn (vec4(p, 1) * m).xyz;\n}\n\n\n// Logarithmic conical spiral center, axis, and angle\n// --------------------------------------------------------\n\n#define PI 3.1415926\n\n// Logarithmic spiral center\n// https://www.shadertoy.com/view/tscBDH\nvec2 spiralCenter(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\nvoid conicalSpiral(mat4 txm, float txmScale, out vec3 axis, out float angle, out vec3 center) {\n\n    // Remove scaling from transformation matrix\n    mat4 txmns = mScale(1. / txmScale) * txm;\n    \n    // Get first four positions, these form a cylinder\n    vec3 v0 = vec3(0);\n    vec3 v1 = mul(v0, txmns);\n    vec3 v2 = mul(v1, txmns);\n    vec3 v3 = mul(v2, txmns);\n    \n\n\t// Cylinder axis\n    // -------------\n    \n    // Calculate normals for the two middle points\n    vec3 n0 = v1 - mix(v0, v2, .5);\n    vec3 n1 = v2 - mix(v1, v3, .5);\n\n    // Cross for cylinder axis\n    axis = normalize(cross(n0, n1));\n\n    // Rotation matrix for cylinder direction\n    mat3 mAxis = mat3(n0, cross(axis, n0), axis);\n\n\n  \t// Angle between iterations\n    // ------------------------\n\n    // Project points onto axis plane\n    vec2 p1 = (v1 * mAxis).xy;\n    vec2 p2 = (v2 * mAxis).xy;\n\n    // Angle between the points\n    angle = PI - acos(dot(normalize(-p1), normalize(p2 - p1)));    \n    \n\n\t// Cone center (tip)\n\t// -----------------\n\n    // Center of the 2d logarithmic spiral\n    vec2 center2d = spiralCenter(p1, angle, txmScale);\n\n    // Transform back into 3d\n    center = vec3(center2d, 0) * inverse(mAxis);\n    \n    // Extrapolate the line between v0 and v1 to find the tip\n    float v1Height = dot(v1, axis);\n    float v1Radius = distance(center2d, p1);\n    center += axis * v1Height * (length(center2d) / (length(center2d) - v1Radius));\n}\n\n\n// Camera movement\n// --------------------------------------------------------\n\nmat4 txm;\nmat4 txmi;\nfloat txmScale;\n\nvec3 cameraAxis;\nfloat cameraAngle;\nvec3 cameraApex;\n\n// Rotate around axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n// With the calculated spiral properties, rotate and scale space\n// (aka move the camera), by a given amount until we have transformed\n// the second iteration into the first iteration\nfloat tweenCamera(inout vec3 p, float t) {\n    float scale = pow(txmScale, t);\n    p -= cameraApex;\n    p = erot(p, cameraAxis, cameraAngle * t);\n    p *= scale;    \n    p += cameraApex;\n    return scale;\n}\n\n\n// Modeling\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fLine(vec3 p, vec3 n) {\n    float t = dot(p, n) / dot(n, n);\n    return length((n * t) - p) ;\n}\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    int id;\n};\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    }\n    return b;\n}\n\nModel mGizmo(vec3 p) {\n\tfloat d = fBox(p, vec3(.5, .5, .5));\n   \treturn Model(d, p, 1);\n}\n\nModel mAxisAndCenter(vec3 p) {\n    float axis = fLine(p - cameraApex, cameraAxis) - .08;\n    float center = length(p - cameraApex) - .3;\n    float d = min(axis, center);\n   \treturn Model(d, p, 2);\n}\n\nModel scene(vec3 p) {\n    \n    Model model = mAxisAndCenter(p);\n\n    float scale = 1.;\n    vec3 pp = p;\n    \n    for (int i = 0; i < 15; i++) {\n        // Draw gizmo\n\t\tModel gizmo = mGizmo(p);\n        gizmo.d *= scale; // Fix distance for scale factor\n        model = opU(model, gizmo);\n        \n        // Apply matrix and scale\n        p = mul(p, txmi);\n        scale *= txmScale;\n    }\n\n\tscale = 1.;\n    p = mul(pp, txm);\n    \n    for (int i = 0; i < 12; i++) {\n        // Draw gizmo\n\t\tModel gizmo = mGizmo(p);\n        gizmo.d *= scale; // Fix distance for scale factor\n        model = opU(model, gizmo);\n        \n        // Apply matrix and scale\n        p = mul(p, txm);\n        scale /= txmScale;\n    }\n    \n    return model;\n}\n\nModel map(vec3 p) {\n    float scale = tweenCamera(p, mod(iTime * 2., 1.));\n    Model model = scene(p);\n    model.d /= scale;\n    return model;\n}\n\n\n\n// Rendering\n// --------------------------------------------------------\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    float t = iTime / 3. + .5;\n    \n    // Build the TRS transformation matrix for each iteration\n    mat4 mT = mTranslate(vec3(0, cos(t/2.), -sin(t/2.)) * (cos(t/2.) * .25 + 1.5));\n    mat4 mR = mRotate(vec3(cos(t) * -.5, cos(t/2.) * -.5, -1), vec3(sin(t) * -.5, 1, 0));\n    mat4 mS = mScale(.8 + sin(t) * .05);\n\ttxm = mS * mR * mT;\n    txmScale = getScale(txm);\n\ttxmi = inverse(txm);    \n\n    // Find conical spiral parameters for camera movement\n    conicalSpiral(txm, txmScale, cameraAxis, cameraAngle, cameraApex);\n    \n    \n    // Ray marching\n\n    float focalLength = 2.4;\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(vec3(p, -focalLength));\n    vec3 rayOrigin = vec3(0,0,15);\n    vec3 rayPosition = rayOrigin;\n    float rayLength = 0.;\n\n    Model model;\n    float dist = 0.;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 color = bgcol;\n    bool isBackground = false;\n\n    for (float i = 0.; i < 100.; i++) {\n        rayLength += dist;\n        rayPosition = rayOrigin + rayDirection * rayLength;\n        model = map(rayPosition);\n\t\tdist = model.d;\n        \n        if (dist < .001) {\n            break;\n        }\n\n        if (rayLength > 50.) {\n            isBackground = true;\n            break;\n        }\n    }\n\n    if ( ! isBackground) {\n        if (model.id == 2) {\n        \tcolor = vec3(1);\n        } else {\n    \t\tvec3 face = step(vec3(vmax(abs(model.p))), abs(model.p)) * sign(model.p);\n            float faceIndex = max(vmax(face * vec3(0,1,2)), vmax(face * -vec3(3,4,5)));\n    \t\tcolor = spectrum(faceIndex / 6.);\n    \t}\n    }\n    \n    float fog = 1. - exp((rayLength - 13.) * -.25);\n    color = mix(color, bgcol, clamp(fog, 0., 1.));\n\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[869, 869, 894, 894, 1002], [1004, 1004, 1041, 1041, 1273], [1275, 1275, 1297, 1297, 1396], [1398, 1398, 1422, 1422, 1450], [1452, 1452, 1478, 1478, 1510], [1650, 1720, 1786, 1786, 1982], [1984, 1984, 2079, 2129, 3417], [3592, 3672, 3710, 3710, 3775], [3777, 3961, 4003, 4003, 4167], [4243, 4243, 4263, 4263, 4301], [4303, 4303, 4331, 4331, 4418], [4420, 4420, 4449, 4449, 4521], [4576, 4576, 4605, 4605, 4663], [4665, 4665, 4687, 4687, 4754], [4756, 4756, 4786, 4786, 4954], [4956, 4956, 4977, 4977, 5689], [5691, 5691, 5710, 5710, 5835], [5913, 5975, 6043, 6043, 6086], [6087, 6087, 6111, 6111, 6209], [6211, 6211, 6266, 6266, 8059]], "test": "error"}
{"id": "Wslyzr", "name": "Rib", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 12, "viewed": 252, "published": "Public", "date": "1584023293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nvec2 pSFold(vec2 p,float n)\n{\n    float h=floor(log2(n)),a =TAU*exp2(h)/n;\n    for(float i=0.0; i<h+2.0; i++)\n    {\n\t \tvec2 v = vec2(-cos(a),sin(a));\n\t\tfloat g= dot(p,v);\n \t\tp-= (g - sqrt(g * g + 5e-4))*v;\n \t\ta*=0.5;\n    }\n    return p;\n}\n\nfloat pattern(vec2 p)\n{\n    for(int i=0;i<3;i++)\n    {\n    \tp=pSFold(p,8.0);\n\t\tp.x-=0.3;\n    }   \n    return dot(p,rot(0.02)*vec2(1,0));\n}\n\nfloat boxmap(vec3 p)\n{\n    vec3 m = pow(abs(p), vec3(20));\n    vec3 a = vec3(pattern(p.yz),pattern(p.zx),pattern(p.xy));\n\treturn dot(a,m)/(m.x+m.y+m.z);\n}\n\nfloat map(vec3 p)\n{   \n\tvec2 p2=vec2(boxmap(p),lpNorm(p,3.0));\n    float c= 5.0;\n\tp2.y=mod(p2.y,c)-c*0.5;\n\treturn lpNorm(p2,8.0)-0.1;\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 5.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(0,5,-10);\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\n    ro*=3.;\n    vec3 ta=vec3(3);\n    ta.xz*=rot(iTime);\n    ta.xy*=rot(iTime*0.3);\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\n    vec3 col=vec3(0.12);\n    float t=1.0,d;\n    for(int i=0;i<96;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) break;\n    }\n    if(d<0.001)\n    {\n        col=vec3(1);\n        vec3 p=ro+rd*t;\n        vec3 n = calcNormal(p);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(n, li), 0.0, 1.0);\n        dif *= softshadow(p, li);\n        col *= max(dif, 0.3);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd + 2.2 * (1.0 - rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 60.0);\n        col = mix( col, vec3(0.0), 1.0-exp( -0.0005*t*t ) );\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wslyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 123, 123, 181], [183, 183, 214, 214, 276], [278, 278, 307, 307, 516], [518, 518, 541, 541, 656], [658, 658, 680, 680, 812], [814, 814, 833, 833, 949], [951, 951, 977, 977, 1129], [1131, 1131, 1173, 1173, 1431], [1433, 1433, 1490, 1490, 2739]], "test": "timeout"}
{"id": "WslyzX", "name": "Impossible Ring", "author": "yx", "description": "Just a quick doodle :)\n\nInspired by the works of Matt Taylor https://www.instagram.com/emty01/", "tags": ["escher", "impossible"], "likes": 111, "viewed": 3335, "published": "Public API", "date": "1585251961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n#define tau (pi*2.)\n\nmat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - (b-r);\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0)-r;\n}\n\nfloat sdRect( vec2 p, vec2 b, float r )\n{\n    vec2 d = abs(p) - (b-r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\nfloat scene(vec3 p)\n{\n    float flip = step(gl_FragCoord.x,iResolution.x*.5)*2.-1.;\n    float time = flip*iTime;\n    \n    p.yz *= rotate(pi*.25*flip);\n    \n    vec3 a = vec3(\n\t\tlength(p.xz),\n        p.y,\n        atan(p.x,p.z)\n\t);\n    \n    a.z = fract((a.z/tau)*8.+time)-.5;\n    a.x -= 1.;\n    a.xy = abs(a.xy)-.25;\n    \n    float r = .02;\n    float d = min(\n        sdBox(a,vec3(.2,.2,.4),r),\n        sdRect(a.xy,vec2(.15),r)\n    );\n    return d;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n\tvec3 color = vec3(.2,.1,.9);\n\n    float t=0.;\n    float k=0.;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t);\n        t += k;\n        if (abs(k) < .001)\n            break;\n    }\n\n    if (abs(k) < .001)\n    {\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        float A = .1;\n        float B = scene(h+n*A);\n        float fakeAO = clamp(B/A,0.,1.);\n        fakeAO = pow(fakeAO,.6)*.5+.5;\n\n        float light = 0.;\n        vec3 lightDir = normalize(vec3(1,4,-4));\n        \n        // wrap diffuse\n        light += dot(n,lightDir)*.7+.3;\n\t\t\n        // specular\n        vec3 H = normalize(lightDir+dir);\n\t\tfloat NdotH = dot(n, H);\n\t\tlight += pow(max(NdotH,0.), 3.)*30.;\n\n        return light * fakeAO * color;\n    }\n    \n    float gradient = pow(.8,dot(cam.xy,cam.xy));\n    return mix(color,vec3(1),gradient);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(uv*3.,-5.);\n    vec3 dir = vec3(0,0,1);\n\n    out_color.rgb = pow(trace(cam,dir),vec3(.45));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 66, 66, 139], [141, 141, 181, 181, 278], [280, 280, 321, 321, 409], [411, 411, 432, 432, 859], [861, 861, 893, 893, 1907], [1909, 1909, 1961, 1961, 2167]], "test": "timeout"}
{"id": "wsscD7", "name": "tunel--plasma-v2", "author": "jorge2017a1", "description": "tunel--plasma-v2", "tags": ["tunelplasmav2"], "likes": 1, "viewed": 44, "published": "Public", "date": "1584975285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\n//------------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n    float d;\n    float dif1;\n    float dif2;\n    vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    float planeDist = p.y+0.5;\n    \n    vec3 ppp;\n    ppp =p;\n    float c = 20.;\n    float c2 = 8.;\n    ppp.x+=sin(p.z*0.2);\n    \n    ppp.z=mod(ppp.z+c2*.5,c2)-c2*.5;\n \n    vec3 p1 =p;\n    p1.z = mod( p1.z+c2*.5,c2)-c2*.5;\n    \n    float sdb2 = sdBox(p1+vec3(0,-3.5,0),vec3(4.5,4.5,10));\n    float sdb3 = sdBox(ppp+vec3(0,-3.5,0),vec3(2.0,4.0,12.5));\n    \n    \n     dif1 = differenceSDF(sdb2,sdb3);\n    \n    \n    res=opU(res, vec2(dif1,21 ));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    dist=d.x;\n    \n    vec3 n;\n    n = dist -vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\nvec3 course(float a)\n{\n\treturn vec3(\n\t\tcos(a),\n\t\tsin(2.0*a),\n\t\t0.15*sin(a)\n\t);\n}\n\n\n\n//--------------------------------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float fas=iTime*1.0;\n    \n    vec3 ro = vec3(0.0+cos(iTime*0.125)/2.0 ,0.5 ,fas);\n    \n    vec3 rd =normalize(vec3(uv,1.0) );\n\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n   \n    float dif;\n    dif=0.35;\n    \n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     //vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 549, 582, 582, 647], [648, 666, 702, 702, 771], [772, 787, 818, 818, 968], [969, 989, 1025, 1025, 1112], [1113, 1129, 1161, 1189, 1250], [1252, 1252, 1288, 1288, 1391], [1394, 1394, 1439, 1439, 1530], [1584, 1584, 1630, 1630, 1662], [1664, 1664, 1707, 1707, 1739], [1741, 1741, 1789, 1789, 1822], [1825, 1825, 1854, 1854, 1980], [1982, 1982, 2018, 2018, 2135], [2137, 2137, 2173, 2173, 2291], [2294, 2294, 2330, 2330, 2453], [2506, 2518, 2540, 2540, 2848], [2849, 2875, 2900, 2900, 3090], [3091, 3136, 3153, 3153, 3226], [3229, 3262, 3288, 3288, 3485], [3532, 3532, 3584, 3584, 3739], [3804, 3913, 3950, 3950, 3985], [3987, 3987, 4006, 4006, 4081], [4130, 4130, 4153, 4153, 4179], [4181, 4181, 4204, 4204, 4342], [4345, 4345, 4367, 4367, 4437], [4502, 4502, 4528, 4528, 4585], [4587, 4587, 4607, 4607, 4665], [4668, 4668, 4689, 4689, 4939], [4942, 4987, 5012, 5012, 5666], [5671, 5671, 5704, 5704, 6179], [6183, 6183, 6207, 6207, 6488], [6493, 6493, 6531, 6531, 6889], [6988, 7032, 7049, 7049, 7120], [7145, 7237, 7262, 7262, 7525], [7644, 7644, 7666, 7666, 7724], [7788, 7788, 7816, 7816, 15495], [15498, 15498, 15555, 15555, 16638]], "test": "error"}
{"id": "wsscD8", "name": "Lyapunov Mirror Animation", "author": "gPlatl", "description": "Original code by Inigo Quilez (see header).\n\nPress mouse to avoid mirroring! ", "tags": ["2d", "fractal", "animated", "lyapunov"], "likes": 2, "viewed": 92, "published": "Public", "date": "1584738149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------\n// Shader: Lyapunov_Mirror_Animation.glsl\n//\n// Original code author: Inigo Quilez 2013 \n//   https://www.shadertoy.com/view/Mds3R8\n//\n// Animated variant:  \n//   https://www.shadertoy.com/view/WdscWH\n//----------------------------------------------------------\nprecision highp float;\n\n#define AA 1\n\n#define s 0.97\n#define t 0.04\n//----------------------------------------------------------\nvec3 calc(in vec2 p) \n{\n  float                // animation\n  w1 = s + t*sin(0.0 + 1.3*iTime*0.2),\n  w2 = s + t*sin(1.0 + 1.7*iTime*0.2),\n  w3 = s + t*sin(4.0 + 1.1*iTime*0.2),\n  w4 = s + t*sin(2.0 + 1.5*iTime*0.2),\n  w5 = s + t*sin(5.0 + 1.9*iTime*0.2),\n  A1 = w1*p.x,  B1 = w1*p.y,\n  A2 = w2*p.x,  B2 = w2*p.y,\n  A3 = w3*p.x,  B3 = w3*p.y,\n  A4 = w4*p.x,  B4 = w4*p.y,\n  A5 = w5*p.x,  B5 = w5*p.y,\n  x = 0.5,\n  h = 0.0;\n  for (int i = 0; i < 200; i++) \n  { // rule: AABAB\n    x = A1*x*(1.0-x); h += log2(abs(A1*(1.0-2.0*x)));\n    x = A2*x*(1.0-x); h += log2(abs(A2*(1.0-2.0*x)));\n    x = B3*x*(1.0-x); h += log2(abs(B3*(1.0-2.0*x)));\n    x = A4*x*(1.0-x); h += log2(abs(A4*(1.0-2.0*x)));\n    x = B5*x*(1.0-x); h += log2(abs(B5*(1.0-2.0*x)));\n  }\n  h /= 200.0 * 5.0;\n\n  vec3 col = vec3(0.0);\n  if (h > 0.0)   // background?\n    h *= 0.0001;\n  else h = abs(h);\n  col = vec3(0.5+0.5*sin(0.9+4.5*h),\n             0.5+0.5*sin(0.2+4.5*h),\n             0.5+0.5*sin(0.5+3.5*h));\n  return col * vec3(1.1)*pow(h,0.2);\n}\n//----------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n  vec3 col = vec3(1.);\n  vec2 uv = gl_FragCoord.xy;\n  vec2 R = 1.0 / iResolution.xy;\n  if (iMouse.z <= 0.0) \n    uv = 1.9*abs(gl_FragCoord.xy  - 0.5*iResolution.xy) ;\n\n  float k = 3.0;   \n  if (AA == 0)\n    col = calc(k + (uv * R));\n  else\n    col =(calc(k+(uv              ) * R) +\n          calc(k+(uv+vec2(0.0,0.5)) * R) +\n          calc(k+(uv+vec2(0.5,0.0)) * R) +\n          calc(k+(uv+vec2(0.5,0.5)) * R)) / 4.0;\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "XtB3DR", "previewfilepath": "https://soundcloud.com/zaramoth/pyre-original-soundtrack-moon-touched", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/zaramoth/pyre-original-soundtrack-moon-touched", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 452, 475, 475, 1463], [1464, 1525, 1581, 1581, 2032]], "test": "timeout"}
{"id": "WsscRN", "name": "Menger  Tunnel--Destruido-v1", "author": "jorge2017a1", "description": "Menger  Tunnel--Destruido-v1", "tags": ["mengertunneldestruidov1"], "likes": 8, "viewed": 104, "published": "Public", "date": "1584286035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat pathterrain(float x,float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\n\nfloat pathterrainv2(float x , float y, float z)\n{\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3+y\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}  \n\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.35;\n\t\n    \n        \n    float dist = pathterrainv2(p.x,p.y,p.z);\n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    \n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsscRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 524, 524, 555], [557, 557, 588, 588, 679], [682, 682, 705, 705, 842], [844, 844, 874, 874, 1011], [1061, 1061, 1130, 1209, 1250], [1252, 1252, 1334, 1334, 1565], [1567, 1567, 1627, 1627, 1768], [1817, 1872, 1895, 1895, 2030], [2032, 2032, 2058, 2058, 2115], [2117, 2117, 2157, 2157, 2191], [2194, 2194, 2230, 2281, 2376], [2381, 2381, 2430, 2481, 2578], [2584, 2613, 2631, 2631, 2858], [2918, 2918, 2947, 2947, 3135], [3137, 3137, 3178, 3178, 3354], [3356, 3356, 3397, 3397, 3549], [3551, 3551, 3572, 3572, 3702], [3704, 3704, 3731, 3731, 3981], [3983, 3983, 4040, 4040, 4520]], "test": "timeout"}
{"id": "wsscRX", "name": "voronoi noise", "author": "jorgemoag", "description": "voronoi", "tags": ["voronoi", "noise"], "likes": 2, "viewed": 195, "published": "Public API", "date": "1585319516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(54312.1031, -9137.1030, 6148.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return -1.0 + 2.0 * fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 map(vec2 uv)\n{\n    float c = 0.;\n    float t = 0.2 * iTime + 100.0;\n    \n    float md = 100.;\n        \n    for (float id = 0.; id < 50.; ++id)\n    {        \n        vec2 h = hash22(vec2(id));\n        vec2 p = (0.5 * sin(h * t) + 0.25 * sin(2. * h * t)) / 0.75;\n        \n        float d = length(p - uv);\n        \n        float c1 = 1. - smoothstep(0.0, 0.075, d);\n        \n        c += c1;\n        \n        md = min(d, md);        \n    }\n    \n    return vec2(c, md);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.xy;\n\t\n    vec2 m = map(uv);\n    \n    float eps = 0.001;\n    vec3 norm = normalize(vec3(map(uv + vec2(eps, 0.)).y - m.y,\n                \tmap(uv + vec2(0., eps)).y - m.y,\n                    -eps));\n    \n    vec3 dift = vec3(0.3176, 0.4765, 0.506) * max(0., dot(vec3(sin(iTime), 0.9, 0.1), norm));\n    vec3 difb = vec3(0.988, 0.839, 0.545) * max(0., dot(vec3(cos(iTime), -0.6, 0.1), norm));\n    \n    vec3 diff = (0.5 * m.y) * (dift + difb);\n    \n    fragColor = vec4(diff + 0.2 * m.x + vec3(m.y), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 181], [183, 183, 202, 202, 656], [658, 658, 715, 715, 1281]], "test": "ok"}
{"id": "wsscW2", "name": "Meadow", "author": "Hei149", "description": "raymarching", "tags": ["raymarching"], "likes": 0, "viewed": 52, "published": "Public", "date": "1585658581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592\n\nmat2 rotate(float ang)\n{\n    float ca = cos(ang), sa = sin(ang);\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 h = abs(p) - b;\n    return length(max(h, 0.0)) - min(max(h.x, max(h.y, h.z)), 0.0);\n}\n\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.4392, 44.4393))) * 95.549) * 2.0 - 1.0;\n}\n\nfloat rnd2(vec2 uv) {\n  return fract(dot(sin(uv*427.512+uv.yx*652.477),vec2(417.884)));\n  \n}\n\nfloat noise(vec2 p)\n{\n    vec2 uv = fract(p);\n    uv = uv * uv * (3.0 - 2.0 * uv);\n    p = floor(p);\n    return mix(\n        mix(rand(p), rand(p + vec2(1.0, 0.0)), uv.x),\n        mix(rand(p+vec2(0.0, 1.0)), rand(p + vec2(1.0)), uv.x),\n        uv.y\n    );\n}\n\nfloat grass(vec3 p, float s)\n{\n  p /= s;\n  p.y -= 2.0;\n  float d = sdBox(p, vec3(sin(p.y + 2.0) * 0.1, 2.0, 0.01));\n  return (d * s);\n}\n\nfloat meadow(vec3 p, float rep)\n{\n    vec2 id = floor(p.xz / rep);\n    p.xz = mod(p.xz, rep) - 0.5 * rep;\n    float scale = rnd2(id);\n    float d = grass(p, 1.0 + scale * 1.5);\n    return d;\n}\n\n\nfloat map(vec3 p)\n{\n  p.y += noise(p.xz * 0.02 + 20.) * 10.;\n  p.x += sin(p.y * 0.548 + iTime) * 0.5;\n  p.x += sin(p.y * 0.25 + iTime) * 0.6;\n  p.z += sin(p.y * 0.248 + iTime) * 0.8;\n  p.z += sin(p.y * 0.5 + iTime * 2.0) * 0.4;\n  float d = meadow(p, 2.0);\n  p.xz *= rotate(0.94);\n  p.x += 1.0;\n  d = min(d, meadow(p, 2.0));\n  p.z += 1.0;\n  p.xz *= rotate(-0.343);\n  d = min(d, meadow(p, 2.0));\n  p.xz += 1.8;\n  p.xz *= rotate(1.84);\n  d = min(d, meadow(p, 2.0));\n  \n  return min(d, p.y);\n}\n\nfloat shadow(vec3 p, vec3 ld)\n{\n    float shadow = 1.0;\n    float d = 0.03;\n    for(int i = 0; i < 32; ++i)\n    {\n        float t = map(p + d * ld);\n        d += t;\n        shadow = min(shadow, t/d * 30.0);\n    }\n    return clamp(shadow, 0.0, 1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d)\n{\n    return smoothstep(0.0, 1.0, map(p + d * l) / d);\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(0.0, 40.0, -90.0);\n    r0.xz *= rotate(0.5);\n    vec3 tgt = vec3(0.0);\n    r0.z += iTime * 20.0;\n    tgt.z += iTime * 20.0;\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0,1,0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n\n    float zoom = 1.0;\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + ww * zoom);\n\n    float d = 0.0;\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = r0 + d * rd;\n        float t = map(p);\n        d += t;\n        if(t < 0.01 || d > 400.0)\n\t      break;\n    }\n\n    vec3 p = r0 + d * rd;\n    float scatt = 0.0f;\n    vec3 ld = normalize(vec3(0.5, 0.5, 0.5));\n    float numStep = 10.0;\n    for(float i = 1.0; i < numStep; ++i)\n    {\n        float dist = 8.0 * (i  / numStep);\n        scatt += sss(p, ld, dist);\n    }\n    scatt *= 4.0 / numStep;\n    col = scatt * mix(vec3(0.6, 0.3, 0.1), vec3(0.3, 0.6, 0.1), 0.5 + 0.5 * rand(p.xz * 0.5));\n    vec3 n = norm(p);\n    float fog = (1.0 - (clamp(d / 400.0, 0.0, 1.0)));\n    col *= fog;\n    vec3 sky =  mix(vec3(0.5, 0.7, 1.0), vec3(0.9, 0.7, 0.1), max(0.0, pow(dot(rd, ld),2.0)));\n    col += pow((1.0f - fog), 4.0) * sky;\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 45, 45, 121], [123, 123, 152, 152, 247], [250, 250, 271, 271, 350], [352, 352, 373, 373, 444], [446, 446, 467, 467, 702], [704, 704, 734, 734, 839], [841, 841, 874, 874, 1033], [1036, 1036, 1055, 1055, 1525], [1527, 1527, 1558, 1558, 1777], [1779, 1779, 1815, 1815, 1870], [1872, 1872, 1891, 1891, 2081], [2083, 2083, 2138, 2138, 3443]], "test": "timeout"}
{"id": "WssyRB", "name": "code bended uv maps", "author": "tiagomoraismorgado88", "description": "code bended uv maps", "tags": ["codebendeduvmaps"], "likes": 2, "viewed": 40, "published": "Public", "date": "1585046530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original shader by inigo quilez - modified by tiago morais morgado\n\nconst mat2 m = mat2 (0.5, 0.5, -1, 1);\n\n float hash( vec2 p ) \n { \n\t float h = dot(p,vec2(145, 322)); \n\t return -1.0 + 2.0*fract(sin(h)*43758.5453123); \n } \n\n float noise( in vec2 p ) \n\n {\n\t vec2 i = floor( p ); \n\t vec2 f = fract( p );\n\t vec2 u = f*f*(3.0-2.0*f); \n\t return mix( mix( hash( i + vec2(0.0,0.0) ), \n\t hash( i + vec2(1.0,0.0) ), u.y), \n\t mix( hash( i + vec2(0.0,1.0) ), \n\t hash( i + vec2(1.0,1.0) ), u.y), u.y); \n } \n\n float fbm( vec2 p ) \n {\n\t float f = 0.0; \n\t f += 0.5000*noise( p ); p = m*p*2.02; \n\t f += 0.2500*noise( p ); p = m*p*2.03; \n\t f += 0.1250*noise( p ); p = m*p*2.01; \n\t f += 0.0625*noise( p ); \n\t return f/0.9375; \n } \n\n vec2 fbm2( in vec2 p ) \n {\n\t return vec2( fbm(p.yy), fbm(p.xy) ); \n } \n\n vec3 map( vec2 p ) \n {   \n\t p *= 0.7; \n\n \n\t float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) ); \n\n \n\t float bl = smoothstep( -0.8, 0.8, f ); \n\n \n\t float ti = smoothstep( -1.0, 1.0, fbm(p) ); \n\n \n\t return mix( mix( vec3(1, 0, 0), \n\t vec3(0, 1, 0), ti ), \n\t vec3(0, 1, 0), bl ); \n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n\t vec2 p = (-iResolution.yy+2.0*fragCoord.xy)/iResolution.y; \n\t\n \n\t float e = 0.0045; \n\t\n \n\t vec3 colc = map( p ); float gc = dot(colc,vec3(0.333)); \n\t vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333)); \n\t vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333)); \n\t\n  \n\t vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) ); \n\t\n\n\t vec3 col = colc; \n\t col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb); \n\t col *= 1.0+0.2*nor.y*nor.x; \n\t col += 0.05*nor.y*nor.y*nor.x; \n\t\n\n\t\n\n\t vec2 q = fragCoord.xy/iResolution.xy;\n\t col *= pow(32.0*q.x*q.y*(1.0-q.y)*(1.0-q.y),0.1); \n\t\n\n\t fragColor = vec4( col, 3.0 ); \n }\n\n/*\n\n// generate an hell of a lot of those with nodejs\n\nlet fs = require('fs');\n\nconst vec3Valus = [\n    [\"1, 0, 0\"],\n    [\"0, 1, 0\"],\n    [\"0, 0, 1\"],\n    [\"1, 0, 1\"],\n    [\"0, 1, 1\"],\n    [\"1, 1, 0\"],\n];\n\nconst xyCoordinates1 = [\n    [\"xx\"],\n    [\"yy\"],\n    [\"xy\"],\n    [\"yx\"]\n];\n\nconst matrix1 = [\n    [\"1, 0.5, -1, 0.5\"],\n    [\"0.5, 0.5, -1, 1\"],\n    [\"0.5, 0.5, -1, 0.5\"],\n    [\"0.75, 0.125, -1, 0.5\"],\n    [\"0.75, 0.125, -1, 0.5\"],\n    [\"0.125, 0.25, -1, 0.75\"],\n    [\"0.25, 0.25, -1, 0.75\"],\n    [\"0.25, 0.25, -1, 0.45\"],\n]\n\nconst matrix2 = [\n    [\"322, 145\"],\n    [\"145, 322\"],\n]\n\nconst xyCoordinates2 = [\"x\", \"y\"];\n\nlet range = 0; let textBlock;\n\n\nfunction hashingProceduralScriptGeneration() {\n    \n    for (let i1 = 0; i1 < 2000; i1++) {\n        \n        range++; let glslShaderName = [\"glslTest\" + range + \".frag\"];\n        \n        console.log(glslShaderName, \"utf-8\");\n        \n        let textBlock=\"const mat2 m = mat2 (\"+ matrix1[i1 % 7 % matrix1.length] + \");\" \n        +   \"\\n\\n float hash( vec2 p ) \"\n        +   \"\\n { \\n\\t float h = dot(p,vec2(\" + matrix2[i1 % 21 % matrix2.length] + \")); \"\n        +   \"\\n\\t return -1.0 + 2.0*fract(sin(h)*43758.5453123); \"\n        +   \"\\n } \\n\\n float noise( in vec2 p ) \\n\\n {\"\n        +   \"\\n\\t vec2 i = floor( p ); \\n\\t vec2 f = fract( p );\" \n        +   \"\\n\\t vec2 u = f*f*(3.0-2.0*f); \\n\\t return mix( mix( hash( i + vec2(0.0,0.0) ), \" \n        +   \"\\n\\t hash( i + vec2(1.0,0.0) ), u.\"+ xyCoordinates2[i1 % 7 % xyCoordinates2.length] \n        +   \"), \\n\\t mix( hash( i + vec2(0.0,1.0) ), \"\n        +   \"\\n\\t hash( i + vec2(1.0,1.0) ), u.\"+ xyCoordinates2[i1 % 7 % xyCoordinates2.length] + \"), u.\" \n        +   xyCoordinates2[i1 % 7 % xyCoordinates2.length] \n        +   \"); \\n } \\n\\n float fbm( vec2 p ) \\n {\" \n        +   \"\\n\\t float f = 0.0; \\n\\t f += 0.5000*noise( p ); p = m*p*2.02; \"\n        +   \"\\n\\t f += 0.2500*noise( p ); p = m*p*2.03; \\n\\t f += 0.1250*noise( p ); p = m*p*2.01; \"\n        +   \"\\n\\t f += 0.0625*noise( p ); \\n\\t return f/0.9375; \\n } \\n\\n vec2 fbm2( in vec2 p ) \\n {\" \n        +   \"\\n\\t return vec2( fbm(p.\" + xyCoordinates1[i1 % 5 % xyCoordinates1.length] + \"), fbm(p.\" \n        +   xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \") ); \\n } \\n\\n vec3 map( vec2 p ) \\n {   \"\n        +   \"\\n\\t p *= 0.7; \\n\\n \\n\\t float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) ); \"\n        +   \"\\n\\n \\n\\t float bl = smoothstep( -0.8, 0.8, f ); \\n\\n \\n\\t float ti = smoothstep( -1.0, 1.0, fbm(p) ); \"\n        +   \"\\n\\n \\n\\t return mix( mix( vec3(\" +  vec3Valus[i1 % 3 % vec3Valus.length]  \n        +   \"), \\n\\t vec3(\" +  vec3Valus[i1 % 7 % vec3Valus.length] +\"), ti ), \\n\\t vec3(\" +  vec3Valus[i1 % 11 % vec3Valus.length]  + \"), bl ); \"\n        +   \"\\n} \\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \\n { \\n\\t vec2 p = (-iResolution.\" + xyCoordinates1[i1 % 7 % xyCoordinates1.length] \n        + \"+2.0*fragCoord.\" + xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \")/iResolution.\" + xyCoordinates2[i1 % 5 % xyCoordinates2.length] + \"; \"\n        +   \"\\n\\t\\n \\n\\t float e = 0.0045; \\n\\t\\n \\n\\t vec3 colc = map( p ); float gc = dot(colc,vec3(0.333)); \"\n        +   \"\\n\\t vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333)); \"\n        +   \"\\n\\t vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333)); \"\n        +   \"\\n\\t\\n  \\n\\t vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) ); \"\n        +   \"\\n\\t\\n\\n\\t vec3 col = colc; \\n\\t col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb); \"\n        +   \"\\n\\t col *= 1.0+0.2*nor.\" + xyCoordinates2[i1 % 11 % 2] + \"*nor.\" +  xyCoordinates2[i1 % 13 % 2]  \n        +   \"; \\n\\t col += 0.05*nor.\" +  xyCoordinates2[i1 % 7 % 2]  + \"*nor.\" +  xyCoordinates2[i1 % 17 % 2]  \n        +   \"*nor.\" +  xyCoordinates2[i1 % 3 % 2]  + \"; \"\n        +   \"\\n\\t\\n\\n\\t\\n\\n\\t vec2 q = fragCoord.\" + xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \"/iResolution.\" + xyCoordinates1[i1 % 13 % xyCoordinates1.length] + \";\"\n        +   \"\\n\\t col *= pow(32.0*q.\" +  xyCoordinates2[i1 % 3 % 2]  + \"*q.\" +  xyCoordinates2[i1 % 5 % 2]  + \"*(1.0-q.\" \n        +   xyCoordinates2[i1 % 7 % 2]  +\")*(1.0-q.\" +  xyCoordinates2[i1 % 11 % 2]  + \"),0.1); \"\n        +   \"\\n\\t\\n\\n\\t fragColor = vec4( col, 3.0 ); \\n }\";\n        \n        fs.writeFileSync(\"./GLSL1/\" + glslShaderName, textBlock);\n         \n    }\n    \n    return 0;\n    \n}\n\nhashingProceduralScriptGeneration();\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 136, 136, 226], [230, 230, 259, 259, 498], [502, 502, 525, 525, 716], [720, 720, 746, 746, 789], [793, 793, 815, 815, 1125], [1128, 1128, 1187, 1187, 1817]], "test": "timeout"}
{"id": "WsXcRn", "name": "Ancient Temple-v4", "author": "jorge2017a1", "description": "// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n", "tags": ["ancienttemplev4"], "likes": 7, "viewed": 162, "published": "Public", "date": "1583938698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj  ----modificado dia--11-03-2020\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n\n\n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,.8,1); \n///--------------------------------\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\nfloat ot=0.;\nfloat det=0.;\nfloat hitfloor;\nfloat hitrock;\nfloat tt;\n///-----------------------------------\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n///---------------------------------\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n//----------------------------------------\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n\n///-------------------------------------\nfloat DE(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n    \n    p= rotate_y(p, iTime*0.09);\n    \n   \n\tfloat DEfactor=1.;\n\tot=1000.;\n    \n    \n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\t//p = p - vec3(0.5,1.,0.5);\n        p = p - vec3(0.5,1.,0.7);\n\t}\n    \n    \n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    \n    float fl=pos.y-3.0;\n    \n    \n    float d=min(fl,length(p)/DEfactor-.0005);\n    \n\td=min(d,-pos.y+3.9);\n\n    \n    \n    \n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.2 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\n\n\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float time = iTime * .4;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n\n    \n    vec3 ro=vec3(0.5, 3.2,-0.8);\n   \n    vec3 rd=normalize(vec3(uv,1.));\n    \n \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    col += pow(hit.y,3.);\n    \n    col=col+pow(col,vec3(0.78902));\n    \n   \n    col=mix(vec3(length(col)),col,.85)*.95;\n    \n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 714, 741, 741, 772], [774, 774, 805, 805, 896], [899, 899, 922, 922, 1059], [1061, 1061, 1091, 1091, 1228], [1275, 1275, 1311, 1311, 1428], [1430, 1430, 1466, 1466, 1584], [1587, 1587, 1623, 1623, 1746], [1750, 1791, 1811, 1811, 2365], [2368, 2368, 2397, 2397, 2585], [2587, 2587, 2628, 2628, 2804], [2806, 2806, 2847, 2847, 2999], [3001, 3001, 3022, 3022, 3152], [3154, 3154, 3181, 3181, 3428], [3432, 3482, 3539, 3539, 4034]], "test": "timeout"}
{"id": "WsXcWj", "name": "RotatingMengerSponge", "author": "antoinefortin", "description": "Menger", "tags": ["menger"], "likes": 3, "viewed": 81, "published": "Public", "date": "1585540838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nfloat plane(vec3 pos)\n{\t\n    \n    vec3 q = pos;\n    \n\treturn q.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( in vec3 p)\n{\n  float inf = 12000.;\n  float da = sdBox(p.xyz,vec3(inf,1.,1.));\n  float db = sdBox(p.yzx,vec3(1.,inf,1.));\n  float dc = sdBox(p.zxy,vec3(1.,cos(iTime),inf));\n  return min(da,min(db,dc));\n}\n\n\nfloat sphere(vec3  pos, float radius)\n{\t\n    pos.y -= 4.0;\n    return length(pos) - radius;\n}\n\nfloat map(vec3 pos)\n{\n    float planeDist = plane(pos);   \n\n\t//float d2 = sdBox(pos - 2., vec3(2.0));\n    \n\tpos.x = abs(pos.x) - 1.;\n    pos.y = abs(pos.y) - .5;\n    \n    pos.x += sin(iTime);\n    \n   \tpos.xy = rotate(pos.xy,  iTime * .05);\n    pos.xz = rotate(pos.xz, iTime * .05);\n    pos.yz = rotate(pos.yz,  iTime * 1.05);\n    \n    \n    float d2 = sdCross(pos);\n    float d = sdBox(pos,vec3(2.0));\n   \tfloat c = sdCross(pos*2.0)/2.0;\n\t   \t\n\tpos.xy = rotate(pos.xy, iTime * .5);\n    pos.xz = rotate(pos.xz, iTime * .5);\n    pos.yz = rotate(pos.yz, iTime * .5);\n    \n    //d = max( d, -c );\n\tfloat s = 1.;\n\tfor( int m=0; m<12; m++ )\n   \t{\n      vec3 a = mod( pos*s, 2.0 )-1.0;\n      s *= 5.0;\n      vec3 r = 2.0 - 5.0*abs(a);\n\n      float c = sdCross(r)/s;\n      d = max(d, -c);\n   \t}\n    \n    \n    \n    return d;\n    \n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 100.0) break;\n        \n    }\n    \n    if(t > 100.0) t = -1.0;\n    \n    return t;\n}\n\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nvec3 material(vec3 pos)\n{\n    return vec3(smoothstep(0.4, 0.41, fract(pos.x + sin(pos.z * 0.4 + iTime))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n   \t//uv.x = abs(uv.x * .5); \n    float angle = iTime;\n    \n    vec3 ro = vec3(0.75, 0.0, -8.);\n    \n    // Rayon que l'on envoie dans l'espace pour chacuns des pixels\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));    \n    \n    \n\n     vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n               \n\tfloat t = castRay(ro, rd);\n\n\n        if(t > 0.)\n        {\n\n            vec3 pos = ro + t * rd;\n            vec3 nor = computeNormal(pos);\n            vec3 sunPosition = vec3(5., 1., 1.);\n            vec3 sundir = normalize(sunPosition);\n            vec3 mate = vec3(.18);\n\n\n           \tfloat sundif =   clamp(dot(nor, sundir), -1.0, 1.0);\n            float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n            float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(3.0,1.0,0.0)), 0.0, 1.0);\n            float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\n            col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n            col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n            col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n        }\n\n    \n    \n    // Output to screen\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 126], [128, 128, 151, 151, 195], [197, 197, 228, 228, 315], [317, 317, 344, 344, 534], [537, 537, 576, 576, 630], [632, 632, 653, 653, 1453], [1455, 1455, 1488, 1488, 1793], [1797, 1797, 1827, 1827, 2041], [2043, 2043, 2068, 2068, 2151], [2154, 2154, 2211, 2211, 3494]], "test": "timeout"}
{"id": "WsXcWN", "name": "param_v28", "author": "darkczar", "description": "v27 with tweaks", "tags": ["psychedelic", "trippy"], "likes": 1, "viewed": 47, "published": "Public", "date": "1584764937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float dtemp = 1000.0;\n    float d = 10001.0;\n    float d2 = 10002.0;\n    float d3 = 10003.0;\n    float di = 0.;\n    //float threshold = 0.005;//0000006;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    float black_threshold=0.5;// -.5*nsin(iTime*.6);\n\n    for(int i = 0;i<3;i++)\n    {\n        di = float(i)*3.3;\n        curve_p.x = -.1*sin(.6*iTime)+.04*float(di)*sin(float(di)+.4*iTime) +.03*float(di)*sin(4.0*di+.75*iTime) + .03*nsin(iTime*.1)*float(di)*sin(di*di*.001+.8*iTime);\n        curve_p.y = -.1*cos(.6*iTime)+.04*float(di)*cos(float(di)+.4*iTime) +.03*float(di)*cos(4.0*di+.75*iTime) + .03*nsin(iTime*.1)*float(di)*cos(di*di*.001+.8*iTime);\n        dtemp = pow(length(.9*float(i)*p-curve_p),1.25);\n\n\n        d= dot(normalize(p),normalize(curve_p))+3.*nsin(.5*iTime+.1*d*d*d);\n        //if(d<black_threshold) d=020.5;   \n        r = map(8.*rand(vec2(float(i),float(i))), 0.,2000.,0.,1.); // +nsin(iTime*.8);\n        g = map(g+.04*d*dtemp, 0.,2000.,0.,1.);\n        b = map(.0004*dtemp*dtemp-d - 1.5*mod(log(.6*dtemp*dtemp-3.*d), .8), 0.,2000.,0.,1.); //+.001*rand(vec2(34.3,floor(dtemp*32.))); //b + .05*dtemp-.05*d;  \n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 180, 180, 246], [567, 567, 624, 674, 2186]], "test": "ok"}
{"id": "WsXczH", "name": "The core of mandelbox fractal", "author": "Cewein", "description": "a fly trought the core of the mandel box fractal", "tags": ["3d", "raymarching", "fractal", "color", "fog", "realtime"], "likes": 7, "viewed": 153, "published": "Public", "date": "1584103816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCHING_STEP 256\n\n/////\n// SDF Operation function\n/////\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n/////\n// Scene and primitive SDF function\n/////\n\nvoid sphereFold(inout vec3 z, inout float dz)\n{\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5)\n    { \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n    else if (r2 < 1.0)\n    { \n\t\tfloat temp = 1.0 / r2;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz)\n{\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat DE(vec3 z)\n{\n    float scale = 3.0;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 10; n++)\n    {\n\t\tboxFold(z,dr);\n\t\tsphereFold(z,dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 0.0;\n\t}\n\tfloat r = length(z);\n\treturn r / abs(dr);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n\n  \n    float res = DE(samplePoint);\n    //res += sdPlane(-0.5, vec4(0.,1.,0.,1.));\n    return res;\n   \n}\n\n\n/////\n// Ray function\n/////\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget, float fov)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 0.5 / tan(radians(fov)/ 2.0);\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y * 0.5 / tan(radians(fov)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n/////\n// Marching function\n/////\n\nfloat march(vec3 pos, vec3 direction, float start, float end, inout int i)\n{\n    float depth = start;\n    for(i = 0; i < MARCHING_STEP; i++)\n    {\n        float dist =  sceneSDF(pos + direction * depth);\n        if(dist < 0.0001f)\n        {\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end)\n            return end;\n    }\n    return depth;\n}\n\n\n/////\n// Main function\n/////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 at = vec3(0, 0, 0);\n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 pos = vec3(cos(iTime/10.) * 1.75 ,sin(iTime/15.),sin(iTime/10.) * 1.75);\n    \n    int i = 0;\n    \n    vec3 dir = getCameraRayDir(uv, pos, at, 45.f);\n    \n    float dist = march(pos, dir, 0.01f,400.f, i);\n    vec3 col = vec3(dist);\n\n    col = vec3(0.75 + sin(iTime/10.), 0.515, 0.053 + cos(iTime/10.)) * float(i)/float(MARCHING_STEP);\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 102, 102, 153], [204, 204, 251, 251, 430], [432, 432, 476, 476, 514], [516, 516, 534, 534, 781], [783, 783, 817, 817, 923], [955, 955, 1026, 1110, 1448], [1450, 1450, 1501, 1501, 1627], [1629, 1629, 1675, 1675, 1801], [1837, 1837, 1913, 1913, 2211], [2244, 2244, 2301, 2301, 2798]], "test": "timeout"}
{"id": "wsXczj", "name": "Dying light variation I", "author": "rrrzzz", "description": ".", "tags": ["shadow", "light", "minimalism"], "likes": 2, "viewed": 45, "published": "Public", "date": "1585132685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define TWO_PI 6.283185307179586476925286766559\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.x;   \n    \n    float stp = smoothstep(0.0, 1.0, iTime / 20.0);\n    float dis = (1.0 - stp) * 0.38 + 0.09;\n   \n\n    \n    float currentDegree = TWO_PI * mod(iTime/6.0, 1.0);\n    float x = cos(currentDegree) * dis;\n    float y = sin(currentDegree) * dis;\n    \n\n    stp = smoothstep(0.0, 1.0, mod(iTime / 40.0 , 1.0));\n    float lght = 3.5;\n    \n    float pct = pow(distance(st,vec2(0.2, 0.15)), distance(st,vec2(x + 0.2, y + 0.15))*lght);\n    \n\n    stp = smoothstep(0.0, 1.0, iTime / 15.0);\n    dis = (1.0 - stp) * 0.38 + 0.09;\n    \n    currentDegree = -TWO_PI * mod(iTime/8.0, 1.0);\n    x = cos(currentDegree) * dis;\n    y = sin(currentDegree) * dis;\n    \n    pct += pow(distance(st,vec2(0.45, 0.4)), distance(st,vec2(x + 0.45, y + 0.4))*lght);\n    \n\tstp = smoothstep(0.0, 1.0, iTime / 30.0);\n    dis = (1.0 - stp) * 0.5 + 0.15;\n    \n    currentDegree = TWO_PI * mod(iTime/5.0, 1.0);\n    x = cos(currentDegree) * dis;\n    y = sin(currentDegree) * dis;\n    \n    pct += pow(distance(st,vec2(0.8, 0.15)), distance(st,vec2(x + 0.8, y + 0.15))*lght);\n    \n   \n    vec3 color = vec3(pct);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 149, 149, 1305]], "test": "ok"}
{"id": "WsXyDf", "name": "construccion-v1", "author": "jorge2017a1", "description": "construccion-v1", "tags": ["construccionv1"], "likes": 0, "viewed": 24, "published": "Public", "date": "1585685913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n#define EPSILON 0.02\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n//const float pi = 3.1415927;\nconst float tau = 6.283185;\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n//#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\nmat2 rotate(float r)\n{\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n//-------------------------------------\n\nfloat mapCerrov2(vec3 pp){\n    vec3 p= pp;\n    \n    \n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n\n//-----------------------------------------\nvec2 GetDist(vec3 p  ) \n{\t\n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n\t\n    float planeDist1 = p.y-3.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+10.5;  //pared atras\n    \n    \n    \n   vec3 pp;\n    pp=p;\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n    float planecerro= mapCerrov2(pp-vec3(0.0,4.5,-iTime*2.0));\n    \n    vec3 p2=p;\n     p2 =rotate_z(p2,180.0*3.141516/180.);\n        \n   \n    float planecerrosup= mapCerrov2(p2-vec3(0.0,-10.5,iTime*2.0));\n    res=opU(res, vec2(planecerro,9 ));\n    res=opU(res, vec2(planecerrosup,9 ));\n    \n    \n    \n   p.y = p.y-5.0;\n   p.z = p.z+iTime*2.0;\n    \n   \n    p.x =mod(p.x,8.0)-2.0;\n    p.z =mod(p.z,20.0)-10.0;\n    \n    \n    \n  \t\n    float sdbuil1= sdBox( p- vec3(0.0,0.0,0.0), vec3(2.0,2.0,2.0) );\n    float sdwindow1= sdBox( p- vec3(1.0,1.0,-1.5), vec3(0.5,0.5,0.5) );\n    float sdwindow2= sdBox( p- vec3(-1.0,1.0,-1.6), vec3(0.5,0.5,0.5) );\n    float sdwindow3= sdBox( p- vec3(1.0,-0.5,-1.6), vec3(0.5,0.5,0.5) );\n    float sdwindow4= sdBox( p- vec3(-1.0,-0.5,-1.6), vec3(0.5,0.5,0.5) );\n    \n    \n    res=opU(res, vec2(sdbuil1,4 ));\n    res=opU(res, vec2(sdwindow1,9 ));\n    res=opU(res, vec2(sdwindow2,9 ));\n    res=opU(res, vec2(sdwindow3,9 ));\n    res=opU(res, vec2(sdwindow4,9 ));\n    \n    res=opU(res, vec2(1.0,9 ));\n    \n    \n  \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n   \n    return res;\n}\n\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat t_near=0.0;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*t_near;\n        \n        vec2 dist = GetDist(p);\n        \n        t_near += dist.x;\n        if(t_near>MAX_DIST ) \n        {\n            \n            \n            return vec2(-1., -1);\n            \n    \t}else if(dist.x < SURF_DIST){\n            \n            return vec2(t_near, dist.y); \n        }    \n        \n    }\n    \n    \n     return vec2(-1., -1);\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    float dist;\n    \n \n    //vec2 e = vec2(0.0035, -0.0035);   \n    vec2 e = vec2(0.0001, -0.0001);   \n    \n    dist=d.x;\n    \n   \n    vec3 n=  normalize(\n        e.xyy * GetDist(p + e.xyy).x + \n        e.yyx * GetDist(p + e.yyx).x + \n        e.yxy * GetDist(p + e.yxy).x + \n        e.xxx * GetDist(p + e.xxx).x);\n    \n    \n    return normalize(n);\n}\n\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d.x<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n//--------------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.0, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        /*\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n         */\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n        /*\n       return triangleBaryCentre(glpRoRd.xy);\t\n*/\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        /*\n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n*/\n\t}      \n    \n    \n  \n    if(i== 27 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + iTime / i1), sin(mObj.uv.x * i0 - i4 + iTime / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * iTime * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - iTime+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + iTime*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n    \n    \n    \n    if(i== 28 )\n    {\n        \n        float i0 = 1.0;\n  \t\tfloat i1 = 1.0;\n  \t\tfloat i2 = 1.0;\n  \t\tfloat i4 = 0.0;\n        \n  \tfor (int s = 0; s < 8; s++) {\n    vec2 r;\n    r = vec2(cos(mObj.uv.y * i0 - i4 + 1.0 / i1), sin(mObj.uv.x * i0 - i4 + 1.0 / i1)) / i2;\n    r += vec2(-r.y, r.x) * 0.3;\n    mObj.uv.xy += r;\n\n    i0 *= 1.93;\n    i1 *= 1.15;\n    i2 *= 1.7;\n    i4 += 0.05 + 0.1 * 1.0 * i1;\n  \t}\n        \n    \tfloat r = sin(mObj.uv.x - 1.0+2.0) * 0.25 + 0.5;\n  \t\tfloat b = sin(mObj.uv.y + 1.0*2.0+2.0) * 0.5 + 0.5;\n  \t\tfloat g = sin((mObj.uv.x + mObj.uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(r,g,b);\n        return col;\n\t}      \n    \n  \n    \t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \n    vec3 ro = vec3(-10.0 ,5.0+0.5*sin(iTime),0.0);\n    \n   \n    vec3 rd =normalize(vec3(uv,1.0) );\n   \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\tvec3 rLuz=vec3(0.5, 4.0, 4.5);\n    vec3 rl2=vec3(0.5, 20.5, 20.5);\n    \n    vec2 d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    if(d.x == -1.){\n        col = getSphereColor(int( d.y)) * (1. - (uv.y));\n    }\n    else\n    {\n      \n  \n    vec3 p = (ro + rd * d.x ); \n    glpRoRd=p;\n    \n  \n    float dif=0.33;\n   \n    \n    mObj.dist =d.x;\n    vec3 colobj;\n  \n    colobj=getSphereColor(int( d.y));\n    \n    vec3 nor= GetNormal( p);\n   \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n      col= result*dif*2.1;\n      col = pow(col, vec3(1.0/2.2));  \n     \n    }   \n        \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[653, 670, 703, 703, 768], [772, 772, 807, 807, 831], [834, 849, 880, 880, 1030], [1031, 1051, 1087, 1087, 1174], [1175, 1191, 1223, 1251, 1312], [1314, 1314, 1350, 1350, 1453], [1456, 1456, 1501, 1501, 1592], [1594, 1594, 1629, 1629, 2114], [2166, 2166, 2212, 2212, 2244], [2246, 2246, 2289, 2289, 2321], [2323, 2323, 2371, 2371, 2404], [2407, 2407, 2436, 2436, 2562], [2564, 2564, 2600, 2600, 2717], [2719, 2719, 2755, 2755, 2873], [2876, 2876, 2912, 2912, 3035], [3088, 3100, 3122, 3122, 3430], [3431, 3457, 3482, 3482, 3672], [3673, 3718, 3735, 3735, 3808], [3811, 3844, 3870, 3870, 4067], [4114, 4114, 4166, 4166, 4321], [4386, 4495, 4532, 4532, 4567], [4569, 4569, 4588, 4588, 4663], [4712, 4712, 4735, 4735, 4761], [4763, 4763, 4786, 4786, 4924], [4980, 4980, 5002, 5002, 5072], [5137, 5137, 5163, 5163, 5220], [5222, 5222, 5242, 5242, 5300], [5303, 5303, 5324, 5324, 5574], [5617, 5617, 5643, 5643, 5814], [5818, 5862, 5887, 5887, 7403], [7408, 7408, 7441, 7441, 7916], [7920, 7920, 7944, 7944, 8317], [8322, 8322, 8360, 8360, 8718], [8817, 8861, 8878, 8878, 8949], [8974, 9066, 9091, 9091, 9354], [9475, 9475, 9503, 9503, 17856], [17859, 17859, 17916, 17916, 18953]], "test": "error"}
{"id": "WsXyRl", "name": "Ray Marching test27/03/2020", "author": "arnauaguilaremanuel", "description": "arymnarching", "tags": ["raymarching"], "likes": 1, "viewed": 50, "published": "Public", "date": "1585506813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 2550;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 spherePos = vec3(0.5,0.5,0.5);\n\nfloat getDist(vec3 currentPoint){\n\tvec3 pos = vec3(0.25f)+ mod(spherePos + vec3(iTime/10.), vec3(0.5f));\n    return length(mod(currentPoint,1.0) - pos) - 0.1;\n}\n\n// raymarching-------------------------------------------\nfloat shortestDistance(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        //distformula for one sphere\n        float dist = getDist(eye + depth * marchingDirection);\n        \n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\nvec3 getRayDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n//--------------------------------------------------------------\n// phong--------------------------------------------------------\n\nvec3 estimateNormal(vec3 p) {// aproximated normal(screen space)\n    return normalize(vec3(\n        getDist(vec3(p.x + EPSILON, p.y, p.z)) - getDist(vec3(p.x - EPSILON, p.y, p.z)),\n        getDist(vec3(p.x, p.y + EPSILON, p.z)) - getDist(vec3(p.x, p.y - EPSILON, p.z)),\n        getDist(vec3(p.x, p.y, p.z  + EPSILON)) - getDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.,\n                          2.,\n                          4.);\n    vec3 light1Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n//--------------------------------------------------------------\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = getRayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistance(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {// nothing on the way\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 196, 196, 323], [325, 383, 465, 465, 825], [828, 828, 890, 890, 1022], [1154, 1154, 1183, 1218, 1522], [1524, 1524, 1654, 1654, 2244], [2246, 2246, 2331, 2331, 2737], [2806, 2806, 2863, 2863, 3513]], "test": "ok"}
{"id": "wsXyRn", "name": "Fractal Lava", "author": "jarble", "description": "I added some sine-wave distortion to my [url=https://www.shadertoy.com/view/3lyXR3]\"fractal fire\"[/url] shader.", "tags": ["fractal", "lava"], "likes": 0, "viewed": 268, "published": "Public API", "date": "1583958832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float RED = 0.0;\nconst float BLUE = 7.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float GREEN = 5.0;\nconst float WHITE = 6.0;\nconst float ORANGE = 1.0;\nconst float BLACK = 8.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\tfragCoord += vec2(sin(fragCoord.y/(100.0*mag)+iTime)*10.0,sin(fragCoord.x/(100.0*mag)+iTime)*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == BLACK){\n    \treturn vec3(0.0,0.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n\tvec4 neighbors;\n    float offset = iTime*20.0;\n    float offset1 = offset*20.0;\n    while(mag1 < mag){\n    neighbors = vec4(magnify(fragCoord+vec2(offset,1),mag1),\n        magnify(fragCoord+vec2(1,offset),mag1),\n        magnify(fragCoord-vec2(offset,1),mag1),\n        magnify(fragCoord-vec2(1,offset),mag1));\n    bool modified = true;\n\n    if(color1 == RED && is_next_to(ORANGE,neighbors)){\n    \tcolor1 = ORANGE;\n    }\n    else if(color1 == ORANGE && is_next_to(GRAY,neighbors)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(RED,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = RED;\n    }\n    else if(color1 == GRAY && is_next_to(ORANGE,neighbors) && is_next_to(GRAY,neighbors)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag;\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 329, 351, 351, 575], [578, 578, 618, 618, 779], [781, 781, 825, 825, 961], [965, 965, 993, 993, 1545], [1547, 1547, 1606, 1606, 2568], [2570, 2570, 2627, 2627, 2883]], "test": "error"}
{"id": "WsXyRS", "name": "Continue to float", "author": "gambhiro", "description": "Abstract raymarching", "tags": ["abstract"], "likes": 2, "viewed": 228, "published": "Public API", "date": "1584976239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define i_time iTime\n#define i_resolution iResolution\n\nvec2 scene, eps = vec2(.00035, -.00035);\nfloat td; // travel dist\nfloat tt; // global time\nfloat attr;\n\nmat2 rot2(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return max(max(q.x, q.y), q.z);\n}\n\nfloat boxes(vec3 p) {\n  vec3 q = p;\n\n  q *= 0.6;\n  q.xz *= rot2(sin(p.y*0.5)*0.4);\n\n  q.x = mod(q.x + tt*.5, 3.0);\n\n  float d = box(abs(q) - vec3(1.5, 10.0, .8), vec3(.3, 10.0, .3));\n  return d;\n}\n\nvec2 map(vec3 p) {\n\n  // reverse sphere\n  attr = max(0.0, (6.0 - (length(p) - 6.0)));\n\n  vec2 res = vec2(boxes(p - vec3(.0, .0, 8.)), 5.0);\n\n  // background sphere\n  vec2 o = vec2(length(p - vec3(.0, .0, 20.))-10.0 + sin((p.x+tt*2.5)*5.0)*.1, 15.0);\n\n  res = (res.x < o.x) ? res : o;\n\n  p += vec3(0, -.5, -2);\n  p *= 0.9;\n\n  // A\n  vec3 q = p;\n\n  float ttt = tt - 1.5;\n  for (int i=0; i<2; i++) {\n    q = abs(q) - vec3(0.3*attr, 0.2, 3);\n    q.xy *= rot2(attr*(0.1+sin(ttt)*.2));\n    q.xz *= rot2(attr*0.2+sin(ttt+1.0)*.2);\n  }\n\n  q.z = mod(q.z, 2.5);\n  o = vec2(box(q - vec3(.0, 4, 0.), vec3(.5, .5, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  // B\n\n  q = p;\n  attr = max(0.0, (4.0 - (length(p) - 4.0)));\n\n  ttt += .5;\n  for (int i=0; i<2; i++) {\n    q = abs(q) - vec3(0.3*attr, 0.2, 3);\n    q.xy *= rot2(attr*(0.1+sin(ttt)*.3));\n    q.xz *= rot2(attr*0.2+sin(ttt+1.0)*.3);\n  }\n\n  q.z = mod(q.z, 2.5);\n  o = vec2(box(q - vec3(.0, 3, 0.), vec3(.5, .5, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  q *= 0.6;\n  q.y -= 0.2;\n  o = vec2(box(q - vec3(.1, 2.5, .0), vec3(.6, .6, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  q *= 0.6;\n  q.y -= 0.2;\n  o = vec2(box(q - vec3(.1, 2, .0), vec3(.7, .7, 10)), 10);\n\n  res = (res.x < o.x) ? res : o;\n\n  return res;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n  vec2 h, t = vec2(0.1);\n  for (int i=0; i<128; i++) {\n    h = map(ro+rd*t.x);\n    if (h.x < .0001 || t.x > 100.0) break;\n    t.x += h.x*0.6;\n    t.y = h.y;\n  }\n  if (t.x > 100.0) t.x = 0.0;\n  return t;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = vec2(frag_coord.x / i_resolution.x, frag_coord.y / i_resolution.y);\n  uv -= 0.5;\n  uv /= vec2(i_resolution.y / i_resolution.x, 1);\n\n  tt = mod(i_time*.5, 100.0);\n\n  // ===============\n\n  vec3 ro = vec3(0, 2, -10);\n  vec3 rd = normalize(vec3(uv,0.5));\n\n  vec3 ld = normalize(vec3(.3, .5, -.5));\n\n  vec3 fog = vec3(0.9) * (1.0 - (length(uv)-0.2));\n  vec3 col = fog;\n\n  scene = trace(ro, rd);\n\n  td = scene.x;\n  if (td > 0.0) {\n    vec3 pp = ro+rd*td;\n    vec3 nor = normalize(eps.xyy*map(pp+eps.xyy).x +\n                         eps.yyx*map(pp+eps.yyx).x +\n                         eps.xyx*map(pp+eps.xyx).x +\n                         eps.xxx*map(pp+eps.xxx).x);\n\n    vec3 b0 = vec3(.1, .5, .8);\n    vec3 b1 = vec3(0.7, .8, .8);\n    vec3 base = mix(b0, b1, attr);\n\n    float foggy;\n\n    if (scene.y == 5.0) {\n      foggy = -.00001*td*td*td;\n    }\n\n    if (scene.y == 10.0) {\n      foggy = -.0000005*td*td*td;\n    }\n\n    if (scene.y == 15.0) {\n      foggy = -.00005*td*td*td;\n      base = vec3(0, 1, 0);\n    }\n\n    float diff = max(0.0, dot(nor, ld));\n\n    float aor = td/30.;\n    float ao = exp2(-2.*pow(max(0.,1.-map(pp+nor*aor).x/aor),2.));\n\n    float fr = pow(1.+dot(nor,rd),2.);\n\n    vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(pp+ld*0.4).x/0.4);\n\n    col = base*(0.9*ao+0.2)*(diff+sss);\n    col = mix(col, b0, min(fr, 0.2));\n\n    col = mix(col, fog, 1.0-exp(foggy));\n  }\n\n\n  col = pow(col, vec3(1.8)); // stronger colours\n  col = vec3(1.0) - exp(-col * 3.0); // exposure hdr\n  col = pow(col, vec3(.45)); // gamma\n\n  frag_color = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 179, 179, 229], [231, 231, 258, 258, 317], [319, 319, 340, 340, 515], [517, 517, 535, 556, 1778], [1780, 1780, 1810, 1810, 2015], [2017, 2017, 2074, 2074, 3632]], "test": "timeout"}
{"id": "wsXyW2", "name": "Moebius Gears 2", "author": "dr2", "description": "Another impossible gear design", "tags": ["illusion", "escher", "gear", "moebius"], "likes": 20, "viewed": 316, "published": "Public API", "date": "1585583898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Moebius Gears 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm3 (vec3 p);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MobiusGDf (vec3 p, float r, vec2 b, float ns, float da, float dMin)\n{\n  vec3 q;\n  float d, a, t, rc;\n  rc = 0.02;\n  t = 0.15 * tCur + 0.5 * pi * da / ns;\n  p.yz = vec2 (- p.z, p.y);\n  q = vec3 (Rot2D (vec2 (length (p.xz) - r, p.y), 1.5 * atan (p.z, p.x)), 0.).xzy;\n  d = PrRoundBox2Df (q.xz, b, rc);\n  q = p;\n  q.xz = Rot2D (q.xz, t);\n  a = 2. * pi * (floor (ns * atan (q.z, - q.x) / (2. * pi)) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += r;\n  q.xy = Rot2D (q.xy, 1.5 * (a + t));\n  q.x = abs (q.x) - b.y;\n  d = max (d, - PrRoundBox2Df (q.xz, vec2 (0.3 * b.y, 0.55 * pi * r / ns), rc));\n  DMINQ (1);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, mobRad;\n  dMin = dstFar;\n  mobRad = 2.5;\n  q = p;\n  q.x -= mobRad + 0.37;\n  dMin = MobiusGDf (q, mobRad, vec2 (0.2, 0.4), 64., 1., dMin);\n  q = p;\n  q.x += mobRad + 0.37;\n  q.x = - q.x;\n  dMin = min (dMin, MobiusGDf (q, mobRad, vec2 (0.2, 0.4), 64., -1., dMin));\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = 20. * dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  }\n  return qBlk;\n}\n\nfloat BgCol (vec3 ro, vec3 rd, float scl)\n{\n  vec2 q;\n  q = smoothstep (0.03, 0.1, abs (mod (16. * scl * BlkHit (ro, rd) + 0.5, 1.) - 0.5));\n  return 1. - min (q.x, q.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vDotL = max (dot (vn, ltDir), 0.);\n    vDotL *= vDotL;\n    col = vec3 (0.85, 0.85, 0.8) * (0.3 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.7 * vDotL * vDotL) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    col *= 0.8 + 0.2 * Fbm3 (128. * qHit);\n    col = mix (col, vec3 (1.) * BgCol (ro, reflect (rd, vn), 0.5), 0.015);\n  } else col = vec3 (0.1, 0.1, 0.2) * BgCol (ro, rd, 4.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi * sin (0.01 * pi * tCur);\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  dstFar = 50.;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -22.);\n  zmFac = 6.;\n  ltDir = vuMat * normalize (vec3 (0.2, 0.2, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[449, 449, 524, 524, 1074], [1076, 1076, 1098, 1098, 1408], [1410, 1410, 1443, 1443, 1620], [1622, 1622, 1643, 1643, 1891], [1893, 1893, 1925, 1925, 2416], [2418, 2418, 2461, 2461, 2590], [2592, 2592, 2627, 2627, 3196], [3213, 3213, 3269, 3269, 4288], [4290, 4290, 4337, 4337, 4384], [4386, 4386, 4408, 4408, 4446], [4448, 4448, 4470, 4470, 4508], [4510, 4510, 4540, 4540, 4653], [4655, 4655, 4691, 4691, 4897], [4931, 4931, 4955, 4955, 5074], [5076, 5076, 5101, 5101, 5326], [5328, 5328, 5349, 5349, 5504]], "test": "error"}
{"id": "wsXyW4", "name": "Day 93", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 12, "viewed": 316, "published": "Public API", "date": "1584786557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Pallete from Inigo Quilez\n// pModPolar from hg-sdf library\n// Antialiasing thx to Fabrice Neyret\n\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define pmod(p,x) mod(p,x) - 0.5*x\n#define PI acos(-1.)\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    \n    \n    n += valueNoise(uv*500.,0.1);\n    //n += valueNoise(uv*1000., 0.1)*0.5;\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    \n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    \n    \n    n = max(n, 0.);\n    return n;\n}\n\nvec3 get(vec2 fragCoord){\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y ;\n\n    vec3 col = vec3(0);\n    \n    vec2 uvn = uv;\n    \n    float mm = 4.;\n    uvn *= rot(-PI*mm*0.5);\n    \n    // random IFS stuff\n    for(int i = 0; i < 26; i++){\n    \tuvn = abs(uvn);\n        uvn -= 0.25;\n    \tuvn.y += 0.299991;\n        if(uvn.x < 0.){\n        \tuvn.x -= 1.*uvn.y;\n        }\n        if(uvn.y < 0.){\n        \t//uvn.y -= 1.*uvn.y;\n        }\n        uvn *= rot(0.5 *PI);\n    }\n    \n    float j = pModPolar(uvn, mm);\n    float modD = 0.05;\n    vec2 id = vec2(j,floor(uvn.x/modD));\n    uvn.x = pmod(uvn.x, modD);\n    \n    vec3 c = pal(0.5,0.5,vec3(1.,0.7,0.5), 0.6 + id.x, id.y + iTime*0.5);\n    \n    c = max(c, 0.);\n    \n    col += c;\n    col -= fbm(uv).x*0.1;\n    col += fbm(uv + 4.).x*0.1;\n    \n    \n    \n    // vignette\n    col = pow(col, vec3(1. + dot(uv,uv)*0.1));\n    col *=1. -  dot(uv,uv)*0.7;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    // float(min(iFrame,0)) hack for faster compilation (stops loop unrolling)\n    for(float i =0.; i < 9. + float(min(iFrame,0)); i++){\n    \tcol += get(fragCoord + vec2(mod(i,3.),floor(i/3.))*0.1);\n    }\n    col /= 9.;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 313, 313, 703], [704, 704, 737, 737, 1266], [1267, 1267, 1285, 1285, 1552], [1554, 1554, 1579, 1579, 2475], [2477, 2477, 2534, 2534, 2826]], "test": "error"}
{"id": "WsXyW7", "name": "my sha_0", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 3, "viewed": 196, "published": "Public API", "date": "1584870315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Xor(float a, float b){\n return a*(1.-b)+   b*(1.-a);\n}\nfloat HexDist(vec2 p){\n\tp = abs(p);\n    float c= dot(p,normalize(vec2(1,1.73)));\n    c=max(c,p.x);   \n    return c;\n}\n\nvec4 HexCoords(vec2 uv){\n    vec2 r=vec2(1.,1.73);\n    vec2 h=r*.5;\n    vec2 a=mod(uv,r)-h;\n    vec2 b=mod(uv-h,r)-h;\n    \n    vec2 gv;\n    if (length(a)<length(b)) {\n     gv=a;   \n    } else {\n        gv=b;\n    }\n    \n    float x=atan(gv.x,gv.y);\n    float y=.5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x,y,id.x,id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.47*iResolution.xy)/iResolution.y;\n\t\n    vec3 col = vec3(0);\n    \n    uv*=10.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float m=0.1;\n    float t = iTime;\n    \n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            vec4 hc=HexCoords(uv+100.);\n    \t\tfloat c=smoothstep(.02,.1,tan(hc.x+(t*.5+.5)));\n            \n    \t\tvec2 offs = vec2(x,y);\n            float d=length(gv+offs);\n            float dist=length(id-offs)*.3;\n            float r = mix(.3,1.5,sin(dist-t)*.5+.5);\n            m=Xor(m,smoothstep(.2,.2,c));\n    \t}\n    }\n    \n    \n    \n    col+=m;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 60], [61, 61, 83, 83, 178], [180, 180, 204, 204, 510], [512, 512, 569, 569, 1235]], "test": "ok"}
{"id": "wsXyW8", "name": "Hexosphere", "author": "ilyaev", "description": "Sphere with hexagons", "tags": ["raymarch", "sphere", "hex"], "likes": 10, "viewed": 348, "published": "Public", "date": "1584647865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 128\n#define MAX_DISTANCE 3.\n#define MIN_DISTANCE 0.001\n#define SPEED 3.\n#define SIZE 3.\n#define SPHERE_SIZE .8\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*123.453 + p.y*4567.543) * 67894.432 );\n}\n\nfloat hexDist(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., 1.73))));\n}\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * .5;\n\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n\n    if (length(a) < length(b)) {\n        gv = a;\n    } else {\n        gv = b;\n    }\n\n    float x = atan(gv.x, gv.y);\n    float y = .5 - hexDist(gv);\n\n    vec2 id = uv - gv;\n\n    return vec4(x, y, id.xy);\n}\n\nvec3 getTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n\n    float size = 3.;\n\n    vec2 ouv = uv;\n\n    vec2 id = floor(uv*size);\n    uv = fract(uv*size) - .5;\n\n    vec3 c = vec3(0.);\n\n    for(int x = -1 ; x <= 1 ; x++) {\n        for(int y = -1 ; y <= 1 ; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 nid = id + offset;\n            float n = n21(nid);\n            if (n > .2) {\n                float n1 = fract(n*123.456);\n                float n2 = fract(n*5678.543);\n                vec3 color = vec3(n, n1, n2);\n                vec2 shift = vec2(n1 - .5, n2 - .5)*sin(iTime + n*n1 + n2);\n                c = max(c, ((0.01 + 0.02*n2)/length(uv - offset - shift)) * color);\n            }\n        }\n    }\n\n    col += c;\n\n    return col;\n}\n\nfloat getHeight(vec3 p, vec4 hex) {\n    float base = 0. + sin(hex.a/hex.b + iTime*2.)*.02;\n    base = clamp(hex.y/2., 0., base + SPHERE_SIZE/30.);\n    return base;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n\n    vec2 uv = fragCoords.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    float a = iTime;\n\n    vec3 ro = vec3(0., 0., -2.);\n    vec3 lookat = vec3(0., 0., 3.);\n    float zoom = 1.;\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(i - ro);\n\n\n    float ds, dt = 0.;\n    vec3 p;\n    float x,y = 0.;\n    vec2 suv;\n    vec4 hex;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n\n        x = acos(p.y/length(p));\n        y = atan(p.z, p.x) + iTime/SPEED;\n\n        suv = vec2(x, y);\n\n        hex = hexCoords(suv*SIZE);\n        float base = SPHERE_SIZE + sin(hex.a*hex.b + iTime*10.)*.0;\n\n        dt = length(p) - (base + getHeight(p, hex));\n        ds += dt * .6;\n\n        if (abs(dt) < MIN_DISTANCE || ds > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    float t = iTime*3.;\n\n    if (dt < MIN_DISTANCE) {\n        col += getTexture(suv);\n        //vec4 hex = hexCoords(suv*SIZE);\n\n        float b = smoothstep(.9, 1., sin(t + sin(t)/cos(t + sin(t*3.+t))) * .5 + .5);\n\n        vec3 gridColor = mix(vec3(0., 1., 1.), mix(vec3(1.,0.,0.), vec3(0.,1.,0.), sin(iTime)), cos(iTime/2.));\n\n        col += pow(.005/hex.y, .6) * gridColor * b;\n\n        col += vec3(n21(hex.ba + 100.))*.6;\n    } else {\n        col = getTexture(uv + vec2(iTime/(SPEED*2.), 0.));\n    }\n\n    fragColor = vec4(clamp(col, 0., 1.), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 149, 149, 215], [217, 217, 241, 241, 319], [321, 321, 346, 346, 680], [682, 682, 708, 708, 1432], [1434, 1434, 1469, 1469, 1599], [1601, 1601, 1657, 1657, 3251]], "test": "timeout"}
{"id": "WsXyWf", "name": "Wavy swamp fractal", "author": "jarble", "description": "Another wavy distorted fractal biome map.", "tags": ["fractal", "swamp", "biome"], "likes": 0, "viewed": 197, "published": "Public API", "date": "1585678872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float GREEN = 0.;\nconst float BLUE = 1.;\nconst float GRAY = 2.;\nconst float YELLOW = 3.;\nconst float WHITE = 4.;\nconst float RED = 5.;\n\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 5.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n    \nfloat sin1(float x){\n    return sin(x+mag*sin(x+iTime));\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n    fragCoord += vec2(sin1(fragCoord.y/(100.0*mag))*10.0,sin1(fragCoord.x/(100.0*mag))*10.0)*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag){\n    return vec4(magnify(fragCoord+vec2(0,1),mag),\n        magnify(fragCoord+vec2(1,0),mag),\n        magnify(fragCoord-vec2(0,1),mag),\n        magnify(fragCoord-vec2(1,0),mag));\n}\n\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float colors[] = float[](GREEN,BLUE,GRAY,YELLOW,WHITE,RED);\n    vec4 neighbors;\n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag);\n    if(color1 == GREEN && is_next_to(BLUE,neighbors)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(GREEN,neighbors)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(GRAY,neighbors)){\n        color1 = BLUE;\n    }\n    else if(color1 == GRAY && is_next_to(YELLOW,neighbors)){\n        color1 = YELLOW;\n    }\n    else if(color1 == WHITE && is_next_to(YELLOW,neighbors)){\n        color1 = GRAY;\n    }\n    else if(color1 == GRAY && is_next_to(BLUE,neighbors)){\n        color1 = BLUE;\n    }\n    mag -= 1.0;\n    }\n    return colors[int(color1)];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 273, 295, 295, 522], [528, 528, 548, 548, 586], [589, 589, 629, 629, 783], [785, 785, 830, 830, 1009], [1012, 1012, 1056, 1056, 1192], [1196, 1196, 1224, 1224, 1638], [2443, 2443, 2499, 2499, 2869]], "test": "error"}
{"id": "WsXyWj", "name": "Lava shader", "author": "j0sh", "description": "it's a lava shader", "tags": ["lava"], "likes": 2, "viewed": 73, "published": "Public", "date": "1585536321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on the 2d clouds shader by drift\n// https://www.shadertoy.com/view/4tdSWr\n\nconst float scale = 1.1;\nconst float speed = 0.015;\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * scale * 0.5);\n    \n    //noise\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= scale*2.0;\n    uv -= vec2(q - time);\n    float weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n\tfragColor = vec4(mix(vec3(1,0.2,0), vec3(0.1,0.02,0), c), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 205, 205, 318], [320, 320, 346, 346, 866], [868, 868, 887, 887, 1041], [1043, 1043, 1100, 1100, 1630]], "test": "timeout"}
{"id": "wsXyz4", "name": "DNA-ish", "author": "Axioplase", "description": "Toying with more \"infinite\" things until I really grok it. I sometimes have some clipping on the circles I don't understand...Also, the moire effect is a problem...", "tags": ["raymarching", "infinite", "dna"], "likes": 6, "viewed": 169, "published": "Public", "date": "1584295008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Base code:\n///// \"RayMarching starting point\" \n//// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n//// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define M(x, y, a) mix(x, y, a) \n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdLine(vec3 p, vec3 o, vec3 dir, float t) {\n    vec3 a = o;\n    vec3 b = a+dir;\n    vec3 bMinusA = b-a;\n    float h = min(t, max(-t, dot((p-a), bMinusA)/dot(bMinusA,bMinusA)));\n    //float h = dot(p-a, bMinusA)/dot(bMinusA,bMinusA);\n    float dist = length(p - a +-(b-a) * h )- 0.01;\n    return dist;\n}\n\nmat3 rx(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1,0,0,0,c,-s,0,s,c);\n}\nmat3 ry(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c,0,s,0,1,0,-s,0,c);\n}\nmat3 rz(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nvec4 sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return vec4(length(q)-t.y, 0.4, 0.4, 0.4);\n}\n\n\nvec4 stick(vec3 p, float m) {\n      vec3 pp = vec3(p.x, p.y, mod(p.z+0.5*m, m)-m/2.);\n    pp = rz(-iTime+p.z*1.)*pp;\n    float dist = sdLine(pp, vec3(0), vec3(1., 1.,0.), .195); \n    return vec4(dist, 1., 1., 1.);\n}\n\n\nvec4 handle(vec3 p, float m) {\n    vec3 pp = vec3(p.x, p.y, mod(p.z+0.5*m, m)-m/2.);\n    pp = rz(-iTime+3.141592/4.+p.z)*pp;\n    pp = rx(3.141592/2.+p.z)*pp;\n    pp.x += 0.33;\n    vec4 t1 = sdTorus(pp, vec2(0.04, .01)); \n    pp.x -= 0.66;\n    vec4 t2 = sdTorus(pp, vec2(0.04, .01)); \n    return vec4(min(t1.x, t2.x), t1.yzw);\n}\n\n\nvec4 GetDist(vec3 p) {\n    // vec4 best = vec4(MAX_DIST, fract(p.z), 1.-fract(p.z), 0.5+0.5*sin(iTime*fract(p.z)));\n    vec4 best = vec4(MAX_DIST, 0.5+0.5*sin(1.3*p.z), 0.5+0.5*sin(p.z), 0.5+0.5*cos(p.z));\n\n    vec3 pp = p;\n    // pp = rx(iTime/25.)*pp;\n    pp.x = sin(pp.x);\n    pp.y = cos(pp.y);\n    pp.z += cos(iTime/2.);\n    float m = 0.1;\n    vec4 distStick = stick(pp, m);\n    vec4 distHandle = handle(pp, m);\n    float d = smoothUnion(distStick.x, distHandle.x, 0.03);\n    best.x = min(best.x, d);\n    \n    return best;\n    \n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dCol = vec4(0.);\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dCol.x;\n        vec4 dS = GetDist(p);\n        dCol.x += dS.x;\n        dCol.yzw = dS.yzw;\n        if(dCol.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n\n    return dCol;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(.00001);\n   \n    vec3 ro = vec3(2.23*cos(1.58+iTime/2.234), 1.7*sin(2.78+iTime/3.43214), -iTime*0.7);\n\n    //vec3 rd = GetRayDir(uv, ro, vec3(cos(iTime)/10., sin(iTime)/20., -(iTime+1.)), 1.);\n\tvec3 rd = GetRayDir(uv, ro,\n                        vec3(\n                            ro.x+7.234*sin(iTime/13.13),\n                            ro.y+8.1*cos(iTime/14.48),\n                            ro.z+5.97*sin(1.587+iTime/15.32443)),\n                        1.);\n\n    vec4 d = RayMarch(ro, rd);\n\n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, normalize(vec3(1,2,3)))*.5+.5, 0.2, 0.8);\n        col = vec3(dif)/d.x;\n        col *= d.yzw;\n        col = M(col*3., vec3(0.00001), S(10., 20., d.x));\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[340, 340, 359, 359, 435], [437, 437, 486, 486, 745], [747, 747, 765, 765, 848], [849, 849, 867, 867, 950], [951, 951, 969, 969, 1052], [1054, 1054, 1104, 1104, 1203], [1206, 1206, 1236, 1236, 1326], [1329, 1329, 1358, 1358, 1544], [1547, 1547, 1577, 1577, 1874], [1877, 1877, 1899, 1992, 2410], [2412, 2412, 2445, 2445, 2707], [2709, 2709, 2733, 2733, 2926], [2928, 2928, 2978, 2978, 3173], [3177, 3177, 3234, 3234, 4210]], "test": "timeout"}
{"id": "wsXyzM", "name": "Moebius, Menger, Spiders", "author": "dr2", "description": "Lots of spiders, with a twist", "tags": ["raymarch", "mobius", "walk", "octopod"], "likes": 18, "viewed": 327, "published": "Public API", "date": "1584369107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Moebius, Menger, Spiders\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir, qHit;\nfloat dstFar, tCur, mobRad, legLenU, legLenD, bdyHt, spdVel, nSpd;\nint idObj;\nconst int idMob = 1, idBdy = 11, idHead = 12, idEye = 13, idAnt = 14, idLegU = 15, idLegD = 16;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat MobiusDf (vec3 p)\n{\n  vec3 b;\n  float sclFac, r, a;\n  const int nIt = 4;\n  sclFac = 2.6;\n  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p = vec3 (mod (16. * a + 1., 2.) - 1., Rot2D (vec2 (p.y, r - 32. / (2. * pi)), pi * a));\n  for (int n = VAR_ZERO; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z, -0.5 * b.z);\n  }\n  return 0.9 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, float (nIt));\n}\n\nfloat SpdDf (vec3 p, float dMin, int tpId)\n{\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 0.2;\n  p /= szFac;\n  dMin /= szFac; \n  p.y -= bdyHt + 0.7;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  DMINQ (idBdy + tpId);\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  DMINQ (idHead + tpId);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  DMINQ (idEye + tpId);\n  q -= vec3 (0., 0.15, -0.3);\n  d = PrEETapCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), vec3 (0.), 0.07, 0.7);\n  DMINQ (idAnt + tpId);\n  p.y += bdyHt;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * PrEETapCylDf (q, kneePos[j], hipPos[j], 0.25, 0.3);\n    DMINQ (idLegU + tpId);\n    q = p - kneePos[j];\n    d = 0.6 * PrEETapCylDf (q, footPos[j] - vec3 (0.3), kneePos[j] - vec3 (0.3), 0.2, 1.2);\n    DMINQ (idLegD + tpId);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, aq, na;\n  dMin = dstFar;\n  d = MobiusDf (p);\n  DMINQ (idMob);\n  q = p;\n  a = tCur * spdVel / (2. * pi * mobRad);\n  q.xz = Rot2D (q.xz, a);\n  na = floor (nSpd * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / nSpd;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += mobRad;\n  a += aq;\n  if (2. * floor (0.5 * na) != na) a += 2. * pi;\n  q.xy = Rot2D (q.xy, 0.5 * a);\n  q.y -= 0.8;\n  if (PrCylDf (q.xzy, 1., 0.7) < dMin) dMin = SpdDf (q, dMin, 0);\n  q = p;\n  a = - tCur * spdVel / (2. * pi * mobRad);\n  q.xz = Rot2D (q.xz, a);\n  na = floor (nSpd * atan (q.z, - q.x) / (2. * pi));\n  aq = 2. * pi * (na + 0.5) / nSpd;\n  q.xz = Rot2D (q.xz, aq);\n  q.x += mobRad;\n  a += aq;\n  if (2. * floor (0.5 * na) != na) a += 2. * pi;\n  q.xy = Rot2D (q.xy, 0.5 * a + 0.5 * pi);\n  q.y -= 0.8;\n  if (PrCylDf (q.xzy, 1., 0.7) < dMin) dMin = SpdDf (vec3 (- q.xz, q.y).xzy, dMin, 10);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvoid SpdSetup (float gDisp)\n{\n  vec3 v;\n  float a, az, fz, d, ll;\n  nSpd = 10.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];\n    hipPos[j + 4].x *= -1.;\n  }\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) + mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 SpdCol (vec3 vn)\n{\n  vec3 col, c1, c2;\n  if (idObj >= idBdy + 10) {\n    idObj -= 10;\n    c1 = vec3 (0.5, 1., 0.2);\n    c2 = vec3 (0.5, 0.2, 0.2);\n  } else {\n    c1 = vec3 (1., 0.5, 0.2);\n    c2 = vec3 (0.2, 0.2, 0.5);\n  }\n  if (idObj == idBdy) {\n    col = mix (c1, c2, SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c2;\n    if (qHit.z > 0.4) col = mix (vec3 (0.2, 0.05, 0.05), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z < 0.6) ? vec3 (0., 1., 0.) : c1;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c2, c1,  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 1.5;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.35, 0.5, 1.), vec3 (0.1, 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.15 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == idMob) {\n      col4 = vec4 (0.6, 0.6, 0.7, 0.1);\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj >= idBdy) {\n      col4 = vec4 (SpdCol (vn), 1.);\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       step (0.95, sh) * col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (col, BgCol (reflect (rd, vn)), 0.3);\n  } else col = BgCol (rd);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0  // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = (floor (0.3 * tCur) + smoothstep (0.8, 1., mod (0.3 * tCur, 1.)));\n    az += 0.1 * t;\n    el -= 0.1 * pi * (1. - sin (0.06 * t));\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  zmFac = 4.5 - 1.5 * abs (el);\n  dstFar = 50.;\n  mobRad = 5.;\n  spdVel = 1.5;\n  SpdSetup (spdVel * tCur);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf)\n{\n  vec3 v;\n  float s;\n  v = v1 - v2;\n  s = clamp (dot (p, v) / dot (v, v), 0., 1.);\n  return length (p - s * v) - r * (1. - rf * s * s);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXyzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[862, 862, 887, 887, 1479], [1481, 1481, 1525, 1525, 2420], [2422, 2422, 2444, 2444, 3352], [3354, 3354, 3387, 3387, 3571], [3573, 3573, 3594, 3594, 3849], [3851, 3851, 3888, 3888, 4117], [4119, 4119, 4148, 4148, 5232], [5234, 5234, 5257, 5257, 6008], [6010, 6010, 6032, 6032, 6455], [6457, 6457, 6492, 6492, 7159], [7202, 7202, 7258, 7258, 8497], [8499, 8499, 8531, 8531, 8631], [8633, 8633, 8666, 8666, 8693], [8695, 8695, 8737, 8737, 8788], [8790, 8790, 8856, 8856, 8994], [8996, 8996, 9031, 9031, 9093], [9095, 9095, 9152, 9152, 9235], [9237, 9237, 9273, 9273, 9479], [9481, 9481, 9511, 9511, 9624], [9658, 9658, 9682, 9682, 9794], [9796, 9796, 9821, 9821, 10007], [10009, 10009, 10038, 10038, 10250], [10252, 10252, 10291, 10291, 10476]], "test": "error"}
{"id": "wt3GDN", "name": "test-water-splash", "author": "shrekshao", "description": "test", "tags": ["noise"], "likes": 3, "viewed": 108, "published": "Public", "date": "1583099329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.y *= iResolution.y / iResolution.x;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    vec3 col;\n    vec2 origin = vec2(0.5, 0.5);\n    \n    vec2 d = uv - origin;\n    \n    d.y *= iResolution.y / iResolution.x;\n    \n    //atan(d.y, d.x)\n    \n    float r = length(d);\n    \n    float a = atan(d.y, d.x);\n    \n    \n    // properties\n    float radius = 0.1;\n    float rim = radius * 0.5;\n    float bumpy = .03;\n    float bias = .15;\t// low frequency bias contribution\n    float rimDots = .1;\n    \n    float f = radius;\n    //f += radius;\n    //float f = r * 0.5;\n    //f += ( abs(cos(a*2.5))*.5+.3 ) * 1.;\n    //float f = abs(cos(a * 9.) + .1);\n    //f += abs(cos(a * 3. + .5) + .1);\n    //f += abs(cos(r * 4.) * 0.2);\n    \n    //f += snoise(vec2(a + 10.2, 7.) * 3.4) * .5;\n    //f += snoise(vec2(uv.x, uv.y) * 3.4) * 2.5;\n\n    //f += snoise(vec2(uv.x, uv.y) * 8.) * 2.;\n    //float f2 = snoise(vec2(a, 0.) * 10.);\n    //f += step(r, .3);\n    \n    //col = vec3(1.-smoothstep(f,f+0.02,r));\n    //col = vec3( max(step(r, f), step(r, .3))  );\n    \n    //r += snoise(vec2(uv.x * 3., uv.y * 3.2) * 1.) * .1;\n    //r += -abs(cos(a * 9.)) * .01;\n    \n    \n    //float mr = r;\t// modifed radius\n    \n    // noise bumpy circle at edge high frequency\n    r += bumpy * ( -0.5 + snoise( vec2(d * 20.) + iTime * .67 ) + 0.1 );\n    \n    // noise bump circle low frequency bias\n    //r += -bias * (sin(a * 5.) * .25);\n    \n    // global offset for dots, influence max at edge of circle\n    r += rimDots * ( 0.2 -0.5 + snoise(d * 12. + vec2(iTime, 0.) )) * ( smoothstep(radius - rim, radius, r) - smoothstep(radius, radius + rim, r) );\n    \n    col = vec3( step(r , f) );\n    //col = vec3( step(r , f * .1) );\n    //col = vec3(  step(r, snoise(vec2(f, r)) * 0.1)   );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3GDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 203], [205, 205, 229, 229, 1735], [1739, 1739, 1796, 1846, 3754]], "test": "ok"}
{"id": "wt3XRn", "name": "Un ptit train", "author": "Axioplase", "description": "Trying to do a small animation.", "tags": ["2d", "train", "vaporwave"], "likes": 4, "viewed": 76, "published": "Public", "date": "1583624344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is super ugly. I've messed up many things when building this, but I'm learning!\n// Missing: trees, electric posts.\n// I'm gonna stop there, though.\n\nvec2 rot(float alpha, vec2 uv) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat2(c, -s, s, c) * uv;\n}\n\nvec3 sky(vec2 p) {\n    return vec3(p.y/2.+0.25)*vec3(0.8,0.,0.8)*3.+.5;\n}\n\nvec3 sun(vec2 p, vec2 center, float radius) {\n    if (length(p-center) <= radius) {\n        return vec3(.8,0.8,.0)*length(p-center+vec2(0.,0.2));\n    }\n    return vec3(0);\n}\n\nvec3 mountains(vec2 p, float height, vec3 col, float freq, float amp, float speed) {\n    p += .4;\n    if (p.y+height + cos(freq*p.x+iTime*speed)/amp < .1) {\n        return col;\n    }\n    return vec3(0);\n}\n\n// not good for small objects\nfloat dist_Rect(vec2 pixel, vec2 rect_center, vec2 rect_size) {  \n    vec2 d = abs(rect_center - pixel) - rect_size*0.5;\n    return length(max(d,0.0));\n}\n\nfloat dist_RoundRect(vec2 pixel, vec2 rect_center, vec2 rect_size, float rect_round) {\n    return dist_Rect(pixel, rect_center, rect_size - vec2(rect_round*2.0)) - rect_round;\n}\n\nbool disk(vec2 pos, float radius) {\n    return (length(pos) < radius);\n}\n\nbool reflekt(vec2 uv, vec2 p, float win, float x, float y) {\n    return (uv.y - p.y < y &&\n            uv.y - p.y > y-0.005 &&\n            uv.x - (p.x-win) < x+0.01 &&\n            uv.x - (p.x-win) > x);\n}\nbool line(vec2 uv, vec2 start, float len, float thick) {\n    return (uv.x >= start.x &&\n            uv.x < start.x + len &&\n            uv.y >= start.y - thick/2. &&\n            uv.y < start.y + thick/2.);\n}\n\nvec3 car(vec2 uv, vec2 p, float phase) {\n    //float bump = smoothstep(1.0 ,1.2,1.0+sin(iTime+phase)/40.);\n    //p -= vec2(0., bump);\n\n    vec3 c;\n    // box car\n    vec2 pp = p;\n    float bump = smoothstep(0.99,1., sin(p.x*0.51+iTime))/150.;\n    bump += cos(p.x*2.7+iTime*2.)/300.;\n    pp = vec2(p.x, p.y-bump);\n    if (dist_RoundRect(uv, pp, vec2(0.5, 0.25), 0.05) <= 0.) {\n        // wagon\n        c = vec3(1.,.1,0.);\n        // decoration\n        if (line(uv, pp-vec2(1.,0.025) ,10., 0.01) ||\n            line(uv, pp-vec2(1.,0.045) ,10., 0.01) ||\n            (uv.y - pp.y < -.06)) {\n            c = vec3(.5,.08,1.);\n        }\n\n        vec2 ww = rot(0.8, uv-pp);\n        if (ww.y < -0.01) {\n            c-=vec3(.1);\n        }\n\n        // Lower part under the step.\n        if (uv.y - pp.y < -0.105) {\n            c = vec3(.5,.08,0.);\n        }\n        // windows\n        float from = -0.2;\n        float to = 0.2;\n        float step = (to-from)/5.;\n        for (float win = from+step; win <= to ; win += step) {\n            if (dist_RoundRect(uv, pp-vec2(win,-0.04), vec2(0.05, 0.08), 0.005) <= 0.) {\n                c = vec3(.5,.5,.5); // outer\n                if (dist_RoundRect(uv, pp-vec2(win+0.007,-0.035), vec2(0.05, 0.08), 0.004) <= 0.) {\n                    c = vec3(.4,.2,.4); // inner\n                    // reflections. I was not able to make it with a rotation of a line\n                    // that ends up in each window, so I'm doing pixel art...\n                    // I probably want to\n                    // 1) rotate space\n                    // 2) shift by the amount of the window center\n                    // 3) draw a small line around the new origin\n                    if (reflekt(uv, pp, win, -.00, 0.050) ||\n                        reflekt(uv, pp, win, -.01, 0.045) ||\n                        reflekt(uv, pp, win, -.02, 0.040) ||\n                        reflekt(uv, pp, win, -.03, 0.035) ||\n                        reflekt(uv, pp, win, .02, 0.045) ||\n                        reflekt(uv, pp, win, .01, 0.040) ||\n                        reflekt(uv, pp, win, .00, 0.035) ||\n                        reflekt(uv, pp, win, -.01, 0.030) \n                       ) {\t\n                        c = vec3(0.7, 0.3, 0.7);\n                    }\n                }\n            } \n        }\n\n        // door\n        if (dist_RoundRect(uv, pp-vec2(from,-0.006), vec2(0.05, 0.15), 0.005) <= 0.) {\n            if (disk(uv-pp+vec2(from-0.01, .01), 0.004)) {\n                c = vec3(0.8); // knob\n            } else {\n                if (dist_RoundRect(uv, pp-vec2(from,-0.006), vec2(0.045, 0.14), 0.005) <= 0.) {\n                    c = vec3(.3,.2,.3);\n                } else {\n                    c = vec3(.2,.1,.2);\n                }\n            }\n        }     \n    } \n    // wheels\n    else if (disk(uv-p+vec2(-0.15, 0.11), 0.04) || disk(uv-p+vec2(0.15, 0.11), 0.04)) {\n        if (disk(uv-p+vec2(-0.15, 0.11), 0.03) || disk(uv-p+vec2(0.15, 0.11), 0.03)) {\n            c = vec3(0.3); // inside\n        } else {\n            c = vec3(0.01); // outside\n        }\n\n        vec2 p1 = rot(iTime*10., vec2(0.02, 0.));\n        vec2 p2 = rot(6.+iTime*10., vec2(-0.02, 0.));\n        if (disk(p1+uv-p+vec2(-0.15, 0.11), 0.005) ||\n            disk(p2+uv-p+vec2(-0.15, 0.11), 0.005) ||\n            disk(p1+uv-p+vec2(0.15, 0.11), 0.003) ||\n            disk(p2+uv-p+vec2(0.15, 0.11), 0.003)\n           ) {\n            c = vec3(0.2);\n        }\n    }\n    else {\n        c = vec3(0);\n    }\n\n    // step\n    if (line(uv, pp-vec2(0.25,0.105), .49, .005)) {\n        c = vec3(.2,.0,.15);\n    } \n\n    // hook\n    if (line(uv, pp-vec2(0.26,.08), 0.013, .01)) {\n        c = vec3(.2,.0,.1);\n    } \n\n    return c;\n\n}\n\nfloat carHeight() {\n    float height = .3;\n    float freq = .4;\n    float speed = 1.3;\n    float amp = .01;\n    float y = height + cos(freq+iTime*speed)*amp;\n\n    return y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = sky(uv);\n    col += sun(uv, vec2(.4,.3), .15);\n\n    vec3 m;\n    m = mountains(uv, -.39, vec3(0.3,0.15,0.3), 2., 25., .1);\n    if (length(m) > 0.) {\n        col=m;\n    }\n    m = mountains(uv, -0.28, vec3(0.5,0.12,0.5), 3., 20., 0.3);\n    if (length(m) > 0.) {\n        col=m;\n    }\n\n\n    float y = carHeight();\n    float p = y-.575;\n    if (uv.y < p) {\n        if (uv.y > p-0.01) {\n            col = vec3(0.);\n        } else {\n            col *= 3.5 * -uv.y;\n        }\n    }\n\n    for (int ccar = 4; ccar >=0; ccar--) {\n        float bump = smoothstep(0.99,1., sin(-0.8+float(ccar)*0.51+iTime))/200.;\n        vec3 c = car(uv, vec2(-0.8+float(ccar)*0.51, bump+y-.43), 1.);\n        if (length(c) > 0.) {\n            col=c;\n        }\n    }\n\n\n    m = mountains(uv, 0.04, vec3(0.8,0.1,0.8), 4., 40., 0.9);\n    if (length(m) > 0.) {\n        col=m;\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 189, 189, 278], [280, 280, 298, 298, 353], [355, 355, 400, 400, 528], [530, 530, 614, 614, 734], [736, 766, 829, 829, 919], [921, 921, 1007, 1007, 1098], [1100, 1100, 1135, 1135, 1172], [1174, 1174, 1234, 1234, 1378], [1379, 1379, 1435, 1435, 1586], [1588, 1588, 1628, 1721, 5290], [5292, 5292, 5311, 5311, 5466], [5469, 5469, 5526, 5576, 6558]], "test": "timeout"}
{"id": "WtdSWX", "name": "Worley water/underwater caustic", "author": "Eldeston", "description": "v1.0.2\nA simple water noise for water surfaces or underwater caustics.", "tags": ["voronoi", "noise", "water", "worley"], "likes": 4, "viewed": 154, "published": "Public", "date": "1584106571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define intensity 24.0\n#define isBorder true\n#define is3D true\n\n// Noise\nfloat rand1D(float n){\n    return fract(sin(dot(n, 12.9898)) * 43758.5453);\n    }\n\nfloat rand1D(vec2 n){\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\nfloat rand1D(vec3 n){\n    return fract(sin(dot(n, vec3(12.9898, 4.1414, 78.233))) * 43758.5453);\n    }\n\nvec2 rand2D(vec2 n){\n    return fract(sin(vec2(dot(n, vec2(12.9898, 4.1414)))));\n    }\n\nvec3 rand3D(vec3 n){\n    return fract(sin(vec3(dot(n, vec3(12.9898, 4.1414, 78.233)))));\n    }\n\n// Value noise\nfloat vnoise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( rand1D(i + vec2(0.0,0.0)), rand1D(i + vec2(1.0,0.0)), u.x), mix( rand1D(i + vec2(0.0,1.0)), rand1D(i + vec2(1.0,1.0)), u.x), u.y);\n    }\n\n// Voronoi noise, 3D and 2D\n// These are extremely laggy, so I decreased the amount of points, while having 3D, being the laggiest\nfloat voronoi3D(vec3 n, float time){\n    float dis = 0.9;\n    for(float y = 0.0; y <= 1.0; y++){\n        for(float x = 0.0; x <= 1.0; x++){\n            for(float z = -1.0; z <= 1.0; z++){\n                // Neighbor place in the grid\n                vec3 p = floor(n) + vec3(x, y, z);\n                float d = length((0.27 * sin(rand3D(p) * intensity + time * 2.0)) + vec3(x, y, z) - fract(n));\n                dis = min(dis, d);\n                }\n            }\n        }\n    return dis;\n    }\n\nfloat voronoi2D(vec2 n, float time){\n    float dis = 0.9;\n    for(float y = 0.0; y <= 1.0; y++){\n        for(float x = 0.0; x <= 1.0; x++){\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x, y);\n            float d = length((0.27 * sin(rand2D(p) * intensity + time * 2.0)) + vec2(x, y) - fract(n));\n            dis = min(dis, d);\n            }\n        }\n    return dis;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.x;\n    vec3 texA = texture(iChannel0, uv).rgb;\n    \n    vec2 base = uv;\n    uv.x += sin(iTime * 2.0 + base.x * 1.0 + base.y * 16.0) * 0.025;\n    vec2 uv1;\n    float V = is3D ? clamp((pow(voronoi3D(vec3(uv * 10.0, 1.0), iTime), 3.6) * 2.0) + 0.25, 0.0, 1.0) :\n    clamp((pow(voronoi2D(uv * 10.0, iTime), 3.6) * 2.0) + 0.25, 0.0, 1.0);\n    \n    float border;\n    \n    border = uv.x >= 0.499 && uv.x <= 0.501 ? 1.0 : 0.0;\n    border = uv.y >= 0.499 && uv.y <= 0.501 ? 1.0 : border;\n    border = isBorder ? border : 0.0;\n    fragColor = vec4(mix(texA * vec3(0.0, 0.5, 1.0) * V, vec3(1.0, 1.0, 0.0), border), 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 73, 95, 95, 154], [156, 156, 177, 177, 250], [252, 252, 273, 273, 354], [356, 356, 376, 376, 442], [444, 444, 464, 464, 538], [540, 555, 581, 581, 819], [821, 952, 988, 988, 1446], [1448, 1448, 1484, 1484, 1854], [1856, 1856, 1912, 1912, 2565]], "test": "error"}
{"id": "WtfSRs", "name": "Simple raymarch shader", "author": "KappnKrunch", "description": "this is a test of a raymarching algorithm.", "tags": ["raymarchray"], "likes": 2, "viewed": 73, "published": "Public", "date": "1584047955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdCapsule(vec3 p,vec3 a, vec3 b, float r)\n{\n    vec3 ab = b- a;\n    vec3 ap = p- a;\n    \n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t , 0. , 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(-3.5,-1,12,0.5);    \n    \n    float planeDist = p.y + 3.0;\n    \n    \n    float d = planeDist;\n    \n    \n    \n    float sphereDist = length(p -s.xyz) - s.w;\n    for(int i = 1; i < 12; i++)\n    {\n        float aroundPiX = ((float(i)/12.0) * 2.0 * 3.14) + (iTime/2.);\n        float aroundPiY = ((float(i)/12.0) * 2.0 * 3.14) + (iTime/3.);\n        float aroundPiZ = ((float(i)/12.0) * 2.0 * 3.14) + (iTime/5.) + aroundPiX + aroundPiY;\n        \n        s += vec4(2.0*sin(aroundPiX),.5*sin(aroundPiZ),2.0*cos(aroundPiY),0);\n        \n\t\tsphereDist = min(length(p -s.xyz) - s.w,sphereDist);\n    }\n    \n   \n    d = min(d,sphereDist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    int MAX_STEPS = 100;\n\tfloat MAX_DIST = 10000.;\n\tfloat SURF_DIST = 0.0001;\n    \n    float dO = 0.0;\n    \n    //raymarching loop\n    for(int i = 0; i < MAX_STEPS; i ++)\n    {\n        //current marching position\n        vec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        \n        if( dO > MAX_DIST || dS < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n        );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,3,0);\n    lightPos.xz = vec2(sin( (17.0*iTime)/100.0 ),cos( (19.0*iTime)/100.0 ))*10.;\n    vec3 l = normalize(\tlightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p + n * 0.05,l);\n    \n    if( d < length(lightPos - p))\n    {\n        diff *= 0.1;\n    }\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n        \n    vec3 ro = vec3(0,1,0);        \n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    \n    vec3 col = vec3(dif);\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 50, 50, 245], [935, 935, 969, 969, 1399], [1401, 1401, 1425, 1425, 1626], [1628, 1628, 1652, 1652, 2008], [2010, 2010, 2067, 2067, 2385]], "test": "timeout"}
{"id": "wtGSWG", "name": "ölaksdfgjalködjf", "author": "lennyjpg", "description": "sadasdfa", "tags": ["asdfasdfasdf"], "likes": 4, "viewed": 239, "published": "Public API", "date": "1583786314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;  \n    vec2 u = uv;\n    u *= 1.;\n    float t = iTime * 3.3;\n    float e = u.y - 0.3 ;\n    e += sin(u.x * 7.0 - t ) * .1;\n    float f = pow(u.x - 0.5,2.0)*3.0;\n    e += sin(f*1.0+t*0.5)*0.1;\n    e -= cos(u.x*17.241-t*1.22)*0.02;\n    e*=2.5;\n    float k = smoothstep(e,f,f*1.05); \n    float m = step(f,e);\n    vec3 a = vec3(33.,33.9,1.1);\n    vec3 b = vec3(1.0,0.2,0.3);\n    vec3 c = mix(a,b,m / k);\n    c.r *= uv.x / uv.y;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 549]], "test": "ok"}
{"id": "WtGSzd", "name": "PapillaCell", "author": "Reva", "description": "Ex05, interact with mouse", "tags": ["2d", "cellularnoise", "cinashader"], "likes": 2, "viewed": 165, "published": "Public API", "date": "1583334900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author Reva - 2020-03-04\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n        return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    st *= rotate2d(noise(st));\n    \n    // Cell positions\n    vec2 point[10];\n    vec2 move = iMouse.xy/iResolution.xy - 0.5;\n    for(float i = 0.; i < 10.; i+= 1.){\n        vec2 pos = random2(vec2(i) - 5.93);\n        vec2 vel = vec2(noise(pos*iTime));\n        point[int(i)] = clamp(pos + vel*0.5 + move,vec2(-0.8),vec2(0.8));\n    }\n\n    float m_dist = 1.;  // minimun distance\n\n    // Iterate through the points positions\n    for (int i = 0; i < 10; i++) {\n        float dist = distance(st, point[i]);\n\n        // Keep the closer distance\n        m_dist = min(m_dist, dist);\n    }\n\n    // Draw the min distance (distance field)\n    float t = m_dist*0.8;\n    \n    vec3 color = pal(t,vec3(0.635,0.589,0.504),vec3(0.720,0.534,0.493),vec3(0.500,0.818,0.915),vec3(0.410,0.317,0.297));\n    \n    // Show isolines\n    // color -= step(0.10,m_dist)*-0.060;\n\n    fragColor = vec4(1.0 - color,0.5 - m_dist);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 190], [192, 277, 299, 299, 703], [705, 705, 772, 772, 819], [821, 821, 848, 848, 930], [933, 933, 990, 990, 1956]], "test": "timeout"}
{"id": "WtGSzK", "name": "flip", "author": "isk", "description": "just flipping some tiles", "tags": ["tile"], "likes": 6, "viewed": 354, "published": "Public API", "date": "1583098106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=acos(-1.);\n\nfloat h21(vec2 p) {\n    p=fract(p*vec2(589.27,916.79));\n    p+=dot(p,p+23.51);\n    return fract(p.x*p.y);\n}\n\nmat2 rmat(float theta) {\n    float s=sin(theta),c=cos(theta);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t=iTime;\n    \n    uv *= 10.+7.*sin(t*.283);\n    uv *= rmat(sin(t*.114));\n    \n    vec2 xy=fract(uv)-.5;\n    float r=h21(floor(uv));\n    \n    float side=sign(xy.x);\n    xy.x=abs(xy.x);\n    \n    float phase=t*.25+r*2.*PI;\n    float flip=.01+.49*smoothstep(0.,.1,abs(sin(phase)*.5));\n    float fill=1.-step(flip,xy.x);\n    \n    float dim=0.2+0.8*smoothstep(0.,.5,flip);\n    vec3 col=vec3(fill*dim);\n    col*=.4+.6*vec3(fract(r*12.3),fract(r*56.9),fract(r*177.2));\n    \n    const float bev=.06,nbev=.5-bev;\n    float edge=step(flip-bev,xy.x*side);\n    edge-=step(flip-bev,xy.x*-side);\n    edge+=step(nbev,xy.y);\n    edge-=(1.-step(-nbev,xy.y));\n    col *= (1.+.2*edge);\n    \n    fragColor=vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 46, 46, 134], [136, 136, 160, 160, 226], [228, 228, 283, 283, 1055]], "test": "error"}
{"id": "WtGXDy", "name": "SDF Test - Infinity", "author": "oleksier", "description": "Based on https://www.shadertoy.com/view/Xs3GRB", "tags": ["sdf"], "likes": 4, "viewed": 96, "published": "Public", "date": "1583451822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\n\n\n\n//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\nconst int iterations = 160;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .02;\n\nconst float cam_dist = 5.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit)\n{\n   vec3 fog_color = sky_color(ray_dir, light_dir);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -.003 :\n      .5; //iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y*.5) * -.003 :\n      .6; //iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir));\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\nfloat fField(vec3 p)\n{\n   float f = 1.;\n   if (mod((p.x + 2.25)/ 4.5,2.) > 1.) f = -1.;\n       \n   p.y = p.y + f * sin(iTime + p.z / 5.0);\n    \n   vec3 q = pMod3(p, vec3(4.5, 4.5, 4.5));\n   float box = length(max(abs(p) - 1., vec3(0)));\n   float sphere = length(p) - 1.2;\n   return max(box, -sphere);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXDy.jpg", "access": "shaders20k", "license": "cc-by-4.0 OR cc-by-3.0", "functions": [[1494, 1533, 1553, 1553, 1578], [1580, 1580, 1604, 1604, 1619], [1621, 1621, 1643, 1643, 1658], [1660, 1660, 1682, 1682, 1697], [1699, 1699, 1724, 1724, 1745], [1748, 1788, 1808, 1808, 1833], [1835, 1835, 1855, 1855, 1890], [1892, 1892, 1912, 1912, 1957], [1959, 1959, 1979, 1979, 2004], [2006, 2006, 2026, 2026, 2061], [2063, 2063, 2083, 2083, 2128], [2686, 2686, 2718, 2718, 2743], [2745, 2819, 2875, 2875, 2917], [2919, 2970, 3003, 3015, 3043], [3045, 3081, 3109, 3109, 3190], [3192, 3249, 3283, 3283, 3309], [3311, 3311, 3340, 3340, 3421], [3424, 3444, 3468, 3468, 3527], [3529, 3633, 3654, 3654, 4027], [4029, 4074, 4122, 4122, 4196], [4198, 4251, 4293, 4293, 4387], [4389, 4473, 4517, 4517, 4620], [4622, 4694, 4743, 4743, 4780], [4782, 4807, 4867, 4867, 4938], [4940, 5039, 5071, 5071, 5132], [5134, 5267, 5297, 5297, 5378], [5380, 5421, 5465, 5465, 5705], [5707, 5744, 5784, 5784, 5848], [5850, 5946, 5995, 5995, 6494]], "test": "error"}
{"id": "WtGXWG", "name": "loopless dots along circle (266c", "author": "FabriceNeyret2", "description": "golfing [url]https://shadertoy.com/view/XsVBz3[/url] ( 379 chars )\ncould it be shorter ? :-)\n\nin a fragment shader, regular patterns can generally be done loopless: each pixel determine on which feature it lays (or not).\n", "tags": ["2tweets", "tuto", "short", "golf", "loopless"], "likes": 5, "viewed": 296, "published": "Public API", "date": "1583429676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfing https://shadertoy.com/view/XsVBz3 ( 379 chars )\n\n#define S(v,r)  smoothstep ( 3./R.y, 0., length(v) r )    //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U =   u+u - R ;\n    float n = ( 16.+ 15.*sin(iTime) ) / 6.3,\n          a = atan(U.y,U.x) * n;\n    O =   S( U = abs( vec2( ( fract (a)     - .5 ) * .5/n,\n                              length(U)/R.y - .5\n                    )     ),\n             -.03 )\n        * ( .6 + .6 * cos( ceil(a)/n + vec4(0,23,21,0) ) )\n        + S( max(U.x,U.y) - .1 , );\n} /*\n\n\n\n\n\n\n// --- 270 chars\n        \n#define S(v,r)  smoothstep ( 3./R.y, 0., length(v) r )   //\n#define mainImage(O,u)                                    \\\n    vec2  R = iResolution.xy,                             \\\n          U = ( u+u - R ) / R.y;                          \\\n    float n = (16.+15.*sin(iTime))/6.3,                   \\\n          a = atan(U.y,U.x) * n;                          \\\n    U = abs( vec2( ( fract (a) - .5 ) * .5/ n,            \\\n                     length(U) - .5                       \\\n            ));                                           \\\n    O =   S( U, -.03 )                                    \\\n        * ( .6 + .6 * cos( ceil(a)/n + vec4(0,23,21,0) ) )\\\n        + S(max(U.x,U.y)-.1,)                            /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "wtKSDV", "name": "Try Spinning That's A Good Trick", "author": "decstar77", "description": "NA", "tags": ["spinning"], "likes": 5, "viewed": 82, "published": "Public", "date": "1583685535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n\nvec3 DrawCircle(vec2 uv, vec2 c, float r)\n{\n    float d =distance(uv, c);\n    return vec3(smoothstep(r * 2., r * 1.5, d));\n}\nvec3 DrawHollowCircle(vec2 uv, vec2 c, float r, float w)\n{\n    float d = distance(uv, c);  \n    float a1 = smoothstep(r + w/2., r, d);\n    float a2 = smoothstep(r - w/2., r - w, d);\n    return vec3(a1 - a2);    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n \tvec2 uv = (fragCoord + fragCoord - iResolution.xy) / (iResolution.y - 50.f);\n\n    // Time varying pixel color\n\tfloat t = iTime;\n    \n    vec3 col = vec3(0);    \n    vec2 center = vec2(0., 0.);\n    float raduis = 1.;\n    float diameter = raduis * 2.;\n    float h = 0.45 * sin(t * PI/2.); \n    h = 0.45f;\n    vec2 q = h * vec2(cos(PI/2. * t), sin(PI/2. * t));\n\t\n    \n    float count = 12.;\n    for (float i = .0; i < count; i++)\n    {\n        float r = radians(360./count * i);\n        vec2 point = vec2(cos(r * t), sin(r * t));\n        vec2 line_start = point;\n        vec2 line_end = q;\n\n        vec2 line_dir =  line_start - line_end;\n        float distance_to_line = abs(line_dir.y * uv.x - \n                                      line_dir.x * uv.y + \n                                      line_start.x * line_end.y - \n                                      line_start.y * line_end.x) / length(line_dir);                                                      \n\n\n\n\t\t//if (distance(line_end, point) < 0.5)\n        if (distance(uv, center) < raduis && distance(uv, point) < raduis * 0.5)\n        \tcol += smoothstep(0.01 * 2., 0.01, distance_to_line);// distance_to_line < 0.01 ? vec3(1) : vec3(0);\n        \n        col += DrawCircle(uv, line_start, 0.03);\n       \n    }\n    col += vec3(DrawCircle(uv, q, 0.03).x, 0.,0.);   \n    col += DrawHollowCircle(uv, center, raduis, 0.03);\n    //col = uv.x < min(p1.x, p2.x) ? vec3(0) : col;\n    //col = uv.x > max(p1.x, p2.x) ? vec3(0) : col;\n    //col = uv.y < min(p1.y, p2.y) ? vec3(0) : col;\n    //col = uv.y > max(p1.y, p2.y) ? vec3(0) : col;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 70, 70, 151], [152, 152, 210, 210, 365], [366, 366, 423, 423, 2068]], "test": "timeout"}
{"id": "wtKSDy", "name": "5/2020", "author": "rimina", "description": "Still continuing from where I got yesterday (https://www.shadertoy.com/view/WlySDG) on my daily shader thingy. I have no idea where this goes.", "tags": ["raymarching", "lighting"], "likes": 1, "viewed": 54, "published": "Public", "date": "1583531530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 128\n#define E 0.001\n#define gamma vec3(2.2)\n\nconst vec3 AMBIENT = vec3(0.2, 0.4, 0.64);\nconst vec3 LC1 = vec3(0.3, 0.6, 0.8);\nconst vec3 LC2 = vec3(0.6, 0.4, 0.3);\n\nstruct Material{\n    vec3 lambertian;\n    vec3 specular;\n    float shininess;\n    bool reflective;\n    bool refractive;\n};\n\n\nMaterial getGroundMaterial(){\n    Material mat;\n    mat.lambertian = vec3(0.3, 0.3, 0.5);\n    mat.specular = vec3(0.64, 0.62, 0.6);\n    mat.shininess = 40.0;\n    mat.reflective = false;\n    mat.refractive = false;\n    \n    return mat;\n}\n\nMaterial getBlockMaterial(in vec2 id){\n    vec2 s = smoothstep(vec2(0.4), vec2(0.8), id);\n    \n    Material mat;\n    mat.lambertian = vec3(id.x, s.y, s.x);\n    mat.specular = vec3(s.y, id.x, s.x);\n    mat.shininess = 10.0;\n    mat.reflective = false;\n    mat.refractive = false;\n    \n    return mat;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\nfloat scene(in vec3 p, out Material mat){\n    \n    float pl = dot(p, normalize(vec3(0.0, 1.0, 0.0)))+1.0;\n    pl -= smoothstep(0.0, 1.0, noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.2));\n    \n    vec3 pp = p;\n    vec2 n = vec2(2.7, 8.0);\n    vec2 dif = n*0.5;\n    pp.xz = mod(p.xz+dif, n)-dif;\n    vec2 id = abs(floor((p.xz+dif)/n));\n    id.x = 1.0+sin(id.x);\n    \n    vec3 d = abs(pp)-vec3(1.0,\n             abs(cos(id.x)+sin(id.y))+0.5,\n             1.0);\n    float sp = length(max(max(d.x, d.y), d.z));\n    \n    vec3 gd = abs(pp)-vec3(n.x, 5.0, n.y)*0.5;\n    \n    float guard = -length(max(max(gd.x, gd.y), gd.z));\n    guard = abs(guard) + n.x*0.1;\n    \n    if(sp < guard && sp < pl){\n        mat = getBlockMaterial(id);\n    }\n    else{\n        mat = getGroundMaterial();\n    }\n    \n    return min(min(sp, guard), pl);\n}\n\nfloat march(in vec3 o, in vec3 d, in float far, in bool inside, out vec3 p, out bool hit, out Material mat){\n    float t = 0.0;\n    float dir = inside ? -1.0 : 1.0;\n    hit = false;\n    for(int i = 0; i < STEPS; ++i){\n        p = o + d*t;\n        float dist = dir*scene(p, mat);\n        \n        if(abs(dist) < E || t > far){\n            if(abs(dist) < E ){\n            \thit = true;\n            }\n            break;\n        }\n        t += dist * 0.999;\n    }\n    \n    return t;\n}\n\nvec3 normal(in vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    Material mat;\n    return normalize(vec3(\n        scene(p+eps.xyy, mat) - scene(p-eps.xyy, mat),\n        scene(p+eps.yxy, mat) - scene(p-eps.yxy, mat),\n        scene(p+eps.yyx, mat) - scene(p-eps.yyx, mat)\n    ));\n}\n\nvec3 shade(in vec3 p, in vec3 d, in vec3 ld, in vec3 lp, in Material mat){\n    \n    vec3 n = normal(p);\n    float lamb = max(dot(n,ld), 0.0);\n    vec3 angle = reflect(n, ld);\n    float spec = pow(max(dot(d, angle), 0.0), mat.shininess);\n    \n    float l = distance(p, lp);\n    bool hit = false;\n    vec3 sp = vec3(0.0);\n    Material mats;\n    float st = march(p+E*n*2.0, ld, l, false, p, hit, mats);\n    float s = 1.0;\n    if(hit){\n        s = 0.0;\n    }\n    \n    return (lamb*mat.lambertian*0.5 + spec*mat.specular*0.8)*s;\n}\n\nvec3 fog(in vec3 col, in vec3 p, in vec3 ro, in vec3 rd, in vec3 ld, in vec3 lc){\n    float d = length(p-ro);\n    float sa = max(dot(rd, -ld), 0.0);\n    float fa = 1.0-exp(-d*0.05);\n    vec3 fc = mix(vec3(0.64, 0.62, 0.6), lc, pow(sa, 4.0));\n    return mix(col, fc, fa);\n}\n\nmat3 camera(in vec3 o, in vec3 t, in vec3 up){\n    \n    vec3 z = normalize(t-o);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    \n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv*2.0-1.0;//scaling from -1 to 1\n    q.x *= (iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(0.0, 2.5, iTime);\n    vec3 rt = vec3(0.0, -4.0, 10.0+iTime);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam = camera(ro, rt, up);\n    vec3 rd = normalize(cam*vec3(q, radians(60.0)));\n    \n    vec3 p = vec3(0.0);\n    bool hit = false;\n    Material mat;\n    float t = march(ro, rd, 40.0, false, p, hit, mat);\n    vec3 col = AMBIENT * 0.6;\n    \n    vec3 lp = vec3(2.0*sin(iTime*0.5)+iTime, -4.0, 1.0+2.0*cos(iTime*0.5)+iTime);\n    vec3 lt = vec3(0.0, 0.0, -10.0+iTime);\n    vec3 ld = normalize(lt-lp);\n    vec3 ld2 = normalize(ro-rt);\n    \n    if(hit){\n        vec3 c = shade(p, rd, ld, lp, mat);\n        c += shade(p, rd, -ld2, ro, mat);\n        c *= 0.5;\n        col += c;\n    }\n    \n    col = fog(col, p, ro, rd, ld, LC1);\n    col += fog(col, p, ro, rd, -ld2, LC2);\n    col *= 0.5;\n    \n    col = pow(smoothstep(0.08, 1.1, col)*smoothstep(0.8, 0.005*0.799, \n          distance(uv, vec2(0.5))*(0.8 + 0.005)), 1.0/gamma);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 333, 333, 540], [542, 542, 580, 580, 843], [845, 871, 891, 891, 1170], [1173, 1173, 1214, 1214, 1993], [1995, 1995, 2103, 2103, 2474], [2476, 2476, 2499, 2499, 2752], [2754, 2754, 2828, 2828, 3279], [3281, 3281, 3362, 3362, 3553], [3555, 3555, 3601, 3601, 3743], [3745, 3745, 3802, 3852, 4994]], "test": "timeout"}
{"id": "WtKSzt", "name": "MONSTER", "author": "butadiene", "description": "30min livecoding", "tags": ["raymarching", "cineshader"], "likes": 18, "viewed": 16775, "published": "Public API", "date": "1583384504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float TK = 1.;\nfloat PI = 3.1415926535;\n\nvec2 rot(vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn m*p;\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np = 2.0*PI/n;\n\tfloat r = atan(p.x,p.y)-0.5*np;\n\tr = mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 m = max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\n\nfloat dist(vec3 p){\n\tp.z -= 1.*TK*iTime;\n\tp.xy = rot(p.xy,1.0*p.z);\n\tp.xy = pmod(p.xy,6.0);\n\tfloat k = 0.7;\n\tfloat zid = floor(p.z*k);\n\tp = mod(p,k)-0.5*k;\n\tfor(int i = 0;i<4;i++){\n\t\tp = abs(p)-0.3;\n\n\t\tp.xy = rot(p.xy,1.0+zid+0.1*TK*iTime);\n\t\tp.xz = rot(p.xz,1.0+4.7*zid+0.3*TK*iTime);\n\t}\n\treturn min(cube(p,vec3(0.3)),length(p)-0.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 2.0*(uv-0.5);\n\tuv.y *= iResolution.y/iResolution.x;\n\tuv = rot(uv,TK*iTime);\n\tvec3 ro = vec3(0.0,0.0,0.1);\n\tvec3 rd = normalize(vec3(uv,0.0)-ro);\n\tfloat t  =2.0;\n\tfloat d = 0.0;\n\tfloat ac = 0.0;\n\tfor(int i = 0;i<66;i++){\n\t\td = dist(ro+rd*t)*0.2;\n\t\td = max(0.0000,abs(d));\n\t\tt += d;\n\t\tif(d<0.001)ac += 0.1;//exp(-15.0*d);\n\t}\n\tvec3 col = vec3(0.0);\n\tcol = vec3(0.1,0.7,0.7)*0.2*vec3(ac);//vec3(exp(-1.0*t));\n\tvec3 pn = ro+rd*t;\n\tfloat kn = 0.5;\n\tpn.z += -1.5*iTime*TK;\n\tpn.z = mod(pn.z,kn)-0.5*kn;\n\tfloat em = clamp(0.01/pn.z,0.0,100.0);\n\tcol += 3.0*em*vec3(0.1,1.0,0.1);\n\tcol = clamp(col,0.0,1.0);\n\t//col = 1.0-col;\n\n\n    // Output to screen\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 66, 66, 127], [129, 129, 155, 155, 274], [276, 276, 302, 302, 398], [400, 400, 419, 419, 736], [739, 739, 796, 796, 1514]], "test": "timeout"}
{"id": "WtKXD3", "name": "Breathing thingy", "author": "hazenn", "description": "trying some stuff", "tags": ["fractal"], "likes": 3, "viewed": 171, "published": "Public API", "date": "1583736774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415;\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat triwave(float x)\n{\n\treturn 1.0-4.0*abs(0.5-fract(0.5*x + 0.25));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float offset = 1. - sin(iTime);\n    \n\tvec2 f = abs(uv);\n    vec2 e = floor(f);\n    \n    for (int i=0;i<6;i++){\n    f *= 3.;\n    e = floor(f-offset); f = fract(f); \n    f = f * ( ((e.x == 0.) && (e.y == 0.))?0.:1. );\n    }\n    \n    \n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = smoothstep(0.1,0.,dot(f,f)) * col;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 102], [104, 104, 128, 128, 176], [179, 179, 236, 286, 747]], "test": "ok"}
{"id": "WtKXDK", "name": "Modular Multiplication", "author": "ElVago", "description": "Inspired by MicMaths: https://youtu.be/-X49VQgi86E", "tags": ["multiplication"], "likes": 3, "viewed": 94, "published": "Public", "date": "1583617582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define MULTIPLIER 100.\n#define MODULE 150. //Number of Vectors\n\nvec4 get_color(vec2 uv, float mul, vec4 color) {\n    float step_angle =2. * PI / float(MODULE);\n    float start_angle = PI / 2.0;\n    float end_angle = PI / 2.0;\n\n    for (float i = 0.; i < MODULE; i++) {\n        vec2 line_start = vec2(sin(start_angle), cos(start_angle));\n        if (distance(line_start, uv) < .01)//Point thickness.\n            return vec4(1., 0.0, .0, 1.); //Point color.\n\n        vec2 line_end = vec2(sin(end_angle), cos(end_angle));\n        vec2 line_dir = line_end - line_start;\n        float distance_to_line = abs(line_dir.y * uv.x -line_dir.x * uv.y + line_start.x * line_end.y - line_start.y * line_end.x) / length(line_dir);\n        if (distance_to_line < 2. / iResolution.y &&\n                dot(uv - line_start, line_dir) > 0. && \n           \t\tdot(uv - line_end, line_dir) < 0.) \n            return color;\n        \n        start_angle += step_angle;\n        end_angle += mul * step_angle;\n    }\n\n    return vec4(0.);//Background color.\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord + fragCoord - iResolution.xy) / (iResolution.y-20.0);//Ball size.\n\n    float mul = 1.0 + MULTIPLIER * (1. - cos(.01 * iTime));//Speed.\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);//Color of vectors.\n\n    fragColor = get_color(uv, mul, color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 138, 138, 1058], [1060, 1060, 1115, 1115, 1383]], "test": "ok"}
{"id": "WtKXWd", "name": " Ancient Temple-II", "author": "jorge2017a1", "description": "https://www.shadertoy.com/view/4lX3Rj------kali\nhttps://www.shadertoy.com/view/XsfczB-----Russ\n", "tags": ["ancienttempleii"], "likes": 2, "viewed": 83, "published": "Public", "date": "1583875706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/4lX3Rj------kali\n//https://www.shadertoy.com/view/XsfczB-----Russ\n\n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,.8,1); \n///--------------------------------\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\nfloat ot=0.;\nfloat det=0.;\nfloat hitfloor;\nfloat hitrock;\nfloat tt;\n\n///---------------------------------\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n\n\nfloat DE(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tot=1000.;\n    \n    \n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    \n    \n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    float fl=pos.y-3.013;\n    float d=min(fl,length(p)/DEfactor-.0005);\n\td=min(d,-pos.y+3.9);\n    d=min(d,rr);\n    if (abs(d-fl)<.0001) hitfloor=1.;\n    if (abs(d-rr)<.0001) hitrock=1.;\n    \n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.2 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .4;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    /*\n    float s1 = sin(time), c1 = cos(time);\n    float arg = 1.5*sin(time*.7894)*.5 + .5;\n    float s2 = sin(arg), c2 = cos(arg);\n    */\n    \n    ///----------------\n    vec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n    float y=(cos(iTime*.1+3.)+1.);\n    if (iMouse.z<1.) mouse=vec2(sin(t*2.),cos(t)+.3)*.15*(.5+y)*min(1.,iTime*.1);\n\tuv+=mouse*1.5;\n\tuv.y-=.1;\n    \n    \n    \n    vec3 from=vec3(0.0,3.04+y*.1,-2.+iTime*.05);\n\tvec3 dir=normalize(vec3(uv*.75,1.));\n    \n    vec3 ro =from;\n    \n    \n    \n    vec3 rd = dir;\n    \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    col += pow(hit.y,3.);\n    \n    col=col+pow(col,vec3(0.78902));\n    \n   \n    col=mix(vec3(length(col)),col,.85)*.95;\n    \n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 543, 570, 570, 601], [603, 603, 634, 634, 725], [728, 728, 751, 751, 888], [890, 890, 920, 920, 1057], [1062, 1062, 1082, 1082, 1651], [1654, 1654, 1683, 1683, 1871], [1873, 1873, 1914, 1914, 2090], [2092, 2092, 2133, 2133, 2285], [2287, 2287, 2308, 2308, 2438], [2440, 2440, 2467, 2467, 2714], [2716, 2716, 2773, 2773, 3717]], "test": "timeout"}
{"id": "WtKXzD", "name": "Infinite expanding grid", "author": "julianlumia", "description": "please ignore the messy code... its really inefficient but i really like the result of this quick doodle)", "tags": ["illusion"], "likes": 8, "viewed": 117, "published": "Public", "date": "1583103778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n vec3 d = abs(p) - b;\n return length(max(d,0.0)); \n}\n\n\nfloat dBar(vec2 p, float width) {\n vec2 d = abs(p) - width;\n return min(max(d.x, d.y), 0.0) + length(max(d, 0.)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n float bar_x = dBar(p.yz, x);\n float bar_y = dBar(p.zx, x);\n float bar_z = dBar(p.xy, x);\n return min(bar_z, min(bar_x, bar_y));\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat dMengerSponge(vec3 p,vec3 size) \n{\n float d = sdBox(p, vec3(size));\n float itt =1.;\n float one_third = .094 / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.5)\n\nfloat GetDist(vec3 p) {\t\n float gap = 1.;\n p.xyz = mod(p.xyz + gap,2.0 * gap) - gap;\n float d;\n d=float(1.0);  \n p = rotate( ( vec3(sin(p.z*2.+iTime*.5) , 0.,0. ) ), 2.)*p;\n vec3 q = p;\n float dp = dot(p,(p*1.))*.2;\n p /= dp;\n p = abs(p*5.);   \n p=fract(p-vec3(T*tau*.1,T*tau*.1,T*tau*.1))*.1;\n float dm1= (dMengerSponge(p,vec3(1.)))+(dMengerSponge(q,vec3(.85)));\n d *=1.;\n d = min( d,dm1); \n d = (((d*dp)/1.));\n g1 +=1./(.001+pow(abs(dm1),1.));\n return d;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) \n{\n float    dO = 0.;        \n for (int i=0; i<100; i++) \n  {\n   vec3 p = ro + dO * rd;\n   float dS = GetDist (p);\n   if (dS<0.001 || abs(dO)>100.) break;  \n   dO += dS*1.;\n  }\n return dO;\n}\n \nvec3 GetNormal(vec3 p)\n{\n float d = GetDist(p);\n vec2 e = vec2(0.001,0.);\n vec3 n = d - vec3(\n  GetDist(p-e.xyy),\n  GetDist(p-e.yxy),\n  GetDist(p-e.yyx));\n return normalize(n);\n}\n\n\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(1);\n    \n    if(fract(dot(floor(p), vec3(.1))) > .1) col = vec3((sin(iTime*2.5)*0.5+0.5),0.2,0.);\n    if(fract(dot(floor(p), vec3(.5))) < .5) col = vec3((cos(iTime*1.5)*0.5+0.5),0.,0);\n    \n    return col;\n    \n}\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);\n vec3 cameraPos = vec3(1.,1.,1);\n vec3 lightPos1 = vec3(-cameraPos-vec3(1,1.,0.0));\n vec3 l1 = normalize(lightPos1-p);\n vec3 n1 = GetNormal(p);    \n float dif1 = clamp(dot(n1, l1), 0., 1.);\n float d1 = RayMarch(p+n1*0.001*1., l1);\n if(d1<length(lightPos1-p)) dif1 *= .6;    \n return (dif1)/=.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 col = vec3(0);\n float s = mod(iTime * 0.25, 1.0);\n float t = 1. * (2.0 * s - s * s);  \n vec3 cameraPos = vec3(1.,1.,1);\n vec3 ro = vec3(-cameraPos);\n vec3 rd = normalize(vec3(uv.x, uv.y, 2.5));\n float the = iTime *1.;\n the = 3.85;\n rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float d = RayMarch(ro, rd);\n float t2;\n t2=d;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  vec3 objCol = getObjectColor(p);\n\n  col+=objCol;\n }  \n col*=g1*vec3(.00001);  \n\n         col/=g1*vec3(.0001);  \nfloat fog = 3. / (1. + d * d * 10.);\n col *= vec3(fog);  \n vec3 sky = vec3(0., 1., 1.);\n col = mix(sky, col, 1.15/(d*d/1./1.*.5+1.)); \n fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 65, 65, 118], [121, 121, 154, 154, 251], [253, 253, 287, 287, 418], [420, 420, 439, 439, 506], [508, 508, 546, 546, 597], [599, 599, 639, 639, 891], [894, 894, 932, 932, 999], [1011, 1011, 1052, 1052, 1420], [1486, 1486, 1509, 1509, 1944], [1946, 1946, 1982, 1982, 2170], [2173, 2173, 2197, 2197, 2351], [2354, 2354, 2382, 2382, 2620], [2623, 2623, 2661, 2661, 3028], [3030, 3030, 3087, 3087, 3951]], "test": "timeout"}
{"id": "WtKXzK", "name": "DrunkFog", "author": "ddorn", "description": "Sea of oil creating while trying to create fog.", "tags": ["noise", "waves", "oil", "fractalnoise"], "likes": 2, "viewed": 160, "published": "Public", "date": "1583141706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n/// Return a determistic random value between 0 and 1.\n/// This function was taken from The Book of Shaders.\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n/// Return a vec2 in the unit sphere\nvec2 random2(vec2 st){\n    float a = random(st) * 6.1831;\n    return vec2(cos(a), sin(a));\n}\n\n\nvec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.1547*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n\n\n/// Return a random value in [0,1]. This function is continuous.\nfloat noise(vec2 st) {\n\n    st = skew(st);\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    // A random gradient for each corner of the simplex\n    vec2 op = (f.y >= f.x) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 a = random2(i);\n    vec2 b = random2(i + op);\n    vec2 c = random2(i + vec2(1.0, 1.0));\n\n    // Dot pruduct between the random gradient and\n    // the vecteur comming from the corner\n    vec3 t = vec3(\n        dot(a, (f)),\n        dot(b, (f - op)),\n        dot(c, (f - 1.))\n    );\n\n    if (u.y >= u.x) {\n        u = u.yx;\n    }\n\n    // Barycentric coordinates according to\n    // https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\n    vec3 l = vec3(1. - u.x, u.x - u.y, u.y);\n    float r = dot(t, l);\n    return .5*r + 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ratio =  iResolution.xy/iResolution.yx;\n    \n    vec2 pos = fragCoord.xy / iResolution.xy * iResolution.x / 1000.;\n    vec2 dp = vec2(-.5, 1.) * iTime / 3.;\n    pos *= 4.;\n    pos += dp;\n    //pos = (pos - 0.25) * (iMouse.y / iResolution.y * 9. + 1.) + dp;\n    \n    float c1 = 10.;\n    float c2 = 5.;\n    vec2 d1 = vec2(1) * iTime / 2. ;\n    float d2 = iTime / 10.;\n\n    float f = noise(pos.yx + d1 + c1 * noise(pos + d2 + c2 * noise(pos)));\n\n    vec3 a = vec3(0.0);\n    vec3 b = vec3(0.3, 0.1, 0.2);\n    vec3 c = vec3(0.22, 0.741, 0.616);\n    vec3 d = vec3(0.965, 0.971, 0.349);\n\n    vec3 p = vec3(0.4, 0.6, 0.7);\n\n\tvec3 color;\n    if (f < p.x) {\n        color = mix(a, b, f);\n    } else if (f < p.y) {\n        color = mix(b, c, smoothstep(p.x, p.y, f));\n    } else {\n        color = mix(c, d, smoothstep(p.y, p.z, f));\n    }\n\n    fragColor = vec4(color, 1.) ;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 111, 139, 139, 247], [250, 287, 309, 309, 379], [382, 382, 403, 403, 490], [493, 558, 580, 580, 1407], [1410, 1410, 1465, 1465, 2338]], "test": "timeout"}
{"id": "wtVGDD", "name": "circles.gif", "author": "DannnYXZ", "description": "attempt to recreate gif", "tags": ["circles", "hex"], "likes": 2, "viewed": 47, "published": "Public", "date": "1584177158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nint chr[12]=int[12](0xe9d72e, 0xe210c4, 0x1f0ba0f, 0xf8320f, 0x1087a31, 0x1f87c3f, 0xe8bc3e, 0x84221f, 0xe8ba2e, 0xe87a2e, 0x007c00, 0xc60000);\n\nfloat font(vec2 p, float code) { // p in [0, 1]\n    if(p.x > 1. || p.y > 1. || p.x < 0. || p.y < 0.) return 0.;\n    p = ((p - vec2(0., 1.)) * vec2(1., -1.)) * 5.;\n    float pos = floor(p.x) + 5.0 * floor(p.y);\n    return float((chr[int(code)]>>int(pos))&1);\n}\n\nfloat number(vec2 uv, float x) {\n    float a, mask = 0., d = 1.1;\n    if(x < 0.) {\n        mask += font(uv, 10.);\n        uv.x -= d;\n        x = abs(x);\n    }\n    float b = modf(x, a);\n    float la = ceil(log(a + 1.) / log(10.)), lb = 4.;\n    vec2 uva = uv - vec2((la - 1.) * d, 0.);\n    vec2 uvb = uv - vec2((la + 1.) * d, 0.);\n    mask += font(uv - vec2(la * d, 0.), 11.); // dot\n    while(la > 0.) {\n        mask += font(uva, mod(a, 10.));\n        a /= 10.;\n        uva.x += 1.1;\n        la -= 1.;\n    }\n    while(lb > 0.) {\n        b *= 10.;\n        mask += font(uvb, mod(b, 10.));\n        b = fract(b);\n        uvb.x -= 1.1;\n        lb -= 1.;\n    }\n    return mask;\n}\n\nfloat ring(vec2 uv, float r){\n    float d = length(uv);\n    float c1 = smoothstep(r, r-.01, d);\n    float c2 = smoothstep(r-.009, r-.0098, d);\n    return c1-c2;\n}\n\nvec4 hex_uv(vec2 uv){\n    float r3 = sqrt(3.);\n    vec2 p = vec2(1., r3);\n    vec2 hp = .5 * p;\n    vec2 gv0 = mod(uv, p)-hp; \n    vec2 gv1 = mod(uv - hp, vec2(1., r3))-hp;\n    vec2 gv = length(gv0) < length(gv1) ? gv0 : gv1;\n    vec2 id = uv - gv;\n    return vec4(gv, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 8.;\n    float t = iTime;\n    t *= .25;\n    t = iMouse.x/iResolution.x * 4.;\n    //uv = abs(uv);\n    vec3 col = vec3(0);\n    \n    float blink = sign(sin(iTime))*.5 + .5;\n    blink = 1.;\n    vec2 id = hex_uv(uv).zw;\n    col.rg = mix(col.rg, id*.1, blink);\n    float scaler = (sin(t*2.)*.5 + 1.5);\n    float m = 0., r = .5;\n#if 0\n    float dy = sqrt(3.)*r;\n    for(float i=0.; i<7.; i++){\n        for(float j=0.; j<9.; j++){\n            float dx = mod(i, 2.) == 0. ? 0.: r;\n            vec2 c = vec2(2.*r*j + dx, i * dy);\n            c /= scaler;\n            //c/= d;\n            vec2 p = vec2(1., sqrt(3.));\n            vec2 hm = .5*p*1.5;\n            hm/=scaler;\n            float d = smoothstep(.05, .049, length(uv - hm));\n            col += d;\n            //col = vec3(d);\n            m += ring(uv - c, r);\n            m += ring(uv - vec2(-c.x, c.y), r);\n            m += ring(uv - vec2(c.x, -c.y), r);\n        }\n    }\n    col += m;\n#endif\n#if 1\n    vec2 np = uv * scaler;\n    vec2 gv = hex_uv(np).xy;\n    scaler = (sin(length(uv) + iTime)*.5 + 1.5);\n    col = vec3(scaler)*.2;\n    gv/=scaler;\n    m += ring(gv, r);\n    float hr3 = .5*sqrt(3.);\n    float dx[6] = float[6](-.5, 0.5, 1.0, 0.5, -0.5, -1.);\n    float dy[6] = float[6](hr3, hr3, 0.0, -hr3, -hr3, 0.);\n    //col += duv;\n    for(int i = 0; i < 6; i++){\n        vec2 cp = vec2(dx[i], dy[i]);\n        cp/=scaler;\n        m += ring(gv-cp, r);\n    }\n    //m = ring(gv, r);\n    col += m;\n#endif\n    //col = uv.xy;\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 178, 193, 405], [407, 407, 439, 439, 1079], [1081, 1081, 1110, 1110, 1243], [1245, 1245, 1266, 1266, 1520], [1522, 1522, 1579, 1579, 3154]], "test": "error"}
{"id": "WtVSDD", "name": "Halo Radar", "author": "BE4T", "description": "Radar from halo", "tags": ["midterm"], "likes": 6, "viewed": 85, "published": "Public", "date": "1583663861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float angle){\n    \n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle));\n}\n\n\nfloat drawRectangle( vec2 uv, vec2 position, vec2 size){\n\n   float rectangle = step(position.x - size.x/2., uv.x) - step(position.x - size.x/2. + size.x,uv.x);\n    rectangle *= step(position.y - (size.y/2.), uv.y) - step(position.y + (size.y/2.), uv.y);\n    return rectangle;\n}\n\nfloat circle(vec2 uv, vec2 pos, float radius){ // Standard Circle\n    \n    return float(distance(uv, pos) < radius);\n}\n\n\nfloat circle2(vec2 uv, vec2 pos, float radius, float vignette){\t//Vignette For Circle\n    \n    return float(smoothstep(radius*vignette, radius, distance(uv, pos)));\n}\n\nfloat circle3(vec2 uv, vec2 pos, float radius){ //Circle Limiter\n    \n    \n    return float(.1-smoothstep(radius, radius+0.01, distance(uv, pos)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 uv2 = uv;\n    \n    // centers pivot point\n    vec2 pos = vec2(0.5*ratio,0.5);\n   \tvec2 pos2 = vec2(0.5*ratio,1.2);\n    // translates the shape to center origin\n    uv -= pos;\n    uv2 -= pos2;\n    \n    //rotations/scales\n    \n  \tuv2 *= rotate2d(1.5708*.5);\n    \n    // translates back to the shape\n    uv += pos;\n    uv2 += pos2;\n    \n    float radius = .48;\n    float radius2 = sin(iTime*5.)/40. + 0.78; //*.2 + .4\n    float radius3 = fract(iTime / 2.4);\n    \n    vec3 lightBlue = vec3(0.27,0.67,1.0);\n    \n    vec3 color;\n    \n    \n    // Radar\n    \n    color += vec3(circle2(uv, pos, .5, 0.8)) + vec3(circle3(uv,pos,.130));\n    \n    color += vec3(circle2(uv, pos, radius2, 0.5) + vec3(circle3(uv,pos,radius)));\n    \n    color += vec3(circle3(uv, pos,radius));\n    \n    // Pulse\n    \n    color += vec3(circle2(uv, pos,radius3, 0.5)) + vec3 (circle3(uv, pos, radius3)) + vec3(circle3(uv,pos,radius)) ;\n    \n    // Cone of Vision\n    \n    color += vec3(drawRectangle(uv2, pos2, vec2(1.,1.)) + vec3(circle3(uv,pos,radius)));\n    color *= lightBlue;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 117], [120, 120, 176, 176, 397], [399, 399, 445, 464, 517], [520, 520, 583, 605, 686], [688, 688, 735, 752, 837], [839, 839, 896, 946, 2174]], "test": "ok"}
{"id": "WtVSWt", "name": "Transformator.", "author": "Logos", "description": "Dynamic version of my very old shader:\n\nhttps://warsztat.gd/screen/14209/inwersja.\n", "tags": ["sin", "space", "inversion"], "likes": 16, "viewed": 179, "published": "Public", "date": "1583919631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Robert Śmietana (Logos) - 11.03.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n\n//--- camera stuff ---//\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, sin(0.59*iTime));\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\n//--- scene description ---//\n\nfloat distanceToScene(vec3 p)\n{\n\tfloat dp = dot(p, p);\n\t\n    p *= 3.0 / dp;\n\tp  = sin(3.0*p + iTime*vec3(0.0, -4.0, 0.0));\n\n\tfloat d = min(length(p.xz) - 0.15, length(p*p) - 0.1);\n\n\treturn 0.6*d * dp*0.111111;\n}\n\n\n//--- cheap normal computing ---//\n\nvec3 computeSurfaceNormal(vec3 p)\n{\n    float d = distanceToScene(p);\n    \n    return normalize(vec3(\n        distanceToScene(p + vec3(0.001, 0.0, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.001, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.0, 0.001)) - d));\n}\n\n\n//--- output color ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- camera setup ---//\n    \n    float rtime = 0.35*iTime;\n    \n    vec2 p   = (-iResolution.xy + 2.0*fragCoord - 1.0) / iResolution.y;\n \tvec3 pos = vec3(5.0 + 5.0*cos(rtime), 10.0*cos(1.2*rtime), 6.0 + 5.0*sin(0.78*rtime));\n    vec3 tar = vec3(0.0);\n    vec3 dir = setCamera(pos, tar) * normalize(vec3(p.xy, 11.6));  \n    \n    \n    //--- distance to nearest object in the scene ---//\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < 210; i++)\n    {\n\t\tfloat d = distanceToScene(pos + t*dir);\n\t\tif(d < 0.003) break;\n        \n\t\tt += d;\n\n        \n\t\t//--- early skip of background pixels ---//\n    \n        if (t > 27.0)\n        {\n            fragColor = vec4(0.0);\n            return;\n        }\n\t}\n    \n    \n    //--- output color depends on few things ---//\n    \n    vec3  sn = computeSurfaceNormal(pos + t*dir);\t\t\t// surface normal\n    float dc = clamp(dot(sn, normalize(pos)), 0.0, 1.0);\t// diffuse component\n    float sr = pow(dc, 100.0);\t\t\t\t\t\t\t\t// specular reflection\n    float od = length(pos + t*dir);\t\t\t\t\t\t\t// distance to origin\n    \n\tfragColor     = abs(dir.xzyz);\n    fragColor    *= 0.2 + 0.8*dc;\n    fragColor.yz *= clamp(od, 0.0, 1.0);\n    fragColor    += sr;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 200, 200, 381], [415, 415, 446, 446, 626], [665, 665, 700, 700, 938], [967, 967, 1022, 1056, 2201]], "test": "timeout"}
{"id": "wtVSzK", "name": "knit 2", "author": "FabriceNeyret2", "description": "the yarn spiral is totally wrong but it still looks good :-p\n\nmouse controls camera.", "tags": ["raymarching", "sdf", "knot", "short", "knitting"], "likes": 10, "viewed": 338, "published": "Public API", "date": "1583172060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/WlVXzK\n// variant of https://shadertoy.com/view/ttKSDm\n\nfloat PI = 3.14159,\n       r = .15,                                                   // wire radius\n      dr = .1,                                                    // yarn radius (but section totally wrong)\n       d = 1.32, e = 4.5, f = 3., s, t0=1e9;\n\n#define FRAME 0\n\n#define S(a,da)  ( abs(mod(atan(q.y,q.x)-a+PI, 2.*PI) -PI) - da ) // section\n#define Ts(q,a,da) max(T(q),S(a,da) )                             // torus section\n#define R(a)       mat2( cos( a + vec4(0,33,11,0)) )              // rotation\n#define CS(a)      vec2(cos(a),sin(a))\n#define T0(q)     ( length(vec2(length(q.xy)-1.,q.z)) - r-dr )      // torus\n#define Ts0(q,a,da) max(T0(q),S(a,da) )                             // torus section\n\nfloat T(vec3 q) { // global s for yarn orientation\n    vec3 c=q; float t, a;     \n        a = atan(c.y,c.x); \n    \n    q = vec3( length(c.xy) - 1., c.z,  a*5.9*s ), \n    a = atan(q.y,q.x); \n    q.xy -= r * CS(-floor(q.z-a)+q.z);\n    t = length(q.xy) - dr;\n    return t*=.5;\n}\n\nfloat knot0(vec3 p) {                           // --- half stitch\n    vec3 q; float t, a=p.y+f/4.;\n  //p.z += .4*(1.-.5*a*a),                      // depth twist\n    p.z += .4*cos(1.5*a),                       // depth twist\n    p.x = mod(p.x-d,2.*d)-d;                    // + rank periodicity\n    q = p, t = Ts(q,PI/2.,1.55*PI/2.);          // half stitch\n    t0 = min(t0,Ts0(q,PI/2.,1.55*PI/2.));        // blur coloring attempt\n    return t;\n}\nfloat knot(vec3 p) {                            // --- full rank of stitch\n    vec3 q=p; float t;\n    q.y = mod(q.y,e)-f,                         // + vertical periodicity\n    s = 1.; t = knot0(q);                                    // top half stitch\n    s= -1.; q.y = -1.5-q.y,  q.x -= d, t = min(t, knot0(q)); // bottom symmetric\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = 1e9, tx,ty,tz, E = 0.;\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),     // ray direction\n          P = 20./q, p, a, qa;                 // marching point along ray \n    vec2  M = (length(iMouse.xy)<20.) ? vec2(0): 3.14*(2.*iMouse.xy-q.xy)/q.y,\n        //C = 3.14*vec2(-.3,.4),               // camera\n          C = M==vec2(0) ? vec2(iTime) : M;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.04 )\n        p = P,\n        p.xz *= R(C.x), p.yz *= R(C.y),        // camera rotation\n        q = p,\n#if FRAME\n        a = abs(qa=q),                         // draw frame\n        t = max(min( ty= max(a.x,a.z) -.01, min( tx= max(a.z,a.y) -.01 ,tz= max(a.x,a.y) -.01 )  ),length(q)-2.),\n#endif\n        t = min(t, knot(p)),                   // odd rank\n        p.y -= e/2., \n        t = min(t, knot(p)),                   // even rank\n        E += .001/t,                           // blur coloring attempt\n        P += t*D;                              // step forward = dist to obj\n\n    O *= 1.5; \n // O.r += E;                                  // coloring attempts\n // O.r += exp(-10.*t0);\n // O = O*vec4(1,0,0,1) + exp(-20.*abs(t0));\n\n#if FRAME                                      // --- color frame\n    if (t==tx) O.gb*=.4+.4*sign(qa.x);         // x axis: red   ( whiter on positive side )\n    if (t==ty) O.rb*=.4+.4*sign(qa.y);         // y axis: green\n    if (t==tz) O.rg*=.4+.4*sign(qa.z);         // z axis: blue\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[810, 810, 827, 860, 1085], [1087, 1087, 1108, 1153, 1535], [1536, 1536, 1556, 1610, 1884]], "test": "ok"}
{"id": "wtVXDd", "name": "Ancient Temple-v3", "author": "jorge2017a1", "description": "// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n//https://www.shadertoy.com/view/WtVSWt-----Logos", "tags": ["ancienttemplev3"], "likes": 3, "viewed": 72, "published": "Public", "date": "1583931349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n//https://www.shadertoy.com/view/WtVSWt-----Logos\n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,.8,1); \n///--------------------------------\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\nfloat ot=0.;\nfloat det=0.;\nfloat hitfloor;\nfloat hitrock;\nfloat tt;\n\n///---------------------------------\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n\n\nfloat DE(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tot=1000.;\n    \n    \n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    \n    \n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    float fl=pos.y-3.013;\n    float d=min(fl,length(p)/DEfactor-.0005);\n\td=min(d,-pos.y+3.9);\n    d=min(d,rr);\n    if (abs(d-fl)<.0001) hitfloor=1.;\n    if (abs(d-rr)<.0001) hitrock=1.;\n    \n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.2 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .4;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    /*\n    float s1 = sin(time), c1 = cos(time);\n    float arg = 1.5*sin(time*.7894)*.5 + .5;\n    float s2 = sin(arg), c2 = cos(arg);\n    */\n    \n    ///----------------\n    vec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n    float y=(cos(iTime*.1+3.)+1.);\n    if (iMouse.z<1.) mouse=vec2(sin(t*2.),cos(t)+.3)*.15*(.5+y)*min(1.,iTime*.1);\n\tuv+=mouse*1.5;\n\tuv.y-=.1;\n    \n    \n    \n    vec3 from=vec3(0.0,3.04+y*.1,-2.+iTime*.05);\n\tvec3 dir=normalize(vec3(uv*.75,1.));\n    \n    vec3 ro =from;\n    \n    \n    \n    vec3 rd = dir;\n    \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col;\n    \n  \n     //--- output color depends on few things ---//\n    \n    \n    vec3   n = getNorm(p);\t\t\t// surface normal\n    float di = clamp(dot(n, normalize(ro)), -2.0, 1.0);\t\t// diffuse component\n    float re = pow(di, 100.0);\t\t\t\t\t\t\t\t// specular reflection\n    float od = length(p);\t\t\t\t\t\t\t// distance to origin\n    \n\tcol     = abs(rd.xyz);\n    col    *= 0.2 + 0.8*di;\n    col.yz *= clamp(od, 0.0, 1.0);\n    col    += re;\n    \n    \n    //col=col+pow(col,vec3(0.78902));\n     col=mix(vec3(length(col)),col,.85)*.95;\n    \n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 627, 654, 654, 685], [687, 687, 718, 718, 809], [812, 812, 835, 835, 972], [974, 974, 1004, 1004, 1141], [1146, 1146, 1166, 1166, 1735], [1738, 1738, 1767, 1767, 1955], [1957, 1957, 1998, 1998, 2174], [2176, 2176, 2217, 2217, 2369], [2371, 2371, 2392, 2392, 2522], [2524, 2524, 2551, 2551, 2798], [2800, 2800, 2857, 2857, 4132]], "test": "timeout"}
{"id": "WtVXRc", "name": "log tiling inf zoom ( 190 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2tweets", "gif", "short", "log", "golf"], "likes": 6, "viewed": 200, "published": "Public API", "date": "1583267801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- expended version at the end :-)\n\n// -2 by Coyote\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  t = exp2(fract(-.3*iTime)) +u-u,\n          R = iResolution.xy,\n          U = t - t* ( u - R*vec2(.25,0) ) / R.y,\n          l = exp2( floor( log2( min(U,U.yx) )) );\n    O += 1.- ( R*l/t*.6 *   ( .1 - min( U = abs( abs( U/l - 1.5 ) - .5),U.x) ) ).y;\n} /*\n\n\n\n\n\n\n// --- 192 chars\n\n#define mainImage(O,u)                                   \\\n    vec2  t = exp2(fract(-.3*iTime)) +u-u,               \\\n          R = iResolution.xy,                            \\\n          U = t - t* ( u - R*vec2(.25,0) ) / R.y,        \\\n          l = exp2( floor( log2( min(U,U.yx) )) );       \\\n    U = abs( abs( U/l - 1.5 ) - .5),                     \\\n/ * O += 1.- R.y/32.    *abs( .1 - min(U.x,U.y) )   * /  \\\n/ * O += 1.- R.y*l/t*.6 *abs( .1 - min(U.x,U.y) )   * /  \\\n    O += 1.- ( R*l/t*.6 *   ( .1 - min(U,U.x) ) ).y /*\n\n\n\n\n\n\n// --- 210 chars\n// ( NB: #define m min(U.x,U.y) = same size )\n\n#define mainImage(O,u)                                      \\\n    float t = exp2(fract(-.3*iTime)), l;                    \\\n    vec2  R = iResolution.xy,                               \\\n          U = t* ( 1.- ( u - vec2(R.x/4.,0) ) / R.y );      \\\n    U.x > 0. ?                                              \\\n        l = exp2( floor( log2( min(U.x,U.y) )) ),           \\\n        U = abs( abs( U/l - 1.5 ) - .5),                    \\\n    / * O += 1.- R.y/32.    *abs( .1 - min(U.x,U.y) )   * / \\\n    / * O += 1.- R.y*l/t*.6 *abs( .1 - min(U.x,U.y) )   * / \\\n        O += 1.- R.y*l/t*.6 *   ( .1 - min(U.x,U.y) )       \\\n    :O /*\n\n\n\n\n\n\n// --- 219 chars\n\n#define mainImage(O,u)                                      \\\n    vec2  R = iResolution.xy, L,                            \\\n          U = 1.- ( u - vec2(R.x/4.,0) ) / R.y;             \\\n    float t = exp2(fract(-.3*iTime)), l;                    \\\n    if ( U.x > 0. )                                         \\\n        L = floor( log2( U *= t ) ),                        \\\n        l = exp2(min(L.x,L.y)),                             \\\n        U = abs( 2.* abs( U/l - 1.5 ) - 1.),                \\\n    / * O += 1.- R.y/32.    *abs( .2 - min(U.x,U.y) )   * / \\\n    / * O += 1.- R.y*l/t/3. *abs( .2 - min(U.x,U.y) )   * / \\\n        O += 1.- R.y*l/t/3. *   ( .2 - min(U.x,U.y) )  /*\n\n\n\n\n\n\n// --- 236 chars\n\n#define mainImage(O,u)                                         \\\n    vec2 R = iResolution.xy, L,                                \\\n         U = 1.- ( u - vec2(R.x/4.,0) ) / R.y;                 \\\n    float t = fract(-.3*iTime), l;                             \\\n    if ( U.x > 0. )                                            \\\n        U = log2( U * exp2(t) ),                               \\\n        L = floor(U),                                          \\\n        l = min(L.x,L.y),                                      \\\n        U = abs( 2.*abs(exp2(U - l) - 1.5) - 1.),              \\\n    / * O += max(0., 1.- R.y/32.          *abs( min(U.x,U.y) -.2) )  * / \\\n    / * O += max(0., 1.- R.y/exp2(1.-l+t) *abs( min(U.x,U.y) -.2) )  * / \\\n        O += max(0., 1.- R.y/exp2(1.-l+t) *( .2 - min(U.x,U.y) ))   /*\n\n\n\n\n\n\n// --- 286 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, L,F,\n         U = 1.- (u-.25*vec2(R.x,0)) / R.y;\n    if ( U.x < 0. ) { O-=O; return; };\n\n    float t = fract(-.3*iTime), l;\n    U = log2(U*exp2(t));\n    L = floor(U);\n    l = min(L.x,L.y);\n    F = exp2(U - l) - 1.;\n    F = abs( 2.*abs(F-.5) - 1.);\n          \n // O = vec4( max(0., 1. -R.y/32.               *abs(min(F.x,F.y)-.2)) );\n    O = vec4( max(0., 1. -R.y/exp2(abs(l)+1.+t) *abs(min(F.x,F.y)-.2)) );  // framed\n // O = vec4( max(0., 1.- R.y/exp2(abs(l)+1.+t) *(.2- min(U.x,U.y))) );    // filled\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 93, 93, 353]], "test": "ok"}
{"id": "WtVXRt", "name": "MetaCircles", "author": "loni852", "description": "asd", "tags": ["circles"], "likes": 2, "viewed": 109, "published": "Public", "date": "1583411714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float Count = 6.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy+3.0*fragCoord.xy)/iResolution.y;\n\n    vec2 metaBalls[int(Count)];\n    \n     float MBRadius = 0.04+((sin(iTime)/2.0)+0.5)*0.05;\n    \n    vec2 MB = vec2(0.8,0.6);\n    \n    \n    //Circles ==\n    //float MBtoUV =   MBRadius/( sqrt ( ( uv.x - MB.x ) * ( uv.x - MB.x ) + ( uv.y - MB.y ) * ( uv.y - MB.y ) ) );\n    \n    \n    //Squares ==\n    //float MBtoUV =   MBRadius/(abs(uv.x - MB.x) + abs( uv.y - MB.y));\n    \n    \n    //Implement Donuts M(x,y) = Radius_1 / |Radius_2 - sqrt( (x-x0)^2 + (y-y0)^2 )|\n    float MBtoUV = MBRadius / abs(MBRadius+0.5 - ( sqrt ( ( uv.x - MB.x ) * ( uv.x - MB.x ) + ( uv.y - MB.y ) * ( uv.y - MB.y ) ) ));\n    \n    \n    \n    float finalcolor =  MBtoUV;\n    \n    for(float i = .0; i < Count; i++){\n    \tvec2 MB2 = vec2(0.8+sin(iTime+i),0.6+cos(iTime+i));\n        \n        \n        //Circles ==\n        float MBtoUV2 = MBRadius/( sqrt ( ( uv.x - MB2.x ) * ( uv.x - MB2.x ) + ( uv.y - MB2.y ) * ( uv.y - MB2.y ) ) );\n        \n        //Squares ==\n        //float MBtoUV2 =   MBRadius/(abs(uv.x - MB2.x+sin(iTime)) + abs( uv.y - MB2.y));\n        \n        //Donut\n        //float MBtoUV2 = MBRadius / abs(MBRadius+0.5 - ( sqrt ( ( uv.x - MB2.x ) * ( uv.x - MB2.x ) + ( uv.y - MB2.y ) * ( uv.y - MB2.y ) ) ));\n        \n        finalcolor +=  MBtoUV2;\n    \n    }\n    \n    if (finalcolor >= 0.0 && finalcolor <= 10.5){\n    \tfinalcolor *= 0.5;\n    }\n    else {\n    \tfinalcolor *= 0.0;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //vec3 col = mix(vec3(0.0,0.0,0.0),vec3(finalcolor,finalcolor,0.0),smoothstep(0.7,0.99,finalcolor));\n\tvec3 col = vec3(finalcolor,finalcolor,0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 133, 1823]], "test": "ok"}
{"id": "WtVXzd", "name": "Shark shader", "author": "z0rg", "description": "Simple landscape series", "tags": ["landscape", "shark"], "likes": 7, "viewed": 185, "published": "Public API", "date": "1583404479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\n\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nvec4 shark(vec2 uv)\n{\n  float sharp = 80.;\n  uv.x += .02*sin(10.*uv.y+iTime*2.);\n\n  float yUp = 0.;\n  float upOffX = .03;\n  float bodyUp = float(uv.x >0.)*(1.-sat(_cir(vec2(2.,1.)*uv+vec2(upOffX,yUp),.2)*sharp))\n  \t+ float(uv.x <0.)*(1.-sat(_cir(vec2(2.,1.)*uv+vec2(-upOffX,yUp),.2)*sharp));\n  float downy = .07;\n  float dOffX = 0.05;\n  float bodyDown = float(uv.x >0.)*(1.-sat(_cir(vec2(2.5,.7)*uv+vec2(dOffX,yUp+downy),.2)*sharp))\n  +   float(uv.x <0.)*(1.-sat(_cir(vec2(2.5,.7)*uv+vec2(-dOffX,yUp+downy),.2)*sharp));\n  float yArm = -.15;\n  float armX = .0;\n  float leftArm = (1.-sat(_sub(_cir(uv-vec2(armX,yArm),.2),_cir(uv-vec2(armX,yArm)+vec2(.0,.2),.3))*sharp));\n  float yPalm = -.42;\n  float palm = (1.-sat(_sub(_cir(.7*vec2(4.,1.)*uv-vec2(armX,yPalm),.15),_cir(.7*vec2(4.,1.)*uv-vec2(armX+sin(-PI+iTime)*.02,yPalm+.02*sin(iTime))+vec2(.0,.2),.3))*sharp));\n  float y2 = -.3;\n  float palm2 = (1.-sat(_sub(_cir(2.*uv-vec2(armX,y2),.2),_cir(2.*uv-vec2(armX,y2)+vec2(.0,.2),.3))*sharp));\n  float y3 = -1.1;\n\n  float palm3 = (1.-sat(_sub(_cir(3.*uv-vec2(armX,y3),.2),_cir(3.*uv-vec2(armX,y3)+vec2(.0,.2),.3))*sharp));\n\n  return vec4(0.,0.1,0.1,sat(palm3+palm2+bodyUp+bodyDown+leftArm+palm));\n}\n\nvec3 rdrLand(vec2 uv, float drawShark)\n{\n  vec3 back;\n  vec3 dark = vec3(4.,32.,24.)/255.;\n  vec3 light = vec3(123.,165.,103.)/255.;\n  vec3 grad = dark+mix(light.yzx,dark,length(uv));\n  vec2 sunP = (uv-vec2(.1))+.09*vec2(sin(55.*uv.y+iTime),sin(35.*uv.x+iTime*2.));\n  vec3 sun = (1.-sat(_cir(sunP,.1)*50.))*light;\n  vec3 sunHalo = pow((1.-sat(_cir(sunP,.1)*5.)),2.)*light.zyx;\n  sun += sunHalo;\n  float shark = shark(uv+vec2(0.,mod(-iTime*.1,2.)-1.)).w;\n  back = back+grad+sun;\n  return mix(back,grad*.7,shark*drawShark)*sat(1.-lenny(uv)+.3);\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  float maskLand = 1.-sat(_cir(uv,.5)*50.);\n\n  vec3 land = rdrLand(uv,1.);\n  vec2 sp = uv-vec2(.1);\n  float auv = iTime*.05+atan(-abs(sp.y),sp.x)/PI*2.;\n  float freq = 55.;\n  vec3 land2 = rdrLand(uv+vec2(sin(auv*freq),cos(auv*freq))*.02,.2)*.5;\n  return mix(rdrLand(uv*.7,0.)*.5,land,maskLand)+(land2*.5)*length(uv*3.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv *= 2.;\n  vec3 col = rdrScn(uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXzd.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[426, 426, 444, 444, 505], [507, 507, 528, 528, 558], [559, 559, 579, 579, 606], [607, 607, 625, 625, 671], [673, 673, 704, 704, 730], [732, 732, 762, 762, 784], [786, 786, 807, 807, 1981], [1983, 1983, 2023, 2023, 2527], [2529, 2529, 2551, 2551, 2873], [2875, 2875, 2932, 2932, 3092]], "test": "timeout"}
{"id": "WtySRc", "name": "Hexagon - gradient  2D ", "author": "iq", "description": "Signed distance and gradient to a (rounded) hexagon. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "hexagon", "distance"], "likes": 13, "viewed": 621, "published": "Public API", "date": "1583214183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a hexagon. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgHexagon( in vec2 p, in float r ) \n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    vec2 s = sign(p);\n    p = abs(p);\n\tfloat w = dot(k.xy,p);    \n    p -= 2.0*min(w,0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    float d = length(p)*sign(p.y);\n    vec2  g = (w<0.0) ? mat2(-k.y,-k.x,-k.x,k.y)*p : p;\n    return vec3( d, s*g/d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // size\n\tfloat si = 0.3 + 0.2*cos( iTime );\n    // corner radious\n    float ra = 0.3*(0.5+0.5*sin(iTime*2.0));\n\n    // sdf(p) and gradient(sdf(p))\n\tvec3 dg = sdgHexagon(p,si);\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n    \n\t// coloring\n     vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySRc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1402, 1497, 1540, 1540, 1858], [1860, 1860, 1917, 1917, 2627]], "test": "ok"}
{"id": "WtyXDt", "name": "[twitch] Lava Temple", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/LavaTemple.glsl", "tags": ["raymarching", "cartoon", "cellshading"], "likes": 17, "viewed": 274, "published": "Public", "date": "1583794130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/LavaTemple.glsl\n*/\n\nfloat time = 0.0;\nfloat pi=0.0;\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\n\nfloat torus(vec3 p, float r, float s) {\n  \n  return length(vec2(length(p.xz)-r,p.y))-s;\n}\n\nfloat cyl(vec3 p, float r, float s) {\n  \n  return max(length(p.xz)-r,abs(p.y)-s);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n#define rep(p,s) ((fract((p)/(s)-0.5)-0.5)*(s))\n\nfloat stair(vec3 p, float size, float w) {\n  \n  p.x=rep(p.x,size*2.0);\n  p.xy *= rot(pi*0.25);\n  \n  \n  float d=box(p, vec3(size,size,w));\n  \n  return d;\n}\n\n// repeat r times around y axis\nvec2 rota(vec2 p, float r) {\n  float a=atan(p.y,p.x)/(2.0*pi);\n  a=rep(a,1.0/r)*2.0*pi;\n  return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat temple(vec3 p) {\n  \n  p.y=-abs(p.y-20.0)+20.0;\n    \n  p.xz = rota(p.xz, 10.0);\n  p.x -= 6.0;\n  \n  p.x = abs(p.x-15.0)-15.0;\n\n  p.xz = abs(p.xz);\n  if(p.x>p.z) p.xz=p.zx;\n  \n  p.y=-p.y;\n  \n  vec3 p2=p;\n  p2.y=abs(p2.y)-1.0;\n  float d=box(p2, vec3(1,0.1,2));\n  d=min(d, box(p-vec3(1.0,0,2), vec3(0.1,2.,0.1)));\n  d=min(d,box(p2-vec3(0,1,0), vec3(1.3,0.1,3)));\n  d=min(d,box(p2-vec3(0,1.2,0), vec3(0.8,0.1,2.5)));\n  \n  vec3 p3=p;\n  p3.zy *= rot(-pi*0.25);\n  float d2=stair(p3.zyx-vec3(0,0.7,0.5), 0.1, 0.3);\n  d2=min(d2,stair(p3.zyx-vec3(0,0.3,0.5), 0.3, 0.9));\n  d2=max(d2, p.y+0.9);\n  d=min(d, d2);\n  \n  return d;\n}\n\nfloat ground(vec3 p) {\n  \n  float d=10000.0;\n  p.y-=8.0;\n  for(float i=0.0; i<5.0; ++i) {\n    //p.xz = rota(p.xz, 20);\n    p.xz *= rot(0.3);\n    p.xz = abs(p.xz);\n    p.xz-=5.0;\n    p.y+=0.1;\n    float ouv = sin(p.z*0.8+ i)*0.5;\n    d=min(d, box(p, vec3(2.0+ouv,3,5)));\n    p.xy *= rot(0.03);\n  }\n  \n  return d;\n}\n\n// glow for white lasers\nfloat at=0.0;\n// glow for yellow lava\nfloat at2=0.0;\nfloat map(vec3 p) {\n  \n  float d=temple(p);\n  \n  d=min(d, ground(p));\n  \n  // Lava\n  float d3 = cyl(p-vec3(0,10,0), 30.0,2.0);\n  at2 += 0.5/(0.5+abs(d3));\n  d=min(d,d3);\n\n  // lasers\n  float d2 = abs(length(p.xz)-3.0);\n  \n  p.xz = rota(p.xz, 10.0);\n  p.x -= 36.0;\n  \n  d2 = min(d2, max(p.y,abs(length(p.xz)-0.2)));\n  \n  at += 0.01/(0.1+d2*d2);\n  //at += exp(-d2*2.0)*0.1;\n  \n  // we use max here so that the ray can never get close enough to the surface\n  // so the ray go through the laser and continue\n  d = min(d, max(d2,0.2));\n  \n  return d;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nvoid cam(inout vec3 p) {\n    float t=time*0.3;\n  p.yz *= rot(sin(t*1.3)*0.2+0.5);\n  p.xz *= rot(t);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*427.542+uv.yx*741.521),vec2(274.511)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n    pi=acos(-1.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float dist = 50.0 + sin(time*0.2)*20.0 + sin(time*0.07)*10.0;\n  vec3 s=vec3(0,0,-dist);\n  cam(s);\n  \n  vec3 t=vec3(0,-10,0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(sin(time*0.3)*0.1,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  \n  float fov=1.0;\n  vec3 r=normalize(uv.x*cx+uv.y*cy+fov*cz);\n  \n  s.y+=10.0;\n  \n  float edgescreensize=0.0015;\n  float edgesize = 0.05;\n  \n  vec3 p=s;\n  float edge=0.0;\n  bool nearsurface=false;\n  float dd=0.0;\n  \n  float dither = mix(1.0,0.9,rnd(uv));\n\n  for(int i=0; i<100; ++i) {\n    float d=map(p)*dither;\n    // This can be used to adjust the edge size according to distance\n    //edgesize = edgescreensize*dd;\n    \n    // if close enough to the surface\n    if(d<edgesize) {\n      nearsurface=true;\n    }\n    // if we were close enough to the surface but we now are far again, we just missed a surface so this is an edge\n    if(nearsurface && d>edgesize) {\n      edge = 1.0;\n    }\n    if(d<0.001) {\n      break;\n    }\n    if(d>200.0) break;\n      \n    p+=r*d;\n    dd+=d;\n  }\n  \n  float fog = 1.0-clamp(dd/200.0,0.0,1.0);\n  \n  \n  vec3 col=vec3(0);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(-vec3(1,3,2));\n  \n  col+=max(0.0,dot(n,l))*vec3(0.2,0.4,1.0)*2.0;\n  col *= fog;\n  \n  vec3 background = mix(vec3(0.6,0.3,0.8),vec3(0.6,0.6,0.0),smoothstep(0.1,0.8,r.y));\n  background = mix(background,vec3(0.0,0.6,0.9),smoothstep(0.1,-0.9,r.y));\n  \n  // background lines, infinitely far away using ray direction\n  vec3 r2 = r;\n  for(float i=0.0; i<5.0; ++i) {\n    float t=time*0.0+i+74.521;\n    r2.xz *= rot(t);\n    r2.xy *= rot(t*1.3);\n    r2 = abs(r2)-0.2;\n  }\n  vec3 grid = smoothstep(0.49,0.5,abs(fract(r2.xyz*5.0)-0.5));\n  background -= max(grid.x,max(grid.y,grid.z))*0.2;\n  \n  col += background*step(fog,0.01);\n  \n  // We use AO to put an edge on the crease of the surface\n  float ao = getao(p,n, edgesize);\n  if(ao<0.9) edge=max(edge,step(0.01,fog));\n  \n  // We use AO from inside the surface to put an edge on the outer edges of the surface\n  float ao2 = getao(p,n, -edgesize);\n  if(ao2<0.9) edge=max(edge,step(0.01,fog));\n  \n  // a little ao shadow below the temple\n  float ao3 = getao(p,n, 5.0)*0.5+0.5;\n  col *= ao3;\n  \n  col += at*0.4;\n  col += at2*vec3(1,0.5,0.2)*0.1;\n  \n  col *= 1.0-edge;\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 247, 247, 296], [299, 299, 338, 338, 388], [390, 390, 427, 427, 473], [475, 475, 494, 494, 563], [614, 614, 656, 656, 768], [770, 802, 830, 830, 931], [933, 933, 955, 955, 1553], [1555, 1555, 1577, 1577, 1868], [1948, 1948, 1967, 1967, 2495], [2497, 2497, 2538, 2538, 2584], [2586, 2586, 2610, 2610, 2687], [2689, 2689, 2709, 2709, 2777], [2779, 2779, 2836, 2836, 5382]], "test": "timeout"}
{"id": "wtyXWG", "name": "mandala1 flash sat [spaz]", "author": "HaleyHalcyon", "description": "you are Anna's Doll", "tags": ["spiral"], "likes": 3, "viewed": 214, "published": "Public", "date": "1583459922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// adjusts the saturation\nvec3 sat(vec3 rgb)\n{\n    // Algorithm from Chapter 16 of \"OpenGL Shading Language\"\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, 1.5); // adjust strength here\n}\n\n// varying speed\nfloat funkySpeed(float x)\n{\n    x = mod(x + 1.0, 2.0) - 1.0;\n    float n = x * x * x; // implement the speed change using x cubed\n\treturn (8. * n - 4. * x) * 3.14159265;\n}\n\n// gets brightness from some factor of dist and angle\nfloat fn(float x)\n{\n    float n = abs(sin(x));\n    return max((n - 0.5) * 1.5, 0.);\n}\n\n// makes edges darker than the center\nfloat vignette(float v, float d)\n{\n    return v * (0.8 - 0.35 * d);\n}\n\n// this is where most of the magic happens\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // some constants that we'll use thru-out the spiral\n    const float PI = 3.14159265; // of course, we need π for trig\n    const float PI_3 = PI / 3.; // pre-compute π/3 for hue rotation\n    const float speed = 0.4; // speed of spiral movement\n    float hue = fract(iTime * 1.2) * PI; // offset of hue [0, π)\n    \n    // Normalized pixel coordinates [-1, 1]\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    // calculate \"distance\" to prepare for a log spiral\n    float distance = log(uv.x*uv.x+uv.y*uv.y);\n    // calculate angle [0, 2π)\n    float angle = atan(uv.y, uv.x);\n    \n    // Time varying pixel color\n    // spiral 1\n    float c1 = vignette(fn(distance * 1.5 + angle * 3.0 + funkySpeed(iTime * speed) + PI), distance);\n    // spiral 2\n    float c2 = vignette(fn(distance * 1.5 - angle * 3.0 + funkySpeed((iTime * speed) + 2. / 3.) + PI), distance);\n    // rings \n    float c3 = vignette(fn(angle * 16.0 + sin(iTime) * 8.0 - iTime * 0.5) * 0.5\n             + fn(distance * 4.0 + funkySpeed((iTime * speed) + 4. / 3.) * 0.5), distance);\n    \n    // Flashing\n    const float flashIntvl = 0.2;\n    const float flashStrength = 1.5;\n    const float flashSudden = flashStrength / flashIntvl * 6.0;\n    float f1 = max(0., flashStrength - mod(iTime, flashIntvl) * flashSudden);\n    float f2 = max(0., flashStrength - mod(iTime + flashIntvl * 1.0/3.0, flashIntvl) * flashSudden);\n    float f3 = max(0., flashStrength - mod(iTime + flashIntvl * 2.0/3.0, flashIntvl) * flashSudden);\n\tc1 += f1; c2 += f2; c3 += f3;\n\n    // Saturation\n    vec3 fragColorRGB = sat(\n        // this part rotates the hue away from each other by 2π/3 radians\n        vec3(\n        \tabs(c1 * sin(hue))        + abs(c2 * -sin(hue + PI_3)) + abs(c3 * -sin(hue - PI_3)),\n        \tabs(c1 * sin(hue + PI_3)) + abs(c2 * -sin(hue - PI_3)) + abs(c3 * -sin(hue)       ),\n        \tabs(c1 * sin(hue - PI_3)) + abs(c2 * -sin(hue))        + abs(c3 * -sin(hue + PI_3))\n        )\n    );\n    \n    // Output to screen\n    fragColor = vec4(fragColorRGB, 1); // just add alpha and we're done\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 46, 108, 260], [262, 279, 306, 306, 450], [452, 506, 525, 525, 591], [593, 631, 665, 665, 700], [702, 745, 802, 859, 2984]], "test": "timeout"}
{"id": "WtyXWt", "name": "cuarto-v10", "author": "jorge2017a1", "description": "cuarto-v10", "tags": ["cuartov10"], "likes": 2, "viewed": 43, "published": "Public", "date": "1583787901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1---9-mar-2020\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n//------------------------------------------\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.5 );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\nfloat thunderbolt(vec2 x)\n{\n    vec2 r = vec2(8.,1.);\n    float d=1000.;\n    if((x).y<abs((x-r).x))return d;    \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= noise2(r+iTime)+vec2(0.,.7);\n        d=min(d,dseg(s,x-r));\n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return d;\n   \n}\n\n//0000000000000000000000000000000000000000000000000000000\n\n//------------------------------------------\n\n\n\n//scene distance functions\nfloat walls(vec3 p) {\n    vec3 ap = abs(p);\n    return 20.0-max(ap.x,max(ap.y,ap.z));\n}\n\nfloat wallx(vec3 p)\n {\n    vec3 ap = abs(p);\n    return 15.0-max(ap.x,0.0);\n}\n\nfloat wally(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 14.0-max(ap.y,0.0);\n}\n\nfloat wallz(vec3 p)\n{\n    vec3 ap = abs(p);\n    return 30.0-max(ap.z,0.0);\n}\n///----------------------------------------------------------\n\nfloat mag(vec3 i)\n{\n    return sqrt(i.x*i.x + i.y*i.y + i.z);\n}\n\nvec3 triangleBaryCentre( vec2 fragCoord )\n{\n    vec4 fragColor;\n    vec2 Restmp;\n \n    Restmp=vec2(5.0,5.0) ;\n        \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/Restmp.xy;\n\tuv -= 0.5;\n    uv.x *= Restmp.x/Restmp.y;\n    \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    float zoom = 2.;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., -1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    \n    //triangle\n    vec3 A = vec3(-0.5, -0.2, 0.0);\n    vec3 B = vec3( 0.5, -0.2, 0.0);\n    vec3 C = vec3(-0.0,  0.4, 0.0);\n   // vec3 D = vec3( 0.5,  0.5, 0.0);\n    \n    vec3 pos=vec3(0.3,0,0);\n    A =A*2.0+pos;\n    B =B*2.0+pos;\n    C =C*2.0+pos;\n    \n    \n    vec3 n = cross((B-A), (C-A))/mag(cross((B-A), (C-A))); // normal\n    \n    float t = (dot(n, ro) + dot(n, A)) / dot(n, rd);\n    vec3 Q = ro + rd*t; // hit point\n    \n    float ar_ABC = dot(cross((B-A), (C-A)), n);\n \n    \n    //barycentric coordinates    \n    float ar_QBC = dot(cross((B-A), (Q-A)), n)/ar_ABC;\n\tfloat ar_AQC = dot(cross((C-B), (Q-B)), n)/ar_ABC;\n\tfloat ar_ABQ = dot(cross((A-C), (Q-C)), n)/ar_ABC;\n\n\n \n    fragColor = vec4(0.0);\n    if (dot(cross((B-A), (Q-A)), n) >= 0.)\n    {\n        if (dot(cross((C-B), (Q-B)), n) >= 0.)\n        {\n            if (dot(cross((A-C), (Q-C)), n) >= 0.)\n            {\n                fragColor = vec4(ar_QBC, ar_AQC, ar_ABQ, 1.0);\n \n                \n            }\n        }\n    }\n            \n    return fragColor.xyz;    \n}\n\n\n//----------------------------------------------\nfloat GetDist(vec3 p  ) {\t\n\n \n    \n    \n    \n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n  \n    \n   float sdwx= wallx(p);\n   float sdwy= wally(p); \n   float sdwz= wallz(p);\n   \n    \n   res=opU(res, vec2(sdwx,8));\n   res=opU(res, vec2(sdwy,13));\n   res=opU(res, vec2(sdwz,22));\n    \n\n   float sdc1=  sdCylinder(p-vec3(12,-5.0,-28.), vec2(2.1,20.0) );\n   float sdc2=  sdCylinder(p-vec3(-12,-5.0,-28.), vec2(2.1,20.0) );\n   res=opU(res, vec2(sdc1,21));\n   res=opU(res, vec2(sdc2,24));\n\n  \n    \n\tfloat sdb1= sdBox(p- vec3(1.,-10.0,-10.), vec3(3.0,3.0,3.0) );\n    //float sds1= sdSphere( p-vec3(0.0,-15.0,-2.0), 1.5 );\n    res=opU(res, vec2(sdb1,6));\n   // res=opU(res, vec2(sds1,24));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n        return vec3(0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        \n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        \n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n     \n    \n    if(i== 20 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n    \t\t\n         vec3 surfaceColor;\n        \tsurfaceColor = mix(vec3(0.1,0.8,0.5),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    if(i== 22 )\n    {\n       return triangleBaryCentre(glpRoRd.xy);\t\n\t} \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*1.11;\n            marbleP.z += sin(p.y*162.0)*1.13;\n            marbleP.y += sin(p.x*145.0)*2.12;\n            marbleP.y += sin(p.z*153.0)*2.15;\n\n            marbleP.x *= 30.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/4.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*2.12;\n            marbleP.z += sin(p.y*23.0)*2.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.11;\n            marbleP.z += sin(p.y*162.0)*0.13;\n            marbleP.y += sin(p.x*145.0)*0.12;\n            marbleP.y += sin(p.z*153.0)*0.15;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/2.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.8);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.1,0.3,0.7),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n\n    \n    if(i== 25 )\n    {\n        \n    \tfloat c = thunderbolt(mObj.uv+.02);\n    \tc=exp(-5.*c);\n    \tvec3 col;\n    \tcol=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\n        return col;\n\t}        \n    \t\n}\n\n///--------------------------------------------\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n //float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\n\n//-------------------------------------------\nvec3 Render(vec3 ro, vec3 rd, vec3 ppcol, vec3 pLig){\n    \n  float dist = 0.0;\n  \n  float EPS=.001;\n  float MAX=100.;\n  \nconst vec2 P2 = vec2(0.450, 0.048);\nconst vec2 A2 = vec2(0.045, 0.068);\nconst vec3 Scale3 = vec3(1.0, 20.0, 10.0);\n\t//vec3 surfaceColor3 = vec3(0.45,0.54,1.0);  \n    vec3 surfaceColor3 = ppcol;  \n    vec3 light =pLig;\n    \n  for(int  i = 0; i < 3; i++)\n  {\n    //float nearest = RayMarch(p + dir*dist);\n    float nearest = RayMarch(ro, rd);  \n    \n    if(nearest>=MAX) return  vec3(0.0);  \n      \n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = ro+rd*dist;\n      \n    \n        \n        vec3 N = GetNormal(hit);\n        vec3 L = normalize(light-hit);\n        vec3 V = normalize(ro-hit);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T = normalize(vec3(-N.y, N.x, 0));\n        vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,P2,A2,Scale3,surfaceColor3);\n        \n        return pixelColor;\n    } \n    dist += nearest;\n    //ro=ro+rd*EPS;\n      \n  }\n  return vec3(0.0);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *0.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(0.,3,-10.);\n    \n    \n    vec3 ro = vec3(-2.0+10.*cos(iTime) ,6.5,10.0+ 7.0*sin(iTime));\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro); \n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t  vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    \n    \n    //float dif = GetLightv2(p);\n    float dif = GetLightPar(p,rLuz);\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n \n    float intensity = 1.0;\n     vec3 V = normalize(p - ro);\n     vec3 L = rd;\n     vec3 normal = nor;\n     vec3 refl = 2.*dot(normal,-rd)*normal + rd;\n     vec3 result = LightShading(normal,L,V, colobj)*intensity;\n    \n    \t\n    \n    vec3 pixelColour = Render(ro, rd,colobj, rLuz);\n    \n    ////////////col = (dif)*colobj; col = pow(col, vec3(1.0/2.2));  \n    //col= pixelColour*dif+result;\n    col= pixelColour+result*dif*1.1;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[457, 474, 507, 507, 572], [573, 591, 627, 627, 696], [697, 712, 743, 743, 893], [894, 914, 950, 950, 1037], [1038, 1054, 1086, 1114, 1175], [1177, 1177, 1213, 1213, 1316], [1319, 1393, 1451, 1451, 1715], [1717, 1717, 1762, 1762, 1853], [1855, 1855, 1937, 1937, 2168], [2171, 2171, 2202, 2202, 2390], [2393, 2447, 2469, 2469, 3729], [3732, 3796, 3832, 3832, 4105], [4157, 4157, 4203, 4203, 4235], [4237, 4237, 4280, 4280, 4312], [4314, 4314, 4362, 4362, 4395], [4398, 4398, 4427, 4427, 4553], [4555, 4555, 4591, 4591, 4708], [4710, 4710, 4746, 4746, 4864], [4867, 4867, 4903, 4903, 5026], [5079, 5091, 5113, 5113, 5421], [5422, 5448, 5473, 5473, 5663], [5664, 5709, 5726, 5726, 5799], [5802, 5835, 5861, 5861, 6058], [6105, 6105, 6157, 6157, 6312], [6377, 6486, 6523, 6523, 6558], [6560, 6560, 6579, 6579, 6654], [6703, 6703, 6726, 6726, 6752], [6754, 6754, 6777, 6777, 6915], [6918, 6918, 6940, 6940, 7010], [7075, 7075, 7101, 7101, 7158], [7160, 7160, 7180, 7180, 7238], [7241, 7241, 7262, 7262, 7512], [7515, 7515, 7547, 7547, 7632], [7634, 7634, 7670, 7670, 7859], [7860, 7860, 7887, 7887, 8302], [8411, 8438, 8459, 8459, 8525], [8527, 8527, 8549, 8549, 8604], [8606, 8606, 8627, 8627, 8682], [8684, 8684, 8705, 8705, 8760], [8824, 8824, 8843, 8843, 8887], [8889, 8889, 8932, 8932, 10482], [10485, 10534, 10559, 10559, 11446], [11449, 11449, 11483, 11483, 11852], [11857, 11857, 11881, 11881, 12113], [12117, 12117, 12141, 12141, 12533], [12536, 12536, 12562, 12562, 12926], [12929, 12929, 12967, 12967, 13324], [13327, 13327, 13352, 13352, 13380], [13382, 13382, 13434, 13434, 13830], [13933, 13977, 13994, 13994, 14065], [14090, 14182, 14207, 14207, 14470], [14529, 14529, 14557, 14557, 21501], [21503, 21551, 21652, 21686, 22196], [22202, 22248, 22301, 22301, 23490], [23493, 23542, 23599, 23599, 25201]], "test": "error"}
{"id": "WtyXWV", "name": "Mondrain variation 8", "author": "Leeondamiky", "description": "A shader based on Piet Mondrian - Tableau (1921).", "tags": ["modernart"], "likes": 3, "viewed": 58, "published": "Public", "date": "1583566585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 drawline(float x, float stx) {\n    return vec3(step(x,stx) * step(0.0, x+0.02 - stx));\n}\n\nvec3 drawrect(float vert1, float vert2, float horiz1, float horiz2, float sty, float stx) {\n    return drawline(vert1, sty) + drawline(vert2, sty) + drawline(horiz1, stx) + drawline(horiz2, stx);\n}\n\nvec3 drawfilledgerect(float x, float stx, float y, float sty, vec3 color) {\n    return vec3(step(x, stx)) * vec3(step(y, 1.0 - sty)) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.875,0.834,0.808);\n\n    color -= drawrect(0.1, abs(clamp(0.5, 0.9, sin(iTime*2.0))), 0.1, sin(iTime*2.0), st.x, st.y);\n\tcolor += drawline(0.4, st.x);\n    color -= drawline(0.5, sin(st.x*iTime));\n\tcolor += drawline(0.14, sin(st.y*iTime));\n    color -= drawline(0.8, sin(st.y*iTime));\n\tcolor -= drawfilledgerect(0.8, st.x, 0.1, st.y, vec3(abs(cos(iTime)),1.000,abs(sin(iTime))));\n    color -= drawfilledgerect(0.9, 1.0 - st.x, sin(iTime), st.y, vec3(abs(sin(iTime)), 1.0, 0.0));\n    color -= drawfilledgerect(0.5, 1.0 - st.x, 0.8, 1.0 - st.y, vec3(0.140,0.219,1.000));\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 93], [95, 95, 186, 186, 292], [294, 294, 369, 369, 437], [439, 439, 496, 496, 1173]], "test": "ok"}
