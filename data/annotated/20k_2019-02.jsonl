{"id": "3d23Dc", "name": "solving cubic polynomial", "author": "FabriceNeyret2", "description": "Sometime useful :-)\n- get 3 solutions (when 3)\n- or the smallest\n- k = index of the smallest ( or -1 when only 1 solution).", "tags": ["cubic", "polynomial", "tuto", "solve", "degree3"], "likes": 1, "viewed": 502, "published": "Public API", "date": "1550170267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === solving Pol3=0 by Cardano formula https://en.wikipedia.org/wiki/Cubic_function\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    \n    // --- Solving a*x³ +b*x³ +c*x +d = 0. -> l = min(3 solutions)\n    float a = 1., b = -4., c = 3., d = -(.1+sin(iTime)),\n          Q, A, D, v, l, k = -1.;\n\n    if (abs(a)<1e-3) {                          // degenerated P3\n        k = -2.;\n        v = c*c - 4.*b*d;\n        l = ( -c -sign(b)* sqrt(v) ) / (2.*b);\n    }\n    else {                                      // true P3       \n      b /= a; c /= a; d /= a;\n      float p = ( 3.*c - b*b ) / 3.,\n            q = ( 9.*b*c - 27.*d - 2.*b*b*b) / 27., // -\n            r = q/2.; Q = p/3.;\n            D = Q*Q*Q + r*r;\n    \n      if ( D < 0.) {                            // --- if 3 sol\n        A = acos(r/sqrt(-Q*Q*Q)), \n        k = round(1.5-A/6.283); // k = 0,1,2 ; we want min l\n#define sol(k) ( 2.*sqrt(-Q)* cos((A+(k)*6.283)/3.) - b/3. )\n        l = sol(k);\n      }\n      else                                        // --- if 1 sol\n        if (p>0.) v = -2.*sqrt(p/3.), \n#define asinh(z) ( sign(z)*asinh(abs(z)) )      // fix asinh() symetry error \n                  l = -v* sinh(asinh(3.*-q/p/v)/3.) -b/3.; \n        else      v = -2.*sqrt(-p/3.), \n                  l = sign(-q)*v* cosh(acosh(3.*abs(q)/p/v)/3.) -b/3.;\n      }\n    \n    // --- display\n    float x = 3.*U.x, y = 3.*U.y;\n    O = vec4( y < a*x*x*x+b*x*x+c*x+d );        // draw curve\n    \n    if (u.y-.5==R.y/2.) O = vec4(1,0,0,0);      // draw zero-line\n    if (abs(x-l)<3.*3./R.x) O = vec4(0,1,0,0);  // draw min solution\n    if (k>=0.) {\n      if ( abs(x-sol(k+1.)) < 3.*3./R.x ) O = vec4(0,0,1,0); // the 2 other solutions\n      if ( abs(x-sol(k+2.)) < 3.*3./R.x ) O = vec4(0,0,1,0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 125, 125, 1814]]}
{"id": "3d23Wt", "name": "Raymarch IFS test", "author": "darkeclipz", "description": "Raymarch IFS test", "tags": ["raymarchifs"], "likes": 3, "viewed": 105, "published": "Public", "date": "1550275631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 128.\n#define MinDistance 0.001\n#define eps 0.001\n#define Iterations 24.\n#define speed iTime\n#define M ((2.*iMouse.xy-R)/R.y*4.)\n\n#define red vec3(227./255., 10./255., 4./255.)\n#define yellow vec3(250./255., 100./255., 1./255.)\n#define salmon vec3(1., 227./255., 161./255.)\n#define blue vec3(163./255.,228./255.,1.)\nmat2 r2(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// from IQ\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\n// from IQ\nfloat sdCircle(vec2 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from IQ\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec2 T(vec2 p) {\n\n    vec4 w = texture( iChannel0, vec2(15./256.,0.1));\n    vec4 w2 = texture( iChannel0, vec2(150./256.,0.1));\n    float s = 0.0006 + 0.0005 * cos(iTime/2.);\n    for(float i=0.; i < Iterations; i++) {\n    \tp = abs(p) - s - i/Iterations; \n        p *= r2(3.1415*fract(iTime / 20.) + w.x/4.);\n        p *= (i/Iterations*.4 + 1.);\n    }\n    \n    return p;\n}\n\nfloat kaleidoscope(vec2 p) {\n\tfloat d = sdCircle(T(p), 0.5);\n    return d;\n}\n\nfloat DE(vec3 z)\n{\n    mat3 ry = rotateY(iTime);\n    mat3 rz = rotateZ(iTime / 2.);\n    mat3 rot = ry * rz;\n    \n    //z *= rot;\n    \n    float Scale = 2.;\n    float Offset = .3;\n    float r;\n    float n = 0.;\n    while (n < Iterations) {\n       //if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       //if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       //if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n        \n       z = abs(z);\n       float coef = (1. - n / Iterations);\n        \n       z *= rotateX(.3*cos(3.1415*2.*fract(iTime/20.)) );\n       z *= rotateY(.3*cos(3.1415*2.*fract(iTime/20.)) );\n       z *= rotateZ(.3*cos(3.1415*2.*fract(iTime/20.)) );\n       z = z*Scale - Offset*(Scale-1.0) * (1. - n / Iterations);\n       n++;\n    }\n    return (length(z) ) * pow(Scale, -float(n));\n}\n\n// from IQ\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdYPlane(vec3 p, float y) { return p.y - y; }\n\n// from IQ\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nvec3 map(vec3 p) {\n    \n    \n    \n    return fract(p * rotateZ(0.2*p.z)) - 0.5;\n    \n    //mat3 rot = rotateZ(0.13*p.z);\n    //p *= rot;\n    float x = fract(p.x) - 0.5;\n    float z = fract(p.z) - 0.5;\n    \n    return vec3(x, p.y, z);\n}\n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothstep2(float a, float b, float w, float v) {\n\treturn smoothstep(a-w, a, v) - smoothstep(b, b+w, v);\n}\n\nfloat scale = .3;\nvec2 scene(vec3 p) {\n    p = map(p);\n    \n    p -= vec3(0,-0.4,0);\n    \n    float sphere = sdSphere(p, scale);\n    \n\tfloat fractal = DE(p - vec3(0,.5,0));\n\treturn vec2(fractal, 0);\n\n    float plane = sdPlane(p, vec4(0., 1., 0., scale));\n    int id = 0;\n    if(fractal > plane) id = 1;\n    return vec2(min(fractal, plane), id);\n}\n\nfloat shadowScene(vec3 p){\n    //p = map(p);\n    float fractal = DE(p - vec3(0,.5,0));\n\treturn fractal;\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n    \nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        float id = hit.y;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, id, 1.-i/MaxSteps);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 32.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    \n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,10,0) + vec3(0,0,speed), 50., vec3(.9));\n    \n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-10,15) + vec3(0,0,speed), 30., vec3(.9,.9,.5));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(-5,1,-10) + vec3(0,0,speed), 20., vec3(.8,.8,.3));\n    \n    \n    vec3 ambient = vec3(.1);\n    \n    return L1 + L2 + ambient + top;\n    \n}\n\nfloat checker(vec2 p, float scale) {\n    p = trunc(fract(p)*scale);\n    if(mod(p.x + p.y, 2.) == 0.) return 1.;\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,.3,-4);\n    mat3 rot = rotateZ(-iTime/4.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n    \n    rd *= rot;\n    ro += vec3(0,-.15,speed);\n    //ro *= rot;\n    //rd *= rot;\n    \n    vec3 hit = march(ro, rd);\n    float t = hit.x;\n    float id = hit.y;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n        \n        // sphere\n        if(id == 0.) {\n\t\t\tcol *= hit.z;\n        }\n        \n        // floor\n        if(id == 1.) {\n         \n            vec3 checkerBoard = mix(vec3(0), vec3(1), checker(p.xz, 2.));\n            col = mix(col, checkerBoard, 0.5) * hit.z;\n        }\n        \n        float shadow = marchShadow(p + 0.1*n, normalize(vec3(10,10,10) - p));\n        if(shadow > eps) {\n        \tcol = mix(col, vec3(0), .5);    \n        }\n        \n        float fog = 1. / (0.3 + t * t * 0.05);\n        col = mix(vec3(0), col, fog);\n    }\n    else {\n        vec3 topcolor = vec3(127./255., 161./255., 189./255.);\n        vec3 bottomcolor = vec3(84./255., 111./255., 138./255.);\n        \n    \tcol = vec3(0);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 379, 379, 443], [445, 445, 472, 472, 558], [560, 560, 587, 587, 673], [675, 675, 702, 702, 780], [782, 793, 861, 861, 906], [908, 919, 952, 952, 981], [983, 994, 1027, 1053, 1084], [1086, 1086, 1102, 1102, 1457], [1459, 1459, 1487, 1487, 1535], [1537, 1537, 1555, 1555, 2308], [2310, 2321, 2354, 2354, 2378], [2379, 2379, 2412, 2412, 2430], [2432, 2443, 2472, 2472, 2528], [2530, 2530, 2548, 2548, 2765], [2767, 2798, 2839, 2839, 2932], [2934, 2934, 2989, 2989, 3046], [3066, 3066, 3086, 3086, 3394], [3396, 3396, 3422, 3440, 3501], [3503, 3503, 3528, 3528, 3800], [3806, 3806, 3836, 3836, 4150], [4152, 4152, 4189, 4189, 4425], [4427, 4494, 4601, 4601, 5359], [5361, 5361, 5399, 5399, 5780], [5782, 5782, 5818, 5818, 5910], [5912, 5912, 5969, 5969, 7174]]}
{"id": "3d23Ww", "name": "cloud_003", "author": "kuma720", "description": "cloud", "tags": ["cloud"], "likes": 4, "viewed": 119, "published": "Public", "date": "1549031047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec3 uv) {\n  return fract( sin( dot( uv ,vec3(123.,65.,44.) ) ) * 4811.424 );\n}\n\nfloat pnoise(vec3 uv,float f) {\n\n  vec3 t = uv * f;\n  vec3 v1 = floor(t);\n  vec3 v2 = fract(t);\n\n  float a0 = hash(v1 + vec3(0.,0.,0.));\n  float b0 = hash(v1 + vec3(1.,0.,0.));\n  float c0 = hash(v1 + vec3(0.,1.,0.));\n  float d0 = hash(v1 + vec3(1.,1.,0.));\n\n  float a1 = hash(v1 + vec3(0.,0.,1.));\n  float b1 = hash(v1 + vec3(1.,0.,1.));\n  float c1 = hash(v1 + vec3(0.,1.,1.));\n  float d1 = hash(v1 + vec3(1.,1.,1.));\n\n  float o1 = mix(a0,b0,v2.x);\n  float o2 = mix(c0,d0,v2.x);\n  float o3 = mix(o1,o2,v2.y);\n\n  float o4 = mix(a1,b1,v2.x);\n  float o5 = mix(c1,d1,v2.x);\n  float o6 = mix(o4,o5,v2.y);\n\n  float o7 = mix(o3,o6,v2.z);\n  \n  return o7;\n}\n\nfloat fbm(vec3 uv) {\n  float o = 0.;\n  float n = 1.;\n  float f = 2.5;\n  \n  for ( int i = 0 ; i < 4 ; ++ i ) {\n    o += pnoise( uv , f ) * n ;\n    f *= 2.; \n    n *= 0.5;\n  }\n\n  return o ;\n}\n\nfloat map( in vec3 p )\n{\n  float f = fbm( p * 0.7 + sin(iTime * 0.1) ) ;\n  float s1 = cos( f * 4.5);\n\treturn min( max(0.0, s1 ), 1.0 );\n}\n\nfloat sdf(vec3 p) {\n  \n  float l0 = dot ( p , vec3(0.,1.,0.));\n  float l1 = length( p ) - 3.0;\n  float l2 = max( -l0 , l1 );\n\n  if ( l2 < 0.01 ) {\n    float CLOUD_DENSITY = 5.5;\n    return map( p ) * CLOUD_DENSITY ;\n  }\n\n  return 0.;\n}\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\n\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 worldDir ) {\n\n  vec3 sky = vec3(0.1 - uv.y ,0.0,0.7 + uv.y ) ;\n\n  vec3 cloudColor = vec3( 1.0 , 1.0 , 1.0 );\n  vec3 lightVec = normalize ( vec3( 0.5 , 1. , 0.5 ) );\n\n  int steps = 40;\n  int shadowSteps = 30;\n\n  float invSteps = 1. / float(steps);\n  float invShadowSteps = 1. / float(shadowSteps);\n  float stepDistance = 2. * invSteps;\n  float shadowStepSize = 2. * invShadowSteps;\n\n  vec3 lightColor = vec3(0.,0.,0.);\n  float lightPower = 1.;\n\n  float dist = length ( eye ) - 1.2;\n  vec3 start = worldDir * dist ;\n  vec3 CurPos = eye + start ;\n  int flg = 0;\n  for(int I=0;I<steps;++I) {\n\n    float cursample = sdf( CurPos ) * 3.;\n    if ( cursample > 0.01 ) {\n\n      vec3 lpos = CurPos;\n\n      float shadowDist = 0.;\n      for ( int S = 0 ; S< shadowSteps ; ++S ) {\n        lpos += lightVec * shadowStepSize ;\n        float lsample = sdf( lpos );\n        shadowDist += lsample;\n      }\n\n      float curdensity = clamp( cursample * invSteps , 0. , 1. );\n      lightColor += exp( - shadowDist * invShadowSteps ) * curdensity * cloudColor * lightPower;\n      lightPower *= (1. - curdensity) ;\n      \n      if ( lightPower < 0.001 ) {\n        break;\n      }\n    }\n\n    CurPos += worldDir * stepDistance;\n  }\n\n  vec3 o = sky + lightColor ;\n  return vec4( o , 1. );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    float t = iTime * .5;\n    vec3 eye = vec3( cos(t) * 5. , 3.2 , sin(t) * 5. );\n\n\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(90.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n    fragColor = render( uv , eye , worldDir );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 90], [92, 92, 123, 123, 740], [742, 742, 762, 762, 931], [933, 933, 957, 957, 1070], [1072, 1072, 1091, 1091, 1307], [1310, 1310, 1356, 1356, 1546], [1549, 1549, 1612, 1612, 1738], [1744, 1744, 1795, 1795, 3045], [3051, 3051, 3108, 3108, 3526]]}
{"id": "3dB3D3", "name": "Backwards Cap Tree", "author": "BackwardsCap", "description": "An odd looking tree", "tags": ["raymarch", "tree"], "likes": 4, "viewed": 375, "published": "Public API", "date": "1550151173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 128\n#define SHADOW_STEPS 36\n#define ZERO (min(iFrame,0))\n#define RENDER_DIST 10.\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    \n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n\nvec4 map( in vec3 p)\n{\n    \n    vec4 res = vec4(1e10,vec3(1));\n    //base\n    vec3 bp = p-vec3(0,-.2,0.5);\n\n    vec3 baseTex = texture(iChannel1, p.xy*4.).rgb * 0.6 + 0.4;\n    res = min(res, vec4(sdCappedCone(bp,.16,.1,.5),baseTex*vec3(0.5)));\n    //trunk\n    vec3 trunkTex = texture(iChannel0, p.xy).rgb * 0.6 + 0.4;\n    res = opU(res, vec4(sdCylinder(p-vec3(0,0.,0.5),vec3(0.,0.0,0.0),vec3(0,1.,0),0.05),\n                       trunkTex*vec3(.49,.36,0)));\n    \n    \n    \n    //smooth tree at base\n\tres = smin(res, vec4(sdCappedCone(bp+vec3(0,0.1,0),.05,.01,.05),vec3(1)),.6);\n\n    \n    //leaves on top\n    float rad = 0.3+.2*cos(p.y*10.0+3.0+3.0);\n    \n    vec3 lp = p-vec3(0,1,0.5);\n    \n    //rotating sphere\n    res = opU(res, vec4(sdSphere(lp+vec3(sin(iTime)*.6,sin(iTime)*.2+.5,cos(iTime)*.6),.1),\n                        vec3(0.5,.2+cos(iTime),.2+sin(iTime))));\n    \n    float rot = 0.;\n    \n//    lp.zx*=mat2(-cos(rot),sin(rot),-sin(rot),cos(rot));\n    \n    vec4 l = vec4(1e10,vec3(1));\n    l = opU(l, vec4(sdSphere(lp,rad),vec3(0,.5,0)));\n                \n    /*\n    for(float z=-.25;z<=.25;z+=.5)\n    {\n    \tfor(float x=-.25;x<=.25;x+=.5)\n    \t{\n        \tl = opU(l, vec4(sdSphere(lp+vec3(x,0,z),.2),vec3(0,.5,0)));\n    \t}\n    }\n    */\n                \n    res = opU(res,l);\n    \n  \n\n    \n    return res;\n    \n    \n}\n\nvec4 trace(in vec3 ro, in vec3 rd, float maxDist)\n{\n    \n    vec4 res = vec4(-1.0,-1.0,-1.0,-1.0);\n    \n    float t = 1.0;\n        for(int i=0;i<MAX_STEPS;++i){\n            \n            vec4 h = map(ro+rd*t);\n\n            t+=h.x;\n            if(abs(h.x)<(0.0001)||maxDist<t){\n                if(maxDist<t){\n                    res = vec4(t,vec3(-1));\n                    break;\n                }\n                res = vec4(t,h.yzw);\n                break;\n                \n            }\n            \n            \n            \n\n            \n        }\n        \n        return res;\n    \n}\n\nfloat maxHei = 1.5;\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    //sample around the point to calculate the normal of our surface\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    vec3 col = vec3(0);\n    \n    vec4 res = trace(ro,rd,RENDER_DIST);\n    float t = res.x;//distance\n    vec3 m = res.yzw;//material info\n    \n    if(m.x<0.){\n        //set background to a gradient\n        col = vec3(.5+rd.y);\n    }else{\n    \t//distance casting\n    \tvec3 p = ro+t*rd;\n    \tvec3 nor = (m.x<1.5)?vec3(0.0,1.0,0.0) : calcNormal(p);\n    \tvec3 ref = reflect(rd,nor);\n    \t\n        \n   \t\tcol=m.xyz;\n    \n        //calc ambient occlusion\n        float occ = calcAO(p, nor);\n\t\t//light vector\n        vec3 lig = normalize(vec3(-1.0,.5,-0.5));\n        vec3 hal = normalize(lig-rd);\n\t\t//ambient lighting\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\n        //diffusion lighting\n        float dif = clamp(dot(nor,lig),0.0,1.0);\n\n        \n        float bac = clamp(dot(nor, normalize(vec3(-lig.x,0.0,-lig.z))),0.0,1.0)*clamp(1.0-p.y,0.0,1.0);\n        //reflections\n        float dom = smoothstep(-0.2,0.2,ref.y);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n        \n        //add shadows\n        dif *= calcSoftshadow(p, lig, 0.02, 2.5);\n        dom*= calcSoftshadow(p,ref,0.02,2.5);\n        \n        //calc specularity\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0)*\n            dif*\n            (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        \n        //add the lighting and color together!\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.30*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n    \n    \n    \n    return vec3(clamp(col,0.0,1.0));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float offset = 5.;\n    \n    vec3 ro = vec3(offset*cos(1.*iTime),1.5,0.5+offset*sin(1.*iTime));\n        \n    \n    vec3 ta = vec3(-0.,0.5,0.5);\n    \n    //set cam pos\n    mat3 ca = setCamera(ro,ta,0.0);\n    vec3 rd = ca * normalize(vec3(uv.xy,2.0) );\n    \n    \n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dB3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 135, 135, 161], [163, 163, 201, 201, 294], [296, 296, 321, 321, 340], [341, 341, 412, 412, 750], [752, 752, 788, 788, 1071], [1073, 1073, 1124, 1124, 1479], [1481, 1481, 1506, 1506, 1564], [1566, 1566, 1603, 1603, 1656], [1659, 1659, 1689, 1689, 1722], [1726, 1726, 1748, 1748, 3052], [3054, 3054, 3105, 3105, 3639], [3662, 3724, 3802, 3802, 4085], [4087, 4151, 4183, 4183, 4467], [4470, 4470, 4512, 4512, 4828], [4830, 4830, 4882, 4882, 5059], [5061, 5061, 5098, 5098, 6918], [6920, 6920, 6977, 7030, 7422]]}
{"id": "3dBGWG", "name": "Line Boxes", "author": "gaz", "description": "3d", "tags": ["raymarching"], "likes": 6, "viewed": 132, "published": "Public", "date": "1549810604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  inspired : https://www.shadertoy.com/view/ll2SRy\n\nvec3 rotate(vec3 p,vec3 axis,float theta)\n{\n    vec3 v = cross(p, axis), u = cross(v, axis);\n    return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   \n}\n\nvec2 rotate(vec2 p, float theta)\n{\n    return p * cos(theta) + vec2(-p.y, p.x) * sin(theta);\n}\n\nfloat deLineBox(vec3 p)\n{\n    p=mod(p,4.0)-2.0;\n    float de = 1e5;\n    for(float j=1.0; j<4.0;j++)\n    {\n        p = abs(p)-1.0;\n        for(int i=0; i<3;i++)\n        {\n            vec3 q =p / j;\n            q[i]=max(0.0,q[i]);\n            de= min(de,length(q));\n        }\n        p*=2.0;\n    }\n    return de;\n}\n\nfloat map(vec3 p)\n{   \n    float t = floor(iTime/5.5)*3.5 + min(9.0, mod(iTime,10.0));\n    p =  rotate(p,normalize(vec3(rotate(vec2(1,2),sin(t/3.)),3)),t*0.35);\n    return deLineBox(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(1,2,3)*sin(iTime*0.02+ 0.2*sin(iTime*0.2));\n    vec3 rd0 = normalize(vec3(uv, -1.0));\n    vec3 rd1 = normalize(vec3(uv, (1.0-dot(uv, uv)*0.5)*0.5));\n    vec3 rd = mix(rd0, rd1, step(6.0,mod(iTime,12.0)));\n\n    float g=0.0,z = 0.05, d;\n \tfor(int i = 0; i < 100; i++)\n \t{\n    \tz += d = 0.2*map(ro + rd * z);\n        if(d < 0.001 || d > 10.0) break;\n        g += smoothstep(0.006,0.0,d);\n        //g += exp(-d *500.0)*exp(-z*z*0.2);\n  \t}\n    g = min(1.0,g);\n    vec3 col = mix(vec3(0.9,0.3,0.1),vec3(1,1,0.8), smoothstep(0.01,0.003,d));  \n    col = mix (vec3(0.05,0.05,0.07)*dot(uv,uv),col,g);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 97, 97, 217], [219, 219, 253, 253, 313], [315, 315, 340, 340, 627], [629, 629, 648, 648, 816], [818, 818, 875, 875, 1582]]}
{"id": "3dBGz3", "name": "Partial derivative based dither", "author": "Zavie", "description": "Experimenting with a dither based on per pixel partial derivative. The goal is to alter the information (in this example, the color) along the local gradient rather than in an arbitrary direction.\n", "tags": ["noise", "dithering", "partialderivative"], "likes": 4, "viewed": 253, "published": "Public", "date": "1549447709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis shader tests using the partial derivatives to add\nnoise to gradients in order to reduce banding.\n\nThe goal is to alter the information (in this example,\nthe color) along the local gradient rather than in an\narbitrary direction.\n\n\n2019-02-06:\nThis is a first draft, and the result is not good yet.\nI'll try to iterate on it and see if I can get\nsomething satisfaying.\n\n--\nZavie\n\n*/\n\n\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n\nvec3 PartialDerivativeDither(vec3 x, vec2 vScreenPos, float colorDepth)\n{\n\tfloat rand = fract(sin(dot(vScreenPos, vec2(12.9898,78.233))) * 43758.5453);\n    \n    vec3 dx = fwidth(x);\n    // This 255 is coming from nowhere:\n    // I simply haven't worked out the math yet.\n    return dx * rand * 255./ colorDepth;\n}\n\n// ---8<----------------------------------------------------------------------\n\n// The functions that follow are only used to generate\n// the color gradients for demonstrating dithering effect.\n\nfloat h00(float x) { return 2.*x*x*x - 3.*x*x + 1.; }\nfloat h10(float x) { return x*x*x - 2.*x*x + x; }\nfloat h01(float x) { return 3.*x*x - 2.*x*x*x; }\nfloat h11(float x) { return x*x*x - x*x; }\nfloat Hermite(float p0, float p1, float m0, float m1, float x)\n{\n\treturn p0*h00(x) + m0*h10(x) + p1*h01(x) + m1*h11(x);\n}\n\n// Source:\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 generateColor(vec2 uv)\n{\n\tfloat a = sin(iTime * 0.5)*0.5 + 0.5;\n\tfloat b = sin(iTime * 0.75)*0.5 + 0.5;\n\tfloat c = sin(iTime * 1.0)*0.5 + 0.5;\n\tfloat d = sin(iTime * 1.25)*0.5 + 0.5;\n\t\n\tfloat y0 = mix(a, b, uv.x);\n\tfloat y1 = mix(c, d, uv.x);\n\tfloat x0 = mix(a, c, uv.y);\n\tfloat x1 = mix(b, d, uv.y);\n    \n    float h = fract(mix(0., 0.1, Hermite(0., 1., 4.*x0, 4.*x1, uv.x)) + iTime * 0.05);\n    float s = Hermite(0., 1., 5.*y0, 5.*y1, 1. - uv.y);\n    float v = Hermite(0., 1., 5.*y0, 5.*y1, uv.y);\n\n\treturn hsv2rgb(vec3(h, s, v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat colorDepth = mix(2.0, 255.0, pow(clamp(mix(-0.2, 1.2, abs(2.0 * fract(iTime / 11.0) - 1.0)), 0., 1.), 2.0));\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 color = pow(generateColor(uv), vec3(1. / gamma));\n    vec3 ditheredColor = color + PartialDerivativeDither(color, fragCoord.xy, colorDepth);\n\n    float separator = 1. - smoothstep(0.497, 0.499, uv.x) * smoothstep(0.503, 0.501, uv.x);\n    vec3 finalColor = mix(color, ditheredColor, smoothstep(0.499, 0.501, uv.x)) * separator;\n    \n\tfragColor = vec4(floor(finalColor * colorDepth) / colorDepth, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 492, 565, 565, 805], [887, 1002, 1022, 1022, 1055], [1056, 1056, 1076, 1076, 1105], [1106, 1106, 1126, 1126, 1154], [1155, 1155, 1175, 1175, 1197], [1198, 1198, 1262, 1262, 1319], [1321, 1391, 1413, 1413, 1582], [1584, 1584, 1613, 1613, 2123], [2125, 2125, 2182, 2182, 2757]]}
{"id": "3dfSD4", "name": "SherfeyFractal Spin Around", "author": "JohnShadow", "description": "SpinAround! basically the bulb version of my fractal. Less spooky too", "tags": ["private"], "likes": 2, "viewed": 114, "published": "Public", "date": "1551253432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define maxsteps 100\n#define maxDist 100.0\nfloat sdf(vec3 x)\n{\n    //sphereical sdf zooming in over time.\n\t//this can use any sdf fuction, even other fractals.\n    return distance(x, vec3(0,0,0)) -3.0;\n}\nvec3 normalSphere (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( sdf(p + vec3(eps, 0, 0) ) - sdf(p - vec3(eps, 0, 0)),\n \t  sdf(p + vec3(0, eps, 0) ) - sdf(p - vec3(0, eps, 0)),\n\t  sdf(p + vec3(0, 0, eps) ) - sdf(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat fractal(vec3 pos)\n{\n\t//vec3 eye = vec3(12.0*sin(iTime), cos(iTime), cos(iTime)*12.0);\n    //sample sphere find normal for later casting onto sphere\n    float sl = sdf(pos);\n    vec3 samp = pos;\n    float l = 0.;\n    for(int i = 0; i < 10; ++i) //fractal iterations\n    {\n        samp = abs(samp) - 1.0;\n        samp /= dot(samp,samp);\n    }\n    l = (distance(samp, vec3(0,0,0))) + sl;\n\treturn l;\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.0001;\n \n return normalize\n ( vec3\n \t( fractal(p + vec3(eps, 0, 0) ) - fractal(p - vec3(eps, 0, 0)),\n \t  fractal(p + vec3(0, eps, 0) ) - fractal(p - vec3(0, eps, 0)),\n\t  fractal(p + vec3(0, 0, eps) ) - fractal(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvec4 map(vec2 fragCoord)\n{\n    vec3 viewDir = rayDirection(60.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = vec3(12.0*sin(iTime), cos(iTime), cos(iTime)*12.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n    float angle = 0.5;\n    vec3 marchpos = eye, dir = worldDir, n = dir;\n    float totaldist = 0.0;\n    float steps = 0.0;\n    for(int i = 0; i < maxsteps; ++i)\n    {\n        float dist = fractal(marchpos);\n        totaldist += dist;\n        marchpos += dir * dist;\n        if(dist < 0.0001)\n        {\n\t\t\tn = normal(marchpos);\n\t\t\tbreak;\n        }\n        ++steps;\n    }\n    //lighting n dot l\n    vec3 light = vec3(0.0, 1.0, 0.5);\n    float l = max(dot(n, light)*0.5,0.1);\n    float sky = dot(n, vec3(0,-1.0,0));\n    vec3  color = sky*vec3(0.5,0.5,0.3) + (1.0-sky)*vec3(0.2,0.5,0.8);\n    if(totaldist < maxDist)\n    \treturn vec4(color * 0.5 + vec3(l) + vec3(n)*0.1, 1.0);\n    else\n        return vec4(vec3(color),1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = map(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 62, 159, 203], [204, 204, 232, 232, 468], [469, 469, 494, 622, 872], [873, 873, 895, 895, 1156], [1157, 1157, 1222, 1222, 1354], [1355, 1355, 1404, 1439, 1665], [1666, 1666, 1692, 1692, 2700], [2701, 2701, 2758, 2758, 2792]]}
{"id": "3dfSRr", "name": "triangularNoiseACID", "author": "skandix", "description": "A C I D ", "tags": ["acid"], "likes": 1, "viewed": 72, "published": "Public", "date": "1550400452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TAU PI*2\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fTime = iTime * PI;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 colors = vec3(tanh(fTime),sinh(fTime),0);\n    \n    float Speed = tanh(sin(uv.y)+(cos(uv.x)));\n    float e0 = -1.5;\n    float interpolation = -100.5;\n    \n    vec3 bg = cos(colors);\n\t\n    uv = rotate2d((PI*fTime)*uv.x) * uv;    \n    vec3 yNoise = vec3(tan(fTime*Speed*uv.x)*smoothstep(e0, uv.y, interpolation));\n    vec3 xNoise = vec3(tan(fTime-Speed*uv.y)/smoothstep(e0, uv.x, interpolation));\n    \n    vec3 noise = vec3(yNoise + xNoise)*fTime;\n    \n    vec3 composition = vec3(bg * noise * tanh(iTime));\n   \n    // Output to screene\n    fragColor = vec4(composition,tanh(iTime));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 71, 71, 157], [159, 159, 216, 216, 961]]}
{"id": "3dfXRM", "name": "Is this hell?", "author": "saidwho12", "description": "Mwahahahah!", "tags": ["2d", "test", "noise", "particles", "smoke", "particle"], "likes": 1, "viewed": 165, "published": "Public", "date": "1550800316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//###############################################################################\n\n//----------------------------------------------------------------------------------------\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33w(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031f, 0.1030f, 0.0973f));\n    p3 += dot(p3, p3.yxz+19.19f);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 hash33s(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031f, 0.11369f, 0.13787f));\n    p3 += dot(p3, p3.yxz + 19.19f);\n    return -1.0f + 2.0f * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n// I think from iq...\nfloat simplex(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33s(i)), dot(d1, hash33s(i + i1)), dot(d2, hash33s(i + i2)), dot(d3, hash33s(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nfloat simplexFbm(vec3 pos, float octaves, float persistence, float scale)\n{\n    float final        = 0.0;\n    float amplitude    = 1.0;\n    float maxAmplitude = 0.0;\n\n    for(float i = 0.0; i < octaves; ++i)\n    {\n        final        += simplex(pos * scale) * amplitude;\n        scale        *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude    *= persistence;\n    }\n\n    return (min(final, 1.0f) + 1.0f) * 0.5f;\n}\n\n#define PI acos(-1.)\n#define TAU (PI+PI)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 hsv(float x) {\n\treturn .5+.5*sin(x+vec3(0,TAU/3.,2.*TAU/3.));\n}\n\nfloat aspect;\n\n\nfloat getTime(float id, float time) {\n    return time + hash11(id);\n}\n\nvec2 getPosition(float id, float time) {\n\tvec2 h = hash21(id);\n    float speed = .5+hash11(id);\n    vec2 p = fract(h + vec2((.0025+.01*hash11(id))\n                            *sin( (speed*h.y + getTime(id,time))*PI ),\n                            .25*time))*2.-1. ;\n    return p *vec2(aspect,1);\n}\n\nfloat getAngle(float id, float time) {\n\treturn ((hash11(id)*2.-1.)+time)*TAU;\n}\n\nfloat getSmoke(vec2 p, float id, float time) {\n\tfloat t = getTime(id,time);\n    vec2 c = getPosition(id,t);\n    \n    float r = .3+hash11(id)*.25;\n    float d = length(p-c)-r;\n    float a = .3+hash11(id)*.8;\n    return (.5+.5*simplex(vec3(rot(getAngle(id,.15*t))*(2.*(p-c)),hash11(id)+.25*t)))\n        * smoothstep(0., -r*.75, d) * a * exp(-3.*(c.y*.5+.5));\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy, p = (u+u-R)/R.y;\n    aspect = R.x/R.y;\n    vec2 uv = u/R;\n    \n    //p = rot(-PI/4.) * p;\n    vec2 p0 = (p - vec2(.025*sin((p.x-iTime)*PI)*sin(p.y*PI),iTime)) * vec2(6.,1.);\n    float a = pow(.5+.5*simplexFbm(vec3(p0,.75*iTime),4.,.7,1.),1.4+2.5*uv.y) * exp(-4.*u.y/R.y);\n\tO *= 0.;\n    O.rgb = mix(O.rgb, hsv((1.-a)*TAU/4.), a);\n    \n    int i = -1, N = 25;\n    while(++i<N) {\n        float alpha = getSmoke(p,float(i),iTime);\n    \tO.rgb = mix(O.rgb, vec3(.5),  alpha);\n    }\n    \n   O.rgb = sqrt(O.rgb);// gamma 2.2\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfXRM.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[1036, 1146, 1169, 1169, 1287], [1289, 1399, 1421, 1421, 1543], [1545, 1655, 1678, 1678, 1786], [1788, 1898, 1920, 1920, 2034], [2036, 2147, 2168, 2168, 2287], [2289, 2400, 2422, 2422, 2526], [2528, 2638, 2660, 2660, 2778], [2781, 2892, 2913, 2913, 3034], [3036, 3147, 3169, 3169, 3279], [3281, 3390, 3412, 3412, 3538], [3540, 3649, 3670, 3670, 3797], [3799, 3908, 3929, 3929, 4056], [4058, 4167, 4189, 4189, 4301], [4386, 4477, 4502, 4531, 4784], [4786, 4786, 4812, 4812, 4970], [4972, 4972, 4995, 4995, 5127], [5129, 5129, 5152, 5152, 5348], [5350, 5372, 5397, 5397, 6057], [6059, 6059, 6134, 6134, 6485], [6580, 6580, 6599, 6599, 6648], [6666, 6666, 6703, 6703, 6735], [6737, 6737, 6777, 6777, 7033], [7035, 7035, 7073, 7073, 7114], [7116, 7116, 7162, 7162, 7474], [7476, 7476, 7517, 7517, 8065]]}
{"id": "3dfXzr", "name": "Raymarch Mandelbox", "author": "darkeclipz", "description": "- http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\n- http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/", "tags": ["raymarch", "mandelbox"], "likes": 2, "viewed": 157, "published": "Public", "date": "1550424443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 64.\n#define MinDistance 0.01\n#define eps 0.001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    \n    float fixedRadius2 = .6 + 4.* cos(iTime/8.) + 4.;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 30.;\n    float Scale = 3.;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n\t\tz = boxFold(z, vec3(2.));       // Reflect\n\t\tsphereFold(z, dr);    // Sphere Inversion\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n    float plane = sdPlane(p, vec4(0,0,1,0));\n    \n    //float l = 1e10;\n    //l = min(l, sdSphere(p-vec3(5,-5,5), .5));\n    //l = min(l, sdSphere(p-vec3(5,-5,-5), .5));\n    //l = min(l, sdSphere(p-vec3(-5,-5,5), .5));\n    //l = min(l, sdSphere(p-vec3(-5,-5,-5), .5));\n    //l = min(l, sdSphere(p-vec3(0), .5));\n    \n    return box;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,3,0), 100., vec3(.5,.0,.0));\n    \n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,5), 25., vec3(.4));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,-5), 25., vec3(.4));\n    vec3 L3 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,5), 25., vec3(.4));\n    vec3 L4 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,-5), 25., vec3(.4));\n    \n\n    mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    vec3 camPos = (vec3(0,0,-3)- vec3(0,1,15)) * rot ;\n    vec3 cam = shadeBlinnPhong(p, rd, sn, camPos, 10., vec3(.9));\n    \n    vec3 ambient = vec3(.1);\n    return L1 + L2 + L3 + L4 + ambient + top + cam;\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0,-3); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    \n    ro -= vec3(0,1,15);\n    ro *= rot;\n    rd *= rot;\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        col += light(p, n, rd);\n        col *= hit.y;   // occlusion \n    }\n    else {\n        col = vec3(0);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 194, 221, 221, 307], [309, 309, 336, 336, 422], [424, 424, 451, 451, 529], [531, 531, 564, 564, 593], [595, 606, 643, 643, 674], [676, 687, 718, 718, 781], [783, 859, 889, 889, 934], [936, 1062, 1109, 1109, 1404], [1406, 1482, 1507, 1507, 1673], [1675, 1773, 1790, 1790, 2207], [2209, 2209, 2229, 2229, 2592], [2594, 2594, 2620, 2620, 2639], [2641, 2652, 2677, 2677, 2949], [2951, 3029, 3059, 3059, 3350], [3352, 3352, 3389, 3389, 3625], [3629, 3696, 3803, 3803, 4561], [4563, 4638, 4676, 4676, 5340], [5342, 5403, 5471, 5471, 5516], [5518, 5518, 5575, 5575, 6223]]}
{"id": "3dj3Rt", "name": "BH", "author": "isak", "description": "bh", "tags": ["stars", "blackhole", "redshift", "bh"], "likes": 1, "viewed": 49, "published": "Public", "date": "1549719118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 uvtotuv(in vec2 uv){\n \treturn 0.5*(iResolution.y*uv/iResolution.xy + 1.0);\n}\n\nvec2 starpos(vec2 x){\n \treturn vec2(sin(x.x*iTime), cos(x.y*iTime));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = 2.0*(fragCoord- 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 d = 0.5*sin(0.1*iTime)*vec2(sin(iTime), cos(iTime));\n    \n    uv *= 2.0;\n    uv -= d;\n    \n    vec2  dir   = normalize(uv);\n    float theta = length(uv) ;\n   \tfloat a     = 0.8;\n    \n    vec2 p = dir*(theta - a/theta);\n    \n    p += d;\n\n    fragColor = texture(iChannel1, uvtotuv(p));\n    \n    vec2 s = 3.0*sin(0.5*iTime)*vec2(1.0, 0.0);\n    \n    float df = 1e9;\n    df = min(df, length(p - starpos(vec2(0.3, 0.6))));\n    df = min(df, length(p - starpos(vec2(0.3, 1.7))));\n    df = min(df, length(p - starpos(vec2(0.1, 0.3))));\n    df = min(df, length(p - starpos(vec2(0.14, 0.2))));\n    \n    df = min(df, length(p - starpos(vec2(0.14, 0.9))));\n    df = min(df, length(p - starpos(vec2(0.24, 0.1))));\n    df = min(df, length(p - starpos(vec2(0.74, 0.4))));\n    df = min(df, length(p - starpos(vec2(0.14, 2.2))));\n\n\n    \n    fragColor += 1.0 -  smoothstep(0.01, 0.1, df);\n    \n    float shade = length(1.5*uv);\n    \n    float r = smoothstep(0.2, 0.7, 1.0 - length(uv));\n    fragColor *= vec4(1.0 - r*r*r, 1.0 - r , 1.0 - r, 0.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dj3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 81], [83, 83, 104, 104, 156], [158, 158, 214, 214, 1325]]}
{"id": "3dj3Wc", "name": "Simple Heart", "author": "willstall", "description": "Just a nice simple shader for a nice simple day. Happy Valentines!", "tags": ["sdf", "heart"], "likes": 2, "viewed": 141, "published": "Public", "date": "1550160316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\n    precision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // space.xy;\n\tvec2 st = fragCoord/iResolution.xy;\n    st = center( st );\n    st *= 2.0;\n    st.y -= .1;\n\n    // timing\n    float seconds = 1.0;\n    float t = fract(iTime/seconds);\n\n    // sdf\n    vec2 pos = vec2( 1.0,1.0 );\n        pos = st-pos;\n        pos.x *= .7;\n        pos += pos*2.5*abs(sin(t));\n\n    float r = length(pos)-.1;\n    float a = abs(atan(pos.x*1.7,pos.y));// + PI;\n    float g = st.y*st.x;\n    float c = 1.0-smoothstep(0.0,0.02,r-a*.1);\n    // color\n    vec3 color = vec3(1.0, 1.0, 1.0);\n        color = mix(color,vec3(1.0, 0.0, 0.0),c);\n        color += vec3(1.0, 0.0, 0.298) *g*c;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dj3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 231, 231, 298], [300, 300, 322, 322, 434], [436, 436, 493, 510, 1136]]}
{"id": "3djGDt", "name": "Raymarch IFS", "author": "darkeclipz", "description": "finally, after months I figured out how to render this! :D\n\nReferences:\n- http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n- http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)\n- iq", "tags": ["raymarch", "ifs"], "likes": 10, "viewed": 250, "published": "Public", "date": "1550277963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 32.\n#define MinDistance 0.01\n#define eps 0.001\n#define Iterations 22.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat DE(vec3 z)\n{\n    float angl = cos(iTime)*.2;\n    mat3 rx = rotateX(angl);\n    mat3 ry = rotateY(angl);\n    mat3 rz = rotateZ(angl);\n    mat3 rot = rx * ry * rz;\n \n    float Scale = 2. + cos(iTime/8.);\n    float Offset = .65;\n    float n = 0.;\n    while (n < Iterations) {\n       z = abs(z);\n       if(z.x - z.y < 0.) z.xy = z.yx;\n       if(z.x - z.z < 0.) z.xz = z.zx;\n       if(z.y - z.z < 0.) z.yz = z.zy;\n       z *= rot;\n       z = abs(z);\n       z = z*Scale - vec3(vec3(Offset*(Scale-1.0)).xy, 0);\n       n++;\n    }\n    return (length(z) ) * pow(Scale, -float(n));\n}\n\nfloat scene(vec3 p) {\n\treturn DE(p - vec3(0,.1,0));\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p - vec3(0,.1,0));\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                  k.yyx*scene( p + k.yyx*h ) + \n                  k.yxy*scene( p + k.yxy*h ) + \n                  k.xxx*scene( p + k.xxx*h ) );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec2 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = scene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec2(t-MinDistance, 1.-i/MaxSteps);  \n        }\n    }\n    return vec2(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 32.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,5,0), 30., vec3(.9));\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,10), 30., vec3(.9,.9,.5));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(-5,1,-5), 20., vec3(.8,.8,.3));\n    vec3 ambient = vec3(.1);\n    return L1 + L2 + ambient + top;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,2.,-4); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateY(-iTime/4.);\n    ro *= rot;\n    rd *= rot;\n    \n    vec2 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        float shadow = marchShadow(p + 0.1*n, normalize(vec3(10,10,10) - p));\n        if(shadow > eps) {\n        \tcol = mix(col, vec3(0), .5);    \n        }\n        \n        float fog = 1. / (0.3 + t * t * 0.05);\n        col = mix(vec3(0), col, fog);\n    }\n    else {\n        vec3 topcolor = vec3(127./255., 161./255., 189./255.);\n        vec3 bottomcolor = vec3(84./255., 111./255., 138./255.);\n    \tcol = mix(bottomcolor, topcolor, uv.y);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 140, 140, 226], [228, 228, 255, 255, 341], [343, 343, 370, 370, 448], [450, 549, 567, 567, 1126], [1128, 1128, 1149, 1149, 1181], [1183, 1183, 1209, 1209, 1241], [1243, 1254, 1279, 1279, 1543], [1545, 1623, 1653, 1653, 1911], [1913, 1913, 1950, 1950, 2186], [2188, 2255, 2362, 2362, 3120], [3122, 3197, 3235, 3235, 3529], [3531, 3531, 3588, 3588, 4565]]}
{"id": "3djGR3", "name": "NIKUNJSHA FILMS", "author": "nikunjsha", "description": "Credits to : Mr.Abhishek Dave for Editing and refactoring & David Hoskins for original Code.", "tags": ["nikunjsha", "textfilter", "customtext", "filtertext"], "likes": 2, "viewed": 111, "published": "Public", "date": "1549534279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Source edited by Nikunjsha - 2019.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 19. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n//#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(3.0, .5);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 7.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\tvec3 col = vec3(0.1, .05+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n\td += N(r()); add(); \n    d += I(r()); add(); \n    d += K(r()); add(); \n    d += U(r()); add();\n    d += N(r()); add();\n    d += J(r()); add(); \n    d += S(r()); add(); \n    d += H(r()); add(); \n    d += A(r()); add(); space();\n    d += F(r()); add(); \n    d += I(r()); add(); \n    d += L(r()); add(); \n    d += M(r()); add();\n    d += S(r()); add();\n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.3,.4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 ) + texture(iChannel0, xy).rgb;\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2671, 2757, 2805, 2868, 3547], [3549, 3635, 3680, 3680, 4024], [4026, 4112, 4142, 4142, 4226], [4228, 4346, 4384, 4384, 4477], [4479, 4565, 4575, 4575, 4678], [4680, 4766, 4778, 4778, 4797], [4799, 4885, 4899, 4899, 4918], [4920, 5006, 5022, 5022, 5068], [5070, 5156, 5213, 5213, 6148]]}
{"id": "3djGWc", "name": "Pulsating peanut", "author": "TronJeremy", "description": "first attempt to follow Wong's raymarching tutorial :)", "tags": ["hello", "world"], "likes": 3, "viewed": 74, "published": "Public", "date": "1550156552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAYSTEPS 255\n#define MINDISTANCE 0.0\n#define MAXDISTANCE 64.0\n#define EPSILON 0.0001\n\n// IOW, list here all primitives/deformation functions that you will need later when composing the scene\nfloat sphereSDF(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n// here you compose the scene together using the above functions\nfloat scene(vec3 p)\n{    \n    return intersectSDF(sphereSDF(p, 1.0),sphereSDF(p+vec3(cos(iTime*0.25), sin(iTime), 0.0), 1.0));\n}\n\nfloat bounce(vec3 eye, vec3 marchingDirection, float start, float end) \n{\n    float depth = start;\n    for (int i = 0; i < RAYSTEPS; i++) \n    {\n        float dist = scene(eye + depth * marchingDirection);\n        if (dist < EPSILON) return depth;        \n        depth += dist;\n        if (depth >= end) return end;        \n    }\n    return end;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan(radians(fov)/2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    vec3 direction = rayDirection(45.0, iResolution.xy, fragCoord);\n    float distance = bounce(eye, direction, MINDISTANCE, MAXDISTANCE);\n    if (distance > MAXDISTANCE - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }    \n    vec3 p = eye + distance * direction;    \n    fragColor = vec4(vec3(estimateNormal(p)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 199, 238, 238, 269], [271, 271, 317, 317, 349], [351, 416, 437, 437, 544], [546, 546, 619, 619, 894], [896, 896, 953, 953, 1072], [1074, 1074, 1103, 1103, 1395], [1397, 1397, 1452, 1452, 1846]]}
{"id": "3djGWt", "name": "Bandeirone", "author": "xicomano", "description": "Aula 01", "tags": ["onda"], "likes": 1, "viewed": 259, "published": "Public API", "date": "1550603885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \n    float balanco2=(sin((100000.0*iTime)+(uv.x*100000.0))/60000.0);\n    \n\n    // Output to screen\n    \n    if(uv.y>0.7-balanco2*600000.0)\n        fragColor = vec4(1,0,0,1)*1.0-balanco2*6000000.0;\n    \n \n    \n\n  \n\n            \n    else if(uv.y<0.4+balanco2*600000.0)\n        fragColor = vec4(0,0,1,1)*1.0-balanco2*400000.0;\n        \n        \n                \n                else if(uv.y>0.2-balanco2*60000.0)\n        fragColor = vec4(1,1,0,1)*1.0-balanco2*30000.0;\n                    \n  \n    \n    \n    \n                    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 682]]}
{"id": "3djGzt", "name": "simple cloudy background semi 3d", "author": "public_int_i", "description": "a simple cloudy background", "tags": ["2d", "noise", "clouds", "background", "cloudy"], "likes": 1, "viewed": 285, "published": "Public API", "date": "1549724926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,1));\n    if (iMouse.w > 0.) {\n        vec2 mc = iMouse.xy*6.28/iResolution.xy;\n        rd.yz *= rot(-mc.y);\n        rd.xz *= rot(mc.x);\n    } else rd.xz *= rot(iTime*.5);\n    vec2 pc = rd.xz*(.5/(1.+abs(rd.y)))+iTime*.01;\n    \n\tvec2 dp = pc*10.+cos((pc.yx-.5)*vec2(16,3)),\n        fp = floor(dp*.5),\n        rp = mod(dp,2.)-1.;\n\tfloat c = max(0.,(.9+.1*hash(fp.xyyx).x)-length(rp)*.8),\n\tm = 0.;\n\tfor (int i = 0; i < 3; i++) {\n\t\tm += max(0.,length(mod(\n\t\tpc*(10.+float(i)*10.)+\n\t\tcos(float(i+2)/(1.+c*float(1+i))+pc.yx-.5*float(i*2+3)+float(i)*vec2(1.4,.6))*float(1+i*2),\n\t\t2.)-1.));\n\t}\n\tc *= pow(m*.2,1./4.);\n\tc = pow(c,2.);\n\tfragColor = mix(vec4(.1,.5,.9,1),vec4(1),c);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 129, 148, 148, 249], [251, 251, 308, 308, 1051]]}
{"id": "3dlSDn", "name": "Colorful metaballs", "author": "butadiene", "description": "This is my first post at shadertoy! Thank you for watching!\n\n", "tags": ["3d", "raymarching", "metaballs"], "likes": 2, "viewed": 1035, "published": "Public API", "date": "1551068129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Butadiene\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\t\t\tconst float  _ypos =-0.25;\n\n\n\t\t\t// The MIT License\n\t\t\t// Copyright © 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t//Making noise\n\t\t\tfloat hash(vec2 p)  \n\t\t\t{\n\t\t\t\tp  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n\t\t\t\treturn -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 p )\n\t\t\t{\n\t\t\t\tvec2 i = floor( p );\n\t\t\t\tvec2 f = fract( p );\n\t\n\t\t\t\tvec2 u = f*f*(3.0-2.0*f);\n\n\t\t\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t\t\t}\t\t\t\n\t\t\t///////////////////////////////////////////////////////////////////////\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tfloat smoothMin(float d1,float d2,float k)\n\t\t\t{\n\t\t\t\treturn -log(exp(-k*d1)+exp(-k*d2))/k;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Base distance function\n\t\t\tfloat ball(vec3 p,float s)\n\t\t\t{\n\t\t\t\treturn length(p)-s;\n\t\t\t}\n\n\t\t\t\n\t\t\t// Making ball status\n\t\t\tvec4 metaballvalue(int i)\n\t\t\t{\n\t\t\t\tfloat ifloat = float(i);\n                float kt = 3.*iTime*(0.1+0.01*ifloat);\n\t\t\t\tvec3 ballpos = 0.3*vec3(noise(vec2(ifloat,ifloat)+kt),noise(vec2(ifloat+10.,ifloat*20.)+kt),noise(vec2(ifloat*20.,ifloat+20.)+kt));\n\t\t\t\tfloat scale = 0.05+0.02*hash(vec2(ifloat,ifloat));\n\t\t\t\treturn  vec4(ballpos,scale);\n\t\t\t}\n\t\t\t// Making ball distance function\n\t\t\tfloat metaballone(vec3 p, int i)\n\t\t\t{\t\n\t\t\t\tvec4 value = metaballvalue(i);\n\t\t\t\tvec3 ballpos = p-value.xyz;\n\t\t\t\tfloat scale =value.w;\n\t\t\t\treturn  ball(ballpos,scale);\n\t\t\t}\n\n\t\t\t//Making metaballs distance function\n\t\t\tfloat metaball(vec3 p)\n\t\t\t{\n\t\t\t\tfloat d1;\n\t\t\t\tfloat d2 =  metaballone(p,0);\n\t\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\t\n\t\t\t\t\td1 = metaballone(p,i);\n\t\t\t\t\td1 = smoothMin(d1,d2,20.);\n\t\t\t\t\td2 =d1;\n\t\t\t\t\t}\n\t\t\t\treturn d1;\n\t\t\t}\n\t\t\n\t\t\t// Making distance function\n\t\t\tfloat dist(vec3 p)\n\t\t\t{\t\n\t\t\t\tfloat y = p.y;\n\t\t\t\tfloat d1 =metaball(p);\n\t\t\t\tfloat d2 = y-(_ypos); //For floor\n\t\t\t    d1 = smoothMin(d1,d2,20.);\n\t\t\t\treturn d1;\n\t\t\t}\n\n\n\t\t\t//enhanced sphere tracing  http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n\t\t\tfloat raymarch (vec3 ro,vec3 rd)\n\t\t\t{\n\t\t\t\tfloat previousradius = 0.0;\n\t\t\t\tfloat maxdistance = 3.;\n\t\t\t\tfloat outside = dist(ro) < 0. ? -1. : +1.;\n\t\t\t\tfloat pixelradius = 0.01;\n\t\t\t\tfloat omega = 1.2;\n\t\t\t\tfloat t =0.0001;\n\t\t\t\tfloat step = 0.;\n\t\t\t\tfloat minpixelt =999999999.;\n\t\t\t\tfloat mint = 0.;\n\t\t\t\tfloat hit = 0.01;\n\t\t\t\t\tfor (float i = 0.; i < 80.; ++i) {\n\n\t\t\t\t\t\tfloat radius = outside*dist(ro+rd*t);\n\t\t\t\t\t\tbool fail = omega>1. &&step>(abs(radius)+abs(previousradius));\n\t\t\t\t\t\tif(fail){\n\t\t\t\t\t\t\tstep -= step *omega;\n\t\t\t\t\t\t\tomega =1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstep = omega * radius;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpreviousradius = radius;\n\t\t\t\t\t\tfloat pixelt = radius/t;\n\t\t\t\t\t\tif(!fail&&pixelt<minpixelt){\n\t\t\t\t\t\t\tminpixelt = pixelt;\n\t\t\t\t\t\t\tmint = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!fail&&pixelt<pixelradius||t>maxdistance)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tt += step;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif ((t > maxdistance || minpixelt > pixelradius)&&(mint>hit)){\n\t\t\t\t\treturn -1.;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\treturn mint;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\t// The MIT License\n\t\t\t// Copyright © 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/Xds3zN\n\n\t\t\t//Tetrahedron technique  http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\t\t\tvec3 getnormal( in vec3 p)\n\t\t\t{\n\t\t\t\tvec2 e = vec2(0.5773,-0.5773)*0.0001;\n\t\t\t\tvec3 nor = normalize( e.xyy*dist(p+e.xyy) + e.yyx*dist(p+e.yyx) + e.yxy*dist(p+e.yxy ) + e.xxx*dist(p+e.xxx));\n\t\t\t\tnor = normalize(vec3(nor));\n\t\t\t\treturn nor ;\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////////////////////////////\n\n\t\t\t// Making shadow\n\t\t\tfloat softray( vec3 ro, vec3 rd , float hn)\n\t\t\t{\n\t\t\t\tfloat t = 0.000001;\n\t\t\t\tfloat jt = 0.0;\n\t\t\t\tfloat res = 1.;\n\t\t\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\t\t\tjt = dist(ro+rd*t);\n\t\t\t\t\tres = min(res,jt*hn/t);\n\t\t\t\t\tt = t+ clamp(0.02,2.,jt);\n\t\t\t\t}\n\t\t\t\treturn clamp(res,0.,1.);\n\t\t\t}\n\t\t\t\n\t\t\t// The MIT License\n\t\t\t// Copyright © 2013 Inigo Quilez\n\t\t\t// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t\t// https://www.shadertoy.com/view/ld2GRz\n\n\t\t\tvec4 material(vec3 pos)\n\t\t\t{\n                vec4 ballcol[6]=vec4[6](vec4(0.5,0.,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.5,0.,1.),\n\t\t\t\t\t\t\t\tvec4(0.,0.,0.5,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0.25,0,1.),\n\t\t\t\t\t\t\t\tvec4(0.25,0,0.25,1.),\n                    \t\t\tvec4(0.,0.25,0.25,1.));\n\t\t\t\tvec3 mate = vec3(0,0,0);\n\t\t\t\tfloat w = 0.01;\n\t\t\t\t\t// Making ball color\n\t\t\t\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\t\t\t\tfloat x = clamp( (length( metaballvalue(i).xyz - pos )-metaballvalue(i).w)*10.,0.,1. ); \n\t\t\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\t\t\tmate += p*vec3(ballcol[i].xyz);\n\t\t\t\t\t\tw += p;\n\t\t\t\t\t}\n\t\t\t\t// Making floor color\n\t\t\t\tfloat x = clamp(  (pos.y-_ypos)*10.,0.,1. );\n\t\t\t\tfloat p = 1.0 - x*x*(3.0-2.0*x);\n\t\t\t\tmate += p*vec3(0.4,0.4,0.4);\n\t\t\t\tw += p;\n\t\t\t\tmate /= w;\n\t\t\t\treturn vec4(mate,1);\n\t\t\t}\n\t\t\t////////////////////////////////////////////////////\n\t\t\t\n\t\t\t//Phong reflection model ,Directional light\n\t\t\tvec4 lighting(vec3 pos,vec3 ro)\n\t\t\t{\t\n\t\t\t\tvec3 mpos =pos;\n\t\t\t\tvec3 normal =getnormal(mpos);\n\t\t\t\t\t\n\t\t\t\tvec3 viewdir = normalize(pos-ro);\n\t\t\t\tvec3 lightdir = normalize(vec3(0.5,0.5,-0.5));\n\t\t\t\t\n\t\t\t\tfloat sha = softray(mpos,lightdir,3.3);\n\t\t\t\tvec4 Color = material(mpos);\n\t\t\t\t\n\t\t\t\tfloat NdotL = max(0.,dot(normal,lightdir));\n\t\t\t\tvec3 R = -normalize(reflect(lightdir,normal));\n\t\t\t\tfloat spec =pow(max(dot(R,-viewdir),0.),10.);\n\n\t\t\t\tvec4 col =  sha*(Color* NdotL+vec4(spec,spec,spec,0.));\n\t\t\t\treturn col;\n\t\t\t}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\t\n    vec2 sc = 2.*(uv-0.5);\n    \n    vec3 ro = vec3(0.18,0.2,-0.8);\n        \n    vec3 rd = normalize(vec3(sc,4)-ro);\n    \n    vec4 baccol = vec4((0.2+uv.y*0.5)*vec3(0.,1.,1.),1.);\n    \n    float t = raymarch(ro,rd);\n    \n\tvec4 col;\n\n\tif (t==-1.) {\n\t\tcol = baccol;\n\t}\n\telse{\n\t\tvec3 pos = ro+rd*t;\n\t\tcol = lighting(pos,ro);\n\t}\n \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlSDn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1111, 2215, 2240, 2240, 2347], [2352, 2352, 2381, 2381, 2648], [2655, 2742, 2789, 2789, 2836], [2847, 2876, 2907, 2907, 2936], [2945, 2970, 3000, 3000, 3313], [3317, 3353, 3390, 3390, 3522], [3527, 3567, 3594, 3594, 3781], [3788, 3819, 3842, 3842, 3981], [3987, 4084, 4121, 4121, 5054], [6190, 6279, 6310, 6310, 6521], [6606, 6626, 6674, 6674, 6898], [6906, 8037, 8065, 8065, 8793], [8857, 8904, 8940, 8940, 9408], [9412, 9412, 9469, 9469, 9908]]}
{"id": "3dlSRn", "name": "evolutive landscape height map", "author": "Myro", "description": "study on 3D perlin noise, drawing level lines on a map\n previously ... : https://www.shadertoy.com/view/3sfSRn", "tags": ["studyon3dperlinnoise", "drawinglevellinesonamap"], "likes": 3, "viewed": 128, "published": "Public", "date": "1550487278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D landscape height map generator made using noise\n\n// noise function from https://www.shadertoy.com/view/4sfGzS\n\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n//----------------------------------------\n\n\n// biome colors from \n// https://www.shadertoy.com/view/3sfSRn\n\n//return a color from a to b when h goes from m to n (and divide the color by 255)\nvec3 colormix (vec3 a, vec3 b, float h, float m, float n) {\n    return mix(a/255.0, b/255.0, (h-m)/(n-m));\n}\n               \n//return a color from a to b to c when h goes from m to n (and divide the color by 255)\nvec3 tricolormix (vec3 a, vec3 b, vec3 c,float h, float m, float n) {\n\tfloat t = (h-m)/(n-m);\n    if (t<0.5) {\n    \treturn mix(a/255.0, b/255.0,t*2.0);\n    }\n    else {\n    \treturn mix(b/255.0, c/255.0,(t-0.5)*2.0);\n    }\n}\n\nvec3 biomeColor (float h) {\n\n    //vec3 fog=vec3(197.0,219.0,211.0);\n    float oceanh = 0.2;\n    vec3 ocean1 =vec3(8.0,42.0,79.0);\n    vec3 ocean2 =vec3(23.0,79.0,114.0);\n    float seah = 0.32;\n    vec3 sea1 =vec3(6.0,104.0,133.0);\n    vec3 sea2 =vec3(56.0,104.0,133.0);\n    float bayh = 0.4;\n    vec3 bay1 =vec3(79.0,176.0,159.0);\n    vec3 bay2 =vec3(93.0,204.0,167.0);\n    float shoreh = 0.45;\n    vec3 shore1 =vec3(131.0,246.0,191);\n    vec3 shore2 =vec3(234.0,246.0,191);\n    float beachh = 0.5;\n    vec3 beach1 =vec3(210.0,173.0,128.0);\n    vec3 beach2 =vec3(255.0,236.0,181.0);\n    float fieldh = 0.74;\n    vec3 field1 =vec3(31.0,122.0,4.0);\n    vec3 field2 =vec3(140.0,191.0,28.0);\n    float dirth = 0.92;\n    vec3 dirt1 =vec3(154.0,148.0,9.0);\n    vec3 dirt2 =vec3(204.0,170.0,31.0);\n    float rockh = 0.97;\n    vec3 rock1 =vec3(133.0,140.0,112.0);\n    vec3 rock2 =vec3(72.0,114.0,104.0);\n    vec3 snow1 =vec3(197.0,219.0,211.0);\n    vec3 snow2 =vec3(224.0,255.0,255.0);\n\n    if (h<oceanh)    \treturn colormix(ocean1, ocean2,h,0.0,oceanh);\n    if (h<seah)     \treturn tricolormix(ocean2,sea1,sea2,h,oceanh,seah);\n    if (h<bayh)         return tricolormix(sea2, bay1, bay2,h,seah,bayh);\n    if (h<shoreh)       return tricolormix(bay2, shore1, shore2,h,bayh,shoreh);\n    if (h<beachh)       return colormix(beach1, beach2,h,shoreh,beachh);\n    if (h<fieldh)       return colormix(field1,field2,h,beachh,fieldh);\n    if (h<dirth)        return tricolormix(field2, dirt1, dirt2,h,fieldh,dirth);\n    if (h<rockh)        return tricolormix(dirt2, rock1, rock2,h,dirth,rockh);\n\telse/*snow*/\t\treturn tricolormix(rock2,snow1, snow2,h,rockh,1.0);\t\n}\n// ------------------------------------\n// ORIGINAL TO THIS SHADER \n\n\nconst float dh = 0.2; // delta height between 2 level lines\n\n\n// returns the height for a given point \n// (x,y : coordinates, z : noise time offset)\nfloat height( in vec3 x ) {\n    float octaveFreq = 2.0;\n    float octaveAmp = 0.8;\n    \n\tfloat h = 1.0-2.0*noise(x);\n    for (int i=1; i<3; i++) {\n\t\th += octaveAmp*(1.0-2.0*noise(x*octaveFreq));\n    \toctaveAmp *= octaveAmp;\n        octaveFreq *= octaveFreq;\n    }\n    return 0.5+h*0.5;\n}\n    \n// return 1 if x is beween min and max, else 0 \nfloat band(float min, float max, float x) {\n\treturn step(min,x)*(1.0-step(max,x));\n}\n\nfloat heightLines(vec3 x) {\n    float c = 0.0; // color to be returned (black or white)\n    float hmin = dh*fract(iTime*0.5);\n    for (float i=hmin-dh; i<hmin+1.0+dh; i+=dh) {\n    \tc += band(i, i+0.005,height(x));\n    }\n    return c;\n}\n\n\n// retuns a color for a given point on the map, and time offset\nvec3 getColor (vec2 uv, float t) {\n\treturn biomeColor(height(vec3(uv,t))) * (1.0- vec3(heightLines(vec3(uv,t))));\n}\n\n\nconst float SCALE = 3.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized screen pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    \n    vec2 mapuv = uv;// coordinate on the map\n    \n    if (iMouse.y <= 0.0) mapuv *= SCALE;\n    else mapuv *= SCALE *iMouse.y / iResolution.y;\n    \n    // vignette & vertical gradient\n    float postfx = 0.05*(uv.y)-0.02*length(uv)*length(uv);\n    // Output to screen\n    fragColor = vec4(getColor(mapuv+vec2(15.2,-8.2), iTime * 0.05) + postfx,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 117, 137, 137, 232], [234, 234, 260, 260, 734], [844, 927, 986, 986, 1035], [1052, 1140, 1209, 1209, 1363], [1365, 1365, 1392, 1433, 3014], [3147, 3234, 3261, 3261, 3521], [3527, 3575, 3618, 3618, 3659], [3661, 3661, 3688, 3688, 3896], [3899, 3963, 3997, 3997, 4078], [4107, 4107, 4164, 4222, 4627]]}
{"id": "3dlXD4", "name": "Spinning Gold Star", "author": "baldand", "description": "A spinning gold star", "tags": ["2d"], "likes": 2, "viewed": 290, "published": "Public API", "date": "1551295860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GLSL version of https://twitter.com/baldand/status/1100746090763247616\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.x;\n\tfloat l = length(uv);\n    float a = atan(uv.y,uv.x)+6.+iTime;\n\tfloat b = 1.256;\n\tfloat c = clamp((l*pow(cos(floor(.5+a/b)*b-a),4.)-.1)/-.005,0.,1.);\n\tfloat s = c*c*(3.-2.*c);\n\tvec3 v = s*vec3(.9,.9,0.)*(1.-l*3.);\n    fragColor = vec4(v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 132, 132, 439]]}
{"id": "3dS3Dm", "name": "[TWITCH] Studies on rupees", "author": "Flopine", "description": "This is the result of a live session on Twitch, you can see the progression here : https://www.twitch.tv/videos/373019927\n\nWant to try some Zelda rendering stuff again, on small objects this time :) Hope you'll enjoyed it", "tags": ["raymarching", "palette", "specular", "zelda", "fresnel"], "likes": 9, "viewed": 200, "published": "Public", "date": "1548977063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define time iTime\n#define ITER 64.\n#define PI 3.141592\n\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 25.18152)))*5418.548416);}\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a), -sin(a), cos(a));}\n\n\nfloat moda (inout vec2 p, float rep)\n{\n  float per = 2.*PI/rep;\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  float id = floor(a/per);\n  a = mod(a, per)-per/2.;\n  p = vec2(cos(a), sin(a))*l;\n  // condition on the id can be found in mercury lib : http://mercury.sexy/hg_sdf/\n  if (abs(id) >= (rep/2.)) id = abs(id);\n\treturn id;\n}\n\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(max(q.x, max(q.y, q.z)),0.) + length(max(q,0.));\n}\n\n\nfloat plane (vec3 p, vec3 n, float dist)\n{return dot(p,normalize(n))-dist;}\n\n\nfloat crystal (vec3 p)\n{\n  p.xz *= rot(time*0.5);\n  p.yz *= rot(time*0.8);\n  float b = box(p, vec3(.5, 0.7, 0.15));\n  p = abs(p);\n  float p1 = plane (p, vec3(0.7,1.,0.7), 0.5);\n  float p2 = plane (p, vec3(1.,0.,0.8), 0.3);\n  float d = max(p2,max(b,p1));\n  return d;\n}\n\n\nvec2 SDF (vec3 p)\n{\n  p.xy *= rot(time*0.1);\n  float id_crystal = moda(p.xy, 3.);\n  p.x -= 1.+sin(time)*0.2+0.1;\n  return vec2(crystal(p), id_crystal);\n}\n\n\nvec3 palette (float uv)\n{\n  if (uv < -0.33) return vec3(8.,0.,0.5);\n  if (uv >= -0.33 && uv < 0.3) return vec3(0.,.8,0.3);\n  if (uv >= 0.3) return vec3(0.,0.,.8);\n}\n\n\nvec3 get_normals(vec3 p)\n{\n  vec2 eps = vec2(0.01,0.);\n  return normalize(vec3(SDF(p+eps.xyy).x - SDF(p-eps.xyy).x,\n                        SDF(p+eps.yxy).x - SDF(p-eps.yxy).x,\n                        SDF(p+eps.yyx).x - SDF(p-eps.yyx).x\n                        )\n                  );\n}\n\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+.5;}\n\n\nvec3 point_light (vec3 p, vec3 n)\n{\n  vec3 lpos = vec3(0.,0., 1.);\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = dot(n , ldir)* 0.5 +0.5;\n  return (vec3(0.4,0.4,0.1)*dotNL) / (0.5 * ldist * ldist);\n}\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(-time*.2);\n  return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*5.)))*vec3(0.4);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n \tuv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = random(uv);\n\n    vec3 ro = vec3(0.001,0.001, -4.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    float fre = 0.;\n    for (float i=0.; i<ITER;i++)\n    {\n        vec2 d = SDF(p);\n        if (d.x<0.01)\n        {\n            // get the normals\n            vec3 n = get_normals(p);\n            // declare a directionnal light\n            vec3 l = vec3(0.,1.,-2.);\n\n\t\t\t// albedo from a palette ranged with id's of rupees\n            col  =  palette(d.y);\n            \n            // get the global lighting\n            float _lighting = lighting(n, l);\n            col += mix(vec3(0.1), vec3(0.6,0.5,0.), _lighting);\n            \n            // get the point light\n            vec3 point = point_light(p,n);\n            col += point;\n            \n            // calculate the fresnel\n            fre = pow(1.-clamp(dot(-rd, n),0.,1.), 4.5);\n            col += fre*palette(d.y+5.)*1.5;\n            \n            // half vector for specular\n            vec3 h = normalize(l-rd);\n            // calculate the specular\n            float spe = pow(max(dot(h,n) ,0.), 15.);\n            col += spe*_lighting;\n            \n            // fake AO\n            shad = i/ITER;\n            col *= (1.-shad);\n\n            break;\n        }     \n        if (d.x>10.)\n        {\n            col = pales(uv);\n            break;\n        } \n\t\t\n        d.x *= 0.9 + dither*0.1;\n        p+=d.x*rd;\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dS3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 249, 273, 273, 341], [344, 344, 364, 364, 409], [412, 412, 450, 450, 747], [750, 750, 778, 778, 863], [866, 866, 908, 908, 941], [944, 944, 968, 968, 1211], [1214, 1214, 1233, 1233, 1367], [1370, 1370, 1395, 1395, 1534], [1537, 1537, 1563, 1563, 1822], [1825, 1825, 1858, 1858, 1894], [1897, 1897, 1932, 1932, 2131], [2133, 2155, 2177, 2177, 2275], [2279, 2279, 2334, 2334, 3967]]}
{"id": "3dS3DV", "name": "Complex Plotter", "author": "Rinku", "description": "Plots a complex function.", "tags": ["math"], "likes": 3, "viewed": 92, "published": "Public", "date": "1549980664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The input is a complex number with the x-axis as the real\n// part and the y-axis as the imaginary part.\n//\n// The output number is displayed by a color where\n// hue is the argument and the brightness is the magnitude.\n\n// -----------------------------------------------------------\n\n// Constants\nconst float pi = 3.14159265359;\nconst float pi2 = 2.0 * 3.14159265359;\nconst float piD3 = 3.14159265359 / 3.0;\n\n// -----------------------------------------------------------\n\n// Viewport\n\n// X scale\nconst float Xs = 3.0;\n// X offset\nconst float Xo = 0.0;\n// Y scale\nconst float Ys = 2.0;\n// Y offset\nconst float Yo = 0.0;\n\nconst mat3 view = mat3\n(\n\tXs ,0.0,Xo,\n    0.0,Ys ,Yo,\n    0.0,0.0,1.0\n);\n\n// -----------------------------------------------------------\n\n// Math operations for complex numbers\n\nvec2 CxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 CxSquare(vec2 a)\n{\n    return vec2(a.x*a.x - a.y*a.y, 2.0*a.x*a.y);\n}\n\nvec2 CxCon(vec2 a)\n{\n    return vec2(a.x,-a.y);\n}\n\nfloat CxAbs(vec2 a)\n{\n    return sqrt(dot(a,a));\n}\n\nfloat CxPhase(vec2 a)\n{\n    return mod(atan(a.y,a.x),pi2);\n}\n\nvec2 CxPolarize(vec2 a)\n{\n    return vec2(CxPhase(a),CxAbs(a));\n}\n\nvec2 CxDiv(vec2 a, vec2 b)\n{\n    return CxMul(a,CxCon(b))/dot(b,b);\n}\n\nvec2 CxExp(vec2 a)\n{\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\n\nvec2 CxLog(vec2 a)\n{\n    a = CxPolarize(a);\n    return vec2(log(a.y),a.x);\n}\n\nvec2 CxPow(vec2 a, vec2 b)\n{\n    return CxExp(CxMul(CxLog(a),b));\n}\n\n// -----------------------------------------------------------\n\n// Engine\n\nvec3 h1(float h)\n{\n    return vec3\n    (\n        clamp(abs(3.0-h/piD3) - 1.0,0.0,1.0),\n        clamp(2.0 - abs(2.0-h/piD3),0.0,1.0),\n        clamp(2.0 - abs(4.0-h/piD3),0.0,1.0)\n    );\n}\n\nvec3 h2(float h)\n{\n    return vec3\n    (\n        (1.0 + cos(h))/2.0,\n        (1.0 + cos(h - 2.0*piD3))/2.0,\n        (1.0 + cos(h - 4.0*piD3))/2.0\n    );\n}\n\nvec3 v1(vec3 a, float v)\n{\n    a *= 1.0 - abs(2.0*v-1.0);\n    \n    if(v > 0.5) a += vec3(2.0*v - 1.0);\n    \n    return clamp(a,0.0,1.0);\n}\n\nvec3 v2(vec3 a,float v)\n{\n    vec3 r = vec3(v*v);\n    r-= 2.0*v*(v-1.0)*a;\n    return r;\n}\n\n// Color from hue and value\nvec3 Color(float h,float v)\n{\n    // H gives a color from hue\n    // H1 is sharper\n    // H2 is smoother\n    vec3 a = h2(h);\n    \n    // V modifies the brightness off a color generated by H\n    // V1 is sharper\n    // V2 is smoother\n    return v1(a,v);\n}\n\nvec3 ComplexColor(vec2 a)\n{\n    a = CxPolarize(a);\n    return Color(a.x,1.0 - 1.0/(1.0 + a.y));\n}\n\n// Gets mouse coordinates\nvec2 m()\n{\n    vec2 M = 2.0*(iMouse.xy/iResolution.xy-0.5);\n    return (vec3(M,1.0) * view).xy;\n    \n}\n\n// -----------------------------------------------------------\n\n\n// This is the function used for plotting.\n// Feel free to change it.\nvec2 f(vec2 x)\n{\n    vec2 x2 = x-m();\n    vec2 x3 = x-vec2(cos(iTime),sin(iTime));\n    \n    vec2 v = CxDiv(x3,x2);\n    return CxMul(x,v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = (vec3(uv,1.0) * view).xy;\n\t\n    vec2 p = f(uv);\n    \n    vec3 col = ComplexColor(p);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dS3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[761, 801, 829, 829, 882], [884, 884, 907, 907, 958], [960, 960, 980, 980, 1009], [1011, 1011, 1032, 1032, 1061], [1063, 1063, 1086, 1086, 1123], [1125, 1125, 1150, 1150, 1190], [1192, 1192, 1220, 1220, 1261], [1263, 1263, 1283, 1283, 1330], [1332, 1332, 1352, 1352, 1408], [1410, 1410, 1438, 1438, 1477], [1543, 1554, 1572, 1572, 1740], [1742, 1742, 1760, 1760, 1896], [1898, 1898, 1924, 1924, 2036], [2038, 2038, 2063, 2063, 2128], [2130, 2158, 2187, 2262, 2412], [2414, 2414, 2441, 2441, 2511], [2513, 2539, 2549, 2549, 2641], [2708, 2778, 2794, 2794, 2917], [2920, 2920, 2977, 2977, 3199]]}
{"id": "3dS3Rd", "name": "Gyroid Tunnelling", "author": "Polytrope", "description": "Panning through a raymarched gyroid with simple fresnel shading. Very much WIP.", "tags": ["raymarching", "gyroid"], "likes": 9, "viewed": 132, "published": "Public", "date": "1549643873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ZERO (min(iFrame,0))\n\n// Volumes\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat gyroid ( vec3 p, float s )\n{\n    return sin(p.x*s)*cos(p.y*s) + sin(p.y*s)*cos(p.z*s) + sin(p.z*s)*cos(p.x*s);\n}\n\n// Ops\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec2 map( in vec3 pos )\n{\n    float d = sdBox( pos-vec3(0, 0, 0), vec3(1, 1, 1) );\n    \n    d = opS(d, sdBox(pos-vec3(0, 0, 0), vec3(0.5, 0.5, 2)));\n    \n    d = gyroid(pos, 1.0);\n    \n    return vec2(d, 1);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 1000.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // Sky color\n    vec3 col = vec3(0);\n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        float a = abs(dot( rd, nor ));\n        \n\t\tvec3 lig = normalize( vec3(-0.5, 0.5, -0.5) );\n        \n        vec3 hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        \n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n        \n\t\tvec3 lin = vec3(0.0);\n        //lin += 1.0*dif*vec3(1.0,1.0,1.0);\n        lin += 1.0*fre*vec3(1.00,1.00,1.00);\n        //lin += 0.50*bac*vec3(0.25,0.25,0.25);\n        \n\t\t//col += 9.00*spe*vec3(1.00,0.90,0.70);\n        \n        \n        col = lin;\n    }\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time\n\tfloat time = iTime;\n    \n    float spin = time * 0.5;\n    float bob = time * 0.5;\n    float pan = time * 0.5;\n\n    // pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // Camera\n    float ox = cos(spin)*5.0;\n    float oy = sin(bob)*2.0;\n    float oz = sin(spin)*5.0;\n    vec3 ro = vec3(ox, oy, oz);\n    vec3 ta = vec3(0, 0, 0);\n    \n    ro = vec3(pan, pan, -pan) + vec3(1, 0, 1);\n    ta = ro + vec3(1, 1, -1);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \n    // Render from origin, along direction\n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dS3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 42, 67, 67, 82], [84, 84, 119, 119, 145], [147, 147, 178, 178, 269], [271, 271, 305, 305, 389], [391, 399, 432, 432, 458], [460, 460, 490, 490, 523], [525, 525, 555, 555, 584], [586, 586, 610, 610, 742], [744, 744, 769, 769, 953], [955, 955, 987, 987, 1195], [1197, 1197, 1237, 1237, 1567], [1569, 1569, 1608, 1625, 2721], [2723, 2723, 2775, 2775, 2952], [2954, 2954, 3011, 3023, 3762]]}
{"id": "3dS3WG", "name": "simple 3d procedural ocean", "author": "public_int_i", "description": "raymarching a procedural ocean", "tags": ["procedural", "3d", "raymarch", "ocean"], "likes": 6, "viewed": 405, "published": "Public API", "date": "1549814952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define time iTime\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define lightDir normalize(vec3(.4,1,.2))\n#define light vec3(1,.9,.8)\n\n#define EPSILON 2e-2\n#define NORMAL_EPSILON 4e-2\n#define MIN_STEP 2e-2\n#define ITER 100\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvec4 background(vec3 rd) {\n    vec2 pc = rd.xz*(.5/(1.+abs(rd.y)));\n\t\n\tvec2 dp = pc*10.+cos((pc.yx-.5)*vec2(16,3)),\n        fp = floor(dp*.5),\n        rp = mod(dp,2.)-1.;\n\tfloat c = max(0.,(.9+.1*hash(fp.xyyx).x)-length(rp)*.8),\n\tm = 0.;\n\tfor (int i = 0; i < 3; i++) {\n\t\tm += max(0.,length(mod(abs(\n\t\tpc*(10.+float(i)*10.)+\n\t\tcos(float(i+2)/(1.+c*float(1+i))+abs(pc.yx-.5)*float(i*2+3)+float(i)*vec2(1.4,.6))*float(1+i*2)),\n\t\t2.)-1.));\n\t}\n\tc *= pow(m*.2,1./4.);\n\tc = pow(c,2.);\n\t\n\treturn mix(vec4(.1,.5,.9,1)+vec4(light,1)*4.*pow(max(0.,1.-length(rd-lightDir)),2.),vec4(1),c);\n}\n\nfloat twave(float v) {\n\tv = fract(abs(v));\n\treturn v*2.-max(0.,v*4.-2.);\n}\nfloat water(vec2 p) {\n\tfloat s = 0.;\n\tfor (int i = 2; i < 6; i++) {\n\t\tfloat fi = float(i);\n\t\ts += pow(twave((p*rot(fi*3.8263)).x/fi+fi*.673+time*.6/fi),1.5+fract(fi*2.864)*2.)*fi*.1;\n\t}\n\treturn s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,1)),\n\t\trp = vec3(0,3.+sin(time*.22)*1.5,0),\n\t\torp = rp;\n\trd.xz *= rot(time*.1);\n\t\n\tint i;\n\tfor (i = 0; i < ITER; i++) {\n\t\tfloat yd = rp.y-water(rp.xz);\n\t\tif (yd < EPSILON) break;\n\t\trp += rd*max(MIN_STEP,yd);\n\t}\n\t\n\tvec4 bg = background(rd);\n\tif (i >= ITER) {\n\t\tfragColor = bg;\n\t} else {\n\t\trp -= rd*MIN_STEP*2.;\n\t\trp += rd*(rp.y-water(rp.xz));\n\t\tfloat bd = water(rp.xz);\n\t\tvec3 nrm = normalize(vec3(water(rp.xz+vec2(NORMAL_EPSILON,0))-bd,NORMAL_EPSILON,water(rp.xz+vec2(0,NORMAL_EPSILON))-bd)),\n\t\t\tdcol = vec3(.04,.15,.4),\n\t\t\tscol = vec3(.22,.5,.6)*pow((1.-max(0.,dot(rd,nrm))),2.);\n\t\tfloat dl = (.5+.5*dot(nrm,lightDir))*(.3+.7*pow(max(0.,dot(rd,nrm)),4.));\n\t\tfragColor = mix(vec4(dcol*light*dl+scol*background(reflect(rd,nrm)).xyz,1),\n\t\t\t\t\t\t\tbg,\n\t\t\t\t\t\t\tclamp(length(rp-orp)/50.-0.3,0.,1.));\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 309, 328, 328, 429], [431, 431, 457, 457, 1009], [1011, 1011, 1033, 1033, 1085], [1086, 1086, 1107, 1107, 1284], [1287, 1287, 1344, 1344, 2213]]}
{"id": "3dSGDc", "name": "Raymarch sphere and box", "author": "darkeclipz", "description": "raymarching with a sphere and a box", "tags": ["raymarch"], "likes": 2, "viewed": 115, "published": "Public", "date": "1550088582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 64.\n#define MinDistance 0.01\n#define eps 0.0001\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 1.5;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdYPlane(vec3 p, float y) { return p.y - y; }\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n        \n    float sphere1 = sdSphere(p - vec3(1,0,0) * cos(iTime), 0.3);\n    float sphere2 = sdSphere(p - vec3(0,1,0) * cos(iTime), 0.3);\n    float sphere3 = sdSphere(p - vec3(0,0,1) * cos(iTime), 0.3);\n    \n    float box = sdBox(p, vec3(.5));\n    float outerSphere = sdSphere(p + 0.001*texture(iChannel0, p.xz).xyz, .65);\n    \n    box = max(box, outerSphere);\n    \n    float res = box;\n    \n    float spheres = sphere1;\n    spheres = min(spheres, sphere2);\n    spheres = min(spheres, sphere3);\n    \n    res = smin(spheres, res, .1);\n    \n    return res;\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                  k.yyx*scene( p + k.yyx*h ) + \n                  k.yxy*scene( p + k.yxy*h ) + \n                  k.xxx*scene( p + k.xxx*h ) );    \n    return n;\n}\n    \nfloat march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = scene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;  \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 8.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n       \n    mat3 rot = rotateY(iTime);\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, rot*vec3(3), 10., vec3(.9,.1,.1));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, rot*vec3(-3), 10., vec3(.9,.1,.1));\n    \n    vec3 diffuse = vec3(.1);\n    \n    return L1 + L2 + diffuse;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.5,.5,.5);\n    vec3 ro = vec3(0,1,-5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n    mat3 rot = rotateY(-3.1415/3.);\n    ro *= rot;\n    rd *= rot;\n    \n    float t = march(ro, rd);\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 118, 118, 225], [227, 305, 331, 331, 711], [731, 731, 755, 777, 1032], [1034, 1034, 1061, 1061, 1147], [1149, 1149, 1182, 1182, 1206], [1207, 1207, 1240, 1240, 1258], [1259, 1259, 1288, 1288, 1344], [1346, 1377, 1418, 1418, 1511], [1513, 1513, 1534, 1534, 2092], [2094, 2094, 2119, 2119, 2384], [2390, 2390, 2421, 2421, 2652], [2654, 2721, 2828, 2828, 3585], [3587, 3587, 3625, 3625, 3893], [3895, 3895, 3952, 3952, 4351]]}
{"id": "3dSGWG", "name": "vib ribbon", "author": "yasuo", "description": "There's no answer, any time, any place.", "tags": ["playstation"], "likes": 10, "viewed": 437, "published": "Public API", "date": "1549808420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define rot2D(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// 2d distance functions from http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nvec4 map(vec3 p){\n    float d = udQuad(p, vec3(-3.5, 2.5, 1.0), vec3(-3.5, -2.5, 1.0), vec3(3.5, -2.5, 1.0),vec3(3.5, 2.5, 1.0));\n    return vec4(vec3(1.0),d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    mat3 camRotY = matRotateY(radians(sin(iTime*0.5)*10.0));\n    \n\tvec3 ro=vec3(0.,0.0,-0.3);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 20; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n        if(t>30.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n    vec2 uvRef = distPos.xy;\n    \n\tfloat n0 = noise(iTime*0.01)*0.05;\n    float n1 = noise(iTime*1.0)*0.06;\n    float n2 = noise(iTime*1.5)*0.05;\n    float n3 = noise(iTime*2.0)*0.04;\n    float n4 = noise(iTime*2.5)*0.03;  \n    \n    // bg color\n    vec3 col = vec3(0.0);\n    \n    // line color and size\n    vec4 lineCol = vec4(1.0);\n\tfloat lineSize = 0.005;\n    \n    /* particle??? */\n    vec2 ppos = vec2(0.5,0.8);  \n    \n    float pnum = 7.0;\n    for(float i = 0.0; i<pnum; i++){\n        float deg = i*(270.0/pnum)-(iTime*150.0);\n    \tfloat ex = cos(radians(deg))*0.6;\n        float ey = sin(radians(deg))*-0.15;\n        \n        float size = (cos(radians(deg))*0.05)+0.02+(((pnum-1.0)-i)*0.001)+n0;\n        float size2 = (-sin(radians(deg))*0.05)+0.02+(((pnum-1.0)-i)*0.001)+n0;\n        \n        mat2 rot = rot2D(radians(i*sin(iTime*1.0)*2.0));\n        vec2 ep = vec2(ex,ey)*rot;\n        vec2 p0 = (vec2(ep.x+size2, ep.y+size));\n        vec2 p1 = (vec2(ep.x-size2, ep.y-size));\n        \n        col = line( col, p0+ppos, p1+ppos, uvRef, vec2(lineSize,lineSize), lineCol);\n    }\n    \n    /* chara */\n    vec2 cpos = vec2(-1.0,0.1+sin(iTime*6.0)*0.02);\n    float moveSpeed = 3.5;\n    \n    // head\n    col = line( col, vec2(-0.08+n0, 0.2)+cpos, vec2(0.08+n0, 0.2)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.08+n0, 0.2)+cpos, vec2(-0.15+n1, 0.1)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.15+n1, 0.1)+cpos, vec2(-0.08+n0, 0.0)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.08+n0, 0.0)+cpos, vec2(0.08+n0, 0.0)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n\tcol = line( col, vec2(0.08+n0, 0.2)+cpos, vec2(0.15+n2, 0.1)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.15+n2, 0.1)+cpos, vec2(0.08+n0, 0.0)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    // ear\n    vec2 earWeightPos = vec2(sin(iTime*2.0)*0.02,sin(iTime*2.0)*0.01);\n    col = line( col, vec2(-0.3+n0, 0.4+n0)+cpos+earWeightPos, vec2(0.0, 0.2)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.3+n0, 0.4+n0)+cpos+earWeightPos, vec2(-0.45+n0, 0.55+n0)+cpos+earWeightPos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.45+n0, 0.55+n0)+cpos+earWeightPos, vec2(-0.3+n0, 0.5+n0)+cpos+earWeightPos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.3+n0, 0.5+n0)+cpos+earWeightPos, vec2(0.0, 0.2)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    vec2 earWeightPos2 = vec2(sin(iTime*1.5)*0.05,sin(iTime*1.5)*0.01);\n    col = line( col, vec2(-0.2+n0, 0.5+n0)+cpos+earWeightPos2, vec2(0.0, 0.2)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.2+n0, 0.5+n0)+cpos+earWeightPos2, vec2(-0.23+n0, 0.65+n0)+cpos+earWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.23+n0, 0.65+n0)+cpos+earWeightPos2, vec2(-0.13+n0, 0.55+n0)+cpos+earWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.13+n0, 0.55+n0)+cpos+earWeightPos2, vec2(0.0, 0.2)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    // eye\n    float num = 8.0;\n    vec2 epos = vec2(0.1+n0*0.5,0.17+sin(iTime*6.0)*0.02+n0*0.5)+cpos;\n    float prevEx = 0.06;\n    float prevEy = -0.05;\n    for(float i = 0.0; i<num; i++){\n        float deg = i*(360.0/num)+30.0;\n    \tfloat ex = cos(radians(deg))*0.03;\n        float ey = sin(radians(deg))*0.03;\n        \n        deg = i*(360.0/num);\n\t\tfloat ex2 = cos(radians(deg))*0.08;\n        float ey2 = sin(radians(deg))*0.08;\n        \n        col = line( col, vec2(ex, ey)+epos, vec2(ex2, ey2)+epos, uvRef, vec2(lineSize,lineSize), lineCol);\n        \n        deg = i*(360.0/num)-30.0;\n    \tex = cos(radians(deg))*0.03;\n        ey = sin(radians(deg))*0.03;\n        col = line( col, vec2(ex, ey)+epos, vec2(ex2, ey2)+epos, uvRef, vec2(lineSize,lineSize), lineCol);\n        \n        col = line( col, vec2(prevEx, prevEy)+epos, vec2(ex2, ey2)+epos, uvRef, vec2(lineSize,lineSize), lineCol);\n        \n        prevEx = ex2;\n        prevEy = ey2;\n    }\n    \n    // body\n    col = line( col, vec2(0.0+n0, 0.0)+cpos, vec2(-0.02+n0, -0.3)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.02+n0, -0.3)+cpos, vec2(0.02+n0, -0.3)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n\tcol = line( col, vec2(0.02+n0, -0.3)+cpos, vec2(0.0+n0, 0.0)+cpos, uvRef, vec2(lineSize,lineSize), lineCol);\n\n    // arm left\n    vec2 armWeightPos = vec2(sin(iTime*moveSpeed)*0.12,0.0);\n    vec2 armWeightPos2 = vec2(0.03+sin(iTime*moveSpeed)*0.17,0.0);\n    col = line( col, vec2(0.0+n0, 0.0)+cpos, vec2(0.0+n0, -0.15)+cpos+armWeightPos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.15)+cpos+armWeightPos, vec2(0.0+n0, -0.25)+cpos+armWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.+n0, -0.25)+cpos+armWeightPos2, vec2(0.02+n0, -0.25)+cpos+armWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    // arm right\n    armWeightPos = vec2(sin(iTime*moveSpeed)*-0.12,0.0);\n    armWeightPos2 = vec2(0.03+sin(iTime*moveSpeed)*-0.17,0.0);\n    \n    col = line( col, vec2(0.0+n0, 0.0)+cpos, vec2(0.0+n0, -0.15)+cpos+armWeightPos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.15)+cpos+armWeightPos, vec2(0.0+n0, -0.25)+cpos+armWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.25)+cpos+armWeightPos2, vec2(0.02+n0, -0.25)+cpos+armWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    // leg left\n\tvec2 legWeightPos = vec2(sin(iTime*moveSpeed)*-0.1,0.0);\n    vec2 legWeightPos2 = vec2(-0.07+sin(iTime*moveSpeed)*-0.17,0.0);\n\n    col = line( col, vec2(0.0+n0, -0.3)+cpos, vec2(0.0+n0, -0.45)+cpos+legWeightPos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.45)+cpos+legWeightPos, vec2(0.0+n0, -0.6)+cpos+legWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.6)+cpos+legWeightPos2, vec2(0.02+n0, -0.62)+cpos+legWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    // leg right\n    legWeightPos = vec2(sin(iTime*moveSpeed)*0.1,0.0);\n    legWeightPos2 = vec2(-0.07+sin(iTime*moveSpeed)*0.17,0.0);\n    \n    col = line( col, vec2(0.0+n0, -0.3)+cpos, vec2(0.0+n0, -0.45)+cpos+legWeightPos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.45)+cpos+legWeightPos, vec2(0.0+n0, -0.6)+cpos+legWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(0.0+n0, -0.6)+cpos+legWeightPos2, vec2(0.02+n0, -0.62)+cpos+legWeightPos2, uvRef, vec2(lineSize,lineSize), lineCol);\n    \n    \n    /* road */\n    vec2 rpos = vec2(0.0,-0.55);\n    uvRef.x += iTime;\n    uvRef.x = mod(uvRef.x,3.0)-3.0;\n    \n\tcol = line( col, vec2(-3.0, 0.0)+rpos, vec2(-2.9, -0.3+n1)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-2.9, -0.3+n1)+rpos, vec2(-2.8, 0.0)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-2.8, 0.0)+rpos, vec2(-2.8, 0.0)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-2.8, 0.0)+rpos, vec2(-1.5, 0.0)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-1.5, 0.0)+rpos, vec2(-1.4, -0.3+n2)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-1.4, -0.3+n2)+rpos, vec2(-1.3, 0.0+n1)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-1.3, 0.0+n1)+rpos, vec2(-1.2, -0.3+n3)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-1.2, -0.3+n3)+rpos, vec2(-1.1, 0.0+n2)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-1.1, 0.0+n2)+rpos, vec2(-1.0, -0.3+n4)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-1.0, -0.3+n4)+rpos, vec2(-0.9, 0.0)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n    col = line( col, vec2(-0.9, 0.0)+rpos, vec2(0.0, 0.0)+rpos, uvRef, vec2(lineSize,lineSize), lineCol);\n\n\tvec3 color;\n\tif(t < 30.){\n\t\tcolor = distCl.xyz*col;\n\t}else{\n        // bg\n        color = vec3(0.0);\n\t}\n\n\t// rendering result\n\tvec3 dst = color;\n\tfragColor = vec4(dst, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 257, 257, 331], [333, 438, 463, 463, 482], [483, 483, 539, 539, 1179], [1181, 1181, 1230, 1230, 1340], [1342, 1342, 1422, 1422, 1556], [1558, 1558, 1575, 1575, 1719], [1721, 1721, 1777, 1777, 10430]]}
{"id": "3dSGz3", "name": "Chaos Static", "author": "Shoseki", "description": "Just a bunch of static", "tags": ["2dstatic"], "likes": 2, "viewed": 381, "published": "Public API", "date": "1549442615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ok so UV is the 0.0 - 1.0, 0.0 = 1.0 of the space\n    \n    float minRes = iResolution.x;\n    if (iResolution.y < minRes) minRes = iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / minRes;    \n    \n    // Define the color it would be if it was 100% succesful\n    float r = rand(uv * sin(iTime)), g = rand(uv * cos(iTime)), b = rand(uv * tan(iTime));\n    \n    // For reference\n    // fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 93], [95, 95, 152, 209, 620]]}
{"id": "3dSGzG", "name": "Shooting Gallery", "author": "Flopine", "description": "just a use case of my rupees :D Not the best shader I did so far but it's the more complex I think. ", "tags": ["raymarching", "texture", "specular", "zelda", "fresnel", "3pointlighting"], "likes": 12, "viewed": 377, "published": "Public", "date": "1549107823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n\n#define MAT_FCRYSTAL 0.\n#define MAT_MCRYSTAL 1.\n#define MAT_BCRYSTAL 2.\n#define MAT_BACK 3.\n#define MAT_PEDESTRAL 4.\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n    return p;\n}\n\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n    else return b;\n}\n\n// iq function for signed hexagone\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y, q.z))) + length(max(q,0.));\n}\n\n\nfloat plane (vec3 p, vec3 n, float dist)\n{return dot(p,normalize(n))-dist;}\n\n\nfloat crystal (vec3 p)\n{\n  p.xz *= rot(iTime*2.);\n  float b = box(p, vec3(.5, 0.7, 0.15));\n  p = abs(p);\n  float p1 = plane (p, vec3(0.7,1.,0.7), 0.5);\n  float p2 = plane (p, vec3(1.,0.,0.8), 0.3);\n  float d = max(p2,max(b,p1));\n  return d;\n}\n\n\nvec2 middle_crystal (vec3 p)\n{return vec2(crystal(vec3(p.x, p.y-sin(iTime)*2.-1., p.z-2.)),MAT_MCRYSTAL);}\n\n\nvec2 back_crystals (vec3 p)\n{\n    p.x += sin(iTime*0.2)*8.;\n    p.yz -= vec2(4., 3.);\n    p.x = abs(p.x);\n    p.x -= 1.; \n    return vec2(crystal(p),MAT_BCRYSTAL);\n}\n\n\nvec2 front_crystals (vec3 p)\n{\n    p *= 1.4;\n    p.x = abs(p.x);\n    p.x -= 1.5;\n\tp.yz += vec2(0.5, 3.3);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(0.8,0.6);\n    return vec2(crystal(p)/1.4, MAT_FCRYSTAL);\n}\n\n\nvec2 scenery (vec3 p)\n{\n    vec3 pp = p;\n    p.xy *= rot(PI/6.);\n    float hex = -sdHexPrism(p, vec2(10.));\n    \n    p = pp;\n    p.y += 2.;\n    float g = abs(p.y)-0.5;\n    \n    return vec2(min(hex,g),MAT_BACK);\n}\n\n\nvec2 pedestrals (vec3 p)\n{\n    p.y += 2.;\n    float b1 = box(vec3(p.x,p.y, p.z+4.), vec3(10.,1., 1.));\n    \n    p.z -= 2.;   \n    float b2 = box(vec3(p.x,p.y,p.z), vec3(4.,1.4,2.));    \n    float b3 = max(-box(p, vec3(1.,10.,1.)),box(vec3(p.x, p.y-2., p.z),vec3(1.5,.5,1.5)));\n    return vec2(min(b3,min(b2,b1)), MAT_PEDESTRAL);\n}\n\n\nvec2 SDF (vec3 p)\n{return mat_min(pedestrals(p),mat_min(back_crystals(p),mat_min(front_crystals(p),mat_min(scenery(p), middle_crystal(p)))));}\n\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy).x-SDF(p-eps.xyy).x,\n                         SDF(p+eps.yxy).x-SDF(p-eps.yxy).x,\n                         SDF(p+eps.yyx).x-SDF(p-eps.yyx).x\n                         )\n                    );\n}\n\n\nvec3 tex (sampler2D chan, vec2 uv)\n{\n    vec3 t = texture (chan, uv).rgb;\n    // apply a gamma correction as I do an inverse gamma at the end\n    t = pow(t,vec3(2.2));\n    return t;\n}\n\n// triplanar mapping without the weights on normals\n// See here for more info : https://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\nvec3 triplanar(vec3 pos, vec3 normal, sampler2D channel, float uvscale) \n{\n    // adding a pixellate effect on the textures\n    float detail = 9.;\n    pos = floor(pos*detail)/detail;\n    \n    vec2 uvx = pos.yz*uvscale;\n    vec2 uvy = pos.xz*uvscale;\n    vec2 uvz = pos.xy*uvscale;\n    vec3 texx = tex(channel,uvx);\n    vec3 texy = tex(channel,uvy)*vec3(0.5,0.8,0.2);\n    vec3 texz = tex(channel,uvz);\n    vec3 blends = abs(normal);\n    return texx*blends.x+texy*blends.y+texz*blends.z;\n}\n\n// iq harmonic palette\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\n\nvec3 front_crystal_color (float id)\n{return palette (id, vec3(0.5), vec3(0.8), vec3(.7), vec3(0.5,0.7,0.1));}\n\n\nvoid crystal_shading (inout vec3 color, vec3 n, vec3 l, vec3 rd)\n{\n    // fresnel\n    float fre = pow(clamp(1.-dot(-rd,n),0.,1.), 4.);\n    color += fre* color*3.;\n    \n    // specular\n    vec3 h = normalize(l-rd);\n    float spe = pow(max(0.,dot(h,n)),7.);\n    color += spe*0.8;\n}\n\n\nvec3 point_light (vec3 p, vec3 n, vec3 lpos, float att)\n{\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = dot(n , ldir)* 0.5 +0.5;\n  return (vec3(1.,1.,0.7)*dotNL) / (att * ldist * ldist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.001,1.,-6.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    // tha albedo will change with the material id\n    vec3 alb = vec3(0.);\n    float shad = 0.;\n    \n    for (float i =0.; i<ITER; i++)\n    {\n        vec2 d = SDF(p);\n        if (d.x<0.001)\n        {\n            vec3 normal = get_normals(p);\n            vec3 light = vec3(3., 6., -6.);\n            \n            if (d.y == MAT_FCRYSTAL) \n            {\n                // reaaaaally dirty hack to retrieve a fake id\n                float id = floor(fract((p.x+.19)*0.17)*5.) *0.25;\n                alb = front_crystal_color(id);\n            }\n                \n            if (d.y == MAT_MCRYSTAL) \n            {\n                alb = vec3(0.1,0.4,0.1);\n            }\n            if (d.y == MAT_BCRYSTAL) \n            {\n              alb = vec3(0.5,0.1,0.1);\n            }\n            if (d.y == MAT_BACK) \n            {\n            \talb = triplanar(p,normal, iChannel0, 0.3);    \n            }\n            if (d.y == MAT_PEDESTRAL) \n            {\n            \talb = triplanar(p,normal, iChannel1, 0.5);  \n            }\n            // three-point lighting... kind of\n            col += point_light(p,normal, vec3(-5.,4.,5.), 0.02)*alb;\n            col += point_light(p,normal, vec3(5.,4.,5.), 0.02)*alb;\n            col += point_light(p,normal, vec3(-1.,4.,-1.), 0.04)*alb;\n            \n            // adding specular and fresnel only on crystals\n            if(d.y != MAT_PEDESTRAL && d.y != MAT_BACK)\n            \tcrystal_shading(col, normal, light, rd);\n            \n            // will be use to add fake AO\n            shad = i/ITER;\n            break;\n        } \n        p += d.x*rd;\n    }\n    \n    // Fake AO\n    col *= 1.-shad;\n    \n    // fog\n    float t = length(ro-p);\n    col = mix(col, vec3(0.3,0.2,0.2), 1.-exp(-0.006*t*t));\n\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 349, 369, 369, 412], [415, 415, 441, 441, 502], [505, 505, 536, 536, 583], [585, 620, 656, 656, 939], [942, 942, 969, 969, 1058], [1061, 1061, 1103, 1103, 1136], [1139, 1139, 1163, 1163, 1381], [1384, 1384, 1414, 1414, 1490], [1493, 1493, 1522, 1522, 1658], [1661, 1661, 1691, 1691, 1864], [1867, 1867, 1890, 1890, 2079], [2082, 2082, 2108, 2108, 2412], [2415, 2415, 2434, 2434, 2557], [2560, 2560, 2587, 2587, 2850], [2853, 2853, 2889, 2889, 3036], [3038, 3198, 3272, 3321, 3685], [3687, 3710, 3766, 3766, 3797], [3800, 3800, 3837, 3837, 3909], [3912, 3912, 3978, 3993, 4191], [4194, 4194, 4251, 4251, 4417], [4420, 4420, 4477, 4527, 6518]]}
{"id": "3dSGzy", "name": "Cloudy Julia", "author": "aiekick", "description": "clcik and maintain for mandelbrot, release for julia", "tags": ["julia", "cloudy"], "likes": 5, "viewed": 315, "published": "Public API", "date": "1549124711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define MANDELBROT\n\n#define lim 20.\n\nfloat shape(vec2 z)\n{\n\tfloat t = iTime;\n\tz *= mat2(cos(t),-sin(t),sin(t), cos(t));\n\t//float _dot = dot(z,z);\n\tfloat _quad = max(abs(z.x),abs(z.y));\n\tfloat _tri = max(abs(z.x)+z.y,-z.y);\n\treturn abs(mix(_quad, _tri, 0.5))+17.;\n}\n\nvoid mainImage( out vec4 f, vec2 z )\n{\n    f.xyz=iResolution;\n    z = (z+z-f.xy)/f.y;\n    vec2 g = z-z; // julia\n    \n    if (iMouse.z > 0.) g = z; // mandelbrot\n    \n   \tz -= g;\n    for (int i=0;i<23;i++)\n    {\t\n        if (shape(z) < lim)\n        \tz = mat2(z,-z.y,z.x) * z + g -\n    \t\t\t(iMouse.z>0. ? \n            \t \tvec2(0.5,0.) : // center mandelbrot\n            \t \tvec2(1,.3)); // julia\n\t}\n \n\tfloat l = log(log(length(z))/log(sqrt(lim)))*0.8;\n\t\n\tf.rgb = cos(l+vec3(0.636,0.978,0.598));\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 60, 60, 266], [268, 268, 306, 306, 762]]}
{"id": "3dsSWN", "name": "Many Spinning Mono Star-Flowers", "author": "baldand", "description": "Many spinning mono star-flowers", "tags": ["2d"], "likes": 4, "viewed": 335, "published": "Public API", "date": "1551298430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Variant of https://www.shadertoy.com/view/3dlXD4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    uv *= 9.;\n    vec2 ix = floor(uv)-vec2(3.,-2.);\n    uv = fract(uv)-.5;\n\tfloat l = length(uv);\n    float a = atan(uv.y,uv.x)+6.+iTime;\n\tfloat b = 6.282/floor(ix.y);\n\tfloat s = smoothstep(.2,.205,pow(cos(floor(.5+a/b)*b-a),ix.x)*l);\n\tvec3 v = vec3(s);\n    fragColor = vec4(v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 110, 110, 437]]}
{"id": "3dsXWH", "name": "Colorful Cell Noise", "author": "IsaacAndersen", "description": "Playing around with Cell Noise from The Shader Book, trying to build some cool color patterns.", "tags": ["test"], "likes": 7, "viewed": 265, "published": "Public", "date": "1551313546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nvoid mainImage( out vec4 O, in vec2 U) {\n\n    float t = iTime/3.0;\n    //float t2 = PI*(floor(t/5.0) + cubicInOut(fract(t/5.0)));\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = 1.25*(U-0.5*R)/R.y;\n    \n    //uv *= 1.2 + 0.4*sin(t2);\n    \n    //float angle = t2;\n    \n    //uv *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    uv *= 5.0;\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n\n    vec3 col = vec3(0);\n    \n    float mD = 10.0;\n    \n    vec2 thisPoint = random2(id);\n    \n    vec2 cellID = vec2(0,0);\n    \n    for (int k = 0; k < 25; k++) {\n        vec2 offs = vec2(k%5-2,k/5-2);\n        \n        vec2 neighborPos = random2(id+offs)+offs;\n        \n        neighborPos += cos(2.0*t + 6.2831*neighborPos);\n\n        vec2 diff = gv-neighborPos;\n        \n        float d = length(diff);\n        \n        if (mD > d) {\n            mD = d;\n            cellID = fract(neighborPos);\n        }\n    }\n    \n    vec3 colorGrad = 1.5*vec3(smoothstep(-5.,5.,uv.x),\n                          0,\n                          smoothstep(5.,-5.,uv.x)); \n\n    vec3 cellGrad = vec3(0,sin(PI*cellID.y),0);\n    \n    vec3 mixStuff = colorGrad;\n    \n    vec3 mixed = mix(cellGrad, colorGrad, colorGrad); \n    \n    \n    col += smoothstep(1.5,0.,mD)*mixed;\n    \n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 45, 45, 138], [140, 140, 167, 167, 251], [253, 253, 293, 293, 1537]]}
{"id": "3dXSDH", "name": "[twitch] Corroded Beasts", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl", "tags": ["3d", "raymarching", "live", "twitch"], "likes": 62, "viewed": 1510, "published": "Public", "date": "1551132995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fractal(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat map(vec3 p) {\n\n  \n  float t1 = time;\n  float o = noise(p*3.0 + t1*0.2);\n  p += (noise(p*10.0 + t1*0.7)-0.5)*0.1;\n  p += tunnel(p);\n  \n  float s=10.0;\n  p.xy = (fract(p.xy/s-0.5)-0.5)*s;\n\n  vec3 p1=p;\n  p1.xy *= rot(p.z*0.2+sin(p.z*1.8)*0.2 + t1*0.1);\n  \n  p1=moda(p1.xzy, 5.0, 0.0);\n  float d = cyl(p1.xz-vec2(1,0),0.0+o*0.3-0.1)+0.1;\n  \n  vec3 p2=p;\n  p2.xy *= rot(p.z*1.2+sin(p.z*0.8)*0.3 + t1*0.13);\n  \n  p2=moda(p2.xzy, 9.0,sin(p2.z)*0.9);\n  float d2 = cyl(p2.xz-vec2(1.3,0),0.05);\n  \n  d=smin(d, d2, 0.9);\n  \n  return d;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat dots(vec3 p, float j) {\n  float v=0.0;\n  \n  p*=4.0+1.0*sin(j);\n  p.x += rnd(floor(p.y));\n\n  p*=PI;\n  v += clamp(0.1-length(vec2(sin(p.x),cos(p.y))),0.0,1.0)*10.3;\n  return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0.0,0.0,-3);\n  vec3 t=vec3(0,0,0);\n  float t2 = time*0.5;\n  s.x += sin(t2*0.7)*0.5;\n  s.y += sin(t2*0.9)*0.5;\n\n  s.z += t2;\n  t.z += t2;\n  s -= tunnel(s);\n  t -= tunnel(t);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  int i=0;\n  float mask=1.0;\n  float d = 10000.0;\n\n  float rand=rnd(uv);\n  float dither=0.5+0.1*rand;\n  \n  for(; i<MARCH_STEPS; ++i) {\n    d=map(p);\n    if(abs(d)<0.001) {\n      mask=0.0;\n      break;\n    }\n    p+=r*d*dither;\n  }\n\n  vec3 col=vec3(0);\n  vec3 n = norm(p);\n  vec3 l =normalize(vec3(-0.2,0.2,0.5));\n  float t1=sin(time*0.2);\n  l.xz *= rot(t1);\n  l.xy *= rot(t1*3.2);\n  vec3 h = normalize(l-r);\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  float fog = pow(1.0-float(i)/100.0,2.0);\n\n  float aodist=0.7;\n  float ao = getao(p,n,aodist*0.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n\n  vec3 back = mix(vec3(0.7,0.2,0.1), vec3(1,0.7,0.2), pow(max(0.0,dot(r,l)),5.0));\n\n  float diff = fractal(p*15.0);\n  //diff=abs(diff-0.3)*2;\n  diff=pow(smoothstep(0.1,0.9,diff),5.0)*2.7+0.9;\n  \n  col += max(0.0,dot(n,l)*0.5+0.5) * fog * ao * (vec3(1,0.7,0.3) + pow(max(0.0,dot(n,h)),20.0));\n  col += vec3(0.7,0.2,0.1)*0.5*pow(n.y*0.5+0.5,3.0);\n  col += sss * fog * back * vec3(1,0.2,0.2) * 1.5 * diff;\n  col += 3.0*f*(-n.y*0.5+0.5)*fog;\n  \n  float len = length(p-s);\n  col += back * max(clamp(d,0.0,1.0), clamp(dot(p-s,p-s)/200.0,0.0,1.0));\n\n  vec3 col2 = vec3(0);\n  for(int j=1; j<PART_COUNT; ++j) {\n    float dist = float(j) * 0.2/r.z;\n    if(dist>len) break;\n    vec3 vp = vec3(s.x,s.y,0) + r*dist;\n    vp.xy *=rot(sin(vp.z*10.0+time*0.2));\n    \n    col2 += dots(vp, float(j)) * clamp(1.0-dist/float(PART_COUNT), 0.0,1.0);\n  }\n  col += col2 * back;\n\n  col *= pow(clamp(1.2-length(uv),0.0,1.0)*1.3,1.7);\n  //col = vec3(rnd(uv));\n  \n  fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 338, 366, 366, 390], [392, 392, 433, 433, 601], [603, 603, 622, 622, 691], [693, 693, 714, 714, 1005], [1007, 1007, 1030, 1030, 1138], [1140, 1140, 1179, 1179, 1256], [1258, 1258, 1278, 1278, 1372], [1374, 1374, 1393, 1393, 1907], [1909, 1909, 1928, 1928, 2047], [2049, 2049, 2090, 2090, 2136], [2138, 2138, 2180, 2180, 2225], [2227, 2227, 2247, 2247, 2290], [2292, 2292, 2311, 2311, 2390], [2392, 2392, 2421, 2421, 2574], [2576, 2576, 2633, 2633, 4800]]}
{"id": "3dXSzM", "name": "Jelly Cubes", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarching"], "likes": 9, "viewed": 1014, "published": "Public", "date": "1550795804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat field(vec3 p)\n{\n    p.x -= 2.;\n    p.y += sin(p.z*.2+iTime)*2.;\n    p.y += cos(p.x*.2-iTime)*2.;\n    p.z += iTime;\n    p.xz = mod(p.xz+vec2(2.), 4.)-vec2(2.);\n    vec3 bp = abs(p) - 1.;\n    return min(max(max(bp.x, bp.y), bp.z), p.y+.9);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<228; ++i) {\n    \tfloat d = field(ro+rd*t);\n        if(d < .0001 || d > 200.) break;\n        t += d*.5;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(3.*pow(length(p), .001), 0.);\n    return normalize(vec3(\n    \tfield(p+eps.xyy) - field(p-eps.xyy),\n        field(p+eps.yxy) - field(p-eps.yxy),\n        field(p+eps.yyx) - field(p-eps.yyx)\n    ));\n}\n\nfloat getSss(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(float i=0.; i<2.; i+=.1) {\n    \tt += field(ro+rd*i);\n    }\n    return clamp(exp(t*.1), 0., 1.);\n}\n\nfloat getAo(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    ro += rd*.002;\n    int i;\n    for(i=0; i<64; ++i) {\n    \tfloat d = field(ro+rd*t);\n        if(d < .001 || d > 100.) break;\n        t += d;\n    }\n    return float(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 cam = vec3(0, 2, 6);\n    vec3 dir = normalize(vec3(uv, -1));\n    dir.yz *= rot(.2);\n    cam.z -= iTime*5.;\n    dir.xz *= rot(iTime*.1);\n    float d = march(cam, dir);\n    vec3 col = vec3(0.);\n    if(abs(uv.y) < .85) {\n        col = vec3(.2, .06, .1) * uv.y+.25;\n\n        if(d < 100.) {\n            vec3 p = cam+dir*d;\n            vec3 normal = getNormal(p);\n            col += vec3(.5, .2, .2) * (pow(1.-max(0., dot(normal, -dir)), .6));\n            col = vec3(1.)-pow(col, vec3(.1));\n            float ss = getSss(p, dir);\n            col += .2*vec3(pow(ss, .5));\n            float ao = getAo(p, normal);\n            col *= vec3(1.-ao/428.);\n            col += .5*vec3(.3, .2, .4) * (pow(max(0., dot(normal, normalize(vec3(-2., 2., 2.)))), 2.));\n            col += .5*vec3(1., .1, .3) * (pow(max(0., dot(normal, normalize(vec3(-2., 2., -2.)))), 2.));\n            col = mix(col, vec3(.27, .24, .25), d/100.);\n        }\n        col = pow(col, vec3(2));\n    }\n\n    // Output to screen\n    col *= 1.-length(uv)*.4;\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 118, 118, 342], [344, 344, 375, 375, 537], [539, 539, 563, 563, 781], [783, 783, 815, 815, 939], [941, 941, 972, 972, 1162], [1164, 1164, 1221, 1221, 2354]]}
{"id": "3dXXDN", "name": "TorusKnot 2", "author": "gaz", "description": "3d", "tags": ["knot", "raymarchig"], "likes": 5, "viewed": 160, "published": "Public", "date": "1551272781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat deTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat lengthN(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nvec3 knot(float t)\n{\n  t *= 6.283;\n\treturn vec3(\n    sin(t)+2.0*sin(2.0*t),\n    cos(t)-2.0*cos(2.0*t),\n    -sin(3.0*t)\n  );\n}\n\nvec3 torusKnot(float t)\n{\n    //return knot(t);\n    t *= 6.283;\n    vec3 p = 0.6*vec3(cos(t*5.0),sin(t*5.0),0);\n    p.x += 1.5;\n    p.xz *= rotate(t*3.0);\n    return p;\n}\n\nfloat deTorusKnot(vec3 p)\n{\n    float ITR = 40.0, pitch = 1.0, t = 0.5, de = 1e10;   \n    for(int j=0; j<2; j++)\n    {\n        float t0 = t-pitch*0.5;\n        pitch /= ITR;\n        for(float i=0.0; i<=ITR; i++) \n        {\n            t0 += pitch;\n            float de0 = distance(p,torusKnot(t0));\n            if (de0<de)\n            {\n                de = de0;\n                t=t0;\n            }       \n        }\n    }\n    vec3 u = normalize(torusKnot(t));\n    vec3 v = normalize(torusKnot(t+0.01)-torusKnot(t-0.01));\n    vec3 w = normalize(cross(u,v));\n    u = cross(v,w);\n    p -= torusKnot(t);\n    p = vec3(dot(p,w), dot(p,u), dot(p,v));       \n    return lengthN(vec2(length(p.yz), p.x), 3.0)-0.25;\n}\n\nfloat map(in vec3 p)\n{   \n    p.xz *= rotate(iTime*0.3);\n    p.xy *= rotate(iTime*0.5);\n    return  deTorusKnot(p);\n    return  min(deTorusKnot(p),deTorus(p,vec2(1.5,0.12)));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 e = vec2(1,-1)*0.05;\n    return normalize(\n        e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+ \n        e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 q = fract(abs(uv*0.5)+iTime*0.2+vec2(0,0.6));\n    vec3 col = 0.3* textureLod(iChannel0, \n    \t5.0 * vec2(1.0/length(uv), atan(q.y,q.x) * 0.8),\n        0.0).xyz;\n    col = pow(col,vec3(1.5,0.8,0.7));\n    col *= smoothstep(-1.0, 2.5, length(uv));\n    vec3 ro = vec3(\n        sin(iTime*0.3+0.3*sin(iTime*0.3)),\n        cos(iTime*0.2+0.5*cos(iTime*0.8)), \n        6.0+2.0*sin(iTime*0.4+0.7*sin(iTime*0.7)));\n    vec3 rd = normalize(vec3(uv, -2.0));\n    float ITR=100.0, t=0.0, d, a=1.0, maxd=20.0, st=1.0/ITR;\n    for(float i = 0.0; i < ITR; i++)\n    {\n        t += d = map(ro+rd*t);\n        if(d<0.001 || t>maxd) break;\n        a -= st;\n    }\n    if(t<maxd)\n    {\n        vec3 p = ro+t*rd;\n     \tvec3 li = normalize(vec3(1));\n        vec3 nor = calcNormal(p);\n\t\tcol = vec3(0.9, 0.4, 0.2);\n        col *= a*a*a; \n\t    col *= clamp(dot(nor,li),0.4,1.0);\n        col *= max(0.5+0.5*nor.y,0.0);\n        col += pow(clamp(dot(reflect(rd, nor),li),0.0,1.0),80.0);\n        col = pow(col,vec3(0.6));\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 80], [82, 82, 113, 113, 178], [180, 180, 212, 212, 270], [272, 272, 292, 292, 397], [399, 399, 424, 446, 569], [571, 571, 598, 598, 1277], [1279, 1279, 1301, 1301, 1455], [1457, 1457, 1485, 1485, 1635], [1637, 1637, 1694, 1694, 2797]]}
{"id": "3dXXzr", "name": "Unlimited Blade Works", "author": "yasuo", "description": "Try to make it looks like one of the key visual from Japanese animation called the Fate Stay Night.", "tags": ["fate"], "likes": 6, "viewed": 346, "published": "Public API", "date": "1550419770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sword(vec3 p){\n    float sc = 4.0;\n    vec3 refP = (p+vec3(0.0,-0.17*sc,0.0))*matRotateX(radians(90.0));\n    vec2 h = vec2(0.02*sc,0.01*sc);\n  \tvec2 d = abs(vec2(length(refP.xz),refP.y)) - h;\n    float d0 = sdBox(p,vec3(0.01*sc,0.17*sc,0.01*sc));\n    float d1 = sdBox(p+vec3(0.0,-0.08*sc,0.0),vec3(0.06*sc,0.01*sc,0.01*sc));\n    float d2 = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return opSmoothUnion(opSmoothUnion(d0,max(-(length(p)-0.085*sc),d1),0.01*sc),d2,0.001*sc); \n}\n\nfloat sdGear( vec3 p, vec2 h )\n{\n    float r = (length(p)-0.65);\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float len = 0.93;\n\tfloat resd = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    float res2d = max(-r,resd);\n    float b = sdBox(p,vec3(0.07,0.015,len));\n    float b2 = sdBox(p,vec3(len,0.015,0.07));\n    float b3 = sdBox(p*matRotateY(radians(30.0)),vec3(len,0.015,0.07));\n    float b4 = sdBox(p*matRotateY(radians(-30.0)),vec3(len,0.015,0.07));\n    \n    float b5 = sdBox(p*matRotateY(radians(60.0)),vec3(len,0.015,0.07));\n    float b6 = sdBox(p*matRotateY(radians(-60.0)),vec3(len,0.015,0.07));\n    \n    float res3d = max(-b,res2d);\n    float res4d = max(-r,min(min(min(min(min(b,b2),b3),b4),b5),b6));\n  \treturn min(res3d,res4d);\n}\n\nvec4 map(vec3 p){\n    float animateZ = iTime*0.5;\n    vec3 refP = p;\n    refP.z += animateZ;\n    refP.y += 2.5;\n    refP.x = mod(refP.x,3.0)-1.5;\n    refP.z = mod(refP.z,3.0)-1.5;\n    \n    float sd = sword((refP+vec3(0.0,(sin(p.x)*cos(p.z))*0.15,-0.5))*matRotateY(radians(20.0))*matRotateZ(radians(10.0)));\n    \n    refP = p;\n    refP.z += 1.5+animateZ;\n    refP.y += 2.5;\n    refP.x += 1.0;\n    refP.x = mod(refP.x,3.0)-1.5;\n    refP.z = mod(refP.z,3.0)-1.5;\n    float sd2 = sword((refP+vec3(0.0,(sin(p.x)*cos(p.z))*0.15,-0.5))*matRotateY(radians(-20.0))*matRotateZ(radians(-10.0)));\n    refP = p;\n    \n    refP.z += animateZ;\n    refP.y -= 0.7;\n    refP.x -= 1.5;\n    refP.x = mod(refP.x,4.0)-2.0;\n    refP.z = mod(refP.z,4.0)-2.0;\n    \n    mat3 rotX = matRotateX(radians(90.0));\n    float rad = radians(iTime*30.0);\n    float gear0 = sdGear(((refP+vec3(0.0,-0.3,-0.6))*rotX)*matRotateY(rad),vec2(0.8,0.015));\n    refP = p;\n    \n\trefP.z += 1.5+animateZ;\n    refP.y -= 2.5;\n    refP.x += 2.0;\n    refP.x = mod(refP.x,6.0)-3.0;\n    refP.z = mod(refP.z,6.0)-3.0;\n    float gear1 = sdGear(((refP+vec3(0.0,-0.5,-0.9))*rotX)*matRotateY(-rad),vec2(0.8,0.015));\n    \n    p.z += animateZ;\n    float n = cnoise(p.xz*1.5)*0.6;\n    vec3 floorCol = (vec3(n)+vec3(0.8,0.7,0.2))*0.9;\n    if(n<0.1){\n        p.y +=n*0.03;\n    \tfloorCol = vec3(0.8,0.7,0.2)+(n*0.2);\n    }\n    \n    p.y += (sin(p.x)*cos(p.z))*0.15;\n\n    vec4 res0 = vec4(floorCol*vec3(0.8,0.5,0.0),min(gear0,gear1));\n    vec4 res1 = vec4(floorCol,min(min(p.y+3.0,sd),sd2));\n    vec4 render = combine(res0,res1);\n    \n    return render;\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*30.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(0.8,0.55,0.15)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0)+(noise(p.x*p.y*iTime*0.1))*0.12;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 346, 368, 368, 442], [444, 444, 463, 463, 499], [500, 500, 521, 521, 558], [560, 560, 581, 581, 1658], [1660, 1660, 1696, 1696, 1755], [1757, 1757, 1809, 1809, 1908], [1910, 1910, 1941, 1941, 2029], [2031, 2031, 2051, 2051, 2518], [2520, 2520, 2552, 2552, 3264], [3266, 3266, 3283, 3283, 4853], [4855, 4855, 4878, 4878, 5128], [5130, 5130, 5164, 5164, 5414], [5416, 5416, 5472, 5472, 6665]]}
{"id": "3s23D3", "name": "Procedural color palettes", "author": "ircss", "description": "A procedural color pattern algo. Small write up on it here: https://link.medium.com/7Pe7frHduU", "tags": ["procedural", "colorpalettes", "colortheorem"], "likes": 4, "viewed": 770, "published": "Public API", "date": "1550747469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// procedural color idea. The geometry is based on code from The_ArtOfCode.\n\n#define iTime iTime*0.4\n#define _Color1 vec3(abs(cos(iTime+12.) + sin(iTime*0.7 + 71.124)*0.5),abs(cos(iTime) + sin(iTime*0.8 + 41.)*0.5) ,abs(cos(iTime+61.) + sin(iTime*0.8 + 831.32)*0.5))\n#define _Color2 vec3(abs(sin(iTime ) + sin(0.6 * iTime+ 21.)*0.5),abs(sin(iTime *0.9 +215.12) + sin(0.93 * iTime+ 52.231)*0.5),abs(sin(iTime+ 12.512 ) + sin(0.8 * iTime+ 58.15)*0.5))\n#define _Color3 vec3(abs(sin(iTime *0.58 +89.21) + sin(0.76 * iTime+ 7232.)*0.5),abs(sin(iTime *1.1 +0.124) + sin(0.5 * iTime+ 712.)*0.5),abs(sin(iTime+ 1.6) + sin(iTime *0.5 + 12.512) *0.5))\n\nfloat rand(vec2 seed){\n return fract(sin( dot(seed, vec2(21.41,13.2)) * 4.)*10.);   \n}\n\nfloat randOneD(float seed){\n    return fract(sin(seed*21.)*61.);\n}\n\n\nvec3 sampleOnATriangle(float r1, float r2 ){\n  return (1. - sqrt(r1))*_Color1 + (sqrt(r1)*(1. - r2))*_Color2\n\t\t\t\t+ (r2*sqrt(r1)) * _Color3;   \n}\n\n\nfloat Circles(vec2 uv, float tiling, out float seed, out float  edge){\n    \n    float m = 0.;\n    for(int x= -1; x<= 1; x++){\n        \n        for(int y = -1; y<= 1; y++){\n         \t\n            \n  \t\t\t  vec2 fracUV = fract(uv * tiling) + vec2(x,y);\n   \t\t\t  vec2 intUV = floor(uv * tiling) + vec2(x,y);\n   \t\t \n    \t\t  float rd = rand(intUV );\n              \tvec2 center = vec2( 0.5) ;\n                vec2 centerToPixel =  fracUV -center;\n   \t\t\t\t float angle = atan(centerToPixel.y, centerToPixel.x);\n    \t\t  \n    \t\t  float radius = 0.5+  0.4 * abs(sin(iTime * 0.8 )+ sin(iTime*1. + 51.215))\n                  + (abs(sin(angle*3. -iTime )+ sin(angle*4. +iTime))) * abs( sin(iTime) +sin(iTime*0.8 + 21.1256))*0.1;\n            \n          float seedController =  1.-smoothstep(radius, radius+0.0001,distance(fracUV, center ));\n  \t\t\t  m += seedController;\n            \n              edge *= 1.-smoothstep(0.03*1./(iResolution.x/600.), .00,abs(distance(fracUV, center )-radius));\n              seed += mix(0.,dot(intUV, vec2(21.214,6.214)), seedController); \n        }\n        \n    }\n    \n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(1.,1.,1.);\n    \n    float tiling = 5.;\n    \n    \n    float seed = 0.;\n    float edge = 1.;\n    float m = Circles(uv, tiling, seed, edge);\n\n    col.xyz = mix(sampleOnATriangle(randOneD(m+61. ), randOneD(m)),\n                  sampleOnATriangle(randOneD(m+1.+seed), randOneD(m+125.+seed)), mod(m, 2.));\n    col.xyz = mix(col.xyz, _Color1*0.7,1.-edge);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 643, 665, 665, 729], [731, 731, 758, 758, 797], [800, 800, 844, 844, 944], [947, 947, 1017, 1017, 2045], [2048, 2048, 2105, 2105, 2642]]}
{"id": "3s23Dc", "name": "[TWITCH] Infinite Spinal Squid", "author": "evvvvil", "description": "\"Infinite Spinal Squid\" - Shader showdown practice session 007.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 20:30 UK time.\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["sun", "time", "demoscene", "sky", "abstract", "limit", "live", "battle", "shadershowdown", "glare", "spine", "coding", "twitch", "showdown", "squid"], "likes": 14, "viewed": 674, "published": "Public API", "date": "1550169832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"Infinite Spinal Squid\" - Shader Showdown practice session 007\n\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 20:30 UK time I practise live on TWITCH.\n// This is the result of session 007. \n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"A squid eating dough in a polyethylene bag is fast and bulbous.\" - Captain Beefheart\n\nvec2 sc,e=vec2(0.00035,-.00035);float t,tt,att,su;vec3 np,pp; //Global fucking variables because we're internafuckingtional\n//Cheap fucking box function (actually stollen from UNC I think, not picking IQ's pockets on this one)\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//Still stolen from someone though, come on, I'm too cool to be that clever.\n\n//Simple 2d rotate function, nothing to see here, move along, find the angry mother and introduce her to DMT\nmat2 r2(float r) {return mat2(cos(r),sin(r),-sin(r),cos(r));}\n\n//Fucking bits function which makes the fucking bit/piece it is a base shape which we clone and repeate to create the whole geometry in mp function\nvec2 fb( vec3 p )//Base piece look like a train track, couple of parralel rectangles with some perpendicular ones in middle\n{\n  vec2 h,t=vec2(bo(abs(p)-vec3(2,0,0),vec3(0.3,0.3,10)),5); //t is the blue bits: 2 rectangles symetry cloned along the x axis\n  h=vec2(1000,3);//h is the black bits, we make it really high, just like me, so we can add shapes by using min function\n  for(int i=0;i<6;i++) {\n    h.x=min(h.x,bo(abs(p)-vec3(0,0,0.5*float(i)),vec3(2,0.1,0.1)));//keep adding one black rectangle per iteration and shift it\n    h.x=min(h.x,bo(abs(p)-vec3(2,0,0.5*float(i)),vec3(0.2,0.5,0.2)));//keep adding one smaller black rectangle per iteration and shift it\n  }\n  t.x=min(t.x,0.8*(length(p-vec3(0,0,6))-1.7));//this creates a sphere in between blue bits\n  t=(t.x<h.x)?t:h;\n  t.x*=0.5;//This make the shape more defined so that we don't get artifact (glitches that look like shit)\n  return t;\n}\n//Map function / scene / Where the geometry is made.\nvec2 mp( vec3 p )//We make a whole complex geometry based on one single piece defined in fb\n{//We do that by fucking with the position p in a new variable np(new position) then we pass np to fb\n\tp.xy*=r2(sin(p.z*.2)*.5+tt*.5);//This does an overall twist and constant rotation \n  \tnp=p;  //Told you we were gonna fuck with p in a new variable np, take fucking notes broski, this isn't your girlfriend's shitty yoga class\n  \tatt=length(p-vec3(0,0,sin(tt*2.)*20.))-5.;//We create reverse-attractor, it's a sphere that pushes the geometry out\n  \tnp.z=mod(p.z+tt*10.,15.)-7.5; //this make the geometry infinite along the z axis, because, yeah you guess right, Einstein, it's a fucking infinite squid\n  \tfor(int i=0;i<3;i++){\n    \tnp=abs(np)-vec3(0.2,0.2+att*0.2,0);//every loop iteration we push geometry out on x axis and depending on attractor on y axis\n    \tnp.xy*=r2((cos(np.z*.2*float(i))));//rotaroo the fuckeroo: we rotate  a bit more each iteration, making it more interesting\n  \t}\n  \tvec2 h,t=fb(np);//Now we finished fucking with p we pass it through fb to create the whole geom from one \"fucking bit\"\n\n  \tpp=abs(p)-vec3(3.2,1.+sin(p.z*0.2),0)-att*0.2;//we create one more new position this time called pp and it's gonnu be for the splines + cubes\n  \tpp.z=mod(pp.z-tt*10.,4.)-2.;//make this pp splines and cube infiintie on z axis again\n  \t\n  \th=vec2(bo(pp,vec3(0.2+att*0.03)),6);//h is gonna be the hollow cubes - one box minus one sphere\n \th.x=max(-(length(pp)-(0.3+att*0.03)),h.x);//boolean operation removes sphere from cube\n  \th.x*=0.7;//make them cubes more defined so we dont get artifacts\n  \tt=(t.x<h.x)?t:h;//This mixes the squid inner geometry with the cubes\n  \th=vec2(bo(pp,vec3(0.1+att*0.01,0.1+att*0.01,30)),5);//Here, broh, the fucking splines, yeah, stick, around, it, all\n  \th.x*=0.8;//more definition less fucking artifact, more pumped pecs, more lasting impression on girls\n\tt=(t.x<h.x)?t:h;//mixes rest with the splines\n\treturn t;\n}\n\n//Main raymarching loop with material ID flex, because driving on the wrong side of the motorway is more fun while sniffing glue!\nvec2 tr( vec3 ro,vec3 rd )\n{\n\tvec2 h,t=vec2(0.1);//0.1 is our near plane\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);//get result of running map function at this ray pos\n        if(h.x<.0001||t.x>50.) break;//Get out early if we hit geom (<precision which is 0.0001) or we hit far plane (t.x>50)\n        t.x+=h.x;t.y=h.y;//t.y=h.y passes the material ID\n    }\n    if(t.x>50.) t.x=0.;//if we hit far plane then make result 0 to do \"some\" optimization\n    return t;//always return this return that, you're a fucking broken record you know that?\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1);//Boilerplate code building uvs by default in BONZOMATIC\n    //Modulo time because I fucking hate noisey sins or whatever the fuck glitches after certain time, hey? (stops it all getting fucking noisy)  \n    tt=mod(iTime*.5,100.);\n    \n   \tvec3 ro=vec3(14,7.+sin(tt*2.)*15.,5.+cos(tt)*15.), //Camera ro=ray origin, rd=ray direction, co=final color, fo=fog, ld=light direction\n    cw=normalize(vec3(0.)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,bk,ld=normalize(vec3(0.2,.2,-.5));//co=final color, fo=fogcolor, bk=backgroundColorm ld=light direction\n    su=clamp(dot(ld,rd),0.,1.);//Su=sun, feels good to play god again but fucking hell Pedro I didn't buy that glue for that.\n    bk=vec3(1,.5,0)*pow(su,4.)+vec3(0.5,.6,.6)-rd.y*0.4;//bk=background mix of sky + sun. Playing god again, fuck yeah there are no side effects to this drug.\n    co=fo=bk; //setting up default color as fog and background color\n\tsc=tr(ro,rd);t=sc.x;//sc=scene. We get the scene by shooting rays, big one this yeah, bigger than your ass look in those jeans. \n  if(t>0.){\n    //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I serenade them fuckin' angels.\n    vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yxy*mp(po+e.yxy).x+e.yyx*mp(po+e.yyx).x+e.xxx*mp(po+e.xxx).x),    \n    \n    //LIGHTING MICRO ENGINE BROSKI \n    //Default albedo is blue with gradient depending on distance to attractor. (al=albedo)\n    al=vec3(0,0.5+att*0.02,1);  \n\t//Different material id? Changeacolourooo... It's all very black and white, like when I'm right and you're wrong\n    if(sc.y<5.) al=vec3(0);\n    if(sc.y>5.) al=vec3(1);\n    float dif=max(0.,dot(no,ld)),//dif = diffuse because I dont have time to cook torrance\n    //ao = ambient occlusion, aor = ambient occlusion range\n    aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),    \n    //Fresnel blends the geometry in the background with some sort of gradient edge reflection colouring mother fucker\n    fre=pow(1.+dot(no,rd),4.); // yeah  maybe it should be reflected but who gives a shit broski, if you do then fuck you\n    //Fake sub surface scattering, sort of reverse ambient occlusion trick from tekf, big up tekf! https://www.shadertoy.com/view/lslXRj\n    vec3 sss=vec3(.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),\n    spec=vec3(.5)*pow(max(dot(reflect(-ld,no),-rd),0.),10.);//specular by shane. Even better than the feeling of stroking used tea bags\n    co=mix(spec+al*(.2+.8*ao)*(dif+sss),bk,min(fre,0.5));//Final result of color, crunching everything into an RGB shit sandwich\n\tco+=0.5*vec3(1,.5,0)*pow(su,3.);//Post processing sunglare effect: much better than being slapped across the face with a fish\n    co=mix(co,fo,1.-exp(-.00003*t*t*t));//Fog is lovely reminds me of dipping my hand in warm honey while watching angels get naked\n  }  \t\n  //Add some sort of tone mapping... but it's fake like a Hipster's craft beer trying to be a Belgian brew.\n  fragColor = vec4(pow(co,vec3(0.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[995, 1160, 1184, 1184, 1230], [1308, 1417, 1435, 1435, 1478], [1480, 1628, 1753, 1753, 2528], [2529, 2582, 2675, 2775, 4539], [4541, 4671, 4699, 4699, 5223], [5225, 5225, 5282, 5282, 8497]]}
{"id": "3s23Dm", "name": "MCG: Phong shading", "author": "tale3d", "description": "In this lecture we discuss vectors. ", "tags": ["teachingmaterial"], "likes": 0, "viewed": 87, "published": "Public", "date": "1549287231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Mathematics for Computer Graphics (CATA programme, 1st year)\n//Supplement material for the lecture \"Vectors\"\n\n//In this scene we have just one light source.\n//Belowe we set up the values for its ambient, diffuse and specular properties.\nvec3 ambient = vec3(0.05, 0.15, 0.2); //La\nvec3 diffuse = vec3(0.2, 0.6, 0.8); //Ld\nvec3 specular = vec3(1.0, 1.0, 1.0); //Ls\n\n\n//The main idea of this example: for pixels on the viewport we \"reconstruct\" \n// the sphere by setting the normal, light direction and so on to apply with Phong shading\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    \n    //The background colour is white by default\n    vec3 colour = vec3(1.0, 1.0, 1.0);\n    \n    //Setting up the light direction L\n    //Using trigonometric functions of time variable to make the light dynamic\n    //Note that sin^2(t) + cos^2(t) = 1, therefore |L| = 1, so the vector is defined as a unit vector\n    //No need to normalize it then. \n    vec3 lightDir = vec3(0.0, abs(cos(iTime)), abs(sin(iTime)));\n   \n    //Recall that we apply this function (shader) for every pixel in our viewport.\n\n    //The pixels which are not on the sphere will be skipped. \n    //Now we can check that? In the geometry we know that a sphere projects to a circle\n    //A circle is a set of points equidistant from its centre\n    //Therefore the criteria is to check the distance between the coordinates of the pixel\n    //   and the centre. \n    //For simplicity reasons the centre point is the origin (0,0,0) and the radius is 1\n\n    //The next line simply tells us \"If the distance between c and (0) is less than 1\"\n    //That means we are going to set background colour for all the points which \n    //   do not satisfy this criteria\n    float dist_squared = c.x*c.x+c.y*c.y;\n    if (dist_squared < 1.0)\n    {\n        //Now we start shading part. First, we need to find the normal. \n        // It might seem tricky, as in some way we reconstruct \n        // the normal of the point from its projection.\n        \n        //But we know that the normal for the sphere \n        // in the given point is the same vector from the centre to the point \n        // and the length of this vector is 1.\n        //The xy coordinates of the normal are the same as the pixel coordinates,\n        // so we only need to find z, knowing that x*x+y*y+z*z=1\n        float nz = sqrt(1.0 - dist_squared);\n        \n        vec3 n = vec3(c.x, c.y, nz);\n        \n        //how about viewer? this vector is constant for all the pixels and points towards us\n\t\tvec3 v = vec3(0.0,0.0,-1.0);\n        \n        //one more vector we need to define is a reflection\n        //we are using unit vectors for n and l, so the equation becomes simple as\n        //r = l - 2(n.l)n\n        vec3 r = lightDir - n*2.0*dot(lightDir, n);\n        float rd = sqrt(r.x*r.x+r.y*r.y+r.z*r.z);\n        if (rd != 0.0) r /= rd;\n            \n        //ambient component is simple as colour times coefficient\n        float ka = 1.0;\n\t\tvec3 ia = ambient*ka;\n        \n        //diffuse component, we use dot product between light source and normal\n        float kd = 1.0;\n        vec3 id = diffuse*kd*dot(lightDir, n);\n        \n        //specular component, we use power of the dot product between viewer and reflection\n        float ks = 0.2;\n        float shininess = 64.0;\n//        float ref = clamp(pow(dot(r, v), shininess), -1.0, 1.0);\n\n\t\t//pow function does not work on older machines, so if you see wrong picture, comment the line above and uncomment below\n        float rdotv = dot(r, v);\n        float ref = rdotv*rdotv*rdotv*rdotv;\n        ref = ref*ref*ref*ref;\n\n        vec3 is = specular*ks*ref;\n        \n        //the final colour is a sum of three components\n        colour = ia+id+is;\n    }\n    //assign colour to the pixel\n\tfragColor = vec4(colour, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 537, 594, 941, 4393]]}
{"id": "3s23Dt", "name": "Raymarch IFS 3", "author": "darkeclipz", "description": "variation of https://www.shadertoy.com/view/3djGDt.", "tags": ["raymarch", "ifs"], "likes": 2, "viewed": 121, "published": "Public", "date": "1550283528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 100.\n#define MinDistance 0.01\n#define eps 0.001\n#define Iterations 22.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat DE(vec3 z)\n{\n    float angl = cos(iTime/4.)*.2;\n    //mat3 rx = rotateX(angl);\n    //mat3 ry = rotateY(angl);\n    mat3 rz = rotateZ(angl);\n    mat3 rot = rz;\n \n    float Scale = 2. + cos(iTime/8.);\n    float Offset = .65;\n    float n = 0.;\n    while (n < Iterations) {\n       z *= rot;\n       //if(z.x - z.y < 0.) z.yx = z.xy;\n       if(z.x + z.y < 0.) z.yx = -z.xy;\n       z *= rot;\n       if(z.x - z.z < 0.) z.xz = z.zx;\n        \n       //if(z.x + z.z < 0.) z.xz = -z.zx;\n       //if(z.y - z.z < 0.) z.yz = z.zy;\n       //if(z.y + z.z < 0.) z.yz = -z.zy;\n        \n       //if(z.y - z.z < 0.) z.yz = z.zy;\n       z *= rot;\n       z = abs(z);\n       z = z*Scale - vec3(vec3(Offset*(Scale-1.0)).xy, 0);\n       n++;\n    }\n    return (length(z) ) * pow(Scale, -float(n));\n}\n\nfloat scene(vec3 p) {\n\treturn DE(p - vec3(0,.1,0));\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p - vec3(0,.1,0));\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                  k.yyx*scene( p + k.yyx*h ) + \n                  k.yxy*scene( p + k.yxy*h ) + \n                  k.xxx*scene( p + k.xxx*h ) );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec2 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = scene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec2(t-MinDistance, 1.-i/MaxSteps);  \n        }\n    }\n    return vec2(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 32.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,5,0), 30., vec3(.9));\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,10), 30., vec3(.9,.9,.5));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(-5,1,-5), 20., vec3(.8,.8,.3));\n    vec3 ambient = vec3(.1);\n    return L1 + L2 + ambient + top;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,2.,-4); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateY(-iTime/4.);\n    ro *= rot;\n    rd *= rot;\n    \n    vec2 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        float shadow = marchShadow(p + 0.1*n, normalize(vec3(10,10,10) - p));\n        if(shadow > eps) {\n        \tcol = mix(col, vec3(0), .5);    \n        }\n        \n        float fog = 1. / (0.3 + t * t * 0.05);\n        col = mix(vec3(0), col, fog);\n    }\n    else {\n        vec3 topcolor = vec3(127./255., 161./255., 189./255.);\n        vec3 bottomcolor = vec3(84./255., 111./255., 138./255.);\n    \tcol = mix(bottomcolor, topcolor, uv.y);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 141, 141, 227], [229, 229, 256, 256, 342], [344, 344, 371, 371, 449], [451, 550, 568, 568, 1326], [1328, 1328, 1349, 1349, 1381], [1383, 1383, 1409, 1409, 1441], [1443, 1454, 1479, 1479, 1743], [1745, 1823, 1853, 1853, 2111], [2113, 2113, 2150, 2150, 2386], [2388, 2455, 2562, 2562, 3320], [3322, 3397, 3435, 3435, 3729], [3731, 3731, 3788, 3788, 4765]]}
{"id": "3s23RV", "name": "Cavitation", "author": "EnigmaCurry", "description": "Adapted from Bubble Rings by tdhooper - https://www.shadertoy.com/view/WdB3Dw\nMusic by EnigmaCurry", "tags": ["torus", "soundcloud"], "likes": 10, "viewed": 920, "published": "Public API", "date": "1549382367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cavitation - EnigmaCurry\n// Adapted from Bubble Rings by tdhooper - https://www.shadertoy.com/view/WdB3Dw\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a, float c, float t) {\n    p = cos(a+p.y+c*t) + sin(a+p.y)*p*vec2(acos(p.x/p.x), p.y);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 16.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Main SDF\n// https://www.shadertoy.com/view/wsfGDS\n// --------------------------------------------------------\n\nvec4 inverseStereographic(vec3 p, out float k) {\n    k = 2.0/(1.0+dot(p,p));\n    return vec4(k*p,k-1.0);\n}\n\nfloat fTorus(vec4 p4) {\n    float d1 = length(p4.xy) / length(p4.zw) - 2.;\n    float d2 = length(p4.zw) / length(p4.xy) - 22.;\n    float d = d1 < 0.9 ? -d1 : d2;\n    d /= PI;\n    return d;\n}\n\nfloat fixDistance(float d, float k) {\n    float sn = sign(d);\n    d = abs(d);\n    d = d / k * 1.82;\n    d += 1.;\n    d = pow(d, .5);\n    d -= 1.;\n    d *= 5./3.;\n    d *= sn;\n    return d;\n}\n\nfloat time;\n\nfloat map(vec3 p) {\n    float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.);\n    float k;\n    vec4 p4 = inverseStereographic(p,k);\n    float c = sin(iTime/22.) * fft;\n    float t = mod(iTime / 12., 333.);\n    pR(p4.zy, time * -PI / 2., c, t);\n    pR(p4.xw, time * -PI / 2., c, t);\n\n    // A thick walled clifford torus intersected with a sphere\n\n    float d = fTorus(p4);\n    d = abs(d);\n    d -= .2;\n    d = fixDistance(d, k);\n    d = smax(d, length(p) - 1.85, .2);\n\n    return d;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = mod(iTime / 1., 10.);\n\n    vec3 camPos = vec3(1.8, 5.5, -5.5) * 1.75;\n    vec3 camTar = vec3(.0,0.,.0);\n    vec3 camUp = vec3(-18,0,-5.5);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    float focalLength = 5.;\n    vec2 p = (-iResolution.xy + 2. * gl_FragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n    vec3 rayPosition = camPos;\n    float rayLength = 12.;\n\n    float distance = 0.;\n    vec3 color = vec3(0);\n\n    vec3 c;\n\n    // Keep iteration count too low to pass through entire model,\n    // giving the effect of fogged glass\n    const float ITER = 82.;\n    const float FUDGE_FACTORR = .8;\n    const float INTERSECTION_PRECISION = .001;\n    const float MAX_DIST = 20.;\n\n    for (float i = 0.; i < ITER; i++) {\n\n        // Step a little slower so we can accumilate glow\n        rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);\n        rayPosition = camPos + rayDirection * rayLength;\n        distance = map(rayPosition);\n\n        // Add a lot of light when we're really close to the surface\n        c = vec3(max(0., .01 - abs(distance)) * .5);\n        c *= vec3(1.4,2.1,1.7); // blue green tint\n\n        // Accumilate some purple glow for every step\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\n        c *= smoothstep(20., 7., length(rayPosition));\n\n        // Fade out further away from the camera\n        float rl = smoothstep(MAX_DIST, .1, rayLength);\n        c *= rl;\n\n        // Vary colour as we move through space\n        c *= spectrum(rl * 6. - .6);\n\n        color += c;\n\n        if (rayLength > MAX_DIST) {\n            break;\n        }\n    }\n\n    // Tonemapping and gamma\n    color = pow(color, vec3(1. / 1.8)) * 2.;\n    color = pow(color, vec3(2.)) * 3.;\n    color = pow(color, vec3(1. / 2.2));\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [{"id": "Xll3WH", "previewfilepath": "https://soundcloud.com/enigmacurry/deer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/enigmacurry/deer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 308, 358, 358, 424], [426, 426, 465, 465, 557], [560, 752, 820, 820, 864], [866, 866, 890, 890, 988], [991, 1165, 1213, 1213, 1271], [1273, 1273, 1296, 1296, 1463], [1465, 1465, 1502, 1502, 1655], [1670, 1670, 1689, 1689, 2177], [2180, 2314, 2364, 2364, 2507], [2509, 2509, 2564, 2564, 4417]]}
{"id": "3s23Ry", "name": "Raymarching Workshop - 2D Rings", "author": "trevortheblack", "description": "SDF, simple, copied from \nhttps://github.com/ajweeks/RaymarchingWorkshop", "tags": ["raymarching"], "likes": 2, "viewed": 91, "published": "Public", "date": "1549489835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TREVOR BLACK\n// LICENSE - There Ain't One\n// This is my take on the 2D raymarching from the RaymarchingWorkshop\n\n\n// Companion shader for Raymarching Workshop run at Electric Square\n// Workshop site: https://github.com/ajweeks/RaymarchingWorkshop\n\n// MIT license\n\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\n// -------------------------\n// SDF FUNCTION DECLARATIONS\nfloat sdSphere   (vec3 p, float s);\nfloat sdBox      (vec3 p, vec3 b);\nfloat sdPlane    (vec3 p, vec4 n);\nfloat sdCylinder (vec3 p, vec3 c);\nfloat sdTorus    (vec3 p, vec2 t);\nfloat sdRoundBox (vec3 p, vec3 b, float r);\nfloat sdCircle(vec2 p, vec2 pos, float radius);\nfloat sdRing(vec2 p, vec2 pos, vec2 radii);\n\n// -------------------------\n// SDF UTILITY DECLARATIONS\nfloat opU(float d1, float d2);\nfloat opBlend(float d1, float d2);\n\n\n// --------------------------\n// MAIN FUNCTION DECLARATIONS\nfloat sdf(vec2 p);\nvec2 screenToWorld(vec2 screen);\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d);\nvec3 shade(float sd);\n\n// compute pixel colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // project screen coordinate into world\n\tvec2 p = screenToWorld(fragCoord);\n    \n    // signed distance for scene\n    float sd = sdf(p);\n    \n    // compute signed distance to a colour\n    vec3 col = shade(sd);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\nvec2 screenToWorld(vec2 screen)\n{\n    vec2 result = 2.0 * (screen/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    t = clamp(t, 0., 1.);\n    return a + b*cos(6.28318*(c*t+d));\n}\nvec3 shade(float sd)\n{\n    float maxDist = 2.0;\n    vec3 palCol = palette(clamp(0.5-sd*0.4, -maxDist,maxDist), \n                      vec3(0.3,0.3,0.0),vec3(0.8,0.8,0.1),vec3(0.9,0.7,0.0),vec3(0.3,0.9,0.8));\n\n    vec3 col = palCol;\n    \n    // Darken around surface\n\tcol = mix(col, col*1.0-exp(-10.0*abs(sd)), 0.4);\n\t// repeating lines\n    col *= 0.8 - 0.2*cos(150.0*sd - sign(sd)*M_PI*5.0*iTime);\n    // White outline at surface\n    col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(sd)));\n    \n    return col;\n}\n\n// SDF \nfloat sdf(vec2 p)\n{\n\tfloat d = 1000.0;\n    \n    d = opBlend(d, sdRing(p, vec2(-0.15, -0.3), vec2(0.2, 0.55)));\n    d = opBlend(d, sdRing(p, vec2(1.6, -0.1), vec2(1.0,1.3)));\n    d = opBlend(d, sdRing(p, vec2(1.6, -0.1), vec2(0.4,0.7)));\n    d = opBlend(d, sdCircle(p, vec2(1.6, -0.1), 0.1));\n    \n    //d = opBlend(d, sdCircle(p, vec2(1.6, -0.1), 1.3));\n    \n    return d;\n}\n\n\n\n// -------------------------\n// SDF FUNCTION DEFINITIONS\n// -------------------------\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;   \n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y,d.z)), 0.0);\n}\n\nfloat sdPlane    (vec3 p, vec4 n)\n{ // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdCylinder (vec3 p, vec3 c)\n{\n    return length(p.xz-c.xy) - c.z;\n}\n\nfloat sdTorus    (vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdRoundBox (vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) - r +\n        min(max(d.x, max(d.y,d.z)), 0.0);                 \n}\n\nfloat sdCircle(vec2 p, vec2 pos, float radius)\n{\n    return length(p-pos)-radius;\n}\n\nfloat sdRing(vec2 p, vec2 pos, vec2 radii)\n{\n    vec2 pRingSpace = p - pos;\n    float dInner = radii.x - length(pRingSpace);\n    float dOuter = length(pRingSpace) - radii.y;\n    //return max(dInner, dOuter);\n    // smooth out sd in body of the ring\n    float dMax = max(dInner, dOuter);\n    /*\n    if(dMax < 0.0)\n    {\n        float dCenterBodyRing = length(pRingSpace) - 0.5*(radii.x+radii.y);\n        dCenterBodyRing = sqrt(dCenterBodyRing*dCenterBodyRing + 0.001); // 0.1 is an eps\n        dCenterBodyRing = dCenterBodyRing - 0.5*(radii.y-radii.x);\n        return dCenterBodyRing;   \n    }\n    */\n    return dMax;\n\n    \n    \n    //float dMax = max(dInner, dOuter);\n    //float width = radii.y - radii.x;\n    //float dMaxCenterAtOrigin = \n    //return sqrt( (dMax-width)*() + 0.0001f);\n    \n}\n// -------------------------\n\n// -------------------------\n// SDF Utility Library\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opBlend(float d1, float d2)\n{\n    float k = 0.2;\n    return sminCubic(d1, d2, k);\n}\n// --------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23Ry.jpg", "access": "shaders20k", "license": "mit", "functions": [[1059, 1083, 1140, 1184, 1394], [1397, 1397, 1430, 1430, 1551], [1552, 1552, 1622, 1622, 1689], [1690, 1690, 1712, 1712, 2207], [2209, 2217, 2236, 2236, 2591], [2595, 2681, 2714, 2714, 2742], [2744, 2744, 2773, 2773, 2876], [2878, 2878, 2913, 2937, 2971], [2973, 2973, 3008, 3008, 3046], [3048, 3048, 3083, 3083, 3157], [3159, 3159, 3203, 3203, 3326], [3328, 3328, 3376, 3376, 3411], [3413, 3413, 3457, 3457, 4207], [4291, 4327, 4371, 4371, 4449], [4451, 4451, 4482, 4482, 4508], [4510, 4510, 4545, 4545, 4599]]}
{"id": "3s23W3", "name": "Melted gold", "author": "bogciobo", "description": "Created by AI algorithm", "tags": ["gold"], "likes": 2, "viewed": 283, "published": "Public API", "date": "1550145470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(0.46739316,0.10106375,0.14717072,-0.11716786) + mat4(vec4(0.48127833008766174,0.4097188413143158,0.46360549330711365,0.9054418206214905),vec4(-0.4809762239456177,0.5844964385032654,0.24651221930980682,-0.5198274850845337),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(-0.65150195,-0.06600195,0.21747641,0.11008277) + mat4(vec4(-0.7398256659507751,0.632050633430481,-0.44727978110313416,-0.5230351686477661),vec4(0.10469664633274078,0.190241739153862,0.40628376603126526,-0.2692520022392273),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(0.036099013,-0.15141723,-0.2850344,-0.02592432) + mat4(vec4(-0.5606597661972046,0.4347532391548157,0.3871471583843231,1.3774549961090088),vec4(0.041218724101781845,-0.446368008852005,0.47220379114151,0.2764115333557129),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(-0.56090766,0.3253215,-0.15987036,0.24589254) + mat4(vec4(-0.41447463631629944,-0.5888586640357971,-0.7587273120880127,0.7405568361282349),vec4(0.5719470977783203,1.1678017377853394,-1.770374059677124,-0.08513271808624268),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.39340892,-0.1830564,0.33868536,-0.16627409) + mat4(vec4(-0.028786587,-0.107959986,0.20787494,-0.10575146),vec4(-0.117143534,0.20033398,0.12548123,-0.11354803),vec4(0.11027961,0.047793873,-0.0991201,-0.079572864),vec4(-0.23743369,-0.015524541,0.013527181,-0.017649975)) * bufB[0] + mat4(vec4(-0.013313093,0.024693016,-0.5634132,0.3681607),vec4(0.17280787,0.07657163,0.43377474,0.1493516),vec4(0.5698278,-0.2147641,-0.18433067,0.15444002),vec4(0.045239042,-0.026197093,0.21704176,0.21456291)) * bufB[1] + mat4(vec4(0.19257046,0.03692077,-0.16203678,-0.2957049),vec4(-0.17519842,-0.16077805,0.20003861,0.11179117),vec4(0.27913868,0.3977329,-0.22671014,0.019781962),vec4(-0.046554368,0.2501053,-0.16364847,0.030979343)) * bufB[2] + mat4(vec4(-0.14861284,-0.10395445,-0.14122714,-0.1901166),vec4(0.18111768,0.08085268,0.44521928,-0.6218651),vec4(-0.39006984,-0.24867593,0.12561198,0.16021846),vec4(0.16802919,-0.09217589,0.030530524,-0.24577326)) * bufB[3] + mat4(vec4(-0.04141602,0.08164458,-0.33299953,0.24468058),vec4(-0.20545487,0.18313438,0.063862644,-0.18370606),vec4(0.18767202,-0.16571996,0.39367345,0.025969805),vec4(-0.43804905,0.25293875,0.21155888,-0.11433667)) * bufB[4] + mat4(vec4(-0.043939296,-0.0023938795,-0.060358364,0.29846963),vec4(0.15389107,-0.098813206,0.028248886,0.044607274),vec4(-0.29265696,0.2333888,0.16624358,-0.12942658),vec4(0.06436506,0.09714263,0.27111524,0.11346116)) * bufB[5] + mat4(vec4(0.08513267,-0.26173893,-0.40963626,0.2779471),vec4(-0.46163654,0.22654967,-0.29837292,0.14202185),vec4(0.07452837,-0.10380114,0.38610488,-0.42486313),vec4(0.2752858,0.38077927,0.35220268,-0.05153779)) * bufB[6] + mat4(vec4(0.09604643,0.1875553,-0.50055677,0.1508651),vec4(-0.08545384,-0.022958305,0.025341993,-0.07743558),vec4(-0.087091595,0.30655095,-0.20363763,0.19458593),vec4(0.3717279,-0.057465855,-0.1291112,-0.107781164)) * bufB[7];\nbufA[1] = vec4(0.185086,0.12392797,0.23528352,0.24454077) + mat4(vec4(0.24385788,0.03911172,-0.101108454,0.40359122),vec4(-0.18352914,0.102519974,0.24531749,0.23356667),vec4(-0.34063327,0.20778248,-0.14265566,0.08254698),vec4(0.16992258,-0.017655348,0.5265773,0.06229786)) * bufB[0] + mat4(vec4(0.10770804,-0.23310553,-0.32351145,-0.30966073),vec4(-0.12667887,-0.18124056,-0.13485073,0.10890376),vec4(-0.019021673,-0.029838383,-0.17725343,-0.11447829),vec4(-0.22442688,0.11041222,0.058158156,-0.3040115)) * bufB[1] + mat4(vec4(-0.20799989,0.41156662,-0.00088859163,-0.11848102),vec4(0.21869248,0.07750995,0.20157209,0.071075015),vec4(-0.22536185,-0.38419694,0.08613047,0.055009827),vec4(-0.34242615,-0.09277983,-0.28063726,0.16130203)) * bufB[2] + mat4(vec4(-0.66957194,-0.10320356,-0.09150737,-0.053691115),vec4(-0.16421536,-0.038122654,-0.37486094,-0.20330279),vec4(0.039773468,-0.098758474,0.17477542,0.099081084),vec4(0.08648957,-0.28327885,0.16996913,0.3776789)) * bufB[3] + mat4(vec4(0.118371874,0.40733448,-0.017032143,-0.21719758),vec4(-0.4423304,0.03435323,0.455421,-0.052940518),vec4(0.05910543,-0.14246209,0.26043916,0.14420168),vec4(-0.036334086,0.03531106,0.22170329,-0.08298519)) * bufB[4] + mat4(vec4(0.38902193,0.32440612,0.022170765,-0.084785245),vec4(0.3608845,-0.020201987,0.1760477,0.078165546),vec4(-0.17307992,0.25608495,0.06698657,-0.034726482),vec4(-0.003570987,-0.43411964,0.67143846,-0.04543174)) * bufB[5] + mat4(vec4(0.10959516,-0.17852738,-0.22278997,-0.30120948),vec4(-0.14475463,-0.02436351,0.108218245,-0.004788089),vec4(-0.20618562,-0.67725325,-0.041163772,0.25650483),vec4(0.29288897,-0.23237087,0.30536962,0.057358827)) * bufB[6] + mat4(vec4(0.13095406,0.2743996,0.055557504,-0.05729672),vec4(-0.29766437,-0.33835852,-0.22713174,0.09789729),vec4(0.06137779,0.02106528,-0.04653497,0.090590745),vec4(0.14693253,0.23532617,0.42647022,0.1469806)) * bufB[7];\nbufA[2] = vec4(0.5089846,-0.2300395,0.17164198,0.7300682) + mat4(vec4(-0.01254305,-0.004707474,0.0112586655,0.3220053),vec4(0.23486288,-0.032334443,-0.062248114,-0.2450318),vec4(0.21517289,-0.29295626,-0.3013266,-0.24366027),vec4(0.12892944,-0.10590222,0.30816972,-0.1486229)) * bufB[0] + mat4(vec4(-0.05959917,0.49133655,0.30963364,-0.48855788),vec4(0.034928184,0.0676412,-0.2887874,-0.30219215),vec4(-0.084834404,-0.021604165,0.00014861883,0.25956488),vec4(0.15648334,-0.24964799,0.41113728,0.26210493)) * bufB[1] + mat4(vec4(-0.099732235,-0.010370342,0.014440367,0.21566923),vec4(-0.13604487,0.3059618,-0.13002391,-0.27029213),vec4(0.2751901,-0.04708595,-0.12902331,-0.36650273),vec4(-0.033844218,0.20199393,-0.40161216,0.032234345)) * bufB[2] + mat4(vec4(-0.14146343,0.19724101,-0.09156817,-0.23132014),vec4(0.060880676,-0.33649918,0.42217264,0.00028216874),vec4(0.08977052,0.18999535,-0.23110761,0.004875456),vec4(0.022137808,-0.25195077,0.11507639,0.2413069)) * bufB[3] + mat4(vec4(0.13308209,0.1796366,0.11436505,0.01720761),vec4(0.2569127,-0.14556296,0.08601555,-0.24209829),vec4(-0.09208052,-0.007616282,0.025824329,-0.46062866),vec4(-0.38675892,0.34532022,-0.37281534,-0.086440966)) * bufB[4] + mat4(vec4(0.020346794,0.16928078,-0.06152509,-0.3411476),vec4(-0.0957544,-0.28216296,-0.10653515,-0.48154438),vec4(-0.06193902,-0.01604808,-0.33963338,0.1488955),vec4(0.11100349,-0.06395115,-0.1174112,-0.15335467)) * bufB[5] + mat4(vec4(-0.6968015,0.29117024,-0.050673805,-0.31249377),vec4(-0.18854511,-0.008161295,-0.13214253,-0.18180925),vec4(-0.04613852,-0.11533035,0.21605545,-0.22821319),vec4(-0.021995137,0.19591096,-0.074653305,0.038841512)) * bufB[6] + mat4(vec4(0.1004229,0.04352646,0.043255977,0.07884362),vec4(0.19728318,-0.0048559294,-0.32081172,0.037227444),vec4(0.027388886,0.18528812,-0.28277168,0.18805444),vec4(-0.41621572,0.19840509,-0.21966407,-0.4067421)) * bufB[7];\nbufA[3] = vec4(-0.16757378,0.08065079,-0.47401646,-0.6356399) + mat4(vec4(0.112453595,0.25092253,0.0029891343,-0.30129254),vec4(-0.35545215,0.1592538,-0.12624231,-0.2534504),vec4(-0.25180846,0.119081095,-0.20520376,0.17936043),vec4(-0.14421096,-0.08617414,-0.15289943,-0.08822735)) * bufB[0] + mat4(vec4(-0.2940676,-0.80073273,0.13214828,0.30649132),vec4(0.1669681,0.09578244,-0.10856888,-0.122966625),vec4(-0.26741827,0.13430059,-0.103379466,0.20888843),vec4(0.22327143,-0.14046581,-0.058084402,-0.092998914)) * bufB[1] + mat4(vec4(-0.2142341,-0.09251822,0.23325868,-0.35079753),vec4(0.28780353,-0.06175639,0.2624664,-0.009978176),vec4(0.06449203,-0.2256141,0.27457976,-0.23098008),vec4(0.0044881506,0.40944186,-0.3180879,-0.011109974)) * bufB[2] + mat4(vec4(0.4035437,-0.36828783,-0.055482674,-0.07815613),vec4(-0.145679,0.12495396,-0.04985744,0.118875295),vec4(-0.20536946,0.056865256,0.13146985,-0.010615184),vec4(-0.108696766,0.43278608,0.013994678,0.10269907)) * bufB[3] + mat4(vec4(0.12911266,0.1081325,-0.011680714,-0.12557238),vec4(-0.22571468,-0.19332416,-0.08116161,0.059014358),vec4(0.25216323,0.18507315,0.04826481,-0.007420198),vec4(0.20688376,0.0041095093,-0.07254781,-0.26708513)) * bufB[4] + mat4(vec4(-0.055660196,0.15540625,-0.12111716,0.24229673),vec4(0.03594934,-0.16848132,0.03778103,0.33097422),vec4(-0.0011488477,-0.021354128,-0.07554007,-0.097608976),vec4(0.1980155,-0.14843655,-0.102483764,0.43955693)) * bufB[5] + mat4(vec4(0.10900838,-0.13988869,-0.034550536,0.028953556),vec4(0.29104802,0.02925436,0.025348047,-0.34962875),vec4(0.21239607,0.13664941,0.13267653,0.19325161),vec4(0.11315173,-0.0976988,-0.23417357,0.23654826)) * bufB[6] + mat4(vec4(0.23051472,0.30017975,0.12155435,0.014306229),vec4(0.29393658,0.043701608,0.14308512,0.086752035),vec4(-0.17137949,0.14822936,0.43983722,-0.09497425),vec4(0.5319565,-0.14301288,-0.3801087,0.025026696)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.27440858,-0.17034917,0.2530948,-0.21429801) + mat4(vec4(0.006242217,-0.112262696,-0.34904832,-0.18821722),vec4(0.08497102,0.17111598,0.048282176,-0.22868314),vec4(-0.5404531,0.44570428,-0.1441042,0.20302963),vec4(0.28937754,-0.12990268,0.17235516,0.038196072)) * bufB[0] + mat4(vec4(-0.29259065,-0.021802427,-0.21543455,-0.05526203),vec4(-0.67930806,-0.3627533,-0.14373179,-0.012448642),vec4(-0.09412179,-0.09495739,0.019910904,-0.13338627),vec4(0.32543907,-0.08023562,0.12223129,0.090249926)) * bufB[1] + mat4(vec4(0.18097857,0.23701884,0.14228278,0.13696851),vec4(0.15647323,0.23689349,0.32707748,0.19577117),vec4(-0.7186111,-0.2940861,-0.09642564,-0.25825486),vec4(-0.570194,0.037203386,0.28563207,0.011156104)) * bufB[2] + mat4(vec4(-0.0006742991,0.098668136,0.082058415,0.23672387),vec4(-0.27531984,0.27877215,-0.20266953,-0.010420432),vec4(0.032447834,0.12944654,0.3729988,0.09718095),vec4(-0.07992425,-0.06612461,0.097411215,-0.26107007)) * bufB[3] + mat4(vec4(-0.041345965,-0.015008408,0.17652754,0.090254374),vec4(0.30372626,-0.077746026,0.11508231,0.4273203),vec4(0.17478175,0.14685762,-0.082345665,0.12514462),vec4(0.04015748,0.03636237,0.41285363,-0.31419542)) * bufB[4] + mat4(vec4(0.60923344,-0.18890661,0.32619753,0.2965434),vec4(0.48250633,0.24739087,0.09543335,-0.0007479391),vec4(0.04206043,-0.12870532,0.05816981,0.38818437),vec4(-0.16481918,0.13191961,-0.23308738,-0.07683004)) * bufB[5] + mat4(vec4(0.08868583,0.18877089,-0.14478195,-0.14612202),vec4(0.06888021,-0.1909382,-0.23449892,-0.37242955),vec4(0.016478075,0.07753363,-0.09400799,0.39990568),vec4(-0.613993,-0.033736773,-0.026217975,-0.13935444)) * bufB[6] + mat4(vec4(0.013657219,-0.16750796,0.016378138,-0.009983096),vec4(-0.05080249,0.014417194,-0.71506023,-0.05362223),vec4(0.11571692,0.112111725,-0.006182246,-0.28888026),vec4(-0.30668145,0.01638379,-0.17622317,-0.24437243)) * bufB[7];\nbufA[1] = vec4(0.13414815,-0.05217254,0.26011518,-0.338685) + mat4(vec4(-0.07375205,0.3845972,0.3268729,0.04006704),vec4(0.221228,-0.2258937,-0.006930833,0.04293252),vec4(-0.04145487,-0.15267316,-0.17676048,0.0469267),vec4(-0.11617827,-0.18468861,-0.037198532,0.1347231)) * bufB[0] + mat4(vec4(-0.021099806,-0.26811987,-0.18722746,0.45850414),vec4(0.07695653,0.22554941,0.07396673,0.33944914),vec4(-0.14143254,-0.119524375,-0.25075287,0.21932334),vec4(-0.04405475,-0.13748115,-0.42671424,0.16573513)) * bufB[1] + mat4(vec4(-0.011185294,-0.15971132,-0.07840243,0.17366697),vec4(0.16317844,0.051209565,0.03247102,0.13557039),vec4(-0.23899636,0.045594316,0.044347353,0.10550681),vec4(0.13428019,0.12555042,-0.3114213,0.02715694)) * bufB[2] + mat4(vec4(0.032594997,-0.042572863,-0.17871322,0.13640593),vec4(0.079238325,-0.266146,-0.20837826,-0.13547158),vec4(-0.038023435,0.14370123,0.055366904,0.004192791),vec4(-0.06041434,-0.10150515,-0.3223247,0.26108155)) * bufB[3] + mat4(vec4(0.30864322,-0.4102087,-0.24677597,0.17545111),vec4(0.28150037,-0.1364832,-0.047238015,0.0086368155),vec4(-0.115625165,-0.20382723,-0.22181003,0.17151521),vec4(0.04976642,-0.1817536,-0.25954974,-0.18541314)) * bufB[4] + mat4(vec4(-0.27784625,-0.1308734,0.22005105,0.10662061),vec4(0.19689089,-0.71570736,-0.00052905874,-0.017434629),vec4(0.08822125,0.20358476,0.031446584,0.08508281),vec4(-0.057023972,-0.043491244,-0.22487615,0.22671582)) * bufB[5] + mat4(vec4(-0.09645299,0.0862598,-0.21028496,-0.0076766517),vec4(0.25732142,0.1483958,-0.69992816,0.046914328),vec4(0.08777284,-0.18551442,-0.0984119,-0.1945758),vec4(-0.019941352,0.22688375,0.090434365,-0.011830892)) * bufB[6] + mat4(vec4(0.27241448,0.36019045,-0.32144785,0.03631186),vec4(0.6436068,0.17581034,-0.46913823,0.038098205),vec4(-0.16438946,0.004486029,0.0021868958,0.0621938),vec4(0.37158555,-0.014421155,-0.10638261,-0.02673211)) * bufB[7];\nbufA[2] = vec4(-0.24200688,-0.11107392,-0.32205948,0.003696145) + mat4(vec4(-0.12741558,-0.09666562,0.30040255,0.17607443),vec4(0.034553654,-0.22962807,0.0005596417,0.038487528),vec4(-0.0057355664,-0.18866085,0.1943845,-0.2646452),vec4(0.009498368,0.21595305,-0.21162155,-0.17975692)) * bufB[0] + mat4(vec4(-0.33653462,0.21893796,-0.14472596,0.20836623),vec4(0.06479342,0.42675102,-0.06209337,-0.1338344),vec4(0.012801735,-0.14848003,-0.5727106,-0.18543221),vec4(-0.11257895,0.050799154,-0.24117228,0.12536451)) * bufB[1] + mat4(vec4(-0.1355821,-0.013256479,-0.22647052,-0.28812742),vec4(0.04140316,0.14504386,0.21597044,-0.055216413),vec4(-0.26377514,-0.31761596,-0.3894415,-0.1352018),vec4(-0.28348672,-0.24868642,0.12350198,-0.17764741)) * bufB[2] + mat4(vec4(0.007477509,-0.090703316,0.057500124,0.007996793),vec4(0.28965616,0.05644096,0.20471272,-0.20737898),vec4(0.12873799,-0.0014448031,-0.40723374,-0.013727029),vec4(-0.24231857,-0.44313732,-0.09417831,0.002964048)) * bufB[3] + mat4(vec4(-0.0013537435,0.01901331,0.48727968,0.20484392),vec4(0.30324483,0.5112009,0.37966835,0.04350742),vec4(-0.035838906,0.03984677,-0.07609413,-0.16039012),vec4(0.19349974,0.1907106,0.14071168,0.067995004)) * bufB[4] + mat4(vec4(0.11052653,0.05273325,0.0010018771,-0.02262405),vec4(0.32186526,-0.12835042,0.41030636,0.1781678),vec4(-0.15722707,0.24913421,-0.13567148,0.120824896),vec4(0.19481452,-0.17891216,-0.017553639,0.22854598)) * bufB[5] + mat4(vec4(-0.14333162,-0.24694782,-0.14560883,-0.031308867),vec4(0.05787556,0.1797059,0.38433623,0.2607136),vec4(0.46571785,0.028410666,0.0324554,-0.079586),vec4(-0.12940297,0.13558985,-0.2708603,-0.02769255)) * bufB[6] + mat4(vec4(0.17391664,0.26305574,0.075207375,0.13116914),vec4(-0.059262723,0.16697255,-0.04045411,0.23948365),vec4(-0.04637833,-0.14065824,0.21447422,-0.20880213),vec4(0.03422053,0.25926366,0.18073674,-0.023562197)) * bufB[7];\nbufA[3] = vec4(0.33870858,-0.47285044,0.12948734,-0.32901004) + mat4(vec4(0.366021,-0.14329197,0.29929554,0.11092843),vec4(-0.03252279,-0.3195866,-0.29557583,0.2671883),vec4(0.31919262,-0.10926474,-0.26527956,0.094458856),vec4(0.06774206,0.32113883,-0.059281066,-0.125943)) * bufB[0] + mat4(vec4(0.08179787,0.0061931475,0.0597084,0.013482815),vec4(0.04689914,-0.041820157,0.09466179,0.051590957),vec4(-0.13095544,0.1238036,-0.0866192,-0.25777552),vec4(-0.12668666,0.21969342,-0.28478375,-0.162576)) * bufB[1] + mat4(vec4(0.015793044,0.19754034,-0.24983147,0.151936),vec4(-0.41235277,0.008614622,-0.2158241,-0.050380174),vec4(0.2351112,-0.1665983,0.1704818,-0.07257205),vec4(0.24583311,-0.35298514,0.116238914,0.15630285)) * bufB[2] + mat4(vec4(-0.18203944,0.08200883,-0.2503134,0.38042462),vec4(-0.05648566,0.25527692,-0.06994542,-0.20255217),vec4(-0.13450038,0.040408734,-0.054035105,0.46614286),vec4(0.062653616,0.2104552,-0.06039039,-0.22585113)) * bufB[3] + mat4(vec4(0.19335507,0.104578964,-0.02276987,0.038746614),vec4(-0.23410909,0.16663435,-0.1048351,0.15302172),vec4(-0.18469937,0.042371936,0.17461574,-0.1666714),vec4(0.2492105,-0.20304662,-0.09943322,0.092864946)) * bufB[4] + mat4(vec4(-0.25457025,-0.24898732,-0.28707525,0.12786512),vec4(-0.264944,0.39181182,0.21355563,-0.44541812),vec4(-0.19938448,0.15121613,-0.11378618,0.417491),vec4(0.010798247,0.41088936,0.084868066,-0.17028071)) * bufB[5] + mat4(vec4(0.26388514,-0.005890969,0.14914659,-0.43556866),vec4(0.13507469,0.21981004,0.48325193,-0.47326332),vec4(-0.11111298,0.017459631,-0.3351527,-0.051271055),vec4(-0.14505246,-0.33066705,-0.146371,0.2163601)) * bufB[6] + mat4(vec4(0.06329987,0.1368002,0.22736503,-0.036342148),vec4(0.123996995,0.2997196,0.25867817,-0.24609126),vec4(-0.27632767,0.035962943,0.029256783,0.05037562),vec4(-0.1555959,-0.081968464,-0.35274482,-0.0437265)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.14992501,-0.38684732,0.2538635,-0.38163352) + mat4(vec4(0.016474372,-0.10679542,0.060205508,0.1953065),vec4(0.11163679,-0.0901351,0.012772581,-0.17155102),vec4(-0.00074721675,0.49749327,0.018749684,-0.3771991),vec4(0.07507665,0.030387236,-0.04895348,-0.11764825)) * bufB[0] + mat4(vec4(0.0375912,-0.03924062,0.033456326,0.060547043),vec4(0.06368154,0.45394325,0.12378155,0.029437926),vec4(-0.010982136,0.1117904,-0.052485734,0.13001432),vec4(-0.6193738,-0.074787,0.29340097,-0.23756655)) * bufB[1] + mat4(vec4(0.23988782,0.14916843,-0.23910286,0.21689612),vec4(0.22638927,0.15367556,0.06581331,-0.017414562),vec4(0.45051187,-0.079908594,-0.17145388,0.7212872),vec4(-0.096663594,0.026753059,-0.1549592,0.034461293)) * bufB[2] + mat4(vec4(0.16633515,0.17955309,0.013206501,0.15359995),vec4(0.08891736,-0.2165779,0.02519672,0.117892675),vec4(-0.26593846,0.07654849,-0.059149057,0.3589858),vec4(0.16321935,0.46727788,-0.23085354,-0.17107682)) * bufB[3] + mat4(vec4(-0.2660338,-0.21434045,-0.070001476,-0.27985787),vec4(-0.32423332,-0.026601382,-0.36642355,0.08056936),vec4(-0.2831066,-0.25109607,0.18221186,-0.467822),vec4(0.28849712,-0.018454252,-0.12519899,0.33883473)) * bufB[4] + mat4(vec4(0.2859205,0.06295786,-0.2125667,-0.15702695),vec4(0.4248729,-0.3317209,-0.13792792,-0.014057798),vec4(-0.053990174,-0.22881101,-0.025474304,-0.012011151),vec4(-0.053357717,0.10682821,-0.19207251,0.31992158)) * bufB[5] + mat4(vec4(-0.20698047,-0.0053999936,-0.16900042,0.019973647),vec4(0.25926745,-0.098138794,0.109551616,0.13406935),vec4(0.23414974,0.3718252,0.073417686,0.5333734),vec4(0.2093311,0.037168454,0.19583662,0.16996975)) * bufB[6] + mat4(vec4(0.13449115,-0.23376998,-0.016189957,0.3892626),vec4(0.30409473,0.23223034,-0.105322294,0.22440328),vec4(0.030033492,0.017374417,0.030372947,0.08893895),vec4(-0.14876813,-0.0018620987,0.009615055,0.13054329)) * bufB[7] + in0;\nbufA[1] = vec4(-0.2982201,-0.26052484,0.14226094,-0.42966008) + mat4(vec4(0.6506358,0.009815033,-0.05954666,0.18288004),vec4(-0.039148357,0.02721621,0.09186833,0.18381429),vec4(0.33267662,0.06073422,0.053464603,-0.007639218),vec4(0.24358459,0.3456689,-0.1259353,0.32455456)) * bufB[0] + mat4(vec4(0.018132979,-0.24958983,0.26496634,-0.004158552),vec4(-0.38332224,0.36455494,0.051691845,0.06925484),vec4(-0.048590515,-0.0459052,0.25354162,0.17111573),vec4(0.02542559,-0.004203213,0.058071423,-0.038965546)) * bufB[1] + mat4(vec4(0.41357294,-0.062518984,0.43141353,0.23341285),vec4(0.20139818,0.017938953,-0.014341604,0.30151302),vec4(0.33682734,0.20972727,0.32263726,-0.09099748),vec4(0.08832866,0.007137366,0.20379664,0.053365916)) * bufB[2] + mat4(vec4(-0.42899236,0.42525545,0.19351941,-0.21440727),vec4(0.5050417,-0.572981,0.1189843,0.07466208),vec4(-0.30155575,-0.11198518,-0.2685818,-0.2159973),vec4(-0.11758529,0.16721565,0.23073222,-0.0170991)) * bufB[3] + mat4(vec4(-0.14343399,-0.18496819,0.04459861,-0.17206915),vec4(0.28962705,0.05829109,-0.0093871085,-0.06489368),vec4(-0.32343015,0.032136705,-0.10692901,-0.13340256),vec4(-0.26156756,0.16055073,0.24288242,-0.114227824)) * bufB[4] + mat4(vec4(0.021972025,0.12795375,0.24852116,0.2718544),vec4(0.13934404,0.1305934,-0.122929946,-0.16327123),vec4(0.13675487,0.09199262,-0.13366923,0.21855119),vec4(0.1499632,0.06383028,-0.08580126,0.36279356)) * bufB[5] + mat4(vec4(0.10963816,0.117824025,-0.43296483,0.034351967),vec4(0.3287203,0.17764632,0.061192796,0.19796681),vec4(-0.13587104,-0.087543756,0.13425231,-0.23864599),vec4(0.029878719,-0.29343173,-0.12716635,-0.016353672)) * bufB[6] + mat4(vec4(-0.50318295,0.1951447,0.19161147,-0.35972637),vec4(-0.17480206,-0.2583351,0.13503195,-0.43270427),vec4(0.22662102,-0.35339883,-0.09017443,-0.016584722),vec4(-0.111062914,0.0075435173,-0.26111254,-0.19143301)) * bufB[7] + in1;\nbufA[2] = vec4(0.26119035,0.16798624,-0.40344787,-0.26162457) + mat4(vec4(0.02764782,-0.07856152,0.0055901185,0.32552266),vec4(-0.094173275,0.07553631,0.18479769,-0.12806548),vec4(0.18179119,0.17610951,0.18573411,0.25845486),vec4(0.2702102,0.1877366,0.35147375,-0.082293786)) * bufB[0] + mat4(vec4(-0.09673251,-0.14577092,0.1316824,-0.1612224),vec4(0.154763,-0.12916256,-0.090647474,-0.32442603),vec4(0.19532335,0.18323103,-0.060851097,0.11215731),vec4(0.14563459,-0.35925537,-0.12008256,0.043020334)) * bufB[1] + mat4(vec4(-0.13271816,-0.15679714,0.08933622,-0.10073565),vec4(0.01132654,0.052657038,0.122885354,0.06496761),vec4(0.10177146,0.07557197,-0.0008254197,-0.21425025),vec4(-0.28331402,-0.124918446,-0.026188495,-0.06833335)) * bufB[2] + mat4(vec4(0.10939189,0.08365287,-0.11263554,-0.5722343),vec4(-0.16455837,-0.1250986,0.6864969,-0.40022904),vec4(-0.32671106,-0.17781474,-0.28743374,-0.2710739),vec4(0.12653086,0.2820888,-0.27590567,0.3261223)) * bufB[3] + mat4(vec4(-0.12801167,-0.04577717,-0.12896952,-0.09391741),vec4(-0.09784295,0.13129817,-0.08299125,-0.14601661),vec4(0.012402116,0.043935142,-0.4077095,0.20199467),vec4(-0.005247897,-0.23438229,-0.07585895,0.022743974)) * bufB[4] + mat4(vec4(-0.31554452,0.07036061,0.22752774,-0.27656946),vec4(-0.1058452,-0.07942431,0.005091005,0.108666085),vec4(-0.25722525,0.2749501,0.31096157,-0.12728587),vec4(0.18843237,-0.0305415,-0.2106906,-0.038618583)) * bufB[5] + mat4(vec4(-0.19853744,-0.03392837,-0.1634528,0.01845304),vec4(-0.014019941,-0.3294624,0.22866276,0.025812674),vec4(0.23095703,-0.15804523,-0.1460285,-0.1570256),vec4(0.1575291,0.08672071,-0.07863831,-0.18734)) * bufB[6] + mat4(vec4(-0.023451068,-0.14567114,-0.2636316,-0.24095877),vec4(-0.06104023,0.19919515,-0.24978077,-0.29744577),vec4(-0.32857016,-0.07511073,0.080440596,-0.31975415),vec4(0.4463175,-0.05110189,-0.10000071,0.15022883)) * bufB[7] + in2;\nbufA[3] = vec4(0.061165832,0.20210567,-0.117128074,-0.29756773) + mat4(vec4(0.08087178,0.11520034,0.1033994,0.004639148),vec4(-0.08724102,-0.07591527,0.12684637,0.07537377),vec4(-0.031741947,0.13474531,-0.034881264,0.56618446),vec4(0.058261614,-0.19897224,0.068204306,-0.13557862)) * bufB[0] + mat4(vec4(-0.30772394,-0.2584101,0.3328317,0.10095017),vec4(-0.53921527,0.28679857,0.005127091,-0.2969969),vec4(-0.43154985,0.5750412,-0.40845278,0.13721691),vec4(0.41905966,-0.21749094,0.1529992,0.025564907)) * bufB[1] + mat4(vec4(-0.5260627,0.3720263,-0.16672815,0.04997647),vec4(0.48044944,-0.42144638,0.06903334,-0.14079273),vec4(0.048848413,-0.05145396,0.026187818,-0.17761493),vec4(-0.05978366,-0.1459767,0.10940226,-0.24992701)) * bufB[2] + mat4(vec4(0.076292835,-0.1548674,0.09490237,-0.12558919),vec4(0.06363464,-0.4918034,0.26816368,0.059680734),vec4(-0.19144957,-0.2855547,0.017701447,-0.36102548),vec4(0.1168534,0.31029156,-0.17783153,0.123015665)) * bufB[3] + mat4(vec4(0.24702974,0.05261153,0.0959025,-0.020311516),vec4(0.04293393,-0.15734544,0.010847873,0.35602424),vec4(0.21178678,-0.07097939,0.09311198,-0.15449972),vec4(-0.07502,0.044123515,0.084877454,-0.14205274)) * bufB[4] + mat4(vec4(-0.21317512,0.00041974604,0.20268176,-0.18966864),vec4(-0.20873791,-0.09627082,-0.05195529,-0.17501837),vec4(-0.11422032,-0.20864029,0.39890262,0.24094766),vec4(0.10297141,-0.08839052,-0.16871159,0.29161742)) * bufB[5] + mat4(vec4(-0.17848429,-0.12972975,-0.28532794,0.052354954),vec4(-0.18442139,-0.099949166,-0.04037899,0.05942311),vec4(0.07576953,0.32539508,-0.2570463,0.16994973),vec4(-0.18056317,-0.13665321,0.08093887,-0.20144019)) * bufB[6] + mat4(vec4(0.100649685,-0.06222344,-0.16472548,0.15622874),vec4(-0.31819433,0.35190943,-0.18314758,-0.06996748),vec4(-0.06229435,0.024452701,0.35333216,0.04530775),vec4(-0.15430252,0.16186407,0.061856367,-0.12802891)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.40391222,0.19271305,-0.10231462,0.39629665) + mat4(vec4(0.13735938,-0.18339656,0.34851253,0.11848748),vec4(0.23487368,-0.87474066,-0.31933722,0.6117505),vec4(-0.003584564,0.21227266,0.20180023,-0.0059381444),vec4(0.13442077,0.1297816,0.115111396,-0.41321564)) * bufB[0] + mat4(vec4(-0.34913674,0.38108113,-0.38430774,-0.32333592),vec4(-0.043011483,-0.21967405,-0.0036889086,-0.08517864),vec4(-0.14699611,0.1589006,0.16854292,-0.021787843),vec4(-0.121855676,-0.24719426,-0.10040764,0.1904629)) * bufB[1] + mat4(vec4(-0.09065354,-0.038666748,-0.3100682,0.3273992),vec4(0.023526069,0.029183073,0.049357485,0.29824808),vec4(-0.14837664,0.27793387,0.10857123,0.17433183),vec4(-0.16544525,0.12853935,-0.20134343,0.15499727)) * bufB[2] + mat4(vec4(0.10215003,-0.0581304,-0.09974173,0.0043683406),vec4(-0.059405133,-0.42091173,-0.18935962,0.26531196),vec4(-0.07589093,0.2594693,0.19032058,0.130807),vec4(0.12235767,0.024181642,-0.13398467,0.10205991)) * bufB[3] + mat4(vec4(0.4377968,-0.25179034,-0.063040614,-0.011190377),vec4(0.26720056,0.44114718,-0.014037185,0.26267737),vec4(-0.027907092,-0.30938494,0.019006453,-0.20713362),vec4(0.18613602,-0.17814901,-0.2288221,-0.032954283)) * bufB[4] + mat4(vec4(0.47759536,0.0824443,0.28489256,-0.23694715),vec4(0.29289177,-0.052301586,-0.29338795,0.1105068),vec4(-0.020772059,-0.45377576,0.0007791745,0.13931674),vec4(0.30975223,-0.0068070497,-0.031070016,-0.30663928)) * bufB[5] + mat4(vec4(-0.5439396,0.08255632,-0.18129946,-0.24326088),vec4(0.061576936,0.22575116,0.13203268,-0.33085385),vec4(-0.2761777,-0.23312703,0.20237236,0.09229084),vec4(0.15884067,-0.2210034,0.34523067,-0.40081653)) * bufB[6] + mat4(vec4(0.24847881,-0.21296951,0.15803333,-0.028999794),vec4(-0.30942222,0.061199978,0.20148186,0.20461169),vec4(-0.2657587,0.22264582,-0.11719055,0.23516718),vec4(0.06956863,-0.108813666,-0.06416933,-0.20901752)) * bufB[7];\nbufA[1] = vec4(-0.0090538785,0.16936137,-0.37906447,-0.03528175) + mat4(vec4(0.2341679,-0.30531812,0.18865286,-0.37775394),vec4(0.030953716,0.13361406,0.10408533,0.10742437),vec4(0.006168252,0.013636412,-0.020011876,-0.1836716),vec4(0.28505042,-0.09388102,-0.35356486,-0.14602955)) * bufB[0] + mat4(vec4(-0.000857392,-0.2615543,-0.2777255,0.6772121),vec4(0.13882443,0.04593426,-0.07473529,-0.086196244),vec4(0.15180117,0.1825766,-0.10055715,-0.088090174),vec4(0.36846954,-0.17987104,0.049009327,0.28879708)) * bufB[1] + mat4(vec4(-0.012443014,0.2107028,0.23590899,0.060935162),vec4(-0.14567302,0.012479759,0.08998826,0.0945272),vec4(-0.3154762,-0.082275055,0.28189757,0.017759467),vec4(0.32079715,-0.2712125,-0.036966797,0.037281614)) * bufB[2] + mat4(vec4(-0.23183343,-0.05992016,0.30477712,-0.021208525),vec4(-0.14693932,0.012777123,-0.10065235,0.12353559),vec4(0.14469168,-0.26436472,0.14454654,0.19342153),vec4(-0.06609196,0.08525201,0.09572232,0.17281987)) * bufB[3] + mat4(vec4(0.14170499,0.058549207,-0.2810128,0.27526703),vec4(-0.03649771,0.0133873345,0.003382085,0.0029380012),vec4(0.3124237,-0.025113912,-0.18436648,0.37543944),vec4(-0.1582759,0.12625389,0.18919562,0.44731522)) * bufB[4] + mat4(vec4(0.22694276,-0.1045896,-0.4515366,-0.3704303),vec4(0.2542384,-0.006192456,-0.19197874,0.028245376),vec4(0.15992248,-0.0849964,-0.08280759,-0.24640341),vec4(0.041003548,-0.17175,-0.080600254,-0.34901747)) * bufB[5] + mat4(vec4(0.011648871,-0.09876325,-0.09973911,0.2053793),vec4(0.25376806,0.13674122,0.143834,0.100746006),vec4(0.43735534,-0.009335073,-0.37363946,0.036930855),vec4(0.4277504,-0.26662958,0.007967802,-0.07896858)) * bufB[6] + mat4(vec4(0.11748048,0.21151821,0.05811614,0.27756035),vec4(-0.14706558,-0.20734972,0.13124016,0.039858103),vec4(-0.051375616,0.06754673,0.23280163,0.0047406266),vec4(0.02747709,0.100478694,-0.14011219,0.283623)) * bufB[7];\nbufA[2] = vec4(0.52362144,0.20713346,-0.04549897,-0.30191562) + mat4(vec4(-0.02039634,-0.05184376,-0.25450376,-0.054719638),vec4(0.32266393,-0.41989106,-0.17383216,-0.4675596),vec4(-0.17377122,0.20483874,0.1376718,0.093595244),vec4(0.12708123,-0.14866568,0.09335912,-0.25161803)) * bufB[0] + mat4(vec4(-0.3734988,-0.24415918,-0.74566364,0.30769643),vec4(0.01758137,0.06292331,0.02317803,-0.21550278),vec4(0.038967025,-0.16107535,-0.336261,-0.2025286),vec4(-0.115713276,0.031963576,0.06023516,-0.14326571)) * bufB[1] + mat4(vec4(0.08097332,-0.33276543,0.18635583,-0.25245488),vec4(0.17629538,-0.19292565,-0.048200786,-0.37356395),vec4(-0.17132355,0.095404156,-0.19464475,0.18793118),vec4(0.1399112,0.052543294,0.16606551,0.20767915)) * bufB[2] + mat4(vec4(0.031289525,0.04674679,0.03274288,0.0492993),vec4(-0.008725634,-0.124930486,0.014673585,-0.3313957),vec4(0.20857942,0.268698,-0.04280195,0.121963196),vec4(0.078511946,0.014202216,-0.23668501,0.05501208)) * bufB[3] + mat4(vec4(0.33518925,-0.075739704,0.072905935,-0.23662806),vec4(0.020453079,-0.23709846,0.05460157,0.30918595),vec4(-0.15172024,0.15731986,-0.050271712,0.18712343),vec4(-0.20159422,0.1623211,0.13565394,0.13136338)) * bufB[4] + mat4(vec4(-0.20739995,-0.24271776,0.56282926,0.041050512),vec4(-0.13494821,-0.065391764,-0.08743378,0.08318338),vec4(0.1318583,0.09490757,0.2028098,-0.080403835),vec4(-0.25754747,0.039303944,0.20866062,-0.12998638)) * bufB[5] + mat4(vec4(-0.1496881,0.024129577,-0.14298949,0.00035208676),vec4(0.14456128,-0.19373477,0.024175119,0.25077394),vec4(-0.0655235,-0.33986416,-0.12478924,-0.2932773),vec4(0.054936204,0.216895,0.021618854,0.08459318)) * bufB[6] + mat4(vec4(0.028302088,-0.04456914,-0.06622367,0.116731085),vec4(-0.117276244,-0.103322335,-0.120153755,-0.013067621),vec4(-0.20770589,0.05022212,-0.31822434,0.057907455),vec4(-0.3905655,0.24180593,-0.19774008,-0.11574086)) * bufB[7];\nbufA[3] = vec4(0.37290168,-0.19450907,0.3413473,0.5165899) + mat4(vec4(0.1496663,-0.043267187,-0.2351873,0.028229458),vec4(0.15145735,-0.08086455,-0.056841716,-0.32208234),vec4(0.0985586,-0.051973633,0.15920441,0.2484516),vec4(0.002636309,-0.17194906,-0.4507517,-0.51916564)) * bufB[0] + mat4(vec4(0.31120905,-0.15027237,-0.06699757,-0.09947749),vec4(-0.09539074,-0.076675855,-0.19576557,0.32961166),vec4(0.3053883,0.0631619,-0.048177134,-0.17633063),vec4(0.35712373,-0.17197584,0.13900176,-0.30766845)) * bufB[1] + mat4(vec4(0.095549196,0.20017408,0.2569768,0.005347974),vec4(-0.06955879,-0.050298236,-0.116466805,-0.07623476),vec4(0.2051435,-0.12589508,0.3282667,-0.04638192),vec4(0.07993984,-0.17789187,0.29166934,-0.054947473)) * bufB[2] + mat4(vec4(0.022623943,-0.04930331,0.25738347,-0.20475224),vec4(0.09177469,0.23431863,-0.36262724,0.0221303),vec4(0.010584721,-0.39357567,0.08997059,0.2181646),vec4(0.28013313,-0.15850727,0.36526823,0.36467984)) * bufB[3] + mat4(vec4(-0.24299313,0.32292467,-0.25693968,-0.10610063),vec4(0.122796476,0.38732216,-0.09888933,0.09811204),vec4(-0.14735818,-0.1123749,0.15477428,-0.010182953),vec4(0.29987508,-0.28593525,0.38860786,0.031269908)) * bufB[4] + mat4(vec4(-0.87853587,-0.2801551,-0.41861045,-0.021782603),vec4(0.07017108,-0.031624354,0.057755098,0.36990312),vec4(-0.060059953,0.13679843,-0.3139631,-0.2744167),vec4(-0.35779795,0.00013305247,-0.40389886,0.33498487)) * bufB[5] + mat4(vec4(0.19618258,-0.10416761,-0.03920497,0.15306382),vec4(0.25971234,0.14364202,-0.14394778,0.025858646),vec4(0.066549495,-0.0025569522,-0.45914742,-0.01281027),vec4(-0.136579,-0.011193525,-0.027368462,0.110175304)) * bufB[6] + mat4(vec4(0.11824479,0.018386547,-0.0062925196,-0.21641074),vec4(0.067663096,0.058579717,0.2412824,0.015390078),vec4(-0.038575795,-0.10697094,0.059145153,-0.06653723),vec4(0.10895367,0.17428745,-0.09063827,0.1617707)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.04936941,0.30084676,0.13443561,-0.25927767) + mat4(vec4(-0.017436268,-0.4375424,-0.30997947,-0.31338924),vec4(-0.45953205,0.1258267,0.29540408,0.19768462),vec4(-0.05749937,-0.031564333,0.3902704,0.23620299),vec4(-0.17938653,0.30481023,-0.043433376,-0.4742118)) * bufB[0] + mat4(vec4(-0.115472436,-0.3206028,0.23254398,0.23907569),vec4(-0.12830484,0.23237108,-0.06616279,-0.09170425),vec4(-0.1836959,0.15849397,0.21218614,-0.33326685),vec4(0.05029252,0.35871127,-0.113713436,0.042214766)) * bufB[1] + mat4(vec4(-0.017960878,0.15473661,0.16575408,0.042003714),vec4(-0.21805674,-0.050928485,0.0053328895,0.1862132),vec4(-0.09541205,-0.15125838,-0.26316753,-0.15793009),vec4(-0.07051637,-0.027148567,0.29834893,-0.0095226355)) * bufB[2] + mat4(vec4(-0.38269702,0.41506335,0.0631478,0.091219805),vec4(0.13759632,-0.16511929,0.13327801,-0.21283358),vec4(-0.26444405,0.63506025,0.28860232,-0.07952366),vec4(-0.10488793,0.17285514,0.16726547,0.018280188)) * bufB[3] + mat4(vec4(-0.015740933,0.45213112,-0.06766978,0.35214868),vec4(0.12172565,0.074898034,0.018629469,-0.32678303),vec4(-0.053691525,-0.28375542,-0.13132502,0.15032436),vec4(0.044927754,-0.46606815,0.28057787,0.53545606)) * bufB[4] + mat4(vec4(0.37260678,-0.64387035,-0.1740657,0.15170124),vec4(-0.026581658,0.095255286,-0.08860721,0.030658282),vec4(0.22202235,-0.37640592,0.24975772,0.054876108),vec4(-0.19687662,0.124951005,-0.030934334,-0.17490037)) * bufB[5] + mat4(vec4(-0.024472004,-0.026949843,0.053359557,0.009172137),vec4(-0.13237321,0.545581,0.2919313,-0.38645998),vec4(-0.51418775,0.15744656,0.008794743,0.3350748),vec4(0.11632182,0.35182008,-0.25930893,-0.25054976)) * bufB[6] + mat4(vec4(-0.19083527,-0.04763383,-0.13542405,0.290642),vec4(0.2703799,-0.15605056,-0.075763874,0.020258954),vec4(-0.35289308,0.49358368,-0.1793059,0.01818497),vec4(0.11996253,0.24544328,-0.12006823,-0.22474258)) * bufB[7];\nbufA[1] = vec4(-0.22185671,-0.34823105,0.20110275,-0.17288525) + mat4(vec4(0.101162255,-0.24324757,0.21814962,-0.1405716),vec4(0.31176612,0.10765487,0.14981358,0.20545967),vec4(0.31330338,-0.3125222,0.427979,0.16962193),vec4(0.0019822386,-0.1144286,0.14276342,0.008829947)) * bufB[0] + mat4(vec4(0.31069943,0.16529252,0.06424556,-0.31950572),vec4(-0.18796882,-0.0522231,0.11181106,-0.22898169),vec4(-0.0741242,-0.030494688,-0.031982407,-0.017274573),vec4(-0.28201225,0.35190225,0.07976975,0.34239402)) * bufB[1] + mat4(vec4(-0.07775086,-0.16009103,0.36548012,-0.03614985),vec4(0.0931434,-0.055989143,0.10221927,0.022771131),vec4(0.20459343,-0.52275735,-0.13127534,0.12319556),vec4(-0.08492171,0.15829612,-0.023433471,0.27197126)) * bufB[2] + mat4(vec4(-0.11493176,0.4470533,0.033830337,0.22251855),vec4(-0.11591831,-0.013780442,0.09934467,-0.059487507),vec4(-0.030982725,-0.3854408,0.14788312,0.41519755),vec4(0.16966075,-0.16399586,0.06930136,0.18091552)) * bufB[3] + mat4(vec4(0.0656782,0.2316611,0.07574607,-0.29838714),vec4(-0.3168674,0.09691113,-0.040776066,-0.33037847),vec4(-0.12248073,-0.20392795,0.10014421,-0.18842642),vec4(0.08691503,0.15573321,-0.3461185,0.32036054)) * bufB[4] + mat4(vec4(0.057692867,0.039105985,-0.19633608,0.07032081),vec4(-0.20808451,0.2098784,0.27019215,-0.081236154),vec4(-0.22809634,0.08222044,-0.3160802,-0.2139742),vec4(0.14115931,-0.29716742,-0.15534213,0.12213908)) * bufB[5] + mat4(vec4(0.0673844,0.07061903,-0.03650939,-0.15080924),vec4(-0.027944446,-0.2197079,0.6700074,-0.27470425),vec4(0.32312396,-0.17814118,0.04646513,-0.1981615),vec4(-0.110827126,-0.08133701,0.14384976,-0.27467585)) * bufB[6] + mat4(vec4(0.38405046,-0.49301895,0.08202175,0.031519216),vec4(-0.2312009,0.056332573,-0.017425347,0.05156612),vec4(-0.069658495,-0.16165975,0.0747194,0.31933588),vec4(0.12111703,-0.2809071,-0.05954784,0.38386077)) * bufB[7];\nbufA[2] = vec4(0.12980975,-0.39900437,-0.36177033,0.048373263) + mat4(vec4(-0.20514455,-0.04736875,0.16650903,0.18187222),vec4(0.0022384268,0.081857905,-0.032577127,0.15828174),vec4(0.08916533,-0.23687498,0.03441796,0.033675097),vec4(-0.23406376,-0.25432342,-0.16859278,0.096397124)) * bufB[0] + mat4(vec4(0.38233057,0.01380395,0.0891679,-0.017912006),vec4(-0.16192244,-0.07639387,-0.22531952,0.044493042),vec4(0.03581516,-0.40510163,-0.23407659,-0.1691359),vec4(0.16802898,-0.26143205,0.18986319,0.01259649)) * bufB[1] + mat4(vec4(0.023659877,0.2714472,0.039719045,-0.081122674),vec4(-0.34843907,-0.15212703,-0.3727001,-0.29988584),vec4(-0.29649857,0.29154083,0.0012966504,0.08889972),vec4(0.28190473,-0.10242955,0.11056156,0.2475925)) * bufB[2] + mat4(vec4(0.1868579,-0.51448125,0.0076828287,-0.21380162),vec4(0.15623365,0.07847554,-0.08820365,0.05030659),vec4(-0.44102144,-0.30987313,0.09568104,-0.057872973),vec4(-0.21367398,-0.026050217,-0.097309686,-0.100613296)) * bufB[3] + mat4(vec4(-0.21891478,-0.13229388,-0.07415361,-0.3113123),vec4(0.07806989,0.0324628,-0.24594854,-0.386767),vec4(0.06316904,0.07637235,-0.098967865,0.041365314),vec4(0.23965205,0.32176802,0.05814816,0.08096825)) * bufB[4] + mat4(vec4(0.026487755,0.25153953,0.34917983,0.1231844),vec4(0.12527488,0.13694264,0.11704454,0.012922333),vec4(0.49562028,0.1570939,0.26885107,0.420923),vec4(-0.03314001,-0.26295748,0.02576142,0.0935687)) * bufB[5] + mat4(vec4(-0.11601888,0.3737876,-0.07367026,0.045763016),vec4(-0.0364265,-0.37301874,0.026490266,0.043988958),vec4(0.17503949,-0.15326472,0.30218977,0.119124845),vec4(0.021078728,0.13220793,0.105861306,0.05761899)) * bufB[6] + mat4(vec4(-0.20884018,0.102043204,0.1144664,0.12631689),vec4(0.014882284,0.3086983,0.17836794,0.1814034),vec4(0.00744546,-0.38344795,0.5465854,-0.14582127),vec4(-0.12240389,-0.06055303,-0.30126148,-0.17710327)) * bufB[7];\nbufA[3] = vec4(0.17260344,-0.30923882,0.46376663,-0.50289005) + mat4(vec4(0.40917164,0.17040865,-0.07086858,-0.100773856),vec4(-0.0406451,0.57387453,-0.78928477,0.52064145),vec4(0.14022037,0.05930806,0.23447835,-0.057658803),vec4(-0.19464315,0.0123290075,0.051776055,0.12158512)) * bufB[0] + mat4(vec4(-0.23927811,-0.06242924,0.422962,0.18759072),vec4(0.10267182,-0.26687247,0.002492495,-0.23767841),vec4(-0.077303275,-0.11337371,-0.24477135,0.25146735),vec4(0.16394915,0.06469819,-0.35893413,0.055120252)) * bufB[1] + mat4(vec4(0.1668194,-0.1369156,0.008676227,-0.11573116),vec4(0.33362868,0.07050368,-0.31279233,-0.018181622),vec4(0.03252586,0.16411264,-0.115993105,-0.0670446),vec4(-0.040022954,0.3947341,-0.4279264,-0.025552107)) * bufB[2] + mat4(vec4(-0.15083368,-0.2883145,-0.39244553,0.41141197),vec4(-0.020568425,0.08130662,-0.09235002,0.31227762),vec4(0.11918171,0.19410565,-0.15569234,0.2268507),vec4(-0.03643079,0.1947437,-0.06022819,-0.027861262)) * bufB[3] + mat4(vec4(0.04437873,-0.039432086,0.11857981,-0.094022624),vec4(-0.35900557,-0.029433036,0.24030529,-0.20117386),vec4(0.26279256,0.18392114,-0.009341842,-0.312605),vec4(0.12748443,0.13931261,-0.34946576,0.068458736)) * bufB[4] + mat4(vec4(-0.058295976,-0.24052529,-0.3767253,-0.2309459),vec4(-0.06699934,0.16956979,-0.12136926,-0.30023608),vec4(-0.010923901,-0.19800325,0.06798398,-0.0181683),vec4(0.040061083,0.11821599,0.054437935,-0.25894442)) * bufB[5] + mat4(vec4(-0.22807483,-0.064923495,0.0632352,0.060197875),vec4(0.27692577,-0.08948984,0.18142089,0.07840138),vec4(-0.20552993,0.22997303,-0.100822516,-0.08073334),vec4(-0.2950421,-0.15574862,-0.06751736,0.28886026)) * bufB[6] + mat4(vec4(-0.2519243,-0.13270885,-0.097782835,0.14677659),vec4(0.12152406,0.027954657,-0.0019909572,0.062335905),vec4(0.08499542,-0.20829512,-0.39312008,0.083737195),vec4(0.31134057,-0.06866313,0.030344302,-0.15819983)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.2313938,-0.0080289915,-0.50829583,0.029345468) + mat4(vec4(-0.02975946,0.48955366,0.006418496,0.36304322),vec4(-0.24612056,0.14335945,0.08621715,-0.14805692),vec4(-0.060453918,0.28960994,-0.09633546,0.07524565),vec4(0.33852953,0.14426915,-0.3218279,-0.08254849)) * bufB[0] + mat4(vec4(-0.019279031,-0.16134012,0.17859551,0.10183321),vec4(0.2177312,0.21575275,0.2198977,-0.10441549),vec4(-0.09678828,-0.0066322405,-0.15742245,0.14728224),vec4(-0.104485095,0.017496452,-0.30292088,-0.14411321)) * bufB[1] + mat4(vec4(0.22014499,0.17203085,0.19758071,-0.14245023),vec4(-0.2171298,-0.15201713,-0.004875184,0.30990794),vec4(-0.058443755,-0.03227041,0.20940527,-0.3080223),vec4(-0.2749571,-0.030423934,-0.12233569,-0.029687684)) * bufB[2] + mat4(vec4(0.3013121,0.06856833,-0.2337008,-0.028722515),vec4(0.010964246,-0.23282608,0.26695982,0.053901844),vec4(0.20989376,0.23841418,-0.18623649,-0.15999721),vec4(-0.22714107,0.4000702,-0.19227871,0.112493694)) * bufB[3] + mat4(vec4(0.13338779,0.35103625,0.1520726,-0.10583923),vec4(0.5118362,0.33774376,-0.097984664,-0.048077393),vec4(-0.14432481,-0.09752918,0.04563575,0.13788362),vec4(0.06447376,-0.065465145,0.08817479,-0.16709766)) * bufB[4] + mat4(vec4(0.28006855,-0.27710927,-0.1944048,0.17348778),vec4(-0.14584564,-0.26188096,-0.14172289,0.1438847),vec4(-0.029442357,-0.09343074,0.003782107,-0.3553818),vec4(-0.29195008,0.089333855,-0.19281472,0.010774296)) * bufB[5] + mat4(vec4(-0.115858376,0.21740869,0.34824532,0.050686453),vec4(-0.04057871,-0.017154718,-0.194239,-0.19216223),vec4(-0.19104779,0.049339235,0.13474801,0.008740101),vec4(0.11521144,-0.35117334,-0.076242544,0.11553454)) * bufB[6] + mat4(vec4(0.30708736,-0.040249106,-0.16141899,-0.12807946),vec4(-0.42475125,0.3157876,0.13771477,0.49216098),vec4(-0.2513518,0.022765258,0.22391146,0.24680051),vec4(0.21192534,-0.21806051,-0.17558403,0.19391577)) * bufB[7];\nbufA[1] = vec4(0.4551541,0.45419163,-0.16538605,0.34364587) + mat4(vec4(0.059196867,0.21720012,-0.1526976,0.277752),vec4(-0.30832547,-0.46921545,-0.18717197,-0.34441927),vec4(0.33852342,0.010863438,0.27432135,0.18399042),vec4(1.0582435,-0.097775355,0.27706894,0.10229298)) * bufB[0] + mat4(vec4(0.37976444,-0.057276458,0.0290842,-0.04901851),vec4(0.22848439,0.020935804,0.18205704,0.11610001),vec4(-0.24547553,-0.5184205,0.055396143,-0.27432498),vec4(0.082180366,-0.40731108,0.02278199,-0.09192223)) * bufB[1] + mat4(vec4(0.2195567,-0.057094846,-0.12126527,0.04621705),vec4(0.04006388,0.08391429,-0.25831065,-0.12064991),vec4(-0.052077673,0.028988719,-0.02569294,0.06502294),vec4(-0.08343241,0.026631676,0.06575991,0.035509977)) * bufB[2] + mat4(vec4(-0.008771735,-0.21315807,0.04303303,-0.20612603),vec4(0.072433226,0.29413676,0.61839885,-0.06982442),vec4(0.25201124,0.34006122,-0.6372596,0.004009042),vec4(0.14197116,0.11294932,0.049785625,0.04548289)) * bufB[3] + mat4(vec4(0.155762,-0.27336293,0.2291179,0.040851142),vec4(0.015854517,-0.3725252,-0.17012374,0.029712683),vec4(0.02211565,-0.14730613,-0.17470512,-0.093275465),vec4(0.58537334,0.20004189,0.5500497,0.28729665)) * bufB[4] + mat4(vec4(0.45421952,0.13528219,-0.054291993,-0.3453679),vec4(-9.889482e-06,0.52990794,-0.13457617,-0.2259933),vec4(0.09055856,-0.28468904,-0.24494353,-0.11068023),vec4(-0.5121114,0.21881375,-0.39349398,0.18050231)) * bufB[5] + mat4(vec4(0.10981339,-0.36066523,0.1915214,0.21997336),vec4(0.108919024,0.27597183,-0.0806879,0.056247007),vec4(0.27789003,-0.1475526,0.10784346,0.23531067),vec4(0.14801963,0.035275232,0.10522093,0.08327671)) * bufB[6] + mat4(vec4(-0.14408529,-0.13112889,-0.027131354,-0.10958887),vec4(-0.15243833,0.3577716,-0.4711345,0.33929405),vec4(-0.2774414,-0.14665599,-0.47382447,0.028156463),vec4(-0.12715966,0.39680383,0.17674567,-0.110876195)) * bufB[7];\nbufA[2] = vec4(0.019055462,0.14447379,-0.34947702,0.13434982) + mat4(vec4(-0.21135552,0.22302298,-0.14866622,-0.068202615),vec4(-0.12576878,-0.17938766,0.1876128,0.8926946),vec4(0.010276758,-0.18958534,0.14119576,0.025360614),vec4(0.46628228,-0.34506178,-0.08517061,-0.27274233)) * bufB[0] + mat4(vec4(0.42758352,-0.08124974,-0.37374064,0.25099778),vec4(-0.098376356,0.17254363,0.16671017,0.09643149),vec4(-0.2265984,-0.13300133,0.107140094,0.34211248),vec4(-0.060505193,-0.10791607,0.1644866,0.42682758)) * bufB[1] + mat4(vec4(-0.2250599,-0.18472219,0.01938969,-0.42255223),vec4(0.08864587,0.08033638,-0.18186782,-0.32577476),vec4(0.062796,-0.23825112,-0.5366263,-0.051250637),vec4(-0.22184408,-0.21017613,-0.016412979,-0.2759547)) * bufB[2] + mat4(vec4(0.23257756,-0.3789094,0.2284483,-0.0035125054),vec4(-0.059614673,0.0711873,-0.016729685,-0.03864277),vec4(-0.09914272,0.027150158,-0.18665452,-0.015077492),vec4(0.026614621,0.034370452,-0.07466538,0.15510231)) * bufB[3] + mat4(vec4(0.17319073,-0.13990936,0.05585848,-0.10027627),vec4(-0.41426516,-0.06177869,0.06821361,0.73668075),vec4(-0.037859213,-0.010270519,0.3110405,0.18669063),vec4(0.3123814,-0.2951236,-0.07732159,0.24011214)) * bufB[4] + mat4(vec4(0.098364376,-0.118802354,-0.2644919,0.10880301),vec4(0.029869733,0.02377175,-0.12178092,-0.40447208),vec4(0.04385899,-0.24922876,-0.25464445,0.056863308),vec4(-0.15773535,0.26482272,0.07397591,0.06967467)) * bufB[5] + mat4(vec4(0.08863419,-0.07802851,-0.14377615,0.15041326),vec4(0.18109514,-0.1176544,0.16172989,-0.20961335),vec4(0.010565409,0.06798156,0.15357247,-0.161065),vec4(0.06697788,-0.17692098,0.10274233,0.051953394)) * bufB[6] + mat4(vec4(-0.07548619,-0.082158186,-0.28122225,0.11740344),vec4(0.0011574067,0.48549005,-0.08735908,0.082048625),vec4(0.023064941,0.24576615,0.09252217,0.13997734),vec4(0.36950245,-0.20512061,-0.054345716,-0.37607273)) * bufB[7];\nbufA[3] = vec4(0.07192487,0.090707384,-0.25308228,0.3228292) + mat4(vec4(0.090566605,0.19618462,-0.20592591,0.03754247),vec4(0.02232253,-0.09372815,0.085391454,-0.18171853),vec4(-0.11730842,-0.043168724,0.07451116,-0.050294988),vec4(-0.19266221,-0.09259376,0.06468556,0.12177951)) * bufB[0] + mat4(vec4(-0.10825888,0.13464364,0.050241522,-0.14687221),vec4(0.44172964,0.22900726,0.11822736,-0.1855254),vec4(-0.07536456,-0.13346842,0.1425361,0.09652498),vec4(0.24859992,0.2594749,0.221165,0.03216487)) * bufB[1] + mat4(vec4(-0.026819225,-0.31035644,0.039979752,0.017237643),vec4(0.22148049,-0.010268043,-0.32292488,-0.03086583),vec4(0.054279447,0.1832313,0.021697275,-0.11224984),vec4(0.056242652,0.026145745,-0.11655155,0.051776126)) * bufB[2] + mat4(vec4(-0.47771874,0.2109898,0.24332958,0.0064064655),vec4(-0.112506345,0.08770519,-0.0296909,0.19999355),vec4(0.13490887,-0.20355028,-0.1500638,-0.21442801),vec4(0.27932778,0.06719929,0.33129445,0.008096962)) * bufB[3] + mat4(vec4(-0.219677,-0.1775961,0.08972463,-0.02147406),vec4(-0.13714571,-0.1164257,0.750605,-0.04697257),vec4(-0.005127403,0.12859714,-0.36174884,-0.13077016),vec4(0.3385022,0.023568183,0.29743963,-0.43503505)) * bufB[4] + mat4(vec4(-0.23754369,0.068073235,-0.1286379,-0.08060392),vec4(-0.23664008,0.037983205,-0.28744477,-0.18605472),vec4(0.066216476,0.011303179,0.021062184,0.22279204),vec4(-0.13230412,0.03968395,0.0030035777,-0.032991305)) * bufB[5] + mat4(vec4(0.26768264,-0.20512417,-0.10492823,0.2403094),vec4(-0.45142886,-0.10664608,0.17376682,0.20300676),vec4(0.11172015,0.044723902,-0.0043862746,0.46753523),vec4(-0.1930267,-0.075443596,0.26804084,-0.0249144)) * bufB[6] + mat4(vec4(-0.05514406,0.0303952,0.12639478,0.00976541),vec4(0.11204835,0.0010461246,-0.069163695,0.2411889),vec4(0.17334564,-0.32057077,-0.2634405,-0.015499812),vec4(0.111427434,0.19105275,-0.22183956,-0.01888428)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.39710754,0.36970067,0.03894373,-0.20966533) + mat4(vec4(-0.35153884,0.3302973,-0.41600356,-0.069849014),vec4(-0.117502026,-0.070716664,0.21356106,0.07897027),vec4(0.098850936,-0.25980055,-0.13445748,-0.18323559),vec4(-0.17147058,0.103598595,-0.16992912,-0.32062566)) * bufB[0] + mat4(vec4(-0.5391703,0.65609324,-0.5441714,-0.31008753),vec4(0.22067298,0.14960691,-0.028369991,0.0064776586),vec4(-0.20542784,0.03782629,-0.34319988,0.02981931),vec4(-0.011809164,-0.0942793,0.0861988,-0.046270385)) * bufB[1] + mat4(vec4(-0.18972169,0.2209111,-0.0050571477,0.25438517),vec4(0.38178483,-0.13275132,0.083082646,-0.080841735),vec4(0.33014417,-0.30245104,-0.09336538,0.20449015),vec4(0.38880977,-0.023471845,-0.04185761,0.114075676)) * bufB[2] + mat4(vec4(0.07153669,-0.22397883,0.020369323,0.07345473),vec4(-0.123626396,-0.04858658,-0.19607234,0.20412162),vec4(0.106453106,-0.030644285,-0.30858442,0.24161431),vec4(-0.070055,0.017446415,-0.024274783,0.19595702)) * bufB[3] + mat4(vec4(-0.08694956,-0.086623475,0.10747022,0.10730196),vec4(0.040028777,0.47597477,-0.3264221,0.105672926),vec4(0.16343024,-0.18164703,0.039865617,-0.05240953),vec4(0.023876714,0.1916719,-0.051696494,-0.13263573)) * bufB[4] + mat4(vec4(-0.16298859,0.038917277,-0.22950645,-0.29201004),vec4(0.109270945,-0.1359308,0.095925696,0.10827802),vec4(0.2974624,-0.055611685,-0.14435022,-0.7659367),vec4(0.0066868574,-0.09405242,-0.26661605,0.08023982)) * bufB[5] + mat4(vec4(-0.3556243,0.23196611,-0.18139917,-0.0759286),vec4(-0.34372145,0.17390159,-0.12507978,-0.08929961),vec4(0.054460578,-0.1198581,0.38809356,0.24342848),vec4(-0.40630206,-0.30635783,-0.31294492,-0.30972448)) * bufB[6] + mat4(vec4(-0.19468924,-0.270233,0.044715922,0.06558922),vec4(0.2111023,-0.007406596,0.05073317,-0.0026912254),vec4(0.18645273,0.08479669,0.10021407,0.08412685),vec4(-0.23887585,0.26446173,0.2835644,0.016297596)) * bufB[7];\nbufA[1] = vec4(-0.4252311,-0.25965598,-0.45697817,0.40770972) + mat4(vec4(-0.09312968,0.6316469,-0.20538579,0.25824633),vec4(-0.0884748,0.11774356,-0.040738247,0.06367038),vec4(0.36807296,0.11488231,0.18133964,-0.13440898),vec4(-0.010212178,-0.19445433,-0.31999254,0.074339524)) * bufB[0] + mat4(vec4(-0.012749273,-0.13577181,-0.224451,0.09518388),vec4(-0.021444138,-0.36994004,0.11551499,-0.26797718),vec4(0.4381803,0.771809,0.38294172,0.6498332),vec4(0.21829164,-0.29483712,0.026159951,-0.010299032)) * bufB[1] + mat4(vec4(-0.05624921,-0.11953161,-0.50704134,0.33160928),vec4(-0.116122216,0.09975964,0.24287248,-0.41315043),vec4(0.17717737,0.10559968,0.09974579,-0.316456),vec4(-0.13172756,0.30124253,-0.19433625,-0.044026844)) * bufB[2] + mat4(vec4(0.24080308,0.07086402,0.1823437,0.28874838),vec4(0.059513114,0.038871516,0.24040654,-0.032864224),vec4(0.48010293,0.9990147,0.09618825,0.55655956),vec4(0.3521221,-0.0010982461,0.13433148,0.14686915)) * bufB[3] + mat4(vec4(-0.04905972,0.09327666,-0.18497255,0.26504713),vec4(0.042781882,0.3488114,0.26804602,0.5079527),vec4(-0.07165692,-0.3383651,-0.06382027,-0.15190287),vec4(-0.11775625,0.0128387455,-0.0428932,-0.26599905)) * bufB[4] + mat4(vec4(0.30697146,0.31223553,-0.18925779,0.089731954),vec4(-0.059639864,0.54036963,0.36464036,-0.067572996),vec4(0.03924906,-0.7881748,-0.0057957377,-0.23007786),vec4(0.14835773,-0.078868195,-0.23166034,-0.36747116)) * bufB[5] + mat4(vec4(-0.10569531,-0.05249115,-0.18466167,0.006667736),vec4(-0.17993696,0.3153741,-0.046212427,0.11187254),vec4(-0.42890722,0.08446343,-0.19472907,-0.1300341),vec4(-0.23763916,0.055724416,0.1803603,0.1335743)) * bufB[6] + mat4(vec4(-0.17697217,-0.24322814,-0.012183524,0.101929404),vec4(-0.09593462,-0.004837192,-0.3721036,-0.07074622),vec4(-0.08510244,-0.22126701,0.08813386,-0.31850705),vec4(-0.044809688,0.017099965,-0.14327385,-0.050672274)) * bufB[7];\nbufA[2] = vec4(-0.4311452,0.28922155,0.29235876,-0.24152634) + mat4(vec4(0.07903165,-0.36566633,0.37707445,-0.041451566),vec4(-0.1826641,0.09674712,-0.09893292,0.09798829),vec4(0.19531894,0.13041836,-0.090115756,0.12474374),vec4(-0.2739334,-0.041466884,0.13253479,0.032641735)) * bufB[0] + mat4(vec4(0.29960272,-1.1063052,0.44724762,-0.34713486),vec4(0.14312565,-0.41710472,0.18417297,-0.47529954),vec4(0.07080318,0.20773329,0.41559428,0.46824282),vec4(0.22850916,-0.27077183,0.027202653,0.24241735)) * bufB[1] + mat4(vec4(-0.020837463,-0.2618217,0.2957077,-0.22362562),vec4(0.0460816,0.028058646,-0.21248323,0.63697284),vec4(-0.074953035,-0.12085683,-0.036706243,-0.04248108),vec4(-0.10101777,-0.18956782,0.13136974,-0.15257551)) * bufB[2] + mat4(vec4(0.37638324,0.23067173,0.114254676,0.10328754),vec4(-0.018840747,0.26456136,-0.08397385,0.12394976),vec4(-0.07040562,0.055198193,0.079854086,0.30884695),vec4(-0.2077155,-0.16924758,-0.18868478,0.028671365)) * bufB[3] + mat4(vec4(-0.3755175,0.09614366,0.46560743,0.015173137),vec4(-0.30176845,-0.15822473,-0.12578394,-0.16756165),vec4(0.26689819,-0.049470577,-0.23135228,-0.23844515),vec4(-0.056845557,0.12088791,-0.09270261,-0.18538058)) * bufB[4] + mat4(vec4(-0.15602747,0.105411515,1.2879535,0.011002065),vec4(-0.03558585,-0.122351676,-0.03092357,0.0029528034),vec4(-0.32330987,0.20200972,-0.12114515,0.08989225),vec4(0.1691637,-0.06443414,0.33149987,0.05760869)) * bufB[5] + mat4(vec4(-0.14505017,0.0042505204,0.10253664,0.06411686),vec4(-0.2141329,-0.43066925,0.3028341,-0.020450387),vec4(-0.04316395,0.19410565,0.09457207,-0.17540719),vec4(-0.08934766,-0.13553813,-0.22934124,-0.2585693)) * bufB[6] + mat4(vec4(0.11383139,0.2693286,-0.09315268,-0.2106468),vec4(-0.345014,-0.27789202,-0.17091075,0.05494222),vec4(0.046131283,0.187255,-0.46574542,-0.40160078),vec4(-0.0076585733,-0.22481239,-0.16142681,-0.26152986)) * bufB[7];\nbufA[3] = vec4(-0.50812984,-0.22253053,0.086367734,-0.22806235) + mat4(vec4(-0.24305175,0.17248172,0.41446382,-0.21560971),vec4(0.18770774,-0.17424591,-0.10316217,0.11186131),vec4(0.4238692,-0.3920134,-0.1893456,-0.29385257),vec4(0.4563422,-0.10388189,0.05958735,0.06010079)) * bufB[0] + mat4(vec4(-0.30389455,0.42802003,0.8725936,-0.3214771),vec4(0.20117922,0.29430833,-0.05816787,0.18623175),vec4(-0.06807196,-0.11047074,0.11601387,0.015461788),vec4(0.57250375,-0.14062324,-0.003203052,-0.24089593)) * bufB[1] + mat4(vec4(-0.18021038,-0.021818608,0.28250247,0.29850206),vec4(0.60046226,-0.07981263,-0.33156937,0.11792242),vec4(-0.25391984,-0.15469813,-0.104421936,0.22754885),vec4(-0.004700346,0.030044593,-0.10212382,0.34227186)) * bufB[2] + mat4(vec4(-0.06508865,-0.29980692,0.24557894,-0.19919895),vec4(-0.103779934,-0.011606459,-0.04430975,-0.24172854),vec4(0.09516983,0.0155229755,0.12605822,-0.2557094),vec4(0.30967438,0.04703041,0.25453374,-0.16567785)) * bufB[3] + mat4(vec4(-0.032498308,0.05110082,-0.09906294,-0.13132322),vec4(-0.05763463,0.40163308,0.2892433,0.16792013),vec4(-0.3068525,-0.14486387,0.13622235,0.23121941),vec4(0.31188557,0.19661477,0.10164289,0.053185634)) * bufB[4] + mat4(vec4(-0.31251132,-0.09547891,0.037314158,-0.05178445),vec4(-0.345964,-0.036733262,0.1277667,-0.01821777),vec4(0.2218953,-0.24993408,-0.17360395,-0.10421119),vec4(-0.060467713,0.19899502,0.31427222,0.039283883)) * bufB[5] + mat4(vec4(-0.036927227,-0.096162796,0.26249233,-0.028164841),vec4(0.06838117,0.11012363,0.16706526,-0.2802495),vec4(-0.04697937,-0.118505254,0.103109464,-0.21504486),vec4(-0.0040437914,0.22636226,0.28593308,-0.42263713)) * bufB[6] + mat4(vec4(0.0015212486,-0.050108485,0.06351831,0.32013896),vec4(0.13708286,-0.042787895,-0.05896903,-0.27725312),vec4(0.19770524,0.13890459,-0.2111458,-0.010693621),vec4(0.1799451,-0.0805696,-0.038879152,0.04739002)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.4098643,-0.22162712,-0.0106656505,-0.19575255) + mat4(vec4(0.044021882,-0.35077572,-0.070327975,0.14808959),vec4(0.013641225,-0.023385487,0.16115426,-0.053704344),vec4(0.20487708,-0.21367794,-0.14245893,0.5178062),vec4(0.15816353,-0.1562271,-0.021748386,0.060734116)) * bufB[0] + mat4(vec4(0.1451071,-0.06251675,-0.34588325,-0.06542721),vec4(0.16053374,0.032252554,-0.014597085,-0.10958718),vec4(0.26381698,0.19511083,-0.10857928,0.06166282),vec4(-0.28573948,0.4313286,-0.12932226,-0.25728086)) * bufB[1] + mat4(vec4(-0.17223565,-0.14128315,-0.2402214,-0.09287419),vec4(0.12289427,-0.17795762,0.15790403,0.098198116),vec4(-0.18493114,0.15835613,-0.164285,-1.1435561),vec4(0.00084436534,0.12084137,-0.061833926,-0.39360952)) * bufB[2] + mat4(vec4(0.33503056,0.17814156,-0.23112291,-3.1744363e-05),vec4(0.47820055,-0.3590769,0.097099714,0.07493211),vec4(0.21118285,0.081778914,0.12990455,-0.52120364),vec4(0.036820136,-0.24006052,0.07704751,0.25976714)) * bufB[3] + mat4(vec4(0.013832727,-0.3446503,0.07236197,-0.14600895),vec4(0.19921446,0.06792277,0.17861888,-0.06867764),vec4(-0.48783368,0.017001934,-0.27202564,-0.14960495),vec4(0.2850885,0.45365107,0.2225599,-0.27338538)) * bufB[4] + mat4(vec4(0.190241,0.18152134,0.32800883,0.26835057),vec4(0.29357526,-0.42799878,0.008184995,0.37269437),vec4(0.1724092,0.02659935,-0.1138373,-0.045707513),vec4(-0.097353555,-0.30268663,0.08843672,0.5589757)) * bufB[5] + mat4(vec4(0.06875293,0.03397961,0.34982938,-0.18609074),vec4(0.11820037,0.11802288,0.4273925,-0.084380046),vec4(-0.29596075,0.12395662,0.19191393,-0.055305652),vec4(-0.04803774,-0.115116134,0.3154349,0.11503649)) * bufB[6] + mat4(vec4(0.24252391,-0.051813427,-0.20562725,0.05930504),vec4(0.31269166,-0.37171477,0.0350098,-0.047703166),vec4(0.25528124,0.05175645,-0.3288669,-0.35869393),vec4(0.23330908,0.28975827,-0.24924354,-0.013611936)) * bufB[7];\nbufA[1] = vec4(0.13382225,0.33783382,0.15219368,0.023796279) + mat4(vec4(0.035194393,-0.23417673,-0.16108096,-0.29178986),vec4(-0.16341567,-0.3044453,-0.15194473,0.50847673),vec4(0.32627103,-0.09208942,-0.0946733,-0.6063414),vec4(0.09458425,-0.037205994,-0.18025504,-0.20091867)) * bufB[0] + mat4(vec4(-0.005450828,-0.16469681,0.039418798,-0.019819153),vec4(-0.19415052,-0.27784824,-0.014021413,0.037119858),vec4(0.008160014,-0.0119123105,0.11864781,0.033875663),vec4(-0.15535195,0.020901999,-0.005837216,-0.27398425)) * bufB[1] + mat4(vec4(-0.060967695,0.076332875,0.24979948,-0.039992627),vec4(0.07591766,-0.4908525,0.012119308,-0.43341142),vec4(0.2774481,-0.35999277,0.044305414,0.5043068),vec4(0.17083822,0.13143554,-0.20298465,0.019450258)) * bufB[2] + mat4(vec4(-0.34345025,0.032434527,-0.1519882,0.13407895),vec4(0.14821559,-0.081182204,0.20013152,-0.016103897),vec4(-0.24320847,0.61562407,-0.118989475,0.5595298),vec4(0.12698625,0.061256472,-0.09169847,-0.06470242)) * bufB[3] + mat4(vec4(-0.022439841,-0.20496231,0.3090038,0.333923),vec4(0.10025019,-0.17342652,0.21760882,-0.04826297),vec4(0.25683895,0.16517356,-0.26731646,-0.0049413256),vec4(-0.42370838,0.14466582,-0.0034609067,0.1551288)) * bufB[4] + mat4(vec4(0.14221062,0.06516307,0.04792778,0.03519148),vec4(0.32514602,-0.6186777,0.45814207,-0.24125192),vec4(0.2155554,0.20648523,0.0072147725,0.31046712),vec4(0.33490914,-0.33970806,0.02594941,0.3858224)) * bufB[5] + mat4(vec4(-0.058859278,0.005212731,0.35066378,-0.004690296),vec4(-0.3039019,-0.24050093,0.016088707,0.3524348),vec4(-0.71835536,0.009688053,-0.053771388,-0.27545917),vec4(0.022923177,0.23612124,0.49332243,0.1988715)) * bufB[6] + mat4(vec4(0.017430857,-0.24790744,0.29157007,-0.20682104),vec4(0.23827045,0.0889294,0.35836014,-0.024311604),vec4(0.119404055,0.21057335,-0.14843705,0.45182267),vec4(-0.22757977,0.04268911,0.15825726,-0.34916332)) * bufB[7];\nbufA[2] = vec4(-0.17246883,0.25682682,0.15492539,-0.26158005) + mat4(vec4(-0.07833304,-0.046818886,0.6525991,-0.58428293),vec4(0.10036265,0.03160599,-0.2983827,0.028045518),vec4(0.1586762,-0.04631258,0.14018585,-0.47061846),vec4(-0.07740971,-0.16502558,0.14332016,-0.114871494)) * bufB[0] + mat4(vec4(-0.27436137,0.41606545,-0.16570945,0.22146688),vec4(-0.099178836,0.06833008,-0.14559262,0.041363683),vec4(-0.026633492,-0.12082238,0.34898978,-0.0671909),vec4(0.034966566,0.112281665,0.030320993,0.3183781)) * bufB[1] + mat4(vec4(0.068538055,0.17555563,-0.1067462,0.019079054),vec4(-0.034789868,0.021980194,0.45840362,-0.5100868),vec4(-0.4455029,0.072457165,0.03818731,0.7563107),vec4(-0.09449155,0.5187771,-0.13989115,0.100532025)) * bufB[2] + mat4(vec4(-0.079890974,-0.06713117,0.17921594,0.03005944),vec4(0.40349215,-0.29136842,-0.005603915,0.05221125),vec4(0.28892776,-0.1362067,-0.8448629,0.47414654),vec4(-0.022702081,0.30906275,0.098973274,0.07045208)) * bufB[3] + mat4(vec4(-0.27382022,-0.18669863,-0.11822698,0.36116266),vec4(-0.13266604,-0.1503057,-0.47462168,0.025471473),vec4(-0.3894167,0.23353884,0.2057649,0.057367545),vec4(0.28525794,0.06409486,-0.044230733,-0.1826985)) * bufB[4] + mat4(vec4(0.123133734,-0.47084963,-0.117063925,-0.37457442),vec4(-0.58497024,-0.5154835,0.110903285,0.12216852),vec4(0.10465639,-0.349695,-0.13768573,0.044628303),vec4(-0.34274194,0.13610153,0.29070148,0.15813668)) * bufB[5] + mat4(vec4(-0.029965756,0.14223133,0.17583768,-0.5287359),vec4(0.08029318,-0.113571376,-0.47916958,0.14302148),vec4(0.4241317,-0.13295713,-0.0037221175,-0.489995),vec4(0.15439335,-0.927462,0.053149723,0.09410631)) * bufB[6] + mat4(vec4(-0.39019534,-0.25636834,0.1370442,-0.07076331),vec4(0.16905926,-0.13333431,-0.079018414,-0.025361862),vec4(-0.06917629,0.26908532,0.040919602,0.80719143),vec4(0.3303094,0.077553205,0.007477696,0.005309009)) * bufB[7];\nbufA[3] = vec4(-0.0074996334,-0.34122238,0.20586245,-0.17742097) + mat4(vec4(-0.45050955,-0.03924012,0.15713271,-0.32865784),vec4(-0.28103358,-0.23066916,-0.16511975,-0.036798146),vec4(0.39360514,0.07668255,0.015849678,-0.3223678),vec4(0.20395836,-0.2959583,0.13482039,-0.16427526)) * bufB[0] + mat4(vec4(-0.22687535,-0.29893976,-0.398391,0.41433722),vec4(-0.002448448,-0.15123679,-0.6447542,0.08701238),vec4(-0.099424206,-0.1611208,0.0113703925,-0.15508613),vec4(-0.21620329,-0.1590793,-0.3671289,0.3204302)) * bufB[1] + mat4(vec4(0.04979674,-0.058688443,-0.18424092,-0.32860002),vec4(0.03409453,0.10197401,-0.011032897,0.31472608),vec4(-0.05619544,0.060695194,-0.07970973,0.4780369),vec4(-0.022176055,-0.101359606,-0.1146663,-0.009009269)) * bufB[2] + mat4(vec4(-0.15765266,-0.07500625,-0.004417093,-0.035282232),vec4(-0.30789876,-0.13761805,-0.006030405,-0.20053843),vec4(-0.09517253,0.006204702,-0.16067043,0.1493774),vec4(-0.24004214,-0.20292811,-0.022818342,-0.060386013)) * bufB[3] + mat4(vec4(-0.323533,-0.11846809,-0.08603567,0.16739291),vec4(0.52727926,0.636749,-0.06379065,0.03486404),vec4(-0.02645408,0.20155619,-0.17213178,0.35431483),vec4(0.13300323,-0.14964266,0.22393337,0.25425053)) * bufB[4] + mat4(vec4(0.023423325,0.1297874,0.27219477,-0.076842085),vec4(0.1633227,0.21970172,0.8331686,-0.35736027),vec4(0.058213595,-0.026048046,0.14217524,0.14234945),vec4(0.28861687,0.16572303,-0.38721052,-0.5844295)) * bufB[5] + mat4(vec4(-0.11911712,0.08739818,0.09036134,-0.12631671),vec4(0.1255487,0.059556775,-0.23789936,0.08653341),vec4(-0.8489969,-0.24363953,-0.24248604,0.5394326),vec4(-0.17079972,0.13837503,0.10639719,-0.3826407)) * bufB[6] + mat4(vec4(0.15719932,0.1318186,0.31593502,-0.2540701),vec4(0.15852626,0.09214467,0.01602397,-0.07879139),vec4(-0.40043375,0.23708954,-0.18186826,0.25047362),vec4(0.03966082,0.11609335,-0.37359786,0.031031014)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.010965682566165924,0.041177909821271896,-0.021019630134105682,0.0) + mat4(vec4(0.17682114243507385,0.11206067353487015,0.013897061347961426,0.0),vec4(0.015018664300441742,0.02891748957335949,-0.02796241082251072,0.0),vec4(0.09019622951745987,0.07711819559335709,0.05866215378046036,0.0),vec4(0.10263877362012863,0.06916158646345139,0.04822903871536255,0.0)) * bufB[0] + mat4(vec4(-0.05645087733864784,0.000506965967360884,0.284607857465744,0.0),vec4(-0.12848560512065887,-0.17838427424430847,-0.14302080869674683,0.0),vec4(0.10034198313951492,0.09258326143026352,0.042934905737638474,0.0),vec4(-0.06901594251394272,-0.15133517980575562,-0.3630870580673218,0.0)) * bufB[1] + mat4(vec4(-0.22743825614452362,-0.16717107594013214,-0.1598612517118454,0.0),vec4(-0.24642525613307953,-0.06950344890356064,-0.1140657439827919,0.0),vec4(0.045923687517642975,0.10010629147291183,0.10563818365335464,0.0),vec4(0.009499027393758297,0.05923071876168251,-0.032607175409793854,0.0)) * bufB[2] + mat4(vec4(0.10648979991674423,0.3068753778934479,0.38804230093955994,0.0),vec4(0.004063596483319998,0.09314116835594177,0.08817297965288162,0.0),vec4(0.18595252931118011,0.18810303509235382,0.10820192098617554,0.0),vec4(-0.24722005426883698,-0.23707833886146545,0.023157570511102676,0.0)) * bufB[3] + mat4(vec4(-0.0072428141720592976,0.014990939758718014,-0.027959134429693222,0.0),vec4(-0.15315429866313934,-0.16676495969295502,-0.1113724336028099,0.0),vec4(-0.02634856104850769,-0.05461461469531059,-0.024826938286423683,0.0),vec4(-0.0057954988442361355,-0.40381133556365967,-0.052187129855155945,0.0)) * bufB[4] + mat4(vec4(-0.06913984566926956,-0.10481500625610352,-0.18821905553340912,0.0),vec4(-0.059209488332271576,-0.08970936387777328,-0.0940219834446907,0.0),vec4(0.02225230261683464,0.14280344545841217,0.07539992034435272,0.0),vec4(0.026777595281600952,-0.051612187176942825,-0.12427230179309845,0.0)) * bufB[5] + mat4(vec4(-0.08053747564554214,-0.09150996059179306,-0.17888501286506653,0.0),vec4(0.10597898066043854,0.18119686841964722,0.2198641449213028,0.0),vec4(0.08360499143600464,-0.12563562393188477,-0.23824062943458557,0.0),vec4(-0.03951389342546463,0.3119222819805145,0.07497544586658478,0.0)) * bufB[6] + mat4(vec4(-0.07975675165653229,0.04801741614937782,0.30742284655570984,0.0),vec4(-0.005213810130953789,0.01232089102268219,0.024966951459646225,0.0),vec4(-0.1428150236606598,-0.1053566038608551,-0.036848071962594986,0.0),vec4(-0.25036415457725525,-0.050241779536008835,-0.11459049582481384,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime), sin(2.*iTime), sin(3.*iTime), sin(4.*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 145, 145, 66677], [66679, 66679, 66736, 66786, 67210]]}
{"id": "3s2GDt", "name": "Unexpected", "author": "AdrianPi", "description": "Simple animation - Will disable AA on full-screen", "tags": ["raytracing", "antialias", "animation"], "likes": 5, "viewed": 98, "published": "Public", "date": "1550285170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 dirInv;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\nconst int BOX_PRIMITIVE = 4;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\nconst float EPSILON4 = 1e-4;\n\nvec3 viewFrom = vec3(0,-8,4);\nvec3 viewAt = vec3(-1,0,0);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 3;\n\nvec4 skyColor = vec4(0.5,0.5,1,1);\nvec4 horizonColor = vec4(0.8,0.8,1,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(0.2,0.2,0.2,1), \n                                   vec4(0.2,0.2,0.2,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   CHECKER_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.54));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(1.0,0.3,0.3,1), \n                                   vec4(1.0,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,1,1), \n                                   vec4(0.3,0.3,1,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, \n                                        material3, material4, material5, material6);\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(3, 3, 1), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _ring = primitive_t(RING_PRIMITIVE, 4, vec3(0,0,0), normalize(vec3(-0.5, 0, 1)), vec3(2, 1.5, 0));\nconst primitive_t _box = primitive_t(BOX_PRIMITIVE, 5, vec3(2, 2, -3), vec3(4, 4, 0), vec3(0,0,0));\n//const primitive_t _box2 = primitive_t(BOX_PRIMITIVE, 6, vec3(5, 5, -3), vec3(9, 9, 1), vec3(0,0,0));\n\nconst int NUM_PRIMS = 3;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _box);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.dirInv = vec3(1) / ray.dir;\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 5.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool hit_box(vec3 p0, vec3 p1, int mat, ray_t ray, inout hit_t hit)\n{\n    float txmin = (p0.x - ray.pos.x) * ray.dirInv.x;\n    float txmax = (p1.x - ray.pos.x) * ray.dirInv.x;\n    float tymin = (p0.y - ray.pos.y) * ray.dirInv.y;\n    float tymax = (p1.y - ray.pos.y) * ray.dirInv.y;\n    float tzmin = (p0.z - ray.pos.z) * ray.dirInv.z;\n    float tzmax = (p1.z - ray.pos.z) * ray.dirInv.z;\n    \n    float tmin = max(max(min(txmin, txmax), min(tymin, tymax)), min(tzmin, tzmax));\n    float tmax = min(min(max(txmin, txmax), max(tymin, tymax)), max(tzmin, tzmax));\n    \n    if(tmax < EPSILON || tmin > tmax)\n    {\n        return false;\n    }\n    \n    if(tmin < EPSILON)\n    {\n        tmin = tmax; // inside the box\n    }\n    \n    \n    if(tmin > EPSILON)\n    {\n        hit.t = tmin;\n        hit.pos = ray.pos + ray.dir * hit.t;\n        \n        if(hit.pos.x < p0.x+EPSILON4)\n            hit.normal = vec3(-1, 0, 0);\n        else if(hit.pos.x > p1.x-EPSILON4)\n            hit.normal = vec3(1,0,0);\n        else if(hit.pos.y < p0.y+EPSILON4)\n            hit.normal = vec3(0, -1, 0);\n        else if(hit.pos.y > p1.y-EPSILON4)\n            hit.normal = vec3(0, 1, 0);\n        else if(hit.pos.z < p0.z+EPSILON4)\n            hit.normal = vec3(0, 0, -1);\n        else if(hit.pos.z > p1.z-EPSILON4)\n            hit.normal = vec3(0, 0, 1);\n        \n        hit.mat = mat;\n        return true;\n    }\n    \n    return false;\n}\n\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.2, 1);\nvec3 lightDirection = normalize(vec3(0.666,0.333,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 4)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON4;\n    sray.dir = -lightDirection;\n    sray.dirInv = vec3(1) / sray.dir;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    float t = mod(iTime, 6.0);\n    if(t > 2.65)\n    {\n        vec3 center = vec3(-4,3,-3);\n        vec3 q = hit.pos - center;\n        vec3 dir = normalize(q);\n        float d = sqrt(dot(q,q));\n        float amp = clamp(4. / d, 0., 1.);  \n        amp *= (2.65/(t*6.));\n        float l = cos(d-t*2.0*4.0);\n        hit.normal += dir * l * 9.0 * amp;\n        hit.normal = normalize(hit.normal);\n        hit.pos += dir * l * 1.6 * amp;\n    }\n    \n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n    \n    \n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }\n        \n        // fog\n\n        float f = (hit.t - 10.0) / (50.0-10.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        case BOX_PRIMITIVE:\n            result = hit_box(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nfloat easeIn(float t)\n{\n    t = t * t;\n    return t;\n}\n\nfloat animZ(float t)\n{\n    if(t < 1.0)\n    {\n        return 1.0;\n    }\n    else\n    {\n    \treturn -2.0 + abs(cos(t-1.0)) * 3.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    if(iResolution.x > 640.0)\n        oversample = 1;\n    \n    float t = mod(iTime, 6.0);\n    \n    prims[1].v0.x = 3.0-easeIn(t);\n    prims[1].v0.z = animZ(t);\n    \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n    \n    for(int i = 0; i < oversample; i++)\n    {\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2GDt.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[4663, 4872, 4911, 4911, 5112], [5114, 5114, 5142, 5142, 5255], [5257, 5257, 5338, 5338, 6157], [6159, 6159, 6234, 6234, 6592], [6594, 6594, 6688, 6688, 7231], [7233, 7233, 7302, 7302, 8642], [8800, 8800, 8828, 8828, 8953], [8955, 8955, 8989, 8989, 9144], [9146, 9146, 9168, 9168, 9197], [9245, 9245, 9288, 9288, 10967], [10969, 10969, 11011, 11011, 11806], [11808, 11808, 11842, 11842, 12405], [12407, 12407, 12451, 12451, 13300], [13302, 13302, 13328, 13328, 13408], [13410, 13410, 13433, 13433, 13464], [13466, 13466, 13488, 13488, 13601], [13603, 13603, 13660, 13660, 14679]]}
{"id": "3s2GWK", "name": "weird alien planes", "author": "Emil", "description": "Projected planes and some experimentation regarding multiple samples at different height", "tags": ["parallax", "weird", "perspective"], "likes": 15, "viewed": 377, "published": "Public", "date": "1550010236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = normalize(vec3((fragCoord-iResolution.xy*0.5)/iResolution.y, 0.65+sin(iTime*0.2)*0.2));\n    viewDir = mix(cross(viewDir, vec3(sin(iTime*0.6)*0.6,cos(iTime*0.15)*0.2,sin(iTime*0.2)*0.3)), viewDir, 4.6+sin(iTime*0.14));\n\tvec3 camRay;\n    vec4 groundPlane = vec4(0.0);\n    \n    float oldLength = 0.0;\n    float absviewDirY = abs(viewDir.y);\n    for(float i = -0.4; i < 1.0; i+=0.01){\n\t\tcamRay = viewDir/(absviewDirY+float(i)*0.4*absviewDirY);\n        \n        vec4 newSample = texture(iChannel0, (camRay.xz + vec2(0.4, iTime))*0.01);\n        float heightSample = texture(iChannel1, (camRay.xz + vec2(0.4, iTime))*0.1).r;\n        float heightSample_o = texture(iChannel1, (camRay.xz + vec2(0.4, iTime))*0.1 + vec2(0.0, 0.01)).r;\n        float zDelta = heightSample - heightSample_o;\n        if(smoothstep(i, 1.0, heightSample+0.3)>0.45){\n            float newLength = 1.0/length(camRay);\n            if(newLength>oldLength){\n                oldLength = newLength;\n                groundPlane = newSample*(i*1.5+1.0);\n                groundPlane *= vec4(0.8)-vec4(zDelta*-4.0+0.9)*(newLength+0.2)+smoothstep(0.5,0.0,absviewDirY);\n                \n            }\n        }\n    }\n    \n    fragColor = groundPlane+vec4(0.1,0.3,0.5,0.0)*oldLength;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2GWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1316]]}
{"id": "3s2GWw", "name": "Kelvin waves / ship waves (191ch", "author": "FabriceNeyret2", "description": "golfed/simplified version of [url]https://shadertoy.com/view/4llBRl[/url]", "tags": ["2d", "waves", "water", "fluid", "physics", "short", "golf", "wake"], "likes": 8, "viewed": 579, "published": "Public API", "date": "1549027268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfed/simplified version of https://shadertoy.com/view/4llBRl\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    for (float L = 25e2, l, x = 0.; x<=5.; x += .005 )\n        l  = L* length( (u+u-R)/R.y  - vec2( x-1.2, .2*sin(x+x-iTime)) ),\n        O -= cos( sqrt(.3/l) *x*L ) / l * exp((L-l)*(l-L)/5e6);\n    O = .5 + O*5.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2GWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 103, 103, 346]]}
{"id": "3sB3Wd", "name": "Heart Function", "author": "dr2", "description": "Using the function from https://imaginary.org (in honor of Valentine's day)", "tags": ["surface", "intersect"], "likes": 3, "viewed": 335, "published": "Public API", "date": "1550238301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Heart Function\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar, a, b;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, v1, v2;\n  q = p.xzy;\n  v1 = (1. + b) * q.y;\n  v2 = q.x * q.x + v1 * v1 + q.z * q.z - 1.;\n  d = v2 * v2 * v2 - (q.x * q.x + a * q.y * q.y) * q.z * q.z * q.z;\n  return d;\n}\n\nvec2 BallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float dbIn, dbOut, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  dbIn = dstFar;\n  dbOut = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    dbIn = - b - d;\n    dbOut = - b + d;\n  }\n  return vec2 (dbIn, dbOut);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec2 bnd;\n  float dHit, h, s, ds, sLo, sHi;\n  const float nDiv = 200.;\n  dHit = dstFar;\n  bnd = BallHit (ro, rd, vec3 (0.), 2.);\n  if (bnd.x < dstFar) {\n    s = bnd.x;\n    sLo = bnd.x;\n    ds = (bnd.y - bnd.x) / nDiv;\n    for (float j = 0.; j < nDiv; j ++) {\n      h = ObjDf (ro + s * rd);\n      if (h < 0. || s > bnd.y) break;\n      sLo = s;\n      s += ds;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (float j = 0.; j < 16.; j ++) {\n        s = 0.5 * (sLo + sHi);\n        if (ObjDf (ro + s * rd) > 0.) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.00001, -0.00001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, vDotL;\n  a = 0.5 + 0.45 * sin (1.5 * tCur);\n  b = 0.5 + 0.45 * sin (1.4 * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (1., 0.3, 0.3, 0.2);\n    vDotL =  max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * vDotL * vDotL) +\n       col4.a * vec3 (1., 1., 0.) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0.1, -8.);\n  zmFac = 5.;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sB3Wd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 218, 240, 240, 432], [434, 434, 484, 484, 733], [735, 735, 768, 768, 1376], [1378, 1378, 1399, 1399, 1593], [1595, 1595, 1630, 1630, 2192], [2236, 2236, 2292, 2292, 3503], [3505, 3505, 3535, 3535, 3648]]}
{"id": "3sB3WG", "name": "ellipsoidal confocal coordinates", "author": "FabriceNeyret2", "description": "Orthogonal ellipsoidal coordinates on the ellipsoid (i.e. 3rd coordinate = 0).\nTune ellipsoid radii (a,b,c) and number of subdiv n.\ncf [url]https://en.wikipedia.org/wiki/Ellipsoidal_coordinates[/url]\n[url]https://www.desmos.com/calculator/nm8yvhj5zi[/url]", "tags": ["raymarching", "ellipsoid", "short", "confocal"], "likes": 10, "viewed": 463, "published": "Public API", "date": "1549822308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fork from https://www.shadertoy.com/view/4lBczR\n\nconst float a = 2., b = 1.5, c = 1., n=8.;               // ellipsoid\nconst vec3 Rell = vec3(a,b,c);\n    \nvoid mainImage(out vec4 O, vec2 U) {                     // === render cube\n    float t = iTime, s =  10.; \n    vec3  q = iResolution, \n          D = normalize( vec3( (U+U-q.xy)/q.y, -8) ),    // ray direction (normalized)\n          p = 1.5*s/q, N, H,                             // p: ray origin\n          L = vec3(0,0,1);                               // light direction (normalized)\n    mat2  R = mat2( sin(t+1.57*vec4(1,2,0,1)) );         // animation\n    L.xz *= R; L.yz *= R;                                // to object frame\n    p.xz *= R; p.yz *= R;                                //   ( turntable: can factor rot out of ray loop )\n    D.xz *= R; D.yz *= R;\n\n    for (int i=0; i<50; i++) {                           // --- ray march\n        t = length( p / Rell ) - 1.;                     // distance to ellipsoid\n        if (t < .01) { s=0.; break; }                    // hit\n        p += t*D;                                        // step forward by dist\n    }\n\n    O -= O;\n    if (s==0.) {                                         // --- if hit\n        p = normalize(p/Rell) * Rell;                    // reproject on ellipsoid for precision\n        \n        float a2 = a*a, b2 = b*b, c2 = c*c,\n              a4 = a2*a2, b4 = b2*b2,                    // ellispoidal coordinates https://en.wikipedia.org/wiki/Ellipsoidal_coordinates\n            X = p.x*p.x / a2 *(a2-b2)*(a2-c2), \n            Y = p.y*p.y / b2 *(b2-a2)*(b2-c2),\n            s = (Y-X -b4+a4) / (b2-a2),\n            m = X -a4 -a2*s,\n            d = s*s-4.*m,\n            u0 = (s+sqrt(d))/2., v0 = s-u0;              // ellipsoidal coordinates\n                                                         // draw them:\n        u0 = (-u0 - c2)/(b2-c2);                         // normalized on [0,1]\n        v0 = (-v0 - b2)/(a2-b2);\n#if 0   // integer isos\n        O = vec4(floor(u0*n)/(n-1.),floor(v0*n)/(n-1.),0,0); \n#  define S(v) smoothstep( 0., .1, abs(fract(v+.5)-.5) )\n#else   // half-int isos\n        O = vec4(round(u0*n)/n,round(v0*n)/n,0,0); \n#  define S(v) smoothstep( 0., .1, abs(fract(v)-.5) )\n#endif\n        O *= min(S(u0*n),S(v0*n));\n      //O *= smoothstep( 0., .01, abs(v0*n) );\n      //O = vec4(1.-S(u0*n),1.-S(v0*n),0,0); O += 1.-max(O.r,O.g);\n\n        N = normalize(p/(Rell*Rell));                    // Normal\n        O *= (.3 + .7 * max( 0., dot(N,L) ));            // ambiant + diffuse\n        H = normalize(L-D); \n        O += pow( max( 0., dot(N,H) ), 200.);            // specular\n    }\n    else O = vec4(.3);                                   // background\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sB3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 158, 194, 233, 2714]]}
{"id": "3sBGDc", "name": "Raymarching demo 1", "author": "darkeclipz", "description": "raymarching repeated cubes and some rotation along the z axis.", "tags": ["raymarching"], "likes": 3, "viewed": 91, "published": "Public", "date": "1550092311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 64.\n#define MinDistance 0.01\n#define eps 0.001\n\n#define red vec3(227./255., 10./255., 4./255.)\n#define yellow vec3(250./255., 169./255., 1./255.)\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 1.5;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdYPlane(vec3 p, float y) { return p.y - y; }\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nvec3 map(vec3 p) {\n    mat3 rot = rotateZ(0.13*p.z);\n    p *= rot;\n\treturn fract(p) - 0.5;   \n}\n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n\tp = map(p);\n    float outerSphere = sdSphere(p, .20);\n    float box = sdBox(p, vec3(1,1,1)*.15) + 0.005*fbm(50.*p.xy);    \n    return max(outerSphere, box);\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                  k.yyx*scene( p + k.yyx*h ) + \n                  k.yxy*scene( p + k.yxy*h ) + \n                  k.xxx*scene( p + k.xxx*h ) );    \n    return n;\n}\n    \nfloat march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = scene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;  \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n       \n    mat3 rot = rotateY(iTime);\n    mat3 rot2 = rotateY(iTime*2.);\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, rot*vec3(5) + vec3(0,0,iTime*2.), 35., red);\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, rot2*vec3(-5) + vec3(0,0,iTime*2.), 20., yellow);\n    \n    vec3 ambient = vec3(.1);\n    \n    return L1 + L2 + ambient;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n    mat3 rot = rotateZ(cos(iTime/4.));\n    rd *= rot;\n\n    ro += vec3(0,0,iTime*2.);\n    float t = march(ro, rd);\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n        float fog = 1. / (1. + t * t * 0.02);\n        col = mix(vec3(0), col, fog);\n        //col = n*.5+.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 217, 217, 324], [326, 404, 430, 430, 810], [830, 830, 854, 876, 1131], [1133, 1133, 1160, 1160, 1246], [1248, 1248, 1275, 1275, 1353], [1355, 1355, 1388, 1388, 1412], [1413, 1413, 1446, 1446, 1464], [1465, 1465, 1494, 1494, 1550], [1552, 1552, 1570, 1570, 1647], [1649, 1680, 1721, 1721, 1814], [1816, 1816, 1837, 1837, 1997], [1999, 1999, 2024, 2024, 2289], [2295, 2295, 2326, 2326, 2557], [2559, 2626, 2733, 2733, 3491], [3493, 3493, 3531, 3531, 3858], [3860, 3860, 3917, 3917, 4433]]}
{"id": "3sBGzV", "name": "[twitch] Sky Path", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SkyPath.glsl", "tags": ["3d", "raymarching", "live", "twitch"], "likes": 44, "viewed": 937, "published": "Public", "date": "1549316373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SkyPath.glsl\n*/\n\n#define MARCH_STEPS 100\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat box(vec3 p, vec3 s) {\n\n  vec3 ap=abs(p)-s;\n  return length(max(vec3(0),ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.6)*0.7;\n  off.x += sin(p.z*0.17)*1.5;\n\n  off.y += cos(p.z*0.27)*0.5;\n  off.y += cos(p.z*0.34)*0.25;\n  return off;\n}\n\nfloat stair(vec3 p, float s1, float s2) {\n\n  p.z = (fract(p.z/s1-0.5)-0.5)*s1;\n  p.yz *= rot(PI*0.25);\n  float b = box(p, vec3(s2,s1,s1));\n\n  return b;\n}\n\nfloat map(vec3 p) {\n\n  float rep = 10.0;\n  p.y -= max(0.0,abs(p.x)-10.0)*0.3;\n  p.x = (fract(p.x/rep-0.5)-0.5)*rep;\n  \n  p += tunnel(p);\n\n  vec3 rp = p;\n  float boxrep = 10.0;\n  rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;\n\n  vec3 rp2 = p;\n  float boxrep2 = 1.0;\n  rp2.x=abs(rp2.x)-0.4;\n  rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;\n\n  float b = box(rp + vec3(0,-9,0), vec3(0.6,10.5,0.6));\n  vec3 rp3 = rp + vec3(0,1.5,0);\n  rp3.xy *= rot(PI*0.3);\n  rp3.yz *= rot(PI*0.3);\n  float b2 = box(rp3, vec3(0.7));\n  b2 = max(b2, p.y+1.5);\n  b = min(b, b2);\n\n  \n\n  float st = stair(p, 0.1, 0.4);\n  float st2 = stair(p + vec3(0,0.7,0), 0.6, 0.4);\n\n  b = max(b, -st2);\n\n  float c = box(rp2 + vec3(0,0.3,0), vec3(0.05,0.3,0.2));\n  rp2.y = abs(rp2.y + 0.43)-0.1;\n  c = min(c, box(rp2, vec3(0.03,0.03,1.0)));\n  \n  \n\n  return min(c,min(b, st));\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*723.588+uv.yx*413.877),vec2(9865.535)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*435.232)*7412.223);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)),rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat curve2(float t, float d) {\n  float g=t/d;\n  float ig = floor(g);\n  float fg = fract(g);\n  fg = smoothstep(0.0,1.0,fg);\n  fg = pow(fg,rnd(ig)*2.0+0.5);  \n  //fg = smoothstep(0,1,fg);\n  return (ig+fg)*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float rand=rnd(uv);\n  float dither = 0.8+0.1*rand;\n\n  vec3 s=vec3(0,-1,0);\n  vec3 t=vec3(0,-0.3,3);\n  vec3 tar=vec3(0,-0.7,3);\n\n  float motion = curve2(time*1.5, 0.8)*3.0;\n  s.z += motion;\n  t.z += motion;\n  //tar.z += time*1.5*3.0;// + pow(curve(time, 0.7),2)*5.0;\n  float offset = 15.0;\n  tar.z += (curve2(time*1.5-offset, 1.1)+offset)*3.0 + pow(curve(time, 0.9),3.0)*5.0;\n\n  s-=tunnel(s);\n  vec3 offt = tunnel(t);\n  t-=offt;\n  tar-=tunnel(tar);\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(0,1,0) - offt*0.2));\n  vec3 cy=normalize(cross(cz,cx));\n\n  vec3 r = normalize(cx*uv.x + cy*uv.y + cz*(0.7+sin(time*2.0)*0.4));\n  \n  vec3 col = vec3(0);\n  vec3 l = normalize(vec3(-0.7,-1.0,-0.5));\n\n  vec3 back = mix(vec3(0.1,0.3,1.0)*0.1, vec3(1.0,0.3,0.5)*0.5, pow(r.y*0.5+0.5,2.0));\n\n  vec3 p = s;\n  float dd=0.0;\n  int i=0;\n  float at=0.0;\n  float at2 = 0.0;\n  for(i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p) * dither;\n    if(d<0.001) {\n      vec3 n=norm(p);\n      float fog = clamp(1.0-dd*0.018, 0.0, 1.0);\n      float bot = pow(clamp(-(p.y-10.0)*.1,0.0,1.0),2.0)*fog;\n\n      float aodist = 0.3;\n      float ao = clamp(map(p+n*aodist)/aodist,0.0,1.0);\n      ao = mix(ao,1.0,0.3);\n      \n      float f = pow(1.0-dot(n,-r), 2.0);\n      col += vec3(0.3,0.4,0.7)*max(0.0, dot(n,l)) * bot * ao;\n      col += 4.0*f * back*2.0 * (-n.y*0.5+0.5) * bot*ao;\n\n      dd = mix(100.0, d, bot);\n      \n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=d*r;\n    dd+=d;\n\n    at += exp(-length(tar-p)*7.0);\n    at2 += exp(-d*0.1)*0.05;\n  }\n  if(i>99) dd=100.0;\n\n  col += vec3(1,0.3,0.5) * at * 3.3;\n  col += vec3(1,0.3,0.5) * at2 * 0.2;\n  col += back*0.05 * exp(dd*0.05);\n\n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 294, 321, 321, 417], [419, 419, 438, 438, 507], [509, 509, 530, 530, 687], [689, 689, 730, 730, 842], [844, 844, 863, 863, 1679], [1682, 1682, 1701, 1701, 1809], [1811, 1811, 1831, 1831, 1900], [1902, 1902, 1922, 1922, 1965], [1967, 1967, 1998, 1998, 2103], [2105, 2105, 2137, 2137, 2314], [2316, 2316, 2373, 2373, 4243]]}
{"id": "3sfGR2", "name": "Some Non-Convex Polyhedra", "author": "mla", "description": "Two series of non-convex uniform polyhedra.\n\n't' to change series\n'd' for duals\n's' for snubs", "tags": ["polyhedra", "uniform", "nonconvex"], "likes": 12, "viewed": 370, "published": "Public API", "date": "1549033565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Some non-convex polyhedra.\n//\n// Created 2019 by Matthew Arcus.\n//\n// Controls:\n// Mouse changes orientation\n// s: show snub\n// d: show dual\n// r: show fundamental region\n// t: select 3 3 5/2 or 5 5/2 2\n//\n// Non-convex polyhedra turn out to be quite hard to raymarch, at least using\n// the standard methods (eg. see https://www.shadertoy.com/view/MlSBDz of which\n// this is a derivation). Faces don't have a clear inside and outside, or can be\n// behind the origin.\n//\n// Here are a couple that work without too much trouble - we extend the\n// fundamental region for the Wythoff construction by reflecting one of the\n// mirrors to a new position. Folding is done as normal with the mirrors\n// for the icosahedral symmetry group, but when constructing the scene in the\n// fundamental region, we have to consider several reflected images.\n//\n// The two Schwarz triangles are 3 3 5/2 and 5 5/2 2. See:\n// https://en.wikipedia.org/wiki/List_of_uniform_polyhedra_by_Schwarz_triangle\n//\n// The Wythoff construction:\n// https://en.wikipedia.org/wiki/Wythoff_construction\n//\n// Schwarz triangles including the snub case:\n// https://en.wikipedia.org/wiki/File:Wythoff_construction-pqr.png\n//\n// Derived in part from knighty's Wythoff construction DE shader:\n// https://www.shadertoy.com/view/XlX3zB, with substantial modifications\n// to handle duals, snubs, prisms and some very basic non-convex polyhedra.\n//\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90; // rotation\n\n// Choices here are: (2,2),(2,3),(2,4),...,(3,3),(3,4),(3,5) (and opposite)\nfloat P = 2.0, Q = 3.0, R = 5.0;\n\nint nonconvex = 0;\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (2 3 5) or (2 2 10)\nint NFOLDS = 5;\n\nbool dofaces = true;\nbool dodualfaces = false;\nbool doregion = false;\nbool snubify = false;\n\nconst vec3 Face0Color = vec3(0.8,0,0);\nconst vec3 Face1Color = vec3(0.8,0.7,0);\nconst vec3 Face2Color = vec3(0.1,0,0.6);\nconst vec3 SnubColor = vec3(0,0.5,0.0);\nconst vec3 DualColor0 = vec3(0.7,0.7,0.1);\nconst vec3 DualColor1 = vec3(0.1,0.1,0.1);\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0 * PI;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat edgedistance(vec3 pos, vec3 X) {\n  assert(eq(length(X),1.0));  // Use dot(X,X)?\n  return length(pos-dot(pos,X)*X);\n}\n\nfloat raydistance(vec3 pos, vec3 q, vec3 r) {\n  float s = max(0.0, dot(pos-q,r));\n  return distance(pos,q+s*r);\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a,max(b,c));\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a,min(b,c));\n}\n\n// Geometric globals\n\n// A,B,C are the mirror planes\n// a,b,c are triangle corners or trihedron edge\n// vectors or face normals\nvec3 A,B,C,a,b,c;\nvec3 A0,B0,C0;\nvec3 tri2bary;\n\n// Could use a matrix here\nvec3 applybary(vec3 bary, vec3 p, vec3 q, vec3 r) {\n  return bary.x*p+bary.y*q+bary.z*r;\n}\n\nvec3 refla(vec3 p) { return p - 2.0*dot(p,A)*A; } // Fold about A plane\nvec3 reflb(vec3 p) { return p - 2.0*dot(p,B)*B; } // Fold about B plane\nvec3 reflc(vec3 p) { return p - 2.0*dot(p,C)*C; } // Fold about C plane\n\n// Planes are represented as vec4s: (a,b,c,d) where p = (x,y,z) is\n// in plane just when (x,y,z,-1).(a,b,c,d) = 0\n\n// For our vec4 plane representations\nvec4 refla(vec4 p) { return vec4(refla(p.xyz),p.w); }\nvec4 reflb(vec4 p) { return vec4(reflb(p.xyz),p.w); }\nvec4 reflc(vec4 p) { return vec4(reflc(p.xyz),p.w); }\n\nvec4 makeplane(vec3 p, vec3 q, vec3 r) {\n  vec3 n = cross(q-p,r-p);\n  //assert(length(n) > 1e-3);\n  n = normalize(n);\n  float k = dot(p,n);\n  // Fix so that away from origin is +ve distance\n  // Not sure I need this. Want the \"natural\" way round.\n  if (k < 0.0) { k = -k; n = -n; }\n  return vec4(n,k);\n}\n\n// Find bary coords of point whose 3 reflections form an equilateral triangle.\n// Fairly standard application of 2-dimensional Newton-Raphson.\n// It's pretty silly doing this in a fragment shader - the coords only\n// depend on the triangle so we could just have a lookup table.\nvec2 eval(vec2 s) {\n  vec3 t = applybary(vec3(s,1.0-s.x-s.y),a,b,c);\n  vec3 p0 = refla(t);\n  vec3 q0 = reflb(t);\n  vec3 r0 = reflc(t);\n  float d0 = distance(p0,q0);\n  float d1 = distance(q0,r0);\n  float d2 = distance(r0,p0);\n  return vec2(d1-d0,d2-d1);\n}\n\nmat2 jacobian(vec2 s, float eps) {\n  // f(a+eps) = f(a-eps) + 2*eps*f'(a) => f'(a) =  (f(a+eps)-f(a-eps))/(2*eps)\n  vec2 e = vec2(eps,0);\n  vec2 s0 = eval(s+e.xy);\n  vec2 s1 = eval(s-e.xy);\n  vec2 s2 = eval(s+e.yx);\n  vec2 s3 = eval(s-e.yx);\n  // df[0]/da df[0]/db\n  // df[1]/da df[1]/db\n  // Column major!\n  return mat2(s0-s1,s2-s3)/(2.0*eps);\n}\n\nvec2 refine(vec2 s) {\n  // 0 = f(a+dx) = f(a)+M(dx)\n  // f(a) = -M(dx)\n  // dx = -inv(M)(f(a))\n  mat2 m = inverse(jacobian(s,1e-6));\n  vec2 t = eval(s);\n  vec2 dx = m*t;\n  return s-dx;\n}\n\nvec3 getsnub() {\n  // Solve f(a,b,c) = g(a,b,c) = h(a,b,c)\n  // Here f,g,h are distances to 3 sides of triangle. a,b,c are bary coords\n  // In fact, we can set a+b+c = 1, so only 2 variables really.\n  // Have a vector quantity: [f-g,h-g], which we want to set to [0,0].\n  // f(x+dx) = f(x) + F(dx)\n  // ie. f(x) + F(dx) = 0 => dx = -inv(F)(f(x))\n  // We need a decent starting point, here the middle of the triangle\n  vec2 s = vec2(0.333,0.333);\n  // A few iterations is enough\n  for (int i = 0; i < 4; i++) {\n    s = refine(s);\n  }\n  //assert(length(eval(s)) < 1e-3); // Check we have a solution\n  vec3 res = vec3(s,1.0-s.x-s.y);\n  return res;\n}\n\nvoid init() {\n  // Setup folding planes\n  float p = PI/P, q = PI/Q, r = PI/R;\n  A0 = vec3(1,0,0);\n  // A.B = -cos(p)\n  B0 = vec3(-cos(p),sin(p),0);\n  // A.C = -cos(r)\n  float x = -cos(r);\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  float y = -(cos(p)*cos(r)+cos(q))/sin(p);\n  // |C| = 1\n  float z = sqrt(1.0-x*x-y*y);\n  C0 = vec3(x,y,z);\n  A = A0;\n  B = B0;\n  C = C0;\n  if (nonconvex == 0) {\n    A = reflect(C0,A0);\n  } else if (nonconvex == 1) {\n    B = reflect(A0,reflect(C0,B0));\n#if 0\n  } else if (nonconvex == 2) {\n    B = reflect(C0,B0);\n  } else if (nonconvex == 3) {\n    // This one doesn't work so well, some planes end up the wrong side\n    // of the origin, which breaks some assumptions somewhere so some\n    // things don't work and some other things do...\n    A = reflect(A0,reflect(C0,A0));\n#endif\n  }\n  a = cross(B,C);\n  b = cross(C,A);\n  c = cross(A,B);\n  // Weights to convert trilinear (distance from region planes) to barycentric\n  // (weighted sum of triangle vertices).\n  tri2bary = vec3(length(a),length(b),length(c));\n  a = normalize(a);\n  b = normalize(b);\n  c = normalize(c);\n  //assert(dot(a,b) > 0.0);\n  //assert(dot(b,c) > 0.0);\n  //assert(dot(c,a) > 0.0);\n  if (snubify) {\n    // For snubs we need to use special values to ensure that the\n    // snub triangles are equilateral (for trilinear coords (1,1,1)).\n    tri2bary = getsnub();\n  }\n}\n\n// Could use an ivec3 and count different types of flip\nvec3 fold(vec3 pos, out int flips) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  flips = 0;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A0);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*A0;\n    k = dot(pos,B0);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*B0;\n    k = dot(pos,C0);\n    flips += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*C0;\n  }\n  return pos;\n}\n\n// p is the \"triangle point\"\n// pa,pb,pc is its reflection in the 3 walls\nvec3 p,pa,pb,pc;\n\n// These vec4s represent planes, xyz is a normal,\n// w is -ve distance from the origin, so we can find\n// distance of p from plane q with dot(vec4(p,1),q):\n//\n// aplane, bplane, cplane are the face planes\n// bplaneB is reflection of bplane in side B.\n// tplane is snub triangle for this region\n// tplaneA, tplaneB, tplaneC are the snub triangle planes for the three\n// adjacent regions (across planes A,B,C respectively).\n\nvec4 aplane, bplane, cplane,bplaneB;\nvec4 tplane, tplaneA, tplaneB, tplaneC;\n\nvoid initp(vec3 tri) {\n  p = applybary(tri2bary*tri,a,b,c);\n  if (true) {\n    //p = normalize(p);\n    float scale = min3(edgedistance(p,A),\n                       edgedistance(p,B),\n                       edgedistance(p,C));\n    p /= scale;\n    if (snubify) {\n      // Centre of triangle edges should be at 1 for snub\n      scale = 0.5*length(refla(p)+reflb(p));\n      p /= scale;\n    }\n  }\n  aplane = vec4(a,dot(p,a)); // Face planes\n  bplane = vec4(b,dot(p,b));\n  cplane = vec4(c,dot(p,c));\n  //assert(abs(aplane.w) < 1.0 || abs(bplane.w) < 1.0 || abs(cplane.w) < 1.0);\n  pa = refla(p);\n  pb = reflb(p);\n  pc = reflc(p);\n  //assert(eq(length(p+pa),2.0) || eq(length(p+pb),2.0) || eq(length(p+pc),2.0) );\n  if (snubify) {\n    bplaneB = reflb(bplane);\n    // Now work out the 3 corners of the snub triangles\n    tplane = makeplane(refla(p),reflb(p),reflc(p));\n    //assert(tplane.w > 0.0);\n    // The snub triangles can coincide with the normal faces\n    // so move them in slightly to avoid clashes.\n    tplane.w -= 0.0001;\n    tplaneA = refla(tplane);\n    tplaneB = reflb(tplane);\n    tplaneC = reflc(tplane);\n  }\n}\n\nvec3 paa,pbb,pcc;\nvoid scenesetup() {\n  paa = normalize(pa); //pa/dot(pa,pa);\n  pbb = normalize(pb); //pb/dot(pb,pb);\n  pcc = normalize(pc); //pc/dot(pc,pc);\n}\n\nfloat faces(vec3 pos, bool parity) {\n  if (snubify && parity) pos = reflect(pos,B);\n  vec4 pos4 = vec4(pos,-1);\n  // Signed distance from 3 planes\n  float d = -1e8;\n  d = max(d,dot(pos4,aplane));\n  d = max(d,dot(pos4,bplane));\n  d = max(d,dot(pos4,cplane));\n  if (!snubify) return d;\n  // Distance from reflection of b in B.\n  d = max(d,dot(pos4,reflb(bplane))); //FIXME\n  // Distance from snub triangles\n  d = max(d,dot(pos4,tplaneA));\n  d = max(d,dot(pos4,tplaneB));\n  d = max(d,dot(pos4,tplaneC));\n  return d;\n}\n\nfloat colorfaces(vec3 pos, bool parity, inout int col) {\n  // This should agree with the snubify check below.\n  if (snubify && parity) pos = reflect(pos,A0);\n  vec4 pos4 = vec4(pos,-1);\n  // Distance from 3 planes\n  float d0, d = -1e8;\n  d0 = dot(pos4,aplane);\n  if (d0 > d) { d = d0; col = 0; }\n  d0 = dot(pos4,bplane);\n  if (d0 > d) { d = d0; col = 1; }\n  d0 = dot(pos4,cplane);\n  if (d0 > d) { d = d0; col = 2; }\n  if (!snubify) return d;\n  d0 = dot(pos4,refla(aplane));\n  if (d0 > d) { d = d0; col = 0; }\n  d0 = max3(dot(pos4,tplaneA),\n            dot(pos4,tplaneB),\n            dot(pos4,tplaneC));\n  if (d0 > d) { d = d0; col = 3; }\n  return d;\n}\n\nfloat dualfaces(vec3 pos, bool parity) {\n  if (snubify && parity) pos = reflect(pos,B);\n  float r = 1.0/length(p);\n  if (!snubify) {\n    return dot(pos,p)-r; // Nice 'n' easy, p defines surface\n  } else {\n    pos = reflb(pos);\n    // Almost as easy, reflect triangle point in each side,\n    // then use to define surface.\n    float d0 = dot(pos,paa)-r;\n    float d1 = dot(pos,pbb)-r;\n    float d2 = dot(pos,pcc)-r;\n    float d = max3(d0,d1,d2);\n    return d;\n  }\n}\n\nfloat colordualfaces(vec3 pos, bool parity, inout int col) {\n  //col = (!snubify && parity) ? 5 : 4;\n  col = 4;\n  return dualfaces(pos,parity);\n}\n\nfloat scene(vec3 pos, bool parity) {\n  float d = 1e8;\n  if (dodualfaces) {\n    d = min(d,dualfaces(pos,parity));\n    if (nonconvex == 0) {\n      d = min(d,dualfaces(reflect(pos,A0),!parity));\n    } else if (nonconvex == 1) {\n      d = min(d,dualfaces(reflect(pos,B0),!parity));\n      d = min(d,dualfaces(reflect(reflect(pos,B0),reflect(C0,B0)),parity));\n#if 0\n    } else if (nonconvex == 2) {\n      d = min(d,dualfaces(reflect(pos,B0),!parity));\n    } else if (nonconvex == 3) {\n      vec3 pos1 = reflect(pos,A0);\n      vec3 C1 = reflect(C0,A0);\n      vec3 pos2 = reflect(pos1,C1);\n      d = min(d,dualfaces(pos1,!parity));\n      d = min(d,dualfaces(pos2,parity));\n      d = min(d,dualfaces(reflect(pos2,reflect(B0,C1)),!parity));\n#endif\n    }\n  }\n  if (dofaces) {\n    d = min(d,faces(pos,parity));\n    if (nonconvex == 0) {\n      d = min(d,faces(reflect(pos,A0),!parity));\n    } else if (nonconvex == 1) {\n      d = min(d,faces(reflect(pos,B0),!parity));\n      d = min(d,faces(reflect(reflect(pos,B0),reflect(C0,B0)),parity));\n#if 0\n    } else if (nonconvex == 2) {\n      d = min(d,faces(reflect(pos,B0),!parity));\n    } else if (nonconvex == 3) {\n      vec3 pos1 = reflect(pos,A0);\n      vec3 C1 = reflect(C0,A0);\n      vec3 pos2 = reflect(pos1,C1);\n      d = min(d,faces(pos1,!parity));\n      d = min(d,faces(pos2,parity));\n      d = min(d,faces(reflect(pos2,reflect(B0,C1)),!parity));\n#endif\n    }\n  }\n  return d;\n}\n\nfloat colorscene(vec3 pos, bool parity, out int col) {\n  float d = 1e8, d0;\n  int col0;\n  if (dodualfaces) {\n    d0 = colordualfaces(pos,parity,col0);\n    if (d0 < d) {\n      d = d0;\n      col = col0;\n    }\n  }\n  if (dofaces) {\n    d0 = colorfaces(pos,parity,col0);\n    if (d0 < d) {\n      d = d0;\n      col = col0;\n    }\n    if (nonconvex == 0) {\n      d0 = colorfaces(reflect(pos,A0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n    } else if (nonconvex == 1) {\n      d0 = colorfaces(reflect(pos,B0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n      d0 = colorfaces(reflect(reflect(pos,B0),reflect(C0,B0)),parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n#if 0\n    } else if (nonconvex == 2) {\n      d0 = colorfaces(reflect(pos,B0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n    } else if (nonconvex == 3) {\n      d0 = colorfaces(reflect(pos,A0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n      d0 = colorfaces(reflect(pos,C0),!parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n      d0 = colorfaces(reflect(reflect(pos,C0),reflect(B0,C0)),parity,col0);\n      if (d0 < d) { d = d0; col = col0; }\n#endif\n    }\n  }\n  return d;\n}\n\nfloat polyhedron(vec3 pos) {\n  int flips;\n  vec3 pos0 = pos;\n  pos = fold(pos,flips);\n  bool parity = flips%2 == 1;\n  float d = 1e8;\n  d = min(d,scene(pos,parity));\n  if (doregion) {\n    d = max(d,dot(pos0,A));\n    d = max(d,dot(pos0,B));\n    d = max(d,dot(pos0,C));\n  }\n  return d;\n}\n\nvec3 getcolor(vec3 pos){\n  vec3 pos0 = pos;\n  int flips;\n  pos = fold(pos,flips);\n  bool parity = flips%2 == 1;\n  int col = 10;\n  float d = colorscene(pos,parity,col);\n  assert(col >= 0);\n  if (doregion) {\n    float d0 = d;\n    d = max(d,dot(pos0,A));\n    d = max(d,dot(pos0,B));\n    d = max(d,dot(pos0,C));\n    if (d != d0) col = 6;\n  }\n  if (col == 0) return Face0Color;\n  if (col == 1) return Face1Color;\n  if (col == 2) return Face2Color;\n  if (col == 3) return SnubColor;\n  if (col == 4) return DualColor0;\n  if (col == 5) return DualColor1;\n  if (col == 6) return vec3(1);\n  //assert(false);\n  return vec3(1);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p) {\n  return polyhedron(p);\n}\n\n// We should be able to do this analytically from the plane hit.\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                        map(p + e.yxy) - map(p - e.yxy),\n                        map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 5.0;\n  const float precis = 0.001;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 64; i++) {\n    if (t > maxd) return -1.0;\n    float h = map(ro+rd*t);\n    h = max(h,0.0);\n    t += 0.5*h;\n    if (h < precis) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (!keypress(CHAR_Z)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\n#if 1\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,1,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,0),vec3(1,1,0),vec3(0,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,1,1),vec3(0,0,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,1),vec3(1,0,0),vec3(1,0,0),\n\n   vec3(1,1,1),vec3(1,1,0),vec3(1,1,1),vec3(0,1,0),\n   vec3(1,1,1),vec3(0,1,1),vec3(1,1,1),vec3(0,0,1),\n   vec3(1,1,1),vec3(1,0,1),\n\n   vec3(1,1,1),vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),vec3(1,0,1),vec3(1,0,0));\n#else\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,0,0),\n   vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,0),\n\n   vec3(1,1,1),vec3(1,1,0),vec3(1,1,1),vec3(0,1,0),\n   vec3(1,1,1),vec3(0,1,1),vec3(1,1,1),vec3(0,0,1),\n   vec3(1,1,1),vec3(1,0,1),\n\n   vec3(1,1,1),vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),vec3(1,0,1),vec3(1,0,0));\n#endif\n\nconst int nsteps = circuit.length();\n\nvec3 gettri(float t) {\n  int i = int(floor(t))%nsteps;\n  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dodualfaces = keypress(CHAR_D);\n  dofaces = !dodualfaces;\n  snubify = keypress(CHAR_S);\n  doregion = keypress(CHAR_R);\n  nonconvex = keypress(CHAR_T) ? 0 : 1;\n#if 0\n  // Debug settings.\n  snubify = false;\n  dofaces = true;\n  dodualfaces = !dofaces;\n  doregion = false;\n#endif\n\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy)/ iResolution.y;\n  p.y = -p.y;\n  p *= 0.5;\n  vec3 col = vec3(0,0,(1.0 - fragCoord.y/iResolution.y) * 0.3);\n  vec3 ro = vec3(0.0, 0.0, -4.0);\n  vec3 rd = vec3(p, 2.0);\n  vec3 li = vec3(0.5, 0.8, -3.0);\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n  li = normalize(li);\n  rd = normalize(rd);\n  init();\n  vec3 tri = gettri(0.5*iTime);\n  if (snubify) tri = vec3(1);\n  initp(tri);\n  scenesetup();\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 pos = ro+t*rd;\n    vec3 n = calcNormal(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col = getcolor(pos) * diffuse;\n    col = pow(col, vec3(0.4545));\n  }\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1490, 1515, 1515, 1575], [2134, 2674, 2698, 2698, 2727], [2729, 2781, 2808, 2808, 2836], [2838, 2838, 2876, 2876, 2960], [2962, 2962, 3007, 3007, 3075], [3077, 3077, 3116, 3116, 3144], [3146, 3146, 3185, 3185, 3213], [3392, 3419, 3470, 3470, 3509], [3511, 3511, 3531, 3531, 3560], [3561, 3583, 3603, 3603, 3632], [3633, 3655, 3675, 3675, 3704], [3843, 3881, 3901, 3901, 3934], [3935, 3935, 3955, 3955, 3988], [3989, 3989, 4009, 4009, 4042], [4044, 4044, 4084, 4084, 4347], [4349, 4627, 4646, 4646, 4881], [4883, 4883, 4917, 4996, 5229], [5231, 5231, 5252, 5325, 5417], [5419, 5419, 5435, 5834, 6065], [6067, 6067, 6080, 6106, 7440], [7442, 7498, 7534, 7630, 7947], [8041, 8542, 8564, 8564, 9659], [9679, 9679, 9698, 9698, 9820], [9822, 9822, 9858, 9858, 10336], [10338, 10338, 10394, 10447, 10989], [10991, 10991, 11031, 11031, 11455], [11457, 11457, 11517, 11557, 11602], [11604, 11604, 11640, 11640, 13023], [13025, 13025, 13079, 13079, 14219], [14221, 14221, 14249, 14249, 14505], [14507, 14507, 14531, 14531, 15124], [15126, 15224, 15260, 15260, 15312], [15314, 15314, 15336, 15336, 15362], [15364, 15429, 15457, 15457, 15667], [15669, 15669, 15706, 15706, 15972], [15974, 15974, 16001, 16001, 16338], [17244, 17244, 17266, 17266, 17359], [17361, 17361, 17418, 17418, 18434]]}
{"id": "3sfSDr", "name": "Comic Dots", "author": "IsaacAndersen", "description": "first shader test", "tags": ["test"], "likes": 8, "viewed": 179, "published": "Public", "date": "1551052658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy;\n    vec2 p = ( fragCoord - .5*R) / R.y;\n    \n    float t = PI/4.*iTime;\n    \n\tfloat l = length(p);\n    \n    p *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    p *= 1.5 + 0.5*sin(t);\n\n    \n\tvec3 c;\n    for(int i=0;i<=2;i++) {\n\t\tt+=0.1;               \n        vec2 a = p*5.0*(sin(t)+2.0);\n        \n        a = abs(fract(a)-0.5);\n        \n        float dist = length(p)*2.0;\n      \n\t\tc[i]= smoothstep(0.0,0.25,abs(.25 - length(a)*dist));\n    }\n\tfragColor=vec4(c/l,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 79, 79, 574]]}
{"id": "3sfSRN", "name": "Rotating Landing Shader", "author": "trevortheblack", "description": "Rewrote the Shadertoy new shader as a polar depiction", "tags": ["polar"], "likes": 1, "viewed": 105, "published": "Public", "date": "1550675140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\n// Accepts [0,1] uv coordinates\n// Outputs to polar coords \n// With [0.5, 0.5] as the center\n//(radius, theta)\n// where radius is [0, 0.717]\n// theta is [-PI, PI]\nvec2 polarCoords( in vec2 uv )\n{\n    vec2 uvPrime = uv - vec2(0.5, 0.5);\n    float r = length(uvPrime);\n    float theta = atan(uvPrime.y, uvPrime.x);\n    return vec2(r, theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Get polar coordinates (radius: [0, 0.717], theta: [-M_PI, M_PI])\n    vec2 pc = polarCoords(uv);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+pc.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 253, 285, 285, 431], [433, 433, 490, 540, 835]]}
{"id": "3sfSW7", "name": "Polar juggling", "author": "duvengar", "description": "Based on a comment by Shane in this [url=https://www.shadertoy.com/view/ll2fzG]Shader[/url] by skaplun. I ended up playing around with some frequencies looking for harmonious interlaced patterns. Uncomment SHOW_STRUC  to see better how it works.", "tags": ["polar"], "likes": 8, "viewed": 173, "published": "Public", "date": "1551378246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Polar juggling\"\n// by Julien Vergnaud @duvengar-2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n// Based on a comment by Shane in this shader https://www.shadertoy.com/view/ll2fzG by skaplun.\n// I ended up playing around with some frequencies looking for harmonious interlaced patterns.\n// Uncomment SHOW_STRUC  to see better how it works.\n// ====================================================================\n\n\n#define R iResolution.xy\n#define T iTime*.5\n#define TWO_PI (2.* acos(-1.))\n#define PI acos(-1.)\n#define POL(u) vec2(atan(u.y,u.x)/TWO_PI, length(u))\n#define ROT2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//#define SHOW_STRUC \n#define DOMAIN_REP\n#define BLACK_BG\n#define GRAIN\n\n\nfloat hash( float n ){\n    \n\treturn fract(sin(n)*75728.5453123); \n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    // INITIALIZING\n\t/////////////////////////////////////////////////////////\n    vec2 uv =  (U.xy - R *.5) / R.y;\n    \n    vec2 pc = uv  *22.;                        // domain zoom -\n\tpc *= ROT2(iTime*.2);\n    float pa = POL(pc).x ;                     // polar Angle\n\n    float steps = 40.;                         // number of steps\n    \n    float index =  floor(pa * steps);          // id for each step from 0 > 1\n    \n    float sa = (index + .5) / steps * TWO_PI;  // remap each step angle\n    \n    float pair = mod(index, 2.);               // if the step is pair or not?\n    \n\n    \n    pc *=  ROT2(sa);                           // rotate coordinate by the step angle\n \t\n    float dist = 3. ;  \n    float speed = tan(T*.3)*.5+.5;\n  \t\n    \n   // float cc[5] = float[5](float(22.),float(3.),float(16.), float(35.), float(11.));     // array of interresting numbers 3(41), 5, 11, 16, 19,  22, 24, 30, 33, 35, 38, 49, 57\n    float cc[5] = float[5](22.,3.,16., 35., 11.); // lol thanks Fabrice !\n    \n    int i =  int(floor(5.*(speed)));\n    float coef = cc[i];\n    float amp = 1.+ cos(coef*(.3*T + index));           // amplitude for sphere offseting\n\n    pc.x -=  dist + amp;                                // translate cartesian coordinates on the X axis\n \t#ifdef DOMAIN_REP\n    pc.x = pc.x >1. && pc.x < 3.? mod(pc.x, 1.) : pc.x; // domain repetition\n    #endif\n    //pa += PI * 1.5;\t\t\t\t\t                    // polar angle adjustement\n    \n\tfloat r = (amp*.19);                                // radius to draw the spheres                      \n\n\t\n   \n    float  b1 = fwidth(length(uv.x)*30.);             // stabilised blur value accross screen for circle's drawing\n    float  b2 = fwidth(pa*steps);                   // stabilised blur value accross screen for polar_grid's drawing\n\n    \n    vec3 polar_G = vec3(1.-smoothstep(.0,b2*1.3,abs(fract(pa*steps)-.5))); // polar segments grid\n    \n    float c  = length(pc + vec2(-.5, .0)) - r;      // the circle's distance function for each steps\n   \n\t\n\n    \n    // SHADING\n    //////////////////////////////////////////////////////////////////////////////////////////\n    \n    vec3 col = vec3(.0);\n    \n    #ifdef SHOW_STRUC\n    col +=  vec3(.1*smoothstep(.0,.1,pc.x));\n    col = clamp(col,vec3(.0),vec3(1.));\n    #endif\n    \n    vec3(.05*index,.0,.0);\n    \n    // drawing the circles with fill or stroke depending on the pair state\n    col += pair == .0 ? vec3(1.-smoothstep(.0,b1,abs(c)-.0015)) :vec3(1.-smoothstep(.0,b1,c)) ;\n    \n    // adding a bit of grain\n    #ifdef GRAIN\n    float noise = length(uv*.5)*hash(uv.x*298.987*uv.y*863.456);\n    col += .1*max(noise,.2);\n    #endif\n    // final color output\n    #ifdef BLACK_BG\n    C = vec4(pow(col,vec3(.6)),.0);\n    #else\n    C = vec4(1.-pow(col,vec3(.6)),.0);\n    #endif\n\n     \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfSW7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[735, 809, 831, 831, 876], [880, 880, 921, 1000, 3716]]}
{"id": "3sfXRM", "name": "[TWITCH] Fountain", "author": "Flopine", "description": "This shader was coded during a live twitch session on 21/02. \nI wanted to experiment on scenery again :)", "tags": ["raymarching", "lighting", "specular", "geometry", "liquid"], "likes": 18, "viewed": 279, "published": "Public", "date": "1550790077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI  3.141592\n#define time iTime\n\nfloat rand (vec2 st)\n{return fract(sin(dot(st, vec2(12.181, 35.154)))*2445.458);}\n\n\nfloat stmin (float a, float b, float k , float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\n// iq smooth minimum function: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.z,max(q.x,q.y))) + length(max(q,0.));\n}\n\nfloat cylH (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\n// iq hexagonal function : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n        length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n        p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat od (vec3 p, float d)\n{\n    p.xz *= rot(time);\n    p.yz *= rot(time);\n    return dot(p, normalize(sign(p)))-d;\n}\n\n\nfloat vortex (vec3 p)\n{\n    p *= 2.;\n    p.xz *= rot(p.y + time);\n    //p.x += sin(p.y);\n    p.y += sin(p.x*0.8 + p.y*1.5+ time);\n    p.x += sin(p.y+time*2.);\n    return cylH(p.xzy, 5.-p.y*0.6, 8.)/2.;\n}\n\nfloat g1 = 0.;\nfloat ball(vec3 p)\n{\n    float d = length(p)-1.3;\n    g1 += 0.1/(0.1*d*d);\n    return d;\n}\n\nfloat water (vec3 p)\n{\n\n    p.y -= .5;\n    float s = ball (vec3(p.x, p.y-4.+sin(time)*0.5, p.z));\n    float v = vortex(p);\n    p.y += sin(length(p.xz*2.)-time)*0.1;\n    return smin(smin(v, s, 3.), max(sdHexPrism(p.xzy, vec2(4.2, 2.)),abs(p.y)-0.5), 15.);\n}\n\nfloat pillars (vec3 p)\n{\n    p.x = abs(p.x);\n    p.z -= 2.;\n    p.x -= 8.8;\n    p.y -= 2.;\n    return box(p, vec3(0.5+abs(p.y)*0.3, 2., 0.5+abs(p.y)*0.3));\n}\n\nfloat gems (vec3 p)\n{\n    p.x = abs(p.x);\n    p.z -= 2.;\n    p.x -= 8.8;\n    p.y -= 6.;\n    return od(p,.8);\n}\n\nfloat background (vec3 p)\n{\n    float b = -box(vec3(p.x, p.y-15., p.z+45.), vec3(13.,15., 50));\n    float h1 = max(-sdHexPrism(p.xzy, vec2(4.2, 2.)),sdHexPrism(p.xzy, vec2(5., 1.5)));\n    return stmin(pillars(p),stmin(h1,b, 1. , 3.),0.5, 3.);\n}\n\nint mat = 0;\nfloat SDF (vec3 p)\n{\n    float g = gems(p);\n    float b = background(p);\n    float w = water(p);\n    float d = min(g,min(b, w));\n    // tricks learned during YX stream\n    if (d == b) mat = 1;\n    if (d == g) mat = 2;\n    if (d == w) mat = 3; \n    return d;\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2  uv, float fov)\n{\n    vec3 forward = normalize(target-ro);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross(forward, left));\n    return normalize(forward*fov + left*uv.x + up*uv.y);\n}\n\nvec3 norms (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy) - SDF(p-eps.xyy),\n                          SDF(p+eps.yxy) - SDF(p-eps.yxy),\n                          SDF(p+eps.yyx) - SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nfloat dir_light(vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5 + 0.5;}\n\nfloat point_light (vec3 p, vec3 n, vec3 lpos)\n{\n    vec3 ldir = normalize(lpos-p);\n    float att = length(lpos-p);\n    float dotNL = dot(n, ldir)*0.5+0.5;\n    return dotNL / ((0.1*att*att));\n}\n\nfloat spec_light (vec3 l, vec3 rd, vec3 n, float spec_power)\n{\n    vec3 h = normalize(l - rd);\n    float spe = pow(max(dot(h,n),0.),spec_power);\n    return spe;\n}\n\nfloat fresnel (vec3 rd, vec3 n, float fre_power)\n{\n    return pow(1.-clamp(dot(n, -rd), 0., 1.), fre_power);\n}\n\nvoid back_mat (inout vec3 col, vec3 n, vec3 p ,vec3 rd)\n{\n    vec3 dir_pos = vec3(-2.,5,5.);\n    col = mix(vec3(0.3,0.1,0.2), vec3(0.3,0.6,0.8), dir_light(n, dir_pos));\n}\n\nvoid water_mat(inout vec3 col, vec3 n, vec3 p , vec3 rd)\n{\n    vec3 point_pos = vec3(0.,5., -5.);\n    vec3 light_dir = normalize(vec3(0.,12., 4.));\n    col += fresnel (rd, n, 3.)*vec3(0.3,0.1,.2);\n    col += spec_light(light_dir, rd, n , 20.);\n    col += point_light(p, n, point_pos)*vec3(0.3,0.6,0.8);\n}\n\nvoid gems_mat (inout vec3 col, vec3 n, vec3 p , vec3 rd)\n{\n    vec3 dir_pos = vec3(0.,3.,-5.);\n    col += fresnel (rd, n, 1.5)*vec3(0.3,0.1,0.8);\n    col += spec_light(dir_pos, rd, n , 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = rand(uv);\n\n    vec3 ro = vec3(-3.,7., -14); vec3 p = ro;\n    vec3 target = vec3(0., 2., 0.);\n    vec3 rd = get_cam(ro, target, uv, 1.);\n    vec3 col = vec3(0.);\n\n    bool hit = false;\n    float shad = 0.;\n    for(float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.5 + dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = norms(p);\n        if (mat == 1) back_mat(col, n, p, rd);\n        if (mat == 2)\n        {\n            col = vec3(0.1,0.5,0.3);\n            gems_mat(col, n, p, rd);\n        } \n        if (mat == 3) \n        {\n            col = vec3(0.4);\n            water_mat(col, n, p, rd);\n        }\n    }\n    // fake AO\n    col *= 1.-shad;\n    fragColor = vec4(pow(col, vec3(1.2)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 246, 268, 268, 327], [330, 330, 381, 381, 488], [490, 575, 616, 616, 690], [692, 692, 712, 712, 755], [757, 757, 785, 785, 873], [875, 875, 914, 914, 954], [956, 1055, 1091, 1091, 1376], [1378, 1378, 1406, 1406, 1495], [1498, 1498, 1521, 1521, 1701], [1718, 1718, 1738, 1738, 1808], [1810, 1810, 1832, 1832, 2066], [2068, 2068, 2092, 2092, 2225], [2227, 2227, 2248, 2248, 2337], [2339, 2339, 2366, 2366, 2583], [2598, 2598, 2618, 2618, 2857], [2859, 2859, 2917, 2917, 3123], [3125, 3125, 3146, 3146, 3405], [3407, 3407, 3440, 3440, 3479], [3481, 3481, 3528, 3528, 3673], [3675, 3675, 3737, 3737, 3837], [3839, 3839, 3889, 3889, 3949], [3951, 3951, 4008, 4008, 4121], [4123, 4123, 4181, 4181, 4427], [4429, 4429, 4487, 4487, 4620], [4622, 4622, 4679, 4679, 5690]]}
{"id": "3sfXWn", "name": "yellow lady bug", "author": "acnologia", "description": "just trying to imitate an animation in bookofshaders tutorial", "tags": ["generative"], "likes": 2, "viewed": 81, "published": "Public", "date": "1550983048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.142857\nfloat circle(vec2 _st,float radius){\n    return 1.-smoothstep(radius-0.05,radius,length(vec2(0.5) - _st));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*10.;\n    uv.x *= iResolution.x/iResolution.y;\n    float t = iTime*2.,x_offset = -cos(mod(t,PI)),y_offset = -cos(mod(t-PI/2.,PI));\n    vec2 i = step(1.,mod(uv,2.));\n    float x_f = step(0.,x_offset)*(x_offset*(1.+2.*(i.y-1.))),\n        y_f = step(0.,y_offset)*(y_offset*(1.+2.*(i.x-1.))),\n        color = 1.-circle(fract(uv+vec2(x_f,y_f)),0.3);\n    fragColor = vec4(color,color,0.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 56, 56, 128], [129, 129, 186, 186, 614]]}
{"id": "3sj3DV", "name": "2D Matrix Rotation Triangles", "author": "synergyseeker1", "description": "2D Matrix Rotation Triangles - Art of Shaders", "tags": ["triangles", "shapes", "rotation", "polygons", "2dmatrixrotationtriangles", "artofshaders", "artofshaders", "artofshaders"], "likes": 8, "viewed": 698, "published": "Public API", "date": "1550035029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TWO_PI = 6.28;\nconst float PI = 3.14;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,0.0,_scale.y);\n}\n\n\nvec4 drawShape(vec2 uv, vec2 position, int sides,float size, vec3 color) {\n\tuv -= vec2(position.x,position.y);\n    // Angle from current pixel\n  \tfloat a = atan(uv.x,uv.y)+PI;\n    // radius from current pixel\n \tfloat r = 2.0*PI/float(sides);\n  \t// modulate the distance\n  \tfloat d = cos(floor(.5+a/r)*r-a)*length(uv);\n\t//define the edges, and make smooth\n  \tvec4 shape = vec4(smoothstep(size+.01,size,d));\n  \t//color the shape\n    shape.rgb*=color;\n\treturn shape;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normailze and adjsut for ratio\n    vec2 res = iResolution.xy,\n    uv = (fragCoord*2.0-res ) / res.y;\n    \n    // rotate the space\n    //uv = rotate2d(radians(180.0) ) * uv;\n    uv = rotate2d(iTime) * uv;\n    \n    //background color\n   \tvec4 background = vec4(0.0);\n  \t\n    // draw shapes\n    float pathRadius = 1.0;\n    float numberToPlot = 30.0;\n    vec4 shapes = vec4(0.0);\n    \n    for(float i=0.0;i<TWO_PI;i+=TWO_PI/numberToPlot){\n    \tuv = rotate2d(iTime*.1) * uv+ i*.1;\n        uv = scale( vec2(sin(iTime - cos(i*iTime*.2))*.1 + 1.)) * uv;\n    \tvec3 color = vec3(.3,.5*sin(i),.9);\n  \t\tint sides = 3;\n        float size = .05;\n    \tvec2 position = vec2(cos(i+iTime*.5),sin(i+iTime));\n        position*=pathRadius * sin(iTime);\n    \tvec4 shape = drawShape(uv,position,sides,size,color);    \n    \t\n    \tshapes += shape;\n    }  \n    \n    fragColor = mix(background, shapes, shapes.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sj3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 79, 79, 148], [150, 150, 174, 174, 220], [223, 223, 297, 297, 688], [691, 691, 748, 786, 1644]]}
{"id": "3sj3RK", "name": "Mini colored Mandelbox flythroug", "author": "xem", "description": "A \"scale 2.8\" Mandelbox fractal raymarched in WebGL seen along the axis [x: -0.44, y: 0.11]\nFormula by Tom Lowe (2010)\nCode by Bálint Csala, Literallylara, p01 (Mathieu Henri) and xem (Maxime Euziere) for js1k 2019", "tags": ["fractalraymarching"], "likes": 6, "viewed": 513, "published": "Public API", "date": "1549368754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec3 r=normalize(vec3(fragCoord.xy/500.-vec2(.5),1.)),p=vec3(-.44,.11,-10.+iTime/2.);\n  for(float i=.0;i<99.;i++){\n    vec4 o=vec4(p,1),q=o;\n    for(float i=0.;i<9.;i++){\n      o.xyz=clamp(o.xyz,-1.,1.)*2.-o.xyz;\n      o=o*clamp(max(.25/dot(o.xyz,o.xyz),.25),0.,1.)*vec4(11.2)+q;\n    }\n    float d=(length(o.xyz)-1.)/o.w-5e-4;\n    if(d<5e-4){break;}\n    p+=r*d;\n    fragColor.rgb=vec3(1.-i/50.-normalize(o.xyz)*.25);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sj3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 475]]}
{"id": "3sj3Wd", "name": "Glowing thread", "author": "sk537", "description": "Glowing thread", "tags": ["glow"], "likes": 0, "viewed": 105, "published": "Public", "date": "1550300575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // Zooms out by a factor of 2.0\n    uv *= 2.0;\n    // Shifts every axis by -1.0\n    uv -= 1.0;\n\n    // Base color for the effect\n    vec3 finalColor = vec3 (1., 1., 1. );\n\n    finalColor *= abs( 0.09/ (sin( uv.x + sin(uv.y+iTime)* 0.5 ) * 4.0) );\n\n    fragColor = vec4( finalColor, 1.0 );   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sj3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 451]]}
{"id": "3sj3Wt", "name": "dark planet", "author": "ali", "description": "inspired by : https://www.shadertoy.com/view/4lSSRw", "tags": ["planet", "stars"], "likes": 1, "viewed": 67, "published": "Public", "date": "1550274823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.7\n#define THIKNESS 0.009\n\n\nfloat sphereSDF(vec2 p){\n\treturn length(p)-RADIUS;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    float sdf = sphereSDF(uv);\n    float sm = smoothstep(0.0,THIKNESS,sdf);\n     \n    float sm2 =sm*(1.0-sm);\n    sm2*=1000.0;\n    \n   //outside\n    vec3 outside =vec3(0.95,0.95,0.87)*sin(iTime*0.3);\n   \n   \n   // inside   \n    vec2 x=fragCoord.xy;\n\tvec3 inside=vec3(max((fract(dot(sin(x),x))-.950)*10.*abs(tan(iTime*0.4)),.0));\n    \n    \n    /// edge\n    vec3 edge=vec3(0.05,abs(sin(iTime)*0.05),sin(iTime*4.0)*0.05);\n    \n    \n    //blend it all\n    vec3 mixedcol = mix(inside,outside,sm);\n    vec3 col=mix(mixedcol,edge,sm2);\n    \n    \n\n    \n   fragColor = vec4(col,1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sj3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 68, 68, 96], [99, 99, 156, 206, 852]]}
{"id": "3sjGDV", "name": "Dwarf", "author": "Kali", "description": "Playing with my star shader. Parameters found using Kodelife https://hexler.net/software/kodelife/", "tags": ["star", "corona", "volumetric", "kaliset"], "likes": 29, "viewed": 507, "published": "Public", "date": "1550028472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mouse (iMouse.xy/iResolution.xy)\n\n//Corona effect based on https://www.shadertoy.com/view/4dXGR4\n\nfloat \tinner_radius=.21;\nfloat \touter_radius=.235;\nfloat \tfov=.69; // not working in this version\nfloat\tzoom=1.8;\n\nfloat \tvol_steps=8.;\nfloat \tvol_rot=.68;\nfloat \tvol_fade=.45;\n\nfloat \tsurf_scale=1.75;\nint \tsurf_iterations=8;\nvec3\tsurf_param_1=vec3(.6,.45,.6);\nfloat\tsurf_param_2=1.2;\nfloat\tsurf_param_3=0.45;\nfloat \tsurf_exp=2.42;\nfloat\tsurf_base_value=.46;\nfloat\tsurf_intensity=1.13;\nfloat\tsurf_brightness=1.;\nfloat\tsurf_contrast=1.86;\nfloat \tsurf_rotation_speed=.15;\nfloat \tsurf_turbulence_speed=.05;\n\nfloat \tcor_size=.37;\nfloat \tcor_offset=.03;\nint \tcor_iterations=4;\nfloat \tcor_iteration_fade=.0;\nfloat \tcor_param_1=.24;\nfloat \tcor_param_2=.3;\nfloat \tcor_exp_1=1.;\nfloat \tcor_exp_2=1.5;\nfloat \tcor_brightness=3.5;\nfloat \tcor_speed=.1;\nfloat \tcor_speed_vary=.8;\n\nfloat\tglow_intensity=7.;\nfloat \tglow_size=.05;\n\n\nvec3\tcolor_1=vec3(.1,.15,.4);\nvec3\tcolor_2=vec3(.35,.22,.15);\nfloat\tcolor_saturation=0.5;\nfloat\tcolor_contrast=1.2;\nfloat\tcolor_brightness=0.4;\n\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nfloat sphere(vec3 p, vec3 rd, float r){\n\tfloat b = dot( -p, rd ), i = b*b - dot(p,p) + r*r;\n\treturn i < 0. ?  -1. : b - sqrt(i);\n}\n\n\nmat2 rot(float a) {\n    float si = sin(a);\n    float co = cos(a);\n    return mat2(co,si,-si,co);\n}\n\nfloat snoise(vec3 uv, float res) //by trisomie21\n{\n    const vec3 s = vec3(1e0, 1e2, 1e4);\t\n\tuv *= res;\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat kset(vec3 p) { //by me :P\n    p*=surf_scale*(1.+outer_radius);\n    float m=1000.;\n\tfor (int i=0; i<surf_iterations; i++) {\n        float d=dot(p,p);\n\t\tp=abs(p)/d*surf_param_2-vec3(surf_param_1);\n\t\tm=min(m,abs(d-surf_param_3))*(1.+surf_param_3);\n    }\n    float c=pow(max(0.,1.-m)/1.,surf_exp);\n\tc=pow(c,surf_exp)*surf_exp*surf_intensity;\n\treturn c; \n}\n\n\n//stolen and mutated code\nfloat cor(vec2 p) { \n\tfloat ti=iTime*cor_speed*cor_param_1+200.;\n    float d=length(p);\n\tfloat fad = (exp(-3.5*d)-outer_radius)/(outer_radius+cor_size)*(1.-step(.5,d));\n    \n    \n    float v1 = fad;\n\tfloat v2 = fad;\n\tfloat angle = atan( p.x, p.y )/6.2832;\n\tfloat dist = length(p)*cor_param_1/fov;\n\tvec3 crd = vec3( angle, dist, ti * .1 );\n    float ti2=ti+fad*cor_speed_vary*cor_param_1;\n    float t1=abs(snoise(crd+vec3(0.,-ti2*1.,ti2*.1),15.));\n\tfloat t2=abs(snoise(crd+vec3(0.,-ti2*.5,ti2*.2),45.));\t\n    float it=float(cor_iterations);\n    float s=1.;\n\tfor( int i=1; i<=cor_iterations; i++ ){\n\t\tti*=1.5;\n        float pw = pow(1.5,float(i));\n\t\tv1+=snoise(crd+vec3(0.,-ti,ti*.02),(pw*50.*(t1+1.)))/it*s*.13;\n\t\tv2+=snoise(crd+vec3(0.,-ti,ti*.02),(pw*50.*(t2+1.)))/it*s*.13;\n    }\n\t\n\tfloat co=pow(v1*fad,cor_exp_2)*cor_brightness;\n\tco+=pow(v2*fad,cor_exp_2)*cor_brightness;\n\tco*=1.-t1*cor_param_2*(1.-fad*.3);\n    return co;\n}\n\n\n//messy code below\nvec3 render(vec2 uv) {\n    vec3 ro=vec3(0.,0.,1.);\n    ro.yz*=rot(mouse.y*3.);\n    ro.xz*=rot(iTime*surf_rotation_speed-mouse.x*3.);\n    vec3 rd=normalize(vec3(uv,fov));\n    rd.xy*=.8;\n    rd=lookat(-ro,vec3(0.,1.,0.))*rd;\n    float tot_dist=outer_radius-inner_radius;\n\tfloat st=tot_dist/vol_steps;\n    float br=1./vol_steps;\n    float tr=iTime*surf_rotation_speed;\n\tfloat tt=iTime*surf_turbulence_speed;\n    float dist=0.;\n    float c=0.;\n    float dout=step(0.,sphere(ro, rd, outer_radius));\n    float d;\n    for (float i=0.; i<vol_steps; i++) {\n        d=sphere(ro, rd, inner_radius+i*st);\n        dist+=st;\n        vec3 p = ro+rd*d;\n        float a=vol_rot*i+tt;\n        p.yz*=rot(a);\n        p.xy*=rot(a);\n        c+=kset(p)*br*step(0.,d)*max(0.,1.-smoothstep(0.,tot_dist,dist)*vol_fade);\n    }\n\tc+=surf_base_value;    \n    vec3 col=1.*mix(color_1, color_2, vec3(c))*c;\n    inner_radius*=fov;\n    outer_radius*=fov;\n    glow_size*=fov;\n    cor_size*=fov;\n    float cor=cor(uv);\n    float r1=inner_radius;\n    float r2=outer_radius;\n    float l=smoothstep(r1-cor_offset,r2, length(uv));\n    float rt=outer_radius+glow_size;\n    float sw=1.-smoothstep(0.,rt,length(uv));\n    col=min(vec3(5.),pow(col,vec3(surf_contrast))*surf_brightness*surf_contrast);\n    col+=cor*color_1*l+sw*color_2*glow_intensity;\n    col=mix(vec3(length(col)), col, color_saturation)*color_brightness;\n    return pow(col,vec3(color_contrast));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\n\tuv.x*=iResolution.x/iResolution.y;\n    uv.x+=cos(iTime*.178924387342)*.1;\n    zoom*=1.+sin(iTime*.2)*.2;\n\tvec3 col = render(uv/zoom);\n    col=pow(col,vec3(1.5))*vec3(1.1,1.,1.);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 1068, 1097, 1097, 1193], [1195, 1195, 1234, 1234, 1325], [1328, 1328, 1347, 1347, 1426], [1428, 1428, 1478, 1478, 2000], [2002, 2002, 2022, 2033, 2359], [2362, 2388, 2407, 2407, 3315], [3318, 3337, 3359, 3359, 4758], [4762, 4762, 4819, 4819, 5076]]}
{"id": "3sjGDz", "name": "faces 13254135", "author": "theepicsnail", "description": "asdf", "tags": ["faces"], "likes": 2, "viewed": 51, "published": "Public", "date": "1551328206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cossin(float f) { return vec2(cos(f), sin(f)); }\nvec2 translate(vec2 uv, vec2 offset) { return uv - offset; }\nfloat circle(vec2 uv, vec2 center, float r) { return length(uv - center) - r; }\nfloat outline(float dist, float r) { return abs(dist)-r; }\nfloat subtract(float d1, float d2) { return max(d1, -d2); }\nfloat add(float d1,float d2) { return min(d1, d2); }\nfloat and(float d1,float d2) { return max(d1, d2); }\n\nvec2 rotate(vec2 uv, float a) {\n    vec2 cs = cossin(a);\n    return mat2x2(cs.x, -cs.y, cs.y, cs.x) * uv;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    //\n    \n\t\n    uv *= 3.0;\n    uv = fract(uv*.5+.5)*2.0-1.0;\n    uv.x = -abs(uv.x);\n    uv.x += sin(uv.y*10.0-iTime)*.05;\n    \n\n    float head = outline(circle(uv, vec2(0,0), 1.0), .01);\n    \n    \n    vec2 eyeOffset = vec2(-.4,.4);\n    float eyeL = circle(uv, eyeOffset, .10);\n    float pupilL = circle(uv, eyeOffset + .05 * cossin(iTime*3.0), .05);\n    eyeL = subtract(eyeL, pupilL);\n    \n    \n    \n    \n    uv = translate(uv, vec2(0, -.25));\n    uv = rotate(uv, iTime);\n    float mouth = outline(\n        and(circle(uv, vec2(0, -.05), .30),\n        \tcircle(uv, vec2(0, .05), .30))\n        , .01);\n    \n    \n    \n    float dist = head;\n    dist = add(dist, eyeL);\n    dist = add(dist, mouth);\n    \n    fragColor = vec4(1.0-dist*50.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 53], [54, 54, 92, 92, 114], [115, 115, 160, 160, 194], [195, 195, 231, 231, 253], [254, 254, 290, 290, 313], [314, 314, 344, 344, 366], [367, 367, 397, 397, 419], [421, 421, 452, 452, 528], [533, 533, 590, 640, 1440]]}
{"id": "3sjGzG", "name": "integrated atmospherics", "author": "isak", "description": "atmospherics, planet", "tags": ["raycast", "planet", "analytical"], "likes": 6, "viewed": 165, "published": "Public", "date": "1549205677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592653589793\n\nstruct Ray { vec3 pos, dir; };\n\nmat3 rot_yz(float a){\n    float ca = cos(a), sa = sin(a);\n\treturn mat3(1.0, 0.0, 0.0, 0.0, ca, -sa, 0.0, sa, ca);\n}\n\nmat3 rot_xz(float a){\n    float ca = cos(a), sa = sin(a);\n\treturn mat3(ca, 0.0, -sa, 0.0, 1.0, 0.0, sa, 0.0, ca);\n}\n\nbool ball_hit(float r, in vec3 c, in Ray R, out vec3 enter, out vec3 exit){\n    \n    // returns true if we hit and where we enter / exit\n    \n    vec3 dv = c - R.pos;  \t\t\t     \n    float d = length(dv);   \t\t\t        \n    float D = (r*r)/(d*d);    \t\t\t     \n    \n   \tfloat cos_a = dot(dv/d, R.dir);\t\n    float discr = 1. - (1. - cos_a*cos_a)/D;\n    \n    if (discr < 0.) return false;\n        \n    float root  = sqrt(discr);\n    enter = R.pos + (d*cos_a - r*root)*R.dir;\n    exit  = R.pos + (d*cos_a + r*root)*R.dir;\n\n    return true;\n}\n\nvec3 integral(in vec3 c, in Ray R, float t){\n    return t*R.pos + .5*t*t*R.dir - t*c;\n}\n\nfloat atmosphere(float r, float w, in vec3 c, in Ray R, in vec3 light_pos) {\n    \n    /*\n\t\treturns atmospheric light\n\t\t\n\t\tr : radius\n        w : width in percentage of r\n        c : center\n\t*/\n    \n    vec3 light = normalize(c - light_pos);\n    \n    float r1 = r;     // outer radius\n    float r2 = w*r;   // inner radius\n    \n    // ray cast of two concentric balls\n    vec3 r1m, r1p, r2m, r2p;\n    bool hit1 = ball_hit(r1, c, R, r1m, r1p);\n    if (!hit1) return 0.0;    \n    bool hit2 = ball_hit(r2, c, R, r2m, r2p);\n\n    // ray parameter start - stop\n   \tfloat t0 = length(r1m - R.pos);\n    float t1 = hit2 ? length(r2m - R.pos) : length(r1p - R.pos);\n    \n    // integrate atmosphere normal along ray\n    vec3 integ_n = integral(c, R, t1) - integral(c, R, t0);\n    \n    // return integrated light along ray\n    return (1.0/r1)*dot(integ_n, -light);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    Ray ray;\n    ray.dir = normalize(vec3(tan(.5*60.*pi/180.)*uv, 1.0));\n    ray.pos = vec3(uv + vec2(6.0, 3.0),-20.0);\n\n    vec3 light = rot_yz(0.5*0.3*iTime)*rot_xz(0.3*iTime)*vec3(1.0, 0.0, 0.0);\n    \n    // parameters\n    float r1 = 6.5;      // radius\n    float w  = 0.97;     // width\n    vec3  c  = vec3(0);  // center\n    \n    // atmosphere\n\tfloat atm = atmosphere(r1, w, c, ray, light);\n    vec3 ent, ext; bool hit = ball_hit(r1*w, c, ray, ent, ext);\n    vec3 n = normalize(ent - c);\n    \n    // surface and stars\n    mat3 rot = rot_yz(0.33*iTime)*rot_xz(0.1*iTime); ent *= rot;\n    float surf = texture(iChannel0, uv/(r1*w - 0.1*dot(ent.xy, ent.xy))).x;\n    vec4 star = texture(iChannel1, fragCoord/iResolution.y);\n    \n    // surface lighting\n    float dref = dot(reflect(ray.dir,n), light);\n    float dotn = dot(n, light);\n    \n    fragColor = 1.5*atm*vec4(0.4, 0.7, 1.0, 0.0)\n              + (clamp(dref + 1.0*dotn, 0.0, 1.0))*float(hit)*surf*vec4(0.5,0.5,0,0)\n              + 0.8*clamp(pow(dref, 101.0), 0.01, 1.0)*vec4(1.0);\n    \n    fragColor += (1.0 - float(hit))*(star*star.zzzz);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 83, 83, 177], [179, 179, 200, 200, 294], [296, 296, 371, 432, 829], [831, 831, 875, 875, 918], [920, 920, 996, 1112, 1774], [1776, 1776, 1833, 1833, 3006]]}
{"id": "3slSWH", "name": "Moving Lissajous-Lights", "author": "arthurstammet", "description": "Moving Blurry Circles\ninspired by The Art od Code - Shadertoy Tutorials\nhttps://www.youtube.com/playlist?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5", "tags": ["blur", "circle", "animation"], "likes": 0, "viewed": 337, "published": "Public API", "date": "1551187096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Moving Lissajous-Lights\n// inspired by The Art od Code - Shadertoy Tutorials\n// https://www.youtube.com/playlist?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5\n\nfloat Circle(vec2 uv, float r, float blur) {\n    float d = length(uv);\n    float c = smoothstep(r, r-blur, d);\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord.xy / iResolution.xy; \t// 0. <> 1.\n    vec2 uv2 = fragCoord.xy / iResolution.xy; \t// 0. <> 1.\n\n    // create Lissajous Curve 1\n    float ldiffx1 = .2;\t\t\t\t\t\t\t\n \tfloat ldiffy1 = .17;\t\t\t\t\t\t\n    float mx1 = .5+(sin(iTime*ldiffx1)*.35);\n    float my1 = .5+(cos(iTime*ldiffy1)*.25);\n    float mr1 = .15+(sin(iTime*.39)*.1);  // modulate the radius of the circle\n     \n    uv1 -= vec2(mx1,my1);\t\t\t\t\t\t\t// -0.5 <> 0.5\n    uv1.x *= iResolution.x/iResolution.y;\n   \n    float mask1 = Circle(uv1, mr1, .1-(mr1*.01));\n    float red1 = 0.7 + 0.3*cos(iTime*0.6);\n    float green1 = 0.7 + 0.3*cos(iTime*0.6);\n    float blue1 = 0.4 + 0.2*cos(iTime*0.46);\n    vec3 color1 = vec3(red1,green1,blue1)*mask1;\n\n    // create Lissajous Curve 2\n    float ldiffx2 = .6;\t\n \tfloat ldiffy2 = .45;\n    float mx2 = .5+(sin(iTime*ldiffx2)*.35);\n    float my2 = .5+(cos(iTime*ldiffy2)*.25);\n    float mr2 = .15+(sin(iTime*.33)*.11);\t// modulate the radius of the circle\n\n    uv2 -= vec2(mx2,my2);\t\t\t\t\t\t\t// -0.5 <> 0.5\n    uv2.x *= iResolution.x/iResolution.y;\n\n    float mask2 = Circle(uv2, mr2, .1-(mr2*.01));\n    float red2 = 0.8 + 0.3*cos(iTime*0.61);\n    float green2 = 0.7 + 0.3*cos(iTime*0.61);\n    float blue2 = 0.4 + 0.2*cos(iTime*0.41);\n    vec3 color2 = vec3(red2,green2,blue2)*mask2;\n\n    fragColor = vec4(vec3(color1 + color2), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 157, 201, 201, 284], [286, 286, 343, 343, 1682]]}
{"id": "3slSzn", "name": "Monte Carlo path tracer", "author": "sndels", "description": "Direct light sampling, Cook-Torrance specular term and naive (cosine hemisphere) reflection sampling. The ceiling corners look a bit funky and smooth materials would benefit from multiple importance sampling on both diffuse and specular reflection.", "tags": ["pathtracer", "brdf"], "likes": 32, "viewed": 2542, "published": "Public", "date": "1550489748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int SAMPLES_PER_PIXEL = 100;\nconst int BOUNCES = 3;\nconst float P_TERMINATE = 0.75;\nconst float EPSILON = 0.01;\n\n#define PI 3.14159265\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// sRGB, linear space conversions\n#define stol1(x) (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4))\n#define stol3(x, y, z) vec3(stol1(x), stol1(y), stol1(z))\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\n// From iq\nfloat seed = 1.0; //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n// From hg_sdf\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// --STRUCTS-------------------------------------------------------------------\nstruct AreaLight {\n    mat4 toWorld;\n    vec2 size;\n    vec3 E;\n};\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metalness;\n    vec3 emission;\n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n    float t;\n};\n\nstruct Hit {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nstruct RDir {\n    vec3 d;\n    float pdf;\n};\n\n// --SCENE---------------------------------------------------------------------\nconst int NUM_LIGHTS = 1;\nconst AreaLight LIGHTS[] = AreaLight[](\n    AreaLight(mat4(1, 0, 0, 0,\n                   0, 1, 0, 0,\n                   0, 0, 1, 0,\n                   0, 5, 0, 1),\n              vec2(1),\n              vec3(0.85, 0.8, 0.4) * vec3(30))\n);\n\nconst int NUM_SPHERES = 7;\nconst vec4 SPHERES[] = vec4[](\n    vec4(  -1.5,     -3,     0,     2),\n    vec4(     1,     -4,    -2,     1),\n    vec4(     0, -10005,     0, 10000),\n    vec4(     0,      0, 10005, 10000),\n    vec4(     0,  10005,     0, 10000),\n    vec4(-10005,      0,     0, 10000),\n    vec4( 10005,      0,     0, 10000)\n);\n\nconst vec3 COLORS[] = vec3[](\n    vec3(0, 0, 1),\n    stol3(1.0, 0.863, 0.616),\n    vec3(180) / vec3(255),\n    vec3(180) / vec3(255),\n    vec3(180) / vec3(255),\n    vec3(180, 0, 0) / vec3(255),\n    vec3(0, 180, 0) / vec3(255)\n);\n\nMaterial evalMaterial(vec3 p, int i)\n{\n    Material m;\n    m.albedo = vec3(1, 0, 1);\n    m.roughness = 1.0;\n    m.metalness = 0.0;\n    m.emission = vec3(1, 0, 1);\n    if (i >= 0) {\n        m.albedo = COLORS[i];\n        m.emission = vec3(0.0);\n        if (i == 0) {\n            m.roughness = 0.3;\n            m.metalness = 0.0;\n        } else if (i == 1) {\n            m.roughness = 0.4;\n            m.metalness = 1.0;\n        } else if (i == 4 && all(lessThan(abs(p.xz), LIGHTS[0].size))) {\n            m.emission = LIGHTS[0].E;\n        }\n    }\n    return m;\n}\n\n// --GEOMETRIC-----------------------------------------------------------------\n// Generate basis matrix for given normal\nmat3 formBasis(vec3 n)\n{\n    // Make vector q that is non-parallel to n\n    vec3 q = n;\n    vec3 aq = abs(q);\n    if (aq.x <= aq.y && aq.x <= aq.z) {\n        q.x = 1.f;\n    } else if (aq.y <= aq.x && aq.y <= aq.z) {\n        q.y = 1.f;\n    } else {\n        q.z = 1.f;\n    }\n\n    // Generate two vectors perpendicular to n\n    vec3 t = normalize(cross(q, n));\n    vec3 b = normalize(cross(n, t));\n\n    // Construct the rotation matrix\n    mat3 m;\n    m[0] = t;\n    m[1] = b;\n    m[2] = n;\n    return m;\n}\n\n// Generate view-ray for given (sub)pixel\nvec3 getViewRay(vec2 px, float hfov)\n{\n    vec2 xy = px - iResolution.xy * 0.5;\n    float z = iResolution.y / tan(radians(hfov));\n    vec3 d = normalize(vec3(xy, z));\n    if (iMouse.x > 0.0) {// Don't use the initial mouse position\n    \tpR(d.yz, iMouse.y / iResolution.y * 2.0 - 1.0);\n    \tpR(d.xz, iMouse.x / iResolution.x * 2.0 - 1.0);\n    }\n    return d;\n}\n\n// --SAMPLING------------------------------------------------------------------\nvec4 sampleLight(int i)\n{\n    AreaLight light = LIGHTS[i];\n    float pdf = 1.0 / (4.0 * light.size.x * light.size.y);\n    mat4 S = mat4(light.size.x,            0, 0, 0,\n                            0, light.size.y, 0, 0,\n                            0,            0, 1, 0,\n                            0,            0, 0, 1);\n    mat4 M = light.toWorld * S;\n    return vec4((M * vec4(vec2(rnd(), rnd()) * 2.0 - 1.0, 0, 1)).xyz, pdf);\n}\n\n// From http://www.rorydriscoll.com/2009/01/07/better-sampling/\nvec3 cosineSampleHemisphere() {\n    vec2 u = vec2(rnd(), rnd());\n    float r = sqrt(u.x);\n    float theta = 2.0 * PI * u.y;\n    return vec3(r * cos(theta), r * sin(theta), sqrt(saturate(1.0 - u.x)));\n}\n\nfloat cosineHemispherePDF(float NoL)\n{\n    return NoL / PI;\n}\n\n// --SHADING-------------------------------------------------------------------\n// Lambert diffuse term\nvec3 lambertBRFD(vec3 albedo)\n{\n    return albedo / PI;\n}\n\n// GGX distribution function\nfloat ggx(float NoH, float roughness)\n{\n    float a2 = roughness * roughness;\n    a2 *= a2;\n    float denom = NoH * NoH * (a2 - 1.0) + 1.0;\n    return a2 / (PI * denom * denom);\n}\n\n// Schlick fresnel function\nvec3 schlickFresnel(float VoH, vec3 f0)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - VoH, 5.0);\n}\n\n// Schlick-GGX geometry function\nfloat schlick_ggx(float NoL, float NoV, float roughness)\n{\n    float k = roughness + 1.0;\n    k *= k * 0.125;\n    float gl = NoL / (NoL * (1.0 - k) + k);\n    float gv = NoV / (NoV * (1.0 - k) + k);\n    return gl * gv;\n}\n\n// Evaluate the Cook-Torrance specular BRDF\nvec3 cookTorranceBRDF(float NoL, float NoV, float NoH, float VoH, vec3 F, float roughness)\n{\n    vec3 DFG = ggx(NoH, roughness) * F * schlick_ggx(NoL, NoV, roughness);\n    float denom = 4.0 * NoL * NoV + 0.0001;\n    return DFG / denom;\n}\n\n// Evaluate combined diffuse and specular BRDF\nvec3 evalBRDF(vec3 n, vec3 v, vec3 l, Material m)\n{\n    // Common dot products\n    float NoV = saturate(dot(n, v));\n    float NoL = saturate(dot(n, l));\n    vec3 h = normalize(v + l);\n    float NoH = saturate(dot(n, h));\n    float VoH = saturate(dot(v, h));\n\n    // Use standard approximation of default fresnel\n    vec3 f0 = mix(vec3(0.04), m.albedo, m.metalness);\n    vec3 F = schlickFresnel(VoH, f0);\n\n    // Diffuse amount\n    vec3 Kd = (1.0 - F) * (1.0 - m.metalness);\n\n    return (Kd * lambertBRFD(m.albedo) + cookTorranceBRDF(NoL, NoV, NoH, VoH, F, m.roughness)) * NoL;\n}\n\n// --INTERSECTION-------------------------------------------------------------------\nfloat iSphere(Ray r, int i)\n{\n    vec4 s = SPHERES[i];\n    vec3 L = s.xyz- r.o;\n    float tc = dot(L, r.d);\n    float d2 = dot(L, L) - tc * tc;\n    float r2 = s.w * s.w;\n    if (d2 > r2)\n        return r.t;\n\n    float tlc = sqrt(r2 - d2);\n    float t0 = tc - tlc;\n    float t1 = tc + tlc;\n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < 0.0) {\n        if (t1 < 0.0)\n            return r.t;\n        return t1;\n    }\n    return t0;\n}\n\n// --TRACING-------------------------------------------------------------------\nHit traceRay(Ray r)\n{\n    int object = -1;\n    float t = r.t;\n    for (int i = 0; i < NUM_SPHERES; ++i) {\n        float nt = iSphere(r, i);\n        if (nt < t) {\n            t = nt;\n            object = i;\n        }\n    }\n    vec3 position = vec3(0);\n    vec3 normal = vec3(0);\n    if (object >= 0) {\n        position = r.o + t * r.d;\n        normal = normalize(position - SPHERES[object].xyz);\n    }\n    return Hit(object >= 0, position, normal, evalMaterial(position, object));\n}\n\nvec3 tracePath(vec2 px)\n{\n    vec3 ei = vec3(0);\n    for (int j = 0; j < SAMPLES_PER_PIXEL; ++j) {\n        // Generate ray\n        vec2 sample_px = gl_FragCoord.xy + vec2(rnd(), rnd());\n        Ray r = Ray(vec3(0,0,-15.5), getViewRay(sample_px, 45.0), 100.0);\n\n        int bounce = 1;\n        vec3 throughput = vec3(1);\n        while (true) {\n            // Fire away!\n            Hit hit = traceRay(r);\n\n            // Cut ray on miss, \"backface\" hit or being outside the box\n            if (!hit.hit || dot(hit.normal, r.d) > 0.0 || hit.position.z < -5.0)\n                break;\n\n            // Collect common info\n            Material m = hit.material;\n            vec3 n = hit.normal;\n            vec3 p = hit.position + hit.normal * EPSILON;\n\n            // Add hacky emission on first hit to draw lights\n            if (bounce == 1)\n                ei += throughput * m.emission;\n\n            // Sample lights\n            for (int i = 0; i < NUM_LIGHTS; ++i) {\n                // Generate point on light surface\n                vec4 ls = sampleLight(i);\n                vec3 pL = ls.xyz;\n                float pdf = ls.w;\n\n                // Generate shadow ray\n                vec3 toL = pL - p;\n                Ray sr;\n                sr.o = p;\n                sr.t = length(toL);\n                sr.d = toL / sr.t;\n\n                // Test visibility\n                Hit sh = traceRay(sr);\n                if (!sh.hit) {\n                    // Add light contribution when visible\n                    float r2 = sr.t * sr.t;\n                    vec3 lN = vec3(0, -1, 0); // TODO: generic\n                    if (dot(lN, -sr.d) > 0.0) {\n                    \tvec3 E = LIGHTS[i].E;\n                    \tei += throughput * evalBRDF(hit.normal, -r.d, sr.d, m) * E / (r2 * pdf);\n                    }\n                }\n            }\n\n            // Russian roulette for termination\n            if (bounce >= BOUNCES && rnd() < P_TERMINATE)\n                break;\n\n            // Get random direction for reflection ray\n            vec3 rd = cosineSampleHemisphere();\n            // Rotate by normal frame\n            rd = normalize(formBasis(n) * rd);\n            float pdf = cosineHemispherePDF(dot(n, rd));\n            // TODO: Multiple importance sampling on diffuse and specular?\n            throughput *= evalBRDF(hit.normal, -r.d, rd, m) / pdf;\n            r.d = rd;\n            r.o = p;\n            bounce++;\n        }\n    }\n    return ei / float(SAMPLES_PER_PIXEL);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Reseed by iq\n    seed = iTime + fragCoord.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 color = tracePath(gl_FragCoord.xy);\n    fragColor = vec4(ltos3(color.x, color.y, color.z), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 546, 559, 559, 602], [604, 619, 651, 651, 696], [1135, 2050, 2088, 2088, 2610], [2612, 2734, 2758, 2805, 3236], [3238, 3280, 3318, 3318, 3639], [3641, 3721, 3746, 3746, 4154], [4156, 4220, 4251, 4251, 4421], [4423, 4423, 4461, 4461, 4484], [4486, 4590, 4621, 4621, 4647], [4649, 4678, 4717, 4717, 4857], [4859, 4887, 4928, 4928, 4980], [4982, 5015, 5073, 5073, 5234], [5236, 5280, 5372, 5372, 5517], [5519, 5566, 5617, 5644, 6144], [6146, 6231, 6260, 6260, 6711], [6713, 6793, 6814, 6814, 7274], [7276, 7276, 7301, 7301, 9753], [9756, 9756, 9813, 9833, 10031]]}
{"id": "3slXD8", "name": "Parametric equation DE", "author": "gaz", "description": "2d", "tags": ["2d", "bezier", "de"], "likes": 10, "viewed": 340, "published": "Public", "date": "1551185076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    t=clamp(t,0.0,1.0);\n\treturn mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n\treturn mix(bezier(a,b,c,t),bezier(b,c,d,t),t);\n}\n\nvec2 func(float t) // parametric equation\n{\n    vec2 ret;\n    switch (int(mod(iTime/5.0,3.0)))\n    {\n        case 1:\n            vec2 a = vec2(1,0);\n            vec2 b = vec2(0.2,sin(iTime));\n            vec2 c = -b;\n            vec2 d = vec2(-1,0);\n            ret = bezier(a,b,c,d,t);\n            break;\n        case 2:\n            t *= 3.1415*6.0;\n            float x = t*0.1-1.0;\n            float y = 0.2*sin(t*0.3+2.0*sin(t*0.5)+iTime);\n            ret = vec2(x,y);\n            break;\n        default:\n            ret = 0.6*vec2(\n                cos(5.0*t*fract(iTime*0.3)),\n                sin(5.0*t*fract(iTime*0.3))\n                );\n            break;\n    }\n    return ret;\n}\n\nfloat de(vec2 p)\n{\n \tfloat ITR = 50.0, pitch = 1.0, t = 0.5, de = 1e10;   \n    for(int j=0; j<2; j++)\n    {\n        float t0 = t-pitch*0.5;\n        pitch /= ITR;\n        for(float i=0.0; i<=ITR; i++) \n        {\n            float de0=distance(p,func(t0));\n            if (de0<de)\n            {\n                de = de0;\n                t=t0;\n            }       \n            t0 += pitch;\n        }\n    }\n    return de;\n    \n    /*\n    float st = 1.0/500.0;\n    float de = 1e10;\n    for (float i=1.0; i>0.0; i-=st)\n        de=min(de,distance(p,func(i)));\n    return de;\n\t*/\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float d = de(p)-0.1;\n    \n    //iq's color scheme\n\tvec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 110], [112, 112, 166, 166, 216], [218, 218, 261, 261, 904], [906, 906, 924, 924, 1479], [1482, 1482, 1539, 1539, 1866]]}
{"id": "3slXzM", "name": "hippieCircles", "author": "ghost7", "description": "test", "tags": ["circle"], "likes": 3, "viewed": 273, "published": "Public", "date": "1550960896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nint b(int N, int B) { return N>>B & 1; }\nint T[] = int[](0x15,0x38,0x32,0x2c,0x0d,0x13,0x07,0x2a);\nint A[] = int[](0,0,0);\n\nint b(int i, int j, int k, int B) { return T[b(i,B)<<2 | b(j,B)<<1 | b(k,B)]; }\n\nint shuffle(int i, int j, int k) {\n    return b(i,j,k,0) + b(j,k,i,1) + b(k,i,j,2) + b(i,j,k,3) +\n        b(j,k,i,4) + b(k,i,j,5) + b(i,j,k,6) + b(j,k,i,7) ;\n}\n\nfloat K(int a, vec3 uvw, vec3 ijk)\n{\n    float s = float(A[0]+A[1]+A[2])/6.0;\n    float x = uvw.x - float(A[0]) + s,\n        y = uvw.y - float(A[1]) + s,\n        z = uvw.z - float(A[2]) + s,\n        t = 0.6 - x * x - y * y - z * z;\n    int h = shuffle(int(ijk.x) + A[0], int(ijk.y) + A[1], int(ijk.z) + A[2]);\n    A[a]++;\n    if (t < 0.0)\n        return 0.0;\n    int b5 = h>>5 & 1, b4 = h>>4 & 1, b3 = h>>3 & 1, b2= h>>2 & 1, b = h & 3;\n    float p = b==1?x:b==2?y:z, q = b==1?y:b==2?z:x, r = b==1?z:b==2?x:y;\n    p = (b5==b3 ? -p : p); q = (b5==b4 ? -q : q); r = (b5!=(b4^b3) ? -r : r);\n    t *= t;\n    return 8.0 * t * t * (p + (b==0 ? q+r : b2==0 ? q : r));\n}\n    \nfloat noise(float x, float y, float z)\n{\n    float s = (x + y + z) / 3.0;  \n    vec3 ijk = vec3(int(floor(x+s)), int(floor(y+s)), int(floor(z+s)));\n    s = float(ijk.x + ijk.y + ijk.z) / 6.0;\n    vec3 uvw = vec3(x - float(ijk.x) + s, y - float(ijk.y) + s, z - float(ijk.z) + s);\n    A[0] = A[1] = A[2] = 0;\n    int hi = uvw.x >= uvw.z ? uvw.x >= uvw.y ? 0 : 1 : uvw.y >= uvw.z ? 1 : 2;\n    int lo = uvw.x <  uvw.z ? uvw.x <  uvw.y ? 0 : 1 : uvw.y <  uvw.z ? 1 : 2;\n    return K(hi, uvw, ijk) + K(3 - hi - lo, uvw, ijk) + K(lo, uvw, ijk) + K(0, uvw, ijk);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //box\n    //vec2 center = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    //float boxSize = 200.0;\n    \n    //if (fragCoord.x > center.x - boxSize && fragCoord.x < center.x + boxSize && fragCoord.y > center.y - boxSize\n    //    && fragCoord.y < center.y + boxSize)\n    //{\n    //    float noiseyPt = noise(fragCoord.x, fragCoord.y, 0.0);\n    //\tfragColor = vec4(noiseyPt, noiseyPt, noiseyPt, noiseyPt);\n    //}\n    \n    \n    //circle\n    vec2 centerScreen = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    float outerRadius = 150.0;\n    float innerRadius = 100.0;\n    \n    //just use distance!!! no need for formula of a circle bs!\n    float currentDistance = distance(fragCoord, centerScreen);\n    vec2 mouseDistance = vec2(distance(iMouse.x, centerScreen.x)/4.0, distance(iMouse.y, centerScreen.y));\n    float noiseSize = 8.0 * iTime;\n    \n    //float yMax = sqrt(pow(radius, 2.0) - pow(fragCoord.x - centerScreen.x, 2.0)) + centerScreen.y;\n    //float yMin = -1.0 * sqrt(pow(radius, 2.0) - pow(fragCoord.x - centerScreen.x, 2.0)) + centerScreen.y;\n    //float xMax = sqrt(pow(radius, 2.0) - pow(fragCoord.y - centerScreen.y, 2.0)) + centerScreen.x;\n    //float xMin = -1.0 * sqrt(pow(radius, 2.0) - pow(fragCoord.y - centerScreen.y, 2.0)) + centerScreen.x;\n\n    if (currentDistance > mouseDistance.x && currentDistance < mouseDistance.y)\n    {\n        float noiseyPt = iTime - 1.0/noise(fragCoord.x/noiseSize, fragCoord.y/noiseSize, iTime);\n        vec3 color = tan(noiseyPt + vec3(1, 2, 4));\n    \tfragColor = vec4(color, 0.5);\n    }\n    else\n    {\n        fragColor = vec4(255.0, 255.0, 255.0, 255.0);\n    }\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 41], [125, 125, 160, 160, 204], [206, 206, 240, 240, 365], [367, 367, 403, 403, 1029], [1035, 1035, 1075, 1075, 1591], [1597, 1597, 1654, 2093, 3524]]}
{"id": "3sS3Dy", "name": "Guns, Lots of guns", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarching", "guns"], "likes": 4, "viewed": 150, "published": "Public", "date": "1549844889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat cap(vec3 p, float l, float w)\n{\n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - w;\n}\n\nfloat torus(vec3 p, float r, float w)\n{\n    return sqrt(pow(length(p.xz)-r, 2.) + pow(p.y, 2.)) - w;\n}\n\nfloat map(vec3 p)\n{\n    \n    p.xz *= rot(iTime*.5);\n    p -= vec3(0., 0., 3.);\n    vec3 id = floor(p);\n    \n    p = mod(p+vec3(11.), 20.)-vec3(11.);\n    \n    vec3 px = vec3(abs(p.x), p.y, p.z);\n    \n    float barrel = max(max(cap(p.xzy, 1., .1), -cap(p.xzy, 2., .05)), p.z-.5);\n    vec3 hfp = px*13.;\n    hfp = mod(hfp+vec3(.5), 2.)-vec3(.5);\n    float holes = (length(hfp)-1.)/13.;\n    float grid = max(max(max(cap(p.xzy, 1., .18), -cap(p.xzy, 2., .16)), p.z-.4), -holes);\n    barrel = min(barrel, grid);\n    \n    // Body\n    vec3 bp = px.xzy;\n    bp.z *= .4;\n    float body = max(max(cap(bp-vec3(0., -.5, -.1), .5, .3)/2., (p.zy*rot(-.5)).x-.1), px.x-.18);\n    float bigBody = cap(bp-vec3(0., -3., -.2), 2.5, .4);\n    float frontHole = cap(px.xzy-vec3(0., -1.5, -.8), .6, .5);\n    float backHole = cap(px.xzy-vec3(0., -4., -.8), .6, .5); // Backhole lol\n    float topRidge = cap(px.xzy-vec3(0., -1.4, .49), 5., .08);\n    float sideRidge = cap(px.xzy-vec3(0.2, -1.8, 0.), 5., .03);\n    vec3 fdp = px;\n    fdp.xz *= rot(-.5);\n    float fing1 = cap(fdp.yxz-vec3(-.7, -1.8, -0.01), 3., .13);\n    float fing2 = cap(fdp.yxz-vec3(-.9, -1.8, -0.05), 3., .13);\n    float fing3 = cap(fdp.yxz-vec3(-1.1, -1.8, -0.1), 3., .13);\n    float fing4 = cap(fdp.yxz-vec3(-1.3, -1.8, -0.15), 3., .13);\n    float t = max(torus(p-vec3(0., -.9, -2.8), .65, .48), -p.y-1.25);\n    body = max(max(max(max(max(max(max(max(max(max(max(min(body, bigBody), (px.x-.21)), -topRidge), -sideRidge), -frontHole), -backHole), -fing1), -fing2), -fing3), -fing4), -t), -p.z-5.75);\n    \n    // Top thing\n    vec3 hp = px-vec3(0., .3, -3.6);\n    float handle = cap(hp.xzy, 2., .5);\n    float handleIndent = cap(px.xzy-vec3(0., -3.3, .95), 2., .5);\n    float inIndent = cap(px.xzy-vec3(0., -3.4, .85), 3., .3);\n    float bigInd = cap(px.xzy-vec3(0.4, -4., 0.18), 1.5, .25);\n    float backInd = cap(px-vec3(0., 1.6, -6.05), 1.5, .2);\n    float tube = cap(px-vec3(0.2, .2, -3.), .2, .05);\n    vec3 wp = px - vec3(0.25, 0., 1.);\n    wp *= 10.;\n    wp.z = mod(wp.z+2., 1.)-2.;\n    float wiggles = cap(wp-vec3(0., 5.5, -1.5), .25, .5)/10.;\n    handle = min(max(max(max(max(max(max(max(handle, hp.x-.25), -handleIndent), -inIndent), -wiggles), -bigInd), -p.z-5.9), -backInd), tube);\n    \n    // Trigger\n    vec3 tp = px;\n    float trigger = cap(px.xzy-vec3(0., -2.4, -.55), .2, .2);\n    float curve = cap(px.yxz-vec3(-.4, 0., -1.8), .2, .5);\n    float curve2 = cap(px.yxz-vec3(-.47, 0., -2.58), .2, .15);\n    float curve3 = cap(px.yxz-vec3(-.53, 0., -2.15), .2, .15);\n    trigger = max(max(max(max(trigger, -curve), px.x-.05), -curve2), -curve3);\n    \n    // Switch\n    float swit = length(p-vec3(0.2, -.4, -2.8)) -.06;\n    \n    float gun = min(min(min(min(body, barrel), handle), trigger), swit);\n    // Bullet added by scratch13764\n    float bullet = length(p - vec3(0,0,fract(iTime)*10.))-.07; return min(gun , bullet);\n    return min(gun , bullet);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<328; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .001) break;\n        if(t > 200.) return -1.;\n        t += d*.8;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    //uv = abs(uv);\n\t\n    vec3 eye = vec3(0., -.25, 5.5);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    eye.y += sin(iTime*.5)*.15;\n    dir.yz *= rot(cos(iTime*.5)*.15);\n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    \n    vec3 col;\n    if(d < 0.) {\n        col = vec3(1.);\n    } else {\n    \tvec3 normal = getNormal(p);\n        col = vec3(1.);\n        col *= vec3(.1) * max(0., dot(normal, vec3(0., 1., 1.)));\n        col += vec3(.8, .8, 1.) * .5*max(0., dot(normal, vec3(0., 1., 1.)));\n        col *= vec3(.2) * pow(max(0., dot(normal, -dir)), 20.);\n        col += vec3(.8, .8, 1.) * .1*max(0., dot(normal, vec3(1., 1., 0.)));\n    }\n\n    // Output to screen\n    col *= 1.-length(uv)*.7;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sS3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 134, 134, 194], [196, 196, 235, 235, 298], [300, 300, 319, 319, 3208], [3210, 3210, 3241, 3241, 3421], [3423, 3423, 3447, 3447, 3635], [3637, 3637, 3694, 3744, 4596]]}
{"id": "3sSGDV", "name": "Long way home", "author": "skaplun", "description": "Original - http://worldintheirart.tumblr.com/post/163985074617\nIts probably better not to raymarch but analytically test ray intersection with torus and plane.\nCircle noise by Leukbaars", "tags": ["raymarching", "noise", "circle", "animation"], "likes": 15, "viewed": 317, "published": "Public", "date": "1549971919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA (10./iResolution.y)\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define PI 3.1415\n#define TAU (PI * 2.)\n#define TORUS vec2(10., 1.)\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec2 unionSDF(vec2 a, vec2 b) {\n    if(a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\nfloat sdInnerTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return t.y - length(q);\n}\n\nvec2 sceneSDFwithMat(vec3 samplePoint) {    \n    float torus = sdInnerTorus(samplePoint, TORUS);\n    return unionSDF(\n                    vec2(torus, 1.),\n                    vec2(samplePoint.y + .25, 2.)\n                    );\n}\n\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDFwithMat(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n            return vec2(depth, dist.y);\n        }\n        depth += dist.x;\n        if (depth >= end) {\n            return vec2(end, 0.);\n        }\n    }\n    return vec2(end, 0.);\n}\n\nvec2 convertToPolarCoords(in vec3 p){\n    float bAng = atan(-p.z, p.x);\n    p *= rotateY(-bAng);\n    float sAng = atan(p.x - TORUS.x, p.y);\n    \n    return (vec2(bAng, sAng) + PI)/TAU;\n}\n\nvec2 hash( float n ){\n    float sn = sin(n);\n    return fract(vec2(sn,sn*42125.13));\n}\n\nfloat circleNoise( vec2 uv ){\n    float uv_y = floor(uv.y);\n    uv.x += uv_y*.31;\n    vec2 f = fract(uv);\n    vec2 h = hash(floor(uv.x)*uv_y);\n    float m = (length(f-.25-(h.x*.5)));\n    float r = h.y*.25;\n    return smoothstep(r+AA, r, m);\n}\n\nconst mat2 rot = mat2( 0.4,  0.4, -0.4,  0.4 );\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 eye = vec3(0., 0., TORUS.x - .125);\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(1., 0., 9.75), vec3(0.0, 1.0, 0.0)) * viewDir;\n    \n    vec2 dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist.x < MAX_DIST - EPSILON) {\n        vec3 p = (eye + dist.x * worldDir);\n        vec2 pc = convertToPolarCoords(p);\n        \n        if(dist.y == 1.){\n            float m = 0.;\n            vec2 uv = pc * vec2(64., 16.) + vec2(iTime * 3., 0.);\n            for(float i=1.;i<=3.;i++){\n                uv += uv * rot * (1. + .012 * i) + 1121.13;\n                m += circleNoise(uv);\n            }\n            fragColor = vec4(vec3(m), 1.0);\n        }else{\n            float clr = smoothstep(.01 + AA, .01, abs(9.1 - length(p.xz)));\n            clr = max(smoothstep(.01 + AA, .01, abs(10.9 - length(p.xz))), clr);\n            clr = max(smoothstep(.025 + AA, .025, abs(10. - length(p.xz)))\n                    * smoothstep(.25 + AA, .25, abs(.5 - fract(p.x + iTime * 4.))), clr);\n            fragColor = vec4(vec3(clr), 1.0);\n        }\n    }else{\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 371], [373, 373, 438, 438, 570], [572, 572, 621, 621, 752], [754, 754, 785, 785, 850], [852, 852, 890, 890, 957], [959, 959, 999, 999, 1188], [1190, 1190, 1280, 1280, 1639], [1641, 1641, 1678, 1678, 1827], [1829, 1829, 1850, 1850, 1915], [1917, 1917, 1946, 1946, 2159], [2209, 2209, 2265, 2265, 3454]]}
{"id": "3sSGRK", "name": "Colorful Light fan", "author": "Canysway", "description": "colorful moving light fan", "tags": ["light", "colorful", "flash", "fan"], "likes": 3, "viewed": 141, "published": "Public", "date": "1549286103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvec2 mouse = vec2(0.35, 0.2);\n\nfloat getLightColor(vec2 uv, float p_ratio, float plus, float minus){\n    float color = 0.;\n    float angle = atan(uv.x, uv.y);\n    float alpha_r = smoothstep(1./p_ratio *PI - 0.1, 1./p_ratio *PI , angle);\n    float alpha_l = smoothstep(-1./p_ratio *PI, -1./p_ratio *PI + 0.1, angle);\n    float alpha = alpha_l * (1. - alpha_r);\n    if (alpha == 0.) {alpha = 0.03;}\n    \n    float circle = plus/sqrt(minus * length(uv));\n    color = circle * circle * alpha + 0.05;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x = uv.x * iResolution.x/iResolution.y * 0.75;\n    uv -= mouse;\n    float p_ratio = (sin(iTime) + 1.)* 2. + 3.5;\n    float outColorA = getLightColor(uv, p_ratio, 0.2, 0.25);\n    float insideColorA = getLightColor(uv, p_ratio + 1.5, 0.15, 0.25);\n \tfloat colorA = outColorA + insideColorA;\n    \n    float outColorB = getLightColor(vec2(uv.x - 0.6, uv.y), p_ratio, 0.2, 0.25);\n    float insideColorB = getLightColor(vec2(uv.x - 0.6, uv.y), p_ratio + 1.5, 0.15, 0.25);\n \tfloat colorB = outColorB + insideColorB;\n   \t\n    vec4 r_light = vec4(vec3(0.7, 0.,0.6), 1.0);\n    r_light *= colorA;\n    \n    vec4 w_light = vec4(vec3(0., 0.,0.6),1.);\n    w_light *= colorB;\n    \n    fragColor = mix(r_light, w_light, colorB);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 120, 120, 535], [537, 537, 593, 593, 1356]]}
{"id": "3sSGWy", "name": "Blue spiral", "author": "Nemix", "description": "Little simple experiment with low maximum step count raymarch", "tags": ["raymarch"], "likes": 7, "viewed": 335, "published": "Public API", "date": "1549831304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_TRY_COUNT 110.\n#define EPSI .001\n#define PI 3.141592\n\nfloat sdSphereLines(vec3 p, vec3 so, float s, float ph){//so: sphere origin, s = size, ph = phase between 0 and 2Pi\n    // p.x += sin(p.z + iTime*2.)*.1;\n    // p.y += cos(p.z + iTime*2.)*.1;\n    float r = 1.;\n    p.x += sin(p.z*.1 + ph)*r;\n    p.y += cos(p.z*.1 + ph)*r;\n    float zTime = p.z + iTime;\n    float m = -1.;\n    float fl = floor(zTime/m)*m;\n    s += max(sin(p.z *.1 - iTime*4.)*.07,0.0);\n    p.z = zTime - fl;\n    return length(p- so)-s;\n}\n\nfloat sdPlane(vec3 p, vec4 pl){\n    p.y += (sin(p.x + iTime*.5) + cos(p.z + iTime))*.05;\n    return dot(p,pl.xyz) - pl.w;\n}\n\nfloat map(vec3 rp){\n    float s1 = sdSphereLines(rp, vec3(0.), .01, PI);\n    float s2 = sdSphereLines(rp, vec3(0.), .01, .0);\n    return min(s1,s2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y *= (iResolution.y/iResolution.x);\n    \n    //Raymarch\n    vec3 p = vec3(0.,0.,-10.);\n    vec3 v = normalize(vec3(uv.xy, 10.));\n    float dist = map(p);\n    float acc = 0.;\n    for(float i = 0.; i < MAX_TRY_COUNT; i++){\n        if(dist < EPSI){\n            break;\n        }else{\n            p += v*dist;\n            dist = map(p);\n            acc += dist;\n        }\n    }\n    vec3 alb = vec3(.1,.4,.7);\n    vec3 col;\n    col = alb*(.9-acc*.0002);\n    if(dist < EPSI){\n        vec2 epsAndZero = vec2(0.02, 0.);\n        vec3 normal = vec3(\n            map(p - epsAndZero.xyy) - map(p + epsAndZero.xyy),\n            map(p - epsAndZero.yxy) - map(p + epsAndZero.yxy),\n            map(p - epsAndZero.yyx) - map(p + epsAndZero.yyx)\n        );\n        normal = normalize(normal);\n        vec3 l = normalize(vec3(.0,1.,-1.));\n        float diff = max(dot(normal, l),0.);\n\n\n        //Blinn\n        // vec3 r = reflect(l,normal);\n        // float spec = pow(max(dot(r, v),0.),16.);\n\n        //Blinn Phong\n        vec3 h = normalize(-l+v);\n        float spec = pow(max(dot(normal,h),0.),16.);\n\n        col += spec + diff * alb* .7;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 122, 257, 519], [521, 521, 552, 552, 644], [646, 646, 665, 665, 796], [798, 798, 855, 905, 2152]]}
{"id": "3ssSD8", "name": "V's fire effect", "author": "vegardno", "description": "This was supposed to be a water effect...", "tags": ["flame", "fire", "effect"], "likes": 10, "viewed": 692, "published": "Public", "date": "1551189265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTH 1\n#define MULTIPLE 1\n#define DEBUG_LINE 0\n\n#if SMOOTH\n#define FLAME_BASE_WIDTH .012\n#else\n#define FLAME_BASE_WIDTH .0\n#endif\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float r, float x, const float n)\n{\n    r *= 1337.;\n    float noise0 = rand(r + floor(n * x));\n    float noise1 = rand(r + floor(n * x + 1.));\n    float t = fract(n * x);\n\treturn t * noise1 + (1. - t) * noise0;\n}\n\nfloat line(vec2 uv)\n{\n#if MULTIPLE\n    uv = vec2(mod(uv.x + .25, .5) - .25, uv.y + floor((uv.x + .25) / .5));\n#endif\n    \n\tfloat center = .1 * (noise(1., uv.y, 5.) + .8 * noise(2., uv.y, 10.) - .9);\n\tfloat width = FLAME_BASE_WIDTH + .04 * (noise(3., uv.y, 5.) + .8 * noise(4., uv.y, 10.));    \n#if SMOOTH\n    //return sin(3.14 * clamp(.5 + (uv.x - center) / width, 0., 1.));\n    if (uv.x < center - width)\n        return 0.;\n    if (uv.x < center)\n        return smoothstep(center - width, center - .7 * width, uv.x);\n    if (uv.x < center + width)\n        return 1. - smoothstep(center + .7 * width, center + width, uv.x);\n\treturn 0.;\n#else\n    return float(uv.x > center - width && uv.x < center + width);\n#endif\n}\n\nvec2 rot(vec2 uv, float a)\n{\n    return uv * mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat flame(vec2 uv, float spread, float p)\n{\n\tfloat col = 1.;\n    col *= line(rot(uv, 3.14 - spread) + vec2(0., p + iTime));\n    col *= line(rot(uv, 3.14 + spread) + vec2(0., p + iTime));\n\treturn col;\n}\n\nvec3 fire_color(float x)\n{\n\treturn\n        // red\n        vec3(1., 0., 0.) * x\n        // yellow\n        + vec3(1., 1., 0.) * clamp(x - .5, 0., 1.)\n        // white\n        + vec3(1., 1., 1.) * clamp(x - .7, 0., 1.);\n}\n\nvec3 smoke_color(float x)\n{\n    return vec3(.5, .5, .5) * x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - vec2(.5 * iResolution.x, 0.)) / iResolution.y\n        - vec2(0., .5);\n\n    //uv *= 3. + 2. * cos(-iTime);\n    \n#if DEBUG_LINE\n   \tfragColor = vec4(vec3(1., 0., 0.) * line(uv + vec2(0., iTime)), 1.0);\n#else\n    const int fire_n = 10;\n\tfloat fire_intensity = 0.;\n    for (int i = 0; i < fire_n; ++i) {\n        float t = float(i)/ float(fire_n) - .5;\n    \tfire_intensity += flame(uv + vec2(0., .08 + .1 * t), .15 + .1 * t, 273. * float(i));\n    }\n\n    fragColor = vec4(fire_color(2. * fire_intensity / float(fire_n)), 1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 210, 230, 230, 268], [270, 270, 316, 316, 493], [495, 495, 516, 516, 1211], [1213, 1213, 1241, 1241, 1298], [1300, 1300, 1345, 1345, 1503], [1505, 1505, 1531, 1531, 1723], [1725, 1725, 1752, 1752, 1787], [1789, 1789, 1844, 1844, 2401]]}
{"id": "3ssSR7", "name": "Spike distance", "author": "dracusa", "description": "The pointiest spike in the world.", "tags": ["sdf", "spiked", "peak", "pointy"], "likes": 1, "viewed": 375, "published": "Public API", "date": "1550882106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nDistance for the implicit surface y = h/(abs(x)+h); with h >= 0\nI think the distance on the exterior side is exact. (not the interior!)\nCan easily be turned into a 3D surface by extruding or lathing.\n\n*/\n\nfloat sdSpike2D(vec2 p, float h)\n{\n\tfloat d = p.y - (h*0.1)/(abs(p.x)+0.1);\n\td = min(d, length(p - vec2(0., min(h, p.y))));\n\tfloat d2 = abs(p.x) - ((h*0.1)-0.1*p.y)/p.y;\n\tif (p.y<h && d>0.0)\n\t\td = min(d, d2);\n\treturn d;\n}\n\n// visualization: smooth fract (from a comment by Shane)\nfloat sFract(float x, float s) {\n\tfloat is = 1./s-0.99;\n\tx = fract(x);\n\treturn min(x, x*(1.-x)*is)+s*0.5;\n}\n\n// visualization: color gradient\nvec3 distanceGradient(float d, float aa) {\n\tvec3 ret = vec3(sFract(abs(d*6.0), aa));\n\tret.x = 1.0 - smoothstep(-0.5*aa, 0.5*aa, d);\n\tret *= exp(-1.0 * abs(d));\n\treturn ret;\n}\n\nfloat height;\n\nvec3 image(vec2 uv, vec2 res)\n{\n\tvec2 p = uv*2.-1.;\n    p.x *= res.x/res.y;\n    p.y += 0.7;\n    float d = sdSpike2D(p, height);\n    float d2 = sdSpike2D(p+1.0/res, height);\n\tfloat aa = abs(d-d2)*25.0;\n    return distanceGradient(d, aa);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    height = sin(iTime)*0.5+0.5;\n    fragColor = vec4(image(uv, iResolution.xy),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 209, 243, 243, 430], [432, 489, 521, 521, 596], [598, 631, 673, 673, 805], [822, 822, 853, 853, 1060], [1062, 1062, 1117, 1117, 1245]]}
{"id": "3ssXR8", "name": "El Jardí de Catalunya", "author": "wizgrav", "description": "Port of a rayglider script minus the audio reactive bits. Original here https://tinyurl.com/ybgfwulm", "tags": ["raymarching", "fractal", "fbm", "mandelbulb"], "likes": 12, "viewed": 575, "published": "Public API", "date": "1550594860", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n #define PI 3.14159265359\n #define PI2 6.28318530718\n #define PHI 1.618033988749895\n \n #define saturate(x) clamp(x, 0., 1.)\n \n \n \n // exported https//tinyurl.com/y82cdk8k\n vec2  raygl_sdf_map_1( in vec3 p) ;\n \n \n // exported https//tinyurl.com/y82cdk8k\n const int  raygl_sdf_ray_steps_1 =  128 ;\n \n \n // exported https//tinyurl.com/y82cdk8k\n const float  raygl_sdf_max_dist_1 =  48. ;\n \n \n // exported sdf\n const float  raygl_sdf_min_dist_6 =  1. ;\n \n \n // exported sdf\n const int  raygl_sdf_shadow_steps_6 =  16 ;\n \n \n // exported color\n const bool  raygl_color_lut_clamp_7 =  true ;\n \n \n // exported color\n const bool  raygl_color_lut_flip_7 =  false ;\n \n \n // body color\n vec3 raygl_rgb2hsv_7(vec3 c){\n     vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n     float d = q.x - min(q.w, q.y);\n     float e = 1.0e-10;\n     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n }\n vec3 raygl_hsv2rgb_7(vec3 c)\n {\n     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n }\n\n \n // body sdf\n vec2 raygl_sdf_map_6(in vec3 p) {\n     return vec2(length(p)-3., 0.);\n }\n vec2 raygl_cast_6( in vec3 ro, in vec3 rd )\n {\n     float t = raygl_sdf_min_dist_6;\n     float m = -1.0;\n     for( int i=0; i < raygl_sdf_ray_steps_1; i++ )\n     {\n \t    float precis = 0.0005*t;\n \t    vec2 res = raygl_sdf_map_1( ro+rd*t );\n         if( res.x < precis || t > raygl_sdf_max_dist_1 ) break;\n         t += res.x;\n \t    m = res.y;\n     }\n     if( t > raygl_sdf_max_dist_1 ) m=-1.0;\n     return vec2( t, m );\n }\n vec3 raygl_norms_6( in vec3 pos )\n {\n     vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n     return normalize( e.xyy*raygl_sdf_map_1( pos + e.xyy ).x + \n \t\t\t\t\t  e.yyx*raygl_sdf_map_1( pos + e.yyx ).x + \n \t\t\t\t\t  e.yxy*raygl_sdf_map_1( pos + e.yxy ).x + \n \t\t\t\t\t  e.xxx*raygl_sdf_map_1( pos + e.xxx ).x );\n }\n vec3 raygl_normals_6( in vec3 pos )\n {\n     vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n \tvec3 nor = vec3(\n \t    raygl_sdf_map_1(pos+eps.xyy).x - raygl_sdf_map_1(pos-eps.xyy).x,\n \t    raygl_sdf_map_1(pos+eps.yxy).x - raygl_sdf_map_1(pos-eps.yxy).x,\n \t    raygl_sdf_map_1(pos+eps.yyx).x - raygl_sdf_map_1(pos-eps.yyx).x );\n \treturn normalize(nor);\n }\n float raygl_shadow_6( in vec3 point, in vec3 rd, in float mint, in float tmax )\n {\n     vec3 ro = point;\n \tfloat res = 1.0;\n     float t = mint;\n     for( int i=0; i < raygl_sdf_shadow_steps_6; i++ )\n     {\n \t\tfloat h = raygl_sdf_map_1( ro + rd*t ).x;\n         res = min( res, 8.0*h/t );\n         t += clamp( h, 0.02, 0.10 );\n         if( h<0.001 || t>tmax ) break;\n     }\n     return clamp( res, 0.0, 1.0 );\n }\n float raygl_occlusion_6( vec3 pos, vec3 nor )\n {\n     float oc = 0.0;\n     float sca = 1.0;\n     for( int i=0; i<5; i++ )\n     {\n         float hr = 0.01 + 0.12*float(i)/4.0;\n         vec3 aopos =  nor * hr + pos;\n         float dd = raygl_sdf_map_1( aopos ).x;\n         oc += -(dd-hr)*sca;\n         sca *= 0.95;\n     }\n     return clamp( 1.0 - 3.0*oc, 0.0, 1.0 );    \n }\n \n // body noise/worley2D\n   // worley noise from glslify\n vec3 raygl_permute_5(vec3 x) {\n     return mod((34.0 * x + 1.0) * x, 289.0);\n   }\n\n vec3 raygl_dist_5(vec3 x, vec3 y,  bool manhattandistance) {\n\n     return manhattandistance ?  abs(x) + abs(y)  : (x * x + y * y);\n \n }\n   vec2 raygl_noise_5(vec2 P, float jitter, bool manhattandistance) {\n   float K= 0.142857142857; // 1/7\n   float Ko= 0.428571428571 ;// 3/7\n   \tvec2 Pi = mod(floor(P), 289.0);\n    \tvec2 Pf = fract(P);\n   \tvec3 oi = vec3(-1.0, 0.0, 1.0);\n   \tvec3 of = vec3(-0.5, 0.5, 1.5);\n   \tvec3 px = raygl_permute_5(Pi.x + oi);\n   \tvec3 p = raygl_permute_5(px.x + Pi.y + oi); // p11, p12, p13\n   \tvec3 ox = fract(p*K) - Ko;\n   \tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n   \tvec3 dx = Pf.x + 0.5 + jitter*ox;\n   \tvec3 dy = Pf.y - of + jitter*oy;\n   \tvec3 d1 = raygl_dist_5(dx,dy, manhattandistance); // d11, d12 and d13, squared\n   \tp = raygl_permute_5(px.y + Pi.y + oi); // p21, p22, p23\n   \tox = fract(p*K) - Ko;\n   \toy = mod(floor(p*K),7.0)*K - Ko;\n   \tdx = Pf.x - 0.5 + jitter*ox;\n   \tdy = Pf.y - of + jitter*oy;\n   \tvec3 d2 = raygl_dist_5(dx,dy, manhattandistance); // d21, d22 and d23, squared\n   \tp = raygl_permute_5(px.z + Pi.y + oi); // p31, p32, p33\n   \tox = fract(p*K) - Ko;\n   \toy = mod(floor(p*K),7.0)*K - Ko;\n   \tdx = Pf.x - 1.5 + jitter*ox;\n   \tdy = Pf.y - of + jitter*oy;\n   \tvec3 d3 = raygl_dist_5(dx,dy, manhattandistance); // d31, d32 and d33, squared\n   \t// Sort out the two smallest distances (F1, F2)\n   \tvec3 d1a = min(d1, d2);\n   \td2 = max(d1, d2); // Swap to keep candidates for F2\n   \td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n   \td1 = min(d1a, d2); // F1 is now in d1\n   \td2 = max(d1a, d2); // Swap to keep candidates for F2\n   \td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n   \td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n   \td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n   \td1.y = min(d1.y, d1.z); // nor in  d1.z\n   \td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n   \treturn sqrt(d1.xy);\n   }\n \n // body phong\n struct raygl_Surface_4 {\n     vec3 normal;\n     vec3 diffuse;\n     vec3 specular;\n     float shiny;\n };\n vec3 raygl_direct_4( in raygl_Surface_4 s, in vec3 color, in vec3 dir ) \n {\n     vec3 halfDir = normalize( dir );\n     float dotNL = saturate( dot( s.normal, dir ) );\n \tfloat dotNH = saturate( dot( s.normal, halfDir ) );\n \tfloat dotLH = saturate( dot( dir, halfDir ) );\n     float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n \tvec3 F = ( 1.0 - s.specular ) * fresnel + s.specular;\n \t\n     vec3 L = (1. / PI) * s.diffuse * dotNL;\n \treturn color * (L + F * ( 0.25 * (1. / PI) * ( s.shiny * 0.5 + 1.0 ) * pow( dotNH, s.shiny ) ));\n }\n \n // body debug\n vec4 raygl_bars_3(vec4 m, vec2 uv) {\n     vec4 color = vec4(0.);\n     float inc = 1. / 4.;\n     for(float j=0.;j<4.;j++) {\n         float v = m.x;\n         m.xyzw = m.yzwx;\n         color.xyzw = color.yzwx;\n         if(uv.x < j * inc || uv.x >= (j + 1.) * inc) { \n             continue;\n         }\n         if(uv.y > v){ \n             color.w = 0.2;\n             continue;\n         }\n         color.w = 1.0;\n     }\n     if(color.a == 0.2) color.rgb = vec3(0.2);\n     else if(color.a == 1.0) color.rgb = vec3(1.);\n     color.a = 1.0;\n     return color;\n }\n \n // body camera\n mat3 raygl_lookAt_2( in vec3 ro, in vec3 ta, float cr )\n {\n \tvec3 cw = normalize(ta - ro);\n \tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n \tvec3 cu = normalize( cross(cw,cp) );\n \tvec3 cv = normalize( cross(cu,cw) );\n     return mat3( cu, cv, cw );\n }\n \n // body https//tinyurl.com/y82cdk8k\n // El Jardí de Catalunya\n // by wizgrav, just normals\n vec3 raygl_CMOD_1;\n vec2 raygl_BMOD_1 = vec2(0.5);\n vec4 raygl_rand_1(vec2 n) {\n   return fract( vec4(1.0, 255.0, 65025.0, 16581375.0) * fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453));\n }\n float raygl_smin_1( float a, float b, float k )\n {\n     float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n     return mix( b, a, h ) - k*h*(1.0-h);\n }\n vec2 raygl_sdf_map_1(in vec3 p) {\n   p.xyz = p.xzy;\n   vec3 c = raygl_CMOD_1;\n   vec3 q = mod(p,c)-0.5 * c;\n   vec3 z = q;\n   vec3 dz=vec3(0.0);\n   vec3 fl = floor((p-q) / raygl_CMOD_1) * raygl_CMOD_1;\n   vec4 r4 = raygl_rand_1( fl.xy );\n   float power = 8.0 + 2. * floor(4. * r4.x);\n   float r, theta, phi;\n   float dr = 1.0;\n   float t0 = 1.0;\n   for(int i = 0; i < 4; ++i) {\n     r = length(z);\n     if(r > 2.0) continue;\n     theta = atan(z.y / z.x) ;\n     phi = asin(z.z / r)  + iTime * 0.3  + 0.9 * mix(raygl_BMOD_1.x,1. - raygl_BMOD_1.y, 0.66 + r4.x * 0.33);\n     \n     dr = pow(r, power - 1.) * dr * power + 1. ;\n     r = pow(r, power);\n     theta = theta * power;\n     phi = phi * power;\n     z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + q;\n     power +=  2. * floor(4. * r4.y) + r4.x * 0.5;\n     t0 = min(t0, r);\n     r4.xyzw = r4.yzwx;\n    }\n   float rz = 0.5 * log(r) * r / dr;\n   rz = raygl_smin_1(q.z , rz, 0.24);\n   return vec2(rz, mix( 0.1, t0, abs(q.z) * 0.96 ));\n }\n float raygl_shape_1(in vec2 fragCoord, out vec3 pt, out vec3 nor) {\n   raygl_CMOD_1 = vec3(2.9 ,2.9,0. );\n   vec3 ro = vec3(4. + iTime * 0.33, 1.7 , 2.9);\n   mat3 cam = raygl_lookAt_2(ro, ro + vec3(4.,-6. ,0.), 0.);\n   vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n   vec3 rd = cam * normalize( vec3(p.xy,1.0) );\n   vec2 res = raygl_cast_6(ro, rd);\n   pt = ro + res.x * rd;\n   nor = raygl_normals_6(pt);\n   return res.y;\n }\n void raygl_main_1(inout vec4 fragColor, vec2 fragCoord) {\n   vec3 pt;\n   vec3 nor;\n   raygl_shape_1(fragCoord, pt, nor);  \n   fragColor.rgb = nor;\n }\n \n // body \n // El Jardí de Catalunya\n // by wizgrav\n \n   \n float raygl_fbm_(vec2 uv) {\n     float amp = 1., freq = 6., asum = 0., res = 0.;\n     for(int i=0; i < 3; i++) {\n         res += raygl_noise_5(uv * freq , 1., false).x * amp;\n         asum += amp;\n         freq *= 2.;\n         amp *= 0.5;\n     }\n     return res / asum;\n }\n void mainImage(out vec4 fragColor, vec2 fragCoord) {\n   vec4 bms = vec4(1.);\n   raygl_BMOD_1 = bms.xy;\n   \n    \n   vec3 pt;\n   vec3 nor;\n   float m = raygl_shape_1(fragCoord, pt, nor);\n   raygl_Surface_4 s;\n   float z = 0.;\n   float mz = raygl_sdf_map_1(vec3( pt.x, 1.0, pt.z)).x;\n   float q = raygl_fbm_(pt.xz * 0.1);\n   z =  raygl_fbm_(pt.xz * 0.2 + vec2(0.01, 0.02) * iTime + vec2(0.2 * bms.y,0.2 * bms.z)  + q);\n   vec3 p = vec3(pt.x, 0.03 * z, pt.z );\n   vec3 nor2 = normalize(cross(dFdx(p),dFdy(p)));\n   float f = smoothstep(0., 0.1, pt.y);\n   nor = mix(nor2, nor, f);\n   s.diffuse = vec3(raygl_hsv2rgb_7(vec3(pow(m, 2.) ,   1. - m,  0.66 -  z * (1. - f)  )));\n   s.specular = vec3(0.9);\n   s.shiny = 32. * m;\n   s.normal = nor;\n   vec3 nv = normalize(vec3(2., 6., 2.));\n   float att = max(0.33, length(pow(bms,vec4(1.33))));\n   vec3 l = raygl_direct_4(s, vec3(att), nv);\n   float ao = raygl_occlusion_6(pt, nor);\n   vec3 col = mix(vec3(0.000, 0.067, 0.067), vec3(0.200, 0.196, 0.200) , s.normal.y) * ao * att + l * raygl_shadow_6( pt, nv, 0.1, 4.0 ); \n   col = pow(col, vec3(1./2.2));\n   fragColor = vec4(col,1.0);\n\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 677, 706, 706, 1043], [1045, 1045, 1076, 1076, 1249], [1254, 1267, 1300, 1300, 1339], [1341, 1341, 1387, 1387, 1763], [1765, 1765, 1801, 1801, 2063], [2065, 2065, 2103, 2103, 2407], [2409, 2409, 2491, 2491, 2820], [2822, 2822, 2870, 2870, 3193], [3197, 3253, 3283, 3283, 3334], [3337, 3337, 3397, 3397, 3472], [3476, 3476, 3542, 3542, 5228], [5232, 5352, 5427, 5427, 5896], [5900, 5915, 5951, 5951, 6469], [6473, 6489, 6547, 6547, 6732], [6736, 6881, 6908, 6908, 7025], [7027, 7027, 7077, 7077, 7173], [7175, 7175, 7208, 7208, 8180], [8182, 8182, 8249, 8249, 8617], [8619, 8619, 8676, 8676, 8768], [8772, 8830, 8857, 8857, 9102], [9104, 9104, 9156, 9156, 10229]]}
{"id": "3ssXRH", "name": "2D global illumination", "author": "darkeclipz", "description": "Testing 2D global illumination with SDF's.\n\nIdea from https://www.shadertoy.com/view/lldcDf.", "tags": ["2d", "global", "illumination"], "likes": 11, "viewed": 823, "published": "Public", "date": "1550608576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 12.\n#define MinDistance 0.01\n#define Samples 60.\n\nmat2 r2(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}    \n\n// from iq\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 r = abs(p) - b;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n    //vec2 d = abs(p) - b;\n  \t//return length(max(d,0.0));\n}  \n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 lightColor = vec3(0);\nfloat light(vec2 p) {\n    lightColor = vec3(.6,.8,1.);\n    float box = sdBox(p - vec2(1.,0), vec2(.2));\n    float circle = sdCircle(p + vec2(1.,0), .2);\n    if(box > circle) lightColor = vec3(1,.9,.8);\n    return smin(box, circle, 1.);\n}  \n\nfloat centerBox(vec2 p) {\n    p *= r2(iTime);\n\tfloat box = sdBox(p, vec2(.3)); \n    box = max(box, -sdCircle(p - vec2(0,.5), .49) + cos(iTime) * .02);\n    box = max(box, -sdCircle(p - vec2(0,-.5), .49) + cos(iTime) * .02);\n    return box;\n}\n\nvec3 objectColor = vec3(1,0,0);\nint objectId = 0;\nfloat scene(vec2 p) {\n    objectId = 0;\t\n    float box = centerBox(p);\n    float light = light(p);\n    if(box > light) {\n    \tobjectId = 1;\n        objectColor = vec3(0,0,1);\n    }\n    return min(box, light);\n}    \n\n// from iq\nvec2 calcNormal(vec2 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec2 n = normalize( vec2(scene(vec2(p.x + h, p.y)) - scene(vec2(p.x - h, p.y)),\n                      scene(vec2(p.x, p.y + h)) - scene(vec2(p.x, p.y - h)))) ;    \n    return n;\n}\n\nfloat march(vec2 ro, vec2 rd) {\n\tfloat t = 0.;\n    for(float i=0.; i < MaxSteps; i++) {\n\t\tvec2 p = ro + t * rd;\n        float dt = scene(p);\n        if(dt < MinDistance) return t+0.00001;\n        t += dt;\n    }       \n    return 0.;\n}    \n\nfloat seed = 0.;\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*U-R)/R.y;\n    vec3 col = vec3(0);\n\n    for(float i=0.; i < Samples; i++) {\n        \n        float r = (i + random(uv + i + iTime)) / Samples * 2. * 3.1415;\n        vec2 rd = vec2(cos(r), sin(r));\n        vec3 sampleColor = vec3(0);\n        \n        float t = march(uv, rd);\n        if(t > 0.) {\n            vec2 p = uv + t * rd;\n            \n            // light\n            if(objectId == 1) {\n            \tsampleColor = lightColor;    \n            }\n            \n            // box\n            if(objectId == 0) {\n            \tvec2 nor = calcNormal(p);\n                vec2 rrd = reflect(rd, nor);\n                float rt = march(p, rrd);\n                \n                if(rt > .0) {\n                    if(objectId == 0) {\n                    \tsampleColor = mix(sampleColor, lightColor, 0.5);\n                    }\n                }\n            }\n        }\n        col += sampleColor;\n    }        \n    \n    \n    \n    // cant figure out how to fix the \n    // center object color, so its hardcoded here\n\tif(centerBox(uv) < MinDistance)\n        col = vec3(0.);\n    \t// TODO: - sample it from a scene without the object iself\n        //       - create a smooth map between the two lights, now it\n        //         abruptly jumps because the other light is closer.\n    \n    \n\n    // Output to screen\n    O = vec4(col/Samples*2.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 110, 110, 170], [172, 172, 196, 196, 239], [241, 241, 269, 269, 360], [362, 362, 395, 395, 423], [429, 440, 469, 469, 616], [620, 651, 692, 692, 785], [814, 814, 835, 835, 1051], [1055, 1055, 1080, 1080, 1295], [1347, 1347, 1368, 1368, 1557], [1563, 1574, 1599, 1599, 1830], [1832, 1832, 1863, 1863, 2066], [2089, 2089, 2130, 2180, 3538]]}
{"id": "3sXSRn", "name": "Tiny ray tracer", "author": "koiava", "description": "Tiny ray tracer for demonstration", "tags": ["raytracer", "teaching"], "likes": 2, "viewed": 193, "published": "Public API", "date": "1550481804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Sphere { vec3 o; float r; };\t\t\t\t\t\t\t\t\t\t\t\t//define struct for a Sphere object\nstruct Ray { vec3 o; vec3 d; };\t\t\t\t\t\t\t\t\t\t\t\t\t//define struct for a ray\n\nbool intersectSphere(in Sphere s, in Ray r, out float t){\t\t\t\t\t\t//function calculates ray-sphere intersection\n    r.o -= s.o;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//move both sphere and ray to the origin\n    float a = 1., b = 2.*dot(r.o,r.d), c = dot(r.o,r.o) - s.r*s.r;\t\t\t\t//a, b, c coefficients of quadric aquation\n    float d = b*b-4.*a*c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t//discriminant of quadric aquation\n    if(d<=0.) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//we hit background\n        return false;\n    } else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//we hit sphere\n        float root0 = (-b - sqrt(d)) / 2.*a, root1 = (-b + sqrt(d)) / 2.*a;\t\t//roots of quadric aquation\n\t\tt = min(root0, root1);\t\t\t\t\t\t\t\t\t\t\t\t\t//we need closest hit\n        return true;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\t\t\t\t//we get fragment coordinate and we should set its color\n    vec2 uv = fragCoord/iResolution.xy-vec2(.5);\t\t\t\t\t\t\t\t//screen coordinate from [-0.5, 0.5] range\n    uv.x *= iResolution.x/iResolution.y;\t\t\t\t\t\t\t\t\t\t//take screen aspect ratio into account\n    Ray r = Ray(vec3(uv, 5.0), vec3(0.0, 0.0, -1.));\t\t\t\t\t\t\t//Ray origin and direction\n    Sphere s = Sphere(vec3(.0), 0.3);\t\t\t\t\t\t\t\t\t\t\t//radius of the sphere. origin is at 0\n\tfloat t;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    if(!intersectSphere(s, r, t)) {\t\t\t\t\t\t\t\t\t\t\t\t//we hit background\n        fragColor = vec4(vec3(0.),1.);\n    } else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//we hit sphere\n        vec3 l = normalize(vec3(sin(iTime), 1.0, sin(iTime*1.2345)));\t\t\t//moving light direction\n        vec3 p = r.o+r.d*t, n = normalize(p-s.o);\t\t\t\t\t\t\t\t//intersection point and surface normal\n        vec3 lambert = vec3(.5, .5, .95) * (1.0/3.1415926);\t\t\t\t\t\t//lambertian reflection model and bit of ambient light\n        vec3 h = normalize(l + (-r.d));\t\t\t\t\t\t\t\t\t\t\t//half vector between light and view\n        float s = iMouse.x/64.0;\t\t\t\t\t\t\t\t\t\t\t\t//surface shininess parameter\n        vec3 blinn = vec3(pow(max(0.0, dot(n, h)), s));\t\t\t\t\t\t\t//Blinn-Phong specular reflection model\n        blinn *= (s + 2.0)/(8.0*3.14159265);\t\t\t\t\t\t\t\t\t//normalization factor\n        vec3 rad = (lambert + blinn) * max(0.0, dot(n, l)) * 2.0;\t\t\t\t\t\t//BRDF and cosine factor\n    \tfragColor = vec4(rad,1.);\t\t\t\t\t\t\t\t\t\t\t\t//store final color\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 154, 211, 262, 834], [836, 836, 893, 955, 2313]]}
{"id": "3sXXD4", "name": "noise over time", "author": "turnage", "description": "noise", "tags": ["noise"], "likes": 6, "viewed": 174, "published": "Public", "date": "1551239880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define RGB(r, g, b, a) vec4(vec3(float(r)/255., float(g)/255., float(b)/255.), a)\n#define NO_DISTANCE 10000.\n\n// NOISE IMPL FROM: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = 0.5*(1.-cos(PI*mod(p,unit)/unit));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res, float scale, float lacunarity){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = scale;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p + iTime, f);\n\t\tf*=lacunarity;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf*3.0;\n}\n\nfloat noiseTextureScalar(vec2 p, float distortion, float scale, int detail, float lower) {\n    float distortionTheta = pNoise(p, detail, scale, 2.) * 2. * PI;\n    vec2 distortionOffset = distortion*vec2(cos(distortionTheta), sin(distortionTheta));\n    return abs(pNoise(p + distortionOffset, detail, scale, 2.));\n}\n\nvec4 noiseTexture(vec2 p, float distortion, float scale, int detail, float lower) {\n    return vec4(\n        noiseTextureScalar(p+10000., distortion, scale, detail, lower),\n        noiseTextureScalar(p+20000., distortion, scale, detail, lower),\n        noiseTextureScalar(p, distortion, scale, detail, lower),\n        1.0\n    );\n}\n\n// 4th param should be point on ramp\n#define RAMP_STEPS 6\nvec3 colorRamp(float p, vec4 steps[RAMP_STEPS]) {\n    /*float sum = 0;\n    for (int i = 0; i < RAMP_STEPS; ++i) {\n        sum += 1.0 - abs(steps[i].w - p);\n    }\n    vec3 color = vec3(0.);\n    for (int i = 0; i < RAMP_STEPS; ++i) {\n        color += steps[i].xyz * (1.0 - abs(steps[i].w - p))/sum;\n    }*/\n    vec3 color = mix(steps[0].xyz, steps[1].xyz, smoothstep(steps[0].w, steps[1].w, p));\n    color = mix(color, steps[2].xyz, smoothstep(steps[1].w, steps[2].w, p));\n    color = mix(color, steps[3].xyz, smoothstep(steps[2].w, steps[3].w, p));\n    color = mix(color, steps[4].xyz, smoothstep(steps[3].w, steps[4].w, p));\n    return color;\n}\n\nvec4 christmasNoise(vec2 p) {\n    vec4 c1 = RGB(23, 39, 44, 1.0);\n    vec4 c2 = RGB(27, 85, 82, 1.0);\n    vec4 c3 = RGB(111, 177, 128, 1.0);\n    vec4 c4 = RGB(231, 204, 129, 1.0);\n    vec4 c5 = RGB(228, 98, 65, 1.0);\n\n    vec4 rampColors[RAMP_STEPS];\n    \n    rampColors[0] = RGB(140, 70, 12, 0.1);\n    rampColors[1] = RGB(100, 0, 0, 0.0);\n    rampColors[2] = RGB(198, 73, 69, 0.2);\n    rampColors[3] = RGB(231, 204, 129, 0.7);\n    rampColors[4] = RGB(180, 60, 65, 1.0);\n    rampColors[5] = RGB(0, 0, 0, 2.0);\n  \n\n    vec4 n1 = noiseTexture(p, 0., 0.1 + 0.0001*iTime, 16, 0.0);\n    \n    vec2 samplePoint = n1.xy*iResolution.xy;\n    \n    vec4 n2 = noiseTexture(samplePoint, 10., 8., 16, 0.0);\n    \n    vec4 n3 = noiseTexture(n2.xy*iResolution.xy, 3., 4., 16, 0.0);\n\n    //fragColor = mix(orangeLayer, blueLayer, abs(sin(iGlobalTime/100.)));\n    return vec4(colorRamp(n3.x, rampColors), 1.0);//mix(orangeLayer, blueLayer, abs(sin(iGlobalTime/100.)));//vec4(orangeLayer.x, blueLayer.z, greenLayer.y, 1.0);\n}\n\n\n\nstruct Candidate {\n\tvec4 color;\n\tfloat distance;\n};\n\nbool candidate_passes(Candidate candidate, vec4 color, vec4 us, float dir) {\n\tif (candidate.distance == NO_DISTANCE) {\n\t\treturn true;\n\t}\n\tfloat delta = candidate.distance - length(us - color);\n\treturn delta * dir > 0.;\n}\n\nvec4 layer1(vec2 pos) {\n    return christmasNoise(pos*iResolution.xy);\n}\n\nCandidate consider(vec2 pos, Candidate candidate, vec4 us, float dir) {\n\tvec4 color = layer1(pos);\n\tif (candidate_passes(candidate, color, us, dir)) {\n\t\tcandidate.color = color;\n\t\tcandidate.distance = length(color - us);\n\t}\n\treturn candidate;\n}\n\nvec4 closest_neighbor(vec2 pos, float distance, float dir) {\n\tvec2 unit = vec2(1.0 / iResolution.x, 1.0 / iResolution.y) * distance;\n\tvec4 us = layer1(pos);\n\n\tCandidate candidate;\n\tcandidate.color = us;\n\tcandidate.distance = NO_DISTANCE;\n\n\tcandidate = consider(pos - unit, candidate, us, dir);\n\tcandidate = consider(pos + unit, candidate, us, dir);\n\n\tcandidate = consider(pos + vec2(unit[0], 0), candidate, us, dir);\n\tcandidate = consider(pos + vec2(0, unit[1]), candidate, us, dir);\n\n\tcandidate = consider(pos - vec2(unit[0], 0), candidate, us, dir);\n\tcandidate = consider(pos - vec2(0, unit[1]), candidate, us, dir);\n\n\tcandidate = consider(pos + vec2(-unit[0], unit[1]), candidate, us, dir);\n\tcandidate = consider(pos + vec2(unit[0], -unit[1]), candidate, us, dir);\n\n\treturn candidate.color;\n}\n\nvec4 closest_neighbor_n(vec2 pos, float start, float step, int n, float dir) {\n\tvec4 us = layer1(pos);\n\tCandidate candidate;\n\tcandidate.color = us;\n\tcandidate.distance = NO_DISTANCE;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfloat distance = float(i + 1) * step + sign(step) * start;\n\t\tvec4 color = closest_neighbor(pos, distance, dir);\n\t\tif (candidate_passes(candidate, color, us, dir)) {\n\t\t\tcandidate.color = color;\n\t\t\tcandidate.distance = length(color - us);\n\t\t}\n\t}\n\n\treturn candidate.color;\n}\nvec4 layer3(vec2 uv) {\n    float start = 0.05;\n    float step = 0.0000005;\n    int steps = 5;\n    return closest_neighbor_n(uv, iResolution.x * start, iResolution.x * step, steps, -1.);\n}\n\nvec2 domainWarp(vec2 fragCoord) {\n    float scale = abs(pNoise(fragCoord, 4, 4., 2.))*1000.;\n    vec2 off = vec2(pNoise(fragCoord, 3, 4., 2.) * scale, pNoise(-1.0 * fragCoord, 3, 4., 2.)*scale);\n    return fragCoord + off;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = layer1(domainWarp(fragCoord/iResolution.xy));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 227, 246, 246, 314], [316, 316, 349, 349, 682], [684, 684, 745, 745, 1057], [1059, 1059, 1149, 1149, 1373], [1375, 1375, 1458, 1458, 1705], [1707, 1765, 1814, 2069, 2409], [2411, 2411, 2440, 2440, 3415], [3472, 3472, 3548, 3548, 3692], [3694, 3694, 3717, 3717, 3766], [3768, 3768, 3839, 3839, 4012], [4014, 4014, 4074, 4074, 4809], [4811, 4811, 4889, 4889, 5299], [5300, 5300, 5322, 5322, 5487], [5489, 5489, 5522, 5522, 5713], [5715, 5715, 5772, 5772, 5836]]}
{"id": "3sXXWr", "name": "simpleCircle ", "author": "patrickhartono", "description": "tryOut", "tags": ["try"], "likes": 1, "viewed": 52, "published": "Public", "date": "1550999798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv);\n    \n    float r = .8; //circle radius\n    \n    float c = smoothstep(r, r * 0.5 * sin(iTime), d);\n        \n\n    //if (d < .3) c = 1.; else c = 0.;\n    \n    fragColor = vec4(vec3(c), 1.0); \n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 441]]}
{"id": "3sXXz4", "name": "Tan Ball", "author": "zyzek", "description": "Just a bit of mucking around...", "tags": ["tangent"], "likes": 2, "viewed": 152, "published": "Public", "date": "1550671865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C fragCoord\n#define R iResolution\n#define T iTime\n#define PI 3.1415927\n\n#define discrete_mod(period) (mod((length(uv)-xmod), stroke_spacing*period)/(stroke_spacing*period))\n\nconst float scale = 1.0/10.0;\nconst float time_offset = 1200.0;\nconst float stroke_size = 0.15;\nconst float stroke_smooth = 0.2;\nconst float stroke_spacing = 0.06;\nconst float spin_speed = 3.0;\nconst float red_period = 3.0;\nconst float green_period = 3.03;\nconst float blue_period = 5.0; \n\nvec2 xform(vec2 p, float a) {\n    a = sqrt(a);\n    return mat2(tan(a), -tan(a), tan(a), tan(a)) * abs(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (C/R.xy - vec2(0.5, 0.5))*vec2(1.0, R.y/R.x)/scale;\n    float xmod = mod(length(uv), stroke_spacing) - stroke_spacing/2.0;\n    uv = xform(uv, (length(uv) - xmod)*(T + time_offset)*PI*spin_speed);\n    vec3 col_base = vec3(discrete_mod(red_period),\n                         discrete_mod(green_period),\n                         discrete_mod(blue_period));\n    float l = length(vec2(xmod, uv.y));\n    vec3 col = col_base*vec3(1.0 - smoothstep(stroke_size, stroke_size + stroke_smooth, l));\n    fragColor = vec4(pow(col, vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 501, 501, 579], [581, 581, 638, 638, 1191]]}
{"id": "4dlfzB", "name": "Doughnut Box", "author": "ssell", "description": "Was one of my first shadertoys and experiment with SDFs though I never published. \n\nMaking it public now because why not?", "tags": ["doughnut"], "likes": 18, "viewed": 346, "published": "Public API", "date": "1551225288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float NearClip         = 0.0;\nconst float FarClip          = 150.0;\nconst float Epsilon          = 0.0001;\nconst vec3  AmbientLight     = vec3(0.8);\nconst float SoftShadowFactor = 1024.0;\nconst float SoftShadowOffset = 0.3;\nconst uint  MultiSamples     = 4u;\n\nconst float PiUnderOne       = 0.31830988;\nconst float PiTwoUnderOne    = 0.15915494;\n\nconst vec3 PinkColor         = vec3(1.0, 0.40, 0.65);\nconst vec3 ChocolateColor    = vec3(0.415, 0.207, 0.085);\n\nconst vec3 SprinkleColors[3] = vec3[](\n    vec3(0.0, 1.0, 1.0),\n    vec3(0.7, 1.0, 0.0),\n    vec3(0.5, 0.0, 0.9));\n\nuint PRNGSeed = 1337u;\n\nvec3 BoxOrigin = vec3(0.0);\nconst float TimeLimit = 8.0;\n\n//------------------------------------------------------------------------------------------\n// Misc Math Functions\n//------------------------------------------------------------------------------------------\n\n/**\n * if(a > b) { return ra; } else { return rb; }\n */\nvec3 StepValue(float a, float b, vec3 ra, vec3 rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\nfloat StepValue(float a, float b, float ra, float rb)\n{\n    float s = step(a, b);\n    return (ra * abs(s - 1.0)) + (rb * s);\n}\n\n//------------------------------------------------------------------------------------------\n// Noise\n//------------------------------------------------------------------------------------------\n\n/**\n * Naive PRNG seeding function.\n */\nvoid Seed(vec2 coord)\n{\n    coord = abs(coord);\n    \n    float x = floor(coord.x * 1000.0);\n    float y = floor(coord.y * 1000.0);\n    \n    //PRNGSeed = uint(floor(length(coord) * 100.0));\n    PRNGSeed = uint((x * 63.0) + (y * 84.0));\n}\n\n/**\n * XorShift32 PRNG\n * Adapted from: https://github.com/ssell/noisegen/blob/master/scripts/noise.js\n *\n * \\return PRNG value on range [-1.0, 1.0]\n */\nfloat NoiseXorShift32()\n{\n    uint x = PRNGSeed;\n    \n    x = x ^ (x << 13u);\n    x = x ^ (x >> 17u);\n    x = x ^ (x << 5u);\n    \n    PRNGSeed = x;\n    \n    return (float(x % 200u) - 100.0) * 0.01;\n}\n\n//------------------------------------------------------------------------------------------\n// Ray Structures and Functions\n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct RayHit\n{\n    bool  hit;\n  \tvec3  surfPos;\n    vec3  surfNorm;\n    float material;\n};\n\n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n//------------------------------------------------------------------------------------------\n// Model Torus\n//------------------------------------------------------------------------------------------\n\nstruct ModelTorus\n{\n    vec3  origin;\n    float radius;\n    float thickness;\n};\n    \nfloat Torus_SDF(vec3 point, ModelTorus t)\n{\n    vec2 q = vec2(length(point.xz - t.origin.xz) - t.radius, point.y - t.origin.y);\n    return length(q) - t.thickness;\n}\n\n\n//------------------------------------------------------------------------------------------\n// Model Ellipsoid\n//------------------------------------------------------------------------------------------\n\nstruct ModelEllipsoid\n{\n    vec3 origin;\n    vec3 radius;\n};\n    \nfloat Ellipsoid_SDF(vec3 point, ModelEllipsoid e)\n{\n    return (length((point - e.origin) / e.radius) - 1.0) * min(min(e.radius.x, e.radius.y), e.radius.z);\n}\n\n//------------------------------------------------------------------------------------------\n// Model Box\n//------------------------------------------------------------------------------------------\n\nstruct ModelBox\n{\n    vec3 origin;\n    vec3 bounds;\n};\n    \nfloat Box_SDF(vec3 point, ModelBox box)\n{\n\treturn length(max(abs(point - box.origin) - box.bounds, 0.0));   \n}\n\n//------------------------------------------------------------------------------------------\n// Sprinkles\n//------------------------------------------------------------------------------------------\n\nfloat Sprinkle_SDF(vec3 point, float i, float a, float y, ModelTorus doughnut, ModelEllipsoid sprinkle)\n{\n    float sR = doughnut.radius + (doughnut.thickness * 0.5 * i);\n    vec3  sOrigin = doughnut.origin + vec3(sR * sin(a), y, sR * cos(a));\n    \n    sprinkle.origin = sOrigin;\n    \n    NoiseXorShift32();\n    \n    return Ellipsoid_SDF(point, sprinkle);\n}\n\nfloat Sprinkles_SDF(vec3 point, float s, ModelTorus doughnut, inout float material)\n{\n    float final = s;\n    float sdf = s;\n    \n    Seed(vec2(1337.0, 797.0));\n    \n    ModelEllipsoid sprinkle;\n    sprinkle.radius = vec3(0.35, 0.075, 0.075);\n    \n    for(float angle = 0.0; angle < 6.20; angle += 0.5)\n    {\n        sdf = Sprinkle_SDF(point,  0.0, angle, 1.85, doughnut, sprinkle);\n        material = StepValue(sdf, final, material, (8.0 + float(PRNGSeed % 3u)));\n        final = min(final, sdf);\n        \n        sdf = Sprinkle_SDF(point,  1.0, angle, 1.55, doughnut, sprinkle);\n        material = StepValue(sdf, final, material, (8.0 + float(PRNGSeed % 3u)));\n        final = min(final, sdf);\n        \n        sdf = Sprinkle_SDF(point, -1.0, angle, 1.55, doughnut, sprinkle);\n        material = StepValue(sdf, final, material, (8.0 + float(PRNGSeed % 3u)));\n        final = min(final, sdf);\n    }\n    \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Scene Structures and Functions\n//------------------------------------------------------------------------------------------\n\nfloat Doughnuts_SDF(vec3 point, inout RayHit hit, float shadow)\n{\n    float final = FarClip;\n    float sdf   = FarClip;\n    float time  = mod(iTime, TimeLimit);\n    \n    time *= step(time, TimeLimit - 2.0);\n    \n    ModelTorus doughnutA;\n    doughnutA.origin    = vec3(0.0);\n    doughnutA.radius    = 4.0;\n    doughnutA.thickness = 1.75;\n    \n    ModelEllipsoid doughnutB;\n    doughnutB.radius = vec3(5.75, 3.5, 5.75);\n    \n    doughnutA.origin = vec3(-12.0, 1.75, 0.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 1.5));\n    hit.material = StepValue(sdf, final, hit.material, 0.0);\n    final = min(final, sdf);\n    \n    doughnutA.origin = vec3(-12.0, 1.75, 12.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 2.0));\n    hit.material = StepValue(sdf, final, hit.material, 1.0);\n    final = min(final, sdf);\n    \n    doughnutB.origin = vec3(0.0, 1.75, 0.0);\n    sdf = Ellipsoid_SDF(point, doughnutB) + (FarClip * step(time, 2.5));\n    hit.material = StepValue(sdf, final, hit.material, 2.0);\n    final = min(final, sdf);\n    \n    doughnutB.origin = vec3(0.0, 1.0, 12.0);\n    sdf = Ellipsoid_SDF(point, doughnutB) + (FarClip * step(time, 3.0));\n    hit.material = StepValue(sdf, final, hit.material, 3.0);\n    final = min(final, sdf);\n    \n    doughnutA.origin = vec3(12.0, 1.75, 0.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 3.5));\n    hit.material = StepValue(sdf, final, hit.material, 5.0);\n    final = min(final, sdf);\n    \n    doughnutA.origin = vec3(12.0, 1.75, 12.0);\n    sdf = Torus_SDF(point, doughnutA) + (FarClip * step(time, 4.0));\n    hit.material = StepValue(sdf, final, hit.material, 4.0);\n    final = min(final, sdf);\n    \n    if(sdf > Epsilon && sdf < 0.5 && shadow < Epsilon)\n    {\n    \tfinal = min(final, Sprinkles_SDF(point, final, doughnutA, hit.material));\n    }\n    \n    return final;\n}\n\nconst vec3 BoxOrigins[10] = vec3[](\n    vec3(   0.0, -89.9,    6.0),  vec3(  0.0, -0.1,  6.0),   // Bottom\n    vec3(-108.0,   2.4,    6.0),  vec3(-18.0,  2.4,  6.0),   // Left\n    vec3( 108.0,   2.4,    6.0),  vec3( 18.0,  2.4,  6.0),   // Right\n    vec3(   0.0,   2.4, -107.95), vec3(  0.0,  2.4, -7.95),  // Back\n     vec3(  0.0,   2.4,  109.95), vec3(  0.0,  2.4, 19.95)   // Front\n    );\n\nconst vec3 BoxBounds[5] = vec3[](\n    vec3(17.95, 0.1, 13.95),\n    vec3(0.05, 2.6, 14.0),\n    vec3(0.05, 2.6, 14.0),\n    vec3(18.0, 2.6, 0.05),\n    vec3(18.0, 2.6, 0.05)\n    );\n\nfloat DoughnutBoxBottom_SDF(vec3 point, inout RayHit hit)\n{\n    float sdf  = FarClip;\n    float lerp = clamp((mod(iTime, TimeLimit) * 0.85f), 0.0, 1.0);\n    \n    // Box Base\n    \n    ModelBox box;\n    \n    box.origin = mix(BoxOrigins[0], BoxOrigins[1], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[0];\n    \n    sdf = Box_SDF(point, box);\n    \n    if(sdf < Epsilon)\n    {\n    \thit.material = 7.0;\n        return sdf;\n    }\n    \n    // Box Left Side\n    \n    box.origin = mix(BoxOrigins[2], BoxOrigins[3], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[1];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Right Side\n    \n    box.origin = mix(BoxOrigins[4], BoxOrigins[5], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[2];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Back Side\n    \n    box.origin = mix(BoxOrigins[6], BoxOrigins[7], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[3];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Front Side\n    \n    box.origin = mix(BoxOrigins[8], BoxOrigins[9], lerp) + BoxOrigin;\n    box.bounds = BoxBounds[4];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    hit.material = StepValue(sdf, Epsilon, hit.material, 6.0);\n    \n    return sdf;\n}\n\nfloat DoughnutBoxTop_SDF(vec3 point, inout RayHit hit)\n{\n    float sdf = FarClip;\n    vec3 offset = BoxOrigin + mix(vec3(0.0, 90.0, 0.0), vec3(0.0, 1.0, 0.0), clamp((mod(iTime, TimeLimit) - 4.0) * 0.65, 0.0, 1.0));\n    \n    // Box Top\n    \n    ModelBox box;\n    \n    box.origin = BoxOrigins[1] + vec3(0.0, 5.0, 0.0) + offset;\n    box.bounds = BoxBounds[0];\n    \n    sdf = Box_SDF(point, box);\n    \n    // Box Left Side\n    \n    box.origin = BoxOrigins[3] + offset;\n    box.bounds = BoxBounds[1];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Right Side\n    \n    box.origin = BoxOrigins[5] + offset;\n    box.bounds = BoxBounds[2];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Back Side\n    \n    box.origin = BoxOrigins[7] + offset;\n    box.bounds = BoxBounds[3];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    // Box Front Side\n    \n    box.origin = BoxOrigins[9] + offset;\n    box.bounds = BoxBounds[4];\n    \n    sdf = min(sdf, Box_SDF(point, box));\n    \n    hit.material = StepValue(sdf, Epsilon, hit.material, 6.0);\n    \n    return sdf;\n}\n\n/**\n * Performs SDF test for the entire scene.\n * The scene is defined within this function and follows the pattern of:\n *\n *     - Test SDF of Object 0\n *         - If SDF 0 < Nearest Hit\n *         - Set RayHit nearest and position\n *         - Calculate RayHit normal for Object 0\n *     - Test SDF of Object 1\n *         - If SDF 1 < Nearest Hit\n *         - Set RayHit nearest and position\n *         - Calculate RayHit normal for Object 1\n *     - Continue for rest of Scene Objects\n */\nfloat Scene_SDF(vec3 point, inout RayHit hit, float shadow)\n{\n    float sdf = FarClip;\n    \n    float doughnutsSDF = Doughnuts_SDF(point, hit, shadow);\n    float boxBottomSDF = DoughnutBoxBottom_SDF(point, hit);\n    float boxTopSDF    = DoughnutBoxTop_SDF(point, hit);\n    \n    sdf = min(sdf, min(doughnutsSDF, min(boxBottomSDF, boxTopSDF)));\n    \n    return sdf;\n}\n\n/**\n * Calculates the normal of a given surface point.\n *\n * In essence it tests multiple points around the surface and uses those SDF\n * values to generate a normal vector.\n *\n * For example, if SDF(vec3(x + e, y, z)) is smaller than SDF(vec3(x - e, y, z))\n * then we know vec3(x + e, y, z) lies further within the surface and thus opposite\n * of the normal's x-component.\n */\nvec3 Scene_Normal(vec3 point)\n{\n    RayHit hit;\n\n\treturn normalize(vec3(\n        (Scene_SDF(vec3(point.x + Epsilon, point.y, point.z), hit, 0.0) - Scene_SDF(vec3(point.x - Epsilon, point.y, point.z), hit, 0.0)),\n        (Scene_SDF(vec3(point.x, point.y + Epsilon, point.z), hit, 0.0) - Scene_SDF(vec3(point.x, point.y - Epsilon, point.z), hit, 0.0)),\n        (Scene_SDF(vec3(point.x, point.y, point.z + Epsilon), hit, 0.0) - Scene_SDF(vec3(point.x, point.y, point.z - Epsilon), hit, 0.0))));\n}\n\n//------------------------------------------------------------------------------------------\n// Light Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct LightDirectional\n{\n    vec3 color;\n\tvec3 direction;  \n};\n    \nstruct LightPoint\n{\n  \tvec3 color;\n    vec3 position;\n    vec3 attenuation;\n};\n\n/**\n * Calculates the shadow factor on range [0.0, 1.0] for the given surface and light point.\n *\n * To determine if our light source is being occluded by scene geometry, we simply march\n * through the scene as we would for calculating the geometry SDF values.\n *\n * The only difference is that instead of using a ray originating from our camera, we\n * instead use a ray being projected from the light source.\n *\n * If our Scene_SDF returns a hit, then we know the light projecting from the point\n * onto the surface is occluded and in shadow.\n *\n * \\param[in] surfPos     Surface position to calculate the shadow factor for.\n * \\param[in] lightOrigin Origin of the light source.\n *\n * \\return Shadow factor value on range [0.0, 1.0]\n */\nfloat CalculateShadow(vec3 surfPos, vec3 lightOrigin)\n{\n    RayHit hit;\n    \n    float result   = 1.0;\n    vec3  lightRay = normalize(surfPos - lightOrigin);\n    \n    for(float depth = NearClip; depth < FarClip - Epsilon; )\n    {\n    \tvec3  point = (lightOrigin + (lightRay * depth));\n        float sdf   = Scene_SDF(point, hit, 1.0);\n        \n        if(sdf < Epsilon)\n        {\n            return 0.0;\n        }\n        \n        // http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n        result = min(result, (SoftShadowFactor * sdf) / depth);\n        \n        depth += sdf;\n    }\n    \n    return result;\n}\n\nvec3 CalculatePhongBRDF(\n    vec3  surfNorm, \n    vec3  toLight, \n    vec3  toView, \n    vec3  diffColor,\n    vec3  specColor,\n    float roughness)\n{\n    vec3  diffuse   = diffColor * PiUnderOne;\n    float halfAngle = dot(normalize(-toLight + toView), surfNorm);\n    float schlick   = (halfAngle / (roughness - (roughness * halfAngle) + halfAngle));\n    vec3  specular  = ((roughness + 2.0) * PiTwoUnderOne) * specColor * schlick;\n\n    return (diffuse + specular);\n}\n\nvec3 CalculateDynamicLight(\n    vec3  surfPos,\n    vec3  surfNorm,\n    vec3  toView,\n    vec3  lightDir,\n    vec3  lightColor,\n    vec3  diffColor,\n    vec3  specColor,\n    float roughness)\n{\n    vec3  origin   = surfPos + (lightDir * (FarClip + SoftShadowOffset));\n    float shadow   = CalculateShadow(surfPos, origin);\n    vec3  brdf     = CalculatePhongBRDF(surfNorm, -lightDir, toView, diffColor, specColor, roughness);\n    float cosAngle = clamp(dot(surfNorm, lightDir), 0.0, 1.0);\n    \n    return (lightColor * brdf * shadow * cosAngle);\n}\n\n/**\n * Calculates total lighting (including shadows) for the given surface.\n */\nvec3 CalculateLighting(\n    vec3 surfPos, \n    vec3 surfNorm, \n    vec3 toView,\n    vec3 diffColor,\n    vec3 specColor, \n    float roughness)\n{\n    vec3 dynamicLighting = vec3(0.0, 0.0, 0.0);\n    \n    LightDirectional light;\n    \n    light.color     = vec3(0.85, 0.85, 0.8);\n    light.direction = normalize(vec3(1.0, 1.0, -0.8));\n    \n    dynamicLighting += CalculateDynamicLight(surfPos, surfNorm, toView, light.direction, light.color, diffColor, specColor, roughness);\n\n    return (AmbientLight + dynamicLighting * 1.25);\n}\n\n//------------------------------------------------------------------------------------------\n// Material Structures and Functions\n//------------------------------------------------------------------------------------------\n\n/**\n * Applies the base doughnut material.\n * The base material consists of:\n *\n *     * Base color\n *     * Middle lighter ring due to frying\n *     * Noise for texture\n */\nvec3 Material_DoughnutBase(vec3 surfNorm)\n{\n    // Base doughnut color\n    vec3 color = vec3(0.9637, 0.6853, 0.2904);\n    \n    // Color of the lighter ring due to frying on each side\n    vec3 centerColor = color + vec3(0.03, 0.10, 0.10);\n    \n    // Calculate the relative surface y-angle. We clamp to [-0.25, 0.25] where the value is cos(angle)\n    float angle = max(min(dot(surfNorm, vec3(0.0, 1.0, 0.0)), 0.25), -0.25);\n    \n    // Interpolate to the center ring color\n    color  = mix(centerColor, color, abs(angle * 4.0));\n   // color += vec3(0.025, 0.025, 0.025) * NoiseXorShift32();\n    \n    return color;\n}\n\nvec3 Material_Powdered(vec3 surfPos, vec3 base)\n{\n    Seed(surfPos.xz);\n    \n    float powderChance = step(0.0, NoiseXorShift32() + 0.85);\n    vec3  powderColor  = vec3(1.0 - (NoiseXorShift32() + 1.0) * 0.01) * powderChance;\n    \n    return max(base, powderColor);\n}\n\nvec3 Material_Jelly(vec3 surfPos, vec3 surfNorm, vec3 base)\n{\n    Seed(surfPos.xz); \n    \n    float angle = dot(vec2(0.0, surfNorm.y), vec2(0.0, 1.0)) * 1.75 - 0.75;\n    \n    float powderChance = step(0.0, NoiseXorShift32() + angle);\n    vec3  powderColor  = vec3(1.0 - (NoiseXorShift32() + 1.0) * 0.01) * powderChance;\n    \n    return max(base, powderColor);\n}\n\nvec3 Material_Frosted(vec3 surfNorm, vec3 base, vec3 color, float crests, inout float r)\n{\n    /** \n     * Here we calculate the surfNorm.y angle that the frosting begins at.\n     *\n     * We have a baseline angle of 0.3 (remember this is angle=acos(dot(surfNorm, vec3(0,1,0))).\n     * Then we modulate up and down (via cos) 8 times around the doughnut and \n     * the angle varies between 0.2 and 0.4.\n     *\n     *     (a) Convert surfNorm.xz to an angle where ( 1.0,  0.0) -> 0, 2pi       (think graph with axis X/Z)\n     *                                               ( 0.0,  1.0) -> pi/2\n     *                                               (-1.0,  0.0) -> pi\n     *                                               ( 0.0, -1.0) -> 3pi/2\n     *     (b) Modulate 8 times over the full circle\n     *     (c) Vary angle (surfNorm.y) by +/- 0.1\n     *\n     *     angle = 0.30 - cos((a) * (b)) * (c)\n     */\n    \n    float angle = 0.30 - cos(acos(dot(normalize(surfNorm.xz), vec2(1.0, 0.0))) * crests) * 0.1;\n    float iced  = step(angle, dot(surfNorm, vec3(0.0, 1.0, 0.0)));\n    \n    r = 4.0 * iced;\n    \n    return StepValue(iced, Epsilon, color, base);\n}\n\nvec3 Material_Stripes(vec3 surfPos, vec3 surfNorm, vec3 base, vec3 color, inout float r)\n{\n    float iced    = step(1.0, r);\n    float striped = step(0.65, cos(surfPos.z * 6.0) * iced);  // 0.65 = stripe thickness; 6.0 = stripe count\n    \n    return StepValue(striped, 0.65, color, base);\n}\n\nvec3 Material_Glazed(vec3 base, inout float r)\n{\n    r = 0.0;\n    return base;\n}\n\nvec3 Material_BoxInterior()\n{\n    return vec3(0.9, 0.9, 0.9);\n}\n\nvec3 Material_BoxExterior()\n{\n    return vec3(1.0, 0.84, 0.94);\n}\n\nvec3 Material_Apply(in RayHit hit, vec3 toView)\n{\n    vec3 color = SprinkleColors[int(clamp(hit.material - 8.0, 0.0, 2.0))];\n    float r = -2.0;\n    \n    if(hit.material < Epsilon)      // Powdered \n    {\n        color = Material_Powdered(hit.surfPos, Material_DoughnutBase(hit.surfNorm));\n    }\n    else if(hit.material < 1.1) // Chocolate Frosted w/ White Stripes\n    {\n        color = Material_Frosted(hit.surfNorm, Material_DoughnutBase(hit.surfNorm), ChocolateColor, 8.0, r);\n    \tcolor = Material_Stripes(hit.surfPos, hit.surfNorm, color, vec3(0.985, 0.877, 0.755), r);\n    }\n    else if(hit.material < 2.1) // ?\n    {\n        color = Material_DoughnutBase(hit.surfNorm);\n        color = Material_Frosted(hit.surfNorm, color, ChocolateColor, 4.0, r);\n    }\n    else if(hit.material < 3.1) // Jelly\n    {\n        color = Material_DoughnutBase(hit.surfNorm);\n        color = Material_Jelly(hit.surfPos, hit.surfNorm, color);\n    }\n    else if(hit.material < 4.1) // Pink Frosted w/ Sprinkles\n    {\n        color = Material_Frosted(hit.surfNorm, Material_DoughnutBase(hit.surfNorm), PinkColor, 10.0, r);\n    }\n    else if(hit.material < 5.1) // Glazed\n    {\n        color = Material_Glazed(Material_DoughnutBase(hit.surfNorm), r);\n    }\n    else if(hit.material < 6.1) // Box Exterior\n    {\n        color = Material_BoxExterior();\n    } \n    else if(hit.material < 7.1) // Box Interor\n    {\n        color = Material_BoxInterior();\n    }\n    \n    vec3 lighting = CalculateLighting(hit.surfPos, hit.surfNorm, toView, color, vec3(1.0), r);\n    \n    return lighting * color;\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\n/**\n * Basic Raymarching using SDF objects.\n *\n * For each raymarch step we:\n *\n *     - Find distance to nearest object along the ray\n *         - If distance <= 0, we are on or inside the object\n *         - If distance > 0, we are outside the object and must continue\n *           along the ray for a length of distance to find the next closest object.\n */\nRayHit RaymarchScene(in Ray ray)\n{\n    RayHit hit;\n    \n    hit.hit      = false;\n    hit.material = 0.0;\n    \n    float sdf = FarClip;\n    \n    for(float depth = NearClip; depth < FarClip; )\n    {\n    \tvec3 pos = ray.origin + (ray.direction * depth);\n        \n        sdf = Scene_SDF(pos, hit, 0.0);\n        \n        if(sdf < Epsilon)\n        {\n            hit.hit      = true;\n            hit.surfPos  = pos;\n            hit.surfNorm = Scene_Normal(pos);\n            \n            return hit;\n        }\n        \n        // Continue along the ray to look for the next nearest object\n        depth += sdf;\n    }\n    \n    return hit;\n}\n\nvec3 Render(vec2 fragCoord, Camera camera)\n{\n    vec3 final = vec3(0.3, 0.3, 0.3);\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    Seed(uv);\n    \n    Ray    ray = Camera_GetRay(camera, uv);\n    RayHit hit = RaymarchScene(ray);\n    \n    if(hit.hit)\n    {\n        final.rgb = Material_Apply(hit, normalize(camera.origin - hit.surfPos));\n    }\n    \n    return final;\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nconst vec2 SampleCoords[4] = vec2[](\n    vec2(0.0, 0.5),\n    vec2(0.5, 0.0),\n    vec2(0.0, -0.5),\n    vec2(-0.5, 0.0));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    BoxOrigin = mix(vec3(0.0), vec3(0.0, 0.0, 70.0), clamp((mod(iTime, TimeLimit) - 6.0) * 0.75, 0.0, 1.0));\n    \n    // Angled\n    vec3 camPos = vec3(40.0, 35.0, 30.0);\n    Camera camera = Camera_LookAt(camPos, vec3(0.0, 0.0, 6.0));\n    \n    // Looking down\n    //vec3 camPos = vec3(0.0, 35.0, 5.9);\n    //Camera camera = Camera_LookAt(camPos, vec3(0.0, 0.0, 6.0));\n    \n    fragColor.rgb = Render(fragCoord, camera);\n    \n    for(uint i = 0u; i < MultiSamples; ++i)\n    {\n        fragColor.rgb += Render(fragCoord + SampleCoords[i], camera);\n    }\n    \n    fragColor.rgb /= (float(MultiSamples) + 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[874, 930, 982, 982, 1053], [1055, 1055, 1110, 1110, 1181], [1379, 1419, 1442, 1442, 1655], [1657, 1810, 1835, 1835, 2009], [2382, 2688, 2734, 2734, 2986], [2988, 2988, 3036, 3036, 3313], [3315, 3602, 3645, 3645, 3767], [3770, 4042, 4093, 4093, 4200], [4202, 4462, 4503, 4503, 4572], [4574, 4774, 4879, 4879, 5131], [5133, 5133, 5218, 5218, 6058], [6060, 6281, 6346, 6346, 8145], [8718, 8718, 8777, 8777, 9945], [9947, 9947, 10003, 10003, 11028], [11030, 11523, 11584, 11584, 11888], [11890, 12268, 12299, 12299, 12761], [13133, 13871, 13926, 13926, 14494], [14496, 14496, 14645, 14645, 14962], [14964, 14964, 15155, 15155, 15509], [15511, 15591, 15734, 15734, 16116], [16342, 16516, 16559, 16586, 17130], [17132, 17132, 17181, 17181, 17398], [17400, 17400, 17461, 17461, 17761], [17763, 17763, 17853, 18668, 18918], [18920, 18920, 19010, 19010, 19210], [19212, 19212, 19260, 19260, 19292], [19294, 19294, 19323, 19323, 19357], [19359, 19359, 19388, 19388, 19424], [19426, 19426, 19475, 19475, 21001], [21205, 21565, 21599, 21599, 22198], [22200, 22200, 22244, 22244, 22573], [22575, 22891, 22946, 22946, 23553]]}
{"id": "ld3XWr", "name": "Ghost Silent Disco", "author": "seb0fh", "description": "Playing with domain repetition with offsets and deformations and fighting artifacts. ", "tags": ["raymarching"], "likes": 32, "viewed": 1009, "published": "Public API", "date": "1549132285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tGhost Silent Disco\n\t02/2019\n\tseb chevrel\n*/\n\nconst float PI= 3.1415926535897;\nconst float H_PI = PI * 0.5;\nconst float Q_PI = PI * 0.25;\nconst float E_PI = PI * 0.125;\nconst float TWO_PI= PI*2.0;\n\n// rotations\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis); float s = sin(angle), c = cos(angle), oc = 1.0 - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          \n               );\n}\nvec3 rotateX(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 rotateY(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x); }\nvec3 rotateZ(vec3 p, float a) { float c = cos(a), s = sin(a); return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n\n// signed distance primitives (from IQ)\nfloat sdPlane( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\nfloat sdSphere(vec3 p,float r) { return (length(p) - r); }\nfloat sdTorus(vec3 p,float r,float r2) { return(length( vec2(length(p.xz)-r,p.y) )-r2); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdHexPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x); }\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\nfloat sdCappedCylinder( vec3 p, vec2 h ) { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdVerticalCapsule( vec3 p, float h, float r ) { p.y -= clamp( p.y, 0.0, h ); return length( p ) - r; }\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) { vec3 pa = p - a, ba = b - a; float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); return length( pa - ba*h ) - r; }\nfloat sdTriPrism( vec3 p, vec2 h ) { vec3 q = abs(p); return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5); }\nfloat sdEllipsoid( in vec3 p, in vec3 r ) { float k0 = length(p/r); float k1 = length(p/(r*r)); return k0*(k0-1.0)/k1;}\n\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) { float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSmoothIntersection( float d1, float d2, float k ) { float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat hash3(vec3 p) { return fract(dot(p,vec3(102.04978598, 51.98729547, 33.09874))*4.13439); }\nfloat hash2(vec2 p) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 cossin(float a) { return vec2(cos(a),sin(a)); }\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }\nfloat checkers( in vec3 p ) { vec2 s = sign(fract(p.xz*.5)-.5); return .5 - .5*s.x*s.y; }\n\n//----------------------------------------------------------------------------------------------\n\n\n\nvec2 map(in vec3 p) \n{    \n    float d2Plane=sdPlane(p,vec4(0.0,1.0,0.0,0.0));\n\n    vec2  grid_id = floor((p.xz+1.0)/2.0);    \n    float fSeed = hash2(grid_id);\n    float fSeed2 = hash2(grid_id+248.0);\n    \n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;        \n    \n    float a =fSeed*TWO_PI+iTime*(1.0+fSeed2*3.0)*sign(fSeed-0.5);\n    vec2 sc = cossin(a);\n   \t\n    // deformation \n    p.xz +=cossin(p.y*sign(fSeed)+iTime*(5.0+fSeed2)+fSeed*TWO_PI).yx*0.2;\n    \n    // jump anim\n    p.y-=0.7+sin(iTime*(1.0+fSeed2*5.0)+fSeed)*0.5;\n    \n    // Body\n    float h = 1.0+fSeed2;\n    float r = sin(p.y*PI+fSeed*TWO_PI+iTime*10.0)*(0.05+fSeed2*0.05-0.025)+0.25;    \n    float d2Body =  sdVerticalCapsule(p, h, r);\n    \n    // Arms\n    float r2 = r*2.5;\n    float armH = h*0.6+fSeed2*0.3;\n    float armL = h*0.4+fSeed*0.2 + abs(sin(iTime*(1.0+fSeed*1.0)+fSeed2));\n    d2Body=opSmoothUnion(d2Body, sdCapsule(p, vec3(sc.x*r,armH,sc.y*r), vec3(sc.x*r2,armL,sc.y*r2) ,0.1), 0.2);\n    d2Body=opSmoothUnion(d2Body, sdCapsule(p, vec3(-sc.x*r,armH,-sc.y*r), vec3(-sc.x*r2,armL,-sc.y*r2) ,0.1), 0.2);\n    \n    // Mouth\n    float mouthR = max(0.0,sin(iTime*(0.7+fSeed2)+fSeed)*sin(iTime*(2.0+fSeed)+fSeed2)*0.15+0.1);\n    float d2Mouth = sdSphere(p+vec3(-sc.y*r,-h*(0.7+fSeed2*0.2),sc.x*r),mouthR);\n    \n    // Eyes\n    vec2 eye1 = cossin(a+Q_PI);\n    vec2 eye2 = cossin(a+Q_PI+H_PI);\n    float eyeS = 0.12;     \n    float d2Eyeball = min(sdSphere(p+vec3(eye1.x*r,-h,eye1.y*r),eyeS),sdSphere(p+vec3(eye2.x*r,-h,eye2.y*r),eyeS) );\n    float pupilS = 0.07;\n    float r3=r+eyeS;\n    float d2Pupil = min(sdSphere(p+vec3(eye1.x*r3,-h,eye1.y*r3),pupilS),sdSphere(p+vec3(eye2.x*r3,-h,eye2.y*r3),pupilS) );\n    float d2Eye = max(d2Eyeball, -d2Pupil);\n    \n    if (d2Plane<d2Body)\n   \t\treturn vec2(-1.0, d2Plane);\n    else if (d2Eye<d2Body)       \n        if (d2Pupil  < d2Eyeball )\n            return vec2(-4.0, d2Pupil);\n\t\telse            \n        \treturn vec2(-3.0, d2Eyeball);\n    else\n    {\n     \tif(d2Body > -d2Mouth)   \n        \treturn vec2(fSeed,d2Body);\n        else\n            return vec2(-2.0,-d2Mouth);\n    }\n}\n\nvec3 normal( in vec3 pos,in float epsilon )\n{\n\tvec3 eps = vec3( 0.003, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).y - map(pos-eps.xyy).y,\n\t    map(pos+eps.yxy).y - map(pos-eps.yxy).y,\n\t    map(pos+eps.yyx).y - map(pos-eps.yyx).y );\n\treturn normalize(nor);\n}\n\nfloat AO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.10*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).y;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).y;\n        res = min( res, 7.0*h/t );\n        t += clamp( h, 0.01, 0.15 );\n        if( res<0.01 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float px, const float maxdist )\n{\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    vec2 IDdist = map(ro + t*rd);\n        res = vec3( t, IDdist.x, float(i)/256.0 );\n        if( IDdist.y<(px*t) || t>maxdist ) break;\n        t += min( IDdist.y, 0.4 )*0.4;\n    }\n\treturn res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 r = intersect(ro, rd, 0.3/iResolution.y, 100.0);                \t\n    \n    // light\n    vec3 p = ro+(rd*r.x);\n    vec3 nor = normal(p,0.0001);\n    vec3 light = normalize(vec3(-0.5,2.0,-1.0));\n    float diffuse = dot(nor,light);\n    float occlusion = AO(p,nor);\n    vec3 ref = reflect( rd, nor );\n    float specular = (r.y >=0.0 || r.y==-4.0) ? pow(clamp( dot( ref, light ), 0.0, 1.0 ),20.0) : 0.0;\n    float shadow = softShadows(p,light,0.01,10.0);   \n    \n    vec3 color = r.y<0.0 ? \n        (r.y<-3.0 ? vec3(0.1) :\n        (r.y<-2.0 ? vec3(1.0) :\n        (r.y<-1.0 ? vec3(0.1) :\n        checkers(p)*vec3(0.2)+0.2 ))) : \n        palette(r.y*100.,vec3(0.5),vec3(0.5),vec3(0.5),vec3(0.0,0.33,0.67));\n    \n    return vec3(1.0)*diffuse*specular + vec3(diffuse*0.5*shadow+0.5)*color;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xx) -vec2( 0.5,0.5*iResolution.y/iResolution.x);\n    \n    float time = iTime*0.3;\n  \n    float cam_h = sin(time*0.5+1.0)*5.0+10.0;\n    float cam_r = sin(time*1.7+2.0)*sin(time)*5.0+cam_h;    \n    vec3 ro = vec3(sin(time)*cam_r,cam_h,-cos(time)*cam_r);      \n    vec3 rd = normalize(vec3(uv, 1.0)); // fov\n    rd=rotateX(rd,PI/5.0);\n    \n    \n    fragColor=vec4(render(ro,rd) ,1.0);\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = vec4(render( fragRayOri, fragRayDir),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 214, 251, 251, 724], [725, 725, 756, 756, 836], [837, 837, 868, 868, 948], [949, 949, 980, 980, 1060], [1062, 1102, 1135, 1135, 1164], [1165, 1165, 1197, 1197, 1223], [1224, 1224, 1264, 1264, 1313], [1314, 1314, 1345, 1345, 1428], [1429, 1429, 1465, 1465, 1541], [1542, 1542, 1578, 1578, 1610], [1611, 1611, 1653, 1653, 1748], [1749, 1749, 1802, 1802, 1857], [1858, 1858, 1910, 1910, 2025], [2026, 2026, 2062, 2062, 2141], [2142, 2142, 2185, 2185, 2261], [2263, 2263, 2315, 2315, 2406], [2407, 2407, 2465, 2465, 2560], [2561, 2561, 2620, 2620, 2714], [2716, 2716, 2737, 2737, 2811], [2812, 2812, 2833, 2833, 2894], [2896, 2896, 2922, 2922, 3553], [3555, 3555, 3577, 3577, 3607], [3608, 3608, 3680, 3680, 3719], [3720, 3720, 3749, 3749, 3809], [3811, 3911, 3933, 3933, 6000], [6002, 6002, 6047, 6047, 6268], [6270, 6270, 6308, 6308, 6607], [6609, 6609, 6684, 6684, 6945], [6947, 6947, 7023, 7023, 7302], [7304, 7304, 7341, 7341, 8136], [8138, 8138, 8195, 8195, 8618], [8622, 8622, 8716, 8716, 8777]]}
{"id": "MdsfRN", "name": "[ Complex ] - Drops", "author": "Friend", "description": "Plane displacement using complex maps", "tags": ["3d", "complex", "drops", "maps"], "likes": 4, "viewed": 360, "published": "Public API", "date": "1550917555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res_           iResolution\n#define time_          iTime\n#define pi_            3.14159265\n#define tau_           2.*pi_\n\n#define dom(f,s)       (2. * f.xy - res_.xy) / res_.y * s\n#define ry(a)          mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define rz(a)          mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.)\n    \nfloat de(vec3 p);\nvec3  gradient(vec3 p);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\nfloat fog_exp2(float dist, float dens);\nvec3  blackbody(float Temp);\n\nvec2  zconj(vec2 z);\nvec2  zmul(vec2 z0, vec2 z1);\n\nfloat hash(vec2 p);\nfloat hashm(vec2 p);\n\n#define march_steps_   128\n#define max_range_     50000.\n#define hit_perc_      .01\n#define micro_step_    1.\n#define grad_perc_     .1\n\n#define droplet_num_   15\n//#define DEBUG\n\nfloat wavlet(\n    vec3 p,       // Wavelet position\n    float r       // Wavelet radius\n) {\n    // Transformation used for displacement\n    vec2 z = p.xz;\n    vec2 fz = zmul(.8 * z, zconj(z));\n   \t\n    float a = 1.; float fq = .000025 + pow(r, -2.); float flowv = time_ * 3.;\n    \n    float disp = a * sin(fq * fz.x - flowv);\n\treturn length(p.xz) - r - sin(time_) * r/4. < hit_perc_ ? disp : 0.;\n}\n\nfloat de(vec3 p) {\n    vec2 z = p.xz;\n    \n    float d_pl = p.y;\n    \n    for(int i = 0; i < droplet_num_; i++) {\n        vec3 rp = vec3(\n            hashm( vec2(i+1, (i+1)*13) ) * 4500.,\n            0.,\n            hashm( vec2(i-1, (i-1)*-7) ) * 4500.\n        ); \n    \td_pl += wavlet(\n            p - rp,\n            hash(vec2(i+2, i*3)) * 800.\n        ); \n    }\n\t\n    return d_pl;\n}\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p  = dom(f, 1.); vec2 np = f / res_.xy;\n    \n    // Camera\n    // ----------------\n    float r = 785.;\n    float speed = .3;\n    vec3 ro = vec3(r * cos(time_ * speed), 6.*r , r * sin(time_ * speed));\n    vec3 target = vec3(0.);\n    mat3 lam = look_at(ro, target, 0.);    \n\tvec3 rd = normalize(lam * vec3(p.xy, .8));\n    \n    // Raymarch\n    // ----------------\n    vec3 pos, nor = vec3(0.);\n    float d, step_ , id= 0.;   \n    for(int i = 0; i < march_steps_; i++) {\n    \tpos    = ro + step_ * rd;\n        d      = de(pos);\n        step_ += d * micro_step_;\n    \tif(d < hit_perc_ || d > max_range_) break;    \n    }\n    \n    // Shading\n    // ----------------\n    vec3 c = vec3(0.);\n    if(step_ > 0.) {\n        pos = ro + step_ * rd;\n \t\tnor = gradient(pos);\n        \n        vec3  lig  = normalize(vec3(.345, .345, .345));\n        float diff = clamp(dot(rd, nor), 0., 1.);\n        float spec = clamp(dot(nor, lig), 0., 1.);\n        float fresnel = clamp(dot(nor, rd), 0.0, 1.0);\n        float leq  = diff + 2.*spec + fresnel;\n        \n        vec3 mat = vec3(.2, .4, .7);\n        mat = mix(mat, vec3(0., 1.2, 0.8), .5*np.x);\n        \n        c = mix(c, vec3(1.2), leq * mat);\n        c += smoothstep(0., 8.1, pos.y);\n    }\n\t\n    // Fog\n    // -----------------\n    c = mix(c, vec3(0.), fog_exp2(step_, .00009));\n    \n    // Post-processing\n\t// -----------------\n    c = pow(c, vec3(2.5));\n\t\n    o = vec4(c, 1.);\n}\n\nvec3 gradient(vec3 p) {\n    vec2 e = vec2(grad_perc_, .0);\n    return normalize(vec3(\n        de(p+e.xyy)-de(p-e.xyy),\n        de(p+e.yxy)-de(p-e.yxy),\n        de(p+e.yyx)-de(p-e.yyx)\n    ));\n}\n\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nfloat fog_exp2(float dist, float dens) {\n  const float log2v = -1.442695;\n  float d = dens * dist;\n  return 1. - clamp(exp2(d * d * log2v), 0., 1.);\n}\n\nvec3 blackbody(float temp) {\n\tvec3 col = vec3(255.);\n    \n    col.x = 56100000. * pow(temp, -1.5) + 148.;\n   \tcol.y = 100.04 * log(temp) - 623.6;\n   \t\n    if(temp > 6500.) col.y = 35200000. * pow(temp,(-3. / 2.)) + 184.;\n   \t\n    col.z = 194.18 * log(temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.) / 255.;\n    \n    if (temp < 1000.) col *= temp / 1000.;\n   \t\n    return col;\n}\n\n\nvec2 zmul(vec2 z0, vec2 z1)  {\n    return vec2(\n        z0.x * z1.x - z0.y * z1.y,\n        z0.x * z1.y + z0.y * z1.x\n    );\n}\n\nvec2 zconj(vec2 z) { \n    return vec2(z.x, -z.y); \n}\n\nfloat hash(vec2 p) {\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\nfloat hashm(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[752, 769, 860, 904, 1166], [1168, 1168, 1186, 1186, 1552], [1554, 1554, 1590, 1590, 3011], [3013, 3013, 3036, 3036, 3206], [3209, 3209, 3253, 3253, 3426], [3428, 3428, 3468, 3468, 3578], [3580, 3580, 3608, 3608, 3956], [3959, 3959, 3989, 3989, 4084], [4086, 4086, 4106, 4106, 4138], [4140, 4140, 4160, 4160, 4223], [4225, 4225, 4246, 4246, 4338]]}
{"id": "MldfWn", "name": "Symmetric Ellipsoid - distance", "author": "iq", "description": "Symmetric Ellipsoids allow for an exact distance estimation. While expensive, it allows exact euclidean operations. Left, ellipsoid distance estimation. Right, exact symmetric ellipsoid distance. Note the better shadows and intersections on the right.", "tags": ["3d", "distancefield", "sdf", "distance", "ellipsoid"], "likes": 8, "viewed": 632, "published": "Public API", "date": "1549869286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The distance to a generic ellipsoid can be approximated, but produces\n// distorted distance fields that manifest, for example, in wrongly \n// rendered soft shadows.\n//\n// Symmetric ellipsoids (ellipses revolved in 3D) do allow however for an exact\n// distance estimation (although it requires solving a cubic, which is expensive)\n// and produce beautiful shadows.\n//\n// Left,  a symmetric ellipsoids rendered with the generic ellipsod method, \n//        producing a too big penumbra.\n// Right, same shape rendered with the symmetric solver, producing the\n//        correct penumbra.\n//\n// See also https://www.shadertoy.com/view/tdS3DG\n\n\n#define AA 2   // make this 4 is you have a fast computer\n\n//------------------------------------------------------------------\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n// generic ellipsoid - approximated distance: https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    return sdEllipse( vec2( length(p.xy), p.z ), r );\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    float d1 = (id==0) ? sdEllipsoid(    p, vec3(0.25,0.25,0.02) ) :\n                         sdEllipsoidXXZ( p, vec2(0.25,     0.02) );\n\n    // plane\n    float d2 = p.y+0.25;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<64 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t) );\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n  \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.1);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            occ = 1.0;\n            col *= 0.8+0.2*checkersGradBox( pos.xz*2.0 );\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.25,0.15,0.05);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.0, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        dif *= calcSoftshadow( pos, lig, id );\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.00*dif*vec3(3.30,2.50,2.00);\n        lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        col = col*lin;\n        col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldfWn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1778, 1847, 1886, 1886, 2951], [2955, 3039, 3083, 3083, 3172], [3174, 3214, 3261, 3261, 3317], [3319, 3389, 3420, 3437, 3670], [3672, 3672, 3720, 3720, 3988], [3991, 3991, 4049, 4049, 4336], [4338, 4338, 4381, 4381, 4605], [4607, 4607, 4660, 4660, 4961], [4965, 5041, 5077, 5098, 5321], [5323, 5323, 5370, 5370, 6862], [6864, 6864, 6921, 6936, 8096]]}
{"id": "MtdfR7", "name": "TE Intro", "author": "Thorgrimar", "description": "Starting screen of my game TE.", "tags": ["raytracing"], "likes": 1, "viewed": 248, "published": "Public API", "date": "1549816365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created thanks to the video WebGL Paris 2015 - Raymarching en Live Coding\n\n// some distance fields\nfloat plane(vec3 pos)\n{\n    return pos.y;\n}\n\nfloat sphere(vec3 pos, vec3 center,float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0)) -0.3;\n}\n\nvec3 size_box_hor = vec3(3.0, 1.0, 1.0);\nvec3 size_box_vert = vec3(1.0, 3.0, 1.0);\n\n// for the T\nvec3 pos_box_a = vec3(-5.0, 8.0, 10.0);\nvec3 pos_box_b = vec3(-5.0, 4.0, 10.0);\n\n// for the E\nvec3 pos_box_c = vec3(5.0, 10.0, 3.0);\nvec3 pos_box_d = vec3(3.0, 6.0, 3.0);\nvec3 pos_box_e = vec3(5.0, 6.0, 3.0);\nvec3 pos_box_f = vec3(5.0, 2.0, 3.0);\n\nfloat map(vec3 pos)\n{\n   vec3 moveT = 1.2*sin(iTime*.5)*vec3(0., 0.5, 0.);\n   return min(min(min(min(min(min(plane(pos), \n              box(pos - (pos_box_a+moveT) , size_box_hor)),\n              box(pos -  (pos_box_b+moveT), size_box_vert)),\n              box(pos -  (pos_box_c-moveT), size_box_hor)),\n              box(pos -  (pos_box_d-moveT), size_box_vert)),\n              box(pos -  (pos_box_e-moveT), size_box_hor)),\n              box(pos -  (pos_box_f-moveT), size_box_hor)    \n              );\n}\n\nvec3 col_floor(vec3 pos)\n{\n    float size = 10.0;\n    vec3 col;\n    float pos_x = (pos.x + 1.)/size;\n    float pos_z = (pos.z - 5.)/size;\n    // 1 box is red, 1 green and the other are white\n    if (0.<pos_x && pos_x<1.0 && 0.<pos_z && pos_z<1.) {\n        col = vec3(0., 0.5, 0.);\n    } else if (-1.<pos_x && pos_x<0. && -1.<pos_z && pos_z<0.) {\n        col = vec3(0.5, 0., 0.);\n    } else {\n        col = vec3(1.0);\n    }\n    // draw black lines between boxes\n    if (mod(pos_x, 1.) < 0.1 || mod(pos_z, 1.) < 0.1) {\n        col = vec3(0.);\n    }\n    return col;\n}\n\n// normal of the face where pos is\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(map(pos+eps.xyy)-map(pos-eps.xyy),\n                     map(pos+eps.yxy)-map(pos-eps.yxy),\n                     map(pos+eps.yyx)-map(pos-eps.yyx)));\n}\n\nfloat diffuse(vec3 normal, vec3 lightDir)\n{\n    return max(0., dot(normal, lightDir));\n    //return dot(normal, lightDir)*.5 + .5; (wrap light)\n}\n\nfloat specular(vec3 normal, vec3 lightDir, vec3 rayDir)\n{\n    vec3 h = normalize(normal - rayDir);\n    return pow(max(dot(h, lightDir), 0.), 40.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (uv.x from -1.0 to 1.0)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x; \n\t\n    // cam positioning\n    vec3 pos_cam = vec3(4.1*sin(iTime*0.2), 15.0 +0.05*sin(iTime*0.4) , -20.0);\n    vec3 pos = pos_cam;\n    vec3 dir = normalize(vec3(uv.x, uv.y -0.5, 1.0));\n    \n    vec3 col = vec3(0.0);\n    //ray marching\n    for (int i=0; i<128; i++) {\n        float d = map(pos);\n        \n        if (d<0.01) {\n            if (pos.y < 0.1) {\n                // the ray hit the floor\n                float d = -pos_cam.y/dir.y;\n                pos = pos_cam + d*dir;\n                col = col_floor(pos);\n            } else {\n                // the ray hit a letter\n                vec3 pos_rel;\n                if (pos.x > 0.) {\n                    pos_rel = pos + 1.2*sin(iTime*.5)*vec3(0., 0.5, 0.);\n                } else {\n                    pos_rel = pos - 1.2*sin(iTime*.5)*vec3(0., 0.5, 0.);\n                }\n                // we add a little texture\n                col = vec3(0.6, 0.3, 0.)*(1.+0.2*sin(pos_rel.x*0.5)*sin(pos_rel.y*1.2));\n            }\n            break;\n        }\n        pos += d*dir;\n    }\n\t\n    // add white light\n    vec3 lightPos = vec3(10., 7., -10.);\n    vec3 lightDir = normalize(lightPos - vec3(-3., 10., 0.));\n    float lightDistance = sphere(pos, lightPos, 0.5);\n    vec3 normal = computeNormal(pos);\n    float intensityLightSurface = 2.*specular(normal, lightDir, dir) + diffuse(normal, lightDir);\n    col = col + intensityLightSurface*col;\n    \n    \n    // add a fog\n    float fogFactor = min(1., exp(-0.05*(pos.z - 10.)));\n    vec3 fogColor = vec3(0.8, 0.9, 0.9);\n    col = mix(fogColor, col, fogFactor);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 102, 125, 125, 145], [147, 147, 197, 197, 241], [244, 244, 276, 276, 329], [509, 676, 697, 697, 1180], [1182, 1182, 1208, 1208, 1746], [1748, 1783, 1813, 1813, 2021], [2023, 2023, 2066, 2066, 2168], [2170, 2170, 2227, 2227, 2318], [2320, 2320, 2377, 2437, 4173]]}
{"id": "MtdyzB", "name": "The Traveling Trusses", "author": "Plento", "description": "The goal of this was to come up with a really simple way to do edge detection / glow. Iv'e tried this before, but this method is 999% improved.", "tags": ["3d", "raymarch", "glow"], "likes": 14, "viewed": 412, "published": "Public API", "date": "1549344813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plento\n\nconst float smod = 0.4; // speed multiplier\n\nfloat opS( float d1, float d2 ) {return max(-d1,d2);}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nvec2 rot2(vec2 k,float t){\n\treturn vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);\n}\n\n\nfloat map(vec3 rp)\n{\n   \n   float p = sin(rp.z * 0.1) * 2.3;\n   rp = vec3(rot2(rp.xy, p), rp.z);\n    \n   vec3 pos = rp - vec3(-iTime*1.6, 0.0, 4.0); \n    pos.z += iTime*2.0*smod;\n   float td = 0.07;\n    \n   vec3 b = vec3(1.0 - td*2.0, 4.0, 3.0);\n   pos = mod(pos, b) - 0.5 * b; \n  \n   pos.yz *= rot(iTime*0.3);\n    \n   float res = sdBox( pos, vec3(0.5 - td));\n    \n   res = opS(sdBox(pos, vec3(0.4, 0.4, 1.1)), res);\n   res = opS(sdBox(pos, vec3(1.1, 0.4, 0.4)), res);\n   res = opS(sdBox(pos, vec3(0.4, 1.1, 0.4)), res);\n    \n   return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.2 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n   \n    vec3 ro = vec3(0.0, 0.0, 10.0); \n    vec3 rd = normalize(vec3(uv,2.0));\n    \n    ro.z += iTime * 8.0 * smod; \n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    // glow stuff\n    float minDist = 999.0; \n    vec3 glowCol = vec3(0);\n    \n    // glow size and softness.\n    float gSize = 0.14;\n    float softness = 0.55;\n    \n    float fog = 0.0; // glow fog\n    float g = 0.0;\n    \n    for (int i = 0; i < 75; i++)\n    {\n    \td = map(ro + rd * t);\n        \n        minDist = min(minDist, d); \n        \n        if(abs(d)<0.001 || t > 25.0) \n        {\n            minDist = abs(d);\n            break;    \n        }\n        \n        t += d * 0.75;\n        \n        // Acquire some edge color if the distance to the closest object is \n        // greater than the minimum distance to an object that the ray encountered.\n        // Basically, if the ray barely misses an object, add some glow color. \n        if(d >= minDist && abs(d) > 0.15)\n        {\n            fog = smoothstep(0.13, 0.12, t / 160.0);\n            \n             glowCol += vec3(1.0, 0.0, 0.0) \n                 * smoothstep(gSize,gSize - softness, minDist) * fog ;\n            \n            g++;\n        }\n        \n    }\n    \n    glowCol /= g;\n    \n    vec3 col = vec3(0);\n    \n    col += glowCol*12.0;\n    \n    col *= smoothstep(0.99, 0.05, length(uv*0.41));\n    col *= smoothstep( 0.0, 0.6, length(uv));\n   \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 56, 89, 89, 109], [111, 111, 141, 141, 228], [230, 230, 249, 249, 301], [302, 302, 328, 328, 402], [405, 405, 425, 425, 947], [949, 949, 1006, 1006, 2521]]}
{"id": "MtXcRj", "name": "Flipmaze", "author": "Vovosunt", "description": "Had this lying around, don't remember what inspired it...", "tags": ["maze"], "likes": 7, "viewed": 120, "published": "Public", "date": "1549677160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define c30 0.86602540378\n#define hm  (4.0/3.0)\n#define grid 20.0\n#define grid2 1.0\n#define smooth (1.0 / iResolution.y * grid)\n#define timeScale 0.05\n#define rt (iTime * timeScale)\n\n\nvec2 hex(vec2 v){\n\tfloat yc = abs(mod(v.x + floor((v.y*hm + 0.5))*(c30 / 2.0),c30) / c30 - 0.5);\n\tfloat y = floor(v.y*hm + yc);\n\tfloat x = floor(v.x/c30 + 0.5 + fract(y / 2.0))- fract(y / 2.0);\n\treturn vec2(x*c30,y /hm + 1.0/(hm * 4.0));\n}\n\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3132)))*43758.5453);\n}\n\nfloat rand(vec3 v){\n    return fract(cos(dot(v,vec3(13.46543,67.1132,123.546123)))*43758.5453);\n}\n\nfloat layer(vec2 uv){\n    vec2 fuv = floor(uv * grid);\n    float nos = fract(rand(fuv) + rt);\n    float fl = uv.y + (step(nos,0.5) * 2.0 - 1.0) * uv.x;\n    float finCol = abs(fract(fl * grid2 * grid) - 0.5);\n    finCol = smoothstep(smooth,-smooth,finCol - 0.25);\n    return finCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy  / iResolution.y;\n    \n    vec3 finCol = vec3(layer(uv),layer(uv + 1231.), layer(uv -324.));\n    \n\tfragColor = vec4(finCol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXcRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 201, 201, 423], [425, 425, 444, 444, 510], [512, 512, 531, 531, 609], [611, 611, 632, 632, 894], [896, 896, 953, 953, 1108]]}
{"id": "td23RK", "name": "Basic raymarching and AO", "author": "liamegan", "description": "Just a basic raymarching loop with some shading and AO", "tags": ["3d", "raymarching"], "likes": 3, "viewed": 339, "published": "Public API", "date": "1549401275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "  \n  // movement variables\n  vec3 movement = vec3(.0);\n  \n  const float clipNear = 0.;\n  const float clipFar = 64.;\n  \n  const int maxIterations = 256;\n  const float stopThreshold = 0.001;\n  const float stepScale = .7;\n  const float eps = 0.01;\n  \n  const vec3 clipColour = vec3(0.);\n  const vec3 fogColour = vec3(0.);\n  \n  const vec3 light1_colour = vec3(.8, .8, .85);\n  const vec3 light1_position = vec3(.3, .3, 1.);\n  const float light1_attenuation = 0.01;\n  const float scene_attenuation = 0.01;\n  \n  struct Surface {\n    int object_id;\n    float distance;\n    vec3 position;\n    vec3 colour;\n    float ambient;\n    float spec;\n  };\n  \n  // This function describes the world in distances from any given 3 dimensional point in space\n  float world(in vec3 position, inout int object_id) {\n    float z = position.z * .1;\n    float c = cos(z);\n    float s = sin(z);\n    position.xy *= mat2(c, -s, s, c);\n    vec3 pos = floor(position * 2.);\n    object_id = int(floor(pos.x + pos.y + pos.z));\n    position = mod(position, .5) - .25;\n    return length(position) - .12;\n  }\n  float world(in vec3 position) {\n    int dummy = 0;\n    return world(position, dummy);\n  }\n  \n  vec3 getObjectColour(int object_id) {\n    float modid = mod(float(object_id), 5.);\n    if(modid == 0.) {\n      return vec3(.3, 0.2, 0.5) * 2.;\n    } else if(modid == 1.) {\n      return vec3(.5, 0.5, 0.3) * 2.;\n    } else if(modid == 2.) {\n      return vec3(.5, 0.4, 0.5) * 2.;\n    } else if(modid == 3.) {\n      return vec3(.2, 0.5, 0.4) * 2.;\n    } else if(modid == 4.) {\n      return vec3(.2, 0.5, 0.2) * 2.;\n    }\n  }\n  \n  Surface getSurface(int object_id, float rayDepth, vec3 sp) {\n    return Surface(\n      object_id, \n      rayDepth, \n      sp, \n      getObjectColour(object_id), \n      .5, \n      100.);\n  }\n  \n  // The raymarch loop\n  Surface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float sceneDist = 1e4;\n    float rayDepth = start;\n    int object_id = 0;\n    for(int i = 0; i < maxIterations; i++) {\n      sceneDist = world(ro + rd * rayDepth, object_id);\n      \n      if(sceneDist < stopThreshold || rayDepth > end) {\n        break;\n      }\n      \n      rayDepth += sceneDist * stepScale;\n    }\n    \n    return getSurface(object_id, rayDepth, ro + rd * rayDepth);\n  }\n  \n  // Calculated the normal of any given point in space. Intended to be cast from the point of a surface\n  vec3 calculate_normal(in vec3 position) {\n    vec3 grad = vec3(\n      world(vec3(position.x + eps, position.y, position.z)) - world(vec3(position.x - eps, position.y, position.z)),\n      world(vec3(position.x, position.y + eps, position.z)) - world(vec3(position.x, position.y - eps, position.z)),\n      world(vec3(position.x, position.y, position.z + eps)) - world(vec3(position.x, position.y, position.z - eps))\n    );\n    \n    return normalize(grad);\n  }\n  \n  // Original by IQ\n  float calculateAO(vec3 p, vec3 n)\n  {\n     const float AO_SAMPLES = 8.0;\n     float r = 0.0;\n     float w = 1.0;\n     for (float i=1.0; i<=AO_SAMPLES; i++)\n     {\n        float d0 = i * 0.15;\n        r += w * (d0 - world(p + n * d0));\n        w *= 0.5;\n     }\n     return 1.0-clamp(r,0.0,1.0);\n  }\n  \n  vec3 lighting(Surface surface_object, vec3 cam) {\n    \n    // start with black\n    vec3 sceneColour = vec3(0);\n    \n    // Surface normal\n    vec3 normal = calculate_normal(surface_object.position);\n    \n    // Light position\n    vec3 lp = light1_position + movement;\n    // Light direction\n    vec3 ld = lp - surface_object.position;\n    \n    // light attenuation\n    // For brightly lit scenes or global illumination (like sunlit), this can be limited to just normalizing the ld\n    float len = length( ld );\n    ld = normalize(ld);\n    float lightAtten = min( 1.0 / ( light1_attenuation*len ), 1.0 );\n    // lightAtten = 1.;\n    \n    // Scene values, mainly for fog\n    float sceneLength = length(cam - surface_object.position);\n    float sceneAttenuation = min( 1. / ( scene_attenuation * sceneLength * sceneLength ), 1. );\n    \n    // The surface's light reflection normal\n    vec3 reflection_normal = reflect(-ld, normal);\n    \n    // Ambient Occlusion\n    float ao = calculateAO(surface_object.position, normal);\n   // ao *= ao * ao;\n    // ao = 1.;\n    \n    // Object surface properties\n    float diffuse = max(0., dot(normal, ld));\n    float specular = max(0., dot( reflection_normal, normalize(cam - surface_object.position) ));\n    specular = pow(specular, surface_object.spec); // Ramping up the specular value to the specular power for a bit of shininess.\n    \n    // Bringing all of the lighting components together\n    sceneColour += ( surface_object.colour * (diffuse + surface_object.ambient) + specular ) * light1_colour * lightAtten * ao;\n    // adding fog\n    sceneColour = mix( sceneColour, fogColour, 1. - sceneAttenuation );\n    \n    // return vec3(ao);\n    return sceneColour;\n  }\n  \n  vec3 path(float z) {\n    return vec3(0,0,-5000.+z);\n  }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float t = iTime * .2;\n    \n    // movement\n    movement = path(iTime);\n    \n    // Camera and look-at\n    vec3 cam = vec3(0,0,-1);\n    vec3 lookAt = vec3(sin(t)*.25,0,0);\n    \n    // add movement\n    lookAt += movement;\n    cam += movement;\n    \n    // Unit vectors\n    vec3 forward = normalize(lookAt - cam);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = normalize(cross(forward, right));\n    \n    // FOV\n    float FOV = .4;\n    \n    // Ray origin and ray direction\n    vec3 ro = cam;\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    float s = sin(t);\n    float c = cos(t);\n    rd.xy *= mat2(c, -s, s, c);\n    \n    // Ray marching\n    Surface objectSurface = rayMarch(ro, rd, clipNear, clipFar);\n    if(objectSurface.distance > clipFar) {\n      fragColor = vec4(clipColour, 1.);\n      return;\n    }\n    \n    vec3 sceneColour = lighting(objectSurface, cam);\n\n    // Output to screen\n    fragColor = vec4(sceneColour, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td23RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 738, 790, 790, 1070], [1073, 1073, 1104, 1104, 1162], [1168, 1168, 1205, 1205, 1588], [1594, 1594, 1654, 1654, 1783], [1789, 1812, 1872, 1872, 2264], [2270, 2374, 2415, 2415, 2831], [2837, 2857, 2894, 2894, 3154], [3160, 3160, 3209, 3238, 4864], [4870, 4870, 4890, 4890, 4925], [4929, 4929, 4986, 4986, 6067]]}
{"id": "td23zd", "name": "Ripple effect water", "author": "sk537", "description": "Simple ripple effect simulation", "tags": ["water", "ripple"], "likes": 5, "viewed": 114, "published": "Public", "date": "1549887268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat uvLength = length(uv);\n\n\tvec2 newuv = fragCoord.xy/iResolution.xy+(uv/uvLength)*sin(uvLength*10.0-iTime*5.0)*0.5;\n\n\tfragColor = vec4(newuv.x*0.1,newuv.y*0.4, 0.9,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td23zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 396]]}
{"id": "td2GDw", "name": "Another attractor", "author": "Justaway", "description": "Visualizing structures in the quadratic map.", "tags": ["attractor"], "likes": 2, "viewed": 77, "published": "Public", "date": "1549085727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float[150] coef = float[150](-0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n                       -0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n                       0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n                       -0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n                        -0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114);\n\nfloat[30] c;\n\nvec3 Dmap(vec3 v, vec3 d){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0] + c[3]*y + c[5]*z + 2.0*c[6]*x;\n    newV.y = c[11] + c[13]*x +c[14]*z + 2.0*c[17]*y;\n    newV.z = c[22] + c[24]*y + c[25]*x + 2.0*c[28]*z;\n    return newV;\n}\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*4733.0+2687.0,6379.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    \n    vec3 V = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    T[0] = float(floor(iTime/5.0));\n    T[1] = T[0]+1.0;\n    float t = smoothstep(0.0,1.0,fract(iTime/5.0));\n    float perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    float T2[2];\n    T2[0] = floor(iTime/5.0);\n    T2[1] = T2[0] + 1.0;\n    float t2 = smoothstep(0.0,1.0,fract(iTime/5.0));\n    perm = permute(permute(T2[0]));\n    int coefIndex[2];\n    coefIndex[0] = int(mod(perm, 5.0));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, 5.0));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    uv*=3.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    int i = 0;\n    vec3 D = vec3(0.0);\n    float m2;\n    for(i = 0; i < 128; i++)\n    {\n        D = Dmap(V,D);\n        V = map(V);\n        m2 = mod2(V);\n        if(m2>1e20) break;\n    }\n    \n    float dist = sqrt(m2/mod2(D))*0.5*log(m2);\n\n    vec4 col;\n    \n    vec3 norm = normalize(V);\n    \n    if(dist > 1.0){\n    \tcol = vec4(abs(1.0/dist));\n    }else{\n        col = vec4(abs(dist));\n    }\n    \n    col.x = min(col.x,abs(norm.x));\n    col.y = min(col.y,abs(norm.y));\n    col.z = min(col.z,abs(norm.z));\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2GDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1706, 1706, 1732, 1732, 2100], [2102, 2102, 2119, 2119, 2674], [2676, 2676, 2696, 2696, 2734], [2736, 2736, 2760, 2760, 2800], [2802, 2802, 2859, 2859, 4612]]}
{"id": "tdB3z3", "name": "[twitch] Snap Arch", "author": "yx", "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/376293452[/url]", "tags": ["raymarched", "livecoding", "twitch"], "likes": 15, "viewed": 526, "published": "Public API", "date": "1549494624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThis shader was created live on stream!\n\tYou can watch the VOD here: https://www.twitch.tv/videos/376293452\n\n\tI use the Bonzomatic tool by Gargaj/Conspiracy:\n\thttps://github.com/Gargaj/Bonzomatic\n\n\tWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n\tCome and watch a show!\n\n\t~yx\n*/\n\n#define pi (acos(-1.))\n\n// shadertoy port only - Bonzomatic provides a noise texture which I'm approximating here\nfloat noise(vec2 a)\n{\n    float b = 0.;\n    b += texture(iChannel0, a*.25).r*.5;\n    b += texture(iChannel0, a*.5).r*.25;\n    b += texture(iChannel0, a*1.).r*.125;\n    b += texture(iChannel0, a*2.).r*.0625;\n    return b*.6+.2;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n    float c =cos(b);\n    float s =sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p = abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat upperroof(vec3 p)\n{\n    p.y -= .3;\n    float d = sdBox(p,vec3(6,.05,1));\n    d = min(d, sdBox(p-vec3(0,.1,0),vec3(6.1,.05,1.1)));\n    d = min(d, sdBox(p-vec3(0,.2,0),vec3(6.2,.05,1.2)));\n\n    d = min(d, sdBox(p-vec3(0,.4,0),vec3(5.3,.05,.3)));\n    d = min(d, sdBox(p-vec3(0,.5,0),vec3(5.4,.05,.4)));\n    d = min(d, sdBox(p-vec3(0,.6,0),vec3(5.5,.05,.5)));\n\n    p.x = abs(abs(abs(abs(p.x)-2.1)-2.1)-1.05)-.525;\n    p.z = abs(p.z)-.5;\n    p.y+=.5;\n    d = min(d, sdBox(p, vec3(.05,.5,.05)));\n\n    return d;\n}\n\nfloat roof(vec3 p)\n{\n    p.y-=7.05;\n    float upper = upperroof(p);\n\n    p.y -= (p.x*p.x)*.001;\n    p.z = -abs(p.z);\n    p.x=5.-abs(p.x);\n    p.xz = p.x>p.z?p.xz:p.zx;\n\n    p.yz = rotate(p.yz, pi/6.8);\n\n    float surface = abs(p.y + cos(p.x*6.*pi)*.05)-.04;\n    vec3 np = p;\n    np.x = mod(p.x, 1.)-.5;\n    float surface2 = sdBox(np-vec3(0,.1,0),vec3(.05,.02,4));\n    surface = max(surface, -(length(p.xz+vec2(-5,25))-22.2));\n    surface2 = max(surface2, -(length(p.xz+vec2(-5,25))-22.05)); \n    surface = min(surface, surface2);\n    return min(max(surface,-4.-p.z), upper);\n}\n\nfloat column(vec3 p)\n{\n    p.xz = abs(p.xz);\n\n    p.xz -= .3;\n    p.xz = abs(p.xz);\n\n    float cheap = sdBox(p,vec3(.5,6,.5));\n    if(cheap > .1) return cheap;\n\n    if(p.y>3.&&p.y<5.){\n        p.xz *= 1. + cos(p.y*20.)*.05;\n    }else if(p.y>5.5){\n        p.xz /= 1.+(p.y-5.5);\n    }\n    float d = sdBox(p,vec3(.28,10,.28));\n    d = max(d, -sdBox(p-vec3(.25,3,.25),vec3(.04,2,.04)));\n    d = min(d, sdBox(p,vec3(.37,.1,.37)));\n    d = min(d, sdBox(p,vec3(.33,.2,.33)));\n    d = max(d, -sdBox(p-vec3(0,4,0), vec3(.5)));\n    d = min(d, length(p.xz)-.28);\n    p.xz = p.x>p.z?p.xz:p.zx;\n    //d = max(d, -sdBox(p-vec3(1,2,0),vec3(.75,.95,.17)));\n\n\n    // cut the top off\n    return max(d,p.y-5.9);\n}\n\nfloat columns(vec3 p)\n{\n    p=abs(p);\n    p.xz-= vec2(4,1.6);\n    p=abs(p);\n    p.x-= 2.;\n    return column(p);\n}\n\nfloat ground(vec3 p)\n{\n    if (p.y>.1)\n        return p.y;\n\n    float s = .005*pow(.9,length(p.xz));\n    float displacement = 0.;//sin(columns(vec3(p.x,0,p.z))*10. - iTime*10.);\n    displacement += sin(length(p.xz-vec2(6,0))*5.-iTime*10.);\n    displacement += sin(length(p.xz+vec2(6,0))*4.-iTime*10.);\n    return p.y + displacement * s;\n    //return p.y + sin(p.x*10.)*s+ sin(p.z*10.)*s;\n}\n\nint mat;\n\nfloat scene(vec3 p)\n{\n    //return min(ground(p),column(p));\n    float a = min(\n        roof(p),\n        columns(p)\n    );\n    float b = ground(p);\n    mat = a<b?0:1;\n    return min(a,b);\n}\n\nvec3 skycolor(vec3 dir, vec3 accum)\n{\n    float nois = noise(vec2(dir.y, 2.*atan(dir.x,dir.z)/pi));\n    //nois *= 1.-pow(abs(dir.y),.5)*.2;\n    nois *= 1.-pow(abs(dir.y*.6),.7)*2.5;\n    //return vec3(nois);\n    //return accum * mix(vec3(1,.3,.05),vec3(2,.02,.01),nois*3);\n    return accum * (pow(vec3(nois*2.), vec3(1,2.5,5)) + vec3(.4,0,0)) + smoothstep(.02,.0,abs(dir.y))*.2;\n    return accum * vec3(1);\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n    vec3 sky = skycolor(dir,accum);\n    float fog = 0.;\n    for(int b=0;b<2;++b){\n        float t = 0.;\n        float k = 0.;\n        int i;\n        for(i=0;i<250;++i)\n        {\n            k = scene(cam+dir*t);\n            t+=k;\n            if(k<.001)\n                break;\n        }\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001,0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n\n        //return n*.5+.5;\n\n        if (k >= .001)\n        { // sky\n            return mix(sky,skycolor(dir,accum),fog);\n        }\n        else if (mat == 0)\n        {\n            //return vec3(pow(1.-dot(-dir,n),1.));\n            float light = pow(float(i)/100.,3.)*.99+.01;\n            //light += dot(n,normalize(vec3(1,3,1)))*.1;\n            return sky*vec3(light);\n            //  return vec3(n.yyy*.5+.5);\n        }\n        else\n        {\n            dir = reflect(dir,n);\n            cam = h + dir * .01;\n            //accum *= .3;\n            accum *= mix(vec3(1),sky,pow(.8,t));\n            fog = pow(.95,t);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,2,-30);\n    vec3 dir = normalize(vec3(uv,1.5));\n\n    dir.yz = rotate(dir.yz, -.05);\n\n    // cam.yz = rotate(cam.yz, .3);\n    // dir.yz = rotate(dir.yz, .3);\n    // cam.xz = rotate(cam.xz, -pi/4);\n    // dir.xz = rotate(dir.xz, -pi/4);\n\n    cam.xz = rotate(cam.xz, iTime*.1);\n    dir.xz = rotate(dir.xz, iTime*.1);\n\n    out_color.rgb = trace(cam,dir);\n    out_color.rgb = pow(out_color.rgb, vec3(.45));\n    out_color.rgb = pow(out_color.rgb, vec3(1)+2.*dot(uv,uv));\n    out_color.rgb *= 1.-dot(uv,uv)*.3;\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdB3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 422, 443, 443, 650], [652, 652, 682, 682, 803], [805, 805, 834, 834, 888], [890, 890, 915, 915, 1402], [1404, 1404, 1424, 1424, 1980], [1982, 1982, 2004, 2004, 2676], [2678, 2678, 2701, 2701, 2791], [2793, 2793, 2815, 2815, 3182], [3194, 3194, 3215, 3254, 3383], [3385, 3385, 3422, 3422, 3792], [3794, 3794, 3826, 3826, 5025], [5027, 5027, 5079, 5079, 5698]]}
{"id": "tdB3zV", "name": "sacred shrubs", "author": "ukeyshima", "description": "sacred shrubs", "tags": ["raymarching", "cineshader"], "likes": 2, "viewed": 5098, "published": "Public API", "date": "1549359228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\nvec3 cPos = vec3(0.0, 0.0, -10.0);\nconst vec3 cDir = vec3(0.0, 0.0, 1.0);\nconst vec3 cUp = vec3(0.0, 1.0, 0.0);\nconst float depth = 1.0;\nconst vec3 lPos = vec3(10.0, 10.0, -10.0);\nconst float ambientColor = 0.5;\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m =\n      mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s,\n           a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s,\n           a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n  return m * p;\n}\n\nfloat fractalDistFunc(vec3 p) {\n  p = rotate(p, 0.3 - 0.015 * iTime, vec3(0.0, 0.0, 1.0));\n  float r = 1.9;\n  p.y = mod(p.y, 6.0) - 3.0;\n  p.xz = mod(p.xz, 3.0) - 1.5;\n  for (float i = 0.0; i < 8.0; i++) {\n    p = abs(p) - vec3(1.1 * mix(2.0, 0.6,\n                                smoothstep(abs(mod(iTime * 10.0, 100.0) - 50.0),\n                                           0.0, 1.0)),\n                      0.5, 2.7);\n    float s = clamp(length(p), 0.17, 0.91);\n    p = p / s;\n    p -= vec3(0.5, 1.8, 0.2) * exp(-i);\n    r /= s;\n  }\n  return length(p / r);\n}\n\nfloat distFunc(vec3 p) { return fractalDistFunc(p); }\n\nvec3 getNormal(vec3 p) {\n  float d = 0.001;\n  return normalize(\n      vec3(distFunc(p + vec3(d, 0.0, 0.0)) - distFunc(p + vec3(-d, 0.0, 0.0)),\n           distFunc(p + vec3(0.0, d, 0.0)) - distFunc(p + vec3(0.0, -d, 0.0)),\n           distFunc(p + vec3(0.0, 0.0, d)) - distFunc(p + vec3(0.0, 0.0, -d))));\n}\n\nvec4 rayMarching(vec3 color, vec2 p) {\n  cPos.z += iTime / 3.0;\n  vec3 cSide = cross(cDir, cUp);\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * depth);\n  vec3 rPos = cPos;\n  float rLen = 0.0;\n  for (float i = 0.0; i < 100.0; i++) {\n    float distance = distFunc(rPos);\n    if (abs(distance) < 0.01) {\n      vec3 normal = getNormal(rPos);\n      vec3 halfLE = normalize(lPos + rPos);\n      float specular = pow(clamp(dot(normal, halfLE), 0.0, 0.1), 20.0);\n      float diffuse = clamp(dot(normal, lPos), 0.0, 1.0) + 0.2;\n      color = (vec3(0.8 * sin(rPos.z + iTime / 50.0 - 5.0),\n                    0.2 * cos(rPos.y + iTime / 70.0 - 2.0),\n                    0.3 * cos(rPos.z * iTime / 80.0)) *\n                   diffuse +\n               specular + ambientColor);\n      break;\n    }\n    rLen += distance * 1.2;\n    rPos = cPos + rLen * ray;\n  }\n  return vec4(color,1.0-clamp(rLen,0.0,1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p =\n      (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec4 color = rayMarching(vec3(0.1), p);\n  fragColor = color;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"sacred shrubs\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdB3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 284, 284, 651], [653, 653, 684, 684, 1210], [1212, 1212, 1236, 1236, 1265], [1267, 1267, 1291, 1291, 1571], [1573, 1573, 1611, 1611, 2474], [2476, 2476, 2531, 2531, 2688]]}
{"id": "tdBGDc", "name": "Raymarching twisted columns", "author": "darkeclipz", "description": "raymarching twisted columns.", "tags": ["raymarch"], "likes": 4, "viewed": 154, "published": "Public", "date": "1550130040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 64.\n#define MinDistance 0.01\n#define eps 0.001\n\n#define red vec3(227./255., 10./255., 4./255.)\n#define yellow vec3(250./255., 100./255., 1./255.)\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdYPlane(vec3 p, float y) { return p.y - y; }\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n// from IQ\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 map(vec3 p) {\n    //mat3 rot = rotateZ(0.13*p.z);\n    //p *= rot;\n    float x = fract(p.x) - 0.5;\n    float z = fract(p.z) - 0.5;\n    return vec3(x, p.y, z);\n}\n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n\tp = map(p);\n    float outerSphere = sdSphere(p - vec3(0,-0.5,0), .20); \n    \n    float plane = sdPlane(p - vec3(0,0,0), normalize(vec4(0,1,0,0.5)));\n    float yPlane = sdYPlane(p, -0.5);\n    \n    mat3 ry = rotateY(3.*p.y);\n    float box = sdBox(ry*p, vec3(.05, 1, .05));\n    \n    \n    yPlane = min(yPlane, box);\n    \n    return smin(yPlane, outerSphere, 0.15);\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                  k.yyx*scene( p + k.yyx*h ) + \n                  k.yxy*scene( p + k.yxy*h ) + \n                  k.xxx*scene( p + k.xxx*h ) );    \n    return n;\n}\n    \nfloat march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = scene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;  \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n       \n    mat3 rot = rotateY(iTime);\n    mat3 rot2 = rotateY(iTime);\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, rot*vec3(5) + vec3(0,0,iTime*2.), 35., red);\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, rot2*vec3(-5, 5, -5) + vec3(0,0,iTime*2.), 20., yellow);\n    \n    vec3 ambient = vec3(.1);\n    \n    return L1 + L2 + ambient;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,1,-5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n    mat3 rot = rotateY(cos(iTime/8.));\n    //rd *= rot;\n\n    ro += vec3(0,0,iTime*2.);\n    float t = march(ro, rd);\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n        float fog = 1. / (1. + t * t * 0.02);\n        col = mix(vec3(0), col, fog);\n        //col = n*.5+.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 216, 216, 302], [304, 304, 331, 331, 409], [411, 411, 444, 444, 468], [469, 469, 502, 502, 520], [521, 521, 550, 550, 606], [607, 618, 651, 677, 708], [710, 710, 728, 780, 874], [876, 907, 948, 948, 1041], [1043, 1043, 1064, 1064, 1428], [1430, 1430, 1455, 1455, 1720], [1726, 1726, 1757, 1757, 1988], [1990, 2057, 2164, 2164, 2922], [2924, 2924, 2962, 2962, 3293], [3295, 3295, 3352, 3352, 3870]]}
{"id": "tdfSDn", "name": "Human Visual Acuity, FAZ", "author": "4rknova", "description": "A perception experiment to help visualize the foveal avascular zone (FAZ) of the human eye.\nLooking close at the fading pattern, the perception of the change weakens towards the eye's peripheral vision.\nhttps://en.wikipedia.org/wiki/Peripheral_vision", "tags": ["experiment", "illusion", "foveated"], "likes": 3, "viewed": 224, "published": "Public", "date": "1551029106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ZOOM (7.5)\n#define WGHT (0.1)\n#define T (iTime)\n#define R (iResolution.xy)\n\n#define HASH(p) (fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123))\n#define CIRCLE(p, c, r) (abs(r - length(p - c)))\n\nfloat sharpen(in float d, in float w)\n{\n    /* The division is specific to wide aspect ratio.\n\t** Replace with min(R.x,R.y) if in portrait mode.\n\t** Same goes for aspect ratio correction below.\n    */\n    float e = 1.5 * ZOOM / R.y;\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat df_pattern(vec2 uv)\n{\n    float l1 = sharpen(CIRCLE(uv, vec2(0), .5), WGHT);\n    float l2 = sharpen(CIRCLE(uv, vec2(1), .5), WGHT);\n    return max(l1,l2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord/R*2.-1.) * ZOOM * vec2(R.x/R.y,1.); \n    vec2 st = floor(uv), p = fract(uv);    \n    float k0 = step(.5, HASH(st + floor(T+1.0)));\n    float k1 = step(.5, HASH(st + floor(T+2.0)));    \n    vec2 s0 = vec2(k0 + p.x - 2.*k0*p.x, p.y);\n    vec2 s1 = vec2(k1 + p.x - 2.*k1*p.x, p.y);\n    vec3 c = vec3(mix(df_pattern(s0), df_pattern(s1),fract(iTime)));\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfSDn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 326, 365, 526, 602], [604, 604, 631, 631, 766], [768, 768, 823, 823, 1223]]}
{"id": "tdfSR7", "name": "Mandelbrot Set Live Demo", "author": "mathmasterzach", "description": "Programmed live during a Shadertoy Tutorial Session at Villanova University that I taught.", "tags": ["fractal", "mandelbrot", "demo", "set", "live"], "likes": 1, "viewed": 293, "published": "Public API", "date": "1550952835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Programmed live during a Shadertoy Tutorial Session at Villanova University\nfloat STEPS=64.;\nfloat PI=acos(-1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 c = fragCoord/iResolution.xy;\n    c=2.*c-1.;\n    c.x*=iResolution.x/iResolution.y;\n    c/=pow(2.,8.5*(-cos(PI*iTime/8.)+1.));\n    c+=vec2(-.602,-.665);\n   \tvec2 z = vec2(0);\n    float i;\n    for(i=0.;i<STEPS;i++){\n    \tvec2 tz=c+vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y);\n        z=tz;\n        if(length(z)>2.){\n        \tbreak;\n        }\n    }\n    float ic=5.*i/STEPS;\n    vec3 col=vec3(cos(1.-ic),cos(2.-ic),cos(3.-ic));\n    //alternate color scheme\n    //vec3 col=vec3(cos(1.-ic)+1.,cos(2.-ic)+1.,cos(3.-ic)+1.)/2.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 171, 171, 722]]}
{"id": "tdfSW7", "name": "[TWITCH] The seal", "author": "Flopine", "description": "The result of the 8th twitch live session! Again heavily inspired by Zelda... I promise this will be the last time! ... or maybe not :P \nHere is the link to the stream: https://www.twitch.tv/videos/388255723", "tags": ["raymarching", "modeling", "zelda", "twitch"], "likes": 8, "viewed": 202, "published": "Public", "date": "1551394619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n#define time iTime\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat rand (float x)\n{return fract(sin(x)*154845.4845);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n  float per = 2.*PI/rep;\n  float a = atan(p.y,p.x);\n  float l = length(p);\n  float id = floor(a/per);\n  a = mod(a,per)-per*0.5;\n  p = vec2(cos(a),sin(a))*l;\n  if (abs(id) >= rep/2.) id = abs(id);\n  return id;\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cylH (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(max(q.x,max(q.y,q.z)),0.) + length(max(q, 0.));\n}\n\nfloat id;\nfloat tentacles (vec3 p)\n{\n  p.y += 4.;\n  id = moda(p.xz, 7.);\n  float offset = mix (0.,1.+sin(p.y*0.5+time)*0.5, smoothstep(5.,1.,p.y));\n  p.x -= offset;\n  return cylH(p.xzy, 0.3+p.y*0.06, 5.);\n}\n\nfloat gem (vec3 p)\n{\n  p.y -= 1.5;\n  float pedestral = stmin(box(p,vec3(1., 0.5, 1.)), od(p,0.8), 0.5, 5.);\n  p.xz *= rot(time);\n  float o1 = od(vec3(p.x,p.y-4.5+sin(time)*0.2,p.z), 0.9);\n  return stmin(pedestral, o1, 1.2, 4.);\n}\n\nfloat seal (vec3 p)\n{\n  p *= 1.3;\n  p.y -= 9.;\n  p.x = abs(p.x);\n  p.x -= 5.;\n\n  vec3 pp = p;\n  p.x += p.y * p.y * 0.12;\n  float sticks = box(p, vec3(.9-p.y*0.18,4., 0.15));\n  \n  p = pp;\n  p.xy *= rot(PI/9.);\n  p.x -= 4.;\n  p.y -= 1.8;\n  float b1 = box(vec3(p.x-p.y*0.7, p.y , p.z), vec3(4., 1.+p.x*0.1, 0.15)); \n\n  p = pp;\n  p.x -= 2.5;\n  p.y += 0.6;\n  float b2 = box(vec3(p.x-p.y*0.7, p.y , p.z), vec3(2.8, .8+p.x*0.1, 0.15)); \n\n  p = pp;\n  p.x -= 1.;\n  p.y += 3.;\n  p.xy *= rot(-PI/10.);\n  float b3 = box(vec3(p.x-p.y*0.7, p.y , p.z), vec3(2., .6+p.x*0.1, 0.15)); \n\n  return min(b3,min(b2,min(sticks, b1)))/1.3;\n}\n\nint mat;\nfloat SDF (vec3 p)\n{\n  p.y += sin(time)*0.2;\n  p.xz *= rot(time*0.2);\n  float s = seal(p);\n  float t = tentacles(p);\n  float g = gem(p);\n  float d = min(s,stmin(t,g, 0.2, 2.));\n  \n  if (d == s) mat = 1;\n  if (d == t) mat = 2;\n  if (d == g) mat = 3;\n\n  return d;\n}\n\nvec3 get_cam(vec3 ro, vec3 tar, vec2 uv, float fov)\n{\n  vec3 forward = normalize(tar-ro);\n  vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n  vec3  up = normalize(cross(forward, left));\n  return normalize(forward * fov + left*uv.x + up * uv.y);\n}\n\nvec3 get_norm (vec3 p)\n{\n  vec2 eps = vec2(0.001,0.);\n  return normalize(vec3(SDF(p+eps.xyy) - SDF(p-eps.xyy),\n                      SDF(p+eps.yxy) - SDF(p-eps.yxy),\n                      SDF(p+eps.yyx) - SDF(p-eps.yyx)\n                      )\n                );\n}\n\nfloat dir_light(vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5 + 0.5;}\n\nfloat spec_light (vec3 rd, vec3 n, vec3 lpos, float spec_pow)\n{\n  vec3 h = normalize(lpos-rd);\n  return pow(max(dot(n,h),0.), spec_pow);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(2.,-6.,-22.), p = ro;\n  vec3 tar = vec3(0.,1. ,0.);\n  vec3 rd = get_cam(ro, tar, uv,1.);\n  vec3 col = vec3(0.);\n  float shad = 0.;\n  bool hit = false;\n\n  for (float i=0.; i<ITER; i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      break;\n    }\n\n    p+= d*rd*0.8;\n  }\n\n  if (hit)\n  {\n    vec3 n = get_norm(p);\n    vec3 keypos = vec3(2., 2., -3.);\n    vec3 rimpos = vec3(0., -1., 4.);\n    \n    float fre = pow(clamp(1.-dot(n, -rd),0.,1.), 5.); \n    float keylight = dir_light(n, keypos);\n    float rimlight = dir_light(n, rimpos);\n\n    if (mat == 1) \n    {\n      vec3 albedo = vec3(.8,0.8,1.);\n        col += albedo * keylight * vec3(0.9,0.9, 0.8);\n        col += albedo * rimlight*vec3(0.5,0.6, 0.8);\n        col += spec_light(rd, n, keypos, 2.)*keylight;\n    }\n    if (mat == 2) \n    {\n      vec3 albedo = vec3(rand(floor(id*7.))*.9,1.,rand(floor(id*7.))*.5);\n      col += albedo * keylight * vec3(0.9,0.9, 0.8);\n      col += albedo * rimlight*vec3(0.5,0.6, 0.8);\n      col += spec_light(rd, n, keypos, 2.)*keylight;\n      col /= 2.;\n    }\n\n    if (mat == 3)\n    {\n      vec3 albedo = vec3(1.,0.9,0.1);\n      col += albedo * keylight * vec3(0.9,0.9, 0.8);\n      col += albedo * spec_light(rd, n, keypos, 5.)*0.3;\n      col += albedo * vec3(0.8,0.4,0.1) * spec_light(rd, n, keypos, 18.)*10.;\n      col += fre*vec3(1.,0.8,0.);\n      col /= 2.;\n    } \n  }\n  float t = length(ro-p);\n  col *= 1.-shad;\n    \n  // suggested by LJ: thank youuuuuuuu <3\n  float texnoise = texNoise(uv+vec2(sin(time*0.05), time*0.05)).r; \n  col = pow(mix(col, vec3(0.9,0.8,1.-length(uv)*0.5), 1.-exp(-0.0005*t*t) +texnoise),vec3(0.8));\n  \n  fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 372, 396, 396, 634], [636, 636, 658, 658, 692], [694, 694, 744, 744, 844], [846, 846, 884, 884, 1095], [1097, 1097, 1116, 1116, 1159], [1161, 1161, 1200, 1200, 1240], [1242, 1242, 1270, 1270, 1307], [1309, 1309, 1337, 1337, 1421], [1433, 1433, 1459, 1459, 1629], [1631, 1631, 1651, 1651, 1860], [1862, 1862, 1883, 1883, 2478], [2489, 2489, 2509, 2509, 2752], [2754, 2754, 2807, 2807, 3007], [3009, 3009, 3033, 3033, 3273], [3275, 3275, 3308, 3308, 3347], [3349, 3349, 3412, 3412, 3490], [3492, 3492, 3549, 3549, 5372]]}
{"id": "tdfSWn", "name": "Space GIF Test", "author": "IsaacAndersen", "description": "playing around with some help from: https://www.youtube.com/watch?v=cQXAbndD5CQ", "tags": ["test"], "likes": 2, "viewed": 79, "published": "Public", "date": "1551052355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= iResolution.x / iResolution.y;\n    \n    //vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.xy;\n    float t = 3.1415*iTime;\n    \n    vec3 col = vec3(0.0);\n    \n    uv *= 2.5-2.0*sin((floor(t/4.0) + fract(t/4.0)));\n    \n   \tfloat angle = (3.1415/4.0)* (floor(t/4.0) + quadraticInOut(fract(t/4.0)));\n    \n    \n    float s = sin(angle);\n    float c = cos(angle);\n    \n    uv *= mat2(c, -s, s, c);\n    \n    \n    vec2 gv = fract(uv);\n    \n     gv.x += 0.01*sin(16.0*3.14*gv.x);\n    gv.y += 0.05*cos(16.0*3.14*gv.y);\n    \n    vec2 id = floor(uv); // uniquely identifies each cell\n    \n    for (int k = 0; k < 3; k++) {\n        float m = 0.0;\n        t += 0.2;\n        for (float i = -1.; i <= 1.; i++) {\n            for (float j = -1.; j <= 1.; j++) {\n                vec2 offset = vec2(j,i);\n\n                float d = length(gv+offset);//((gv+offset).x + (gv+offset).y)/4.0;\n                float dist = length(id-offset);//((id-offset.xy).x + (id-offset.xy).y)/4.0;\n                \n                float d2 = length(0.11/gv.xx + 0.1/gv.yy);\n                \n                float specialDist = 0.9+0.05*sin(-t+dist);\n\n                float r = mix(0.3,.75,.5*sin(-t+dist)+.5);\n                \n                \n                float c = smoothstep(r,r*specialDist,(d-abs((0.5-gv.x)*(0.5-gv.y))));\n\n                m =  m*(1.0-c) + c*(1.0-m);\n            }\n        }\n\t\tcol[k] += m;\n    }\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 103], [105, 105, 132, 132, 216], [218, 218, 242, 242, 264], [266, 266, 323, 323, 1820]]}
{"id": "tdfXzn", "name": "MCG: Transforming Yin-Yang pt1", "author": "tale3d", "description": "In the first lecture about transformations we discuss linear transformations. ", "tags": ["teachingmaterial"], "likes": 0, "viewed": 44, "published": "Public", "date": "1550581172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Mathematics for Computer Graphics (CATA programme, 1st year)\n//Supplement material for the lecture \"Linear transformations\"\n\n//This code heavily re-uses the very first example, from the lecture about sets. \n\n//Some comments therefore are copied from that example.\n\n//defining a simple primitive - disk\n//first argument of this function is a pixel coordinates in the world space\n//second argument is the centre of the disk\n//and the third is the radius\nfloat disk(in vec2 position, in vec2 centre, in float radius)\n{\n    //we will discuss circle equation in few weeks' time\n    float pcx = position.x - centre.x;\n    float pcy = position.y - centre.y;\n    if (pcx*pcx + pcy*pcy - radius*radius < 0.0)\n        return -1.0; //in\n    return 1.0; //out\n}\n\n//set-theoretic intersection\nfloat csg_intersection(in float shape1, in float shape2)\n{\n    //pixel is inside both primitives (point sets)\n    if (shape1 < 0.0 && shape2 < 0.0) \n        return -1.0; //in\n    \n    return 1.0; //out    \n}\n\n//set-theoretic union\nfloat csg_union(in float shape1, in float shape2)\n{\n    //the pixel is inside either primitive (point set)\n    if (shape1 < 0.0 || shape2 < 0.0)\n        return -1.0; //in\n    \n    return 1.0; //out    \n}\n\n//set-theoretic difference\nfloat csg_difference(in float shape1, in float shape2)\n{\n    //the pixel is inside first primitive, but outside second\n    if (shape1 < 0.0 && shape2 > 0.0)\n        return -1.0; //in\n    \n    return 1.0; //out    \n}\n\n//The parameters for the shapes in this example are fixed\nfloat radius1(in float t)\n{\n    return 0.5;\n}\nvec2 position2(in float t)\n{\n   \treturn vec2(0.0,0.0);\n}\nvec2 position3(in float t)\n{\n    return vec2(0.0, 0.25);\n}\nvec2 position4(in float t)\n{\n    return vec2(0.0, -0.25);\n}\n\n//Here goes the main function, which is applied for every pixel in our window\n//It takes the pixel coordinates as an argument\n//And returns the colour of the given pixel.\n//Below we see how we can define our shape by using mathemaics in code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n    \n  \n    //In this example we are going to rotate the point set around the point (0.5, 0.2)\n    //The angle is defined by the time variable\n    float theta = iTime;\n    \n    //Note that in the lecture I am using cx and cy to denote the centre of rotation.\n    //Here I have already used these variables for pixel position, so I am using px and py instead.\n    float px = 0.5, py = 0.2;\n    \n    //I could do that in three steps (move-rotate-move back), but instead I am using\n    //   the resulting equation (refer to lectures)\n    float cxi = (c.x-px)*cos(theta)-(c.y-py)*sin(theta)+px;\n    float cyi = (c.x-px)*sin(theta)+(c.y-py)*cos(theta)+py;\n\n    //cxi and cyi store transformed position of the current pixel. \n    c.x = cxi; c.y = cyi;\n    \n    \n    //As we have to return the colour, we have to set up one by default\n    vec3 colour = vec3(1.0, 1.0, 1.0); //it is basically white background colour\n\n    //Here we are going to define our primitives and set-theoretic operations\n    //resulting_object is the value for the pixel with respect to the object we define.\n    float resulting_object;\n    //The convention for all the point sets will be the following:\n    //If the pixel is in the point set, its value is -1.0\n    //Otherwise its value is 1.0\n\n    //We initialise our final object by all the pixels whose x coordinate is greater than 0\n    //Effectively we define the point set defining a half-space\n    if (c.x > 0.0) resulting_object = -1.0;\n    else resulting_object = 1.0;\n    \n    //the first disk, which has the centre in (0,0) and radius defined above\n    //the value of the function denotes whether the given pixel is inside the disk or outside \n    float disk1 = disk(c, vec2(0,0), radius1(iTime)); \n\n    //intersect the first circle with the half-space results in half-disk\n    resulting_object = csg_intersection(resulting_object, disk1);\n\n    //adding two more disks, one will be \"added\" by using union operation, \n    //another will be \"subtracted\" by using difference operation\n    float disk3 = disk(c, position3(iTime), 0.25);\n    float disk4 = disk(c, position4(iTime), 0.25);\n    //note that we apply the result of the operation to previously defined value\n    resulting_object = csg_difference(resulting_object, disk3);\n    resulting_object = csg_union(resulting_object, disk4);\n\n    //the second circle, radius 0.5\n    float disk2a = disk(c, position2(iTime), 0.5);\n    float disk2b = disk(c, position2(iTime), 0.48);\n\n    //doing a set-theoretic difference\n    float disk12 = csg_difference(disk2a, disk2b);\n    //...and few more operations\n    resulting_object = csg_union(resulting_object, disk12);\n    float disk3a = disk(c, vec2(0.0, 0.25), 0.05);\n    resulting_object = csg_union(resulting_object, disk3a);\n    float disk4a = disk(c, vec2(0.0, -0.25), 0.05);\n    resulting_object = csg_difference(resulting_object, disk4a);\n\n    //So in here we have defined if the point is in the point set or not and colour it black if it is \n    if (resulting_object < 0.0) colour = vec3(0.0,0.0,0.0); \n        \n\tfragColor = vec4(colour,1.0); //set the colour of the pixel\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 454, 517, 574, 751], [753, 782, 840, 891, 989], [991, 1013, 1064, 1119, 1216], [1218, 1245, 1301, 1363, 1460], [1462, 1520, 1547, 1547, 1565], [1566, 1566, 1594, 1594, 1622], [1623, 1623, 1651, 1651, 1681], [1682, 1682, 1710, 1710, 1741], [1743, 1986, 2043, 2390, 5830]]}
{"id": "tdj3WG", "name": "cell2", "author": "sshinderman", "description": "yet another cell ... using second order distance to find edge.", "tags": ["cellnoise"], "likes": 5, "viewed": 133, "published": "Public", "date": "1549914754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand1(vec2 n) {\n    return fract(abs(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453));\n}\n\nfloat rand2(vec2 n) {\n    return fract(abs(sin(dot(n, vec2(92.198, 103.114 + 1000.0))) * 147583.5453));\n}\n\nvec2 getRandomCenter( vec2 index )\n{\n    float c1 = rand1( index );\n    float c2 = rand2( index );\n\n    return vec2(c1, c2);\n}\n\nvec2 getRandomCenterWithMotion( vec2 index, float time )\n{\n    float c1 = rand1( index );\n    float c2 = rand2( index );\n\n    float theta = (c1 * c2 - .5) * time * 3.14159;\n   \tc1 += 0.25 * cos(theta);\n   \tc2 += 0.25 * sin(theta);\n        \n    return vec2(c1, c2);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;  ///iResolution.xy;\n\n    // Time varying pixel color\n//     vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tfloat scale = 1.0 / 20.0;\n    float t = iTime;\n    \n    vec2 tileCoord = fract(uv * scale);\n    vec2 tileIndex = vec2( floor( uv * scale ));\n    \n    float minDistance = 1e20;\n    float secondDistance = 1e20;\n    vec2 secondIndex = vec2(0,0);\n    vec2 minIndex = vec2(0,0);\n    vec2 minCenter = vec2(0,0);\n    vec2 secondCenter = vec2(0,0);\n\n    for (int j=-1;  j <= 1;  j++)\n    {\n        for (int i=-1;  i <= 1;  i++)\n        {\n            vec2 offset = vec2( i, j );\n            vec2 center = getRandomCenterWithMotion( tileIndex + offset, t ) + offset;\n            vec2 diff = tileCoord - center;\n\n            float distance = dot(diff,diff);\n            if (distance < minDistance)\n            {\n                secondDistance = minDistance;\n                secondIndex = minIndex;\n                secondCenter = minCenter;\n                \n                minDistance = distance;\n                minIndex = tileIndex + offset;\n                minCenter = center;\n            } \n            else if (distance < secondDistance)\n            {\n               secondDistance = distance;\n               secondIndex = tileIndex + offset;\n               secondCenter = center;\n            }            \n        }\n    }\n\n    \n    float d1 = sqrt(minDistance);\n    float d2 = sqrt(secondDistance);    \n    //float halfway = 0.5 * length(minCenter - secondCenter);\n    \n    vec2 dir = normalize(secondCenter - minCenter);\n    vec2 midpoint = 0.5 * ( minCenter + secondCenter );\n    float distToEdge = 1.0 - abs(dot(tileCoord - midpoint, dir));\n    \n    float c  = smoothstep( 0.95, 1.0, distToEdge);\n    // colorize the cell\n    float c2 = (1.0-c) * rand1( minIndex );\n\n    vec4 resultColor = vec4(c2,c2,c2, 1.0 );\n    \n    \n    // Output to screen\n    fragColor = resultColor;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdj3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 95], [97, 97, 118, 118, 202], [204, 204, 240, 240, 330], [332, 332, 390, 390, 598], [602, 602, 659, 709, 2622]]}
{"id": "tdj3Ww", "name": "Almost a Sun", "author": "martinsh", "description": " a work in progress sun surface shader", "tags": ["sun", "star"], "likes": 10, "viewed": 214, "published": "Public", "date": "1550587800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//attempts to simulate Sun`s limb darkening \n//https://en.wikipedia.org/wiki/Limb_darkening\n//https://hesperia.gsfc.nasa.gov/ssw/gen/idl/solar/darklimb_correct.pro\n\n//https://hesperia.gsfc.nasa.gov/ssw/gen/idl/solar/darklimb_u.pro\n//https://hesperia.gsfc.nasa.gov/ssw/gen/idl/solar/darklimb_v.pro\n//not really giving me the results I`d like to see :/\n//i`m surely doing something wrong here\n\n//i have to revisit this one\n//http://www.physics.hmc.edu/faculty/esin/a101/limbdarkening.pdf\n#define time iTime*2.0\n\nfloat gamma = 2.2;\nfloat scale = 1.0;\nfloat exposure = 40.2;\n\nvec3 sunColor = vec3(1.0,0.14,0.01); //artistic value\n\nvec2 darklimbUlVl(float wavelength)\n{\n    float ll = wavelength; //wavelength in Angstroms (lambda)\n\n    float au = -8.9829751;\n    float bu = 0.0069093916;\n    float cu = -1.8144591e-6;\n    float du = 2.2540875e-10;\n    float eu = -1.3389747e-14;\n    float fu = 3.0453572e-19;\n\n    float av = 9.2891180;\n    float bv = -0.0062212632;\n    float cv = 1.5788029e-6;\n    float dv = -1.9359644e-10;\n    float ev = 1.1444469e-14;\n    float fv = -2.599494e-19;\n\n    float ul = au+(bu*ll)+(cu*pow(ll,2.0))+(du*pow(ll,3.0))+(eu*pow(ll,4.0))+(fu*pow(ll,5.0));\n    float vl = av+(bv*ll)+(cv*pow(ll,2.0))+(dv*pow(ll,3.0))+(ev*pow(ll,4.0))+(fv*pow(ll,5.0));\n    return vec2(ul,vl);\n}\n\nfloat limbDarkening(in float cosTheta)\n{\n    //values from somewhere in internet..\n\tfloat ul = 0.85;\n\tfloat vl = 0.65;\n    \n\tfloat sundisk = cosTheta;\n\tfloat limbfilt = 1.0 - ul - vl + ul*cos(asin(sundisk)) + vl*pow(cos(asin(sundisk)),2.0);\n    return limbfilt;\n}\n\nvec3 limbDarkening3(in float cosTheta)\n{\n\tfloat sundisk = cosTheta;\n    vec2 ulvlR = darklimbUlVl(6700.0); //red wavelength in Angstroms\n\tvec2 ulvlG = darklimbUlVl(5200.0); //green wavelength in Angstroms\n    vec2 ulvlB = darklimbUlVl(4500.0); //blue wavelength in Angstroms\n        \n\tfloat limbR = 1.0 - ulvlR.x - ulvlR.y + ulvlR.x*cos(asin(sundisk)) + ulvlR.y*pow(cos(asin(sundisk)),2.0);\n    float limbG = 1.0 - ulvlG.x - ulvlG.y + ulvlG.x*cos(asin(sundisk)) + ulvlG.y*pow(cos(asin(sundisk)),2.0);\n    float limbB = 1.0 - ulvlB.x - ulvlB.y + ulvlB.x*cos(asin(sundisk)) + ulvlB.y*pow(cos(asin(sundisk)),2.0);\n    return vec3(limbR,limbG,limbB);\n}\n\n\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p, vec3 n)\n{\n\tfloat f;\n    f  = 0.60000*pow((simplex3D( p*0.9 )),3.0)*0.4+0.6; p = p*2.01;\n    f += 0.35000*pow(abs(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(3.0))*3.0)),0.8 ); p = p*2.02; //from iq\n    //* 1.0 / pow(f*0.0002+0.9998,3.0)\n    f += 0.12500*pow(simplex3D( p*0.9 + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*3.0),2.0 ); p = p*2.03;\n    f += 0.1250*(simplex3D( p*0.6 + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*2.0) ); p = p*2.04;\n    f += 0.03125*(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(3.0))*3.0) );\n\treturn f;\n}\n\n#define ONE vec2(1.0, 0.0)\n#define EPS vec2(1e-3, 0.0)\n\nconst float pi = 3.1415926;\n\nfloat N(vec2 p)\n{\n   p = mod(p, 4.0);\n   return fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p)\n{\n\tvec2 fp = floor(p);\n\tvec2 pf = smoothstep(0.0, 1.0, fract(p));\n\treturn mix( mix(N(fp), N(fp + ONE), pf.x), \n\t\t\t   mix(N(fp + ONE.yx), N(fp + ONE.xx), pf.x), pf.y);\n}\n\n\nfloat fbm2(vec2 p)\n{\n\tfloat f = 0.0, x;\n\tfor(int i = 1; i <= 9; ++i)\n\t{\n\t\tx = exp2(float(i));\n\t\tf += smN2(p * x) / x;\n\t}\n\treturn f;\n}\n\n// Scalar field for the surface undulations.\n\nfloat spots(vec2 p)\n{\n\tp *= 2.5;\n\treturn smN2(p + EPS.xy * 2.0);\n}\n\nfloat field(vec2 p)\n{\n\tp *= 1.5;\n\treturn mix(smN2(p * 3.0), smN2(p * 4.0), 0.5 + 0.5 * cos(time * 0.02 + p.x*3.8 + 2.531)+ sin(time * 0.01 + p.y*4.2 + 1.536));\n}\n\nfloat field2(vec2 p)\n{\n\tp *= 6.5;\n\treturn mix(smN2(p * 2.0), smN2(p * 5.0), 0.5 + 0.5 * sin(time * 0.6 + p.x*2.0 + 83.123)+ cos(time * 0.5 + p.y*4.0 + 2.323));\n}\n\n// Vector field extracted from the scalar field.\nvec2 flow(vec2 p)\n{\n    vec2 flowout = vec2(0.0,0.0);\n\tfloat f0 = field(p);\n\tfloat f1 = field(p + EPS.xy);\n\tfloat f2 = field(p + EPS.yx);\n    flowout += (vec2(f1 - f0, f2 - f0)).yx * vec2(-1, 1) * 0.13;\n    float f20 = field2(p);\n\tfloat f21 = field2(p + EPS.xy);\n\tfloat f22 = field2(p + EPS.yx);\n    flowout += (vec2(f21 - f20, f22 - f20)).yx * vec2(-1, 1) * 0.005;\n\treturn flowout;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    scale *= (1.0-(iMouse.y / iResolution.y))+0.05;\n    exposure *= ((iMouse.x / iResolution.x))*0.5+0.01;\n    \n    vec2 R = iResolution.xy, \n         M = iMouse.xy/R;\n         U = (( U + U - R ) / R.y)*scale; \n    O -= O;\n    \n    \n    \n    float l = length(U),\n      dotNL = sqrt(1.-l*l),                // N = ( U.x, U.y, sqrt(1.-l*l) )\n          a = iTime;\n    //if ( M != vec2(0) ) wrap = M.x, shape = 4.*M.y;\n    \n    vec3 N = vec3( U.x, U.y, sqrt(1.-l*l) );\n    \n\tfloat sky = max(0.0,dot(U, U));\n    \n    float dotVL = dot(vec3(U,dotNL), vec3(sin(a),0,cos(a)) );    \n    vec3 sunpos = vec3(U,dotNL);\n\n\t\n\tvec2 uv = vec2(atan(sunpos.z, sunpos.x) / pi * 2.0, acos(sunpos.y) / pi * 2.0 - 1.0);\n    \n\tconst int count = 32;\n    float csum = 0.0;\n    float wsum = 0.0;\n    \n\tfor(int i = 0; i < count; ++i)\n\t{\n\t\tfloat w = 1.0;\n        uv += flow(uv);\n\t\tcsum += fbm(vec3(uv + vec2(csum*N.x*(1.0-N.z),csum*N.y*(1.0-N.z))*0.01,dotNL+time*0.002)*40.0, N) * 0.5 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n\t\twsum += w;\n\t\t\n\t\t\n\t}\n\n    float sunspot = pow(smoothstep(0.00,0.002,spots(uv)),3.0)*0.9+0.1;\n    float sunspot1 = pow(smoothstep(0.005,0.01,spots(uv)),3.0)*0.5+0.5;\n    \n \tO = vec4(1.0);\n\n    O.rgb = vec3(pow((csum/wsum)*1.0,1.2)*1.6);\n    O.rgb *= sunspot1;\n    O.rgb *= sunspot;\n    O.rgb /= pow(fbm(vec3(uv,dotNL+iTime*0.001)*80.0, N)*1.0,1.6)*0.9+0.1;\n\n    O.rgb *= limbDarkening3(sky)*sunColor*exposure;  \n\n    \n\n    O *= smoothstep(0.,3./R.y,1.-l); \n    O.rgb = pow(O.rgb,vec3(1.0/gamma));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdj3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 627, 664, 664, 1298], [1300, 1300, 1340, 1382, 1563], [1565, 1565, 1605, 1605, 2213], [2217, 2217, 2240, 2240, 2321], [2323, 2323, 2348, 2348, 4473], [4475, 4475, 4502, 4502, 5024], [5111, 5111, 5128, 5128, 5208], [5210, 5210, 5230, 5230, 5397], [5400, 5400, 5420, 5420, 5533], [5535, 5581, 5602, 5602, 5647], [5649, 5649, 5670, 5670, 5810], [5812, 5812, 5834, 5834, 5973], [5975, 6024, 6043, 6043, 6408], [6411, 6411, 6449, 6449, 7990]]}
{"id": "tdj3zt", "name": "Friendly Robots", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarching"], "likes": 10, "viewed": 153, "published": "Public", "date": "1549773901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat caps(vec3 p, float r, float l)\n{\n    return length(p - vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat map(vec3 p)\n{\n    p.xz = mod(p.xz+vec2(1.5), 3.5)-vec2(1.5);\n    //p.xz *= rotate(iTime);\n    //p.yz *= rotate(iTime);\n    \n    vec3 symp = p;\n    symp.x = abs(symp.x);\n    \n    // Head\n    float mask = caps(p-vec3(0., -.06, 0.), .25, .1);\n    float negMask = caps(p-vec3(0., -.2, -.26), .3, .1);\n    float eyeHole = sphere(symp-vec3(.13, -.01, .21), .023);\n    float mouthHole = sphere(p-vec3(0., -.26, .26), .045);\n    float axle = caps(p.yxz, .12, .2);\n    axle = max(axle, symp.x-.21);\n    float head = max(max(max(mask, -negMask), -eyeHole), -mouthHole);\n    // Flatten sides\n    head = max(head, symp.x-.2);\n    head = min(head, axle);\n    //vec3 fp = symp;\n    \n    \n    // Body\n    vec3 bp = symp;\n    bp.y += 1.;\n    bp.xy *= rotate(-.25);\n    float body = caps(bp, .3, .3);\n    float bottomNeg = caps(symp.xzy-vec3(0.5, 0., -1.2), .4, .3);\n    float backNeg = caps(p-vec3(0., -1., -.1), .3, .3);\n    float armNeg = caps(symp.yxz-vec3(-.7, 0., -.1), .2, .3);\n    float neckHole = sphere(p-vec3(0., -.25, 0.), .4);\n    body = max(max(max(max(body, -bottomNeg), -backNeg), -armNeg), -neckHole);\n    \n    // Pelvis\n    float pelvis = caps(p.yxz-vec3(-1.45, .0, .0), .13, .3);\n    pelvis = max(pelvis, abs(p).x-.25);\n    \n    // Core\n    vec3 cp = p*20.;\n    float verteb = floor(cp.y);\n    cp.y = mod(cp.y, 1.);\n    cp.z -= sin((verteb)*.2)*2.;\n    float core = max(sphere(cp, 1.)/20., abs(p-vec3(0., -.7, 0.)).y-.7);\n    \n    // Legs\n    vec3 lp = symp;\n    lp -= vec3(.2, -1.2, -.15);\n    lp.yz *= rotate(-.7);\n    float legs = caps(lp, .07, .3);\n    lp = symp;\n    lp -= vec3(.2, -.3, -.15);\n    lp.yz *= rotate(-.3);\n    float lower = caps(lp-vec3(.0, -1.3, -.4), .07, .7);\n    legs = min(legs, lower);\n    \n    // Arms\n    vec3 ap = symp;\n    ap.xy *= rotate(.2);\n    float arms = caps(ap.yxz-vec3(-.5, 0., 0.), .02, .2);\n    float shoulder = sphere(symp-vec3(.3, -.55, .0), .1);\n    float upper = caps(symp-vec3(.35, -.75, 0.), .05, .2);\n    vec3 lowap = ap-vec3(0.15, -1.3, 0.15);\n    lowap.yz *= rotate(-.5);\n    float lowera = caps(lowap, .06, .3);\n    arms = min(min(min(arms, shoulder), upper), lowera);\n    \n\t// Floor\n    float flo = p.y + 2.5;\n    \n    return min(min(min(min(min(min(head, body), pelvis), core), legs), arms), flo);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<328; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .0001) break;\n        if(t > 100.) return -1.;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 eps = vec3(.001, 0., 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 eye = vec3(0.5, -1., 2.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    eye.x += iTime*.5;\n    dir.yz *= rotate(-.3);\n    dir.xz *= rotate(.6);\n    \n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    \n    vec3 col;\n    if(d < 0.) {\n        col = vec3(1., .2, .2)/pow((uv.y+.4), 1.1);\n    } else {\n        vec3 normal = getNormal(p);\n        col = vec3(.95, .95, 1.) * (1.-pow(max(0., dot(normal, -dir)), 2.));\n        col *= vec3(.3, .27, .27) * max(0., dot(normal, vec3(0., 1., 0.)));\n        col += vec3(1., .5, .5) * pow(max(0., dot(normal, -dir)), 200.);\n        col += vec3(.8, .8, 1.) * pow(max(0., dot(normal, vec3(0., 1., .5))), 30.);\n        col += vec3(.1, 0., 0.) * d/10.;\n        col += vec3(1.) * d/50.;\n    }\n\t\n    col *= 1.-length(uv)*.8;\n    col = pow(col, vec3(.6));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdj3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [100, 100, 131, 131, 159], [161, 161, 199, 199, 261], [263, 263, 282, 282, 2522], [2524, 2524, 2555, 2555, 2733], [2735, 2735, 2759, 2759, 2950], [2952, 2952, 3009, 3009, 3944]]}
{"id": "tdjGRK", "name": "581 Ray Marching Practice PBR", "author": "zheng516", "description": "581", "tags": ["581"], "likes": 3, "viewed": 119, "published": "Public", "date": "1549494631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\n//camera position\nvec3  camPos = vec3(0.0, 0.0, 10.0);\n\n//template distance funciton\nfloat sphereSDF(in vec3 samplePoint, in float radius){\nreturn length (samplePoint) - radius;\n}\n\nfloat planeSDF( in vec3 samplePoint, in vec4 n)\n{// n must be normalized\n\treturn dot(samplePoint, n.xyz) + n.w;\n}\n\n// Signed distance function for a sphere centered at the origin with radius 1.0;\nfloat sphereSDF1(vec3 samplePoint) {\n    return length(samplePoint - vec3 (- 1.5 , 0.0 ,-1.5 )) - 0.9;\n}\nfloat sphereSDF2(vec3 samplePoint) {\n    return length(samplePoint - vec3 (1.0, 0.0,0.0)) - 0.5;\n}\nfloat sphereSDF3(vec3 samplePoint) {\n    return length(samplePoint - vec3 (0.0, 1.5* cos(iTime), -1.5 * -sin(iTime))) - 0.5;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n/** assign an id to each SDF in the scene, check if a ray hit the obj\n*since there's a better way to assign the ID, these code coudl be obsoleted\n*/\n//** easier understood, differentiate each sphere\n/*\nint id(vec3 samplePoint)\n{\n    if (sphereSDF1( samplePoint)<EPSILON)\n        return 1;\n    if (sphereSDF2( samplePoint)<EPSILON)\n        return 2;\n    if (sphereSDF3( samplePoint)<EPSILON)\n        return 3;\n}\n*/\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//used in the sceneSDF, but sceneSDF only returns .x, set global here to hold .y\n// which is the ID of dist\nvec2 result = vec2 (0.0);\n\n\n float boxPotDist= 0.0;\n//**assign id to each dist as the second component in mapNid\nfloat sceneSDF(vec3 samplePoint) {\n    result = vec2(planeSDF(samplePoint, normalize(vec4(0.0, 1.0, 1.0, 5.0))), 0.0);\n    \n    result = opU(result, vec2(sphereSDF(samplePoint-vec3 (-2.0, \t\t\t0.0, \t\t\t   -1.5), 2.0), 1.0));\n    result = opU(result, vec2(sphereSDF(samplePoint-vec3 ( 1.0, \t\t\t0.0, \t\t\t\t0.0), 0.5), 2.0));   \n    result = opU(result, vec2(sphereSDF(samplePoint-vec3 ( 0.0, 1.5* cos(iTime), -1.5 * -sin(iTime)), 0.5), 3.0));\n    \n   \n    boxPotDist = sdBox( samplePoint, vec3 (1.0, 1.0, 1.0)) -sdBox( vec3( +1.5 * -sin(iTime), 0.0, 0.0), vec3 (1.0, 1.0, 1.0))  ;\n    \n    //result = opU(result, vec2 (boxPotDist, 1.0) );\n    \n    \n    result = opU(result, vec2(sdBox    (samplePoint - vec3(-2.0 +1.5 * -sin(iTime), 0.0, 0.0)                           , vec3(1.0, 1.0, 1.0)),3.0));\n    result = opU(result, vec2(sdHexPrism(samplePoint - vec3( 1.0,1.0, 1.5* cos(iTime))                         , vec2(1.0, 1.0)   ), 1.0 ) );\n    \n    \n    //return min(min(sphereSDF1(samplePoint), sphereSDF2(samplePoint)),\n      //        sphereSDF3(samplePoint));\n\n    return result.x;\n\n}\n\n/**\n * Return the shortest distance from the camera point to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * camPos: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 camPos, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(camPos + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) {\n            return end;\n        }\n    }\n    \n    return end;\n}          \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n//phong lighting\n//==============================================================\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: shininess (exponent of R dot V)\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\nvec3 K_a = vec3(0.2, 0.2, 0.2);\nvec3 K_d = vec3(0.7, 0.7, 0.7);\nvec3 K_s = vec3(0.1, 0.4, 0.1);\nfloat shininess = 40.0;\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 camPos,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(camPos - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess (exponent of R dot V)\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n* The function here loop all the sample point of dist through all the light \n*/\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 camPos) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 lit1Col = vec3(0.3, 0.5, 0.9);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, camPos,\n                                  light1Pos,\n                                  lit1Col);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 lit2Col = vec3(0.4, 0.9, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, camPos,\n                                  light2Pos,\n                                  lit2Col);    \n    \n     vec3 light3Pos = vec3(3.0 * sin(0.66 * iTime),\n                          2.0 * cos(0.66 * iTime),\n                          1.0);\n    vec3 lit3Col = vec3(0.8, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, camPos,\n                                  light3Pos,\n                                  lit3Col);    \n    \n    return color;\n}\n\n//PBR\n//=====================================================================\n/*\n\nin vec2 TexCoords;\nin vec3 WorldPos;\nin vec3 Normal;\n\n// material parameters\nuniform vec3  albedo;\nuniform float metallic;\nuniform float roughness;\nuniform float ao;\n\n// lights\nuniform vec3 lightPositions[4];\nuniform vec3 lightColors[4];\n\nuniform vec3 camPos;\n\nconst float PI = 3.14159265359;*/\n\n//** PBR Equations===========================================================\n\nconst float PI = 3.14159265359;\n\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n} \n\n//Render PBR========================================================================\nint numOfLit = 4;\n//set parameters for material\nvec3 albedo;\nfloat roughness = 0.1; //** can be changed later\nfloat metallic = 0.3;  //** can be changed later\n\n//preset albedo color\nvec3 alumi = vec3(0.96, 0.96, 0.97);\nvec3 gold = vec3(1.00, 0.86, 0.57);\nvec3 copper = vec3(0.95, 0.64, 0.54);\nvec3 plastic = vec3(0.24, 0.24, 0.24);\n\n\n\nvec3 renderPBR(vec3 p){\n//** in shader toy changing variables cannot be global, so put litPos locally    \nvec3 lightPos[4] = vec3[4](\n        vec3(4.0 * sin(iTime)\t\t, 2.0\t\t\t\t\t , 4.0 * cos(0.29*iTime)),\n        vec3(2.0 * sin(0.37 * iTime), 2.0 * cos(0.37 * iTime), 2.0),\n        vec3(3.0 * sin(0.66 * iTime), 2.0 * cos(0.66 * iTime), 1.0),\n    \tvec3(5.0 * cos(0.17 * iTime), 3.0 * sin(0.47 * iTime), 3.0 * cos(0.17*iTime))\n    );\nvec3 lightColor[4] =  vec3[4](\n    vec3(10.0),\n    vec3(3.0, 4.0, 5.0),\n    vec3(12.0),\n    vec3(5.0, 6.0, 9.0));\n   \n\n//mapNid.y is the ID of the dist, so set parameters of each dist here\nif(result.y == 1.0)\n    {\n        roughness = 0.5;\n        metallic= 0.6;\n        albedo = gold;\n        //F0 =  mix(F0, albedo, metallic);\n    }\n    else if(result.y == 2.0)\n    {\n        roughness =0.7;\n        metallic = 0.9;\n        albedo = copper;\n       \t//F0 = mix(F0, albedo, metallic);\n    }\n    else if (result.y == 3.0)\n    {\n        roughness =0.5;\n        metallic = 0.5;\n        albedo = vec3 (0.95, 0.93, 0.88);\n       \t//F0 = mix(F0, albedo, metallic);\n    }\n    else if (result.y == 0.0){\n       \troughness =0.9;\n        metallic = 0.1;\n        albedo = plastic;\n       \t//F0 = mix(F0, albedo, metallic); \n    }\n\n    \n    //computing the variable needed in the loop\n\tvec3 N =  estimateNormal(p);\n\tvec3 V =  normalize(camPos - p);\n\tvec3 F0 = vec3(0.04);\n\t\t F0 = mix(F0, albedo, metallic); \n\tvec3 Lo = vec3(0.0);\n\n    \t\n    for(int i=0;i<numOfLit;i++)\n    {\n        vec3 L = normalize(lightPos[i]-p);\n        vec3 H = normalize(V+L);\n        \n        float attenDist = length(lightPos[i]-p);\n        float attenuation = 1.0/(attenDist*attenDist);\n        \n        vec3 radiance = lightColor[i]*attenuation;\n        \n        float NDF = DistributionGGX(N, H, roughness);\n        float G   = GeometrySmith(N, V, L, roughness);\n        vec3 F = fresnelSchlick(max(dot(H,V),0.0),F0);\n        \n        vec3 numerator    = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n\t\tvec3 specular     = numerator / max(denominator, 0.001);\n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - roughness;\n        \n        float NdotL = max(dot(N, L), 0.0);\n        Lo += (kD * albedo / PI  + specular) * radiance * NdotL;\n    }\n\n    vec3 ambient = vec3(0.03) * albedo * roughness;\n    vec3 color = ambient + Lo;\n    \n    //**to scale the PBR bigger since no diffuse term\n    //color = color / (color + vec3(1.0));\n    //color = pow(color, vec3(1.0/2.2));\n    \n    return color;\n}\n\n\n//=================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //vec3 camPos = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(camPos, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    //The sample point on the ray that shot from each fragment\n    vec3 sampleP = camPos + dist * dir;\n    \n    vec3 color = renderPBR(sampleP);\n    \n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, sampleP, camPos);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 213, 267, 267, 307], [309, 309, 358, 381, 422], [424, 505, 541, 541, 609], [610, 610, 646, 646, 708], [709, 709, 745, 745, 835], [838, 838, 869, 869, 956], [959, 959, 995, 995, 1268], [1686, 1927, 1957, 1957, 1990], [2152, 2213, 2247, 2247, 3294], [3296, 3720, 3814, 3814, 4146], [4158, 4412, 4477, 4477, 4609], [4611, 4700, 4729, 4729, 5039], [5041, 5748, 5891, 5891, 6484], [6486, 6942, 7030, 7030, 8149], [8529, 8642, 8698, 8698, 8965], [8967, 8967, 9023, 9023, 9178], [9179, 9179, 9241, 9241, 9459], [9461, 9461, 9507, 9507, 9564], [9812, 9987, 10010, 10092, 12551], [12554, 12623, 12680, 12680, 13259]]}
{"id": "tdjGRt", "name": "3D Lissajous Figures", "author": "mla", "description": "3D Lissajous, drawn as chains of small spheres.\n\n[url]https://mathcurve.com/courbes3d.gb/lissajous3d/lissajous3d.shtml[/url]", "tags": ["3d", "lissajous"], "likes": 20, "viewed": 492, "published": "Public API", "date": "1549782990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 3D Lissajous figures\n//\n// mouse rotates\n// 'c': use cos for z-rotation\n// 'p': phase shift\n// 'r': auto rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dophase = false;\nbool docos = false;\n\nconst float PI = 3.14159;\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // (unnormalized) normal\n  int id;       // what was hit\n};\n\nstruct Sphere {\n  float r2;      // radius squared\n  vec3 p;       // centre\n  int id;\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r2 = s.r2;\n  float c2 = dot(p,p);\n  vec3 q = ray.q-s.p, d = ray.d;\n  // |q + t*d|^2 = r^2\n  float B = dot(q,d);\n  float C = dot(q,q)-r2;\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  // We normalize it later\n  hit = Hit(t, q+t*d, s.id);\n  return true;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    //p.xy = rotate(p.xy,t*0.123);\n    p.zx = rotate(p.zx,t*0.2);\n  }\n  return p;\n}\n\nint imod(int n, int m) {\n  return n - n/m*m;\n}\n\nfloat P = 3.0;\nfloat Q = 2.0;\nfloat R = 1.0;\nfloat NN = 200.0;\nbool intersectScene(Ray ray, out Hit hit) {\n  float k = 0.5*(1.0+cos(0.2*iTime));\n  hit.t = 1e8;\n  NN = (P+Q+R)*20.0;\n  for (float i = 0.0; i < max(-iTime,NN); i++) {\n    float r = 0.1;\n    float t = i*2.0*PI/NN;\n    t += 0.1*iTime;\n    float phase = 0.0;\n    if (dophase) phase += 0.123*iTime;\n    if (docos) phase += 0.5*PI;\n    vec3 p = vec3(sin(P*t),sin(Q*t),sin(R*t+phase));\n    Sphere s = Sphere(r*r,p,int(i));\n    Hit hits;\n    if (intersectSphere(s,ray,hits) && hits.t < hit.t) {\n      hit = hits;\n    }\n  }\n  return hit.t < 1e8;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec4 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = normalize(hit.n);\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = hsv2rgb(float(hit.id)/NN,0.5,1.0);\n    vec3 color = vec3(0);\n    color += baseColor.xyz*ambient;\n    color += baseColor*diffuse*max(0.0,dot(light,n));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),10.0);\n    color += 1.0*specular*baseColor;\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_P = 80;\nconst int CHAR_R = 82;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  docos = !keypress(CHAR_C);\n  dorotate = !keypress(CHAR_R);\n  dophase = keypress(CHAR_P);\n  vec2 uv = fragCoord.xy/iResolution.y;\n  uv.y = 1.0-uv.y;\n  uv *= 5.0;\n  vec2 pq = floor(uv)+1.0;\n  P = pq.x, Q = pq.y;\n  uv = 2.0*fract(uv)-1.0;;\n  vec3 p = vec3(0,0,-4.0);\n  vec3 d = vec3(uv.x, uv.y, 2.0);\n  p = transform(p);\n  d = transform(d);\n  d = normalize(d);\n  light = vec3(0.5,1.0,-1.0);\n  light = transform(light);\n  light = normalize(light);\n  ambient = 0.6;\n  diffuse = 0.2;\n  fragColor = solve(Ray(p,d));\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 686, 740, 740, 1230], [1232, 1232, 1262, 1262, 1314], [1316, 1316, 1343, 1343, 1682], [1684, 1684, 1708, 1708, 1730], [1795, 1795, 1838, 1838, 2334], [2379, 2379, 2420, 2420, 2596], [2598, 2598, 2617, 2617, 3132], [3204, 3204, 3229, 3229, 3289], [3291, 3291, 3348, 3348, 3861]]}
{"id": "tdjGzd", "name": "LFO", "author": "PianiGiani", "description": "Playing around with Colours and Functions", "tags": ["slow"], "likes": 3, "viewed": 94, "published": "Public", "date": "1549801161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.;\n    \n    float nTime=iTime*.5;\n    \n    float s = sin(nTime*.1);\n    float c = cos(nTime*.1);\n    uv*=mat2(c, -s, s, c); \n    \n    float nFact=10.+50.*(sin(nTime*.3)+1.);\n    float col1=sin((uv.x*uv.y)*nFact);\n    float col2=cos((uv.x+sin(uv.y))*nFact);\n    float col3=cos((uv.x*uv.y)*nFact);\n    \n    \n    fragColor = mix(vec4(col1+col2+col3,col1,col1+col2+col3,1.0),vec4(col1,col1+col2+col3,col3,1.0),sin(nTime+uv.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 573]]}
{"id": "tdlSD4", "name": "Happy accidents", "author": "uada", "description": "Just a happy accident, still new", "tags": ["sunset"], "likes": 1, "viewed": 87, "published": "Public", "date": "1551313922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n} \n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float s = 15. + sin(iTime/3.) * 5.;\n    \n    vec2 center = vec2(0.);\n    vec3 col = vec3(0);\n\n    for (float i = 0.0; i < 1.0; i += 0.1){\n        // fake flare \n    \tcenter += vec2(i);\n        \n    \tuv*=1.5;\n\n    \tvec2 uv_c = uv - center;\n    \tfloat dist = length(uv_c);\n    \n    \tuv_c = normalize(uv_c);\n    \n    \tfloat a = atan(uv_c.y,uv_c.x);\n    \n    \tfloat xo = map(cos(a+(iTime/7245.)),-1.,1.,-s,s);\n    \tfloat yo = map(sin(a+(iTime)),-1.,1.,-s,s);\n\n    \tfloat r = map(noise(vec2(xo,yo)),0.,1.,0.65,0.7);\n    \n    \tvec2 nv = vec2(r * cos(a),r*sin(a));\n    \n    \tcol += smoothstep(r,r-0.08,dist);\n    \n\t    //col *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \tvec3 col1 = 0.7 + 0.3*cos(iTime+uv.xyx+vec3(4,2,1));\n    \tvec3 col2 = 0.7 + 0.3*sin(iTime+uv.xyx+vec3(1,2,4));\n    \tcol1 *= col2;\n    \tcol *= col1;\n    }\n    uv*=.05;\n\tvec2 suv = uv;\n    \n    if (uv.y < -0.4 + sin(uv.x+iTime) * 0.1)\n    {\n        uv.y *=-.31;\n        uv.x *= sin((suv.y/.1)+iTime*5.)*.1 + 1.1;\n    }\n    center = vec2(0.);\n    \n    vec2 uv_c = uv - center;\n    float dist = length(uv_c);\n    \n    uv_c = normalize(uv_c);\n    \n    float a = atan(uv_c.y,uv_c.x);\n    \n    float xo = map(cos(a+(iTime/7245.)),-1.,1.,-s,s);\n    float yo = map(sin(a+(iTime)),-1.,1.,-s,s);\n\n    float r = map(noise(vec2(xo,yo)),0.,1.,0.595,0.7);\n    \n    vec2 nv = vec2(r * cos(a),r*sin(a));\n    \n    col += smoothstep(r,r-0.08,dist);\n    \n    uv=suv;\n    \n    if (uv.y < -0.4 + sin(uv.x+iTime) * 0.1)\n    {\n        col = mix(vec3(0.5,0.50,0.97)+ cos(uv.x+(iTime)*3.) * 0.1212\n            + sin(uv.y*30.+sin(iTime)) * 0.01212,col,0.351);\n    }\n    else\n    {\n        col += vec3(0.86,0.6321,0.12) + sin(iTime) * 0.02;\n    }\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 102], [103, 103, 129, 129, 430], [433, 433, 511, 511, 586], [588, 588, 645, 645, 2434]]}
{"id": "tdlSRr", "name": "Almost a Star", "author": "martinsh", "description": "'Gas giants are sometimes known as failed stars because they contain the same basic elements as a star.'\n\nMy attempt to swirl and distort a simplex noise to form somewhat believable turbulent clouds. Not a particularly fast shader", "tags": ["gasgiant"], "likes": 13, "viewed": 380, "published": "Public", "date": "1550581990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//attempt to simulate a semi-realistic gas giant\n//mostly based on Planet Funk by fizzer\n//https://www.shadertoy.com/view/XssGWN\n\n\n#define time iTime*0.8\n\nfloat gamma = 2.2;\nfloat scale = 1.0;\nfloat exposure = 7.0;\n\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n//changed this for my liking\nfloat fbm(vec3 p, vec3 n)\n{\n\tfloat f;\n    p = p*7.3;\n    f  = 0.60000*pow((simplex3D( p )),3.0)*0.7+0.8;\n    f += 0.35000*pow(abs(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(3.0))*1.0)),0.8 )*1.0; p = p*2.02;\n    f += 0.12500*pow(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*1.0),1.0 )*1.0; p = p*2.03;\n    f += 0.1250*(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*1.0) ); p = p*4.04;\n    f += 0.03125*(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*1.0) );\n\treturn f;\n}\n\n#define ONE vec2(1.0, 0.0)\n#define EPS vec2(1e-3, 0.0)\n\nconst float pi = 3.1415926;\n\nfloat N(vec2 p)\n{\n   p = mod(p, 4.0);\n   return fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p)\n{\n\tvec2 fp = floor(p);\n\tvec2 pf = smoothstep(0.0, 1.0, fract(p));\n\treturn mix( mix(N(fp), N(fp + ONE), pf.x), \n\t\t\t   mix(N(fp + ONE.yx), N(fp + ONE.xx), pf.x), pf.y);\n}\n\n\nfloat fbm2(vec2 p)\n{\n\tfloat f = 0.0, x;\n\tfor(int i = 1; i <= 9; ++i)\n\t{\n\t\tx = exp2(float(i));\n\t\tf += smN2(p * x) / x;\n\t}\n\treturn f;\n}\n\n// Scalar field for the surface undulations.\n\nfloat spots(vec2 p)//unused\n{\n\tp *= 2.5;\n\treturn smN2(p + EPS.xy * 2.0);\n}\n\nfloat field(vec2 p)\n{\n\tp *= 1.5;\n\treturn mix(smN2(p * 3.0), smN2(p * 4.0), 0.5 + 0.5 * cos(time * 0.02 + p.x*3.8 - 2.531)+ sin(time * 0.01 + p.y*4.2 + 1.536));\n}\n\nfloat field2(vec2 p)\n{\n\tp *= 6.5;\n\treturn mix(smN2(p * 2.0), smN2(p * 5.0), 0.5 + 0.5 * sin(time * 0.6 + p.x*2.0 + 83.123)+ cos(time * 0.5 + p.y*4.0 - 2.323));\n}\n\nfloat field3(vec2 p)\n{\n\tp *= 0.6;\n\treturn mix(smN2(p * 1.0), smN2(p * 2.0), 0.5 + 0.5 * cos(time * 0.5 + p.x*2.0 + 4.323));\n}\n\n// Vector field extracted from the scalar field.\nvec2 flow(vec2 p)\n{\n    vec2 flowout = vec2(0.0,0.0);\n\tfloat f0 = field(p);\n\tfloat f1 = field(p + EPS.xy);\n\tfloat f2 = field(p + EPS.yx);\n    flowout += (vec2(f1 - f0, f2 - f0)).yx * vec2(-1, 1) * 0.2;\n    float f20 = field2(p);\n\tfloat f21 = field2(p + EPS.xy);\n\tfloat f22 = field2(p + EPS.yx);\n    flowout += (vec2(f21 - f20, f22 - f20)).yx * vec2(-1, 1) * 0.05;\n    float f30 = field3(p);\n\tfloat f31 = field3(p + EPS.xy);\n\tfloat f32 = field3(p + EPS.yx);\n    flowout -= (vec2(f31 - f30, f32 - f30)).yx * vec2(-1, 1) * 0.1;\n\treturn flowout;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    scale *= (1.0-(iMouse.y / iResolution.y))+0.5;\n    //exposure *= ((iMouse.x / iResolution.x))*0.5+0.01;\n    \n    vec2 R = iResolution.xy, \n         M = iMouse.xy/R;\n         U = (( U + U - R ) / R.y)*scale;     \n        \n    float l = length(U);\n    \n    vec3 N = vec3( U.x, U.y, sqrt(1.-l*l) );\n\n    vec2 uv = vec2(1.0-atan(N.z, N.x) / (2.0*pi),1.0-(atan(length(N.xz), N.y)) / pi);\n    uv.x -= ((iMouse.x / iResolution.x));   \n\tuv.x -= time*0.03+pow(cos(N.y*22.0)*0.03+0.97,2.5)*cos(N.y*1.0)*0.1;\n    \n\tconst int count = 5;\n    float csum = 0.0;\n    float wsum = 0.0;\n    \n\tfor(int i = 0; i < count; ++i)\n\t{\n\t\tfloat w = 1.0;\n        uv += flow(uv);\n        \n\t\tcsum += fbm(vec3(uv,time*0.002)*5.0, N) * 0.15 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n        csum += fbm(vec3(uv,time*0.002)*12.0, N) * 0.15 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n        csum += fbm(vec3(uv,time*0.002)*27.0, N) * 0.15 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n\n\t\twsum += w;\t\n\n\t}\n\n    \n \tO = vec4(1.0);\n    \n    //all artistic values below\n\tvec3 skyext = vec3(0.6, 0.5, 0.45)*0.1;//sky extinction\n    \n    vec3 color = vec3(0.1,0.2,0.2);\n    vec3 color1 = vec3(0.9,0.26,0.1)*0.7;\n    vec3 color2 = vec3(0.4,0.4,0.32)*0.3;\n    vec3 color3 = vec3(0.7,0.7,0.7);\n    \n    //mixing up the colors\n    vec3 planet = mix(color1,color3,pow(sin(uv.y*89.0-time*0.05)*0.5+0.5,2.5));\n    planet = mix(planet,color2,pow(sin(uv.y*25.0+0.3)*0.5+0.5,1.8));\n    planet = mix(color3,planet,pow(cos(uv.y*47.0)*0.5+0.5,0.5));\n    planet = mix(planet,planet*color,pow(cos(uv.y*9.0-1.3)*0.5+0.5,1.5));\n    \n    //more interesting mix between light and shadow\n    O.rgb = mix(vec3(0.2,0.7,1.0)*0.0005,planet,(pow(csum/wsum,2.9)*pow(N.z,1.5)*(-N.x*0.5+0.5)/skyext));\n\n    O.rgb *= exposure;\n    O *= smoothstep(0.,3./R.y,1.-l);//AA\n    O.rgb = pow(O.rgb,vec3(1.0/gamma));\n    //O.rgb = planet;\n    //O.rgb = vec3(uv.yy,0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 217, 240, 240, 321], [323, 323, 348, 348, 2473], [2474, 2503, 2530, 2530, 3002], [3089, 3089, 3106, 3106, 3186], [3188, 3188, 3208, 3208, 3375], [3378, 3378, 3398, 3398, 3511], [3513, 3559, 3588, 3588, 3633], [3635, 3635, 3656, 3656, 3796], [3798, 3798, 3820, 3820, 3959], [3961, 3961, 3983, 3983, 4086], [4088, 4137, 4156, 4156, 4680], [4683, 4683, 4721, 4721, 6734]]}
{"id": "tdS3DG", "name": "Ellipsoid - distance", "author": "iq", "description": "Bad (left) vs improved (right) approximation of distance to ellipsoid. Note improved intersection quality for the same number of iterations and more accurate shadows. Info: [url]http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm[/url]", "tags": ["3d", "distancefield", "sdf", "distance", "ellipsoid"], "likes": 12, "viewed": 2195, "published": "Public API", "date": "1549869274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the exact distance to a generic (non symmetric) ellipsoid\n// requires solving a sixth degree equation, which can be difficult.\n// Approximating the distance is easier though. This shaders shows one\n// such approximation that produces better results than the naive\n// distance bound. More info here:\n//\n// http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\n//\n// Left, naive ellipsoid distance approximation (single square root)\n// Right, improved approximation (two square roots).\n//\n// Note how the improved approximation produces a more accurate intersection\n// for the same number of raymarching steps (specially noticeable in the first\n// frame of the animation). Note also how the penumbra shadow estimation works\n// best with since since it has a more eucliden distance as input.\n//\n// The technique is based on dividing the bad approximation's distance estimation\n// by the length of its gradient to get a first order approximation to the true\n// distance (see http://iquilezles.org/www/articles/distance/distance.htm)\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#define AA 2   // make this 3 is you have a fast computer\n\n//------------------------------------------------------------------\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    float d1 = (id==0) ? sdEllipsoid_Bad( p, vec3(0.18,0.3,0.02) ) :\n                         sdEllipsoid(     p, vec3(0.18,0.3,0.02) );\n\n    // plane\n    float d2 = p.y+0.3;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<100 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.0);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            col *= 0.7+0.3*checkersGradBox( pos.xz*2.0 );\n            occ = 1.0;\n\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.2);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.9, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        float sha = calcSoftshadow( pos, lig, id );\n        sha = sha*sha;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif * sha *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        //vec3 lin = vec3(0.0);\n        //lin += 2.00*dif*vec3(3.30,2.50,2.00)*sha;\n        //lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        //lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        //col = col*lin;\n        //col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        col *= 5.0;\n        col *= vec3(0.2,0.3,0.4)*amb*occ + 1.6*vec3(1.0,0.9,0.75)*dif*sha;\n        col += vec3(2.8,2.2,1.8)*spe*3.0;            \n\n\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    // scene selection\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    // render\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // separator    \n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdS3DG.jpg", "access": "shaders20k", "license": "mit", "functions": [[2405, 2465, 2513, 2513, 2567], [2570, 2624, 2668, 2668, 2757], [2759, 2829, 2860, 2877, 3109], [3111, 3111, 3159, 3159, 3428], [3431, 3431, 3489, 3489, 3776], [3778, 3778, 3821, 3821, 4045], [4047, 4047, 4100, 4100, 4401], [4404, 4480, 4516, 4537, 4760], [4762, 4762, 4809, 4809, 6501], [6503, 6503, 6560, 6575, 7784]]}
{"id": "tdS3Dw", "name": "Cloud Soft Shadows", "author": "scratch13764", "description": "A little experiment I was doing with making clouds that could cast good soft shadows. It works by distorting a smoothstep blurred ellipse with fractal noise, so the farther a shadow ray is, the more blurred the cloud can be made.", "tags": ["fractal", "cloud", "perlin", "shadows"], "likes": 5, "viewed": 263, "published": "Public", "date": "1548998559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//returns a 0-1 density value for a smoothstep blurred circle\nfloat BlurCircle(vec2 p,float r, float b)\n{\n    float l = length(p)-r+b*.5;\n    return smoothstep(b,-.001,l);\n}\n\nvec2 Hash (vec2 p)\n{\n    p = round(p - .5) + .5;\n    return fract(vec2(\n        sin(p.x*89.2832 + p.y*32.4687),\n        sin(p.x*34.7427 + p.y*37.9275)\n        )*35.673);\n}\n\nvec2 Perlin (vec2 p)\n{\n    vec4 a = vec4(\n    Hash(vec2(floor(p.x),floor(p.y))).x,\n    Hash(vec2(floor(p.x),ceil(p.y))).x,\n    Hash(vec2(ceil(p.x),floor(p.y))).x,\n    Hash(vec2(ceil(p.x),ceil(p.y))).x\n    );\n    \n    vec4 b = vec4(\n    Hash(vec2(floor(p.x),floor(p.y))).y,\n    Hash(vec2(floor(p.x),ceil(p.y))).y,\n    Hash(vec2(ceil(p.x),floor(p.y))).y,\n    Hash(vec2(ceil(p.x),ceil(p.y))).y\n    );\n    \n    vec2 m = smoothstep(0.,1., fract(p));\n    \n    vec2 r;\n    r.x = mix(mix(a.x,a.y,m.y), mix(a.z,a.w,m.y), m.x) - .5;\n    \n    return r;\n}\n\nfloat GetCloud (vec2 p, float s)\n{\n    vec2 b = vec2(0);\n    float amp = 1.3;\n    float freq = 1.;\n    for (int i = 0; i <= 5; i++)\n    {\n        b += Perlin((iTime*.1+p)*freq*3.)*amp;\n        amp *= .5;\n        freq *= 2.;\n    }\n\n    return BlurCircle((p*vec2(.6,1.))+b/5.,.25,s);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 a = (f-iResolution.xy*.5)/iResolution.y;\n    \n    float soft = (sin(iTime*.64)+1.)/8.;\n    \n    float Cloud = GetCloud(a,soft);\n    float Light = 1.;\n    vec2 LightP = 2.*(iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    for (float i = 0.; i <= .5; i += .05)\n    {\n        Light *= 1.-GetCloud(a + i*LightP, soft + i/length(LightP))/10.;\n        //Light = min(Light, 1. - GetCloud(a + i*LightP, 0. + i/length(LightP)/5.));\n        //Comment line 67 and uncomment line 68 to see a more informational view.\n    }\n    \n    c = mix(vec4(.6,.6,1,1), vec4(Light+.4), Cloud)*(.5+Light*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdS3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 105, 105, 173], [175, 175, 195, 195, 346], [348, 348, 370, 370, 891], [893, 893, 927, 927, 1176], [1178, 1178, 1219, 1219, 1812]]}
{"id": "tdS3zy", "name": "Dizzy Place", "author": "Minus256", "description": "13th in TokyoDemoFest 2018 Shader Compo.\n\nGradient is Distorted by constant*sin(time)", "tags": ["intro"], "likes": 4, "viewed": 172, "published": "Public", "date": "1549168994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Minus256\nconst float err = 0.001;\nconst float sta = 0.0;\nconst float end = 7000.0;\nconst int mxmrch = 255;\nfloat spheresdf(vec3 p,float r)\n{\n    return length(p) - r;\n}\nfloat rep(vec3 p,vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return spheresdf(q,max(50.0*sin(iTime*5.0),30.0));\n}\nfloat scenesdf(vec3 p)\n{\n    vec3 damn = vec3(200.0,200.0,200.0);\n    return rep(p,damn);\n}\nvec3 raydir(float fov,vec2 res,vec2 pos)\n{\n    vec2 dir = pos - res/2.0;\n    float depth = (res.y/2.0)/tan(radians(fov/2.0));\n    return normalize(vec3(dir,-depth));\n}\nmat4 viewmat(vec3 pos, vec3 centerdir, vec3 roll) {\n    vec3 f = normalize(centerdir - pos);\n    vec3 s = normalize(cross(f, roll));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        scenesdf(vec3(p.x + 1.5+sin(iTime)*0.1,p.y,p.z)) - scenesdf(vec3(p.x - 4.1,p.y,p.z)),\n        scenesdf(vec3(p.x,p.y + 4.1,p.z)) - scenesdf(vec3(p.x,p.y - 1.7+sin(iTime)*0.1,p.z)),\n        scenesdf(vec3(p.x,p.y,p.z + 9.7+sin(iTime)*0.1)) - scenesdf(vec3(p.x,p.y,p.z - 8.1))\n        ));\n}\nfloat dirlength(vec3 p,vec3 raydir)\n{\n    float depth = 2.0;\n    for(int i = 0; i < mxmrch; i++)\n    {\n        float dist = scenesdf(p + raydir * depth);\n            if(dist < err)\n            {\n                return depth;\n            }\n        depth += dist;\n        if(depth >= end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\nfloat Minresetnor(vec3 lightpos,vec3 normalo,vec3 eye,vec3 rgb,float ext,float strongness)\n{\n    vec3 dir = normalo;\n    vec3 point = eye;\n    vec3 altp = dir*dirlength(eye,normalo);\n    float altl = dirlength(eye,normalo);\n    float altl2 = altl;\n    for(int i = 0;i<2;i++)\n    {\n        altp = dir*altl;\n        dir = reflect(dir,normal(altp));\n        altl = dirlength(altp,dir);\n        altl2 = altl2+altl;\n    }\n    return altl2;\n}\nvec3 Minresetnorr(vec3 lightpos,vec3 normalo,vec3 eye,vec3 rgb,float ext,float strongness)\n{\n    vec3 dir = normalo;\n    vec3 point = eye;\n    vec3 altp = dir*dirlength(eye,normalo);\n    float altl = dirlength(eye,normalo);\n    float altl2 = altl;\n    for(int i = 0;i<2;i++)\n    {\n        altp = dir*altl;\n        dir = reflect(dir,normal(altp));\n        altl = dirlength(altp,dir);\n        altl2 = altl2+altl;\n    }\n    return altp;\n}\nvec3 PCFL(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n    vec3 lightPos, vec3 lightITs,vec3 ffff) {\n    vec3 N = ffff;\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));   \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    if (dotRV < 0.0) {\n        return lightITs * (k_d * dotLN);\n    }\n    return lightITs * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\nvec3 POI(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,vec3 ffff) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1ITs = vec3(0.4, 0.4, 0.4);\n    color += PCFL(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1ITs,ffff);\n    vec3 light2Pos = vec3(2.0 * sin(0.37 *iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2ITs = vec3(0.4, 0.4, 0.4);\n    color += PCFL(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2ITs,ffff);    \n    return color;\n}\nvoid mainImage(out vec4 fragColor ,in vec2 fragCoord)\n{\n    vec4 background = vec4(0.5,0.5,0.5,1.0);\n    vec3 viewDir = raydir(90.0, iResolution.xy, fragCoord.xy);\n    vec3 pointt = vec3(700.0*sin(iTime),400.0*cos(iTime),mod(iTime*400.0,sin(iTime*400.0)));\n    mat4 viewToWorld = viewmat(pointt, vec3(0.0), normalize(vec3(sin(mod(iTime*5.0,5.0)),cos(iTime*0.5),cos(iTime))));   \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = dirlength(pointt, worldDir);\n    vec3 eye = (pointt + dist * worldDir);\n\tvec3 ambient = vec3(1.0,1.0,1.0);\n    vec3 hellr = Minresetnorr(vec3(0.0),worldDir,pointt,vec3(0.0,0.0,1.0),10.0,0.5);\n\tvec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 p = pointt + dist * worldDir;\n    vec3 normcolor = normal(hellr);\n    vec3 color = POI(K_a, K_d, K_s, shininess, p, pointt,normcolor);\n    float hell = Minresetnor(vec3(0.0),worldDir,eye,vec3(0.0,0.0,1.0),10.0,0.5);\n    float minphase = clamp(abs(1.1*sin(iTime*10.0)*sin(fragCoord.y)),0.0,0.3);\n    fragColor = vec4(1.0) - vec4((hell)/(end))+vec4(vec3(color),0.0) - vec4(dist/(end-40.0*abs(sin(iTime)))) \n        - vec4(minphase) + vec4(vec3(0.2,0.2,0.5),0.0);\n}   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdS3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 142, 142, 170], [171, 171, 197, 197, 283], [284, 284, 308, 308, 375], [376, 376, 418, 418, 543], [544, 544, 595, 595, 826], [827, 827, 848, 848, 1170], [1171, 1171, 1208, 1208, 1525], [1526, 1526, 1618, 1618, 1962], [1963, 1963, 2055, 2055, 2398], [2399, 2399, 2505, 2505, 2897], [2898, 2898, 2979, 2979, 3712], [3713, 3713, 3768, 3768, 4965]]}
{"id": "tdSGDc", "name": "Fast Shadow for Rectangle", "author": "kanro", "description": "Create a fast shadow for rect by 1-D Box", "tags": ["2d", "blur", "shadow", "rectangle", "gaussian"], "likes": 6, "viewed": 865, "published": "Public", "date": "1550127195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference: http://stereopsis.com/shadowrect/\n\n// blend two color by alpha\nvec4 blend(vec4 src, vec4 append) {\n  \treturn vec4(src.rgb * (1.0 - append.a) + append.rgb * append.a,\n              1.0 - (1.0 - src.a) * (1.0 - append.a));\n}\n\n// approximation to the gaussian integral [x, infty)\nfloat gi(float x) {\n\tfloat i6 = 1.0 / 6.0;\n\tfloat i4 = 1.0 / 4.0;\n\tfloat i3 = 1.0 / 3.0;\n\n    if (x > 1.5) return 0.0;\n    if (x < -1.5) return 1.0;\n\n    float x2 = x * x;\n    float x3 = x2 * x;\n    \n    if (x >  0.5) return .5625  - ( x3 * i6 - 3. * x2 * i4 + 1.125 * x);\n    if (x > -0.5) return 0.5    - (0.75 * x - x3 * i3);\n    return 0.4375 + (-x3 * i6 - 3. * x2 * i4 - 1.125 * x);\n}\n\n// create a line shadow mask\nfloat lineShadow(vec2 border, float pos , float sigma) {\n    float t = (border.y - border.x) / sigma;\n    \n    float pos1 = ((border.x - pos) / sigma) * 1.5;\n    float pos2 = ((pos - border.y) / sigma) * 1.5;\n    \n  \treturn 1.0 - abs(gi(pos1) - gi(pos2));\n}\n\n// create a rect shadow by two line shadow\nfloat rectShadow(vec4 rect, vec2 point, float sigma) {\n    \n    float lineV = lineShadow(vec2(rect.x, rect.x + rect.z), point.x, sigma);\n    float lineH = lineShadow(vec2(rect.y, rect.y + rect.w), point.y, sigma);\n    \n  \treturn lineV * lineH;\n}\n\n// draw shadow\nvec4 drawRectShadow(vec2 pos, vec4 rect, vec4 color, float sigma) {\n    vec4 result = color;\n    \n    float shadowMask = rectShadow(rect, pos, sigma);\n    \n    result.a *= shadowMask;\n    \n\treturn result;\n}\n\n// check a point in a rect\nfloat insideBox(vec2 v, vec4 pRect) {\n   vec2 s = step(pRect.xy, v) - step(pRect.zw, v);\n  return s.x * s.y;\n}\n\n// draw rect\nvec4 drawRect(vec2 pos, vec4 rect, vec4 color) {\n    vec4 result = color;\n    \n    result.a *= insideBox(pos, vec4(rect.xy, rect.xy+rect.zw));\n    return result;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    float sigma = 60. * iMouse.x / iResolution.x;\n    sigma += step(iMouse.x, 0.0) * 30.;\n    \n    float z = sigma * iMouse.y / iResolution.y;\n    \n    vec4 result = vec4(1.0);\n    \n    vec3 rectColor = hsv2rgb(vec3(fract(iTime * 0.1), 0.8, 0.8));\n    \n    vec4 rect = vec4(iResolution.xy / 2.0 - 100., vec2(200.,200.));\n    vec4 color = vec4(rectColor,1.0);\n    \n    vec4 shadowRect = vec4(vec2(rect.x + sqrt(z), rect.y - sqrt(z)), rect.zw);\n    vec4 shadowColor = vec4(rectColor,sin(iTime) * 0.2 + 0.8);\n    \n  \tresult = blend(result, drawRectShadow(fragCoord, shadowRect, shadowColor, sigma));\n  \tresult = blend(result, drawRect(fragCoord, rect, color));\n    \n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 77, 112, 112, 236], [238, 291, 310, 310, 680], [682, 711, 767, 767, 968], [970, 1013, 1067, 1067, 1258], [1260, 1275, 1342, 1342, 1481], [1483, 1510, 1547, 1547, 1620], [1622, 1635, 1683, 1683, 1798], [1800, 1800, 1827, 1827, 2005], [2007, 2007, 2063, 2063, 2752]]}
{"id": "tdSGW3", "name": "Kaleidoscope color test", "author": "darkeclipz", "description": "Kaleidoscope", "tags": ["kaleidoscope"], "likes": 7, "viewed": 155, "published": "Public", "date": "1550096403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define Iterations 20.\nmat2 r2(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }\n\nfloat sdCircle(vec2 p, float r) {\n\treturn length(p) - r;    \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvec2 T(vec2 p) {\n\n    vec4 w = texture( iChannel0, vec2(15./256.,0.1));\n    float s = 0.0006 + 0.0005 * cos(iTime/2.);\n    for(float i=0.; i < Iterations; i++) {\n    \tp = abs(p) - s - i/Iterations; \n        p *= r2(3.1415*fract(iTime / 12.) + w.x);\n        p *= (i/Iterations*.4 + 1.);\n    }\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-R)/R.y;\n\n    // Time varying pixel color\n    vec3 col = pal(fract(0.3*sdCircle(T(uv), 0.5) + iTime / 7.), vec3(.5), vec3(0.5), \n                   vec3(1.0,1.0,1.0), vec3(.0, .10, .2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 70, 70, 134], [136, 136, 169, 169, 198], [200, 200, 268, 268, 313], [315, 315, 331, 331, 627], [629, 629, 686, 736, 1012]]}
{"id": "tdsSRr", "name": "faster glitchy julia fog", "author": "pde", "description": "dynamic jumpsizes... allow a nice frame rate, but give us some (perhaps cool) glitchy artefacts\n\nclick and drag to rotate the camera", "tags": ["raymachedjuliaset"], "likes": 4, "viewed": 190, "published": "Public", "date": "1550520690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmult(vec2 a, vec2 b)\n{\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 spacify(vec2 p)\n{\n    return ( p - .5 * iResolution.xy ) / iResolution.y;\n}\n\nconst int counts = 160;\nconst float fcount = float(counts);\n\nint julia(in vec2 z0, in vec2 c)\n{\n    vec2 z = z0;\n    if (length(z) > 4.0)\n        return 0;\n    for (int n=0; n <counts; n++) {\n        z = cmult(z,z) +c;\n        if (length(z) > 4.0)\n            return n;\n    }\n    return -1;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // start at 0,0,z=3, shoot a ray at the plane z=1\n    vec3 camera = vec3(0,0,4.0);\n    vec2 xy = spacify(fragCoord);\n    vec3 coord = vec3(xy.x, xy.y, 3.0);\n    vec3 ray = coord - camera;\n    float radius =  length(xy);\n    \n    vec2 mouse_xy=spacify(iMouse.xy);\n    mat3 rot = rotationMatrix(vec3(mouse_xy.y, mouse_xy.x, 0.0), 2.5 * length(mouse_xy));\n    \n    camera = camera*rot;\n    ray = ray*rot;\n    \n    float col = 0.0;      // integral of collisions with halo fog\n    float core = 0.0;     // integral of collisions with core fog\n    float steps = 50.0;\n    float z2 = sin(iTime/7.0);\n    float corr =cos(iTime/3.1415), jumpphase = pow(sin(iTime/4.0),3.0);\n    vec3 pos=camera; int inc=0; float jumpsize,j1,j2,j0; int n=0;\n    for (float dist=0.0; dist < 5.0; ) {\n        // there are lots of weird artefacts that result from jumpsize selection choices!\n        // j0 is a heuristic choice to step slowly near the julia boundary\n        // watch out for j0 == 0...\n        j0 = (fcount + 1.0 - float(inc)) / (fcount + 1.0);\n        // playing with two variants of it gives a cool banded visual effect\n        j1 = 0.02 + 0.5 * radius * j0;\n        j2 = 0.005 + 0.1 * j0;\n        jumpsize = jumpphase * j1 + (1.0 - jumpphase) * j2;\n\n        pos += jumpsize*ray;\n        dist +=jumpsize;\n        inc = julia(vec2(pos.x+corr, pos.y), vec2(pos.z,z2));\n        \n        if (inc < 0)\n            // collisions with the core of the julia set\n            core += 1.0;\n        else {\n            // collisions with the halo\n            col += float(inc) * jumpsize * 20.0;\n\n        }\n        if (n > 2000) break;\n\n    }\n    // Each of the rgb channels grows increases with halo fog collisions & decreases\n    // with core fog collisions, but with different weights on those two effects\n    float scale = 10.24 * steps, b=2.0*scale;\n    float pen = core / 10.0;\n    fragColor = vec4(col/scale - pen, col/scale-(pen/5.0), col/b - (pen/3.0), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 63], [65, 65, 87, 87, 145], [208, 208, 242, 242, 439], [441, 441, 486, 486, 969], [971, 971, 1026, 1080, 2977]]}
{"id": "tdsXD4", "name": "Caged Crystal (remix^2)", "author": "slerpy", "description": "remix of [url]https://shadertoy.com/view/tslXD4[/url]\nwhich is a remix of [url]https://www.shadertoy.com/view/tdlXW4[/url]", "tags": ["sdf", "raymarcher", "crystal"], "likes": 3, "viewed": 80, "published": "Public", "date": "1551317247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"caged crystal (remix)\" by _discovery\n// https://shadertoy.com/view/tslXD4\n// 2019-02-28 00:48:34\n\n/* remix of https://www.shadertoy.com/view/tdlXW4 */\n\n#define pi (acos(-1.))\n\n//#define LOOP6\n\nint mat;\nvec3 shift;\nfloat tt;\n\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nvec2 rotate(vec2 a,float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p=abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    p=abs(p);\n    return (p.x+p.y+p.z-r)/sqrt(3.);\n}\n\nfloat sdInk(vec3 p)\n{\n    float low=length(max(abs(p)-1.,0.));\n    if(low>.3)return low;\n    \n    float spacing = .15;\n    float thickness = .025;\n#ifdef LOOP6\n    p.y += sin(p.y*3.-tt*pi/3. + 0.2)*.09;\n#else\n    p.y += sin(p.y*3.-tt*2.)*.09;\n#endif\n    p.xz = rotate(p.xz, (floor(p.y/spacing-.5)*spacing+spacing/2.) * .9);\n    float w = .25 + pow(p.y,2.)*.5;\n    shift = p;\n    return max(\n        sdBox(p,vec3(w,.9,w)),\n        abs(mod(p.y-spacing/2.,spacing)-spacing/2.)-thickness\n    )*.8;\n}\n\nfloat sdGold(vec3 p)\n{\n    float low=length(max(abs(p)-1.,0.));\n    if(low>.3)return low;\n    \n#ifdef LOOP6\n    float q = .05*sin(tt*pi/3.);\n#else\n    float q = sin(tt-2.+cos(tt*2.))*.1;\n#endif\n    float box = max(sdBox(p,vec3(1.0)),-sdBox(p,vec3(.96)));\n    float oct = max(sdOctahedron(p,2.01+q),-sdOctahedron(p,1.99+q));\n    oct = min(oct, max(sdOctahedron(p,1.95+q),-sdOctahedron(p,1.9+q)));\n    float edges = 1.25;\n    float oct1 = max(sdOctahedron(p-edges,1.98+q),-sdOctahedron(p,1.850+q));\n    float oct2 = max(sdOctahedron(p+edges,1.98+q),-sdOctahedron(p,1.850+q));\n    return max(box, min(min(oct1,oct2), oct));\n}\n\nfloat sdGround(vec3 p)\n{\n    return p.y+1.3;\n}\n\nfloat scene(vec3 p)\n{\n    float ground = sdGround(p);\n    \n    float ink = sdInk(p);\n    float gold = sdGold(p);\n    \n    float best = min(min(ink,gold),ground);\n    \n    if(ink==best) mat=0;\n    else if(gold==best) mat=1;\n  \telse mat=2;\n    \n  \treturn best;\n}\n\nfloat noisefloor(vec2 uv,float t)\n{\n    float n = texNoise(uv*.1).r*4.-1.;\n    \n#ifdef LOOP6\n    float m = mod(tt, 6.);\n    float t0 = texNoise(vec2(n+m*t)).r;\n    float t1 = texNoise(vec2(n+(m-6.)*t)).r;\n    return mix(t0, t1, m/6.);\n#else\n    return texNoise(vec2(n+tt*t)).r;\n#endif\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t =98.;\n    float k =0.;\n    vec3 accum = vec3(1);\n    vec3 emit = vec3(0);\n    for(int i=0;i<200;++i){\n        k=scene(cam+dir*t);\n        t+=k;\n        \n        if(k>3.5)break;\n        \n        if(abs(k)<.001)\n        {\n            vec3 h = cam+dir*t;\n            vec2 o = vec2(.001,0);\n            vec3 n = normalize(vec3(\n                scene(h+o.xyy),\n                scene(h+o.yxy),\n                scene(h+o.yyx)\n            )-scene(h));\n            \n            if (mat == 0)\n            {\n#ifdef LOOP6\n                float f = -0.9*mod(1.0+abs(sin(pi*tt/3.-0.2)), 8.42);\n#else\n                float f = -0.9*mod(1.0+abs(sin(tt)), 8.42);\n#endif\n                vec3 pos = floor(shift*10.+.5);\n                float noise = noisefloor(f*shift.xz*.5+pos.y*.9,0.)*2.-.25;\n                float fresnel = pow(max(0.,1.-dot(-dir,n)),5.)*.5;\n                accum *= fresnel;\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n                emit += pow(noise,6.5)*10. * vec3(19.1,.1,.4) * 2.;\n            }\n            else if (mat == 1)\n            {\n                accum *= .7;\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n            }\n            else if (mat == 2)\n            {\n                float noise = noisefloor(h.xz,.1)*2.-.1;\n                noise *= exp(-0.1 * dot(h.xz,h.xz));\n                accum *= noise*.7+.3;\n                accum *= vec3(.04,.04,0.05);\n                cam = h+n*.01;\n                dir = mix(reflect(dir,n),n,noise*.3);\n                t = 0.;\n            }\n        }\n    }\n    return accum+emit;\n}\n\nvec4 image(vec2 coord)\n{\n    vec2 uv = coord/ iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-100);\n    vec3 dir = normalize(vec3(uv,25));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n#ifdef LOOP6\n    float a = pi*tt/3. - 1.4;\n    a = .3 + (a - .95 * sin(a));\n#else\n    float a = pi * tt / 4.;\n    a = .3 + (a - .8 * sin(a)) / 2.;\n#endif\n    \n    cam.xz = rotate(cam.xz, a);\n    dir.xz = rotate(dir.xz, a);\n\n    vec3 col = trace(cam,dir);\n    col = max(vec3(0), col);\n    col = 1.3 * pow(col, vec3(1) / 2.2);\n    col *= 1. - .6*dot(uv,uv);\n    \n    return vec4(col, 0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    out_color = vec4(fragCoord, iFrame, 1);\n    for(int i=0; i<8; i++)out_color = fract(1e4*sin(out_color) + out_color.wxyz);\n   \tout_color *= 1.0 / 256.0;\n    \n    float dt = iTimeDelta;\n    vec4 acc = vec4(0);\n    for(int i=0; i<4; i++)\n    {\n        vec2 u = 2. * fragCoord + vec2(i&1, i>>1);\n        float d = texelFetch(iChannel0, ivec2(u)%64, 0).x;\n        tt = iTime + dt * d;\n        acc += image(0.5 * u);\n    }\n    \n    out_color += acc / 4.;\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 302, 326, 326, 564], [566, 566, 595, 595, 706], [708, 708, 737, 737, 789], [791, 791, 828, 828, 881], [883, 883, 904, 904, 1378], [1380, 1380, 1402, 1402, 2002], [2004, 2004, 2028, 2028, 2050], [2052, 2052, 2073, 2073, 2312], [2314, 2314, 2349, 2349, 2600], [2602, 2602, 2634, 2634, 4282], [4284, 4284, 4308, 4308, 4920], [4922, 4922, 4974, 4974, 5429]]}
{"id": "tdsXRM", "name": "[TWITCH] Dali's mustache train", "author": "evvvvil", "description": "\"The train along Dali's mustache\" - Shader showdown practice session 008.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 20:30 UK time.\nhttps://www.twitch.tv/evvvvil_", "tags": ["time", "demoscene", "abstract", "limit", "live", "train", "battle", "shadershowdown", "coding", "twitch", "showdown", "dali", "mustache"], "likes": 19, "viewed": 1177, "published": "Public API", "date": "1550937845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"The train along Dali's mustache\" - Shader Showdown practice session 008\n\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 20:30 UK time I practise live on TWITCH.\n// This is the result of session 008. \n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"The only difference between me and a madman is that I am not mad.\" - Salvador Dali\n\nvec2 sc,e=vec2(.00035,-.00035);float t,tt,at,st;vec3 np,ro,bp;//Some fucking globals, about as exciting as a wet piece of cardboard\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//box function stolen from UNC because IQ was busy eating tapas\nvec2 fb( vec3 p ) //fucking bit function creates a piece and then we clone and tweak it in the mp map function. Just like boredom and veganism: they are related.\n{//Sort of a train track broski, this isn't \"Southwest\" trains, so it will arrive on time, despite the driver being drunk\n\n  vec2 h,t=vec2(bo(abs(p)-vec3(2,0,0),vec3(.4,.4,3)),5);//this creates two rectangle cloned out with symetry along x axis, \n  h=vec2(1000,3);//setup next shape to be huge numbrer so we can directly mix in new shapes\n  for(int i=0;i<4;i++){//in da loop we keep cloning rectangles along the z to create inner rectangles on the train tracks\n    h.x=min(h.x,bo(abs(p)-vec3(0,0,0.85*float(i)),vec3(2,0.15,0.15)));//adding ractanlges, because the tracks you leave are more important than correct fcuking spellling\n  }\n  t.x=min(t.x,0.7*bo(p,vec3(15,0.2+at*.1,0.2+at*.1)));//long horizontal box that gets spread out by attractor(at), \"Oi mate, fancy moving along yeah? You fucking prancer\"\n  t=(t.x<h.x)?t:h;//Mixes t-blue bits and h-black bits with material ID. Blends geometries but should not be confused with an actual blender as it does not care for juicing diets pseudo-science.\n  t.x*=0.6;//this increases the definition so we don't get artifacts, becuase the influence is Dali, not your nephew shitty drawings that you are forced to leave on the fridge.\n  return t;\n}\n\nfloat noise(vec3 p){//Noise function stolen from Virgil who stole it from Shane who I assume understands this shit, unlike me who is far too busy trading pokemon cards\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip;\n  vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);//Ah, yes I understand this bit: it draws a shape which, if you are drunk enough, looks like a penis\n}\n\n\nvec2 fc( vec3 p )//This function is dumb as fuck it creates a hollow rectangle, which looks like a painting frame\n{//Something sort of Dali about it especially with the noise on the outside edges, i assume he would have wanted to rub his mustache against it\nfloat noi=noise(p);//Add a bit of noise to the edge of the frame to make it more Dali-esque\nvec2 t=vec2(bo(p,vec3(12.+noi,12.+noi,1)),6);//Create a dumb fucking rectangle wide, tall, but thin, bit like as if I folded your annoying uncle\nt.x=max(t.x,-bo(p,vec3(10,10,2)));//This digs a fucking hole in the above rectangle making it into a frame/hollow rectangle\nt.x*=0.5;//this increases the definition so we don't get artifacts. Mustache grooming, because hipsters didnt invent anything\n  return t;\n}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//simple rotate function, it is useful as fuck and short. Bit like a flexible midget\n\nvec2 mp( vec3 p ) //This is the main MAP function where all geometry is made/defined. It's centre stage broski, unlike you trying to make a best man speech at your ex's wedding.\n{\n  p.xy*=r2((p.z-ro.z)*st*0.1);//st is switchtwist and as it says on the fucking tin: it twists along z\n  np=bp=p;//We create new positions np and bp which we will modulo, tweak, push rotate and then pass to the fucking bit function\n  np.z=mod(np.z+tt*10.,6.)-3.;//first mod makes inifinite z axis and move towards you, \"The train arriving at La Ciota\" aint't got nothing on us mother fucker.\n  bp.z=mod(bp.z+tt*20.,60.)-30.;//this double modulo will push attractor close to you and again into infitnity\n  at=max(0.,(6.-(length(bp)-6.)));//This create the attractor (reverse attractor) which pushes and rotates the geometry apart to reveal it\n  for(int i=0;i<2;i++){//In da loop, sort of, pretty fuckign weak though i mean loop running twice, that ain't a loop it's a small-time recuring offender\n   np=abs(np)-vec3(0.3*at,0.5*at,0);//this clones the train track along the x and y axis only happens to geometry within radius of attractor\n   np.xy*=r2(at*0.1);//this rotates the traintracks along xy axis only happens to geometry within radius of attractor \n   np.xz*=r2(at*0.1);//this rotates the traintracks along xz axis only happens to geometry within radius of attractor\n   np.xz*=r2(sin(bp.z*0.1)*st*.5);//This twists/rotates the train track every so often along the xz axis to make it less boring\n  }\n  vec2 h,t=fb(np);//Passing the new position to fucking bit function to create more complex geometry, \n  h=vec2(0.3*length(abs(np)-vec3(4,at,1))-0.2*at,6);//This creates spheres which are snug to the blue/black geometry it reuses np again but with 1 more abs symstery cloning\n  t=(t.x<h.x)?t:h;//This is classic line to mix two shapes together while retaining their material ids and idividual colors\n  np.xy*=r2(.785);//this rotates np 45 degree so that the white frames are like triangular arches rather than square.\n  h=fc(np);//This create the outter frame with the fc function (the comments in this function are more entertaining than the function itself so go on, have a gander)\n  t=(t.x<h.x)?t:h;//This is classic line to mix two shapes together while retaining their individual colors.\n  t.x=max(t.x,-0.5*(length(p-ro)-2.));//Simple trick with sphere around camera to remove any geometry colliding. \"1:Personal space. 2:Personal space. 3:Stay away from my personal space\"\n  return t;\n}\n\nvec2 tr( vec3 ro,vec3 rd )//Main raymarching function with material ID flex, because heckling during your children's school play is always funny.\n{\nvec2 h,t=vec2(0.1);//0.1 is our near plane\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);//get result of running map function at this ray pos\n        if(h.x<.0001||t.x>50.) break;//Get out early if we hit geom (<precision which is 0.0001) or we hit far plane (t.x>50)\n        t.x+=h.x;t.y=h.y;//t.y=h.y passes the material ID\n    }\n    if(t.x>50.) t.x=0.;//Exit early optimizes, because just like me, your GPU needs a drink sometimes, or 7!\n    return t;//always return this return that, you're a fucking broken record you know that?\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    tt=mod(iTime*0.5,100.);//My time variable which everything uses to animate. This is modulo to avoid ugly artifact.\n\n    ro=vec3(0,2,-19);//Ro=ray origin=camera position \n    st=clamp(cos(tt),0.,1.);//St=switch twist is an animation variable which defines if we are twitsting the whole scene along z axis or not\n    vec3 rd=normalize(vec3(uv,0.5)),co,fo,//ro=ray direction (where the camera is pointing), co=final color, fo=fog color\n    ld=normalize(mix(vec3(0.5,.2,-.1),vec3(0.3,0.5,-.5),st));//light direction, because god likes to point finger with dramatic effect\n    co=fo=vec3(0.9)*(1.-(length(uv)-0.2));//By default the color fog color and it's a light coloured vignette\n\n    sc=tr(ro,rd);t=sc.x;//This is where we shoot the fucking rays to get the scene, like God playing fetch with them fucking angels again\n\n    if(t>0.){//If t>0 then we must have hit some geometry so let's shade it.\n    //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I hang out with Socrates, corrupting the youth\n    vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n        \n    //LIGHTING MICRO ENGINE BROSKI \n    al=max(vec3(0,.8,1)-at*0.2,0.);//al=albedo this is the base colour defined by material id, by default it's blue with gradient depending on the sphere attractor\n    no*=(1.+0.6*ceil(cos(np*2.)));no=normalize(no);//This normals trick shift the normals and creates details sort of like metal plaque \n    if(sc.y<5.) al=vec3(0);//This says ok different material id so im gonna make this shape black...\n    if(sc.y>5.) al=vec3(1);//or white. Simple and sweet, like the village idiot covered in sugar.\n\n    float dif=max(0.,dot(no,ld)),//dif=diffuse becuase I ain't got time to cook torrance\n    aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),//ao = ambient occlusion, aor = ambient occlusion range\n    //spo=specular power, THIS TRICK is some fucking sweet gloss map generated from recursive noise function. Fuck yeah broski!\n    spo=exp2(1.+3.*noise(np/vec3(0.4,.8,.8)+noise(np/vec3(0.1,.2,.2)))),\n    fr=pow(1.+dot(no,rd),4.);//Fresnel blends the geometry in the background with some sort of gradient edge reflection mother fucker\n    vec3 sss=vec3(0.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),//Fake sub surface fucking scattering, from tekf, big up tekf! https://www.shadertoy.com/view/lslXRj\n    sp=vec3(0.5)*pow(max(dot(reflect(-ld,no),-rd),0.),spo);//specular by shane. Even better than rubbing your cheeks against frozen barbed-wire\n\n    co=mix(sp+al*(0.8*ao+0.2)*(dif+sss),fo,min(fr,0.2));//Final lighting result: taking it all in, and then crushing it into an RGB shit sandwich\n    co=mix(co,fo,1.-exp(-.00006*t*t*t));//Adding some nice fog, feels nice like when you manage to put your socks on in one seamless gesture. What a beautiful world we live in the west.\n    }\n    vec3 allIWantedForChristmasWasBrexitButAllIGotWasThisLousyGermanSausage=co;\n    fragColor = vec4(pow(allIWantedForChristmasWasBrexitButAllIGotWasThisLousyGermanSausage,vec3(0.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1003, 1073, 1097, 1097, 1143], [1143, 1207, 1370, 1490, 2560], [2562, 2562, 2582, 2729, 3054], [3057, 3057, 3172, 3314, 3815], [3816, 3816, 3833, 3833, 3876], [3876, 3962, 4141, 4141, 6440], [6442, 6442, 6589, 6589, 7131], [7132, 7132, 7189, 7189, 10448]]}
{"id": "tdsXRn", "name": "Raytracing0 - Primitives ", "author": "bearworks", "description": "Raytracing Primitives using Ideal Reflection and Refraction Rays Based on https://www.shadertoy.com/view/Xds3zN\n\n\n\n\n\n\n\n\n", "tags": ["procedural", "3d", "raytracing", "raymarching", "distancefields", "primitives"], "likes": 10, "viewed": 323, "published": "Public", "date": "1550687074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nBased on https://www.shadertoy.com/view/Xds3zN\n\nA Fake Raytracing using Ideal Reflection and Refraction Rays\n\n*/\n\n#define AA 1   // make this 2 or 3 for antialiasing\n#define SOFTSHADOW 1 // make this 0 for hard shadow\n#define MODE 2 // make this 0,1,2 for reflection,refraction,both objects\n#define REFRACTIDX 1.2\n\nvec3 skyCol =  vec3(0.7, 0.9, 1.0);\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r )\n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s )\n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n    return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n    p = p*p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n    p = p*p; p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nbool isReflection(float m)\n{\n#if MODE>1\n        bool reflection = m < 15.;\n#elif MODE>0\n        bool reflection = m < 2.;\n#else\n        bool reflection = m > -6999.;\n#endif\n    \n   \treturn reflection;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x<-0.5 )\n    {\n    res = opU( res, vec2( opS(\n                          sdRoundBox(  pos-vec3(-2.0,0.21, 1.0), vec3(0.15),0.05),\n                          sdSphere(    pos-vec3(-2.0,0.21, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n                          sdTorus82(   pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n                          sdCylinder(  \n                               opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    res = opU( res, vec2( 0.5*sdSphere(pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(45.0*pos.x)*sin(45.0*pos.y)*sin(45.0*pos.z), 65.0 ) );\n    res = opU( res, vec2( 0.6*sdTorus(\n                              opTwist( pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-2.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    }\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdOctahedron(pos-vec3(-1.0,0.15,-2.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n    res = opU( res, vec2( sdCappedCone(pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.30, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdRoundBox(  pos-vec3( 1.0,0.30, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-2.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20,-2.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad )\n{\n    vec3 m = 1.0001/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\nconst float minRay = 0.01;\nfloat minRefrac = 0.0;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = minRay;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0001 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = max(tmin,minRefrac);\n#if AA>1\n        for( int i=0; i<70 * AA && t<tmax; i++ )\n#else\n        for( int i=0; i<70 && t<tmax; i++ )         \n#endif\n        {\n            vec2 h = map( ro+rd*t );\n            \n            t = minRefrac > 0. ? abs(t) : t;\n            if( abs(h.x)<(0.0001*t) )\n            {\n                res = vec2(t,h.y);\n                break;\n            }\n            t +=  minRefrac > 0. ? -(h.x) : h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcHardshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    for( float t=mint; t < tmax; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n                      e.yyx*map( pos + e.yyx ).x +\n                      e.yxy*map( pos + e.yxy ).x +\n                      e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        vec2 mapp = map( aopos );\n        float dd = mapp.x;\n        occ += -(dd-hr)*sca * (isReflection(mapp.y) ? 1.0 : 0.5);\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    float fDis = 100.;\n    for( int bounce = 0; bounce<10; bounce++ ) // bounces of GI\n    {\n        vec2 res = castRay(ro,rd);\n        float t = res.x;\n        float m = res.y;\n        \n        if(m < -0.5)\n        {\n           if(bounce == 0)\n              accumulatedColor = skyCol;\n            \n           return vec3( clamp(accumulatedColor,0.0,1.0) );\n        }\n        \n        if(bounce == 0) fDis = t;\n           \n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\n        bool reflection = isReflection(m);\n\n        //nor = reflection || minRefrac < minRay ? nor : -nor;\n            \n        // material        \n        if( m<1.5 )\n        {\n            float f = checkersGradBox( 5.0*pos.xz );\n            colorMask *= 0.3 + f*vec3(0.1);\n        }\n        else\n            colorMask *= 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n        vec3 ref = reflect( rd, nor );\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5*occ+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n        #if SOFTSHADOW>0\n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        #else\n        dif *= calcHardshadow( pos, lig, 0.02, 2.5 );\n        #endif\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n            dif *\n            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.30*amb*skyCol;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        \n        nor = reflection || minRefrac < minRay ? nor : -nor;\n        \n        if(reflection)\n        {\n            accumulatedColor += colorMask*(lin + 9.00*spe*vec3(1.00,0.90,0.70));\n\n            colorMask *= clamp(1.0+0.77*dot(nor,rd),0.0,1.0);\n            rd = ref;\n            ro = pos;\n            minRefrac = 0.;\n              \n            accumulatedColor = mix( accumulatedColor, skyCol, 1.0-exp( -0.0004*fDis*fDis*fDis ) );\n        }\n        else\n        {\n            accumulatedColor += colorMask*fre*(lin + 9.00*spe*vec3(1.00,0.90,0.70));\n\t\t\t\n            rd = refract(rd, nor, 1.0/ REFRACTIDX);\n            ro = pos;\n\n            minRefrac = minRefrac < minRay ? minRay : 0.;\n    \n        }\n       }\n\n    minRefrac = 0.;\n        \n    return vec3( clamp(accumulatedColor,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 15.0 + iTime;\n\n    // camera    \n    vec3 ro = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render    \n        vec3 col = render( ro, rd );\n\n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 426, 451, 451, 469], [471, 471, 506, 506, 532], [534, 534, 565, 565, 656], [658, 658, 717, 717, 811], [813, 813, 867, 867, 962], [964, 964, 997, 997, 1052], [1054, 1054, 1090, 1090, 1401], [1403, 1403, 1455, 1455, 1578], [1580, 1580, 1644, 1644, 1922], [1924, 1924, 1948, 1948, 1965], [1966, 1966, 2029, 2093, 2680], [2682, 2682, 2725, 2725, 2976], [2978, 2978, 3014, 3014, 3197], [3199, 3211, 3247, 3247, 3350], [3352, 3377, 3428, 3428, 3783], [3785, 3785, 3823, 3823, 3992], [3994, 3994, 4019, 4019, 4038], [4039, 4039, 4110, 4110, 4448], [4961, 4961, 4986, 4986, 5026], [5028, 5028, 5053, 5053, 5117], [5119, 5119, 5144, 5144, 5215], [5217, 5217, 5252, 5252, 5323], [5325, 5325, 5360, 5360, 5431], [5433, 5433, 5470, 5470, 5523], [5525, 5595, 5628, 5628, 5654], [5656, 5656, 5686, 5686, 5722], [5724, 5724, 5754, 5754, 5783], [5785, 5785, 5809, 5809, 5941], [6043, 6113, 6141, 6141, 6315], [6317, 6317, 6342, 6342, 9145], [9147, 9215, 9265, 9265, 9479], [9558, 9558, 9598, 9598, 10558], [10560, 10622, 10700, 10723, 11070], [11072, 11072, 11150, 11150, 11313], [11315, 11379, 11411, 11411, 11984], [11986, 11986, 12028, 12028, 12410], [12413, 12489, 12525, 12546, 12769], [12771, 12771, 12810, 12810, 15697], [15699, 15699, 15751, 15751, 15940], [15942, 15942, 15999, 15999, 16974]]}
{"id": "tdsXRr", "name": "Simple 3D Sphere", "author": "synergyseeker1", "description": "A simple 3D sphere made from 2 radial lights, distance fields. cropped at circle distance.", "tags": ["3d", "colors", "fake", "lighting", "sphere", "lights", "artofshaders", "cirlce"], "likes": 6, "viewed": 552, "published": "Public API", "date": "1550518796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// shading 3D sphere\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n\t// normailze and adjsut for ratio\n    vec2 res = iResolution.xy,\n    uv = (fragCoord*2.0-res ) / res.y;\n\tuv*=.7;\n    //initilize colors\n\tvec4 color1 = vec4(.4,.6,.7,1.0);\n    vec4 color2 = vec4(.9,.7,.6,1.0);\n    \n    // shade with 2 faux lights\n    color1*=.8-distance(uv,vec2(-.1,-.1));\n    color2*=.6-distance(uv,vec2(.25,.3));\n \tvec4 sphere = color1+color2 ;\n    \n    //limit edges to circle shape\n    float d = distance(uv, vec2(0.0));\n    // smooth edges\n\tfloat t =1.0- smoothstep(.6,.61, d);\n    // apply shape to colors\n    sphere*=t+sin(iTime)*.2*uv.y;\n    \n    //output final color, and brighten\n\tfragColor = sphere*1.6;\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 22, 78, 116, 720]]}
{"id": "tdsXWH", "name": "bookofshaders Clouds", "author": "milolouis", "description": "Taken from the fantastic bookofshaders", "tags": ["noise", "cloud", "perlin", "bookofshaders"], "likes": 7, "viewed": 115, "published": "Public", "date": "1551214410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy*6.0;\n    \n    //---------------------\n    \n    // st += st * abs(sin(u_time*0.1)*3.0);\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 185, 213, 213, 321], [323, 401, 428, 428, 810], [835, 835, 861, 861, 1199], [1201, 1201, 1258, 1308, 2122]]}
{"id": "tdXSDn", "name": "dotgrid2", "author": "lennyjpg", "description": "asdfasdfasdfasdf", "tags": ["grid", "dots"], "likes": 1, "viewed": 277, "published": "Public API", "date": "1551050988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 p = fragCoord  + iMouse.xy + iTime ;    \n    \n    float dd = snoise(iTime*0.03+uv*.5)*3.0;\n    float ee = snoise(iTime*0.03+uv*.5)*370.0;\n\n    p.x+=sin(dd)*ee;\n    p.y+=cos(dd)*ee;\n\n    p.y -= iTime * 100.;\n    p.x -= iTime * 100.;\n\n    p.y+=sin(p.y*.1)*3.1;\n    float s = 100.;\n    \n    vec2 c = vec2(sin(iTime*3.),cos(iTime*3.))*0.2+1.2;\n    uv*=c;\n    //p+=snoise(p*.11)*uv.y*100.0;\n        \n    float n = 1.0;//snoise(uv*7.0)*2.0;\n    float t = 5. * iTime ;\n    \n    t += sin(uv.x*10.1);\n    float k = cos(t)+1.;\n\n   \tvec2 g = mod(p,s)/s;\n    float e = g.x*g.y;\n    float v = 1.0;\n    if( sin(t) > 0. ){\n\t    p.x -= k * step(s, mod(p.y, s * 2.)) * s;   \n    }else{\n        p.y -= k * step(s, mod(p.x, s * 2.)) * s;\n    }\n    \n    float d = length(mod(p,s)-0.5*s);    \n    v = uv.y * 1.2;\n    float points = smoothstep(d,d*.9,1.0+70.*v);\n    fragColor = vec4(.2+points);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 45, 45, 84], [86, 86, 107, 107, 927], [929, 929, 986, 986, 1912]]}
{"id": "tdXSRn", "name": "Raymarch Mandelbox 2", "author": "darkeclipz", "description": "Variant of https://www.shadertoy.com/view/3dfXzr, with different folds.", "tags": ["raymarch", "mandelbox"], "likes": 10, "viewed": 508, "published": "Public", "date": "1550430035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 32.\n#define MinDistance 0.0075\n#define eps 0.0001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    \n    float fixedRadius2 = .6 + 4.* cos(20./8.) + 4.;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 20.;\n    float Scale = 3.6;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n        \n\n        z = mengerFold(z);\n        z = boxFold(z, vec3(2.));       // Reflect\n        sphereFold(z, dr);    // Sphere Inversion\n        z.xz = -z.zx;\n\t\tz = boxFold(z, vec3(1.));       // Reflect\n        \n\t\tsphereFold(z, dr);    // Sphere Inversion\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n\treturn box;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,1,0), 25., vec3(.2,.2,.4));\n    \n    mat3 rot = rotateZ(iTime / 10.) * rotateY(iTime / 10.) * rotateX(iTime / 10.);\n    \n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,5) * rot, 10., vec3(.4,.1,.1));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,-5) * rot, 10., vec3(.4,.1,.1));\n    vec3 L3 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,5) * rot, 10., vec3(.4,.1,.1));\n    vec3 L4 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,-5) * rot, 10., vec3(.4,.1,.1));\n    \n\n    mat3 rot2 = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    vec3 camPos = (vec3(0,0,-3)- vec3(0,1,15)) * rot2 ;\n    vec3 cam = shadeBlinnPhong(p, rd, sn, camPos, 13., vec3(.9));\n    \n    vec3 ambient = vec3(.25);\n    return L1 + L2 + L3 + L4 + ambient + top + cam;\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0,-3); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    \n    ro -= vec3(0,1,15);\n    ro *= rot;\n    rd *= rot;\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        col += light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        col = mix(col, vec3(0), clamp(1.-10./t, 0., 1.));\n    }\n    else {\n        col = vec3(0);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 197, 224, 224, 310], [312, 312, 339, 339, 425], [427, 427, 454, 454, 532], [534, 534, 567, 567, 596], [598, 609, 646, 646, 677], [679, 690, 721, 721, 784], [786, 862, 892, 892, 937], [939, 1065, 1112, 1112, 1405], [1407, 1483, 1508, 1508, 1674], [1676, 1774, 1791, 1791, 2378], [2380, 2380, 2400, 2400, 2444], [2446, 2446, 2472, 2472, 2491], [2493, 2504, 2529, 2529, 2801], [2803, 2881, 2911, 2911, 3202], [3204, 3204, 3241, 3241, 3477], [3481, 3548, 3655, 3655, 4413], [4415, 4490, 4528, 4528, 5330], [5332, 5393, 5461, 5461, 5506], [5508, 5508, 5565, 5565, 6280]]}
{"id": "tdXSW4", "name": "CityView (Beginner)", "author": "asdhyq", "description": "Beginner", "tags": ["calm"], "likes": 1, "viewed": 47, "published": "Public", "date": "1551325502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 white = vec3(0.,0.,0.);\nvec3 black = vec3(0.,0.,0.);\nvec3 colorA = vec3(0.2509,0.1568,0.2901);\nvec3 colorB = vec3(0.4509,0.2627,0.2941);\nvec3 colorC = vec3(0.7019,0.3019,0.1450);\nvec3 colorD = vec3(0.9411,0.4941,0.0274);\nvec3 colorE = vec3(0.9686,0.8705,0.3333);\n\n\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n    \n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 center = vec2(0.1, 0.1);\n\tfloat width = .1;\n\tfloat height = .3;\n\n    // Background layer\n\tvec4 bg = vec4(white, 1.0);\n\t\n\t// Rectangle\n\tvec3 col = black;\n\tvec4 rect = rectangle(uv, center, width, height, col);\n\t\n\tvec3 color = mix(colorA,colorB,uv.y);\n    color = mix(color,colorC,uv.y);\n\tcolor = mix(color,colorD,uv.y);\n    color = mix(colorE,color,uv.y);\n    \n    color = mix(colorA,color,sin(iTime + uv.y)) * mix(colorA,color,sin(iTime +  uv.y)) ;\n    \n    \n    // Blend the two\n\tcolor = mix(color, black, rect.a);\n    color = mix (color, black,rectangle(uv,vec2(.195,.1),.08,.2,col).a);\n    color = mix (color, black,rectangle(uv,vec2(.28,.1),.08,.5,col).a);\n    color = mix (color, black,rectangle(uv,vec2(.37,.1),.08,.4,col).a);\n    color = mix (color, black,rectangle(uv,vec2(.455,.1),.08,.9,col).a);\n    color = mix (color, black,rectangle(uv,vec2(.542,.1),.08,.7,col).a); \n    color = mix (color, black,rectangle(uv,vec2(.63,.1),.08,.8,col).a);  \n    color = mix (color, black,rectangle(uv,vec2(.72,.1),.08,.5,col).a);  \n    color = mix (color, black,rectangle(uv,vec2(.81,.1),.08,.5,col).a);\n      \n    color = mix (color, black,rectangle(uv,vec2(.90,.1),.08,.3,col).a);\n\n    \n    // Output to screen\n    \n    \n    fragColor = vec4(color ,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 344, 344, 542], [545, 545, 602, 602, 1907]]}
{"id": "tdXSWN", "name": "1 000 000 dreams", "author": "Ridge", "description": "One of my first ray marching projects. This was made more than a year ago but this is probably the best that I've been able to do so far. Now it's finally published!", "tags": ["raymarching", "water", "balls"], "likes": 11, "viewed": 147, "published": "Public", "date": "1551275117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Create a two-dimensional rotation matrix\nmat2 rot(in float a){float s = sin(a); float c= cos(a); return mat2(c,s,-s,c);}\n\n// Signed distance field function of a sphere\nfloat sphere(vec3 p, float r){return length(p)-r;}\n// Use modulo to copy the spheres\nfloat copy(float p, float d){return mod(p, d) - d/2.0;}\n\n// The distance to the closest sphere\nfloat map(vec3 p){\n    p.y-= iTime;\n    p.xz = p.xz*rot(iTime/11.);\n    p.x -= iTime*3.0;\n    p.x = copy(p.x, 10.0);\n    p.z = copy(p.z, 10.0);\n    p.y = copy(p.y, 5.0);\n    float s1 = sphere(vec3(p.x, p.y - 0.0, p.z), 1.0);\n    float s2 = sphere(vec3(p.x, p.y - 2.5, p.z), 1.0);\n    float s3 = sphere(vec3(p.x, p.y + 2.5, p.z), 1.0);\n \treturn min(min(s1, s2), s3);\n}\n\n// The distance to the closest point on the water\nfloat wmap(vec3 p){\n \treturn p.y+0.3;\n}\n\n// Use raymacrching to get the point in which the ray hits a ball\nvec3 trace(vec3 ro, vec3 rd){\n    int i = 0;\n    vec3 mp = ro;\n \tfor (i = 0; i < 60; i++)\n    {\n        float dist = map(mp);\n        mp += rd*dist;\n        if(dist < 0.01){break;}\n    }\n\treturn mp;\n}\n\n// Distort the normal of the plane to create the water effect\nvec3 distort(vec3 p, float i){return vec3(p.x + sin(p.x*315.+iTime*1.2)*i/10.,p.y +cos(p.y*321.+iTime)*i,p.z + sin(p.z*300.+iTime)*i/10.);}\n\n// Use raymacrching to get the point in which the ray hits the water\nvec3 wtrace(vec3 ro, vec3 rd){\n    int i = 0;\n    vec3 mp = ro;\n \tfor (i = 0; i < 100; i++){\n        float dist = wmap(mp);\n        mp += rd*dist;\n        if(dist < 0.01){break;}\n    }\n\treturn mp;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates in the center of the screen are 0,0\n    // Using x-resolution to scale the coordinates (-1 to 1 on x axis)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    // Ray orignin and ray dispance for the ray marching loops\n    vec3 ro = vec3(0.0); vec3 rd = normalize(vec3(uv.x, uv.y, 2.0));\n    // How far the ray can travel before hitting a sphere\n    float dist1  = length(trace(ro, rd));\n    // The point in which the ray hits water\n    vec3 wp = wtrace(ro, rd);\n    // How far the ray cal travel before hitting water\n    float wdist = length(wp);\n    // The distorted reflection after hitting water\n    vec3 wnormal = normalize(distort(vec3(rd.x, -rd.y, rd.z), 0.02));\n    // The distance from water to the sphere the reflection ray hits\n    float rdist = length(trace(ro + rd*wdist, wnormal)) - wdist;\n    vec3 col = vec3(0.0);\n    // Background color\n    vec3 bgcol = vec3(0.125, 0.25, 0.5)*(uv.y+0.1);\n    // Water Background color\n    vec3 wbgcol = vec3(0.125, 0.25, 0.5)*(-uv.y*1.0-0.1);\n    // If the ray hits nothing, use the bg color\n    if(min(dist1, wdist) > 120.0)\n        col = bgcol;\n    else\n    {\n        // If the ray hits a sphere, use the sphere's white color, blend its color with the background\n        if(dist1 < wdist)\n            col = mix(vec3(1.0), bgcol, dist1/120.);\n        else\n        {\n            // Does the reflection ray hit a sphere? No: use the water background color\n            if(wdist + rdist > 120.)\n                col = wbgcol;\n            // Yes: Blend the sphere's color with the water background color\n            else\n        \t\tcol = mix(vec3(1.0), wbgcol, (wdist + rdist)/120.);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 65, 65, 123], [125, 171, 201, 201, 221], [222, 256, 285, 285, 311], [313, 351, 369, 369, 718], [720, 770, 789, 789, 809], [811, 877, 906, 906, 1077], [1079, 1141, 1171, 1171, 1280], [1282, 1351, 1381, 1381, 1549], [1550, 1550, 1607, 1733, 3385]]}
{"id": "tdXSz4", "name": "RayTracing Tutorial - Step 4", "author": "BrunoLevy", "description": "Shadows...", "tags": ["raytracing", "tutorial"], "likes": 0, "viewed": 360, "published": "Public API", "date": "1550694619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n};\n\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, vec3(0.0, 0.0, 0.0));\n}\n\nMaterial light(in vec3 Ke) {\n   return Material(vec3(0.0, 0.0, 0.0), Ke);\n}\n\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\nObject scene[3];\n\nvoid init_scene() {\n   float beta = float(iFrame)/30.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      diffuse(vec3(1.0, 1.0, 1.0))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n      diffuse(vec3(1.0, 0.0, 0.0))\n   );\n\n   scene[2] = Object(\n      Sphere(vec3(5.0, 0.0, 3.0),0.02),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n\n//   scene[3] = Object(\n//      Sphere(vec3(1.5, 0.0, 1.5),0.02),\n//      light(vec3(1.0, 1.0, 1.0)) \n//   );\n\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n \nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n           float lamb = max(0.0, dot(E,N) / length(E));\n           result += lamb * material.Kd * scene[i].material.Ke;\n         }\n      }\n   }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n\n   if(t != FARAWAY) {\n      fragColor.rgb = lighting(P,N,material);\n   }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 281, 281, 579], [581, 581, 618, 618, 715], [848, 848, 878, 878, 925], [927, 927, 955, 955, 1002], [1082, 1082, 1101, 1101, 1616], [1618, 1618, 1677, 1677, 1943], [1946, 1946, 1969, 1969, 2253], [2255, 2255, 2314, 2314, 2818], [2820, 2820, 2877, 2877, 3626]]}
{"id": "tdXXRM", "name": "TV-Noise", "author": "arthurstammet", "description": "Inspired by https://www.youtube.com/watch?v=zXsWftRdsvU\nValue Noise Explained", "tags": ["noise", "tv", "animation"], "likes": 4, "viewed": 1448, "published": "Public API", "date": "1550828715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Let's make some TV Noise\n\n// Inspired by https://www.youtube.com/watch?v=zXsWftRdsvU\n// Value Noise Explained\n\nfloat Noise21 (vec2 p, float ta, float tb) {\n    return fract(sin(p.x*ta+p.y*tb)*5678.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime+123.; // tweak the start moment\n    float ta = t*.654321;\n    float tb = t*(ta*.123456);\n    \n    float c = Noise21(uv, ta, tb);\n    vec3 col = vec3(c);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 114, 158, 158, 204], [206, 206, 261, 261, 508]]}
{"id": "tdXXWr", "name": "Goop delivery", "author": "sndels", "description": "Doodle of a lo-fi idea", "tags": ["raymarching", "tunnel"], "likes": 2, "viewed": 136, "published": "Public", "date": "1551036354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 500.0\n#define PI 3.14159265\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// sRGB, linear space conversions\n#define stol1(x) (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4))\n#define stol3(x, y, z) vec3(stol1(x), stol1(y), stol1(z))\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n    float specularPow;\n    vec3 emission;\n};\n\nvec3 CAM_POS = vec3(0);\nconst vec3 LIGHT_POS = vec3(0, 0, 4);\nconst vec3 LIGHT_AINT = vec3(0, 0.3, 0);\nconst vec3 LIGHT_DINT = vec3(1.5);\nconst vec3 LIGHT_SINT= vec3(1.5);\n\n// sRGB, linear space conversions\nfloat stol(float x) { return (x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4)); }\nvec3 stol(vec3 c) { return vec3(stol(c.x), stol(c.y), stol(c.z)); }\nfloat ltos(float x) { return (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055); }\nvec3 ltos(vec3 c) { return vec3(ltos(c.x), ltos(c.y), ltos(c.z)); }\n\n\n// Thanks mercury! http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0 * PI / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n\nvec2 scene(vec3 p)\n{\n    vec2 h = vec2(MAX_DIST, 0);\n\n    {\n        // Tunnel\n        vec3 pp = p;\n        pMod1(pp.z, 3.6);\n        pModPolar(pp.xy, 6.0);\n        {\n            // Blocky tunnel \n            vec3 ppp = pp - vec3(0, 0, -0.5);\n            float d = -fBox(ppp, vec3(2.15, 0.7, 5));\n            h = d < h.x ? vec2(d, 1) : h;\n        }\n\n        {\n            // Cutouts\n            vec3 ppp = pp;\n            ppp -= vec3(1.48, 0, 0.26);\n            float d = -fBox(ppp, vec3(0.27, 1.1, 1.01));\n            h = d > h.x ? vec2(d, 1) : h;\n        }\n    }\n\n    {\n        // Screens\n        vec3 pp = p;\n        pMod1(pp.z, 3.6);\n        float d = -fBox(pp - vec3(0, 0, 0.26), vec3(2.17, 0.35, 1));\n        h = d > h.x ? vec2(d, 2) : h;\n    }\n\n    {\n        // Pipes\n        vec3 pp = p;\n        pR(pp.xy, 2.0);\n        pModPolar(pp.xy, 6.0);\n        pp -= vec3(1.81, -0.83, 4.89);\n        pR(pp.yz, PI / 2.0);\n        float d = fCylinder(pp, 0.16, 1000.0);\n        h = d < h.x ? vec2(d, 3) : h;\n    }\n\n    {\n        // Chamfers\n        vec3 pp = p;\n        pR(pp.xy, 2.4);\n        pModPolar(pp.xy, 6.0);\n        pp -= vec3(1.25, 0, 0);\n        pR(pp.xy, -1.35);\n        float d = -fBox(pp, vec3(0.44, 0.48, 1000));\n        h = d > h.x ? vec2(d, 1) : h;\n    }\n\n    return h;\n}\n\nvec2 march(vec3 ro, vec3 rd, float p, float m, int it)\n{\n    vec2 t = vec2(0.1);\n    for (int i = 0; i < it; ++i) {\n        vec2 h = scene(ro + rd * t.x);\n        if (h.x < p || t.x > m)\n            break;\n        t.x += h.x;\n        t.y = h.y;\n    }\n    if (t.x > m)\n        t.y = 0.0;\n    return t;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 v, Material m)\n{\n    // Calculate light position and distance\n    vec3 l = CAM_POS + LIGHT_POS - p;\n    float r2 = dot(l, l);\n    l /= sqrt(r2);\n\n    // Check shadowing\n    float t = march(p + n * 0.001, l, 0.001, MAX_DIST, 100).x;\n    vec3 ambient = m.diffuse * LIGHT_AINT;\n    vec3 diffuse, specular = vec3(0);\n    if (t > sqrt(r2)) {\n        // Do the Blinn-Phong\n        vec3 h = normalize(v + l);\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        diffuse = NoL * LIGHT_DINT * m.diffuse;\n        specular = pow(pow(NoH, m.specularPow) * LIGHT_SINT * m.specular, vec3(10));\n    }\n\n    return ambient + (diffuse + specular) / r2 + m.emission;\n}\n\n\nvec3 normal(vec3 p, float m)\n{\n    vec3 e = vec3(0.0001, 0, 0);\n    vec3 n = vec3(scene(vec3(p + e.xyy)).x - scene(vec3(p - e.xyy)).x,\n                  scene(vec3(p + e.yxy)).x - scene(vec3(p - e.yxy)).x,\n                  scene(vec3(p + e.yyx)).x - scene(vec3(p - e.yyx)).x);\n    return normalize(n);\n}\n\nMaterial material(vec3 p, int i)\n{\n    Material m;\n\n    if (i == 1) {\n        m.diffuse = stol3(0.31, 0.0, 0.0);\n        m.specular = stol3(0.745, 0.011, 0.0);\n        m.specularPow = 64.0;\n    } else if (i == 2) {\n        m.diffuse = stol3(0.06, 0.08, 0.0);\n        m.specular = stol3(0.0, 0.7, 0.07);\n        m.specularPow = 32.0;\n        float wform = sin(p.z * 10.0 - iTime) +\n                      sin(p.z * 12.0 - iTime * 2.0) +\n                      sin(p.z * 20.0 - iTime * 5.0) +\n                      sin(p.z * 15.0 - iTime * 3.0);\n        float dwf = pow(saturate(1.0 - abs(20.0 * p.y - wform)), 5.0);\n        vec3 indicator = vec3(0, 1, 0) * (1.0 / pow(abs(abs(wform) - 5.0), 7.0));\n        m.emission = (stol3(0.55, 0.0, 0.96) * dwf + indicator) * sin(p.y * 300.0);\n    } else if (i == 3) {\n        m.diffuse = vec3(0);\n        m.specular = vec3(1);\n        m.specularPow = 128.0;\n        m.emission = stol3(0.0, 1.0, 0.12) * (1.1 + sin(iTime * 2.0 - p.z));\n    }\n    m.emission /= 2.0 * (p.z - CAM_POS.z);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate neutral camera ray (+Z)\n    vec2 uv = fragCoord.xy / iResolution.xy; // uv\n    uv -= 0.5; // origin an center\n    uv /= vec2(iResolution.y / iResolution.x, 1); // fix aspect ratio\n    vec3 cd = normalize(vec3(uv, 0.7)); // pull ray\n    CAM_POS = vec3(0, 0, iTime);\n\n    // Trace\n    vec2 t = march(CAM_POS, cd, 0.001, MAX_DIST, 256);\n    if (t.x > MAX_DIST) {\n        fragColor = vec4(0);\n        return;\n    }\n    vec3 p = CAM_POS + cd * t.x;\n\n    // Shade\n    Material m = material(p, int(t.y));\n    vec3 color = shade(p, normal(p, t.y), -cd, m);\n\n    fragColor = vec4(ltos(color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[669, 703, 724, 724, 793], [794, 794, 813, 813, 861], [862, 862, 883, 883, 958], [959, 959, 978, 978, 1026], [1029, 1076, 1096, 1096, 1131], [1133, 1133, 1165, 1165, 1207], [1209, 1209, 1249, 1249, 1370], [1372, 1372, 1422, 1422, 1668], [1670, 1670, 1698, 1698, 1779], [1781, 1781, 1829, 1829, 1903], [1906, 1906, 1926, 1926, 3189], [3191, 3191, 3247, 3247, 3493], [3495, 3495, 3543, 3588, 4213], [4216, 4216, 4246, 4246, 4520], [4522, 4522, 4556, 4556, 5558], [5560, 5560, 5617, 5657, 6223]]}
{"id": "tdXXzH", "name": "Tams Voronoi", "author": "baginbix", "description": "Voronoi pattern", "tags": ["voronoi"], "likes": 1, "viewed": 81, "published": "Public", "date": "1550686547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p)\n{\n\tvec3 a = fract(p.xyx * vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    float m = 0.;\n    float t = iTime*.2;\n    vec3 col = vec3(0);\n    float minDist = 100.;\n    float cellIndex = 0.;\n    if(false){\n    for( float i =0.; i<50.; i++)\n    {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n        \n        float d = length(uv-p);\n        m += smoothstep(.02,.01,d);\n        \n        if(d < minDist){\n        \tminDist = d;\n            cellIndex = i;\n        }\n    }\n    }\n    else{\n        uv *= 3.;\n        \n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        vec2 cid = vec2(0);\n        for(float y = -1.; y <=1.; y++){\n            for(float x = -1.; x <=1.; x++){\n                vec2 offs = vec2(x,y);\n                \n                vec2 n = N22(id + offs);\n        \t\tvec2 p = offs + sin(n*t)*.5;\n                p -= gv;\n                float ed = length(p);\n                float md = abs(p.x)+abs(p.y);\n                float d = mix(ed,md,sin(iTime *.5+.5));\n                \n                if(d < minDist){\n        \t\t\tminDist = d;\n            \t\tcid = id + offs;\n        \t\t}\n        \t}\n        }\n        col = vec3(minDist);\n        //col.rg = cid*.1;\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 141], [143, 143, 200, 250, 1476]]}
{"id": "ts23RG", "name": "Brushed Steel Thing", "author": "cbrpnk", "description": "everyday", "tags": ["raymarching"], "likes": 11, "viewed": 259, "published": "Public", "date": "1549228928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 p) {\n    return fract(sin(dot(p, vec2(123.3345, 876.654))) * 984594.2343);\n}\n\nfloat perlin(vec2 p){\n    p *= 10.;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float bl = random(i);\n    float br = random(i + vec2(1, 0));\n    float tl = random(i + vec2(0, 1));\n    float tr = random(i + vec2(1, 1));\n    \n    float x = mix(bl, br, smoothstep(0., 1., f.x));\n    float y = mix(tl, tr, smoothstep(0., 1., f.x));\n    return mix(x, y, smoothstep(0., 1., f.y));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat cube(vec3 p, vec3 d)\n{\n    p = abs(p);\n\tfloat s = length(p) - .7;\n    s = max(s, p.x-d.x);\n    s = max(s, p.y-d.y);\n    s = max(s, p.z-d.z);\n    \n    return s;\n}\n\nfloat caps(vec3 p, float l, float w)\n{\n    return length(vec3(0., p.y, 0.)-vec3(p.x, clamp(p.y, -1., 1.), p.z)) - w;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat map(vec3 p)\n{\n    p.xz = rotate(p.xz, iTime);\n    p.yz = rotate(p.yz, iTime);\n    \n    //p = mod(p+vec3(2.5), 5.)-vec3(2.5);\n    float c = cube(p, vec3(.5));\n    float s = sphere(p, 1.);\n    \n    float h = sphere(p-vec3(.7, 0., 0.), .55);\n    float h2 = sphere(p-vec3(-.7, 0., 0.), .55);\n    float h3 = sphere(p-vec3(0., .7, 0.), .55);\n    float h4 = sphere(p-vec3(0., -.7, 0.), .55);\n    float h5 = sphere(p-vec3(0., 0., .7), .55);\n    float h6 = sphere(p-vec3(0., 0., -.7), .55);\n    \n    vec3 p2 = mod(p+vec3(.1), .5)-vec3(.1);\n    float c1 = caps(p2, .1, .1);\n    float c2 = caps(p2.yzx, .1, .1);\n    float c3 = caps(p2.zxy, .1, .1);\n    \n    vec3 p3 = mod(p+vec3(.2), .38)-vec3(.2);\n    float s2 = sphere(p3, .1);\n    \n    vec3 p4 = mod(p+vec3(.025), .18)-vec3(.025);\n    float s3 = sphere(p4, .05);\n    \n    float d = mix(c, s, .4);\n    d = max(d, -h);\n    d = max(d, -h2);\n    d = max(d, -h3);\n    d = max(d, -h4);\n    d = max(d, -h5);\n    d = max(d, -h6);\n    \n    d = max(d, -c1);\n    d = max(d, -c2);\n    d = max(d, -c3);\n    \n    d = max(d, -s2);\n    d = mix(d, -s3, .03);\n    d = mix(d, s, .01);\n    \n    d += perlin(p.yy*20.)*.0003;\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t=0.;\n    for(int i=0; i<128; ++i) {\n    \tfloat d = map(ro+t*rd);\n        if(d < .001) break;\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(0., 0., abs(sin(iTime*.4))*2. + .5);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.));\n    \n    \n    eye.xz = rotate(eye.xz, sin(iTime)*.5);\n    eye.yz = rotate(eye.yz, sin(iTime)*.5);\n    lookat.xz = rotate(lookat.xz, sin(iTime)*.5);\n    lookat.yz = rotate(lookat.yz, sin(iTime)*.5);\n\t\n    \n    float d = march(eye, lookat);\n    vec3 normal = getNormal(eye+d*lookat);\n    vec3 col = vec3(.8, .7, 1.) * clamp(dot(normal, vec3(0., 1., 0.)), 0., 1.);\n    col += vec3(1., .7, .8) * clamp(dot(normal, vec3(-1., 0., -1.)), 0., 1.);\n    col += vec3(.2*d);\n\t\n    col = vec3(.5, .5, .5) * col * d * .2;\n    col += vec3(.5) * pow(clamp(dot(normal, -lookat), 0., 1.), 5.);\n    col += vec3(1., .5, .5) * pow(clamp(dot(normal, -lookat), 0., 1.), 50.);\n    \n    if(d>20.) col = vec3(0.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts23RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 94], [96, 96, 117, 117, 483], [485, 485, 515, 515, 595], [597, 597, 625, 625, 764], [766, 766, 804, 804, 884], [886, 886, 917, 917, 945], [947, 947, 966, 966, 2119], [2121, 2121, 2145, 2145, 2373], [2375, 2375, 2406, 2406, 2548], [2550, 2550, 2607, 2657, 3609]]}
{"id": "ts23WG", "name": "Linear transformations excercise", "author": "darkeclipz", "description": "homework problem which I had to graph.", "tags": ["lineartransformation"], "likes": 3, "viewed": 100, "published": "Public", "date": "1549920346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14156\n#define PixelSize 18. / iResolution.y\n#define R iResolution.xy\n#define I2 mat2(1,0,0,1)\n#define t (0.5*cos(iTime+PI)+0.5)\n\nmat2 mat2interpolate(mat2 a, mat2 b) {\n\treturn mat2(a[0][0]*(1.-t) + b[0][0] * t,\n                a[0][1]*(1.-t) + b[0][1] * t,\n                a[1][0]*(1.-t) + b[1][0] * t,\n                a[1][1]*(1.-t) + b[1][1] * t);    \n}\n\nfloat grid(vec2 p) {\n    vec2 f = smoothstep(PixelSize, 0., abs(fract(4.*p)-PixelSize));\n    return clamp(f.x + f.y, 0., 1.);\n}\n\nfloat T1(vec2 p) {\n    mat2 T = mat2(-1,0,0,-1);\n    p *= mat2interpolate(I2, T);\n    return grid(p);\n}\n\nfloat T2(vec2 p) {\n    mat2 T = mat2(.5, 0, 0, .5);\n    p *= mat2interpolate(I2, T);\n    return grid(p);\n}\n\nfloat T3(vec2 p) {\n    mat2 T = mat2(1,.75,0,1);\n    p *= mat2interpolate(I2, T);\n    return grid(p);\n}\n\nfloat T4(vec2 p) {\n    mat2 T = mat2(1,0,-.75,-1);\n    p *= mat2interpolate(I2, T);\n    return grid(p);\n}\n\nfloat T5(vec2 p) {\n    mat2 T = mat2(.25, .5, .75, .1);\n    p *= mat2interpolate(I2, T);\n    return grid(p);\n}\n\nfloat T6(vec2 p) {\n    float c = cos(iTime), s = sin(iTime);\n    mat2 T = mat2(c,s,-s,c);\n    p *= mat2interpolate(I2, T);\n    return grid(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.y;\n    uv *= 2.;\n    vec2 uvp = trunc(uv);\n    vec2 uvf = 2.*fract(uv)-1.;\n    vec3 col = vec3(0);\n    if(uvp.x == 0. && uvp.y == 0.) col = mix(col, vec3(1), T1(uvf));\n    if(uvp.x == 1. && uvp.y == 0.) col = mix(col, vec3(1), T2(uvf));\n    if(uvp.x == 0. && uvp.y == 1.) col = mix(col, vec3(1), T3(uvf));\n    if(uvp.x == 1. && uvp.y == 1.) col = mix(col, vec3(1), T4(uvf));\n    if(uvp.x == 2. && uvp.y == 0.) col = mix(col, vec3(1), T5(uvf));\n    if(uvp.x == 2. && uvp.y == 1.) col = mix(col, vec3(1), T6(uvf));\n    if(uvp.x > 2.) col = vec3(0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts23WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 180, 180, 368], [370, 370, 390, 390, 497], [499, 499, 517, 517, 602], [604, 604, 622, 622, 710], [712, 712, 730, 730, 815], [817, 817, 835, 835, 922], [924, 924, 942, 942, 1034], [1036, 1036, 1054, 1054, 1180], [1182, 1182, 1239, 1239, 1845]]}
{"id": "ts23zt", "name": "Practice : Sunrise ", "author": "hawky_shadie", "description": "Just Study. \nThe sun rises from horizon. the color of morning glow is arranged with changing the rate of each RGB separately. see the line 40-43th and line 52-55th.", "tags": ["sunrise"], "likes": 1, "viewed": 106, "published": "Public", "date": "1549789549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//precision mediump float;\n//uniform vec2 iResolution;\n//uniform float iTime;\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nfloat plot_y(vec2 st, float pct, float w){\n  return  smoothstep( pct-w, pct, st.y) -\n          smoothstep( pct, pct+w, st.y);\n}\n\nfloat plot_x(vec2 st, float pct, float w){\n  return  smoothstep( pct-w, pct, st.x) -\n          smoothstep( pct, pct+w, st.x);\n}\n\nfloat spot(vec2 p, float r) {\n  float d = length(p);\n  return smoothstep(0.,d,r);\n}\n\n\nvec3 bgcolor(vec2 uv) {\n  float m1 = 0.;\n  m1 = clamp(.0, 0.5, uv.y*uv.y );\n  return vec3(0.,0., m1);\n}\n\nvec3 sun(vec2 uv) {\n  float t = fract(iTime*0.03);\n\n  vec2 p = uv;\n  p.y -= (t*0.4 - .0625);\n  vec3 basecol = vec3(0.0,0.0,0.05) ;\n  basecol.r += smoothstep( 0.28, 1.5, t*3.4)*0.80 ;\n  basecol.g += smoothstep( 0.32, 1.5, t*3.2)*0.75 ;\n  basecol.b += smoothstep( 0.38, 1.5, t*3.2)*0.80 ;\n  vec3 col=basecol;\n  vec2 m = vec2(0.01,0.01);\n  return col*smoothstep(0.1, -0.1 , length(p) )*smoothstep(-0.03,0.01,uv.y);\n}\n\nvec3 sky(vec2 uv) {\n  float t = fract(iTime*0.03);\n  //t *=0.90;\n  vec3 basecol = vec3(0.0,0.0,0.05) ;\n  basecol.r += smoothstep( 0.30, 1.2, t*2.8 )*0.79 ;\n  basecol.g += smoothstep( 0.34, 1.2, t*2.6 )*0.80 ;\n  basecol.b += smoothstep( 0.40, 1.2, t*2.5 )*0.95 ;\n  vec3 col=basecol;\n  return col*smoothstep(-0.2, 0.1 ,uv.y )*smoothstep(-0.4, 0.005,uv.y);\n}\n\nvec3 ocean(vec2 uv, vec3 basecol) {\n  vec3 col=basecol;\n  //*smoothstep(-1.,0.,uv.y);\n  return col*step(uv.y, 0.) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy ;\n  uv -= .5;\n  float asp = iResolution.x/iResolution.y;\n  uv.x *= asp;\n\n  vec3 col =  vec3(0.);\n  col += bgcolor(uv);\n  vec3 cl = vec3(0,0,0.18);\n  col = ocean(uv, cl) ;\n  col += sky(uv) ;\n  col += sun(uv) ;\n\n  fragColor = vec4(col, 1.) ;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts23zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 128, 159, 159, 250], [252, 252, 294, 294, 379], [381, 381, 423, 423, 508], [510, 510, 539, 539, 593], [596, 596, 619, 619, 699], [701, 701, 720, 720, 1114], [1116, 1116, 1135, 1135, 1471], [1473, 1473, 1508, 1508, 1590], [1592, 1592, 1649, 1649, 1933]]}
{"id": "ts2GDw", "name": "Samples Per Pixel 2", "author": "valler", "description": "Multiple samples per pixel.", "tags": ["ray", "pixel", "distance", "march", "samples"], "likes": 0, "viewed": 70, "published": "Public", "date": "1549206350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tMax = 1.e2;\nconst float dMin = 1.e-4;\nconst int numObjects = 3;\nconst int spp = 16;\n\n// https://www.shadertoy.com/view/4lVcRm\nvec2 R2seq(int n)\n{\n\treturn fract(vec2(n) * vec2(0.754877666246692760049508896358532874940835564978799543103, 0.569840290998053265911399958119574964216147658520394151385));\n}\n\nvec3 A (vec4 uvwt)\n{\n    return vec3(1,0,0)*fract(uvwt.x);\n}\n\nvec3 B (vec4 uvwt)\n{\n    return abs(vec3(cos(iTime)) * uvwt.xyz);\n}\n\nfloat F (vec3 p, vec3[numObjects] c, int i)\n{\n\treturn distance(p,c[i]);\n}\n\nfloat D (vec3 ro, vec4 uvwt)\n{\n    vec3 p = ro+uvwt.xyz*uvwt.w;\n    vec3[numObjects] c;\n    c[0] = vec3(0,0,2);\n    c[1] = vec3(1,0,2);\n    c[2] = vec3(-1,0,2);\n    float d = tMax;\n    for (int i = 0; i < numObjects; ++i) d = min(d,F(p,c,i));\n\treturn d-.4;\n}\n\nvec4 T (vec2 uv, float s, int i)\n{\n    vec4 uvwt = vec4(normalize(vec3(uv+(R2seq(i))*s,.707)),0);\n    vec3 ro = vec3(0,0,-1.);\n    while (uvwt.w <= tMax)\n    {\n        float d = D(ro, uvwt);\n        if (d < dMin) break;\n        uvwt.w += d;\n    }\n    return uvwt;\n}\n\nvoid mainImage (out vec4 _, in vec2 a)\n{\n    float invMaxRes = 1./max(iResolution.x, iResolution.y);\n    vec2 uv = (a-.5*iResolution.xy)*invMaxRes;\n    vec3 col = vec3(0);\n    for (int i = 0; i < spp; ++i)\n    {\n        vec4 uvwt = T(uv, invMaxRes, i);\n    \tcol += (uvwt.w>tMax) ? A(uvwt) : B(uvwt);\n    }\n\t_ = vec4(sqrt(col/float(spp)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2GDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 139, 158, 158, 313], [315, 315, 335, 335, 375], [377, 377, 397, 397, 444], [446, 446, 491, 491, 519], [521, 521, 551, 551, 779], [781, 781, 815, 815, 1046], [1048, 1048, 1088, 1088, 1390]]}
{"id": "ts2GW3", "name": "Saturno!", "author": "AdrianPi", "description": "Old-school raytracing", "tags": ["raytracing", "phong", "fog", "antialias", "checker"], "likes": 9, "viewed": 255, "published": "Public", "date": "1550240952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\n\nvec3 viewFrom = vec3(0,-1,1);\nvec3 viewAt = vec3(0,0,0);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 2;\n\nvec4 skyColor = vec4(0.5,0.5,1,1);\nvec4 horizonColor = vec4(0.8,0.8,1,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(0.2,0.2,0.2,1), \n                                   vec4(0.2,0.2,0.2,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   CHECKER_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.54));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[5] = material_t[5](material0, material1, material2, material3, material4);\n\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(0, 0, 0), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _ring = primitive_t(RING_PRIMITIVE, 4, vec3(0,0,0), normalize(vec3(-0.5, 0, 1)), vec3(2, 1.5, 0));\n\nconst int NUM_PRIMS = 3;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _ring);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 5.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.2, 1);\nvec3 lightDirection = normalize(vec3(1,1,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 4)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos;\n    sray.dir = -lightDirection;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }\n        \n        // fog\n\n        float f = (hit.t - 10.0) / (50.0-10.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    viewFrom = vec3(sin(iTime)*6.0, -cos(iTime)*6.0, 2.0);\n    \n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n    \n    for(int i = 0; i < oversample; i++)\n    {\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2GW3.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 3698, 3737, 3737, 3902], [3904, 3904, 3932, 3932, 4045], [4047, 4047, 4128, 4128, 4947], [4949, 4949, 5024, 5024, 5382], [5384, 5384, 5478, 5478, 6021], [6170, 6170, 6198, 6198, 6323], [6325, 6325, 6359, 6359, 6514], [6516, 6516, 6538, 6538, 6567], [6615, 6615, 6658, 6658, 8187], [8189, 8189, 8231, 8231, 8575], [8577, 8577, 8611, 8611, 9174], [9176, 9176, 9220, 9220, 9944], [9946, 9946, 9972, 9972, 10052], [10054, 10054, 10111, 10111, 11039]]}
{"id": "ts2GWc", "name": "Zebra Lines", "author": "johncurtis", "description": "I proudly present... the zebra line noise shader! Cooked this up over the last few months, hope you all enjoy. I release it as public domain, do what you will with it but please do not harm any zebras.", "tags": ["lines"], "likes": 2, "viewed": 73, "published": "Public", "date": "1550185495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I've spent the last few months playing around with procedural\n// and animated lines and have been cooking this shader up\n// I Thought I would share with the world, I am pretty proud of it\n// I call it the zebra shader\n// Enjoy!\n// \n\n/*\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n*/\n    \nfloat zebraNoise(vec2 uv)\n{\n\tconst float uvMultiplier = 1.879;\n\tconst float uv2Multiplier = 1.542;\n\tconst float clipNoiseBelow = 0.15;\n\n\tfloat t = iTime;\n\tfloat uvNoiseMultiplier = 0.7; // raise for thicker lines\n    float uv2NoiseMultiplier = 0.3; // raise for more bending\n\tfloat noise = 0.0;\n\tfloat nx, ny, nz, nw;\n\t\n\t// slide position to animate panning\n\tvec2 slide = vec2(t * 0.34, t * 0.42);\n\tuv += slide;\n\tvec2 uv2 = uv;\n\t\n    uv2 *= uv2Multiplier;\n    nx = sin(uv2.x);\n    ny = sin(uv2.y);\n    nz = sin(uv2.y + nx);\n    nw = (nx + ny);\n    vec2 uv2Noise = vec2(nz, nw);\n    \n   \t// rotate noise value to bend and wiggle the lines\n    // rotation function: https://stackoverflow.com/questions/2259476/rotating-a-point-about-another-point-2d\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n    uv2Noise = vec2((uv2Noise.x * c) - (uv2Noise.y * s), (uv2Noise.x * s) + (uv2Noise.y * c));\n    uv += (uv2Noise * uv2NoiseMultiplier);\n\n    uv *= uvMultiplier;\n    nx = (uv.y);\n    ny = sin(uv.x);\n    \n    // clever trick from https://gamedev.stackexchange.com/questions/141916/antialiasing-shader-grid-lines\n    nz = abs(fract(nx + ny) - 0.5);\n    \n    nw = (nz * uvNoiseMultiplier);\n    nw *= max(0.0, ceil(nw - clipNoiseBelow));\n    noise += (nw);\n\t\n\treturn noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) / max(iResolution.x, iResolution.y);\n\tuv *= 4096.0;\n    float noise = zebraNoise(uv);\n    vec3 col = vec3(noise, noise * abs(cos(iTime)), noise * abs(sin(iTime)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2GWc.jpg", "access": "shaders20k", "license": "unlicense", "functions": [[236, 1458, 1485, 1485, 2716], [2718, 2718, 2775, 2825, 3066]]}
{"id": "ts2GWm", "name": "TinkerTime_1", "author": "hobohippy", "description": "Remake of https://www.shadertoy.com/view/4dccWj", "tags": ["noise"], "likes": 2, "viewed": 56, "published": "Public", "date": "1549069779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PIX=8.0;\nfloat PT=2.0;\nfloat PV=0.5;\nfloat PC=1.0;\nfloat A=0.0;\nfloat B=0.0;\nfloat C=0.0;   \n\n#define BW vec3(0.5,0.5,0.5)\n#define CU vec3(A,B,C)\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = PIX*fragCoord/iResolution.yx;\n\t\n    // pattern\n    float f = sin(p.x + sin(PT*p.y + iTime)) +\n              sin(length(p)+iTime) +\n              PV*sin(p.x*2.5+iTime);\n    \n    // color\n    vec3 col = PC * sin(f + BW * CU);\n\n    // putput to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2GWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 214, 250, 545]]}
{"id": "ts2GWw", "name": "Attractor Sampling w/o Colors", "author": "Justaway", "description": "Attractor sampling in black/white.", "tags": ["attractors"], "likes": 2, "viewed": 69, "published": "Public", "date": "1549051240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float[150] coef = float[150](-0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n                       -0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n                       0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n                       -0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n                        -0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114);\n\nfloat[30] c;\n\nvec3 Dmap(vec3 v, vec3 d){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0] + c[3]*y + c[5]*z + 2.0*c[6]*x;\n    newV.y = c[11] + c[13]*x +c[14]*z + 2.0*c[17]*y;\n    newV.z = c[22] + c[24]*y + c[25]*x + 2.0*c[28]*z;\n    return newV;\n}\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*x*4733.0+2687.0,6379.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    \n    vec3 V = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    T[0] = float(floor(iTime/5.0));\n    T[1] = T[0]+1.0;\n    float t = smoothstep(0.0,1.0,fract(iTime/5.0));\n    float perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    float T2[2];\n    T2[0] = floor(iTime/5.0);\n    T2[1] = T2[0] + 1.0;\n    float t2 = smoothstep(0.0,1.0,fract(iTime/5.0));\n    perm = permute(permute(T2[0]));\n    int coefIndex[2];\n    coefIndex[0] = int(mod(perm, 5.0));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, 5.0));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    uv*=3.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    int i = 0;\n    vec3 D = vec3(0.0);\n    float m2;\n    for(i = 0; i < 128; i++)\n    {\n        D = Dmap(V,D);\n        V = map(V);\n        m2 = mod2(V);\n        if(m2>1e20) break;\n    }\n    \n    float dist = sqrt(m2/mod2(D))*0.5*log(m2);\n\n    vec4 col;\n    \n    vec3 norm = normalize(V);\n    col = vec4(abs(dist));\n    \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2GWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1706, 1706, 1732, 1732, 2100], [2102, 2102, 2119, 2119, 2674], [2676, 2676, 2696, 2696, 2734], [2736, 2736, 2760, 2760, 2802], [2804, 2804, 2861, 2861, 4428]]}
{"id": "tsB3Dm", "name": "Tan Triangles", "author": "Jamie_Pendergast", "description": "I dont know why this works but it does.\nEquilateral triangles turn to Right  Angle triangles vice versa", "tags": ["interesting"], "likes": 1, "viewed": 281, "published": "Public API", "date": "1549019183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nmat2 rot(float theta)\n{\n    return mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;\n    uv *= PI*2.;\n    uv.x *= iResolution.x / iResolution.y*PI/2.;\n\t\n    \n    vec3 col = vec3(1.);\n    float angle = iTime;   \n\tuv *= rot(radians(angle*10.));\n    \n    float change = tan(uv.x - angle - uv.y) - tan(uv.x +  angle +  uv.y); \n\t\n    if(change >= 0.) \n    {\n        col = vec3(1.,0.4,0.4);\n    }\n    else\n    {\n        col = vec3(0.4,1.,1.);\n    }\n\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsB3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 44, 44, 109], [111, 111, 168, 218, 663]]}
{"id": "tsB3Rc", "name": "Mount Castle", "author": "cbrpnk", "description": "everyday", "tags": ["raymarching"], "likes": 7, "viewed": 112, "published": "Public", "date": "1549509963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat box(vec3 p, vec3 r)\n{\n    vec3 d = abs(p) - r;\n \treturn length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cylinder(vec3 p, float r, float l)\n{\n    return max(length(p.xz) - r, abs(p).y-l);\n}\n\nfloat caps(vec3 p, float r, float l)\n{   \n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat voronoi(vec2 p)\n{    \n    p = mod(p+vec2(.5), 1.)-vec2(.5);\n    p *= 5.;\n    p = abs(p);\n    \n    float d = 1000000.;\n    float alpha = .25;\n    \n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<2; ++j) {\n        \td = min(d, length(p-vec2(float(i)*alpha, (float(j)+.5*mod(float(i), 2.))*alpha)));\n        \td = min(d, length(p-vec2(i, j)));\n            d = min(d, length(p-vec2(i, j)*2.));\n            d = min(d, length(p-vec2(i, j)*3.));\n        }\n    }\n    \n    return d;\n}\n\nfloat tower(vec3 p)\n{\n    p.xz = abs(p.xz);\n    p.xz -= vec2(.5);\n    p.y -= .1;\n    float d = 1000.;\n    d = min(d, cylinder(p, .2, .6));\n    d = min(d, cylinder(p-vec3(0., .5, 0.), .23, .1));\n    d = max(d, -cylinder(p+vec3(0., -.6, 0.), .15, .1));\n    float h = min(1000., box(p-vec3(.01, .6, .1), vec3(.025, .055, .4)));\n    h = min(h, box(p-vec3(.01, .6, .01), vec3(.4, .055, .025)));\n    p.xz = rotate(p.xz, .7);\n    h = min(h, box(p-vec3(.01, .6, .01), vec3(.4, .055, .025)));\n    h = min(h, box(p.zyx-vec3(.01, .6, .01), vec3(.4, .055, .025)));\n    return max(d, -h);\n}\n\nfloat outterWalls(vec3 p)\n{\n\tfloat d = 1000000.;\n    d = min(d, box(p, vec3(.5)));\n    d = max(d, -box(p-vec3(0., .2, 0.), vec3(.4, 1., .4)));\n    \n    d = max(d, -box(p-vec3(0.12, .5, 0.), vec3(.05, .1, 1.)));\n    d = max(d, -box(p-vec3(-.12, .5, 0.), vec3(.05, .1, 1.)));\n    p.xz = rotate(p.xz, 1.55);\n    d = max(d, -box(p-vec3(0.12, .5, 0.), vec3(.05, .1, 1.)));\n    d = max(d, -box(p-vec3(-.12, .5, 0.), vec3(.05, .1, 1.)));\n    \n    return d;\n}\n\nfloat inner(vec3 p)\n{\n    float main = box(p-vec3(0., .25, 0.), vec3(.25, .7, .25));\n    float top = box(p-vec3(0., 1., 0.), vec3(.3, .2, .3));\n    float cap = caps(vec3(abs(p.x), p.y, abs(p.z)) - vec3(.25, 1., .25), .1, .25);\n    \n    \n   \tfloat roof = box(p-vec3(0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    float roof2 = box(p-vec3(-0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    p.xz = rotate(p.xz, 1.55);\n    float roof3 = box(p-vec3(0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    float roof4 = box(p-vec3(-0.1, 1.2, 0.), vec3(.025, .1, 1.));\n    float roof5 = box(p-vec3(-0., 1.2, 0.), vec3(.25, .2, .25));\n    float roof6 = box(p-vec3(-0., 1.2, 0.), vec3(.05, .8, .05));\n    \n    \n    \n    float d = min(main, top);\n    d = min(d, cap);\n    d = max(d, -roof);\n    d = max(d, -roof2);\n    d = max(d, -roof3);\n    d = max(d, -roof4);\n    d = max(d, -roof5);\n    d = min(d, roof6);\n    return d;\n}\n\nfloat land(vec3 p)\n{\n    p.y += 2.2;\n    //p.xz *= .8;\n    float mount = sphere(p, 2.) - voronoi(p.xz)*.1 - voronoi(p.xz*1.5)*.05;\n    float d = mount;\n    \n    return d;\n}\n\nfloat map(vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.25);\n    \n    float d = 1000000.;\n    d = min(d, outterWalls(p));\n    d = min(d, tower(p));\n    d = min(d, inner(p));\n    d = min(d, land(p));\n    \n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    float ao = 0.;\n    for(int i=0; i<128; ++i) {\n        ao = float(i);\n    \tfloat d = map(ro+rd*t);\n        if(d < .001) break;\n        t += d*.6;\n    }\n    return vec2(t, ao);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(0., 0., 4.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.));\n    vec2 res = march(eye, lookat);\n    vec3 normal = getNormal(eye+lookat*res.x);\n    \n    vec3 col = vec3(.1, .1, .9);\n    if(res.x<100.) {\n        col = vec3(.4) * (uv.x+.5);\n        col += .3 * vec3(.8, .8, .55) * max(0., dot(normal, vec3(1., 0., 1.)));\n        col += .3 * vec3(.55, .8, .8) * max(0., dot(normal, vec3(-1., 1., 1.)));\n        col *= pow(res.x*.2, 1.1);\n        col *= 1.4;\n    }\n\n    col *= pow(max(dot(lookat, vec3(0., 0., -1.)), 0.), 5.);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsB3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 110], [112, 112, 139, 139, 227], [229, 229, 271, 271, 319], [321, 321, 359, 359, 422], [424, 424, 455, 455, 483], [485, 485, 508, 508, 968], [970, 970, 991, 991, 1547], [1549, 1549, 1576, 1576, 2000], [2002, 2002, 2023, 2023, 2884], [2886, 2886, 2906, 2906, 3058], [3060, 3060, 3079, 3079, 3303], [3305, 3305, 3335, 3335, 3534], [3536, 3536, 3560, 3560, 3788], [3790, 3790, 3847, 3897, 4590]]}
{"id": "tsB3Ww", "name": "Mandelbrot Fractal Renderer -", "author": "levkruglyak", "description": "An interactive mandelbrot rendered using complex numbers.", "tags": ["mandelbrot"], "likes": 1, "viewed": 92, "published": "Public", "date": "1548984575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define bailout 200.\nfloat mandelbrot( vec2 c ){\n    int iterations = int(iTime)*10+100;\n    \n    vec2 z = vec2(0);\n    for (int i = 0; i < iterations; i++) {\n        if (dot(z,z) > bailout * bailout) {\n        \treturn float(i)/float(iterations);   \n        }\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 shift =iResolution.xy/2.;\n    vec2 center = vec2(1.39389,0.10990);\n    float zoom = iTime*iTime*iTime;\n    vec2 uv = (fragCoord-shift.y)/(zoom*iResolution.y) - center;\n    float outp = mandelbrot(uv);\n    fragColor = vec4(vec3(outp),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsB3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 48, 48, 340], [342, 342, 399, 399, 649]]}
{"id": "tsBGDd", "name": "Guiné-Melies-TJD05", "author": "guigames", "description": "Guilherme Leandro De Cicco", "tags": ["tjd05"], "likes": 1, "viewed": 51, "published": "Public", "date": "1550272469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float balanco= (sin(iTime+uv.y*1.5)/ 10.0);\n\n    // Output to screen\n    if(uv.x<0.3+balanco)\n    {\n        fragColor = vec4(1,0,0,1) * 1. - balanco * 2.;\n    }else if(uv.x<0.68+balanco){\n        fragColor = vec4(1,1,0,0) * 1. - balanco * 2.;\n    }else\n        fragColor = vec4(0,0.7,0,1) * 1. - balanco * 2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 468]]}
{"id": "tsBGDV", "name": "RaytracingSphere", "author": "temportalflux", "description": "raytracing a sphere", "tags": ["raytracing"], "likes": 1, "viewed": 46, "published": "Public", "date": "1550006302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nstruct Camera\n{\n    vec3 position;\n    float focalLength;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Light\n{\n    vec3 position;\n    float intensity;\n};\n    \nSphere orb = Sphere(vec3(0.0, 0.0, 10.0), 2.0, vec3(1, 0, 0));\nCamera camera = Camera(vec3(0, 0, 0), -1.0);\nLight light = Light(vec3(0, 0, 5), 2.0);\n\n// https://yduf.github.io/my-tracer/\n// https://www.shadertoy.com/view/ldS3DW\n// https://www.shadertoy.com/view/ldScDc\n// http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/\nfloat sphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 center, float radius)\n{\n\tvec3 rc = rayOrigin-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(rayDir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nRay makeRay(Camera camera, vec2 uv)\n{\n    return Ray(\n        camera.position,\n        normalize(vec3(uv, -camera.focalLength))\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter the lights position on a sinusoidal wave, in x y and z\n    light.position += vec3(-cos(iTime * 2.), sin(iTime * 2.), cos(iTime * 3.0)) * vec3(0, 0, 5);\n    //camera.position = vec3(-cos(iTime), sin(iTime), 1) * vec3(5, 5, 0) + vec3(0, 0, -10) + orb.position;\n    \n    // ----------------------------------------------\n    // UVs\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    // ----------------------------------------------\n    // Orb Draw\n    \n    // Raytrace to the sphere\n    Ray ray = makeRay(camera, uv);\n    // Determine how close to the center of the sphere the ray hit\n    // -1 is no hit\n    // 0 is at center\n    // 1 is at radius of the sphere/orb\n    float hitRadiusRatio = sphereIntersect(ray.origin, ray.dir, orb.position, orb.radius);\n    // Determine if a color should be rendered for the sphere (only has alpha if hit was on sphere)\n    float alpha = clamp(hitRadiusRatio, 0.0, 1.0);\n    // Make an output color for the sphere, based on sphere albedo and how transparent it is\n    vec4 fragColorForOrb = vec4(alpha * orb.color, alpha);\n    \n    // Lighting\n    // Determine the hit offset from the camera\n    vec3 rayEndWrtOrb = ray.origin + ray.dir * hitRadiusRatio;\n    // Calculate the normal for the hit location\n    vec3 orbNormal = normalize(rayEndWrtOrb - orb.position);\n    // Calculate light direction based on the hit location\n    vec3 hitLightDir = normalize(light.position - rayEndWrtOrb);\n    float nDotL = dot(orbNormal, hitLightDir);\n    \n    // Diffuse lighting\n    fragColorForOrb.rgb *= light.intensity * max(0.0, nDotL);\n    \n    // Apply color for the orb\n    fragColor += vec4(fragColorForOrb.rgb, 1.0);\n    \n    // ----------------------------------------------\n    // Background\n    \n    float notIntersecting = 1.0 - fragColorForOrb.a;\n    vec3 col = 0.5 + 0.5 * cos(iTime + (fragCoord / iResolution.xy).xyx + vec3(0,2,4));\n    fragColor += notIntersecting * vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 592, 671, 671, 881], [883, 883, 920, 920, 1019], [1021, 1021, 1076, 1144, 3182]]}
{"id": "tsBGWt", "name": "analytical ray-sink intersection", "author": "FabriceNeyret2", "description": "analytical ray-intersection, allowing free antialiasing and all 2D-shaders goodies.\nColor = intersection levels. ( texture ignores it and is mapped on nearest surface ).\n\nMouse controls shape (or auto-demo ).", "tags": ["cubic", "polynomial", "tuto", "solve", "degree3"], "likes": 15, "viewed": 466, "published": "Public API", "date": "1550254900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of  https://shadertoy.com/view/ws23D3\n// analytical ray - sink intersection ( solving cubic polynomial ).\n\n// NB: cleaner code in this version: https://www.shadertoy.com/view/wsBGWd\n\n// --- render scene\n// sink shape: P.z = m / ( h + |P.xy|²)  ; solve with ray P = P0+lD\nfloat m =  1.,       // amplitude factor\n      h = 1./3.;     // inv heap\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime-9.2;\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n         M = iMouse.z > 0. ? iMouse.xy / R \n                           : vec2(.4+.3*sin(4.7*t),.5+.5*cos(t));\n    m = 20.*M.x;\n    h = m/M.y/4.;\n    \n    // --- set camera     \n    vec3 P = .8*vec3(0., 5.5, 6),\n      look = normalize( vec3(0,0,1.7) - P ),\n    //vec3 P = .8*vec3(0., 7.5, 4),\n    //  look = normalize( vec3(0,0,-1.5) - P ),\n     right = normalize(cross(look, vec3(0,0,1))),\n        up = cross( right, look ),\n         D = normalize( look*3. + U.x*right + U.y*up );\n   \n    // --- Solving a*x³ +b*x³ +c*x +d = 0. -> l = min(3 solutions)\n    // using \"solving cubic polynomial\"  https://shadertoy.com/view/3d23Dc\n    // here: ( h + P² +2lP.D + l²D²)xy * (P  + lD)z = m\n    float a =   dot(D.xy,D.xy)*D.z,\n          b = ( dot(D.xy,D.xy)*P.z +2.*dot(P.xy,D.xy)*D.z ) /a, \n          c = ( dot(P.xy,P.xy)*D.z +2.*dot(P.xy,D.xy)*P.z +h*D.z ) /a, \n          d = ( dot(P.xy,P.xy)*P.z +h*P.z - m ) /a,\n        p = ( 3.*c - b*b ) / 3.,\n        q = ( 9.*b*c - 27.*d - 2.*b*b*b) / 27., // -\n        Q = p/3., r = q/2., \n        v,z, l, A, k = -1.;\n    \n    if ( Q*Q*Q + r*r < 0.) {                    // --- if 3 sol\n        A = acos(r/sqrt(-Q*Q*Q)), \n        k = round(1.5-A/6.283); // k = 0,1,2 ; we want min l\n#define sol(k) ( 2.*sqrt(-Q)* cos((A+(k)*6.283)/3.) - b/3. )\n        l = sol(k);\n    }\n    else                                        // --- if 1 sol\n        if (p>0.) v = -2.*sqrt(p/3.), \n#define asinh(z) ( sign(z)*asinh(abs(z)) )      // fix asinh() symetry error \n                  l = -v* sinh(asinh(3.*-q/p/v)/3.) -b/3.; \n        else      v = -2.*sqrt(-p/3.), \n                  l = sign(-q)*v* cosh(acosh(3.*abs(q)/p/v)/3.) -b/3.;\n\n    // --- display\n\n    if (l<0.) { O-=O; return; }\n    vec3 W,X;// = P + l*D;\n    P.xy += t; \n                                                 // draw grid\n#define draw(l) ( X = P + (l)*D  ,                      \\\n               /* X = abs(1.-2.*fract(4.*X)) -.8, */    \\\n                  X = 1. - abs(.5-fract(4.*X))/fwidth(4.*X),\\\n               /* X = sin(15.*X)-.9, */                 \\\n                  W = fwidth(X),                        \\\n                  X = smoothstep(-.75,.75,X/W),         \\\n                  max(X.x,X.y) )\n    O = vec4( draw(l));\n    if (k>=0.) {                                 // hidden parts in color\n        O.ra += (1.-O.a)* draw(sol(mod(k+1.,3.)));\n        O.ba += (1.-O.a)* draw(sol(mod(k+2.,3.)));\n    }\n    O.rgb *= exp(-.1*l);\n    \n#if 1    \n    P += l*D;                                    // draw texture\n    O += (1.-O.a)* 2.*texture(iChannel0,.3*P.xy) * exp(-.1*l);\n  //O = vec4( exp(-.1*l));\n  //O = vec4(.5+.5*sign(P)*fract(3.*P),0);\n#endif\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 358, 396, 396, 3139]]}
{"id": "tsBGzV", "name": "Mini Mandelbox flythrough", "author": "xem", "description": "A \"scale 2.8\" Mandelbox fractal raymarched in WebGL seen along the axis [x: -0.44, y: 0.11] Formula by Tom Lowe (2010) Code by Bálint Csala and Maxime Euziere (js1k 2019)", "tags": ["fractalraymarching"], "likes": 4, "viewed": 310, "published": "Public API", "date": "1549352165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 r = normalize(vec3(fragCoord.xy / 500. - vec2(.5), 1.)),\n         p = vec3(-.44, .11,-15. + iTime);\n    for(float i = .0; i < 200.; i++){\n        vec4 o = vec4(p, 1), q = o;\n        for(int i = 0;i < 20;i++){\n            o.xyz = clamp(o.xyz, -1., 1.)*2. - o.xyz;\n            o = o * clamp(max(.25 / dot(o.xyz, o.xyz), .25), 0., 1.);\n            o = o * (vec4(2.79) / .25) + q;\n        }\n        float d = (length(o.xyz) - 1.) / o.w - pow(2.79, -9.);\n        if(d < .0001){\n            break;\n        }\n        p += r * d;\n        fragColor.rgb = vec3(1. - i / 100.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 641]]}
{"id": "tsBGzy", "name": "Line Segment Example", "author": "Xor", "description": "This is my one-size-fits-all approach to line segments.\nYou may not need the line length float if you do not need end caps.", "tags": ["2d", "example", "line"], "likes": 7, "viewed": 118, "published": "Public", "date": "1549163739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"Line Segments\" by Xor.\n\n\tThis is my one-size-fits-all approach to line segments.\n\tYou may not need the line length float if you do not need end caps.\n*/\nvoid mainImage( out vec4 Color, in vec2 Coord)\n{\n    //Pick two points to draw lines from.\n    vec2 P1 = vec2(100,100)+50.*cos(iTime+vec2(0,1));\n    vec2 P2 = vec2(400,200)+50.*cos(iTime+vec2(2,3));\n    \n    //Find the length of the line segment.\n    float Length = distance(P1,P2);\n    //Find the slope vector of the line.\n    vec2 Slope = (P1-P2)/Length;\n    //Find the perpendicular vector to the slope.\n    vec2 Normal = Slope.yx*vec2(-1,1);\n    //Line thickness in pixels.\n    const float Width = 4.;\n    \n    //Calculate distance to line. (This should to be clamped).\n    float LineWidth = Width*.5-abs(dot(Coord-P1,Normal));\n    //Calculate distance to line ends. (This should to be clamped).\n    float LineLength = Length/2.-abs(dot(Coord-(P1+P2)/2.,Slope));\n    //Find the distance to the line edges.\n    float Line = clamp(min(LineWidth,LineLength),0.,1.);\n    \n    //Add some circles for the end points\n    const float Radius = 8.;\n    float Circle1 = clamp(Radius-length(Coord-P1),0.,1.);\n    float Circle2 = clamp(Radius-length(Coord-P2),0.,1.);\n    \n    float Output = Line+Circle1+Circle2;\n    Color = vec4(Output);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 206, 248, 1290]]}
{"id": "tsfXR4", "name": "RayTracing Tutorial - step 2", "author": "BrunoLevy", "description": "Let us create a red sphere that orbits around the white one.", "tags": ["raytracing", "tutorial"], "likes": 0, "viewed": 425, "published": "Public API", "date": "1550694384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-6;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   float alpha = float(iFrame)/30.0;\n   float s = sin(alpha);\n   float c = cos(alpha); \n\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, fragCoord);\n   Sphere S1 = Sphere(vec3(0.0, 0.0, 0.0), 0.5);\n   Sphere S2 = Sphere(vec3(0.7*c, 0.7*s, 0.0), 0.3);\n   \n   fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n  \n   float t = FARAWAY;\n   float t1;\n   if(intersect_sphere(R,S1,t1) && t1 < t) {\n      fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      t = t1;\n   }\n   float t2;\n   if(intersect_sphere(R,S2,t2) && t2 < t) {\n      fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n      t = t2;\n   }\n\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 281, 281, 579], [581, 581, 618, 618, 715], [765, 765, 824, 824, 1090], [1093, 1093, 1150, 1150, 1795]]}
{"id": "tsfXR8", "name": "blobs146146", "author": "theepicsnail", "description": "blobs", "tags": ["blobs"], "likes": 0, "viewed": 42, "published": "Public", "date": "1551328506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n#define PI 3.1416\n#define MAX_DIST 50.0\n#define EPS 0.001\n#define ITR 200.0\nvec2 delta = vec2(.01,0);\nvec3 lastCell = vec3(0);\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co){\n    return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);\n}\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 49.566))) * 43758.5453);\n}\n\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SDF(vec3 ro, vec3 rd) {\n\n    float n = snoise(vec4(ro*.2,iTime*.1));\n    float d = abs(abs(n-.8)-mix(0., .3, abs(cos(iTime))));\n    \n    return d*.5;\n}\n\n\nvec3 EstNormal(vec3 ro, vec3 rd) {\n    float cx = SDF(ro+delta.xyy, rd)-SDF(ro-delta.xyy, rd);\n    float cy = SDF(ro+delta.yxy, rd)-SDF(ro-delta.yxy, rd);\n    float cz = SDF(ro+delta.yyx, rd)-SDF(ro-delta.yyx, rd);\n    return normalize(vec3(cx,cy,cz));\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 p = ro;\n    float t;\n    float d=0.0;\n    float i = 0.0;\n    float c = 1.0;\n    vec3 pos;\n    for(; i < ITR ; i++) {\n    \tt += d = SDF(pos=ro+rd*t,rd);\n        c = min(d,c);\n        if(t > MAX_DIST || d < EPS) break;\n    }\n   \tvec3 normal =EstNormal(pos, rd);\n    \n    float dist_brightness = 1.0-(t/MAX_DIST);\n    float norm_brightness = -dot(normal, rd);\n    \n    return vec3(1)*norm_brightness*dist_brightness;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\ttim*=0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=lookat(-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y,1.0));\n    \n    ro.yz *= .2;\n    ro.yz += .5;\n    ro.x += iTime;\n    \n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 58], [59, 59, 82, 82, 126], [127, 127, 154, 154, 202], [203, 203, 232, 232, 280], [282, 282, 311, 311, 572], [574, 574, 595, 595, 2880], [3011, 3011, 3045, 3045, 3092], [3094, 3094, 3114, 3114, 3186], [3188, 3188, 3208, 3208, 3318], [3320, 3320, 3341, 3341, 3422], [3425, 3425, 3446, 3446, 3546], [3549, 3549, 3571, 3571, 3740], [3742, 3742, 3771, 3771, 3899], [3902, 3902, 3936, 3936, 4156], [4158, 4158, 4197, 4197, 4627], [4629, 4629, 4686, 4686, 5109]]}
{"id": "tsfXRn", "name": "Raymarch Mandelbox 3", "author": "darkeclipz", "description": "Variant of https://www.shadertoy.com/view/3dfXzr, with different folds.", "tags": ["raymarch", "mandelbox"], "likes": 4, "viewed": 151, "published": "Public", "date": "1550434316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 32.\n#define MinDistance 0.0075\n#define eps 0.0001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    \n    float fixedRadius2 = .6 + 4.* cos(20./8.) + 4.;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 30.;\n    float Scale = 3.2;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n        \n        z = boxFold(z, vec3(1.5));       // Reflect\n        sphereFold(z, dr);    // Sphere Inversion\n        z.xz = -z.zx;\n        //z = mengerFold(z);\n        z = boxFold(z, vec3(1.3));       // Reflect\n        z.yz = z.zy;\n\t\tsphereFold(z, dr);    // Sphere Inversion\n        \n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec3 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n    \n    mat3 rot = rotateZ(iTime / 10.) * rotateY(iTime / 10.) * rotateX(iTime / 10.);\n    vec3 L1 = vec3(5,-5,5) * rot;\n    vec3 L2 = vec3(5,-5,-5) * rot;\n    vec3 L3 = vec3(-5,-5,5) * rot;\n    vec3 L4 = vec3(-5,-5,-5) * rot;\n    vec3 L5 = vec3(-5,5,5) * rot;\n    vec3 L6 = vec3(5,5,-5) * rot;\n    \n    \n    \n    float L = 1e10;\n    L = min(L, sdSphere(p - L1, .025));\n    L = min(L, sdSphere(p - L2, .025));\n    L = min(L, sdSphere(p - L3, .025));\n    L = min(L, sdSphere(p - L4, .025));\n    L = min(L, sdSphere(p - L5, .025));\n    L = min(L, sdSphere(p - L6, .025));\n    \n    float id = 0.;\n    if(L < box.x) id = 1.;\n    box.x = min(box.x, L);\n\treturn vec3(box, id);\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec4 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec3 hit = scene(p);\n        float dt = hit.x;\n        float id = hit.z;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec4(t-MinDistance, 1.-i/MaxSteps, hit.y, id);  \n        }\n    }\n    return vec4(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,1,0), 25., vec3(.4));\n    \n    mat3 rot = rotateZ(iTime / 10.) * rotateY(iTime / 10.) * rotateX(iTime / 10.);\n    \n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,5) * rot, 8., vec3(.4));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,-5) * rot, 8., vec3(.4));\n    vec3 L3 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,5) * rot, 8., vec3(.4));\n    vec3 L4 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,-5) * rot, 8., vec3(.4));\n    vec3 L5 = shadeBlinnPhong(p, rd, sn, vec3(-5,5,5) * rot, 8., vec3(.4));\n    vec3 L6 = shadeBlinnPhong(p, rd, sn, vec3(5,5,-5) * rot, 8., vec3(.4));\n    vec3 L7 = shadeBlinnPhong(p, rd, sn, vec3(-5,5,5) * rot, 8., vec3(.4));\n    vec3 L8 = shadeBlinnPhong(p, rd, sn, vec3(-5,5,-5) * rot, 8., vec3(.4));\n    \n\n    mat3 rot2 = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    vec3 camPos = (vec3(0,0,-3)- vec3(0,1,15)) * rot2 ;\n    vec3 cam = shadeBlinnPhong(p, rd, sn, camPos, 13., vec3(.9));\n    \n    vec3 ambient = vec3(.25);\n    return L1 + L2 + L3 + L4 + L5 + L6 + L7 + L8 + ambient + top + cam;\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0,-3); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2 + iTime/16.) * rotateY(iTime/10.);\n    \n    ro -= vec3(0,1,15);\n    ro *= rot;\n    rd *= rot;\n    \n    vec4 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        float trap = fract(hit.z*.5 + 2.06 - 0.5);\n        \n        n += 0.2*trap*n;\n        \n        col = pal(trap*0.4, vec3(.5), vec3(0.5), \n                   vec3(1.0,1.0,1.0), vec3(.0, .10, .2));\n        \n        col *= .2;\n        \n        col += light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        if(hit.w == 1.) col = vec3(2);\n        \n        col = mix(col, vec3(0), clamp(1.-10./t, 0., 1.));\n    }\n    else {\n        col = vec3(0);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 197, 224, 224, 310], [312, 312, 339, 339, 425], [427, 427, 454, 454, 532], [534, 534, 567, 567, 596], [598, 609, 646, 646, 677], [679, 690, 721, 721, 784], [786, 862, 892, 892, 937], [939, 1065, 1112, 1112, 1405], [1407, 1483, 1508, 1508, 1674], [1676, 1774, 1791, 1791, 2408], [2410, 2410, 2430, 2430, 3133], [3135, 3135, 3161, 3161, 3180], [3182, 3193, 3218, 3218, 3490], [3492, 3570, 3600, 3600, 3921], [3923, 3923, 3960, 3960, 4196], [4200, 4267, 4374, 4374, 5132], [5134, 5209, 5247, 5247, 6340], [6342, 6403, 6471, 6471, 6516], [6518, 6518, 6575, 6575, 7589]]}
{"id": "tsfXzn", "name": "Iridescent Blob", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarching"], "likes": 5, "viewed": 122, "published": "Public", "date": "1550447780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat pat(vec2 p)\n{\n    p = mod(p+vec2(1), 2.)-vec2(1.);\n    float d = 1000.;\n    for(float i=0.; i<10.; ++i) {\n        p *= rot(i*.3*cos(iTime*.1));\n        for(float j=0.; j<5.; ++j) {\n            p *= rot(j*.02*sin(iTime*.3));\n            p -= vec2(sin(i)+cos(iTime), cos(j)+sin(iTime))*.01;\n            d = min(d, length(p-vec2(j*.2)) - (.2-j*.05*abs(cos(iTime))));\n        }\n    }\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    p.xz *= rot(iTime);\n    return length(p) - .6 + pat(p.xy)*.1 + pat(p.yz)*.3 -pat(p.xz)*.4;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .001 || d > 100.) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nfloat marchSs(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(float i=0.; i<1.; i+=.1) {\n    \tfloat d = map(ro+rd*i);\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    vec3 cam = vec3(0, 0, 1);\n    vec3 dir = normalize(vec3(uv, -1));\n    float pattern = pat(uv*4.);\n    float d = march(cam, dir);\n    \n    vec3 col = vec3(.1, .2, .3);\n    vec3 p = cam+dir*d;\n    vec3 normal = getNormal(p);\n    \n    if(d<50.) {\n        float ss = marchSs(p, dir);\n    \tcol = vec3(.1, .8, .6) * max(0., dot(normal, vec3(1)));\n        col += vec3(.1, .1, .2) * pow(max(0., dot(normal, vec3(-1))), .5);\n        col *= vec3(.1, .1, .2);\n        col -= vec3(.2, .2, .1)*pow(1.-max(0., dot(normal, -dir)), 3.);\n        col += .5*col + .5+.2*ss*vec3(.3, .2, .8)*vec3(max(.5,ss));\n        col /= 1.-d*.5;\n        col = pow(col, vec3(1.5));\n    }\n    \n    col = pow(col, vec3(1., 3.*d, .2));\n    col *= 1.-length(uv)*.4;\n    fragColor = vec4(pow(col.grb, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 116, 116, 498], [500, 500, 519, 519, 616], [618, 618, 649, 649, 805], [807, 807, 831, 831, 1018], [1020, 1020, 1053, 1053, 1173], [1175, 1175, 1232, 1232, 2081]]}
{"id": "tsj3D3", "name": "Sphere grid movement", "author": "noby", "description": "Regular infinite grid of spheres, with a random path moving inbetween them", "tags": ["raymarching", "grid", "sphere", "spheres", "random", "infinite", "path", "spheretraching"], "likes": 36, "viewed": 644, "published": "Public", "date": "1550181569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(uint n){\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash(vec3 p3){\n    p3 = fract(p3*.1031);\n\tp3 += dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nvec3 cellid;\nvoid repeat(inout vec3 p, vec3 dim){\n    cellid = floor((p )/(dim));\n    p = mod(p, dim)-dim*0.5;\n}\n\nconst float spacing = 3.0;\nvec3 targetpos;\nvec3 targetactual;\n\nfloat target(vec3 p){\n    return sphere(p-targetactual, 1.0);\n}\n\nfloat map(vec3 p){\n    float t = target(p);\n    repeat(p, vec3(spacing));\n    return min(t, sphere(p, 0.5));\n}\n\nvec3 normal(vec3 p){\n    float c = map(p);\n    const float e = 0.001;\n    return normalize(vec3(c-map(p-vec3(e,0,0)), c-map(p-vec3(0,e,0)), c-map(p-vec3(0,0,e))));\n}\n\nfloat intersect(vec3 cam, vec3 ray){\n    float d = 0.0;\n    const int steps = 99;\n    for(int i = 0; i < steps; ++i){\n        float t = map(cam+ray*d);\n        d += t;\n        if(t < 0.002 || d > 50.0)\n        \tbreak;\n    }\n    \n    return min(d, 50.0);\n}\n\nvec3 shade(vec3 cam, vec3 ray, vec3 pos, vec3 n, vec3 rv, float anim){\n    const vec3 rc = vec3(0.9,0.1,0.05);\n    if(target(pos) < 0.01)\n        return rc;\n    \n    vec3 emit = vec3(0);\n    if(hash(cellid) > 0.75)\n        emit = vec3(0.9)*(1.0-smoothstep(5.5, 6.0, distance(floor(targetactual), floor(pos))));\n    \n    vec3 light = targetactual;\n    vec3 lv = normalize(light-pos);\n#if 1\n    float lambert = 0.1*max(0.0, dot(n, lv));\n    float spec = 0.5*pow(max(0.0, dot(lv, rv)), 100.0);\n    \n    float ld = distance(pos, light);\n    float falloff = pow(1.0-smoothstep(1.0, 14.0, ld), 6.0);\n    vec3 surface = mix(vec3(1), rc, 0.25)*vec3(lambert+spec)*(falloff);\n    if(hash(-cellid) > 0.5)\n        surface *= 0.0;\n# else\n\tvec3 surface = vec3(0);\n#endif\n    float spacing = 2.0+6.0*hash(cellid+9999.);\n    emit += step(0.5, mod(pos.y*spacing+iTime*(-1.0+2.0*hash(cellid+999.)), 1.0))*falloff * step(0.8, hash(-cellid));\n    surface += emit;\n    \n    \n    \n    return surface;\n}\n\nvec3 getpoint(uint index){\n    float a = floor(0.5+4.5*hash(index));\n    float b = floor(0.5+4.5*hash(index+1U));\n    float c = floor(0.5+4.5*hash(index+2U));\n    \n    vec3 p = vec3(a,b,c);\n    switch( int(mod(float(index), 3.0)) ){\n        case 0:\n        \treturn p.xyz;\n        case 1:\n        \treturn p.zxy;\n        case 2:\n        \treturn p.yzx;\n    }\n}\n\nvec3 path(float time){\n    uint index = uint(time);\n    return spacing*mix(getpoint(index), getpoint(index+1U), smoothstep(0.0, 1.0, mod(time, 1.0)));\n}\n\nmat3 lookat(vec3 cam, vec3 target){\n\tvec3 ww = normalize(target - cam);\n\tvec3 uu = normalize(cross(ww, normalize(vec3(1e-4,1.0-1e-4,1e-4))));\n\tvec3 vv = normalize(cross(uu, ww));\n\treturn mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cum = vec3(0);\n    const int samples = 3;\n    for(int y = 0; y < samples; ++y)\n        for(int x = 0; x < samples; ++x){\n            vec2 p = -1.0 + 2.0 * (uv + (-1.0+2.0*(vec2(x, y)/float(samples)))/iResolution.xy);\n            p.y *= iResolution.y/iResolution.x;\n            \n            float anim = 10.0+iTime-texelFetch(iChannel0, ivec2(mod(fragCoord*float(samples)+vec2(x,y),1024.)),0).r/48.0;\n\n            // cam setup\n            vec3 cam = vec3(0,0,0) + path(anim);\n            targetpos = path(anim+2.25);\n            targetactual = path(anim+2.35);\n            float fov = mix(0.5, 5.0, smoothstep(5.0, 20.0, distance(cam, targetpos)));\n            vec3 ray = normalize(vec3(p, fov));\n            ray = lookat(cam, targetpos) * ray;\n\n            // primary ray and shading\n            float dist = intersect(cam, ray);\n            \n            if(dist < 50.0){\n                vec3 pos = cam+ray*dist;\n                vec3 n = normal(pos);\n                vec3 rv = reflect(ray, n);\n                vec3 col = shade(cam, ray, pos, n, rv, iTime);\n\t\t\t\t\n                // reflection ray\n                float rd = intersect(pos+n*0.01, rv);\n                vec3 rpos = pos+rv*rd;\n                vec3 rn = normal(rpos);\n                vec3 rrv = reflect(rv, rn);\n\n                // reflection shading\n                vec3 rcol = shade(pos, rv, rpos, rn, rrv, iTime);\n                float fresnel = pow(1.0-max(0.0, dot(n, -ray)), 5.0);\n                col = mix(col, rcol, fresnel);\n                //col += fresnel/pow(distance(cam, pos), 2.0);\n\t\t\t\t\n                cum += col;\n            }\n    }\n    \n    cum /= float(samples*samples);\n    \n    cum *= 1.0+0.1*(-1.0+2.0*hash(vec3(fragCoord, iTime)));\n    \n    cum = mix(cum, mix(vec3(0.82,0.99,0.82)*0.02, vec3(0.99,0.92,0.85), cum), 0.1);\n    cum = pow(cum, vec3(1.0/2.2));\n    cum = smoothstep(-0.2, 1.05, cum);\n    fragColor.rgb = cum;\n    \n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsj3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 157], [159, 159, 179, 179, 272], [274, 274, 304, 304, 330], [345, 345, 381, 381, 444], [509, 509, 530, 530, 572], [574, 574, 592, 592, 684], [686, 686, 706, 706, 851], [853, 853, 889, 889, 1108], [1110, 1110, 1180, 1180, 2090], [2092, 2092, 2118, 2118, 2449], [2451, 2451, 2473, 2473, 2603], [2605, 2605, 2640, 2640, 2811], [2813, 2813, 2869, 2869, 4834]]}
{"id": "tsj3DG", "name": "Weird liquid", "author": "fabiojcortes", "description": "Water experiment", "tags": ["water"], "likes": 0, "viewed": 79, "published": "Public", "date": "1549927710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = 5.0*fragCoord/iResolution.xy;\n\n    for(int n = 1; n < 7; n++){\n    float i = float(n);\n      p += vec2(0.5 / i * sin(i * p.y  *+ iTime + 0.3 * i) + 0.8, 0.4 / i * sin(i*p.x+ iTime + 0.3 * i) + 1.6);\n    }\n\n    p *= vec2(0.5 / tan(p.y + iTime + 0.3) + 0.8, 0.4 / sin(p.x + iTime + 0.3) + 1.6);\n    vec3 col = vec3(0.1 * sin(p.x) + 0.2, 0.5 * sin(p.y) + 0.2, sin(p.x));\n    col *= 0.9;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsj3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 563]]}
{"id": "tsjGRG", "name": "kaleidoscope city", "author": "Kushulain", "description": "Fractal formula taken from paulofalcao https://www.shadertoy.com/view/Mss3Wf\nUse mouse to change point of view.\nI added some mystic SHA256 singing.", "tags": ["fractal", "ray", "marching", "city"], "likes": 28, "viewed": 623, "published": "Public", "date": "1549219296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define steps 10\n#define camDist 30.\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\n//float rayDist = 1000.0;\nfloat dist = 1000.0;\nvec3 rayColor = vec3(0.0,0.0,0.0);\nvec3 ro;\n\nfloat fog = 0.;\n\n\nfloat sphere(vec3 ray,vec3 pos, float radius)\n{\n    return length(ray-pos) - radius;\n}\n\nfloat cylinder(vec3 ray,vec3 pos, float radius, float height)\n{\n    return max(length(ray.xy-pos.xy) - radius, abs(ray.z-pos.z)-height);\n}\n\nfloat cube(vec3 ray, vec3 pos, float size)\n{\n    ray = abs(ray-pos) - size;\n    return max(max(ray.x,ray.y),ray.z);\n}\n\nfloat line(vec3 ray, vec3 pos, float size)\n{\n    ray = abs(ray-pos) - size;\n    return max(ray.z,ray.y);\n}\n\nfloat box(vec3 ray, vec3 pos, vec3 size)\n{\n    ray = abs(ray-pos) - size;\n    return max(max(ray.x,ray.y),ray.z);\n}\n\nvec3 Spherize(vec3 pos)\n{\n    vec3 result = vec3(0.,0.,0.);\n    result.x = atan(normalize(pos.xy)).y * 10.0;\n    result.y = atan(normalize(pos.zx)).y * 10.0;\n    result.z = (2.*length(pos))-15.;\n    result.xy += 10.;\n    return result;\n}\n\nvec3 FractalSpace(vec3 pos)\n{\n    pos *= 0.1;\n    \n    float height = length(pos) * 10.0;\n    float s=3.;\n\tfor(int i=0;i<steps;i++){\n\t\tpos.xy=abs(pos).xy-s; \n        pos.xy *= rz2(0.1*iTime);\n        //pos.xz *= rz2(2.8+iTime*0.23); //PLEASE DO NOT UNCOMMENT ME\n\t\ts=s/1.3;\n\t}\n    \n    return pos;\n}\n\nfloat map(vec3 pos)\n{\n    float rayDist = 0.;\n    \n    //pos = Spherize(pos);\n    \n    pos = FractalSpace(pos);\n    pos += .05;\n    \n    vec3 pos1 = pos;\n    pos1.x = abs(pos.x);\n    vec3 pos2 = pos;\n    \n    pos.xy = abs(pos.xy);\n    \n    \n    //ground\n    rayDist = box(pos,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n    \n    //roads\n    rayDist = max(rayDist,-box(pos,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    rayDist = max(rayDist,-box(pos,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    \n    rayDist = max(rayDist,-box(pos,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    rayDist = max(rayDist,-box(pos,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n    \n    \n    \n    //Paris building\n    /*vec3 b1 = pos;\n    b1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    rayDist = min(rayDist,box(b1,vec3(0.,0.,0.0),vec3(0.05,0.05,0.05)));\n    rayDist = max(rayDist,-box(b1,vec3(0.0,0.0,0.05),vec3(0.02,0.02,0.05)));\n    \n    vec3 bev1 = b1;\n    bev1 -= vec3(0.04,0.06,0.062);\n    bev1.yz *= rz2(2.);\n    rayDist = max(rayDist,-box(bev1,vec3(0.0),vec3(0.02,0.02,0.02)));\n    \n    vec3 bev2 = b1;\n    bev2 -= vec3(0.057,0.03,0.062);\n    bev2.xz *= rz2(2.1);\n    rayDist = max(rayDist,-box(bev2,vec3(0.0),vec3(0.02,0.022,0.02)));*/\n    \n    \n    \n    //Paris building\n    vec3 b1 = pos;\n    b1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.,.5*pos.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.01);\n    rayDist = min(rayDist,box(b1,vec3(0.,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    rayDist = max(rayDist,-box(b1,vec3(0.0,0.0,0.05),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    \n    rayDist = min(rayDist,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.008)));\n    rayDist = min(rayDist,box(b1,vec3(0.04,0.01,0.05),vec3(0.005,0.001,0.008)));\n    \n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n    rayDist = max(rayDist,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n    \n    //Garden walls\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n    rayDist = min(rayDist,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    rayDist = max(rayDist,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n    \n    //Garden trees\n    float noise = 1.+0.1*length(sin(pos*2000.0))+0.2*length(sin(pos*900.0)); \n    \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    rayDist = min(rayDist,cylinder(b0,vec3(0.,0.,-0.01),0.001,0.006));\n    b0*=noise;\n    rayDist = min(rayDist,sphere(b0,vec3(0.),0.008));\n\n    //big building\n    vec3 b2 = pos;\n    b2.xy -= 0.22;\n    //b2.xy -= vec2(0.22,-0.08);\n    b2 = abs(b2);\n    rayDist = min(rayDist,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.05,0.1)));\n    rayDist = min(rayDist,box(b2,vec3(0.,0.,0.05),vec3(0.04,0.04,0.1)));\n    //rayDist = min(rayDist,box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n    \n    //parking\n    vec3 b3 = pos2;\n    b3.xy -= vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.033),vec3(0.05,0.05,0.033)));\n    rayDist = max(rayDist,-box(b3,vec3(0.,0.0,0.064),vec3(0.049,0.049,0.006)));\n    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    rayDist = max(rayDist,-box(b3,vec3(0.022,0.,0.033),vec3(0.01,0.051,0.003)));\n    rayDist = max(rayDist,-box(b3,vec3(0.,0.022,0.033),vec3(0.051,0.01,0.003)));\n    rayDist = max(rayDist,-box(b3,vec3(0.022,0.,0.053),vec3(0.01,0.051,0.003)));\n    rayDist = max(rayDist,-box(b3,vec3(0.,0.022,0.053),vec3(0.051,0.01,0.003)));\n    \n    //square\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    rayDist = min(rayDist,box(b4,vec3(0.,0.,0.003),vec3(0.05,0.05,0.003)));\n    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.051,0.01,0.004)));\n    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.01,0.051,0.004)));\n    \n    vec3 cone = b4;\n    vec3 stairs = b4;\n    \n    rayDist = min(rayDist,cylinder(b4,vec3(0.,0.,0.015),0.015,0.006));\n    \n    cone.xy += (cone.z-0.021);\n    rayDist = min(rayDist,cylinder(cone,vec3(0.,0.,0.027),0.015,0.006));\n    \n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n    rayDist = min(rayDist,box(stairs,vec3(0.018,0.018,0.0),vec3(0.01,0.01,0.01)));\n    rayDist = min(rayDist,box(stairs,vec3(0.00,0.0,0.01),vec3(0.01,0.01,0.02)));\n    \n    \n    //Business building\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n    b5.xy *= 1.+2.0*floor(b5.z * 50.0)/50.0;\n    b5.xy *= rz2(b5.z);\n    rayDist = min(rayDist,box(b5,vec3(0.,0.,0.15),vec3(0.05,0.05,0.15)));\n    \n    fog = pos.z;\n    \n    return rayDist;\n    \n}\nvec4 GetSampleColor(vec2 uv)\n{\n    ro = vec3(0.,0.,-camDist);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.)) * 7.;\n    \n    rd.yz *= rz2(3.14+1.6*iMouse.y / iResolution.y);\n    rd.xy *= rz2(3.1*iMouse.x / iResolution.y);\n    ro.yz *= rz2(3.14+1.6*iMouse.y / iResolution.y);\n    ro.xy *= rz2(3.1*iMouse.x / iResolution.y);\n    \n    vec3 mp=ro;\n    \n    int i;\n    for (i=0;i<120;i++){\n        dist = map(mp);\n        //if(abs(rayDist)<mix(0.0001,0.1,(mp.z+camDist)*0.005))\n        if(abs(dist)<0.0001)\n            break;\n        mp+=rd*dist;\n    }\n    \n    float ma=1.-float(i)/120.;\n    \n    return vec4(mp,ma);\n}\n\nvec3 GetNormal(vec3 pos, float posDist)\n{\n    vec2 e = vec2(0.002,0.) * length(pos-ro);\n    return normalize(vec3(map(pos+e.xyy) - posDist, map(pos+e.yxy) - posDist, map(pos+e.yyx) - posDist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n\n    \n    vec4 pos = GetSampleColor(uv);\n    float height = fog;\n    //vec4 posX = GetSampleColor(vec2(uv.x+dFdx(uv).x*0.8,uv.y));\n    //vec4 posY = GetSampleColor(vec2(uv.x,uv.y+dFdy(uv).y*0.8));\n    \n    //vec3 normal = normalize(cross(normalize(posY.xyz-pos.xyz),normalize(posX.xyz-pos.xyz)));\n    vec3 normal = GetNormal(pos.xyz,dist);\n    \n    //cam direction (screen space)\n    //vec3 cp = vec3(0.,0.,-1);\n    \n    vec3 lightPOV = vec3(1.,-1.,1.);\n    vec3 lightPOV2 = vec3(-1.,-1.,1.);\n    \n    pos.w *= pos.w;\n    \n    //diffuse\n    vec3 finalCol = max(0.,dot(normal,lightPOV)) * vec3(0.,.5,1.);\n    finalCol +=  max(0.,dot(normal,lightPOV2)) * vec3(1.,.5,0.);\n    finalCol *= 0.8;\n    \n    vec3 fogCol = vec3(1.,0.8,0.7);\n    float rayLgth = length(pos.xyz-ro) * 0.005;\n    //finalCol *= vec3(pow(rayLgth,1.));\n    finalCol = mix(finalCol*pos.w,fogCol,rayLgth);\n    //finalCol += fogCol*rayLgth;\n    //finalCol += (1.-finalCol)*pow(max(0.,1.-fog),20.)*0.2 * (1.-pos.z*0.01);\n    if (height < 0.0 && pos.w > 0.1)\n    \tfinalCol *= 0.5;\n    \n    \n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [{"id": "Mlf3DH", "previewfilepath": "https://soundcloud.com/kushulain/shant-du-sha-v2", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kushulain/shant-du-sha-v2", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 56, 56, 103], [105, 215, 262, 262, 301], [303, 303, 366, 366, 441], [443, 443, 487, 487, 560], [562, 562, 606, 606, 668], [670, 670, 712, 712, 785], [787, 787, 812, 812, 1024], [1026, 1026, 1055, 1055, 1324], [1326, 1326, 1347, 1347, 5977], [5978, 5978, 6008, 6008, 6588], [6590, 6590, 6631, 6631, 6785], [6787, 6787, 6844, 6844, 7996]]}
{"id": "tsjGWy", "name": "20190211", "author": "Justaway", "description": "20190211", "tags": ["20190211"], "likes": 2, "viewed": 127, "published": "Public", "date": "1550173418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SETS 8\n#define TIME_SCALE 10.0\nfloat[30*NUM_SETS] coef = float[30*NUM_SETS](\n    -1.017237, -0.903984, -0.512759, 0.476637, 0.271241, -1.150559, 0.560693, 0.097803, -0.407286, 0.882287, 0.180914, -0.420358, -1.081892, 0.498610, 1.087361, 0.243611, 0.331453, -0.502525, -0.359248, 1.084326, 0.834692, -0.634044, 0.660750, 1.096257, -0.059903, 0.350534, 0.602114, 0.025440, 0.993483, -0.476214, \n    -0.786305, -0.298404, 0.372053, 0.756946, 0.353847, -0.400713, -0.932856, 0.917608, 0.942425, -1.004183, 0.381193, 0.093966, -0.324366, -0.402953, -0.055247, 0.244378, -0.013363, 0.294876, 1.054206, 0.307839, -0.879138, -0.464629, -0.686187, 0.719042, -0.490385, 0.648228, 0.471379, 1.016690, 0.300288, 0.150001,\n    0.803768, 0.661441, -0.424644, -0.470243, 0.050267, 0.514802, -0.649469, -0.705689, -0.561211, 0.101740, -1.175427, -0.765153, -0.490339, -0.606044, 0.322624, 0.003870, -0.050577, 0.528116, -0.553878, 0.284891, -1.128502, 0.028663, -0.758520, 0.874346, -0.594991, -0.932099, -0.740500, 0.732730, 0.706501, 0.123612,\n    -0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n    -0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n    0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n    -0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n    -0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114);\n\nfloat[30] c;\n\nvec3 Dmap(vec3 v, vec3 d){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0] + c[3]*y + c[5]*z + 2.0*c[6]*x*d.x + 1.0;\n    newV.y = c[11] + c[13]*x +c[14]*z + 2.0*c[17]*y*d.y + 1.0;\n    newV.z = c[22] + c[24]*y + c[25]*x + 2.0*c[28]*z*d.z + 1.0;\n    return newV;\n}\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*1693.0+241.0,4904.0);\n}\n\n#define PI 3.14159265359\nfloat cosstep(float x)\n{\n    return (1.0 - cos(PI*x))/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2((fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    vec3 z = vec3(0.0);\n    vec3 dz = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    float t, t2;\n    float perm;\n    float T2[2];\n    vec3 av = vec3(0.0);\n    int i;\n    float d;\n    vec4 col;\n    float m,mu;\n    vec3 norm;\n    float m2;\n    float myTime = iTime/TIME_SCALE;\n    float timeFloor = floor(myTime);\n    float timeFract = fract(myTime);\n    \n    T[0] = timeFloor;\n    T[1] = T[0]+1.0;\n    t = cosstep(timeFract);\n    perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    T2[0] = timeFloor;\n    T2[1] = T2[0] + 1.0;\n    t2 = cosstep(timeFract);\n    perm = permute(permute(T2[0]));\n    int coefIndex[2];\n    coefIndex[0] = int(mod(perm, float(NUM_SETS)));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, float(NUM_SETS)));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    av = vec3(0.0);\n    uv*=10.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    #define ITER 200\n    #define COL_ITER 3\n    for(i = 0; i < ITER; i++)\n    {\n        z = map(z);\n        m = length(z);\n        if(i < COL_ITER)\n        {\n            av += z;\n        }\n        if(m>1.5e9) break;\n    }\n    \n    mu = float(i) - (log(log(m)))/log(2.0);\n    col = vec4((float(ITER)-mu)/float(ITER));\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2647, 2647, 2673, 2673, 3071], [3073, 3073, 3090, 3090, 3645], [3647, 3647, 3667, 3667, 3705], [3707, 3707, 3731, 3731, 3770], [3797, 3797, 3821, 3821, 3857], [3859, 3859, 3916, 3916, 5716]]}
{"id": "tsjGzc", "name": "Portal to the Unseen", "author": "Hauta", "description": "Based on\nhttps://www.shadertoy.com/view/td23RK", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 69, "published": "Public", "date": "1549595380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float start = 0.01;\nconst float end = 32.;\nconst float rayStep = 0.6;\nconst float tolerance = 0.001;\nconst float FOV = .7;\nconst int MAX_ITER = 1024;\nconst vec3 bg_color = vec3(0.9, 0.8, 0.3);\nconst vec3 ref_fog = vec3(.5, 0., 0.);\n\nconst float eps = 0.001;\nconst vec3 e0 = vec3(eps, 0., 0.);\nconst vec3 e1 = vec3(0., eps, 0.);\nconst vec3 e2 = vec3(0., 0., eps);\n\nconst vec3 s_center = vec3(0., 1., 0.);\nconst float s_size = 1.;\n\n// reflection constants for plane\nconst float p_spec = 10.;\nconst vec3 p_color = vec3(0., .5, .5);\nconst vec3 p_norm = vec3(0., 1., 0.);\n\nconst vec3 l_center = vec3(1.5, 5., 1.5);\nconst vec3 l_color = vec3(1.);\nconst float l_atten = .2;\n\n\nvoid twistxy(inout vec3 pos, in float amt) {\n  float z = pos.z * amt;\n  float c = cos(z);\n  float s = sin(z);\n  pos.xy *= mat2(c, -s, s, c);\n}\n    \n// finds distance to reflected surfaces\nfloat ref_dist(in vec3 pos, inout int ID) {\n  twistxy(pos, sin(.5 * iTime)* .2);\n  \n  vec3 npos = pos + vec3(0., 2.*iTime, 0.);\n  vec3 nn = floor(npos / 4.);\n  ID = int(floor(nn.x + nn.y + nn.z));\n    \n  // distance to center point at (n, m, l) * 4. - (2., 2., 2.)\n  return length(max(abs(mod(npos, 4.) - 2.) - 1., 0.));\n}\n\n// finds distance to real surface (sphere || lower plain)\nfloat real_dist(in vec3 pos, inout int ID) {\n  float a = length(pos - s_center) - s_size;\n    \n  if(a < pos.y) {\n    ID = -2;\n    return a;\n  } else {\n    ID = -1;\n    return pos.y;\n  }\n}\n\n\nvec3 real_norm(in vec3 pos) {\n  int ID = 0;\n  return normalize(vec3(\n    real_dist(pos + e0, ID) - real_dist(pos - e0, ID),\n    real_dist(pos + e1, ID) - real_dist(pos - e1, ID),\n    real_dist(pos + e2, ID) - real_dist(pos - e2, ID)));   \n}\n\nvec3 ref_norm(in vec3 pos) {\n  int ID = 0;\n  return normalize(vec3(\n    ref_dist(pos + e0, ID) - ref_dist(pos - e0, ID),\n    ref_dist(pos + e1, ID) - ref_dist(pos - e1, ID),\n    ref_dist(pos + e2, ID) - ref_dist(pos - e2, ID)));\n}\n\n// takes origin, direction, gives distance to \n// surface.\nfloat march(in vec3 o, in vec3 d, in bool first, inout int ID) {\n  float rayDist = start;\n  float nextDist = 1024.;\n  for(int i = 0; i < MAX_ITER; ++i) {\n    ID = 0;\n    nextDist = first ? real_dist(o + d * rayDist, ID) : \n                       ref_dist(o + d * rayDist, ID);\n      \n    if(nextDist < tolerance) {\n      break;\n    }\n      \n    if(rayDist > end) {\n      ID = 0;\n      break;\n    }\n      \n    rayDist += rayStep * nextDist;\n  }\n  \n  return rayDist;\n}\n\nfloat march(in vec3 o, in vec3 d) {\n  int ID = 0;\n  return march(o, d, true, ID);   \n}\n\n\nvec3 color(in vec3 l, in float dist, int ID) {\n  switch(int(mod(float(ID), 5.))) {\n    case 0: return vec3(.6, 0.4, 1.); break;\n    case 1: return vec3(1., 1., 0.6); break;\n    case 2: return vec3(1., 0.8, 1.); break;\n    case 3: return vec3(.4, 1., 0.8); break;\n    case 4: return vec3(.4, 1., 0.4); break;\n  }  \n}\n\n// lighting for plane\nvec3 lighting(in vec3 pos, in vec3 cam, in vec3 color, in bool real) {\n  vec3 incidence = l_center - pos;\n  float ld = length(incidence); \n  incidence = normalize(incidence);\n  vec3 norm = real ? real_norm(pos) : ref_norm(pos);\n  vec3 reflection = reflect(-incidence, norm);\n    \n  if(march(pos, incidence) < ld) {\n    return vec3(0.);      \n  }\n    \n  float atten = min(1./ (l_atten * ld), 1.);\n  float diff = max(0., dot(incidence, p_norm));\n  float spec = max(0., dot(reflection, normalize(cam - pos)));\n  spec = pow(spec, p_spec);\n    \n  return (color * diff + spec) * l_color * atten;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n  // camera position + orientation\n  vec3 cam = vec3(4. * sin(.1 * iTime), 1.5 + .7 * cos(.2 + .3 * iTime), 2. * cos(.1*iTime));\n\n  vec3 forward = normalize(s_center - cam);\n  vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n  vec3 up = normalize(cross(forward, right));\n    \n  vec3 o = cam;\n  vec3 d = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n  \n  int ID = -3;\n  float dist = march(o, d, true, ID);\n  vec3 no = o + dist*d;\n    \n  if(ID == 0) {\n    fragColor = vec4(bg_color, 1.);\n    return;\n  }\n    \n  if(ID == -1) {\n    vec3 l = lighting(no, cam, p_color, true);\n    fragColor = vec4(l, 1.);\n  }\n    \n  if(ID == -2) {\n    vec3 l = lighting(no, cam, p_color, true);\n    vec3 dir = normalize(reflect(no, real_norm(no)));\n    float dist2 = march(no, dir, false, ID);\n    vec3 l2 = color(l, dist2, ID);\n    l2 = lighting(no + dist2*dir, no, l2, false);\n    float fog_atten = 1./(.1 * (dist2 + dist));\n    fragColor = vec4(mix(l2, ref_fog, 1. - fog_atten), 1.);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[436, 675, 719, 719, 817], [823, 863, 906, 906, 1185], [1187, 1245, 1289, 1289, 1432], [1435, 1435, 1464, 1464, 1675], [1677, 1677, 1705, 1705, 1907], [1909, 1968, 2032, 2032, 2434], [2436, 2436, 2471, 2471, 2522], [2525, 2525, 2571, 2571, 2840], [2842, 2864, 2934, 2934, 3455], [3458, 3458, 3513, 3513, 4589]]}
{"id": "tslSz7", "name": "Soundshader", "author": "Airground", "description": "is showing a scaling color circle", "tags": ["sounddisplay"], "likes": 17, "viewed": 2207, "published": "Public API", "date": "1550961603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 128.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.5;\nconst float BRIGHTNESS = 0.15;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 color){\n    vec4 konvert = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 calc = abs(fract(color.xxx + konvert.xyz) * 6.0 - konvert.www);\n    return color.z * mix(konvert.xxx, clamp(calc - konvert.xxx, 0.0, 1.0), color.y);\n}\n\nfloat luma(vec3 color) {\n  //return dot(color, vec3(0.299, 0.587, 0.114));\n  return dot(color, vec3(0.299, 0.587, 0.5));\n}\n\nfloat getFrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getFrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getFrequency(index), getFrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getFrequency_blend(float x) {\n    return mix(getFrequency(x), getFrequency_smooth(x), 0.5);\n}\n\nvec3 circleIllumination(vec2 fragment, float radius) {\n\tfloat distance = length(fragment);\n\tfloat ring = 1.0 / abs(distance - radius - (getFrequency_smooth(0.0)/4.50));\n\t\n\t//float brightness = distance < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcolor += hsv2rgb( vec3( ( angle + iTime * 2.5 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * BRIGHTNESS;\n\t\n\tfloat frequency = max(getFrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcolor *= frequency;\n\t\n\t// Black halo\n\t//color *= smooth//step(radius * 0.5, radius, distance);\n\t\n\treturn color;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getFrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n\tcolor += circleIllumination(fragPos, RADIUS);\n    \n    \n    \n    color += max(luma(color) - 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 181, 206, 206, 423], [425, 425, 449, 499, 547], [549, 549, 578, 578, 671], [673, 673, 709, 709, 920], [922, 922, 957, 957, 1021], [1023, 1023, 1077, 1077, 1627], [1629, 1629, 1680, 1680, 1932], [1934, 1934, 1991, 1991, 2311]]}
{"id": "tslXD4", "name": "caged crystal (remix)", "author": "_discovery", "description": "remix of [url]https://www.shadertoy.com/view/tdlXW4[/url]\nDefinitely view the original, I just made some minor changes for personal fun.\nThe original was done on a livestream, see the link for more info!", "tags": ["sdf", "raymarcher", "crystal"], "likes": 10, "viewed": 220, "published": "Public", "date": "1551314467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* remix of https://www.shadertoy.com/view/tdlXW4 */\n\n#define pi acos(-1.)\n\nint mat;\nvec3 shift;\n\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nvec2 rotate(vec2 a,float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p=abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    p=abs(p);\n    return (p.x+p.y+p.z-r)/sqrt(3.);\n}\n\nfloat sdInk(vec3 p)\n{\n    float spacing = .15;\n    float thickness = .025;\n    p.y += sin(p.y*3.-iTime*2.)*.09;\n    p.xz = rotate(p.xz, (floor(p.y/spacing-.5)*spacing+spacing/2. + iTime*.0) * .9);\n    float w = .25 + pow(p.y,2.)*.5;\n    shift = p;\n    return max(\n        sdBox(p,vec3(w,.9,w)),\n        abs(mod(p.y-spacing/2.,spacing)-spacing/2.)-thickness\n    )*.8;\n}\n\nfloat sdGold(vec3 p)\n{\n    float q = sin(iTime)*.8;\n    q = sin(iTime-2.+cos(iTime*2.))*.1;\n    float box = max(sdBox(p,vec3(1.0)),-sdBox(p,vec3(.96)));\n    float oct = max(sdOctahedron(p,2.01+q),-sdOctahedron(p,1.99+q));\n    oct = min(oct, max(sdOctahedron(p,1.95+q),-sdOctahedron(p,1.9+q)));\n    float edges = 1.25;\n    float oct1 = max(sdOctahedron(p-edges,1.98+q),-sdOctahedron(p,1.850+q));\n    float oct2 = max(sdOctahedron(p+edges,1.98+q),-sdOctahedron(p,1.850+q));\n    return max(box, min(min(oct1,oct2), oct));\n}\n\nfloat sdGround(vec3 p)\n{\n    return p.y+1.2;\n}\n\nfloat tick(float t)\n{\n    float f=floor(t);\n    t=fract(t);\n    t=smoothstep(0.,1.,t);\n    t=smoothstep(0.,1.,t);\n    return f+t;\n}\n\nvec2 tickspin(vec2 a)\n{\n    return rotate(a,tick(iTime*.125)*pi*.5);\n}\n\nfloat scene(vec3 p)\n{\n    float ground = sdGround(p);\n\n    p.xz = tickspin(p.xz);\n\n    float ink = sdInk(p);\n    float gold = sdGold(p);\n    float best = min(min(ink,gold),ground);\n    if(ink==best)\n        mat=0;\n    else if(gold==best)\n        mat=1;\n  else\n    mat=2;\n  return best;\n}\n\nfloat noisefloor(vec2 uv,float t)\n{\n    float n = texNoise(uv*.1).r*4.-1.;\n    return texNoise(vec2(n+iTime*t)).r;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t =0.;\n    float k =0.;\n    vec3 accum = vec3(1);\n    vec3 emit = vec3(0);\n    for(int i=0;i<100;++i){\n        k=scene(cam+dir*t);\n        t+=k;\n        if(abs(k)<.001)\n        {\n            vec3 h = cam+dir*t;\n            vec2 o = vec2(.01,0);\n            vec3 n = normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n            if (mat == 0)\n            {\n                float f = -0.9*mod(1.0+abs(sin(iTime)), 8.42);\n                vec3 pos = floor(shift*10.+.5);\n                float noise = noisefloor(f*shift.xz*.5+pos.y*.9,0.)*2.-.25;\n                float fresnel = pow(max(0.,1.-dot(-dir,n)),5.)*.5;\n                accum *= fresnel;\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n                emit += pow(noise,6.5)*10. * vec3(19.1,.1,.4) * 2.;\n            }\n            else if (mat == 1)\n            {\n                accum *= vec3(1,.45,.1);\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n            }\n            else if (mat == 2)\n            {\n                float noise = noisefloor(h.xz,.1)*2.-.1;\n                accum *= noise*.7+.3;\n                accum *= vec3(.04,.04,0.05);\n                cam = h+n*.01;\n                dir = mix(reflect(dir,n),n,noise*.1);\n                t = 0.;\n            }\n        }\n    }\n    return accum+emit;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/ iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-100);\n    vec3 dir = normalize(vec3(uv,25));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n    cam.xz = rotate(cam.xz, pi/8.);\n    dir.xz = rotate(dir.xz, pi/8.);\n\n    out_color.rgb = trace(cam,dir);\n    out_color.rgb = pow(out_color.rgb, vec3(.45));\n    out_color.rgb *= 1.-dot(uv,uv)*.4;\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 163, 187, 187, 425], [427, 427, 456, 456, 567], [569, 569, 598, 598, 650], [652, 652, 689, 689, 742], [744, 744, 765, 765, 1112], [1114, 1114, 1136, 1136, 1634], [1636, 1636, 1660, 1660, 1682], [1684, 1684, 1705, 1705, 1815], [1817, 1817, 1840, 1840, 1887], [1889, 1889, 1910, 1910, 2176], [2178, 2178, 2213, 2213, 2294], [2296, 2296, 2328, 2328, 3821], [3823, 3823, 3875, 3875, 4304]]}
{"id": "tsS3RG", "name": "Shader session at IUT #1", "author": "antonOTI", "description": "I've done a shader session at my IUT (a kind of French school) for there open doors event\n\ndone on Bonzomatic with some @Iq functions to help me up :)", "tags": ["raymarching", "livecoding", "showdown", "bonzomatic"], "likes": 4, "viewed": 370, "published": "Public API", "date": "1549133039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159\n#define TAU 2. * PI\n#define REP(p, r) (mod(p + r/2., r) - r /2.)\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat subtraction( float d1, float d2, float k ) \n{\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat intersection( float d1, float d2, float k ) \n{\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 lookAt (vec3 eye, vec3 at, vec2 uv) \n{\n  vec3 forward = normalize(at - eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward + right * uv.x + up * uv.y);\n}\n\n\nvec2 modA(vec2 p, float r)\n{\n  float a = atan(p.y,p.x);\n\n  a = mod(a + PI, TAU/r) - PI;\n\n  return length(p) * vec2(cos(a),sin(a));\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat ease(float t)\n{\n  return floor(t) + sin(fract(t) * PI - PI / 2.) * .5 + .5;\n}\n\nfloat map(vec3 p)\n{\n\n  vec3 cp = p;\n  float dist = 1000.;\n  float time = iTime;\n  time = ease(time ) * 5. ;\n\n\n  p.z += iTime * 3.;\n\n  p.xy *= rot(sin(p.z * .1) * .1);\n\n  p = REP(p, 30.);\n\n  p.x = abs(p.x);\n\n\n  float bump = sin(iTime  * 2.+ p.y * .2 + p.x + cp.z*.25) * .5 + .5;\n\n  bump = pow(bump, 4.)*.9+.5;\n\n  p.y -= p.x * bump;\n\n  dist = length(p) - 1.;\n\n  p = cp;\n\n\n\n  p.xy *= rot(p.z * .5 + iTime);\n    \n//  p.xy = modA(p.xy, 2.);\n  p.x = -abs(p.x);\n  p += 1.7;\n\n\n  float cy = length(p.xy) - .5;\n\n  dist  = min(dist, cy);\n\n  p = cp;\n  cy = length(p.xy) - .4 * clamp(-cp.z*.1+1.,0.,1.);\n\n  dist = -min(-dist, cy);\n  return dist;\n}\n\n\nfloat cd = 0.;\nfloat ray(inout vec3 cp, vec3 rd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1./ 128.)\n  {\n    cd = map(cp);\n    if(cd < .01) break;\n    cp += rd * cd * .5;\n  }\n\n  return st;\n}\n\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 tar = vec3(0.);\n  vec3 rd = lookAt(eye, vec3(0.), uv);\n  vec3 cp = eye;\n\n  float st = ray(cp,rd);\n\n  vec3 norm = normal(cp);\n  vec3 ldir = normalize(tar - eye);\n\n  float li = dot(norm, ldir * 2.);\n  li = pow(1. - li, 3.);\n  \n\n  fragColor = vec4(li) * (1. - st);\n  fragColor.zy *= rot(cp.x);\n  fragColor.xz *= rot(cp.y);\n  fragColor.xy *= rot(cp.z * .1);\n  fragColor *= 3.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsS3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 122, 122, 146], [148, 148, 179, 179, 329], [331, 331, 376, 376, 530], [532, 532, 568, 568, 602], [604, 604, 668, 668, 789], [791, 791, 824, 824, 855], [857, 857, 908, 908, 1004], [1006, 1006, 1058, 1058, 1153], [1155, 1155, 1198, 1198, 1395], [1398, 1398, 1426, 1426, 1530], [1532, 1532, 1551, 1551, 1624], [1626, 1626, 1647, 1647, 1709], [1711, 1711, 1730, 1730, 2345], [2363, 2363, 2398, 2398, 2537], [2540, 2540, 2561, 2561, 2722], [2724, 2724, 2781, 2781, 3333]]}
{"id": "tsS3Rt", "name": "[TWITCH] Framed", "author": "Flopine", "description": "Here is the result of a twitch live session when I totally improvised... And produced this :)\nYou can watch the full process here: https://www.twitch.tv/videos/377379162", "tags": ["raymarching", "palette", "livecoding", "twitch"], "likes": 12, "viewed": 177, "published": "Public", "date": "1549667214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI acos(-1.)\n#define time iTime\n\n\nfloat random (vec2 st) \n{return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a), cos(a));}\n\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l= length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n\nvoid mo (inout vec2 p, vec2 d)\n{\n  p = abs(p)-d;\n  if (p.y > p.x) p.xy = p.yx; \n}\n\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b+cos(2.*PI*(c*t+d));}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat stmin(float a, float b , float k , float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b) , 0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0., max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\n\nfloat g1 = 0.;\nfloat globe (vec3 p)\n{\n    float d = sphe(vec3(p.x, p.y-1.,p.z), 1.);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\n\nfloat prim1 (vec3 p)\n{\n    float t1 = floor(time);\n    float t2 = fract(time);\n    t2 = pow(t2, 6.);\n\n    float anim = PI/4.*(t1+t2);\n\n    p.xz*= rot(anim);\n    float b = box (p, vec3(1.,0.5,1.));\n    float o = od (p, 1.);\n    float s = globe(p);\n\n    p.y += 0.7;\n    p.xz = moda(p.xz, PI/2.);\n    p.x -= 1.5;\n    float c = cyl(p.yzx, 0.4-p.x*0.2, 2.);\n    return stmin(s,stmin(o,b,0.5, 5.), 0.2, 3.); \n}\n\n\nfloat prim2 (vec3 p)\n{\n    vec3 pp = p;\n    p.y += 2.;\n    float c = cyl(p.xzy, 0.4, 2.);\n\n    p = pp;\n    p.y += 1.5  ;\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 5.;\n    p.y += sin(p.x-time)*0.3;\n\n    float d = min(c,cyl (p.yzx, 0.1-p.x*0.1, 5.));\n    return d;\n}\n\n\nfloat prim3 (vec3 p)\n{\n    float p1 = prim1(p);\n    float p2 = prim2(p);\n    return min(p1,p2);\n}\n\n\nfloat g2 = 0.;\nfloat heart (vec3 p)\n{\n    float d = sphe(p, 0.8-sin(time)*0.5+0.5);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\n\nfloat id = 0.;\nfloat prim4 (vec3 p)\n{\n    p.x -= 15.*(floor(time*0.4) + smoothstep(0.,1.,smoothstep(0.1,0.3,fract(time*0.4))));\n    float per = 15.;\n    id = floor((p.x-per/2.)/per);\n    p.x = mod(p.x-per/2., per)-per/2.;\n    p.xz *= rot(PI/2.);\n    vec3 pp = p;\n    p.xz *= rot(time*0.6);\n    float s = min(heart(p),max(-od(p, 1.7),sphe(p, 2.)));\n    p = pp;\n    p.yz = moda(p.yz, 2.*PI/3.);\n    p.y -= 5.;\n    return smin(s,prim3(p), 0.5);\n}\n\n\nfloat g3 = 0.;\nfloat od_frame(vec3 p)\n{\n    float o = od (p, 1.);\n    g3 += 0.1/(0.1+o*o);\n    return o;\n}\n\n\nfloat frame (vec3 p)\n{\n    float per = 5.;\n\n    mo(p.xy, vec2(10., 7.));\n    p.x += sin(p.y*0.1);\n    p.y += sin(p.x*2.);\n    vec3 pp = p;\n    p.y = mod(p.y, per)-per/2.;\n    float o = od_frame(p);\n\n    p = pp;\n    p.xz *= rot(time);\n    p.xz *= rot(p.y*0.7);\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 0.6;\n    float c = cyl(p.xzy, 0.2, 1e9);\n    return smin(o,c, 0.2);\n}\n\n\nfloat SDF (vec3 p)\n{\n    float f = frame(p);\n    if (abs(p.x) < 10. && abs(p.y) < 7.) return min(f,prim4(vec3(p.x, p.y+0.3 , p.z-5.)));\n    else return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = random(uv);\n\n    vec3 ro = vec3(0.01,0.01, -19.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n\n    float shad = 0.;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d*= 0.7 + dither*0.1;\n        p+=d*rd;\n    }\n\n    vec3 pal = palette(id,\n                       vec3(0.5),\n                       vec3(0.5),\n                       vec3(0.1+fract(id*3.)/3.),\n                       vec3(0.,0.3,0.7));\n\n    vec3 col = vec3(shad);\n    col += g1 * vec3(0.5,0.2,0.1)*0.2;\n    col += g2 *pal*0.03;\n    col += g3 * vec3(0.1,0.5,0.5)*0.06;\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsS3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 247, 272, 272, 338], [341, 341, 361, 361, 405], [408, 408, 439, 439, 563], [566, 566, 598, 598, 647], [650, 650, 706, 706, 737], [740, 740, 781, 781, 874], [877, 877, 928, 928, 1034], [1037, 1037, 1067, 1067, 1087], [1090, 1090, 1118, 1118, 1202], [1205, 1205, 1233, 1233, 1270], [1273, 1273, 1311, 1311, 1350], [1368, 1368, 1390, 1390, 1478], [1481, 1481, 1503, 1503, 1885], [1888, 1888, 1910, 1910, 2154], [2157, 2157, 2179, 2179, 2254], [2272, 2272, 2294, 2294, 2381], [2399, 2399, 2421, 2421, 2827], [2845, 2845, 2869, 2869, 2936], [2939, 2939, 2961, 2961, 3312], [3315, 3315, 3335, 3335, 3471], [3474, 3474, 3531, 3531, 4377]]}
{"id": "tsSGWd", "name": "Nederlands Flag", "author": "radioaltivo", "description": "Nederlands flag waving, my first shader!", "tags": ["flag", "nederlands"], "likes": 0, "viewed": 66, "published": "Public", "date": "1550272416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float wave = +(sin(iTime-uv.x*5.)/(20.0));\n    \n    \n    if(uv.x < .95 && uv.x > .05)\n    {\n    if(uv.y>.9 + wave)\n        fragColor = vec4(0,0,0,0);\n        \n\n        \n    else if(uv.y>.655 + wave){    \n        fragColor = vec4(.7-(wave*5.),0,0,1);\n    }\n    else if(uv.y>.345 + wave){\n        fragColor = vec4(1.-(wave*5.),1.-(wave*5.),1.-(wave*5.),1);}\n    else if(uv.y>.1 + wave)\n        fragColor=vec4(0,0,.7-(wave*5.),1);\n        }\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 551]]}
{"id": "tsSGWt", "name": "Quantum Socket", "author": "XMunkki", "description": "Visuals for a game made for/in the Quantum Wheel Game Jam 2019.\nhttps://xmunkki.itch.io/quantum-socket", "tags": ["raymarching"], "likes": 3, "viewed": 95, "published": "Public", "date": "1550247870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifndef UNITY_MODE\nvec2 mul2x2(mat2 m, vec2 p) { return m * p; }\nvec3 mul3x3(mat3 m, vec3 p) { return m * p; }\nfloat _atan(float x, float y) { return atan(x, y); }\n#endif\n\n// Uses code (MIT) from Inigo Quilez -- https://www.shadertoy.com/view/Xds3zN\n\n#define AA 2   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\n#define PI (3.1415926535897932384626433832795)\n#define PI2 (2.0 * PI)\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder_xy( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return vec2(max(-d2.x,d1.x), d1.y);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(mul2x2(m,p.xz),p.y);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n//#define ZERO (int(min(iTime,0.0))) // iOS fix\n\n//------------------------------------------------------------------\n\nfloat s2dCircle(in vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat s2dBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat s2dCapsule(vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat s2dTri(in vec2 p)\n{\n   \tvec2 slope1 = normalize(vec2(0.6, 1));\n    vec2 slope2 = vec2(slope1.x, -slope1.y);\n    float slope_ofs = 0.065;\n    \n    float d = dot(p, vec2(-1, 0));\n    d = max(d, dot(p - vec2(0, slope_ofs), slope1));\n    d = max(d, dot(p - vec2(0, -slope_ofs), slope2));\n    \n    return d;\n}\n\nfloat s2dUsbLogo(in vec2 p)\n{\n    float d = 1e10;\n    \n    // Center\n    p.y -= 0.5;\n    \n    d = opU(d, s2dCircle(p-vec2(0.11,0.0), 0.1));\n    d = opU(d, s2dBox(p-vec2(0.5,0.0), vec2(0.39, 0.02)));\n    d = opU(d, s2dTri(p-vec2(0.88,0.0)));\n\n    d = opU(d, s2dCircle(p-vec2(0.56,0.15), 0.052));\n    d = opU(d, s2dCapsule(p,vec2(0.56,0.15), vec2(0.4,0.15), 0.02));\n    d = opU(d, s2dCapsule(p,vec2(0.25,0.0), vec2(0.4,0.15), 0.02));\n    \n    d = opU(d, s2dBox(p-vec2(0.74,-0.15), vec2(0.052, 0.052)));\n    d = opU(d, s2dCapsule(p,vec2(0.74,-0.15), vec2(0.58,-0.15), 0.02));\n    d = opU(d, s2dCapsule(p,vec2(0.38,0.0), vec2(0.58,-0.15), 0.02));\n    \n    return d;\n}\n\nvec3 rot_xy(vec3 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec3(p.x * c + p.y * s, p.x * s - p.y * c, p.z);\n}\n\n\n#define usb_plug_ratio (12.0 / 4.5)\n\nvec2 sdUsbHole(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    float shell_mat = 46.0- length(pos.xy) * 10.0;\n    \n    // Shell\n    float d = sdCylinder_xy(pos-vec3(0, 0, 0.5), vec2(1.0, 0.5));\n    d = opS(d, sdCylinder_xy(pos-vec3(0, 0, -0.1), vec2(0.9, 0.2)));\n    d -= 0.03; // Roundness\n    \n    // Side supports\n    d = opU(d, sdCapsule(pos-vec3(0,0,0.7), vec3(-0.9,0,0), vec3(0.9,0,0), 0.3));\n    \n    // USB hole\n    d = opS(d, sdRoundBox(pos, vec3(0.1 * usb_plug_ratio, 0.1, 0.5), 0.05));\n    res = opU(res, vec2(d, shell_mat));\n    \n    res = opU(res, vec2(sdBox(pos-vec3(0, 0.05, 0.43), vec3(0.1 * usb_plug_ratio, 0.05, 0.3)), 333.0));\n    \n    return res;\n}\n\nvec2 sdUsbPlug(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    pos.z = -pos.z; // Flip to face the wheel\n    \n    float d = 99999.0;\n    \n    // The head\n    res = opU(res, vec2(sdBox(pos, vec3(0.1 * usb_plug_ratio, 0.1, 0.6)), 123.0));\n    res = opU(res, vec2(sdBox(pos-vec3( 0.1,0,-0.35), vec3(0.06, 0.105, 0.1)), 85.0));\n    res = opU(res, vec2(sdBox(pos-vec3(-0.1,0,-0.35), vec3(0.06, 0.105, 0.1)), 85.0));\n    // The body\n    float body_mat = 55.0 - abs(fract(pos.z/0.4)) * 3.0;\n    res = opU(res, vec2(sdRoundBox(pos-vec3(0,0,0.5), vec3(0.1 * usb_plug_ratio, 0.1, 0.5), 0.1), body_mat));\n    res = opU(res, vec2(sdCylinder_xy(pos-vec3(0,0,1.0), vec2(0.3, 0.3)) - 0.03, 56.0));\n    // The wire \"cap\"\n    res = opU(res, vec2(sdCylinder_xy(pos-vec3(0,0,1.2), vec2(0.2, 0.3)) - 0.03, 6.0));\n    // The wire\n    res = opU(res, vec2(sdCylinder_xy(pos-vec3(0,0,5.2), vec2(0.11, 5.0)), 10.0));\n    \n    //res = opU(res, vec2(d, 123.0));\n\n    //res = opU(res, sdWheel(pos));\n    \n    return res;\n}\n\nvec2 sdWheel(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    float segment_ang = PI2 / 6.0; // One segments \"pi\" angle\n    \n#ifndef UNITY_MODE\n    float rot_ang = iTime;\n#else\n    float rot_ang = _WheelPos;\n#endif\n    \n    rot_ang *= segment_ang; // Every integer step addvances one segment\n    rot_ang -= segment_ang / 2.0; // Align the angle so that every integer has a slot at the bottom\n                \n    float d = 0.0;\n    \n    \n    // Add the wheel\n    float wheel_mat = 15.0 + length(pos.xy) * 10.0;\n    float center_mat = 5486.0 + length(pos.xy) * 5.0;\n    \n    vec3 wpos = rot_xy(pos, rot_ang);\n    \n    float logo_scale = 4.0;\n    float logo = s2dUsbLogo((wpos.xy / logo_scale + vec2(0.5, 0.5))) * logo_scale;\n    if (logo <= 0.0) center_mat = 1000.0; \n    \n    d = sdCylinder_xy(wpos-vec3(0,0,1), vec2(5.2, 0.5));\n    d = opU(d, sdCylinder_xy(wpos-vec3(0,0,0.8), vec2(5.7, 0.1)));\n    //res = opU(res, vec2(d, 15.0));\n    res = opU(res, vec2(d, wheel_mat));\n    res = opU(res, vec2(sdRoundBox(wpos-vec3(0,0,0.6), vec3(1.8, 1.8, 0.1), 0.1), center_mat));\n    res = opU(res, vec2(sdRoundBox(rot_xy(wpos, PI/4.0)-vec3(0,0,0.6), vec3(1.8, 1.8, 0.1), 0.1), center_mat));\n\n    \n    // Pick the segment\n#ifndef UNITY_MODE\n    float seg_ang = _atan(pos.y, pos.x) - rot_ang;\n#else\n\tfloat seg_ang = atan2(pos.y, pos.x) - rot_ang;\n#endif\n    seg_ang += segment_ang / 2.0;\n    seg_ang -= mod(seg_ang, segment_ang);\n    seg_ang += rot_ang;\n    \n    // Insert the hole\n    vec3 hole_pos = vec3(cos(seg_ang), sin(seg_ang), 0.0) * 4.0;\n    \n    //float d = sdBox(pos - hole_pos, vec3(0.1, 0.1, 0.1));\n\n    res = opS(res, vec2(sdCylinder_xy(pos - hole_pos, vec2(1.1, 5.0)), 1.0)); // Small hole around the plug\n    res = opU(res, sdUsbHole(pos - hole_pos));\n\n    return res;\n}\n\nvec2 sdWheelExplosion(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    float expl_time = 3.0;\n    float expl = mod(iTime, expl_time);\n\n#ifndef UNITY_MODE\n    expl=0.0;\n#else\n    expl = clamp(_WheelExplosion, 0.0, expl_time);\n#endif\n    expl *= 0.333;\n    expl = expl * cos(expl * pos.x * pos.y * pos.z);\n    \n    res = opU(res, sdWheel(pos));\n    res.x += expl * 3.0;\n        \n    return res;\n}\n\nvec2 sdSurrounds(in vec3 pos)\n{\n    float rep = 5.0;\n    vec3 rep3 = vec3(rep, rep, rep);\n\n    float manh_dist = max(abs(pos.x), max(abs(pos.y), abs(pos.z)));\n    if (manh_dist < 6.5)\n        return vec2(sdSphere(pos, -5000.0), 0.0);\n    \n    pos += rep3 * 0.5;\n    \n\tvec3 pos_rep = mod(pos,rep3)-0.5*rep;\n    vec3 cell = floor(pos / rep3);\n    \n    return sdUsbHole(pos_rep);\n}\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n#ifndef UNITY_MODE\n    float usb_plug_offset = pow(abs(cos(iTime*3.0)), 5.0);\n    float usb_plug_orientation = smoothstep(0.0, 1.0, abs(cos(iTime*1.1235)));\n#else\n    float usb_plug_offset = _PlugOffset;\n    float usb_plug_orientation = _PlugOrientation;\n#endif\n\n    usb_plug_offset *= 1.5;\n    float usb_plug_ang = usb_plug_orientation * PI;\n    \n    //res = opU(res, sdWheel(pos));\n    res = opU(res, sdWheelExplosion(pos));\n    \n    res = opU(res, sdUsbPlug(rot_xy(pos-vec3(0,-4.0,-0.15-usb_plug_offset),usb_plug_ang)));\n    \n    //res = opU(res, sdSurrounds(pos));\n    //res = sdSurrounds(pos);\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n/*\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n*/    \n    \n    // raymarch primitives   \n    //vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );\n    //if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //tmin = max(tb.x,tmin);\n        //tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<130 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n//    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\ncol *= 0.1; // Make sky darker\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1, 0.1, 0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0, 0.0, 0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.30*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \t//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    \tcol = mix( col, vec3(0.2,0.2,0.3), 1.0-exp( -0.0001*t*t*t ) );\n        \n        // Logo\n        if (m == 1000.0) col = vec3(0,0,0);\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 0.0 + iTime;\n\n#ifndef UNITY_MODE\n    float expl_amount = mod(iTime, 3.0);\n\texpl_amount = 0.0;\n#else\n    float expl_amount = _WheelExplosion;\n#endif\n    \n    // Explosion effects\n    if (expl_amount >= 0.0)\n    {\n        expl_amount = clamp(expl_amount * 0.2 - 0.025, 0.0, 1.0) * 0.1;\n        fragCoord.x += cos(fract(fragCoord.y * 1234.678) * 326.0) * iResolution.x * expl_amount;\n    }\n\n    \n    // camera\t\n    vec3 ro = vec3( 2.6*cos(0.5*time + 6.0*mo.x), -3.5 + 2.0*mo.y, -6.5 + 1.6*sin(0.5*time + 6.0*mo.x) );\n    //ro.z = -abs(ro.z);\n    vec3 ta = vec3( 0, -2.5, 0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0, 0.0, 0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = mul3x3(ca, normalize( vec3(p.xy,2.0) ));\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545, 0.4545, 0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    tot *= pow(max(0.0, 1.0 - length(fragCoord/iResolution.xy - vec2(0.5, 0.5)) * 0.8), 1.44);\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 446, 471, 471, 486], [488, 488, 523, 523, 549], [551, 551, 582, 582, 673], [675, 675, 734, 734, 828], [830, 830, 885, 885, 980], [982, 982, 1015, 1015, 1070], [1072, 1072, 1108, 1108, 1419], [1421, 1421, 1473, 1473, 1587], [1589, 1589, 1653, 1653, 1931], [1933, 1933, 1957, 1957, 1974], [1975, 1975, 2038, 2102, 2689], [2691, 2691, 2734, 2734, 2985], [2987, 2987, 3023, 3023, 3206], [3208, 3220, 3256, 3256, 3359], [3361, 3361, 3400, 3400, 3503], [3505, 3530, 3581, 3581, 3936], [3938, 3938, 3976, 3976, 4145], [4147, 4147, 4172, 4172, 4191], [4192, 4192, 4263, 4263, 4601], [5114, 5114, 5139, 5139, 5176], [5178, 5178, 5203, 5203, 5261], [5263, 5263, 5288, 5288, 5353], [5355, 5355, 5390, 5390, 5461], [5463, 5463, 5498, 5498, 5569], [5571, 5571, 5608, 5608, 5661], [5663, 5733, 5766, 5766, 5792], [5794, 5794, 5822, 5822, 5864], [5866, 5866, 5897, 5897, 5923], [5925, 5925, 5955, 5955, 5988], [5990, 5990, 6020, 6020, 6049], [6051, 6051, 6075, 6075, 6215], [6365, 6435, 6472, 6472, 6500], [6502, 6502, 6538, 6538, 6620], [6622, 6622, 6674, 6674, 6801], [6803, 6803, 6828, 6828, 7113], [7115, 7115, 7144, 7144, 7778], [7780, 7780, 7812, 7812, 7922], [7962, 7962, 7991, 7991, 8640], [8642, 8642, 8671, 8671, 9646], [9648, 9648, 9675, 9675, 11431], [11433, 11433, 11469, 11469, 11836], [11838, 11838, 11869, 11869, 12216], [12218, 12218, 12241, 12241, 12898], [12900, 12968, 13019, 13019, 13224], [13253, 13253, 13293, 13293, 14088], [14091, 14153, 14231, 14328, 14597], [14599, 14663, 14695, 14695, 15226], [15228, 15228, 15270, 15270, 15586], [15588, 15664, 15700, 15721, 15944], [15946, 15946, 15985, 15985, 17898], [17900, 17900, 17952, 17952, 18129], [18131, 18131, 18188, 18188, 19673]]}
{"id": "tssSDN", "name": "Hopping Boxes", "author": "kaneta", "description": "boxes", "tags": ["3d", "box"], "likes": 21, "viewed": 588, "published": "Public API", "date": "1551331495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// distance function by iq\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n#define PI 3.141592\n\nvec2 map(vec3 p)\n{\n    float c = 0.05;\n    vec2 id = floor(p.xz / c);\n\n    vec2 b = vec2(9999., 0.0);\n    vec3 pp = p;\n    float t = iTime;\n    pp.xz = mod(pp.xz, c) - 0.5*c;\n \tfloat v = sin(t) * 0.5 + 0.5;\n   \tvec3 bp = vec3(sin(t) * 3.0, v * 5.0, cos(t) * 3.0);\n    for (int i = 0; i < 5; i++) {\n        float y = float(i) * c * 2.0;\n    \tvec3 cp = vec3(id.x, -y, id.y);\n    \tfloat s = clamp(pow(5.0 / distance(bp, cp), -6.0), 0.0, 1.0);\n        float by = (1.0 - s) * -0.4;\n        b = opU(b, vec2(sdBox(pp + vec3(0.0, by + y, 0.0), vec3(c * s * smoothstep(-0.4, -0.3,  by) * 0.5)), 1.0));\n    }\n    return b;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 ret = vec3(0.0);\n    vec3 nor = normal(p, 0.0001);\n    if (depth > 2000.0) {\n    \tret = vec3(0.0);\n    } else if (mat.y == 1.0) {\n    \tvec2 id = floor(p.xz / 0.05);\n        if (id.x == 3.0 && id.y == 0.0 && p.y >= 0.0) {\n            ret = vec3(nor.y, 0.0, 0.0) + nor.z * 0.3;\n        } else {\n            ret = vec3(nor.y) + nor.z * 0.3;\n        }\n    }\n    return ret;\n}\n\nvec3 trace(vec3 ro, vec3 ray)\n{\n    float t = 1.3;\n    vec3 col = vec3(0.0);\n    vec3 p;\n    vec2 m;\n    vec3 rdi = 1.0 / ray;\n    for(int i = 0; i < 60; i++) {\n    \tp = ray * t + ro;\n        m = map(p);\n        if (m.x < 0.001) {\n            break;\n        }\n        // grid traverse technique\n        // https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        t += min(min((step(0.0,ray.x)-mod(p.x, 0.05)) * rdi.x, (step(0.0,ray.z)-mod(p.z, 0.05))*rdi.z)+0.001,m.x);\n    }\n    return materialize(p, ray, t, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(1.0, 1.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ray = camera(ro, ta, 0.0) * normalize(vec3(p, 7.5));\n    \n    vec3 col = trace(ro, ray);\n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 102, 133, 133, 229], [231, 231, 259, 259, 288], [290, 290, 318, 318, 351], [374, 374, 392, 392, 988], [990, 990, 1032, 1032, 1210], [1212, 1212, 1251, 1251, 1453], [1455, 1455, 1514, 1514, 1895], [1897, 1897, 1928, 1928, 2418], [2420, 2420, 2477, 2477, 2895]]}
{"id": "tssXRr", "name": "City of lightsadg", "author": "theepicsnail", "description": "lights1adg", "tags": ["lights"], "likes": 0, "viewed": 58, "published": "Public", "date": "1550522706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cs(float f) {\n    return vec2(cos(f), sin(f));\n}\n\nfloat noise(float f) {\n    return fract(sin(f*1430.856+1355.2)*9898.11);\n}\nvec3 noise3(float f){ \n    return vec3(noise(f), noise(f*1.2+43.), noise(f*1.3+12.));\n}\n\nvec3 getColor(float i, float t) {\n    vec3 c1 = noise3(floor(t) + i);\n    vec3 c2 = noise3(floor(t) + i + 1.);\n    return mix(c1, c2, fract(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 texCoord = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 r = cs(iTime*.1);\n    \n    float falloff =1.-length(texCoord)*.25;\n\ttexCoord.x += iTime*.1;\n\t\n\tvec3 result = vec3(0,0,0);\n\tfloat sum = 0.;\n\n    vec3 color;\n\tfor(int i = 0 ; i < 6 ; i++) {\n        float r;\n\t\ttexCoord = fract(texCoord)*2.-1.;\n        \n\t\tr = 3.1415/4.;\n\t\tfloat c = cos(r);\n\t\tfloat s = sin(r);\n\t\ttexCoord *= mat2(vec2(c,-s),vec2(s,c));\n    \t//texCoord *= mat2x2(r.x, -r.y, r.y, r.x);\n\t\tcolor = getColor(float(i), iTime);\n\n\t\tfloat d = length(texCoord);\n\t\t r = 1.0 *noise(float(i));\n\t\tif(d<r){\n\t\t\td/=r;\n\t\t\tfloat v = 1.-d;\n\t\t\tv = pow(v, 2.) * falloff;\n\t\t\t//sum += v*3;\n\t\t\t//result = lerp(color, result, v/sum);\n\t\t\tresult += color*v;\n\t\t\tsum += v;\n\t\t}\n\n        //texCoord += iTime*.11;\n\t\t\n\t}\n\tcolor = result * sum;\n\tfragColor.rgb = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 53], [55, 55, 77, 77, 129], [130, 130, 151, 151, 217], [219, 219, 252, 252, 365], [367, 367, 424, 474, 1297]]}
{"id": "tssXz8", "name": "Sine wave line", "author": "noriben", "description": "Sine wave line\nreference: https://www.shadertoy.com/view/wsf3zS", "tags": ["wave"], "likes": 0, "viewed": 482, "published": "Public API", "date": "1550653673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float amp = 0.1; //振幅\n    float freq = 6.0; //周波数\n    float thickness = 0.05 / 2.0; //線の太さ\n    float smoothing = 4.0 / iResolution.x; //画面解像度に応じたアンチエイリアス\n    \n    //サインカーブをtimeでmix\n    //float y = mix(amp * sin(uv.x * freq + iTime), amp * cos(uv.x * freq * 2. + iTime),  sin(iTime));\n    float wave = uv.x * freq + iTime;\n    //wave01\n    float y = amp * (wave - floor(wave)) + amp * acos(cos(2.0 * wave)) + amp  - 0.3;\n    //wave02\n    float s = amp * sin(wave);\n    //mix\n    y = mix(y,s, sin(iTime));\n    \n    vec3 linecolor = vec3(uv.x * sin(iTime), uv.y * sin(iTime), 0.9);\n    vec3 coltop = vec3(smoothstep(0.0, smoothing, uv.y - y - 0.5 + thickness)) * linecolor;\n    vec3 colbottom = vec3(1. - smoothstep(0.0, smoothing, uv.y - y - 0.5 - thickness));\n    vec3 col = coltop * colbottom;\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 1002]]}
{"id": "tssXzn", "name": "banded mandelfog", "author": "pde", "description": "An odd-event banded version of the ray-marched Julia fog; this view is oriented around one of the Mandelbrot cross-sections of the Julia set, use the mouse to explore!\n\nNow accelerated with dynamic ray jump sizes and early stopping in the inky blackness.", "tags": ["raymarching", "juliaset"], "likes": 1, "viewed": 163, "published": "Public", "date": "1550515499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmult(vec2 a, vec2 b)\n{\n\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 spacify(vec2 p)\n{\n    return ( p - .5 * iResolution.xy ) / iResolution.y;\n}\n\nconst int counts = 17;\nconst float fcount = float(counts);\n\nint julia(in vec2 z0, in vec2 c)\n{\n    vec2 z = z0;\n    if (length(z) > 4.0)\n        return 0;\n    for (int n=0; n <counts; n++) {\n        z = cmult(z,z) +c;\n\n        if (length(z) > 4.0) return n;\n    }\n    return -1;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\n\nconst float ideal_frame_duration = 1.0/60.0;\n\nvoid raymarchJulia(in vec3 camera, in vec3 ray, out vec4 col)\n{\n    col =vec4(0.0);\n    float core = 0.0;\n    float steps = 50.0;\n    float time = iTime + 28.19;\n    float z2 = sin(time/7.0);\n    float corr =cos(time/3.1415);\n    vec3 pos=camera; int inc=0; float jumpsize,j0;\n    int n=0;\n    for (float dist=0.0; dist < 5.0; ) {\n        // there are lots of weird artefacts that result from jumpsize selection choices,\n        // but this one seems to work fairly well.\n        j0 = (fcount - float(inc))/fcount;\n        if (inc == -1) j0 = 1.0/fcount;\n        jumpsize = j0 * 0.04;\n        \n        pos += jumpsize*ray;\n        dist +=jumpsize;\n        inc = julia(vec2(pos.z,z2),vec2(pos.x+corr, pos.y));\n       \n        if (inc < 0) {\n            // collisions with the core of the julia set\n            core += 2.0;\n        \tif (core > 30.0)\n                break;\n        }else {\n            // collisions with the halo\n            col.x += float(inc)*jumpsize*50.0;\n            if (inc % 2 == 0) {\n                col.y += float(inc)*jumpsize*50.0;\n                col.z += float(inc)*jumpsize*50.0;\n            }\n\n        }\n        n += 1;\n        if (n == 3000) break;\n    }\n    float scale = 10.24 * steps;\n    float pen = core / 10.0;\n    col /= scale;\n    col.z -= pen;\n    col.x = col.x * 1.0 - pen/5.0;\n    col.z = col.z * 2.0 - pen;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // start at 0,0,z=3, shoot a ray at the plane z=1\n    //vec3 camera = vec3(0.2*sin(iTime/2.3),0.2*cos(iTime/18.8),4.0);\n    vec3 camera = vec3(0,0,4.0);\n    vec2 xy = spacify(fragCoord);\n    vec3 coord = vec3(xy.x, xy.y, 3.0);\n    vec3 ray = coord - camera;\n    float radius =  length(xy);\n    vec2 mouse = iMouse.xy;\n    clamp(mouse.x, 0.0, iResolution.x);\n    clamp(mouse.y, 0.0, iResolution.y);\n    \n    vec2 mouse_xy=spacify(mouse);\n    vec2 offset=spacify(vec2(iResolution.x*0.74,iResolution.y*0.25));\n    mat3 rot = rotationMatrix(vec3(2.0*mouse_xy.y, mouse_xy.x, 0.0),2.0*length(mouse_xy));\n    \n    camera = camera*rot;\n    ray = ray*rot;\n    raymarchJulia(camera, ray, fragColor);\n\n}\n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 64], [66, 66, 88, 88, 146], [208, 208, 242, 242, 428], [431, 431, 476, 476, 959], [1008, 1008, 1071, 1071, 2358], [2360, 2360, 2415, 2539, 3112]]}
{"id": "tssXzr", "name": "[twitch] Scary Hairy", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow, or put CURLYHAIR to 0\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ScaryHairy.glsl", "tags": ["3d", "raymarching", "hair", "live", "twitch"], "likes": 18, "viewed": 364, "published": "Public", "date": "1550529389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow, or put CURLYHAIR to 0\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ScaryHairy.glsl\n*/\n\n#define MARCH_STEPS 100\n#define CURLYHAIR 1\n\n#define time iTime\n\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 rotrep(vec3 p, float rep, float off) {\n  vec2 rp=vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x = (fract(rp.x*rep-0.5+off)-0.5)/rep;\n  return vec3(cos(rp.x*2.0*PI)*rp.y,p.y,sin(rp.x*2.0*PI)*rp.y);\n}\n\nfloat rotid(vec3 p, float rep, float off) {\n  vec2 rp=vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  return floor(rp.x*rep-0.5+off);\n}\n\nvec3 tmin(vec3 a, vec3 b) {\n  return a.x<b.x?a:b;\n}\n\nvec3 curly(vec3 p, float hole, float freq, float offset) {\n\n  \n  vec3 rp = rotrep(p, freq, offset);\n  float off = fract(sin(rotid(p, 30.0, 0.0)*780.4)*7842.25)*12.0;\n  \n  rp.xz *= rot(sin(rp.y*10.0+off)*0.01);\n\n  vec3 dp = p;\n  dp.y = max(-dp.y, 0.0);\n  float dec = 1.0-length(normalize(dp).xz);\n  float wid = 1.1 + sin(p.y*5.0+off*42.57)*0.3;\n    \n  vec3 cyl = vec3(length(rp.xz-vec2((1.0-dec)*1.49,0.0))-0.1*wid,atan(rp.z,rp.x)*1.0,rp.y);\n  cyl.x = smin(cyl.x, -1.85-p.y, -0.8);\n  cyl.x = smin(cyl.x, -5.9+p.y, -4.8);\n  cyl.x = smin(cyl.x, -hole,-.7);\n\n  return cyl;\n\n}\n\nvec3 hairbase(vec3 p, float r) {\n  vec3 lp = p;\n  lp.y = max(0.0,-lp.y);\n\n  \n  float edge = atan(p.z,p.x)/(2.0*PI);\n/*\n  p.x += sin(edge*3)*.1;\n  //p.x -= sin(p.y*6.8)*.1;\n  p.y += sin(p.x*30)*.01;\n  p.y += sin(p.z*13)*.03;\n*/\n  float sp = length(lp)-r;\n  float d = abs(sp)-0.05;\n  \n  \n  vec3 ph = p;\n  ph.y = max(0.0,0.8-ph.y);\n  float hole = (length(ph.xy)-0.5);\n  hole = max(hole, p.z);\n  \n  d = smin(d,-1.9+p.y + (sin(edge*50.0)+sin(edge*108.0)*0.5+sin(edge*138.0)*0.45)*0.3, -.3);\n\n  d = smin(d,-hole,-.9);\n\n  vec3 res = vec3(d, atan(p.z,p.x), p.y/r);\n#if CURLYHAIR\n  res = tmin(res, curly(p, hole, 15.0, 0.0));\n  res = tmin(res, curly(p, hole, 35.0, 0.5));\n  res = tmin(res, curly(p, hole, 13.0, 0.27));\n#endif  \n  return res;\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nvec3 body(vec3 p) {\n\n  vec3 cp2 = p;\n  cp2.y += sin(cp2.x*PI*5.0)*0.1;\n  cp2.x -= clamp(cp2.x,-0.3,0.3);  \n  \n  vec3 cp3 = p-vec3(-0.0,0.4,-1.5);\n  cp3.y -= clamp(cp3.y,-0.1,0.1);  \n  //cp3.yz *= rot(-0.2);\n  \n  p.x = smin(p.x, -p.x, 0.3);\n  \n  float b1 = sph(p,1.5);\n  b1 = smin(b1, sph(p-vec3(0,1,-0.3),1.2), 0.5);\n  b1 = smin(b1, -sph(p-vec3(-0.6,0.3,-1.8),0.4), -0.4);\n  b1 = smin(b1, sph(p-vec3(-0.45,0.3,-1.2),0.15), 0.05);\n\n  b1 = smin(b1, sph(p-vec3(-0.1,0.7,-1.6),0.1), 0.15);\n  b1 = smin(b1, sph(cp3,0.1), 0.2);\n  \n  b1 = smin(b1, -sph(cp2-vec3(0.0,1.3,-1.3),0.1), -0.2);\n\n  vec3 cp = p;\n  cp.y -= clamp(cp.y-2.0,0.0,1.0);\n  b1 = smin(b1, sph(cp-vec3(0,2,0.1),0.7), 0.2);\n  return vec3( b1, 0, 0);\n}\n\nfloat mat = 0.0;\nvec3 map(vec3 p) {\n  vec3 h = hairbase(p, 1.5);\n  vec3 b = body(p);\n  mat=(b.x<h.x)?1.0:0.0;\n  return tmin(h, b);\n}\n\nfloat mapx(vec3 p) {\n  return map(p).x;\n}\n\nfloat mapz(vec3 p) {\n  return map(p).z;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(mapx(p)-vec3(mapx(p-off.xyy), mapx(p-off.yxy), mapx(p-off.yyx)));\n}\n\nvec3 tangent(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(mapz(p)-vec3(mapz(p-off.xyy), mapz(p-off.yxy), mapz(p-off.yyx)));\n}\n\nfloat noise(vec2 uv) {\n  vec2 iuv=floor(uv);\n  vec2 fuv=fract(uv);\n  fuv=smoothstep(0.0,1.0,fuv);\n  vec2 st=vec2(7,877);\n  vec2 m = dot(iuv,st)+vec2(0,st.y);\n  vec2 val = mix(fract(sin(m)*7584.522), fract(sin(m+st.x)*7584.522), fuv.x);\n  return mix(val.x,val.y, fuv.y);\n}\n\nfloat fractal(vec2 uv) {\n  float d=0.0;\n  for(int i=0; i<5; ++i) {\n    float s=pow(2.0,float(i));\n    d+=noise(uv*s)/s;\n  } \n  return d*0.5;\n}\n\nvoid cam(inout vec3 p) {\n  float t1=time*0.3;\n  p.xz *= rot(t1);\n  p.xy *= rot(sin(t1*1.3)*0.5);\n  //p.yz *= rot(0.9);\n  //p.xz *= rot(sin(time)*0.9);\n}\n\nfloat hair(vec3 tang, vec3 h, float power) {\n  float cosang = dot(tang, h);\n  float sinang = sqrt(1.0-cosang*cosang);\n  float spechair = pow(sinang, power);\n  return spechair;\n}\n\nvec3 light(vec3 l, vec3 p, vec3 r, vec3 n, vec2 tex, vec3 tang, float curmat) {\n  float rand = fractal(tex*vec2(150,3));\n  vec3 h = normalize(l-r);\n\n  vec3 col = vec3(0);\n\n  vec3 haircol = vec3(1,0.5,0.1);\n\n  vec3 diff = haircol * 0.3;\n\n  float aodist=0.2;\n  float ao = clamp(mapx(p+n*aodist)/aodist,0.0,1.0);\n  //ao = pow(ao, 3);\n\n  if(curmat<0.5) {\n    float spechair1 = hair(normalize(tang + n * (rand-0.3) * 1.0), h, 100.0);\n    float spechair2 = hair(normalize(tang + n * (rand-0.7) * 1.0), h, 10.0);\n    col = max(0.0, dot(n,l)*0.7+0.3) * (diff + spechair1 + spechair2 * haircol) * ao;\n  } else {\n  \n    vec3 eyep = p;\n    eyep.x=-abs(eyep.x);\n    float disteye = sph(eyep-vec3(-0.45,0.3,-1.2),0.15);\n    float eye = step(disteye, 0.03);\n\n    float spec = pow(max(0.0,dot(n,h)),6.0);\n    float spec2 = pow(max(0.0,dot(n,h)),50.0);\n\n    \n    if(eye>.0) {\n      col = vec3(1)*max(0.0, dot(n,l)*0.7+0.3) * step(0.007,disteye);\n    } else {\n      float fade = clamp((-p.y+2.7)*1.0,0.0,1.0);\n      col = max(0.0, dot(n,l)*0.7+0.3) * (vec3(1.0,0.7,0.5) * (1.0 + spec) + 0.2*spec2) * ao * fade;\n    }\n    \n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(0.0,0.7,-5);\n  vec3 r = normalize(vec3(-uv, 0.8+sin(time*0.7)*0.2));\n\n  cam(s);\n  cam(r);\n\n  vec3 p=s;\n  float dd=0.0;\n  \n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=mapx(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d*0.7;\n    dd+=d*0.7;\n  }\n  float curmat = mat;\n\n  vec3 n = norm(p);\n  vec3 tang = tangent(p);\n  vec3 bin = normalize(cross(n,tang));\n  tang = normalize(cross(n,bin));\n\n\n  vec2 tex = map(p).yz;\n\n  float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n\n  vec3 col = vec3(0);\n\n  vec3 l = normalize(vec3(-1));\n  vec3 l2 = normalize(vec3(1.3,-0.7,0.5));\n  vec3 l3 = normalize(vec3(0.7,-0.7,0.5));\n  \n  col += light(l, p, r, n, tex, tang, curmat) * fog;\n  col += light(l2, p, r, n, tex, tang, curmat) * fog * vec3(0.7,0.5,0.8);\n  //col += light(l3, p, r, n, tex, tang, curmat) * fog * vec3(0.3,0.7,0.5);\n  \n  \n  //col = vec3(fractal(uv*10));\n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 342, 361, 361, 430], [432, 432, 471, 471, 549], [551, 551, 594, 594, 758], [760, 760, 803, 803, 893], [895, 895, 922, 922, 946], [948, 948, 1006, 1006, 1519], [1521, 1521, 1553, 1553, 2255], [2257, 2257, 2285, 2285, 2309], [2311, 2311, 2330, 2330, 3020], [3039, 3039, 3057, 3057, 3154], [3156, 3156, 3176, 3176, 3197], [3199, 3199, 3219, 3219, 3240], [3242, 3242, 3261, 3261, 3373], [3375, 3375, 3397, 3397, 3509], [3511, 3511, 3533, 3533, 3782], [3784, 3784, 3808, 3808, 3926], [3928, 3928, 3952, 3952, 4080], [4082, 4082, 4126, 4126, 4259], [4261, 4261, 4340, 4340, 5385], [5387, 5387, 5444, 5444, 6533]]}
{"id": "tsXSz4", "name": "RayTracing Tutorial - Step 6", "author": "BrunoLevy", "description": "One ray bounce", "tags": ["raytracing", "tutorial"], "likes": 2, "viewed": 433, "published": "Public API", "date": "1550694964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-6;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n    vec3 Kr; // reflective material\n};\n\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\n\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, zero3, zero3);\n}\n\nMaterial light(in vec3 Ke) {\n   return Material(zero3, Ke, zero3);\n}\n\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(Kd, zero3, Kr);\n}\n\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\nObject scene[4];\n\nvoid init_scene() {\n   float beta = float(iFrame)/30.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      mirror(vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8))\n      // diffuse(vec3(1.0, 1.0, 1.0))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n      diffuse(vec3(1.0, 0.0, 0.0))\n   );\n\n   scene[2] = Object(\n      Sphere(vec3(5.0, 0.0, 3.0),0.02),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n\n   scene[3] = Object(\n      Sphere(vec3(0.0, 0.0, -10000.0),9999.5),\n      diffuse(vec3(1.0, 1.0, 1.0)) \n//      mirror(vec3(0.2, 0.2, 0.2), vec3(1.0, 1.0, 1.0))\n   );\n \n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n \nRay reflect_vector(in Ray I, in vec3 P, in vec3 N) {\n   return Ray(\n      P,\n      -2.0*dot(N,I.Dir)*N + I.Dir\n   );\n}\n\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n           float lamb = max(0.0, dot(E,N) / length(E));\n           result += lamb * material.Kd * scene[i].material.Ke;\n         }\n      }\n   }\n\n   return result;\n}\n\nbool nearest_intersection(\n   in Ray R, \n   out vec3 P, out vec3 N, out Material material\n) {\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON && cur_t > 0.0\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n   return (t != FARAWAY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n\n \n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n \n   if(nearest_intersection(R, P, N, material)) {\n      fragColor.rgb = lighting(P,N,material);\n      if(material.Kr != zero3) {\n         vec3 Kr = material.Kr;\n         R = reflect_vector(R, P, N);   \n         if(nearest_intersection(R, P, N, material)) {\n             fragColor.rgb = \n                 Kr*lighting(P,N,material);\n         } else {\n             fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n         }\n\n      }\n   } \n  \n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 281, 281, 579], [581, 581, 618, 618, 715], [925, 925, 955, 955, 995], [997, 997, 1025, 1025, 1065], [1067, 1067, 1108, 1108, 1145], [1225, 1225, 1244, 1244, 1876], [1878, 1878, 1937, 1937, 2203], [2206, 2206, 2258, 2258, 2324], [2326, 2326, 2349, 2349, 2633], [2635, 2635, 2694, 2694, 3198], [3200, 3200, 3293, 3293, 3736], [3738, 3738, 3795, 3795, 4519]]}
{"id": "tsXSzn", "name": "Soul  - Distance Fields ", "author": "synergyseeker1", "description": "Exploring distance fields and cheap light effect, color mixing", "tags": ["shader", "distance", "lights", "fields", "shaping", "artofshadersartofshaders3d"], "likes": 8, "viewed": 451, "published": "Public API", "date": "1550436731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// color circle part 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n\t// normailze and adjsut for ratio\n    vec2 res = iResolution.xy,\n    uv = (fragCoord*2.0-res ) / res.y;\n    \n    //initilize colors\n\tvec4 background = vec4(.2,.7,.7,1.0)*-uv.y*.3*cos(uv.x); \n    vec4 color = vec4(1.0,.7,.2,1.0);\n    \n\t// calculate fragment distance from center\n    float d = length(uv*4.0); \n    uv+=uv/d*cos(d-iTime);\n    float shape = .2/length(fract(uv*1.5)-.5);\n    color*=shape*uv.y;\n    \n    \n    \n    //output final color\n\tfragColor = mix(background, color, color.a);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 80, 118, 578]]}
{"id": "tsXXR8", "name": "Figure 8", "author": "bozfloat", "description": "Learning the algorithm for a figure 8", "tags": ["particles", "figure8"], "likes": 1, "viewed": 288, "published": "Public API", "date": "1550558666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GLOW 0.7\n#define NUM_PARTICLES 100.0\n\n#define figureEightRadius -0.4 //Sign of value changes direction\n\nvec3 particles(vec2 uv, vec3 color, float radius, float offset)\n{        \n    float amplitude = sin(iTime/6.0);\n    //float amplitude = atan(iTime/6.0); //Continuous forward motion\n    \n    float x=sin((iTime*amplitude/offset)) * figureEightRadius*2.5*offset+ 0.9;\n    float y=sin((iTime*amplitude*2.0/offset)) * figureEightRadius*1.1*offset+ 0.5;\n\n    vec2 position = vec2(x,y);\n    \n    float dist = radius / distance(uv, position);\n    return color * pow(dist, 0.95 / GLOW);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius= 0.006* (sin(iTime*.33)+2.1);\n    \n    // center pixel\n    vec2 uv = (fragCoord.xy /iResolution.y);\n    \n    // Time varying pixel color\n    vec3 color ;\n    color.r = ((sin(((iTime)) * 0.15) + 0.05) * 0.4);\n    color.g = ((sin(((iTime)) * 0.002)) * 0.2);\n    color.b = ((sin(((iTime)) * 2.0) + 0.05) * 0.3);\n\t\n    vec3 pixel ;\n        \n    for\t(float i = 0.0; i < NUM_PARTICLES; i++)\n        pixel += abs(particles(uv, color, radius, i / NUM_PARTICLES));\n    \n    fragColor = mix(vec4(uv,sin(iTime),1.0), vec4(pixel, 1.0), 0.8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 177, 177, 591], [593, 593, 650, 650, 1199]]}
{"id": "tsXXRM", "name": "distance to sinusoid", "author": "FabriceNeyret2", "description": "Way more involve that I though !\n\n( note that the approach is a bit more general than sinusoids, provided you can bound a x range containing only one extrema ).", "tags": ["2d", "sdf", "distance", "curve", "spring", "bisection", "solving", "mz"], "likes": 19, "viewed": 651, "published": "Public API", "date": "1550849249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === find the distance to a sinusoid (or more general function)\n//     in the purpose of tracing thick antialiased curve.\n//\n// principle: searche the zero of the derivative df() of distance(curPos,vec2(x,f(x)))\n// within a range known to contain only one.\n// (slight precision issue when facing min/max for now).\n\n// NB: managing ends adds a bit to the difficulty :-) Buggy for now\n\nfloat L = 1.6,                   // sprint length \n      n = 10.,                   // number of spires\n      r = .3,                    // spring radius\n      w = .03;                   // wire radius \n#define N 10                     // number of iterations\n#define PI 3.14159\n\n#define ofs 0. // (.1*iTime)\n#define f(x)  ( r * sin(k*(x-ofs)) ) // spring equation\n                                 // derivative of distance² / cst\n#define df(x) ( x0-(x) + r*k*cos(k*(x-ofs))* ( y0 -r*sin(k*(x-ofs)) ) )\n\n//#define f(x)  ( r * cos(k*(x)) ) // spring variant (set h=0.).\n//#define df(x) ( x0-(x) - r*k*sin(k*(x))* ( y0 -r*cos(k*(x)) ) )\n\n#define d(x)  length( vec2(x0,y0) - vec2( x, f(x) ) ) // distance\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;  // convert to normalized units\n       //w *= 2./R.y;   \n    L *= 1.+.5*sin(iTime);\n    \n    O-=O;\n    \n  //U = U.yx;                     // uncomment for vertical spring\n  //if (abs(U.x)>L/2.+w+3./R.y) return;  // optim\n\n    float x0 = U.x, y0 = U.y, x=x0,\n           k = 2.*PI*n/L, d;\n    \n#if 1 // zero-solving using bisection method\n    x = clamp( x0, -L/2., L/2.);\n    float  h = .5, // set to 0 for f(x) = cos()\n          xm = ( floor((x-ofs)*k/PI +h) -h ) *PI/k +ofs, // monotonous sin() branch\n          xM = (  ceil((x-ofs)*k/PI +h) -h ) *PI/k +ofs; // = range with only one dist extrema\n    // ends and beyond requires special care\n    xm = max(xm,-L/2.);                  \n    xM = min(xM, L/2.); \n    float ym = df(xm), yM = df(xM), y;   // v sign: hack to avoid the extra extrema\n    if ( xm ==-L/2. && ym < 0. ) xm=xM, ym= 1., xM+=PI/k, yM=df(xM);\n    if ( xM == L/2. && yM > 0. ) xM=xm, yM=-1., xm-=PI/k, ym=df(xm);\n    // special case when x is exactly above an extrema\n  //if ( yM > 0. ) xM -= .01*PI/k, yM = 1.;  // should be df\n    if ( ym < 0. ) xm -= .01*PI/k, ym = 1.;  //-> 1st useless, 2nd = any positive\n    // bisection to find distance extrema (i.e. zero of derivative df() )\n    for (int i=0; i<N; i++) {          \n        x = (xm+xM)/2.; y = df(x);\n        if ( sign(y)==sign(ym)) xm = x, ym = y;\n            else                xM = x, yM = y;\n       }\n    \n#else // zero-solving using Newton: not working (df() too nasty)\n    \n    x = x0;\n    for (int i=0; i<N; i++) {\n        x = df(x)+x;\n        if (k*abs(x-x0)>6.28) x = mod(x-x0,6.28/k)+x0;\n    }\n#endif\n    \n  //x = clamp( x, -L/2., L/2.);                 // limit spring to ends\n    d = d(x);                                   // dist to sine\n    d = min( d, d( L/2.) );                     // dist to ends\n    d = min( d, d(-L/2.) );\n    d -= w;                                     // thickness\n    \n    O = vec4( smoothstep(3./R.y,0., d) );       // draw spring\n    O.r += smoothstep(90./R.y,0.,1.-sin(100.*d)); // red: distance field\n\n#if 0                                           // debug\n    if( abs(y0-f(x0)) < 1./R.y) O = vec4(1,0,0,0);\n    O.g += .01 / d(xm);\n    O.b += .01 / d(xM);\n    O.gb += float( abs(abs(x0) - L/2.) < 2./R.y );\n#endif\n\n    O = sqrt(O);                                // to sRGB (cheap version)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[891, 1090, 1128, 1128, 3507]]}
{"id": "tsXXz7", "name": "hw3 566 2", "author": "24602848yan", "description": "hw3 566 last one crash...\nthis one also dangerous...\ni think i need to learn more in efficiently rendeirng things.", "tags": ["sdf"], "likes": 4, "viewed": 238, "published": "Public", "date": "1550871592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 256\n#define FAR 10.0\n#define PI 3.14159265359\n#define EPS 0.0001\n#define MoveSpeedT (iTime * 0.1)\n#define iGT (iTime + 1.0)\n\n//pow is to increase the contrast of the color\nvec3 skyCol = pow(vec3(163., 175., 223.) / 255., vec3(2.0));\nvec3 sunCol = 2. * pow(vec3(207., 255., 255.) / 255., vec3(2.));\n\nvec4 lights[3];\nvec3 lightColor1 = vec3(231., 231., 238.) / 255.;\nvec3 lightColor2 = vec3(55, 56, 83) / 255.;\nvec3 lightColor3 = vec3(93, 72, 123) / 255.;\n\n//remap\nvec3 Colora = vec3(128., 128., 128.) / 255.;\nvec3 Colorb = vec3(128., 128., 128.) / 255.;\nvec3 Colorc = vec3(510., 255., 0.) / 255.;\nvec3 Colord = vec3(128., 51., 64.) / 255.;\n\n//this perlin noise comes from https://www.shadertoy.com/view/MlfXWH\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    // Quintic\n    vec2 df = 30.f * f * f * (f * (f - 2.0) + 1.0);\n    f = f * f * f * (f * (f * 6.-15.) + 10.);  \n    float a = texture(iChannel0, (i+vec2(0.5, 0.5))/256., -100.0).r;\n    float b = texture(iChannel0, (i+vec2(1.5, 0.5))/256., -100.0).r;\n    float c = texture(iChannel0, (i+vec2(0.5, 1.5))/256., -100.0).r;\n    float d = texture(iChannel0, (i+vec2(1.5, 1.5))/256., -100.0).r;    \n    float k = a-b-c+d;\n    float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);   \n    return vec3(n, vec2(b-a+k*f.y, c-a+k*f.x)*df);\n}\n//2d space rotation\nmat2 m = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbmSimple(vec2 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 2; i++){ \n        f += amp * noise(p).x;\n        p = 2.0 * m * p;\n        amp = amp * 0.5;\n    }\n    return f;\n}\nfloat fbmL(vec2 p) {\n    float f = 0.0, w = 0.5;\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 6; ++i) {\n        vec3 n = noise(p);\n        f += abs(w * 1.8 * n.x);\n        w *= 0.5; \n        p = 2.* m * p;\n    }\n    return f;\n}\nfloat fbmM(vec2 p) {\n    float f = 0.0, w = 0.5;\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < 6; ++i) {\n        vec3 n = noise(p);\n        f += abs(w * n.x);\n        w *= 0.5; \n        p = 1.6 * rot * p;\n    }\n    return f;\n}\n//sdf things\nvec2 sdfmoutain(vec3 p) {\n\treturn vec2(p.y + 0.9 - fbmM(p.xz), 2.0);\n}\n//from iq http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdCappedCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  float ss = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return vec2(ss, 3.0);\n}\n\nvec2 sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2( length(p.xz)- 2.0 * ra+rb, abs(p.y) - h );\n    float ss = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n    return vec2(ss, 4.0);\n}\n\nvec2 sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0 * p.x < m ) q = p.xyz;\n    else if( 3.0 * p.y < m ) q = p.yzx;\n    else if( 3.0 * p.z < m ) q = p.zxy;\n    else return vec2(m * 0.57735027, 5.0);    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    float dis = length(vec3(q.x,q.y-s+k,q.z-k));\n    return vec2(dis, 5.0); \n}\n\nvec2 sdRoundCone(vec3 p, float r1, float r2, float h){\n    vec2 q = vec2( length(p.xz), p.y );  \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    if(k < 0.0) return vec2(length(q) - r1, 7.0);\n    if(k > a*h) return vec2(length(q-vec2(0.0,h)) - r2, 7.0);\n    float dis = dot(q, vec2(a,b) ) - r1;\n    return vec2(dis, 7.0);\n}\n\nvec2 minDist(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x)? d1 : d2;\n}\n\nvec2 rotatesdOctahedron(vec3 p, float ss, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n    mat4 rotaEar = mat4(vec4(c, 0, s, 0),\n                        vec4(0, 1, 0, 0),\n                        vec4(-s, 0, c, 0),\n                        vec4(0, 0, 0, 1));\n    vec4 pp = inverse(rotaEar) * vec4(p, 1.0);\n    vec3 poi = vec3(pp);\n    return sdOctahedron(poi, ss);\n}\n\nvec2 rotatesdRoundedCylinder(vec3 p, float ra, float rb, float h, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n\tmat4 rotaEar = mat4(vec4(1, 0, 0, 0),\n                        vec4(0, c, -s, 0),\n                        vec4(0, s, c, 0),\n                        vec4(0, 0, 0, 1));\n    vec4 pp = inverse(rotaEar) * vec4(p, 1.0);\n    vec3 poi = vec3(pp);\n    return sdRoundedCylinder(poi, ra, rb, h);\n}\n\n//actually is a frog\nvec2 CatHead(vec3 p) {\n\tvec2 dishead =  vec2(sdRoundedCylinder(p - vec3(0, -2.0, 0.4), 1.5, 2.0, 0.6).x, 3.0);\n    vec2 ear1 = vec2(sdRoundCone(p - vec3(1.2, 0.9, 0.8), 0.2, 0.9, 0.9).x, 4.0);\n    vec2 ear2 = vec2(sdRoundCone(p - vec3(-1.2, 0.9, 0.6), 0.2, 0.9, 0.9).x, 4.0);\n    vec2 eye1 = vec2(rotatesdOctahedron(p - vec3(-1, -0.6, 2.8), 0.5, 22.).x, 6.0);\n    vec2 eye2 = vec2(rotatesdOctahedron(p - vec3(1, -0.6, 2.8), 0.5, -22.).x, 6.0);\n    vec2 eyeball = vec2(rotatesdRoundedCylinder(p - vec3(-1.5, 1.5, 1.2), 0.2, 0.3, 0.1, 90.).x, 8.0);\n    vec2 eyeball2 = vec2(rotatesdRoundedCylinder(p - vec3(0.8, 1.5, 1.6), 0.2, 0.3, 0.1, 90.).x, 8.0);\n    \n    vec2 dismin = minDist(minDist(minDist(minDist(dishead, eye1), ear1), eye2), ear2);\n    dismin = minDist(minDist(dismin, eyeball), eyeball2);\n    return dismin;\n}\nvec2 catScale(in vec3 p, in float s){\n    //return primitive(p/s)*s;\n    return CatHead(p / s) * vec2(s, 1.);\n}\nvec2 rotatesdcat(vec3 p, float sc, float angle) {\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n    mat4 rotaEar = mat4(vec4(c, 0, s, 0),\n                        vec4(0, 1, 0, 0),\n                        vec4(-s, 0, c, 0),\n                        vec4(0, 0, 0, 1));\n    vec4 pp = inverse(rotaEar) * vec4(p, 1.0);\n    vec3 poi = vec3(pp);\n    return catScale(poi, sc);\n}\nvec2 map(vec3 p) {\n    vec2 dis1 = sdfmoutain(p);\n    vec2 dis2 = rotatesdcat(p - vec3(-2.5, -0.38, 3.), 0.03, -60.);\n    return minDist(dis1, dis2);\n    //return dis1;\n}\n\n//color remap\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d){\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n//clouds inspiration comes from https://www.shadertoy.com/view/4tdSWr\nconst mat2 m2 = mat2(1.6, 1.2, -1.2, 1.6);\nconst mat2 rot = mat2(0.75, 0.66, -0.66, 0.75);\n//perlin noise comes from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(vec2 p) {return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise2(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat fbmClouds(vec2 uv) {\n    float sum = 0.0;\n    float freq = 2.0;\n    float amp = 0.5;\n    for(int i = 0; i < 8; i++) {\n        sum += noise2(uv) * amp;\n        uv = uv * m2;\n        amp *= 0.4;\n    }\n    return sum;\n}\nfloat fbmClouds2(vec2 uv){\n\tfloat q = fbmClouds(uv);\n    float r = 0.0;\n    uv -= q - iTime * 0.03f;\n    float weight = 0.6;\n    for (int i = 0; i < 8; i++){\n        r += abs(weight * noise2(uv));\n        uv = m * uv + iTime * 0.5;\n        weight *= 0.7;\n    }\n    return r;\n}\nfloat fbmClouds3(vec2 uv){\n\tfloat q = fbmClouds(uv);\n    float r = 0.0;\n    uv -= q - iTime * 0.03f;\n    float weight = 0.6;\n    for (int i = 0; i < 8; i++){\n        r += abs(weight * noise2(uv));\n        uv = rot * uv + iTime * 0.5;\n        weight *= 0.7;\n    }\n    return r;\n}\n//////////////////////////////////////////////\n//tool box\nfloat smooththestep(float edge0, float edge1, float x) {\n\tx = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return x * x * (3.0 - 2. * x);    \n}\nvec3 Sky(vec3 sundir, vec3 dir) {\n    ////////star////////////////\n    vec3 stars = vec3(smooththestep(0.85, 0.9, 0.18 + fbmSimple(iTime * 0.2 + 100.0 * dir.xy)));\n    ////////////////////clouds\n    vec3 clouds = vec3(0.0);\n    vec3 clouds2 = vec3(0.0);\n    vec3 pale = palette(iTime * 0.02, Colora, Colorb, Colorc, Colord);\n    //clouds += vec3(195., 93., 249.)/255. * fbmClouds2(vec2((dir.x) / dir.y, -dir.z / dir.y ));   \n    clouds2 += pale * fbmClouds3(vec2((dir.z - iTime * 0.02) / dir.y, -(dir.x - 0.1) / dir.y));        \n    vec3 col = 0.4 * skyCol/* + 0.55 * clouds * max(0.0, dir.y)*/ + 0.75 * clouds2 * max(0.0, dir.y);    \n    vec3 starcol = vec3(232., 183., 124.)/255.;\n    col = mix(col, 2.5 * starcol * stars * max(0.0, dir.y), 0.8);  \n    ///////////////////////////////////////\n    vec2 sunPos = dir.xy/dir.z - sundir.xy/sundir.z;\n    col +=  max(0.0, -dir.z - 0.1) * sunCol * 0.29 * pow(max(dot(sundir, dir) - 0.19, 0.0), 10.0);       \n    col = mix(col, vec3(0.8), max(0.0, -dir.z) * fbmSimple(7. * sunPos + iTime * 0.2) * smoothstep(0.30, 0.29, length(sunPos)));\n    return col;\n}\nvec3 terrainbasecolor(vec3 p, vec3 n) {\n    vec3 color = pow(vec3(80., 61., 89.)/255., vec3(2.4));\n    //return color;\n    return mix(vec3(1.0), color, smoothstep(0.09 * n.y, 0.5 * n.y, fbmM(p.xz)));\n}\n//get normal\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(map(p+q.yxx).x - map(p-q.yxx).x,\n                \t\t   map(p+q.xyx).x - map(p-q.xyx).x,\n                \t\t   map(p+q.xxy).x - map(p-q.xxy).x));\n}\n/////////////////////////////AO////////////////////////////////\nconst int AO_SAMPLES = 100;\nconst float AO_DIST = 0.5;\n//tangent space axis get from adam\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) {   \n    if (abs(v1.x) > abs(v1.y)) {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\nfloat computeAO(vec3 p, vec3 n, float dist) {\n    float aoSum = 0.0;\n    // Sample a few points in the hemisphere around n at p\n    vec3 t, b;\n    // Make a tangent and bitangent vector\n    coordinateSystem(n, t, b);\n    for(int i = 0; i < AO_SAMPLES; ++i) {\n        // Generate a pair of random [0, 1] floats\n        vec2 xi = random2(p + float(i) * 100.);//square random        \n        // Convert the xi pair to a vector in the hemisphere\n        float rz = xi.x;\n        float rx = cos(2.* PI * xi.y) * sqrt(1. - rz * rz);\n     \tfloat ry = sin(2.* PI * xi.y) * sqrt(1. - rz * rz);       \n        //local to world\n        vec3 dir = transpose(mat3(t, b ,n)) * vec3(rx, ry, rz);\n        //step if dis < 0 return 0, else return 1\n        aoSum += step(0.55, map(p + dir * dist).x);\n    }\n    return aoSum / float(AO_SAMPLES);\n}\n//iq fog\nvec3 applyFog(vec3  rgb,     // original color of the pixel\n               float distance,// camera to point distance\n               vec3  rayOri, // camera position\n               vec3  rayDir) // camera to point vector\n{\n    rayOri = rayOri + rayDir * 0.01;\n    float c = 6., b = 80.0, b2 = 0.03;\n    float fogAmount = c * exp(-rayOri.y * b2) * (1.0-exp(-distance*rayDir.y * b)) / rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.5,0.7);\n    vec3 col = mix(rgb, fogColor, fogAmount);\n    if(col.x < 0.1 && col.y < 0.1 && col.z < 0.1) {\n    \tcol =  0.5 * rgb;\n    }\n    return col;\n    //return vec3(fogAmount);\n}\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\nvec2 Shadowmap(vec3 p){\n    vec2 dis1 = sdfmoutain(p);\n    //vec2 dis2 = CatHead(p);\n    //return minDist(dis1, dis2);\n    return dis1;\n}\n//iq soft shadow\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;//min t\n    for(int i = 0; i < MAX_STEP; ++i) {\n        float m = Shadowmap(origin + t * dir).x;\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t, float id) {\n    vec3 sunpos = normalize(vec3(1.0, 0.9, -1.0));     \n    // Light positions with intensity as w-component\n\tlights[0] = vec4(sunpos, 2.0); // key light\n\tlights[1] = vec4(-6.0, 3.0, -1.0, 1.5); // fill light\n\tlights[2] = vec4(5.0, 5.0, -1.5, 4.0); // back light            \n    \n    //if t = -1\n    vec3 col = Sky(sunpos, rd);        \n    vec3 p = ro + t * rd;//p\n    vec3 n = normal(p);//normal\n    vec3 lightp = normalize(sunpos - p);\n    vec3 lightp2 = normalize(lights[1].xyz - p);\n    vec3 lightp3 = normalize(lights[2].xyz - p);\n    vec3 pale = palette(iTime * 0.002, Colora, Colorb, Colorc, Colord);\n    \n    float dis = map(ro + t * rd).x; \n    //if t > 0\n    if (t > 0.0 && id == 2.0) {//moutain\n        //basecolor//////////////////////////////\n        vec3 tex = terrainbasecolor(p, n);\n        /////fog////////////////////////////////\n        vec3 afterfog = applyFog(tex, dis, ro, rd);\n        /////ao.////////////////////////////////\n        vec3 ao = vec3(computeAO(p, n, 1.0)); \n        /////diffuse color////////////////////////////////\n        //shadow//////////////////////////////\n        vec3 lightfinal = pow(lightColor1, vec3(2.2)) * max(dot(n, sunpos), 0.0);\n        float shadow = softShadow(lightp, p + 0.01 * n, 0.02, 2.);\n        vec3 lightfinal2 = pow(lightColor2, vec3(1.2)) * max(dot(n, lights[1].xyz), 0.0);\n        float shadow2 = softShadow(lightp2, p + 0.01 * n, 0.02, 2.);\n        vec3 lightfinal3 = pow(pale, vec3(1.2)) * max(dot(n, lights[2].xyz), 0.0);\n        float shadow3 =  0.05 + softShadow(lightp3, p + 0.01 * n, 0.2, 2.);\n        \n        vec3 diff_light = 0.7 * lightfinal * shadow\n            \t\t\t+ 0.25 * lightfinal2 * shadow2\n            \t\t\t+ 0.05 * lightfinal3 * shadow3;\n        \n        vec3 lcol = ao * diff_light;\n    \tcol = mix(lcol, afterfog, 0.3);\n        //col = vec3(afterfog);\n    } else if(t > 0.0 && id != 2.0){//frog\n        vec3 ao = vec3(1.);\n        vec3 basecolor = vec3(1.);\n        switch(int(id)) {\n            case 3:{\n                ao = vec3(computeAO(p, n, 1.0));\n                vec3 lightfinal = pow(lightColor1, vec3(2.2)) * max(dot(n, sunpos), 0.0);\n        \t\tfloat shadow = softShadow(lightp, p + 0.01 * n, 0.02, 2.);\n        \t\tvec3 lightfinal2 = pow(lightColor2, vec3(1.2)) * max(dot(n, lights[1].xyz), 0.0);\n        \t\tfloat shadow2 = softShadow(lightp2, p + 0.01 * n, 0.02, 2.);\n        \t\tvec3 lightfinal3 = pow(pale, vec3(1.2)) * max(dot(n, lights[2].xyz), 0.0);\n        \t\tfloat shadow3 =  0.05 + softShadow(lightp3, p + 0.01 * n, 0.2, 2.);        \n        \t\tbasecolor = vec3(0.5, 0.6, 0.6) * ao * (0.7 * lightfinal * shadow\n            \t\t\t\t\t+ 0.28 * lightfinal2 * shadow2\n            \t\t\t\t\t+ 0.02 * lightfinal3 * shadow3);\n                break;\n            }\n            case 4:{//eye\n                basecolor = vec3(.7, .8, .7);\n                break;\n            }\n            case 8:{\n\t\t\t\tbasecolor = vec3(0.0, 0.0, 0.0);\n                break;\n            }            \n        }\n                \n        vec3 lcol = basecolor;\n        col = lcol;\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    vec2 d = vec2(0.); \n    float t = 0.0;\n    for (int i = 0; i < MAX_STEP; i++) {\n        d = map(ro + t * rd);\n        //id = \n        if (d.x < EPS * t || t > FAR){\n            break;\n        }\n        t +=  d.x;\n    }  \n    return d.x < EPS * t ? vec2(t, d.y) : vec2(-1., d.y);\n}\n\n//from tool box\nfloat parabola(float x, float k) {\n    return pow( 4.0 * x * (1.0 - x), k );\n}\nvec3 raycas(vec2 p, vec3 u_Ref, vec3 u_Eye, vec3 u_Up) {\n vec3 forward = u_Ref - u_Eye;\n float ratio =  iResolution.x / iResolution.y;\n vec3 Right = normalize(cross(forward, u_Up)) * ratio;\n vec3 up = normalize(cross(Right, forward));\n float len = length(forward);\n vec3 dir = normalize(forward + len * p.x * Right + len * p.y * up);\n return dir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //camera pos\n    float xpos = parabola(-0.02 * iGT, 2.0);\n    vec3 ct = vec3(0.0, 0.1, -2.0);//target\n\tvec3 cp = vec3(xpos, 0.1 , 5.0);//position\n\tvec3 up = vec3(0.0, 1.0, 0.0);//forward\t\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - vec2(1.0);\t\n\tvec3 ro = cp;\n    vec3 rd = raycas(uv, ct, cp, up);//ray cast a ray\t\t\t      \n \tvec2 t = raymarch(ro, rd);//ray march\n    vec3 col = pow(shade(ro, rd, t.x, t.y), vec3(1.0/2.2));\n    col = smoothstep(0.0, 1.0, col * 1.2);\n    \n    //Vignette/////////////////////////////\n    float point = length(fragCoord.xy + vec2(0.5, 0.5) - vec2(iResolution.xy) / 2.0);\n    float distance = 1.0 - point / length(vec2(iResolution.xy) / 2.0 - vec2(0.5,0.5));//circle the 0.5 0.5\n    col *= pow(distance, 0.4);\n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[657, 726, 746, 746, 1322], [1323, 1377, 1402, 1402, 1578], [1579, 1579, 1599, 1599, 1847], [1848, 1848, 1868, 1868, 2114], [2115, 2128, 2153, 2153, 2198], [2199, 2276, 2315, 2315, 2442], [2444, 2444, 2505, 2505, 2659], [2661, 2661, 2697, 2697, 3044], [3046, 3046, 3100, 3100, 3411], [3413, 3413, 3445, 3445, 3479], [3481, 3481, 3537, 3537, 3885], [3887, 3887, 3967, 3967, 4324], [4326, 4347, 4369, 4369, 5167], [5168, 5168, 5205, 5236, 5279], [5280, 5280, 5329, 5329, 5673], [5674, 5674, 5692, 5692, 5844], [5846, 5860, 5929, 5929, 5978], [6141, 6205, 6225, 6225, 6312], [6313, 6313, 6335, 6335, 6637], [6638, 6638, 6664, 6664, 6860], [6861, 6861, 6887, 6887, 7137], [7138, 7138, 7164, 7164, 7416], [7417, 7475, 7531, 7531, 7625], [7626, 7626, 7659, 7692, 8726], [8727, 8727, 8766, 8766, 8928], [8929, 8942, 8963, 8963, 9162], [9282, 9317, 9381, 9381, 9568], [9569, 9569, 9591, 9591, 9675], [9676, 9676, 9721, 9721, 10504], [10505, 10514, 10736, 10736, 11122], [11124, 11209, 11232, 11232, 11346], [11347, 11364, 11427, 11427, 11699], [11701, 11701, 11750, 11750, 14829], [14831, 14831, 14864, 14864, 15149], [15151, 15167, 15201, 15201, 15245], [15246, 15246, 15302, 15302, 15594], [15596, 15596, 15651, 15668, 16436]]}
{"id": "tsXXzH", "name": "starfield grid test", "author": "Fab48", "description": "Still learning...\n\ninspired by tutorial here :  https://www.youtube.com/watch?v=3CycKKJiwis\n\nclick to fade from mouse distance\n\n", "tags": ["grid", "starfield"], "likes": 2, "viewed": 111, "published": "Public", "date": "1550584349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 3.\n\nfloat Random(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 Random2(vec2 p){\n    return vec2(Random(p),Random(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.);\n   \n    vec2 grid = fract(scale*uv)-0.5;\n    mouse = (scale*mouse)-0.5;\n\n    vec2 gridId = floor(uv*scale);\n    \n    vec2 rnd = Random2(gridId)*0.7/scale;\n    float angle = 3.14*  (0.5*(iTime* (length(rnd)))-1.);\n\tmat2 rot = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    \n\tgrid+=rnd*rot;\n    grid/=rnd*4.;\n    \n    float dist = clamp(0.,2., 2.-(length(mouse-(gridId-rnd*rot))));\n    if(iMouse.z<0.1){\n        dist=1.;\n    }\n    \n    fragColor += vec4(smoothstep(0.2,0.0,length(grid))*dist); \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 40, 40, 175], [177, 177, 198, 198, 238], [240, 240, 297, 297, 963]]}
{"id": "wd23D3", "name": "Paper Thin", "author": "PianiGiani", "description": "Blueish paper thin texture", "tags": ["texture"], "likes": 4, "viewed": 106, "published": "Public", "date": "1550183026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy/1.4;\n    \n    float nTime=iTime*1.2;\n\n    \n    float col4=100.;\n\n    float cnt=1.;\n   \n    for(float x1=0.;x1<3.;x1+=0.2)\n    {\n    for(float y1=0.;y1<3.;y1+=0.3)\n    {\n    float x2=uv.x+x1;\n    float y2=uv.y+y1;\n\n    float nFact=10.+50.*(cos(nTime*.13)-x2);\n    float col1=sin((uv.x*y2)*nFact);\n    float col2=cos((y2+sin(x2))*nFact);\n    float col3=cos((x2*y2)*nFact);\n        \n        \n    col4+=0.2126*(col1+col2+col3)+0.7152*col1+0.072*(col1+col2+col3);\n    cnt+=1.;\n    }\n    }\n    \n    vec3 colmix=vec3(sin(nTime/10.),1.,1.);\n\tfragColor = vec4(vec3(col4/cnt)*colmix,1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd23D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 727]]}
{"id": "Wd23DG", "name": "Lights ping pong", "author": "Canysway", "description": "Flash and disapeared repeatly..:)", "tags": ["light", "move", "twinkle", "firefly"], "likes": 10, "viewed": 313, "published": "Public", "date": "1549992244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTER(w, h)\t vec2((cos(iTime * w) + 1.) * 0.5, (sin(iTime * h) + 1.)*0.5)\n#define F_TIME(a, b)\t a * fract(iTime * b)\n#define F_TIME_RE(a, b) \ta - F_TIME(a, b)\n#define C_TIME(a, b) \t\t(cos(iTime * a) + 1.) * b\n#define S_TIME(a, b)\t\t(sin(iTime * a) + 1.) * b\n\nvec4 sum(vec4 a, vec4 b){\n\treturn  vec4(min(1., a.r + b.r), min(1., a.g + b.g), min(1., a.b + b.b), min(1., a.a + b.a));\n}\n\nvec4 getSpotLightOne(vec2 uv, vec2 center, float intensity, vec3 color){\n\tfloat ratio = iResolution.x/iResolution.y; \n    uv.x *= ratio;\n    center.x *= ratio;\n    float dist = intensity/sqrt(distance(uv, center));\n    return vec4(color * dist, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec2((cos(iTime * 0.1) + 1.) * 0.5, (sin(iTime * 2.) + 1.)*0.5)\n\tvec4 light1 = getSpotLightOne(uv, CENTER(0.5, 3.), F_TIME(0.2, 0.3), vec3(0.,1.,0.));\n    vec4 light2 = getSpotLightOne(uv, CENTER(2., 0.5), F_TIME_RE(0.15, .5), vec3(1.,1.,0.));\n    vec4 light3 = getSpotLightOne(uv, CENTER(1.5, 0.3), S_TIME(3., .1), vec3(1.,0.,0.));\n    vec4 light4 = getSpotLightOne(uv, CENTER(1., 1.3), C_TIME(3., .1), vec3(0.,1.,1.));\n    vec4 light5 = getSpotLightOne(uv, CENTER(3., 2.3), F_TIME(.4, 1.1), vec3(0.5,0.5,.5));    \n\tvec4 light = sum(light1, light2);\n    light = sum(light, light3);\n    light = sum(light, light4);\n    light = sum(light, light5);\n\tfragColor = mix(vec4(0.), light, light.a);                        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd23DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 291, 291, 388], [390, 390, 462, 462, 643], [645, 645, 701, 701, 1464]]}
{"id": "Wd23DK", "name": "CPPN #75", "author": "eps", "description": "CPPN to GLSL \nhttps://github.com/wxs/cppn-to-glsl\nmixed4e_pool_reduce_pre_relu:75", "tags": ["cppn"], "likes": 13, "viewed": 242, "published": "Public", "date": "1550015507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 24\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(-0.25184476,0.11298771,0.43778932,-0.1572586) + mat4(vec4(-0.5258355140686035,-1.1267290115356445,-0.6649447679519653,-0.06830576807260513),vec4(-0.09232506901025772,1.0561412572860718,1.1205568313598633,-1.5881409645080566),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(-0.074317925,0.16551621,0.1444894,-0.36319184) + mat4(vec4(-0.3367200493812561,0.49517324566841125,0.6878888010978699,-0.6914942264556885),vec4(0.05852704495191574,-0.4039391577243805,0.8976340293884277,-0.042348943650722504),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(0.4486023,0.40516084,0.23222205,0.012933488) + mat4(vec4(-0.4550468921661377,-1.0073034763336182,0.13144363462924957,0.1223221868276596),vec4(0.16716426610946655,0.4704827070236206,0.48181068897247314,-0.9825983643531799),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(0.4246299,-0.04600056,-0.45928755,0.019452047) + mat4(vec4(-0.3352990448474884,-0.5691156387329102,0.5413476824760437,-0.2136530727148056),vec4(0.4422396123409271,0.01704365201294422,-0.30822789669036865,0.06616584211587906),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[4] = vec4(0.2642756,-0.41921577,0.21381181,0.029168982) + mat4(vec4(-0.3517737090587616,-0.3572115898132324,0.3136453628540039,0.9308379292488098),vec4(1.0180306434631348,-0.4693899154663086,0.0660674124956131,0.6025292873382568),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[5] = vec4(-0.3912515,0.10245033,0.39589643,-0.25149244) + mat4(vec4(1.0422908067703247,-0.21403354406356812,-0.2536153793334961,0.6014097929000854),vec4(0.2739301323890686,1.299776315689087,0.27459877729415894,0.25379499793052673),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.061553072,-0.23871528,0.45524567,0.25243348) + mat4(vec4(-0.0015718823,0.045450356,-0.17019221,-0.00304472),vec4(-0.020369662,-0.24415043,-0.15177688,-0.19952664),vec4(0.009109233,-0.09685735,0.20406799,-0.15003976),vec4(0.16398776,-0.08629617,0.16389252,0.19015355)) * bufB[0] + mat4(vec4(-0.122810915,0.0095425965,-0.24197319,-0.29904392),vec4(-0.06686355,-0.033714753,0.074999526,-0.21241856),vec4(0.08573714,0.05624565,0.0053381035,-0.33352003),vec4(0.06690114,-0.08825707,-0.022982363,0.11937565)) * bufB[1] + mat4(vec4(-0.11208906,-0.090617806,-0.13940468,0.22071879),vec4(0.15779933,-0.05323154,-0.1050513,-0.12970161),vec4(-0.029260907,-0.035173338,-0.13468719,-0.10197808),vec4(-0.012934331,0.09915543,-0.041538592,0.22980061)) * bufB[2] + mat4(vec4(-0.23906238,0.054711025,0.152344,-0.017963503),vec4(0.10985313,-0.14109986,-0.14705518,-0.045916423),vec4(0.02514742,0.0013045908,-0.07149541,-0.03043807),vec4(-0.014236472,-0.21083638,-0.20153975,0.22105284)) * bufB[3] + mat4(vec4(-0.21104863,0.142909,-0.019242918,0.035426985),vec4(0.12509824,-0.13926783,-0.03281997,-0.24175037),vec4(-0.17816482,-0.18679522,0.2348919,-0.082337864),vec4(-0.17167135,-0.221716,0.10704718,-0.13703232)) * bufB[4] + mat4(vec4(-0.055366077,-0.0034829148,0.08389117,0.080580555),vec4(0.15881105,0.022427628,-0.23934858,0.029721048),vec4(0.16584551,0.056426343,0.14240193,0.13720681),vec4(-0.13610655,-0.17181912,0.009834587,-0.07489825)) * bufB[5] + mat4(vec4(-0.009293907,-0.21041039,0.04164976,0.09643282),vec4(-0.24943513,-0.14244238,-0.10784494,-0.009974899),vec4(-0.4347554,-0.18664105,-0.034674928,0.06418207),vec4(0.22992466,-0.34139824,-0.122114204,-0.22623819)) * bufB[6] + mat4(vec4(0.11774684,0.025027262,-0.075041726,0.22308482),vec4(0.1440062,0.1684807,0.10193811,-0.10999184),vec4(0.061554,-0.3037866,-0.1656662,0.07761649),vec4(-0.05680824,0.041445125,0.09515151,-0.14773345)) * bufB[7] + mat4(vec4(-0.008321676,-0.11169724,-0.18996944,0.063277304),vec4(0.22026257,-0.10497836,-0.06732476,-0.025188241),vec4(0.024448829,0.13475633,-0.23656295,0.12054141),vec4(0.27694872,0.06458123,-0.18728583,-0.18995579)) * bufB[8] + mat4(vec4(-0.017732501,-0.2193256,0.036789518,0.06279562),vec4(0.14035822,-0.22538176,-0.19658007,0.025673062),vec4(0.07710251,-0.01725408,-0.09510073,0.025591688),vec4(0.3119008,-0.003945121,-0.2446045,0.07947569)) * bufB[9] + mat4(vec4(0.070700586,-0.062123016,-0.23103237,-0.22800449),vec4(0.122871116,-0.15544815,-0.060840517,0.08007436),vec4(-0.09795107,-0.15987204,-0.14515783,-0.04335363),vec4(0.07611821,-0.10850707,0.116553344,0.23792472)) * bufB[10] + mat4(vec4(-0.08270596,0.008379229,-0.18200116,-0.055103373),vec4(-0.11497634,0.14177658,-0.18984976,-0.28111607),vec4(0.08377539,-0.12425721,-0.06097825,0.0719701),vec4(0.0482688,-0.003156048,-0.42221937,0.05454359)) * bufB[11];\nbufA[1] = vec4(-0.0884314,-0.012536289,-0.3557865,0.031674404) + mat4(vec4(0.13137756,-0.046536684,0.11913838,0.075616635),vec4(-0.23242521,0.072946966,0.19895077,0.16276501),vec4(0.13159792,0.25913554,-0.032946613,0.20163126),vec4(0.04400907,0.050498884,-0.00038749195,0.032903694)) * bufB[0] + mat4(vec4(-0.2130969,0.01617468,-0.011469667,-0.11084132),vec4(0.29896903,-0.23826706,-0.1857671,-0.10588259),vec4(-0.11811253,0.1387197,0.18322514,-0.15152206),vec4(-0.12628487,0.12102573,0.2340065,0.055364773)) * bufB[1] + mat4(vec4(0.004721215,0.11309856,-0.04718187,0.0345798),vec4(-0.25365147,0.035057943,-0.16417983,-0.06786846),vec4(0.116316535,-0.14050254,0.069928356,0.26696667),vec4(0.034991417,0.19457394,-0.053553272,0.26401132)) * bufB[2] + mat4(vec4(0.11972531,0.109352104,-0.05697314,-0.14923832),vec4(-0.15919554,-0.08289388,0.3276293,-0.13888298),vec4(0.1451159,0.15126151,-0.0783485,0.23284066),vec4(-0.05401034,-0.09275994,-0.19713627,0.22708231)) * bufB[3] + mat4(vec4(0.019460095,0.023177698,0.1376087,-0.12077232),vec4(-0.08693203,0.28632522,0.44651052,-0.034838535),vec4(0.15520366,-0.052424222,-0.19819139,-0.19053352),vec4(-0.13654499,-0.0079769045,0.03304684,-0.2471557)) * bufB[4] + mat4(vec4(-0.25751045,0.29891792,0.27488396,-0.08648746),vec4(-0.051669754,-0.11743906,0.14593999,0.16540793),vec4(-0.1966067,0.09755818,-0.12084893,-0.12826933),vec4(-0.046559088,0.07540159,-0.13006924,-0.055145048)) * bufB[5] + mat4(vec4(0.30693018,0.23113014,-0.1547464,0.020081293),vec4(0.077214986,-0.015836218,0.18070093,0.121667884),vec4(-0.11011937,0.280343,-0.27990377,-0.16124055),vec4(-0.05429835,-0.012999965,-0.054401174,0.00900978)) * bufB[6] + mat4(vec4(0.05429789,0.06768178,0.002932549,0.028082652),vec4(0.3353234,0.042656574,-0.06302258,-0.004874257),vec4(-0.48150095,-0.41017178,-0.014978618,0.24956362),vec4(-0.057698894,0.04209308,0.08204013,-0.026707074)) * bufB[7] + mat4(vec4(0.058622044,-0.08871233,-0.083554186,0.2827976),vec4(0.08554039,0.41595995,0.27041796,0.14077513),vec4(-0.2275072,0.22886394,0.21376385,0.20539933),vec4(-0.08405244,0.13128689,-0.14219856,-0.13890055)) * bufB[8] + mat4(vec4(-0.045835443,0.25669307,-0.093438424,-0.22082387),vec4(0.28290516,-0.041447144,0.06433824,0.033068858),vec4(-0.39349952,0.215636,0.30497286,0.19540508),vec4(-0.23454423,0.11505698,0.26715046,-0.008448626)) * bufB[9] + mat4(vec4(0.20053266,0.12292378,-0.20951217,0.06747928),vec4(0.052442968,-0.12334168,0.039863944,0.09068965),vec4(0.16020447,0.029392706,-0.0913272,0.1668572),vec4(-0.10114277,0.30580524,-0.055388983,-0.25279388)) * bufB[10] + mat4(vec4(-0.24656127,0.21481654,0.33183762,0.22770625),vec4(-0.053883824,0.047201697,-0.015381264,-0.34697717),vec4(0.20154469,0.07769384,-0.037697054,-0.107371524),vec4(-0.114465326,0.32364637,-0.297637,0.19235954)) * bufB[11];\nbufA[2] = vec4(0.18877931,-0.22817819,0.23214997,-0.05715854) + mat4(vec4(-0.06335373,-0.22656669,-0.116808854,-0.0448449),vec4(-0.033623263,0.2794208,-0.08995873,0.07382539),vec4(-0.07639018,0.09435755,-0.13809529,0.3109298),vec4(0.020722922,0.02774035,-0.03697715,-0.062279433)) * bufB[0] + mat4(vec4(0.047860038,-0.17778938,0.16739577,0.049347322),vec4(0.058170415,0.0665264,0.18691863,-0.060944237),vec4(0.29200798,-0.043949924,-0.11278063,-0.28053963),vec4(0.2575547,-0.13347708,0.012925046,0.27047887)) * bufB[1] + mat4(vec4(-0.06439382,0.3279206,-0.3668372,-0.09155201),vec4(-0.036483254,0.10164356,0.04929924,0.09293091),vec4(0.02442736,0.22568336,-0.23493783,0.06181533),vec4(-0.08911259,-0.20981447,0.24855527,-0.10604064)) * bufB[2] + mat4(vec4(-0.0018319217,-0.046436034,-0.12506518,0.12869658),vec4(-0.24471267,0.08532445,0.057064563,-0.041377876),vec4(0.33345562,-0.12984727,-0.24775378,-0.06355688),vec4(0.14740457,-0.008969218,-0.07952403,0.09562946)) * bufB[3] + mat4(vec4(-0.15114617,-0.14690423,0.15951319,-0.23962119),vec4(-0.109996185,-0.011386884,0.22102824,-0.0092293415),vec4(0.019842135,-0.008616053,-0.18396555,-0.16763857),vec4(0.27795914,-0.1495224,0.10268328,0.044857707)) * bufB[4] + mat4(vec4(0.0502109,-0.09847562,-0.13810755,-0.003475092),vec4(0.457577,0.19687541,0.03772429,0.37245134),vec4(-0.14275818,0.1927743,-0.19723728,0.03006025),vec4(0.17084147,-0.4081429,-0.080475725,-0.014005456)) * bufB[5] + mat4(vec4(0.2156368,-0.17206718,0.0713639,0.03390551),vec4(-0.1017185,-0.041924562,0.21626846,0.020739911),vec4(0.046622396,-0.07738228,-0.0131087145,0.0069824085),vec4(-0.071341045,0.08157183,0.090421654,-0.022059802)) * bufB[6] + mat4(vec4(-0.18109438,-0.20482808,0.034498375,-0.16680779),vec4(0.100090936,-0.15023527,0.13836718,0.20900363),vec4(0.20891146,-0.05309741,0.16013154,-0.27370235),vec4(0.37474772,-0.06462654,0.252128,-0.15793972)) * bufB[7] + mat4(vec4(-0.0580254,0.17477241,0.0684593,0.0041019353),vec4(-0.15427391,0.04256825,0.35414234,0.07629056),vec4(0.022786172,-0.12916367,-0.13687505,-0.06490726),vec4(-0.21879287,-0.14502433,-0.089354485,-0.060461547)) * bufB[8] + mat4(vec4(-0.09718334,0.01569404,0.14352101,0.33017552),vec4(0.47796968,-0.2129893,0.010218448,0.20280242),vec4(0.18782856,0.011918778,-0.24339007,0.19753562),vec4(-0.24396828,-0.038410593,0.087380916,0.018796058)) * bufB[9] + mat4(vec4(0.11947707,-0.1829282,0.09088628,0.12760225),vec4(0.44691527,0.029762596,0.0602562,0.19639784),vec4(0.3595719,0.09698058,0.26945528,0.107735634),vec4(0.109299615,-0.32316026,0.1325883,-0.22701243)) * bufB[10] + mat4(vec4(0.20664805,-0.42137372,0.13771579,0.36904725),vec4(-0.2075984,-0.29941037,-0.08038994,-0.20872684),vec4(0.048770647,0.34856194,0.035441928,0.19167508),vec4(0.17017071,0.07184829,0.25936663,0.08006042)) * bufB[11];\nbufA[3] = vec4(-0.08660396,-0.24232244,0.13113092,-0.075799234) + mat4(vec4(0.1665997,-0.0055405796,0.31270373,0.08093155),vec4(0.2000744,-0.2517911,0.06152284,0.058353707),vec4(0.07017385,-0.33114368,-0.13832247,0.097028606),vec4(0.16423635,-0.08298818,0.020853633,0.17002207)) * bufB[0] + mat4(vec4(-0.0973322,0.025929376,0.12093568,-0.10504563),vec4(0.06682615,-0.102248274,0.18918431,0.20746286),vec4(0.13421585,-0.027194342,0.055295005,-0.16997705),vec4(0.09187528,0.14298831,0.14180036,-0.00057173986)) * bufB[1] + mat4(vec4(-0.106482156,-0.140049,0.20866135,0.021768255),vec4(-0.35716134,-0.01524004,-0.15016614,0.056955475),vec4(-0.032431375,-0.15952685,-0.100060716,0.13323025),vec4(0.15468594,0.06177868,-0.0006440469,0.09895386)) * bufB[2] + mat4(vec4(0.0603117,0.25404206,0.12851907,-0.15137003),vec4(0.14420722,0.2721836,0.08996971,-0.037264317),vec4(0.038814716,0.021587046,-0.08905059,-0.090852164),vec4(0.07869414,-0.27319026,-0.11638648,0.22624297)) * bufB[3] + mat4(vec4(0.02597523,-0.0932486,0.00520721,-0.08606582),vec4(-0.05365398,0.2557192,0.12205204,-0.1324796),vec4(-0.10357222,0.008823851,0.066196784,0.08687778),vec4(0.0397954,0.16635887,0.021532295,-0.067175254)) * bufB[4] + mat4(vec4(-0.07957001,-0.0129915895,0.0729452,-0.28811353),vec4(-0.011828251,0.034603003,0.09107723,-0.07410944),vec4(-0.27912894,-0.0925801,0.07840672,-0.051563643),vec4(0.22285128,-0.13672756,-0.075657606,-0.16241892)) * bufB[5] + mat4(vec4(-0.11796544,0.047514785,0.07487518,0.12823446),vec4(-0.20830218,0.13246197,-0.05525857,0.084609255),vec4(0.024879426,0.1011179,0.00883518,0.30409515),vec4(0.019416489,0.04926782,0.21823217,-0.20015512)) * bufB[6] + mat4(vec4(-0.09884806,-0.30870703,0.14816996,-0.13856316),vec4(-0.1776838,0.12693772,0.20247531,0.17256458),vec4(0.03521642,0.03561595,0.22149637,0.2205286),vec4(-0.34695578,0.38312945,-0.026736807,0.2224934)) * bufB[7] + mat4(vec4(-0.037618406,0.01721679,-0.23475094,-0.08699543),vec4(-0.036607936,-0.0051677157,-0.028992578,0.12660086),vec4(-0.13473022,0.21522617,0.21360937,0.04345703),vec4(-0.055285677,0.110339895,0.14659095,0.221945)) * bufB[8] + mat4(vec4(-0.34820765,0.06464396,0.106020704,0.21207246),vec4(0.07703024,-0.05860919,-0.0106214555,0.070782445),vec4(-0.02548854,-0.14538266,0.07690986,0.2310148),vec4(0.119770564,-0.02595761,0.1339912,0.03345616)) * bufB[9] + mat4(vec4(0.040212803,0.28013182,0.16423568,0.1008101),vec4(0.13179699,0.20171931,-0.015831687,0.020568073),vec4(-0.12686482,0.22049926,-0.055117197,0.10124479),vec4(-0.09461791,0.13750747,-0.17202006,0.24284063)) * bufB[10] + mat4(vec4(0.19009717,-0.019653749,-0.13554688,-0.20845927),vec4(0.2028747,0.031962357,0.20674004,0.28513122),vec4(0.25577918,0.088132806,-0.032870717,0.20435703),vec4(-0.325427,0.07629256,0.18599615,0.04520761)) * bufB[11];\nbufA[4] = vec4(-0.33914444,0.273531,-0.12937596,0.0024889559) + mat4(vec4(0.09075324,0.22201376,0.06681233,-0.04016812),vec4(-0.19638494,0.06636755,-0.023619832,-0.22969452),vec4(-0.21362102,-0.096076466,-0.015193459,-0.13498692),vec4(0.33448312,0.10262137,-0.16058372,-0.17973079)) * bufB[0] + mat4(vec4(-0.0021439665,0.19183901,0.27067935,0.23214631),vec4(0.4034776,-0.23454165,-0.07832675,0.17841911),vec4(-0.0049242596,0.07765509,-0.18144979,-0.14087768),vec4(0.13373345,0.29437444,0.10864057,0.08672435)) * bufB[1] + mat4(vec4(-0.058030628,0.030058246,0.001328194,-0.0022402536),vec4(0.20319988,0.07294628,0.12639938,-0.053437904),vec4(0.19055311,0.057851132,-0.08232154,0.13382228),vec4(-0.018046701,0.09988789,-0.20083334,-0.15046224)) * bufB[2] + mat4(vec4(-0.01635514,0.15097278,-0.09573423,0.1016753),vec4(-0.18564776,0.2770429,-0.09001664,-0.021936163),vec4(0.0930157,0.019865941,0.08683227,0.27378622),vec4(-0.10766856,0.20416299,-0.04414834,-0.29312477)) * bufB[3] + mat4(vec4(-0.22555535,0.10147641,0.21358669,0.012692074),vec4(-0.00389674,0.124782845,-0.08575221,-0.07509762),vec4(-0.06359917,-0.11832295,-0.17535771,0.2453676),vec4(0.072066896,0.21414362,0.22929478,-0.15801325)) * bufB[4] + mat4(vec4(0.18574159,0.06476555,0.10106464,-0.07515602),vec4(0.0051569846,0.26640913,0.09066825,-0.02208388),vec4(-0.027038705,-0.1215302,-0.19587484,0.14659606),vec4(0.15358636,-0.18971843,0.12386415,-0.12558825)) * bufB[5] + mat4(vec4(0.024407417,-0.010724134,-0.045623958,0.06044878),vec4(-0.02205647,0.2108501,-0.08323189,-0.23434599),vec4(-0.23425843,0.31502947,0.0762957,0.18925954),vec4(0.28391945,0.10161768,0.47738972,0.123724155)) * bufB[6] + mat4(vec4(-0.029792143,-0.10502307,0.18793254,0.162035),vec4(0.062402427,0.24316135,-0.1929685,0.01591964),vec4(0.12861572,0.1790488,-0.14646459,0.38542145),vec4(0.09317902,0.12665862,-0.03986782,0.13745657)) * bufB[7] + mat4(vec4(0.26327145,0.11399969,0.3687399,-0.050923713),vec4(0.1736606,0.23473388,0.46943665,-0.057091273),vec4(0.5048476,-0.0886797,0.09322529,0.13819872),vec4(0.26860318,0.27699447,-0.054621376,-0.31568712)) * bufB[8] + mat4(vec4(-0.1375265,-0.07923291,0.03282027,-0.050182912),vec4(0.014580812,0.3865815,0.32715586,0.024482485),vec4(0.107790194,0.023307694,0.10965771,-0.09458658),vec4(0.13413315,-0.07931561,-0.06596831,-0.060834963)) * bufB[9] + mat4(vec4(-0.06730578,0.29374638,0.09682111,-0.18825597),vec4(0.27008003,0.096251205,0.17386688,-0.008124175),vec4(-0.10755048,0.15243298,0.12457195,-0.048673183),vec4(0.071725786,-0.2925807,-0.04239566,0.22325267)) * bufB[10] + mat4(vec4(-0.037762545,-0.10319537,-0.0066364845,0.09196737),vec4(0.19869916,-0.17485572,0.14585385,-0.049458507),vec4(0.1945113,0.14884265,0.04291356,0.16664325),vec4(0.13792416,0.24387896,0.12805481,0.08114057)) * bufB[11];\nbufA[5] = vec4(0.2907176,0.40335065,0.0493269,-0.03948666) + mat4(vec4(0.091793776,0.13186814,0.056079566,0.18847083),vec4(-0.25536877,-0.24457999,0.09842693,0.025713215),vec4(0.2777717,-0.012319582,-0.015394454,-0.055721395),vec4(0.17274243,-0.34646726,0.1655387,0.24378817)) * bufB[0] + mat4(vec4(0.09590376,-0.1201605,0.0046867095,0.26150876),vec4(-0.025921226,-0.088296495,0.101476744,0.20425725),vec4(0.020612977,0.029320754,0.004458427,-0.047064282),vec4(-0.07039464,0.09530281,0.23149072,0.27858788)) * bufB[1] + mat4(vec4(0.34349555,-0.0030070741,0.26635614,-0.015214155),vec4(0.052075192,-0.07091997,-0.25308722,0.08078729),vec4(0.09841501,0.00816503,0.15385273,-0.24116284),vec4(0.17456989,0.13812652,0.17985351,-0.109232634)) * bufB[2] + mat4(vec4(-0.22165039,-0.16128948,0.1321344,0.10721488),vec4(-0.05432208,0.12895088,0.21689092,0.09758655),vec4(-0.15751468,-0.124229826,0.049563706,0.04145193),vec4(-0.091771826,0.20349924,0.009739103,-0.14187045)) * bufB[3] + mat4(vec4(-0.13616921,0.18238874,-0.08149643,-0.27973375),vec4(-0.07624986,0.12385882,0.2360283,0.051314406),vec4(-0.11565993,-0.002915013,0.039301846,-0.14901888),vec4(0.08559099,0.29156747,0.16541253,-0.35042423)) * bufB[4] + mat4(vec4(0.05470387,-0.24780522,0.02653274,-0.07687713),vec4(-0.15172851,0.017674226,-0.4017547,-0.2019792),vec4(0.033057414,-0.14525,0.043245047,0.22337218),vec4(0.10872526,0.06064392,0.09055531,0.086752236)) * bufB[5] + mat4(vec4(0.10608246,0.06499436,0.24124357,-0.0013623117),vec4(-0.01244794,0.10881484,0.03297288,-0.018921228),vec4(0.036515616,0.06972208,0.29125917,0.065791056),vec4(-0.15665004,0.113995545,-0.08675231,-0.09297752)) * bufB[6] + mat4(vec4(0.25745767,0.046671353,0.040462002,-0.05100864),vec4(0.08966891,0.104924396,0.0063634044,0.08303503),vec4(0.07830321,-0.02410052,0.19104709,0.3736344),vec4(-0.14719568,0.3506401,-0.12525128,-0.002190887)) * bufB[7] + mat4(vec4(0.053861465,-0.12093998,-0.07968554,0.17599986),vec4(-0.11204836,0.19640793,-0.05855287,0.11583744),vec4(-0.1341651,0.21080904,0.49072993,-0.24943198),vec4(-0.10364049,0.33894342,-0.062300965,-0.14693931)) * bufB[8] + mat4(vec4(0.018992022,0.05124801,-0.12229619,-0.2437773),vec4(0.08388214,0.14155,0.21988104,-0.027644115),vec4(-0.0012152062,0.052519012,-0.21393168,0.17757742),vec4(-0.13724183,-0.21717009,-0.074852906,-0.120588124)) * bufB[9] + mat4(vec4(0.086585894,0.04772191,0.39980683,-0.1626906),vec4(0.09321793,-0.07000958,0.4845026,-0.050258182),vec4(-0.15009053,-0.20245627,0.20505238,0.09488247),vec4(0.5127461,-0.40071306,0.35500965,0.37852484)) * bufB[10] + mat4(vec4(0.2254403,0.15253161,-0.010240924,0.3305772),vec4(0.1108595,-0.24188884,0.31167603,-0.23446217),vec4(-0.012079767,0.023223681,0.112935096,-0.23969896),vec4(-0.06216983,0.352237,0.096158914,0.32252714)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.37206554,-0.031445313,0.35524857,0.10937633) + mat4(vec4(-0.040055875,0.13561341,-0.17572169,-0.34410223),vec4(0.09225551,0.012449396,-0.040308453,0.21608086),vec4(0.11879843,-0.072307475,-0.027796412,-0.13942967),vec4(-0.24974614,0.15057462,0.39894062,0.088180475)) * bufB[0] + mat4(vec4(-0.030510062,0.05421995,-0.014805171,0.14731115),vec4(-0.06767436,-0.16290174,-0.045015424,0.060854923),vec4(-0.06411575,-0.0014753822,-0.18924192,0.21530871),vec4(-0.18742198,0.09562969,-0.095555454,0.08919311)) * bufB[1] + mat4(vec4(-0.08764587,0.2564421,-0.14276253,-0.1909974),vec4(0.10630151,-0.08151989,0.2219587,-0.15803592),vec4(0.09299056,0.088453226,-0.055678952,0.04923239),vec4(0.00549544,-0.033502433,0.030066326,0.1474146)) * bufB[2] + mat4(vec4(0.14049502,-0.18613477,0.18465275,-0.009694356),vec4(-0.26453015,0.067765586,-0.34878722,-0.12982789),vec4(-0.15839377,-0.30318856,-0.0722436,0.04508692),vec4(-0.035462003,0.050531045,0.050489783,0.11002835)) * bufB[3] + mat4(vec4(-0.0057106735,0.13702779,-0.0064020986,0.07189174),vec4(-0.11963756,0.028709566,0.13868159,0.06360403),vec4(0.059300084,-0.022455908,-0.10689671,0.06371404),vec4(-0.13141629,0.24793458,-0.038011983,0.065899074)) * bufB[4] + mat4(vec4(0.09085037,-0.09474874,-0.18459724,-0.16456081),vec4(-0.17639518,0.05670683,-0.20794787,-0.2247028),vec4(-0.058471266,0.00395207,-0.14636782,0.077140994),vec4(0.15388411,0.12909126,0.081357084,-0.12411346)) * bufB[5] + mat4(vec4(-0.06726519,0.23051491,-0.09463445,-0.08994111),vec4(-0.26053622,0.052884247,-0.07432696,0.20576715),vec4(0.32468778,0.059705447,-0.25834456,0.040652193),vec4(-0.089213826,-0.09535776,-0.07476464,-0.19286121)) * bufB[6] + mat4(vec4(-0.16239892,0.16898851,0.081167236,-0.10616707),vec4(-0.14684361,-0.32044727,0.073513635,0.083511),vec4(-0.034784053,-0.2801748,-0.0007740977,0.0013646006),vec4(-0.2639699,0.081638545,0.0446362,-0.079046376)) * bufB[7] + mat4(vec4(0.18178408,0.06861418,-0.13025023,0.03171978),vec4(0.08611527,0.14812829,-0.21189298,-0.059887506),vec4(-0.10303125,0.16689977,-0.044137646,-0.22653364),vec4(0.18502612,-0.012352151,-0.17518736,0.27349743)) * bufB[8] + mat4(vec4(0.06463568,0.05721326,0.04437417,-0.10818518),vec4(-0.08283308,0.03726491,-0.08607625,-0.057891466),vec4(-0.075305104,0.15886323,-0.04135979,-0.005862133),vec4(-0.101179264,0.3241819,-0.05716043,-0.2871266)) * bufB[9] + mat4(vec4(0.06904447,-0.083026364,0.1278696,-0.012330073),vec4(-0.056614537,-0.14655489,0.019190386,0.19412158),vec4(0.1251905,-0.014325131,0.16047741,0.3731266),vec4(-0.10461111,0.031779736,-0.31076652,0.33744317)) * bufB[10] + mat4(vec4(-0.1044139,0.024290966,0.24152125,0.013429907),vec4(0.20671347,-0.076605536,-0.20341972,0.09473831),vec4(0.006490167,0.19967294,-0.045015465,0.20996743),vec4(-0.6013486,0.11624604,0.18422067,-0.14044574)) * bufB[11];\nbufA[1] = vec4(-0.3583653,-0.41024798,0.16424862,0.15689151) + mat4(vec4(0.31081405,-0.03414388,0.21625695,-0.07191334),vec4(-0.090677805,0.35350513,0.049881957,0.054403335),vec4(-0.27129453,0.21962443,-0.065644674,0.068258286),vec4(-0.07567508,0.21917188,0.36889434,-0.040746648)) * bufB[0] + mat4(vec4(0.056843072,0.2641185,-0.042004686,-0.017377947),vec4(0.27878705,-0.30698672,0.02866036,0.03193098),vec4(0.16129468,-0.11169657,-0.15963061,0.13837644),vec4(-0.13286991,-0.17044508,-0.023735791,0.094668046)) * bufB[1] + mat4(vec4(-0.11311331,0.2472435,0.038061026,0.024718834),vec4(-0.113134034,0.089817755,-0.004903353,0.24753843),vec4(0.10737153,0.25001636,0.21635388,-0.021503575),vec4(-0.15810974,-0.16661115,-0.14299366,-0.07241775)) * bufB[2] + mat4(vec4(0.24125187,-0.099102855,0.09695515,-0.12478444),vec4(0.05280727,0.11211127,0.18318391,-0.097156644),vec4(-0.1399735,-0.17732358,0.13169217,-0.08929741),vec4(0.5384172,-0.19825712,0.2493904,-0.14393118)) * bufB[3] + mat4(vec4(0.48038024,0.113435246,0.04052989,-0.31260565),vec4(0.13464624,-0.091221035,-0.03098806,-0.038817115),vec4(-0.2196979,-0.20873109,-0.26015773,-0.07046434),vec4(0.22458625,0.22535951,0.21115558,0.15567312)) * bufB[4] + mat4(vec4(-0.03885211,0.054967765,-0.0028287675,-0.05009356),vec4(-0.071380146,-0.11093641,-0.006265877,-0.10588361),vec4(0.34781384,-0.2376796,0.15254603,-0.20025523),vec4(0.40429747,0.066399485,0.20605956,-0.06065938)) * bufB[5] + mat4(vec4(-0.007655983,-0.10484155,-0.020158153,0.33813304),vec4(-0.07813624,-0.17213659,-0.22854045,-0.13290235),vec4(-0.1971801,0.5563978,-0.22406061,0.042150248),vec4(-0.10391866,-0.05652319,0.052047458,-0.088233046)) * bufB[6] + mat4(vec4(-0.022799283,-0.16714232,0.15382732,-0.044702373),vec4(-0.008783272,-0.00424771,0.15201871,0.34872946),vec4(0.23182127,-0.09807731,-0.1900631,-0.27282265),vec4(-0.0038819518,-0.12925984,-0.0903355,0.04311961)) * bufB[7] + mat4(vec4(-0.13621023,0.11340952,0.32194582,-0.12854506),vec4(0.09145067,0.20135568,0.09877082,-0.42660064),vec4(0.35333884,-0.16603485,0.19233792,0.10941567),vec4(-0.04728078,0.027392685,0.1351206,0.1433716)) * bufB[8] + mat4(vec4(0.08204903,-0.040572893,-0.06875072,0.06852887),vec4(0.097866036,0.27287972,0.25352636,0.07930678),vec4(0.20382465,0.08004533,0.11155085,-0.07466428),vec4(0.010400162,0.49423802,0.11541918,-0.10357967)) * bufB[9] + mat4(vec4(-0.1996002,0.15909564,-0.017165188,-0.08731606),vec4(0.057360724,0.09907826,-0.14264157,0.08848832),vec4(-0.20368326,0.20957643,-0.09154666,-0.17396452),vec4(0.0599647,-0.13091767,-0.13107054,0.04612482)) * bufB[10] + mat4(vec4(0.1410634,-0.0767457,0.040021844,-0.07988107),vec4(0.15382707,0.014672541,0.18086562,0.050604064),vec4(0.08086575,-0.03551974,-0.115868926,-0.015858373),vec4(0.3983826,-0.38818097,0.100264244,-0.19515532)) * bufB[11];\nbufA[2] = vec4(-0.32311097,-0.26992193,0.4833919,0.3680651) + mat4(vec4(0.02002922,0.15049896,-0.2184986,0.2598085),vec4(-0.18683611,0.03267723,0.08436995,0.21711695),vec4(-0.18811204,-0.13956378,0.34200644,-0.33286563),vec4(0.09353751,-0.21939375,0.008342601,0.08578654)) * bufB[0] + mat4(vec4(0.11318448,0.14904578,0.15128565,0.012258438),vec4(0.15240613,-0.034577463,-0.02709234,-0.010298256),vec4(0.085333146,0.026189223,-0.14084834,0.13189358),vec4(0.30139777,-0.1325932,-0.008333534,-0.05787959)) * bufB[1] + mat4(vec4(-0.1866231,-0.02199998,-0.026776675,-0.12625785),vec4(0.043010466,0.15394297,0.028483436,0.25392064),vec4(0.19272226,-0.119259715,-0.0049180277,0.221015),vec4(0.054677393,0.21021792,0.05401198,0.14529312)) * bufB[2] + mat4(vec4(-0.10674833,-0.012285372,0.041416004,0.011415349),vec4(0.1823635,-0.015348573,-0.11524416,-0.16693795),vec4(-0.029959131,0.12711841,0.08162814,-0.13115826),vec4(0.19302413,-0.12546912,-0.16426717,-0.27331406)) * bufB[3] + mat4(vec4(0.003808549,-0.10059491,-0.0048083095,0.116170995),vec4(0.023793802,0.26368392,-0.17298788,0.21664944),vec4(-0.0032701371,0.14657277,-0.051915534,-0.018333485),vec4(-0.00053796277,-0.09465094,0.055768847,0.06616349)) * bufB[4] + mat4(vec4(0.16871585,-0.088089235,0.113304615,-0.07131043),vec4(0.09883806,0.13270265,0.08726045,0.015343062),vec4(0.00859971,-0.033219863,0.061859395,-0.12831523),vec4(0.3697349,-0.12506491,-0.17116778,0.23131032)) * bufB[5] + mat4(vec4(-0.10261406,0.011396171,-0.07843884,-0.06832317),vec4(-0.05835615,0.047797535,-0.012205082,-0.016181288),vec4(0.1323094,0.12828258,-0.13130333,-0.10055352),vec4(-0.15668666,0.046631865,0.113065735,0.12159984)) * bufB[6] + mat4(vec4(-0.34856585,0.26674646,0.110751726,0.1322426),vec4(0.35371974,-0.18866415,-0.0019205336,-0.13233458),vec4(0.06663993,-0.19156836,0.09894332,-0.18840207),vec4(-0.16026387,0.16740419,-0.018481141,-0.2753568)) * bufB[7] + mat4(vec4(0.05202225,-0.38985807,0.06915525,0.23019034),vec4(0.2643428,0.00708217,0.08062197,-0.27924424),vec4(0.101162516,0.09904194,0.109470546,-0.23543008),vec4(0.23068452,-0.046977274,-0.12842898,0.022423284)) * bufB[8] + mat4(vec4(0.24895334,-0.021954782,-0.201658,0.11543393),vec4(0.0714122,-0.22942954,-0.111761235,0.046973635),vec4(-0.050474796,-0.014928188,-0.16747323,0.050665766),vec4(0.08962799,-0.07592281,-0.10540121,-0.45934564)) * bufB[9] + mat4(vec4(0.29128382,0.25813636,0.0061233016,-0.10221793),vec4(-0.052006684,0.11467388,-0.012506095,0.10744723),vec4(-0.017422572,0.26833266,0.05846377,0.1481649),vec4(-0.007846982,0.28777102,-0.027115632,0.2898989)) * bufB[10] + mat4(vec4(0.043824013,-0.0053418684,0.044495627,0.1530205),vec4(0.12445975,0.22685727,-0.08834196,0.12768735),vec4(0.32747456,-0.017831348,-0.1879754,0.13627595),vec4(-0.24712427,0.08117973,0.03502453,-0.19246994)) * bufB[11];\nbufA[3] = vec4(-0.45479622,-0.09971387,0.25429296,0.41900033) + mat4(vec4(-0.17279501,0.08906394,-0.07635752,-0.10260759),vec4(0.03558077,0.23550306,0.17330483,0.016598241),vec4(-0.034524176,0.32982478,-0.079745114,-0.2694259),vec4(-0.011281881,-0.16655584,-0.053207286,0.033407137)) * bufB[0] + mat4(vec4(0.06275729,0.23402838,-0.11754973,0.1110176),vec4(-0.16435355,-0.0035220024,-0.10286906,-0.037051424),vec4(-0.04037334,-0.097367264,-0.16092712,0.2367021),vec4(-0.031639915,-0.18757446,0.20812222,0.036782816)) * bufB[1] + mat4(vec4(-0.20080994,0.08731598,-0.11233811,-0.053423777),vec4(-0.09509526,-0.47074,0.13300565,-0.24010389),vec4(-0.15744069,-0.32230186,0.026137361,-0.10764286),vec4(0.0019055924,-0.24526896,-0.10606189,-0.11572755)) * bufB[2] + mat4(vec4(0.09427907,-0.20958811,0.034337286,-0.10161516),vec4(0.044425383,-0.10823972,0.01546217,-0.010025047),vec4(0.31742182,0.03895102,0.052119434,-0.24048239),vec4(0.101875626,0.27178195,0.13237993,0.10746855)) * bufB[3] + mat4(vec4(0.35044968,0.25259632,-0.2613094,-0.10411729),vec4(0.2218164,-0.1041421,0.06676462,-0.091502935),vec4(-0.014766622,-0.20730464,-0.08709151,-0.18350987),vec4(-0.18178783,-0.0074035143,-0.0676576,0.15437473)) * bufB[4] + mat4(vec4(-0.11069113,0.296871,-0.1350048,0.104521364),vec4(0.020577634,0.0029466613,-0.12395482,0.091393374),vec4(-0.14548272,-0.2705492,-0.16139714,-0.006937783),vec4(0.063724555,-0.17295596,-0.10683033,0.15403473)) * bufB[5] + mat4(vec4(-0.029187467,0.057506815,-0.3838832,-0.16224389),vec4(0.06892542,0.2886782,-0.0218912,0.04770478),vec4(-0.33633098,-0.068622336,0.056381427,0.2788916),vec4(-0.07191227,-0.01982126,-0.13040058,-0.14936693)) * bufB[6] + mat4(vec4(-0.18904418,0.105193764,-0.2225115,-0.29034826),vec4(0.14313394,0.17210408,0.15565163,0.28954288),vec4(-0.051858213,0.14423238,0.14427444,0.05381051),vec4(-0.12304745,0.27721217,-0.07997477,0.12313805)) * bufB[7] + mat4(vec4(0.3794684,-0.0018774841,-0.16915505,0.16652013),vec4(0.03306753,0.00041269744,-0.023946425,-0.2588617),vec4(-0.17884734,-0.01675404,-0.100213766,0.059950005),vec4(0.2057203,0.034976274,0.046786062,-0.0024461611)) * bufB[8] + mat4(vec4(-0.13134338,0.26953533,0.19469209,0.12845503),vec4(-0.08198633,-0.43160638,0.061196793,-0.06653351),vec4(0.010511232,0.066485636,-0.15150093,0.22250262),vec4(-0.03214577,0.17308559,0.14545587,0.18901652)) * bufB[9] + mat4(vec4(0.068431094,-0.12048066,0.17147414,-0.1446077),vec4(0.0475717,0.18900883,0.4025201,0.1408492),vec4(0.0052275998,-0.14239597,-0.1317833,0.22128883),vec4(0.26100865,0.08387081,-0.06613173,0.066290356)) * bufB[10] + mat4(vec4(-0.1954208,-0.20649678,0.066586815,-0.2891861),vec4(0.07699298,0.049941696,0.31465772,-0.085332066),vec4(-0.12807494,-0.25483564,0.10772377,-0.12907092),vec4(0.111622386,-0.19971608,0.07815937,-0.1805844)) * bufB[11];\nbufA[4] = vec4(0.26131076,-0.37263006,0.3172183,0.39024252) + mat4(vec4(-0.48004258,0.20188686,0.15237553,-0.044428777),vec4(-0.08864149,-0.08440741,0.08552581,0.025002642),vec4(0.02895288,0.0153171085,-0.1673824,0.10568732),vec4(-0.04728297,-0.24174036,0.07619642,0.05740258)) * bufB[0] + mat4(vec4(-0.0689662,0.056732316,0.08490768,0.16945374),vec4(-0.047585,0.22537476,-0.1210281,-0.1318291),vec4(-0.078017645,-0.10780062,0.065829694,-0.077682264),vec4(-0.21729048,0.18270168,0.15801892,-0.005685051)) * bufB[1] + mat4(vec4(0.031508535,-0.3099294,0.018904943,-0.0043357317),vec4(-0.046490956,-0.10509706,-0.06300099,0.31751934),vec4(-0.21784833,0.025657214,-0.0052205464,0.06511824),vec4(-0.11614989,0.0294341,0.016613154,-0.006114167)) * bufB[2] + mat4(vec4(-0.025419882,-0.051538557,0.14947233,-0.046635915),vec4(0.042283725,-0.022855194,-0.20454329,-0.10693987),vec4(-0.05293075,0.07978312,0.029814256,-0.05978742),vec4(-0.23370083,0.04553623,-0.08047413,0.1901528)) * bufB[3] + mat4(vec4(-0.13279456,0.16162741,0.0548513,-0.025094701),vec4(0.23638043,0.26291037,-0.17298317,0.15975524),vec4(-0.024474083,0.43341514,-0.29798108,0.0661202),vec4(-0.18396392,-0.30199072,0.14797506,-0.05755129)) * bufB[4] + mat4(vec4(-0.109503195,0.061064582,0.027498696,-0.050136242),vec4(0.1330803,-0.014976122,0.2991715,0.07318069),vec4(-0.040744744,-0.29687682,-0.22397073,-0.20617363),vec4(-0.1786088,-0.11149071,0.05647002,-0.1591068)) * bufB[5] + mat4(vec4(0.01011457,-0.07040597,0.025868746,0.22156572),vec4(-0.07454014,0.3541435,0.0606385,-0.047950774),vec4(-0.051039107,-0.045499176,-0.3261675,0.060411416),vec4(0.025419688,0.15806052,-0.02814525,-0.18590677)) * bufB[6] + mat4(vec4(0.33644474,0.42113718,-0.13236207,0.23658502),vec4(-0.16515326,-0.15012571,0.024594257,0.18535395),vec4(-0.13693689,-0.09406046,0.19002523,-0.03761015),vec4(0.1526683,0.14369065,-0.03290925,0.23871534)) * bufB[7] + mat4(vec4(0.13800953,0.018168058,0.43723556,-0.20546076),vec4(0.25623658,0.06652906,0.104811996,-0.08029715),vec4(-0.101440504,0.20004542,-0.054841224,0.019679807),vec4(0.11247547,-0.1889395,-0.012377311,0.036690403)) * bufB[8] + mat4(vec4(-0.029791802,-0.18435839,0.03498167,-0.03157018),vec4(0.1534818,0.1056879,0.10616114,0.054945655),vec4(-0.16698855,-0.047378756,-0.22036107,-0.18158154),vec4(-0.05455262,0.0709782,-0.37831604,-0.076296575)) * bufB[9] + mat4(vec4(-0.13729554,-0.18412325,-0.1926639,-0.14580415),vec4(-0.00608825,-0.25025114,-0.17538226,-0.08989442),vec4(-0.03842873,0.07069479,0.30124626,-0.19979478),vec4(-0.13648501,-0.15798616,0.03713455,-0.13785505)) * bufB[10] + mat4(vec4(0.13170041,-0.05857565,0.13046744,-0.08284322),vec4(0.13736996,0.12068531,-0.12185571,0.07146254),vec4(-0.09968277,-0.16664706,0.087899625,-0.33404663),vec4(0.025501506,0.24839585,-0.36443332,-0.20478806)) * bufB[11];\nbufA[5] = vec4(0.43318382,0.05518178,0.5155457,-0.29989222) + mat4(vec4(-0.023130601,0.032574143,-0.37724018,0.031824473),vec4(0.008982043,-0.048295826,-0.21552165,0.11742189),vec4(-0.013515201,-0.14055379,-0.009052332,0.031657618),vec4(-0.2427806,-0.11745824,-0.046531484,-0.10207096)) * bufB[0] + mat4(vec4(0.09971876,-0.09604984,-0.19011638,0.24199815),vec4(-0.18747056,-0.1548102,-0.07497568,-0.05487628),vec4(0.040110104,-0.056019276,0.35268998,-0.07252901),vec4(0.19554614,-0.060626812,-0.03867238,-0.11425906)) * bufB[1] + mat4(vec4(-0.17619498,-0.016661383,0.1127864,-0.12548918),vec4(0.040758245,-0.098469034,0.023111215,0.18507256),vec4(-0.16299713,-0.05311364,-0.053335283,-0.24529652),vec4(0.18406421,-0.22016811,0.26896143,0.18702361)) * bufB[2] + mat4(vec4(-0.10322418,-0.14430362,-0.03466403,0.16229734),vec4(-0.1914106,-0.064466216,0.022788884,-0.2195925),vec4(0.029566608,0.030556122,-0.19950865,-0.10200742),vec4(0.13521175,0.15974413,0.004857522,-0.2702984)) * bufB[3] + mat4(vec4(-0.40251538,0.09420951,0.22193114,0.16853288),vec4(-0.1520217,-0.1269982,0.074630134,-0.22177814),vec4(-0.2058472,0.11488156,0.08089978,-0.026814725),vec4(-0.039375823,-0.30594152,0.08772273,-0.047724243)) * bufB[4] + mat4(vec4(0.1461776,-0.17464636,-0.011803326,0.1280377),vec4(-0.22232613,0.12647821,0.08612018,-0.09417425),vec4(-0.12968148,-0.03963302,0.02048683,-0.00868034),vec4(0.05878305,0.019971134,0.006960739,-0.27587098)) * bufB[5] + mat4(vec4(0.22044137,-0.1468959,-0.16659032,-0.30559656),vec4(-0.13994159,-0.034960195,0.038640283,-0.09909423),vec4(-0.016801026,-0.26329508,-0.10256894,-0.16380171),vec4(-0.057786644,-0.0025747917,0.006057757,-0.0718432)) * bufB[6] + mat4(vec4(0.10437425,-0.030373149,-0.041565232,-0.07235285),vec4(0.18754342,-0.101406164,-0.3642797,0.019838039),vec4(-0.07247568,-0.043505445,-0.15311006,0.035369426),vec4(-0.2377883,-0.042962626,-0.0900386,0.04764984)) * bufB[7] + mat4(vec4(0.12875211,0.10512763,0.2677167,0.21877363),vec4(-0.47483557,0.1373809,0.046866946,0.071485214),vec4(0.018825198,-0.12571014,-0.070182696,0.09503832),vec4(0.07552341,-0.04243812,-0.08190243,0.05253624)) * bufB[8] + mat4(vec4(-0.09605107,0.061776746,0.04675037,-0.027437884),vec4(-0.1132375,-0.14533214,-0.18923193,0.095627904),vec4(0.23691946,0.060323082,0.051182088,-0.12810302),vec4(-0.38160753,-0.41895753,-0.08792275,-0.040707726)) * bufB[9] + mat4(vec4(-0.062065337,-0.08576449,-0.14552443,0.2304407),vec4(-0.16520536,0.12827645,0.09954696,-0.14465983),vec4(0.082981765,-0.051798973,-0.07964334,-0.23915756),vec4(-0.111333296,-0.06301063,0.20237093,0.19991463)) * bufB[10] + mat4(vec4(-0.16079785,-0.09043502,0.0883987,-0.16060974),vec4(0.07351196,-0.032645818,-0.03898658,0.29101977),vec4(0.29953274,0.11065992,-0.06813735,-0.02726324),vec4(-0.092411175,0.2154762,-0.08523485,-0.08708482)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(-0.2731111,0.4349763,0.24145283,0.24818774) + mat4(vec4(-0.07051356,0.22274102,0.11858325,0.13905524),vec4(0.025365183,-0.05503595,0.21241164,0.061151415),vec4(-0.28875256,-0.08343792,-0.057930343,0.057166405),vec4(0.09030674,0.016162716,-0.0608293,-0.17601024)) * bufB[0] + mat4(vec4(-0.25219923,-0.031228928,-0.0872343,-0.07050113),vec4(0.23125276,-0.038066808,0.030204646,-0.0028523628),vec4(-0.2566476,0.0708563,-0.12848338,0.05245727),vec4(0.19681397,-0.26359767,-0.011864392,-0.056994066)) * bufB[1] + mat4(vec4(0.2052915,-0.062405016,-0.21071647,-0.105709665),vec4(-0.05503511,-0.011726532,-0.14891703,-0.32251424),vec4(-0.14896025,0.16388097,0.25864926,0.030063737),vec4(0.04314052,0.014986614,0.13642606,0.15491965)) * bufB[2] + mat4(vec4(-0.41971338,0.2513654,0.07192699,-0.09988523),vec4(-0.09250503,-0.06438391,0.077812046,0.25306073),vec4(0.34209314,0.08201379,-0.024060862,-0.004443074),vec4(0.266687,0.15187195,0.26871246,0.15109709)) * bufB[3] + mat4(vec4(-0.025873315,0.08643188,0.310928,0.09622867),vec4(-0.21442424,-0.18845995,-0.26499847,-0.19647397),vec4(-0.054794602,0.15737644,0.19691016,0.08529476),vec4(-0.07724654,-0.116581716,-0.036696363,0.19129343)) * bufB[4] + mat4(vec4(-0.01249155,-0.21550179,0.13764209,0.109325476),vec4(-0.14175151,0.20155703,0.22110009,0.048872296),vec4(0.043997884,0.21767712,-0.035360653,-0.29250455),vec4(0.2337524,-0.06914368,-0.0034218088,0.1412905)) * bufB[5] + mat4(vec4(0.37383327,0.16583379,-0.03818877,-0.042195693),vec4(0.12973726,0.22948298,-0.18718787,0.00044516474),vec4(-0.10831093,-0.24653201,-0.16405264,-0.0008598878),vec4(0.017683966,-0.33901945,0.012074982,0.12467166)) * bufB[6] + mat4(vec4(-0.008098281,0.09320008,-0.05232563,-0.23003058),vec4(0.16992502,0.1451094,0.16545704,0.29074863),vec4(0.03133968,-0.13130382,-0.13166203,0.079537615),vec4(-0.25307417,0.12654272,-0.05675753,-0.14843917)) * bufB[7] + mat4(vec4(-0.47877803,0.055207733,-0.14145365,0.17705408),vec4(-0.19826877,0.062035453,-0.025879847,0.06960333),vec4(0.124712326,0.2239542,0.010958116,0.14017415),vec4(-0.12400945,-0.17510386,0.119792715,-0.2502392)) * bufB[8] + mat4(vec4(0.023876993,0.18456563,0.109255716,-0.0052598454),vec4(-0.033412177,-0.18362218,-0.12747988,-0.058345497),vec4(0.062142372,0.09355287,-0.1968354,0.03540795),vec4(-0.0030607306,0.032844786,0.044578016,0.055185325)) * bufB[9] + mat4(vec4(-0.09873392,0.045547288,0.17711,-0.12260805),vec4(-0.09302058,0.23560241,0.28351387,0.024637602),vec4(-0.080020845,-0.12154826,0.048365593,0.17666274),vec4(0.12890384,0.14371821,0.2562812,-0.30740833)) * bufB[10] + mat4(vec4(0.11697302,0.11911843,0.06980797,-0.0098902825),vec4(-0.10697391,0.0053506093,0.021503601,0.06953058),vec4(-0.2551877,0.14624901,-0.109557755,-0.16268273),vec4(0.12448016,0.13503797,-0.13132037,-0.008659646)) * bufB[11] + in0;\nbufA[1] = vec4(-0.3535352,0.30738437,-0.20817846,-0.3711767) + mat4(vec4(-0.018409964,-0.055613592,0.004811674,0.11147468),vec4(-0.07535667,0.14296345,-0.11983765,-0.010201683),vec4(-0.032315813,-0.29191652,-0.0028610507,-0.07839437),vec4(0.2740658,-0.018113345,0.10103329,-0.26959693)) * bufB[0] + mat4(vec4(0.04991974,-0.18953241,0.26515296,0.1355062),vec4(0.0675434,-0.04961681,-0.2228076,-0.1101395),vec4(-0.30331352,-0.22946548,0.0058690654,0.058941226),vec4(0.09697436,-0.047733005,-0.043460146,0.20102663)) * bufB[1] + mat4(vec4(-0.13196214,-0.24982488,-0.25448295,0.2355418),vec4(-0.066303805,0.23695722,-0.06812403,-0.031774238),vec4(0.13154763,-0.01542768,-0.020858267,-0.26251033),vec4(-0.043839324,-0.038760807,0.030990982,0.09247431)) * bufB[2] + mat4(vec4(0.017580729,-0.30125213,-0.05999772,0.19605659),vec4(0.0001792488,0.3411414,-0.11514709,-0.07745413),vec4(0.19967021,-0.23003748,0.10066408,-0.018731212),vec4(-0.16639477,-0.046652745,0.08400689,-0.2271897)) * bufB[3] + mat4(vec4(0.14728893,0.13927728,-0.26121897,-0.15799841),vec4(-0.017180836,0.27797964,-0.16214092,0.031755917),vec4(0.053013783,-0.20941234,0.042699452,-0.080293834),vec4(-0.2420736,0.24891733,-0.28765097,-0.21364412)) * bufB[4] + mat4(vec4(0.071206786,-0.07030727,0.006919389,-0.051007833),vec4(0.14469491,-0.23573335,0.25692877,0.094861224),vec4(0.05421341,-0.018858165,0.1511569,-0.08135784),vec4(-0.048046812,0.066156104,-0.3244524,0.09869128)) * bufB[5] + mat4(vec4(-0.1943695,-0.07278631,0.24834384,0.0698026),vec4(-0.09013552,-0.012649612,0.20976692,0.10439798),vec4(-0.035943773,-0.08357524,0.20159897,0.011671032),vec4(0.03908487,0.15421422,-0.19304399,-0.112428434)) * bufB[6] + mat4(vec4(0.29080832,-0.07718414,-0.14935458,0.23404124),vec4(0.022096217,0.25176686,-0.13229135,-0.23111819),vec4(-0.17607646,-0.06601508,0.25529462,0.08704851),vec4(-0.13022462,0.015695825,0.19686818,0.008497207)) * bufB[7] + mat4(vec4(0.21584404,-0.09226066,-0.34910205,-0.12624995),vec4(-0.29086325,0.031013139,0.16449925,0.116515435),vec4(-0.3660536,0.11499588,-0.17642903,0.09809773),vec4(0.19291309,0.1922332,-0.052462026,-0.032738972)) * bufB[8] + mat4(vec4(-0.042167302,-0.04692749,-0.06218673,-0.08563702),vec4(0.008802051,-0.08399185,-0.05877196,0.0006613392),vec4(0.05359932,-0.031270433,-0.0971103,0.06292002),vec4(-0.18693797,-0.116815634,-0.045851167,0.078578256)) * bufB[9] + mat4(vec4(0.028404683,0.07746476,-0.07495422,-0.18397851),vec4(-0.22446947,0.29667348,0.041379087,-0.046476107),vec4(-0.21982418,0.14528938,0.20634928,-0.21691705),vec4(0.24211784,0.017778587,-0.03984156,-0.0027964264)) * bufB[10] + mat4(vec4(0.27402627,0.010401885,0.009195566,-0.086853385),vec4(-0.024863493,0.33926252,0.23092006,-0.30637163),vec4(-0.030637164,0.16253772,-0.067940354,0.011682846),vec4(-0.2625941,-0.0057420824,0.122808225,0.13533625)) * bufB[11] + in1;\nbufA[2] = vec4(0.5501896,-0.5106471,-0.05083023,0.12267473) + mat4(vec4(-0.13750392,0.24494648,0.3160854,-0.23651248),vec4(0.0024251756,0.08334346,0.08454839,-0.03369737),vec4(0.13587622,-0.008701192,0.15237497,-0.38949275),vec4(0.18544358,-0.07146711,-0.18366149,-0.14380793)) * bufB[0] + mat4(vec4(0.33959523,-0.021226428,-0.4378045,0.1090453),vec4(-0.0027439971,0.263174,0.005961046,-0.21855393),vec4(0.099085435,0.15447766,0.068382874,0.07461281),vec4(-0.11377373,-0.09304672,0.13058583,-0.19486132)) * bufB[1] + mat4(vec4(0.18685739,-0.056616496,-0.08521288,0.21117571),vec4(-0.05014735,-0.119578846,-0.16306053,0.24175192),vec4(0.36404806,0.43591574,-0.10690492,0.19567911),vec4(-0.058167,-0.24250413,0.24485934,-0.09019684)) * bufB[2] + mat4(vec4(0.36526048,-0.28968576,-0.30505443,-0.3828145),vec4(-0.11893024,0.07288856,-0.32036465,-0.21279402),vec4(0.051555526,0.0322964,0.0371504,-0.0080058435),vec4(-0.041093286,0.04396998,0.24458513,-0.2908213)) * bufB[3] + mat4(vec4(0.090577066,0.034615103,-0.07128159,0.21311739),vec4(0.2410895,0.18708846,-0.057490148,0.108242296),vec4(0.0019042017,0.010468747,0.396422,-0.12887706),vec4(-0.1476165,-0.03986736,-0.2733866,-0.2418544)) * bufB[4] + mat4(vec4(-0.106813066,-0.07142822,0.20800743,-0.18112311),vec4(-0.0018622053,0.043722734,0.038295202,0.0063827224),vec4(-0.046216864,-0.17682354,0.2748342,0.09835246),vec4(0.10114978,-0.14352104,0.09949333,-0.43185535)) * bufB[5] + mat4(vec4(-0.2704387,0.09855828,0.15237145,0.04894172),vec4(-0.27430785,0.074994914,0.051409412,-0.12983772),vec4(0.27270213,0.24609052,0.02957535,0.15045732),vec4(-0.1669357,-0.34373862,0.08571198,-0.41430426)) * bufB[6] + mat4(vec4(0.22197232,-0.20822245,-0.087921984,-0.08100981),vec4(0.13154659,0.13588344,0.07411888,0.34054345),vec4(0.10045852,0.05144482,-0.038931612,0.09439701),vec4(-0.118002534,0.25262555,-0.4323533,0.03613078)) * bufB[7] + mat4(vec4(0.32352772,-0.2056873,-0.16432351,-0.14651515),vec4(0.14759886,0.04190515,0.024257166,0.11746354),vec4(-0.09932161,0.16002652,0.025173197,0.09823313),vec4(-0.068711385,-0.09869009,0.25574565,-0.26881862)) * bufB[8] + mat4(vec4(-0.25442728,0.14585097,0.02383479,-0.3139336),vec4(0.16226816,-0.011834845,0.3097949,0.088062905),vec4(-0.12295675,0.052578446,0.0497525,0.08193753),vec4(-0.23957214,0.009353282,0.025548598,-0.24821487)) * bufB[9] + mat4(vec4(0.013563958,-0.12499254,-0.050074693,-0.052991565),vec4(0.14372675,0.04609548,0.057919897,0.04526399),vec4(-0.14325732,0.19268401,0.048381682,-0.06293463),vec4(-0.0048885113,0.125074,-0.19890705,0.0004572895)) * bufB[10] + mat4(vec4(-0.0007676261,0.064384125,-0.03700976,-0.25528407),vec4(0.027316997,0.1289141,-0.0766271,-0.059560835),vec4(-0.2535076,0.19771604,-0.23088697,-0.16250584),vec4(-0.0830034,-0.23846795,0.09070317,0.17747535)) * bufB[11] + in2;\nbufA[3] = vec4(0.14726137,-0.32742086,-0.046252757,-0.20956898) + mat4(vec4(0.21728277,0.1413723,0.15204896,0.037206788),vec4(0.15554963,-0.20583953,0.12408191,0.0031996672),vec4(-0.058271628,-0.11103355,-0.014851776,-0.34322166),vec4(0.015575605,0.06817993,-0.19386782,-0.09024664)) * bufB[0] + mat4(vec4(0.09735058,-0.31016186,0.06472832,-0.48713332),vec4(0.013686175,-0.12846191,-0.049546786,0.01907205),vec4(-0.0056063575,-0.052324113,-0.16464067,-0.16481857),vec4(-0.011192905,-0.044519424,0.13168383,-0.025646256)) * bufB[1] + mat4(vec4(-0.43104702,0.14360085,0.12198365,-0.3626128),vec4(-0.09061833,0.23278688,0.123932995,-0.040896285),vec4(0.19582552,-0.3085177,-0.012141171,0.12581909),vec4(0.014964571,0.02811852,0.010544727,-0.08851546)) * bufB[2] + mat4(vec4(-0.3893957,0.09886886,-0.026490001,-0.14456029),vec4(0.03194365,-0.3533659,0.05765374,0.33341697),vec4(0.014609968,0.20973054,-0.21397905,-0.1544335),vec4(-0.14767872,-0.32770982,0.14401144,0.0018211652)) * bufB[3] + mat4(vec4(-0.20166153,0.20984325,0.23185469,0.08333456),vec4(-0.4168406,0.2290112,0.21801716,0.18615149),vec4(0.058867224,-0.21042408,0.17885134,-0.070207566),vec4(-0.00580973,0.040872864,0.12541927,0.15102746)) * bufB[4] + mat4(vec4(-0.17773543,0.19287688,0.06634826,0.04581929),vec4(0.18660682,-0.17220262,0.1996856,-0.05623583),vec4(0.11443139,-0.07784939,0.088477895,-0.05864058),vec4(0.062728755,0.25928184,0.14238515,0.190843)) * bufB[5] + mat4(vec4(-0.29199508,0.020482473,0.43702105,-0.3189751),vec4(-0.04170018,-0.042550374,-0.00913392,-0.12965006),vec4(-0.059225924,0.1082078,-0.06743889,-0.10572418),vec4(0.18261155,0.079174295,-0.05664771,0.2056329)) * bufB[6] + mat4(vec4(0.034638222,0.052428328,0.048082843,-0.05278728),vec4(-0.13494806,-0.055807903,0.54472417,-0.24362741),vec4(-0.3335213,-0.26910216,-0.13622215,-0.13042983),vec4(-0.11769375,-0.11328277,-0.041259043,-0.22563471)) * bufB[7] + mat4(vec4(-0.35329178,-0.18962295,0.08587223,0.008529375),vec4(-0.12733877,-0.107705794,0.103834264,-0.1059655),vec4(-0.057060488,-0.11129356,-0.18369348,0.042372048),vec4(0.05678625,0.12573682,0.16817392,0.064323254)) * bufB[8] + mat4(vec4(0.1865131,-0.050353788,0.10743805,0.022322038),vec4(-0.016901659,0.2769952,-0.061145984,0.008137255),vec4(0.1536008,0.018291898,-0.1646619,-0.26303834),vec4(-0.08694664,0.109837845,0.16445121,0.08704958)) * bufB[9] + mat4(vec4(0.18419954,-0.036767963,-0.121529765,0.32643357),vec4(-0.20584594,-0.08950521,-0.015759654,-0.03789551),vec4(-0.04440443,-0.017196605,-0.11750413,-0.06421162),vec4(0.29898834,-0.070598565,-0.2647019,0.118083455)) * bufB[10] + mat4(vec4(0.27754918,0.23483609,-0.027928943,-0.11320508),vec4(-0.050069325,-0.20951551,-0.20310342,-0.2808602),vec4(-0.112256944,0.25991052,-0.17093636,0.21302524),vec4(0.08962789,-0.009925168,0.14313412,-0.10662482)) * bufB[11] + in3;\nbufA[4] = vec4(0.0050964393,-0.16092901,0.39979464,0.22360513) + mat4(vec4(-0.062990315,-0.0223665,0.5397474,0.0019848403),vec4(-0.36277676,0.25229302,-0.17792445,-0.037431456),vec4(-0.18598004,-0.07855946,-0.3351807,0.087944314),vec4(-0.028359963,-0.1594119,0.10650885,-0.10539766)) * bufB[0] + mat4(vec4(0.2636457,0.13065839,-0.259781,-0.49416876),vec4(0.3373878,0.19913961,0.023835074,-0.16861345),vec4(0.10936877,0.25423357,-0.307027,0.20172304),vec4(0.12978111,-0.32992676,0.20883837,-0.09411983)) * bufB[1] + mat4(vec4(-0.343876,0.04678371,-0.010305024,-0.14785881),vec4(0.06921375,0.11982011,0.120767646,0.029771574),vec4(0.1427222,0.078471534,-0.011285466,-0.14768298),vec4(-0.020927845,-0.0772159,0.0003287145,-0.1863969)) * bufB[2] + mat4(vec4(-0.0378086,-0.09752582,-0.21938641,0.0648702),vec4(0.15235406,-0.1514182,-0.025276864,0.309336),vec4(-0.110616684,-0.070824645,-0.015085768,0.26218063),vec4(-0.103384875,-0.11816871,-0.20665117,0.054734536)) * bufB[3] + mat4(vec4(0.30496702,-0.035271313,-0.10864451,0.19730242),vec4(-0.105014876,0.08787023,0.005512492,0.01626486),vec4(-0.102275886,0.08731546,-0.1729266,-0.11409638),vec4(0.30021876,0.15119159,0.17453068,0.07691446)) * bufB[4] + mat4(vec4(0.14197397,-0.019139465,-0.051668543,-0.05447635),vec4(0.11108332,0.07719128,0.0699202,-0.1592198),vec4(-0.2138987,-0.015493093,-0.14518815,0.048937168),vec4(-0.32641736,-0.11426958,0.13541304,0.04187636)) * bufB[5] + mat4(vec4(0.23828684,-0.12900765,0.10593939,-0.28578398),vec4(0.2929354,0.21401697,0.16413118,-0.049727846),vec4(-0.022371268,-0.028540742,-0.20267592,0.20091675),vec4(-0.10513421,-0.027425485,0.22042242,-0.045550488)) * bufB[6] + mat4(vec4(0.096456066,-0.2714468,0.29506528,0.18458644),vec4(0.25690982,-0.08881091,0.024009798,0.22608376),vec4(-0.1263774,0.0923496,-0.24703826,0.16228393),vec4(-0.040230352,0.2455811,-0.099048994,-0.026352279)) * bufB[7] + mat4(vec4(0.16917476,-0.4909075,-0.19905388,-0.379508),vec4(0.045529693,-0.11669869,-0.029852236,0.041335322),vec4(0.010859118,-0.019514311,0.11143697,0.058315746),vec4(0.12064839,0.1641488,-0.052589353,-0.1300301)) * bufB[8] + mat4(vec4(-0.106995456,-0.08092669,0.1654736,-0.12994868),vec4(0.035208065,0.14512843,0.06589629,0.20602784),vec4(0.25772074,-0.03681387,-0.115721636,-0.20188986),vec4(-0.07802159,-0.110303454,0.19458067,-0.014139496)) * bufB[9] + mat4(vec4(-0.04350245,0.2040643,0.05876422,0.007930198),vec4(0.010528637,-0.21412921,-0.07891656,-0.1599884),vec4(-0.1808923,-0.08477845,0.10163479,-0.024376418),vec4(0.043243885,0.23228869,0.27277517,-0.09696933)) * bufB[10] + mat4(vec4(0.06888294,0.059374586,0.30272663,0.006677051),vec4(-0.030721031,0.05190345,-0.01210622,0.13747679),vec4(-0.08702979,-0.08897872,0.12419655,0.08872456),vec4(-0.05150588,0.15117577,0.15791814,-0.1778023)) * bufB[11] + in0;\nbufA[5] = vec4(-0.3052756,0.38850993,0.352491,0.22973959) + mat4(vec4(0.06840162,0.12719813,0.23101144,-0.023742374),vec4(0.07084271,0.110436544,0.12384052,-0.018377732),vec4(-0.23771085,0.27122203,0.23233284,0.23861486),vec4(-0.23767,-0.24488862,-0.1514219,-0.16624947)) * bufB[0] + mat4(vec4(0.092702985,-0.057059903,-0.26210523,0.13140681),vec4(-0.11241928,-0.2393545,-0.22569197,-0.29715303),vec4(0.26917204,-0.13972954,-0.27005485,-0.23265642),vec4(0.06016871,0.0075975778,-0.04148917,0.07493946)) * bufB[1] + mat4(vec4(0.15296783,-0.1336911,-0.290114,-0.11613563),vec4(-0.039024107,0.14884792,-0.11977134,0.1871522),vec4(-0.09726232,0.2776159,0.061706174,-0.115233704),vec4(0.16452943,-0.37357974,-0.14003764,-0.32935923)) * bufB[2] + mat4(vec4(0.21405455,-0.21144538,-0.30279464,-0.17900105),vec4(-0.01739152,0.06490476,0.13696973,-0.19554184),vec4(-0.12556382,0.09782513,-0.23560458,0.030720677),vec4(0.2265702,-0.30065787,-0.15532573,0.27225804)) * bufB[3] + mat4(vec4(0.002022345,0.3853134,0.050839536,-0.1345596),vec4(-0.06921341,-0.10733363,-0.115700684,0.08171345),vec4(-0.017474737,-0.22562842,0.36390758,-0.14335993),vec4(-0.026972812,-0.054423433,-0.20075867,0.24603187)) * bufB[4] + mat4(vec4(0.02196602,-0.1930997,0.18615659,0.25036842),vec4(-0.033752408,-0.009509727,0.019679183,-0.07171906),vec4(0.10017971,-0.23958208,0.26954582,0.059100717),vec4(-0.16235882,0.19474854,0.081098616,-0.18026511)) * bufB[5] + mat4(vec4(0.062719345,-0.10117413,-0.09048934,0.08555543),vec4(0.1487645,-0.3341113,0.025548413,0.15543151),vec4(0.12922202,0.20713122,0.0064377477,-0.16341875),vec4(0.0015975483,-0.0784059,-0.108744405,0.2357893)) * bufB[6] + mat4(vec4(-0.3602907,0.09704309,-0.0098346425,0.11468455),vec4(-0.14100346,-0.1301278,0.15607443,0.29504624),vec4(0.108972155,-0.029999966,-0.10259415,-0.09048702),vec4(-0.034078363,-0.11467939,-0.29449788,0.010448445)) * bufB[7] + mat4(vec4(-0.005050869,-0.099671096,0.03713888,0.25558808),vec4(0.038000856,-0.02019305,-0.18870796,-0.09019065),vec4(-0.20591658,0.023175754,0.045171767,0.08210023),vec4(0.13972123,0.21936114,-0.07539723,-0.06578007)) * bufB[8] + mat4(vec4(0.0562126,-0.052356765,-0.2040335,-0.09839883),vec4(-0.093589276,0.2343527,-0.08213961,-0.006927943),vec4(0.18217829,-0.13938786,-0.036447372,0.03901026),vec4(-0.30584514,-0.12821552,0.24499227,-0.042094674)) * bufB[9] + mat4(vec4(0.030816259,-0.0563037,-0.07884295,-0.09943449),vec4(-0.029680459,0.019729896,-0.027241783,0.052686684),vec4(-0.12701249,-0.12671292,-0.18659279,-0.03798692),vec4(-0.03824308,-0.15993887,-0.10418695,-0.079451226)) * bufB[10] + mat4(vec4(-0.12724598,0.25292566,0.23639888,-0.020597037),vec4(-0.059317943,-0.15539144,0.16542691,-0.057770766),vec4(-0.06189054,0.11181213,-0.14392908,-0.044519205),vec4(0.15247834,-0.040604122,0.0647544,0.016631141)) * bufB[11] + in1;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(-0.20833127,0.023677109,-0.1592262,-0.18710127) + mat4(vec4(-0.14134446,0.12439146,-0.20139094,0.21665812),vec4(0.21093233,0.24804212,-0.032044012,0.14867921),vec4(0.20367406,-0.036276806,0.09586872,-0.33800396),vec4(-0.111347035,0.06439471,0.009912257,0.094907254)) * bufB[0] + mat4(vec4(0.112977155,-0.07365913,0.014392222,0.05407373),vec4(-0.287132,-0.19123377,-0.17596479,-0.25590777),vec4(0.3187733,-0.032300882,0.2333246,-0.07779353),vec4(0.164249,0.1023599,0.1674499,-0.22434564)) * bufB[1] + mat4(vec4(0.11919065,-0.27191383,0.037231974,-0.21553396),vec4(0.07021708,-0.21512762,-0.3011862,0.21363026),vec4(0.032415498,0.28894708,0.022084964,-0.106173806),vec4(-0.13348979,0.16327934,-0.3316765,-0.06290717)) * bufB[2] + mat4(vec4(-0.04426581,-0.17165196,-0.17037821,0.15222543),vec4(-0.08876148,0.20102099,-0.12907615,0.3265271),vec4(0.031088402,-0.3137244,-0.08879793,0.05335436),vec4(-0.16601631,-0.12465767,-0.24158399,-0.25265613)) * bufB[3] + mat4(vec4(-0.048452307,0.011045525,0.11271698,0.025589041),vec4(0.09710095,0.041057378,-0.068807535,0.19972445),vec4(-0.4692747,-0.08293395,-0.26707754,0.087325364),vec4(-0.13463204,-0.22240004,0.0036414717,-0.034317043)) * bufB[4] + mat4(vec4(0.28196257,0.18082224,0.30748585,-0.031696144),vec4(0.10766827,-0.38999426,-0.21662064,0.32475635),vec4(0.0005273149,-0.115342125,-0.18369843,-0.4516792),vec4(-0.20859592,0.05041255,-0.096197836,-0.1983341)) * bufB[5] + mat4(vec4(-0.005997967,-0.08198398,-0.1722572,-0.10969393),vec4(-0.19006549,0.05764702,-0.052422278,-0.07175337),vec4(0.24261509,-0.05844938,-0.13140781,-0.0859187),vec4(0.08778788,0.13950834,-0.08992031,-0.08070917)) * bufB[6] + mat4(vec4(-0.058981325,0.31401113,0.14271212,0.052296758),vec4(0.025090944,-0.10444289,-0.028388621,0.042350337),vec4(0.08693856,-0.012828124,0.20662686,-0.010657442),vec4(-0.1589177,-0.18919991,-0.038442828,-0.0039089974)) * bufB[7] + mat4(vec4(0.32341966,-0.05122996,0.17157397,0.017543685),vec4(-0.19776672,-0.060711544,0.07881307,0.21597652),vec4(0.2741295,-0.049394865,0.027725102,0.17942742),vec4(-0.314967,0.4455956,-0.050377183,-0.024377806)) * bufB[8] + mat4(vec4(0.017136905,-0.07753145,-0.031143986,0.2713072),vec4(-0.017985763,0.02946822,-0.00035311515,-0.10716577),vec4(-0.31499213,-0.08889771,0.114389434,0.09829334),vec4(0.24533966,-0.08343517,-0.10926874,-0.03393736)) * bufB[9] + mat4(vec4(-0.15843242,0.09938054,-0.21377759,-0.090509064),vec4(0.020455044,-0.18644314,0.05350808,0.061166283),vec4(-0.030370235,0.45146674,-0.35088322,-0.15047921),vec4(0.08979892,-0.069154434,-0.001688926,-0.10908669)) * bufB[10] + mat4(vec4(-0.1047691,0.06444157,-0.19640891,-0.09267253),vec4(0.000114660244,-0.111101985,0.006675773,-0.022774477),vec4(0.019465623,-0.20740443,0.03833399,-0.0726378),vec4(-0.12169325,-0.033999234,0.017665237,0.36830848)) * bufB[11];\nbufA[1] = vec4(-0.41144943,0.4684753,0.13153853,0.05791446) + mat4(vec4(0.10733927,0.14878732,-0.13097167,-0.17694508),vec4(0.053147532,0.009674657,-0.015496003,0.04643702),vec4(0.05285639,0.0796503,0.10686874,-0.056441512),vec4(0.022802634,-0.16644804,-0.3170339,-0.14414407)) * bufB[0] + mat4(vec4(0.049426973,0.35091287,0.006784931,0.15294118),vec4(0.08344075,0.028107403,0.21294668,0.033564184),vec4(0.08838207,0.1800273,0.010444277,-0.0787333),vec4(0.14717187,-0.12083083,-0.1123864,0.26229414)) * bufB[1] + mat4(vec4(-0.10249854,0.08697067,-0.029455166,0.04019519),vec4(0.0951744,-0.15396276,0.05691182,-0.14403974),vec4(0.11173109,-0.18152592,-0.08187357,0.16194086),vec4(0.0044904677,0.11102259,-0.3785786,0.23070215)) * bufB[2] + mat4(vec4(-0.21897547,-0.023146715,0.38092712,0.054416556),vec4(-0.056638744,0.061521452,0.053101633,0.1949892),vec4(0.053273667,-0.028805789,0.20203815,0.28183588),vec4(-0.21453062,-0.3029218,0.2833352,-0.19959426)) * bufB[3] + mat4(vec4(0.05392391,-0.22460514,0.09962767,0.07003685),vec4(-0.49911988,-0.16802381,-0.15313435,0.1424043),vec4(0.18414667,-0.18606031,0.27607748,-0.068518005),vec4(-0.18920378,0.3119665,-0.040013522,-0.024355695)) * bufB[4] + mat4(vec4(-0.07270557,-0.03862189,-0.18445818,-0.07541442),vec4(-0.09110727,0.07623666,-0.04571029,-0.1143252),vec4(0.00022743922,0.049540017,0.18372759,0.023885721),vec4(0.49936104,0.25883076,0.19208926,0.28054407)) * bufB[5] + mat4(vec4(0.035162084,0.29179308,-0.265985,0.2823129),vec4(0.3551928,-0.09938699,0.0021401853,0.1181216),vec4(-0.08974318,0.037918337,0.016453782,-0.010555365),vec4(0.05384465,-0.13555561,-0.012161349,-0.12292472)) * bufB[6] + mat4(vec4(-0.10115391,0.026110046,-0.30070904,-0.06871025),vec4(0.08179834,0.090492494,-0.25075436,-0.2238098),vec4(-0.0071806624,0.07779554,-0.12388769,0.11499102),vec4(0.30061477,-0.18331254,-0.2810604,0.019731726)) * bufB[7] + mat4(vec4(0.048029613,0.029704623,-0.17802575,-0.090438105),vec4(-0.15498006,0.0423844,0.22184238,-0.027425284),vec4(-0.03390417,0.18822649,-0.07060027,-0.18380958),vec4(0.2671587,-0.13396834,-0.05971098,-0.0813349)) * bufB[8] + mat4(vec4(-0.19278538,-0.23854467,0.40283492,-0.021424105),vec4(-0.01089844,0.23496607,-0.15716971,0.06387927),vec4(0.20646697,-0.12111866,-0.033779602,-0.06771317),vec4(-0.20996751,0.37163338,0.23690026,0.30081514)) * bufB[9] + mat4(vec4(-0.095639996,-0.013329258,-0.062025532,-0.18824299),vec4(-0.0896531,0.029354464,0.35356674,-0.37375733),vec4(0.31529838,0.2820335,0.12793824,0.5023473),vec4(0.08377085,-0.17559557,0.13363174,0.15567328)) * bufB[10] + mat4(vec4(0.027900293,0.051158987,0.13278769,-0.09896161),vec4(-0.019141067,0.08083749,0.05976619,0.010043876),vec4(0.08156062,0.277649,-0.27945697,-0.051093478),vec4(0.26320705,0.059733495,0.20621586,-0.040087234)) * bufB[11];\nbufA[2] = vec4(0.063653484,0.4236924,0.11711113,-0.17176779) + mat4(vec4(0.013010073,-0.007887593,-0.3834355,0.074427254),vec4(-0.036126845,0.006737831,0.13794167,0.058581475),vec4(0.005658782,-0.1611769,0.23747744,0.16384761),vec4(-0.1911515,-0.14404643,-0.01590795,-0.092881374)) * bufB[0] + mat4(vec4(-0.19174367,-0.12552884,0.057005573,0.1370414),vec4(0.14996192,-0.1476733,-0.036630902,0.3484263),vec4(0.16758506,-0.18715116,-0.023353314,-0.044875115),vec4(-0.28209335,-0.12828736,0.10855106,-0.20624577)) * bufB[1] + mat4(vec4(-0.19387801,0.18911941,-0.06854817,-0.2912373),vec4(0.18346739,-0.07970407,0.13682961,0.08316818),vec4(-0.014852241,0.22811824,0.04790608,-0.28625825),vec4(0.40320045,0.100120425,0.0011282228,-0.23397751)) * bufB[2] + mat4(vec4(-0.16551535,0.19579817,-0.010651717,-0.017691396),vec4(-0.13047871,0.36143655,-0.0525153,-0.27546823),vec4(0.1549463,0.013182502,-0.042428702,-0.2885253),vec4(-0.08720054,0.047389355,-0.065887086,0.122672446)) * bufB[3] + mat4(vec4(0.005978683,0.012839171,-0.124679156,-0.112376414),vec4(0.1440654,0.05521449,0.22982332,-0.017803626),vec4(0.10531373,-0.0015547588,-0.27525574,0.236565),vec4(0.2728887,0.058961347,-0.16404934,0.031861883)) * bufB[4] + mat4(vec4(-0.2474831,0.1060357,0.052815024,0.2791945),vec4(0.26752597,-0.08840109,-0.0935568,-0.16922736),vec4(-0.031905685,-0.17229879,-0.048844177,-0.14521936),vec4(-0.056157216,-0.28441814,-0.29603505,0.15776157)) * bufB[5] + mat4(vec4(0.023193117,0.16713662,0.2754845,0.096174),vec4(0.05999264,-0.07751865,0.0067209722,0.18132691),vec4(-0.032179866,-0.003236351,-0.10182113,-0.044789348),vec4(-0.007829154,0.04077317,-0.12378322,0.035655003)) * bufB[6] + mat4(vec4(-0.048980787,0.1087105,-0.12272631,0.18529773),vec4(-0.08117145,0.03554649,-0.11240726,-0.0331271),vec4(-0.02598961,-0.326926,0.20158418,-0.27433306),vec4(0.055780955,-0.19064525,-0.015791705,0.24876277)) * bufB[7] + mat4(vec4(0.027872495,0.117903285,0.23040743,-0.097599275),vec4(-0.38954762,0.33820024,-0.29399416,0.22908477),vec4(0.2836903,0.3867955,0.038910452,-0.035894733),vec4(-0.057577904,-0.19378169,-0.35495752,0.2004035)) * bufB[8] + mat4(vec4(-0.012903131,0.08942134,-0.35585654,0.18850479),vec4(-0.09477618,0.2822507,0.19223522,-0.008605178),vec4(0.047368772,0.11372414,-0.13703458,0.32549128),vec4(0.38497925,-0.34450513,0.004076106,-0.20332828)) * bufB[9] + mat4(vec4(0.32019728,-0.16006611,0.19822979,0.06452458),vec4(-0.1478426,-0.05809641,-0.31253484,-0.0036809705),vec4(-0.032088537,-0.06612564,-0.06505652,0.08554661),vec4(0.16808915,0.1373768,0.20683867,-0.041579444)) * bufB[10] + mat4(vec4(0.065012336,-0.14459613,-0.10481317,-0.10079613),vec4(0.25539654,-0.09413651,-0.1734073,-0.31209928),vec4(0.08727524,0.104535624,0.19655776,0.11640805),vec4(-0.14795096,-0.09543424,-0.16816671,-0.08781834)) * bufB[11];\nbufA[3] = vec4(0.18587308,-0.2883314,-0.49111393,0.33098036) + mat4(vec4(0.07075652,-0.0018872574,0.19689621,0.008309549),vec4(-0.01258729,0.1481826,0.040011983,0.106867515),vec4(0.13423578,0.03870211,0.05494414,0.26857936),vec4(0.12787467,-0.025759572,0.31357107,-0.016676137)) * bufB[0] + mat4(vec4(-0.05727785,0.03763094,-0.30285588,-0.19208518),vec4(-0.14505248,-0.38704872,0.12573953,0.0035798254),vec4(0.09791115,-0.10869882,0.19227129,0.2033166),vec4(-0.20407231,0.06986968,-0.097140566,0.069528304)) * bufB[1] + mat4(vec4(0.15321411,0.047336064,-0.004222515,-0.19606656),vec4(0.153179,0.026313331,0.23042208,0.12055815),vec4(0.18074341,0.19895028,0.038323574,-0.5068322),vec4(-0.1498603,0.05792576,-0.18009314,-0.21620132)) * bufB[2] + mat4(vec4(0.0039655236,0.19460648,0.121762015,-0.22034499),vec4(-0.03372911,-0.070744224,-0.2536909,0.10399119),vec4(-0.023717303,-0.010697698,-0.05499194,0.123512544),vec4(-0.026387027,0.2314163,0.08705002,0.15758774)) * bufB[3] + mat4(vec4(0.15416604,0.026790975,0.133143,-0.12591031),vec4(0.29232985,0.09805104,0.05900566,0.44282022),vec4(-0.13322829,0.034082044,0.14282802,-0.043103877),vec4(0.2115312,-0.06912367,-0.09403995,-0.099041104)) * bufB[4] + mat4(vec4(0.08341416,-0.18691705,0.059742462,-0.06594275),vec4(0.04469716,0.016973639,-0.08732967,-0.1759377),vec4(0.10787487,0.18615094,-0.03805527,-0.3905292),vec4(-0.007727951,-0.009951016,0.15186307,-0.2554001)) * bufB[5] + mat4(vec4(0.34245047,-0.118989825,-0.12805358,0.39652848),vec4(0.029859992,-0.19974647,0.30075282,0.426594),vec4(-0.32516947,-0.045308687,0.1311443,0.1253704),vec4(-0.21918838,0.20662588,0.22097512,0.16986042)) * bufB[6] + mat4(vec4(0.0021394738,0.0477733,0.2921707,0.16335398),vec4(-0.07913404,0.18070167,-0.11864486,0.048605047),vec4(0.199119,0.13615756,0.019749163,0.028827494),vec4(-0.4053085,0.2630176,-0.187579,-0.07247393)) * bufB[7] + mat4(vec4(0.24582872,-0.06432037,-0.02023571,-0.1270576),vec4(-0.21203104,-0.18264937,-0.21605453,0.18998021),vec4(0.17815186,0.16102971,-0.001010495,0.12984307),vec4(-0.34316137,0.07149185,0.05455496,-0.07669648)) * bufB[8] + mat4(vec4(-0.23758878,-0.41862887,0.16854,0.010310047),vec4(0.19669813,0.07762572,-0.22258452,-0.013299961),vec4(-0.2861217,-0.22096923,0.25537643,-0.2388409),vec4(0.120259784,0.071343124,-0.23706707,-0.26020157)) * bufB[9] + mat4(vec4(-0.07693821,0.20944291,0.06897208,-0.05158736),vec4(-0.15437348,0.00791885,-0.09372596,-0.31043696),vec4(0.01003149,-0.11908217,-0.14944084,-0.16465722),vec4(0.061467357,0.057579443,0.04846709,-0.09298308)) * bufB[10] + mat4(vec4(-0.032602094,0.16827333,-0.14982334,-0.24300429),vec4(0.38509881,0.1436639,-0.30504328,-0.18584174),vec4(0.20227696,0.014214929,-0.17151736,-0.15281971),vec4(-0.28178462,-0.23219405,0.2865388,-0.17130214)) * bufB[11];\nbufA[4] = vec4(-0.5018718,0.051691964,-0.4586796,-0.21879208) + mat4(vec4(-0.047903378,-0.018742522,0.2242483,0.18341166),vec4(-0.151175,0.10040198,0.23935166,0.07437287),vec4(-0.13814922,-0.1101585,0.059100162,-0.077213906),vec4(0.07033592,-0.11588273,-0.13321678,0.24140161)) * bufB[0] + mat4(vec4(0.026131194,-0.09853109,-0.07512941,0.041781653),vec4(0.059173856,-0.06972559,-0.019185081,0.13257444),vec4(-0.20075567,-0.19338766,-0.23662667,-0.16917555),vec4(0.09058945,0.0380691,0.15910307,-0.1326397)) * bufB[1] + mat4(vec4(-0.06569906,-0.064914264,-0.38994807,-0.026022878),vec4(-0.2971702,-0.15170181,-0.16358282,0.12713942),vec4(0.29831466,-0.2820835,0.03984798,0.38670304),vec4(-0.30302095,0.092590794,-0.007144597,-0.057764564)) * bufB[2] + mat4(vec4(0.26783648,0.025219427,0.3262576,-0.10761031),vec4(0.18031004,-0.10064611,-0.17370245,-0.36838633),vec4(-0.093452565,-0.11727357,-0.023347184,-0.08360823),vec4(0.5205958,0.12990597,0.21652395,0.16048603)) * bufB[3] + mat4(vec4(-0.16825844,0.07327319,0.10158749,0.2578116),vec4(-0.036305033,-0.098045275,0.17823797,-0.1384417),vec4(0.16453451,-0.004094836,0.072196625,0.28968516),vec4(0.12906133,-0.045882452,-0.13825879,-0.062514566)) * bufB[4] + mat4(vec4(-0.22310056,-0.2599105,0.29767063,-0.08329858),vec4(0.12923896,0.04294338,-0.122470886,-0.09214386),vec4(0.48939148,-0.2426274,0.13458888,0.0077653173),vec4(-0.085151225,0.09295784,-0.031820223,0.21248157)) * bufB[5] + mat4(vec4(-0.0039054593,0.13611059,-0.24107525,0.0057850224),vec4(0.048722386,-0.13357826,-0.048096597,0.075898364),vec4(-0.05844694,0.00857395,-0.125827,0.13864796),vec4(0.054057278,0.010762981,0.071374394,0.046830587)) * bufB[6] + mat4(vec4(-0.10232687,0.13225442,-0.07303836,0.036567606),vec4(-0.014378258,0.008728677,0.21252376,-0.364591),vec4(-0.23890124,-0.21759796,0.24071851,0.013693515),vec4(-0.07063452,-0.16222306,-0.087871276,0.16106196)) * bufB[7] + mat4(vec4(-0.03114735,0.07619302,-0.31276408,0.022308253),vec4(-0.2993398,-0.12058509,-0.0038621265,-0.19716781),vec4(0.01119383,0.22355857,-0.24169923,-0.25273716),vec4(-0.3110186,-0.02281571,0.17951074,-0.12132964)) * bufB[8] + mat4(vec4(-0.016952218,0.50406784,0.018505994,0.20877077),vec4(0.006960596,0.085185334,0.18818447,-0.15770283),vec4(-0.27062997,0.18753402,-0.16027449,0.15700659),vec4(0.08441627,0.2013597,-0.041556854,-0.08659869)) * bufB[9] + mat4(vec4(-0.08468754,0.060223944,0.0038317651,-0.08756061),vec4(-0.24072956,-0.20655417,0.2514882,0.02278339),vec4(0.15744354,0.12658635,-0.011780222,-0.10023481),vec4(0.14186527,0.055671837,-0.11936928,0.01703939)) * bufB[10] + mat4(vec4(0.23702069,-0.088766135,-0.11430035,-0.00670055),vec4(-0.036555693,0.030631516,0.22399534,-0.024345059),vec4(-0.04443228,0.08019074,-0.2034362,0.08341266),vec4(-0.21611638,0.3252629,0.038743805,0.11840808)) * bufB[11];\nbufA[5] = vec4(-0.42748317,0.35851008,-0.44154692,-0.2531856) + mat4(vec4(0.016503766,-0.11996404,0.056054246,0.23086135),vec4(-0.19097401,0.02162096,-0.3068217,0.0013142477),vec4(-0.23584114,0.11507273,-0.17114848,-0.11674144),vec4(-0.09700451,0.11116426,0.14263815,0.0946855)) * bufB[0] + mat4(vec4(-0.13231406,-0.041116398,-0.14079715,-0.32918534),vec4(0.07232535,-0.27418947,0.065606624,-0.014405009),vec4(0.079815105,-0.20202859,0.13615389,-0.037977725),vec4(-0.014279979,0.04769086,0.05250959,-0.0021248898)) * bufB[1] + mat4(vec4(0.05112728,-0.009870851,-0.48871997,-0.30844456),vec4(0.29832613,-0.12309719,-0.07839486,0.109647885),vec4(-0.12821007,-0.4023116,-0.004325836,0.15394045),vec4(-0.04349931,0.19413173,-0.056914788,-0.0068443627)) * bufB[2] + mat4(vec4(-0.04500852,0.22175716,0.056167826,0.18288709),vec4(0.06919244,-0.17960712,0.17416476,-0.22845437),vec4(-0.009418766,-0.022075258,0.008936831,0.024218187),vec4(0.08516369,0.14048024,-0.06258767,-0.023704978)) * bufB[3] + mat4(vec4(-0.0073039494,-0.1866085,-0.14539714,-0.11095615),vec4(0.2522718,-0.1351084,0.04513401,0.04630187),vec4(0.35194397,0.08505067,-0.0363943,0.13455124),vec4(0.023295421,0.02899573,-0.2019694,-0.08671004)) * bufB[4] + mat4(vec4(0.03933246,-0.097863525,0.010186067,0.11945597),vec4(-0.04904234,0.34828037,-0.34643263,-0.22893552),vec4(-0.2377542,-0.2306375,0.14526618,-0.00148609),vec4(-0.21100004,0.026694378,0.15961857,0.013844907)) * bufB[5] + mat4(vec4(-0.029440397,0.049569096,-0.08167097,-0.032054365),vec4(-0.26170167,-0.1962094,-0.14878981,0.13927636),vec4(0.007805892,0.11592682,-0.042415388,0.087785706),vec4(-0.038755063,0.03330663,-0.19866018,0.1039859)) * bufB[6] + mat4(vec4(-0.09351898,-0.36424953,0.11247662,0.210001),vec4(-0.22898497,-0.041449144,-0.28037563,-0.2689242),vec4(-0.0010275892,0.19695579,0.07258302,-0.21858646),vec4(-0.03753134,0.30995932,-0.23071358,0.060488027)) * bufB[7] + mat4(vec4(-0.17535272,0.15031275,-0.17083359,0.0089128725),vec4(0.08705587,0.24123946,-0.10203759,-0.095622964),vec4(0.44130373,-0.123472705,-0.0012433992,-0.15054905),vec4(0.06709521,-0.24142383,0.2249239,-0.074556366)) * bufB[8] + mat4(vec4(-0.17645355,0.095460355,-0.08680911,0.16539904),vec4(-0.0020602823,-0.26002207,-0.09448178,0.18096429),vec4(0.046996247,0.028569924,0.0057393936,0.038629137),vec4(-0.3109037,0.18902497,0.17392665,-0.5148037)) * bufB[9] + mat4(vec4(0.35139343,0.029715791,0.14861502,-0.024104372),vec4(-0.28301477,0.17944613,0.04320395,-0.09841291),vec4(0.100932434,0.069956906,0.12361576,-0.17419733),vec4(0.2083456,0.17767914,-0.024442662,-0.03852807)) * bufB[10] + mat4(vec4(-0.14903009,0.0955232,0.14284214,-0.17804942),vec4(0.12654692,0.108330816,-0.0063050017,-0.019635363),vec4(0.03838804,0.27388257,-0.2235415,0.065093234),vec4(-0.17822573,-0.1484608,-0.24460195,-0.17109412)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(-0.16736454,-0.21843648,0.25790995,-0.35543358) + mat4(vec4(-0.10147703,-0.017558815,-0.09882509,0.2063725),vec4(0.3290603,-0.083919205,0.013242233,0.28088206),vec4(0.050986383,-0.19894508,0.075489,0.072713986),vec4(0.16715582,0.034795105,0.19289306,0.029656703)) * bufB[0] + mat4(vec4(0.18882197,-0.03808449,0.00026882958,0.13544197),vec4(-0.29221502,0.09115948,0.002653241,0.14206862),vec4(-0.24867797,-0.25915074,-0.12299677,0.063271776),vec4(-0.040083423,-0.020599078,0.07490059,-0.03580206)) * bufB[1] + mat4(vec4(-0.061824262,-0.047820278,0.00029171357,-0.11474428),vec4(0.019458855,0.024796389,-0.09163196,-0.16476473),vec4(-0.14479178,-0.14906672,-0.1483207,0.22554238),vec4(0.019515155,0.105955355,-0.24518642,0.0761939)) * bufB[2] + mat4(vec4(-0.20975175,0.1305603,-0.022521622,-0.07989974),vec4(-0.25878295,0.15666346,0.24305779,-0.14201836),vec4(0.32110745,0.019068703,-0.12160842,-0.06782918),vec4(0.11519489,-0.05400088,-0.10196116,0.053059664)) * bufB[3] + mat4(vec4(-0.21877782,-0.20610864,-0.111969575,-0.25056097),vec4(0.054365285,-0.043725032,-0.15945795,0.245451),vec4(0.06520695,-0.23788565,-0.0032547116,0.0908785),vec4(0.05377383,0.15026014,-0.35360894,-0.24576314)) * bufB[4] + mat4(vec4(0.053886008,-0.010674436,0.002884137,-0.24893375),vec4(-0.037482798,0.2824594,-0.15666655,-0.07423576),vec4(0.18612364,0.15926518,0.1024054,0.17182203),vec4(-0.08500359,-0.09143285,-0.34569463,-0.32641497)) * bufB[5] + mat4(vec4(-0.21877696,0.13547865,-0.26403126,-0.083555296),vec4(0.26552355,-0.008594905,-0.07662301,0.016003001),vec4(-0.28549454,-0.021579156,0.07743357,-0.24231866),vec4(-0.18768105,-0.20357254,-0.031987153,-0.2688294)) * bufB[6] + mat4(vec4(0.011156198,0.14188118,0.24724673,-0.31700248),vec4(0.021555427,0.20004539,0.113751076,-0.23807062),vec4(-0.071629375,-0.16936943,0.22947638,0.05298625),vec4(0.15926586,-0.07837134,0.2945314,-0.09932657)) * bufB[7] + mat4(vec4(0.01763492,-0.25467095,0.569732,0.16996588),vec4(-0.1796189,-0.05026849,-0.33367476,-0.2859437),vec4(0.03505761,-0.044110946,-0.09204744,0.14105646),vec4(0.39223182,-0.14726685,-0.20807563,0.05389863)) * bufB[8] + mat4(vec4(0.14170583,0.0016184805,0.15911813,0.24587795),vec4(0.09121787,-0.21826291,-0.10387591,0.020611044),vec4(-0.25442895,0.25077733,-0.16335678,-0.09709767),vec4(0.15198378,0.25850475,-0.12636285,0.07388154)) * bufB[9] + mat4(vec4(0.35872528,-0.28243652,-0.055406865,0.37726226),vec4(0.10418628,-0.45628273,0.028412197,0.46112907),vec4(0.028228078,-0.2376191,-0.31058624,-0.050460737),vec4(-0.268409,-0.032908075,-0.20123206,0.013120279)) * bufB[10] + mat4(vec4(-0.30101776,0.08884026,-0.08604741,-0.040155437),vec4(-0.1523513,-0.09666816,0.06521591,-0.045113437),vec4(-0.15978752,0.034947064,0.21370648,0.06408491),vec4(-0.16043052,0.25052407,0.041667752,-0.11816964)) * bufB[11];\nbufA[1] = vec4(0.25685298,0.036472034,-0.048398923,0.039836254) + mat4(vec4(0.29105133,-0.39556924,0.34266907,-0.20226295),vec4(0.25678658,-0.16035405,0.23027694,0.017324915),vec4(0.4412056,-0.24747375,-0.017130993,0.11995906),vec4(-0.027450051,-0.030897023,0.08618415,0.17653638)) * bufB[0] + mat4(vec4(-0.026093693,-0.097748764,-0.098728195,0.26596856),vec4(-0.030479146,-0.31444758,0.3233926,0.2101622),vec4(-0.26234138,0.00078176596,-0.087337755,0.07555664),vec4(-0.23864447,-0.077572554,0.18498982,0.16786863)) * bufB[1] + mat4(vec4(0.017360818,0.02043594,0.049093883,-0.23351942),vec4(-0.14575967,-0.3058091,0.15831137,-0.04483436),vec4(0.33730403,0.040908854,-0.06747099,-0.30600157),vec4(-0.023095736,-0.16141231,-0.11270882,0.07816999)) * bufB[2] + mat4(vec4(-0.011296313,-0.074960686,0.23687181,-0.12911545),vec4(0.062362663,0.17451037,-0.11646079,0.08818874),vec4(0.06908955,-0.06672858,0.047798105,-0.0032445798),vec4(0.3188589,-0.22402743,0.12751545,-0.28072432)) * bufB[3] + mat4(vec4(-0.084433824,-0.040415168,0.22798318,-0.21708739),vec4(-0.06413354,0.089533746,0.12825036,0.3255143),vec4(-0.044308487,0.14317222,-0.22531754,0.100348495),vec4(0.014748524,0.1841395,-0.13881522,0.061898053)) * bufB[4] + mat4(vec4(0.006728596,0.038260695,-0.12311967,-0.2150594),vec4(-0.17691989,0.0012706781,-0.34406057,0.28696972),vec4(0.15746993,-0.1368771,0.11772994,-0.051916044),vec4(0.117094785,0.19697027,-0.0064524766,0.10711951)) * bufB[5] + mat4(vec4(-0.39719793,-0.023861898,0.028537571,0.14047205),vec4(0.056384142,-0.02410098,-0.24418232,-0.25027844),vec4(-0.40736318,0.09338378,-0.3110493,0.14535613),vec4(-0.10696563,0.10547493,-0.15226318,0.10827601)) * bufB[6] + mat4(vec4(0.28013867,0.010758501,0.0458137,-0.2876167),vec4(-0.18482876,0.084167525,0.19699734,0.0026195822),vec4(-0.15461357,-0.124218866,-0.07923059,-0.050289907),vec4(0.035194773,-0.17866045,0.07350424,0.22622155)) * bufB[7] + mat4(vec4(-0.14841188,0.1504136,0.114118926,0.18803462),vec4(-0.21053512,-0.018800667,-0.49187455,-0.1285901),vec4(0.054178055,-0.01930319,0.20979251,0.096752584),vec4(-0.39852405,0.177099,0.026788756,-0.38667396)) * bufB[8] + mat4(vec4(-0.25728193,-0.04311868,0.089535736,-0.022147533),vec4(-0.19441675,-0.0028397932,-0.039697066,-0.28069946),vec4(0.27040118,0.10670636,0.3081677,0.07791789),vec4(0.0967779,0.062137887,0.23676513,-0.0704398)) * bufB[9] + mat4(vec4(-0.08839985,-0.4404702,0.4828132,0.4777876),vec4(-0.07405056,-0.46345767,0.031246824,0.15664957),vec4(-0.12561557,-0.119577006,-0.17491688,-0.028367411),vec4(0.0029785957,0.60787565,-0.048462253,0.12268995)) * bufB[10] + mat4(vec4(-0.030224126,0.117826216,-0.18269104,0.00010918372),vec4(0.003664699,0.07595533,-0.1049501,0.11193703),vec4(-0.11171398,0.05545157,-0.0138913505,-0.01854458),vec4(-0.15462454,0.20766349,-0.20428367,-0.017421195)) * bufB[11];\nbufA[2] = vec4(0.2039022,-0.12709604,0.24724853,-0.4764764) + mat4(vec4(0.101172194,-0.24992123,0.14689897,-0.33111584),vec4(-0.16431369,0.18376775,-0.19003858,0.20411974),vec4(-0.032982685,0.25327492,-0.14402716,-0.23648873),vec4(-0.16799359,-0.13477999,-0.008012513,0.003576016)) * bufB[0] + mat4(vec4(0.2370501,0.18189387,0.19874406,0.2654367),vec4(-0.0625601,-0.091049805,-0.14316076,0.064330496),vec4(-0.07607848,0.23464352,-0.20478395,0.15949),vec4(-0.059477974,0.07216557,0.15678896,-0.030014602)) * bufB[1] + mat4(vec4(0.048454165,0.289497,0.24921855,-0.053749073),vec4(-0.33741552,-0.1357035,-0.14430605,0.115153216),vec4(0.19451419,-0.35879385,-0.040090755,-0.33044297),vec4(0.047788996,-0.07252946,0.015198808,-0.075064145)) * bufB[2] + mat4(vec4(-0.07908038,-0.17853637,0.05299421,-0.37866205),vec4(-0.084103204,-0.15580036,-0.22465393,0.35496667),vec4(0.019938143,0.078846134,0.07801712,-0.11647781),vec4(-0.63202673,-0.20714754,0.14608361,-0.013177708)) * bufB[3] + mat4(vec4(0.24794492,-0.1532539,-0.45786065,-0.06752717),vec4(0.038277764,0.029167535,-0.44188192,0.07467327),vec4(-0.18206684,0.043237433,-0.28842017,0.22625591),vec4(0.23773666,-0.09227153,-0.34414208,0.008075761)) * bufB[4] + mat4(vec4(-0.07813444,-0.044199456,-0.21489437,-0.006505201),vec4(-0.054567285,-0.28087205,0.08078356,-0.15066423),vec4(0.076434955,0.2907663,0.0966502,0.18955694),vec4(0.37009072,0.063108705,0.051774558,0.022473972)) * bufB[5] + mat4(vec4(0.2242952,0.13009077,0.19798945,0.15022776),vec4(-0.34211355,0.2439811,-0.33470225,-0.064721644),vec4(0.080718875,-0.2771363,-0.06390913,0.045843873),vec4(-0.086546324,-0.1993424,0.1440338,0.16351421)) * bufB[6] + mat4(vec4(-0.059119474,0.055843588,-0.2352244,0.21765883),vec4(0.20703162,-0.18361829,0.0051086606,-0.13215406),vec4(0.040150166,0.1411586,-0.19868855,0.2515005),vec4(0.18137605,-0.13724001,0.18870056,-0.09501041)) * bufB[7] + mat4(vec4(-0.34180608,0.13391192,0.05385726,-0.032461368),vec4(-0.17974772,-0.31300598,-0.330041,-0.029405925),vec4(0.17059688,0.26694307,0.13847642,0.021757955),vec4(-0.009153929,-0.27473015,0.074500486,-0.29023808)) * bufB[8] + mat4(vec4(0.14152496,-0.33472908,0.13440184,-0.33900365),vec4(0.046323843,-0.03630546,-0.09228732,-0.1747884),vec4(0.14322315,-0.06691594,-0.101127565,0.031041922),vec4(0.27889395,0.053794816,-0.10902433,-0.13708672)) * bufB[9] + mat4(vec4(-0.11458009,0.13516046,0.11711683,-0.15777738),vec4(0.28987044,0.20429087,0.08245575,-0.05830758),vec4(0.17531128,-0.10419703,0.0076265815,-0.08503929),vec4(0.06086583,-0.022281995,-0.2973251,-0.009942864)) * bufB[10] + mat4(vec4(0.11591178,0.022497542,-0.057787836,0.052488662),vec4(-0.1419049,0.20663486,-0.11227217,0.14650486),vec4(0.014908083,-0.229615,0.10932034,-0.1439775),vec4(-0.14569008,0.24419378,0.22526616,0.16607037)) * bufB[11];\nbufA[3] = vec4(-0.2804913,-0.17446408,0.19323666,-0.011656925) + mat4(vec4(0.3717709,-0.2933159,0.1393895,-0.0014249532),vec4(0.10061687,0.19808355,0.13552369,-0.16936313),vec4(0.42219907,-0.053993065,0.07518685,-0.22432503),vec4(0.06714503,-0.09123063,0.09182013,-0.03781739)) * bufB[0] + mat4(vec4(-0.24596037,0.26777083,-0.0035302301,-0.045126073),vec4(0.1231035,0.32662836,-0.024766723,-0.20218877),vec4(-0.20164905,-0.08996156,-0.16856857,0.28588787),vec4(0.27738214,0.16198671,0.05680222,-0.1348902)) * bufB[1] + mat4(vec4(0.06965756,-0.041558903,-0.16880299,0.23905604),vec4(-0.02072103,-0.25586608,0.18692915,-0.40986052),vec4(0.47847283,-0.051800143,0.029134061,0.09486243),vec4(-0.19643809,0.33780348,-0.045345355,0.1645601)) * bufB[2] + mat4(vec4(0.33149812,-0.032802522,-0.22980559,-0.2923214),vec4(0.21895654,-0.0037365903,-0.3321835,-0.09484498),vec4(-0.16117278,-0.17102598,0.25697297,0.3659623),vec4(-0.11587458,-0.038646597,-0.059516523,0.26135385)) * bufB[3] + mat4(vec4(0.19806182,-0.21293736,-0.42250437,-0.13867024),vec4(-0.16122936,0.005863744,0.07711553,-0.028786298),vec4(0.22829355,0.22064485,-0.15162718,-0.20842205),vec4(0.12642048,0.15652785,0.011799167,0.20068763)) * bufB[4] + mat4(vec4(0.028236369,-0.2506481,0.3019582,-0.017331863),vec4(-0.21449019,-0.28486896,-0.16219962,0.008370039),vec4(-0.18452942,-0.21768054,-0.07331055,-0.16483888),vec4(-0.28967938,-0.05746658,0.19245234,-0.33327207)) * bufB[5] + mat4(vec4(-0.10414685,-0.27814335,-0.31419522,0.07781549),vec4(-0.14086193,-0.03515324,-0.07642573,0.33925784),vec4(0.07069919,0.3387269,-0.15338893,0.33236516),vec4(0.1728095,0.054332577,-0.108605735,0.10413963)) * bufB[6] + mat4(vec4(-0.024765098,0.10717384,0.0798515,0.23697534),vec4(-0.08208741,-0.16092074,0.08604656,-0.1957826),vec4(-0.17895603,0.08223686,-0.37042442,0.09610679),vec4(0.090591796,-0.077626884,-0.1164481,-0.12092169)) * bufB[7] + mat4(vec4(-0.01992801,-0.20200507,0.22193293,-0.04486737),vec4(0.021223137,0.469246,0.16736013,-0.1867422),vec4(0.069533154,0.026822558,0.049514085,-0.049039047),vec4(0.19727048,0.17174785,0.15011658,-0.23135282)) * bufB[8] + mat4(vec4(0.14949332,0.042980812,-0.14928676,-0.042689633),vec4(0.20591655,-0.19264847,0.04278928,-0.10254436),vec4(-0.07491168,0.056351736,-0.051232398,-0.14875586),vec4(-0.06976317,0.2199498,0.17054358,-0.055579007)) * bufB[9] + mat4(vec4(-0.15129462,-0.19364941,0.2703971,-0.38710243),vec4(0.01799635,0.033666868,0.04978363,-0.0033272002),vec4(-0.16199976,-0.43818542,-0.067444235,0.0967774),vec4(-0.07601706,-0.17908187,-0.030873964,0.11209351)) * bufB[10] + mat4(vec4(0.07134031,0.1340224,-0.08314295,0.0060287747),vec4(0.1317604,0.022386871,0.06952625,0.29639697),vec4(0.05503677,-0.120582566,0.028999701,0.30472857),vec4(-0.21874215,-0.07401596,0.115271516,-0.028531449)) * bufB[11];\nbufA[4] = vec4(-0.4009421,-0.06723514,0.11684886,-0.13431011) + mat4(vec4(0.22225466,-0.36393917,-0.1351269,0.06947388),vec4(-0.0026860805,0.03641526,0.18888624,0.04936424),vec4(0.10777743,0.13168405,0.18498407,0.1317176),vec4(0.024436085,-0.21817997,0.2690291,0.02097287)) * bufB[0] + mat4(vec4(-0.030653082,0.08409867,0.111348145,0.12601274),vec4(0.05504848,-0.042783264,-0.12752295,0.06490764),vec4(-0.083921924,0.1312364,0.30642304,-0.11136061),vec4(-0.13373399,0.077568196,-0.11006157,0.305706)) * bufB[1] + mat4(vec4(-0.224301,0.20014597,-0.021051466,-0.10299477),vec4(0.16331284,-0.032766167,-0.15669945,0.05099724),vec4(0.28418145,0.10227079,-0.22043958,-0.3890869),vec4(-0.045877595,-0.045011032,0.36496022,-0.34979516)) * bufB[2] + mat4(vec4(-0.087478235,-0.177953,-0.18078177,-0.13383344),vec4(0.2209169,0.08194958,-0.22235432,0.41716808),vec4(0.050637797,0.28019276,0.015027665,-0.23604926),vec4(-0.24247268,-0.096301764,-0.086175576,-0.25795475)) * bufB[3] + mat4(vec4(0.0848152,0.11343047,0.0149037335,0.1187297),vec4(-0.084471114,0.16251417,-0.052764527,-0.28065658),vec4(0.13967177,-0.2548978,-0.0094202645,-0.035171643),vec4(-0.120160446,0.2348515,0.25275138,-0.18048018)) * bufB[4] + mat4(vec4(-0.075284995,-0.086076155,0.014124924,0.01855692),vec4(-0.110022336,0.06160619,-0.084349595,0.10974847),vec4(-0.2167211,0.15709902,0.09022073,-0.12619175),vec4(-0.06556848,-0.075243294,0.15029566,0.17111167)) * bufB[5] + mat4(vec4(0.17205058,9.662192e-05,0.027079996,0.09432717),vec4(-0.05585937,-0.12127965,-0.2350115,-0.18715389),vec4(-0.1297381,0.28826514,0.03841234,0.09603296),vec4(0.056593016,-0.23545347,-0.25360513,-0.05693265)) * bufB[6] + mat4(vec4(0.027084831,-0.02076537,0.07685357,-0.2881205),vec4(-0.078218736,-0.07680639,0.12593654,-0.12184545),vec4(0.18797715,-0.053776722,-0.02620323,0.14491704),vec4(-0.28391448,-0.0062992787,0.09963093,0.10100056)) * bufB[7] + mat4(vec4(0.07618985,-0.1000477,-0.2211708,0.085496664),vec4(0.2345687,0.003404677,0.0007032175,0.44843635),vec4(0.1572993,-0.1133293,0.2669518,-0.16859385),vec4(-0.11639332,-0.23187311,0.106005,-0.033910476)) * bufB[8] + mat4(vec4(0.1787875,0.16718668,-0.046245076,0.1937442),vec4(0.24161802,0.13015667,-0.039407436,0.40878963),vec4(-0.06174672,-0.1825192,0.0020066644,-0.07495896),vec4(0.11408901,-0.0536297,-0.0020596273,0.17267983)) * bufB[9] + mat4(vec4(-0.18838204,-0.013365713,0.1631801,-0.10717234),vec4(0.22883788,0.16511811,-0.1631999,0.05932295),vec4(-0.22787005,-0.019317998,0.012224529,-0.100599825),vec4(0.15407252,-0.34890825,-0.17390019,-0.010243774)) * bufB[10] + mat4(vec4(0.24901894,0.2981571,-0.0850264,0.27900857),vec4(0.2819928,0.014453658,-0.13563424,0.31571925),vec4(0.3720556,-0.0034672106,-0.19726606,-0.019055493),vec4(0.13761501,-0.0762868,-0.21652263,0.0844805)) * bufB[11];\nbufA[5] = vec4(0.32019037,-0.38876602,-0.20303312,-0.22779638) + mat4(vec4(0.07261045,0.17385952,0.3469655,-0.04256551),vec4(-0.027630094,0.08021475,-0.057961743,0.062982805),vec4(0.38083228,-0.00057962467,0.29205632,-0.06040062),vec4(0.020370374,-0.05941666,-0.013110795,0.13769332)) * bufB[0] + mat4(vec4(-0.055316903,-0.26256147,-0.046573617,-0.17411852),vec4(-0.19020642,0.00057359925,-0.09200375,-0.32779583),vec4(0.07585367,-0.21205333,0.02309434,0.016625265),vec4(-0.43460897,-0.03220904,0.02201538,0.20514917)) * bufB[1] + mat4(vec4(0.15254612,-0.025074385,-0.11854563,-0.18051082),vec4(-0.016366297,0.1801156,0.0406807,-0.20251918),vec4(-0.26645043,0.10708844,-0.03666653,-0.052597664),vec4(0.3843477,-0.038848452,0.07061566,-0.05025706)) * bufB[2] + mat4(vec4(-0.2060047,-0.005584074,0.03533058,-0.094277985),vec4(0.162216,0.15838115,-0.17990667,0.21379252),vec4(0.23717238,-0.05175066,-0.20917353,-0.090059035),vec4(0.29067692,0.5595159,0.19346282,-0.11793953)) * bufB[3] + mat4(vec4(-0.18186188,0.15556417,-0.2912834,0.18943124),vec4(-0.16459413,0.16324027,0.034425225,0.10800765),vec4(0.019385442,0.073049955,0.007575302,0.22095639),vec4(0.17263693,-0.13230033,-0.116828635,-0.13047634)) * bufB[4] + mat4(vec4(0.0709179,0.29797754,-0.33517018,-0.12334292),vec4(-0.026336111,0.1347062,0.036095273,-0.267656),vec4(0.36224777,-0.07934509,-0.045695044,0.36288348),vec4(0.30008596,-0.12659948,0.14506465,-0.15414622)) * bufB[5] + mat4(vec4(0.011703474,0.3114127,0.18399526,-0.12881184),vec4(-0.12416403,-0.28740442,0.16076134,-0.0415218),vec4(0.031695407,0.23581785,0.004417332,-0.20940664),vec4(-0.09660925,0.14089607,-0.064734146,0.076106705)) * bufB[6] + mat4(vec4(0.029110095,-0.06838642,0.19057205,-0.15882471),vec4(0.0023614296,0.061609656,-0.043381833,-0.008287388),vec4(0.35198256,-0.21715368,0.0036959907,0.24731477),vec4(-0.046720672,-0.110709384,-0.11778261,0.09831968)) * bufB[7] + mat4(vec4(0.08748954,0.06501986,-0.11918809,0.10277774),vec4(-0.18397322,-0.09693098,-0.21703993,-0.38391536),vec4(0.14870597,-0.15520214,0.39318106,0.15909302),vec4(-0.12304456,-0.26756382,-0.2252986,0.10357379)) * bufB[8] + mat4(vec4(-0.11880144,0.009683211,-0.010984352,0.13515976),vec4(0.09973293,-0.31594908,0.12838867,-0.17235601),vec4(-0.2279434,0.066225216,-0.054187547,0.19382116),vec4(0.0046811495,0.009366532,-0.1269963,-0.21191104)) * bufB[9] + mat4(vec4(0.043271154,0.04633356,-0.12953092,0.29667315),vec4(0.056769554,0.10146302,-0.0056501967,0.17373842),vec4(0.14102359,-0.23934524,0.16327925,0.14576647),vec4(0.004462183,0.1265393,-0.31119674,-0.11621066)) * bufB[10] + mat4(vec4(0.0073960493,-0.23269337,-0.08771677,0.28832263),vec4(0.13227387,0.052642275,0.015822008,0.017941985),vec4(-0.17822503,0.17455687,0.015481809,-0.050198566),vec4(-0.12880507,0.05907114,-0.055622865,0.0060347905)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(0.34682742,0.45770803,0.46811846,-0.19507909) + mat4(vec4(0.03018875,0.3221244,0.064712696,-0.09711969),vec4(0.12501997,-0.02470575,-0.25911206,-0.2888825),vec4(0.014438868,0.31109145,0.038740966,-0.2594554),vec4(0.07598454,0.20300184,0.21702304,-0.32614422)) * bufB[0] + mat4(vec4(0.024917178,0.26128325,-0.13316624,-0.105123535),vec4(-0.1436887,-0.092887625,-0.11177067,0.17201091),vec4(0.22419891,-0.18643765,0.26953956,-0.046660468),vec4(0.043256592,0.110844545,-0.024082324,0.03894271)) * bufB[1] + mat4(vec4(-0.24486892,-0.15032093,-0.31899488,0.122617796),vec4(-0.15579525,-0.036740605,-0.15193175,-0.32367924),vec4(0.025346726,-0.16991732,-0.094350405,-0.024335366),vec4(-0.1329169,0.033747926,0.09970624,-0.16025321)) * bufB[2] + mat4(vec4(0.1093888,-0.1742866,-0.068332404,0.06087186),vec4(-0.39571133,0.27218732,0.19597827,-0.024801211),vec4(-0.059135754,0.083716504,0.31219065,0.18401292),vec4(0.14042851,-0.20661345,-0.07055087,-0.10278144)) * bufB[3] + mat4(vec4(-0.22740908,-0.097536236,-0.27511963,0.12556098),vec4(-0.22075437,0.03564529,-0.09444704,0.020263355),vec4(-0.25434166,0.25121212,0.47162846,-0.15116769),vec4(-0.1110192,-0.07641172,-0.22898851,-0.20687398)) * bufB[4] + mat4(vec4(-0.2343248,-0.1621757,0.19432192,0.05642043),vec4(0.23848455,-0.17244586,0.113374405,-0.20020682),vec4(0.028757948,-0.18884206,-0.027752127,0.051825326),vec4(0.08106325,0.34796658,-0.3132166,0.020851463)) * bufB[5] + mat4(vec4(0.02719877,-0.2518807,0.05739141,0.23442233),vec4(-0.09079759,0.014908559,-0.08615766,-0.14176221),vec4(-0.00829785,-0.19068629,0.09977418,0.05390317),vec4(-0.13418746,-0.08995979,-0.06997579,-0.21710025)) * bufB[6] + mat4(vec4(-0.09340127,0.045542754,0.14986286,-0.074720755),vec4(-0.028545555,0.043927252,0.13421468,-0.14406447),vec4(0.06424917,0.12180066,0.24718432,0.16400442),vec4(-0.2020774,0.29013437,0.06288987,0.034423195)) * bufB[7] + mat4(vec4(-0.09191293,0.17562653,-0.27440992,-0.14040965),vec4(0.19490752,-0.01912476,-0.1662648,0.17227766),vec4(-0.16260351,0.22291641,-0.12213061,0.17341879),vec4(0.04931654,-0.03672048,0.072859116,0.3190338)) * bufB[8] + mat4(vec4(-0.2620006,0.00047663058,-0.1607649,0.2133305),vec4(-0.036087833,0.16931373,-0.14515406,0.27956712),vec4(-0.22945696,0.10998186,0.46851683,0.036192387),vec4(-0.27057305,0.4394136,0.03033683,0.20423755)) * bufB[9] + mat4(vec4(0.22349593,-0.18767093,-0.1387329,-0.14241263),vec4(0.02443035,0.006285293,-0.093864165,-0.0042381645),vec4(0.22444536,-0.19493419,-0.10359044,0.36059386),vec4(-0.22945827,0.28916463,0.008546318,0.14679278)) * bufB[10] + mat4(vec4(0.21248038,-0.270597,-0.2924641,0.35319728),vec4(-0.2433052,-0.0412754,-0.17607833,0.3410985),vec4(0.16779429,0.1236248,0.080205545,-0.0075953067),vec4(0.04158185,0.05427111,0.21990395,-0.27475947)) * bufB[11];\nbufA[1] = vec4(-0.11609643,-0.06357409,0.20919506,0.5689738) + mat4(vec4(0.022438038,-0.24375613,0.038176186,-0.021315102),vec4(0.061359167,0.07575486,-0.0481885,0.043961097),vec4(0.10977382,0.012310135,-0.18918909,0.32418972),vec4(0.115481086,-0.045736343,0.005876939,-0.23314334)) * bufB[0] + mat4(vec4(-0.059772406,0.00010136323,-0.214856,-0.06903869),vec4(-0.08940905,-0.33891672,0.4511728,0.26985186),vec4(-0.33849525,-0.3083402,0.0028772396,0.050971914),vec4(-0.2654775,0.011368322,-0.20710474,0.41354385)) * bufB[1] + mat4(vec4(-0.46011743,-0.11840763,0.14555985,0.25878444),vec4(0.21468255,-0.019839153,-0.08434358,0.19858806),vec4(-0.12923828,0.31256813,-0.08787762,-0.23695952),vec4(-0.0054224376,0.1460042,-0.049280725,-0.13414982)) * bufB[2] + mat4(vec4(-0.40106735,-0.28287333,0.03878551,-0.16191648),vec4(-0.13564779,0.09677641,0.38513398,-0.38744017),vec4(-0.05694232,-0.21151575,-0.061852764,-0.13331583),vec4(0.08189319,0.32441834,0.20891026,0.10930519)) * bufB[3] + mat4(vec4(0.016760644,0.37590477,-0.10738883,-0.024556918),vec4(0.21677147,0.019899603,0.08573695,0.04214058),vec4(-0.054637667,-0.24139313,0.33723143,0.114800885),vec4(-0.020812847,-0.07187859,-0.1681485,-0.12617983)) * bufB[4] + mat4(vec4(-0.09731129,0.18284743,0.20297386,0.046341162),vec4(-0.54261655,0.016098287,-0.1948796,0.08438243),vec4(-0.22968869,-0.0619656,-0.23648512,-0.21586889),vec4(-0.12612566,-0.19680692,-0.18304156,0.47305697)) * bufB[5] + mat4(vec4(-0.27503356,-0.19185261,0.060709026,0.08363169),vec4(0.34711766,0.061579153,0.0007416301,0.040499214),vec4(-0.09831999,-0.049679827,0.107115544,0.2109173),vec4(-0.20413719,0.12558486,-0.21871391,0.0011401818)) * bufB[6] + mat4(vec4(0.0280391,-0.0508458,-0.06174469,-0.10821569),vec4(0.04425185,-0.17630152,0.010023313,0.0152485715),vec4(-0.02143263,0.26289704,-0.13001786,0.03557674),vec4(0.08735304,-0.28745934,-0.016057195,0.11683718)) * bufB[7] + mat4(vec4(0.1714391,-0.17219034,-0.11899603,0.09568817),vec4(-0.1029426,-0.070127755,0.20238073,0.06433719),vec4(0.11767415,-0.022831392,0.026291408,-0.09670499),vec4(0.05410939,-0.29432702,0.3824992,0.17238688)) * bufB[8] + mat4(vec4(-0.051334206,0.15780489,0.12619175,0.08243813),vec4(0.20553738,0.333276,-0.044163026,-0.15622556),vec4(0.0022553867,-0.16306882,0.19366005,0.115937024),vec4(0.43969,-0.29206008,0.39720684,0.012011767)) * bufB[9] + mat4(vec4(-0.25914687,-0.041802607,0.049596515,0.13746518),vec4(0.22673742,0.20379035,0.3314447,0.13344736),vec4(-0.1053624,-0.15069358,-0.16260286,0.030725475),vec4(0.04846554,-0.10985619,0.10373692,0.02143744)) * bufB[10] + mat4(vec4(-0.01447188,0.08957686,-0.058463316,0.16322948),vec4(0.21777892,-0.29656884,-0.016900646,0.11989616),vec4(-0.18197945,0.058398787,-0.1618277,0.15261012),vec4(0.22238699,-0.06673278,-0.19221476,-0.2606267)) * bufB[11];\nbufA[2] = vec4(-0.4415897,-0.5554047,0.101479344,-0.29093513) + mat4(vec4(-0.09747547,-0.27822837,-0.097532645,-0.22606845),vec4(0.0029333767,-0.04723112,-0.17388813,0.06412816),vec4(0.29410228,0.009219076,-0.20206423,-0.015075999),vec4(0.22262721,-0.4064053,-0.15923153,-0.17665403)) * bufB[0] + mat4(vec4(0.41392952,0.15122908,0.08448234,-0.025120217),vec4(-0.029203732,0.21795155,0.01928056,0.23780815),vec4(0.045916084,0.16609067,-0.050745506,0.21570314),vec4(-0.31531206,-0.048603646,-0.027787581,-0.09222889)) * bufB[1] + mat4(vec4(-0.26376027,-0.17743671,0.19613576,0.113216564),vec4(0.09504482,-0.14717051,0.23771723,-0.1413229),vec4(-0.0043995143,0.13480872,-0.042100713,-0.025228163),vec4(-0.046883564,0.2633809,0.17219979,0.23755686)) * bufB[2] + mat4(vec4(0.28999195,0.22091001,-0.14868739,0.07119734),vec4(0.10224232,0.27296397,-0.5419772,0.23467362),vec4(0.17787088,0.08416102,0.12839983,-0.123322725),vec4(0.20562789,-0.33377978,-0.04501168,-0.37280595)) * bufB[3] + mat4(vec4(-0.021274567,-0.08556468,-0.31672677,-0.12684706),vec4(-0.26632848,-0.06454305,-0.25198328,0.209935),vec4(-0.19057761,0.109066114,-0.04985588,-0.021947114),vec4(0.036809493,0.25958332,-0.14585973,-0.09613321)) * bufB[4] + mat4(vec4(-0.20609689,-0.11772359,-0.13473181,-0.11165669),vec4(0.055669837,0.25665542,0.24284904,-0.078939766),vec4(-0.03181745,-0.42049214,-0.079855904,-0.06512132),vec4(-0.06176773,0.091143385,-0.1688729,0.3010908)) * bufB[5] + mat4(vec4(0.113163896,-0.25611627,0.09087539,0.13026439),vec4(-0.21231525,-0.1969739,-0.06977314,0.08435654),vec4(-0.33282787,0.09294794,0.045618072,0.27252185),vec4(-0.24380955,-0.25143594,-0.022918547,0.19647855)) * bufB[6] + mat4(vec4(-0.121746756,0.1565783,-0.027779926,-0.07793061),vec4(0.09617144,-0.3437982,-0.04952018,-0.30436665),vec4(0.043169122,0.139822,0.087697156,-0.32482886),vec4(-0.1659608,-0.12803033,0.121930994,0.029268974)) * bufB[7] + mat4(vec4(-0.11259705,-0.19318768,0.17769177,-0.035074785),vec4(0.3275734,0.4170947,-0.15329596,-0.24035814),vec4(-0.08473799,0.04167126,-0.08859726,-0.13811296),vec4(0.16720645,-0.12089555,-0.23187406,-0.066432945)) * bufB[8] + mat4(vec4(-0.021261774,-0.01797903,0.08086004,0.12928596),vec4(-0.122090705,0.10961144,-0.20728487,0.009932552),vec4(0.052758645,-0.07396639,0.090349965,0.14694835),vec4(0.13235186,-0.23600605,0.029680893,-0.0731654)) * bufB[9] + mat4(vec4(-0.19709416,-0.06616212,-0.06560037,-0.61014044),vec4(0.05695839,-0.040208694,0.053443126,-0.05511826),vec4(0.27965382,-0.22649074,-0.00027597928,-0.27701256),vec4(0.053967293,0.085815586,0.071147054,-0.025645684)) * bufB[10] + mat4(vec4(0.33401576,0.23838468,0.1940393,0.14325118),vec4(0.15017559,-0.21909924,0.21118549,-0.009689921),vec4(-0.05329862,0.1661543,0.1152371,0.29851168),vec4(-0.34201372,0.13167791,0.14781843,-0.09322207)) * bufB[11];\nbufA[3] = vec4(0.33491874,0.044944234,-0.14848416,-0.32635048) + mat4(vec4(-0.08885337,0.14143716,-0.20152098,-0.44316557),vec4(-0.008774845,0.104131386,0.15982006,0.20026274),vec4(0.014217746,0.0018627364,0.19328626,-0.050618213),vec4(-0.0030827126,-0.35272294,-0.30280346,-0.22382782)) * bufB[0] + mat4(vec4(0.056551106,0.1500405,-0.019096479,-0.21643806),vec4(-0.13245173,0.18200637,0.061390985,-0.13272567),vec4(-0.1045162,-0.077003926,0.0973585,-0.1835048),vec4(-0.185891,0.12603892,0.027601874,0.1441591)) * bufB[1] + mat4(vec4(-0.13793635,-0.020295547,0.1517317,0.12912603),vec4(0.15045899,-0.11052888,0.06925366,-0.44447514),vec4(0.23893201,0.17268965,-0.0992135,0.06187017),vec4(0.041666478,0.13879322,-0.012607779,0.25323725)) * bufB[2] + mat4(vec4(0.061894834,0.10247958,0.08916787,-0.031627417),vec4(-0.07898356,0.24507903,0.3283465,-0.006217776),vec4(0.19154628,-0.26362884,-0.113448925,-0.5839384),vec4(-0.078309156,-0.064542666,-0.003369272,0.23372212)) * bufB[3] + mat4(vec4(-0.23807156,-0.18527706,-0.09155648,0.111955814),vec4(-0.27043357,0.07577679,0.38702616,0.1870645),vec4(-0.011968172,0.051752936,-0.08076017,0.058056083),vec4(-0.3888805,-0.3051375,-0.043530338,-0.00039687392)) * bufB[4] + mat4(vec4(-0.09780792,0.07253611,-0.14260373,0.009044916),vec4(0.11333391,-0.20050548,-0.18380648,0.31834427),vec4(0.08519857,0.2820581,-0.24180599,-0.010951782),vec4(0.022831688,0.4756361,-0.38202026,-0.4937366)) * bufB[5] + mat4(vec4(-0.14413309,0.10468313,-0.029151345,0.2580918),vec4(-0.19545418,0.13810962,-0.0036750482,0.04509712),vec4(0.07733899,0.09310148,-0.11242715,0.14543249),vec4(-0.046765428,0.19703653,0.020026082,-0.20716545)) * bufB[6] + mat4(vec4(0.17845097,-0.21222456,0.3245531,0.21882948),vec4(-0.42906058,-0.17354625,-0.12734748,-0.09122039),vec4(-0.26183492,-0.70449007,0.09773177,-0.0440534),vec4(-0.011508421,0.21438281,0.16531809,-0.1623579)) * bufB[7] + mat4(vec4(0.016816193,0.0897461,-0.06378801,-0.068445474),vec4(0.19118924,0.115395874,0.30721208,0.09377789),vec4(0.18827625,-0.09329135,-0.3110404,-0.052984755),vec4(0.33144465,-0.3051167,-0.3274018,0.52480984)) * bufB[8] + mat4(vec4(0.3471436,0.17102353,-0.36314863,-0.25742832),vec4(0.052559927,-0.06884841,0.27972248,-0.10451027),vec4(-0.26188272,0.09881689,-0.039347276,-0.03674516),vec4(0.03476895,0.10906669,0.029209998,0.08549031)) * bufB[9] + mat4(vec4(0.0047088475,-0.22673826,-0.002826845,-0.11069769),vec4(0.31332463,-0.0003962724,-0.09225599,-0.06423671),vec4(-0.18421498,0.0772771,-0.13037233,0.18856852),vec4(0.34372127,-0.073314026,0.0846948,-0.19903411)) * bufB[10] + mat4(vec4(0.09627885,0.26481158,0.33813915,-0.09041857),vec4(-0.23608816,-0.1631172,-0.04729709,-0.15420014),vec4(-0.15500556,-0.4020926,0.097844824,0.105887234),vec4(0.16957174,-0.22875458,-0.07967432,-0.057559285)) * bufB[11];\nbufA[4] = vec4(0.030515384,0.5319401,-0.29855177,-0.23596191) + mat4(vec4(-0.08595825,0.030488342,-0.08691276,-0.23233008),vec4(0.06210118,-0.18635517,-0.2863457,-0.15556145),vec4(0.139341,0.03199358,0.21026568,0.41988412),vec4(-0.32944232,0.0762656,-0.34192684,-0.013446756)) * bufB[0] + mat4(vec4(-0.06756502,-0.061059948,-0.017821224,0.05949455),vec4(0.5153872,-0.14082992,0.110809736,0.22522491),vec4(0.17070125,0.2024138,-0.04985532,0.13604128),vec4(-0.1559397,-0.0041558817,0.25348735,0.36621195)) * bufB[1] + mat4(vec4(0.0060905074,-0.019826654,0.17550525,-0.21799935),vec4(-0.27113467,-0.4603008,-0.47020724,0.06966534),vec4(-0.018089062,0.17353646,0.019076811,0.26335883),vec4(-0.05413681,-0.25274163,-0.084900185,0.17046405)) * bufB[2] + mat4(vec4(-0.15803872,0.16452439,0.37926817,-0.35058594),vec4(-0.01199046,-0.22470462,-0.13022473,0.08284366),vec4(0.013783421,0.13206281,-0.22912617,0.06132971),vec4(0.009239957,-0.18234792,-0.32141653,0.009953179)) * bufB[3] + mat4(vec4(0.25071055,0.13679962,-0.066005826,0.10212238),vec4(0.02623145,0.008850086,-0.22495836,-0.016103711),vec4(-0.34981027,-0.41338485,0.1363951,0.018578367),vec4(0.13467707,0.13548529,0.18655373,0.6536167)) * bufB[4] + mat4(vec4(-0.1616803,-0.220894,-0.29262897,-0.15614498),vec4(0.026051199,0.0051559545,-0.0032618127,-0.13602282),vec4(-0.18689553,0.074310765,-0.15692139,-0.113055296),vec4(-0.49815705,0.0028223037,0.029364752,-0.2042862)) * bufB[5] + mat4(vec4(-0.06506669,0.1763833,0.14646812,-0.023225136),vec4(-0.031097842,-0.060568064,-0.16668957,-0.1587543),vec4(-0.049149804,-0.04947795,-0.15109569,0.14238529),vec4(0.022606708,0.13182636,-0.27379405,0.16841008)) * bufB[6] + mat4(vec4(-0.15247774,0.19436795,0.1548244,0.0688048),vec4(-0.15045367,0.13466644,-0.13872407,0.16482837),vec4(0.012726712,-0.101321325,-0.07481758,0.19807665),vec4(-0.080397576,0.16062318,-0.24824291,0.06068397)) * bufB[7] + mat4(vec4(-0.1148835,0.3470887,-0.055889923,-0.11525219),vec4(0.3013024,-0.03564116,0.42193446,-0.11506933),vec4(0.08537759,0.15478642,-0.02435083,-0.07080604),vec4(0.020265436,-0.20031072,-0.17219502,-0.08789952)) * bufB[8] + mat4(vec4(-0.13985312,0.22781107,0.08119784,-0.017079584),vec4(0.24389482,-0.09808136,-0.012340156,0.03151778),vec4(-0.18352416,0.42813045,0.07648092,0.2618085),vec4(-0.26350224,-0.05588373,-0.29937893,-0.20010746)) * bufB[9] + mat4(vec4(-0.3922284,0.031824373,-0.19280313,-0.11393826),vec4(0.13400863,-0.04520027,-0.07313882,0.09963155),vec4(0.037327174,0.0366353,0.27612415,0.09948319),vec4(0.015834633,-0.106762104,0.16066831,-0.00051683735)) * bufB[10] + mat4(vec4(0.16926134,-0.0631337,0.2259756,0.034805205),vec4(0.044195276,-0.15832996,-0.16870804,0.1823828),vec4(0.10668805,0.06709158,0.17307466,0.039003707),vec4(-0.11112319,0.25780645,0.13329414,-0.030811602)) * bufB[11];\nbufA[5] = vec4(0.33398262,0.0049092863,0.6044544,-0.03809499) + mat4(vec4(-0.31712207,0.33499628,-0.13749076,-0.5701151),vec4(0.17897825,0.002820289,0.01472522,0.18188685),vec4(0.13818145,-0.13479863,0.17833787,0.2080488),vec4(-0.3523054,0.12173087,-0.1251135,-0.34789285)) * bufB[0] + mat4(vec4(-0.13686936,-0.006479132,-0.119855136,-0.077313945),vec4(0.37339523,-0.01955093,0.17862558,0.0098628905),vec4(-0.1965627,-0.10395075,0.036606807,-0.028088173),vec4(0.15393522,0.2422341,-0.09060405,0.035998445)) * bufB[1] + mat4(vec4(-0.18887231,0.08793416,0.042559605,0.06851441),vec4(0.12986694,-0.043181702,-0.3560365,-0.18599632),vec4(0.03987876,0.21689728,0.27657437,-0.058931638),vec4(0.23513469,-0.08276961,-0.016136104,0.28143126)) * bufB[2] + mat4(vec4(-0.16834071,0.067346185,0.07464442,-0.061574634),vec4(0.069753624,-0.11582238,-0.07369721,0.47274193),vec4(-0.030056141,0.50925446,-0.36451358,-0.002424666),vec4(0.04400802,-0.28147653,0.198451,-0.063569784)) * bufB[3] + mat4(vec4(-0.08481972,-0.04973002,-0.07977904,0.15921846),vec4(-0.019469582,-0.20553172,-0.06307933,0.06654819),vec4(-0.0058355303,0.45503354,0.11615641,-0.085750416),vec4(0.13475507,0.06295997,-0.10003512,0.17860734)) * bufB[4] + mat4(vec4(-0.102388486,-0.058693487,-0.27174032,-0.19458714),vec4(0.039438277,0.056427427,0.089812964,0.08689009),vec4(-0.3777009,-0.08375322,-0.11059971,-0.26181236),vec4(0.20224668,-0.10475003,-0.002326267,-0.23237273)) * bufB[5] + mat4(vec4(-0.21696933,-0.13929546,-0.25994122,0.3873568),vec4(-0.495392,0.04863596,-0.13999166,-0.33900958),vec4(0.018536212,0.094679594,0.067196645,-0.33205056),vec4(-0.51934767,-0.12240069,-0.12182717,-0.3078049)) * bufB[6] + mat4(vec4(0.29237023,-0.006533401,0.05461885,0.20100378),vec4(0.09396636,-0.20569117,-0.21467552,-0.0333763),vec4(0.78504133,-0.19985993,-0.14716154,0.16342457),vec4(-0.5223576,0.07453239,-0.14138654,0.020652656)) * bufB[7] + mat4(vec4(-0.0528699,-0.17967853,-0.16918157,0.029940698),vec4(-0.13643782,-0.08277503,0.2535705,0.44155434),vec4(-0.25693834,-0.1253799,0.11539413,0.08835872),vec4(-0.2577487,0.057278875,-0.21877131,0.32607445)) * bufB[8] + mat4(vec4(0.14793779,0.06319773,0.077109784,0.0035847868),vec4(0.06630551,0.003629596,0.09438617,0.2466055),vec4(-0.236195,-0.06735064,0.09703587,-0.11767155),vec4(0.23911637,0.004843608,0.1253324,-0.10333884)) * bufB[9] + mat4(vec4(0.17590216,-0.17473839,-0.43199655,-0.101040795),vec4(0.022786515,0.07914167,-0.12062136,0.09958278),vec4(0.20800053,0.02844863,-0.25936604,0.15117227),vec4(0.14859729,0.000758297,0.087185755,-0.2351052)) * bufB[10] + mat4(vec4(0.1260747,0.06569548,0.114177935,0.071070164),vec4(0.056987673,0.043243293,-0.40543085,0.3289844),vec4(0.13767092,-0.19229424,0.026238445,0.24488582),vec4(-0.2491537,-0.05438795,0.114506856,-0.21894416)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.20138046,0.024647307,-0.3707709,0.2334647) + mat4(vec4(-0.08481538,-0.1055938,0.15292989,-0.23440005),vec4(0.28032896,0.24352592,-0.33735052,-0.19944067),vec4(-0.16444954,-0.063377485,-0.25355035,0.1266252),vec4(-0.14639474,-0.17199403,-0.043440394,-0.15245563)) * bufB[0] + mat4(vec4(0.5348395,-0.061002932,-0.03011536,0.012723544),vec4(0.23428035,0.06658732,-0.15921995,-0.021351434),vec4(-0.31938928,0.12993,0.032359507,-0.21445131),vec4(-0.018907798,-0.036477096,0.100503154,-0.031534478)) * bufB[1] + mat4(vec4(-0.040215425,-0.17573887,0.35752967,-0.45849213),vec4(-0.18660283,0.058028504,0.16204892,-0.039156143),vec4(-0.20433947,-0.16899443,-0.07325777,-0.104979314),vec4(0.07454529,0.19549926,0.038388174,-0.042225868)) * bufB[2] + mat4(vec4(0.24060403,-0.32501838,0.032017503,-0.283941),vec4(-0.22321568,0.41433173,-0.26803946,-0.081252284),vec4(0.13861324,0.43642178,0.0030594198,-0.1468943),vec4(-0.2533959,-0.04071084,-0.3893546,0.010760873)) * bufB[3] + mat4(vec4(0.052764505,-0.35276806,-0.12940682,-0.284471),vec4(0.26351443,-0.2127001,-0.15218557,0.21059106),vec4(-0.15439105,-0.05659788,0.109783664,-0.49988896),vec4(0.2719069,0.2674259,0.3226017,0.30116418)) * bufB[4] + mat4(vec4(0.04175797,0.036923535,0.28299382,0.05768693),vec4(-0.39492673,-0.11289194,-0.041224755,0.13566896),vec4(0.22786108,-0.18068616,-0.2026419,-0.4967348),vec4(-0.08832595,0.1936708,-0.29432216,-0.11561325)) * bufB[5] + mat4(vec4(0.17877926,0.06978151,0.021979628,0.16585676),vec4(0.2505322,0.26652858,-0.14723721,0.057879984),vec4(-0.11491818,0.021833852,0.24350911,0.0057359017),vec4(-0.14377744,-0.14733082,0.13684545,-0.09762661)) * bufB[6] + mat4(vec4(0.046766024,-0.05026518,0.13008298,-0.14801952),vec4(-0.12551513,-0.25033394,0.041370187,0.0996498),vec4(-0.22154453,0.14122586,-0.15084131,-0.010968308),vec4(-0.14490867,0.13811216,-0.24355625,0.07985523)) * bufB[7] + mat4(vec4(-0.08215949,0.33154413,-0.13768812,-0.031346876),vec4(-0.14249754,0.10781679,-0.2736193,0.25561112),vec4(-0.02031123,0.046930384,0.0022457337,0.03379222),vec4(0.0064758146,-0.10741187,0.17779802,0.06506041)) * bufB[8] + mat4(vec4(0.085830666,0.035991345,0.17834185,-0.36077803),vec4(0.13566238,-0.2488266,0.17194079,-0.23105375),vec4(-0.13874382,0.014792893,0.01666245,0.0935448),vec4(0.33378878,0.17987172,-0.36851132,-0.014641175)) * bufB[9] + mat4(vec4(0.22533473,-0.04472518,0.30509388,-0.15798628),vec4(-0.06419385,-0.4442183,0.08231601,-0.12418969),vec4(-0.14059833,0.3224231,-0.041710746,-0.08822933),vec4(0.38519198,-0.068768494,0.13074134,0.10051919)) * bufB[10] + mat4(vec4(0.07907081,-0.47735646,0.031439327,0.001369654),vec4(0.1819909,0.14710274,0.19033866,0.15358667),vec4(-0.13467892,-0.010979917,-0.055039693,0.118109494),vec4(0.06853958,0.16249005,-0.023714358,-0.17757224)) * bufB[11];\nbufA[1] = vec4(0.278217,1.4235673e-05,-0.13461424,-0.051184535) + mat4(vec4(0.28859356,-0.13748735,-0.083722875,0.13829319),vec4(0.14251056,0.1561846,0.26341382,-0.15754905),vec4(-0.23812972,0.061556067,0.040506728,-0.007611314),vec4(-0.13020633,-0.2549035,0.07666561,0.14475848)) * bufB[0] + mat4(vec4(0.06878909,0.32807365,-0.14740235,-0.27123868),vec4(0.07272299,-0.22169538,0.09133231,0.058317866),vec4(-0.010064662,-0.15264921,0.08039931,-0.5462301),vec4(0.035055023,0.12206465,-0.053594965,-0.016346782)) * bufB[1] + mat4(vec4(-0.14126185,-0.041781336,-0.03818191,-0.04503782),vec4(0.29336557,-0.41870254,0.17201471,0.45419616),vec4(0.3128361,0.098072685,-0.3363171,0.18110657),vec4(0.10241419,0.1120117,0.25098556,0.24656792)) * bufB[2] + mat4(vec4(-0.00418746,-0.15788206,-0.008389517,0.36340472),vec4(0.2925362,0.15413216,0.32184365,-0.37559447),vec4(-0.0123567125,-0.5377723,0.3825298,0.24637139),vec4(0.19290946,0.10294242,-0.021991888,0.35561356)) * bufB[3] + mat4(vec4(0.045127727,-0.20201261,0.13990846,-0.083348595),vec4(0.105277315,-0.06484033,-0.17065352,0.18575598),vec4(-0.003969058,-0.78365594,0.6104357,0.31013885),vec4(0.13275622,0.34918734,-0.16854979,0.26347736)) * bufB[4] + mat4(vec4(0.24220729,0.16774972,-0.12532559,0.19390552),vec4(-0.010048771,-0.06433258,-0.043732945,-0.0049752546),vec4(0.14304167,-0.16511282,0.42750865,-0.091411434),vec4(0.20273261,0.04485376,0.16817716,0.26446253)) * bufB[5] + mat4(vec4(-0.018339122,-0.035295147,-0.27495646,0.03921493),vec4(-0.23384213,0.08163494,0.048555467,-0.122892074),vec4(0.16786544,0.43683976,0.2634344,-0.046929527),vec4(-0.20825642,0.0065540373,0.31150734,0.06088126)) * bufB[6] + mat4(vec4(-0.4319117,-0.054470293,-0.21135643,-0.11587839),vec4(0.10666023,-0.066606104,0.122983776,-0.28532565),vec4(-0.07499261,-0.09460885,-0.113638565,-0.33533192),vec4(0.100573875,0.25591645,0.15035367,-0.09255188)) * bufB[7] + mat4(vec4(-0.022354832,-0.20350084,0.16402917,0.065770246),vec4(-0.23086557,0.14259137,-0.32570493,0.076370336),vec4(0.1721766,0.15165582,-0.096723765,0.06800823),vec4(-0.035617396,-0.029476373,-0.16521882,0.09032104)) * bufB[8] + mat4(vec4(-0.39937398,-0.091343924,0.034701146,-0.18036783),vec4(-0.034308605,0.21827045,-0.114300005,-0.024841605),vec4(0.20902912,-0.04037199,0.16957493,-0.05442064),vec4(-0.10138766,0.2725133,-0.2120444,-0.08233788)) * bufB[9] + mat4(vec4(0.24313273,-0.044521887,0.22536294,-0.052214324),vec4(-0.036207188,-0.003592111,0.39448962,0.22468133),vec4(-0.14591433,-0.44481176,0.4732507,-0.062440682),vec4(-0.041846797,-0.008908057,-0.21356753,-0.03904357)) * bufB[10] + mat4(vec4(-0.24493296,0.2791884,-0.30731773,-0.45460933),vec4(0.0062863575,-0.0034210058,-0.02838826,-0.12964624),vec4(-0.43368834,0.2978098,-0.27661672,0.06943898),vec4(0.091051035,-0.28954485,0.34334332,0.10437468)) * bufB[11];\nbufA[2] = vec4(-0.10242313,0.16592082,-0.2931157,0.29374203) + mat4(vec4(0.06820789,0.19686581,-0.10481667,0.1532514),vec4(-0.20109017,-0.12483483,0.20064877,-0.41765535),vec4(-0.3372256,-0.1341929,-0.3165163,-0.2039402),vec4(-0.42355254,0.17224301,0.21722782,-0.017500682)) * bufB[0] + mat4(vec4(-0.049620777,-0.02813761,-0.02806444,-0.11109916),vec4(0.2676637,0.14766966,0.07227616,0.062746756),vec4(-0.3679483,0.059272528,0.13228123,-0.10830411),vec4(-0.19955984,-0.03441917,-0.07830361,-0.06332673)) * bufB[1] + mat4(vec4(0.25363007,-0.032221973,0.13588561,-0.1262579),vec4(-0.050371468,0.50624895,0.021019135,-0.041110788),vec4(-0.0075329873,0.11670342,0.3658147,-0.22790293),vec4(0.23819496,0.043970164,-0.17084843,-0.17883794)) * bufB[2] + mat4(vec4(-0.17659536,0.013632468,0.05536658,-0.055698313),vec4(-0.10528359,-0.39585692,0.09404799,0.12662493),vec4(0.113948114,0.30016783,0.08664344,0.14121611),vec4(0.14439185,0.33431193,0.4911649,0.13986409)) * bufB[3] + mat4(vec4(-0.26982117,0.41927028,0.20229262,-0.04391201),vec4(-0.19571519,-0.0027675473,-0.07359772,0.13420527),vec4(0.054559927,0.1973126,0.16888048,-0.10669089),vec4(0.16938804,0.45443872,-0.044638984,-0.02625157)) * bufB[4] + mat4(vec4(-0.20887423,0.31654534,0.5425373,-0.023965498),vec4(-0.10879592,-0.23067468,-0.14188422,-0.27478313),vec4(-0.2362067,0.30144578,0.1030658,0.3526489),vec4(-0.27382532,0.26666698,0.1699351,-0.15617354)) * bufB[5] + mat4(vec4(0.062537774,0.37096283,-0.018659983,0.119084805),vec4(-0.23254575,-0.34958914,-0.037708733,-0.07515546),vec4(0.10402193,-0.09547902,-0.17295913,0.07316605),vec4(0.12160394,-0.27123445,0.16311109,0.0227828)) * bufB[6] + mat4(vec4(0.3487068,0.16419509,0.34935895,-0.340952),vec4(0.08829624,-0.23758967,-0.2314323,-0.16567166),vec4(-0.20213594,-0.067712866,-0.15099558,-0.31379294),vec4(0.2793966,0.0891313,0.0133116,-0.21267214)) * bufB[7] + mat4(vec4(0.10712991,0.30868933,0.16573033,-0.15749533),vec4(0.042856526,-0.32650733,0.19632684,-0.23288102),vec4(-0.015237905,-0.23118371,-0.2863996,0.25055584),vec4(0.057120625,0.04762176,0.023919383,-0.05129619)) * bufB[8] + mat4(vec4(-0.14028822,0.07011642,-0.09989091,-0.07563727),vec4(0.12168683,-0.03102513,-0.16979918,-0.005948665),vec4(0.040342875,0.039218556,0.039635185,-0.07365475),vec4(-0.092667125,-0.16557747,0.19431554,0.16569962)) * bufB[9] + mat4(vec4(0.10286221,-0.019914912,-0.17484212,-0.014966488),vec4(-0.008452457,-0.25562686,-0.10673618,0.11040059),vec4(-0.15059936,0.15596838,0.07407709,-0.18905297),vec4(-0.028452441,0.36468688,-0.19398092,0.062354606)) * bufB[10] + mat4(vec4(-0.11836419,-0.5275318,-0.23769478,0.41709876),vec4(0.102005646,0.1356728,0.003332735,0.04357906),vec4(-0.22076443,0.019474965,-0.092912346,-0.14215784),vec4(-0.10972267,0.7090135,0.16248123,0.059532505)) * bufB[11];\nbufA[3] = vec4(0.21377867,0.06540333,0.09221931,0.4623759) + mat4(vec4(-0.2769601,-0.14719945,0.112267725,0.26594228),vec4(-0.20638958,0.11223325,0.12842391,0.115441106),vec4(0.30742282,0.17039448,0.052292798,-0.32509315),vec4(-0.14590035,0.05350211,0.42410976,-0.038611628)) * bufB[0] + mat4(vec4(0.035192363,0.24035159,0.19100586,0.47129017),vec4(-0.21172477,0.11038211,-0.14909063,0.12618127),vec4(0.25113693,0.2531929,0.16953471,-0.47603646),vec4(0.14229909,-0.013183873,0.19147822,0.22265786)) * bufB[1] + mat4(vec4(-0.18321118,0.26478866,-0.037715826,0.19940464),vec4(0.5284582,-0.13834767,0.0879618,-0.059076637),vec4(0.025496772,-0.095130004,0.51699173,-0.22929399),vec4(0.010765176,-0.06926269,0.010436434,-0.41186795)) * bufB[2] + mat4(vec4(0.0030998841,-0.050949793,0.08475618,-0.2152786),vec4(0.16128704,-0.17884025,0.26366717,-0.027954647),vec4(-0.014330175,-0.047782414,0.07965129,-0.018010674),vec4(-0.62036717,0.07704914,-0.09577895,-0.026869569)) * bufB[3] + mat4(vec4(-0.09871055,-0.0021587736,0.13052495,0.1069766),vec4(-0.18272562,0.22088239,-0.010001621,-0.33658478),vec4(-0.1361837,0.09464567,0.10708765,-0.3250668),vec4(0.17578998,0.05465301,0.03979571,-0.32178608)) * bufB[4] + mat4(vec4(0.20841937,-0.22408576,0.25037336,-0.061965693),vec4(0.039750326,-0.24395838,-0.3351389,-0.1896583),vec4(0.053245936,-0.15450703,0.061124615,0.087710224),vec4(-0.34323442,0.093126975,0.31585202,0.19510567)) * bufB[5] + mat4(vec4(0.021557165,-0.035629805,-0.0044813203,-0.026408762),vec4(0.19945721,-0.01710971,0.26230898,0.3625121),vec4(-0.06257963,-0.018370047,0.21256462,0.10101639),vec4(0.07903152,0.29460457,0.21135294,-0.058046207)) * bufB[6] + mat4(vec4(0.021171652,0.6464806,0.13981849,0.20080069),vec4(0.1927789,0.06838896,-0.004540706,-0.14901894),vec4(-0.03986784,0.0011526567,0.312407,-0.27199504),vec4(0.15993701,0.21252322,0.3031688,-0.01490203)) * bufB[7] + mat4(vec4(-0.1253594,0.035831112,0.10946689,-0.45047137),vec4(0.04741312,0.023332153,-0.1020692,-0.010285766),vec4(-0.07007926,0.04622782,-0.3033514,-0.09708427),vec4(-0.18932913,-0.26032522,-0.01002885,-0.0099028)) * bufB[8] + mat4(vec4(0.047762837,0.23174286,0.2462574,0.08378851),vec4(-0.11927994,0.3118126,0.08336965,0.036506206),vec4(0.070990644,-0.1296862,0.08252631,0.10124756),vec4(-0.5464234,-0.0804036,-0.16629288,-0.010268681)) * bufB[9] + mat4(vec4(0.10998921,0.017092314,0.22615671,0.0692039),vec4(-0.119623005,0.12168273,-0.07928285,0.013126999),vec4(-0.20564738,0.1435839,0.09019019,-0.048113503),vec4(0.19356154,-0.27510655,-0.09149391,0.16680357)) * bufB[10] + mat4(vec4(-0.0017626875,0.10402032,-0.07441979,0.19512834),vec4(-0.3244034,-0.05040777,0.07687035,0.017955199),vec4(0.17937975,0.120358676,0.094878435,0.2912914),vec4(-0.13526154,0.3010324,0.25711754,0.09596721)) * bufB[11];\nbufA[4] = vec4(-0.06629219,0.26760006,0.10252558,-0.117169864) + mat4(vec4(0.12760386,0.1340828,-0.11701463,0.4649686),vec4(0.11919128,-0.014734572,-0.052312497,-0.19210134),vec4(0.10258909,-0.01931546,0.12819105,-0.16327813),vec4(0.09048712,-0.10952728,-0.08719596,0.022826849)) * bufB[0] + mat4(vec4(0.074019335,0.6161137,-0.0982474,-0.09594343),vec4(-0.098310284,0.16738929,0.006828584,0.35704088),vec4(-0.20857762,-0.050183684,0.111721225,-0.17949425),vec4(0.12914793,-0.21865682,0.047122832,-0.3493242)) * bufB[1] + mat4(vec4(-0.015405706,-0.013248149,0.14041713,0.24655779),vec4(-0.025125898,-0.14771402,-0.27308637,0.110117994),vec4(0.15743834,0.18940412,-0.058963884,0.18821147),vec4(0.17748895,0.08399445,0.105969995,-0.29622665)) * bufB[2] + mat4(vec4(-0.2675385,-0.04943971,-0.10491932,0.14012952),vec4(-0.1130843,-0.044246458,0.07445345,0.16887467),vec4(-0.17572626,-0.10398024,0.28150743,-0.031959277),vec4(-0.3557525,-0.03668607,-0.17914107,0.431256)) * bufB[3] + mat4(vec4(-0.16739085,0.33054683,0.2381204,0.24068952),vec4(0.02664176,0.15687563,0.120319046,-0.07114152),vec4(-0.14479227,0.106374554,0.07433466,-0.06484967),vec4(-0.1143363,-0.10890843,0.12900177,-0.14440955)) * bufB[4] + mat4(vec4(-0.08382429,-0.32181513,-0.17895767,-0.21706015),vec4(0.15984908,0.09953149,0.19094981,0.06575922),vec4(-0.39866632,0.13289812,-0.29669955,0.16197874),vec4(0.03366282,-0.04286663,0.107624695,0.0076744165)) * bufB[5] + mat4(vec4(0.04404228,-0.046823665,-0.1909526,0.4010104),vec4(-0.03872055,0.11302935,-0.018829279,-0.031063538),vec4(-0.13364236,-0.024936534,-0.16979426,0.07969447),vec4(0.012155422,-0.26201367,0.08625117,-0.25545532)) * bufB[6] + mat4(vec4(-0.12988777,-0.23382394,-0.16127239,0.08188809),vec4(0.08352011,-0.14657328,-0.28051051,-0.06287566),vec4(0.13335799,-0.20466037,-0.18539056,-0.30937272),vec4(0.11813964,-0.25096935,-0.3777075,0.027163573)) * bufB[7] + mat4(vec4(-0.21950303,0.19272843,0.22758718,-0.08863293),vec4(0.10676094,0.041072913,-0.21451297,-0.13068658),vec4(0.047698677,0.07520517,-0.22092207,0.22906913),vec4(-0.089155294,0.13861707,0.048189636,0.2791257)) * bufB[8] + mat4(vec4(0.12979709,-0.049804047,-0.14209682,0.03459791),vec4(-0.059863966,0.05689157,0.05665497,0.28906345),vec4(0.20894547,-0.28476393,-0.1738218,0.041995518),vec4(-0.29327172,0.047427133,0.05511448,0.24545589)) * bufB[9] + mat4(vec4(-0.08425013,0.30403835,0.0946311,0.062331196),vec4(0.25485194,0.13390027,-0.15037446,-0.100981824),vec4(0.15325001,-0.036429264,-0.13864377,-0.024041625),vec4(0.24571453,0.14591266,0.21558937,-0.22403692)) * bufB[10] + mat4(vec4(0.7120269,0.11300006,-0.38209867,-0.027403396),vec4(0.09020862,-0.17545454,-0.25994924,-0.2516951),vec4(0.35906067,0.056992255,-0.22769248,-0.14067319),vec4(-0.13162325,-0.19207,0.04035917,-0.17656045)) * bufB[11];\nbufA[5] = vec4(-0.15445802,-0.46861714,-0.042643666,0.45959032) + mat4(vec4(0.11016539,-0.070412844,-0.06976846,-0.08574889),vec4(-0.25700888,0.28109095,0.09690446,0.25566038),vec4(0.22937246,0.15345143,-0.28801972,0.4525189),vec4(-0.22469887,-0.02297957,-0.14649679,0.1242521)) * bufB[0] + mat4(vec4(-0.1339163,0.087918654,-0.10957322,0.33015874),vec4(-0.0109538045,-0.13749692,0.101448685,-0.08171512),vec4(0.122460276,0.033112213,0.062208034,0.1860262),vec4(-0.046934217,-0.0006641591,-0.02046078,0.15048341)) * bufB[1] + mat4(vec4(-0.031276684,0.24010311,0.05523969,-0.3419206),vec4(0.33765814,0.094389096,0.0756271,-0.40255064),vec4(-0.08187899,-0.06677486,-0.0018889265,0.34105903),vec4(0.1195456,0.13094115,0.30012912,0.43418312)) * bufB[2] + mat4(vec4(-0.06331627,-0.029761307,-0.037410084,0.12927839),vec4(0.22272322,0.38143596,0.12973702,0.46258244),vec4(0.106457,0.27850103,0.10022761,-0.1610846),vec4(0.03248071,-0.09053752,0.09333143,-0.15006794)) * bufB[3] + mat4(vec4(0.19127434,-0.1899255,0.15642522,-0.3809522),vec4(0.065022424,0.042404264,-0.1668018,0.11968985),vec4(0.44357413,0.020563927,0.28080902,-0.2752605),vec4(0.3604152,0.11668083,-0.044916987,-0.055122714)) * bufB[4] + mat4(vec4(0.03691089,-0.23515773,0.16324146,0.17497475),vec4(-0.16543886,-0.16827936,-0.3401268,0.12711965),vec4(0.5261407,0.18195018,0.13613394,0.16213831),vec4(-0.1559445,0.27110595,0.012220803,-0.09087783)) * bufB[5] + mat4(vec4(-0.071265824,0.24746093,-0.066934414,-0.2506787),vec4(-0.3380262,0.17824301,0.08860019,0.12654597),vec4(0.55261457,-0.20088747,0.29408792,0.17358501),vec4(-0.03719999,0.18236324,0.30521995,0.19093503)) * bufB[6] + mat4(vec4(-0.41216263,-0.005276528,0.059052076,-0.2639998),vec4(0.14144541,0.07691905,0.10944445,0.07878979),vec4(-0.069599375,-0.020014327,-0.10151906,-0.099404395),vec4(0.043646928,0.24543062,0.09642123,-0.01960765)) * bufB[7] + mat4(vec4(0.094603255,-0.07383413,-0.23643117,-0.17876184),vec4(-0.21236858,-0.19767915,-0.3062377,0.22062884),vec4(0.11339271,-0.16392653,0.15005563,0.20122299),vec4(-0.30474937,-0.032269128,-0.29318598,0.09630139)) * bufB[8] + mat4(vec4(-0.049727432,0.19834837,-0.021989023,-0.059172682),vec4(-0.14903787,-0.02080192,0.05167225,-0.09834839),vec4(0.2289017,0.40492147,0.23942137,0.22094506),vec4(0.06897358,-0.11765748,-0.025070615,-0.14940195)) * bufB[9] + mat4(vec4(-0.30662742,0.3482531,-0.42260256,-0.17811012),vec4(0.34513986,-0.19924432,0.12036023,0.26095784),vec4(0.06985028,0.33096936,0.11156875,-0.035398845),vec4(0.27271867,0.28058574,-0.18681958,-0.21300063)) * bufB[10] + mat4(vec4(-0.08276726,0.32287848,-0.1208394,-0.12626158),vec4(0.29928985,0.07470453,0.08062542,-0.06485878),vec4(-0.4817422,-0.043007996,-0.18694039,-0.10999289),vec4(-0.020871304,-0.28933322,-0.028865643,-0.25440168)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.27855122089385986,-0.13750462234020233,0.17376478016376495,0.0) + mat4(vec4(0.06516215950250626,0.2457045614719391,0.20193614065647125,0.0),vec4(-0.0662231519818306,-0.05986601486802101,-0.11819766461849213,0.0),vec4(-0.09198729693889618,-0.0765373483300209,-0.03670273721218109,0.0),vec4(0.062259357422590256,0.032262448221445084,-0.14666937291622162,0.0)) * bufB[0] + mat4(vec4(-0.014693697914481163,0.03992684558033943,0.012590340338647366,0.0),vec4(-0.21226857602596283,0.10129968076944351,0.037550415843725204,0.0),vec4(-0.08621320873498917,-0.10246475785970688,-0.12117709219455719,0.0),vec4(0.1544487178325653,0.09158292412757874,-0.026651889085769653,0.0)) * bufB[1] + mat4(vec4(-0.07604197412729263,-0.06148863211274147,-0.08806147426366806,0.0),vec4(0.13585563004016876,0.039323680102825165,0.06381513178348541,0.0),vec4(-0.07796391099691391,-0.049181610345840454,0.0719236209988594,0.0),vec4(0.04877841845154762,0.0532936230301857,0.02552070841193199,0.0)) * bufB[2] + mat4(vec4(-0.13923706114292145,-0.11941824108362198,-0.07463119924068451,0.0),vec4(0.07818679511547089,-0.025318952277302742,-0.013893038034439087,0.0),vec4(-0.08977100998163223,-0.16010895371437073,0.17031052708625793,0.0),vec4(-0.16437505185604095,0.2608083486557007,0.18141551315784454,0.0)) * bufB[3] + mat4(vec4(-0.06445962935686111,-0.11466939747333527,-0.15925833582878113,0.0),vec4(0.07405626028776169,0.12399423122406006,0.17103083431720734,0.0),vec4(0.07021963596343994,0.08581483364105225,0.14877142012119293,0.0),vec4(0.0510064996778965,0.08798026293516159,0.03818058222532272,0.0)) * bufB[4] + mat4(vec4(0.04291403293609619,-0.08093515038490295,-0.043621376156806946,0.0),vec4(-0.10210443288087845,-0.05695445463061333,-0.01960179954767227,0.0),vec4(-0.06192612648010254,-0.029889605939388275,-0.017697161063551903,0.0),vec4(0.020682882517576218,-0.12010017782449722,-0.05548907071352005,0.0)) * bufB[5] + mat4(vec4(0.08948958665132523,0.02482835203409195,0.06090734153985977,0.0),vec4(0.11434585601091385,0.08589276671409607,0.11387903243303299,0.0),vec4(-0.06741280853748322,-0.04477090761065483,-0.033121995627880096,0.0),vec4(-0.03210550174117088,-0.003191557712852955,-0.06036700680851936,0.0)) * bufB[6] + mat4(vec4(0.007695659063756466,0.09733147919178009,0.08202719688415527,0.0),vec4(0.11534307897090912,0.016981428489089012,-0.021277008578181267,0.0),vec4(-0.1703428030014038,-0.22621136903762817,-0.29474392533302307,0.0),vec4(-0.09599669277667999,-0.049840833991765976,0.07545526325702667,0.0)) * bufB[7] + mat4(vec4(-0.060240257531404495,-0.06863535940647125,-0.03008355014026165,0.0),vec4(0.5088471174240112,0.4616861343383789,0.38832664489746094,0.0),vec4(0.028761107474565506,-0.008207599632441998,-0.08253265172243118,0.0),vec4(0.1057659387588501,0.10047987103462219,0.07761672884225845,0.0)) * bufB[8] + mat4(vec4(-0.035062942653894424,-0.035960301756858826,-0.044076237827539444,0.0),vec4(0.013453200459480286,-0.016270341351628304,-0.04938767850399017,0.0),vec4(-0.042844951152801514,-0.015028543770313263,-0.08835048228502274,0.0),vec4(0.021168136969208717,-0.10667296499013901,-0.08262039721012115,0.0)) * bufB[9] + mat4(vec4(0.06936855614185333,0.06955144554376602,0.026601001620292664,0.0),vec4(-0.08818382024765015,-0.08487462997436523,-0.12522795796394348,0.0),vec4(-0.16620613634586334,-0.10170567780733109,-0.15846703946590424,0.0),vec4(-0.010704334825277328,-0.036532726138830185,-0.007026609033346176,0.0)) * bufB[10] + mat4(vec4(-0.10885347425937653,-0.13697153329849243,-0.10659477114677429,0.0),vec4(0.026829201728105545,0.008007438853383064,-0.0012795240618288517,0.0),vec4(-0.09843379259109497,-0.07075189054012299,-0.10386953502893448,0.0),vec4(-0.1622486263513565,-0.11758273839950562,-0.07664106041193008,0.0)) * bufB[11];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime), 1.5*sin(0.69*iTime), 1.*sin(0.44*iTime), 1.5*sin(0.32*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd23DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 144, 144, 127660], [127662, 127662, 127719, 127769, 128210]]}
{"id": "Wd23Dt", "name": "Raymarch IFS 2", "author": "darkeclipz", "description": "variation of https://www.shadertoy.com/view/3djGDt.", "tags": ["raymarch", "ifs"], "likes": 2, "viewed": 102, "published": "Public", "date": "1550283052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 100.\n#define MinDistance 0.01\n#define eps 0.001\n#define Iterations 22.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat DE(vec3 z)\n{\n    float angl = cos(iTime)*.2;\n    mat3 rz = rotateZ(angl);\n    mat3 rot = rz;\n \n    float Scale = 2. + cos(iTime/8.)*.5;\n    float Offset = .65;\n    float n = 0.;\n    while (n < Iterations) {\n       z *= rot;\n       if(z.x - z.y < 0.) z.yx = z.xy;\n       if(z.x + z.y < 0.) z.yx = -z.xy;\n       if(z.x - z.z < 0.) z.xz = z.zx;\n       z *= rot;\n       z = abs(z);\n       z = z*Scale - vec3(vec3(Offset*(Scale-1.0)).xy, 0);\n       n++;\n    }\n    return (length(z) ) * pow(Scale, -float(n));\n}\n\nfloat scene(vec3 p) {\n\treturn DE(p - vec3(0,.1,0));\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p - vec3(0,.1,0));\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                  k.yyx*scene( p + k.yyx*h ) + \n                  k.yxy*scene( p + k.yxy*h ) + \n                  k.xxx*scene( p + k.xxx*h ) );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec2 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = scene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec2(t-MinDistance, 1.-i/MaxSteps);  \n        }\n    }\n    return vec2(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 32.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,5,0), 30., vec3(.9));\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,10), 30., vec3(.9,.9,.5));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(-5,1,-5), 20., vec3(.8,.8,.3));\n    vec3 ambient = vec3(.1);\n    return L1 + L2 + ambient + top;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,2.,-4); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateY(-iTime/4.);\n    ro *= rot;\n    rd *= rot;\n    \n    vec2 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        float shadow = marchShadow(p + 0.1*n, normalize(vec3(10,10,10) - p));\n        if(shadow > eps) {\n        \tcol = mix(col, vec3(0), .5);    \n        }\n        \n        float fog = 1. / (0.3 + t * t * 0.05);\n        col = mix(vec3(0), col, fog);\n    }\n    else {\n        vec3 topcolor = vec3(127./255., 161./255., 189./255.);\n        vec3 bottomcolor = vec3(84./255., 111./255., 138./255.);\n    \tcol = mix(bottomcolor, topcolor, uv.y);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd23Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 141, 141, 227], [229, 229, 256, 256, 342], [344, 344, 371, 371, 449], [451, 550, 568, 568, 1061], [1063, 1063, 1084, 1084, 1116], [1118, 1118, 1144, 1144, 1176], [1178, 1189, 1214, 1214, 1478], [1480, 1558, 1588, 1588, 1846], [1848, 1848, 1885, 1885, 2121], [2123, 2190, 2297, 2297, 3055], [3057, 3132, 3170, 3170, 3464], [3466, 3466, 3523, 3523, 4500]]}
{"id": "Wd23Wc", "name": "Rain in the mud", "author": "Gaxil", "description": "Procedural raindrops with water flowing on the terrain. Heavy usage of noises with derivatives from IQ", "tags": ["water", "rain", "flowmap", "mud"], "likes": 16, "viewed": 754, "published": "Public", "date": "1550770543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WATER_LEVEL 0.075\t\t\t// from -0.2 to 0.2\n#define RAIN_INTENSITY 1.0\n#define RAIN_DROPS_SIZE 96.0\n\nfloat GetHash1D(vec2 p)\n{\n    // from IQ\n\tp  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Noise1D(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n   \tf = f*f*(3.0-2.0*f);\n\n\treturn \n\t\tmix(\n\t\t\tmix(GetHash1D(p), GetHash1D(p+vec2(1.0, 0.0)), f.x),\n\t\t\tmix(GetHash1D(p+vec2(0.0, 1.0)), GetHash1D(p+vec2(1.0, 1.0)), f.x),\n\t\t\tf.y);\n}\n\nvec3 GetHash3D( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat Noise3D( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( GetHash3D( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( GetHash3D( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( GetHash3D( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( GetHash3D( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( GetHash3D( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( GetHash3D( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( GetHash3D( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( GetHash3D( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvec2 GetHash2D( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 Noise2DDer( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = GetHash2D( i + vec2(0.0,0.0) );\n    vec2 gb = GetHash2D( i + vec2(1.0,0.0) );\n    vec2 gc = GetHash2D( i + vec2(0.0,1.0) );\n    vec2 gd = GetHash2D( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec3 GetFBM( vec2 position)\n{\n\tvec3 f = vec3(0.0);\n\n\tvec3 warping = Noise2DDer( position*2.5 )*0.45 + Noise2DDer( position*1.1 ) ;\n\tposition += warping.yz*0.07;\n\n\tvec2 q = vec2(8.0)*position;\n\tf  = vec3(0.5000)*Noise2DDer( q ); q = q*vec2(2.01);\n\tf += vec3(0.2500*Noise2DDer( q )); q = q*vec2(2.02);\n\tf += vec3(0.1250*Noise2DDer( q )); q = q*vec2(2.03);\n\tf += vec3(0.0625*Noise2DDer( q )); q = q*vec2(2.01);\n\tf += vec3(0.03125*Noise2DDer( q )); q = q*vec2(2.02);\n\n\treturn f;\n}\n\n\nvec2 Rotate(vec2 pos, float angle) \n{\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nvec2 getRainNormal(vec2 position)\n{\n\tfloat gridSize = RAIN_DROPS_SIZE;\n\tvec2 normal2D = vec2(0.0);\n\n\tfor(float i=0.0; i<15.0 * RAIN_INTENSITY; i++)\n\t{\n\t\tvec2 coord = Rotate(position, .25*i) + vec2(3.0, 7.0)*i;\n\t\tvec2 gridPos = round(coord / vec2(gridSize))*vec2(gridSize);\n\t\tfloat offset = GetHash1D(gridPos+vec2(153.0*i, 127.0*i));\n\t\tvec2 delta = gridPos - coord;\n\t\tfloat dist = length(delta);\n\t\tdelta /= dist;\n\t\tdist /= gridSize;\n\t\tfloat mask = 1.0 - clamp((dist)*4.0 - 1.0, 0.0, 1.0);\n\t\toffset = mod(iTime + offset*3.0, 3.0)-1.0;\n\t\tfloat ripple = sin((dist - offset)*60.0);\n\t\tfloat dRipple = cos((dist - offset)*60.0);\n\t\tfloat rippleMask = clamp(abs(dist - offset)*10.0, 0.0, 1.0);\n\t\tfloat height = ((1.0-rippleMask)*1.0) * mask;\n\t\tnormal2D += delta * dRipple * height;\n\t}\n\n\treturn normal2D;\n}\n\nvec3 getWaterNormal(vec2 position)\n{\n\tfloat noiseScale = 0.01;\n\tvec3 bpos = vec3(position.x, position.y, iTime*400.0);\n\tfloat base = Noise3D(bpos*noiseScale);\n\tfloat N = Noise3D((bpos + vec3( 0.0, 10.0, 0.0))*noiseScale);\n\tfloat S = Noise3D((bpos + vec3( 0.0,-10.0, 0.0))*noiseScale);\n\tfloat E = Noise3D((bpos + vec3( 10.0, 0.0, 0.0))*noiseScale);\n\tfloat W = Noise3D((bpos + vec3(-10.0, 0.0, 0.0))*noiseScale);\n\tvec2 baseNormal = vec2((N-base)-(S-base),(E-base)-(W-base))*.6;\n\n\treturn vec3(base, baseNormal.x, baseNormal.y);\n}\n\nvec3 getCheckerBackground(vec2 position)\n{\n\tfloat checkerSize = 64.0;\n\tvec2 checkerPos = round(position / vec2(checkerSize));\n\tfloat checker = step(mod(checkerPos.x + checkerPos.y, 2.0), 0.0);\n\n\treturn mix (vec3(0.3, 0.3, 0.3), vec3(0.7, 0.7, 0.7), checker);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragCoord = Rotate(fragCoord - iResolution.xy*0.5, iTime*0.06);\n\tfragCoord += vec2(sin(iTime*0.015), cos(iTime*0.03))*3000.0;\n\n\t// light dir\n\tvec3 l = normalize(vec3(1.0, -1.0, 2.0));\t\n\tl.xy = Rotate(l.xy, iTime*0.06);\n\n\tvec3 groundBase =  GetFBM((fragCoord)*0.0005);\n\tvec3 water = getWaterNormal(fragCoord);\n\tfloat waterDepth = clamp((WATER_LEVEL - water.x*0.02 - groundBase.x), 0.0, 1.0);\n\tvec3 nUnderwater = normalize(vec3(groundBase.y, groundBase.z, 1.0));\n\tfloat diffuseUnderwater = clamp(dot(nUnderwater, l), 0.0, 1.0);\n\tfloat waterLimitSharp = clamp(waterDepth*30.0, 0.0, 1.0);\n\tfloat waterLimitSmooth = clamp(waterDepth*20.0, 0.0, 1.0);\n\tvec2 normal2D = getRainNormal(fragCoord + groundBase.yz*50.0 *(1.0 - waterLimitSharp))*0.5 + water.yz*1.0;\n\n\n\t// flowmap\n\tfloat timing1 = fract(iTime*0.25);\n\tvec3 waterFlowing = Noise2DDer((fragCoord + groundBase.yz*timing1 * 150.0) * 0.07) * (1.0 - abs(timing1*2.0 - 1.0));\n\tfloat timing2 = fract(iTime*0.25 + 0.5);\n\twaterFlowing += Noise2DDer((fragCoord + vec2(500.0) + groundBase.yz*timing2 * 150.0) * 0.07) * (1.0 - abs(timing2*2.0 - 1.0));\n\tfloat flatGround = clamp(dot(normalize(vec3(groundBase.yz, 1.0)), vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\twaterFlowing *= 1.0 - flatGround;\n\tnormal2D *= flatGround;\n\n\t// Ground color - mix with water ponds\n\tvec3 ground =  GetFBM((fragCoord + normal2D * 500.0 * waterDepth + waterFlowing.yz * RAIN_INTENSITY * 800.0 * (1.0 - flatGround))*0.0005);\n\tvec3 col = mix (vec3(0.5, 0.3, 0.2), vec3(0.3, 0.25, 0.25), ground.x);\n\tcol = mix (col, mix (vec3(0.4, 0.2, 0.00), vec3(0.0, 0.0, 0.0), waterDepth*3.0), waterLimitSmooth) * diffuseUnderwater;\n\tnormal2D = mix (ground.yz + normal2D*0.1 + waterFlowing.yz * 0.15 * RAIN_INTENSITY, vec2(0.0)+ normal2D, waterLimitSharp);\n\n\tvec3 n = normalize(vec3(normal2D.x, normal2D.y, 1.0));\n\tvec3 v = vec3(0.0, 0.0 ,1.0);\n\n\tvec3 reflect = normalize(2.0 * n - l); \n\tfloat specular = pow(clamp(dot(reflect, v), 0.0, 1.0), 65.0)*3.0;\n\tfloat diffuse = clamp(dot(n, l), 0.0, 1.0);\n\tvec3 light = vec3(specular);\n\n\tcol = col* diffuse + light*0.25;\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd23Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 130, 145, 229], [231, 231, 254, 254, 474], [476, 476, 538, 538, 707], [709, 709, 737, 737, 1602], [1604, 1604, 1670, 1670, 1808], [1810, 1870, 1900, 1900, 2786], [2788, 2788, 2817, 2817, 3264], [3267, 3267, 3304, 3304, 3424], [3426, 3426, 3461, 3461, 4222], [4224, 4224, 4260, 4260, 4750], [4752, 4752, 4794, 4794, 5012], [5014, 5014, 5071, 5121, 7252]]}
{"id": "wd23Wt", "name": "Gears test", "author": "yasuo", "description": "It's just an experiment.", "tags": ["gear"], "likes": 7, "viewed": 352, "published": "Public API", "date": "1550329281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdGear( vec3 p, vec2 h )\n{\n    float r = (length(p)-0.08);\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float len = 0.13;\n\tfloat resd = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    float res2d = max(-r,resd);\n    float b = sdBox(p,vec3(0.02,0.015,len));\n    float b2 = sdBox(p,vec3(len,0.015,0.02));\n    float b3 = sdBox(p*matRotateY(radians(45.0)),vec3(len,0.015,0.02));\n    float b4 = sdBox(p*matRotateY(radians(-45.0)),vec3(len,0.015,0.02));\n    float res3d = max(-b,res2d);\n    float res4d = max(-r,min(min(min(b,b2),b3),b4));\n  \treturn min(res3d,res4d);\n}\n\nvec4 map(vec3 p){\n    p.z -= iTime*0.2;\n    p.z = mod(p.z,1.0)-0.5;\n    \n    mat3 rotX = matRotateX(radians(90.0));\n    float rad = radians(iTime*60.0);\n    float gear0 = sdGear(((p+vec3(-0.17,-0.17,-0.4))*rotX)*matRotateY(rad),vec2(0.1,0.015));\n    float gear1 = sdGear(((p+vec3(0.0,0.0,-0.4))*rotX)*matRotateY(-rad+radians(20.0)),vec2(0.1,0.015));\n    float gear2 = sdGear(((p+vec3(-0.17,0.17,-0.4))*rotX)*matRotateY(rad),vec2(0.1,0.015));\n    float gear3 = sdGear(((p+vec3(0.25,0.0,-0.4))*rotX)*matRotateY(rad),vec2(0.1,0.015));\n    float gear4 = sdGear(((p+vec3(0.43,0.18,-0.4))*rotX)*matRotateY(-rad+radians(20.0)),vec2(0.1,0.015));\n    float gear5 = sdGear(((p+vec3(-0.43,-0.18,-0.4))*rotX)*matRotateY(-rad+radians(20.0)),vec2(0.1,0.015));\n    return vec4(vec3(0.9),min(min(min(min(min(gear0,gear1),gear2),gear3),gear4),gear5));\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*30.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.1,1.31,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd23Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 211, 211, 299], [301, 301, 333, 333, 874], [876, 876, 893, 893, 1712], [1714, 1714, 1737, 1737, 1987], [1989, 1989, 2023, 2023, 2273], [2275, 2275, 2331, 2331, 3492]]}
{"id": "wd23zd", "name": "Mindrape", "author": "jamadazi", "description": "Stare at this for a while (in fullscreen, filling up your whole vision) and then look around your room. Your brain's visual processing will be messed up and everything will look distorted.\n\nSeizure warning!", "tags": ["illusion"], "likes": 3, "viewed": 281, "published": "Public API", "date": "1549807689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float yshfr = 50.0;\nconst float yshmg = 1.0;\nconst float sosc = 256.0;\nconst float sosc_var = 0.2;\n\nvec3 r1(vec2 pos) {\n    float yshift = sin(pos.y * yshfr) * yshmg;\n    float scale = ((pos.x) * sosc * 3.14) / (1.0 + sin(iTime) * sosc_var) + yshift;\n\n    return vec3(cos(scale)*0.5+0.5);\n}\nvec3 r2(vec2 pos) {\n    float yshift = sin(pos.y * yshfr) * yshmg;\n    float scale = ((pos.x) * sosc * 3.14) / (1.0 + sin(iTime) * sosc_var);\n        \n    float xabbermag = 1.0;\n    vec3 xabber = vec3(yshift) + vec3(-xabbermag, 0.0, +xabbermag);\n    vec3 scale3 = vec3(scale) + xabber;\n\n    vec3 clr = cos(scale3)*0.5+0.5;\n    return clr;\n\n}\nvec3 r3(vec2 pos) {\n    float vabbermag = 2.0;\n    vec3 vabber = vec3(sin(iTime * 0.123), sin(iTime * 0.234), sin(iTime * 0.345));\n    vec3 yshb = vec3(pos.y) + vabber;\n    vec3 yshift = sin(yshb * yshfr) * yshmg;\n    float scale = ((pos.x) * sosc * 3.14) / (1.0 + sin(iTime) * sosc_var);\n        \n    float xabbermag = 1.0;\n    vec3 xabber = yshift + vec3(-xabbermag, 0.0, +xabbermag);\n    vec3 scale3 = vec3(scale) + xabber;\n\n    vec3 clr = cos(scale3)*0.5+0.5;\n    return clr;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord / iResolution.xy - 0.5;\n\n    vec3 col = r3(pos);\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n    //fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd23zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 296], [297, 297, 316, 316, 638], [639, 639, 658, 658, 1121], [1122, 1122, 1179, 1179, 1364]]}
{"id": "wd2GDG", "name": "[twitch] Rainy Bridge", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl", "tags": ["3d", "raymarching", "rain", "live", "twitch"], "likes": 58, "viewed": 1150, "published": "Public", "date": "1549925760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl\n*/\n\n#define MARCH_STEPS 100\n#define RAIN_STEPS 50\n#define SHAD_STEP 30\n\n#define time iTime\n\nfloat PI = acos(-1.0);\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  //return vec3(0.0);\n  vec3 off = vec3(0.0);\n  off.x += sin(p.z*0.2) + sin(p.z*0.137)*3.0;\n  off.y += sin(p.z*0.5)*0.2 + p.z*0.3;\n  return off;\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a, b, k) - k*(1.0-k)*h;\n}\n\nfloat map(vec3 p) {\n\n  float water = 10.0-p.y-p.z*0.3;\n\n  p += tunnel(p);\n\n  vec3 rp = p;\n  float sizerepeat = 2.0;\n  rp.z = (fract(rp.z/sizerepeat-0.5)-0.5)*sizerepeat;\n  \n  rp.yz *= rot(-rp.z*0.2);\n  float bridge = box(rp + vec3(0,-1,0), vec3(1.0,0.2,2.0));\n\n  \n  vec3 rp4 = rp + vec3(0,-0.8,0);\n  rp4.x += sin(p.z*8.0)*0.05;\n  rp4.y += cos(p.z*7.0)*0.05;\n  float size4 = 0.14;\n  rp4.xz = (fract(rp4.xz/size4-0.5)-0.5)*size4;\n  float bricks = box(rp4, vec3(0.05))-0.015;\n  bricks = max(bricks, bridge - 0.05);\n\n  bridge = smin(bridge, bricks, 0.09);\n\n\n  rp.x = abs(rp.x) - 1.0;\n  \n  float bar = box(rp + vec3(0,-0.5,0), vec3(0.05,0.05,2.0));\n  vec3 rp2 = rp;\n  float size2 = 0.2;\n  rp2.z = (fract(rp2.z/size2-0.5)-0.5)*size2;\n  bar = min(bar, box(rp2 + vec3(0,-0.8,0), vec3(0.03,0.3,0.03)));\n\n  bridge = min(bridge, bar);\n\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n  float def = sin(rp3.y*17.0+2.0)*0.5+0.5;\n  def = sin(rp3.y*10.0 + def*3.0);\n  def = smoothstep(0.0,1.0,def);\n  def = smoothstep(0.0,1.0,def);\n  float lsize = 0.05 + (def)*0.02;\n  float lamp = max(cyl(rp3.xz + vec2(0,0), lsize), abs(rp3.y)-1.0);\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  top = max(top, -sph(lpos-vec3(0,0.3,0), 0.5));\n\n  lpos.y = max(abs(lpos.y)-0.1,0.0);\n  //lamp = min(lamp, sph(lpos, 0.12));\n  \n  //lamp = min(lamp, top);\n  lpos = abs(lpos)-0.1;\n  lpos.xz *= rot(PI*0.25);\n  //lamp = max(lamp, -box(lpos, vec3(0.05,0.2,0.05)));  \n  bridge = min(bridge, lamp);\n\n  bridge = min(bridge, water);\n\n  return bridge;\n\n}\n\n\nfloat lighting(vec3 p) {\n\n  p += tunnel(p);\n\n  float sizerepeat = 2.0;\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  return sph(lpos, 0.12);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvec3 getlightdir(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(lighting(p)-vec3(lighting(p-off.xyy), lighting(p-off.yxy), lighting(p-off.yyx)));\n}\n\nfloat rnd(float t) {\n\n  return fract(sin(t*745.523)*7894.552);\n\n}\n\nfloat rain(vec3 p) {\n\n  p.y -= time*4.0;\n  p.xy *= 60.0;\n  \n  p.y += rnd(floor(p.x))*80.0;\n  \n  return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);\n}\n\nfloat ripple(vec3 p) {\n\n  float t2 = time*5.0;\n\n  float size3 = 0.2;\n  vec3 rp3 = p + vec3(1,0,1.0);\n  \n  float id = dot(floor(rp3.xz/size3-0.5), vec2(7.52,5.48));\n  rp3.xz = (fract(rp3.xz/size3-0.5)-0.5)*size3;\n  \n\n  float r = clamp(1.0-length(rp3.xz)*20.0, 0.0, 1.0);\n  float looplen = 0.5;\n  float off = rnd(id * 75.5238);\n  float fl = 1.0-fract(time*looplen + off);\n  fl = pow(fl,10.0);\n  //float il = floor(time*looplen);\n  float r2 = cos(r*10.0 + t2) * fl;\n\n\n  return r2*r;\n\n}\n\nfloat ripples(vec3 p) {\n\n  float r = 0.0;\n  for(int i=0; i<5; ++i) {\n    vec3 cur = p + vec3(rnd(float(i)), 0, rnd(float(i)+75.523));\n    cur *= rnd(float(i)+12.71)*0.2+0.8;\n    cur *= 3.0;\n    r += ripple(cur);\n  }\n  return r;\n}\n\nvec3 ripplenorm(vec3 n, vec3 p) {\n\n  vec2 off = vec2(0.01,0.0);\n\n  vec3 rn = normalize(vec3(ripples(p+off.xyy)-ripples(p-off.xyy), 1.9, ripples(p+off.yyx)-ripples(p-off.yyx)));\n  n.xz += rn.xz * (abs(n.y));\n  //n.y *= rn.y;\n  return n;\n  \n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot( sin(uv*vec2(784.553) + uv.yx*vec2(546.124)), vec2(7845.523) ));\n}\n\nfloat curve(float t, float r, float p) {\n  float g = t/r;\n  return mix(step(rnd(floor(g)), p), step(rnd(floor(g)+1.0), p), fract(g));\n}\n\nfloat shadow(vec3 s, vec3 r, float maxdist, float rn) {\n  float shad = 1.0;\n  int steps = SHAD_STEP;\n  vec3 raystep = r*maxdist/float(steps);\n  vec3 p = s + raystep*rn;\n  for(int i=0; i<steps; ++i) {\n    float d = map(p);\n    if(d<0.01) {\n      shad = 0.0;\n      break;\n    }\n    p += raystep;\n  }\n  return shad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(1,sin(time*0.3)*0.2,-3);\n  vec3 t = vec3(0,0,0);\n/*\n  float t1 = fract(time*0.1);\n  s.z += t1;\n  t.z += t1;\n\n  s -= tunnel(s);\n  t -= tunnel(t);\n  \n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(0,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  vec3 r = normalize(uv.x*cx + uv.y*cy + cz * 0.7);\n*/\n\n  vec3 r = normalize(vec3(-uv,0.7));\n  \n\n  \n  vec3 p = s;\n  float dd=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n\n  vec3 col = vec3(0.0);\n  vec3 n = norm(p);\n\n  n = ripplenorm(n, p);\n\n\n  float lightning = curve(time, 0.2, 0.1);\n  //float idlightning = floor(time/0.4-0.5);\n  float idlightning = 0.0;\n\n  float fog = 1.0-pow(clamp(dd/50.0,0.0,1.0),0.2);\n  vec3 lmoon = normalize(vec3(-8,-3,-3.0 + sin(idlightning)*3.0));\n\n  float shad = shadow(p + n * 0.02, lmoon, 3.0, rnd(uv));\n\n  col += lightning * 5.0 * max(0.0, dot(n, lmoon)) * fog * shad;\n\n  vec3 l = -getlightdir(p);\n  float ldist = lighting(p);\n\n  vec3 h = normalize(l-r);\n\n  //col += fract(length(light-p)*10.5);\n  //vec3 l = normalize(light-p);\n  //float ldist = dot(light-p, light-p);\n  col += max(0.0, dot(n, l)) * fog * 10.0 * (0.4 + 2.0*pow(max(0.0, dot(n,h)),30.0) )/(ldist*ldist*ldist*ldist);\n\n  float at = 0.0;\n  vec3 raining = vec3(0.0);\n  int steps = RAIN_STEPS;\n  float stepsize = 30.0 / float(steps);\n  vec3 raystep = r * stepsize / r.z;\n  //vec3 raypos = s + raystep;\n  for(int i=0; i<steps; ++i) {\n    vec3 raypos = s + raystep * (float(i)+1.0);\n    float tot = length(raypos-s);\n\n    if(tot>dd) break;\n    float fog2 = 1.0-pow(clamp(tot/40.0,0.0,1.0),0.5);\n\n    \n    vec3 ldir = getlightdir(raypos);\n    float l2dist = lighting(raypos);\n    float curlight = 1.0/pow(l2dist,2.0);\n\n    vec3 rainpos = raypos;\n    rainpos.xy *= rot(sin(float(i)*0.2)*0.01 + sin(time)*0.009);\n    rainpos.xy += rnd(float(i))*vec2(7.52,13.84);\n    raining += rain(rainpos) * fog2 * (lightning*0.5 + pow(curlight,2.0));\n\n    //vec3 ldir = light-raypos;\n    at += 0.04*curlight * fog2;\n    //raypos += raystep;    \n  }\n  col += at;\n  col += raining;\n/*\n  col = vec3(rain(vec3(-uv,5)));\n  col += rain(vec3(-uv*2.3,5)) * 0.5;\n  col += rain(vec3(-uv*4.7,5)) * 0.25;\n*/\n  //col = ripplenorm(n, vec3(-uv.x,0.0,-uv.y)); \n\n  col = pow(col, vec3(0.4545));\n\n  fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2GDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 343, 371, 371, 395], [397, 397, 425, 425, 449], [451, 451, 478, 478, 575], [577, 577, 596, 596, 665], [667, 667, 688, 710, 835], [837, 837, 876, 876, 959], [961, 961, 980, 980, 2555], [2558, 2558, 2582, 2582, 2832], [2834, 2834, 2853, 2853, 2961], [2963, 2963, 2989, 2989, 3117], [3119, 3119, 3139, 3139, 3184], [3186, 3186, 3206, 3206, 3360], [3362, 3362, 3384, 3384, 3844], [3846, 3846, 3869, 3869, 4075], [4077, 4077, 4110, 4110, 4317], [4319, 4319, 4339, 4339, 4425], [4427, 4427, 4467, 4467, 4562], [4564, 4564, 4619, 4619, 4878], [4880, 4880, 4937, 4937, 7479]]}
{"id": "wd2GWm", "name": "Dangling Chain", "author": "cbrpnk", "description": "everyday", "tags": ["raymarchingmetal"], "likes": 5, "viewed": 109, "published": "Public", "date": "1549069768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float torus(vec3 p, float r, float w)\n{\n    return sqrt(pow(length(p.xz)-r, 2.) + pow(p.y, 2.)) - w;\n}\n\nfloat cap(vec3 p, float l, float r)\n{\n    return length(vec3(0., p.y, 0.)-vec3(p.x, clamp(p.y, -l, l), p.z)) - r;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat chain(vec3 p) {\n    p = p.yxz;\n    p.x = mod(p.x+.9, 9.)-9.;\n    float t = torus(p, 3., 1.);\n    float t3 = torus(vec3(p.x+9., p.y, p.z), 3., 1.);\n    p.x += 4.5;\n    float t2 = torus(p.yzx, 3., 1.);\n    float c = cap(p, 5., 1.);\n    \n    float d = min(t, t2);\n    d = min(d, t3);\n    \n    return d;\n}\n\nfloat map(vec3 p)\n{\n    \n    p.xy = rotate(p.xy, dot(p.xz, vec2(-.5, -0.))*.01);\n    p.yx = rotate(p.yx, sin(iTime));\n    p.zx = rotate(p.zx, sin(iTime));\n    p.x += 3.*sin(iTime);\n\n    return chain(p);\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    \n    float td = 0.;\n    int i;\n    for(i=0; i<128; ++i) {\n    \tfloat d = map(ro+rd*td);\n        if(d < .001) break;\n        if(d > 200.) return vec2(-1.);\n        td += d*.5;\n    }\n    return vec2(td, i);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p-vec3(0.0001, 0., 0.)) - map(p+vec3(0.0001, 0., 0.)),\n        map(p-vec3(0., 0.0001, 0.)) - map(p+vec3(0., 0.0001, 0.)),\n        map(p-vec3(0., 0., 0.0001)) - map(p+vec3(0., 0., 0.0001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(0., 0., 70.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1));\n    //eye.xz = rotate(eye.xz, iTime*.2);\n    \n    vec2 res = march(eye, lookat);\n    vec3 col;\n    \n    if(res.x > 0.) {\n    \tvec3 normal = getNormal(eye + res.x*lookat);\n    \tcol = vec3(.7, .6, .5) * clamp(dot(normal, vec3(1. ,1., 0.5)), 0., 1.);\n        col *= 30.*vec3(pow(res.y/200., 2.));\n        col += .8*pow(clamp(dot(normal, vec3(-1., 0., -1.)), 0., 1.), 300.);\n        col = pow(col, vec3(.9));\n    } else {\n    \tcol = vec3(.04) * pow(clamp(dot(lookat, vec3(0., 0., -1)), 0., 1.), 5.);\n    }\n\t\n    \n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2GWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 102], [104, 104, 141, 141, 219], [221, 221, 251, 251, 331], [333, 333, 354, 354, 640], [642, 642, 661, 661, 846], [848, 848, 878, 878, 1089], [1091, 1091, 1115, 1115, 1349], [1351, 1351, 1408, 1408, 2149]]}
{"id": "wd2Gzc", "name": "What The Heck", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarching"], "likes": 2, "viewed": 83, "published": "Public", "date": "1549597316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, float r)\n{\n    p = abs(p);\n    float d = max(0., p.x-r);\n    d = max(d, p.y-r);\n    d = max(d, p.z-r);\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    \n    float s = sphere(p, 2.);\n    float s2 = sphere(p-vec3(1.3), 1.);\n    vec3 rp = p-vec3(.5);\n    rp = mod(rp+vec3(.5), 1.)-vec3(.5);\n    vec3 id = floor(p);\n    \n    rp.xz = rotate(rp.xz, iTime+id.x);\n    rp.yz = rotate(rp.yz, iTime+id.z);\n\tfloat d = min(1000., box(rp, .125*sin(iTime-p.z)));\n    d = min(d, max(s, -s2));\n    d = min(d, p.y);\n    d = min(d, p.x);\n    d = min(d, p.z);\n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n        float d = map(ro+rd*t);\n        if(d < .001) break;\n        if(t > 50.) break;\n        t += d*.6;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nfloat lightRay(vec3 p, vec3 normal, vec3 lightPos)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    float lightDst = length(lightPos - p);\n    float d = march(p+normal*.02, lightDir);\n    if(d >= lightDst) return 1.;\n    return 0.;\n}\n\nfloat getAo(vec3 p, vec3 normal)\n{\n    float d = march(p+normal*.02, normal);\n    return pow(d, .2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(1., 1., 6.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.+smoothstep(.2, .4, cos(iTime)*.1)));\n    eye.xz = rotate(eye.xz, -.3+sin(iTime)*.1);\n    eye.y += cos(iTime*2.)*.1;\n    eye.z += sin(iTime*2.)*.1;\n    lookat.xz = rotate(lookat.xz, -.4+sin(iTime)*.1);\n    \n    float d = march(eye, lookat);\n    vec3 p = eye + lookat*d;\n    \n    vec3 normal = getNormal(eye+lookat*d);\n    float ao = getAo(p, normal);\n    vec3 light = vec3(1., 1., 5.);\n    vec3 light2 = vec3(15., 5.5, 3.);\n    \n  \t\n    vec3 col = .05+.5*vec3(mod(floor(p.x)+floor(p.y)+floor(p.z), 2.));\n    col *= .5+.01*ao;\n    col += .05 * vec3(.5, .5, .6) * max(0., dot(normal, light));\n    col += .03 * vec3(.6, 1., 1.) * max(0., dot(normal, light2));\n    col += .07*lightRay(p, normal, light);\n    col += .07*lightRay(p, normal, light2);\n    col *= .1;\n    col *= 1.-d*.1;\n\n    // Output to screen\n    col *= 1.-length(uv)*.5;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2Gzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 110], [112, 112, 143, 143, 171], [173, 173, 201, 201, 309], [311, 311, 330, 330, 738], [740, 740, 771, 771, 948], [950, 950, 974, 974, 1202], [1204, 1204, 1256, 1256, 1439], [1441, 1441, 1475, 1475, 1543], [1545, 1545, 1602, 1652, 2713]]}
{"id": "Wd2Gzt", "name": "Rhombic Dodecahedron SDF", "author": "yx", "description": "Exploring more polyhedral SDFs.", "tags": ["math", "sdf", "dodecahedron"], "likes": 17, "viewed": 514, "published": "Public API", "date": "1549727776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\nconst vec3 color = vec3(.3,.01,.05);\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat scene(vec3 p)\n{\n    // minified version\n    p = abs(p);\n    p += p.yzx;\n    return (max(max(p.x,p.y),p.z)-1.) * sqrt(.5);\n    \n    // initial version - intersection of 3 planes in a mirrored space\n    /*p = abs(p);\n    float a = dot(p,normalize(vec3(0,1,1)))-sqrt(2.)*.5;\n    float b = dot(p,normalize(vec3(1,0,1)))-sqrt(2.)*.5;\n    float c = dot(p,normalize(vec3(1,1,0)))-sqrt(2.)*.5;\n    return max(max(a,b),c);*/\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t;\n    for(int i = 0; i < 100; ++i)\n    {\n        float k = scene(cam+dir*t);\n        t += k;\n        if (k < .001)\n        {\n            vec3 h = cam+dir*t;\n    \t\tvec2 o = vec2(.001, 0);\n    \t\tvec3 n = normalize(vec3(\n        \t\tscene(h+o.xyy)-scene(h-o.xyy),\n        \t\tscene(h+o.yxy)-scene(h-o.yxy),\n        \t\tscene(h+o.yyx)-scene(h-o.yyx)\n    \t\t));\n\n\t\t\tif (iMouse.z > 0.)\n    \t\t{\n        \t\treturn n*.5+.5;\n    \t\t}\n    \t\telse\n    \t\t{\n                const vec3 lightdir = normalize(vec3(1,5,2));\n                \n\t\t        float light = dot(n,lightdir)*.5+.5;\n\t\t\n\t\t        return light * color;\n    \t\t}\n        }\n    }\n    return vec3(1);\n}\n\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15.);\n    vec3 dir = normalize(vec3(uv,6));\n\n    cameraspin(cam);\n    cameraspin(dir);\n    \n    out_color.rgb = trace(cam,dir);\n    if (iMouse.z <= 0.)\n    {\n    \tout_color.rgb *= pow(color, vec3(2.*dot(uv,uv)));\n    \tout_color.rgb = pow(out_color.rgb,vec3(.45));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2Gzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 92, 92, 215], [217, 217, 238, 262, 640], [642, 642, 674, 674, 1326], [1328, 1328, 1359, 1359, 1425], [1427, 1427, 1479, 1479, 1870]]}
{"id": "wdB3Dd", "name": "Bandeira Russia", "author": "Isabella", "description": "Aula 2", "tags": ["tjd05"], "likes": 1, "viewed": 58, "published": "Public", "date": "1550705000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n        fragColor = vec4(0,0,0,1);       \n    \n    float balanco=(sin(iTime+(uv.x*4.0))/20.0);\n\n    // Output to screen    \n    if(uv.y<0.05+balanco){} \n    else if(uv.x<0.1+balanco){}\n    else if(uv.x>0.9+balanco){}\n    else if(uv.y>0.8+balanco){}\n    else   if(uv.y<0.3+balanco){\n        fragColor = vec4(5,0,0,0)*1.0-balanco*5.0;\n    }else if(uv.y>0.55+balanco){\n        fragColor = vec4(1,1,1,1)*1.0-balanco*5.0; \n    }else\n       fragColor = vec4(0,0,.8,0)*1.0-balanco*5.0;     \n}\n        \n    \n        \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdB3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 637]]}
{"id": "WdB3Rd", "name": "Random Worm", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarching"], "likes": 2, "viewed": 60, "published": "Public", "date": "1549670459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smu( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    p.xz *= rotate(iTime);\n    p += .5;\n    float s =100.;\n    \n    //p = abs(p);\n    for(int i=0; i<15; ++i) {\n        p -= .2;\n        p.xz *= rotate(sin(iTime*1.4));\n        p.yz *= rotate(cos(iTime*2.));\n        //s = min(s, length(p)-sqrt(float(i))*.2);\n        s = smu(s, length(p)-sqrt(float(i))*.015, 1.);\n    }\n    \n    return s;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n        float d = map(ro+rd*t);\n        if(d < .001) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 eps = vec3(.001, 0., 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(0., 0., 15.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    vec3 normal = getNormal(p);\n    vec3 col = normal;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdB3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 95], [97, 97, 139, 139, 238], [240, 240, 259, 259, 600], [602, 602, 633, 633, 780], [782, 782, 806, 806, 997], [999, 999, 1056, 1106, 1450]]}
{"id": "wdB3RK", "name": "Baobabs", "author": "cbrpnk", "description": "everyday", "tags": ["raymarching"], "likes": 8, "viewed": 120, "published": "Public", "date": "1549325594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat random(vec2 p) {\n    return fract(sin(dot(p, vec2(123.3345, 876.654))) * 984594.2343);\n}\n\nfloat perlin(vec2 p){\n    p *= 10.;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float bl = random(i);\n    float br = random(i + vec2(1, 0));\n    float tl = random(i + vec2(0, 1));\n    float tr = random(i + vec2(1, 1));\n    \n    float x = mix(bl, br, smoothstep(0., 1., f.x));\n    float y = mix(tl, tr, smoothstep(0., 1., f.x));\n    return mix(x, y, smoothstep(0., 1., f.y));\n}\n\nfloat voronoi(vec2 p)\n{   \n    p *= 3.;\n    p = mod(p+vec2(1.), 2.)-vec2(1.);\n    p = abs(p);\n    \n    float d = 1000000.;\n    float alpha = .25;\n    \n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<2; ++j) {\n            float x = float(i);\n            float y = float(j)+.5*x; \n            d = min(d, length(p-vec2(x, y)));\n        }\n    }\n    \n    return d;\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat caps(vec3 p)\n{\n    return .1;\n}\n\nfloat torus(vec3 p)\n{\n    return sqrt(pow(length(p.xz) - .8, 2.) + pow(p.y, 2.)) - .5 + voronoi(p.xz)*.2;\n}\n\nfloat map(vec3 p)\n{\n    p.x += iTime*.3;\n    p.z -= iTime*.3;\n    \n    p.xz = mod(p.xz+vec2(2.), 5.3)-vec2(2.);\n    \n    vec2 proj;\n    proj.x = dot(vec3(1., 0., 0.), vec3(p.x, 0., p.z));\n    proj.y = dot(vec3(0., 1., 0.), vec3(0., p.y, p.z));\n    float s = sphere(p-vec3(0., .3, 0.), 1.) - voronoi(proj+perlin(-proj)*.9)*.1;\n    float t = torus(p-vec3(0., .3, 0.));\n    \n    float d = max(s, -t);\n    \n    // Floor\n    d = min(d, p.y + voronoi(vec2(perlin(p.xz*.2)*.01)) + perlin(p.xz)*.01);\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<328; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .01) break;\n        if(t > 40.) return -1.;\n        t += d*.4;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0., .02, 3.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.));\n    lookat.yz = rotate(lookat.yz, .35);\n    lookat.xz = rotate(lookat.xz, iTime*.3);\n\t\n    \n    float d = march(eye, lookat);\n    \n    vec3 col;\n    if(d < 0.) {\n        col = mix(vec3(.5, .4, 1.), vec3(.5, .5, 1.), uv.y*5.);\n    } else {\n        vec3 p = eye+lookat*d;\n    \tvec3 normal = getNormal(p);\n    \tcol = .5*vec3(.1) + .5*vec3(.2) * dot(normal, vec3(0., 1., 0.));\n        col += vec3(.1);\n        col *= .1*vec3(.4, 1., .2);\n        col += .3* vec3(1., .5, .5) * clamp(dot(vec3(0., 0. ,1.), normal), 0., 1.);\n        col.r += p.y*.1*d/20.;\n        col *= p.y;\n        col = mix(col, vec3(.5, .4, 1.), d/67.);\n\t}\n\t\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdB3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 110], [112, 112, 134, 134, 206], [208, 208, 229, 229, 595], [597, 597, 620, 620, 962], [965, 965, 996, 996, 1024], [1026, 1026, 1046, 1046, 1063], [1065, 1065, 1086, 1086, 1172], [1174, 1174, 1193, 1193, 1687], [1689, 1689, 1720, 1720, 1898], [1900, 1900, 1924, 1924, 2152], [2154, 2154, 2211, 2211, 3071]]}
{"id": "WdB3Ry", "name": "Pla.net", "author": "Gaxil", "description": "First planet rendering & first shadertoy shader ... I use a trick for the planet normal map that compute a normal with only two height samples, it's definitely a shortcut but the result is ok.\nBeside that, I uses some tricks and code from IQ (thanks BTW!)", "tags": ["raytracing", "earth", "space", "planet"], "likes": 21, "viewed": 882, "published": "Public", "date": "1549208739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define OCEANS_LEVEL .60\n#define PLANETCENTER vec3(-4, -3, 25)\n#define PLANETRADIUS 7.0\n#define MOONCENTER vec3(54, -50, 145)\n#define MOONRADIUS 7.0\n#define ATMOSPHERETHICKNESS .5\n#define ATMOSPHEREDENSITY 2.0\n#define LIGHTPOS vec3(20*3, 15*3, 10)\n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    // from Inigo Quilez\n    // http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    // from IQ\n    // https://www.shadertoy.com/view/lllXz4\n\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nfloat GetHash1(float p)\n{\n    // from IQ\n    return fract(sin(p)*158.5453123);\n}\n\nfloat GetHash(vec3 p)\n{\n    // from IQ\n\tp  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat GetNoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( GetHash(p+vec3(0,0,0)), \n                        GetHash(p+vec3(1,0,0)),f.x),\n                   mix( GetHash(p+vec3(0,1,0)), \n                        GetHash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( GetHash(p+vec3(0,0,1)), \n                        GetHash(p+vec3(1,0,1)),f.x),\n                   mix( GetHash(p+vec3(0,1,1)), \n                        GetHash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat GetFBM(vec3 p)\n{\n    float noise = 0.0;\n    \n    // Domain warping\n    vec3 warp = vec3(GetNoise(p*0.8+vec3(13.0, 44.0, 15.0)),\n                     GetNoise(p*0.8+vec3(43.0, 74.0, 25.0)),\n                     GetNoise(p*0.8+vec3(33.0, 14.0, 75.0)));\n                     \n    warp -= vec3(0.5);\n    \n    p+= vec3(123.0, 234.0, 55.0);\n    p+= warp*0.6;\n    \n    noise = GetNoise(p) * 1.0 +\n\t        GetNoise(p*2.02) * 0.49 + \n\t        GetNoise(p*7.11) * 0.24 + \n\t        GetNoise(p*13.05) * 0.12 + \n\t        GetNoise(p*27.05) * 0.055 + \n\t        GetNoise(p*55.25) * 0.0025+ \n\t        GetNoise(p*96.25) * 0.00125; \n\n    return noise;\n}\n\nfloat GetFBMClouds(vec3 p)\n{\n    float noise = 0.0;\n    // Domain warping\n    vec3 warp = vec3(GetNoise(p*0.8+vec3(13.0, 44.0, 15.0)),\n                     GetNoise(p*0.8+vec3(43.0, 74.0, 25.0)),\n                     GetNoise(p*0.8+vec3(33.0, 14.0, 75.0)));\n                     \n    warp -= vec3(0.5);\n    \n    p+= vec3(123.0, 234.0, 55.0);\n    p+= warp*0.2;\n    \n    noise = GetNoise(p) * 1.0 +\n\t        GetNoise(p*5.02) * 0.49 + \n\t        GetNoise(p*11.11) * 0.24 + \n\t        GetNoise(p*23.05) * 0.12 +\n\t        GetNoise(p*45.05) * 0.055; \n\treturn noise;\n}\n\nvec3 GetNormal(vec3 p) \n{\n    return normalize(p-PLANETCENTER);\n}\n\nfloat GetSceneDistance(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n \n    vec2 inter = sphIntersect( ro, rd, PLANETCENTER, PLANETRADIUS);\n\tif (inter.x>=0.0)\n        return inter.x;\n    else\n        return MAX_DIST;\n}\n\nvec3 RotateY(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x * cos(angle) - pos.z * sin(angle),\n        pos.y,\n        pos.x * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nvec3 RotateX(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x,\n        pos.y * cos(angle) - pos.z * sin(angle),\n        pos.y * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nfloat GetLight(vec3 p, vec3 n, float height, float waterMask) \n{\n    vec3 lightPos = LIGHTPOS;\n    vec3 l = normalize(lightPos-p);\n\n    // Tricky way to compute the normal ... seems acceptable on screen, only one extra height sample to compute\n    vec3 pBis =normalize(p+l*0.01 - PLANETCENTER)*0.5*PLANETRADIUS;\n    pBis = RotateY(pBis, iTime*0.05);\n    float heightBis = GetFBM(pBis) * 0.6;\n    float deltaH = heightBis-height;\n    \n   \tn = normalize(n-deltaH*l*40.0*(1.0-waterMask));\n    \n    float dif = dot(n, l); // can go - (used for night lights)\n    float d = GetSceneDistance(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nfloat Density(vec3 pos)\n{\n    float distanceToCenter =  length(pos - PLANETCENTER);\n    float relativePos = clamp((distanceToCenter-PLANETRADIUS)/ATMOSPHERETHICKNESS, 0.0, 1.0);\n    \n    return ATMOSPHEREDENSITY* exp(-relativePos);\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.03;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 RayTrace(vec3 ro, vec3 rd, vec4 noise) \n{\n\tvec3 color = vec3(0,0,0);\n    \n    float dist = GetSceneDistance(ro,rd);\n\n    vec2 atmosInOut = sphIntersect( ro, rd, PLANETCENTER, ATMOSPHERETHICKNESS+PLANETRADIUS);\n    \n    if (dist<MAX_DIST)\n    {\n        // Hit planet\n\n        atmosInOut.y = dist;\n        vec3 pos = ro + rd * dist;   \n\t\tvec3 n = GetNormal(pos);\n        \n        vec3 localPos = (pos - PLANETCENTER)*0.5;\n\t\tlocalPos = RotateY(localPos, iTime*0.05);\n        float heatDistribution = smoothstep(2.5, 0.5, (abs(localPos.y) + GetNoise(localPos+vec3(-20,55,20))));\n        \n        float height = GetFBM(localPos) * 0.6;\n        float waterMask = smoothstep(OCEANS_LEVEL+0.05, OCEANS_LEVEL-0.05, height);\n\n        float waterHeight = clamp((height / OCEANS_LEVEL),0.0,1.1); \n        float groundHeight = clamp(((height-OCEANS_LEVEL) / (1.0-OCEANS_LEVEL)),0.0,1.0); \n        float foamNoise =  GetNoise(localPos*7.0*(0.75+0.25*sin(iTime*0.1)))*0.25;\n        float foamLimit = smoothstep(0.6+foamNoise, 1.0, waterHeight);\n        foamLimit = 0.7*foamLimit + 0.3*fract(foamLimit*4.0-iTime*.2)*foamLimit*smoothstep(1.0, 0.85, foamLimit);\n\n\t\tfloat iceDistribution = smoothstep(4.0, 4.3, foamLimit + smoothstep(0.7, 0.85, height)*0.25+ (abs(localPos.y) -waterMask*0.5 + height*0.5 + GetNoise(localPos+vec3(-20,55,20))));\n\t\tfloat wideIceDistribution = smoothstep(2.5, 3.0, foamLimit + smoothstep(0.7, 0.85, height)*0.25+ (abs(localPos.y) -waterMask*0.5 + height*0.5));\n\n        float flatening = waterMask*(1.0-iceDistribution);\n        flatening = max(flatening, iceDistribution*0.75);\n        \n        float light = GetLight(pos, n, height, flatening);\n        float dif = clamp(light, 0., 1.);\n        float invdif = smoothstep(0.1, 0.1-0.05, light);\n        \n\t\tvec3 lightPos = LIGHTPOS;\n\t    vec3 l = normalize(lightPos-pos);\n\t    float rawNdotL = clamp(dot(n, l), 0.0, 1.0);\n        rawNdotL = smoothstep(0.0, 0.2, rawNdotL);\n\t\tdif = max(dif,rawNdotL*0.4); \n        dif*=rawNdotL;\n        \n        vec3 groundColor = mix (vec3(.3,.1,0), vec3(1.0,.5,.40),clamp(groundHeight*3.0, 0.0, 1.0));\n        groundColor = mix (groundColor, vec3(0.76,.36,.36),clamp((groundHeight-0.23)*3.0, 0.0, 1.0));\n        groundColor = mix (groundColor, vec3(0.86,.8,.8),clamp((groundHeight-0.53)*6.0, 0.0, 1.0));\n        vec3 hotWaterColor =mix (vec3(0.0,.2,.6), vec3(0.0,.4,1.00),smoothstep(0.0, 0.9, waterHeight)); \n        vec3 coldWaterColor =mix (vec3(0.15,.3,0.500), vec3(0.2,0.5,.7), smoothstep(0.0, 0.9, waterHeight)); \n        vec3 waterColor =mix (coldWaterColor, hotWaterColor, heatDistribution); \n\t\twaterColor = mix (waterColor , vec3(0.7,.8,0.9),foamLimit);\n\n        vec3 finalColor = mix(groundColor, waterColor, waterMask);\n\n\t\tfinalColor = mix (finalColor, mix(vec3(1.1,1.1,1.1),vec3(.9,1.0,1.0),abs(sin(height*10.0))), iceDistribution);\n\n        float fresnel =pow (1.0-clamp(dot(n, -rd), 0., 1.), 3.0);\n\n        invdif*= (1.0-fresnel);\n        dif *= (1.0-fresnel);\n        color = vec3(dif) * finalColor;\n        \n\t\tfloat citiesLimit = smoothstep(0.0, 0.1, groundHeight)*smoothstep(0.15, 0.13, groundHeight)*(1.0-waterMask)*(1.0-iceDistribution);\n\n        float greenArea = smoothstep(0.0, 0.01, groundHeight)*smoothstep(0.45, 0.3, groundHeight)*(1.0-waterMask)*(1.0-wideIceDistribution);\n\n        vec2 cityInfo = inverseSF(normalize(localPos), 150.0)+\n            inverseSF(normalize(localPos), 100.0);\n        localPos = normalize(localPos);\n        \n        vec2 lightInfo1 = inverseSF(localPos, 23000.0);\n        vec2 lightInfo2 = inverseSF(RotateX(localPos, 1.0), 38000.0);\n        vec2 lightInfo3 = inverseSF(RotateX(localPos, 1.5), 33000.0);\n\n        float townMask = smoothstep(0.28, 0.1, cityInfo.y);\n        \n\t\tfloat lightIntensity = min(min(lightInfo1.y*1.25*(1.0+smoothstep(0.8,0.4, GetHash1((lightInfo1.x)*.015))), \n\t\t\t\t\t\t\t\tlightInfo2.y*1.75*(1.0+smoothstep(0.8,0.4, GetHash1((lightInfo1.x)*.015)))\n                                ), lightInfo3.y*(1.0+smoothstep(0.8,0.4,GetHash1((lightInfo1.x)*.015))));\n\t\tlightIntensity = smoothstep(0.01, 0.000, lightIntensity);\n        \n        float cityArea = smoothstep(0.2, 0.18, cityInfo.y) * citiesLimit;\n\t\tcitiesLimit*=townMask* lightIntensity;\n\t        \n        greenArea *=smoothstep(0.4, 0.3, cityInfo.y)*smoothstep(0.25, 0.28, cityInfo.y);\n        color = mix (color,vec3(dif) * mix(vec3(.45, .65, .15),vec3(.1, .35, .1), GetNoise(localPos*150.0))\n                     , clamp(greenArea-GetNoise(localPos*70.0)*0.6, 0.0, 1.0));\n        \n        color = mix (color, vec3(.15, .15, .15), cityArea);\n        color = mix(color, vec3(.35, .35, .35), clamp(citiesLimit*2.0, 0.0, 1.0));\n    \tcolor += vec3(0.95, 0.8, 0.5)*invdif*citiesLimit*2.0;\n  \n\t\tvec3 localPosClouds = (pos - PLANETCENTER)*0.25;\n\t\tlocalPosClouds = RotateY(localPosClouds, iTime*0.055 + localPosClouds.y*0.85);\n        float clouds = GetFBMClouds(localPosClouds*3.0-vec3(iTime*0.025)) * 0.6;\n\n\t\tvec3 localPosCloudsBis = (pos+l*0.1 - PLANETCENTER)*0.25;\n\t\tlocalPosCloudsBis = RotateY(localPosCloudsBis, iTime*0.055);\n        float cloudsBis = GetFBMClouds(localPosCloudsBis*3.0-vec3(iTime*0.025)) * 0.6;\n\n        float level = smoothstep(OCEANS_LEVEL-0.1, OCEANS_LEVEL+0.6, height);\n        clouds = smoothstep(0.5+level*0.85, 0.8+level*0.85, clouds);\n        float cloudShadow = 1.0-smoothstep(0.5+level*0.85, 1.0+level*0.85, cloudsBis)*0.75*(1.0 - clamp(dot(n, l), 0.0, 1.0));\n        \n        color = mix (color*cloudShadow, vec3(1)*rawNdotL*cloudShadow, clouds);\n    }\n    else\n    {\n        \n\t\tfloat dO=0.;\n \n\t    vec2 inter = sphIntersect( ro, rd, MOONCENTER, MOONRADIUS);\n\t\tif (inter.x>=0.0)\n        {\n            // moon hit\n            \n            vec3 hitPos = inter.x * rd + ro;\n            vec3 hitNormal = normalize(hitPos-MOONCENTER);\n       \t\tvec3 lightPos = LIGHTPOS;\n\t\t    vec3 l = normalize(lightPos-hitPos);\n\n            float dif = clamp(dot(l, hitNormal), 0.0, 1.0);\n            float noise = GetFBM(hitPos*0.4);\n            color = mix(vec3(0.2), vec3(.4), noise)*dif;\n        }\n\t\telse\n        {\n            // background\n            \n            vec3 pos = normalize(ro + rd * 1000.0);   \n            pos = pos.xyz;\n\n            for(float i=0.0;i<5.0;i++)\n            {\n                vec2 info = inverseSF(pos, 50000.0 + i*5000.0);\n                float random = GetHash1((info.x + i*10.0)*.015);\n                float distToStar = smoothstep(0.00025+0.0015*pow((1.0-random), 15.0), 0.0002,info.y) * smoothstep(0.1, 0.0,random ); \n\n                color = max(color, vec3(distToStar));\n            }\n                \n            float noise = GetFBM(pos*2.0 + vec3(0.0, 0.0, iTime*0.05));\n            float nebulae = smoothstep(0.4, 1.8, noise);\n\t\t\tfloat nebulae1 = max(0.3-abs(nebulae-0.3), 0.0)*1.0;\n\t\t\tfloat nebulae2 = max(0.2-abs(nebulae-0.4), 0.0)*1.0;\n\t\t\tfloat nebulae3 = max(0.3-abs(nebulae-0.5), 0.0)*1.0;\n\n            vec3 nebulaeColor = vec3(0.0, 0.2, 0.7)*nebulae1 + vec3(0.5, 0.4, 0.3)*nebulae2 + vec3(0.1, 0.2, 0.4)*nebulae3;\n\n            color += nebulaeColor;\n        }        \n    }\n    \n    if (atmosInOut.x>=0.0)\n    {\n        float density = .1;\n        \n        atmosInOut.x-=noise.r;\n        // Atmosphere\n        float atmosphereToGo = atmosInOut.y - atmosInOut.x;\n        \n        vec3 startPosition = ro + rd * atmosInOut.x;\n        \n        float lightEnergy  = 0.0;\n        float transmittance = 1.0;\n        float steps = 0.0051;\n        for(float i = 0.0; i<atmosphereToGo;i+=steps)\n        {\n\t\t\tvec3 pos = startPosition+rd*i;\n            \n            float localDensity = Density(pos)*steps;\n            vec3 lightDir = -normalize(pos-LIGHTPOS);\n            float shadow = GetSceneDistance(pos, lightDir);\n            shadow = step(MAX_DIST*0.9, shadow);\n            \n            lightEnergy+=  localDensity * shadow;\n\t\t\ttransmittance *= (1.0-localDensity*1.0);\n            \n        }\n        color = mix(color, \n                    mix( vec3(0.1,0.15,0.7), vec3(0.65,0.8,1.0),(1.0-exp(-lightEnergy*0.6)))\n                        *clamp(lightEnergy*0.5, 0.0, 1.0),(1.0-transmittance)* (1.0-exp(-lightEnergy*0.6)));\n    }\n    \n\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 noise = texture(iChannel0, fragCoord/1024.0); \n    vec3 offset =  vec3(sin(iTime*0.1)*3.0, 0.25+(cos(iTime*0.1)*.5), 0);\n    offset = mix(offset, vec3(4.0-iMouse.x/iResolution.x*8.0, 4.0-(iMouse.y/iResolution.y)*8.0, 0), step( 0.001, iMouse.z ));\n    \n    vec3 ro = offset + vec3(0.0, 12.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 2));\n    rd = RotateX(rd, 0.5);\n    vec3 col = RayTrace(ro, rd, noise);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}, {"id": "MlfGW8", "previewfilepath": "https://soundcloud.com/gil-damoiseaux/mistymorning", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/gil-damoiseaux/mistymorning", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdB3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 383, 450, 547, 768], [770, 770, 806, 866, 2061], [2063, 2063, 2088, 2103, 2143], [2145, 2145, 2168, 2183, 2275], [2277, 2277, 2306, 2306, 2804], [2806, 2806, 2828, 2828, 3446], [3448, 3448, 3476, 3476, 4007], [4009, 4009, 4034, 4034, 4074], [4076, 4076, 4118, 4118, 4284], [4286, 4286, 4324, 4324, 4459], [4461, 4461, 4499, 4499, 4634], [4636, 4636, 4700, 4700, 5305], [5307, 5307, 5332, 5332, 5540], [5542, 5542, 5573, 5573, 5686], [5688, 5688, 5734, 5734, 13827], [13829, 13829, 13886, 13886, 14398]]}
{"id": "WdB3Wd", "name": "Purple Tiles", "author": "polymonster", "description": "Animating tiles made from a concept background for a game.", "tags": ["tiles"], "likes": 9, "viewed": 433, "published": "Public", "date": "1550271483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from gold noise\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat rand(vec2 coordinate, float seed)\n{\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nfloat isolate_tile(vec2 uv, vec2 tile_size2, float isox, float isoy)\n{\n    if(uv.x < tile_size2.x * isox || uv.x > tile_size2.x * isox + tile_size2.x)\n        return 0.0;\n    \n    if(uv.y < tile_size2.y * isoy || uv.y > tile_size2.y * isoy + tile_size2.y)\n        return 0.0;\n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 palette[6];\n    palette[0] = vec3(109.0, 31.0, 165.0) / 255.0;\n    palette[1] = vec3(154.0, 71.0, 203.0) / 255.0;\n    palette[2] = vec3(123.0, 39.0, 143.0) / 255.0;\n    palette[3] = vec3(122.0, 74.0, 235.0) / 255.0;\n    palette[4] = vec3(203.0, 163.0, 255.0) / 255.0;\n    palette[5] = vec3(97.0, 37.0, 143.0) / 255.0;\n    \n    vec3 gradient[4];\n    gradient[0] = vec3(37.0, 6.0, 100.0) / 255.0;\n    gradient[1] = vec3(252.0, 194.0, 255.0) / 255.0;\n    gradient[2] = vec3(188.0, 66.0, 208.0) / 255.0;\n    gradient[3] = vec3(165.0, 110.0, 228.0) / 255.0;\n    \n    // tweakables\n    float tile_size = 0.025;\n    float x_offset = 12.0;\n    float y_tiles = 24.0;\n    float centre_width = 16.0;\n    \n    vec2 aspect = iResolution.xy / iResolution.xx;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    // tile mask\n    vec2 tile_size2 = vec2(tile_size, tile_size) / aspect;\n    vec2 mm = mod(uv * aspect, tile_size);\n    vec2 mv = smoothstep(0.0, tile_size, mm);\n    \n    float edge = 0.025;\n    \n    vec2 tile = step(mv, vec2(edge) * aspect);\n    \n    // tile isolate centre\n    for(int i = 0; i < 70; ++i)\n    {        \n        float ep = 0.00001;\n        float xx = floor(rand(vec2(iTime * ep + float(i), iTime * ep + float(i) * 5.0), float(i)) * centre_width);\n        \n    \tfloat yy = floor(rand(vec2(iTime * ep + float(i) * 3.0, iTime * ep + float(i)), float(i)) * y_tiles);\n    \n\t\tcol.rgb += isolate_tile(uv, tile_size2, x_offset + xx, yy);\n    }\n    \n    // tile isolate sides\n    for(int i = 0; i < 25; ++i)\n    {        \n        float ep = 0.000002;\n        float xx = floor(rand(vec2(iTime * ep + float(i), iTime * ep + float(i) * 5.0), float(i)) * 40.0);\n        \n    \tfloat yy = floor(rand(vec2(iTime * ep + float(i) * 3.0, iTime * ep + float(i)), float(i)) * 16.0);\n    \n\t\tcol.rgb += isolate_tile(uv, tile_size2, xx, yy + 4.0);\n    }\n    \n    // tile animation\n    float yanim = mod(floor(iTime * 30.0), 40.0);\n    for(int i = 0; i < 16; ++i)\n    {\n        for(int j = 0; j < 16; ++j)\n    \t{\n            float xx = floor(rand(vec2(float(j), float(j)), 0.0)* 10.0);\n            float yy = mod(yanim + float(i) + float(j) * 2.0, 40.0);\n        \tcol.rgb += isolate_tile(uv, tile_size2, float(j) + 12.0, yy + xx);\n        }\n    }\n     \n    col.rgb *= clamp(1.0 - (tile.x + tile.y), 0.0, 1.0);\n    vec3 inv_tile = clamp(1.0 - col.rgb * 0.1, 0.0, 1.0);\n    \n    if(length(col.rgb) > 0.99)\n    {        \n        float px = floor(uv.x / tile_size2.x);\n        float py = floor(uv.y / tile_size2.y);\n        float rp = mod( floor(rand(vec2(px, py), 0.0) * 126.0), 6.0);\n        \n        col.rgb = vec3(0);\n        \n        for(int pp = 0; pp < 6; ++pp)\n            if(length(rp - float(pp)) < 0.2)\n        \t\tcol.rgb += palette[pp];\n            \n        col.rgb += (mm.x * 2.0 / tile_size2.x + mm.y * 2.0 / tile_size2.y) * 0.1;\n        col.rgb *= 0.8;\n    }\n    \n    // gradient background\n    vec2 ndc = (uv * 2.0 - 1.0);\n    \n    float r = clamp( 1.0 - length(ndc*aspect), 0.0, 1.0);\n    vec2 r2 = clamp( vec2(r + sin(iTime) * 0.2, r + cos(iTime)), 0.0, 1.0); \n    \n    // col.rgb *= 1.0 - vec3(r2.x, r2.y, r) * 1.0 - inv_tile;\n    \n    vec3 bg = mix(gradient[0], gradient[1], r2.x);\n    bg = mix(gradient[2], bg, r2.y);\n    bg = mix(gradient[0], bg, r);\n    bg = mix(bg, gradient[1], max((1.0 - uv.y) * sin(iTime) * 0.7, 0.0));\n    \n    col.rgb += bg * inv_tile;\n    \n    // tile modulate\n    col.rgb *= 1.0 - bg * (1.0 - inv_tile);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdB3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 214, 255, 255, 332], [334, 334, 404, 404, 632], [634, 634, 691, 691, 4232]]}
{"id": "WdB3zc", "name": "Voronoi Island", "author": "willstall", "description": "I absolute adore topography and procedural generation. This is my very first attempt at an island by breaking down voronoi spaces.", "tags": ["procedural", "voronoi", "sdf", "topography"], "likes": 4, "viewed": 204, "published": "Public", "date": "1549475864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tWill Stallwood\n\thttps://www.instagram.com/willstall/\n\n*/\n\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random( in vec2 st )\n{\n\treturn fract( sin( dot(st.xy, vec2(-30.950,-10.810) )) * 43758.5453123  );\t    \n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nfloat sdf_iso_lines(float sdf,float amt,float size, float ratio)\n{\n    // float amt = 0.02;\n    // float size = 0.01;\n    float half_amt = amt * .5;\n\n    float minor = abs(fract(sdf/amt + 0.5)-0.5)*1.0;\n    float major = abs(fract(sdf/(amt*ratio) + 0.5)-0.5)*1.0;\n\n    minor = smoothstep(half_amt-size,half_amt+size,minor);\n    major = smoothstep(half_amt-size,half_amt+size,major);\n\n    float t = major*minor;\n    return t;    \n}\n\n// iq\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // config\n    float scale = 3.0;\n    float t = iTime/30.0 * 5.0;        // code works but is off by 1.0, this is a 6 second animation\n\n    //vec2 st = gl_FragCoord.xy / u_resolution.xy;\n    vec2 st = fragCoord/iResolution.xy;\n    st = center( st );\n\n    vec2 origin_st = st;\n\n    // modulate\n    float r = noise(vec2(st.x+t, st.y));\n\n    float offset = 0.07;\n    vec2 pos = vec2(0.5);\n        pos.x += offset * sin(TWO_PI*t);\n        pos.y += offset * cos(TWO_PI*t);\n\n    st.x += offset * sin(TWO_PI*t);\n    st.y += offset * cos(TWO_PI*t);\n\n    \n    \n    // sdf\n    float c = 1.0 - length(origin_st-pos);\n    c -= .70;\n\n    float d = 1.0;\n    d = c;\n\n    // voronoi\n    vec2 sSt = st * scale * scale;\n    vec2 iSt = floor(sSt);\n    vec2 fSt = fract(sSt);\n    vec2 seed = vec2(31.00,1.0);    \n    vec2 p;\n\n    // get sdf based on neighbors\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            vec2 offset = vec2(x,y);            \n            vec2 point = random2(iSt+offset+seed);\n            float diff = length(fSt-point-offset)*d;\n\n            if(d > diff)\n            {\n                d = diff;\n                p = point;\n            }\n        }\n    }\n\n    // shade island\n    float outside =  smoothstep(0.062,0.063,d+.04);\n    float z = 1.0;\n    \n    z = sdf_iso_lines(d,pow(d,1.3),0.4,0.25);  // get isolines\n    z = smoothstep(0.50,0.56,z);    // refine islines\n    z = outside * smoothstep(0.0,1.0,z);   // remove outside\n    z += 1.0-outside;   // remove holes\n\n    float shade = max(c,1.0-outside);\n\n    // color\n    vec3 color = vec3(0.04);\n    color = mix( color, vec3(1.0),1.0-z);\n\n    // vignette\n    c = length(origin_st-0.5);\n    color += (vec3(-0.18)*c*random(origin_st)*.5+.1);\n\t\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdB3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 147, 171, 171, 264], [266, 266, 294, 294, 377], [379, 379, 405, 405, 922], [924, 924, 950, 950, 1017], [1019, 1019, 1041, 1041, 1153], [1155, 1155, 1221, 1272, 1585], [1587, 1593, 1640, 1640, 1734], [1736, 1736, 1791, 1805, 3575]]}
{"id": "wdB3zt", "name": "Baby's First Toy", "author": "FergoTheGreat", "description": "Something of no consequence.", "tags": ["sdf", "motionblur", "antialias"], "likes": 2, "viewed": 190, "published": "Public", "date": "1549675502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n#define ISQRT_2 0.7071067811865475\n\nuint hash(uint x)\n{\n    x = ((x >> 16) ^ x) * 0x85ebca6bu;\n    x = ((x >> 13) ^ x) * 0xc2b2ae35u;\n    x = ((x >> 16) ^ x);\n    return x;\n}\n \nuint hash(uvec2 v) { return hash(v.y ^ hash(v.x)); }\nuint hash(uvec3 v) { return hash(v.z ^ hash(v.y ^ hash(v.x))); }\nuint hash(uvec4 v) { return hash(v.w ^ hash(v.z ^ hash(v.y ^ hash(v.x)))); }\n\nfloat floatConstruct(uint m)\n{\n    m &= 0x007FFFFFu;\n    m |= 0x3F800000u;\n\n    float  f = uintBitsToFloat(m);\n    return f - 1.0;\n}\n\nfloat random(float x) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random(vec2 v) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random(vec3 v) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random(vec4 v) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rotate(vec2 p, float r)\n{\n\tfloat angle = r * PI * -2.0;\n    float s = sin(angle), c = cos(angle);\n    return vec2(c * p.x + s * p.y, c * p.y - s * p.x);\n}\n\nvec2 translate(vec2 p, vec2 offset)\n{\n\treturn p - offset;   \n}\n\nfloat sdComplexShape(vec2 p)\n{\n\tfloat circle = sdCircle(p, 100.0);\n    float h0 = sdCircle(translate(rotate(p, 0.0), vec2(0.0, 60.0)), 25.0);\n    float h1 = sdCircle(translate(rotate(p, 0.2), vec2(0.0, 60.0)), 25.0);\n    float h2 = sdCircle(translate(rotate(p, 0.4), vec2(0.0, 60.0)), 25.0);\n    float h3 = sdCircle(translate(rotate(p, 0.6), vec2(0.0, 60.0)), 25.0);\n    float h4 = sdCircle(translate(rotate(p, 0.8), vec2(0.0, 60.0)), 25.0);\n    float h = min(min(min(min(h0, h1), h2), h3), h4);\n    return max(circle, -h);\n}\n\nfloat visibility(float d)\n{\n\tfloat g = length(vec2(dFdx(d), dFdy(d))) * ISQRT_2;\n    return smoothstep(g, -g, d);\n}\n\nfloat LinearFromSRGB(float srgb)\n{\n    if(srgb < 0.04045)\n        srgb /= 12.92;\n    else\n        srgb = pow((srgb + 0.055) / 1.055, 2.4);\n    return srgb;\n}\n\nvec3 LinearFromSRGB(vec3 srgb)\n{\n\treturn vec3(\n    \tLinearFromSRGB(srgb.x),\n        LinearFromSRGB(srgb.y),\n        LinearFromSRGB(srgb.z)\n    );   \n}\n\nvec4 tex(sampler2D samp, vec2 uv)\n{\n    vec4 t = texture(samp, uv);\n\treturn vec4(LinearFromSRGB(t.xyz), t.w);\n}\n\nvec3 scene(vec2 fragCoord, float time)\n{\n    vec2 pBox = rotate(translate(fragCoord, vec2(200.0, 200.0)), time * 0.3);\n    float box = sdBox(pBox, vec2(100.0, 100.0));\n    vec2 uvBox = pBox / 100.0 * 0.5 + 0.5;\n    \n\tvec2 pComplexShape = rotate(translate(fragCoord, iMouse.xy), time * 2.0);\n    float complexShape = sdComplexShape(pComplexShape);  \n    vec2 uvComplexShape = pComplexShape / 100.0 * 0.5 + 0.5;\n    \n    float shadow = sdCircle(pComplexShape, 100.0);\n    float cShadow = clamp(sqrt(clamp(shadow / 150.0, 0.0, 1.0)) + 0.5, 0.0, 1.0);\n    \n    vec3 bg = tex(iChannel0, fragCoord / iResolution.xy).xyz;\n    vec3 cBox = tex(iChannel1, uvBox).xyz;\n    vec3 cComplexShape = tex(iChannel2, uvComplexShape).xyz;\n    \n    return mix(mix(bg, cBox * cShadow, visibility(box)), cComplexShape, visibility(complexShape));\n}\n\n#define SAMPLES 64\n#define FPS 24\n#define GAMMA 2.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 color;\n    for (int i = 0; i < SAMPLES; i++)\n    {\n        float jitter = random(vec4(fragCoord, iTime, i));\n        float t = floor(iTime * float(FPS)) / float(FPS);\n        color += scene(fragCoord, t + jitter / (float(FPS) * 2.0)) / float(SAMPLES);\n    }\n    vec3 dither = vec3(\n    \trandom(vec4(fragCoord, iTime, 0.0)) / 255.0,\n        random(vec4(fragCoord, iTime, 1.0)) / 255.0,\n        random(vec4(fragCoord, iTime, 2.0)) / 255.0\n    );\n    fragColor = vec4(pow(color, vec3(1.0/GAMMA)) + dither, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdB3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 203], [206, 206, 226, 226, 258], [259, 259, 279, 279, 323], [324, 324, 344, 344, 400], [402, 402, 432, 432, 534], [536, 536, 559, 559, 610], [611, 611, 633, 633, 684], [685, 685, 707, 707, 758], [759, 759, 781, 781, 832], [834, 834, 867, 867, 892], [894, 894, 923, 923, 1005], [1007, 1007, 1037, 1037, 1166], [1168, 1168, 1205, 1205, 1230], [1232, 1232, 1262, 1262, 1757], [1759, 1759, 1786, 1786, 1874], [1876, 1876, 1910, 1910, 2033], [2035, 2035, 2067, 2067, 2185], [2187, 2187, 2222, 2222, 2298], [2300, 2300, 2340, 2340, 3124], [3179, 3179, 3234, 3234, 3751]]}
{"id": "wdBGD3", "name": "Led Balls", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarching"], "likes": 4, "viewed": 94, "published": "Public", "date": "1550103224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat random(vec3 p)\n{\n    return fract(sin(dot(p, vec3(123.2345, 345.6546, 789.65648))) * 345879823.234234);\n}\n\nvec3 ptrn(vec2 p)\n{\n    p = abs(p);\n    vec2 backup = p;\n    p *= rot(floor(iTime*2.)) + abs(sin(fract(iTime)))*.1;\n    p = mod(p, .5);\n    p = mod(p, .2);\n    float zoom = 25.;\n    float t = pow(iTime, 1.);\n    vec2 id = floor(p * zoom);\n    vec2 fra = fract(p * zoom);\n    float size = pow(2., id.y+2.);\n    float shade;\n    if(mod(floor(t*10.)+id.x*id.x, size) > size/2.) shade = 0.;\n    else shade = 1.;\n    shade *= sin(backup.x*400.);\n    shade *= sin(backup.y*400.);\n    vec3 col = vec3(shade*fra.x) * vec3(1., 1., .4);\n    col.r *= p.x * 3.;\n    col.g *= p.y * 20.;\n    col.b *= length(p)*5.;\n    col += pow(col, vec3(.5));\n    col.g *= abs(sin(floor(iTime*2.)));\n    return sqrt(col);\n}\n\nfloat map(vec3 p)\n{\n    float walls = min(p.y+.5, p.z+1.);\n    p.x += 1.;\n    p.xz = mod(p.xz+vec2(1.), 2.)-vec2(1.);\n    float s = length(p) - .5;\n    return min(s, walls);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i)\n    {\n    \tfloat d = map(ro+rd*t);\n        if(d <.001) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 eye = vec3(0., 0., 5.);\n    eye.z += sin(iTime*.25+1.57)*2.;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    dir.yz *= rot(sin(iTime*.25+1.57)*.5);\n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    vec3 normal = getNormal(p);\n    vec3 col;\n    \n    if(dot(normal, vec3(0., 1., 0.)) == 0.) {\n        col = ptrn(p.xy);\n    } else {\n        vec3 bounceDir = dir - 2.*(dir * normal) * normal;\n    \tvec3 bounceOrigin = p+normal*.002;\n        float bounceD = march(bounceOrigin, bounceDir);\n        vec3 bp = p+bounceDir*bounceD;\n        \n        \n        col += ptrn(bp.xy);\n        col /= bounceD*20.;\n        col *= pow(d*.05, .5);\n    }\n\t\n    col.r *= uv.x+1.;\n    col *= 1.-length(uv)*.8;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 119, 119, 208], [210, 210, 229, 229, 905], [907, 907, 926, 926, 1082], [1084, 1084, 1115, 1115, 1262], [1264, 1264, 1288, 1288, 1475], [1477, 1477, 1534, 1534, 2398]]}
{"id": "wdBGW3", "name": "[twitch] Door Warehouse", "author": "yx", "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/380207883[/url]", "tags": ["raymarcher", "livecoding", "twitch"], "likes": 47, "viewed": 1497, "published": "Public API", "date": "1550098307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThis shader was created live on stream!\n\tYou can watch the VOD here: https://www.twitch.tv/videos/380207883\n\n\tI use the Bonzomatic tool by Gargaj/Conspiracy:\n\thttps://github.com/Gargaj/Bonzomatic\n\n\tWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n\tCome and watch a show!\n\n\t~yx\n*/\n\n#define pi acos(-1.)\n\n\nvec2 rotate(vec2 a, float b)\n{\n    float c=cos(b);\n    float s=sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p=abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdBox(vec3 p, vec3 a, vec3 b)\n{\n    return sdBox(p-(a+b)/2.,abs(b-a)/2.);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    n.xyz = normalize(n.xyz);\n    return dot(vec4(p,1),n);\n}\n\nfloat sdCappedCylinder(vec3 p, vec4 r)\n{\n\n    return max(\n        length(p.xy-r.xy)-r.z,\n        abs(p.z)-r.w\n    );\n}\n\nfloat noise(vec3 p)\n{\n    return fract(sin(dot(p,vec3(13.43672,4.534782,21.43672)))*234.432);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdChamferBox(vec3 p, vec3 r, float R)\n{\n    p=abs(p);\n    p=max(p,r-R);\n    return (dot(p-r,vec3(1))+R+R)/sqrt(3.);\n}\n\nint mat;\nvec3 cell;\n\nfloat sdDoor(vec3 p)\n{\n    float rail = sdBox(p, vec3(-.3,5.2,-10), vec3(.3,5.4,10));\n\n    float yoffs = 5.5;\n    p.y-=yoffs;\n    p.xy = rotate(p.xy, sin(iTime*4.+cell.z*10.)*.1);\n    p.y+=yoffs;\n\n    vec3 np = p;\n\n    float door = sdBox(p,vec3(2,4,.15));\n    p.xz = abs(p.xz);\n    p.z-=.2;\n    door=max(door, -sdChamferBox(p, vec3(1.4,3.4,.1), .2));\n    p.z+=.2;\n    if(noise(cell)>.5)\n        door = min(door, sdBox(p, vec3(-.1,3.5,0.03), vec3(.3,-3.5,.15)));\n    if(noise(cell+1.)>.5)\n        door = min(door, sdBox(p, vec3(-2,-.8,0.03), vec3(2,-.2,.15)));\n\n    float frame = sdBox(p, vec3(2,-4.2,-.3), vec3(2.4,4.1,.3));\n    frame = min(frame, sdBox(p, vec3(-.1, 4, -.3), vec3(2.4, 5., .3)));\n    frame = min(frame, sdBox(p, vec3(-.1, -4.4, -.3), vec3(2.4, -4, .3)));\n    frame = min(frame, sdBox(p, vec3(-.1, -4.55, -.2), vec3(.5, -4, .2)));\n    frame = min(frame, sdBox(p, vec3(1, -4.55, -.2), vec3(1.6, -4, .2)));\n\n    float frameMask = sdPlane(p, vec4(1,1,0,-4.7));\n    frameMask = max(frameMask, sdPlane(p, vec4(.2,1,0,-4.9)));\n    frameMask = max(frameMask, sdPlane(p, vec4(-.2,1,0,-4.4)));\n    frameMask = min(frameMask, sdPlane(p, vec4(2,1,0,-2.7)));\n\n    frame = max(frame, frameMask);\n    frame = min(frame, sdCappedCylinder(p, vec4(0,4.5,.3,.36)));\n    frame = min(frame, sdBox(p, vec3(.3, 5, -.3), vec3(.5,5.6,.3)));\n    frame = min(frame, sdBox(p, vec3(-.5, 5.4, -.3), vec3(.5,5.6,.3)));\n\n    frame = min(frame, sdSphere(np-vec3(1.5,-.5,.5), .25));\n\n    float light = sdCappedCylinder(p, vec4(0,4.5,.22,.42));\n\n    float dist = min(min(door,rail), min(frame, light));\n    if (door == dist) {\n        mat=1;\n    } else if (light == dist) {\n        mat=2;\n    } else {\n        mat=3;\n    }\n\n    return dist;\n}\n\nfloat scene(vec3 p)\n{\n    const vec3 cellsize = vec3(20, 18, 8);\n    p.xy += p.z*p.z*.002;\n    p.y -= iTime;\n    p.z -= sign(sin(p.x/cellsize.x*pi)*sin(p.y/cellsize.y*pi))*iTime*25.; // thanks, theartofcode\n    cell = floor(p/cellsize);\n    p = mod(p, cellsize)-cellsize*.5;\n    return sdDoor(p);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,2,15);\n    vec3 dir = normalize(vec3(uv,-1));\n\n    cam.yz = rotate(cam.yz, -.1);\n    dir.yz = rotate(dir.yz, -.1);\n\n    vec3 bg = vec3(.1,.15,.2);\n\n    float t = 0.;\n    float k = 0.;\n    for(int i=0;i<100;++i) {\n        k=scene(cam+dir*t);\n        t+=k;\n        if(k<.001)\n        {\n            vec3 h = cam+dir*t;\n            vec2 o=vec2(.02,0);\n            vec3 n= normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n\n            float light = dot(n,normalize(vec3(1,2,3)))*2.;\n\n            if (mat == 1)\n            {\n                vec3 color = vec3(\n                    noise(cell.xyz),\n                    noise(cell.yzx),\n                    noise(cell.zxy)\n                )*.8+.2;\n                out_color.rgb = vec3(light)*color;\n            }\n            else if (mat == 2)\n            {\n                out_color.rgb = light*vec3(1,.1,.1)*.7;\n            }\n            else\n            {\n                out_color.rgb = light*vec3(.5);\n            }\n\n            out_color.rgb = mix(bg, out_color.rgb, pow(.985, t-15.));\n\n            return;\n        }\n    }\n    out_color.rgb = bg;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 331, 361, 361, 468], [470, 470, 499, 499, 551], [553, 553, 590, 590, 634], [636, 636, 667, 667, 728], [730, 730, 770, 770, 848], [850, 850, 871, 871, 945], [947, 947, 980, 980, 1006], [1008, 1008, 1053, 1053, 1131], [1154, 1154, 1176, 1176, 2878], [2880, 2880, 2901, 2901, 3178], [3180, 3180, 3232, 3232, 4562]]}
{"id": "wdBGzd", "name": "Jordan shader", "author": "theasocialmatzah", "description": "a test shader", "tags": ["test"], "likes": 3, "viewed": 150, "published": "Public", "date": "1549692145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "WdBGzV", "name": " Kaleidoscopic demo", "author": "darkeclipz", "description": " Kaleidoscopic idea from Kushulain.\n\nFractal formula: https://www.shadertoy.com/view/Mss3Wf", "tags": ["kaleidoscope"], "likes": 6, "viewed": 204, "published": "Public", "date": "1549314764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r2(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }\n#define R iResolution.xy\n#define Iterations 10.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-R)/iResolution.y;\n\tvec3 col = vec3(0);\n    float s = iTime/16. * cos(iTime/32.);\n\n    // https://www.shadertoy.com/view/Mss3Wf\n    for(float i=0.; i < Iterations; i++) {\n    \tuv = abs(uv) - s; \n        uv.xy *= r2(iTime/16. + 2.);\n        uv *= 1.08;\n    }\n    \n    float dist = length(fract(2.*uv));\n    vec3 rainbow = cos(vec3(0,2,4) + iTime + 2.*uv.xyx);\n    col = dist*rainbow;\n    \n    float gridSize = 3.;\n    float gridWidth = 0.04;\n    vec2 grid = smoothstep(gridWidth, 0., abs(fract(gridSize*uv)-gridWidth));\n    col = mix(col, vec3(1), clamp(grid.x + grid.y, 0., 1.)); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 86], [135, 135, 192, 242, 908]]}
{"id": "wdfSDH", "name": "SherfeyFractal Zoom, slow start", "author": "JohnShadow", "description": "An absolute based fractal with repeating geometry that is flexible and is reminiscent of the MandleBrot fractal\nI have never tried ray marching before... here goes nothing.  goes to 230 seconds", "tags": ["raymarching", "fractal", "fun"], "likes": 5, "viewed": 147, "published": "Public", "date": "1551171557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define maxsteps 20\n#define maxDist 20.0\n#define surfaceScalar 1.75\nfloat sdf(vec3 x)\n{\n    //sphereical sdf zooming in over time.\n\t//this can use any sdf fuction, even other fractals.\n    float part = abs((iTime+20000.0)/20000.0);\n    float time = 620.0*sin(iTime*0.000025) * part;\n    return distance(x, vec3(0,0,time)) - 2.0;\n}\nvec3 normalSphere (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( sdf(p + vec3(eps, 0, 0) ) - sdf(p - vec3(eps, 0, 0)),\n \t  sdf(p + vec3(0, eps, 0) ) - sdf(p - vec3(0, eps, 0)),\n\t  sdf(p + vec3(0, 0, eps) ) - sdf(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat fractal(vec3 pos)\n{\n    //sample sphere find normal for later casting onto sphere\n    float sl = sdf(pos);\n    vec3 samp = pos;\n    float l = 0.;\n    for(int i = 0; i < 25; ++i) //fractal iterations\n    {\n        samp = abs(samp) - 1.0;\n        samp /= dot(samp,samp);\n    }\n    //do length calcs\n    l = (distance(samp, vec3(0,0,0)) - 1.0) + sl;\n\treturn l;\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( fractal(p + vec3(eps, 0, 0) ) - fractal(p - vec3(eps, 0, 0)),\n \t  fractal(p + vec3(0, eps, 0) ) - fractal(p - vec3(0, eps, 0)),\n\t  fractal(p + vec3(0, 0, eps) ) - fractal(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec4 map(vec2 uv)\n{\n    vec3 marchpos = vec3(0, 0, 0), dir = vec3(uv, 1), n = vec3(0,0,0);\n    float totaldist = 0.0;\n    float steps = 0.0;\n    for(int i = 0; i < maxsteps; ++i)\n    {\n        float dist = fractal(marchpos);\n        totaldist += dist;\n        marchpos += dir * dist;\n        if(dist < 0.01)\n        {\n\t\t\tn = normal(marchpos);\n\t\t\tbreak;\n        }\n        ++steps;\n    }\n    //lighting n dot l\n    vec3 light = vec3(sin(iTime), cos(iTime), cos(0.1*iTime + 1.232));\n\tfloat dist = 1.0/distance(light, marchpos);\n    float l = max(dot(n, light)*0.5,0.1) * dist;\n    return vec4(vec3(l) + vec3(n)*0.1, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0)*2.;\n    // Output to screen\n    fragColor = map(uv);\n}", "image_inputs": [{"id": "XlX3DN", "previewfilepath": "https://soundcloud.com/minecraftwizards/11-c418-warmth", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/minecraftwizards/11-c418-warmth", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 184, 330], [331, 331, 359, 359, 595], [596, 596, 621, 683, 961], [962, 962, 984, 984, 1244], [1245, 1245, 1264, 1264, 1865], [1866, 1866, 1923, 1973, 2123]]}
{"id": "wdfSRM", "name": "FBM bug? help", "author": "darkeclipz", "description": "my laptop seems to render the fbm function with a lot of random rectangles, see screenshot: \n\nhttps://prnt.sc/mojhme\n\ndoes anyone have an idea on how i can fix this?", "tags": ["bug"], "likes": 1, "viewed": 127, "published": "Public", "date": "1550826335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat random (in vec2 st) {\n    \n    uvec3 ust = uvec3(st.x, st.y, st.x * st.y);\n    vec3 r = hash(ust);\n    return r.x;\n    \n    //return fract(sin(dot(st.xy,\n    //                     vec2(12.9898,78.233)))*\n    //    4375.5453123);\n}\n\n\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(fbm(uv + iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 185], [187, 187, 214, 214, 424], [428, 506, 532, 532, 912], [932, 932, 956, 978, 1232], [1233, 1233, 1290, 1340, 1528]]}
{"id": "wdfSW8", "name": "asdfasf", "author": "lennyjpg", "description": "asdfasdfasf", "tags": ["asdfsdf"], "likes": 3, "viewed": 299, "published": "Public API", "date": "1551226764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x-=cos(-uv.x*3.)*.5;\n \tfloat t = iTime*.5;\n    uv.x+=sin(uv.x-uv.y*1.3+t*.71);\n    uv.y+=t;\n    uv.y = sin(uv.y*sin(uv.y*.01)*1.1) * .15;\n    float p = 100.*(sin(iTime*.1)+1.)+1.;\n    float x = p*(uv.x+uv.y);\n    float g = .01+floor(sin(x*.5))*.1;\n    fragColor = vec4(fract(x*g));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 388]]}
{"id": "WdfXR4", "name": "Apollonian Dreams", "author": "krakel", "description": "Based on a project I did for a seminar.\nThe distance field is ultimately based on https://www.shadertoy.com/view/4ds3zn\n\nThe results of that seminar (incl. interactive version of this):\nhttps://geo.ma.tum.de/de/lehrveranstaltungen/visualisation-gpu.html", "tags": ["3d", "raymarching", "fractal", "distancefield", "kleinian", "inversion", "apollonian"], "likes": 16, "viewed": 327, "published": "Public", "date": "1550664571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by krakel, 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define sqrt3 sqrt(3.)\n#define pixelRadius .5/iResolution.x\n#define Time .1*float(iFrame)/30.\n\n//this AA is expensive and rather ineffective\n#define AA 0\n\nvec3 sunDir = normalize(vec3(0, 0, 1));\nfloat viewDist = 30.;\nvec3 sunLight = vec3(2.,2.,1.6);\nvec3 ambLight = vec3(.5, .8, .9);\nvec3 fogColor = vec3(.8,.8,.9);\n\nvec3 triangles(vec3 p){\n    float zm = 1.;\n    p.x = p.x-sqrt3*(p.y+.5)/3.;\n\tp = vec3(mod(p.x+sqrt3/2.,sqrt3)-sqrt3/2., mod(p.y+.5,1.5)-.5 , mod(p.z+.5*zm,zm)-.5*zm);\n\tp = vec3(p.x/sqrt3, (p.y+.5)*2./3. -.5 , p.z);\n\tp = p.y>-p.x ? vec3(-p.y,-p.x , p.z) : p;\n\tp = vec3(p.x*sqrt3, (p.y+.5)*3./2.-.5 , p.z);\n\treturn vec3(p.x+sqrt3*(p.y+.5)/3., p.y , p.z);\n}\nfloat sdf(vec3 p){\n    float scale = 1.;\n\tfloat s = 1./3.;\n\tfor( int i=0; i<10;i++ )\n\t{\n\t\tp = triangles(p);\n\t\tfloat r2= dot(p,p);\n\t\tfloat k = s/r2;\n\t\tp = p * k;\n\t\tscale=scale*k;\n    }\n\treturn .3*length(p)/scale\t\t-.001/sqrt(scale);\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.03;\n    float h = 5.;\n    for( int i=0; i<80; i++ )\n    {\n        if(h<t*pixelRadius || t>viewDist){break;}\n\t    h = sdf( ro+rd*t );\n        t += h;\n    }\n    if(h>t*pixelRadius){t=viewDist*2.;}\n    return t;\n}\n\nvec3 getNormal( in vec3 p, in float t )\n{\n    float precis = 0.0001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*sdf( p + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdf( p + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdf( p + e.yxy ) + \n                      e.xxx*sdf( p + e.xxx ) );\n}\nfloat ao(vec3 p,vec3 n){\n\tfloat r=0.;\n    float t=0.;\n\tfor( int i=0; i<3;i++ )\n\t{\n\t\tt=t+.01;\n\t\tr=r + sdf(p+n*t)/t;\n    }\n    return smoothstep(.0,1.7,r);\n}\n\nfloat shadowRay(vec3 p,vec3 n,vec3 ld){\n    p = p + n*.1;\n    float t = .1;\n    float h = 5.;\n    for( int i=0; i<50; i++ )\n    {\n        if(h<t*pixelRadius || t>2.){break;}\n\t    h = sdf( p+ld*t );\n        t += h;\n    }\n    return smoothstep(0.,1.,t/2.);\n}\n\nvec3 fog(float t, vec3 col, float density){\n   return  mix(col , fogColor, 1.-exp(-t*density));\n}\n\nfloat pulse(float t){\n    return pow(t,3.);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float t= march(ro,rd);\n    vec3 col = vec3(0);\n    if(t<viewDist){\n        vec3 p = ro+t*rd;\n    \tvec3 n = getNormal(p, t);\n        col = sunLight*vec3 ( dot(n, sunDir ) );\n        col *= shadowRay(p,n,sunDir);\n        float ao = ao(p,n);\n        col += ambLight*mix(ao,.2+.8/ao, pulse(.5+sin(p.z+10.*Time)*.5));\n        col *= .6;\n        col = fog(t, col, .3);\n    }else{\n        col = fogColor;\n    }\n    return col;\n}\n\nvec3 jitter( int i){\n    return pixelRadius* fract(123.*sin(vec3(15,17,19)*float(i)));\n}\n\nvec3 AArender(vec3 ro, vec3 rd){\n    if(AA>1){\n    vec3 col = vec3(0);\n    for( int i=0; i<AA; i++){\n        col += render(ro, normalize(rd+jitter(i)));\n    }\n        return col/float(AA);}\n    else{return render(ro,rd);}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - .5*iResolution.xy/iResolution.x;\n    \n    vec3 camPos = vec3(0,1,.5) + Time*vec3(1) + .5*vec3(sin(Time), cos(Time) ,0 );\n    vec3 camDir = normalize(vec3(1,0,1) + vec3(0, cos(Time),sin(Time)) );\n    vec3 camRi  = normalize(cross(camDir, vec3(0,sin(Time),cos(Time))));\n    vec3 camUp  = normalize(cross(camDir, camRi));\n    \n    sunDir = normalize(vec3(0, sin(Time),cos(Time)));\n    sunLight = vec3(sin(Time),cos(Time),0);\n    \n    fragColor = vec4(AArender(camPos, normalize(camDir + camRi*uv.x + camUp*uv.y) ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfXR4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[210, 432, 455, 455, 786], [787, 787, 805, 805, 1019], [1021, 1021, 1051, 1051, 1278], [1280, 1280, 1321, 1321, 1553], [1554, 1554, 1578, 1578, 1709], [1711, 1711, 1750, 1750, 1967], [1969, 1969, 2012, 2012, 2066], [2068, 2068, 2089, 2089, 2113], [2115, 2115, 2145, 2145, 2571], [2573, 2573, 2593, 2593, 2661], [2663, 2663, 2695, 2695, 2886], [2888, 2888, 2945, 2945, 3505]]}
{"id": "WdfXRr", "name": "Raymarch Mandelbulb", "author": "darkeclipz", "description": "Raymarching the Mandelbulb. For more info, see: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\nWith a 3D Mandelbrot :)", "tags": ["raymarch", "mandelbulb"], "likes": 13, "viewed": 433, "published": "Public", "date": "1550413299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 64.\n#define MinDistance 0.0007\n#define eps 0.001\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nvec2 DE(vec3 pos) {\n        \n    float Iterations = 64.;\n    float Bailout = 2.;\n    float Power = 6. - 4.*cos(iTime/16.);\n    \n    vec3 trap = vec3(0,0,0);\n    float minTrap = 1e10;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n        \n        minTrap = min(minTrap, z.z);\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\t//z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z = zr*vec3( cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta) );\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr, minTrap);\n}\n\nvec2 scene(vec3 p) {\n    \n\treturn DE(p - vec3(0,.1,0));\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p - vec3(0,.1,0)).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,5,0), 20., vec3(.2));\n    \n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,5), 30., vec3(.7));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,-5), 30., vec3(.4));\n    vec3 L3 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,5), 30., vec3(.7));\n    vec3 L4 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,-5), 30., vec3(.4));\n    \n    vec3 ambient = vec3(.1);\n    return L1 + L2 + L3 + L4 + ambient + top;\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0,-3); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateX(iTime / 8.) * rotateZ(iTime / 8.) * rotateZ(iTime/4.);\n    \n    ro -= vec3(0,0,1.);\n    ro *= rot;\n    rd *= rot;\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        float trap = fract(hit.z*.5 + .5);\n        col = pal(trap, vec3(.5), vec3(0.5), \n                   vec3(1.0,1.0,1.0), vec3(.0, .10, .2));\n        \n        col *= .2;\n        \n        col += light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        float shadow = marchShadow(p + 0.1*n, normalize(vec3(10,10,10) - p));\n        if(shadow > eps) {\n        \tcol = mix(col, vec3(0), .1);    \n        }\n        \n        float fog = 1. / (0.1 + t * t * 0.03);\n        col = mix(vec3(0), col, fog);\n    }\n    else {\n        vec3 topcolor = vec3(127./255., 161./255., 189./255.);\n        vec3 bottomcolor = vec3(84./255., 111./255., 138./255.);\n    \tcol = mix(bottomcolor, topcolor, uv.y);\n        col = vec3(0);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 119, 119, 205], [207, 207, 234, 234, 320], [322, 322, 349, 349, 427], [429, 528, 547, 547, 1386], [1388, 1388, 1408, 1408, 1445], [1447, 1447, 1473, 1473, 1507], [1509, 1520, 1545, 1545, 1817], [1819, 1897, 1927, 1927, 2218], [2220, 2220, 2257, 2257, 2493], [2495, 2562, 2669, 2669, 3427], [3429, 3504, 3542, 3542, 3988], [3990, 4051, 4119, 4119, 4164], [4166, 4166, 4223, 4223, 5488]]}
{"id": "WdfXW7", "name": "[TWITCH] Joan of Arc Tangent", "author": "evvvvil", "description": "Actually it's \"Joan of Arc versus Terry Tangent\" - Shader showdown practice session 009.\nLive coded on Twitch with 25 minutes time limit.\nPracticing live on TWITCH every Tuesdays around 21:00 UK time.\nhttps://www.twitch.tv/evvvvil_", "tags": ["time", "demoscene", "abstract", "limit", "arc", "live", "tangent", "battle", "shadershowdown", "coding", "twitch", "showdown", "joan"], "likes": 9, "viewed": 631, "published": "Public API", "date": "1551376683", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"Joan of Arc versus Terry Tangent\" - Shader Showdown practice session 009\n\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 20:30 UK time I practise live on TWITCH. This is the result of session 009.\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\n// \"What happened to my cigar commercial? What happened to my agent? Bastard must have died.\" - Withnail & I\n\nvec2 sc,e=vec2(.00035,-.00035);float t,tt,at,st;vec3 bp,pp;//Some fucking globals, about as exciting as instagram influencer being advertising boards\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}//box function stolen from UNC because UNC from QUITE is a genius coder\nvec2 fb( vec3 p ) //fucking bit function creates a piece and then we clone and tweak it in the mp map function. Just like poverty and crime: they are related.\n{\n    vec2 h,t=vec2(bo(abs(p)-vec3(3,2,3),vec3(.5,1.5,.5)),0);//abs symstery cloning to make 8 boxes in one line of code\n    h=vec2(bo(abs(p)-vec3(3,0,3),vec3(.4,100,.4)),5);//more abs symstery cloning boxes\n    h.x=min(bo(abs(p)-vec3(3,0,0),vec3(.3,3,3)),h.x);//man loving this abs symstery cloning thing, pass me another beer\n    t.x=min(bo(abs(p)-vec3(0,2.5,2),vec3(3,.4,.4)),t.x);//Fucking hell still at it: cloning fucking boxes.\n    t=(t.x<h.x)?t:h;//finally box stacking job is finished, i can get paid and smoke that cigar: it's been so rewarding broski.\n    return t;//Return this, return that, this guy will never leave you alone, go away and never return!\n}\n\nfloat noise(vec3 p){//Noise function stolen from Virgil who stole it from Shane who I assume understands this shit, unlike me who is too busy trying to fit these round pegs in squared holes\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip;\n  vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);//Ah, yes I understand this bit: it draws a shape which, if you have enough imagination, looks like a penis\n}\n\n\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//simple rotate function, it is useful as fuck and short. Bit like your diminutive friend who can get you into the club for free.\n\nvec2 mp( vec3 p ) //This is the main MAP function where all geometry is made/defined. It's centre stage broski, like cat videos on youtube\n{\n  vec4 np=vec4(p,1);//np will be the new position we pass to fucking bit function fb\n    //because np will be scaled in a loop we make it a vec4 to remember the amount of scaling in np.w and scale the distance field to avoid artifact \n  np.z=atan(np.z);//Making geometry infinite and more interesting by turning z axis into and arc tangent of it\n  bp=np.xyz;//bp is another new position which will be the pos for the white spehrical geometries\n  for(int i=0;i<4;i++){//in da  fucking loop broski\n    np*=1.6;//sizing the fucker\n    np.xz*=r2(sin(p.y*0.3)*0.2);//spin xy along y axis\n    np.xyz=abs(np.xyz)-vec3(6,6,0);//Spread geom out each iter we make more\n    bp.xyz=abs(bp.xyz)-vec3(6,4.+2.*sin(tt*5.),0);//Ah yeah do the same to bp but with little offset\n    bp.x+=2.;//nudge bp out to make it wide, open up the centre hole, some much innuendo im giggling at the lewd joke possibilities, if you're not then you're a nerd\n    if(i==0){//sometimes we do this, sometimes we dont\n    np.xy*=r2(.785*1.5*sin(p.z*0.1+tt*10.));//spinneroo the fuckeroo\n    bp.xy*=r2(.785*1.5*sin(p.z*0.1+tt*10.));//spinneroo the whiteroo fuckeroo\n    }\n    if(i==1) np.xz*=r2(.785);//Sometimes i just feel like spinning things, mostly when i is 1 the other times I feel like a double cheesburger\n    np.w+=0.1;//nudge the distance field scaler a bit, seems to improve artifacts, truth is I dont really know what the fuck im doing but it's looking good broski\n  }\n  pp=np.xyz;//shortening the np.xyz into pp var for ease of use further down the line\n  vec2 h,t=fb(pp);//push the new fucking position in to the fucking bits function and get some mad fucking geometry broski\n  t.x/=np.w;//THERE we scale the distance field to avoid artifact. Not so dumb overall I guess, well a litte more susbtance than a drowning shoe\n  h=vec2(length(bp)-1.9,6);h.x*=0.8;//make the white geom from bp, Making it all more exciting, like recruiting the youth for political party activisim.\n  t=(t.x<h.x)?t:h;//We blend it all together while retaignin material ID, because sharing is fucking caring as long as it's colour coded.\n  return t;//This guy again, using precious bytes and all it does is return, what a fucking waste of a boomerang.\n}\n\nvec2 tr( vec3 ro, vec3 rd,float near,float far,int it )\n{\n  vec2 h,t=vec2(near);//Near plane because we all started as babies\n  for(int i=0;i<it;i++){//Main loop de loop\n    h=mp(ro+rd*t.x);//Marching forward like any good fascist army: without any care for culture theft\n    if(h.x<.0001||t.x>far) break;//Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y;//Remember the postion and the material id? Because it was an amazing afternoon we spent feeling all these drapes.\n  }\n  if(t.x>far) t.x=0.;//If we've gone to far then I will remove my cape.\n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);//boiler[plate code to get uvs in BONZOMATIC live coding software i use.\n    tt=mod(iTime*0.1,10.);//My time variable which everything uses to animate. This is modulo to avoid ugly artifact. Holding time in my hand: playing god is such a thrill.\n\t\n    vec3 ro=vec3(-sin(tt)*5.,-cos(tt*10.)*5.,-10),//Ro=ray origin=camera position because everything is relative to a view point, even nerds' lack of sense of humour\n    rd=normalize(vec3(uv,0.5)),co,fo,//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n    ld=normalize(vec3(0.4,0.2,0.2));//light direction, because god likes to point fingers with dramatic effect\n    co=fo=vec3(0.5)*(1.-(length(uv)-0.2));//By default the color fog color and it's a dark coloured vignette, because someone made a sexist joke and the west is offended\n\n    sc=tr(ro,rd,0.1,50.,128);t=sc.x;//This is where we shoot the fucking rays to get the scene, because shooting rays to gather colours beats playing Rugby against your ex girlfriend's team\n\t//(warned you about the sexist joke in line 93, if offended please tell Twitter, but trust, only the Rugby reference was meant to be offensive)\n    if(t>0.){//If t>0 then we must have hit some geometry so let's fucking shade it. Grab an umbrella, it's like dinning at the beach\n    //We hit some geometry so let's get the current position (po) and build some normals (no). You do the Maths while I light up Diogenes' lamp as he searches for an honest person.\n    vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n    //LIGHTING MICRO ENGINE BROSKI \n    al=vec3(.7,.2,.5+0.1*(length(po-ro)-10.));//Albedo is base colour.\n\n    float spo=exp2(1.+3.*noise(pp/vec3(.8,1.6,1.6)+noise(pp/vec3(.4,.8,.8))));//spo=specular power THIS, sick gloss map derived from noise function, it's a thing of fucking beauty\n    if(sc.y<5.) al=vec3(0);//Change colour depending on material id, it's like a painting/decorating job but without smoking weed at each break\n    if(sc.y>5.) {//More colour change this time re make the spo as the pos is different (bp instead of np) get your fucking positions in order this isn't you and your mates trying to dance to beyoncé after 2 shandies\n      al=vec3(1);no*=(1.+.6*ceil(cos(bp*4.)));no=normalize(no);\n      spo=exp2(1.+3.*noise(bp/vec3(.2,.4,.4)+noise(bp/vec3(.05,.1,.1))));\n    }\n    float dif=max(0.,dot(no,ld)),//dif=diffuse because i ain't got time to cook torrance\n    aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),//aor =amibent occlusion range, ao = ambient occlusion\n    fr=pow(1.+dot(no,rd),4.),//Fr=fresnel which adds reflections on edges to composite geometry better, yeah could be reflected, but who gives a shit? That's twice you're a nerd, come on, grab a beer, relax.\n    sha=tr(po,ld,.05,2.0,50).x;sha=(sha>.0)?0.0:1.0;//Fuck it why not draw some fucking shadows? just gonnu soften them with some brutal hacks\n    vec3 sss=vec3(0.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),//sss=subsurface scatterring made by tekf from the wax shader, big up tekf! https://www.shadertoy.com/view/lslXRj\n    sp=vec3(0.5)*pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specualr, sotlen from Shane and it's better than dipping your fingers in hot mashed potatoes\n\tsha*=0.5;//Pseudo soften the shadows and adding 0.5 in line below \n    co=mix(sp+al*(0.8*ao+0.2)*((sha+0.5)*dif+sss),fo,min(fr,0.5));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(co,fo,1.-exp(-.00003*t*t*t));//Fog soften things, like smoke machines at a SUNN O))) concerts\n    }\n    fragColor = vec4(pow(co,vec3(0.45)),1);//Cheap tone mapping, even cheaper than street justice\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfXW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1019, 1110, 1134, 1134, 1180], [1180, 1252, 1412, 1412, 2079], [2081, 2081, 2101, 2270, 2602], [2605, 2605, 2622, 2622, 2665], [2665, 2796, 2936, 2936, 5141], [5143, 5143, 5200, 5200, 5714], [5715, 5715, 5772, 5772, 9642]]}
{"id": "WdfXzn", "name": "5901 - Skaczące kafelki", "author": "heliosbeatz", "description": "Praca zaliczeniowa", "tags": ["jumpingtiles"], "likes": 2, "viewed": 67, "published": "Public", "date": "1550390404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nautor Bernard M\nnr albumu 5901 \nProsty shader \"skaczący\" w rytm muzyki.\nPrzy pracy inspirowałem się projektami:\n\thttps://www.shadertoy.com/view/Wd23D3\n\thttps://www.shadertoy.com/view/4tyXWV\n\thttps://www.shadertoy.com/view/XlBBDt\njak również dokumentacją: \n\thttps://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf\nkorzystałem również z kalkulatora graficznego Desmos:\n\thttps://www.desmos.com/calculator\njako tło dźwiękowe wykorzystałem swój stary utwór \"joyful_journey\"\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //definicja zmiennych:\n    float s = (texture(iChannel0, vec2(0.1, 0.0)).x); //float s oparta o parametry dzwieku z kanału 0\n    float t = iTime/2.; // float t - bieżący czas w sekundach podzielony przez 2\n    vec3 plytka =  vec3(8,2,4); // definicja pojedynczej plytki\n    vec3 kolor1 = vec3(s/2.,0,0); // definicja koloru 1 - odcień czerwieni zależny od parametru s\n\tvec3 kolor2 = vec3(.0,s,0);  // definicja koloru 2 - odcień zieleni zależny od parametru s\n\n    \n    // standardowa normalizacja wspołrzędnych oraz proporcji\n    vec2 uv = (fragCoord/iResolution.xy);\n\tuv.x *= iResolution.x / iResolution.y;\n    uv+= pow(sin(t),3.)+s; // funkcje matematyczne operujące na zmiennych s oraz t\n\tuv *= abs(sin(t)+2.);  \n    \n\n\t// kolorowanie pojedynczej płytki\n    plytka = mix(kolor1, kolor2,.1); \n    plytka.b += abs(1.05-length(fract(uv+s)));\n\n    // wyjście na ekran\n    fragColor = vec4(plytka,1.0);\n}", "image_inputs": [{"id": "llsGWH", "previewfilepath": "https://soundcloud.com/heliosbeatz/joyful_journey_2", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/heliosbeatz/joyful_journey_2", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 521, 578, 605, 1498]]}
{"id": "Wdj3RK", "name": "Approx glossy material Fresnel", "author": "amally", "description": "Approximating the Fresnel reflectivity of glossy surfaces using basic rim lighting.", "tags": ["environmentmapmetal"], "likes": 3, "viewed": 216, "published": "Public", "date": "1550586673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst vec3 MAIN_LIGHT_DIR = normalize(vec3(1.0, 0.2, -0.4));\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nfloat random1( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nfloat interpNoise3D1(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.z);\n}\n\n\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise3D1(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);\n    //eye = vec3(0.0, 5.0, 5.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n// Version that just returns the t value, for surface normal computation\nfloat sceneMap3D(vec3 pos)\n{\n    float t = sphere(pos, 2.0, vec3(0.0, 0.0, 0.0));\n    t = min(t, sphere(pos, 2.0, vec3(12.0, 0.0, -6.0)));\n    t = min(t, sphere(pos, 2.0, vec3(-8.0, 0.0, 4.0)));\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\n// Version that returns t value and the ID of the object hit\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = sphere(pos, 2.0, vec3(0.0, 0.0, 0.0));\n    float t2;\n    obj = 0; // 0 is center sphere\n    if((t2 = sphere(pos, 2.0, vec3(12.0, 0.0, -6.0))) < t) {\n        t = t2;\n        obj = 1; // 1 is left sphere\n    }\n    if((t2 = sphere(pos, 2.0, vec3(-8.0, 0.0, 4.0))) < t) {\n        t = t2;\n        obj = 2; // 2 is right sphere\n    }\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3; // 3 is floor\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvec3 skyColor(vec3 dir) {\n    float t = smoothstep(0.0, 1.0, dir.y);\n    t = clamp(0.0, 1.0, t + fbm(dir / 8.0, 4.0) * 0.1);\n    t = fbm(dir / 8.0, 6.0);\n    t = smoothstep(0.0, 1.0, t);\n    vec3 dawnGradient = mix(vec3(253.0, 96.0, 81.0) / 255.0, vec3(255.0, 229.0, 119.0) / 255.0, t);\n    vec3 duskGradient = mix(vec3(48.0, 24.0, 96.0) / 255.0, vec3(144.0, 96.0, 144.0) / 255.0, t);\n    t = max(0.0, dot(dir, MAIN_LIGHT_DIR));\n    return mix(duskGradient, dawnGradient, t);\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0:\n        // Center sphere\n        return vec3(1.0, 0.67, 0.67);\n        break;\n        case 1:\n        // Back sphere\n        return vec3(0.67, 1.0, 0.67);\n        break;\n        case 2:\n        // Front sphere\n        return vec3(0.67, 0.67, 1.0);\n        break;\n        case 3:\n        // Floor\n        float t = floor(mod((sin(p.x) + sin(p.z)) * 0.5, 2.0));\n        return mix(vec3(0.7, 0.4, 0.2), vec3(1.0), t);\n        break;\n        case -1:\n        // Background\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    if(t == -1.0) {\n        return Intersection(t, skyColor(dir), vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n\n    float fresnel = 1.0 - max(0.0, dot(normalize(eye - isect), nor));\n    fresnel = 0.25 + 0.75 * fresnel;\n    vec3 sdfColor = mix(material, skyColor(reflect(dir, nor)) * material, fresnel);\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    // Stratified sampled 4x4 anti-aliasing\n    Intersection aaIsects[16];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.25) {\n        for(float j = 0.0; j < 1.0; j += 0.25) {\n            raycast(uv2 + (vec2(i, j) + random2(vec2(i, j))) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n    fragColor = vec4(avgColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdj3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 150, 150, 224], [226, 226, 251, 251, 324], [326, 326, 348, 348, 446], [448, 448, 497, 497, 561], [563, 563, 593, 593, 1418], [1421, 1421, 1455, 1455, 1729], [1814, 1814, 1847, 1847, 1925], [1931, 1931, 1962, 1962, 2045], [2047, 2047, 2112, 2112, 2555], [2557, 2557, 2596, 2596, 2629], [2631, 2631, 2660, 2660, 2727], [2729, 2756, 2783, 2783, 2824], [2826, 2899, 2927, 2927, 3180], [3182, 3243, 3296, 3296, 3762], [3764, 3764, 3828, 3828, 4091], [4093, 4093, 4123, 4123, 4442], [4444, 4444, 4469, 4469, 4921], [4923, 4923, 4981, 4981, 5532], [5534, 5534, 5574, 5574, 6132], [6134, 6134, 6191, 6241, 6879]]}
{"id": "Wdj3W3", "name": "Moving White Blurry Circles", "author": "arthurstammet", "description": "Inspired by The Art of Code - Shadertoy Tutorials\nhttps://www.youtube.com/playlist?list=PLGmrMu-IwbguU_nY2egTFmlg691D\n\nThis circle moves around following a smooth Lissajous Curve and also changes its radius very slowly in order to simulate some depth. ", "tags": ["tutorial", "circle", "animation", "function", "lissajous"], "likes": 1, "viewed": 300, "published": "Public API", "date": "1550248582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Moving White Blurry Circle\n// inspired by The Art od Code - Shadertoy Tutorials\n// https://www.youtube.com/playlist?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5\n\nfloat Circle(vec2 uv, float r, float blur) {\n    float d = length(uv);\n    float c = smoothstep(r, r-blur, d);\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord.xy / iResolution.xy; \t// 0. <> 1.\n    vec2 uv2 = fragCoord.xy / iResolution.xy; \t// 0. <> 1.\n\n    float ldiffx1 = .2;\t\t\t\t\t\t\t// choose the shape of the Lissajous curve\n \tfloat ldiffy1 = .17;\t\t\t\t\t\t// 1. and 1. = ellipse\n    float mx1 = .5+(sin(iTime*ldiffx1)*.35);\t// create a modulated\n    float my1 = .5+(cos(iTime*ldiffy1)*.22);\t// Lissajous Curve\n    float mr1 = .15+(sin(iTime*.39)*.1);\t\t// modulate the radius of the circle\n    \n    float ldiffx2 = .6;\t\t\t\t\t\t\t// choose the shape of the Lissajous curve\n \tfloat ldiffy2 = .45;\t\t\t\t\t\t// 1. and 1. = ellipse\n    float mx2 = .5+(sin(iTime*ldiffx2)*.25);\t// create a modulated\n    float my2 = .5+(cos(iTime*ldiffy2)*.24);\t// Lissajous Curve\n    float mr2 = .15+(sin(iTime*.33)*.13);\t\t// modulate the radius of the circle\n    \n    uv1 -= vec2(mx1,my1);\t\t\t\t\t\t\t// -0.5 <> 0.5\n    uv1.x *= iResolution.x/iResolution.y;\n\n    uv2 -= vec2(mx2,my2);\t\t\t\t\t\t\t// -0.5 <> 0.5\n    uv2.x *= iResolution.x/iResolution.y;\n\n    float mask = Circle(uv1, mr1, .2-(mr1*.12));\n\tmask += Circle(uv2, mr2, .2-(mr2*.12));\n\n    fragColor = vec4(vec3(mask), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdj3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 204, 204, 287], [289, 289, 346, 346, 1456]]}
{"id": "wdj3Wm", "name": "VolumetricFlow", "author": "felipunkerito", "description": "Above the clouds infinite skills create miracles...", "tags": ["3d", "ray", "sdf", "marching", "volumetrics"], "likes": 12, "viewed": 681, "published": "Public API", "date": "1549073235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  acos( -1.0 )\n#define TPI     2.0 * PI\n#define HASHSCALE  .1031\n\nmat2 rot( float a )\n{\n\n\treturn mat2( cos( a ), -sin( a ),\n               \t sin( a ),  cos( a )\n               );\n\n}\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Thanks Shane.\nfloat noise3D(vec3 p){\n\n    // Just some random figures, analogous to stride. You can change this, if you want.\n\t  const vec3 s = vec3(7, 157, 113);\n\n\t  vec3 ip = floor(p); // Unique unit cell ID.\n\n    // Setting up the stride vector for randomization and interpolation, kind of.\n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\n\t  p -= ip; // Cell's fractional component.\n\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n\n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\n\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n\n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n\n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\n}\n\n/*\nfloat fbm( in vec3 p )\n{\n\n    p.xy *= rot( time * 0.5 );\n\n    float f = 0.0;\n    f += 0.5000 * noise3D( p ); p *= 2.02;\n    f += 0.2500 * noise3D( p ); p *= 2.03; //p += iTime + FRE;\n    f += 0.1250 * noise3D( p ); p *= 2.01; //p -= iTime + WAV;\n    f += 0.0625 * noise3D( p );\n    f += 0.0125 * noise3D( p );\n    return f / 0.9375;\n\n}\n*/\n\nfloat fbm( vec3 p )\n{\n\n\tfloat amp = 1.0, fre = 1.0, res = 0.0, div = 0.0,\n\ttim = 0.8;\n\n\tfor( int i = 0; i < 7; ++i )\n\t{\n\n\t\tres += amp * noise3D( p * fre );\n\t\tp += 0.025 * tim * iTime;\n\t\tdiv += amp;\n\t\tamp *= 0.5;\n\t\tfre *= 2.0;\n\t\ttim *= 0.5;\n\n   }\n\n\tres /= div;\n\n\treturn res;\n}\n\nfloat map( vec3 p )\n{\n\n    float f = 0.0;\n\n    f = p.y - 1.5 + fbm( p ) * 5.0;\n\n    return f;\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float den )\n{\n\n    float t = 0.0, maxD = 0.0; den = 0.0;\n\n    for( int i = 0; i < 128; ++i )\n    {\n\n        vec3 p = ro + rd * t;\n\n        den = 0.5 * map( p );\n\n        maxD = maxD < den ? den : maxD;\n\n        if( den > 0.99 || t > 20.0 ) break;\n\n        // https://www.shadertoy.com/view/MscXRH\n        t += max( maxD * 0.05, 0.05 );\n\n        //t += 0.05;\n\n    }\n\n    den = maxD;\n\n    return t;\n\n}\n\nvec3 shad( vec3 ro, vec3 rd, vec2 uv )\n{\n\n    //float wav = texture( iChannel1, vec2( 0.5, 0.6 ) ).x * 0.5;\n    //float fre = texture( iChannel1, vec2( 0.2, 0.5 ) ).x * 0.5;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n\n    float den = 0.0;\n    float t = ray( ro, rd, den );\n\n    vec3 p = ro + rd * t;\n\n    vec3 col = mix( vec3( 0.9 ),\n               \t   mix( vec3( min( 0.3, mou.y ), 0.2, 0.6 ),\n               \t         mix( vec3( 0.8, 0.8, 0.8 ),\n               \t        \t  vec3( 0.2, 0.5, 0.8 ),\n               \t        \t  uv.y ),\n               \t        \t  den\n               \t       ),\n                    den );\n\n    //col *= sqrt( col );\n\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n\n    //float pi = acos( -1.0 );\n    vec3 ro = vec3( 0, 0.25, 0 );\n    //ro.y -= fbm( ro );\n    ro.xz *= rot( mou.x * TPI );\n    //ro.yz *= rot( gyroscope.y );\n    vec3 rd = normalize( vec3( uv, 1.0 ) );\n    //rd.y -= fbm( ro );\n    rd.xz *= rot( mou.x * TPI );\n    //rd.yz *= rot( gyroscope.y );\n\n    //ro *= rotationMatrix;\n    //rd *= rotationMatrix;\n\n    float den = 0.0, t = ray( ro, rd, den );\n\n    vec3 bco = mix( vec3( 0.8, 0.8, 0.8 ),\n               \t   vec3( 0.2, 0.5, 0.8 ),\n               \t   uv.y );\n\n    vec3 col = den < 0.99 ? shad( ro, rd, uv ) : bco;\n\n    //vec3 bkCol = mix( vec3( 0.8 ), vec3( 0.2, 0.5, 0.8 ), uv.y );\n\t  //vec3 col = mix( bkCol, shad( ro, rd, uv ), den );\n\n    // Output to screen\n    fragColor = vec4( col, 1 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdj3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 97, 97, 191], [193, 235, 256, 256, 373], [375, 392, 414, 503, 1939], [1941, 2284, 2305, 2305, 2559], [2561, 2561, 2582, 2582, 2657], [2659, 2659, 2705, 2705, 3091], [3093, 3093, 3133, 3266, 3756], [3758, 3758, 3815, 3815, 4683]]}
{"id": "Wdj3Wt", "name": "LGBTS", "author": "Lianon", "description": "Flag experiment", "tags": ["flag"], "likes": 2, "viewed": 77, "published": "Public", "date": "1550449129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 1.015 + 0.1*cos(iTime+uv.xyx+vec3(0,2,4)/200.0);\n    float balanco = sin((iTime) + (uv.y*0.5))/50.0;\n\n    // Output to screen\n    \n    if(uv.y*(col.y * col.x)  <= 0.165 && uv.x <= 0.165 + balanco + 5.0)\n        fragColor = vec4 (0.6,0,0.8,0);\n    else if(uv.y*(col.y * col.x ) <= 0.33 && uv.x <= 0.33 + balanco + 5.0)\n        fragColor = vec4 (0.3,0.1,0.9,0);\n    else if(uv.y*(col.y * col.x ) <= 0.485 && uv.x <= 0.485 + balanco + 5.0)\n        fragColor = vec4 (0.5,1,0.6,0);\n    else if(uv.y*(col.y * col.x) <= 0.65 && uv.x <= 0.65 + balanco + 5.0)\n        fragColor = vec4 (0.9,0.8,0.1,0);\n    else if(uv.y*(col.y * col.x ) <= 0.83 && uv.x <= 0.83 + balanco + 5.0)\n        fragColor = vec4 (0.9,0.6,0.3,0);\n    else if(uv.y*(col.y * col.x) <= 1.0 && uv.x <= 1.0 + balanco + 5.0)\n        fragColor = vec4 (0.8,0,0.1,0);\n    else\n        fragColor = vec4 (0,0,0,0);\n                \n                   \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdj3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1111]]}
{"id": "wdjGDc", "name": "SDF Reflections", "author": "Sciman101", "description": "First attempts at sdf rendering stuff. Most of the code is more or less copied from yx and other tutorials.", "tags": ["sdf"], "likes": 1, "viewed": 259, "published": "Public", "date": "1550191316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 color = vec3(.1,.4,.6);\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n//Thanks iq\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nint mat;\n\n//Main scene functon\nfloat scene(vec3 p) {\n\n   //float box = sdBox(p-vec3(.75,0,0),vec3(.5)) - .5;\n   float sphere = sdSphere(p+vec3(0,0,0),2.);\n    \n   p.y = abs(p.y);\n   sphere = opSmoothUnion(sphere,sdSphere(p+vec3(0,-1.5+sin(iTime),0),1.),.5);\n    \n   p = mod(p,10.) - 5.;\n   float box = sdSphere(p,1.5);\n    \n   float d = min(sphere,box);\n    \n    if (d == sphere) {\n        mat = 0;\n    }else{\n        mat = 1;\n    }\n    \n   return d;\n    \n}\n\n//Shadow calculation function\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = scene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n//Thanks yx\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, -.3);\n    p.xz = rotate(p.xz, iTime*.5);\n}\n\nconst vec3 lDir = vec3(1,1,1);\n\nvec3 trace(vec3 cam, vec3 dir) {\n    //Perform raytrace\n    float t = 0.;\n    float k = 0.;\n    vec3 h;\n    for(int i=0;i<100;++i) {\n        k=scene(cam+dir*t);\n        t+=k;\n        if(k<.001)\n        {\n            h = cam+dir*t;\n            vec2 o=vec2(.02,0);\n            vec3 n= normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n\n            //Light comes from camera\n            float light = dot(n,normalize(lDir))*.5+.5;\n            \n            //Add specular reflections\n            light += pow(light,64.);\n            \n            float shad = shadow(h,lDir,0.,1000.);\n            \n            if (mat == 0) {\n                \n                //Reflection\n                //Change ray origin and direction so that it now points off the suface of the shape\n                cam = h;\n                dir = reflect(dir,n);\n                \n                //The distance MUST be greater than the minimum amount, or else it will just \n                t = 0.002;\n                \n            }else if (mat == 1){ \n                return n*light;\n            }\n        }\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n\n    //Multiply by aspect\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Define camera position and direction\n    vec3 cam = vec3(0,0,10);\n    vec3 dir = normalize(vec3(uv,-1));\n    \n    cameraspin(cam);\n    cameraspin(dir);\n    \n    fragColor.rgb = trace(cam,dir);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 69, 69, 97], [99, 111, 140, 140, 229], [231, 231, 283, 283, 382], [394, 415, 436, 492, 841], [843, 873, 937, 937, 1100], [1102, 1114, 1144, 1144, 1267], [1268, 1268, 1299, 1299, 1366], [1400, 1400, 1432, 1455, 2624], [2627, 2627, 2684, 2739, 3064]]}
{"id": "wdjGDK", "name": "Blobby McFerrite", "author": "Gaxil", "description": "Experimenting with raymarching and a home made subsurface scattering ... \nThe SSS raycast can be improved by using SDF in a better way ...", "tags": ["raymarch", "blob"], "likes": 57, "viewed": 1674, "published": "Public", "date": "1550070806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.141592653589793\n#define SUBSPHERE_COUNT 24\n#define MAINSPHERE vec4(0, 0, 0, 1)\n\nvec4[SUBSPHERE_COUNT] secondaries;\n\n// Hash from Dave_Hoskins\n#define HASHSCALE1 .1031\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Noise1D(float x)\n{\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n   \tf = f*f*(3.0-2.0*f);\n\n\treturn mix(hash11(p), hash11(p+1.0), f);\n}\n\nvec3 GetSphericalFibonacciCoord(int ng, int index)\n{\n\tfloat phi = ( 1.0 + sqrt ( 5.0 ) ) / 2.0;\n    \n  \tfloat ngFloat = float(ng);\n\n    float iFloat = float( - ng + 1 + 2 * index);\n    float theta = 2.0 * PI * iFloat / phi;\n    float sphi = iFloat / ngFloat;\n    float cphi = sqrt ( ( ngFloat + iFloat ) * ( ngFloat - iFloat ) ) / ngFloat;\n\n    return vec3(\n        cphi * sin ( theta ),\n        cphi * cos ( theta ),\n\t\tsphi);\n}\n\n// Smooth min function from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p) \n{\n\tvec4 s = MAINSPHERE;\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float d=sphereDist;\n    \n\tfloat sphere2Radius = 0.25;\n\tfor(int i=0;i<SUBSPHERE_COUNT;i++)\n    {\n\t\tvec4 secSpj = secondaries[i] ;\n\t\tfloat secondarySphereDist = length(p- secSpj.xyz - MAINSPHERE.xyz)-secSpj.w;\n\t\td = smin(d, secondarySphereDist, .1);\n    }\n    \n    return d;\n}\n\n// Raytrace inside volume to check for occlusion\nfloat RayMarchOut(vec3 ro, vec3 rd) \n{\n\tfloat dO=0.;\n    \n    for(float i=0.0; i<1.0; i+=0.05) \n\t{\n    \tvec3 p = ro + rd*i;\n        float dS = GetDist(p);\n\t\tdO += 0.05 * step(dS, 0.0);\n    }\n\treturn exp(-dO*1.1);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n\t{\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 GetLight(vec3 p, vec3 rd, float curd, vec4 noise) \n{\n\tvec3 SScol = vec3(0.8, 0.4, 0.4);\n\n    // Light 1\n\tvec3 lightCol = vec3(1.0, 0.1, 0.1);\n\tfloat d2;\n    \n    vec3 lightPos = vec3(0, 2, 6);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\td2 = RayMarchOut(p+rd*(SURF_DIST*4. + noise.x*0.05), l);\n    float dif = dot(n, l);\n\tfloat invDif = clamp(-dif, 0., 1.); \n    dif = clamp(dif, 0., 1.);\n\n\tvec3 light = (0.5 + dif*0.5)*SScol*d2*lightCol ;\n\tvec3 v = -rd;\n\tvec3 reflect = normalize(2.0 * dif * n - l); \n\tfloat specular = pow(clamp(dot(reflect, v), 0.0, 1.0), 12.0) * dif;\n\tfloat specular2 = pow(clamp(dot(reflect, v), 0.0, 1.0), 5.0) * dif;\n\tlight += (vec3(specular) + specular2 * SScol)*lightCol;\n\n\n    // Light 2\n\tlightCol = vec3(0.1, 0.1, 1.0);\n \tlightPos = vec3(0, -2, -6);\n    l = normalize(lightPos-p);\n  \td2 = RayMarchOut(p+rd*(SURF_DIST*4. + noise.x*0.05), l);\n    dif = dot(n, l);\n\tinvDif = clamp(-dif, 0., 1.); \n    dif = clamp(dif, 0., 1.);\n\t\n\tlight += (0.5 + dif*0.5)*SScol*d2*lightCol ;\n\treflect = normalize(2.0 * dif * n - l); \n\tspecular = pow(clamp(dot(reflect, v), 0.0, 1.0), 12.0) * dif;\n\tspecular2 = pow(clamp(dot(reflect, v), 0.0, 1.0), 5.0) * dif;\n\tlight += (vec3(specular) + specular2 * SScol)*lightCol;\n\n    return light;\n}\n\nvec3 RotateY(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x * cos(angle) - pos.z * sin(angle),\n        pos.y,\n        pos.x * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nvec3 RotateX(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x,\n        pos.y * cos(angle) - pos.z * sin(angle),\n        pos.y * sin(angle) + pos.z * cos(angle)\n    );\n}\n\n// Reinhard Tonemapping\nvec3 ToneMap(vec3 inColor)\n{\n    inColor *= 1.0;  // Hardcoded Exposure Adjustment\n    inColor = inColor/(vec3(1)+inColor);\n    vec3 retColor = pow(inColor,vec3(1.0/2.2));\n    return retColor;\n    \n    return inColor;\n}\n\n// Raymarching inspired by RayMarching for Dummies! from BigWIngs\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Avoid recomputing the sphere pos more than once per pixel\n\tfor(int i=0;i<SUBSPHERE_COUNT;i++)\n    {\n\t\tvec3 ssphPos = GetSphericalFibonacciCoord(SUBSPHERE_COUNT, i).xzy;\n\t\tfloat rndVal = Noise1D(float(i)*0.1+iTime*2.5+ssphPos.y);\n\t\tssphPos *= (.7 + rndVal*.7);\n\t\tsecondaries[i] = vec4(ssphPos, mix(0.5, 0.15, rndVal));\n    }\n\n    vec4 noise = texture(iChannel0, fragCoord/1024.0); \n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 offset =  vec3(0.0, 0.0, 0.0);\n\tfloat angle = mix(iTime, 4.0-iMouse.x/iResolution.x*8.0, step( 0.001, iMouse.z ));\n\n\tvec3 ro = offset + vec3(0.0, 0.0, -8.0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 2));\n    \n\tro = RotateY(ro, angle);\n\trd = RotateY(rd, angle);\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 col = mix( vec3(0.5, 0.5, 0.5), GetLight(p, rd, d, noise), step(d,50.0));\n        \n    fragColor = vec4(ToneMap(col),1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 245, 268, 268, 386], [388, 388, 412, 412, 524], [526, 526, 578, 578, 954], [956, 987, 1028, 1028, 1121], [1123, 1123, 1147, 1147, 1498], [1500, 1549, 1587, 1587, 1763], [1766, 1766, 1801, 1801, 2009], [2011, 2011, 2036, 2036, 2225], [2228, 2228, 2285, 2285, 3497], [3499, 3499, 3537, 3537, 3672], [3674, 3674, 3712, 3712, 3847], [3849, 3873, 3901, 3901, 4092], [4094, 4160, 4217, 4279, 5122]]}
{"id": "wdjGRV", "name": "2D Heart beat", "author": "surffer3d", "description": "Heart beat", "tags": ["procedural", "2d", "animation", "heart"], "likes": 5, "viewed": 148, "published": "Public", "date": "1549410479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate world UVs\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5);\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    uv.y -= 0.2;    // Displace the uv to center the heart\n    \n\n    float a = atan(uv.x,uv.y) / PI;     // angle\n    float r = length(vec2(uv.x,uv.y));  // radius\n    \n    float duration = 1.75;\n    float t = pow(mod(iTime, duration)/duration, 0.85);\n    float tanim = sin(t*PI*10.0) * exp(1.0 - t*4.0);\n    float global_scale = 0.75;\n    float d = global_scale *\n                (0.2\n               + 0.6 * abs(a)                     // main\n               - (0.1 - tanim*0.0125) * cos(abs(a) * PI * 2.0)     // wide\n               + (0.05 + tanim*0.025) * pow(abs(a), 20.0)         // bottom\n               - step(0.0, a) * 0.075 * sin(a*PI)  // reduce right side\n                );\n\n    float light_pos = length(vec2(uv.x - 0.35, uv.y + 0.25));\n    vec3 heart_color = vec3(0.1, 0.0, 0.15) + vec3(pow(min(d,0.15),light_pos), 0, 0);\n    vec3 background = vec3(0.85, 0.75, 0.65) * (1.5 -r);\n    float is_heart = smoothstep(d, d+fwidth(r)*2.0, r);\n    vec3 color = mix(heart_color, background, is_heart);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 111, 1307]]}
{"id": "wdjGWm", "name": "Inverse Square Law", "author": "richard702", "description": "2D demo of inverse square law.", "tags": ["2dlight"], "likes": 0, "viewed": 106, "published": "Public", "date": "1549068950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Metaball{\n    vec2 Position;\n    float RadiusSq;\n    vec3 Color3;\n};\n\nMetaball light1 = Metaball(\n    vec2(0.9, 0.5), pow(0.1, 2.0), vec3(1.0, 0.0, 0.0)\n);\nMetaball light2 = Metaball(\n    vec2(0.9, 0.5), pow(0.1, 2.0), vec3(0.0, 1.0, 1.0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float lightOffset = 0.4*sin(iTime);\n    light2.Position.x = 0.9 + lightOffset*cos(0.5*iTime);\n    light2.Position.y = 0.5 + lightOffset*sin(0.5*iTime);\n    vec2 disp1 = uv-light1.Position;\n    vec2 disp2 = uv-light2.Position;\n    float g1 = \n        clamp(light1.RadiusSq/(dot(disp1, disp1)+0.001), 0.0, 1.0);\n    float g2 = \n        clamp(light2.RadiusSq/(dot(disp2, disp2)+0.001), 0.0, 1.0);\n    vec3 combColor = g1*light1.Color3 + g2*light2.Color3;\n    fragColor = vec4(combColor, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 307, 357, 934]]}
{"id": "WdjGWV", "name": "waves01", "author": "ali", "description": "sine waves", "tags": ["sincos"], "likes": 5, "viewed": 79, "published": "Public", "date": "1550018790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n\n// in radians\nvec2 rot2d(vec2 st, float angle){\nst =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    return st;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n \n\t\n\tuv = rot2d(uv,PI*.1*iTime);\n\n\tfloat width = 0.01;\n    uv=uv*2.;\n    vec3 color=vec3(0);\n    for(float i = 0.0; i < 20.0; i++) {\n\t\tuv.y+= (0.04 * sin(uv.x + i/20. + iTime));\n        width = abs(1.0 / (250.0 * uv.y));\n\t\tcolor += vec3(width * uv.x, width * 0.4, width*uv.y*0.8);\n\t}\n    \n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 39, 72, 72, 174], [176, 176, 233, 233, 598]]}
{"id": "Wdl3R7", "name": "Всепокайтеся!", "author": "nolibab", "description": "Всепокайтеся, грехоносцы! Богу в угоду. Ибо Христос грядёт!\nAll confess, sin carriers! To god to please. Because Christ approaches!", "tags": ["confess", "sinners", "christ", "approaches"], "likes": 2, "viewed": 247, "published": "Public", "date": "1550086463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec4 fire(vec2 p)\n\t{\n    p-=vec2(.5);     \n\tp.x /= 1.75;\n\t\n\tfloat color = 3.0 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 2; i++)\n\t\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);\n\t\t}\n\treturn vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n\t}\n\n\nconst vec2 ch_size  = vec2(0.9, 2.0);              \t// character size\nconst vec2 ch_space = ch_size + vec2(0.7, 1.0);    \t// character distance  \nconst vec2 ch_start = vec2 (-8.8, 3.0); \t\t\t// start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             \t// character position\nfloat d = 1e6;\n\n/* 16 segment display...\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n\n#define A_ ch_pos.x-=0.5;ddigit(0x4381,uv);ch_pos.x+=0.1;\n#define B_ ch_pos.x-=0.5;ddigit(0xC442,uv);\n#define V_ ch_pos.x-=0.5;ddigit(0xC642,uv);\n#define G_ ch_pos.x-=0.5;ddigit(0x4402,uv);\n#define D_ ch_pos.x-=0.5;ddigit(0x42C1,uv);ch_pos.x+=0.1;\n//#define E_ ch_pos.x-=0.5;ddigit(0x4542,uv);\n#define E_ ch_pos.x-=0.5;ddigit(0x8300,uv);\n#define EY_ ch_pos.x-=0.5;ddigit(0x8300,uv);ch_pos+=vec2(.5-ch_space.x,2.5);ddigit(0x0,uv); ch_pos.x+=.5-ch_space.x; ddigit(0x0,uv); ch_pos-=vec2(1.,2.5);\n//ch_pos+=vec2(1.-ch_space.x,0.);ddigit(0,uv);ch_pos-=vec2(1.,1.);\n\n#define J_ ddigit(0xEE00,uv);\n#define Z_ ch_pos.x-=0.5;ddigit(0x8242,uv);\n#define I_ ddigit(0x6418,uv);ch_pos.x-=0.4;ch_pos.x+=0.1;\n#define IY_ ddigit(0x6418,uv);ch_pos+=vec2(-ch_space.x,.5);ddigit(0x4,uv);ch_pos-=vec2(.5,.5);ch_pos.x+=0.1;\n#define K_ ch_pos.x-=0.5;ddigit(0xc600,uv);\n#define L_ ch_pos.x-=0.5;ddigit(0x4281,uv);ch_pos.x+=0.1;\n#define M_ ddigit(0x0A99,uv);ch_pos.x+=0.1;\n#define N_ ch_pos.x-=0.5;ddigit(0x4581,uv);ch_pos.x+=0.1;\n#define O_ ch_pos.x-=0.5;ddigit(0x44c3,uv);ch_pos.x+=0.1;\n#define P_ ch_pos.x-=0.5;ddigit(0x4483,uv);ch_pos.x+=0.1;\n#define R_ ch_pos.x-=0.5;ddigit(0x4602,uv);\n//#define S_ ch_pos.x-=0.5;ddigit(0x4442,uv);\n#define S_ ch_pos.x-=0.5;ddigit(0x8200,uv);\n\n#define T_ ddigit(0x4406, uv /* * vec2(1.2, 1.)-vec2(.5,0.)*/ );//ch_pos.x-=0.3;\n\n#define U_ ddigit(0x3408,uv);ch_pos.x-=0.4;\n#define F_ ddigit(0x550F,uv);\n#define H_ ddigit(0xAA00,uv);\n//#define C_ ddigit(0x4478,uv);\n#define C_ ddigit(0x4478,uv);ch_pos+=vec2(.5-ch_space.x,-1.);ddigit(0x2000,uv);ch_pos-=vec2(.5,-1.);\n#define CH_ ddigit(0x5408,uv);ch_pos.x-=0.4;\n#define SH_ ddigit(0x44F9,uv);ch_pos.x+=0.1;\n//#define SHCH_ ddigit(0x1589,uv);\n#define SHCH_ ddigit(0x44F9,uv);ch_pos+=vec2(1.-ch_space.x,-1.);ddigit(0x3000,uv);ch_pos-=vec2(.5,-1.);\n\n#define mz_ ch_pos.x-=0.5;ddigit(0xC440,uv);\n#define YI_ ddigit(0x50B9,uv);ch_pos.x+=0.1;\n#define tz_ ddigit(0xC44C,uv);\n//#define YE_ ddigit(0x5424,uv);\n#define YE_ ddigit(0x3800,uv);ch_pos.x-=0.4;\n\n#define YU_ ddigit(0x54DB,uv);ch_pos.x+=0.1;\n#define YA_ ddigit(0x740C,uv);ch_pos.x-=0.4;\n\n\n#define n0 ddigit(0x22FF,uv);\n#define n1 ddigit(0x0281,uv);\n#define n2 ddigit(0x1177,uv);\n#define n3 ddigit(0x11E7,uv);\n#define n4 ddigit(0x5508,uv);\n#define n5 ddigit(0x11EE,uv);\n#define n6 ddigit(0x11FE,uv);\n#define n7 ddigit(0x2206,uv);\n#define n8 ddigit(0x11FF,uv);\n#define n9 ddigit(0x11EF,uv);\n\n#define A ddigit(0x119F,uv);\n#define B ddigit(0x927E,uv);\n#define C ddigit(0x007E,uv);\n#define D ddigit(0x44E7,uv);\n#define E ddigit(0x107E,uv);\n#define F ddigit(0x101E,uv);\n#define G ddigit(0x807E,uv);\n#define H ddigit(0x1199,uv);\n#define I ddigit(0x4466,uv);\n#define J ddigit(0x4436,uv);\n#define K ddigit(0x9218,uv);\n#define L ddigit(0x0078,uv);\n#define M ddigit(0x0A99,uv);\n#define N ddigit(0x8899,uv);\n#define O ddigit(0x00FF,uv);\n#define P ddigit(0x111F,uv);\n#define Q ddigit(0x80FF,uv);\n#define R ddigit(0x911F,uv);\n#define S ddigit(0x8866,uv);\n#define T ddigit(0x4406,uv);\n#define U ddigit(0x00F9,uv);\n#define V ddigit(0x2218,uv);\n#define W ddigit(0xA099,uv);\n#define X ddigit(0xAA00,uv);\n#define Y ddigit(0x4A00,uv);\n#define Z ddigit(0x2266,uv);\n#define _ ch_pos.x += ch_space.x / 1.5;\n\n#define s_dot     ddigit(0,uv);ch_pos.x -= ch_space.x/2.;\n\n#define s_minus   ddigit(0x1100,uv);\n#define s_plus    ddigit(0x5500,uv);\n#define s_greater ddigit(0x2800,uv);\n#define s_less    ddigit(0x8200,uv);\n#define s_sqrt    ddigit(0x0C02,uv);\n#define s_exc ch_pos.y+=0.5; ddigit(0x18,uv);ch_pos+=vec2(-ch_space.x,-0.5);ddigit(0,uv);ch_pos.x-=1.;\n#define s_que ch_pos.y+=0.5; ddigit(0x1414,uv);ch_pos+=vec2(-ch_space.x,-0.5);ddigit(0,uv);ch_pos.x-=.4;\n\n#define s_sobaka ddigit(0x50F7,uv);\n\nfloat dseg(vec2 p0, vec2 p1, vec2 uv)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nvoid ddigit(int n, vec2 uv)\n{\n\tfloat v = 1e6;\t\n\tvec2 cp = uv - ch_pos;\n\tif (n == 0)     v = min(v, dseg(vec2(-0.505, -1.000), vec2(-0.500, -1.000), uv));\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937), uv));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000), uv));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000), uv));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062), uv));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938), uv));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000), uv));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000), uv));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063), uv));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000), uv));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938), uv));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937), uv));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938), uv));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000), uv));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938), uv));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063), uv));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938), uv));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texcoord = ( fragCoord.xy / iResolution.xy );\n\tvec2 uv = texcoord - vec2(0.5);\n\tuv *= 25.0; \t\n\t\n\tch_pos = ch_start;\n\tch_pos.x += 2.0; \n\tch_pos.y += 5.0;\n\tV_ S_ E_ P_ O_ K_ A_ IY_ T_ E_ S_ YA_ \n\n        ch_pos = ch_start;\n\tch_pos.x += 2.0; \n\tch_pos.y += 1.0;       \n        G_ R_ E_ H_ O_ N_ O_ S_ C_ YI_ _ s_exc\n\n\tch_pos = ch_start;\n\tch_pos.x += 2.0;\n\tch_pos.y -= 3.0;\n\tB_ O_ G_ U_ _ V_ _ U_ G_ O_ D_ U_\n\t\n\tch_pos = ch_start;\n\tch_pos.x += 8.0;\n\tch_pos.y -= 7.0;\n\tI_ B_ O_\n\n\tch_pos = ch_start;\n\tch_pos.x += 0.0;\n\tch_pos.y -= 11.0;\n\tH_ R_ I_ S_ T_ O_ S_ _ G_ R_ YA_ D_ EY_ T_ _ s_exc \n\n\tvec3 color = mix(vec3(1.), vec3(0.), smoothstep(0.0, 0.0, d) - (0.10 / d));\n\tif (length(color) > 0.6)\n\tfragColor = vec4(color, 1.0);\n\telse fragColor = fire(texcoord);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdl3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 558], [560, 560, 580, 580, 970], [3615, 5372, 5411, 5411, 5583], [5585, 5585, 5609, 5609, 5677], [5679, 5679, 5708, 5708, 7203], [7205, 7205, 7262, 7262, 8023]]}
{"id": "wdlSDr", "name": "основная часть", "author": "nirvanabc", "description": "чтобы получше рассмотреть середину рекомендуется повращать", "tags": ["raymarching"], "likes": 0, "viewed": 69, "published": "Public", "date": "1551109603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.14159265;\n\n\nvec2 obj_floor(in vec3 p, int color)\n{\n  return vec2(p.y+10.0 + 0.8 * sin(iTime), color);\n}\n\n\nvec2 obj_cone( in vec3 p, in vec3 c, int color)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), color);\n}\n\n\nvec2 obj_cylinder( vec3 p, vec2 h, int color)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)), color);\n}\n\n\nvec2 obj_torus(in vec3 p, int color)\n{\n  vec2 r = vec2(2.1,0.5);\n  vec2 q = vec2(length(p.xy)-r.x,p.z);\n  float d = length(q)-r.y + 0.1 * sin(iTime);\n  return vec2(d, color);\n}\n\n\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  if (obj0.x < obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n\nvec2 op_sub(vec2 a, vec2 b, int color)\n{\n  float d = max(a.x, -b.x);\n  if (d == a.x)\n    return vec2(d, 2);\n  else return vec2(d, color);\n}\n\nvec2 obj_sphere(in vec3 p, float r, float k, int color)\n{\n  float d = length(p)- r + k * sin(iTime);\n  return vec2(d, color);\n}\n\nvec2 twist_torus(vec3 p, int color)\n{\n    float  c = cos(1.0*p.y+5.0);\n    float  s = sin(1.0*p.y+5.0);\n    mat2   m = mat2(c,-s,s,c);\n    return obj_torus(vec3(m*p.xz,p.y), color);\n}\n\n\nvec2 twist_t_bad(vec3 p, int color)\n{\n    float  c = cos(1.0*p.y);\n    float  s = sin(2.0*p.z);\n    mat2   m = mat2(c,-s,s,c);\n    return obj_torus(vec3(m*p.xz,p.y), color);\n}\n\n\nvec2 twist_s_bad(vec3 p, float r, float k, int color)\n{\n    float  c = cos(1.6*p.y);\n    float  s = sin(1.*p.x);\n    mat2   m = mat2(c,-s,s,c);\n    return obj_sphere(vec3(m*p.xz, p.y), r, k, color);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\t\n  \tvec2 dist = op_sub(obj_sphere(p + 0.03*sin(20.0*p.x)*sin(20.0*p.y)*sin(2.0*p.z), 1.9, 0.7, 1), obj_cylinder(p, vec2(2,1), 2), 1);\n    dist = obj_union(obj_torus(p, 3), dist);\n    dist = obj_union(obj_sphere(p+ 0.3*sin(7.0*p.x)*sin(7.0*p.y)*sin(7.0*p.z), 1.5, 0.3, 1), dist);\n    dist = obj_union(twist_s_bad(p - vec3(0,0,4), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(0,0,-4), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(0,4,0), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(4,0,0), 0.7, 0.2, 5), dist);\n    dist = obj_union(twist_s_bad(p - vec3(-4,0,0), 0.7, 0.2, 5), dist);\n    dist = obj_union(obj_cone(p - vec3(0.0,3.50,-3.0), vec3(0.8,0.6,0.7), 7), dist);\n    dist = obj_union(obj_cone(p - vec3(0.0,3.50,3.0), vec3(0.8,0.6,0.7), 7), dist);\n    dist = obj_union(dist, vec2( 0.6 * \n                                 twist_t_bad(p - vec3(0.0,0.0, 0.0), 6)));\n    \n  return obj_union(obj_floor(p, 0), dist);\n}\n\n\nvec3 floor_color(in vec3 p)\n{\n  if (fract(p.x*0.2)>0.2)\n  {\n    if (fract(p.z*0.2)>0.2)\n      return vec3(0.4, 0.7,0.2);\n    else\n      return vec3(1,2.1,1);\n  }\n  else\n  {\n    if (fract(p.z*.2)>.2)\n      return vec3(1.9,1,1);\n    else\n      return vec3(0.3,0,1);\n   }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n\n  // Camera up vector.\n  vec3 vuv=vec3(0,1,0); \n  \n  // Camera lookat.\n  vec3 vrp=vec3(0,0,0);\n\n  float mx=iMouse.x/iResolution.x*PI*2.0;\n  float my=iMouse.y/iResolution.y*PI/2.0;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*10.0; \n\n  // Camera setup.\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n  \n\n  // Raymarching.\n  const vec3 e=vec3(0.02,0.007,0.001);\n  const float maxd=100.0; //Max depth\n  vec2 d=vec2(0.1,0.0);\n  vec3 c,p,N;\n\n  float f=1.0;\n  for(int i=0;i<256;i++)\n  {\n    if ((abs(d.x) < .001) || (f > maxd)) \n      break;\n    \n    f+=d.x;\n    p=prp+scp*f;\n    d = distance_to_obj(p);\n  }\n  \n  if (f < maxd)\n  {\n    // y is used to manage materials.\n    if (d.y==0.0) \n      c = floor_color(p);\n    else if (d.y == 1.0)\n      c = vec3(0.9,0.1,0.5);\n    else if (d.y == 2.0)\n      c = vec3(0.1,0.1,1.8);\n    else if (d.y == 3.0)\n      c = vec3(0.2,0.2,0.6);\n    else if (d.y == 4.0)\n      c = vec3(0.7,0.1,0.6);\n    else if (d.y == 5.0)\n      c = vec3(0.1,1.4,1.2);\n    else if (d.y == 7.0)\n      c = vec3(1.1,1.9,0.2);    \n    else c = vec3(0.,1.0,0);\n        \n    \n    vec3 n = vec3(d.x-distance_to_obj(p-e.xyy).x,\n                  d.x-distance_to_obj(p-e.yxy).x,\n                  d.x-distance_to_obj(p-e.yyx).x);\n    N = normalize(n);\n\tvec3 L = vec3(sin(iTime)*20.0,10,cos(iTime)*20.0);\n    float b=dot(N,normalize(prp-p+L));\n    //phong lighting, LightPosition = CameraPosition\n    fragColor=vec4((b*c+pow(b,16.0))*(1.0-f*.01),1.0);\n  }\n  else \n    fragColor=vec4(0.2,0,0.5,1); //background color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 61, 61, 114], [117, 117, 166, 166, 348], [351, 351, 398, 398, 514], [517, 517, 555, 555, 693], [696, 696, 740, 740, 804], [806, 806, 846, 846, 945], [947, 947, 1004, 1004, 1074], [1076, 1076, 1113, 1113, 1259], [1262, 1262, 1299, 1299, 1437], [1440, 1440, 1495, 1495, 1640], [1642, 1642, 1675, 1675, 2645], [2648, 2648, 2677, 2677, 2918], [2921, 2921, 2978, 2978, 4725]]}
{"id": "wdlSzM", "name": "Phong Refrection Test", "author": "yasuo", "description": "Phong shading experiments.", "tags": ["phong"], "likes": 2, "viewed": 270, "published": "Public API", "date": "1550932813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec4 map(vec3 p){\n    vec3 pref = p;\n    pref += vec3(0.0,0.0,-1.0);\n    pref *= matRotateX(radians(iTime*20.0))*matRotateY(radians(iTime*20.0))*matRotateZ(radians(iTime*20.0));\n    vec2 t= vec2(0.5,0.15);\n    vec2 q = vec2(length(pref.xz)-t.x,pref.y);\n    \n    return vec4(vec3(0.9),length(q)-t.y);\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*30.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n        vec3 V = distPos;\n        vec3 L = normalize(lightDir-V);\n        \n        vec3 E = normalize(-V);\n        vec3 R = normalize(-reflect(L, normal));\n        \n\t\t// difuse color\n        float diffuseVal = 2.7;\n        float diffuse = diffuseVal * max(dot(normal, L), 0.0);\n        diffuse = clamp(diffuse, 0.0, 1.0);\n        \n\t\tfloat specVal = 0.9;\n\t\tfloat shininess = 10.0;\n\t\tfloat spec = specVal * pow(max(dot(R, E), 0.0), 0.3*shininess);\n        spec = clamp(spec, 0.0, 1.0);\n\t\t\t\t\n        float AmbientVal = 1.5;\n        vec3 AmbientColor = vec3(1.0,0.0,0.0);\n        vec3 DiffuseColor = vec3(0.3,0.3,0.3);\n        vec3 SpecularColor = vec3(0.9);\n\t\tvec3 ambient = AmbientVal * AmbientColor;        \n        \n\t\tfloat lambert = max(.0, dot( normal, light));\n\n\t\t// result\n\t\tcolor = (distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        color *= ambient +(DiffuseColor * diffuse)+ (SpecularColor*spec);\n\t}else{\n        color =.84*max(mix(vec3(0.9,1.11,1.15)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = color*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 274, 274, 558], [560, 560, 583, 583, 833], [835, 835, 891, 891, 2644]]}
{"id": "wdlSzn", "name": "Hypnotic Carpet", "author": "arthurstammet", "description": "Hypnotic grid with animated overlapping pulsating Xor Circles.\n\nCode inspired by https://www.youtube.com/watch?v=cQXAbndD5CQ with many thanks for the high competence.", "tags": ["circle", "animation", "xor", "rotation", "operlap"], "likes": 5, "viewed": 558, "published": "Public API", "date": "1550585404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Grid with animated overlapping pulsating Xor Circles \n// my step by step tutorial\n\nfloat Xor(float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; // set center to the middle of the screen\n    vec3 col = vec3(0.,0.,0.); // black screen\t\n\n    float ta = iTime*.2; // change animation speed : animation amplitude\n    float tr = iTime*.01; // change animation speed : carpet rotation\n    float tn = iTime*.009; // change animation speed : number of cells\n    float td = iTime*.003; // change animation speed : diameter of the circles\n    float th3 = iTime*.1; // change animation speed : amplitude of the 3rd harmonic\n    float th4 = iTime*.11; // change animation speed : amplitude of the 4th harmonic\n    float std = sin(td);\n    float tVarD = std+(3.*std*(.333*th3))+(4.*std*(.25*th4)); // build a complex wave\n\n    float amp1 = 0.1; // 0 <> 1.5 for circles\n    float amp2 = 0.7; // 0 <> 1.5 for circles (0.5 <> 1.5 for Xor effects)\n    \n\t// rotate a matrix\n    float a = tr;\n    float s = sin(a);\n    float c = cos(a);\n    uv *= mat2(c, -s, s, c);\n    uv *= 10. + sin(tn);\n\n    vec2 gv = fract(uv)-.5; // set center of a single box\n    vec2 id = floor(uv)+.5; // give each single box an id\n\n    float m = 0.;\n\n    // using the 8 cells surrounding main cell for drawing the circles\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n\t        vec2 offs = vec2(x, y);\n\t        float d = length(gv-offs);\n            float dist = length(id+offs)*(.25+(tVarD*.2)); // make the diameters pulsate\n\t        float r = mix(amp1, amp2, sin(dist-ta)*.5+.5); // set min and max = animation amplitude\n\n            m = Xor(m, smoothstep(r, r-15./iResolution.y, d));\n        }\n    }\n\n    col += m;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 86, 115, 115, 149], [151, 151, 208, 208, 1860]]}
{"id": "WdlXD4", "name": "antialiased line", "author": "santaclos", "description": "antialiased line", "tags": ["line", "antialiasing"], "likes": 3, "viewed": 245, "published": "Public", "date": "1551296178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p1 = iResolution.xy/2.;\n  //vec2 p2 = iMouse.xy;\n    vec2 p2 = vec2(iResolution.x * (sin(iTime*0.2) * .5 + .5), 0);\n  \n  float d = abs((p2.y - p1.y) * fragCoord.x - (p2.x - p1.x) * fragCoord.y + p2.x * p1.y - p2.y * p1.x);\n  d /= sqrt(pow(p2.y - p1.y, 2.) + pow(p2.x - p1.x, 2.));\n  \n  fragColor = vec4(clamp(d, 0., 1.2)/1.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlXD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 393]]}
{"id": "WdlXRN", "name": "3d Primitives  transparent anim.", "author": "tholzer", "description": "A set of animated 3d transparent primitives and combined objects.\nUse mouse to rotate scene or set ROTATE_SCENE = true.\nOriginal shader created by Inigo Quilez!", "tags": ["procedural", "3d", "raymarching", "primitives", "animated", "transparent"], "likes": 6, "viewed": 572, "published": "Public", "date": "1550749129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Shader:   3dPrimitivesTransAnim.glsl   \n//\n//  v1.1   4/2015  animation added to original\n//  v1.2  12/2016  using new objects  \n//  v1.3  11/2018  antialasing added, see AA\n//  v1.4  12/2018  icosahedron & dodecahedron added\n//  v1.5   2/2019  mainImage & calcNormal adaption\n//  v1.6   2/2019  merging transparent version\n//\n// tags: 3d, primitives, procedural, raymarching, animated, transparent\n//\n// see also:\n//   original:     https://www.shadertoy.com/view/Xds3zN   IQ, colored\n//   gray scaled:  http://glslsandbox.com/e#20839          \n//   transparent:  https://www.shadertoy.com/view/tdsXRn \n//   sdSuperprim:  https://www.shadertoy.com/view/Xdy3Rm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A list of useful distance function to simple primitives (animated), \n// and examples on how to do some interesting boolean operations, \n// repetitions and displacements you'll finder under\n//   http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\n\n// Question: Can fps be increased by checking first if we are \n//           intersecting an circumsphere first?\n//           This means 1. step raytracing 2. step rayMarching. \n\n#define AA 2   // make this 1 if your machine is too slow\n\n#define ANIMATE_OBJECTS true\n\n//#define ROTATE_SCENE true\n#define ROTATE_SCENE false\n\n#define flag true\n\n#define MODE 1\n// make this 0,1,2 for reflection,refraction,both objects\n#define REFRACTIDX 1.2\n\n#define PI 3.14159265359\n\nfloat time = 0.0;\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a), ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//---------------------------------------------------------\n// distance functions - distance operations - domain operations\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\nfloat length2( vec2 p )  // sqrt(x^2+y^2) \n{\n  return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )  // (x^6+y^6)^(1/6)\n{\n  p = p*p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )  // (x^8+y^8)^(1/8)\n{\n  p = p*p; \n  p = p*p; \n  p = p*p;\n  return pow( p.x + p.y, 1.0/8.0 );\n}\n\n//---------------------------------------------------------\n// distance operations\n//---------------------------------------------------------\n#define opUnion(a,b)      min(a,b)\n#define opIntersect(a,b)  max(a,b)            \n#define opDifference(a,b) max(a,-b)\n#define opSubstraction(a,b) max(-a,b)\n#define opExklusiveOr(a,b)  min(max(-a,b),max(-b,a))\n\n// Union: d1 + d2\nvec2 opU( in vec2 d1, in vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------------------\n// domain operations\n//---------------------------------------------------------\n\n// Repetition x,y,z:\n// vec3 opRepeat (vec3 p, vec3 c)  {  return mod(p, c)-0.5*c;   }\n#define opRepeat(p,c) (mod(p,c)-0.5*c)\n\n//---------------------------------------------------------\n// domain deformations: p=position\n//---------------------------------------------------------\n// Twist: angle = twist angle\nvec3 opTwist (vec3 p, float angle)\n{\n  float c = cos(10.0*p.y + angle);\n  float s = sin(10.0*p.y + angle);\n  mat2  m = mat2(c, -s, s, c);\n  return vec3(m*p.xz, p.y);\n}\n\n//---------------------------------------------------------\n//  3d primitives: p = position\n//---------------------------------------------------------\n\nfloat sdPlane1 (vec3 p)\n{\n  return p.y;\n}\n\nfloat sdPlane (vec3 p, vec4 n)  // n must be normalized\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float radius )\n{\n  return length(p) - radius;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    //old: return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdEgg1(in vec3 p, float radius)\n{\n  p.y = 0.8*p.y + 0.15 * pow(1.9*dot(p.xz, p.xz), 0.65);\n  return length(p) - radius;\n}\n\n// egg2:  https://www.shadertoy.com/view/lsXSWf\nfloat sdEgg2(vec3 p, float r)\n{\n    p.y -= r*0.5;\n    p.y *= 0.8;\n    return length(p) - 1.7 * r * cos(p.y + 1.36);\n}\n\n// signed box: b=size\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// unsigned box: b=size\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// unsigned rounded box: b=size, r=round radius\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b, 0.0))-r;\n}\n\n// Torus:  t.x = torus radius,  t.y = ring radius\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x, p.y);\n  return length8(q) - t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x, p.y);\n  return length8(q)-t.y;\n}\n\n// Capsule:  a,b = end points, r = cylinder radius\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// Triangle prism:  base radius, prism height\nfloat sdTrianglePrism( vec3 p, float radius, float height )\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max(q.x*0.866025 +p.y*0.5, -p.y) - radius*0.5);\n  #else\n    float d1 = q.z-height;\n    float d2 = max(q.x*0.866025+p.y*0.5, -p.y) - radius*0.5;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n  #endif\n}\n\n// Hexagonal Prism:  base radius, prism height\nfloat sdHexagonalPrism( vec3 p, float radius, float height)\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max((q.x*0.866025 +q.y*0.5), q.y) - radius);\n  #else\n    float d1 = q.z-heighty;\n    float d2 = max((q.x*0.866025 +q.y*0.5), q.y)-radius;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n// Cylinder: h.x=radius, h.y=height\nfloat sdCylinder(in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cylinder: h=dimension, h.y=height\nfloat sdCylinder (in vec3 p, in vec3 h)\n{\n  return length(p.xz - h.xy) - h.z;\n}\n\n// Cylinder6: h.xy = base rectangle size, h.z=height\nfloat sdCylinder6 (in vec3 p, in vec3 h)\n{\n  return max( length6(p.xz) - h.x, abs(p.y) - h.z );\n}\n\n// Cone: c=dimension\nfloat sdCone (in vec3 p, in vec3 c)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  #if 0\n    return max( max( dot(q, c.xy), p.y), -p.y -c.z );\n  #else\n    float d1 = -p.y - c.z;\n    float d2 = max( dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n// Dodecahedron: radius = circumsphere radius\nfloat sdDodecahedron(vec3 p, float radius)\n{\n  const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;  \n  const vec3 n = normalize(vec3(phi,1,0));\n\n  p = abs(p / radius);\n  float a = dot(p, n.xyz);\n  float b = dot(p, n.zxy);\n  float c = dot(p, n.yzx);\n  return (max(max(a,b),c)-n.x) * radius;\n}\n\n// Icosahedron: radius = circumsphere radius\nfloat sdIcosahedron(vec3 p, float radius)\n{\n  const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n  const vec3 n1 = normalize(vec3(q,1,0));\n  const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n  p = abs(p / radius);\n  float a = dot(p, n1.xyz);\n  float b = dot(p, n1.zxy);\n  float c = dot(p, n1.yzx);\n  float d = dot(p, n2) - n1.x;\n  return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\n\nfloat sdIcosDodecaStar(vec3 p, float radius)\n{\n  return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));\n}\n\n// 4-sided Pyramid:  h = (cos a, sin a, height)\nfloat sdPyramid4(vec3 p, vec3 h )\n{\n  // Tetrahedron = Octahedron - Cube\n  float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n  float d = 0.0;\n  d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n  d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n  d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n  d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n  float octa = d - h.z;\n  return max(-box,octa); // subtraction\n}\n\n// https://www.shadertoy.com/view/lsBGzG\nfloat sdPyramid( vec3 p, float h) \n{\n  vec3 q=abs(p);\n  return max(-p.y, (q.x +q.y +q.z -h)/3.0 );\n}\n\n\n//=== Additional shapes ===\n\n//---------------------------------------------------------\nfloat sdWaveSphere(vec3 p, float radius, int waves, float waveSize) \n{\n  //bounding Sphere\n  float d = length(p) - radius*2.2;\n  if(d > 0.0) return 0.2;\n\n  // deformation of radius\n//d = waveSize * (radius - abs(p.y));\n  d = waveSize * (radius*radius-(p.y*p.y));\n  radius += d * cos(atan(p.x,p.z) * float(waves));\n  return 0.5*(length(p) - radius);\n}\n//---------------------------------------------------------\nfloat sdBlob (in vec3 pos, in float r)\n{\n  vec3 v1 = pos * 6.0;\n  return 0.05*(r + 0.5* (length(dot(v1, v1)) -0.51*(cos(4.*v1.x) +cos(4.*v1.y) +cos(4.*v1.z))));\n}\n   \n//---------------------------------------------------------\n// 3d cross: s=cross size\n//---------------------------------------------------------\nfloat sdCross( in vec3 p, in float s)\n{\n  float da = max (abs(p.x), abs(p.y));\n  float db = max (abs(p.y), abs(p.z));\n  float dc = max (abs(p.z), abs(p.x));\n  return min(da,min(db,dc)) - s;\n}\n//---------------------------------------------------------\n// 3d CrossInSphere: r=sphere radius, s=cross size\n//---------------------------------------------------------\nfloat CrossInSphere( in vec3 p, in float r, in float s )\n{\n  float d1 =  sdCross(p, s);  // cross\n  float d2 = length(p) - r;   // sphere\n  return max (d1,d2);         // intersection\n}\n//---------------------------------------------------------\n// sphere cutted out from a rounded box\n//---------------------------------------------------------\nfloat sdBoxMinusSphere( in vec3 pos, in float radius)\n{\n  return opDifference (udRoundBox(pos, vec3(0.15), 0.05)\n                      ,sdSphere(  pos, radius - 0.012 + 0.02*sinTime));\n}\n//---------------------------------------------------------\n// rack-wheel with holes\n//---------------------------------------------------------\nfloat sdRackWheel( in vec3 pos)\n{\n  return opDifference(sdTorus82(pos, vec2(0.20, 0.1)), \n    sdCylinder (opRepeat (vec3 (atan(pos.x, pos.z)/6.2831 + 0.1*aTime \n                               ,pos.y\n                               ,0.02+0.5*length(pos))\n                         ,vec3(0.05, 1.0, 0.05))\n               ,vec2(0.02, 0.6)));\n}\n//---------------------------------------------------------\nfloat sdBallyBall( in vec3 pos)\n{\n  return 0.7 * sdSphere(pos, 0.2 ) \n    + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y + 8.0*aTime)*sin(50.0*pos.z);\n}\n//---------------------------------------------------------\nfloat sdTwistedTorus( in vec3 pos, float angle)\n{\n  return 0.5*sdTorus( opTwist(pos,angle), vec2(0.20, 0.05));\n}\n//---------------------------------------------------------\n// render object positions\n\nconst vec3 p01 = vec3(-2.0, 0.25, -2.0);\nconst vec3 p02 = vec3(-1.0, 0.25, -2.0);\nconst vec3 p03 = vec3( 0.0, 0.25, -2.0);\nconst vec3 p04 = vec3( 1.0, 0.25, -2.0);\nconst vec3 p05 = vec3( 2.0, 0.20, -2.0);\n\nconst vec3 p11 = vec3(-2.0, 0.25, -1.0);\nconst vec3 p12 = vec3(-1.0, 0.50, -1.0);\nconst vec3 p13 = vec3( 0.0, 0.25, -1.0);\nconst vec3 p14 = vec3( 1.0, 0.25, -1.0);\nconst vec3 p15 = vec3( 2.0, 0.25, -1.0);\n\nconst vec3 p21 = vec3(-2.0, 0.20, 0.0);\nconst vec3 p22 = vec3(-1.0, 0.20, 0.0);\nconst vec3 p23 = vec3( 0.0, 0.25, 0.0);\nconst vec3 p24 = vec3( 1.0, 0.25, 0.0);\nconst vec3 p25 = vec3( 2.0, 0.25, 0.0);\n\nconst vec3 p31 = vec3(-2.0, 0.20, 1.0);\nconst vec3 p32 = vec3(-1.0, 0.25, 1.0);\nconst vec3 p33 = vec3( 0.0, 0.25, 1.0);\nconst vec3 p34 = vec3( 1.0, 0.25, 1.0);\nconst vec3 p35 = vec3( 2.0, 0.25, 1.0);\n\nconst vec3 p41 = vec3(-2.0, 0.25, 2.0);\nconst vec3 p42 = vec3(-1.0, 0.25, 2.0);\nconst vec3 p43 = vec3( 0.0, 0.25, 2.0);\nconst vec3 p44 = vec3( 1.0, 0.25, 2.0);\nconst vec3 p45 = vec3( 2.0, 0.30, 2.0);\n\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n  \n//vec2 res = vec2 (sdPlane1(pos), 1.0); \n  vec2 res = vec2 (sdPlane(pos, vec4(0,1,0,0)), 1.0); \n  \n  //---0---\n    \n  res = opU(res, vec2( sdWaveSphere ( pos-p01, 0.18 , 10, sinTime*0.4), 99));\n\n                                    r1 = rotateY (pos-p02, aTime*0.5);\n  res = opU(res, vec2( sdDodecahedron(r1, 0.2), 55));\n\n                                    r1 = rotateX (pos-p03, sinTime*0.8);\n  res = opU(res, vec2( sdIcosDodecaStar(r1, 0.18), 177));\n\n                                    r1 = rotateZ (pos-p04, sinTime*0.8);\n  res = opU(res, vec2( sdIcosahedron(r1, 0.16), 222));\n    \n                                    float h1 = 0.2 + 0.1 * abs(sinTime);\n//  res = opU(res, vec2( sdPyramid4  (pos-p05, vec3(0.8,0.6,h1) ), 8 ) );\n  res = opU(res, vec2( sdPyramid  (pos-p05, h1 ), 8));\n\n  //---1---\n                                    r1 = rotateY (pos-p11, aTime*0.5);\n  res = opU(res, vec2( sdTrianglePrism( r1, 0.1*sinTime + 0.25, 0.05 ), 44));\n    \n                                    r1 = rotateX (pos-p12, sinTime*0.8);\n  res = opU(res, vec2( sdCone      (r1, vec3(0.8, 0.5+0.2*sinTime, 0.3)), 222));\n    \n  res = opU(res, vec2( sdBlob      (pos-p13, -0.5 - 0.45*sinTime ), 244));\n    \n                                    h1 = 0.2 + 0.06 * sinTime;\n  res = opU(res, vec2( sdCylinder  (pos-p14, vec2(0.1, h1) ), 130));\n\n               vec3 a = vec3( 0.1, 0.0, 0.0);  float sr1 = 0.1+0.05*sinTime;\n               vec3 b = vec3(-0.1, 0.3, 0.1);  float sr2 = 0.05;\n  res = opU(res, vec2( sdRoundCone( pos-p15, a,b, sr1,sr2), 51.7));\n\n  //---2---\n    \n  res = opU(res, vec2( CrossInSphere ( pos-p21, 0.2+0.05*sinTime, 0.05), 51));\n   \n                                    r1 = p22 + rotateY (vec3(-0.22, 0, 0), aTime);\n                                    r2 = p22 - rotateY (vec3(-0.22, 0, 0), aTime);\n  res = opU(res, vec2( sdCapsule   (pos, r1, r2, 0.1), 32));\n\n                                    r1 = vec3( 0.0, 0.1 + 0.1 * sinTime, 0.0);\n  res = opU(res, vec2( sdSphere    (pos-p23-r1, 0.25-0.5*r1.y), 111));\n \n  res = opU(res, vec2( sdBox       (pos-p24, vec3(0.20)), 3));\n    \n  res = opU(res, vec2( sdEgg1      (pos-p24-r1, 0.21), 47));\n\n  res = opU(res, vec2( sdEgg2      (pos-p25, 0.18+h1), 47));\n\n  //---3---\n  res = opU(res, vec2( sdBoxMinusSphere (pos-p31, 0.25), 13));\n    \n                                    r1 = rotateX (pos-p32, aTime*0.5);\n  res = opU(res, vec2( sdHexagonalPrism ( r1, 0.25, 0.05 ), 17.0));\n    \n                                    r1 = rotateX (pos-p33, sinTime*1.2);\n                                    r1 = rotateZ (r1, aTime*2.0);\n  res = opU(res, vec2( sdTorus(     r1, vec2(0.20, 0.05) ), 25.0));\n    \n  res = opU(res, vec2( udRoundBox(  pos-p34, vec3(0.12), 0.05+0.05*+sinTime), 77));\n    \n  res = opU(res, vec2( sdBallyBall ( pos-p35), 65.0));\n\n  //---4---\n    \n  res = opU(res, vec2( sdTwistedTorus( pos-p41, 6.0*sinTime ), 46.7));\n\n                                    r1 = rotateY (pos-p42, aTime*0.25);\n  res = opU(res, vec2( sdTorus88(   r1, vec2(0.20, 0.05) ), 43.0));\n    \n  res = opU(res, vec2( sdTorus82(   pos-p43, vec2(0.20-0.05*sinTime, 0.05)), 77));\n    \n  res = opU(res, vec2( sdRackWheel( pos-p44 ), 51));\n\n                                    r1 = rotateY (pos-p45, aTime*0.25);\n  res = opU(res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, 0.25) ), 12));\n    \n  return res;   // return x=distance, y=color id\n}\n\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\n//---------------------------------------------------------\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad )\n{\n    vec3 m = 1.0001/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    return vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n}\n//---------------------------------------------------------\nconst float maxHei = 0.8;\nconst float minRay = 0.01;\nfloat minRefrac = 0.0;\n//---------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = minRay;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0001 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n\n    // raymarch primitives\n    vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = max(tmin,minRefrac);\n#if AA>1\n        for( int i=0; i<70 * AA && t<tmax; i++ )\n#else\n        for( int i=0; i<70 && t<tmax; i++ )\n#endif\n        {\n            vec2 h = map( ro+rd*t );\n\n            t = minRefrac > 0. ? abs(t) : t;\n            if( abs(h.x)<(0.0001*t) )\n            {\n                res = vec2(t,h.y);\n                break;\n            }\n            t +=  minRefrac > 0. ? -(h.x) : h.x;\n        }\n    }\n    return res;\n}\n\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//---------------------------------------------------------\n#define ZERO (min(iFrame,0))\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n    \n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n//---------------------------------------------------------\nvec3 calcNormal( in vec3 pos )   // get surface normal\n{\n    const vec2 e = vec2(0.0003,-0.0003);\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n//---------------------------------------------------------\n// https://en.wikipedia.org/wiki/Ambient_occlusion\n// https://de.wikipedia.org/wiki/Umgebungsverdeckung\n//---------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )  // get ambient occlusion\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<4; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n//---------------------------------------------------------\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\nfloat HexagonalGrid (in vec2 position\n                    ,in float gridSize\n                    ,in float gridThickness)\n{\n  vec2 pos = position / gridSize;\n  pos.x *= 0.57735 * 2.0;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*1.5 + pos.y, pos.y*2.0) - 1.0);\n  return smoothstep(0.0, gridThickness, d);\n}\n//---------------------------------------------------------\n#if MODE > 1\n  #define isReflection(m) (m < 15.)\n#elif MODE > 0\n  #define isReflection(m) (m < 2.)\n#else\n  #define isReflection(m) (m > 6999.)\n#endif\n//---------------------------------------------------------\nconst vec3 skyColor   = vec3(0.6, 0.8, 0.9);\nconst vec3 planeColor = vec3(0.8, 0.7, 0.6);\n    \nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n    float fDis = 100.;\n    for( int bounce = 0; bounce < 6; bounce++ ) // bounces of GI\n    {\n        vec2 res = castRay(ro,rd);\n        float t = res.x;\n        float m = res.y;\n\n        if(m < -0.5)\n        {\n           if(bounce == 0)\n              accumulatedColor = skyColor;\n\n           return vec3( clamp(accumulatedColor,0.0,1.0) );\n        }\n\n        if(bounce == 0) fDis = t;\n\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\n        bool reflection = isReflection(m);\n\n        //nor = reflection || minRefrac < minRay ? nor : -nor;\n\n        // material\n        if( m<1.5 )\n        {\n      //    float f = checkersGradBox( 5.0*pos.xz );\n            float f = HexagonalGrid (4.*pos.xz, 0.8, 0.2);\n            colorMask *= 0.2 + f*vec3(0.1);\n        }\n        else\n            colorMask *= 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n        vec3 ref = reflect( rd, nor );\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5*occ+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n            dif *\n            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.130*amb*skyColor;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n        nor = reflection || minRefrac < minRay ? nor : -nor;\n\n        if(reflection)\n        {\n            accumulatedColor += colorMask*(lin + 9.00*spe*vec3(1.00,0.90,0.70));\n\n            colorMask *= clamp(1.0+0.77*dot(nor,rd),0.0,1.0);\n            rd = ref;\n            ro = pos;\n            minRefrac = 0.;\n\n            accumulatedColor = mix( accumulatedColor, skyColor, 1.0-exp( -0.0004*fDis*fDis*fDis ) );\n        }\n        else\n        {\n            accumulatedColor += colorMask*fre*(lin + 9.00*spe*vec3(1.00,0.90,0.70));\n\n            rd = refract(rd, nor, 1.0/ REFRACTIDX);\n            ro = pos;\n\n            minRefrac = minRefrac < minRay ? minRay : 0.;\n\n        }\n    }\n    minRefrac = 0.;\n    return vec3( clamp(accumulatedColor,0.0,1.0) );\n}\n//---------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 + iTime;\n    float rtime = ROTATE_SCENE ? 0.1*time : 0.0;\n    aTime = ANIMATE_OBJECTS ? iTime : 0.0;\n    sinTime = sin(aTime);\n    \n    // camera\n    float mx = 2.0 * PI * mo.x;           // mouse.x set horizontal rotation\n    vec3 ta = vec3( 0.0, -0.1, 0.0 );     // target position\n    vec3 ro = vec3( 4.0*cos(rtime + mx)\n                  , 0.2 + 3.3*mo.y        // mouse.y set vertical view angle\n                  , 4.2*sin(rtime + mx) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": "XtX3D4", "previewfilepath": "https://soundcloud.com/grizzogor/alkis-livathinos-dearest-hue", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/grizzogor/alkis-livathinos-dearest-hue", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlXRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1671, 1731, 1762, 1762, 1860], [1861, 1861, 1892, 1892, 1993], [1994, 1994, 2025, 2025, 2125], [2127, 2381, 2425, 2425, 2463], [2465, 2465, 2510, 2510, 2573], [2575, 2575, 2620, 2620, 2693], [3048, 3066, 3102, 3102, 3138], [3140, 3176, 3217, 3217, 3306], [3577, 3762, 3798, 3798, 3929], [3931, 4084, 4109, 4109, 4125], [4127, 4127, 4184, 4184, 4215], [4217, 4217, 4257, 4257, 4288], [4290, 4290, 4349, 4349, 4503], [4505, 4505, 4544, 4544, 4632], [4634, 4682, 4713, 4713, 4799], [4801, 4823, 4854, 4854, 4945], [4947, 4971, 5002, 5002, 5040], [5042, 5090, 5135, 5135, 5176], [5178, 5228, 5261, 5261, 5315], [5317, 5317, 5352, 5352, 5422], [5424, 5424, 5459, 5459, 5527], [5529, 5580, 5632, 5632, 5749], [5751, 5751, 5815, 5815, 6093], [6095, 6095, 6119, 6119, 6136], [6137, 6137, 6200, 6264, 6851], [6853, 6899, 6960, 6960, 7242], [7244, 7291, 7352, 7352, 7627], [7629, 7665, 7706, 7706, 7809], [7811, 7848, 7889, 7889, 7927], [7929, 7982, 8024, 8024, 8079], [8081, 8102, 8139, 8139, 8391], [8393, 8439, 8483, 8483, 8745], [8747, 8792, 8835, 8835, 9193], [9196, 9196, 9242, 9242, 9314], [9316, 9364, 9399, 9436, 9791], [9793, 9834, 9870, 9870, 9934], [9966, 10026, 10096, 10116, 10376], [10377, 10437, 10477, 10477, 10599], [10604, 10750, 10789, 10789, 10941], [10942, 11113, 11171, 11171, 11298], [11299, 11459, 11514, 11514, 11645], [11646, 11791, 11824, 11824, 12129], [12130, 12190, 12223, 12223, 12333], [12334, 12394, 12443, 12443, 12506], [12507, 13610, 13635, 13635, 17019], [17021, 17209, 17259, 17259, 17473], [17610, 17670, 17710, 17710, 18637], [18639, 18851, 18929, 18952, 19291], [19292, 19476, 19532, 19532, 19735], [19736, 19960, 20028, 20028, 20297], [20298, 20494, 20530, 20551, 20774], [20776, 20939, 21062, 21062, 21298], [21509, 21664, 21703, 21703, 24440], [24441, 24501, 24553, 24553, 24733], [24734, 24794, 24851, 24851, 26074]]}
{"id": "wdlXW8", "name": "blakes palm", "author": "derive_by", "description": "as seen", "tags": ["trippy", "art"], "likes": 1, "viewed": 288, "published": "Public API", "date": "1551205666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y*uv.x-uv.y*spin,uv.x*spin*uv.y+uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle*angle/2.0);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nvec4 dcAdd( vec4 a, vec4 b )\n{\n    return a + b;\n}\n\nvec4 dcMul( vec4 a, vec4 b )\n{\n    return vec4( a.x*b.x - a.y*b.y, \n\t\t\t\t a.x*b.y + a.y*b.x,\n\t\t\t\t a.x*b.z + a.z*b.x - a.y*b.w - a.w*b.y,\n\t\t\t\t a.x*b.w + a.w*b.x + a.z*b.y + a.y*b.z );\n}\n\nvec4 dcSqr( vec4 a )\n{\n    return vec4( a.x*a.x - a.y*a.y, \n\t\t\t\t 2.0*a.x*a.y,\n\t\t\t\t 2.0*(a.x*a.z - a.y*a.w),\n\t\t\t\t 2.0*(a.x*a.w + a.y*a.z) );\n}\n\n//--------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float pi = 3.14159265359;\n    float myTime = iTime*(1.0/3.0);\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    p = kale(p, pi/3.0, myTime*0.1*pi, myTime);\n    // animation\t\n\t//float tz = 0.5 + cos(0.0111225*myTime);\n    //float zo = pow( 0.5, 1.0*tz );\n    float tz = 0.5 - 0.5*cos(0.225*myTime);\n    float zo = pow( 0.5, 13.0*tz );\n\t\n    vec4 c = vec4( vec2(-0.05,.6805) + p*zo, 1.0, 0.0 );\n\n\tfloat m2 = 1.0;\n    float co = 0.0;\n\t\n\tvec4 z = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n\t\t\t\n        // Z -> ZÂ² + c\t\t\n\t\tz = dcAdd( dcSqr(z), c );\n\t\t\n\t\tm2 = dot( z.xy, z.xy );\n        co += 1.0;\n    }\n\n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat d = 0.0;\n\tif( co<256.0 ) d = sqrt( dot(z.xy,z.xy)/dot(z.zw,z.zw) )*log(dot(z.xy,z.xy));\n\n\t\n    // do some soft coloring based on distance\n\td =  4.0*d/zo, 0.0, 1.0 ;\n\td = pow( d, 0.825 );\n    vec3 col = vec3( d );\n    \n    \n    vec2 q = p;\n\n    // Time varying pixel color\n    vec3 bol = 0.8 + 0.2*sin(myTime+p.xxx+vec3(0,2,6)) - 0.2*cos(myTime+p.yyy+vec3(6,1,3));\n    \n    float r = 0.5 + 0.4 * cos(atan(q.y,q.x)*16.0*sin(myTime+q.x-q.y) - 32.0*q.x*q.y*(cos(myTime+q.x-q.y)));\n    bol *= smoothstep(d, r-0.1-zo/2.0, length(atan(q.x,q.y)-d+1.0));\n    \n    fragColor = vec4(bol, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 258], [260, 260, 290, 290, 310], [312, 312, 342, 342, 495], [497, 497, 519, 519, 638], [640, 694, 751, 751, 2111]]}
{"id": "WdlXzr", "name": "Orbitando", "author": "AdrianPi", "description": "Old-school raytracing", "tags": ["3d", "raytracing", "polkadots"], "likes": 6, "viewed": 101, "published": "Public", "date": "1550498955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\nconst int POLKA_MATERIAL = 3;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\n\nvec3 viewFrom = vec3(0,-1,1);\nvec3 viewAt = vec3(0,0,-1);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 2;\n\nvec4 skyColor = vec4(1,0.5,0,1);\nvec4 horizonColor = vec4(1,0.75,0.25,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,0,0,1), \n                                   vec4(1,0,0,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   POLKA_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.24));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,1,1), \n                                   vec4(0,0,1,1), \n                                   vec4(1,1,1,60), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(.8,.4,0,1), \n                                   vec4(.8,.4,0,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, material3, material4, material5, material6);\n\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(0, 0, -1), vec3(2, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere2 = primitive_t(SPHERE_PRIMITIVE, 4, vec3(4, 2, -1.5), vec3(1.5, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere3 = primitive_t(SPHERE_PRIMITIVE, 5, vec3(-4, -3, -2), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere4 = primitive_t(SPHERE_PRIMITIVE, 6, vec3(-2, 4, -1.8), vec3(1.2, 0, 0), vec3(0,0,0));\n\nconst int NUM_PRIMS = 5;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _sphere2, _sphere3, _sphere4);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 30.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.1, 1);\nvec3 lightDirection = normalize(vec3(1,1,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 6)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON;\n    sray.dir = -lightDirection;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade_polka(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int iy = int(floor(p.y)) & 0x01;\n    if((iy & 0x01) == 1)\n        p.x += 0.5;\n\n    vec3 p2 = mod(p, vec3(1.));\n    p2 *= 2.;\n    p2 -= 1.;\n        \n    float d = dot(p2,p2);\n\n    hit.mat = (d < (.666*.666)) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }\n        else if(type == POLKA_MATERIAL)\n        {\n            color = shade_polka(ray, hit);\n        }\n        \n        // fog\n\n        float f = (hit.t - 10.0) / (50.0-10.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    viewFrom = vec3(sin(iTime*.5)*14.0, -cos(iTime*.5)*14.0, 2. + sin(iTime*1.5)*3.);\n    \n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n    \n    for(int i = 0; i < oversample; i++)\n    {\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlXzr.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 4800, 4839, 4839, 5004], [5006, 5006, 5034, 5034, 5148], [5150, 5150, 5231, 5231, 6050], [6052, 6052, 6127, 6127, 6485], [6487, 6487, 6581, 6581, 7124], [7273, 7273, 7301, 7301, 7426], [7428, 7428, 7462, 7462, 7617], [7619, 7619, 7641, 7641, 7670], [7718, 7718, 7761, 7761, 9317], [9319, 9319, 9361, 9361, 9705], [9707, 9707, 9747, 9747, 10154], [10156, 10156, 10190, 10190, 10856], [10858, 10858, 10902, 10902, 11626], [11628, 11628, 11654, 11654, 11734], [11736, 11736, 11793, 11793, 12748]]}
{"id": "WdS3Dt", "name": "Test of sprites", "author": "42n4", "description": "Mix of these\nhttps://www.shadertoy.com/view/XdByzy\nhttps://www.shadertoy.com/view/ldX3zr", "tags": ["sprite"], "likes": 2, "viewed": 61, "published": "Public", "date": "1550223074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nfloat head(vec2 pos, vec2 uv)//rysowanie glowy\n{\n    vec2 v = pos-uv;\n    float d = dot(v, v) *10.-1.;\n    return smoothstep(0., 0.03, d*d);\n}\n\nfloat body(vec2 pos, vec2 uv)//rysowanie linji ciala\n{\n    vec2 v = pos - uv;\n    float dx = v.x*v.x;\n    float d = dot(v, v);\n    return clamp(smoothstep(0., .1, dx*100.)+smoothstep(.5, .6, d), 0., 1.);\n}\n\nvec2 rotation(vec2 p, float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle))*p;\n}\n\nfloat leg(vec2 pos, vec2 uv, float angle)//rysowanie linij nog\n{\n    vec2 v = rotation(pos - uv, angle) - vec2(0., .5);\n    float dx = v.x*v.x;\n    float d = dot(v, v);\n    return clamp(smoothstep(0., .10, dx*100.)+smoothstep(.2, .3, d), 0.5,\n1.);\n}\n\nfloat arm(vec2 pos, vec2 uv, float angle1, float angle2)//rysowanie linij rak\n{\n    vec2 v = rotation(pos - uv, angle1) - vec2(0., .35);\n    float dx = v.x*v.x;\n    float d = dot(v, v);\n    vec2 v2 = rotation(v - vec2(0., .35), angle2) - vec2(0., .35);\n    float dx2 = v2.x*v2.x;\n    float d2 = dot(v2, v2);\n    return clamp(smoothstep(0., .1, dx*100.)+smoothstep(.1, .15, d), 0., 1.)*\n        clamp(smoothstep(0., .1, dx2*100.)+smoothstep(.1, .15, d2), 0., 1.);\n}\n\nfloat stickman(vec2 pos, vec2 uv, float bass, float angle1, float\nangle2)//zebranie linij w czlowieka\n{\n    vec2 v = uv-pos;\n    float d = head(vec2(0., .8), v*1.5);\n    d *= body(vec2(0., -.1), v*2.);\n    d *= leg(vec2(0., -.8), v*2., angle1);\n    d *= leg(vec2(0., -.8), v*2., -angle1);\n    d *= arm(vec2(0., .65), v*2., angle2+bass, iTime+bass*2.);\n    d *= arm(vec2(0., .65), v*2., -(angle2+bass), -iTime+bass*2.);\n        return d;\n}\nvec2 center = vec2(2.0,5.0);\nfloat speed = 0.5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 uv =\n(-1.+2.*fragCoord.xy/iResolution.xy)*vec2(iResolution.x/iResolution.y,\n1.8);\n\n    float bass = 0.;//obrot rak w rozne strony\n\n    for(float f = 0.; f <= .25; f += 1./100.)\n    {\n        bass += texture(iChannel0, vec2(f, .25)).x;\n    }\n\n    bass = -1.+2.*bass;\n\n   float invAr = iResolution.y / iResolution.x;\n\n\n\nvec3 col = vec4(uv,0.5-0.5*sin(iTime),1.0).xyz;\n\nvec3 texcol;\n\nfloat x = (center.x/uv.x);//od prawej strony szerokie linii do lewej wezsze i rowniejsze\nfloat y = (center.y+uv.y) *invAr;//wskazuje kierunek linij\nfloat r = -(x/x * y/y);//dodaje czarne linii\nfloat z = 0.5 + 1.5*sin((x+iTime*speed)/0.05);//dodaje szerokosc linij\n\n\ntexcol.y = z;//dodaje zolto-zielony kolor\ntexcol.z = z;//roznokolorowe\n\n    vec3 co = vec3(3.);\n\n    col *= stickman(vec2(-1.3, 0.), uv, bass, PI/8., PI/4.);//pozycja czlowieka na ekranie\n    col *= stickman(vec2(1.3, 0.), uv, bass, PI/8., PI/2.);\n\n    col *= vec3(sin(uv.x), cos(uv.x), sin(uv.x/uv.y));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdS3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 69, 69, 163], [165, 165, 219, 219, 370], [372, 372, 408, 408, 478], [480, 480, 544, 544, 729], [731, 731, 810, 810, 1195], [1197, 1197, 1300, 1300, 1635], [1686, 1686, 1743, 1743, 2742]]}
{"id": "wdS3RK", "name": "signed distance bun", "author": "daisyowl", "description": "its a bunny", "tags": ["sdf", "bunny"], "likes": 12, "viewed": 361, "published": "Public", "date": "1549322465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdf(vec3);\nvec3 normal(vec3);\nfloat sphere(vec3, float);\nfloat union_smooth(float, float, float);\nfloat sub_smooth(float, float, float);\nfloat ao(vec3, vec3, float);\nfloat ss(vec3, vec3);\nfloat mirrorX(vec3);\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nmat3 eulerToMat(vec3 e){\n  float sx = sin(e.x);\n  float sy = sin(e.y);\n  float sz = sin(e.z);\n  float cx = cos(e.x);\n  float cy = cos(e.y);\n  float cz = cos(e.z);\n  return mat3(\n    cy*cz, cz*sx*sy-cx*sz, cx*cz*sy+sx*sz,\n    cy*sz, cx*cz+sx*sy*sz, cx*sy*sz-cz*sx,\n    -sy, cy*sx, cx*cy);\n}\n\nconst float EPS = 0.0001;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEPS = 128;\nconst float MIN_STEP_SIZE = 0.005;\n\nconst int AO_STEPS = 5;\nconst float AO_DIST_PER_STEP = 0.5;\nconst float D2R = 3.141528 / 180.0;\nconst vec3 bg = vec3(0.7, 0.7, 1.2) * 0.5;\n\nvec3 lightPos = normalize(vec3(1, 1, 1));\n\nstruct Shape {\n  bool additive;\n  float r;\n  float blend;\n  vec3 pos;\n  vec3 scale;\n  vec3 rot;\n};\n\n\nShape shapes[16] = Shape[16](\n  Shape(true, 1.0, 1.0, vec3(0.0, 0.5, 0.0), vec3(1,1,1), vec3(0,0,0)*D2R), // head\n  Shape(true, 0.4, 0.3, vec3(0, 0.2, 0.6), vec3(1,1,1), vec3(0,0,0)*D2R), // snoot\n  Shape(true, 0.4, 0.3, vec3(-0.5, 1.5, -0.5), vec3(1,3,1), vec3(-20,25,0)*D2R), // ear\n  Shape(true, 0.4, 0.3, vec3(+0.5, 1.5, -0.5), vec3(1,3,1), vec3(-20,-25,0)*D2R), // ear\n  Shape(false, 0.2, 0.2, vec3(-0.7, 2.1, -0.3), vec3(1,3,1), vec3(-20,25,0)*D2R), // ear-cut\n  Shape(false, 0.2, 0.2, vec3(+0.7, 2.1, -0.3), vec3(1,3,1), vec3(-20,-25,0)*D2R), // ear-cut\n  Shape(false, 0.35, 0.3, vec3(+0.5, 0.7, 0.8), vec3(1,1,1), vec3(0,0,0)*D2R), // eye-socket\n  Shape(false, 0.35, 0.3, vec3(-0.5, 0.7, 0.8), vec3(1,1,1), vec3(0,0,0)*D2R), // eye-socket\n  Shape(true, 0.5, 0.0, vec3(+0.2, 0.6, 0.35), vec3(1,1,1), vec3(0,0,0)*D2R), // eye\n  Shape(true, 0.5, 0.0, vec3(-0.2, 0.6, 0.35), vec3(1,1,1), vec3(0,0,0)*D2R), // eye\n  Shape(true, 0.5, 0.1, vec3(0.0, -0.8, 0.0), vec3(1,1,1), vec3(0,0,0)*D2R), // chest\n  Shape(true, 0.7, 0.5, vec3(0.0, -1.5, 0.0), vec3(1,1,1), vec3(0,0,0)*D2R), // tummy\n  Shape(true, 0.2, 0.1, vec3(-0.7, -0.8, 0), vec3(1,2,1), vec3(0,0,-45)*D2R), // arm\n  Shape(true, 0.2, 0.1, vec3(0.7, -0.8, 0), vec3(1,2,1), vec3(0,0,45)*D2R), // arm\n  Shape(true, 0.2, 0.1, vec3(-0.3, -2, 0), vec3(1,2,1), vec3(0,0,-15)*D2R), // leg\n  Shape(true, 0.2, 0.1, vec3(0.3, -2, 0), vec3(1,2,1), vec3(0,0,15)*D2R) // leg\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  vec2 mouse = iMouse.xy/iResolution.xy;\n\n  float camDist = 6.0;\n  float spinRate = 0.5;\n  vec3 p = vec3(sin(iTime * spinRate + mouse.x * 6.0) * camDist, (mouse.y - 0.5) * -6.0, cos(iTime * spinRate + mouse.x * 6.0) * camDist);\n  vec3 camDir = normalize(-p);\n\n  mat3 cMatrix = setCamera(p, camDir, 0.0);\n  float aspect = iResolution.x / iResolution.y;\n  vec3 dir = cMatrix * normalize(vec3((uv.x - 0.5) * aspect, uv.y - 0.5, 1));\n\n  //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n  bool hit = false;\n\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sdf(p);\n\n    if (dist < EPS) {\n      hit = true;\n      break;\n    }\n\n    if (length(p) > MAX_DIST) {\n      break;\n    }\n\n    p += dir * max(MIN_STEP_SIZE, dist);\n  }\n\n\n  vec3 outColor = bg.rgb;\n\n\n  if (hit)  {\n    vec3 normal = normal(p);\n    float lamp = max(0.0, dot(normal, cMatrix * lightPos)) * 1.0;\n    vec3 light = vec3(lamp * 1.5, lamp * 1.3, lamp);\n    light += bg.xyz;\n\n    float fBias = 0.0;\n    float fScale = 0.5;\n    float fPower = 2.0;\n    float fresnel = max(0.0, min(1.0, fBias + fScale * pow((1.0 + dot(dir, normal)), fPower)));\n    light += fresnel * bg;\n    \n    float _ao = ao(p, normal, 0.6);\n    light *= _ao;\n\n    float _ss = ss(p, -dir);\n    light += _ss * vec3(1,0,0.2) * 1.0;\n\n    vec3 baseColor = vec3(0.8,0.8,0.8);\n\n    //float gray = log(1.0 + light);\n    outColor = light * baseColor;\n    //fragColor = vec4(ao,ao,ao, 1.0);\n  }\n  \n  fragColor = vec4(log2(1.0 + outColor.r), log2(1.0 + outColor.g), log2(1.0 + outColor.b), 1.0);\n\n  // for debugging values\n  // fragColor = vec4(dir, 1.0);\n}\n\nfloat sdf(vec3 p) {\n  float dist = 1000000.0;\n  for(int i = 0; i < shapes.length(); i++) {\n    Shape s = shapes[i];\n    mat3 mat = eulerToMat(s.rot);\n    dist = s.additive\n      ? union_smooth(dist, sphere(mat * (p - s.pos) / s.scale, s.r), s.blend)\n      : sub_smooth(sphere(mat * (p - s.pos) / s.scale, s.r), dist, s.blend);\n  }\n  return dist;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 normal(vec3 p) {\n  return normalize(vec3(\n    sdf(p + vec3(EPS, 0.0, 0.0)) - sdf(p + vec3(-EPS, 0.0, 0.0)),\n    sdf(p + vec3(0.0, EPS, 0.0)) - sdf(p + vec3(0.0, -EPS, 0.0)),\n    sdf(p + vec3(0.0, 0.0, EPS)) - sdf(p + vec3(0.0, 0.0, -EPS))\n  ));\n}\n\nfloat union_smooth(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sub_smooth(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat ao(vec3 p, vec3 normal, float k) {\n  float actualSum = 0.0;\n  for(int i = 1; i <= AO_STEPS; i++) {\n    float exp = (1.0 / pow(2.0, float(i)));\n    vec3 sampleP = p + normal * float(i) * AO_DIST_PER_STEP;\n    actualSum += exp * (float(i) * AO_DIST_PER_STEP - sdf(sampleP));\n  }\n  return 1.0 - k * actualSum;\n}\n\nconst int SS_STEPS = 3;\nconst float SS_DIST_PER_STEP = 0.5;\nfloat ss(vec3 p, vec3 normal) {\n  float actualSum = 0.0;\n  for(int i = 1; i <= SS_STEPS; i++) {\n    float exp = (1.0 / pow(2.0, float(i)));\n    vec3 sampleP = p + -normal * float(i) * SS_DIST_PER_STEP;\n    actualSum += exp * max(0.0, sdf(sampleP));\n    // actualSum += exp * (float(i) * AO_DIST_PER_STEP - sdf(sampleP));\n  }\n  return actualSum;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdS3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 266, 266, 441], [443, 443, 467, 467, 732], [2561, 2561, 2616, 2616, 4242], [4244, 4244, 4263, 4263, 4591], [4593, 4593, 4624, 4624, 4650], [4652, 4652, 4673, 4673, 4903], [4905, 4905, 4954, 4954, 5057], [5059, 5059, 5106, 5106, 5210], [5212, 5212, 5252, 5252, 5526], [5588, 5588, 5619, 5619, 5934]]}
{"id": "WdS3Wy", "name": "I can't sleep", "author": "fabiojcortes", "description": "I can't sleep, too many voices trying to talk to me.", "tags": ["math", "gradient", "weird", "dark"], "likes": 2, "viewed": 88, "published": "Public", "date": "1549837679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4));\n    col += sin(p.x * cos(iTime / 10.0) * 50.0) + sin(p.y * cos(iTime / 15.0) *10.0);\n  \tcol += cos(p.x * sin(iTime / 10.0) * 50.0) + cos(p.y * sin(iTime / 15.0) *10.0);\n\n  \tcol *= vec3(0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdS3Wy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 483]]}
{"id": "WdS3zK", "name": "Worley Sky", "author": "denosya", "description": "First attempt to 2D clouds using Worley noise.", "tags": ["worley"], "likes": 5, "viewed": 241, "published": "Public", "date": "1549359908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 SKYCOLOR = vec3(59.0/255.0, 121.0/255.0, 254.0/255.0) * 0.75;\nconst vec3 CLOUDCOLOR = vec3(1.0,1.0,1.0);\nconst vec3 HASHSCALE3 = vec3(.1031, .1030, .0973);\nconst float SIMULATION_SPEED = 8.0;\n\n\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 randomVec2(in float i, in float j) {\n    return vec2(i, j) + hash22(vec2(i, j));   \n}\n\nfloat worley(in vec2 uv, float scale)\n{\n    vec2 ij = floor(uv / scale);\n    \n    float minDist = 2.0;\n    \n    for(float x=-1.0;x<=1.0;x+=1.0) {\n        for(float y=-1.0;y<=1.0;y+=1.0) {\n        \tfloat d = length(randomVec2(ij.x+x, ij.y+y)*scale - uv);\n            minDist = min(minDist, d);\n        }\n\t}\n\n    return 1.0 - minDist / scale;\n}\n\nfloat anim(float a, float p) {\n\treturn (cos(iTime*6.283/p) * 0.5 + 0.5) * a;\n}\n\nfloat cloud(in vec2 uv) {\n\n    float t = iTime * SIMULATION_SPEED;\n\tvec2 uv1 = uv + t*0.01;\n\tvec2 uv2 = uv + vec2(t*0.01, t*0.0025);    \n    \n    float col[] = float[] ( worley(uv1, 0.1) * 0.00 + anim(0.05, 10.0),\n    \t\t\t\t\t\tworley(uv1, 0.2) * 0.15,\n\t\t\t\t\t\t\tworley(uv1, 0.4) * 0.2 + anim(0.25, 10.0),\n\t\t\t\t\t\t\tworley(uv1, 1.0) * 0.7,            \n\t\t\t\t\t\t\tworley(uv2, 0.1) * 0.05,\n\t\t\t\t\t\t\tworley(uv2, 0.2) * 0.15,    \n\t\t\t\t\t\t\tworley(uv2, 0.4) * 0.2 - anim(0.5, 25.0),        \n\t\t\t\t\t\t\tworley(uv2, 1.0) * 0.7);            \n\n    float layer1 = 0.0;\n    float layer2 = 0.0;    \n    \n    for(int l=0; l<4; l++) {\n    \tlayer1 += col[l];\n    }\n\n    for(int l=4; l<8; l++) {\n    \tlayer2 += col[l];\n    }\n    \n    float test1 = col[1]*5.0;\n    float test2 = col[2]*3.;    \n    \n//    return test1;\n//    return test2;    \n//    return (test1 + test2)*0.5;    \n    \n    \n    \n    return pow(mix(layer1, layer2, 0.5), 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    float cloudval = pow(cloud(uv), 1.0);\n    \n    //pseudo lighting attempt\n    vec3 light = normalize(vec3(1,-1,1)); //light = vec3(0,0,1);\n    \n    vec3 slope = vec3(1, -1, 0) * 0.12;\n    \n    float px1 = cloud(uv + slope.yz);\n    float px2 = cloud(uv + slope.xz);\n    float py1 = cloud(uv + slope.zy);\n    float py2 = cloud(uv + slope.zx);\n    \n    vec3 pseudo_normal = normalize(vec3(px2 - px1, py2 - py1, -0.1));\n    \n    float lighting = dot(pseudo_normal, -light); //  lighting=1.;\n    \n    vec3 color = mix(SKYCOLOR, CLOUDCOLOR * lighting, cloudval);\n    \n    fragColor = vec4(color, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdS3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 245, 266, 266, 385], [387, 387, 428, 428, 477], [479, 479, 518, 518, 821], [823, 823, 853, 853, 901], [903, 903, 928, 928, 1806], [1809, 1809, 1866, 1866, 2552]]}
{"id": "wdS3zV", "name": "Wrapped Bottle", "author": "dr2", "description": "Full bottle wrapped in a protective mesh", "tags": ["reflect", "refract", "weave"], "likes": 12, "viewed": 372, "published": "Public API", "date": "1549356364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Wrapped Bottle\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCaps4Df (vec3 p, float r, float h);\nfloat PrCapsAn4Df (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Length4c (vec3 p);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir;\nfloat tCur, dstFar, rMesh, rBot;\nint idObj;\nbool inBot, chkBot;\n\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, wt, w, h, s;\n  dMin = dstFar;\n  w = rMesh - rBot;\n  wt = 0.1;\n  r = rBot - 2. * w;\n  if (chkBot) {\n    dMin = SmoothMin ((inBot ? PrCapsAn4Df (p.xzy, r + w, w, r + w) : PrCaps4Df (p.xzy, r, r)),\n       (inBot ? PrCylAnDf (vec3 (p.xz, p.y - 2.2 * r), 0.2 * r + w, w, 0.3 * r + w) :\n       PrCylDf (vec3 (p.xz, p.y - 2.2 * r), 0.2 * r, 0.3 * r)), 3. * w);\n  } else if (inBot) {\n    d = PrCylDf (vec3 (p.xz, p.y - 2.4 * r), 0.2 * r - 4. * w, 0.2 * r);\n    DMIN (1);\n    d = PrSphDf (vec3 (p.xz, abs (p.y) - 1.5).xzy, 1.);\n    DMIN (2);\n  } else {\n    d = PrCylDf (vec3 (p.xz, p.y - 2.6 * r), 0.2 * r + 4. * w, 0.1 * r);\n    DMIN (3);\n    d = PrCylDf (vec3 (p.xz, p.y + 2.01 * r), 3. * r, 0.03 * r);\n    DMIN (4);\n    h = 1.4 * r;\n    q = p;\n    q.xz = vec2 (rMesh * atan (q.z, - q.x), length (q.xz) - rMesh);\n    d = PrRoundBox2Df (vec2 (abs (q.y) - h, q.z), vec2 (w, 0.7 * w), 0.5 * w);\n    DMIN (5);\n    q.xy = mod (q.xy + 0.5, 1.) - 0.5;\n    s = 0.6 * wt * cos (2. * pi * q.x);\n    d = 0.5 * max (min (PrRoundBox2Df (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt (2.),\n       q.z + s), vec2 (wt, 0.2 * wt), 0.2 * wt),\n       PrRoundBox2Df (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt (2.), q.z - s),\n       vec2 (wt, 0.2 * wt), 0.1 * wt)), abs (p.y) - h);\n    DMIN (5);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 c;\n  if (idObj == 1) c = vec4 (0.4, 0.3, 0.1, 0.);\n  else if (idObj == 2) c = vec4 (0.7, 0.7, 0.8, 0.2);\n  else if (idObj == 3) c = (abs (p.x) > 0.4) ? vec4 (0.2, 0.6, 0.2, 0.2) * (1. - \n     0.3 * sin (32. * atan (p.z, - p.x) / 2. * pi) * step (1.3, length (p.xz))) :\n     vec4 (0.8, 0.8, 0.8, 0.);\n  else if (idObj == 4) c = mix (vec4 (0.4, 0.5, 0.7, 0.1), vec4 (0.85, 0.95, 0.9, 0.2), \n     smoothstep (0.02, 0.03, abs (Fbm2 (vec2 (0.5, 0.2) * p.xz) - 0.4))) * \n     (0.9 + 0.1 * Fbm2 (4. * p.xz)) *\n     (1. - 0.3 * smoothstep (0., 1.5, rBot - length (p.xz)) * step (-2. * rBot, p.y));\n  else if (idObj == 5) c = vec4 (0.9, 0.9, 0., 0.1);\n  return c;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 c, u, uu;\n  vec2 f;\n  float t;\n  col4 = vec4 (0.);\n  uu = normalize (ro + 200. * rd);\n  for (int ky = -1; ky <= 1; ky ++) {\n    for (int kx = -1; kx <= 1; kx ++) {\n      u = uu;\n      f = vec2 (kx, ky);\n      u.yz = Rot2D (u.yz, 0.0025 * f.y);\n      u.xz = Rot2D (u.xz, 0.0025 * f.x);\n      t = max (SmoothBump (0.45, 0.55, 0.02, mod (64. * atan (u.z, - u.x) / pi, 1.)),\n         SmoothBump (0.45, 0.55, 0.02, mod (64. * asin (u.y) / pi, 1.)));\n      c = mix (vec3 (0.2, 0.3, 0.6), vec3 (0.8, 0.8, 0.5), t) * (0.7 + 0.3 * u.y);\n      t = (u.y > 2. * max (abs (u.x), abs (u.z * 0.25))) ? 0.5 * min (2. * u.y, 1.) :\n         0.05 * (1. + dot (u, sunDir));\n      if (u.y > 0.) t += pow (clamp (1.05 - 0.5 *\n         length (max (abs (u.xz / u.y) - 0.4 * vec2 (1., 4.), 0.)), 0., 1.), 8.);\n      c += vec3 (0.5, 0.5, 1.) * t + vec3 (1., 0.9, 0.6) *\n         dot (pow (abs (u.xz), vec2 (512.)), vec2 (1.));\n      col4 += vec4 (min (c, 1.), 1.) * (1. - 0.15 * dot (f, f));\n    }\n  }\n  return col4.rgb / col4.w;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, rdd, vn, vnW, colD, colR, col, flCol;\n  float dstObj, dstBot, dstBotW, rdDotN, eta;\n  bool bWallHit;\n  rMesh = 20. / pi;\n  rBot = rMesh - 0.05;\n  eta = 1.33;\n  inBot = false;\n  chkBot = true;\n  dstBot = ObjRay (ro, rd);\n  chkBot = false;\n  dstObj = ObjRay (ro, rd);\n  roo = ro;\n  rdo = rd;\n  dstBotW = dstBot;\n  flCol = vec3 (1.);\n  rdDotN = 0.;\n  bWallHit = (dstBot < min (dstObj, dstFar));\n  if (bWallHit) {\n    ro += dstBot * rd;\n    chkBot = true;\n    vn = ObjNf (ro);\n    vnW = vn;\n    rdDotN = - dot (rd, vn);\n    rd = refract (rd, vn, 1. / eta);\n    ro += 0.1 * rd;\n    inBot = true;\n    dstBot = ObjRay (ro, rd);\n    chkBot = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstBot < min (dstObj, dstFar)) {\n      ro += dstBot * rd;\n      chkBot = true;\n      vn = ObjNf (ro);\n      rdd = refract (rd, vn, eta);\n      if (length (rdd) > 0.) {\n        rd = rdd;\n        inBot = false;\n      } else {\n        rd = reflect (rd, vn);\n      }\n      ro += 0.01 * rd;\n      chkBot = false;\n      dstObj = ObjRay (ro, rd);\n    }\n    flCol *= 1.8 * vec3 (0.5, 0.2, 0.25);\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    chkBot = false;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    colD = col4.rgb * (0.2 + 0.8 * max (dot (sunDir, vn), 0.) +\n       col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n  } else colD = BgCol (ro, rd);\n  colR = vec3 (0.);\n  if (bWallHit) {\n    ro = roo + dstBotW * rdo;\n    rd = reflect (rdo, vnW);\n    ro += 0.01 * rd;\n    inBot = false;\n    chkBot = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += rd * dstObj;\n      vn = ObjNf (ro);\n      col4 = ObjCol (ro);\n      colR = col4.rgb * (0.2 + 0.8 * max (dot (sunDir, vn), 0.) +\n         col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n    } else colR = BgCol (ro, rd);\n  }\n  col = flCol * colD;\n  if (eta != 1. && bWallHit) col = mix (colR, col, 0.1 + 0.9 * smoothstep (0.4, 0.8, rdDotN));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 2. * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.04 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2., -60.);\n  zmFac = 3.3;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (1.)), 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCaps4Df (vec3 p, float r, float h)\n{\n  return Length4c (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCapsAn4Df (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (Length4c (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - Length4c (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Length4c (vec3 p)\n{\n  return sqrt (length (vec2 (dot (p.xy, p.xy), p.z * p.z)));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdS3zV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 754, 776, 776, 2105], [2107, 2107, 2140, 2140, 2317], [2319, 2319, 2340, 2340, 2532], [2534, 2534, 2556, 2556, 3220], [3222, 3222, 3253, 3253, 4280], [4282, 4282, 4317, 4317, 6310], [6312, 6312, 6368, 6368, 7635], [7637, 7637, 7684, 7684, 7731], [7733, 7733, 7766, 7766, 7793], [7795, 7795, 7837, 7837, 7888], [7890, 7890, 7943, 7943, 8004], [8006, 8006, 8050, 8050, 8116], [8118, 8118, 8173, 8173, 8324], [8326, 8326, 8371, 8371, 8474], [8476, 8476, 8533, 8533, 8616], [8618, 8618, 8648, 8648, 8761], [8763, 8763, 8788, 8788, 8851], [8885, 8885, 8909, 8909, 9039], [9041, 9041, 9066, 9066, 9252], [9254, 9254, 9275, 9275, 9430]]}
{"id": "wdSGDw", "name": "Halftone Experiment", "author": "kzone272", "description": "Inspired by Into the Spider-Verse", "tags": ["dots"], "likes": 5, "viewed": 397, "published": "Public", "date": "1548987701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float roundNearest(float f, float size)\n{\n\treturn round(f / size) * size;\n}\n\n// slope = f'(x) at x = 0;\nfloat sigmoid(float f, float slope) {\n    return tanh(slope * f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    mat2 t;\n    // Transform to isometric:\n    //t[0] = vec2(1, 0);\n    //t[1] = vec2(0.5, 0.866);\n    // Rotate 22.5 degrees\n    t[0] = vec2(0.924, 0.323); // cos, sin\n    t[1] = vec2(-0.323, 0.924); // -sin, cos\n    float scale = (uv.x + 1.) / 2. + (uv.y + 1.) / 3.;\n    //float scale = length(uv.xy - vec2(-1, 1)) + 1.;\n    //float scale = 1.;\n    //t *= scale;\n    mat2 tInv = inverse(t);\n    vec2 pIso = tInv * fragCoord.xy;\n    \n    float size = 7.;\n    float stopX = roundNearest(pIso.x, size);\n    float stopY = roundNearest(pIso.y, size);\n    \n    vec2 nearestIso = vec2(stopX, stopY);\n    \n    float real = length(texture(iChannel0, t * nearestIso / iResolution.xy).rgb) / sqrt(3.);\n    //float real = length(texture(iChannel0, uv.xy).rgb) / sqrt(3.);\n    \n    vec3 hue = 0.5 + 0.5 * cos(iTime+uv.xyx + vec3(0, 2, 4));\n    //hue = vec3(1);\n    \n    vec3 col;\n    \n    float light = 1.;\n    float dark = real;\n    \n    float d = abs(distance(t * nearestIso, t * pIso));\n \tfloat pivot = d - (1. - real) * size / 1.7;\n    float alpha = sigmoid(pivot, 2.); // sigmoid for AA\n    \n    float lum = alpha * light + (1. - alpha) * dark;\n    //lum = real;\n    col = lum * hue;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 75], [77, 104, 141, 141, 171], [173, 173, 230, 280, 1697]]}
{"id": "WdSGRd", "name": "SDF arbitary 2D polygon", "author": "wagyx", "description": "Implements the SDF for an arbitray polygon\nI could not find this anywhere else on shadertoy.\nUses the winding number algorithm.", "tags": ["2d", "sdf", "polygon"], "likes": 15, "viewed": 1414, "published": "Public", "date": "1549649610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 5\n\n\nfloat cross2d(vec2 v0, vec2 v1) {\n    return v0.x*v1.y - v0.y*v1.x;\n}\n\n\n\n// signed distance to a 2D polygon\n// adapted from triangle\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdPoly( in vec2[N] poly, in vec2 p ) {\n    vec2[N] e;\n    vec2[N] v;\n    vec2[N] pq;\n    // data\n    for( int i=0; i<N; i++) {\n        int i2= int(mod(float(i+1),float(N))); //i+1\n\t\te[i] = poly[i2] - poly[i];\n        v[i] = p - poly[i];\n        pq[i] = v[i] - e[i]*clamp( dot(v[i],e[i])/dot(e[i],e[i]), 0.0, 1.0 );\n    }\n    \n    //distance\n    float d = dot(pq[0], pq[0]); \n\tfor( int i=1; i<N; i++) {\n    \td = min( d, dot(pq[i], pq[i]));\n    }\n\t\n    //winding number\n    // from http://geomalgorithms.com/a03-_inclusion.html\n    int wn =0; \n    for( int i=0; i<N; i++) {\n        int i2= int(mod(float(i+1),float(N)));\n        bool cond1= 0. <= v[i].y;\n        bool cond2= 0. > v[i2].y;\n        float val3= cross2d(e[i],v[i]); //isLeft\n        wn+= cond1 && cond2 && val3>0. ? 1 : 0; // have  a valid up intersect\n        wn-= !cond1 && !cond2 && val3<0. ? 1 : 0; // have  a valid down intersect\n    }\n    float s= wn == 0 ? 1. : -1.;\n    return sqrt(d) * s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n\tvec2 v1 = cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( iTime + vec2(0.0,3.00) + 4.0 );\n\tvec2 v4 = cos( iTime + vec2(0.0,2.00) - 2.0 );\n    vec2 v5 = cos( iTime + vec2(0.0,1.00) - 1.0 );\n    \n    // add more points\n    vec2[N] poly= vec2[N](v1,v2,v3,v4,v5);\n    \n\tfloat d = sdPoly(poly, p );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n   \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 47, 47, 83], [87, 225, 269, 269, 1191], [1193, 1193, 1250, 1250, 1889]]}
{"id": "wdSGRy", "name": "Rayfish", "author": "edapx", "description": "raymarching rayfish", "tags": ["rayfish"], "likes": 2, "viewed": 75, "published": "Public", "date": "1549143996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nconst int MAX_MARCHING_STEPS = 128;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 80.00;\n\nvec3 lightDirection = vec3(1.0, 1.0, 0.);\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat smin( float a, float b, float k ){    \n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ){\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ){\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat map(vec3 pos){\n    pos.z += fract(iTime*0.001) * 900.0;\n    float side = 1.5;\n    //raviolo\n    pos = opRep(pos, vec3(11.0 ,17.,11.));\n    float c = cos(sin(iTime)*0.1 *pos.z);\n    float s = sin(sin(iTime)*0.1 *pos.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy,pos.z);\n    float osc = 11.0/side;\n    q.y+= sin(((iTime+q.z)*osc)) * abs(q.x) * side*0.01;\n    q.xz *= rotate2d(-PI/4.);\n    float raviolo =  sdRoundBox(q,vec3(side, side*0.01, side), side*0.01);\n    //body\n    vec3 posBody = pos;\n    posBody.z+= side*0.4;\n    float body = sdEllipsoid(posBody, vec3(side*0.2, side*0.1, side*1.));\n    //tail\n    vec3 posTail = pos;\n    posTail.z-= side*1.9;\n    posTail.y += sin(iTime+posTail.z * 1.2)* side*0.03;\n    float tail = sdEllipsoid(posTail, vec3(side*0.02, side*0.03, side*1.6));\n\n    return smin(tail,smin(raviolo,body, side*0.14), side*0.07);\n}\n\nvec2 squareFrame(vec2 res, vec2 coord){\n    vec2 uv = 2.0 * coord.xy / res.xy - 1.0;\n    uv.x *= res.x / res.y;\n    return uv;\n}\n\nfloat raymarching(vec3 eye, vec3 marchingDirection){\n    float depth = NEAR_CLIP;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= FAR_CLIP) {\n            return FAR_CLIP;\n        }\n    }\n    return FAR_CLIP;\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.3;\n    return clamp( dot(normal, lightDirection) * ambient + ambient, 0.0, 1.0 );\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 100.;\n    return clamp( pow(max(dot(h, normal), 0.), specularityCoef), 0.0, 1.0);\n}\n\n\nfloat fresnel(vec3 normal, vec3 dir){\n    return pow( clamp(1.0+dot(normal,dir),0.0,1.0), 2.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 eye = vec3(2.5,\n                15.0,\n                11.0\n    );\n    \n    vec3 ta = vec3(9.0, -1.0, -9.0 );\n    mat3 camera = setCamera( eye, ta, 0.0 );\n    float fov = 1.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n    float shortestDistanceToScene = raymarching(eye, dir);\n\n    vec3 color;\n    vec3 bgColor = mix(vec3(0.3,0.3,1.),vec3(0.06,0.1,0.34),pow(uv.y-1.3,2.)); \n    // This bg is horrible\n    // suggestion to have a better quick&dirty BG are welcome!\n\n    if (shortestDistanceToScene < FAR_CLIP - EPSILON) {\n        vec3 collision = (eye += (shortestDistanceToScene*0.995) * dir );\n        vec3 normal = computeNormal(collision);\n        float diffLight = diffuse(normal);\n        float specLight = specular(normal, dir);\n        float fresnelLight = fresnel(normal, dir);\n        color = (diffLight + specLight + fresnelLight) * vec3(0.744, 0.613, 0.589);\n        \n\n    } else {\n        color = bgColor;\n    }\n    \n\n    float fogFactor = exp(eye.z * 0.05);\n    color = mix(vec3(bgColor), color, fogFactor);\n    fragColor = vec4(clamp(color,0.0,1.0) , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 224, 224, 315], [317, 317, 346, 346, 375], [377, 377, 405, 405, 491], [493, 493, 533, 533, 630], [633, 633, 675, 675, 764], [767, 767, 811, 811, 911], [913, 913, 933, 933, 1788], [1790, 1790, 1829, 1829, 1918], [1920, 1920, 1972, 1972, 2302], [2304, 2304, 2333, 2333, 2547], [2549, 2549, 2576, 2576, 2682], [2684, 2684, 2722, 2722, 2872], [2875, 2875, 2912, 2912, 2973], [2975, 2975, 3026, 3026, 3215], [3218, 3218, 3274, 3274, 4403]]}
{"id": "WdSGWG", "name": "Sphere box substraction", "author": "rodgzilla", "description": "Smooth subtraction of a moving box from a sphere.", "tags": ["raymarching", "substraction"], "likes": 3, "viewed": 106, "published": "Public", "date": "1549808894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define PI 3.14159\n\nmat2 rot2d(float a) {\n  float c = cos(a);\n  float s = sin(a);\n\n  return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n\n  return length(max(d, 0.)) + \n    min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat map(vec3 p) {\n  p.xz = (p.xz - vec2(0, 5)) * rot2d(time) + vec2(0, 5);\n//  p.yz *= rot2d(time);\n  float wave = sin(2. * time) * 0.5 + 0.5;\n  float d = p.y + 1.5;\n  d = min(d, 3.9 - p.y);\n  d = min(d, p.x + 6.);\n  d = min(d, 6. - p.x);\n  d = min(d, 11. - p.z);\n  d = min(d, p.z + 1.);\n  float dObject = sdSphere(p - vec3(0, 0, 5), 1.);\n  vec3 posBox = p - vec3(0.1 * cos(5. * time), 0.1 * sin(time), 5);\n  posBox.xy = (posBox.xy - vec2(0, 0)) * rot2d(2. * time) + vec2(0, 0);\n//  dObject = max(dObject, -sdBox(p - vec3(0, 0, 5), vec3(0.8) + wave * 0.1));\n//  dObject = max(dObject, -sdBox(posBox, vec3(0.8) + wave * 0.1));\n//  dObject = max(dObject, -sdBox(posBox, vec3(0.8) + wave * 0.1));\n  dObject = opSmoothSubtraction(sdBox(posBox, vec3(0.8) + wave * 0.1), dObject, 0.2 * wave * wave);\n//  dObject = max(dObject, -sdBox(p - vec3(-0.5, 0, 5), vec3(0.5 + .1 * wave)));\n  d = min(d, dObject);\n\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float d = 0.;\n\n  for (int i = 0; i < 60; i++) {\n    vec3 p = ro + d * rd;\n    float m = map(p);\n    d += m;\n\n    if (m < 0.001 || m > 100.) {\n      break;\n    }\n  }\n\n  return d;\n}\n\nvec3 GetNormal(vec3 p) {\n  vec2 e = vec2(0.01, 0.);\n\n  vec3 n = normalize(map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  ));\n\n  return n;\n}\n\nfloat GetLight(vec3 p, vec3 light) {\n  vec3 toLight = light - p;\n  vec3 n = GetNormal(p);\n  float dif = dot(n, normalize(toLight));\n  float d = RayMarch(p + 0.01 * n, normalize(toLight));\n\n  if (d < length(toLight)) {\n    dif *= 0.1;\n  }\n\n  return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col = vec3(0.);\n  vec3 ro = vec3(0);\n  vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n  rd.xz *= rot2d(.01 * time);\n  ro.xz = (ro.xz - vec2(0, 5)) * rot2d(.01 * time) + vec2(0, 5);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + d * rd;\n  vec3 light = vec3(.5);\n  light.xz = (light.xz - vec2(0, 5)) * rot2d(.5 * time) + vec2(0, 5);\n//  light.xz *= rot2d(time);\n  float dif = GetLight(p, light);\n\n  col = vec3(dif);\n\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 131], [133, 133, 166, 166, 192], [194, 194, 223, 223, 318], [320, 320, 378, 378, 479], [481, 481, 500, 500, 1395], [1397, 1397, 1431, 1431, 1613], [1615, 1615, 1639, 1639, 1783], [1785, 1785, 1821, 1821, 2039], [2041, 2041, 2096, 2096, 2681]]}
{"id": "wdSGWK", "name": "BSSRDF Approximation CIS 566", "author": "amally", "description": "An implementation of the subsurface scattering approximation described in this GDC 2011 talk: https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/", "tags": ["subsurfacescattering"], "likes": 3, "viewed": 343, "published": "Public", "date": "1549981065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 1.0, 15.0), 3.14159 * 1.5);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));\n    t = min(t, sphere(pos, 2.0, lightPos));\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\nfloat shadowMap3D(vec3 pos)\n{\n    float t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));\n    float t2;\n    obj = 0; // 0 is center sphere\n    if((t2 = sphere(pos, 2.0, lightPos)) < t) {\n        t = t2;\n        obj = 1;\n    }\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3;\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    return softShadow(dir, origin, min_t, 6.0);\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view, float thick) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // Center sphere\n        vec3 color = vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.67, 0.67) * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + vec3(1.0, 0.67, 0.67) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);\n        break;\n        case 1:\n        // Back sphere\n        return vec3(1.0, 0.88, 0.7);\n        break;\n        case 3:\n        // Floor\n        t = floor(mod(1.0 * (sin(p.x) + sin(p.z)), 2.0));\n        vec3 checker = mix(vec3(0.5), vec3(1.0), t);\n        return vec3(1.0, 0.88, 0.7) * checker * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        break;\n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 lightPos = rotateY(vec3(12.0, 4.0, -6.0), sin(iTime) * 0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[570, 765, 796, 796, 879], [881, 881, 946, 946, 1337], [1339, 1339, 1378, 1378, 1411], [1413, 1413, 1442, 1442, 1509], [1511, 1511, 1539, 1567, 1628], [1630, 1657, 1684, 1684, 1725], [1727, 1727, 1758, 1784, 1815], [1817, 1817, 1850, 1850, 1928], [1930, 1930, 1973, 1973, 2157], [2159, 2159, 2188, 2188, 2328], [2330, 2330, 2398, 2398, 2697], [2699, 2699, 2778, 2778, 3051], [3053, 3053, 3098, 3098, 3477], [3479, 3479, 3521, 3521, 3735], [3737, 3737, 3800, 3800, 4066], [4068, 4068, 4118, 4118, 4168], [4170, 4170, 4247, 4247, 4652], [4654, 4654, 4740, 4740, 5509], [5511, 5511, 5566, 5566, 5998], [6000, 6000, 6057, 6057, 6913]]}
{"id": "WdSGWy", "name": "victorqribeiro_myFirstShader", "author": "victorqribeiro", "description": "a simple shader: a ball orbit around the center of the screen on the z axis", "tags": ["sin", "cos", "ball"], "likes": 0, "viewed": 257, "published": "Public API", "date": "1549830557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tvec2 uv = ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n\t\t\n\t\tuv.x -= sin(iTime)*.4;\n\t\t\n\t\tfloat d = length(uv);\n\t\tfloat r = .2 * abs((cos(iTime)+1.)/2.)+0.1;\n\t\t\n\t\tfloat c = smoothstep(r, r-(1./iResolution.y), d);\n\t\t\n\t\tfragColor = vec4( c );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 306]]}
{"id": "WdSGzt", "name": "Fractal Experiment 29", "author": "aiekick", "description": "Fractal Experiment 29", "tags": ["fractal", "experiment", "29"], "likes": 2, "viewed": 269, "published": "Public API", "date": "1549630824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via NoodlesPlate\n\n//uniform vec2(0.0:1.0:0.924,0.) _c;\n//uniform int(0:200:50) _niter;\n//uniform float(0.0:1.0:0.48) _k;\n//uniform float(0.0:5.0:2.2) _scale;\n//uniform float(0.0:.5:0.03) _limit;\n//uniform float(0.0:100.0:8.) _dist;\n//uniform vec3(color:1,0,1) _color;\n//uniform vec2(0:5:3,2) _colorVar;\n\n#define _c vec2(0.9240,0)\n#define _niter 100\n#define _k 0.25912\n#define _scale 2.2\n#define _limit 0.03\n#define _dist 8.\n#define _color vec3(1,0,1)\n#define _colorVar vec2(3,1.51)\n\nvec2 zmul(vec2 a, vec2 b){return mat2(a,-a.y,a.x)*b;} // z * z \nvec2 zinv(vec2 a){return vec2(a.x, -a.y) / dot(a,a);} // 1 / z\n\nconst float AA = 2.;\n    \nfloat shape(vec2 z)\n{\n\t//return max(abs(z.x), abs(z.y)) * 0.8 + dot(z,z) * 0.2;\n\t//return max(abs(z.x)-z.y,z.y);\n\treturn dot(z,z);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f = vec4(0);\n    \n\tvec2 si = iResolution.xy;\n        \n    for( float m=0.; m<AA; m++ )\n    for( float n=0.; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n) / AA - .5;\n        vec2 uv = ((g+o)*2.-si)/min(si.x,si.y) * _scale;\n        vec2 z = uv, zz;\n        vec2 c = _c;\n\t\tc.y += sin(iTime) * _limit;\n        float it = 0.;\n        for (int i=0;i<_niter;i++)\n        {\n\t\t\tzz = z;\n            z = zinv( _k * zmul(z, z) - c);\n\t\t\tif( shape(z) > _dist ) break;\n            it++;\n        }\n\n\t\tvec4 sec = _colorVar.x + it * _colorVar.y + vec4(_color,1);\n\t\t\n\t\tf += .5 + .5 * sin(sec - shape(zz) / shape(z));\n    }\n    \n    f /= AA * AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSGzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[183, 648, 674, 674, 701], [702, 712, 730, 730, 765], [766, 802, 823, 914, 934], [936, 936, 977, 977, 1609]]}
{"id": "wdsSRn", "name": "swaybars", "author": "midorixyz", "description": "experiment", "tags": ["2d"], "likes": 2, "viewed": 68, "published": "Public", "date": "1550506862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 colora = vec3(0.);\n    vec3 colorb = vec3(0.); \n   \n    int cellx = int(floor(uv.x * 200.));\n    int celly = int(floor(uv.y * 12.));\n    \n    bool foo = (celly % 2) != 0;\n \t\n    float a = sin((iTime) + (float(cellx)));\n    float b = sin((iTime) + (float(cellx)) + sin(iTime) * 2.);\n    \n    colora = vec3(0.,a, a);\n    colorb = vec3(0., b, b);\n    \n    if(foo) {\n    \tfragColor = vec4(colora, 1.);\n    } else {\n    \tfragColor = vec4(colorb, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 557]]}
{"id": "wdsSz7", "name": "MCG: skeletal animation", "author": "tale3d", "description": "We have not learnt 3D geometry yet, so this example is about compound transformations used in character animation.", "tags": ["teachingmaterial"], "likes": 0, "viewed": 52, "published": "Public", "date": "1551103037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Find the distance to the segment\n//This function has some mathematics which we have not discussed yet\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n//The idea behind distance to segment algorithm is the following: \n//  given the points AB for segment and query point P, we project vector AP to the vector AB. \n    vec2 ab = b - a, ap = p - a;\n    \n//However, we do not use explicit projection formula, but just scalar factor which we would multiply by vector AB. \n    float t = dot(ab, ap) / dot(ab, ab);\n//We need that to check if the projected point lies inside the segment and therefore t is in [0,1]\n//   but if it does not, we find the closest point to the segment by ensuring t is in [0,1]\n    if (t < 0.0) t = 0.0;\n    if (t > 1.0) t = 1.0; //we can also use \"clamp\" function in GLSL language\n    \n//Here we find the distance from point P to the segment AB\n    float distance = length(ap - ab*t);\n\n//For visiualisation purposes we re-map it to make the resulting shape to look like an arrow, not a straight line\n    t = 0.2+0.8*t;\n//If we wanted to draw just a segment, we would return distance. But we want to draw a joint, so we multiply by a coefficient we discussed above    \n    return distance*t;\n}\n\n//Translation matrix as in the previous example\nmat3 matTranslate(in float tx, in float ty)\n{\n    //in GLSL we use column-major matrices, so fill the one column by column\n    return mat3(1.0,0.0,0.0,0.0,1.0,0.0,tx,ty,1.0);\n}\n//Rotation matrix as in the previous example\nmat3 matRotate(in float angle)\n{\n    float sa = sin(angle), ca = cos(angle);\n    //in GLSL we use column-major matrices, so fill the one column by column\n    return mat3(ca,sa,0.0,-sa,ca,0.0,0.0,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n\t//Here we set up local transformation for every joint. For joint 1 it is dynamic shift.    \n    mat3 loc1 = matTranslate(0.2*sin(iTime), 0.1);\n    \n    //For all other joint we have static shift and dynamic rotation. Note that we move first and then rotate, \n    //    so matrices are multiplied in the reverse order.\n    mat3 loc2 = matRotate(iTime)*matTranslate(0.5, 0.0);\n    mat3 loc3 = matRotate(-iTime*0.5)*matTranslate(0.0,0.2);\n    mat3 loc4a = matRotate(iTime*1.7)*matTranslate(0.3,0.2);\n    mat3 loc4b = matRotate(iTime*2.2)*matTranslate(0.2,-0.1);\n    \n    //Now we calculate the global transformations for our joints\n    mat3 abs1 = loc1;\n    //We find position of the point (0,0) after transformation for each joint to visualise where the joints are.\n    //In actual skeletal animation we only keep transformation matrices. \n\tvec3 joint1 = abs1*vec3(0.0,0.0,1.0);\n    mat3 abs2 = abs1*loc2;\n    vec3 joint2 = abs2*vec3(0.0,0.0,1.0);\n    mat3 abs3 = abs2*loc3;\n    vec3 joint3 = abs3*vec3(0.0,0.0,1.0);\n    mat3 abs4a = abs3*loc4a;\n    vec3 joint4a = abs4a*vec3(0.0,0.0,1.0);\n    mat3 abs4b = abs3*loc4b;\n    vec3 joint4b = abs4b*vec3(0.0,0.0,1.0);\n\n\n    //Now we draw our segments by finding the distance to the joints from our current point \n    //    and checking if the distance within limits\n    \n    //Note that I am using here conversion from vec3 to vec2 by using internal GLSL .xy function, \n    //   which returns first two fields of vec3 as vec2\n    float segment1 = segment(c, joint1.xy, joint2.xy);\n    if (segment1 < 0.01) colour = vec3(0.0,0.0,1.0);\n    float segment2 = segment(c, joint2.xy, joint3.xy);\n    if (segment2 < 0.01) colour = vec3(0.0,1.0,1.0);\n    float segment3a = segment(c, joint3.xy, joint4a.xy);\n    if (segment3a < 0.01) colour = vec3(1.0,0.0,1.0);\n    float segment3b = segment(c, joint3.xy, joint4b.xy);\n    if (segment3b < 0.01) colour = vec3(1.0,0.0,0.0);\n\n\n    //This is it, colour the pixel and see what we get.\n    fragColor = vec4(colour,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 105, 144, 306, 1208], [1210, 1258, 1303, 1380, 1434], [1435, 1480, 1512, 1512, 1686], [1689, 1689, 1746, 2093, 4830]]}
{"id": "WdsSzN", "name": "RT Soft Shadows", "author": "AdrianPi", "description": "Soft shadows. Pretty slow but nice results.", "tags": ["raytracing", "softwhadows"], "likes": 3, "viewed": 108, "published": "Public", "date": "1550792909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int prim;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\nconst int STARS_MATERIAL = 6;\n    \nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\nconst float EPSILON4 = 1e-4;\n\nvec3 viewFrom = vec3(0,-1,1);\nvec3 viewAt = vec3(0,0,-1);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nconst int oversample = 1;\n\nconst vec4 skyColor = vec4(0,0.25,0.75,1);\nconst vec4 horizonColor = vec4(0.5,0.5,1,1);\n\nconst float fogNear = 10.;\nconst float fogFar = 50.;\nconst float fogDenom = 1. / (fogFar - fogNear);\nconst vec4 fogColor = horizonColor;\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(1,0.8,0,1), \n                                   vec4(1,0.8,0,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0),\n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(.25,0,1,1), \n                                   vec4(.25,0,1,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   STARS_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.24));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(0.3,0.3,0.3,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.6,0.6,0.6,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,1,1), \n                                   vec4(0,0,1,1), \n                                   vec4(1,1,1,60), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0.01,0.01,0.01,0), \n                                   vec4(1,0.1,0.1,1.54));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, material3, material4, material5, material6);\n\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 3, vec3(0, 0, -1), vec3(2, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere2 = primitive_t(SPHERE_PRIMITIVE, 4, vec3(4, 2, -1.5), vec3(1.5, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere3 = primitive_t(SPHERE_PRIMITIVE, 5, vec3(-4, -3, -2), vec3(1, 0, 0), vec3(0,0,0));\nconst primitive_t _sphere4 = primitive_t(SPHERE_PRIMITIVE, 6, vec3(-2, 4, -1.8), vec3(1.2, 0, 0), vec3(0,0,0));\n\nconst int NUM_PRIMS = 5;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _sphere2, _sphere3, _sphere4);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 60.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(int i, ray_t ray, inout hit_t hit)\n{\n    vec3 center = prims[i].v0;\n    float radius = prims[i].v1.x;\n    \n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = prims[i].mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(int i, ray_t ray, inout hit_t hit)\n{\n    vec3 p0 = prims[i].v0;\n    vec3 normal = prims[i].v1;\n        \n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = prims[i].mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\n/*bool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}*/\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.1, 1);\n//vec3 lightDirection = normalize(vec3(1,1,-1));\nvec3 lightPosition = vec3(-10,-10,10);\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\nconst int SS_QUALITY = 8;\nconst int SS_SIZE = SS_QUALITY*SS_QUALITY;\nconst float SS_SCALE = 2. / float(SS_QUALITY-1);\nconst float SS_LIGHT_RADIUS = 0.75;\n\nvec4 shadowIntersect(ray_t ray, inout hit_t hit)\n{\n    vec4 color = vec4(1);\n    hit.t = INFINITE;\n    \n#pragma unroll 1\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            //result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            result = hit_plane(i, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            //result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            result = hit_sphere(i, ray, h);\n            break;\n        /*case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;*/\n        }\n        \n        if(result && h.t > EPSILON)\n        {\n            hit = h;\n            hit.prim = i;\n            if(materials[hit.mat].transparent == vec4(0))\n            {\n             \tcolor = vec4(0);\n                break;\n            }\n            else\n            {\n                // poor-guy caustics\n                float c = pow(-dot(ray.dir, hit.normal), 200.);\n                color *= mix(materials[hit.mat].transparent, vec4(1., 1., 1., 1), c*c) * c * 4.;\n                ////color *= materials[hit.mat].transparent * dot(ray.dir, -hit.normal);\n            }\n        }\n    }\n    return color;\n}\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 4)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    vec3 rawLightDir = hit.pos - lightPosition;\n    vec3 lightDirection = normalize(rawLightDir);\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON;\n    \n    vec3 u = cross(lightDirection, vec3(0,0,1));\n    vec3 v = normalize(cross(u, lightDirection));\n    u = cross(lightDirection, v);\n                       \n    float shadow = 0.;\n    vec4 shadowColor = vec4(0);\n    float w = 0.;\n    if(SS_QUALITY > 1)\n    {\n        for(int i = 0; i < SS_SIZE; i++)\n        {\n            sray.dir = -rawLightDir;\n\n            int iu = i % SS_QUALITY;\n            int iv = i / SS_QUALITY;\n            float fu = (float(iu) * SS_SCALE) - 1.;\n            float fv = (float(iv) * SS_SCALE) - 1.;\n            sray.dir += (fu * u + fv * v) * SS_LIGHT_RADIUS;\n            sray.dir = normalize(sray.dir);\n            hit_t h;\n            vec4 scolor = shadowIntersect(sray, h);\n            float fw =(fu*fu+fv*fv);\n            shadowColor += scolor;\n            if(h.t != INFINITE)\n            {            \n                shadow += fw;\n            }\n            w += fw;\n        }\n    }\n    else        \n    {\n        sray.dir = -lightDirection;\n        hit_t h;\n        vec4 scolor = shadowIntersect(sray, h);\n        shadowColor = scolor;\n        if(h.t != INFINITE)\n        {            \n        \tshadow = 1.;\n        }\n        w = 1.;\n    }\n    w = 1. / w;\n    shadow *= w;\n    //shadow = 1. - shadow;\n    if(shadow <= 1.)\n    {\n        shadowColor *= w;\n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * shadowColor * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * shadowColor.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\n/*vec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}*/\n\nconst int POINTS = 5;\nconst float ANGLE = PI*2./float(POINTS);\n\nvec4 shade_stars(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    vec3 p2 = mod(p, vec3(1.));\n    p2.x += floor(p2.y) * 0.5;\n\n    p2 *= 2.;\n    p2 -= 1.;\n            \n    float acc = 0.;\n    \n    float a = ANGLE;    \n    \n    for(int i = 0; i < POINTS; i++)\n    {\n        vec2 sc = vec2(sin(a), cos(a));\n    \tfloat test = dot(sc, p2.xy-sc*0.25);\n    \tacc += test > 0. ? 0.5 : 0.;\n        a += ANGLE;\n    }\n    \n    hit.mat = (acc < 1.) ?  materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        if(type == STANDARD_MATERIAL)\n        {\n            color = shade_standard(ray, hit);\n        }\n        /*else if(type == CHECKER_MATERIAL) \n        {\n            color = shade_checker(ray, hit);\n        }*/\n        else if(type == STARS_MATERIAL)\n        {\n            color = shade_stars(ray, hit);\n        }\n        \n        // fog\n\t\tif(ray.level != 0)\n        {\n        \tfloat f = (hit.t - fogNear) * fogDenom;\n        \tf = clamp(f, 0.0, 1.0);\n        \tcolor = mix(color, fogColor, f);\n        }\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n\n#pragma unroll 1\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            //result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            result = hit_plane(i, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            //result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            result = hit_sphere(i, ray, h);\n            break;\n        /*case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;*/\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n            hit.prim = i;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    vec4 color = shade(ray, hit);\n    color.w = hit.t;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    viewFrom = vec3(sin(iTime*.5)*14.0, -cos(iTime*.5)*14.0, 2. + sin(iTime*1.5)*3.);\n    \n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    \n    float ovs = float(oversample);\n    vec4 color = vec4(0,0,0,0);\n    float sx = 1.0 / (ovs * iResolution.x);\n    float sy = 1.0 / (ovs * iResolution.y);       \n    \n    float fog = 0.;\n\n#pragma unroll 1\n\n    for(int i = 0; i < oversample; i++)\n    {\n#pragma unroll 1\n        \n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            float t = 0.;\n            \n            while(dequeueRay(ray))\n            {\n\t    \t\tvec4 col = raytrace(ray);\n                if(ray.level == 0 && (col.w != INFINITE || ray.dir.z*ray.dir.z < EPSILON4))\n                {\n                    t = col.w;\n                    float f = (t - fogNear) * fogDenom;\n                \tf = clamp(f, 0.0, 1.0);\n                \tfog += f;\n                }\n                color += col;\n            }\n        }\n    }\n    \n    float ovsInv = 1. / (ovs*ovs);\n    color *= ovsInv;\n    fog *= ovsInv;\n    color = (mix(color, horizonColor, fog));\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsSzN.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 5019, 5058, 5058, 5223], [5225, 5225, 5253, 5253, 5367], [5369, 5369, 5421, 5421, 6319], [6321, 6321, 6372, 6372, 6806], [7495, 7639, 7667, 7667, 7792], [7794, 7794, 7828, 7828, 7983], [7985, 7985, 8007, 8007, 8036], [8238, 8238, 8288, 8288, 9672], [9674, 9674, 9717, 9717, 12597], [12599, 13055, 13095, 13095, 13666], [13668, 13668, 13702, 13702, 14411], [14413, 14413, 14457, 14457, 15320], [15322, 15322, 15348, 15348, 15473], [15475, 15475, 15532, 15532, 17025]]}
{"id": "wdsXR7", "name": "dotgrid", "author": "lennyjpg", "description": "dotgird", "tags": ["grid", "dots", "pattern"], "likes": 6, "viewed": 340, "published": "Public API", "date": "1550978347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 p = fragCoord  + iMouse.xy + iTime ;    \n    p.y += iTime * 20.;\n    float s = 50.;\n    float k = (cos(2.*iTime+uv.x*uv.y*4.)+1.);\n    p.y += k*step(s,mod(p.x,s*2.))*s*.5;\n    p.x += k*step(s,mod(p.y,s*2.))*s*.4+30.;\n    float d = length(mod(p,s)-0.5*s);    \n    float points = smoothstep(d,d*.8,3.);\n    fragColor = vec4(.2+points);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 443]]}
{"id": "wdsXR8", "name": "Gyro Cube", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarcher"], "likes": 3, "viewed": 83, "published": "Public", "date": "1550622862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// Iq's exact box\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    float res = length(p) - .4;\n        for(float i=1.; i<6.; ++i) {\n            p.xz *= rot(iTime*.5);\n            p.yz *= rot(iTime*.5);\n            res = min(res, max(box(p, vec3(i*.8)), -(length(p)-i)));\n        }\n    return res;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<256; ++i) {\n        float d = map(ro+rd*t);\n        if(d < .001 || t > 100.) break;\n        t += d;\n    }\n    return t*.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    //vec3 cam = vec3(0, -1.8, 2.3);\n    vec3 cam = vec3(0, 0., 8.);\n    vec3 dir = normalize(vec3(uv, -1));\n    //dir.yz *= rot(-.6);\n    int aa = 2;\n    \n    vec3 col = vec3(0.);\n    for(int i=-1; i<1; ++i) {\n        for(int j=-1; j<1; ++j) {\n            float d = march(cam+vec3(.01*float(i), .01*float(j), 0.), dir);\n            vec3 p = cam+dir*d;\n\n            vec2 a = abs(uv);\n            vec3 c = vec3(.2, .1, 1.);\n            if(d < 5.) {\n                c = vec3(1.-d*.5);\n                c.r = floor(d);\n                c.g = fract(d);\n            }\n            col += c;\n        }\n    }\n    col /= 2.;\n\n    // Output to screen\n \tcol *= 1.-length(uv)*.4;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 115, 142, 142, 229], [231, 231, 250, 250, 486], [488, 488, 519, 519, 681], [683, 683, 740, 790, 1556]]}
{"id": "wdsXRN", "name": "Voronoided", "author": "Blokatt", "description": "Looks cool, but it's pretty slow.", "tags": ["voronoi"], "likes": 4, "viewed": 407, "published": "Public API", "date": "1550774061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POINT_N 60\n\nstruct Point {\n\tvec2 position;\n    vec3 colour;\n};\n    \nvec4 dither(vec3 col, vec2 frag, int depth){    \n    float cols = float(depth);\n    float val = texture(iChannel0, mod(frag / 8., 1.)).r;\n\treturn vec4((floor((col.rgb + val * (1. / cols)) * cols) / cols), 1.0);\n}    \n\nfloat noise(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float t){\n    vec2 m = vec2(a + b) / 2.;\n    a = vec2(-(a.y - m.y), a.x - m.x) + m;\n    b = vec2(-(b.y - m.y), b.x - m.x) + m; \t\n    float dst = abs((b.y - a.y) * p.x - (b.x - a.x) * p.y + (b.x * a.y) - (b.y * a.x)) / distance(a, b);\n    return smoothstep(0., t * 1.5, dst);        \t              \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Point point[POINT_N];\n    float t = iTime* 6.28318530718 / 2.5;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= ratio;\n    uv -= .5;  \n    \n    for (int i = 0; i < POINT_N; ++i) {\n    \tpoint[i].position = vec2(noise(vec2(float(i))) * ratio + sin(float(i) * .1 + t) * .1,\n                                 noise(vec2(float(i + 2))) + cos(float(i + 15) * .1 + t * .5) * .1\n                                ) - .5;\n        point[i].position.x += sin(point[i].position.x + t * .5) * .25;  \n        point[i].colour =  hsv2rgb(vec3(noise(vec2(float(i))),\n                                .5,\n                                1.));                              \n    }\n       \n    /*\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse -= .5;\n    point[POINT_N - 1].position = mouse;\n    */\n    \n    int closestIndex = 0;\n    float closestDistance = 999999.; \n    \n    for (int i = 0; i < POINT_N; ++i) {\n    \tfloat d = distance(uv, point[i].position);\n        if (d < closestDistance){                \n        \tclosestIndex = i;             \n            closestDistance = d;             \n        }\n    }\n\n    fragColor = vec4(point[closestIndex].colour, 1.) * (1. - .05 * pow(1. + closestDistance, 8.));\n    float thickness = min(dFdx(uv.x), dFdy(uv.y));\n    for (int i = 0; i < POINT_N; ++i) {\n    \tfragColor *= smoothstep(.005, .01, distance(uv, point[i].position));\n    \tif (i != closestIndex) fragColor *= line(uv, point[closestIndex].position, point[i].position, thickness);\n    }\n    fragColor = dither(fragColor.rgb, fragCoord, 255);\n       \n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsXRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 120, 120, 288], [294, 294, 314, 314, 379], [381, 440, 462, 462, 631], [633, 633, 677, 677, 967], [969, 969, 1026, 1026, 2669]]}
{"id": "WdsXW4", "name": "isometric textured 3-story-map", "author": "FabriceNeyret2", "description": "isometric + special view angle: no ray-tracing needed, we know exactly which element could show at any given place.\nExample with 4 possible levels (0 + up to 3 stories).", "tags": ["isometric", "city", "fake3d", "town", "short", "golf", "ville"], "likes": 12, "viewed": 399, "published": "Public API", "date": "1551292349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 3-story variant of https://shadertoy.com/view/WslSW4\n// textured variant of https://shadertoy.com/view/3sXSW8\n\n//#define C(x,y) 2.*texelFetch(iChannel1, ivec2(U+vec2(x,y)),0).r//\n#define C(x,y) sin(1e3*length (ceil(U)+vec2(x,y)))//\n//\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, w,v,\n         U =  ( u+u - R ) / R.y * mat2(1,-2,1,2);\n    U.y += iTime;\n    R = fract( U *= 5. );\n    bool r = R.x+R.y > 1.;\n    w = .5+cos(12.6*R*mat2(1,1,0,1));\n    vec4 a = max(w.xxxx,w.y),\n         b = texture(iChannel1,U/8.).grba,\n         c = .4+.1*cos(12.6*(R.y+R.xxxx)),\n         d = 1.7*texture(iChannel0,U/4.);\n    O +=  C(3,-3)>.9       ? d         /* 3rd story */\n        : C(3,-2)>.9 &&  r ? a*2.\n        : C(2,-3)>.9 && !r ? c\n        : C(2,-2)>.9 ?   r ? c : a*2.\n        : C(2,-2)>.7       ? d*.7      /* 2nd story */\n        : C(2,-1)>.7 &&  r ? a\n        : C(1,-2)>.7 && !r ? c\n        : C(1,-1)>.7 ?   r ? c : a\n        : C(1,-1)>.5       ? d*.5      /* 1st story */\n        : C(1, 0)>.5 &&  r ? a*.7\n        : C(0,-1)>.5 && !r ? c*.9\n        : C(0, 0)>.5 ?   r ? c*.9 : a*.7\n        : C(-1,0)>.5       ? b*.5      /* ground lev*/\n        :                    b;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 238, 274, 274, 1188]]}
{"id": "WdsXzN", "name": "MANTAP JIWA", "author": "sanddroo", "description": "mantap boss", "tags": ["omg"], "likes": 3, "viewed": 337, "published": "Public API", "date": "1550757468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat sphere(vec3 rp, vec3 c, float r)\n{\n\treturn distance(rp,c)-r;\n}\n\nfloat cube( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec4 map(vec3 rp)\n{\n\tvec4 d;\n     //sun\n\tvec4 sp = vec4(vec3(1., .3 , 0.), sphere(rp, vec3(0.,2.0,0.), 1.0)) ;\n    //mercury\n\tvec4 sp2 = vec4( vec3(.5, 0.5, 0.5), sphere(rp, vec3(2.*cos(iTime) ,2.0,2.*(sin(iTime))), .25) ); \n    //earth\n\tvec4 sp3 = vec4( vec3(.0, .3, 0.65), sphere(rp, vec3(5.*cos(iTime/2.)  ,2.0,5.*(sin(iTime/2.))), 0.5) ); \n\t//venus\n    vec4 sp4 = vec4( vec3(.7, 0.55, 0.45), sphere(rp, vec3(2.7*cos(iTime/3.)  ,2.0,2.7*(sin(iTime/3.))), 0.3) ); //planet 3\n    //dave mom\n    //mars255-140-0\n    vec4 sp5 = vec4( vec3(255./255., 140./255., 0.), sphere(rp, vec3(3.6*cos(iTime/4.5)  ,2.0,3.6*(sin(iTime/4.5))), 0.3) ); //planet 4\n    //dave\n    //jupiter 165,42,42\n    vec4 sp6 = vec4( vec3(164./255., 42./255., 42./255.), sphere(rp, vec3(6.75*cos(iTime/8.)  ,2.0,6.75*(sin(iTime/8.))), 0.75) ); //planet 5\n\t//saturn\n    vec4 sp7 = vec4( vec3(.6, .5, 0.5), sphere(rp, vec3(8.5*cos(iTime/1.05)  ,2.0,8.5*(sin(iTime/1.05))), 0.6) ); //planet 5\n\t//uranus\n    vec4 sp8 = vec4( vec3(.0, .5, 0.85), sphere(rp, vec3(10.*cos(iTime/2.5)  ,2.0,10.*(sin(iTime/2.5))), 0.7) ); //planet 5\n    //neptune\n    vec4 sp9 = vec4( vec3(.0, .45, 0.9), sphere(rp, vec3(12.*cos(iTime/1.1)  ,2.0,12.*(sin(iTime/1.1))), 0.35) ); //planet 5\n\n    //pluto\n    vec4 sp10 = vec4( vec3(.45, .45, 0.45), sphere(rp, vec3(15.*cos(iTime/2.3)  ,2.0,15.*(sin(iTime/2.3))), 0.2) ); //planet 5\n    \n    vec4 cb = vec4( vec3(0.85, 0.30, 0.40), cube(rp, vec3(1.0,1.0,1.0), 0.025) );\n\tvec4 py = vec4( vec3(1.95, 0.84, 0.65), rp.y+1.0+sin(rp.x*10.0)*0.1+cos(rp.z*10.0)*0.1 );\n\td = (sp.a == cb.a) ? cb : sp;\n\td = ( py.a == d.a) ? py : d;\t\n\td = (d.a < sp2.a) ? d : sp2;\n    d = (d.a < sp3.a) ? d : sp3;\n    d = (d.a < sp4.a) ? d : sp4;\n    d = (d.a < sp5.a) ? d : sp5;\n    d = (d.a < sp6.a) ? d : sp6;\n    d = (d.a < sp7.a) ? d : sp7;\n    d = (d.a < sp8.a) ? d : sp8;\n    d = (d.a < sp9.a) ? d : sp9;\n    d = (d.a < sp10.a) ? d : sp10;\n\n\treturn d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   //shamelessly stolen from iq :(\n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\n\n}\n\nfloat softShadow(vec3 ro, vec3 lp)\n{\n\tvec3 rd = normalize(lp-ro);\n\tfloat tmax = distance(lp,ro);\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfor(int i = 0; i<256; i++ )\n\t{\n        if(t>=tmax) break;\n\t\tfloat d = map(ro+rd*t).a;\n\t\tif(d < 0.001) return 0.0;\n\t\tres = min(res, 4.0*d);\n\t\tt += d;\n\t}\n\treturn res;\n}\n\nfloat ao(vec3 ro, vec3 norm, float k)\n{\n    float res = 0.0;\n    float f = 0.1;\n    for(int i = 1; i<256; i++)\n    {\n        vec3 rp = ro + f*float(i)*norm;\n     \tres+=(1.0/pow(2.0,float(i)))*(f*float(i)-map(rp).a);    \n    }\n\treturn 1.0;//-k*res;\n}\n\n\n\nvec3 lp(){ \n    return vec3(.0,2.,.0);//*rot(vec3(0.0,time*0.5,0.0));\n}\n\nvec3 reflection(vec3 rro, vec3 rd, vec3 n, vec3 ro)\n{\n    vec3 res = vec3(0.9, 0.75, 0.70)*0.35; //ambient reflection\n    int chk = 1;\n    for(int j = 0; j<3; j++)\t\t// 3 reflections\n    {\n\t\trd = reflect(rd, n);\t\n\t\tfloat tmax = 50.0;\n   \t\tfloat t = 0.1;\n    \tvec3 rp = rro;\n    \tvec4 d = vec4(res, 1.0);\n    \tif(chk == 1)\n    \t{\n\t\t\tfor(int i = 0; i<256; i++ )\n\t\t\t{\n        \t\tif(t>=tmax) break;\n\t\t\t\trp = rro+rd*t;\n\t\t\t\td = map(rp);\n\t\t\t\tif(d.a < 0.001) break;\n\t\t\t\tt += d.a*(0.35+t/tmax);\n\t\t\t}\n    \t}\n    \tchk = 0;\n    \tif(d.a < 0.001) \n\t\t{\t\t\n    \t\tfloat ks = 0.1;\n\t\t\tfloat kd = 0.1;\t\t\n\t\t\tfloat ka = 0.04;\n        \tfloat a = 3.0;\n\t\t\tfloat aof = 0.06;\t\n\t\t\tfloat ss = 0.2;\t\t\n\t\t\t\n\t\t\tvec3 l = normalize(lp()-rp);          \n\t\t\tn = normal(rp);\t\t\t\t\n\t\t\tvec3 v = normalize(ro-rp);\n        \tvec3 h = normalize(l+v);\t\t\n\t\t\t\n\t\t\tfloat illumination  = ka*ao(rp,n, aof) \t\t\t\t\n\t\t\t\t\t\t\t\t+ kd*max(dot(l,n),0.0)\n                         \t    + ks*pow(max(dot(n,h),0.0),a)\t\t\n\t\t\t\t\t\t\t\t+ ss*softShadow(rp, lp());\n        \tillumination = max(illumination, 0.0);\n\t\t\tres += d.rgb*illumination*(1.0/pow(2.0,float(j)));\n        \tchk = 1;\n        \trro = rp;\n\t\t}\n    }\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.y+=1.0;\n\tp.x*=iResolution.x/iResolution.y;\t\n\tfloat f = -15.0*(sin(time*0.2)*0.25+0.75);\n\tvec3 col = vec3(0.0, 0., 0.)*0.35;\n\tvec3 ang = vec3((iMouse.y == 0.0 ? 0.25 :iMouse.y/iResolution.y)*3.141592*0.5,\n                     time*0.1+(iMouse.x/iResolution.y)*3.141592,\n                     0.0);\n\tvec3 ro = vec3(0.0,1.,f-2.0);\n\tvec3 rd = normalize(vec3(p,f)-ro);\n\tro*=rot(ang);\n\trd*=rot(ang);\n\tvec3 rp;\n\tfloat tmax = 50.0;\n\tfloat t = 0.5;\n    vec4 d = vec4(col, 1.0);\n\tfor(int i = 0; i<256; i++)\n\t{\n        if(t >= tmax) break;\n\t\trp = ro+rd*t;\n\t\td = map(rp);\n\t\tif(d.a < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.a*(0.35+t/tmax);\n\t}\n\tif(d.a < 0.001)\n    {\n   \t\tfloat ks = 0.33;\t\t//specular reflection constant\n\t\tfloat kd = 0.33;\t\t//diffuse reflection constant\n\t\tfloat ka = 0.33;\t\t//ambient reflection constant\n\t\tfloat a = 3.0;\t\t//shininess constant\n\t\tfloat aof = 5.0;\t//ambient occlusion amount\n\t\tfloat ss = 1.;\t\t//direct light amount\n\t\tfloat rf = 1.0;\t\t//reflection amount\n\t\t\t\n\t\tvec3 l = normalize(lp()-rp);          //surface to light vector\n\t\tvec3 n = normal(rp);\t\t\t\t//surface normal vector\n\t\tvec3 v = normalize(ro-rp);\t\t\t//surface to camera vector\n        vec3 h = normalize(l+v);\t\t\t//the \"half way vector\"\n\t\t\t\n\t\tvec3 illumination  =  ka*ao(rp,n, aof) \t\t\t\t//add ambient light\n\t\t\t\t\t\t\t+ kd*max(dot(l,n),0.0) \t\t\t//add diffuse light\n\t\t\t\t\t\t\t+ ks*max(pow(dot(n,h),a),0.0)\t//add specular light\n\t\t\t\t\t\t\t+ ss*softShadow(rp, lp())\t\t//add direct light\n           \t\t\t\t\t+ rf*reflection(rp,rd,n,ro);\n\t\t\t\t\t\t\t\t\n\t\t\t\n\t\tcol = d.rgb*illumination;\n    }\n    \n\tfloat dlp = length(cross(lp()-ro, lp()-(ro+rd)))/length((ro+rd)-ro+3.);\n\t//col+=max(exp(-dlp*1.0),0.)*vec3(1.,.5,0.);\n    col+=max(exp(-dlp*5.0),0.)*vec3(1.,.5,0.);\n\n\tfragColor = vec4(col,1.0);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 303], [305, 305, 345, 345, 373], [375, 375, 414, 414, 454], [456, 456, 475, 475, 2378], [2380, 2380, 2402, 2402, 2656], [2658, 2658, 2694, 2694, 2959], [2961, 2961, 3000, 3000, 3210], [3214, 3214, 3224, 3224, 3285], [3287, 3287, 3340, 3340, 4432], [4434, 4434, 4489, 4489, 6281]]}
{"id": "wdXSDn", "name": "Local lighting model", "author": "darkeclipz", "description": "Testing out various components of a local lightning model. Used the following book as a reference: \n\n - 3D Math Primer for Graphics and Game Development, Fletcher Dunn, page 398-411\n\n| 5 | 6 | 7 | 8 |\n| 1 | 2 | 3 | 4 |", "tags": ["phong", "raymarch", "lighting", "shading", "blinn"], "likes": 3, "viewed": 178, "published": "Public", "date": "1551025320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 80.\n#define MinDistance 0.0075\n#define eps 0.001\n#define AA 4.\n#define AA2 (AA*AA)\n#define torus 0\n#define floor 1\n\nmat2 r2(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// from IQ\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// from IQ\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// from IQ\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\n// from IQ\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nvec2 scene(vec3 p) {\n    \n    float plane = sdPlane(p, vec4(0., 1., 0., .9));\n    //float box = sdBox(p - vec3(0,.207,0), vec3(.5));\n    float box = sdTorus(p*rotateZ(iTime/2.) - vec3(0,0,0), vec2(.5,0.2));\n    int id = 0;\n    if(plane < box) id = 1;\n    plane = min(plane, box);\n    return vec2(plane, id);\n}\n\nfloat shadowScene(vec3 p) {\n    return sdTorus(p*rotateZ(iTime/2.) - vec3(0,0,0), vec2(.5,0.2));\n}\n\n// from IQ\nvec3 calcNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  \t\tk.yyx*scene( p + k.yyx*h ).x + \n                  \t\tk.yxy*scene( p + k.yxy*h ).x + \n                  \t\tk.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n    \nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        float id = hit.y;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, id, 1.-i/MaxSteps);  \n        }\n    }\n    return vec3(0.);\n}\n\nvec2 shadowMarch(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    float min_dt = 1e10;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        min_dt = min(min_dt, dt);\n        if(dt < MinDistance) {\n        \treturn vec2(t, 0);  \n        }\n    }\n    return vec2(0, min_dt);\n}\n\n\nfloat checker(vec2 p, float scale) {\n    p = trunc(fract(p)*scale);\n    if(mod(p.x + p.y, 2.) == 0.) return 1.;\n    return 0.;\n}\n\n/* \tStandard Local Lighting Model \n\n\tThe *emissive* contribution, denoted c_emis, is the same as\n\tthe rendering equation. It tells the amount of radiance emitted\n\tdirectly from the surface in the given direction.\n\n\tThe *specular* contribution, denoted c_spec, accounts for light\n\tincident directly from a light source that is scattered preferentially\n\tin the direction of a perfect 'mirror bounce'.\n\n\tThe *diffuse* contribution, denoted c_diff, accounts for light\n\tincident directly from a light source that is scattered in every\n\tdirection evenly.\n\n\tThe *ambient* contribution, denoted c_amb, is a fudge factor\n\tto account for all indirect light.\n\t\n\tReference:\n\t\t-\t3D Math Primer for Graphics and Game Development, \n\t\t\tsecond ed., Fletcher Dunn, Ian Parberry, pages 398-411\n\n*/\nconst vec3 light = vec3(0,3,0);\n\n// simple shading by showing the normal of the object.\nvec3 shade01(vec3 p, vec3 n, vec3 v, int id) {\n    if(id == torus) return n*.5+.5; // remap the normal from [-1, 1] to [0, 1].\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//  Specular component with Phong model for specular reflection.\n// \n//\tThe *specular component* of the standard model accounts for the\n//  light that is reflected (mostly) in a \"perfect mirror bounce\" off\n//\tthe surface. The specular component is what gives a surface\n// \ta \"shiny\" appearance.\n//\n// \tn: a local outward pointing surface normal\n//\tv: points towards the viewer (symbol 'e' for eye is sometimes used)\n//\tl: points towards the light source\n//  r: reflection vector for reflecting l about n\n//  theta: angle between r and v\n//\n//  Phong model for specular reflection:\n//\tc_spec = (s_spec * m_spec)(cos theta)^m_gls = (s_spec * m_spec)(v . r)^m_gls\n\nvec3 shade02(vec3 p, vec3 n, vec3 v, int id) {\n\n    vec3 l = normalize(p - light);\n    \n    vec3 m_spec = vec3(.7); // controls the intensity and color of the specular\n    \t\t\t\t\t\t// highlight. A highly reflective surface will have a \n    \t\t\t\t\t\t// higher m_spec, and more matte surface will be lower.\n    \t\t\t\t\t\t// (m: material, _spec: specular)\n    \n    vec3 s_spec = vec3(.9); // light specular color; essentially the color of the light\n    \t\t\t\t\t\t// which contains both its color and intensity. In practice,\n    \t\t\t\t\t\t// s_spec is almostalways equal to the light color used\n    \t\t\t\t\t\t// for diffuse lightning. \n    \t\t\t\t\t\t// (s: source, _spec: specular)\n    \n    vec3 r = reflect(n, l);\t// Reflection vector can be computed by 2 * ( n . l ) n - l.\n    \n    float m_gls = 8.;\t\t// Glossiness of the material (or Phong exponent/specular exponent/shininess)\n    \t\t\t\t\t\t// controls how wide the hotspot is, a smaller m_gls produces a larger,\n    \t\t\t\t\t\t// more gradual falloff from the hotspot. This is a hotspot of reflection,\n    \t\t\t\t\t\t// not to be confused with the hotspot of a spot light.\n    \n    vec3 spec = s_spec * m_spec * pow(clamp(dot(-v, r), .0, 1.), m_gls); // (s_spec * m_spec) (v . r) ^ m_gls\n    \n    if(id == torus) return spec;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//  Specular component with Blinn model for specular reflection.\n// \n//  The formula for the Blinn model is quite similar to the\n// \toriginal Phong model. Only the dot product portion changed.\n//\n//\tThe half-angle h is calculated:   h = (v + l) / (|| v + l ||)\n//\n// \tBlinn model for specular reflection:\n//\tc_spec = (s_spec * m_spec) (cos theta)^m_gls = (s_spec * m_spec) (n . h) ^ m_gls\n\nvec3 shade03(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light);\n    vec3 m_spec = vec3(.7);\n    vec3 s_spec = vec3(.9);\n    vec3 h = normalize(v + l); // (v + l) / (|| v + l ||)\n    float m_gls = 8.;\n    \n    // (s_spec * m_spec) (v . r) ^ m_gls\n    vec3 spec = s_spec * m_spec * pow(max(clamp(-dot(n, h), 0., 1.), .0), m_gls); \n    \n    if(id == torus) return spec;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//\tDiffuse component with Lambert's Law\n//\t\n// \tDiffuse light models light that is reflected randomly in all \n//\tdirection due to the rough nature of the surface material. Surfaces\n// \tmore perpendicular to the light ray receive more light per unit area\n// \tthan a surface oriented at a more glancing angle.\n//\n//\tDiffuse light obeys Lambert's Law: the intensity of the reflected light\n//\tis proportional to the cosine of the angle between the surface normal\n//\tand the ray of light.\n//\n//\tDiffuse Component accordings to Lambert's Law:\n//\tc_diff = (s_diff * m_diff) (n . l)\n\nvec3 shade04(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light); // unit vector that points towards the light source.\n    \n    vec3 m_diff = vec3(.6);\t// Material's diffuse color, which is the value that\n    \t\t\t\t\t\t// most people think of when they think of the color of an object.\n    \t\t\t\t\t\t// The diffuse material color often comes from a texture map.\n    \n    vec3 s_diff = vec3(.9);\t// Diffuse color of the light source, s_diff, usually equal\n    \t\t\t\t\t\t// to the light's specular color, s_spec.\n    \n    vec3 c_diff = s_diff * m_diff * clamp(-dot(n, l), 0., 1.); // (s_diff * m_diff) (n . l)\n    \n    if(id == torus) return c_diff;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//\tAmbient and emissive components\n//\n//\tTo model light that is reflected more than one time before it enters\n//\tthe eye, we use a very crude approximation known as 'ambient light'. The\n//\tambient portion of the lighting equation depends only on the properties of\n//\tthe material and an ambient lighting value, which is often a global value\n//\tused for the entire screen.\n//\n//\tAmbient contribution to lighting equation:  c_amb = g_amb * m_amb\n\nvec3 shade05(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light); // unit vector that points towards the light source.\n    \n    vec3 m_amb = vec3(.9);\t// Materials ambient color. This is almost always the\n    \t\t\t\t\t\t// same as the diffuse color.\n    \n    vec3 g_amb = vec3(.15);\t// Global ambient light factor, g_amb. Usually a global variable\n    \t\t\t\t\t\t// for the entire screen.\n    \n    vec3 c_amb = g_amb * m_amb;\n    \n    if(id == torus) return c_amb;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n// Lighting Equation\n//\n// Standard lighting model for one light source:\n//\n//   \t       c_spec\t     (s_spec * m_spec) max(n . h, 0)^m_gls\n//\tc_lit =  + c_dif     = + (s_diff * m_diff) max(n . l, 0)\n//\t\t\t + c_amb\t   + g_amb * m_amb\n//\t\t\t + c_emis\t   + m_emis\n//\n// Standard lighting equation for multiple lights:\n//\n// c_lit = sum_{j=1}^n[(s_j * m_spec) max(n . h, 0) + (s_j * m_diff) max(n . l, 0)]\n//\t\t   + g_amb * m_amb + m_emis\n//\n// where s_j : color of the light source, including attenuation factor, and j=1 to n number of lights.\n\nvec3 shade06(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light);\n    vec3 h = normalize(v + l);\n    \n    vec3 m_spec = vec3(.7);\n    vec3 s_spec = vec3(.9);\n    float m_gsl = 8.;\n    \n    vec3 c_spec = (m_spec * s_spec) * pow(max(-dot(n, h), 0.), m_gsl);\n    \n    vec3 m_diff = vec3(.6);\n    if(id == floor) m_diff = vec3(1) * checker(p.xz, 4.);\n    \n    vec3 s_diff = vec3(.9);\n    \n    vec3 c_diff = (s_diff * m_diff) * max(-dot(n, l), 0.);\n    \n    vec3 m_amb = vec3(.4);\n    vec3 g_amb = vec3(.15);\n    \n    vec3 c_amb = m_amb * g_amb;\n    \n    return c_spec + c_diff + c_amb;\n    \n    // Most surfaces don't emit light, so c_emis = 0. We are\n    // rendering self-illuminated surfaces but they don't interact\n    // with the objects around it. When using the lighting equation\n    // properly (global illumination?), the lighting equation does\n    // light up their surroundings.\n}\n\n// Light attenuation\n\nfloat attenuate(float d, float d_min, float d_max) {\n\tif(d <= d_min) return 1.;\n    if(d > d_min && d < d_max) return (d_max - d) / (d_max - d_min);\n    else return 0.;\n}\n\nfloat simpleLinearAttenuation(float d) { return attenuate(d, 10., 60.); }\nfloat realWorldAttenuation(float d) { return 100. / (d*d); } // shoots to infinity\n\nvec3 shade07(vec3 p, vec3 n, vec3 v, int id) {\n    \n    float d = length(p - light);\n    return shade06(p,n,v,id) * attenuate(d, 4., 6.);\n}\n\n// Hard shadow\n\nvec3 shade08(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 c_lit = shade07(p,n,v,id);\n    vec3 rd = normalize(light - p);\n    vec2 t = shadowMarch(p + 2.*MinDistance*n, rd);\n    if(t.x > eps) return 0.25 * c_lit;\n    return c_lit;\n    \n}\n\nvec2 shadeId = vec2(0);\nvec3 shadingSelector(vec3 p, vec3 n, vec3 v, int id) {\n    if(shadeId == vec2(0,0)) return shade01(p,n,v,id);\n    if(shadeId == vec2(1,0)) return shade02(p,n,v,id);\n    if(shadeId == vec2(2,0)) return shade03(p,n,v,id);\n    if(shadeId == vec2(3,0)) return shade04(p,n,v,id);\n    if(shadeId == vec2(0,1)) return shade05(p,n,v,id);\n    if(shadeId == vec2(1,1)) return shade06(p,n,v,id);\n    if(shadeId == vec2(2,1)) return shade07(p,n,v,id);\n    if(shadeId == vec2(3,1)) return shade08(p,n,v,id);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec3 samples = vec3(0);\n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n    \tvec2 uv = (U + vec2(aax, aay) / AA)/R.y;\n        uv *= 2.25;\n        \n        shadeId = trunc(uv);\n        uv = fract(uv) - 0.5;\n        uv *= 2.;\n        \n        vec3 col = vec3(.0);\n        vec3 ro = vec3(0,1.7,-5.);\n        mat3 rot = rotateY(iTime/2.);\n        vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n\n        ro *= rot;\n        rd *= rot;\n\n        vec3 hit = march(ro, rd);\n        float t = hit.x;\n        float id = hit.y;\n\n        if(t > 0.) {\n            vec3 p = ro + t * rd;\n            vec3 n = calcNormal(p);\n            col = shadingSelector(p, n, rd, int(id));\n            col = clamp(col, .0, 1.);\n        }\n    \n        samples += col;\n    }\n\n    O = vec4(samples/AA2,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 180, 180, 244], [245, 245, 272, 272, 358], [360, 360, 387, 387, 465], [467, 478, 511, 511, 576], [578, 589, 622, 648, 679], [681, 692, 725, 725, 749], [751, 762, 791, 791, 847], [849, 849, 869, 869, 1158], [1160, 1160, 1187, 1187, 1258], [1260, 1271, 1296, 1296, 1575], [1581, 1581, 1611, 1611, 1925], [1927, 1927, 1963, 1963, 2269], [2272, 2272, 2308, 2308, 2400], [3214, 3269, 3315, 3315, 3453], [3455, 4117, 4163, 4163, 5412], [5414, 5804, 5850, 5850, 6251], [6253, 6829, 6875, 6875, 7543], [7545, 7990, 8036, 8036, 8523], [8525, 9064, 9110, 9110, 9972], [9974, 9996, 10048, 10048, 10166], [10168, 10168, 10208, 10208, 10241], [10242, 10242, 10279, 10279, 10302], [10303, 10326, 10372, 10372, 10465], [10467, 10483, 10529, 10529, 10722], [10748, 10748, 10802, 10802, 11244], [11246, 11246, 11287, 11287, 12105]]}
{"id": "wdXSWn", "name": "Crypt Roots", "author": "leon", "description": "Ray marching improvised geometry with curvy shapes and rock textures.\nExploring level of details, materials and lights.", "tags": ["tunnel"], "likes": 88, "viewed": 3979, "published": "Public API", "date": "1551017954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Crypt Roots\n// Ray marching improvised geometry with curvy shapes and rock textures\n// Exploring level of details, materials and lights\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.02.24\n\n// Using code from\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n\n// Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define repeat(p,r) (mod(p,r)-r/2.)\nconst float PI = 3.14159;\nmat2 rot (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = 0.5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 3.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward + right * anchor.x + up * anchor.y);\n}\nvoid moda(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map (vec3 pos) {\n  float chilly = noise(pos * 2.);\n  float salty = fbm(pos*20.);\n  \n  pos.z -= salty*.04;\n  salty = smoothstep(.3, 1., salty);\n  pos.z += salty*.04;\n  pos.xy -= (chilly*2.-1.) * .2;\n    \n  vec3 p = pos;\n  vec2 cell = vec2(1., .5);\n  vec2 id = floor(p.xz/cell);\n  p.xy *= rot(id.y * .5);\n  p.y += sin(p.x + .5);\n  p.xz = repeat(p.xz, cell);\n    \n  vec3 pp = p;\n  moda(p.yz, 5.0);\n  p.y -= .1;\n  float scene = length(p.yz)-.02;\n    \n  vec3 ppp = pos;\n  pp.xz *= rot(pp.y * 5.);\n  ppp = repeat(ppp, .1);\n  moda(pp.xz, 3.0);\n  pp.x -= .04 + .02*sin(pp.y*5.);\n  scene = smoothmin(length(pp.xz)-.01, scene, .2);\n\n  p = pos;\n  p.xy *= rot(-p.z);\n  moda(p.xy, 8.0);\n  p.x -= .7;\n  p.xy *= rot(p.z*8.);\n  p.xy = abs(p.xy)-.02;\n  scene = smoothmin(scene, length(p.xy)-.005, .2);\n\n  return scene;\n}\n\nvec3 getNormal (vec3 pos) {\n  vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n  return normalize( e.xyy*map( pos + e.xyy ) + e.yyx*map( pos + e.yyx ) + e.yxy*map( pos + e.yxy ) + e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 eye = vec3(.1,.1,-iTime*.1-4.);\n  vec3 at = vec3(0,0,eye.z-2.0);\n  vec3 ray = look(eye, at, uv);\n  vec3 pos = eye;\n  float dither = random(uv+fract(iTime));\n  float total = dither * .2;\n  float shade = 0.0;\n  const float count = 60.0;\n  for (float index = count; index > 0.0; --index) {\n    pos = eye + ray * total;\n    float dist = map(pos);\n    if (dist < 0.001 + total * .003) {\n      shade = index / count;\n      break;\n    }\n    dist *= 0.5 + 0.1 * dither;\n    total += dist;\n  }\n  vec3 normal = getNormal(pos);\n  vec3 color = vec3(0);\n  color += smoothstep(.3, .6, fbm(pos*100.)) * .2;\n  color += vec3(0.839, 1, 1) * pow(clamp(dot(normal, normalize(vec3(0,2,1))), 0.0, 1.0), 4.);\n  color += vec3(1, 0.725, 0.580) * pow(clamp(dot(normal, -normalize(pos-at)), 0.0, 1.0), 4.);\n  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(4,0,1))), 0.0, 1.0), 4.);\n  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(-5,0,1)))*.5+.5, 0.0, 1.0), 4.);\n  color = mix(vec3(0), color, clamp(dot(normal, -ray), 0.0, 1.0));\n  color *= pow(shade, 1.0/1.2);\n  fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXSWn.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[292, 414, 434, 434, 485], [486, 486, 531, 531, 605], [606, 606, 633, 633, 701], [702, 702, 723, 723, 753], [754, 754, 775, 775, 1358], [1359, 1359, 1379, 1379, 1569], [1570, 1570, 1618, 1618, 1833], [1834, 1834, 1878, 1878, 2019], [2021, 2021, 2043, 2043, 2830], [2832, 2832, 2859, 2859, 3031], [3033, 3033, 3090, 3090, 4272]]}
{"id": "wdXSz4", "name": "RayTracing Tutorial - Step 5", "author": "BrunoLevy", "description": "Multiple light sources and shadows", "tags": ["raytracing", "tutorial"], "likes": 0, "viewed": 334, "published": "Public API", "date": "1550694808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n};\n\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, vec3(0.0, 0.0, 0.0));\n}\n\nMaterial light(in vec3 Ke) {\n   return Material(vec3(0.0, 0.0, 0.0), Ke);\n}\n\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\nObject scene[8];\n\nvoid init_scene() {\n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      diffuse(vec3(1.0, 1.0, 1.0))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.0, 0.0, -10000.0),9998.0), \n      diffuse(vec3(1.0, 1.0, 1.0))\n   );\n\n\n   {\n     float beta = float(iFrame)/30.0 + 1.0;\n     float s = sin(beta);\n     float c = cos(beta); \n     scene[2] = Object(\n        Sphere(vec3(2.0*c, 2.0*s, 2.5),0.02),\n        light(vec3(1.0, 0.0, 0.0)) \n     );\n   }\n\n   {\n     float beta = float(iFrame)/30.0 + 2.0;\n     float s = sin(beta);\n     float c = cos(beta); \n     scene[3] = Object(\n        Sphere(vec3(2.0*c, 2.0*s, 2.5),0.02),\n        light(vec3(0.0, 1.0, 0.0)) \n     );\n   }\n\n   {\n     float beta = float(iFrame)/30.0 + 3.0;\n     float s = sin(beta);\n     float c = cos(beta); \n     scene[4] = Object(\n        Sphere(vec3(5.0*c, 5.0*s, 3.0),0.02),\n        light(vec3(0.0, 0.0, 1.0)) \n     );\n   }\n\n   for(int i=0; i<3; ++i) {\n     float beta = float(iFrame)/30.0 + float(i)/1.555;\n     float s = sin(beta);\n     float c = cos(beta); \n\n     scene[5+i] = Object(\n        Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n        diffuse(vec3(float(i)/19.0, 1.0-float(i)/19.0, float(i)/19.0))\n     );\n   } \n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n \nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n           float lamb = max(0.0, dot(E,N) / length(E));\n           result += lamb * material.Kd * scene[i].material.Ke;\n         }\n      }\n   }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n\n   if(t != FARAWAY) {\n      fragColor.rgb = lighting(P,N,material);\n   }\n\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 281, 281, 579], [581, 581, 618, 618, 715], [848, 848, 878, 878, 925], [927, 927, 955, 955, 1002], [1082, 1082, 1101, 1101, 2281], [2283, 2283, 2342, 2342, 2608], [2611, 2611, 2634, 2634, 2918], [2920, 2920, 2979, 2979, 3483], [3485, 3485, 3542, 3542, 4291]]}
{"id": "WdXXRr", "name": "rayleigh, mie", "author": "kuma720", "description": "rayleigh, mie", "tags": ["rayleigh", "mie"], "likes": 5, "viewed": 219, "published": "Public", "date": "1550454753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referenced \n//http://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/index_en.html\n//https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\n//https://github.com/wwwtyro/glsl-atmosphere\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\nfloat sdf( vec3 p ) {\n    return length( p ) - 1.2 ;\n}\n\nvec3 createnormal(vec3 p) {\n  float e = 0.001;\n  return normalize( vec3(\n    sdf( vec3(p.x+e,p.y,p.z) ) - sdf( vec3(p.x-e,p.y,p.z) ) ,\n    sdf( vec3(p.x,p.y+e,p.z) ) - sdf( vec3(p.x,p.y-e,p.z) ) ,\n    sdf( vec3(p.x,p.y,p.z+e) ) - sdf( vec3(p.x,p.y,p.z-e) )\n  ));\n}\n\n\n\nvec2 rsi(vec3 r0, vec3 rd, float sr) {\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, r0);\n    float c = dot(r0, r0) - (sr * sr);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 dir ) {\n  float len = 0.;\n\n  //////////////////////////////////////////\n  int iSteps = 30;\n  int jSteps = 8;\n  float PI = 3.14159265;\n\n  //////////////////////////////////////////\n  float intensity = 15.;\n  float g = -.995;\n  float rAtmos = 6420e3;\n  float rPlanet = 6360e3;\n  float atmosThickness = rAtmos - rPlanet; \n  float shRlh = 0.25 * atmosThickness; //scale height rayliegh\n  float shMie = 0.01 * atmosThickness; //scale height mie\n  float kMie = 21e-6;\n  vec3 kRlh = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n  vec3 r0 = vec3(0,rPlanet,0);\n\n  //////////////////////////////////////////\n  float T = iTime;\n  vec3 pSun = normalize( vec3( cos(T) , sin(T*3.5) * .1 + .2 , sin(T) ) );\n  vec3 rayDirection = normalize(dir);\n\n  ////////////////\n  float iOdRlh = 0.0;\n  float iOdMie = 0.0;\n  vec3 totalRlh = vec3(0,0,0);\n  vec3 totalMie = vec3(0,0,0);\n\n  float iStepSize = 0.;\n  {////////////////\n    vec2 p = rsi(r0, rayDirection, rAtmos);\n    p.y = min(p.y, rsi(r0, rayDirection, rPlanet).x);\n    iStepSize = (p.y - p.x) / float(iSteps);\n  }\n\n  ////////////////\n  float len2 = 0.;\n  vec3 objcol = vec3(0.);\n  for ( int I=0 ; I<iSteps ; ++I ) {\n\n    ////////////////\n    vec3 iPos = (eye + r0) + rayDirection * ( float(I) * iStepSize + iStepSize * 0.5 );\n      \n    // The Out-Scattering Equation\n    float iHeight = length(iPos) - rPlanet;\n    float odStepRlh = exp(-iHeight / shRlh) * iStepSize;\n    float odStepMie = exp(-iHeight / shMie) * iStepSize;\n    iOdRlh += odStepRlh;\n    iOdMie += odStepMie;\n    \n    ////////////////\n    float jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);\n    float jTime = 0.0;\n    float jOdRlh = 0.0;\n    float jOdMie = 0.0;\n    for (int j = 0; j < jSteps; j++) {\n        vec3 jPos = iPos + pSun * ( float(j) * jStepSize + jStepSize * 0.5 );\n        float jHeight = length(jPos) - rPlanet;\n        jOdRlh += exp(-jHeight / shRlh) * jStepSize;\n        jOdMie += exp(-jHeight / shMie) * jStepSize;\n    }\n\n    ////////////////\n    totalRlh += odStepRlh * exp( -( kRlh * (iOdRlh + jOdRlh) ) );\n    totalMie += odStepMie * exp( -( vec3(kMie) * (iOdMie + jOdMie) ) );\n\n    ////////////////\n    vec3 p = eye + dir * len2;\n    float l = sdf( p );\n    len2 += min( l , 3. );\n    if ( l < 0.01 ) {\n      objcol = dot ( createnormal(p) , pSun ) * vec3(.5,.4,.3);\n      break;\n    }\n\n  }\n\n\n\n  ////////////////\n  float mu = dot( -rayDirection , pSun);\n  float mumu = mu * mu;\n  float gg = g * g;\n    \n  //fix\n  //float pRlh = 1. / (4. * PI) * ( 1.0 + mumu );\n  float pRlh = 3. / (16. * PI) * ( 1.0 + mumu );\n    \n  //fix\n  //float pMie = 1. / (4. * PI) * ( ( 3. * (1.0 - gg) ) / (2. * (2.0 + gg) ) )  * ( (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) )\n  float pMie = 3. / (8. * PI) * ( ( (1. - gg) * (mumu + 1.) ) / ( ( 2. + gg ) * pow(1. + gg - 2. * mu * g, 1.5) ) );\n\n  ////////////////\n  vec3 col = intensity * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie) + objcol;\n  return vec4( col , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    vec3 eye = vec3( -25. , -2. ,  -25. );\n    vec3 center = vec3( 0. , 3., 0. );\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n   fragColor = render( uv , eye , worldDir );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 240, 286, 286, 476], [477, 477, 540, 540, 666], [669, 669, 690, 690, 723], [725, 725, 752, 752, 989], [993, 993, 1031, 1031, 1290], [1294, 1294, 1340, 1340, 4262], [4265, 4265, 4322, 4322, 4701]]}
{"id": "wdXXW4", "name": "arc_1", "author": "ferreus", "description": "cursor", "tags": ["first"], "likes": 1, "viewed": 55, "published": "Public", "date": "1551345057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.1415926535897932384626433832795;\n    vec2 coord = fragCoord.xy;\n    vec2 center = iResolution.xy /2.0;\n    float dist = length(center - coord);\n    float circlesOut = cos(dist/7.0 - iTime*6.0);\n    circlesOut *= 5.0;\n    float circlesIn = cos(dist/7.0 + iTime*6.0);\n    circlesIn *= 5.0;\n    circlesIn = clamp(circlesIn,0.0,1.0);\n    circlesOut = clamp(circlesOut,0.0,1.0);\n    float edge = clamp(dist-100.0,0.0,1.0);\n    circlesOut *= edge;\n    circlesIn *= 1.0-edge;\n    \n    float dx = coord.x - center.x;\n    float dy = coord.y - center.y;\n    \n    float c = circlesOut;\n    float targetAngle = (mod(iTime*4.0,36.0)*10.0);\n    float angle = 180.0 + atan(dy,dx) * 180.0 / PI;\n    float a = angle-targetAngle+180.0+ 360.0;\n    float da = 360.0 - mod(a,360.0) - 180.0;\n    if (da < 30.0 && da > 0.0) {\n\t\tfragColor = vec4(0,c,0,0.0);\n    } else {\n        fragColor = vec4(0,0,0,0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 972]]}
{"id": "ws23Dc", "name": "LAZERS", "author": "lambmeow", "description": "lazers", "tags": ["lazers"], "likes": 0, "viewed": 105, "published": "Public API", "date": "1550208941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SEGMENTS 20.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.);\n    uv.y *= 3.;\n    uv.y -= 0.7;\n    for(float j = 0.; j < NUM_SEGMENTS; j+=1.){\n    \tfor(float i = 0.; i < 10.; i += 1.){\n        \tfloat x = uv.y;\n        \tx += 0.5;\n    \t\tx +=  1.-sin(iTime* 3.+ uv.x * j) * 0.4* j * atan(i + j )*0.5;\n  \t\t\tcol += (abs(0.01/(1.- x))*.3) * vec3(1.- j/NUM_SEGMENTS,i/NUM_SEGMENTS, i/NUM_SEGMENTS);\n    \t}\n    }\n    \n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws23Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 132, 577]]}
{"id": "ws23DG", "name": "Distance Field Experiment", "author": "synergyseeker1", "description": "Distance field basics. Experiment with rings. Art of Shaders #artofshaders", "tags": ["circles", "distancefields", "vfx", "artofshadersartofshaders"], "likes": 1, "viewed": 106, "published": "Public", "date": "1549931047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\t\n    float d = distance(uv, pos);\n    d = abs(cos(d*12.)*sin(d*rad))*4.8-.5;\n\treturn vec4(color*vec3(rad,d*d,rad*uv.y),1.0- d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// normailze and adjsut for ratio\n\tvec2 r = iResolution.xy,\n     uv = (fragCoord*2.0-r ) / r.y; \n\t\n    \t// Background layer\n\tvec4 background = vec4(0.0);\n\t\n\t// Circle\n\tvec3 color = vec3(.6, .7, 2.0);\n    float radius = sin(iTime);\n    vec2 position = vec2(.0,.0);\n\tvec4 circle1 = circle(uv, position, radius, color);\n    \n\t\n\t// combine\n\tfragColor = mix(background, circle1, circle1.a);\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws23DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 186], [188, 188, 245, 281, 639]]}
{"id": "Ws23Ry", "name": "Fast box rep twist", "author": "rodgzilla", "description": "Fast forward through a landspace of boxes.", "tags": ["raymarching", "box"], "likes": 3, "viewed": 122, "published": "Public", "date": "1549213236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define FOV 2.\n#define SHIFT 0.02\n#define SPEED 5.\n#define MIN_DIST 0.0001\n#define MAX_DIST 100.\n#define MAX_STEP 100\n#define PI 3.14159\n\nvec3 palette(float x) {\n  float wave = sin(3. * time) * 0.5 + 0.5;\n  wave = 0.;\n  vec3 a = vec3(.3, .6, .9);\n  vec3 b = vec3(0.5 + 0.5 * wave);\n  vec3 c = vec3(.5);\n  vec3 d = vec3(.3, .6, .7);\n\n  return a + b * cos(2. * PI * (c + d * x));\n}\n\nmat2 rot2d(float a) {\n  float c = cos(a);\n  float s = sin(a);\n\n  return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat boxRep(vec3 p, vec3 b, vec3 rep) {\n  vec3 q = mod(p, rep) - 0.5 * rep;\n\n  return box(q, b);\n}\n\nfloat map(vec3 p) {\n  p.xy *= rot2d(sin(time) * 3. * sin(p.z / 10.));\n  float tSize = 1.;\n  float d = 500.;\n  vec3 b = vec3(.1);\n  float dBox1 = boxRep(p - vec3(2, 0, 0), b + 0.025 * sin(3. * time), vec3(.5, .5, 2.3));\n  float dBox2 = boxRep(p - vec3(2, -1, 2), b + 0.05 * sin(time), vec3(.5, .25, 2.3));\n  d = min(d, dBox1);\n  d = min(d, dBox2);\n\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float d = 0.;\n\n  for (int i = 0; i < MAX_STEP; i++) {\n    vec3 p = ro + d * rd;\n    float m = map(p);\n    d += m;\n\n    if (m < MIN_DIST || m > MAX_DIST) {\n      break;\n    }\n  }\n\n  return d;\n}\n\nvec3 GetNormal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n\n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n\n  return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n  vec3 light = vec3(0, 0, 0. + SPEED * time);\n  vec3 toLight = light - p;\n  vec3 n = GetNormal(p);\n  float dif = dot(n, normalize(toLight));\n  float d = RayMarch(p + SHIFT * n, normalize(toLight));\n\n  if (d < length(toLight)) {\n    dif *= 0.1;\n  }\n\n  return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv *= FOV;\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0, 0, SPEED * time);\n ro.xy *= rot2d(time / 3.);\n  vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + d * rd;\n  float dif = GetLight(p);\n\n  col = vec3(dif);\n  col = palette(1. - 3. * p.z / MAX_DIST) * dif;\n\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws23Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 180, 180, 398], [400, 400, 421, 421, 492], [494, 494, 521, 521, 611], [613, 613, 653, 653, 712], [714, 714, 733, 733, 1075], [1077, 1077, 1111, 1111, 1306], [1308, 1308, 1332, 1332, 1475], [1477, 1477, 1501, 1501, 1766], [1767, 1767, 1824, 1824, 2288]]}
{"id": "Ws23zt", "name": "Tetrahedron SDF", "author": "yx", "description": "Exploring more polyhedral SDFs.", "tags": ["math", "sdf", "tetrahedron"], "likes": 10, "viewed": 678, "published": "Public API", "date": "1549732809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\nconst vec3 color = vec3(.1,.7,.6);\n                \nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat scene(vec3 p)\n{\n    return (max(\n\t    abs(p.x+p.y)-p.z,\n\t    abs(p.x-p.y)+p.z\n\t)-1.)/sqrt(3.);\n    \n    /*float a = +p.x +p.y;\n    float c = +p.x -p.y;\n\treturn (max(max(a,-a)-p.z,max(c,-c)+p.z)-r)/sqrt(3.);*/\n    \n    /*float a = +p.x +p.y -p.z;\n    float b = -p.x -p.y -p.z;\n    float c = +p.x -p.y +p.z;\n    float d = -p.x +p.y +p.z;\n\treturn (max(max(a,b),max(c,d))-r)/sqrt(3.);*/\n    \n    /*vec3 p2 = abs(p)-1.;\n    float d = max(max(p2.x,p2.y),p2.z);\n    d = max(d, dot(p, vec3(1,1,-1))-r);\n    d = max(d, dot(p, vec3(-1,-1,-1))-r);\n    d = max(d, dot(p, vec3(1,-1,1))-r);\n    d = max(d, dot(p, vec3(-1,1,1))-r);\n\treturn d/sqrt(3.);*/\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t;\n    for(int i = 0; i < 100; ++i)\n    {\n        float k = scene(cam+dir*t);\n        t += k;\n        if (k < .001)\n        {\n            vec3 h = cam+dir*t;\n    \t\tvec2 o = vec2(.001, 0);\n    \t\tvec3 n = normalize(vec3(\n        \t\tscene(h+o.xyy)-scene(h-o.xyy),\n        \t\tscene(h+o.yxy)-scene(h-o.yxy),\n        \t\tscene(h+o.yyx)-scene(h-o.yyx)\n    \t\t));\n\n\t\t\tif (iMouse.z > 0.)\n    \t\t{\n        \t\treturn n*.5+.5;\n    \t\t}\n    \t\telse\n    \t\t{\n\t\t        const vec3 lightdir = normalize(vec3(1,5,2));\n                \n\t\t        float light = dot(n,lightdir)*.5+.5;\n\t\t\n\t\t        return light * color;\n    \t\t}\n        }\n    }\n    return vec3(1);\n}\n\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15.);\n    vec3 dir = normalize(vec3(uv,4));\n    \n    cameraspin(cam);\n    cameraspin(dir);\n\n    out_color.rgb = trace(cam,dir);\n    if (iMouse.z <= 0.)\n    {\n    \tout_color.rgb *= pow(color, vec3(2.*dot(uv,uv)));\n    \tout_color.rgb = pow(out_color.rgb,vec3(.45));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws23zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 106, 106, 229], [231, 231, 252, 252, 877], [879, 879, 911, 911, 1557], [1559, 1559, 1590, 1590, 1656], [1658, 1658, 1710, 1710, 2101]]}
{"id": "ws2GD3", "name": "Moment Factory SDF", "author": "fractalteapot", "description": "Quick ray tracing experiment with a signed distance function of the Moment Factory logo.", "tags": ["raytracing", "sdf"], "likes": 10, "viewed": 158, "published": "Public", "date": "1550180843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.14159265359, ASP = 2.36550308, WW = 0.039930556, LH = 0.451595072, RM = 0.506145483, RN = 0.436, SA = 0.25, SR = 0.35, SY = 0.36;\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 3.2, MAX_DIST = 5.5, EPSILON = 0.0001;\nconst float ANI_DUR = 20.0, SLIDE_DUR = 2.0, FADE_DUR = 5.0;\n\n#define ADD(z) x = min(x, z)\n#define SADD(z, k) x = smoothAdd(x, z, k)\n#define SUB(z) x = max(-z, x)\n#define ZERO (min(iFrame,0))\n\nfloat smoothAdd( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat plane(vec3 p){\n\treturn p.z - 0.1;\n}\nfloat box( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b/2.0;\n    return length(max(d, 0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\nfloat box( vec3 p, vec2 o, vec3 b ){\n\tp -= b/2.0 * vec3(o,0.0);\n    return box(p, b);\n}\nfloat box( vec3 p, float a, vec2 o, vec3 b ){\n\tp.xy -= 0.5*b.xy;\n    vec2 t = vec2(sin(a), cos(a));\n\tp.xy += b.xy*o/2.0; p.xy = mat2(t.y, t.x, -t.x, t.y) * p.xy; p.xy -= b.xy*o/2.0;\n    return box(p, b);\n}\nfloat sheer(vec3 p, float a, vec2 o, vec3 b ) {\n\tp.xy -= 0.5*b.xy;\n\tp.xy += b.xy*o/2.0; p.x += a*p.y;p.xy -= b.xy*o/2.0; \n\treturn box(p, b);\n}\nvec4 opElong( in vec3 p, in vec3 h ){\n    return vec4( p-clamp(p,-h,h), 0.0 );\n}\nfloat cylin( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat time;\nvec3 anim(float offset) {\n\treturn vec3(0.0,0.5*(1.0-smoothstep(0.0, 1.0, time-offset)),0.0) + vec3(0.0,0.0,0.2*smoothstep(ANI_DUR-SLIDE_DUR-FADE_DUR, ANI_DUR-SLIDE_DUR, time-offset));\n}\n\nfloat map(vec3 p) {    \n\n\tvec2 u = vec2(1.0,-1.0);\n\t\n    float cnvs = iResolution.x/iResolution.y, w = WW*cnvs, ln = LH*cnvs/ASP;\n\n\tp.x += w * 12.5;\n\tp.y += w * 6.0;    \n\n\tfloat h = 0.2;\n\tfloat hh = h/2.0;\n\t\n\tfloat t = 1., dt = SLIDE_DUR/6.0;\n\t\n\tfloat x = 1e10;\n\t\n\t/*M*/\n    ADD(box(p-vec3(0.0,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n    ADD(box(p-vec3(3.0*w, 1.35*ln+w,hh)+anim(t), RM, u.xy, vec3(w, ln*.65, h)));\n    ADD(box(p-vec3(0.0, 1.35*ln+w,hh)+anim(t), -RM, u.yy, vec3(w, ln*.65, h)));\n\tADD(box(p-vec3(1.66*w, ln+w*2.56,hh)+anim(t), u.xx, vec3(w*0.68, ln*0.2, h)));\n    ADD(box(p-vec3(3.0*w, ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tt+=dt;\n\t/*O*/\n \t{vec4 e = opElong( p - vec3(6.5*w, 1.5*ln+w,hh)+anim(t), vec3(0.009,w,0.) );\n    ADD(e.w+cylin( e.yzx, vec2(0.1,0.5*h)));} \n\tSUB(box(p-vec3(6.05*w, 1.2*ln+w,hh)+anim(t), u.xx, vec3(w, ln*.6, h*2.0)));\n\tt+=dt;\n\t/*M*/\n\tADD(box(p-vec3(9.1*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n    ADD(box(p-vec3(12.1*w, 1.35*ln+w,hh)+anim(t), RM, u.xy, vec3(w, ln*.65, h)));\n    ADD(box(p-vec3(9.1*w, 1.35*ln+w,hh)+anim(t), -RM, u.yy, vec3(w, ln*.65, h)));\n    ADD(box(p-vec3(12.1*w, ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(10.76*w, ln+w*2.56,hh)+anim(t), u.xx, vec3(w*0.68, ln*0.2, h)));\n\tt+=dt;\n\t/*E*/\n\tADD(box(p-vec3(14.1*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(14.*w,ln+w,hh)+anim(t), PI/2.0, u.yx, vec3(w, ln*.43, h)));\n\tADD(box(p-vec3(14.*w,2.0*ln,hh)+anim(t), PI/2.0, u.yx, vec3(w, ln*.43, h)));\n\tADD(box(p-vec3(14.*w,2.0*ln-w*1.8,hh)+anim(t), PI/2.0, u.yx, vec3(w, ln*.35, h)));\n\tt+=dt;\n\t/*N*/\n\tADD(box(p-vec3(18.*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(20.15*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(18.*w, ln+w,hh)+anim(t), -RN, u.yy, vec3(w, ln, h)));\n\tt+=dt;\n\t/*T*/\n\tADD(box(p-vec3(22.95*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(21.1*w,2.0*ln+w*0.1,hh)+anim(t), PI/2.0, u.yx, vec3(w*0.9, ln*.6, h)));\n\n\t/*MASK*/\n\tSUB(box(p-vec3(-w*2.0,ln+w,0.0), u.xy, vec3(2.0,1.0,1.0)));\n\t\n\tfloat ln1 = x; x = 1e10;\n\tdt = SLIDE_DUR/7.0;\n\t\n\t/*F*/\n\tADD(box(p-vec3(0.0,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(0.0,1.0*ln-0.9*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), PI/2.0, u.yx, vec3(w*0.9, ln*.41, h)));\n\tADD(box(p-vec3(0.0,1.0*ln-w*2.9,hh)+anim(t)*vec3(1.0,-1.0,1.0), PI/2.0, u.yx, vec3(w*.85, ln*.38, h)));\n\tt-=dt;\n\t/*A*/\n\tADD(sheer(p-vec3(3.1*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), -SA, u.xx, vec3(w, ln, h)));\n\tADD(sheer(p-vec3(5.65*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), SA, u.xx, vec3(w, ln, h)));\n\tt-=dt;\n\t/*C*/\n\t{vec4 e = opElong( p - vec3(8.7*w, ln*0.5,hh)+anim(t)*vec3(1.0,-1.0,1.0), vec3(0.009,w,0.) );\n    ADD(e.w+cylin( e.yzx, vec2(0.1,0.5*h) ) );}\n\tSUB(box(p-vec3(8.2*w, 0.95*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln*.6, h*2.0)));\n\tSUB(box(p-vec3(8.4*w, 1.55*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w*2.6, ln*.35, h*2.0)));\n\tt-=dt;\n\t/*T*/\n\tADD(box(p-vec3(11.8*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(9.9*w,ln-w*0.9,hh)+anim(t)*vec3(1.0,-1.0,1.0), PI/2.0, u.yx, vec3(w*0.9, ln*.6, h)));\n\tt-=dt;\n\t/*O*/\n\t{vec4 e = opElong( p - vec3(15.85*w, ln*0.5,hh)+anim(t)*vec3(1.0,-1.0,1.0), vec3(0.009,w,0.) );\n    ADD(e.w+cylin( e.yzx, vec2(0.1,0.5*h) ) );} \n\tSUB(box(p-vec3(15.4*w, 0.2*ln,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln*.6, h*2.0)));\n\tt-=dt;\n\t/*R*/\n\t{vec4 e = opElong( p - vec3(19.7*w, ln*0.68,hh)+anim(t)*vec3(1.0,-1.0,1.0), vec3(0.02,0.009,0.));\n    ADD(e.w+cylin(e.yzx, vec2(0.1,0.5*h)));} \n\tADD(box(p-vec3(18.35*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, h)));\n\tSUB(box(p-vec3(17.35*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, 2.0*h)));\n\tADD(sheer(p-vec3(20.5*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), SR, u.xx, vec3(w, ln, h)));\n\tSUB(box(p-vec3(19.35*w,2.5*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln*.28, h*2.0)));\n\tt-=dt;\n\t/*Y*/\n\tADD(sheer(p-vec3(22.95*w,.4*ln,hh)+anim(t)*vec3(1.0,-1.0,1.0), SY, u.xx, vec3(w*0.9, ln*0.6, h)));\n\tADD(sheer(p-vec3(23.05*w,.4*ln,hh)+anim(t)*vec3(1.0,-1.0,1.0), -SY, u.xx, vec3(w*0.9, ln*0.6, h)));\n\tADD(box(p-vec3(22.98*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w*.95, ln*.5, h)));\n\t/*MASK*/\n\tSUB(box(p-vec3(-w*2.0,ln,0.0), u.xx, vec3(2.0,1.0,1.0)));\n\t\n\tADD(ln1);\n\t\n\tSADD(plane(p), 0.025);\n\n\tx = min(x,x);\n    return x;\n}\n\nvec3 hit;\nfloat march(vec3 rayPos, vec3 marchingDiboxion, float start, float end) {\n    hit = vec3(1e9);\n\tfloat depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\t\thit = rayPos + depth * marchingDiboxion;\n        float dist = map(hit);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= end) return end;\n    }\n    return end;\n}\n            \nvec3 rayDiboxion(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 calcNormal( vec3 pos ){\n    // From IQ - 'inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times'\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n); \n}\n\nvec3 phong(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 rayPos) {\n    vec3 lPos = vec3(-sin(iTime*.25),0.5*cos(iTime*.25), 2.0);\n    vec3 lInt = vec3(0.4, 0.4, 0.4);\n\tvec3 N = calcNormal(p), L = normalize(lPos - p), V = normalize(rayPos - p), R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) return k_a + vec3(0.0, 0.0, 0.0);\n    if (dotRV < 0.0) return k_a + lInt * (k_d * dotLN);\n    return k_a + lInt * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nmat3 viewMatrix(vec3 rayPos, vec3 center, vec3 up) {\n    // Based on gluLookAt\n    vec3 f = normalize(center - rayPos);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\ttime = fract(iTime / ANI_DUR) * ANI_DUR;\n\tvec3 rayDir = rayDiboxion(45.0, iResolution.xy, fragCoord);\n\tfloat a = 1.2*smoothstep(4.0, 10.0, iTime);\n    vec3 rayPos = vec3(a*sin(iTime*0.5), a*cos(iTime*0.5), 4.0);\n    \n    vec3 worldDir = viewMatrix(rayPos, vec3(0.0), vec3(0.0, 1.0, 0.0)) * rayDir;\n    \n    float dist = march(rayPos, worldDir, MIN_DIST, MAX_DIST);\n    \n\tvec3 K_a = vec3(0.6) - smoothstep(0.18,0.2,hit.z)*0.5 + smoothstep(0.2,0.0,hit.z)*0.2;\n\tvec3 K_d = vec3(0.5,0.42,0.4);\n    vec3 K_s = vec3(1.0, 0.9, 0.8);\n    float shininess = 10.0;\n\t\n\tvec3 color;\n\t\n    if (dist > MAX_DIST - EPSILON) {\n        color = K_a;\n    } else {\n\t\tvec3 p = rayPos + dist * worldDir;    \n\t\tcolor = clamp(phong(K_a, K_d, K_s, shininess, p, rayPos) - 0.5 * smoothstep(3.0, 0.0, iTime), 0.0, 1.0);\n\t}\n\t\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat v = 1.0*smoothstep(0.4, 1.0, distance(uv, vec2(0.5)));\n\tcolor -= v*v;\n\tfragColor = vec4(clamp(color, 0.0, 1.0),1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2GD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 441, 489, 489, 588], [590, 590, 610, 610, 631], [632, 632, 660, 660, 755], [756, 756, 792, 792, 843], [844, 844, 889, 889, 1049], [1050, 1050, 1097, 1097, 1192], [1193, 1193, 1230, 1230, 1273], [1274, 1274, 1304, 1304, 1403], [1416, 1416, 1441, 1441, 1601], [1603, 1603, 1622, 1622, 5939], [5951, 5951, 6024, 6024, 6319], [6333, 6333, 6397, 6397, 6529], [6531, 6531, 6559, 6669, 6865], [6867, 6867, 6943, 6943, 7387], [7389, 7389, 7441, 7467, 7601], [7604, 7604, 7661, 7661, 8624]]}
{"id": "Ws2GRd", "name": "Rhombic Triacontahedron SDF", "author": "yx", "description": "Exploring more polyhedral SDFs.", "tags": ["math", "sdf", "triacontahedron"], "likes": 11, "viewed": 460, "published": "Public API", "date": "1549735452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\nconst vec3 color = vec3(.1,.4,.6);\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat scene(vec3 p)\n{\n    const float phi = (1.+sqrt(5.))*.5;\n    \n    //const float l = length(vec3(phi+1.,phi,1));\n    // or, expanded, sqrt(2.*phi*phi + 2.*phi + 2.);\n    // or, I guess, sqrt(2)*sqrt(phi*phi+phi+1)\n    const float l = phi*2.; // or this!\n    \n    // minified version\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-1.;\n    \n    // and the optimization histoy is below....\n    \n    /*float l = length(vec3(phi+1.,phi,1));\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-1.;*/\n    \n    /*float l = length(vec3(phi+1.,phi,1));\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-1.;*/\n    \n    /*vec3 n = vec3(phi+1.,phi,1);\n    float l = length(n);\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-1.;*/\n    \n    /*vec3 n = vec3(phi+1.,phi,1);\n    float l = length(n);\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z)-1.;\n    p = p*phi+p + p.yzx*phi + p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l-1.);*/\n    \n    /*vec3 n = vec3(phi+1.,phi,1);\n    float l = length(n);\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z)-1.;\n    float b = p.x*(phi+1.) + p.y*phi + p.z;\n    float c = p.y*(phi+1.) + p.z*phi + p.x;\n    float d = p.z*(phi+1.) + p.x*phi + p.y;\n    return max(a, max(b,max(c,d))/l-1.);*/\n    \n    /*vec3 n = vec3(phi+1.,phi,1);\n    float l = length(n);\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z)-1.;\n    float b = dot(p.xyz, n);\n    float c = dot(p.yzx, n);\n    float d = dot(p.zxy, n);\n    return max(a, max(b,max(c,d))/l-1.);*/\n    \n    /*p = abs(p);\n    float a = max(max(p.x,p.y),p.z)-1.;\n    float b = dot(p.xyz, normalize(vec3(phi+1.,phi,1)))-1.;\n    float c = dot(p.yzx, normalize(vec3(phi+1.,phi,1)))-1.;\n    float d = dot(p.zxy, normalize(vec3(phi+1.,phi,1)))-1.;\n    return max(max(a,b),max(c,d));*/\n    \n    /*p = abs(p);\n    float a = max(max(p.x,p.y),p.z)-1.;\n    for(int i=0;i<3;++i)\n    {\n        a = max(a, dot(p, normalize(vec3(phi+1.,phi,1)))-1.);\n        p = p.yzx;\n    }\n    return a;*/\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t;\n    for(int i = 0; i < 100; ++i)\n    {\n        float k = scene(cam+dir*t);\n        t += k;\n        if (k < .001)\n        {\n            vec3 h = cam+dir*t;\n    \t\tvec2 o = vec2(.001, 0);\n    \t\tvec3 n = normalize(vec3(\n        \t\tscene(h+o.xyy)-scene(h-o.xyy),\n        \t\tscene(h+o.yxy)-scene(h-o.yxy),\n        \t\tscene(h+o.yyx)-scene(h-o.yyx)\n    \t\t));\n\n\t\t\tif (iMouse.z > 0.)\n    \t\t{\n        \t\treturn n*.5+.5;\n    \t\t}\n    \t\telse\n    \t\t{\n                const vec3 lightdir = normalize(vec3(1,5,2));\n                \n\t\t        float light = dot(n,lightdir)*.5+1.;\n\t\t\n\t\t        return light * color;\n    \t\t}\n        }\n    }\n    return vec3(1);\n}\n\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, .3);\n    p.xz = rotate(p.xz, iTime*.1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-15.);\n    vec3 dir = normalize(vec3(uv,6));\n\n    cameraspin(cam);\n    cameraspin(dir);\n    \n    out_color.rgb = trace(cam,dir);\n    if (iMouse.z <= 0.)\n    {\n    \tout_color.rgb *= pow(color, vec3(2.*dot(uv,uv)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2GRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 90, 90, 213], [215, 215, 236, 236, 2476], [2478, 2478, 2510, 2510, 3162], [3164, 3164, 3195, 3195, 3261], [3263, 3263, 3315, 3315, 3655]]}
{"id": "ws2GWK", "name": "Psytrance with Text", "author": "nikunjsha", "description": "Just a psytrance beat lol\n\nOriginal Colors : https://www.shadertoy.com/view/lltGDs\nOriginal Pangram : https://www.shadertoy.com/view/XdXGRB\n", "tags": ["2d", "music", "text", "text", "glitch", "font", "alphabet", "pangram", "psytrance"], "likes": 3, "viewed": 121, "published": "Public", "date": "1550049814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Source edited by Nikunjsha - 2019.\n\n// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 19. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n//#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(3.0, .5);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\n\n//Original Color Code \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n//}\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n    float time = mod(iTime, 7.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\tvec3 col = vec3(0.1, .05+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n\td += N(r()); add(); \n    d += I(r()); add(); \n    d += K(r()); add(); \n    d += U(r()); add();\n    d += N(r()); add();\n    d += J(r()); add(); \n    d += S(r()); add(); \n    d += H(r()); add(); \n    d += A(r()); add(); space();\n    d += F(r()); add(); \n    d += I(r()); add(); \n    d += L(r()); add(); \n    d += M(r()); add();\n    d += S(r()); add();\n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.3,.4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 ) + texture(iChannel0, xy).rgb;\n    fragColor = vec4( col, 0.5 ) + vec4(uv,0.5+0.5*sin(iTime),0.5);\n}\n\n", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2GWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2714, 2800, 2848, 2911, 3590], [3592, 3678, 3723, 3723, 4067], [4069, 4155, 4185, 4185, 4269], [4271, 4389, 4427, 4427, 4520], [4522, 4608, 4618, 4618, 4721], [4723, 4809, 4821, 4821, 4840], [4842, 4928, 4942, 4942, 4961], [4963, 5049, 5065, 5065, 5111], [5200, 5223, 5280, 5280, 6404]]}
{"id": "Ws2GWy", "name": "Bad looking Shader", "author": "cbrpnk", "description": "It's pretty ugly but I had to put something out to not break my streak.", "tags": ["asd"], "likes": 1, "viewed": 71, "published": "Public", "date": "1549939309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat caps(vec3 p, float r, float l)\n{\n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat map(vec3 p)\n{\n    p.xz *= rot(iTime);\n    //p.yz *= rot(iTime);\n    p.x += iTime;\n    float a = 2.5;\n    p = mod(p+vec3(5.), 10.)-vec3(5.);\n    \n    p = abs(p);\n    float d = 1000.;\n    for(int i=0; i<2; ++i) {\n        p.xz *= rot(a);\n    \tp.yz *= rot(a);\n        p.xy *= rot(.4*a);\n        p.x += float(i)*.1;\n        p.y += float(i)*float(i)*.1;\n        for(int j=0; j<6; ++j) {\n            p.x *= float(j);\n            //p.xy *= rot(a);\n            p.y += sin(p.x)*.05;\n            p.x *= sin(a);\n\t\t\td = min(d, max(max((caps(p, .5, .5) + .2), p.y), -caps(p, .2, .4)));\n        }\n    }\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .001) break;\n        if(t > 100.) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 eye = vec3(0., 0., 5.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    vec3 normal = getNormal(p);\n    vec3 col = normal;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2GWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 135, 135, 195], [197, 197, 216, 216, 811], [813, 813, 844, 844, 1016], [1018, 1018, 1042, 1042, 1230], [1232, 1232, 1289, 1339, 1714]]}
{"id": "ws2Gz3", "name": "Migraine 1977", "author": "PianiGiani", "description": "This is not very pleasant", "tags": ["horrible"], "likes": 1, "viewed": 101, "published": "Public", "date": "1549575351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*200.;\n    \n    float nTime=iTime*6.;\n    \n    float s = sin(nTime*.05);\n    float c = cos(nTime*.051);\n    uv*=mat2(c, -s, s, c); \n    \n    \n    float col1=tan(sin(uv.y)+cos(uv.x));\n    float col2=tan(sin(uv.y)+sin(uv.x+sin(nTime)));\n    float col3=tan(sin(uv.x)+cos(uv.y+sin(nTime)));\n    \n    fragColor = vec4(col1,col2,col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2Gz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 481]]}
{"id": "ws2Gzt", "name": "Arcs 3d", "author": "theepicsnail", "description": "3d version of https://www.shadertoy.com/view/td2GzR", "tags": ["arcs"], "likes": 4, "viewed": 95, "published": "Public", "date": "1549773356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS .001\n#define STEPS 120\n#define FAR_CLIP 100.0\nvec2 cossin(float f){ return vec2(cos(f), sin(f)); }\nvec2 rotate(vec2 xy, float f) {\n    vec2 cs = cossin(f);\n    return mat2x2(cs.x, -cs.y, cs.y, cs.x) * xy;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nmat2x2 rotate(float t) { \n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c,-s,s,c);\n}\n\n\nstruct SDF_RESULT {\n    vec4 params;\n    float best_dist;\n    int id;\n} sdf_result;\n\nstruct CAST_RESULT {\n    vec3 ro;\n    vec3 rd;\n    vec3 end;\n    float total_dist;\n    bool hit;\n} cast_result;\n\nbool update(float dist) {\n    if(dist < sdf_result.best_dist) {\n        sdf_result.best_dist = dist;\n        return true;\n    }\n    return false;\n}\n\n\nvec3 mirror(vec3 vin, vec3 pos, vec3 norm) {\n    //  v = i - 2 * n * dot(i n) .\n    float d = dot((vin - pos), norm);\n    return pos + (\n        (vin - pos) - (1.0+sign(d)) * norm * d\n    );\n    return reflect(vin-pos, norm)+pos;\n}\nfloat sdf(vec3 pos) {\n    sdf_result.best_dist = FAR_CLIP;\n    sdf_result.id = -1;\n\t\n    //if(update(length(pos.xy-vec2(1,0))-.1)) {\n//        sdf_result.params.xyz = vec3(1,0,0);\n//    }\n    update(sdSphere(pos, 1.));\n    \n    return sdf_result.best_dist;\n}\n\n\nvec2 eps = vec2(EPS, 0);\nvec3 sdf_normal(vec3 pos) {\n    return normalize(vec3(\n        sdf(pos - eps.xyy)-sdf(pos + eps.xyy),\n        sdf(pos - eps.yxy)-sdf(pos + eps.yxy),\n        sdf(pos - eps.yyx)-sdf(pos + eps.yyx)));\n}\n\n\nfloat min3(vec3 a) { return min(min(a.x,a.y),a.z);}\nfloat max3(vec3 a) { return max(max(a.x,a.y),a.z);}\nvec3 colorize(vec3 dir) {\n    vec3 o = dir;\n    dir-=min(min3(dir),0.);\n    dir/=max(1., max3(dir));\n    \n    return dir;\n}\n\nvec3 color() {\n    return sdf_result.params.xyz;\n}\n\nvec3 lighting() {\n    float f = cast_result.total_dist/FAR_CLIP;\n    vec3 n = sdf_normal(cast_result.end);\n    return vec3(1.0-sqrt(f)) * dot(cast_result.rd, n);\n}\n\nvoid cast_ray(vec3 ro, vec3 rd) {\n    \n    cast_result.ro = ro;\n    cast_result.rd = rd;\n    cast_result.hit = false;\n    \n    vec3 pos = ro;\n    float total_dist = 0.0;\n    for(int i = 0 ; i < STEPS ; i ++) {\n        float dist = sdf(pos);\n        if(dist < eps.x) {\n            cast_result.hit = true;\n        \tbreak;\n        }\n        \n        total_dist += dist;\n        pos += dist * rd;\n        \n        if(total_dist > FAR_CLIP) {\n            total_dist = FAR_CLIP;\n            break;\n        }\n    }   \n    \n    cast_result.total_dist = total_dist;\n    cast_result.end = pos;\n}\n\nvec3 movement(vec3 i) {\n   \n    i.xz = i.xz * rotate(cos(iTime)*.5);\n    i.xy = i.xy * rotate(iTime*.5);\n \treturn i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = movement(vec3(-5, 0, 0));\n    \n    vec3 rd = movement(normalize(vec3( 1.8, uv)));\n    \n    cast_ray(ro, rd);\n    \n    \n    fragColor.rgb = colorize(sdf_normal(cast_result.end)); //color() * lighting();\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2Gzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 110], [111, 111, 142, 142, 218], [219, 219, 252, 252, 317], [318, 318, 349, 349, 499], [500, 500, 533, 533, 559], [561, 561, 598, 598, 619], [621, 621, 664, 664, 686], [688, 688, 732, 732, 753], [755, 755, 779, 779, 853], [1054, 1054, 1079, 1079, 1201], [1204, 1204, 1248, 1283, 1435], [1436, 1436, 1457, 1457, 1694], [1722, 1722, 1749, 1749, 1921], [1924, 1924, 1944, 1944, 1975], [1976, 1976, 1996, 1996, 2027], [2028, 2028, 2053, 2053, 2151], [2153, 2153, 2167, 2167, 2203], [2205, 2205, 2222, 2222, 2368], [2370, 2370, 2403, 2403, 2955], [2957, 2957, 2980, 2980, 3075], [3077, 3077, 3134, 3134, 3427]]}
{"id": "wsB3D3", "name": "Colliding Blocks Calculate Pi", "author": "Flyguy", "description": " Based on this video by 3Blue1Brown: https://youtu.be/brU5yLm9DZM\n", "tags": ["math", "pi", "physics", "block"], "likes": 14, "viewed": 532, "published": "Public API", "date": "1550199295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Constants\nfloat pi = atan(1.0)*4.0;\n\n//System Parameters\nfloat timescale = 0.1;\n\n//m1 = 100^(n-1) where n = # of pi digits \n//Precision issues show up at 4 digits (100^3).\nfloat m1 = 10000.0; \nfloat m2 = 1.0;\n\nfloat m1size = 0.6;\nfloat m2size = 0.2;\n\nfloat m1pos = 0.80;\nfloat m2pos = 0.60;\n\n//Rendering\nvec4 gridcol1 = vec4(0.2);\nvec4 gridcol2 = vec4(0.4);\nfloat gridsize = 10.0;\n\nvec4 m1col = vec4(0.5,0.5,0.9,0);\nvec4 m2col = vec4(0.8,0.6,0.4,0);\n\nvec4 textcol = vec4(1);\nvec2 textsize = vec2(0.2);\n\nvec2 shadowoffs = vec2(0.03);\n\n//Cartesian coordinates to polar coordinates.\nvec2 cart2pol(vec2 uv)\n{\n\treturn vec2(length(uv), atan(uv.y, uv.x));\n}\n\n//Polar coordinates to cartesian coordinates.\nvec2 pol2cart(vec2 ra)\n{\n    return ra.x * vec2(cos(ra.y), sin(ra.y));\n}\n\n//Repeat (mod) x in range -r/2 to +r/2\nfloat rep(float x, float r)\n{\n\treturn mod(x + r/2.0, r) - r/2.0;   \n}\n\n//Print integer v\nfloat PrintInt(vec2 p, float v, vec2 uv, vec2 size)\n{\n    uv -= p;\n    v = abs(floor(v));\n    vec2 t = floor(uv / size);\n    float ox = (1.0 - (size.x/size.y))/2.;\n    uv = mod(uv, size) / size.y;\n    uv.x += ox;\n    float dl = max(1.0,1.0 + floor(log(v) / log(10.0)));\n    if(t.y == 0.0 && t.x >= 0.0 && t.x < dl)\n    {\n        float d = mod(floor(v / pow(10.0, dl - t.x - 1.0)), 10.0);\n        \n        return texture(iChannel0, ((uv + vec2(d,12))/16.0), -100.0).r;\n    }\n    return 0.0;\n}\n\n//Simulate a reflecting ray of light by repeating/mirroring UVs.\n//Returns the x position of m1 (x) and m2 (y) at time t.\n//Count = the # of collisions at time t.\nvec2 simulate(float t, out float count)\n{\n    vec2 uv = vec2(m1pos - t, m2pos - m2size);\n    uv *= sqrt(vec2(m1, m2)); \n    \n    //The angle pf the line to mirror the UVs about.\n    float refang = atan(sqrt(m2), sqrt(m1));\n    \n    vec2 pol = cart2pol(uv);\n    count = floor(pol.y / refang); //Number of collisions.\n    \n    pol.y = rep(pol.y, refang*2.0); //Polar repeat UVs by refang/2.\n    vec2 uvr = pol2cart(pol);\n    uvr.y = abs(uvr.y); //Mirror repetitions about center.\n    \n    uvr /= sqrt(vec2(m1, m2));\n    \n    return uvr + m2size; \n}\n\nfloat dfSquare(vec2 pos, float size, vec2 uv)\n{\n    uv = abs(uv - pos);\n\treturn (size/2.0) - max(uv.x, uv.y); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 res = iResolution.xy/iResolution.y;\n    float ps = 1.0 / iResolution.y;\n    \n    float count = 0.0;\n    vec2 p1p2 = simulate(iTime*timescale, count);\n    \n    vec2 m1uv = vec2(p1p2.x + m1size/2.0, m1size/2.0);\n    vec2 m2uv = vec2(p1p2.y - m2size/2.0, m2size/2.0);\n    \n    vec2 grid = abs(fract(uv*gridsize)-0.5);\n    \n    //Grid background\n    vec4 col = mix(gridcol1,\n                   gridcol2,\n                   smoothstep(0.5-ps*gridsize,0.5, max(grid.x, grid.y))\n                   );\n    \n    //Shadows\n    col *= mix(1.0, \n               0.5, \n               smoothstep(0.0, ps, dfSquare(m1uv-shadowoffs, m1size, uv))\n             );\n    \n    col *= mix(1.0, \n               0.5, \n               smoothstep(0.0, ps, dfSquare(m2uv-shadowoffs, m2size, uv))\n             );\n    \n    col *= mix(1.0, \n               0.5, \n               PrintInt(vec2(0, res.y - textsize.y)-shadowoffs, count, uv, textsize)\n             ); \n    \n    col *= texture(iChannel1,uv,0.5).rrrr * 0.2 + 0.8;\n    \n    //Blocks/Text\n    col = mix(col, \n              m1col * (texture(iChannel1,uv-m1uv,0.5).rrrr * 0.2 + 0.8), \n              smoothstep(0.0, ps, dfSquare(m1uv, m1size, uv))\n             );\n    \n    col = mix(col, \n              m2col * (texture(iChannel1,uv-m2uv,0.5).rrrr * 0.2 + 0.8), \n              smoothstep(0.0, ps, dfSquare(m2uv, m2size, uv))\n             );\n    \n    col = mix(col, \n              textcol, \n              PrintInt(vec2(0, res.y - textsize.y), count, uv, textsize)\n             ); \n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsB3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[536, 582, 606, 606, 652], [654, 700, 724, 724, 772], [774, 813, 842, 842, 882], [884, 902, 955, 955, 1393], [1395, 1558, 1599, 1599, 2104], [2106, 2106, 2153, 2153, 2218], [2220, 2220, 2277, 2277, 3861]]}
{"id": "WsB3Dd", "name": "Candyman LL", "author": "Sciman101", "description": "Candyman from Lethal League", "tags": ["sdf"], "likes": 1, "viewed": 86, "published": "Public", "date": "1550253633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 headColor = vec3(.9,.9,0);\nconst vec3 mouthColor = vec3(.9,.2,0);\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n//Thanks iq\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - .1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    p.y = -p.y;\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nint mat;\n\n//Main scene functon\nfloat scene(vec3 p) {\n\n   //Head and mouth\n   float sphere = sdSphere(p,3.);\n    \n   vec3 q = p;\n   q.y *= 1.+abs(sin(iTime));\n   float wedge = sdTriPrism(q+vec3(-3,.5,0),vec2(2,5));\n    \n   //Hat\n    q = p;\n    q -= vec3(-.25,2.6,0);\n    q.xy = rotate(q.xy,-.15);\n   float hat = sdCappedCylinder(q,vec2(2.,.15));\n    hat = min(hat,sdSphere(q,1.5));\n    \n   //Eyes\n   p.z = abs(p.z);\n   float eyes = sdSphere(p+vec3(-1.5,-1.5,-1.5),1.);\n    \n    //Put it all together\n    \n   float result = max(sphere,-wedge);\n   result = min(result,eyes);\n    result = min(result,hat);\n    \n    if (result == sphere) {\n        mat = 0;\n    }else if (result == eyes){\n        mat = 2;\n    }else{\n        mat = 1;\n    }\n    \n   return result;\n    \n}\n\n//rotate and cameraspin from yx\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, -.3);\n    p.xz = rotate(p.xz, 17.+sin(iTime));\n}\n\nvec3 trace(vec3 cam, vec3 dir) {\n    //Perform raytrace\n    float t = 0.;\n    float k = 0.;\n    float closest = 500.;\n    vec3 h;\n    for(int i=0;i<100;++i) {\n        k=scene(cam+dir*t);\n        t+=k;\n        closest = min(k,closest);\n        if(k<.001)\n        {\n            h = cam+dir*t;\n            vec2 o=vec2(.02,0);\n            vec3 n= normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n\n            float light = dot(n,normalize(vec3(1,2,3)))*.5+1.0;\n            light = step(0.1,light);\n            \n            if (mat == 0) {\n                return headColor*light;\n            }else if (mat == 2) {\n                \n                //Pupils dynamically follow camera\n                \n                float d = dot(n,-dir);\n                \n                return vec3(1.-step(abs(1.-d),.05))*light;\n                \n                \n            }else if (mat == 1) {\n                return mouthColor*light;\n            }\n        }\n    }\n    \n    if (closest < .1) {\n        return vec3(0);\n    }else return vec3(.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n\n    //Multiply by aspect\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Define camera position and direction\n    vec3 cam = vec3(0,0,10);\n    vec3 dir = normalize(vec3(uv,-1));\n    \n    cameraspin(cam);\n    cameraspin(dir);\n    \n    fragColor.rgb = trace(cam,dir);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsB3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 111, 111, 139], [142, 154, 183, 183, 277], [279, 279, 315, 315, 418], [420, 420, 462, 462, 561], [563, 563, 615, 615, 714], [716, 716, 746, 746, 869], [881, 902, 923, 944, 1634], [1636, 1668, 1699, 1699, 1772], [1774, 1774, 1806, 1829, 2926], [2929, 2929, 2986, 3041, 3366]]}
{"id": "wsB3Dt", "name": "flareflake", "author": "uada", "description": "a flare snowflake", "tags": ["fract"], "likes": 2, "viewed": 77, "published": "Public", "date": "1550267492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\n\n#define PI 3.1415926\n#define TWO_PI (PI * 2.)\n\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv-p);\n    \n    return smoothstep(r,r-blur,d);\n}\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 8\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 1.2;\n        amplitude *= .66;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    float c1 = Circle(uv,vec2(.0,.0),.3,.3);\n\n    float c2 = Circle(uv,vec2(.0,.0),.5,.5);\n    for (float i = 0.; i < TWO_PI; i+=.9)\n    {\n        c1 += Circle(uv,vec2(0.+sin(i+iTime)*fbm(uv+iTime)*0.2,0.+cos(i+iTime)*fbm(uv+iTime)*0.2),.2,.1);\n    }\n    for (float i = 0.; i > -TWO_PI; i-=.4)\n    {\n        c1 += Circle(uv,vec2(0.+sin(i-iTime)*fbm(uv+iTime)*.4,0.+cos(i-iTime)*fbm(uv+iTime)*.4),.1,.1);\n    }\n    \n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.3*cos(iTime+uv.xyx+vec3(2,1,0));\n    vec3 col2 = 0.5 + 0.2*sin(iTime+uv.xyx+vec3(0,1,2));\n    col1*=col2;\n    //c1+=c2;\n    // Output to screen\n    fragColor = vec4(vec3(c1*col1),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsB3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 105, 105, 175], [177, 177, 199, 199, 271], [273, 273, 299, 299, 679], [699, 699, 723, 745, 1001], [1003, 1003, 1060, 1110, 1868]]}
{"id": "WsB3Wc", "name": "Pewdiepie swirl", "author": "ducklett", "description": "Still very new to shaders, pls be gentle", "tags": ["waves", "animated", "background", "pewdiepie"], "likes": 7, "viewed": 1457, "published": "Public API", "date": "1550088522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//subscribe to pewdiepie\n\nvec2 rot(vec2 uv, float r) {\n    float sinX = sin (r);\n    float cosX = cos (r);\n    float sinY = sin (r);\n    mat2 rotationMatrix = mat2( cosX, -sinX, sinY, cosX);\n    return uv *rotationMatrix;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 7.;\t\t//stripes\n    float st = 0.2;\t\t//stripe thickness\n\n    vec2 uv = rot(fragCoord/iResolution.xy, -0.2+sin(iTime)*0.05);\n\n    float osc = sin(uv.x*(uv.x+.5)*15.)*0.2;\n    uv.y += osc * sin(iTime+uv.x*2.);\n    uv.y = fract(uv.y*s);\n    \n    vec3 bg = vec3(.8,.2,.3);\n    vec3 fg = vec3(.05,.05,.1);\n    \n    float mask = smoothstep(0.5, 0.55, uv.y);\n    mask += smoothstep(0.5+st,0.55+st, 1.-uv.y);\n    \n    vec3 col = mask*bg + (1.-mask)*fg;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsB3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 54, 54, 223], [225, 225, 282, 282, 798]]}
{"id": "WsBGDm", "name": "Dreambox", "author": "thiagoborn", "description": "I was trying to make a mandelbox, but I don't know what I'm doing :p\nBy pure luck while trying I made this :p\nIn the end it's a wrong mandelbox but a correct DREAMBOX \\o/\n\nobs: If anyone know what's wrong with the code please comment :p", "tags": ["procedural", "clouds", "mandelbox", "dream"], "likes": 10, "viewed": 423, "published": "Public API", "date": "1549037125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float eps = 0.0001;\nint steps = 32;\nfloat minDist = 0.01;\nfloat maxDist = 10.0;\nfloat delta = 1.0;\n\nfloat foldingLimit = 1.0;\nconst float minRadius =  0.5;\nconst float minRadius2 = minRadius*minRadius;\n\nconst float fixedRadius = 1.0;\nconst float fixedRadius2 = fixedRadius*fixedRadius;\n\nint Iterations = 5;\nfloat Scale = 1.5;\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nfloat mandelbox(vec3 z)\n{\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tboxFold(z,dr);       \n\t\tsphereFold(z,dr);    \n\t\tz=Scale*z + offset;  \n        dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\nfloat world(vec3 p){\n  return mandelbox(p);\n}\n    \nfloat trace(vec3 origin,vec3 direction){\n    float distTraveled = minDist;\n   \n    for(int i=0;i<steps;i++){\n   \t\tvec3 point = origin + direction * distTraveled;\n        float dist = world(point);\n        if(dist<eps){\n            return distTraveled;\n        }\n       \tdistTraveled += dist * delta;\n       \n    }\n    return distTraveled;\n}\n\nfloat shadow(vec3 ro,vec3 rd,float mint,float maxt,float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = world(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal(vec3 p) {   \n    return normalize(vec3(\n        world(vec3(p.x + eps, p.y, p.z)) - world(vec3(p.x - eps, p.y, p.z)),\n        world(vec3(p.x, p.y + eps, p.z)) - world(vec3(p.x, p.y - eps, p.z)),\n        world(vec3(p.x, p.y, p.z  + eps)) - world(vec3(p.x, p.y, p.z - eps))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv  = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 lookingTo = vec3(0.,0.,0.);\n    float it = iTime / 10.;\n    vec3 viewer = vec3(\n        0.1+sin(it/2.5) * 1.,\n        0.2+cos(it/3.0) * 1.,\n        sin(it/3.5) * 1.\n    );\n    \n    vec3 forward = normalize(lookingTo-viewer);\n    vec3 rigth = cross(vec3(0.0,1.0,0.0),forward);\n    vec3 up = cross(forward,rigth);\n    \n    vec3 direction = normalize(forward *2.0 + rigth * uv.x + up * uv.y);\n    float dist = trace(viewer,direction); \n\tvec3 color = vec3(0.0);    \n\tfloat fog = 1.0 / (1.0 + dist);\n    color = vec3(fog);\n\tfragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 374, 374, 650], [652, 652, 696, 696, 752], [754, 754, 779, 779, 1004], [1006, 1006, 1026, 1026, 1051], [1057, 1057, 1097, 1097, 1397], [1399, 1399, 1460, 1460, 1790], [1792, 1792, 1817, 1817, 2088], [2090, 2090, 2147, 2147, 2826]]}
{"id": "wsBGRt", "name": "Infinite Lines", "author": "SwaginWagon", "description": "Just another thing I thought was cool. Second shader", "tags": ["geometry"], "likes": 2, "viewed": 291, "published": "Public API", "date": "1549664434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy ;\n    \n    uv.x += 0.*iTime;\n    uv.x -= iResolution.x/2.;\n    uv.y += iResolution.y/2.;\n    \n    uv.y = iResolution.y - uv.y;\n    //uv.xy/= .1;\n    uv.x += 100.*iTime;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    \n   // vec4 color = colormap(float(int(uv.x + 0.*iTime)%int(uv.y))/(iResolution.y * 0.03));\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    if (int(uv.x)%int(uv.y) == 0)\n   \t\tcolor = vec4(1.0,1.0,1.0,1.0);\n    \n    if (uv.y < 0.)\n        color = vec4(0.0,0.0,0.0,1.0);\n//    if (int(uv.x)%int(uv.y) == 1)\n //  \t\tcolor = vec4(1.0,1.0,0.0,1.0);\n //   if (int(uv.x)%int(uv.y) == 2)\n  // \t\tcolor = vec4(1.0,0.0,0.0,1.0);\n   // if (int(uv.x)%int(uv.y) == 3)\n  //      color = vec4(1.0,0.0,1.0,1.0);\n  //   if (int(uv.x)%int(uv.y) == 4)\n  // \t\tcolor = vec4(1.0,1.0,0.0,1.0);\n  //   if (int(uv.x)%int(uv.y) == 5)\n  // \t\tcolor = vec4(0.0,1.0,0.0,1.0);\n //    if (int(uv.x)%int(uv.y) == 6)\n //  \t\tcolor = vec4(1.0,0.0,0.0,1.0);\n    \n    //float depth = 100.;\n    \n    //for (float i = 0.; i < 20.; i++)\n    //    if (uv.x >= i*depth && uv.x <= i*depth+1.)\n    //    \tcolor = vec4(1.0,1.0,0.0,1.0);\n    \n    //for (float i = 0.; i < 20.; i++)\n\t//\tif (uv.y >= i*depth && uv.y <= i*depth+1.)\n    //    \tcolor = vec4(1.0,1.0,0.0,1.0);\n        \n   \n    \n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 115, 1492]]}
{"id": "wsBGWd", "name": "analytical ray-sink intersec 2", "author": "FabriceNeyret2", "description": "analytical ray-intersection, allowing free antialiasing and all 2D-shaders goodies.\nTry changing #slice()\n\nMouse controls shape (or auto-demo ).", "tags": ["cubic", "polynomial", "tuto", "solve", "degree3"], "likes": 12, "viewed": 393, "published": "Public API", "date": "1550268485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/tsBGWt\n// analytical ray - sink intersection ( solving cubic polynomial ).\n\n// sink shape: P.z = m / ( h + |P.xy|²)  ; solve with ray P = P0+lD\nfloat m =  1.,       // amplitude factor\n      h = 1./3.,     // inv heap\n    opa = .3;        // layers opacity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime-9.2;\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n         M = iMouse.z > 0. ? iMouse.xy / R \n                           : vec2(.4+.3*sin(4.7*t),.5+.5*cos(t));\n\n  O-=O;\n  for (float i=0.; i<2.; i+=.1) {\n        \n    m = 20.*M.x  * (1.-i);\n    h = m/M.y/4. / (1.-i);\n    \n    // --- set camera     \n    vec3 P = .8*vec3(0., 5.5, 6),\n      look = normalize( vec3(0,0,1.7) - P ),\n     right = normalize(cross(look, vec3(0,0,1))),\n        up = cross( right, look ),\n         D = normalize( look*3. + U.x*right + U.y*up );\n   \n    // --- Solving a*x³ +b*x³ +c*x +d = 0. -> l = min(3 solutions)\n    // using \"solving cubic polynomial\"  https://shadertoy.com/view/3d23Dc\n    // here: ( h + P² +2lP.D + l²D²)xy * (P  + lD)z = m\n    float a =   dot(D.xy,D.xy)*D.z,\n          b = ( dot(D.xy,D.xy)*P.z +2.*dot(P.xy,D.xy)*D.z ) /a, \n          c = ( dot(P.xy,P.xy)*D.z +2.*dot(P.xy,D.xy)*P.z +h*D.z ) /a, \n          d = ( dot(P.xy,P.xy)*P.z +h*P.z - m ) /a,\n        p = ( 3.*c - b*b ) / 3.,\n        q = ( 9.*b*c - 27.*d - 2.*b*b*b) / 27., // -\n        Q = p/3., r = q/2., \n        v,z, l, A, k = -1.;\n    \n    if ( Q*Q*Q + r*r < 0.) {                    // --- if 3 sol\n        A = acos(r/sqrt(-Q*Q*Q)), \n        k = round(1.5-A/6.283); // k = 0,1,2 ; we want min l\n#define sol(k) ( 2.*sqrt(-Q)* cos((A+(k)*6.283)/3.) - b/3. )\n        l = sol(k);\n    }\n    else                                        // --- if 1 sol\n        if (p>0.) v = -2.*sqrt(p/3.), \n#define asinh(z) ( sign(z)*asinh(abs(z)) )      // fix asinh() symetry error \n                  l = -v* sinh(asinh(3.*-q/p/v)/3.) -b/3.; \n        else      v = -2.*sqrt(-p/3.), \n                  l = sign(-q)*v* cosh(acosh(3.*abs(q)/p/v)/3.) -b/3.;\n\n    // --- display layer\n\n//#define slice(P)  ( true )\n//#define slice(P)  ( (P).y < 0. )\n//#define slice(P)  ( mod(floor((P).y-t),2.) == 0. )\n//#define slice(P)  ( mod(floor((P).x-t),2.) == 0. )\n//#define slice(P)  ( mod(floor((P).x+(P).y-t),2.) == 0. )\n//#define slice(P)  ( mod(floor(6.*(P).z-t),2.) == 0. )\n//#define slice(P)  ( mod( floor((P).x)+floor((P).y) ,2.) == 0. )\n//#define slice(P)  ( length( mod((P).xy-1. ,2.) -1.) < .8 )\n  #define slice(P)  ( length( mod((P).xy ,2.) -1.) > .8 )\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) ) // https://www.shadertoy.com/view/ll2cDc\n        \n    for( float j = 0.; j < 3.; j++ ) { // front + \"hidden\" parts\n        vec3 P2 = P + l*D,\n              X = 1. - abs(.5-fract(4.*P2))/fwidth(4.*P2);\n        X = smoothstep(-.75,.75, X/fwidth(X) ); \n        v = max(X.x,X.y);              // grid\n        if slice(P2) O += (1.-O.a) \n                    // * v;\n                       * vec4( max( hue(i), v ) *exp(-.2*l)*2. , 1) * opa;\n        if (k<0.) break;               // there is just one layer\n        l = sol(mod(k++,3.));\n    }\n\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 300, 338, 338, 3178]]}
{"id": "WsBGzK", "name": "fractal foundation flythrough", "author": "public_int_i", "description": "fractal foundation realtime raytraced scene", "tags": ["fractal", "raymarch", "raytraced", "realtime", "foundations"], "likes": 18, "viewed": 443, "published": "Public API", "date": "1549299127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define EPSILON 1e-2\n#define REFLECTION_EPSILON 4e-2\n#define NORMAL_PRECISION 1e-3\n\nvec2 rot(vec2 v, float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(co,-si,si,co);\n}\nmat2 rot2(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co,-si,si,co);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n//from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat ruins(vec3 p) {\n    vec3 rp = p;\n    float d = 0.;\n    float s = 20.;\n    \n    for (int i = 0; i < 3; i++) {\n        rp -= s/8.;\n        d = max(-sdBox(mod(abs(rp), s*2.)-s, vec3(s*.9)), d);\n        \n        if (mod(float(i),2.) > 0.) {\n            rp.xz = abs(rot(rp.xz,float(i)*1.8+1.5));\n        } else {\n            rp.zy = abs(rot(rp.zy,float(i)*1.2+0.5));\n        }\n        \n    \ts /= 2.;\n    }\n                       \n    return max(d,p.y);\n}\n\nfloat distf(vec3 p) {\n\treturn ruins(p);\n}\n\nvec3 normf(vec3 p, float bd) {\n\treturn normalize(vec3(distf(p+vec3(NORMAL_PRECISION,0,0))-bd,\n\t\t\t\t\t\t  distf(p+vec3(0,NORMAL_PRECISION,0))-bd,\n\t\t\t\t\t\t  distf(p+vec3(0,0,NORMAL_PRECISION))-bd));\n}\n\nfloat ambientOcclusion(vec3 arp, vec3 nrm, const int iter) {\n\tfloat asum = 0., as = .1;\n\tfor (int i = 0; i < iter; i++) {\n\t\tfloat adst = distf(arp);\n\t\tasum += max(0.,1.-adst/as);\n\t\tarp += nrm*adst;\n\t\tas += adst;\n\t}\n\treturn pow(clamp(1.-asum*.07,0.,1.),1./2.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    \n\t//initial ray parameters\n\tvec4 hsh = hash(uv.xyyx*vec4(1,1,.3,.3));\n\tvec3 rp = vec3(cos(iTime*.044)*100.,-40.+sin(iTime*.05+.5)*20.,0.),\n\t\trd = normalize(vec3(uv+(hsh.xy-.5)/iResolution.xy,1.));\n\tmat2 rang = rot2(iTime*.04);\n\trp.xz *= rang;\n\trd.xz *= rang;\n\trp += rd*(5.+hsh.z*2.0);\n\t\n\t//raytracing\n\tvec3 orp = rp;\n\tfloat eps = EPSILON;\n\tfor (int i = 0; i < 64; i++) {\n\t\tfloat dst = distf(rp);\n\t\tif (dst < eps) break;\n\t\trp += rd*dst;\n\t\teps *= 1.1;\n\t}\n\t\n\t#define depthl(p) clamp(p.y*.01+1.,0.,1.)\n\t#define bgl(rd) max(0.,rd.y)\n\t#define fogl(v,len,rd) mix(v,bgl(rd),min(1.,len/200.))\n\t\n\tfloat bdst = distf(rp);\n\tif (bdst < eps) {\n\t\trp -= rd*eps*5.;\n\t\trp += rd*distf(rp)*.7;rp += rd*distf(rp)*.7;\n\t\tvec3 nrm = normf(rp,distf(rp));\n\t\tfloat sv = 0.;\n\t\t\n\t\t//reflection\n\t\tvec3 reflDir = reflect(rd,nrm), reflp = rp+reflDir*REFLECTION_EPSILON*2.;\n\t\tfloat reps = REFLECTION_EPSILON, reflectionAmount = (1.-max(0.,dot(rd,-nrm)))*.5;\n\t\tfor (int i = 0; i < 32; i++) {\n\t\t\tfloat dst = distf(reflp);\n\t\t\tif (dst < reps) break;\n\t\t\treflp += reflDir*dst;\n\t\t\treps *= 1.1;\n\t\t}\n\t\tif (distf(reflp) < reps) {\n\t\t\treflp -= reflDir*reps*5.;\n\t\t\treflp += reflDir*distf(reflp)*.7;reflp += reflDir*distf(reflp)*.7;\n\t\t\tvec3 reflNrm = normf(reflp,distf(reflp));\n\t\t\tfloat rl = ambientOcclusion(reflp,reflNrm,16);\n\t\t\trl *= depthl(reflp);\n\t\t\trl = fogl(rl,length(reflp-rp),reflDir);\n\t\t\tsv += rl*reflectionAmount;\n\t\t} else sv += bgl(reflDir)*reflectionAmount;\n\t\t\n\t\t//ambient occlusion\n\t\tsv += ambientOcclusion(rp,nrm,16)*(1.-reflectionAmount);\n\t\tsv *= depthl(rp);\n\t\tsv = fogl(sv,length(rp-orp),rd);\n\t\tfragColor = vec4(sv);\n\t} else {\n\t\tfragColor = vec4(max(0.,rd.y));//background\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 162, 191, 191, 276], [277, 277, 297, 297, 366], [368, 368, 387, 387, 488], [490, 569, 602, 602, 667], [668, 668, 699, 699, 737], [738, 738, 769, 769, 865], [866, 866, 918, 918, 1045], [1046, 1046, 1082, 1082, 1168], [1169, 1169, 1210, 1210, 1303], [1304, 1304, 1344, 1344, 1383], [1385, 1385, 1406, 1406, 1840], [1842, 1842, 1863, 1863, 1883], [1885, 1885, 1915, 1915, 2078], [2080, 2080, 2140, 2140, 2341], [2343, 2343, 2398, 2398, 4109]]}
{"id": "wsBGzy", "name": "2019-02-03", "author": "Justaway", "description": "chaos", "tags": ["chaos"], "likes": 1, "viewed": 83, "published": "Public", "date": "1549171776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float[150] coef = float[150](-0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n                       -0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n                       0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n                       -0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n                        -0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114);\n\nfloat[30] c;\n\nvec3 Dmap(vec3 v, vec3 d){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0] + c[3]*y + c[5]*z + 2.0*c[6]*x*d.x + 1.0;\n    newV.y = c[11] + c[13]*x +c[14]*z + 2.0*c[17]*y*d.y + 1.0;\n    newV.z = c[22] + c[24]*y + c[25]*x + 2.0*c[28]*z*d.z + 1.0;\n    return newV;\n}\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*47343.0+2687.0,679.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    \n    vec3 V = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    T[0] = float(floor(iTime/5.0));\n    T[1] = T[0]+1.0;\n    float t = smoothstep(0.0,1.0,fract(iTime/5.0));\n    float perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    float T2[2];\n    T2[0] = floor(iTime/5.0);\n    T2[1] = T2[0] + 1.0;\n    float t2 = smoothstep(0.0,1.0,fract(iTime/5.0));\n    perm = permute(permute(T2[0]));\n    int coefIndex[2];\n    coefIndex[0] = int(mod(perm, 5.0));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, 5.0));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    uv*=10.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    //vec3 av;\n    int i = 0;\n    vec3 D = vec3(0.0);\n    //float m2;\n    #define ITER 100\n    for(i = 0; i < ITER; i++)\n    {\n        //D = Dmap(V,D);\n        V = map(V);\n        //m2 = mod2(V);\n        //av += normalize(V);\n        if(length(V)>1e7f) break;\n    }\n    //av /= float(ITER);\n\n    vec4 col;\n    \n    float m = length(V);\n    float mu = float(i) - log(log(m))/log(2.0);\n    //vec3 norm = normalize(av);\n    \n    mu = abs(mu);\n    if(mu > 1.0){\n        mu = 1.0/mu;\n    }\n    \n    col = vec4(mu);\n    //col.x = min(col.x,abs(norm.x));\n    //col.y = min(col.y,abs(norm.y));\n    //col.z = min(col.z,abs(norm.z));\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1706, 1706, 1732, 1732, 2130], [2132, 2132, 2149, 2149, 2704], [2706, 2706, 2726, 2726, 2764], [2766, 2766, 2790, 2790, 2830], [2832, 2832, 2889, 2889, 4761]]}
{"id": "wsfSDN", "name": "Color Fade Pattern", "author": "IceSelkie", "description": "Was messing around with the default colors, while trying to build a ray marcher, so it has some elements of both.\n\n(Ray marcher this is based off from http://youtu.be/PGtv-dBi2wE and https://www.shadertoy.com/view/XlGBW3 )", "tags": ["color", "glow", "screensaver"], "likes": 1, "viewed": 259, "published": "Public API", "date": "1551329453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXDIST 500.\n\nfloat f = 1.;\n\nstruct obj\n{\n    vec3 loc;\n    float size_max;\n    int type;\n    vec4 size;\n};\n    \nobj objs[5];\n\nfloat getDist(vec3 pt, obj object)\n{\n    return 1.;\n}\nfloat getDist(vec3 pt)\n{\n    float d[objs.length()];\n    for (int i = 0; i<objs.length(); i++)\n        d[i]=getDist(pt,objs[i]);\n    float mind = MAXDIST;\n    \n    for (int i = 0; i<objs.length(); i++)\n        if (mind>d[i]) \n            mind=d[i];\n    return mind;\n}\n    \nfloat getLight(vec3 pt)\n{\n    return pt.z-1.;\n}\n\nvec3 getColor(vec3 pt)\n{\n    pt.z=pt.x+pt.y*.3;\n    return 0.5 + 0.5*cos((.3*iTime*vec3(1.,.95,1.06))+pt.xyz*.2);;\n}\n\nfloat march(vec3 origin, vec3 dir, float maxdist)\n{\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (to -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Camera location & look direction\n    vec3 cam = vec3(0,0,1);\n    vec3 look = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = march(cam,look,MAXDIST);\n    vec3 pt = cam+d*look;\n    vec3 col = getLight(pt)*getColor(pt);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor.xyz = col.xyz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 171, 171, 188], [189, 189, 213, 213, 456], [462, 462, 487, 487, 509], [511, 511, 535, 535, 627], [629, 629, 680, 680, 696], [698, 698, 755, 804, 1243]]}
{"id": "WsfSRn", "name": "Underground Maze", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarching"], "likes": 7, "viewed": 125, "published": "Public", "date": "1550363273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 d)\n{\n    p = abs(p) - d;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat map(vec3 p)\n{\n    p.xz *= rot(iTime*.2);\n    p.xz = mod(p.xz, 2.)-vec2(1.);\n    float g = min(min(max(box(p-vec3(0., 1., 0.), vec3(1.)), -sphere(p, 1.2)), sphere(p, .3)), p.y-.05);\n   \t\n    p = abs(p);\n    return g + texture(iChannel1, p.xz+p.y*3., .0).r * .02 + texture(iChannel1, p.xy+p.z, .0).r * .04;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .001 || t > 200.) break;\n        t += d*.5;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2. - iResolution.xy) / iResolution.y; // Thanks FabriceNeyret2\n    vec3 cam = vec3(0, .2, 1.);\n    vec3 dir = normalize(vec3(uv, -1.));\n    float d = march(cam, dir);\n    vec3 p = cam+dir*d;\n    vec3 normal = getNormal(p);\n\n    // Time varying pixel color\n    vec3 col = .3/d*pow(1.-max(0., dot(normal, -dir)), 10.) *vec3(1., 1., .85);\n\tcol += vec3(.02);\n    col *= max(0., dot(normal, vec3(1., 1., 1.)));\n    col /= d*d;\n    col.r += pow(col.g, 2.);\n    col.g += d*.002;\n    col.b += d*.007;\n    \n    // Output to screen\n    col *= 1.-length(uv)*.3;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 124, 124, 182], [184, 184, 215, 215, 243], [245, 245, 264, 264, 557], [559, 559, 590, 590, 749], [751, 751, 775, 775, 961], [963, 963, 1020, 1070, 1685]]}
{"id": "WsfSWN", "name": "Square the rainbow", "author": "Chosen", "description": "I'd love to understand what is happening here!", "tags": ["rainbow"], "likes": 3, "viewed": 66, "published": "Public", "date": "1551245178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BAND .07\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ROYGBIV\n    const vec3 colours[7] = vec3[7](\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, 0.5, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n        vec3(0.293, 0.0, 0.5),\n        vec3(0.578, 0.0, 0.824)\n    );\n\n    float cycle = iTime * .02;\n    float scale = .4 + 150. * sin(cycle) * sin(10.*cycle);\n    vec3 col = vec3(0);\n    int x, y;\n\n    for(x = -1; x != 2; ++x){\n        for(y = -1; y != 2; ++y){\n            vec2 uv = (fragCoord + vec2(x, y) - vec2(.5) * iResolution.xy) / scale;\n            float r = length(uv);\n            float theta = atan(uv.x, uv.y) / 6.283185;\n\n            // Square the rainbow - nb: I have no idea what I'm doing\n\t\t\tcol = mix(col, colours[int(mod(r * (r + cycle * scale), BAND * 7.) / BAND)], .5);\n        }\n    }\n\n    fragColor = vec4(sqrt(col), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfSWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 90, 920]]}
{"id": "wsfXR4", "name": "RayTracing Tutorial - Step 3", "author": "BrunoLevy", "description": "Let there be light !", "tags": ["raytracing", "tutorial"], "likes": 1, "viewed": 340, "published": "Public API", "date": "1550694543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n};\n\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, vec3(0.0, 0.0, 0.0));\n}\n\nMaterial light(in vec3 Ke) {\n   return Material(vec3(0.0, 0.0, 0.0), Ke);\n}\n\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\nObject scene[3];\n\nvoid init_scene() {\n   float beta = float(iFrame)/30.0;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5), \n      diffuse(vec3(1.0, 1.0, 1.0))\n   );\n\n   scene[1] = Object(\n      Sphere(vec3(0.7*s, 0.7*c, 0.0),0.1), \n      diffuse(vec3(1.0, 0.0, 0.0))\n   );\n\n   scene[2] = Object(\n      Sphere(vec3(5.0, 0.0, 3.0),0.02),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n\n//   scene[3] = Object(\n//      Sphere(vec3(1.5, 0.0, 1.5),0.02),\n//      light(vec3(1.0, 1.0, 1.0)) \n//   );\n\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n \nvec3 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         vec3 E = scene[i].sphere.Center - P;\n         float lamb = max(0.0, dot(E,N) / length(E));\n         result += lamb * material.Kd * scene[i].material.Ke;\n       }\n   }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, fragCoord);\n   \n   \n   fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n\n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t) \n          && cur_t < t\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       } \n   }\n\n   if(t != FARAWAY) {\n      fragColor.rgb = lighting(P,N,material);\n   }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 281, 281, 579], [581, 581, 618, 618, 715], [848, 848, 878, 878, 925], [927, 927, 955, 955, 1002], [1082, 1082, 1101, 1101, 1616], [1618, 1618, 1677, 1677, 1943], [1946, 1946, 2005, 2005, 2466], [2468, 2468, 2525, 2525, 3274]]}
{"id": "WsfXWH", "name": "Zig zags", "author": "Chosen", "description": "Noob jamming with trig", "tags": ["retro", "quick"], "likes": 3, "viewed": 125, "published": "Public", "date": "1551132233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float angle = iTime;\n    vec2 origin = vec2(0.5, 0.5);\n    uv -= origin.xy;\n    origin.y = 20.0*cos(iTime)*origin.y;\n    vec2 rot = vec2(uv.x * cos(angle) - uv.y * sin(angle),\n                    uv.x * sin(angle) + uv.y * cos(angle));\n    rot += origin.xy;\n    \n    vec3 col = vec3(cos(rot.y+cos(20.0*rot.x+iTime)+iTime),\n                    cos(rot.y+cos(20.0*rot.x+iTime)),\n                    cos(rot.y+cos(20.0*rot.x+iTime)-iTime));\n    \n\n    // Output to screen\n    fragColor = vec4(sqrt(col),0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 691]]}
{"id": "wsfXzH", "name": "Noisy grid deformation", "author": "Simplyfire", "description": "first I made a grid and then I only showed parts of it based on noise and then I displaced the whole thing based on the same noise so it has a kind of a 3d feel to it", "tags": ["noise", "grid"], "likes": 11, "viewed": 259, "published": "Public", "date": "1550586451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Krab\t\n// Title: Functions\n\n#define PI 3.14159265359\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    vec4 w, d;\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    w = max(0.6 - w, 0.0);\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    w *= w;\n    w *= w;\n    d *= w;\n    return dot(d, vec4(52.0));\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 rgb( in vec3 hsb){\n    vec3 rgb = clamp(abs(mod(hsb.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return hsb.z * mix(vec3(1.0), rgb, hsb.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.);\n        \n    float noiseScl = 10.5;\n    float n = snoise(vec3(uv.x*noiseScl, uv.y*noiseScl, t));\n    \n    uv += .08*n;\n    \n    float modScl = .05;\n    uv = mod(uv, modScl);\n    float pulseX = cubicPulse(modScl*.5, 0.012, uv.x);\n    float pulseY = cubicPulse(modScl*.5, 0.012, uv.y);\n    \n    float pct = 0.;\n    pct += n*pulseX;\n    pct += n*pulseY;\n    pct = smoothstep(0., 1.0, pct);\n    pct = clamp(pct, .0, 1.);\n    \n    color += rgb(vec3(.6+pct*0.6, 1., pct));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 111, 158, 158, 252], [254, 254, 276, 276, 473], [533, 533, 555, 555, 1175], [1177, 1251, 1274, 1274, 1512], [1514, 1514, 1542, 1542, 1628], [1630, 1630, 1686, 1686, 2325]]}
{"id": "wsfXzr", "name": "Reflecting Heart", "author": "dr2", "description": "Based on \"Heart Function\", with analytical normals and reflection (mouseable)", "tags": ["reflection", "function", "surface"], "likes": 4, "viewed": 299, "published": "Public API", "date": "1550481398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Reflecting Heart\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar, a, b;\nconst float pi = 3.14159;\n\nfloat SurfDf (vec3 p)\n{\n// f(x,y,z) = (x^2 + ((1 + b) * y)^2 + z^2 - 1)^3 - x^2 * z^3 - a * y^2 * z^3\n  float v1, v2;\n  v1 = (1. + b) * p.y;\n  v2 = p.x * p.x + v1 * v1 + p.z * p.z - 1.;\n  return v2 * v2 * v2 - (p.x * p.x + a * p.y * p.y) * p.z * p.z * p.z;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  float v1, v2;\n  v1 = (1. + b) * p.y;\n  v2 = p.x * p.x + v1 * v1 + p.z * p.z - 1.;\n  return normalize (vec3 (6. * p.x * v2 * v2 - 2. * p.x * p.z * p.z * p.z,\n     6. * (1. + b) * v1 * v2 * v2 - 2. * a * p.y * p.z * p.z * p.z,\n     6. * p.z * v2 * v2 - 3. * (p.x * p.x + a * p.y * p.y) * p.z * p.z));\n}\n\nvec2 BallHit (vec3 ro, vec3 rd, float s)\n{\n  float dbIn, dbOut, b, d;\n  b = dot (rd, ro);\n  d = b * b + s * s - dot (ro, ro);\n  dbIn = dstFar;\n  dbOut = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    dbIn = - b - d;\n    dbOut = - b + d;\n  }\n  return vec2 (dbIn, dbOut);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec2 bnd;\n  float dHit, h, s, ds, sLo, sHi;\n  const float nDiv = 200.;\n  dHit = dstFar;\n  bnd = BallHit (ro, rd, 2.);\n  if (bnd.x < dstFar) {\n    s = bnd.x;\n    sLo = bnd.x;\n    ds = (bnd.y - bnd.x) / nDiv;\n    for (float j = 0.; j < nDiv; j ++) {\n      h = SurfDf (ro + s * rd);\n      if (h < 0. || s > bnd.y) break;\n      sLo = s;\n      s += ds;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (float j = 0.; j < 16.; j ++) {\n        s = 0.5 * (sLo + sHi);\n        if (SurfDf (ro + s * rd) > 0.) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nfloat BgPat (vec3 rd)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = max (max (tm.x, tm.y), tm.z) * rd;\n  q = mod (12. * vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.));\n  return min (SmoothBump (0.08, 0.92, 0.03, q.x), SmoothBump (0.08, 0.92, 0.03, q.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, vDotL, spec;\n  a = 0.5 + 0.45 * sin (1.5 * tCur);\n  b = 0.5 + 0.45 * sin (1.4 * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = SurfNf (ro);\n    vDotL =  max (dot (vn, ltDir), 0.);\n    col = vec3 (1., 0.8, 0.8) * (0.2 + 0.7 * vDotL * vDotL);\n    spec = 0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    rd = reflect (rd, vn);\n  } else {\n    col = vec3 (0.9, 0.9, 1.) * (0.4 + 0.1 * (rd.z + 1.) * (rd.z + 1.));\n    spec = 0.;\n  }\n  col = mix (col, vec3 (1.) * (0.4 + 0.6 * BgPat (rd)), 0.5) + spec * vec3 (1., 1., 0.5);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.6 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  } else {\n    az += 0.01 * pi * tCur;\n    el -= 0.1 * pi * sin (0.021 * pi * tCur);\n  }\n  ro = vec3 (0., 0.13, -7.);\n  ro.yz = Rot2D (ro.yz, el);\n  ro.xy = Rot2D (ro.xy, az);\n  dstFar = 20.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  ltDir.yz = Rot2D (ltDir.yz, el);\n  ltDir.xy = Rot2D (ltDir.xy, az);\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 5.));\n    rd.yz = Rot2D (rd.yz, el);\n    rd.xy = Rot2D (rd.xy, az);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfXzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 277, 300, 378, 535], [537, 537, 559, 559, 862], [864, 864, 906, 906, 1134], [1136, 1136, 1169, 1169, 1768], [1770, 1770, 1793, 1793, 2118], [2120, 2120, 2155, 2155, 2797], [2814, 2814, 2870, 2870, 4000], [4002, 4002, 4059, 4059, 4142], [4144, 4144, 4174, 4174, 4287]]}
{"id": "wsj3Dc", "name": "HaHaHa", "author": "winstonrenatan", "description": "Solar System 2D", "tags": ["sun", "earth", "solar"], "likes": 4, "viewed": 127, "published": "Public", "date": "1550201236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//PLANETS\n#define Sun vec3(1.0, 1.0, 0.0)\n#define Mercury vec3(0.96, 0.91, 0.72)\n#define Venus vec3(0.96, 0.82, 0.38)\n#define Earth vec3(0.62, 0.79, 0.37)\n#define Mars vec3(0.88, 0.82, 0.62)\n#define Jupiter vec3(0.84, 0.67, 0.53)\n#define Saturn vec3(0.89, 0.87, 0.64)\n#define Uranus vec3(0.01, 0.87, 0.96)\n#define Neptune vec3(0.0, 0.52, 0.89)\n\n//CIRCLE FUNCTION\nvoid drawCircle(vec2 uv, vec3 color, float radiusCircle, float blur, vec2 pos, inout vec3 image) {\n    float d = length(uv-pos);\n    if(d <= radiusCircle) {\n\t\timage.r = color.r*(1.0-smoothstep(radiusCircle-blur, radiusCircle, d));\n        image.g = color.g*(1.0-smoothstep(radiusCircle-blur, radiusCircle, d));\n        image.b = color.b*(1.0-smoothstep(radiusCircle-blur, radiusCircle, d));\n    }\n}\n\n//ROTATE FUNCTION\nvec2 Rotation(float distance, float multi) {\n    float x1 = distance*(cos(iTime*multi));\n    float y1 = distance*(sin(iTime*multi));\n    return vec2(x1,y1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) - 0.5;  // -0.5 <> 0.5\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3 c = vec3(0.0, 0.0, 0.0);\n    \n    float blurRate = 0.005;\n    float d = 0.0007; \t\t\t//Diameter\n    float dist = 0.000625; \t\t//Distance\n    float vel = 0.030*2.0;   \t//Velocity of planet times two   \n    \n    drawCircle(uv, Sun, 70.0*d, blurRate, vec2(0.0, 0.0), c);\n    drawCircle(uv, Mercury, 12.0*d, blurRate, Rotation(dist*188.0, vel*40.0), c);\n    drawCircle(uv, Venus, 26.0*d, blurRate, Rotation(dist*242.0, vel*35.0), c);\n\tdrawCircle(uv, Earth, 28.0*d, blurRate, Rotation(dist*300.0, vel*29.0), c);\n    drawCircle(uv, Mars, 28.0*d, blurRate, Rotation(dist*360.0, vel*24.0), c);\n    drawCircle(uv, Jupiter, 56.0*d, blurRate, Rotation(dist*485.0, vel*13.0), c);\n    drawCircle(uv, Saturn, 46.0*d, blurRate, Rotation(dist*610.0, vel*10.0), c);\n    drawCircle(uv, Uranus, 29.0*d, blurRate, Rotation(dist*700.0, vel*8.0), c);\n    drawCircle(uv, Neptune, 31.0*d, blurRate, Rotation(dist*780.0, vel*6.0), c);\n    \n\tfragColor += vec4(c, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsj3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 363, 461, 461, 761], [763, 781, 825, 825, 939], [941, 941, 998, 998, 2060]]}
{"id": "Wsj3Dd", "name": "LFO2", "author": "PianiGiani", "description": "Slowly changing pattern based on maths functions", "tags": ["patterns"], "likes": 2, "viewed": 73, "published": "Public", "date": "1550316882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set page size\n    vec2 uv = fragCoord/iResolution.xy*2.;\n    \n    //set speed\n    float nTime=iTime*.3;\n    \n    //rotate page\n    float s = sin(nTime*.1);\n    float c = cos(nTime*.1);\n    uv*=mat2(c, -s, s, c); \n    \n    //colour formulas\n    float nFact=10.+50.*(sin(nTime*.3)+1.);\n    float col1=radians((uv.x*uv.y)*nFact);\n    float col2=cos((uv.x+sin(uv.y))*nFact);\n    float col3=cos((uv.x*uv.y)*nFact);\n    \n    //apply colour\n    fragColor = mix(vec4(col1+col2+col3,col1,col1+col2+col3,1.0),vec4(col1,col1+col2+col3,col3,1.0),sin(nTime+uv.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsj3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 78, 618]]}
{"id": "Wsj3Dw", "name": "Attractor Sampling", "author": "Justaway", "description": "Sampling the 2d area surrounding chaotic 3d quadratic map attractors.", "tags": ["attractor"], "likes": 0, "viewed": 75, "published": "Public", "date": "1549049628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float[150] coef = float[150](-0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n                       -0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n                       0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n                       -0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n                        -0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114);\n\nfloat[30] c;\n\nvec3 Dmap(vec3 v, vec3 d){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0] + c[3]*y + c[5]*z + 2.0*c[6]*x;\n    newV.y = c[11] + c[13]*x +c[14]*z + 2.0*c[17]*y;\n    newV.z = c[22] + c[24]*y + c[25]*x + 2.0*c[28]*z;\n    return newV;\n}\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*x*4733.0+2687.0,6379.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    \n    vec3 V = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    T[0] = float(floor(iTime/5.0));\n    T[1] = T[0]+1.0;\n    float t = smoothstep(0.0,1.0,fract(iTime/5.0));\n    float perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    float T2[2];\n    T2[0] = floor(iTime/5.0);\n    T2[1] = T2[0] + 1.0;\n    float t2 = smoothstep(0.0,1.0,fract(iTime/5.0));\n    int coefIndex[2];\n    perm = permute(permute(T2[0]));\n    coefIndex[0] = int(mod(perm, 5.0));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, 5.0));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    uv*=3.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    int i = 0;\n    vec3 D = vec3(0.0);\n    float m2;\n    for(i = 0; i < 128; i++)\n    {\n        //D = Dmap(V,D);\n        V = map(V);\n        m2 = mod2(V);\n        if(m2>1e20) break;\n    }\n    \n    //float dist = sqrt(m2/mod2(D))*0.5*log(m2);\n\n    vec4 col;\n    \n    vec3 norm = normalize(V);\n    col.x = abs(norm.x);\n    col.y = abs(norm.y);\n    col.z = abs(norm.z);\n    \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsj3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1706, 1706, 1732, 1732, 2100], [2102, 2102, 2119, 2119, 2674], [2676, 2676, 2696, 2696, 2734], [2736, 2736, 2760, 2760, 2802], [2804, 2804, 2861, 2861, 4480]]}
{"id": "wsj3Wc", "name": "Glsl Valentine", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarchingmarcher"], "likes": 6, "viewed": 105, "published": "Public", "date": "1550187691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat heart(vec2 p)\n{\n    p.x = abs(p.x);\n    p.y *= 1.5;\n    p.x *= 1.2;\n    p.y -= p.x;\n    float c =(length(p) - .3);\n    return c / 2.;\n}\n\nfloat map(vec3 p)\n{\n    p.z -= iTime;\n    vec3 cell = floor(p*.5);\n    p.y += sin(cell.z);\n    p.xy *= rot(cell.z+iTime*.01);\n    p.xy *= rot(iTime*.08);\n    p = mod(p, 2.)-vec3(.8);\n    \n    float ay = abs(p.z) - .01;\n    float h = max(sqrt(pow(heart(p.xy)+.2, 2.) + pow(p.z, 2.)) - .2, ay);\n    \n    return h;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i)\n    {\n        float d = map(ro+rd*t);\n        if(d < .001+t*.03) break;\n        if(t > 30.) return -1.;\n        t += d*.6;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam = vec3(0, 0, 3.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    float d = march(cam, dir);\n    float h = heart(uv);\n    vec3 col;\n    \n    if(d < 0.) {\n        col = vec3(1., .6, .85);\n    } else {\n    \tcol = vec3(clamp(d*.05, .6, 1.));\n\t\tcol *= vec3(1., .3, .35) * clamp(d, 5., 100.) *.2;\n   \t\tcol.gb = pow(col.gb, vec2(1.4, 1.));\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsj3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 118, 118, 238], [240, 240, 259, 259, 553], [555, 555, 586, 586, 778], [780, 780, 837, 837, 1332]]}
{"id": "wsj3WG", "name": "experiment3", "author": "thoughtformmax", "description": "learning to raymarch from Art of Code", "tags": ["3d", "raymarching", "sphere"], "likes": 1, "viewed": 74, "published": "Public", "date": "1550301517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 16\t\n#define SURFACE_DIST .03\n#define MAX_DIST 8.\n\nfloat maxFract (vec3 p) {\n    //p.z = mod(p.z,16.);\n\t//p.z+=mod(iTime*2.,8.);\n    vec4 sphere = vec4 (sin(iTime),0.,2.,1.);\n    float d = length(p - sphere.xyz)-sphere.w;\n    for(float i = 0.; i < 6.; i++){\n        p.x =sin(p.y)+.19+mod(p.x,sin(iTime));\n    \tp.y += tan(p.z)+.17;\n    \tp.z += sin(p.y)+.11;\n        vec4 sphere2 = sphere + vec4 (2.*i,2.*i,2.*i,.1*i);\n        sphere2.y += sin(iTime*2.*i);\n        float d2 = length(p - sphere2.xyz)-sphere2.w;\n\t\td = min(d,d2);\n    }\n    return d;\n}\nfloat GetDist(vec3 p) {\n    float d = maxFract(p-vec3(0.,0.,6.));\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd) {//ray origin, ray direction\n    \n    float dO = 0.; \n    for(int i = 0; i< MAX_STEPS; i++){\n        vec3 p = ro+dO*rd;\n        float dS = GetDist(p); //distance to scene\n            dO += dS;\n        if(dS<SURFACE_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.01,0.);\n    float d = GetDist(p);\n    vec3 n = d - vec3 (\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n        );\n    return normalize(n);\n    \n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0.,5.,6.);\n    lightPos.xz += vec2(sin(iTime*1.),cos(iTime*1.)) * 2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURFACE_DIST*2.,l);//shadow\n    if(d<length(lightPos-p)) dif *= .3;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //camera\n    vec3 ro = vec3(0,1,0); //ray origin\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); //ray direction\n\n    float d = RayMarch (ro,rd);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);//diffuse light\n    \n    d /= 9.;\n    vec3 col = vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsj3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 93, 145, 564], [565, 565, 588, 588, 646], [647, 647, 681, 708, 945], [947, 947, 971, 971, 1168], [1170, 1170, 1194, 1194, 1509], [1511, 1511, 1568, 1618, 1996]]}
{"id": "WsjGDc", "name": "That's a Moiré!", "author": "bignobody", "description": "Watched a Numberphile video about Moiré patterns ( https://www.youtube.com/watch?v=QAja2jp1VjE ). Figured it would be fun to play with the idea in shaders.", "tags": ["noise", "moire"], "likes": 8, "viewed": 211, "published": "Public", "date": "1550171759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cgrid(vec2 dc)\n{\n \tvec2 sc = vec2(cos(dc.x * 50.0),sin(dc.y * 50.0));\n    //float r = sin(sc.x * sc.y + dc.x * dc.y); \n    float r = sin(sc.x * sc.y); \n    float a = cos(iTime * 0.5) - 0.5;\n    return vec3(r,r+a,r*a);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 pos = vec2(uv-vec2(0.5));\n    \n    pos.x *= aspect;\n    float t = iTime * 0.33;\n    float s = sin(length(pos));\n    mat2 m = mat2(cos(t),-sin(t),sin(t),cos(t));\n    mat2 sm = mat2(0.99,0.0,0.0,0.99);\n\n    vec3 col = cgrid(pos);\n\n    pos = pos * m;\n    pos = pos * sm;\n    \n    vec3 col2 = cgrid(pos);\n    \n    col = mix(col, col2,0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 227], [229, 229, 286, 336, 827]]}
{"id": "WsjGRd", "name": "Motorola Loading screen", "author": "ircss", "description": "Motorolas loading screen", "tags": ["procedural", "simple"], "likes": 11, "viewed": 451, "published": "Public API", "date": "1549735414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat Cricle(vec2 uv, vec2 center, float radius, float thickness, float seed){\n    \n    float dis = distance(center, uv);\n    vec2 centerToPixel =  uv -center;\n    float angle = atan(centerToPixel.y, centerToPixel.x);\n    \n    float s1 = sin(angle *5. -iTime + 512. + seed)*0.006;\n    float s2 = sin(angle *2. + iTime*1.8+ 21.+ seed)*0.008;\n    float noise = s1 + s2;\n    return 1.- smoothstep(thickness, thickness + 0.013,abs(dis -radius + noise));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    float r =  Cricle(uv, vec2((iResolution.x/iResolution.y)*0.5, 0.5), 0.3, 0.0065, 42.);\n    float g =  Cricle(uv, vec2((iResolution.x/iResolution.y)*0.5, 0.5), 0.3, 0.005, 18.);\n    float b =  Cricle(uv, vec2((iResolution.x/iResolution.y)*0.5, 0.5), 0.3, 0.0065, 71.);\n    vec3 col = vec3(r,g,b);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 80, 80, 458], [460, 460, 517, 567, 1038]]}
{"id": "wsjGWc", "name": "Chinese Style Pavilion", "author": "whaoran", "description": "Reference from IQ's knowledge of sdf and procedure techniques", "tags": ["3d", "raymarch"], "likes": 6, "viewed": 342, "published": "Public API", "date": "1550184352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float EPSILON = 1e-6;\nfloat STEPSIZE = 0.5;\nfloat MIN_MARCH_LEN = 1e-2;\nfloat MAX_MARCH_LEN = 1e2;\nint   MAX_MARCH_ITER = 64;\n\nvec3 lightVec = normalize(vec3(-2, 0.7, 0.0));\nvec3 lightCol = vec3(1.0, 1.0, 1.15);\nvec3 skyLitCol = vec3(0.16, 0.20, 0.28) / 2.0;\nvec3 indLitCol = vec3(0.3, 0.28, 0.2) / 2.0;\nvec3 lanternPos = vec3(0.0, 9.0, 0.0);\nvec3 lanternCol = vec3(1.0, 0.0, 0.0);\nfloat ambientLit = 0.05;\nvec3 ambientCol = vec3(1);\n\n// Noise\n///////////////////////////////////////////////////////\nvec3 c_seed = vec3(0);\nfloat PI = 3.14159265;\nfloat PI_2 = 6.2831853;\nfloat random1( vec2 p , vec2 seed) { return fract(sin(dot(p + seed, vec2(127.1, 311.7))) * 43758.5453); }\nfloat random1( vec3 p , vec3 seed) { return fract(sin(dot(p + seed, vec3(987.654, 123.456, 531.975))) * 85734.3545); }\nvec2 random2( vec2 p , vec2 seed) { return fract(sin(vec2(dot(p + seed, vec2(311.7, 127.1)), dot(p + seed, vec2(269.5, 183.3)))) * 85734.3545); }\n\nfloat falloff(float t) {\n  t = t * t * t * (t * (t * 6. - 15.) + 10.);\n  return t;\n}\n\nvec2 randGrad(vec2 p, vec2 seed) {\n  float randDeg = random1(p, seed) * PI_2;\n  return vec2(cos(randDeg), sin(randDeg));\n}\n\nfloat PerlinNoise(vec2 p, float s) {\n    p /= s;\n    vec2 pCell = floor(p);\n    p -= pCell;\n    float dotGrad00 = dot(randGrad(pCell + vec2(0., 0.), c_seed.xz), p - vec2(0., 0.));\n    float dotGrad01 = dot(randGrad(pCell + vec2(0., 1.), c_seed.xz), p - vec2(0., 1.));\n    float dotGrad10 = dot(randGrad(pCell + vec2(1., 0.), c_seed.xz), p - vec2(1., 0.));\n    float dotGrad11 = dot(randGrad(pCell + vec2(1., 1.), c_seed.xz), p - vec2(1., 1.));\n\n    return mix(mix(dotGrad00, dotGrad10, falloff(p.x)), mix(dotGrad01, dotGrad11, falloff(p.x)), falloff(p.y)) * .5 + .5;\n}\n\nfloat FBMPerlin(vec2 p, float minCell, int maxIter) {\n  float sum = 0.;\n  float noise = 0.;\n  for (int i = 0; i < maxIter; i++) {\n      noise += PerlinNoise(p, minCell * pow(2., float(i))) / pow(2., float(maxIter - i));\n      sum += 1. / pow(2., float(maxIter - i));\n  }\n  noise /= sum;\n  return noise;\n}\n\nvec2 sampleInCell(vec2 p) {\n  return random2(p, c_seed.xz) + p;\n}\n\nfloat worleyNoise(vec2 p, float s) {\n    // Which cell p belongs to\n    p /= s;\n    vec2 pCell = floor(p);\n\n    float min_dist = 1.;\n    for (int i = -1; i <= 1 ; i++) {\n        for (int j = -1; j <= 1; j++) {\n          vec2 sampleNoise = sampleInCell(pCell + vec2(i, j));\n          min_dist = min(min_dist, distance(sampleNoise, p));\n        }\n    }\n    float noise = clamp(min_dist, 0., 1.);\n    return noise;\n}\n\nfloat worleyNoiseOutline(vec2 p, float s) {\n    // Which cell p belongs to\n    p /= s;\n    vec2 pCell = floor(p);\n\n    float min_dist = 1.;\n    float sec_dist = 1.;\n    for (int i = -1; i <= 1 ; i++) {\n        for (int j = -1; j <= 1; j++) {\n          vec2 sampleNoise = sampleInCell(pCell + vec2(i, j));\n          float dist = distance(sampleNoise, p);\n          if (dist < min_dist) { sec_dist = min_dist; min_dist = dist; }\n          else if (dist < sec_dist) { sec_dist = dist; }\n        }\n    }\n    float noise = clamp(sec_dist - min_dist, 0., 1.);\n    return noise;\n}\n\n// Transform Function\n///////////////////////////////////////////////////////\nvec3 rotX(vec3 p, float x) {\n  x = radians(x);\n  float c = cos(x);\n  float s = sin(x);\n  return vec3(p.x, c*p.y-s*p.z, s*p.y+c*p.z);\n}\n\nvec3 rotY(vec3 p, float y) {\n  y = radians(y);\n  float c = cos(y);\n  float s = sin(y);\n  return vec3(c*p.x+s*p.z, p.y, -s*p.x+c*p.z);\n}\n\nvec3 rotZ(vec3 p, float z) {\n  z = radians(z);\n  float c = cos(z);\n  float s = sin(z);\n  return vec3(c*p.x-s*p.y, s*p.x+c*p.y, p.z);\n}\n\n// SDF\n///////////////////////////////////////////////////////\nfloat opExtrussion(vec3 p, float sdf, float h )\n{\n  vec2 w = vec2( sdf, abs(p.z) - h );\n  return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec3 opCheapBendX(vec3 p, float w)\n{\n  float c = cos(w*p.y);\n  float s = sin(w*p.y);\n  mat2  m = mat2(c, s, -s, c);\n  return vec3(p.x, m * p.yz);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriangleIsosceles( vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    \n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  \n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdRoundCone(vec3 p, float h, float r1, float r2)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n  \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n      \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x), p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// UV Map\n///////////////////////////////////////////////////////\nvec3 uvCylinder(vec3 p, vec2 h) {\n  if (p.y > -h.y && p.y < h.y) {\n    return vec3(degrees(atan(p.z, p.x)) / 180.0, p.y / h.y, 0.5);\n  }\n  else {\n    return vec3(p.x / h.x, p.z / h.x, 0.0);\n  }\n}\n\nvec3 uvHexPrism( vec3 p, vec2 h ) {\n  if (p.z > -h.y && p.z < h.y) {\n    float a = degrees(atan(p.y, p.x));\n    vec2 _p = rotZ(vec3(p.xy, 0.0), -floor((a+120.0)/60.0) * 60.0).xy;\n    return vec3(1.732051 * _p.x / _p.y, p.z / h.y, 0.5);\n  }\n  else {\n    return vec3(p.x/h.x, p.y/h.x, 0.0);\n  }\n}\n\n// Map Function\n////////////////////////////////////////////////////////\nfloat mapCeiling(vec3 pos, out vec3 uvflag) {\n  float r = 0.3;\n  float l = 4.5;\n  float r0 = 0.25;\n  float l0 = 4.0;\n  float d = MAX_MARCH_LEN;\n  float halfWidth = 4.0;\n  float angle = degrees(asin(clamp(halfWidth / l * 0.866025, -1.0, 1.0)));\n\n  vec3 po = pos;\n  vec3 pCol;\n  int flag = -1;\n\n  float a = degrees(atan(po.z, po.x));\n  vec3 p1 = rotY(po, floor((a+120.0)/60.0) * 60.0);\n  p1 = rotX(p1, -angle) + vec3(0.0, l, 0.0);\n  p1 = rotZ(p1 + vec3(0.0, -l, r), 180.0) - vec3(0.0, 0.0, r + 0.2);\n  float d1 = opExtrussion(p1, sdTriangleIsosceles(p1.xy, vec2(halfWidth, l * 2.0)), 0.2);\n  float dis = abs(cos(p1.x * 5.0)) * 0.1;\n  if (p1.z < 0.0) { d1 = d1 - dis; }\n  if (d > d1) { d = d1; flag = 1; }\n  \n  vec3 p2 = rotY(po, floor((a+90.0)/60.0) * 60.0);\n  float len = sqrt(halfWidth * halfWidth * 0.25 + l * l);\n  vec3 p3 = rotX(rotY(p2, 30.0), -angle * 1.1) + vec3(0.0, len * 1.9, 0.0);\n  float d3 = sdRoundCone(p3, len * 1.9, 0.8 * r, r);\n  d3 = smin(d3, sdRoundCone(opCheapBendX(rotX(p3 + vec3(0.0, r, 0.0), -30.0), 0.5) + vec3(0.0, 2.0, 0.0), 2.0, 0.0, 0.8 * r), 15.0);\n  if (d > d3) { d = d3; flag = 2; }\n  \n  vec3 p4 = rotY(p2 + vec3(0.0, 9.0, 0.0), 30.0) + vec3(0.0, 0.0, 6.0);\n  float d4 = sdCylinder(p4, vec2(r0, l0));\n  if (d > d4) { d=d4; flag=3; }\n\n  switch(flag) {\n  case -1: break;\n  case 0: break;\n  case 1: uvflag = vec3(pos.x, pos.y, 1.0); break;\n  case 2: uvflag = vec3(pos.x, pos.y, 2.0); break;\n  case 3: uvflag = uvCylinder(p4, vec2(r, l)) + vec3(0.0, 0.0, 3.0); break;\n  }\n  return d;\n}\n\nfloat mapBase(vec3 pos, out vec3 uvflag) {\n  int flag = -1;\n  float d = MAX_MARCH_LEN;\n\n  vec3 p0 = rotX(pos, 90.0);\n  float r0 = 6.0;\n  float l0 = 1.0;\n  float d0 = sdHexPrism(p0, vec2(r0, l0));\n  if (d > d0) { d=d0; flag=0; }\n\n  switch(flag) {\n  case -1: break;\n  case 0: uvflag = uvHexPrism(p0, vec2(r0, l0)) + vec3(0.0, 0.0, 4.0);  break;\n  }\n  return d;\n}\n\nfloat mapWater(vec3 pos, out vec3 uvflag) {\n  vec2 q = vec2(FBMPerlin(pos.xz + vec2(iTime * 0.5,0.), 0.5, 4) + iTime * 0.1,\n                FBMPerlin(pos.xz + vec2(20., 5.), 0.5, 4));\n  float n = pow(FBMPerlin(pos.xz + 5.0 * q, 0.5, 4), 2.0);\n  uvflag = vec3(pos.x, pos.z, 5.0 + n);\n  return pos.y - n * 0.7;\n}\n\nfloat map(vec3 pos, bool lightVisible, out vec3 uvflag)\n{\n  vec3 p = pos;\n  vec3 uv;\n  float d = MAX_MARCH_LEN;\n  float d0 = mapCeiling(p - vec3(0.0, 13.0, 0.0), uv);\n  float ds = sdCylinder(p - vec3(0.0, 17.0, 0.0), vec2(10.0, 7.0));\n  d0 = opSubtraction(ds, d0);\n  if(d > d0) { d=d0; uvflag=uv; }\n  float d1 = opIntersection(ds, mapCeiling((p - vec3(0.0, 15.5, 0.0)) / 0.7, uv) * 0.7);\n  if(d > d1) { d=d1; uvflag=uv; }\n  float d2 = mapBase(p, uv);\n  if(d > d2) { d=d2; uvflag=uv; }\n  float d3 = mapWater(pos + vec3(0.0, 1.0, 0.0), uv);\n  if(d > d3) { d=d3; uvflag=uv; }\n  if (lightVisible) {\n    float d4 = sdSphere(pos - lanternPos, 1.0);\n    if(d > d4) { d=d4; uvflag=vec3(0.0, 0.0, 7.0); }\n  }\n  return d;\n}\n\n// Normal Calculation\n// Reference from http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n////////////////////////////////////////////////////////\n#define ZERO (min(iTime,0.0))\nvec3 calcNormal(vec3 pos, vec3 uv) {\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=int(ZERO); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h, false, uv);\n    }\n    return normalize(n);\n}\n\n\n// Ray Marching Funtion\n// Reference from https://www.shadertoy.com/view/4lyfzw\n////////////////////////////////////////////////////////\nbool rayMarch(in vec3 ori, in vec3 dir, out vec3 uvflag, out vec3 p, out float d) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_MARCH_ITER; i++) {\n    p = ori + t * dir;\n    d = map(p, true, uvflag);\n    if (t > MAX_MARCH_LEN || d < MIN_MARCH_LEN * t) {\n      break;\n    }\n    t += d * STEPSIZE;\n  }\n  return t < MAX_MARCH_LEN;\n}\n\n// Visual Effect\n// Reference from http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n////////////////////////////////////////////////////////\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n  float res = 1.0;\n  vec3 uv;\n  for( float t=mint; t < maxt; )\n  {\n    float h = map(ro + rd*t, false, uv);\n    if( h < MIN_MARCH_LEN * t )\n      return 0.0;\n    res = min( res, k*h/t );\n    t += h * STEPSIZE;\n  }\n  return res;\n}\n\n// Render\n///////////////////////////////////////////////////////\nvec3 render(vec3 pos, vec3 uvflag, out vec3 norm) {\n  vec3 color;\n  if (uvflag.z < 0.0 + EPSILON) {\n      return vec3(0.0);\n  }\n  else if(uvflag.z < 1.0 + EPSILON) {\n    color = vec3(69.0, 88.0, 82.0) / 255.0;\n  }\n  else if(uvflag.z < 2.0 + EPSILON) {\n    color = vec3(98.0, 113.0, 102.0) / 255.0;\n  }\n  else if(uvflag.z < 3.5 + EPSILON) {\n    color = vec3(174.0, 14.0, 14.0) / 255.0;\n  }\n  else if(uvflag.z < 4.0 + EPSILON) {\n    vec2 q = vec2(FBMPerlin(uvflag.xy + vec2(0.,0.), 0.05, 4),\n                  FBMPerlin(uvflag.xy + vec2(2.,5.), 0.05, 4));\n    float n = FBMPerlin(uvflag.xy + 5.0 * q, 0.05, 4);\n    vec3 c0 = vec3(200.0, 200.0, 216.0) / 300.0;\n    vec3 c1 = vec3(210.0, 202.0, 191.0) / 330.0;\n    vec3 c2 = vec3(230.0, 238.0, 250.0) / 300.0;\n    vec3 col;\n    if (n < 0.3) { col = mix(c0, c1, n / 0.3); }\n    else if (n < 0.7) { col = mix(c1, c2, (n - 0.3) / 0.4); }\n    else { col = mix( c2, c0, (n - 0.7) / 0.3); }\n    color = col;\n  }\n  else if(uvflag.z < 4.5 + EPSILON) {\n    vec3 c0 = vec3(161.0, 164.0, 154.0) / 550.0;\n    vec3 c1 = vec3(200.0, 200.0, 216.0) / 300.0;\n    vec3 col = c1;\n    if (abs(uvflag.y) < 0.8) {\n      float n = smoothstep(0.0, 1.0, worleyNoiseOutline(uvflag.xy * vec2(3.0, 1.0), 0.4)) * 0.5 + 0.5;\n      col = mix(c0, c1, n);\n      if (abs(uvflag.y) > 0.5) {\n        col *= mix(1.0, 0.7, (abs(uvflag.y) - 0.5) / 0.3);\n      }\n    }\n    color = col;\n  }\n  else if(uvflag.z < 6.0 + EPSILON) {\n    color = mix(vec3(3., 7., 15.) / 255., vec3(12., 19., 36.) / 255., uvflag.z - 5.0);\n  }\n  else if(uvflag.z < 7.0 + EPSILON) {\n    color = lanternCol;\n    return color;\n  }\n\n  vec3 uv;\n  norm = calcNormal(pos, uv);\n  // ambient light\n  vec3 assembleCol = ambientLit * ambientCol;\n\n  // sun light\n  float sunTerm = clamp(dot(norm, lightVec), 0.0, 1.0);\n  vec3 shadowRay = lightVec;\n  float shadowTerm = softshadow(pos, shadowRay, MIN_MARCH_LEN + EPSILON, MAX_MARCH_LEN, 16.0 );\n  assembleCol += pow(vec3(shadowTerm), vec3(1.5, 1.2, 1.0)) * sunTerm * lightCol;\n\n  // sky light\n  float skyTerm = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n  assembleCol += skyTerm * skyLitCol;\n\n  // indirect light\n  float indTerm = clamp(dot(norm, lightVec * vec3(-1.0, 0.0, -1.0)), 0.0, 1.0);\n  assembleCol += indTerm * indLitCol;\n\n  // lantern\n  vec3 lanternRay = lanternPos - pos;\n  float le = length(lanternRay);\n  float lanternTerm = pow(1.0 / le, 2.0) * smoothstep(-0.8, 1.0, dot(norm, normalize(lanternRay)));\n  lanternRay = normalize(lanternRay);\n  float lanternShadowTerm = softshadow(pos, lanternRay, MIN_MARCH_LEN + EPSILON, le - EPSILON, 32.0 );\n  assembleCol += lanternShadowTerm * clamp(lanternTerm * 200.0, 0.0, 1.0) * lanternCol;\n\n  return assembleCol * color;\n}\n\n// Ray Casting Funtion\n///////////////////////////////////////////////////////\nvec3 rayCast(vec2 p, vec3 eye, vec3 ref, vec3 up) {\n  vec3 focusVector = ref - eye;\n  vec3 Right = normalize(cross(focusVector, up)) * iResolution.x / iResolution.y;\n  float len = length(focusVector) * 0.7;\n  return normalize(focusVector + len * p.x * Right + len * p.y * up);\n}\n\n// Schlick's Approximation for Fresnel Reflection\n///////////////////////////////////////////////////////\nfloat fresnelReflect(float n1, float n2, float cosTheta) {\n  float R0 = pow((n1 - n2) / (n1 + n2), 2.0);\n  return R0 + (1.0 - R0) * pow(1.0 - cosTheta, 2.5); // 5.0 for origin equation\n}\n\n// Sky Ramp\n///////////////////////////////////////////////////////\nvec3 skyRamp(vec3 dir) {\n  float cosUp = dir.y;\n  vec3 col1 = vec3(49., 58., 83.)/255.;\n  vec3 col2 = vec3(20., 34., 77.)/255.;\n  vec3 col3 = vec3(12., 19., 36.)/255.;\n  vec3 col4 = vec3(3., 7., 15.)/255.;\n\n  vec3 col;\n  if (cosUp < 0.0) {\n    col = col1;\n  }\n  else if (cosUp < 0.2) {\n    col = mix(col1, col2, cosUp / 0.2);\n  }\n  else if (cosUp < 0.5) {\n    col = mix(col2, col3, (cosUp - 0.2)/0.3);\n  }\n  else {\n    col = mix(col3, col4, (cosUp - 0.5)/0.5);\n  }\n\n  float dotMoon = dot(dir, lightVec);\n  if (dotMoon > 0.988) {\n    col = vec3(1);\n  }\n  else {\n    col = mix(col, vec3(1), smoothstep(0.97, 0.995, dotMoon));\n  }\n\n  return col;\n}\n\n// fog\n///////////////////////////////////////////////////////\nvec3 applyFog(vec3 pos, vec3 rgb, float distance )\n{\n    float fogAmount = 1.0 - exp( -distance * 3.0);\n    vec3  fogColor  = vec3(53., 68., 90.)/255.;\n    return mix(rgb, fogColor, fogAmount * (1.0 - smoothstep(0.0, 35.0, pos.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.1;\n    float r = 14.0 + 10.0 * smoothstep(-0.5, 0.5, sin(speed * iTime));\n    vec3 eye = vec3(r * sin(speed * iTime), 4.8, r * cos(speed * iTime));\n  \tvec3 ref = vec3(0.0, 2.8, 0.0);\n  \tvec3 forward = normalize(ref - eye);\n  \tvec3 up = normalize(vec3(0.0, 1.0, 0.0)-forward.y * forward);\n\n  \tvec3 dir = rayCast(fragCoord/iResolution.xy * 2.0 - 1.0, eye, ref, up);\n  \tvec3 skyCol = skyRamp(dir);\n  \tvec3 uvflag;\n  \tvec3 pos;\n \tvec3 col;\n  \tvec3 norm;\n  \tfloat d;\n  \tif(rayMarch(eye, dir, uvflag, pos, d)) {\n    \tcol = render(pos, uvflag, norm);\n    \tif (uvflag.z > 4.5 + EPSILON && uvflag.z < 6.0 + EPSILON) {\n      \tdir = -2.0 * norm * dot(norm, dir) + dir;\n      \tvec3 ori = pos;\n      \tfloat R = fresnelReflect(1.0, 1.33, dot(norm, dir));\n      \tfloat dd;\n      \tif (rayMarch(ori, dir, uvflag, pos, dd)) {\n        \tcol = mix(col, render(pos, uvflag, norm), R);\n      \t}\n      \telse {\n        \tcol = mix(col, skyRamp(dir), R);\n      \t}\n    \t}\n  \t}\n  \telse {\n    \td = MAX_MARCH_LEN;\n    \tcol = skyCol;\n  \t}\n  \tcol = applyFog(eye + d * dir, col, d);\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 570, 606, 606, 675], [676, 676, 712, 712, 794], [795, 795, 830, 830, 940], [942, 942, 966, 966, 1026], [1028, 1028, 1062, 1062, 1150], [1152, 1152, 1188, 1188, 1720], [1722, 1722, 1775, 1775, 2026], [2028, 2028, 2055, 2055, 2093], [2095, 2095, 2131, 2162, 2508], [2510, 2510, 2553, 2584, 3083], [3085, 3163, 3191, 3191, 3297], [3299, 3299, 3327, 3327, 3434], [3436, 3436, 3464, 3464, 3570], [3572, 3635, 3684, 3684, 3777], [3779, 3779, 3822, 3822, 3844], [3845, 3845, 3889, 3889, 3910], [3912, 3912, 3948, 3948, 4059], [4061, 4061, 4102, 4102, 4176], [4178, 4178, 4209, 4209, 4305], [4307, 4307, 4343, 4343, 4442], [4444, 4444, 4489, 4489, 4803], [4805, 4805, 4827, 4827, 4846], [4847, 4847, 4906, 4906, 5228], [5230, 5230, 5286, 5286, 5544], [5546, 5546, 5582, 5582, 5840], [5842, 5842, 5877, 5877, 5901], [5903, 5969, 6002, 6002, 6164], [6166, 6166, 6201, 6201, 6460], [6462, 6535, 6580, 6580, 8046], [8048, 8048, 8090, 8090, 8408], [8410, 8410, 8453, 8453, 8720], [8722, 8722, 8779, 8779, 9435], [9437, 9625, 9661, 9661, 9902], [9905, 10042, 10125, 10125, 10370], [10372, 10523, 10593, 10593, 10823], [10825, 10891, 10942, 10942, 13580], [13582, 13661, 13712, 13712, 13939], [13941, 14047, 14105, 14105, 14233], [14235, 14303, 14327, 14327, 14947], [14949, 15012, 15064, 15064, 15246], [15248, 15248, 15305, 15305, 16432]]}
{"id": "wsjGWt", "name": "Psycospace", "author": "AdrianPi", "description": "A pinch/punch folding/unfolding pattern", "tags": ["psycospace"], "likes": 2, "viewed": 68, "published": "Public", "date": "1550322451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;  \n    \n    float sx = 1. / 8. / iResolution.x;\n    float sy = 1. / 8. / iResolution.y;\n \n    vec3 color;\n    \n    float a = mod(iTime*0.1, 1.) * 2. * 3.141592;\n    \n    for(int i = 0; i < 8; i++)\n    {\n        for(int j = 0; j < 8; j++)\n        {\n            vec2 uv = ((fragCoord / iResolution.xy)-0.5) * 8.;\n            uv.x *= aspect;\n                       \n            vec2 uv2;\n            uv2.x = uv.x * cos(a) + uv.y * sin(a);\n            uv2.y = uv.x * -sin(a) + uv.y * cos(a);\n\n            vec2 dir = normalize(uv2);\n\n            uv2 -= dir * sin(iTime*0.1)*18.;\n\n            int ix = (mod(uv2.x,1.) < 0.2) ? 1 : 0;\n            int iy = (mod(uv2.y,1.) < 0.2) ? 2 : 0;\n\n            vec3 col = (ix | iy) != 0 ? vec3(1,1,0) : vec3(.5,0,1);\n            color += col;\n        }\n    }\n    \n    color *= (1./64.);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 984]]}
{"id": "WsjGWV", "name": "Tommy Oiseau", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarching"], "likes": 3, "viewed": 94, "published": "Public", "date": "1550019363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI    3.1415926535\n#define TWOPI 2.*PI\n#define HPI   PI/2.\n#define QPI   PI/4.\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat merge(float a, float b, float c)\n{\n\tfloat k = min(1., max(0., (b-a)/c + .5));\n    return ((k*a) + (1.-k)*b) - ((1.-k) * k * .3);\n}\n\nfloat caps(vec3 p, float r, float l)\n{\n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat torus(vec3 p, float r, float w)\n{\n    return sqrt(pow(length(p.xz)-r, 2.) + pow(p.y, 2.)) - w;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat map(vec3 p)\n{\n    float speed = 6.;\n    \n    float body = caps(vec3(p.x, p.y+sin(iTime*speed)*.2, p.z), 1., .5);\n    float legs = caps(vec3(abs(p.x)-.4, p.y+1.5+clamp(cos(iTime*speed+PI), -1., 0.)*.15, p.z), .2, .2);\n    float belly = sphere(vec3(p.x, p.y+.6+cos(iTime*speed+PI)*.1, p.z), 1.);\n    \n    // Arm\n    vec3 ap = p;\n    ap.x = abs(ap.x);\n    ap.xy *= rot(.6+sin(iTime*speed+QPI)*.07);\n    float arms = caps(ap-vec3(.7, -.9, 0.), .1, .2);\n    \n    // Mouth\n    float oMouth = torus(p.xzy-vec3(.0, 1., -sin(iTime*speed)*.2), .2, .1);\n    float cMouth = caps(p.yxz-vec3(-sin(iTime*speed)*.2, 0., 1.), .1, .15);\n    cMouth = min(cMouth, caps(p.yxz-vec3(-sin(iTime*speed)*.2+.1, 0., 1.), .1, .15));\n    float mouth = mix(cMouth, oMouth, smoothstep(.9, 1., sin(iTime*speed)));\n    \n    // Eyes\n    float eyes = sphere(vec3(abs(p.x)-.6, p.y-.25+sin(iTime*speed)*.2, p.z-.75), .12-smoothstep(.99, 1., sin(iTime*2.))*.1);\n    return min(min(merge(merge(merge(body, legs, .5), belly, .6), arms, .5), mouth), eyes);\n\t//return flo;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .001) break;\n        if(t > 1000.) return -1.;\n        t += d;\n    }\n    return t;\n}\n\nfloat sss(vec3 ro, vec3 rd)\n{\n    float t = .0;\n    for(int i=0; i<10; ++i)\n    {\n        vec3 p = ro+rd*.12*float(i);\n        float d = map(p);\n        t += d;\n    }\n    return max(0., t);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(0.001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 eye = vec3(0., 0., 5.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, -1.));\n    float d = march(eye, dir);\n    vec3 p = eye+dir*d;\n    vec3 col;\n    \n    if(d < 0.) {\n        col = vec3(.02);\n    } else {\n    \tvec3 normal = getNormal(p);\n        float s = sss(p, dir);\n        col = .5*vec3(1., 1., 0.);\n    \tcol += .4 * vec3(.8, .8, 1.) * max(0., dot(normal, vec3(1., 1., 1.)));\n        col += .3 * vec3(1., .6, .9) * max(0., dot(normal, vec3(-1., 1., 1.)));\n        col *= .4*col + 1.-max(0., dot(normal, vec3(0., 0., 1.)));\n        col += .1*pow(col + max(0., dot(normal, vec3(1., 0., 1.))), vec3(2.));\n        col = pow(col, vec3(3.));\n        col += .04*vec3(1., .2, 0.)*vec3(s);\n    }\n\n    // Output to screen\n    col *= 1.-length(uv);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 107, 107, 183], [185, 185, 225, 225, 321], [323, 323, 361, 361, 421], [423, 423, 462, 462, 525], [527, 527, 558, 558, 586], [588, 588, 607, 607, 1626], [1628, 1628, 1659, 1659, 1837], [1839, 1839, 1868, 1868, 2030], [2032, 2032, 2056, 2056, 2244], [2246, 2246, 2303, 2353, 3280]]}
{"id": "wsjGzd", "name": "cloud_004", "author": "kuma720", "description": "cloud", "tags": ["cloud"], "likes": 3, "viewed": 70, "published": "Public", "date": "1549803710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise( vec2 v ) {\n  return fract( sin ( dot( v , vec2( 78.123 , 36.1226 ) ) ) * 64.314 );\n}\n\nfloat pnoise( vec2 uv ) {\n\n  vec2 a = fract( uv );\n  a = a * a * ( 3. - 2. * a );\n\n  //dirc\n  vec2 uv2 = floor( uv );\n  float w0 = noise ( uv2 ) ;\n  float w1 = noise ( uv2 + vec2( 1. , 0. ) ) ;\n  float w2 = noise ( uv2 + vec2( 0. , 1. ) ) ;\n  float w3 = noise ( uv2 + vec2( 1. , 1. ) ) ;\n\n  float g0 = dot( vec2(w0) , ( a - vec2(0.,0.) ) ) ;\n  float g1 = dot( vec2(w1) , ( a - vec2(1.,0.) ) ) ;\n  float g2 = dot( vec2(w2) , ( a - vec2(0.,1.) ) ) ;\n  float g3 = dot( vec2(w3) , ( a - vec2(1.,1.) ) ) ;\n\n  float h0 = mix( g0 , g1 , a.x );\n  float h1 = mix( g2 , g3 , a.x );\n  float h2 = mix( h0 , h1 , a.y );\n\n  float h = h2 + .1;\n\n  return h;\n}\n\nfloat fbm( vec2 uv ) {\n  float a = pnoise( uv );\n  a += pnoise( uv * 2. ) * 0.5 ;\n//  a += pnoise( uv * 4. ) * 0.25 ;\n//  a += pnoise( uv * 8. ) * 0.125 ;\n//  a += pnoise( uv * 16. ) * 0.0625 ;\n  a += pnoise( uv * 32. ) * 0.03125 ;\n  return a;\n}\n\n\n\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\nfloat sdf( vec3 p ) {\n    float h = fbm( p.xz ) * .5 + .2;\n    vec3 p2 = vec3( p.x , h , p.z );\n\n    float l = p.y - p2.y;\n    return l;\n}\n\nvec3 createnormal(vec3 p) {\n  float e = 0.001;\n  return normalize( vec3(\n    sdf( vec3(p.x+e,p.y,p.z) ) - sdf( vec3(p.x-e,p.y,p.z) ) ,\n    sdf( vec3(p.x,p.y+e,p.z) ) - sdf( vec3(p.x,p.y-e,p.z) ) ,\n    sdf( vec3(p.x,p.y,p.z+e) ) - sdf( vec3(p.x,p.y,p.z-e) )\n  ));\n\n}\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 dir ) {\n\n  float len = 0.;\n  vec3 lightVec = vec3(1.,1.,1.);\n  vec3 lightColor = vec3( 0.7 , 0.5, 0.3 );\n\n  for ( int i = 0 ; i < 80 ; ++ i ) {\n    vec3 p = eye + dir * len;\n\n    float l = sdf( p );\n    len += length( l ) ;\n\n    if ( l < 0.01 ) {\n      vec3 n = createnormal( p );\n      float light = dot ( n , lightVec );\n      float sp = fbm( p.xz * .6 + iTime * .5 ) * 4.;\n      return vec4( vec3( light ) * sp * lightColor + vec3( 0.3,0.2,0.15) , 1. );\n    }\n\n  }\n\n  return vec4( 0. , 0. , 0. , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    float t = iTime * .1;\n    vec3 eye = vec3( cos(t) * 5. , 2. , sin(t) * 5. );\n   // vec3 eye = vec3( 5. , 5. , 5. );\n    vec3 center = vec3(0.,0.5,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n   fragColor = render( uv , eye , worldDir );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 97], [99, 99, 124, 124, 742], [744, 744, 766, 766, 989], [995, 995, 1041, 1041, 1231], [1234, 1234, 1297, 1297, 1423], [1426, 1426, 1447, 1447, 1564], [1566, 1566, 1593, 1593, 1831], [1834, 1834, 1880, 1880, 2379], [2382, 2382, 2439, 2439, 2893]]}
{"id": "WslGWl", "name": "Cloud raymarching", "author": "edo_m18", "description": "Cloud raymarching sample. This is cloned from https://www.shadertoy.com/view/lss3zr\n\nI also post an article of detail of this post.\nhttps://qiita.com/edo_m18/items/cbba0cc4e33a5aa3be55", "tags": ["raymarching", "cloud", "cineshader"], "likes": 61, "viewed": 95860, "published": "Public API", "date": "1549787641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------\n//\n// This post cloned from \"https://www.shadertoy.com/view/lss3zr\"\n//\n// I also refer this blog post below.\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\n//\n// This post is to learn how to cloud raymarching is working.\n//\n// ------------------------------------------\n\n#define USE_LIGHT 0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\n//////////////////////////////////////////////////\n\n///\n/// Sphere distance function.\n///\n/// But this function return inverse value.\n/// Normal dist function is like below.\n/// \n/// return length(pos) - 0.1;\n///\n/// Because this function is used for density.\n///\nfloat scene(in vec3 pos)\n{\n    return 0.1 - length(pos) * 0.05 + fbm(pos * 0.3);\n}\n\n///\n/// Get normal of the cloud.\n///\nvec3 getNormal(in vec3 p)\n{\n    const float e = 0.01;\n    return normalize(vec3(scene(vec3(p.x + e, p.y, p.z)) - scene(vec3(p.x - e, p.y, p.z)),\n                          scene(vec3(p.x, p.y + e, p.z)) - scene(vec3(p.x, p.y - e, p.z)),\n                          scene(vec3(p.x, p.y, p.z + e)) - scene(vec3(p.x, p.y, p.z - e))));\n}\n\n///\n/// Create a camera pose control matrix.\n///\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n///\n/// Main function.\n///\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 mo = vec2(iTime * 0.1, cos(iTime * 0.25) * 3.0);\n    \n    // Camera\n    float camDist = 25.0;\n    \n    // target\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Ray origin\n    //vec3 ori = vec3(sin(iTime) * camDist, 0, cos(iTime) * camDist);\n    vec3 ro = camDist * normalize(vec3(cos(2.75 - 3.0 * mo.x), 0.7 - 1.0 * (mo.y - 1.0), sin(2.75 - 3.0 * mo.x)));\n    \n    float targetDepth = 1.3;\n    \n    // Camera pose.\n    mat3 c = camera(ro, ta);\n    vec3 dir = c * normalize(vec3(uv, targetDepth));\n    \n    // For raymarching const values.\n    const int sampleCount = 64;\n    const int sampleLightCount = 6;\n    const float eps = 0.01;\n    \n    // Raymarching step settings.\n    float zMax = 40.0;\n    float zstep = zMax / float(sampleCount);\n    \n    float zMaxl = 20.0;\n    float zstepl = zMaxl / float(sampleLightCount);\n    \n    // Easy access to the ray origin\n    vec3 p = ro;\n    \n    // Transmittance\n    float T = 1.0;\n    \n    // Substantially transparency parameter.\n    float absorption = 100.0;\n    \n    // Light Direction\n    vec3 sun_direction = normalize(vec3(1.0, 0.0, 0.0));\n    \n    // Result of culcration\n    vec4 color = vec4(0.0);\n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n        // Using distance function for density.\n        // So the function not normal value.\n        // Please check it out on the function comment.\n        float density = scene(p);\n        \n        // The density over 0.0 then start cloud ray marching.\n        // Why? because the function will return negative value normally.\n        // But if ray is into the cloud, the function will return positive value.\n        if (density > 0.0)\n        {\n            // Let's start cloud ray marching!\n            \n            // why density sub by sampleCount?\n            // This mean integral for each sampling points.\n            float tmp = density / float(sampleCount);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            // Return if transmittance under 0.01. \n            // Because the ray is almost absorbed.\n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            #if USE_LIGHT == 1\n            // Light scattering\n            \n            // Transmittance for Light\n            float Tl = 1.0;\n            \n            // Start light scattering with raymarching.\n            \n            // Raymarching position for the light.\n            vec3 lp = p;\n            \n            // Iteration of sampling light.\n            for (int j = 0; j < sampleLightCount; j++)\n            {\n                float densityLight = scene(lp);\n                \n                // If densityLight is over 0.0, the ray is stil in the cloud.\n                if (densityLight > 0.0)\n                {\n                    float tmpl = densityLight / float(sampleCount);\n                    Tl *= 1.0 - (tmpl * absorption);\n                }\n                \n                if (Tl <= 0.01)\n                {\n                    break;\n                }\n                \n                // Step to next position.\n                lp += sun_direction * zstepl;\n            }\n            #endif\n            \n            // Add ambient + light scattering color\n            float opaity = 50.0;\n            float k = opaity * tmp * T;\n            vec4 cloudColor = vec4(1.0);\n            vec4 col1 = cloudColor * k;\n            \n            #if USE_LIGHT == 1\n            float opacityl = 30.0;\n            float kl = opacityl * tmp * T * Tl;\n            vec4 lightColor = vec4(1.0, 0.7, 0.9, 1.0);\n            vec4 col2 = lightColor * kl;\n            #else\n            vec4 col2 = vec4(0.0);\n            #endif\n            \n            color += col1 + col2;\n        }\n        \n        p += dir * zstep;\n    }\n    \n    vec3 bg = mix(vec3(0.3, 0.1, 0.8), vec3(0.7, 0.7, 1.0), 1.0 - (uv.y + 1.0) * 0.5);\n    color.rgb += bg;\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 461, 482, 482, 523], [525, 552, 576, 576, 1024], [1026, 1170, 1189, 1189, 1338], [1392, 1604, 1630, 1630, 1686], [1688, 1725, 1752, 1752, 2055], [2057, 2106, 2137, 2137, 2295], [2297, 2324, 2379, 2379, 6390]]}
{"id": "WslSRH", "name": "Blobacity", "author": "teraspora", "description": "Wild blobs", "tags": ["blobs"], "likes": 2, "viewed": 80, "published": "Public", "date": "1550603309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tBlobacity\n\tAuthor: John Lynch\n\tDate: Feb. 2019\n*/\n\n#define PI 3.14159265\nvec4 img;\nvec3 black = vec3(0.);\n\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// Colour fns.:\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n    \nfloat lightness(vec3 col) {\n    return rgb2hsl(col).b;\n}\n\nvec3 changeLightness(vec3 col, float newLightness) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.p = newLightness;\n    return hsl2rgb(colHSL);\n}\n    \nvec3 saturate(vec3 col) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.t = 1.0;\n    return hsl2rgb(colHSL);    \n}\n\nvec2 nmouse() {\n    return iMouse.xy / iResolution.xy;\n}\n\nfloat om(float x) {     // one minus x\n    return 1. - x;\n}\n\nvec3 om(vec3 v) {       // one minus v\n    return 1. - v;\n}\n\nfloat op(float x) {     // one plus x \n    return 1. + x;\n}\n\n// Normalised trig fns.:\nfloat nsin(float x) {\n    return op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n    return op(cos(x)) * 0.5;\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nvec2 trt(vec2 v, vec2 offset, float phi) {\n\treturn rotate(v - offset, phi) + offset;\n}\n\nfloat sec(float theta) {\n    return 1. / cos(theta);\n}\n\nfloat iden(float x) {\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float scale = exp2(nmouse().x * 6.) / 4.;\n    vec3 col;\n    float t = iTime / 2.;\n    vec2 asp = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 uv = fragCoord.xy / iResolution.yy - asp * .5;\n    float amp = 0.04; // * sin(t);\n    float freq = 5.;\n    float freqx = floor(3. + 32. * nsin(t / 24.)); // + mod(floor(iTime / 16.), 9.);\n    \n    float uvy = uv.y;\n    col = mix(vec3(.0, .9, .6), vec3(.999, .3, .2), nsin(pow(length(uv), exp2(16. * nsin(t / 4.) * length(uv))))) / 2.;\n    float cdelta = mod(iTime, 15.) / 15.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n   \n    vec2 offset = vec2(sin(t) / 2., -cos(t) / 2.) * asp * 0.75 * nsin(mod(t / 5., 64.));\t\t// Path: Ellipse\n    float edge = 0.3 + 0.03 * sin(arg((uv - offset)) * freqx)  + 0.03 * sin(arg(uv) * freqx) + 0.05 * sin(t / 5.);\n    float dist = distance(uv, offset);\n    if (dist < edge) {\n        uv = trt(uv, offset, PI / 4. + t);\n        col = vec3(.9, .3, .2);\n        if (dist > edge - .04) {\n            col = black;\n        }\n        if (dist < edge * .3) {\n            col = vec3(.0, .7, .8);\n            if (dist > edge * .5 - .1) {\n                col = black;\n            }\n        }            \n    } \n    float edge2 = 0.2 + 0.1 * sin(arg((uv - offset)) * freqx)  + 0.03 * sin(arg(uv) * freqx) + 0.05 * sin(t / 5.);\n    float phi = t;\n    float a = 1.9;\n    offset = vec2(a * sin(phi), a * sin(phi) * cos(phi)) * asp * 0.75 * nsin(mod(t / 5., 64.));     // Path: Gerono lemniscate\n    dist = distance(uv, offset);\n    if (dist < edge2) {\n        uv = trt(uv, offset, PI / 4. + t);\n        col += vec3(.9, .3, .2).gbr;\n        // col = texture2D(u_tex0, uv).rgb;\n        if (dist > edge2 - .02) {\n            col = black;\n        }\n        if (dist < edge2 * .33) {\n            col = vec3(.8, .3, .3).gbr;\n            if (dist > edge2 * .33 - .01) {\n                col = black;\n            }\n        }            \n    } \n    \n    cdelta = mod(iTime, 32.) / 32.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n    col *= pow(col, vec3(.45454545));\n    col = saturate(col);\n    fragColor = vec4(col,1.0);\n}  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 233, 258, 258, 416], [418, 482, 506, 559, 842], [844, 879, 903, 903, 1023], [1025, 1060, 1084, 1084, 1236], [1238, 1254, 1275, 1275, 1304], [1306, 1306, 1346, 1346, 1431], [1437, 1437, 1464, 1464, 1493], [1495, 1495, 1547, 1547, 1638], [1644, 1644, 1669, 1669, 1755], [1757, 1757, 1772, 1772, 1813], [1815, 1815, 1834, 1853, 1874], [1876, 1876, 1893, 1914, 1935], [1937, 1937, 1956, 1975, 1996], [1998, 2023, 2044, 2044, 2075], [2077, 2077, 2098, 2098, 2129], [2131, 2131, 2150, 2150, 2179], [2181, 2181, 2213, 2213, 2260], [2262, 2262, 2290, 2290, 2355], [2357, 2357, 2389, 2389, 2430], [2432, 2432, 2474, 2474, 2518], [2520, 2520, 2544, 2544, 2574], [2576, 2576, 2597, 2597, 2613], [2615, 2615, 2672, 2672, 4780]]}
{"id": "wslSRr", "name": "thinking...", "author": "kaneta", "description": "🤔", "tags": ["3d", "raymarch", "face", "emoji", "think"], "likes": 57, "viewed": 3248, "published": "Public API", "date": "1550517244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926\n\n#define MAT_BODY 1.0\n#define MAT_FACE 2.0\n#define MAT_HAND 3.0\n#define MAT_BROW 4.0\n\n#define SUN smoothstep(-0.5, 0.5, sunDir.y)\n#define MOON smoothstep(-0.2, -0.5, sunDir.y)\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    float f = 0.5000 * noise(p); p = m2 * p * 2.02;\n    f += 0.2500 * noise(p); p = m2 * p * 2.03;\n    f += 0.1250 * noise(p); p = m2 * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y); }\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 thinkingFace(vec3 p)\n{\n    vec2 face = vec2(sdSphere(p, 1.0), MAT_BODY);\n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.3);\n    q.yz *= rot(-0.25 + 0.05 * step(0.0, p.x));\n    q.y *= 0.8;q.z *= 2.0;q.z -= 2.0;\n    vec2 eye =  vec2(sdSphere(q, .11) * 0.5, MAT_FACE);\n    \n    q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.35);\n    q.yz *= rot(-0.62 + 0.26 * step(0.0, p.x) + pow(abs(q.x), 1.7) * 0.5);\n    q.z -= 1.0;\n    vec2 brow = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .05) * 0.5, MAT_BROW);\n\n    q = p;\n    q.yz *= rot(0.2 + pow(abs(p.x), 1.8));\n    q.xy *= rot(-0.25);\n    q.z -= 1.0;\n    vec2 mouth = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .045), MAT_BROW);\n    \n    p -= vec3(-.25, -.73, 1.0);\n    p.xy *= rot(0.2);\n    q = p;\n    q = (q * vec3(1.2, 1.0, 2.0));\n    q -= vec3(0.0, 0.01, 0.0);\n    vec2 hand = vec2(sdSphere(q, .3) * 0.5, MAT_HAND);\n    \n    q = p;\n    \n    vec2 finger1 = vec2(sdCapsule(q - vec3(0.3, 0.2, 0.02), vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .07), MAT_HAND);\n    vec2 finger2 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.2, 0.06, 0.02), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger3 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.15, -0.08, 0.015), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger4 = vec2(sdCapsule(q * vec3(1.2, 1.0, .9) - vec3(0.1, -0.2, -0.01), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    \n    p -= vec3(-0.1, 0.3, 0.0);\n    q = p;\n    q.x -= q.y * 0.7;\n\n    vec2 finger5 = vec2(sdCapsule(p, vec3(0.0, -0.2, 0.0) - q, vec3(0.0, 0.2, 0.0), .1 - p.y * 0.15), MAT_HAND);\n    vec2 finger = opU(finger1, opU(finger5, opSU(finger2, opSU(finger3, finger4, 0.035), 0.035)));\n    \n    hand = opSU(hand, finger, 0.02);\n    \n    vec2 d = opU(eye, face);\n    d = opU(brow, d);\n    d = opS(mouth, d);\n    d = opU(hand, d);\n    return d;\n}\n\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    vSamplePos *= rot(iTime*.5);\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 think = thinkingFace(p - vec3(-0., 3.0, 0.));\n    return think;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\nfloat fbm( vec3 pos )\n{\n    float o = 0.;\n    for ( int i=0; i < 5; i++ )\n    {\n    \to = o*2. + abs(noise(pos)*2.-1.);\n        pos = m * pos * 2.;\n    }\n    return o / 40.0;\n}\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    float intensity = 0.02;\n    float n1 = fbm(pos * 1.5 + e.xyy) * intensity;\n    float n2 = fbm(pos * 1.5 + e.yyx) * intensity;\n    float n3 = fbm(pos * 1.5 + e.yxy) * intensity;\n    float n4 = fbm(pos * 1.5 + e.xxx) * intensity;\n    return normalize( e.xyy*(map( pos + e.xyy ).x + n1) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x + n2) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x + n3) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x + n4) );\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 sunDir;\nvec3 fakeSky(vec3 rd)\n{   \n    vec3 moning = mix(vec3(0.85,0.5,0.2)*1.1, vec3(0.2,0.5,0.85)*1.1, rd.y);\n    vec3 noon = mix(vec3(0.2,0.5,0.85)*1.3, vec3(0.05,0.2,0.7), rd.y);\n    vec3 night = mix(vec3(.5,0.2,0.05) * 2.0, vec3(0.3,0.1,0.5), clamp(pow(rd.y, 0.5), 0.0, 1.0));\n    night = mix(night, vec3(0.0, 0.0, 0.0), MOON);\n    \n    // sky\t\t\n    vec3 col = noon;\n    col = mix(moning, noon, SUN);\n    col = mix(col, night, MOON);\n    \n    // stars\n    col += vec3(StableStarField(rd.xy * 1100.0, 0.99)) * 0.3;\n\n    // Clouds\n    vec3 cloud = mix(mix(vec3(1.0, 0.95, 1.0), vec3(1.0, 0.2, 0.1), 1.0 - SUN), vec3(0.02), MOON);\n    col = mix(col, cloud, 0.75 * step(0.0, rd.y) * smoothstep(0.4, 0.9, fbm(vec2(iTime, 0.0) + (rd.xz / rd.y) * 3.0)));\n    \n    return col * 3.0;\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * albedo / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/40.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.5, vec3(0.2,0.25,0.8) * 0.75, 0.5+0.5*N.y);\n    ambientColor = mix(vec3(0.3, 0.15, 0.05), ambientColor, 1.0 - smoothstep(0.2, -0.5, sunDir.y));\n    ambientColor = mix(vec3(0.03), ambientColor,  1.0 - smoothstep(-0.2, -0.5, sunDir.y));\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(fakeSky(R) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 nor = normal(p, 0.001);\n    vec3 sky = fakeSky(ray);\n    if (depth > 2000.0) {\n        col = sky;\n    } else {\n        float checker = mod(floor(p.x) + floor(p.z), 2.0);\n        float roughness, metalness;\n    \tif(mat.y == MAT_BODY) {\n            col = pow(vec3(1.0, 204.0 / 255.0, 77.0 / 255.0), vec3(2.2)) * 0.6;\n            roughness = 0.5;\n            metalness = 0.0;\n        } else if(mat.y == MAT_FACE) {\n            col = pow(vec3(102.0 / 255.0, 69.0 / 255.0, 0.0), vec3(2.2)) * 0.6;\n            roughness = 0.1;\n            metalness = 0.0;\n    \t} else if (mat.y == MAT_HAND) {\n        \tcol = pow(vec3(244.0 / 255.0, 144.0 / 255.0, 12.0 / 255.0), vec3(2.2)) * 0.7;\n            roughness = 0.8;\n            metalness = 0.0;\n        } else if(mat.y == MAT_BROW) {\n            col = pow(vec3(102.0 / 255.0, 69.0 / 255.0, 0.0), vec3(2.2)) * 0.8;\n            roughness = 0.6;\n            metalness = 0.0;\n        }\n        vec3 result = vec3(0.);\n        result += shade(p, col, metalness, roughness, nor, -ray, normalize(sunDir), vec3(1.0, 0.98, 0.95) * 100.) * SUN;\n        result += shade(p, col, metalness, roughness, nor, -ray, normalize(-sunDir), vec3(1.0, 0.98, 0.95) * 2.) * MOON;\n        result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n        col = result;\n    }\n    float fo = 1.0-exp(-0.0015*depth);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 100; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.00001) {\n        \tbreak;\n        }\n        t += mat.x;\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = iTime * M_PI * 2.0 / 6.0 - M_PI * 0.5;\n    sunDir = normalize(vec3(.5, sin(t), cos(t)));\n    vec3 ro = vec3(-0.43 * 5.0, 1.3, 0.9 * 5.0);\n    vec3 ta = vec3(2.4, 4.6, -0.3);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = trace(ro, ray);\n    col = reinhard(col, .6, 30.0);\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 220, 220, 308], [310, 310, 331, 331, 626], [628, 628, 647, 647, 886], [888, 888, 921, 921, 949], [951, 951, 1003, 1003, 1130], [1132, 1132, 1160, 1160, 1193], [1195, 1195, 1225, 1225, 1277], [1279, 1279, 1319, 1319, 1438], [1440, 1440, 1461, 1461, 1529], [1531, 1531, 1558, 1558, 3451], [3453, 3519, 3547, 3547, 3674], [3676, 3766, 3829, 3829, 4035], [4037, 4103, 4167, 4337, 5001], [5003, 5003, 5021, 5021, 5096], [5098, 5098, 5121, 5121, 5160], [5162, 5162, 5188, 5188, 5593], [5704, 5704, 5727, 5727, 5879], [5881, 5881, 5920, 5920, 6382], [6384, 6384, 6420, 6420, 6750], [6765, 6765, 6788, 6788, 7538], [7540, 7540, 7584, 7584, 7757], [7759, 7759, 7800, 7800, 7843], [7845, 7845, 7908, 7908, 8019], [8021, 8021, 8094, 8094, 8178], [8180, 8180, 8289, 8289, 8905], [8907, 9033, 9103, 9103, 9386], [9388, 9523, 9571, 9571, 9658], [9660, 9660, 9760, 9760, 10871], [10873, 10873, 10932, 10932, 12355], [12357, 12357, 12387, 12387, 12648], [12650, 12650, 12692, 12692, 12870], [12872, 12872, 12899, 12899, 12958], [12960, 12960, 13014, 13014, 13156], [13158, 13158, 13215, 13215, 13703]]}
{"id": "WslSW4", "name": "isometric textured binary-map", "author": "FabriceNeyret2", "description": "isometric + special view angle: no ray-tracing needed, we know exactly which element could show at any given place.\n(textures put on golfed version).", "tags": ["isometric", "city", "fake3d", "town", "short", "golf", "ville"], "likes": 6, "viewed": 354, "published": "Public API", "date": "1551285861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// textured variant of https://shadertoy.com/view/3sXSW8\n\n#define C(x,y) sin(1e3*length (ceil(U)+vec2(x,y))) > .3//\n//\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, w,v,\n         U =  ( u+u - R ) / R.y * mat2(1,-2,1,2);\n    U.y += iTime;\n    R = fract( U *= 5. );\n    bool r = R.x+R.y > 1.;\n    w = .5+cos(12.6*R*mat2(1,1,0,1));\n    vec4 a = max(w.xxxx,w.y),\n         b = texture(iChannel1,U/8.).grba,\n         c = .4+.1*cos(12.6*(R.y+R.xxxx));\n    O +=  C(1,-1)       ? 1.7*texture(iChannel0,U/4.)\n        : C(1, 0) &&  r ? a\n        : C(0,-1) && !r ? c\n        : C(0, 0) ?   r ? c : a\n        : C(-1,0)       ? b*.5\n        :                 b;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 119, 155, 155, 668]]}
{"id": "WslSWr", "name": "an animated circle", "author": "nebbul", "description": "a simple animated circle", "tags": ["simple", "circle"], "likes": 0, "viewed": 69, "published": "Public", "date": "1551084249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// base code taken from:\n// https://www.shadertoy.com/view/XsjGDt\n//\n\n// Draw a circle at \"pos\" with radius \"rad\"\nfloat circle(vec2 uv, vec2 pos, float rad) {\n\tfloat d = length(pos - uv) - rad;\n    // anti aliasing\n    float t = smoothstep(-0.75, 0.75, d);\n    \n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // define our UVs\n\tvec2 uv = fragCoord.xy;\n    // get center of image\n\tvec2 center = iResolution.xy * 0.5;\n    // set radius of circle\n\tfloat radius = 0.25 * iResolution.y * ((sin(iTime)+1.0)/2.0 + 0.5);//sin(length(iResolution.y-center)*(iTime*0.02))*1.0;\n\n    // Background color RGBA\n\tvec4 bg_color = vec4(0.0, 0.0, 0.0, 1.0);\n    // foreground color RGBA (circle)\n\tvec4 fg_color = vec4(1.0, 1.0, 1.0, 1.0);\n\n\t// Circle mask\n\tfloat circle = circle(uv, center, radius);\n\n\t// Blend the two\n\tfragColor = vec4( mix(fg_color, bg_color, circle) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 114, 158, 158, 274], [276, 276, 333, 356, 885]]}
{"id": "WslSzr", "name": "vonronoi mystery glass", "author": "Myro", "description": "quick glass-like animated vonroi pattern ", "tags": ["2d", "color", "animated", "glass", "pattern", "fragment", "mystery", "vonronoi"], "likes": 3, "viewed": 132, "published": "Public", "date": "1550498409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"vonronoise\" from iq - https://www.shadertoy.com/view/Xd23Dh\n// More info here: http://iquilezles.org/www/articles/voronoise/voronoise.htm\n\n// ell noise    u=0,v=0\n// voronoi      u=1,v=0\n// perlin noise u=0,v1=\n// voronoise    u=1,v=1\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat vonronoi(vec2 x) {\n\treturn iqnoise(x,0.7,0.0);\n}\n\nfloat noise(vec2 x) {\n\treturn iqnoise(x,0.0,1.0);\n}\n\nfloat vonronoise(vec2 x) {\n\treturn iqnoise(x,1.0,1.0);\n}\n// ---------------------------------------\n\n// 3D noise from iq https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n// ----------------------------------------\n\n\n// noise but with intensity & contrast control\n// i : intensity, a-b : step begin & end, x : your coordinate : h 3D component (time)\nfloat noiseStep(float i, float a, float b, vec2 x, float h) {\n    float d = 0.2*(b-a);\n\treturn 1.0-i+(smoothstep(a-d, b+d, noise(vec3(x,h))*(i)));\n}\n\n// cosine palette by iq\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\n// ---------------------------------------\n\n// ORIGINAL TO THIS SHADER\n\nconst float dx = 0.12;\n\nfloat vonronoistroke(vec2 uv) {\n    float h = vonronoi(uv);\n    float d = 0.0;\n    d -= 0.5*vonronoi(uv+vec2(0,dx));\n    d -= 0.5*vonronoi(uv+vec2(dx,0));\n    h += d;\n    h*=10.0;\n    return abs(h);\n}\n\nconst float rotSpeed= 0.1;\n\nfloat glassFragment (vec2 uv) {\n    float rotAngle = rotSpeed * iTime;\n    mat2 rotmat = mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    mat2 invrotmat = mat2(cos(-rotAngle), -sin(-rotAngle), sin(-rotAngle), cos(-rotAngle));\n\treturn clamp(vonronoistroke(uv * invrotmat) / (1.0 + 5.0*vonronoistroke(3.0*uv * rotmat)),0.0,1.0);\n}\n\nfloat height(vec2 uv) {\n\treturn 0.05+(noiseStep(0.95,0.55,0.6,uv*0.8, iTime*0.5)-0.1) * glassFragment(uv);\n}\n\n// retuns a color for a given point on the map, and time offset\nvec3 getColor (vec2 uv) {\n\treturn palette(height(uv))*(0.1+height(uv)*0.9);\n}\n\nconst float SCALE = 20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized screen pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec2 mapuv = uv;// coordinate on the map\n    \n    if (iMouse.y <= 0.0) mapuv *= SCALE*0.5;\n    else mapuv *= SCALE *iMouse.y / iResolution.y;\n    \n    // vignette & vertical gradient\n    float postfx = -0.2*(length(uv)*length(uv)-0.1);\n    // Output to screen\n    fragColor = vec4(getColor(mapuv) + postfx,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 240, 262, 262, 413], [415, 415, 458, 458, 893], [895, 895, 919, 919, 949], [951, 951, 972, 972, 1002], [1004, 1004, 1030, 1030, 1060], [1105, 1163, 1183, 1183, 1278], [1280, 1280, 1306, 1306, 1780], [1827, 1960, 2021, 2021, 2108], [2110, 2134, 2210, 2210, 2253], [2255, 2255, 2279, 2279, 2396], [2441, 2493, 2524, 2524, 2693], [2723, 2723, 2754, 2754, 3073], [3075, 3075, 3098, 3098, 3183], [3185, 3249, 3274, 3274, 3326], [3355, 3355, 3412, 3470, 3879]]}
{"id": "wslXRH", "name": "Thinking Kaiware", "author": "kaiware007", "description": "[´∃`]🤔\nOriginal \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr", "tags": ["3d", "raymarching", "kaiware"], "likes": 4, "viewed": 147, "published": "Public", "date": "1550829028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// ------------------------------------------------------------------------------------\n\n#define M_PI 3.1415926\n\n#define MAT_BODY 1.0\n#define MAT_FACE 2.0\n#define MAT_HAND 3.0\n#define MAT_BROW 4.0\n\n#define SUN smoothstep(-0.5, 0.5, sunDir.y)\n#define MOON smoothstep(-0.2, -0.5, sunDir.y)\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    float f = 0.5000 * noise(p); p = m2 * p * 2.02;\n    f += 0.2500 * noise(p); p = m2 * p * 2.03;\n    f += 0.1250 * noise(p); p = m2 * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y); }\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// https://www.shadertoy.com/view/llVBDy\nvec2 sdKaiware(vec3 p, float sc)\n{\n\t\n\t// scale\n\tp = p / sc;\n\n\t// head - 頭部\n\tfloat d1 = sdRoundBox(p, vec3(1, 0.8, 1), 0.1);\n\n\t// beak - くちばし\n\tfloat d2_0 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.8, 0.25, 0.4), 0.1);\n\tfloat d2_1 = sdRoundBox(p - vec3(0, -0.0, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_2 = sdRoundBox(p - vec3(0, -0.4, 0.7), vec3(1.1, 0.35, 1.1), 0.0);\n\tfloat d2_3 = sdRoundBox(p - vec3(0, -0.2, 0.7), vec3(0.75, 0.1, 0.35), 0.1);\n\n\tfloat d2_top = max(d2_0, d2_1);\n\tfloat d2_bottom = max(d2_0, d2_2);\n\tfloat d2 = min(min(d2_top, d2_bottom), d2_3);\n\n\t// stem - はっぱの茎\n\tfloat d3_0 = sdCapsule(p, vec3(0, 0.5, 0), vec3(0, 0.9, 0), 0.05);\n\t// leaf - 葉っぱ\n\tfloat d3_1 = sdEllipsoid(p - vec3(0.2, 0.9, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3_2 = sdEllipsoid(p - vec3(-0.2, 0.9, 0), vec3(0.2, 0.025, 0.1));\n\tfloat d3 = min(d3_0, min(d3_1, d3_2));\n\n    vec2 face = vec2(min(min(d1, d2), d3), MAT_FACE);\n    \n\t// eyes - 目\n\tfloat d4_0 = sdCapsule(p, vec3(0.2, 0.25, 0.6), vec3(0.4, 0.2, 0.6), 0.025);\n\tfloat d4_1 = sdCapsule(p, vec3(-0.2, 0.25, 0.6), vec3(-0.4, 0.2, 0.6), 0.025);\n\tvec2 eye = vec2(min(d4_0, d4_1), MAT_BODY);\n\n\t// combine - 合成\n\tvec2 sum = opS(eye, face);\n    \n\tsum.x *= sc;\n\n\treturn sum;\n}\n\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    vSamplePos *= rot(iTime*.5);\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 map(vec3 p)\n{\n\n    p -= vec3(-0., 3.0, 0.);\n\n    vec2 kwr = sdKaiware(p, 1.25);\n    \n    // Hand\n    vec3 q = p;\n    p -= vec3(-.5, -.9, 1.2);\n    p.xy *= rot(0.2);\n    q = p;\n    q = (q * vec3(1.2, 1.0, 2.0));\n    q -= vec3(0.0, 0.01, 0.0);\n    vec2 hand = vec2(sdSphere(q, .3) * 0.5, MAT_HAND);\n    \n    q = p;\n    \n    vec2 finger1 = vec2(sdCapsule(q - vec3(0.3, 0.2, 0.02), vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .07), MAT_HAND);\n    vec2 finger2 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.2, 0.06, 0.02), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger3 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.15, -0.08, 0.015), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger4 = vec2(sdCapsule(q * vec3(1.2, 1.0, .9) - vec3(0.1, -0.2, -0.01), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    \n    p -= vec3(-0.1, 0.3, 0.0);\n    q = p;\n    q.x -= q.y * 0.7;\n\n    vec2 finger5 = vec2(sdCapsule(p, vec3(0.0, -0.2, 0.0) - q, vec3(0.0, 0.2, 0.0), .1 - p.y * 0.15), MAT_HAND);\n    vec2 finger = opU(finger1, opU(finger5, opSU(finger2, opSU(finger3, finger4, 0.035), 0.035)));\n    \n    hand = opSU(hand, finger, 0.02);\n    \n    vec2 d = opU(kwr, hand);\n\n    return d;    \n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\nfloat fbm( vec3 pos )\n{\n    float o = 0.;\n    for ( int i=0; i < 5; i++ )\n    {\n    \to = o*2. + abs(noise(pos)*2.-1.);\n        pos = m * pos * 2.;\n    }\n    return o / 40.0;\n}\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    float intensity = 0.02;\n    float n1 = fbm(pos * 1.5 + e.xyy) * intensity;\n    float n2 = fbm(pos * 1.5 + e.yyx) * intensity;\n    float n3 = fbm(pos * 1.5 + e.yxy) * intensity;\n    float n4 = fbm(pos * 1.5 + e.xxx) * intensity;\n    return normalize( e.xyy*(map( pos + e.xyy ).x + n1) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x + n2) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x + n3) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x + n4) );\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 sunDir;\nvec3 fakeSky(vec3 rd)\n{   \n    vec3 moning = mix(vec3(0.85,0.5,0.2)*1.1, vec3(0.2,0.5,0.85)*1.1, rd.y);\n    vec3 noon = mix(vec3(0.2,0.5,0.85)*1.3, vec3(0.05,0.2,0.7), rd.y);\n    vec3 night = mix(vec3(.5,0.2,0.05) * 2.0, vec3(0.3,0.1,0.5), clamp(pow(rd.y, 0.5), 0.0, 1.0));\n    night = mix(night, vec3(0.0, 0.0, 0.0), MOON);\n    \n    // sky\t\t\n    vec3 col = noon;\n    col = mix(moning, noon, SUN);\n    col = mix(col, night, MOON);\n    \n    // stars\n    col += vec3(StableStarField(rd.xy * 1100.0, 0.99)) * 0.3;\n\n    // Clouds\n    vec3 cloud = mix(mix(vec3(1.0, 0.95, 1.0), vec3(1.0, 0.2, 0.1), 1.0 - SUN), vec3(0.02), MOON);\n    col = mix(col, cloud, 0.75 * step(0.0, rd.y) * smoothstep(0.4, 0.9, fbm(vec2(iTime, 0.0) + (rd.xz / rd.y) * 3.0)));\n    \n    return col * 3.0;\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * albedo / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/40.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.5, vec3(0.2,0.25,0.8) * 0.75, 0.5+0.5*N.y);\n    ambientColor = mix(vec3(0.3, 0.15, 0.05), ambientColor, 1.0 - smoothstep(0.2, -0.5, sunDir.y));\n    ambientColor = mix(vec3(0.03), ambientColor,  1.0 - smoothstep(-0.2, -0.5, sunDir.y));\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(fakeSky(R) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 nor = normal(p, 0.001);\n    vec3 sky = fakeSky(ray);\n    if (depth > 2000.0) {\n        col = sky;\n    } else {\n        float checker = mod(floor(p.x) + floor(p.z), 2.0);\n        float roughness, metalness;\n        if(mat.y == MAT_FACE) {\n        \tcol = vec3(0.65, 1.0, 0.3);\n            roughness = 0.125;\n            metalness = 0.0;\n        } else if (mat.y == MAT_HAND) {\n        \tcol = vec3(0.2, 0.35, 0.05);\n            roughness = 0.8;\n            metalness = 0.0;\n        }else if(mat.y == MAT_BROW) {\n \t\t\tcol = pow(vec3(102.0 / 255.0, 69.0 / 255.0, 0.0), vec3(2.2)) * 0.8;\n            roughness = 0.1;\n            metalness = 0.0;\n        } \n\n        vec3 result = vec3(0.);\n        result += shade(p, col, metalness, roughness, nor, -ray, normalize(sunDir), vec3(1.0, 0.98, 0.95) * 100.) * SUN;\n        result += shade(p, col, metalness, roughness, nor, -ray, normalize(-sunDir), vec3(1.0, 0.98, 0.95) * 2.) * MOON;\n        result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n        col = result;\n    }\n    float fo = 1.0-exp(-0.0015*depth);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 100; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.00001) {\n        \tbreak;\n        }\n        t += mat.x;\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = iTime * M_PI * 2.0 / 6.0 - M_PI * 0.5;\n    sunDir = normalize(vec3(.5, sin(t), cos(t)));\n    vec3 ro = vec3(-0.43 * 5.0, 1.3, 0.9 * 5.0);\n    vec3 ta = vec3(2.4, 4.6, -0.3);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = trace(ro, ray);\n    col = reinhard(col, .6, 30.0);\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 560, 606, 606, 662], [664, 664, 714, 714, 832], [834, 834, 871, 871, 960], [962, 962, 982, 982, 1070], [1072, 1072, 1093, 1093, 1388], [1390, 1390, 1409, 1409, 1648], [1650, 1650, 1683, 1683, 1711], [1713, 1713, 1741, 1741, 1774], [1776, 1776, 1806, 1806, 1858], [1860, 1860, 1900, 1900, 2019], [2021, 2021, 2042, 2042, 2110], [2112, 2153, 2187, 2199, 3398], [3400, 3466, 3494, 3494, 3621], [3623, 3713, 3776, 3776, 3982], [3984, 4050, 4114, 4284, 4948], [4950, 4950, 4968, 4968, 6197], [6199, 6199, 6222, 6222, 6261], [6263, 6263, 6289, 6289, 6694], [6805, 6805, 6828, 6828, 6980], [6982, 6982, 7021, 7021, 7483], [7485, 7485, 7521, 7521, 7851], [7866, 7866, 7889, 7889, 8639], [8641, 8641, 8685, 8685, 8858], [8860, 8860, 8901, 8901, 8944], [8946, 8946, 9009, 9009, 9120], [9122, 9122, 9195, 9195, 9279], [9281, 9281, 9390, 9390, 10006], [10008, 10134, 10204, 10204, 10487], [10489, 10624, 10672, 10672, 10759], [10761, 10761, 10861, 10861, 11972], [11974, 11974, 12033, 12033, 13188], [13190, 13190, 13220, 13220, 13481], [13483, 13483, 13525, 13525, 13703], [13705, 13705, 13732, 13732, 13791], [13793, 13793, 13847, 13847, 13989], [13991, 13991, 14048, 14048, 14536]]}
{"id": "wslXRr", "name": "Hexadrome", "author": "AdrianPi", "description": "Old-school raytracing", "tags": ["3d", "raytracing"], "likes": 3, "viewed": 135, "published": "Public", "date": "1550518418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 dirInv;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\nconst int POLKA_MATERIAL = 3;\nconst int HONEYCOMB_MATERIAL = 4;\n\nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\nconst int BOX_PRIMITIVE = 4;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\nconst float EPSILON4 = 1e-4;\n\nvec3 viewFrom = vec3(0,-1,1);\nvec3 viewAt = vec3(0,0,-1);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 45.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 2;\n\nvec4 skyColor = vec4(0.2,0.,0.5,1);\nvec4 horizonColor = vec4(0.5,0.8,1,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(.1,.1,.1,1), \n                                   vec4(.1,.1,.1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(0.5,0,1,1), \n                                   vec4(0.5,0,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   HONEYCOMB_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(0.5,0.5,0.5,0), \n                                   vec4(0.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.54));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.1,0.1,0.1,1), \n                                   vec4(0.1,0.1,0.1,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.3,0.3,0.3,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,1,1), \n                                   vec4(0,0,1,1), \n                                   vec4(1,1,1,60), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(.8,.4,0,1), \n                                   vec4(.8,.4,0,1), \n                                   vec4(0.5,0.5,0.5,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[7] = material_t[7](material0, material1, material2, material3, material4, material5, material6);\n\n\nconst primitive_t _floor = primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, -3), vec3(0, 0, 1), vec3(0,0,0));\nconst primitive_t _sphere = primitive_t(SPHERE_PRIMITIVE, 4, vec3(-2, 0, 0), vec3(3, 0, 0), vec3(0,0,0));\nconst primitive_t _box = primitive_t(BOX_PRIMITIVE, 3, vec3(3.5, 0, -2.99), vec3(8.5, 5, 2), vec3(0,0,0));\n\nconst int NUM_PRIMS = 3;\n\nprimitive_t prims[NUM_PRIMS] = primitive_t[NUM_PRIMS](_floor, _sphere, _box);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.dirInv = vec3(1) / ray.dir;\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 30.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool hit_box(vec3 p0, vec3 p1, int mat, ray_t ray, inout hit_t hit)\n{\n    float txmin = (p0.x - ray.pos.x) * ray.dirInv.x;\n    float txmax = (p1.x - ray.pos.x) * ray.dirInv.x;\n    float tymin = (p0.y - ray.pos.y) * ray.dirInv.y;\n    float tymax = (p1.y - ray.pos.y) * ray.dirInv.y;\n    float tzmin = (p0.z - ray.pos.z) * ray.dirInv.z;\n    float tzmax = (p1.z - ray.pos.z) * ray.dirInv.z;\n    \n    float tmin = max(max(min(txmin, txmax), min(tymin, tymax)), min(tzmin, tzmax));\n    float tmax = min(min(max(txmin, txmax), max(tymin, tymax)), max(tzmin, tzmax));\n    \n    if(tmax < EPSILON || tmin > tmax)\n    {\n        return false;\n    }\n    \n    if(tmin < EPSILON)\n    {\n        tmin = tmax; // inside the box\n    }\n    \n    \n    if(tmin > EPSILON)\n    {\n        hit.t = tmin;\n        hit.pos = ray.pos + ray.dir * hit.t;\n        \n        if(hit.pos.x < p0.x+EPSILON4)\n            hit.normal = vec3(-1, 0, 0);\n        else if(hit.pos.x > p1.x-EPSILON4)\n            hit.normal = vec3(1,0,0);\n        else if(hit.pos.y < p0.y+EPSILON4)\n            hit.normal = vec3(0, -1, 0);\n        else if(hit.pos.y > p1.y-EPSILON4)\n            hit.normal = vec3(0, 1, 0);\n        else if(hit.pos.z < p0.z+EPSILON4)\n            hit.normal = vec3(0, 0, -1);\n        else if(hit.pos.z > p1.z-EPSILON4)\n            hit.normal = vec3(0, 0, 1);\n        \n        hit.mat = mat;\n        return true;\n    }\n    \n    return false;\n}\n\nvec4 ambientLight = vec4(0.2, 0.2, 0.2, 1);\nvec3 lightDirection = normalize(vec3(1,1,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 8)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON;\n    sray.dir = -lightDirection;\n    sray.dirInv = vec3(1) / sray.dir;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade_polka(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int iy = int(floor(p.y)) & 0x01;\n    if((iy & 0x01) == 1)\n        p.x += 0.5;\n\n    vec3 p2 = mod(p, vec3(1.));\n    p2 *= 2.;\n    p2 -= 1.;\n        \n    float d = dot(p2,p2);\n\n    hit.mat = (d < (.666*.666)) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nconst float SIN60 = 0.86602540378443864676372317075294;\n\nvec4 shade_honeycomb(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    //int iy = int(floor(p.y)) & 0x01;\n    //if((iy & 0x01) == 1)\n    //     p.x += 0.5;\n\tp.y += floor(p.x) * 0.5;\n    \n    vec3 p2 = mod(p, vec3(1.));\n    p2 *= 2.;\n    p2 -= 1.;\n    p2 *= vec3(1.1,1.2,1.);\n    p2 = abs(p2);\n        \n    //float d = dot(p2,p2);\n\tfloat d = max((p2.x*SIN60+p2.y*0.5),p2.y);\n    \n    hit.mat = (d < (1.)) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        switch(type)\n        {\n        case STANDARD_MATERIAL:\n            color = shade_standard(ray, hit);\n            break;\n        case CHECKER_MATERIAL:\n            color = shade_checker(ray, hit);\n            break;\n        case POLKA_MATERIAL:\n            color = shade_polka(ray, hit);\n            break;\n        case HONEYCOMB_MATERIAL:\n            color = shade_honeycomb(ray, hit);\n            break;            \n        }\n        \n        // fog\n\n        float f = (hit.t - 10.0) / (50.0-10.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        case BOX_PRIMITIVE:\n            result = hit_box(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    viewFrom = vec3(sin(iTime*.5)*14.0, -10.-cos(iTime*.5)*4.0, 2. + sin(iTime*1.5)*3.);\n    \n    if(iResolution.x > 800.)\n        oversample = 1;\n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n    \n    \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n    \n    for(int i = 0; i < oversample; i++)\n    {\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    // vignette    \n    float d = pow(1. - dot(uv,uv), 3.);\n    color *= d;\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslXRr.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 4671, 4710, 4710, 4911], [4913, 4913, 4941, 4941, 5055], [5057, 5057, 5138, 5138, 5957], [5959, 5959, 6034, 6034, 6392], [6394, 6394, 6488, 6488, 7031], [7033, 7033, 7102, 7102, 8442], [8591, 8591, 8619, 8619, 8744], [8746, 8746, 8780, 8780, 8935], [8937, 8937, 8959, 8959, 8988], [9036, 9036, 9079, 9079, 10757], [10759, 10759, 10801, 10801, 11145], [11147, 11147, 11187, 11187, 11594], [11653, 11653, 11697, 11697, 12230], [12232, 12232, 12266, 12266, 13052], [13054, 13054, 13098, 13098, 13928], [13930, 13930, 13956, 13956, 14036], [14038, 14038, 14095, 14095, 15187]]}
{"id": "WslXzr", "name": "Shapes of Constant Width", "author": "EnigmaCurry", "description": "Reuleaux Triangles\nMusic by EnigmaCurry", "tags": ["transparency", "triangle", "geometry", "soundcloud", "reuleaux"], "likes": 5, "viewed": 654, "published": "Public API", "date": "1550502529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Shapes of Constant Width - EnigmaCurry 2019\n/// See Mathologer for more about Reuleaux Triangles\n/// https://www.youtube.com/watch?v=-eQaF6OmWKw\n\n#define BORDER_PCT 0.2\n#define PI 3.14159\n\nfloat circle(in vec2 _p, in vec2 _center, in float _radius) {\n  vec2 dist = _p - _center;\n  return step(distance(_p, _center), _radius);\n}\n\nfloat line(in vec2 p, in vec2 p1, in vec2 p2, float width) {\n  vec2 d0 = p2 - p1;\n  vec2 d1 = p - p1;\n  return length(d1 - d0 * clamp(dot(d0, d1) / dot(d0, d0), 0., 1.)) * (1./width*8.);\n}\n\nvec2 rotateVec2(in vec2 v, in vec2 axis, in float angle) {\n  vec2 vprime = v - axis;\n  vec2 vrot = vec2(vprime.x * cos(angle) - vprime.y * sin(angle),\n                   vprime.y * cos(angle) + vprime.x * sin(angle));\n  return vrot + axis;\n}\n\nvec3 reuleauxTriangle(in vec2 _p, in vec2 _rotCenter, in float r) {\n  float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.);\n  vec2 top = vec2(_rotCenter.x, _rotCenter.y + (sqrt(3.)/2.) * r);\n  vec2 left = vec2(top.x-(r/2.), top.y-1. * (sqrt(3.)/2.) * r);\n  vec2 right = vec2(top.x+r/2., top.y-1. * (sqrt(3.)/2.) * r);\n  vec2 center = vec2(_rotCenter.x, _rotCenter.y + 0.333 * distance(_rotCenter, top));\n  /// Rotate triangle\n  float angle = 0.;\n  float tmod = mod(iTime, 60.);\n  float sigh = sin(iTime/110.) * cos(iTime*1.) * 4.;\n  float wave = sin(iTime/14.) * cos(iTime/6.) * 4.;\n  if (tmod < 15.) {\n    angle = sigh;\n  } else if (tmod < 30.) {\n    angle = mix(sigh, wave, (tmod - 15.) / 15.);\n  } else if (tmod < 45.) {\n    angle = wave;\n  } else if (tmod < 60.) {\n    angle = mix(wave, sigh, (tmod - 45.) / 15.);\n  }\n  top = rotateVec2(top, _rotCenter, angle);\n  left = rotateVec2(left, _rotCenter, angle);\n  right = rotateVec2(right, _rotCenter, angle);\n  center = rotateVec2(center, _rotCenter, angle);\n  /// Union of three circles:\n  float c1 = circle(_p, top, r);\n  float c2 = circle(_p, left, r);\n  float c3 = circle(_p, right, r);\n  float drot = distance(_p, _rotCenter);\n  float dtop = distance(_p, top);\n  float dleft = distance(_p, left);\n  float dright = distance(_p, right);\n  float dcenter = distance(_p, center);\n  float dthreshold = 0.008;\n  float dline1 = line(_p, top, left, 0.5);\n  float dline2 = line(_p, left, right, 0.5);\n  float dline3 = line(_p, right, top, 0.5);\n\n  vec3 color = vec3(0.);\n  if ( c1 > 0. && c2 > 0. && c3 > 0.){\n    float c = atan(cos((_p.x/_p.y) * abs(sin(iTime/14.)) * 13. + 3.) * 15.);\n    color = smoothstep(\n                      vec3(smoothstep(fft*-1.48, 1.48, fft*atan(cos(iTime/8.)*22.*sin(iTime/2.)))),\n                      vec3(1.0 - c, c, _p.x * c),\n                      vec3(smoothstep(-PI/4., PI/4.,atan(sin(iTime/3.))))\n                        - distance(_p, _rotCenter)\n                      );\n    if (drot < dthreshold) {\n      color = vec3(smoothstep(0.,.01,drot * smoothstep(-1.,1., sin(iTime/2.))),\n                   smoothstep(0.,.01,drot * smoothstep(-1.,1., sin(iTime/4.))),\n                   smoothstep(0.,.01,drot * smoothstep(-1.,1., sin(iTime/8.)))\n                   );\n    } else if (dtop < dthreshold || dleft < dthreshold || dright < dthreshold) {\n      color = vec3(0.8);\n    } else if (dcenter < dthreshold) {\n      color = vec3(smoothstep(0.,.01,dcenter * smoothstep(-1.,1., cos(0.01*fft*iTime/2.))),\n                   smoothstep(0.,.01,dcenter * smoothstep(-1.,1., cos(0.01*fft*iTime/4.))),\n                   smoothstep(0.,.01,dcenter * smoothstep(-1.,1., cos(0.01*fft*iTime/8.)))\n                   );\n    } else if (dline1 < dthreshold || dline2 < dthreshold || dline3 < dthreshold) {\n      color = vec3(smoothstep(-1., 0.1 * _p.x, atan(sin(iTime/4.))));\n    }\n  }\n\n  return color;\n}\n\nvec4 bgScene(in vec3 _color, in vec2 _p) {\n  float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.) / 16.;\n  fft /= sqrt(fft);\n  float c = atan(cos((_p.x/_p.y) * abs(sin(iTime/14.)) * 13. + 3.) * 15.);\n  if (_color == vec3(0.)) {\n    return vec4(vec3(0.1+fft * c, 0.1+fft*_p.y*c, 0.1+fft*_p.x * c), smoothstep(-1., 1., sin(iTime/12.)));\n  } else {\n    return vec4(_color, 1.);\n  }\n}\n\nvec3 tint(in vec3 color, in vec3 base, in float amount) {\n  if (base !=  vec3(0.)) {\n    return mix(base, color, amount);\n  } else {\n    return base;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  //Center and normalize zoom:\n  float zoom = smoothstep(-1., 1., sin(iTime/12.)) + 0.5;\n  vec2 p = (uv - 0.5) / zoom;\n  if (iResolution.x > iResolution.y) {\n    p.x *= iResolution.x/iResolution.y;\n  } else {\n    p.y *= iResolution.y/iResolution.x;\n  }\n  float width = 0.5;\n  float radius = width / 2.;\n  float tintAmount = smoothstep(-4.,8.,sin(iTime/2.));\n  vec3 color = tint(vec3(0.,1.,0.), reuleauxTriangle(p, vec2(0., 0.), radius), tintAmount);\n  color += tint(vec3(0.294,0.,0.50980), reuleauxTriangle(p, vec2(radius, 0.), radius), tintAmount);\n  color += tint(vec3(1.,0.64706,0.), reuleauxTriangle(p, vec2(-radius, 0.), radius), tintAmount);\n  color += tint(vec3(1.,0.,0.), reuleauxTriangle(p,\n                                                 vec2(-radius/2., (sqrt(3.)/2.) * radius),\n                                                 radius), tintAmount);\n  color += tint(vec3(0.,0.,1.), reuleauxTriangle(p,\n                            vec2(radius/2., (sqrt(3.)/2.) * radius),\n                                                 radius), tintAmount);\n  color += tint(vec3(1.,1.,0.), reuleauxTriangle(p,\n                            vec2(-radius/2., 0. - (sqrt(3.)/2.) * radius),\n                                                 radius), tintAmount);\n  color += tint(vec3(0.93333, 0.50980, 0.93333), reuleauxTriangle(p,\n                            vec2(radius/2., 0. - (sqrt(3.)/2.) * radius),\n                                                                        radius), tintAmount);\n\n  color += reuleauxTriangle(p, vec2(radius*2., 0.), radius);\n  color += reuleauxTriangle(p, vec2(-radius*2., 0.), radius);\n  color += reuleauxTriangle(p, vec2(-3.*radius/2., (sqrt(3.)/2.) * radius), radius);\n  color += reuleauxTriangle(p, vec2(3.*radius/2., (sqrt(3.)/2.) * radius), radius);\n  color += reuleauxTriangle(p, vec2(-3.*radius/2., -(sqrt(3.)/2.) * radius), radius);\n  color += reuleauxTriangle(p, vec2(3.*radius/2., -(sqrt(3.)/2.) * radius), radius);\n\n  color += reuleauxTriangle(p, vec2(radius, (sqrt(3.)/2.) * 2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(0., (sqrt(3.)/2.) * 2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(-radius, (sqrt(3.)/2.) * 2. * radius), radius);\n\n  color += reuleauxTriangle(p, vec2(radius, (sqrt(3.)/2.) * -2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(0., (sqrt(3.)/2.) * -2. * radius), radius);\n  color += reuleauxTriangle(p, vec2(-radius, (sqrt(3.)/2.) * -2. * radius), radius);\n\n\n  fragColor = bgScene(color, p);\n}\n", "image_inputs": [{"id": "lll3WH", "previewfilepath": "https://soundcloud.com/enigmacurry/dediameterizing-super-locution", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/enigmacurry/dediameterizing-super-locution", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 193, 254, 254, 331], [333, 333, 393, 393, 521], [523, 523, 581, 581, 764], [766, 766, 833, 833, 3660], [3662, 3662, 3704, 3704, 4065], [4067, 4067, 4124, 4124, 4222], [4224, 4224, 4280, 4280, 6805]]}
{"id": "wsS3Dc", "name": "Distance to an Octahedron", "author": "sopyer", "description": "Distance to an octahedron, alternative approach to https://www.shadertoy.com/view/wsSGDG", "tags": ["distance", "octahedron"], "likes": 2, "viewed": 343, "published": "Public API", "date": "1550150794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// It computes the distance to a triangle.\n//\n// See here: http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n//\n// In case a mesh was rendered, only one square root would be needed for the\n// whole mesh. In this example the triangle is given a thckness of 0.01 units\n// for display purposes. Like the square root, this thickness should be added\n// only once for the whole mesh too.\n\n\n// Other distande functions (SDFs):\n//\n// Quad:          https://www.shadertoy.com/view/Md2BWW\n// Triangle:      https://www.shadertoy.com/view/4sXXRN\n// Rounded Cone:  https://www.shadertoy.com/view/tdXGWr\n// Cylinder:      https://www.shadertoy.com/view/wdXGDr\n// Octahedron:    https://www.shadertoy.com/view/wsSGDG\n// Many more:     https://www.shadertoy.com/view/Xds3zN\n//\n// List of primitive SDFs at http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat saturate(in float v) {return clamp(v, 0.0, 1.0);}\n\nvec2 udSegment(in vec2 p0, in vec2 p1, in vec2 p)\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 v0 = p - p0;\n\tvec2 pq0 = v0 - e0*saturate( dot(v0,e0)/dot(e0,e0) );\n    return pq0;\n}\n\nfloat udOctahedron( in vec3 p )\n{\n    // Octant symmetry\n    p = abs(p);\n    // Diagonal symmetry\n    p.xz = p.x < p.z ? p.zx : p.xz;\n  \n    // transform into triangle plane\n    //float x = (1.0 - p.x + sqrt(2.0)*p.y) / sqrt(3.0);\n    //float y = p.z - 1.0;\n    //float z = (sqrt(2.0)*(p.x - 1.0)+p.y) / sqrt(3.0);\n    \n    // transform into triangle plane\n    p.xz -= vec2(1.0);\n    float x = (-p.x + sqrt(2.0)*p.y) / sqrt(3.0);\n    float y = p.z;\n    float z = (sqrt(2.0)*p.x+p.y) / sqrt(3.0);\n    \n    \n    // x==0.0 edge mask\n    float edge0 = step(0.0, -x);\n    // diagonal edge mask\n    float edge1 = (1.0-edge0) * step(0.0, x / sqrt(3.0)+ y);\n    \n    vec2 pd = vec2(0);\n    //pd += edge0 * udSegment(vec2(0, 1), vec2(0, 0), p2);\n    //pd += edge1 * udSegment(vec2(0, 1), vec2(sqrt(3.0), 0.0), p2);\n\n    pd += edge0 * vec2(x, y + saturate(-y));\n    float t = saturate( (sqrt(3.0)*x - y)/4.0 );\n    pd += edge1 * vec2(x - sqrt(3.0)*t, y + t );\n\n    // compute distance to triangle\n    return length(vec3(pd, z));\n}\n\n//=====================================================\n\nfloat map( in vec3 p )\n{\n\tfloat rad = 0.103+0.1*sin(iTime*2.0);\n\tfloat d1 = udOctahedron( (p-vec3(0, 1.0, 0))/(1.0-rad) )*(1.0-rad) - rad;\n\n    // ground plane\n\tfloat d2 = p.y + 1.0;\n\n    return min( d1, d2 );\t\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 4.0*cos(an), 2.4, 4.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3Dc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1487, 1964, 1989, 1989, 2008], [2009, 2009, 2037, 2037, 2064], [2066, 2066, 2117, 2117, 2229], [2231, 2231, 2264, 2287, 3251], [3253, 3310, 3334, 3334, 3522], [3524, 3524, 3567, 3567, 3794], [3796, 3796, 3828, 3828, 4040], [4042, 4042, 4099, 4099, 4345], [4347, 4347, 4396, 4396, 4687], [4731, 4731, 4788, 4788, 5780]]}
{"id": "WsS3Dd", "name": "Color Cycling Circle", "author": "arthurstammet", "description": "Color Cycling Circle\ninspired by The Art of Code - Shadertoy Tutorials\nhttps://www.youtube.com/playlist?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5\n", "tags": ["color", "circle", "rgb", "animation", "cycling"], "likes": 2, "viewed": 286, "published": "Public API", "date": "1550248928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Color Cycling Circle\n// inspired by The Art of Code - Shadertoy Tutorials\n// https://www.youtube.com/playlist?list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; \t// 0. <> 1.\n\n    uv -= .5;\t\t\t\t\t\t\t\t\t// -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\t\t// compress ellipse to circle (x axis only)\n\n    vec3 color = vec3(1.);\n    \n    float d = length(uv);\t\t\t\t\t\t// UV -= .5 represents the center of the screen\n    float r = 0.3;\t\t\t\t\t\t\t\t// radius of the circle\n    float blur = 0.01;\t\t\t\t\t\t\t// blur amount : higher values for more blur\n    float mask = smoothstep(r, r-blur, d);\t\t// create a mask with the shape pf of a blurry circle\n    \n    float red = 0.5 + 0.5*cos(iTime*0.6);\n    float green = 0.5 + 0.5*cos(iTime*0.75);\n    float blue = 0.5 + 0.5*cos(iTime*0.46);\n    \n    color = vec3(red,green,blue)*mask;\n    \n    fragColor = vec4(color, 1.0);\t\t\t\t// draw a blurry circle\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsS3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 154, 211, 211, 975]]}
{"id": "WsS3Rd", "name": "2019-02-08", "author": "Justaway", "description": "2019-02-08", "tags": ["20190208"], "likes": 0, "viewed": 93, "published": "Public", "date": "1549918740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SETS 5\n#define TIME_SCALE 10.0\nfloat[30*NUM_SETS] coef = float[30*NUM_SETS](\n    -0.365012, 0.113198, 0.728690, 0.532211, 0.307810, 1.020798, -1.093627, -0.402579, -1.187197, 0.234389, 0.575446, 0.278413, -0.723809, -0.103608, 0.835509, -0.536590, -0.896289, -0.910966, -1.064098, 0.575108, 0.122817, 0.132315, 0.549229, -0.323954, 0.576727, -0.102974, 0.941263, 0.311224, 0.817682, -0.527912,\n    0.794040, 0.201886, -0.172050, -0.379148, -0.800696, -0.023903, 0.483914, -0.403474, 1.119349, 0.016700, -0.817502, -0.509113, 1.071045, 0.316189, 0.411465, -0.616891, 0.978903, -0.691962, -0.511872, 0.475321, 0.000099, -0.615705, -0.196656, -0.429549, 0.848504, -0.547946, 0.373088, 0.376478, 0.396687, 0.084169,\n    -1.017237, -0.903984, -0.512759, 0.476637, 0.271241, -1.150559, 0.560693, 0.097803, -0.407286, 0.882287, 0.180914, -0.420358, -1.081892, 0.498610, 1.087361, 0.243611, 0.331453, -0.502525, -0.359248, 1.084326, 0.834692, -0.634044, 0.660750, 1.096257, -0.059903, 0.350534, 0.602114, 0.025440, 0.993483, -0.476214, \n    -0.786305, -0.298404, 0.372053, 0.756946, 0.353847, -0.400713, -0.932856, 0.917608, 0.942425, -1.004183, 0.381193, 0.093966, -0.324366, -0.402953, -0.055247, 0.244378, -0.013363, 0.294876, 1.054206, 0.307839, -0.879138, -0.464629, -0.686187, 0.719042, -0.490385, 0.648228, 0.471379, 1.016690, 0.300288, 0.150001,\n    0.803768, 0.661441, -0.424644, -0.470243, 0.050267, 0.514802, -0.649469, -0.705689, -0.561211, 0.101740, -1.175427, -0.765153, -0.490339, -0.606044, 0.322624, 0.003870, -0.050577, 0.528116, -0.553878, 0.284891, -1.128502, 0.028663, -0.758520, 0.874346, -0.594991, -0.932099, -0.740500, 0.732730, 0.706501, 0.123612\n    //-0.562382, -0.825137, -1.091844, 0.935173, 0.601242, -0.918670, 1.099101, -0.671295, 0.738957, 1.030110, -1.097903, 0.612579, -0.473047, 0.018712, -0.357112, 0.799581, 0.887695, -0.229816, -0.074310, 0.315690, -0.276303, -0.932574, -0.477739, 0.275418, -0.853308, -0.168254, 1.003870, -0.000951, -0.250323, 0.2687860,\n    //-0.309574, 0.807723, 1.025505, 0.573068, 0.683365, -0.181145, 0.211926, 0.113968, -0.376128, 0.349162, 0.928868, -0.210045, 0.710791, -0.298831, -0.512152, -0.401817, -1.091119, 0.196270, 0.055377, -0.082567, -0.349668, 0.714866, 0.824623, 0.354524, -0.234629, 0.597942, -0.974828, 0.301032, -0.329624, 0.257103,\n    //0.910843, 0.497447, 0.897955, 0.122985, -0.363504, 1.046468, 0.737447, -0.728952, -0.390985, -0.050037, 0.555775, 1.001503, 0.337579, -0.599918, 0.161471, -1.068861, -0.708915, -0.480711, -0.591640, 0.913434, 0.496210, -1.178109, -0.016749, -1.072668, 0.135254, 1.178998, -0.457025, 0.273666, 0.353600, 0.821535, \n    //-0.172477, -0.055175, 0.630376, -0.418818, -0.587702, 0.292670, 0.355657, -0.705739, -0.472009, 0.419189, 0.587554, -0.142814, 0.094523, 0.889469, 0.656007, 0.185450, 0.865860, -0.245562, 0.878038, 0.449732, 0.336955, 0.256571, -0.563523, 0.665381, 0.152538, 0.562831, -0.713084, 0.001681, 0.537751, 0.111259,\n    //-0.110493, 0.867670, 0.816344, -1.035664, 0.518601, 0.971636, 0.412624, -0.022961, -1.112663, 0.371931, 0.800081, 0.640390, -0.718583, 0.053005, -0.602554, 0.670707, 0.581050, 0.503452, 0.579796, -0.394368, 0.271451, 1.083272, -0.469859, -0.923139, 0.163897, 1.190899, -0.552614, -0.471609, -0.999791, -0.105114\n);\n\nfloat[30] c;\n\n\nvec3 map(vec3 v){\n    vec3 newV;\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n    float xy = x*y;\n    float yz = y*z;\n    float xz = x*z;\n    newV.x = c[0]*x  + c[1]*y  + c[2]*z  + c[3]*xy  +c[4]*yz  + c[5]*xz  + c[6]*xx  + c[7]*yy  + c[8]*zz  + c[9];\n    newV.y = c[10]*x + c[11]*y + c[12]*z + c[13]*xy +c[14]*yz + c[15]*xz + c[16]*xx + c[17]*yy + c[18]*zz + c[19];\n    newV.z = c[20]*x + c[21]*y + c[22]*z + c[23]*xy +c[24]*yz + c[25]*xz + c[26]*xx + c[27]*yy + c[28]*zz + c[29];\n    return newV;\n}\n\nfloat mod2(vec3 V)\n{\n    return V.x*V.x+V.y*V.y+V.z*V.z;\n}\n\nfloat permute(float x) {\n  return mod(x*1693.0+242.0,4800.0);\n}\n\n#define PI 3.14159265359\nfloat cosstep(float x)\n{\n    return (1.0 - cos(PI*x))/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2((fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    vec3 z = vec3(0.0);\n    vec3 dz = vec3(0.0);\n    int index[2];\n    int iNext[2];\n    float T[2];\n    float t, t2;\n    float perm;\n    float T2[2];\n    vec3 av = vec3(0.0);\n    int i;\n    float d;\n    vec4 col;\n    float m,mu;\n    vec3 norm;\n    float m2;\n    \n    T[0] = float(floor(iTime/TIME_SCALE));\n    T[1] = T[0]+1.0;\n    t = cosstep(fract(iTime/TIME_SCALE));\n    perm = permute(permute(T[0]));\n    index[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    index[1] = int(mod(perm,30.0));\n    perm = permute(permute(T[1]));\n    iNext[0] = int(mod(perm,30.0));\n    perm = permute(perm);\n    iNext[1] = int(mod(perm,30.0));\n    \n    T2[0] = floor(iTime/TIME_SCALE);\n    T2[1] = T2[0] + 1.0;\n    t2 = cosstep(fract(iTime/TIME_SCALE));\n    perm = permute(permute(T2[0]));\n    int coefIndex[2];\n    coefIndex[0] = int(mod(perm, float(NUM_SETS)));\n    perm = permute(permute(T2[1]));\n    coefIndex[1] = int(mod(perm, float(NUM_SETS)));\n    \n    for(int i = 0; i < 30; i++){\n        c[i] = coef[coefIndex[0]*30+i] * (1.0-t2);\n        c[i] += coef[coefIndex[1]*30+i] * t2;\n    }\n    \n    uv*=10.0;\n    c[index[0]] += (1.0-t)*uv.x;\n    c[index[1]] += (1.0-t)*uv.y;\n    c[iNext[0]] += t*uv.x;\n    c[iNext[1]] += t*uv.y;\n    \n    #define ITER 128\n    for(i = 0; i < ITER; i++)\n    {\n        z = map(z);\n        m= length(z);\n        if(m>1.5e9) break;\n    }\n    \n    mu = float(i) - (log(log(m)))/log(2.0);\n    col = vec4((cos(mu)+1.0)/2.0);\n    if(col.x <0.0) col.x = 1.0;\n    if(col.y <0.0) col.y = 1.0;\n    if(col.z <0.0) col.z = 1.0;\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsS3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3293, 3293, 3310, 3310, 3865], [3867, 3867, 3887, 3887, 3925], [3927, 3927, 3951, 3951, 3990], [4017, 4017, 4041, 4041, 4077], [4079, 4079, 4136, 4136, 5863]]}
{"id": "wsS3Wc", "name": "r1", "author": "ali", "description": "inspired by : https://www.shadertoy.com/view/4d2yW1", "tags": ["idk"], "likes": 2, "viewed": 69, "published": "Public", "date": "1550114557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tconst float pi = 3.1415926535;\n    vec2 p = fragCoord.xy - iResolution.xy / 2.0;\n    float phi = atan(p.y, p.x );\n\n    float ks =sin((iTime/17.))*13.;\n    float fin = floor(phi *ks / pi + 0.5);\n    float phi_fin = fin * pi / ks;\n\n    vec2 dir = vec2(cos(phi_fin), sin(phi_fin));\n    float l = dot(dir, p) ;\n\n    float ivr = 13.0;\n    float seg = l / ivr;\n\n    float w = sin(floor(seg) * 0.2 - iTime) * 0.4 + 0.5;\n    float c = (w / 2.0 - abs(fract(seg) - 0.5)) * ivr;\n\n    fragColor = vec4(c*sin(ks/2.), c*0.1, 0.5*c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 583]]}
{"id": "wsS3WG", "name": "diffractoscope 4", "author": "pde", "description": "play with the mouse; try out the corners; also watch time evolution", "tags": ["moire", "tentacles"], "likes": 2, "viewed": 106, "published": "Public", "date": "1550089747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void coords(in vec2 coord, out float radius, out float angle, out vec2 xy)\n{\n    // transform input coord into our target space, both as cartesian xy\n    // and polar radius & angle\n    vec2 uv = coord/iResolution.xy;\n    uv.x = uv.x * iResolution.x / iResolution.y;    \n    xy = (uv - 0.5) * 2.0;\n    xy.x = xy.x -0.8;\n    radius = length(xy);\n    angle = (atan(xy.y/xy.x));\n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy, mouse_xy;\n    float angle, radius, mouse_a, mouse_r;\n    float pi = 3.141592654;\n    // transform both the pixel and mouse coordinates\n    coords(fragCoord, radius, angle, xy);\n    coords(iMouse.xy, mouse_r, mouse_a, mouse_xy);\n    angle = angle+mouse_a;\n    \n    // we have a growing oscillation that winds back and forwards with log-increasing period\n    float oscTime = pow(iTime,1.0) * cos(log(iTime+1.0));\n    \n    // shimmy is the wiggle in the radial tentacle pattern\n    float shimmy = mouse_r*oscTime*cos(12.0*radius + iTime*2.0)*exp(-3.0*radius);\n    \n    // effective angle\n    float e_angle=angle+shimmy*0.2;\n       \n    // our red color is a swirling shiny pattern\n    float red=abs(sin(iTime+angle+radius+shimmy));\n    \n    // this defines the radius of the pattern\n    float radius_of_shape=0.7 + 0.4 * sin (24.0 * pi * e_angle * (10.0 *mouse_a)) * sin (4.0*pi*mouse_a*e_angle);\n    float blue = 0.4+ radius_of_shape - radius;\n    //blue = 1.0;\n    float green = 0.0;\n    if (radius > radius_of_shape) {\n        green = -blue; blue=0.0;red=0.0;\n    }\n    \n    \n    fragColor = vec4(red, green, blue, 0.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 181, 389], [391, 391, 448, 448, 1585]]}
{"id": "wsSGDG", "name": "Octahedron - distance", "author": "iq", "description": "Exact distance to an octahedron. Beware, most implementations our there are wrong in that they return a bound, not the exact distance. Having the exact distance, although more expensive, allows to do proper euclidean operations on it, such as rounding.", "tags": ["3d", "distancefield", "sdf", "distance", "octahedron"], "likes": 15, "viewed": 2148, "published": "Public API", "date": "1549862672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// EXACT distance to an octahedron. Most of the distance functions you'll find\n// out there are not actually euclidan distances, but just approimxations that\n// act as bounds. This implementation, while more involved, returns the true\n// distance. This allows to do euclidean operations on the shape, such as \n// rounding (see http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n// while other implementations don't. Unfortunately the maths require us to do\n// one square root sometimes to get the exact distance to the octahedron.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    \n#if 0\n    // filbs111's version (see comments)\n    vec3 o = min(r, 0.0);\n    o = max(r*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n#else\n    // my original version\n\tvec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n#endif    \n}\n\n\nfloat map( in vec3 pos )\n{\n    float rad = 0.1*(0.5+0.5*sin(iTime*2.0));\n    return sdOctahedron(pos,0.5-rad) - rad;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGDG.jpg", "access": "shaders20k", "license": "mit", "functions": [[1628, 1775, 1812, 1812, 2339], [2342, 2342, 2368, 2368, 2460], [2462, 2526, 2558, 2558, 2797], [2817, 2817, 2874, 2899, 4437]]}
{"id": "wsSGDV", "name": "CPPN #62", "author": "eps", "description": "CPPN to GLSL \nhttps://github.com/wxs/cppn-to-glsl\nmixed4e_pool_reduce_pre_relu:62 ", "tags": ["cppn"], "likes": 10, "viewed": 366, "published": "Public", "date": "1550008310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 24\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.33895856,0.18147796,-0.19505174,0.1311849) + mat4(vec4(0.7518298029899597,-1.347240686416626,0.6439601182937622,-1.0130223035812378),vec4(0.5928223729133606,-1.175956130027771,0.982658863067627,1.2399333715438843),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(-0.22542596,0.0014959802,-0.39894506,-0.06029384) + mat4(vec4(0.37649235129356384,1.1847352981567383,0.18476060032844543,-0.14549031853675842),vec4(-0.3617017865180969,0.10274992138147354,-0.8161017894744873,0.05104842782020569),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.308657,0.070627965,0.2618027,0.46892673) + mat4(vec4(-0.8349474668502808,0.21140459179878235,-0.1763724684715271,-0.18687540292739868),vec4(0.11678159981966019,0.0752866342663765,0.32274046540260315,0.018572496250271797),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(0.32279697,0.22012356,0.19692256,-0.019974919) + mat4(vec4(0.0080359922721982,0.3293400704860687,0.13696399331092834,0.5282223224639893),vec4(0.03214113414287567,0.3015969395637512,-1.3669450283050537,-1.4320826530456543),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[4] = vec4(-0.30109072,0.041650202,-0.23534024,0.20897567) + mat4(vec4(0.5619973540306091,0.610148012638092,-0.2789373993873596,-0.09835441410541534),vec4(-0.06493046134710312,-0.22605925798416138,0.23467165231704712,0.7497353553771973),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[5] = vec4(0.32819498,0.29038897,0.18691163,-0.46963477) + mat4(vec4(0.6674495935440063,-0.4540223777294159,0.7770633697509766,-0.5905131101608276),vec4(0.14384661614894867,0.6780056953430176,-0.02742173708975315,-0.9880178570747375),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 1 \nbufA[0] = vec4(0.05871301,0.21272922,-0.2722246,0.14121573) + mat4(vec4(0.18709148,0.074149534,-0.027542667,-0.03411758),vec4(0.20890649,-0.3628758,-0.228123,-0.028920414),vec4(-0.21388537,0.3055199,0.12377522,0.11829814),vec4(0.10639633,-0.0653782,-0.0069036125,-0.3422563)) * bufB[0] + mat4(vec4(0.043907665,0.20581788,0.27188593,0.14836963),vec4(0.14688599,-0.022064267,0.10522976,-0.019090649),vec4(0.0646538,0.3229842,0.22202992,0.40095243),vec4(0.0445807,-0.14312837,-0.0988746,0.0057976246)) * bufB[1] + mat4(vec4(0.021971274,0.025373617,0.0726241,0.094291866),vec4(0.09926468,-0.10045447,0.045943446,0.16141804),vec4(0.49315664,-0.15013476,-0.074637696,-0.21771705),vec4(0.1428262,-0.27164316,-0.27797034,-0.17040682)) * bufB[2] + mat4(vec4(0.019930918,0.048150863,0.0008924046,-0.2221685),vec4(-0.073047616,-0.1890803,-0.14537124,-0.31356555),vec4(0.06951617,0.07450851,-0.06339707,0.07894487),vec4(0.2953779,-0.0018454511,-0.059294384,-0.08796858)) * bufB[3] + mat4(vec4(-0.11978362,-0.024361748,0.14190339,0.09658976),vec4(0.14618786,0.12135164,-0.1712494,0.2784688),vec4(-0.15306276,0.21581511,0.14883262,-0.0077137933),vec4(-0.08193978,0.027946183,-0.0752353,-0.39883468)) * bufB[4] + mat4(vec4(0.11956629,-0.034437563,-0.13237065,-0.085202225),vec4(0.25558317,-0.011042672,-0.22945717,-0.16137649),vec4(0.17282096,-0.08247776,-0.007210612,0.10851778),vec4(-0.017847432,0.0031411466,0.22426635,-0.071967945)) * bufB[5] + mat4(vec4(0.0042883563,0.288581,0.42157307,0.36653838),vec4(-0.07958004,0.14636508,0.011676802,-0.07325427),vec4(0.027272528,-0.2793097,-0.04800376,0.11431217),vec4(-0.11827772,0.10171754,-0.1261419,-0.124502815)) * bufB[6] + mat4(vec4(-0.12496555,0.066002026,-0.07150016,0.16500428),vec4(0.038447354,-0.046835262,0.07299388,0.24118988),vec4(-0.24262792,0.24003464,-0.26017377,-0.08645974),vec4(0.027844593,-0.00086178817,0.06087436,-0.041862804)) * bufB[7] + mat4(vec4(-0.19963314,0.044468854,0.105245255,0.17477588),vec4(-0.013070473,0.06665319,0.26774734,0.0009681203),vec4(-0.48911485,-0.05099972,-0.3534363,-0.0778393),vec4(-0.04724497,-0.19453166,-0.2731654,-0.09629373)) * bufB[8] + mat4(vec4(0.18153007,0.14676839,-0.24817273,-0.05542403),vec4(-0.06636217,-0.009709157,0.3219634,0.11773564),vec4(0.044453513,-0.004205105,0.26917702,-0.027699765),vec4(-0.10603546,0.32038748,0.07938839,-0.05745303)) * bufB[9] + mat4(vec4(0.050042763,-0.09900566,-0.13523036,0.03227603),vec4(-0.22210033,-0.14864616,0.38573,0.07997318),vec4(-0.08290844,-0.109498255,0.07693886,-0.24025767),vec4(-0.28424224,0.38264292,0.33092704,0.04994828)) * bufB[10] + mat4(vec4(0.24715205,-0.02248958,0.1877522,0.3690862),vec4(-0.31155655,0.11016694,-0.055580314,-0.37308338),vec4(0.17839125,-0.046368435,0.2005912,0.05115882),vec4(0.023695461,0.034191962,0.37087554,0.10821759)) * bufB[11];\nbufA[1] = vec4(-0.39691687,-0.35113722,0.29679188,0.45178112) + mat4(vec4(0.24602054,-0.33983046,0.30831066,-0.07490903),vec4(-0.17526281,0.042953953,-0.058714826,-0.041968156),vec4(0.1640351,0.115192026,0.026900465,-0.09086071),vec4(-0.7032636,0.26936695,0.14387172,-0.07832794)) * bufB[0] + mat4(vec4(-0.0043179006,-0.41723233,-0.12622912,-0.1441497),vec4(0.10796018,-0.1988614,-0.020647448,-0.1678324),vec4(-0.08517324,-0.32114762,-0.32932836,-0.07586045),vec4(0.050183695,-0.08191236,-0.06654835,-0.08683906)) * bufB[1] + mat4(vec4(-0.058862887,-0.097288266,-0.05568772,0.10855064),vec4(0.086817645,-0.1331148,-0.08356406,-0.054626346),vec4(0.13716312,0.27326924,-0.07188314,0.12505561),vec4(0.07219121,-0.05100581,-0.05968401,0.18108371)) * bufB[2] + mat4(vec4(-0.29142967,0.21696223,0.31678048,0.25383508),vec4(0.26436746,0.2318967,0.24312301,0.04747388),vec4(0.22643179,0.014783889,-0.049248446,0.13555808),vec4(0.1616401,-0.092852205,0.16275226,0.033830732)) * bufB[3] + mat4(vec4(0.05189424,-0.12476061,0.08257374,0.18000579),vec4(0.35372272,-0.029162917,0.06882266,0.033195708),vec4(-0.40710112,-0.07917801,-0.06802278,0.076803155),vec4(-0.10879397,0.18539074,0.15045308,-0.13646892)) * bufB[4] + mat4(vec4(-0.030398335,0.046919692,0.059858594,0.11372287),vec4(-0.22323824,0.3275952,0.051230107,0.1466344),vec4(0.45161036,-0.52261114,0.081269585,-0.008727047),vec4(-0.05850722,0.037457004,-0.10746394,-0.19308876)) * bufB[5] + mat4(vec4(0.17599918,-0.44519907,-0.046345077,-0.018265055),vec4(-0.30837506,-0.2912683,0.037485622,-0.048889942),vec4(-0.12281166,0.1675576,-0.08401128,0.23523451),vec4(-0.32034272,0.064629264,0.044541355,-0.36667174)) * bufB[6] + mat4(vec4(-0.18072636,0.2972973,-0.22705385,-0.22012386),vec4(-0.14264145,-0.08769241,0.23764619,-0.25636676),vec4(-0.40039918,0.19108874,-0.05435381,-0.0153704025),vec4(0.0131731685,-0.36309907,0.014774883,-0.20877458)) * bufB[7] + mat4(vec4(0.10754019,-0.12569726,0.11843766,0.0412169),vec4(-0.017483339,-0.3134677,0.2406945,-0.008869686),vec4(-0.21079165,0.15568237,0.11407368,-0.115857564),vec4(0.071433954,0.40372053,-0.24919194,0.076222345)) * bufB[8] + mat4(vec4(0.0033579785,-0.0607095,0.10437418,0.06820135),vec4(-0.078896016,-0.42345813,0.1480483,-0.19983496),vec4(0.19519034,0.11632362,-0.10337294,-0.13969535),vec4(0.003595055,0.062043548,0.09398027,-0.07020473)) * bufB[9] + mat4(vec4(-0.040586717,0.13480198,-0.031001294,-0.094684735),vec4(-0.3570871,-0.14646554,0.22578952,-0.0046218084),vec4(0.27886435,0.060044765,0.20265056,0.21014272),vec4(-0.014837497,-0.106268145,-0.40431646,-0.22265023)) * bufB[10] + mat4(vec4(0.20723058,-0.29688928,0.26327476,-0.046024203),vec4(-0.31716278,0.23086774,0.07576422,-0.3794756),vec4(0.14364381,-0.2651919,0.28092158,0.26128858),vec4(-0.09896576,-0.3630138,-0.29282266,-0.101060465)) * bufB[11];\nbufA[2] = vec4(0.2071007,-0.38800728,0.37852535,0.5502636) + mat4(vec4(-0.07749668,-0.0544416,0.13945475,0.14515932),vec4(0.22814794,-0.16253768,0.16583842,0.0052049714),vec4(0.02348407,0.2906237,-0.03586363,-0.102548584),vec4(0.15315159,-0.03497173,-0.23609956,-0.13873397)) * bufB[0] + mat4(vec4(-0.18151602,-0.053189207,-0.17361966,0.08483119),vec4(0.2679969,0.34396237,-0.13739885,0.008999725),vec4(0.021495933,0.29904407,0.095595516,-0.13569568),vec4(0.04986622,-0.037188947,-0.13496278,-0.046396896)) * bufB[1] + mat4(vec4(0.20279667,-0.055922203,-0.0020021996,-0.17778067),vec4(-0.0679341,-0.17134778,0.0055961413,0.14490019),vec4(0.27205354,-0.082188934,0.11913694,0.25495476),vec4(-0.0087603675,-0.083241664,0.28609237,0.28874022)) * bufB[2] + mat4(vec4(-0.036375023,0.028092202,0.11764514,0.17886047),vec4(0.2504565,0.07369878,0.28041616,0.055263218),vec4(-0.02309186,-0.14590771,0.19783802,0.048749767),vec4(0.12027039,0.14433686,0.0049465275,-0.10070273)) * bufB[3] + mat4(vec4(0.031161662,-0.01930886,-0.21973334,-0.07919443),vec4(0.010429952,-0.06814579,0.013464582,-0.18656108),vec4(0.12697499,-0.06900255,-0.15540938,-0.28756887),vec4(-0.10504989,0.0028188662,-0.20083947,0.10954511)) * bufB[4] + mat4(vec4(0.039494038,-0.115280375,0.25894734,0.25247595),vec4(-0.026208391,-0.29105288,-0.013481579,0.16127075),vec4(0.02048058,-0.029947741,0.0044985153,0.20450637),vec4(-0.23081434,0.027168356,0.055259876,0.2199478)) * bufB[5] + mat4(vec4(-0.1803863,0.16494045,-0.16709259,0.026439453),vec4(0.18519568,0.03595847,0.11584002,-0.093429096),vec4(-0.085156135,0.023779312,-0.020350415,-0.100789815),vec4(-0.22695768,0.05688191,-0.095591664,-0.23086044)) * bufB[6] + mat4(vec4(0.13890176,0.13806388,-0.11681759,-0.02963919),vec4(0.013519893,-0.00523484,0.26553667,-0.29449856),vec4(-0.49730107,-0.13475432,-0.4670841,-0.22539632),vec4(-0.09373831,0.14223164,-0.02992715,-0.07584923)) * bufB[7] + mat4(vec4(-0.04417422,0.00094125874,-0.3053866,-0.17184031),vec4(-0.023448536,0.30763987,-0.24813387,-0.09724191),vec4(-0.008215687,0.10518815,0.023128346,-0.27588132),vec4(0.3861333,0.10005597,0.010942465,0.3506273)) * bufB[8] + mat4(vec4(0.24480063,0.13332173,0.11726477,-0.18750995),vec4(-0.24365613,0.49705493,-0.32289055,-0.036437653),vec4(0.12262312,0.045521196,0.10154965,-0.07736518),vec4(0.09760428,-0.10208738,-0.21389146,-0.23086038)) * bufB[9] + mat4(vec4(0.03314996,0.06144645,-0.069983914,-0.071501575),vec4(0.022288095,0.07807993,0.03401569,-0.13032638),vec4(0.058958586,0.06367544,0.119207785,0.2156177),vec4(-0.52433497,0.11061153,-0.47074553,-0.34208596)) * bufB[10] + mat4(vec4(0.19040269,0.29479688,-0.341871,0.045058798),vec4(-0.2574175,-0.071996175,-0.14349568,0.00019562128),vec4(0.010158362,0.2705645,-0.23815848,0.22122242),vec4(-0.16203547,0.53580415,-0.4435722,-0.10209995)) * bufB[11];\nbufA[3] = vec4(-0.17861201,-0.47036576,0.48608586,-0.4028523) + mat4(vec4(-0.073870435,-0.20813559,0.39726144,-0.113217875),vec4(-0.37980995,0.05323572,-0.29888013,-0.1711635),vec4(0.19241898,0.0034173958,0.16236559,0.18220484),vec4(-0.25706843,0.0022586272,0.14539969,0.24379843)) * bufB[0] + mat4(vec4(-0.03872372,0.08005299,0.05736699,-0.16540867),vec4(0.15798819,0.027173748,0.024820523,0.011119639),vec4(-0.026762148,0.26776475,0.0075083803,0.37041092),vec4(0.26887834,0.04474288,-0.13826741,0.0026889557)) * bufB[1] + mat4(vec4(0.19412385,-0.0953299,0.01972267,0.18911757),vec4(-0.10083928,0.19359568,-0.009332947,-0.23552515),vec4(-0.026053142,-0.08566374,0.07233238,-0.12816942),vec4(-0.094690025,-0.1485216,0.2513514,-0.47880623)) * bufB[2] + mat4(vec4(-0.2655635,-0.1170396,0.15924573,-0.17918351),vec4(-0.30994833,-0.13793653,0.2138225,-0.030142227),vec4(-0.18507433,-0.3304501,0.31634626,-0.13923658),vec4(-0.11878004,-0.23257516,-0.12826268,0.007864658)) * bufB[3] + mat4(vec4(0.09813738,0.16294616,-0.15508077,0.0685889),vec4(-0.13424246,0.13330175,0.25298595,-0.160395),vec4(0.08441835,-0.04919915,0.110268064,-0.11806068),vec4(-0.044083614,0.0020795022,-0.062002685,-0.14897285)) * bufB[4] + mat4(vec4(-0.27889985,-0.2572538,0.12674749,0.12139368),vec4(0.18354197,-0.087836556,0.12614782,-0.24337614),vec4(-0.10216267,0.039410695,0.11932123,-0.11900191),vec4(-0.06028417,0.19686449,-0.24167748,0.110720426)) * bufB[5] + mat4(vec4(0.25312734,0.2776738,-0.054207448,0.53917724),vec4(-0.1695154,0.1470479,-0.23365912,0.029462036),vec4(0.0057016644,0.10058742,-0.41680178,-0.03916303),vec4(0.056833263,0.16158459,-0.2605911,0.15520449)) * bufB[6] + mat4(vec4(0.34394002,0.039024286,-0.01623842,0.031056315),vec4(-0.023891687,-0.097868405,0.28864542,0.2945017),vec4(0.36633995,0.35785446,-0.38463727,-0.2150956),vec4(0.3169941,-0.082532115,-0.16177149,0.3350611)) * bufB[7] + mat4(vec4(0.12572175,-0.0049420777,0.23469459,0.16034196),vec4(0.1702251,-0.26806393,-0.27399755,0.47552592),vec4(0.28391927,0.18137802,-0.042616803,-0.24759616),vec4(0.0065297163,-0.19801494,-0.16474372,0.054267317)) * bufB[8] + mat4(vec4(0.013605888,-0.34054792,-0.035036884,0.022947546),vec4(0.44956052,0.24776584,-0.17210272,0.5167862),vec4(-0.0032744098,0.07911749,-0.246245,-0.004205093),vec4(0.1541527,-0.049929824,0.015351262,-0.20901081)) * bufB[9] + mat4(vec4(0.044781253,-0.07192816,0.046787277,0.13227415),vec4(0.2330093,0.3042251,0.006887787,0.11392833),vec4(0.15006192,-0.1804252,0.16367796,-0.10588299),vec4(0.12741064,0.27547204,-0.423888,-0.21383889)) * bufB[10] + mat4(vec4(0.26918334,0.19829524,0.19092633,0.549451),vec4(0.25580946,0.24934645,-0.1241359,0.008450561),vec4(0.19851999,0.1199214,0.061793383,0.4993646),vec4(0.17995463,-0.10823604,-0.12962084,0.34021765)) * bufB[11];\nbufA[4] = vec4(-0.2682996,0.43696925,0.39433053,0.03089033) + mat4(vec4(0.28984454,-0.18681058,-0.085965656,0.18818057),vec4(-0.3791844,-0.18487862,0.120180234,-0.38192204),vec4(0.24406555,-0.10147261,-0.04294491,0.04619109),vec4(-0.091864415,-0.2909374,0.07926457,0.14604586)) * bufB[0] + mat4(vec4(0.14596991,0.2044771,-0.0663688,0.12910792),vec4(0.24026456,0.06572999,-0.03763407,-0.087968774),vec4(-0.3532964,0.07849816,0.248676,-0.059723012),vec4(0.008381483,0.058170307,-0.21007602,0.010438019)) * bufB[1] + mat4(vec4(-0.19717142,-0.07656618,-0.26659727,-0.13157739),vec4(0.2253013,-0.17900437,0.16950989,0.13679534),vec4(-0.0043599126,-0.13773942,0.10232641,0.14749332),vec4(-0.41950765,0.31126764,0.21848881,-0.014541232)) * bufB[2] + mat4(vec4(-0.046410166,-0.081909284,0.29714116,0.07110539),vec4(0.29560772,0.007929045,0.063945524,0.15076233),vec4(-0.1904831,0.3430187,0.07319477,0.17356715),vec4(-0.0012052648,0.16538829,0.18667147,0.02620698)) * bufB[3] + mat4(vec4(-0.025827626,-0.042130332,-0.16792783,-0.010780949),vec4(0.29301792,0.4341977,-0.049202405,-0.13722117),vec4(-0.24526626,-0.11335729,-0.36453652,0.067966916),vec4(-0.08754329,-0.22348094,-0.08018507,0.32116055)) * bufB[4] + mat4(vec4(0.11741604,-0.22440894,0.15021506,0.0065786494),vec4(-0.198018,-0.21458955,-0.21591899,0.28137794),vec4(0.13605547,-0.060531497,-0.018199582,-0.0016612589),vec4(-0.298709,0.32035065,0.17369221,0.107384145)) * bufB[5] + mat4(vec4(0.2184284,-0.11065005,-0.30340266,0.07994067),vec4(-0.10897796,-0.2785227,0.0012374171,-0.11304256),vec4(-0.2184457,0.027842507,-0.096017994,-0.34120524),vec4(-0.059562195,-0.017150212,0.14080621,0.05173275)) * bufB[6] + mat4(vec4(0.022877656,-0.38147113,-0.32265803,-0.0391993),vec4(-0.112627804,-0.22636843,-0.2554902,0.193049),vec4(-0.2822513,0.2205234,-0.013053987,-0.3711575),vec4(-0.15205121,-0.48949116,-0.28751302,0.10126937)) * bufB[7] + mat4(vec4(0.14726582,-0.39476085,-0.2696562,0.5307748),vec4(0.21044445,-0.03313862,-0.2279345,0.18559967),vec4(-0.32945302,-0.21638247,-0.12452034,0.019671157),vec4(-0.30338538,0.08605797,0.13739972,0.021237863)) * bufB[8] + mat4(vec4(-0.1447317,0.24099757,0.14696601,-0.09387624),vec4(0.11668061,-0.10217366,-0.2659806,0.14679639),vec4(-0.3062554,0.13375369,0.08829976,-0.06987651),vec4(0.01934106,0.11891676,0.17924714,-0.22370769)) * bufB[9] + mat4(vec4(-0.047939602,-0.10011582,-0.15050723,0.30147856),vec4(-0.08713827,-0.5712163,-0.5141832,0.3354668),vec4(0.11165569,0.13107197,0.098838896,-0.07896826),vec4(-0.24909145,0.17129011,-0.017071396,-0.48458648)) * bufB[10] + mat4(vec4(0.631542,-0.36999467,-0.21207811,0.15905982),vec4(-0.25953197,0.044027343,0.11977761,0.10272987),vec4(0.19010252,-0.5564631,-0.6350294,0.2807133),vec4(-0.24052921,-0.0423435,0.35575807,0.017777001)) * bufB[11];\nbufA[5] = vec4(0.14278518,0.3829121,-0.2842381,-0.34384847) + mat4(vec4(-0.184337,-0.09325044,-0.15335247,-0.07665427),vec4(-0.073803924,0.12173065,0.11560374,-0.00035571516),vec4(-0.07818308,-0.058022767,-0.18650496,0.3672543),vec4(0.20624475,0.08675564,0.26982567,0.35917372)) * bufB[0] + mat4(vec4(0.05358245,-0.2672184,-0.007206838,-0.04551418),vec4(-0.15974076,-0.29409003,-0.51300627,-0.2499816),vec4(0.15372096,-0.27489895,0.084585905,-0.29181382),vec4(0.07441159,-0.12863892,0.19689502,0.050310854)) * bufB[1] + mat4(vec4(0.23060422,-0.20050973,0.41182172,0.3150606),vec4(-0.095479935,-0.090374224,-0.035143625,0.050251484),vec4(-0.08648165,0.07851428,0.15756372,0.10341421),vec4(-0.1147568,0.039604787,0.10964222,0.15496819)) * bufB[2] + mat4(vec4(-0.20020363,0.3378364,-0.12856625,-0.20285955),vec4(-0.08720437,0.04849141,0.124900885,0.07378377),vec4(-0.18780391,0.10400624,0.052741285,-0.14440908),vec4(-0.35493353,0.042276025,-0.019881576,-0.3614643)) * bufB[3] + mat4(vec4(-0.021609824,-0.2278556,-0.048285596,0.045100152),vec4(-0.09177081,0.042382397,-0.18716867,0.0441165),vec4(0.33817807,-0.22748634,0.008601024,0.18075264),vec4(0.09067905,-0.09063155,0.101346776,0.15800548)) * bufB[4] + mat4(vec4(-0.06570068,0.30353495,-0.3821235,-0.22807305),vec4(0.15028593,-0.15345377,0.1200289,0.1187137),vec4(-0.16009861,0.2587319,-0.12265498,-0.35551715),vec4(-0.07765572,0.25953874,0.031585142,-0.042151053)) * bufB[5] + mat4(vec4(-0.03262453,-0.16361575,0.06947807,0.07631308),vec4(-0.022676311,0.25529376,-0.02570851,0.13907546),vec4(-0.0792484,-0.068133995,-0.054101802,-0.033588573),vec4(0.39575145,-0.09338755,-0.15865695,-0.17563534)) * bufB[6] + mat4(vec4(0.3709585,-0.049095504,0.00782359,0.1027759),vec4(0.21262975,-0.16384767,0.22316733,0.24552144),vec4(0.11093888,0.021134196,-0.07182711,0.026681215),vec4(0.41155046,-0.08838878,-0.17798744,0.09853012)) * bufB[7] + mat4(vec4(0.22443005,-0.46947357,0.037782528,0.24063925),vec4(0.012890993,-0.18916509,0.41498992,0.15049222),vec4(0.47849175,0.21602961,0.3487766,-0.021862376),vec4(-0.112101965,-0.11423579,0.2256952,0.020424178)) * bufB[8] + mat4(vec4(-0.020552127,0.17128637,-0.0586909,0.25426343),vec4(-0.040104188,-0.35454598,0.14159767,0.12602225),vec4(-0.25459635,0.20675753,0.0056066066,-0.4300024),vec4(0.07670352,-0.021315448,-0.018392958,-0.26240876)) * bufB[9] + mat4(vec4(0.025211243,-0.08311459,0.2793595,0.10351395),vec4(0.33667824,-0.21812241,0.046548676,0.48549223),vec4(0.2291763,0.2607411,-0.0028114174,-0.09565729),vec4(0.25829613,-0.06674644,-0.078039974,-0.17381373)) * bufB[10] + mat4(vec4(-0.050721362,-0.5378258,0.06713103,0.17895599),vec4(0.23757535,-0.056588456,0.1693747,0.12432906),vec4(0.17220345,-0.1255742,-0.017769145,-0.06994488),vec4(-0.05800711,-0.21780723,-0.32716894,0.13730112)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 2 \nbufA[0] = vec4(0.0870981,-0.26997662,0.014111205,0.19130805) + mat4(vec4(0.24095134,-0.046612896,0.2318447,-0.0015513399),vec4(-0.21200535,-0.09017459,-0.1709167,0.3046464),vec4(0.0564847,0.23875408,0.071444735,0.26363453),vec4(0.30459952,-0.19363557,-0.024029851,0.20464395)) * bufB[0] + mat4(vec4(-0.19746022,-0.054865196,0.15045221,0.15696026),vec4(-0.029109636,0.13136418,-0.11643391,-0.41461706),vec4(0.14012524,-0.34279743,-0.20136108,0.121674195),vec4(0.030243367,-0.07901315,0.3955214,-0.22158836)) * bufB[1] + mat4(vec4(-0.06655281,-0.24194379,0.07331008,-0.3418639),vec4(-0.15217595,0.0039594686,0.046818618,0.39430124),vec4(0.5100075,-0.010547908,0.17778105,-0.33189732),vec4(0.07556693,-0.18395899,0.32689548,-0.06159359)) * bufB[2] + mat4(vec4(-0.15886581,0.25138485,-0.20458223,0.108199894),vec4(-0.18548615,0.38836804,-0.05279154,0.1990223),vec4(0.3285539,-0.25628084,0.22858556,0.0953179),vec4(-0.37360176,0.39514846,-0.14696185,0.33673382)) * bufB[3] + mat4(vec4(-0.00090653315,-0.22862262,-0.027757745,0.28393883),vec4(0.24007183,-0.049192283,0.09140407,-0.09478521),vec4(0.46798596,-0.28282094,0.2189009,-0.11853751),vec4(-0.13345861,-0.03422021,0.030270178,0.00042594678)) * bufB[4] + mat4(vec4(-0.33030513,0.13652596,-0.076860785,-0.41711763),vec4(0.15820666,0.07923069,-0.09757452,-0.21122257),vec4(-0.28790316,0.41135487,0.033746008,-0.40034932),vec4(-0.34309328,0.32184944,-0.1148563,-0.27355868)) * bufB[5] + mat4(vec4(-0.070749186,-0.034917332,-0.11263899,-0.3147793),vec4(-0.06084256,0.051465552,-0.063301854,-0.20571509),vec4(0.1549169,0.20798267,-0.2684637,0.34388113),vec4(-0.16046998,-0.028024433,-0.003242388,0.2684035)) * bufB[6] + mat4(vec4(-0.018224621,-0.0953428,-0.07816897,-0.09629304),vec4(-0.05262934,-0.13326444,-0.14154299,0.0742526),vec4(-0.1156513,-0.12545723,0.024707373,0.14556989),vec4(1.7676968e-05,0.20752904,-0.3511109,0.043155644)) * bufB[7] + mat4(vec4(0.0067210244,-0.089089446,-0.22453558,0.1699703),vec4(-0.30391905,-0.07198754,-0.110488385,0.107739896),vec4(0.07765131,-0.09748328,0.051876146,-0.23353598),vec4(0.037658893,0.35545644,-0.014709211,0.28974307)) * bufB[8] + mat4(vec4(-0.15236895,-0.058991592,-0.23828436,-0.27155572),vec4(0.005603198,0.0777711,-0.042790573,0.5147603),vec4(-0.097781755,0.15309379,0.13707902,0.18540832),vec4(0.01340133,0.3070232,0.06839553,0.17764811)) * bufB[9] + mat4(vec4(-0.16960712,0.19940838,-0.08496681,-0.18670285),vec4(0.021485388,-0.17554228,-0.22974697,-0.27548355),vec4(0.32861722,-0.0103743905,-0.16031191,-0.12648293),vec4(0.0045475042,0.113237955,0.19640402,-0.061115414)) * bufB[10] + mat4(vec4(-0.035019852,0.005504545,-0.06536979,0.200842),vec4(0.06505202,0.39992395,-0.011720207,-0.31855533),vec4(-0.10500171,-0.16136219,0.24592878,0.29498735),vec4(-0.015703304,-0.26517397,0.025092686,-0.2477894)) * bufB[11];\nbufA[1] = vec4(-0.06788344,-0.21311307,-0.3883699,0.042369228) + mat4(vec4(-0.25279632,0.15694393,0.07386027,0.38901636),vec4(0.425648,-0.07983261,-0.13797034,0.011998034),vec4(-0.12202696,-0.15100442,-0.079996645,-0.13486116),vec4(-0.26280507,-0.11930993,0.17794245,0.2034548)) * bufB[0] + mat4(vec4(-0.049860884,0.17128195,-0.3641564,0.183367),vec4(0.05053414,-0.021733958,-0.14897487,0.037399944),vec4(0.0065570073,0.23281792,-0.22808951,-0.1028241),vec4(-0.3947689,0.18144628,0.08822946,0.23413391)) * bufB[1] + mat4(vec4(-0.14136752,0.14138438,-0.16986303,0.14144497),vec4(0.15628447,0.0050612153,0.1755032,-0.1562723),vec4(-0.43913764,0.16634473,-0.13507223,0.346656),vec4(-0.04147447,0.23062095,0.15885536,-0.059740525)) * bufB[2] + mat4(vec4(0.54743326,-0.1135657,-0.091094814,-0.37545535),vec4(0.07466952,-0.5803862,-0.095466726,-0.3418723),vec4(0.07129842,0.2379224,-0.15881203,0.22860052),vec4(-0.13367343,-0.079332545,0.18595664,-0.07428939)) * bufB[3] + mat4(vec4(-0.081725515,-0.030864282,-0.0066192904,0.079459205),vec4(0.19338216,-0.11336734,0.09511228,0.3144423),vec4(0.239488,-0.04904598,0.09716672,0.3863868),vec4(-0.039609276,0.25275823,-0.19239323,-0.095018364)) * bufB[4] + mat4(vec4(-0.23710202,-0.13513567,-0.13840011,-0.17433007),vec4(-0.07602974,-0.13235068,0.10507886,0.17431651),vec4(-0.25384775,-0.031532202,0.09828667,0.14417665),vec4(-0.074681096,-0.039255053,0.11116586,-0.3832198)) * bufB[5] + mat4(vec4(-0.41134495,-0.18287866,0.1214886,0.10735877),vec4(-0.080867395,-0.18088362,-0.16286393,-0.1600046),vec4(-0.054858636,0.0025056768,0.27835432,0.0650007),vec4(0.08721499,-0.095308006,0.010973206,-0.097306356)) * bufB[6] + mat4(vec4(-0.18668623,0.0017295508,-0.18998575,-0.060490426),vec4(0.46530136,-0.055921536,-0.13742602,0.12269726),vec4(0.011092703,0.32828122,-0.12577763,0.057930745),vec4(-0.14145388,-0.033103447,-0.14301635,-0.058770984)) * bufB[7] + mat4(vec4(0.18396701,-0.18128292,0.11329974,-0.3545251),vec4(0.22269633,0.19455253,0.015722532,0.106753804),vec4(0.25559542,0.035293877,-0.26162428,-0.12063398),vec4(0.04017784,-0.49958912,0.26631916,-0.1771619)) * bufB[8] + mat4(vec4(0.035747286,0.23788597,-0.0093356725,0.048448127),vec4(0.19478522,-0.09064094,0.2337373,-0.2968349),vec4(0.15092862,0.07230589,0.45992273,0.08383767),vec4(-0.2639319,-0.21143848,-0.05704147,0.029066814)) * bufB[9] + mat4(vec4(-0.112285264,-0.018689368,-0.009722443,0.22542822),vec4(0.41433546,-0.25291237,-0.14950503,-0.23603493),vec4(0.16924863,-0.16909309,0.13247272,-0.2119716),vec4(0.42900273,0.21202041,-0.035432342,0.16017917)) * bufB[10] + mat4(vec4(0.13309398,0.045432005,0.0025805116,-0.15124807),vec4(-0.18266015,0.10226381,0.035896618,0.41194126),vec4(-0.2114217,0.14373998,-0.24847789,-0.063865714),vec4(0.29408777,0.19589351,0.01291286,0.12119393)) * bufB[11];\nbufA[2] = vec4(0.23720449,0.33959132,0.2136436,0.4662586) + mat4(vec4(-0.13090473,0.19880751,0.22478235,0.106688224),vec4(-0.040819377,-0.057922285,0.24144903,0.1220782),vec4(-0.2563254,0.097301975,0.01348224,-0.25130266),vec4(0.2973084,-0.007843907,0.10356111,-0.20421019)) * bufB[0] + mat4(vec4(-0.010936097,-0.08713394,0.13723357,0.028065901),vec4(0.05970654,0.024589375,-0.03067507,0.27620873),vec4(-0.19170444,0.15375803,0.16859567,-0.08903296),vec4(-0.041258454,0.052977614,0.30545858,-0.027895704)) * bufB[1] + mat4(vec4(0.07119167,0.044132788,-0.026499417,0.035632916),vec4(-0.37197235,0.048562326,0.19048129,-0.22947583),vec4(0.5039412,-0.26369837,-0.18034305,0.0675914),vec4(-0.331534,0.0013074734,0.24514173,0.08647539)) * bufB[2] + mat4(vec4(-0.34821528,0.32346568,0.17527936,-0.19317411),vec4(-0.03502767,0.07374055,-0.3254475,0.0323063),vec4(-0.21478792,0.30973122,0.22386707,0.096370995),vec4(-0.15036911,0.38174728,-0.02636669,-0.48604527)) * bufB[3] + mat4(vec4(-0.15336491,0.19471276,0.15790896,0.056804705),vec4(0.303309,-0.46457356,0.029174045,0.10829633),vec4(0.29191822,-0.058673777,0.17771165,0.29900414),vec4(-0.3461286,0.035935342,-0.029010858,-0.27180004)) * bufB[4] + mat4(vec4(-0.0715268,0.21704975,-0.37225026,0.12056842),vec4(0.35915017,-0.3741945,0.14123566,0.24433126),vec4(0.17063303,0.04836737,-0.18981296,0.11824361),vec4(-0.27001292,0.31075752,0.013150958,0.058782887)) * bufB[5] + mat4(vec4(-0.16833442,-0.2690668,-0.097672954,-0.1411121),vec4(0.0776839,0.13114612,-0.08850254,-0.21199866),vec4(0.02598737,-0.027779398,-0.42287654,-0.08900263),vec4(0.14123577,0.269062,-0.027214743,-0.015221528)) * bufB[6] + mat4(vec4(0.039320394,0.29434314,0.07326718,-0.10481205),vec4(0.26270264,0.25986746,0.05087922,-0.28605336),vec4(-0.019177835,0.14788756,-0.039545935,0.18984652),vec4(0.18593375,0.40334666,-0.04154458,0.03325538)) * bufB[7] + mat4(vec4(0.06761163,-0.10219284,-0.16542427,-0.0971616),vec4(0.00800868,0.1477322,0.021586582,-0.1788265),vec4(0.13036853,-0.32414004,0.038713764,0.23887563),vec4(-0.39608485,0.1035537,-0.25375846,0.16629142)) * bufB[8] + mat4(vec4(0.061055183,0.055925578,-0.06522514,0.14441313),vec4(-0.32798117,-0.17635103,-0.5506227,0.32445028),vec4(-0.39275324,-0.053580835,0.08635014,-0.11111217),vec4(-0.17801434,0.023381274,-0.19649397,0.13699265)) * bufB[9] + mat4(vec4(0.36783418,-0.22062837,-0.10479212,-0.23386882),vec4(-0.01303117,-0.121659815,-0.12788267,0.019509051),vec4(0.003248859,-0.23602793,-0.10353237,0.08342907),vec4(0.12370116,-0.36585918,-0.12880577,0.18990715)) * bufB[10] + mat4(vec4(0.11713885,0.34993476,0.058049653,0.03764403),vec4(0.3666458,-0.062398504,-0.15674262,0.20641115),vec4(-0.23172049,0.21689306,0.09449111,-0.21852796),vec4(0.2910904,0.15408544,0.07319187,-0.043243162)) * bufB[11];\nbufA[3] = vec4(-0.45856506,0.07458256,0.41694784,-0.45319685) + mat4(vec4(0.10878501,-0.077382825,0.1528452,0.14658785),vec4(0.07557883,-0.012799673,-0.09589148,0.11743586),vec4(0.14553906,0.11258497,0.28330308,-0.0047211777),vec4(0.15726854,0.16388315,0.029998869,0.114700936)) * bufB[0] + mat4(vec4(0.06306577,0.23250619,0.09390173,0.23373303),vec4(-0.20986786,-0.020056529,-0.13190809,0.099927716),vec4(-0.17388897,-0.084012546,-0.106532864,-0.08582348),vec4(0.05134344,-0.14916827,-0.118922696,0.027515553)) * bufB[1] + mat4(vec4(0.05470972,-0.15475914,0.09612078,-0.25625598),vec4(0.119006075,-0.004856198,0.43291432,-0.026865847),vec4(0.10964098,0.05121216,0.03793006,0.015377414),vec4(0.05705153,0.09993098,-0.021191547,0.047330655)) * bufB[2] + mat4(vec4(-0.2772202,-0.02549763,0.30601797,0.08176954),vec4(0.10969949,0.24316311,-0.19428338,-0.03597555),vec4(0.15410648,0.037141718,0.42502746,-0.07102379),vec4(0.252083,-0.14924574,0.37362486,0.111351036)) * bufB[3] + mat4(vec4(0.23583722,0.13658638,0.11377613,0.22424619),vec4(0.20482968,0.030436814,-0.07981924,0.16014655),vec4(-0.16535656,0.13376263,-0.07526627,-0.15139315),vec4(0.16822821,-0.4813005,0.35594496,0.18140143)) * bufB[4] + mat4(vec4(-0.15430366,-0.04115887,-0.08598009,0.111911915),vec4(0.04872244,-0.06782282,0.009197314,-0.10023072),vec4(-0.18091613,-0.19907436,0.030919626,-0.057460662),vec4(0.08393063,-0.19464462,0.31912327,0.39023492)) * bufB[5] + mat4(vec4(-0.073476635,-0.103502914,-0.19031923,0.14728484),vec4(0.13071002,-0.2758015,-0.18958525,-0.051969517),vec4(-0.1119137,0.16451004,0.35352322,-0.15185516),vec4(-0.42708474,-0.031286392,0.31535903,-0.16309261)) * bufB[6] + mat4(vec4(0.00023126649,-0.39621758,0.34181845,-0.26142132),vec4(-0.07568309,0.3761614,0.33064976,0.16202345),vec4(0.01030793,-0.011178149,0.50892335,-0.1563114),vec4(-0.049061205,-0.045312744,-0.037516102,-0.0969625)) * bufB[7] + mat4(vec4(-0.06940239,0.051447287,0.04673464,-0.31018275),vec4(-0.2370229,0.08145541,0.07229335,-0.06181479),vec4(-0.21711509,-0.18742631,-0.51813227,-0.14603989),vec4(-0.08737229,0.12365186,0.122638665,-0.15345322)) * bufB[8] + mat4(vec4(-0.032576125,-0.112644576,-0.2856189,-0.1060038),vec4(-0.20301047,0.35254785,-0.09472357,-0.053688746),vec4(0.38276994,-0.08539105,0.102542706,0.035356075),vec4(0.5729523,-0.16966651,0.52645195,0.15799867)) * bufB[9] + mat4(vec4(0.14324147,0.122315675,-0.16949499,-0.112842135),vec4(0.19043997,-0.11657907,-0.31943205,-0.12131646),vec4(0.1542018,0.069651596,-0.3211457,-0.2977114),vec4(0.13424695,0.3764379,-0.12504894,-0.12699082)) * bufB[10] + mat4(vec4(0.12649566,-0.33083612,-0.13489114,0.012406764),vec4(-0.014532383,-0.04068456,0.044062648,-0.08955957),vec4(0.0765896,-0.054929085,0.1199932,0.0021870206),vec4(0.020221287,0.07859629,-0.34553954,-0.07684812)) * bufB[11];\nbufA[4] = vec4(0.52363545,0.16672216,-0.5769614,-0.23290971) + mat4(vec4(-0.01665467,-0.07908759,-0.056782834,-0.06413591),vec4(0.055956963,-0.12083171,-0.2523328,0.1435382),vec4(0.21725017,-0.5286669,0.07835354,-0.22624329),vec4(0.027003149,-0.45065108,-0.35691997,-0.12999867)) * bufB[0] + mat4(vec4(-0.15860161,-0.51887846,-0.2636406,-0.10153664),vec4(-0.3655451,0.18545337,0.2196615,0.14218298),vec4(0.08100422,0.1549876,0.32272905,-0.14436936),vec4(0.35945284,0.17668477,-0.115884684,0.18844326)) * bufB[1] + mat4(vec4(-0.05011152,0.10628965,0.14176251,0.14674969),vec4(-0.08018113,-0.20498584,-0.28063414,-0.08865011),vec4(0.06764198,0.054611664,0.19910371,0.23805957),vec4(0.02774715,-0.12828074,-0.08736247,0.100724824)) * bufB[2] + mat4(vec4(0.15950768,0.026380358,-0.007668173,-0.39623067),vec4(-0.19480824,-0.3914613,0.28228077,-0.07229331),vec4(0.101591386,0.15375909,-0.13591985,0.0056952354),vec4(-0.27929166,-0.13629194,0.11705827,-0.060492825)) * bufB[3] + mat4(vec4(0.10762613,0.31306162,-0.26261047,-0.11782193),vec4(-0.15048397,-0.497744,-0.35270604,-0.046384394),vec4(0.3387249,-0.02066784,-0.2879185,-0.13360949),vec4(0.18287148,0.39520255,0.3148531,0.09005341)) * bufB[4] + mat4(vec4(0.021379082,0.22484931,0.21344945,-0.14347951),vec4(-0.11768348,0.22910084,-0.34855163,0.047823086),vec4(-0.0065232012,0.03325115,0.10821378,0.29080018),vec4(-0.41138056,0.1867686,0.1645292,0.28531712)) * bufB[5] + mat4(vec4(-0.13456708,0.15093048,0.40948057,0.089662194),vec4(0.2011312,0.11014708,0.36564714,0.106137514),vec4(-0.023124335,-0.3942137,-0.09396286,-0.34754533),vec4(0.12710391,-0.07737124,-0.2586154,-0.12654687)) * bufB[6] + mat4(vec4(-0.09375996,0.43658382,0.3029871,0.183393),vec4(0.10238205,-0.033954896,-0.19184649,-0.10629561),vec4(0.39081603,-0.25634184,-0.13645062,-0.17226666),vec4(0.21590465,-0.13594021,0.016168058,-0.061448235)) * bufB[7] + mat4(vec4(-0.058332574,0.045988485,0.11336531,0.10660845),vec4(0.09003528,-0.06987184,0.37299573,-0.13055947),vec4(-0.21126318,-0.061822712,0.3732362,0.12215315),vec4(0.13038425,-0.21019936,-0.23102677,-0.48454392)) * bufB[8] + mat4(vec4(-0.28725544,-0.03883707,0.45571175,0.037834108),vec4(0.15593769,-0.06411312,-0.06679304,-0.4053245),vec4(0.064817354,-0.25723407,-0.39090773,0.18061593),vec4(0.045509744,-0.3556485,0.29301393,-0.3149179)) * bufB[9] + mat4(vec4(0.3642818,0.07281653,0.1144946,0.4154704),vec4(0.22813933,-0.019944044,-0.033985063,-0.47829896),vec4(0.09456229,-0.19765666,-0.2843575,-0.28024253),vec4(-0.0055289883,-0.30982897,-0.371057,-0.18595038)) * bufB[10] + mat4(vec4(-0.06959418,0.387169,0.4483684,-0.2967123),vec4(0.22404878,-0.038354166,0.081370346,0.08569194),vec4(0.37280944,0.050501965,0.1604368,0.19661313),vec4(0.16516265,-0.3025923,-0.23609947,0.060019936)) * bufB[11];\nbufA[5] = vec4(-0.63516736,0.23641008,0.059669346,-0.32981563) + mat4(vec4(-0.168397,-0.01486643,-0.1187533,-0.13262986),vec4(-0.02758022,-0.19077292,0.045945253,-0.110352874),vec4(0.23791534,-0.25900558,-0.11826439,0.02702302),vec4(0.19355455,-0.26523003,-0.06354909,0.07492245)) * bufB[0] + mat4(vec4(0.22801109,0.15803342,0.06737932,0.21907538),vec4(-0.16231237,0.41308185,0.4362115,0.12078724),vec4(-0.17746139,0.17065427,-0.041533913,-0.3997447),vec4(-0.14586033,-0.1333757,-0.23634306,-0.0016645822)) * bufB[1] + mat4(vec4(0.003649114,-0.015554008,-0.106810644,-0.133124),vec4(0.16357744,-0.22214995,-0.09909356,-0.063549384),vec4(-0.318855,0.15050681,-0.17708626,0.0009642157),vec4(-0.08128693,0.0065233316,-0.105092466,-0.043022376)) * bufB[2] + mat4(vec4(0.19113535,-0.3007032,0.07183972,-0.19102685),vec4(0.20689665,-0.29822412,0.34425616,0.20360279),vec4(0.020678794,0.111190364,-0.1213554,-0.39911693),vec4(0.20655885,-0.2598493,0.041189354,-0.030872533)) * bufB[3] + mat4(vec4(0.20030947,-0.21933018,0.018759564,-0.2769163),vec4(-0.21816282,0.25172874,-0.19141158,0.14016539),vec4(-0.3105055,-0.2060159,-0.17744763,0.01584067),vec4(-0.067899555,0.181935,0.094015285,-0.27215052)) * bufB[4] + mat4(vec4(0.012857325,-0.052379075,0.16923659,-0.014177079),vec4(-0.12969695,0.23895599,-0.23572363,0.110185504),vec4(-0.1855029,0.26175737,0.0031048702,0.009031404),vec4(-0.14980386,-0.15935363,0.21080643,-0.105754934)) * bufB[5] + mat4(vec4(0.065767005,0.28150865,0.08653095,0.20331861),vec4(-0.08460198,0.14815235,0.33945847,-0.2074924),vec4(0.104970165,-0.15299553,0.19690078,-0.119091205),vec4(-0.16377053,0.12773247,0.3041325,0.15259492)) * bufB[6] + mat4(vec4(-0.36231637,-0.11879327,0.13131113,-0.34193015),vec4(0.09193669,0.02255402,-0.09213093,-0.13824472),vec4(0.027092103,0.01215463,-0.1894146,-0.19966552),vec4(0.029780356,0.1390726,0.03088899,0.07831578)) * bufB[7] + mat4(vec4(-0.08321636,-0.105432644,0.045645185,0.07632729),vec4(0.06190346,0.06847872,0.040204015,-0.11431063),vec4(-0.03762329,0.19051139,-0.19475201,0.14321373),vec4(-0.08361106,-0.041487556,-0.004293239,-0.02840354)) * bufB[8] + mat4(vec4(-0.1913439,0.25872013,-0.11182678,0.09149799),vec4(0.12080154,0.06906873,0.30830604,0.121554025),vec4(0.3952291,-0.08823244,-0.22438665,-0.15676896),vec4(0.48864493,-0.22883363,0.073757194,-0.4576435)) * bufB[9] + mat4(vec4(0.1588637,0.14318602,-0.15695614,0.07723766),vec4(-0.05076031,-0.26425073,0.09831226,0.040501636),vec4(-0.061323754,-0.14264314,-0.03461714,0.13711397),vec4(0.2001029,0.016863754,-0.40975907,-0.0014734694)) * bufB[10] + mat4(vec4(-0.04653007,0.12042434,0.16121209,0.0056123054),vec4(-0.059520025,0.18709284,-0.1505482,-0.114059135),vec4(0.07589823,-0.33262464,-0.0027578387,-0.15142702),vec4(0.050702326,0.003734826,0.02245666,0.13815948)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 3 \nbufA[0] = vec4(0.24227428,-0.04023362,-0.35180035,-0.29014677) + mat4(vec4(0.24272214,0.3062561,-0.23292418,-0.27343795),vec4(-0.01898237,-0.5011679,-0.24499239,0.37973148),vec4(0.09818618,0.0112222405,-0.23573959,-0.05868814),vec4(0.26709437,0.24397321,0.13646765,-0.12925717)) * bufB[0] + mat4(vec4(-0.054969463,0.24766769,0.26330015,0.18107888),vec4(0.13515595,-0.07687283,0.3460039,-0.01514289),vec4(-0.038435034,-0.01702905,-0.28274134,0.03765317),vec4(-0.25133228,-0.092546605,-0.11632483,0.024494873)) * bufB[1] + mat4(vec4(-0.3136558,-0.14230041,0.060897984,0.064102426),vec4(0.114805214,0.38017598,-0.046304163,-0.16416574),vec4(0.15165378,0.22638157,0.13178958,-0.0036537359),vec4(-0.07220082,0.08933775,0.04766889,0.09895569)) * bufB[2] + mat4(vec4(-0.20479356,-0.048348792,0.1950821,0.11902446),vec4(0.19012715,-0.060181275,-0.101975165,0.017438322),vec4(0.047442693,0.06063815,-0.33402243,-0.18817925),vec4(0.03800768,-0.11973579,-0.07210313,0.127502)) * bufB[3] + mat4(vec4(-0.20802505,-0.019819543,-0.030216215,0.11355308),vec4(0.2280144,-0.076660745,0.092387244,-0.3126997),vec4(-0.0061025154,-0.38790825,0.033991776,0.11234886),vec4(0.117915176,-0.0023615952,-0.13952899,0.13230638)) * bufB[4] + mat4(vec4(-0.032583717,-0.12801953,0.055412505,0.028804982),vec4(-0.29611367,-0.26992428,0.00658262,0.12842278),vec4(-0.18618163,0.09775578,-0.14370766,-0.13031603),vec4(-0.15872724,-0.28960934,0.15515663,0.1618449)) * bufB[5] + mat4(vec4(-0.045152567,0.04596512,0.20840406,-0.42194477),vec4(0.12566562,0.12496313,-0.074495606,0.09051846),vec4(-0.11532015,-0.13784939,0.36302882,0.10586985),vec4(-0.3066004,0.09129653,0.29339024,-0.15142876)) * bufB[6] + mat4(vec4(-0.10772133,0.009131758,-0.024475534,0.020452216),vec4(0.097816326,0.057161883,0.042699017,-0.006684802),vec4(-0.2256437,-0.32629073,-0.044520833,-0.118969135),vec4(0.08719191,-0.047633052,0.24337266,-0.04168956)) * bufB[7] + mat4(vec4(0.104568176,0.12786059,0.1140313,-0.09647529),vec4(-0.18848811,0.26055396,-0.043680783,-0.18068232),vec4(-0.16067949,-0.17858496,-0.09888038,0.0892337),vec4(-0.09519665,-0.029546818,0.05283674,-0.18714392)) * bufB[8] + mat4(vec4(-0.1634841,0.27660695,-0.21370484,0.3078003),vec4(-0.1498075,-0.07930737,0.045958947,0.08728345),vec4(-0.11629607,-0.13890016,-0.09486701,-0.19767165),vec4(-0.2052771,-0.19746472,-0.22784725,-0.08429373)) * bufB[9] + mat4(vec4(-0.0092255995,-0.08996155,0.08398647,-0.08663545),vec4(-0.06037142,0.32898986,0.030912327,-0.07842148),vec4(-0.2994775,0.19551311,0.47079632,0.032620292),vec4(-0.07174134,0.028120058,0.26342866,-0.03430483)) * bufB[10] + mat4(vec4(-0.25557533,-0.35638815,0.13424867,0.111826204),vec4(-0.565293,-0.11637573,0.10122291,-0.23467922),vec4(0.42247605,-0.024580356,0.22834174,0.22167572),vec4(0.013023516,-0.18327732,-0.17049794,0.039139416)) * bufB[11] + in0;\nbufA[1] = vec4(0.1509249,0.13396525,0.20974207,0.32926023) + mat4(vec4(0.1794056,-0.03938289,-0.15958536,0.052097365),vec4(-0.27093834,-0.08047997,0.14468886,0.04827564),vec4(0.104427375,0.069102,-0.0003695503,0.13666825),vec4(0.15331925,-0.12805817,-0.1426289,-0.15228647)) * bufB[0] + mat4(vec4(-0.12581293,0.1869765,0.10892125,-0.40186423),vec4(0.115745746,0.106893376,0.25580895,0.2734274),vec4(-0.13308463,0.17745444,-0.21684827,0.16166453),vec4(0.13448842,-0.24874316,-0.09333545,0.14783195)) * bufB[1] + mat4(vec4(0.16321729,-0.22211841,-0.23734479,-0.08280926),vec4(0.3018137,-0.07128068,-0.05120949,0.10407736),vec4(-0.05754455,0.06372927,0.16938324,0.074321404),vec4(0.13458374,0.08219917,0.13554594,0.36542642)) * bufB[2] + mat4(vec4(-0.01269825,0.030463187,-0.18285434,-0.14053924),vec4(-0.024774926,-0.0044498537,0.05840795,-0.13145883),vec4(0.042831406,-0.005536285,0.29814696,0.16890444),vec4(-0.33694038,-0.22260942,0.21605872,-0.023789817)) * bufB[3] + mat4(vec4(0.19089834,-0.1608465,-0.04338625,-0.12108418),vec4(-0.18235385,0.40589312,0.12982611,0.324931),vec4(-0.02013597,-0.38487685,0.024352837,0.13877669),vec4(-0.07286871,-0.14065242,-0.30477342,0.27183625)) * bufB[4] + mat4(vec4(-0.24145307,-0.31244853,0.18160932,-0.0807368),vec4(0.06284759,0.33484933,-0.09998937,-0.10849946),vec4(-0.08534586,0.055239834,-0.3637073,-0.24774376),vec4(0.26795316,-0.14792721,0.07680449,-0.28680044)) * bufB[5] + mat4(vec4(0.068697095,-0.043141384,-0.0298788,-0.094050825),vec4(0.30836636,-0.2329842,0.078503124,0.0015947437),vec4(0.12591757,-0.08243283,-0.16857599,0.06739026),vec4(-0.3863089,-0.16690123,-0.10777768,-0.20511907)) * bufB[6] + mat4(vec4(0.2081613,-0.31936818,0.098266624,-0.09503052),vec4(0.2238236,0.004654225,0.21365122,-0.017139835),vec4(-0.061141763,0.12698925,-0.06346731,-0.081556484),vec4(0.17131823,-0.20668772,0.046278585,0.26155555)) * bufB[7] + mat4(vec4(0.21188682,0.073934406,-0.07819555,0.16439302),vec4(0.009895374,0.14398806,-0.19731104,-0.14400682),vec4(-0.23446564,-0.17429705,0.12832299,0.022957202),vec4(-0.27402532,0.11568979,-0.24759379,0.20993024)) * bufB[8] + mat4(vec4(-0.21323726,-0.042664614,0.07192517,0.036941856),vec4(0.00437075,-0.16564249,0.1045099,-0.21605466),vec4(-0.24698235,0.18053736,-0.079442464,-0.035289545),vec4(0.059865076,0.12258447,-0.027410476,0.13066044)) * bufB[9] + mat4(vec4(0.018122666,-0.13409191,0.06273206,0.16097303),vec4(-0.17766428,-0.061934385,-0.06186383,-0.15872158),vec4(-0.14972349,0.093327954,0.038048796,0.034121804),vec4(0.14126126,-0.19247572,0.025972113,-0.0078109773)) * bufB[10] + mat4(vec4(-0.34643653,-0.07259609,-0.14311932,-0.22533628),vec4(0.08801956,-0.06314899,-0.19444577,-0.03126834),vec4(0.07442109,0.3822702,-0.0924853,-0.25886533),vec4(-0.096342325,0.17075539,0.046070006,0.078063436)) * bufB[11] + in1;\nbufA[2] = vec4(0.5276965,0.46779442,0.096874475,-0.35153866) + mat4(vec4(0.031529795,0.024452176,0.32629302,-0.49698606),vec4(-0.15330863,-0.14722084,-0.19156659,0.2874548),vec4(0.09698165,0.053079028,0.10149336,-0.24921654),vec4(-0.15120468,-0.28230894,0.3260074,0.123062)) * bufB[0] + mat4(vec4(-0.22905871,-0.12341081,-0.02823716,-0.19372638),vec4(-0.25657925,0.16291915,-0.15832251,-0.022203553),vec4(-0.05079453,0.22668816,0.12740633,0.048896052),vec4(0.3089414,0.038191468,-0.14477444,-0.21454379)) * bufB[1] + mat4(vec4(0.30380547,0.027754113,0.045109354,0.03128256),vec4(-0.42390707,0.12352969,-0.21692277,-0.1390182),vec4(-0.2541395,0.35066223,0.16940632,-0.10245826),vec4(-0.12986606,0.14893988,0.057691444,0.0041190013)) * bufB[2] + mat4(vec4(0.29231972,-0.28103435,-0.09700843,-0.26327473),vec4(0.3061335,-0.119584695,0.06380625,-0.18923026),vec4(-0.089546196,-0.1265305,0.2696161,0.025275094),vec4(-0.019124242,-0.19983359,0.0032508187,0.02261717)) * bufB[3] + mat4(vec4(0.036166508,0.18326686,-0.1944911,-0.0675717),vec4(0.028090639,0.36031523,-0.21682669,0.04482036),vec4(-0.124264814,-0.026429553,-0.16668175,0.3649848),vec4(0.1753858,0.3468922,-0.19613914,0.22794613)) * bufB[4] + mat4(vec4(-0.087043114,-0.17753138,0.06255054,0.13721061),vec4(0.43038246,-0.031829022,0.121745095,0.21220307),vec4(-0.02323731,-0.25350332,0.07862731,0.20145482),vec4(0.115092084,-0.22106302,-0.22856139,0.0402165)) * bufB[5] + mat4(vec4(0.24655001,-0.062364295,-0.15893395,0.027009044),vec4(0.23361881,0.298243,0.025547355,-0.25525278),vec4(0.12606403,0.1692106,0.33989578,0.3449631),vec4(-0.17390579,0.057608217,0.041748855,-0.20427495)) * bufB[6] + mat4(vec4(0.15005961,0.07105608,-0.14624813,-0.038854484),vec4(-0.19157837,0.0050784443,0.17494434,-0.12743688),vec4(-0.036705077,-0.09288478,-0.061875872,0.21291508),vec4(-0.118534155,-0.052032866,-0.040340904,0.16645974)) * bufB[7] + mat4(vec4(0.11150274,0.12780866,-0.38773298,-0.02741183),vec4(-0.26745173,-0.1850585,-0.056486316,-0.029949736),vec4(-0.13517416,0.088207245,0.28354064,0.20436665),vec4(0.062081218,-0.33177248,0.13904294,0.0046654497)) * bufB[8] + mat4(vec4(-0.0752171,-0.002625794,0.008615011,-0.2572639),vec4(-0.002829346,-0.09365069,0.19331539,0.0999387),vec4(-0.019794103,0.034249336,0.16434503,0.12100787),vec4(0.12138479,0.15455094,0.071080655,0.27766114)) * bufB[9] + mat4(vec4(0.053287633,0.05299789,-0.122878924,-0.017884685),vec4(0.19531931,-0.5798148,-0.00440055,0.19331153),vec4(0.14552103,0.063783765,0.10409013,-0.031635612),vec4(0.1302563,-0.19064423,-0.036196105,0.3159391)) * bufB[10] + mat4(vec4(-0.2127277,0.16873801,0.03001302,0.25338665),vec4(-0.050874673,-0.049591597,0.043545373,0.24942745),vec4(-0.024762847,0.1134773,-0.06956915,0.056072854),vec4(-0.014709872,0.17129706,-0.06800748,0.05978785)) * bufB[11] + in2;\nbufA[3] = vec4(-0.25672594,-0.013453317,-0.030683553,-0.25145596) + mat4(vec4(0.24786794,0.024364226,0.10754805,0.1336859),vec4(-0.018680157,-0.2545205,0.021541059,-0.2507898),vec4(0.06469609,-0.014879024,0.001557938,0.0028162508),vec4(0.47405943,-0.22537926,0.046100874,0.4358389)) * bufB[0] + mat4(vec4(-0.23048718,0.27725208,-0.06847018,0.3299023),vec4(0.05355448,0.47316045,-0.24390827,-0.19511293),vec4(0.35168153,-0.18874405,0.19519116,-0.025165236),vec4(0.055442028,0.3950691,0.0006135497,-0.3282817)) * bufB[1] + mat4(vec4(-0.03076666,-0.07773604,-0.0143403,-0.21914977),vec4(0.007660644,0.110002905,-0.22442827,-0.12843181),vec4(0.2702752,0.37173018,-0.12812595,-0.046010572),vec4(0.019243551,0.020705387,0.14483687,-0.12283003)) * bufB[2] + mat4(vec4(0.16449831,0.21038249,0.09484871,0.16678685),vec4(0.29868248,-0.0697683,0.061241373,0.021231897),vec4(0.31666645,0.10072548,0.032576583,0.062295813),vec4(-0.15026183,-0.22764534,-0.045632534,0.08740312)) * bufB[3] + mat4(vec4(0.16071036,0.186588,0.28263706,0.22825016),vec4(-0.44563755,-0.10737991,0.1317748,-0.2800007),vec4(-0.025290394,0.086025454,-0.3877971,0.059046246),vec4(-0.23021992,0.017235879,-0.07046176,-0.5320788)) * bufB[4] + mat4(vec4(0.24096937,-0.20310098,-0.23166364,0.45982194),vec4(-0.2175632,0.027145261,-0.05677342,-0.24553344),vec4(-0.19283551,-0.044340495,-0.109694526,0.0148699125),vec4(0.10921933,-0.2409472,0.41262168,-0.064197354)) * bufB[5] + mat4(vec4(0.30049035,-0.2339596,0.04805375,-0.10634866),vec4(0.20702791,-0.111310154,-0.15424937,-0.024691673),vec4(-0.20206322,-0.25747612,-0.2832181,0.09252155),vec4(-0.18216884,0.064390786,0.04405714,-0.026515726)) * bufB[6] + mat4(vec4(-0.09422036,-0.079505794,-0.17274725,0.27747372),vec4(0.18582061,-0.297955,0.118119076,0.08059852),vec4(0.39783108,0.09108475,-0.0653796,0.04487559),vec4(-0.071495734,-0.39720428,-0.43739212,0.21277604)) * bufB[7] + mat4(vec4(0.042439286,-0.124211654,0.45212534,-0.05513301),vec4(-0.06954627,0.17413966,-0.35576817,-0.1046504),vec4(-0.08207229,-0.23533772,0.08788285,0.08368662),vec4(0.25734207,0.23797867,0.1678963,0.093915105)) * bufB[8] + mat4(vec4(0.1686973,0.30241147,-0.08688209,0.004196447),vec4(0.10891387,-0.36609998,-0.1008955,0.3042182),vec4(0.076972425,-0.15329105,-0.22278418,0.019045776),vec4(-0.12993875,-0.09643806,0.006244663,-0.031808626)) * bufB[9] + mat4(vec4(0.24034512,0.117679074,0.0582628,0.08790453),vec4(-0.26201728,0.07315576,0.2477644,-0.23993975),vec4(-0.06157222,0.33223793,0.035377357,0.19589695),vec4(-0.44493282,-0.14740534,-0.25427517,0.028874421)) * bufB[10] + mat4(vec4(-0.33116513,0.16003887,-0.22205044,-0.3689575),vec4(0.11252089,0.054683656,-0.15277702,-0.09135072),vec4(-0.23157603,-0.29058346,0.17045334,0.12771548),vec4(0.100447,0.18329239,-0.015372524,0.09277089)) * bufB[11] + in3;\nbufA[4] = vec4(0.44037622,-0.42429954,0.49586204,-0.15235974) + mat4(vec4(0.3714118,-0.33040935,0.10787419,-0.08136137),vec4(-0.057911612,-0.22046496,0.25844672,0.25656205),vec4(0.21503036,0.22197545,-0.13383459,0.119026884),vec4(-0.2605606,-0.055623855,-0.40270188,-0.053351387)) * bufB[0] + mat4(vec4(0.16920315,0.14520729,-0.4214979,0.10216701),vec4(0.08912513,0.48706433,0.093614675,-0.035854027),vec4(-0.016977066,0.3528328,0.14609861,0.046229124),vec4(0.6236029,0.37596142,0.30815184,-0.27139294)) * bufB[1] + mat4(vec4(0.15439188,-0.22024381,0.17441586,-0.5836151),vec4(-0.059005126,-0.36121374,-0.061732408,-0.022439294),vec4(0.01757103,0.33845696,-0.2530644,-0.16827501),vec4(0.30256757,-0.1050552,-0.07925904,-0.06752079)) * bufB[2] + mat4(vec4(-0.0559663,-0.011452423,0.029780703,0.29499212),vec4(0.05059062,0.03101379,-0.03100019,0.060572624),vec4(-0.58775395,-0.34946144,-0.30808482,-0.20203424),vec4(-0.07884351,-0.025368946,-0.24446626,-0.09810714)) * bufB[3] + mat4(vec4(0.14228217,0.25667235,0.46829897,-0.02064857),vec4(-0.31445333,-0.25111836,-0.10379755,-0.006942266),vec4(0.07161054,-0.08384171,0.08170439,0.107979804),vec4(0.037742402,0.09072874,0.28576928,0.19677074)) * bufB[4] + mat4(vec4(-0.27823392,0.05696245,-0.3958153,0.099461555),vec4(0.1406943,0.012164315,0.18700245,-0.104560375),vec4(-0.37268323,-0.4322214,-0.07628378,-0.11830415),vec4(0.48705515,0.18490706,0.14555183,0.18575107)) * bufB[5] + mat4(vec4(-0.11192459,-0.022791928,0.18173684,0.072389394),vec4(-0.10508526,-0.11556917,-0.07069484,0.00956567),vec4(-0.30507725,-0.18030602,-0.03113182,0.19125327),vec4(-0.10604406,0.05925199,-0.34341118,-0.12501955)) * bufB[6] + mat4(vec4(0.14169618,0.17936498,-0.3354909,0.5316605),vec4(-0.02283477,0.02081304,0.075513706,0.042454902),vec4(0.030662663,0.062168542,-0.059404176,-0.039149273),vec4(0.11161181,0.21578605,-0.17170677,0.14617944)) * bufB[7] + mat4(vec4(0.3457114,0.20109613,0.35070398,-0.20006335),vec4(-0.28339392,-0.03510358,-0.04949128,-0.028776184),vec4(0.03625505,0.057388462,0.1641669,0.29985693),vec4(0.27352095,-0.24144499,0.1132525,-0.19439359)) * bufB[8] + mat4(vec4(-0.18804327,-0.22294533,-0.10934732,-0.18684304),vec4(0.07837674,-0.057270132,-0.17653202,0.30163765),vec4(-0.40319028,0.19320217,0.23844117,-0.3626035),vec4(0.26091826,-0.058274273,0.05415229,0.007932159)) * bufB[9] + mat4(vec4(0.026060168,0.20109889,-0.11390934,-0.19245538),vec4(0.08520097,-0.3482135,-0.07270686,-0.20353194),vec4(0.0074104564,0.27270445,-0.17321865,0.6652457),vec4(0.38731086,-0.19971313,-0.26239908,0.39012676)) * bufB[10] + mat4(vec4(-0.121023044,-0.0502295,0.066460624,-0.338042),vec4(-0.03787264,-0.08244936,-0.012400954,-0.05216959),vec4(0.081868865,0.096640155,-0.02225304,0.35797137),vec4(0.28966478,0.07217412,-0.16061588,-0.13139564)) * bufB[11] + in0;\nbufA[5] = vec4(-0.49209088,-0.04713086,0.0032244518,-0.09991239) + mat4(vec4(0.114500836,0.036860634,0.22573937,-0.46606293),vec4(0.14427423,-0.19665718,0.06658939,0.17144501),vec4(0.012350817,0.07957782,0.09021073,0.013773683),vec4(-0.08298794,-0.034102313,-0.20589404,-0.034723047)) * bufB[0] + mat4(vec4(0.5018689,0.22389585,-0.23340662,0.26310638),vec4(0.083177306,-0.16225119,0.24547008,-0.114511825),vec4(-0.041666064,-0.13857174,0.27406883,0.19607107),vec4(0.057034027,0.3142999,0.44565135,-0.34908792)) * bufB[1] + mat4(vec4(-0.19014119,0.17897874,0.26699057,0.25784472),vec4(-0.59872717,0.087583885,-0.3244063,-0.1940305),vec4(-0.014338976,0.18596786,-0.1456673,-0.036706142),vec4(0.28311792,0.061091486,-0.11496171,-0.3570102)) * bufB[2] + mat4(vec4(-0.006021029,0.35992298,0.14209251,0.11634952),vec4(0.096152194,-0.03549558,-0.20130764,0.047280937),vec4(-0.64456594,0.06345169,-0.07837856,-0.18931265),vec4(0.10847009,-0.19121161,-0.23645099,0.08824301)) * bufB[3] + mat4(vec4(-0.10989517,0.12507948,0.20255911,-0.026362168),vec4(0.091208376,0.07006313,0.1858879,-0.33423308),vec4(-0.060967818,-0.14434196,0.07946108,0.15292314),vec4(0.08342395,0.12303877,0.23236924,-0.15998226)) * bufB[4] + mat4(vec4(0.11401566,-0.3268492,-0.38569364,0.12142923),vec4(0.26034907,0.17168081,0.1699784,-0.26283193),vec4(-0.19349045,-0.10781488,-0.108612075,-0.18036285),vec4(0.37624264,-0.32807273,-0.14722061,0.2546345)) * bufB[5] + mat4(vec4(0.013272645,0.35705027,0.051804133,-0.08403745),vec4(-0.26099434,0.33734506,0.15771891,0.02691544),vec4(0.03678658,-0.03873361,-0.07017391,0.056156516),vec4(-0.29067907,-0.2711095,-0.029391501,0.17145425)) * bufB[6] + mat4(vec4(-0.12771143,0.16305664,-0.041229323,0.2614289),vec4(0.08393185,-0.15077665,-0.18644999,0.030314263),vec4(0.32285798,0.054700293,-0.22446209,0.21373627),vec4(0.12681535,0.31304622,0.20653966,0.1437265)) * bufB[7] + mat4(vec4(0.05102407,0.13971937,0.07503601,0.17525752),vec4(0.20272501,0.17133199,0.06383312,-0.028599445),vec4(0.15267177,-0.33517823,0.0042871987,0.06982372),vec4(-0.26256707,0.019627327,-0.26817346,0.12900402)) * bufB[8] + mat4(vec4(0.37958494,-0.23484048,-0.039272226,0.37128),vec4(0.08987979,0.07443932,0.086823046,-0.11136008),vec4(-0.09513543,-0.07406826,0.12372672,0.046734553),vec4(0.026035024,-0.006303923,0.08528341,-0.13270254)) * bufB[9] + mat4(vec4(-0.209104,0.14848468,-0.044804353,0.038528867),vec4(0.14741246,-0.24771878,-0.2585897,0.023185696),vec4(-0.05584247,0.3652269,-0.034038816,0.10285636),vec4(-0.07156232,0.117215164,0.27753577,0.07929043)) * bufB[10] + mat4(vec4(0.34112898,-0.34849888,-0.09497541,-0.21684794),vec4(-0.15856932,-0.113611475,-0.13288349,0.29082406),vec4(-0.017578458,-0.19941354,-0.0018017066,0.3309312),vec4(0.21981578,-0.09339459,-0.23194085,-0.19527657)) * bufB[11] + in1;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 4 \nbufA[0] = vec4(0.08838813,-0.069259614,-0.1934159,-0.41584873) + mat4(vec4(0.049516767,0.14102961,-0.13679305,-0.15480171),vec4(0.12047667,0.018257406,0.026289964,0.020563122),vec4(0.017385822,-0.31784979,-0.17569846,0.14521691),vec4(-0.32008934,0.056249056,0.26639387,0.023834981)) * bufB[0] + mat4(vec4(0.49117848,0.26297337,0.023356328,-0.15779568),vec4(-0.11240182,-0.0015246479,-0.076464675,-0.052580077),vec4(0.043609586,-0.13496667,-0.090344094,0.07294073),vec4(0.06011671,0.20764504,0.16056775,-0.16116634)) * bufB[1] + mat4(vec4(0.23961763,-0.05427486,-0.04601696,0.07500971),vec4(0.19338612,0.37589887,-0.02267513,0.1890827),vec4(-0.101336494,0.13836505,0.07863176,-0.06166463),vec4(0.010583749,-0.2338248,0.11550013,0.08504642)) * bufB[2] + mat4(vec4(0.29979792,0.072682634,-0.1654592,-0.072308),vec4(-0.068821974,0.05972346,-0.38374677,0.034971543),vec4(0.25114062,0.012360802,-0.2887265,-0.45957527),vec4(0.03921588,0.02089893,-0.2722989,0.26278433)) * bufB[3] + mat4(vec4(0.06251172,0.05140645,-0.1465234,0.01690597),vec4(0.16311271,-0.1405016,-0.2953181,0.20748824),vec4(0.34053427,-0.25951767,0.070529275,-0.30926538),vec4(-0.24650754,-0.069654755,0.2877395,0.45362106)) * bufB[4] + mat4(vec4(-0.005840511,-0.12732098,-0.24362646,0.21030813),vec4(0.14291497,-0.014460616,-0.35509083,-0.05486277),vec4(0.32449138,0.0411841,-0.23081368,-0.27749825),vec4(0.015302233,0.025894504,0.11455604,-0.0059674373)) * bufB[5] + mat4(vec4(-0.102339216,0.010839663,-0.11444158,0.030588344),vec4(0.078205794,0.053321116,-0.5800286,-0.26436895),vec4(-0.04358233,0.11609069,-0.10719067,0.24645521),vec4(0.20267296,0.31686422,0.111096166,0.012360323)) * bufB[6] + mat4(vec4(0.19665018,-0.01346326,-0.1278459,0.20446065),vec4(-0.07471792,0.04884818,0.16833337,0.19961974),vec4(0.13308574,0.08365872,-0.047285587,0.03675478),vec4(-0.31569463,0.09220068,0.07046652,-0.011516079)) * bufB[7] + mat4(vec4(-0.10073573,-0.11193625,-0.20556794,0.18487325),vec4(-0.13556047,0.34691337,0.010280449,0.026350979),vec4(0.102737844,0.17416637,-0.027679814,-0.03477266),vec4(0.09669993,-0.4507808,0.43342733,0.18238248)) * bufB[8] + mat4(vec4(-0.35736212,-0.5640648,-0.1803976,0.5204515),vec4(-0.20908517,-0.35108915,0.39607546,-0.05751817),vec4(-0.07686722,-0.39468142,-0.12711619,0.058988683),vec4(0.05357827,-0.22871716,0.11478337,0.17470853)) * bufB[9] + mat4(vec4(-0.24781337,-0.4734211,-0.018155187,-0.53135806),vec4(0.033043966,0.1511386,0.22610258,-0.042603884),vec4(0.2668389,0.21553344,-0.13127357,-0.47498947),vec4(0.007937939,0.2619527,0.38261423,-0.25476268)) * bufB[10] + mat4(vec4(0.40872997,0.1254779,-0.18956465,0.071510985),vec4(0.44094333,0.0042749215,-0.2961821,0.039110344),vec4(0.025086518,-0.17056711,-0.018691929,-0.00455779),vec4(0.10257495,-0.17383233,0.28521985,0.15044011)) * bufB[11];\nbufA[1] = vec4(-0.051680032,-0.06233112,0.3749348,-0.46979603) + mat4(vec4(-0.10940699,0.10636544,-0.05649902,-0.11537613),vec4(-0.073352315,-0.070981644,0.17294872,0.2329452),vec4(0.18507527,-0.19656818,0.1622658,-0.08822003),vec4(0.19735488,0.18659587,0.031435072,0.17742096)) * bufB[0] + mat4(vec4(-0.38749838,-0.013860094,-0.058294613,-0.1768018),vec4(-0.15439664,-0.07672809,-0.03399358,-0.3907041),vec4(0.18072733,0.06436122,0.12189614,-0.010903915),vec4(0.22371499,0.004735555,0.14536642,-0.40489885)) * bufB[1] + mat4(vec4(-0.07202355,0.05734755,-0.13180707,-0.08775459),vec4(0.12081367,-0.17989701,0.68513334,-0.2977577),vec4(0.17697398,0.060980055,0.06611025,0.031999793),vec4(0.23132448,-0.05138874,-0.17340921,-0.28450722)) * bufB[2] + mat4(vec4(-0.2797891,0.2879253,-0.15027729,-0.09001803),vec4(0.022273963,0.060487755,0.07114529,0.2826972),vec4(-0.19656584,-0.06796414,-0.012936454,-0.11076846),vec4(0.14455134,0.21013002,-0.19306557,0.21994767)) * bufB[3] + mat4(vec4(-0.07108902,-0.30628946,-0.030985177,-0.097939625),vec4(0.031043505,-0.12543993,0.31553578,0.0130059915),vec4(-0.18430325,-0.38100642,-0.020863969,-0.4377172),vec4(0.30828446,-0.047196288,-0.06305435,0.2541156)) * bufB[4] + mat4(vec4(0.45718256,0.016951526,-0.20963745,0.30497238),vec4(-0.5405588,0.041887145,0.037263274,0.13148472),vec4(0.13754547,-0.23105294,0.29824415,0.15092766),vec4(0.13690849,0.23786418,-0.04485263,0.07496056)) * bufB[5] + mat4(vec4(-0.24028511,0.052376725,0.12704508,-0.13941967),vec4(-0.27641708,0.22011195,0.21047653,-0.0728902),vec4(0.34116283,-0.22454174,-0.10691661,-0.06850532),vec4(-0.112919874,0.034220856,0.008566128,-0.18218367)) * bufB[6] + mat4(vec4(-0.39254093,-0.13641043,-0.09157266,0.25229102),vec4(0.10089716,0.27421921,-0.37136814,0.008137815),vec4(0.029083284,-6.2312e-05,0.010564097,-0.010839407),vec4(-0.014746405,0.08939495,-0.40058383,0.5053266)) * bufB[7] + mat4(vec4(0.09960235,-0.54559016,-0.055558108,0.1720762),vec4(-0.03943219,-0.017318439,0.16537632,-0.16694959),vec4(0.09834415,0.03330046,0.009945304,0.24395384),vec4(-0.08014789,-0.02068774,0.00022915174,-0.15876101)) * bufB[8] + mat4(vec4(0.07031104,0.017745756,0.17290948,0.01624679),vec4(-0.20956786,0.25754228,0.01440839,-0.18731405),vec4(0.0965606,0.076169245,-0.2901621,-0.04265814),vec4(0.35668418,-0.15134579,0.06727272,0.012225516)) * bufB[9] + mat4(vec4(0.28458118,0.18445791,-0.3298436,0.35215363),vec4(-0.3817777,0.07478182,-0.23811603,-0.29194853),vec4(-0.20247497,-0.25817168,-0.07871561,0.14708178),vec4(-0.4847883,-0.2291739,0.102707505,-0.0052243387)) * bufB[10] + mat4(vec4(-0.2866481,0.025942283,0.021517158,-0.010846714),vec4(-0.16506645,-0.1951206,0.05930474,-0.06820629),vec4(0.18190314,0.36953208,0.0700432,0.053408496),vec4(0.045825448,0.32412678,-0.29713488,-0.014257949)) * bufB[11];\nbufA[2] = vec4(0.36040756,-0.47827247,0.39086336,-0.26835525) + mat4(vec4(-0.036027167,0.07848066,-0.0003992864,0.085067935),vec4(-0.14232522,0.24942298,-0.36746097,0.11481267),vec4(-0.19103351,0.08056706,-0.079588644,0.25201985),vec4(-0.14132197,-0.09133475,0.043067098,-0.06431286)) * bufB[0] + mat4(vec4(-0.024231397,0.1570185,-0.44091195,-0.33604127),vec4(0.10901942,-0.23946565,-0.19548447,0.18701777),vec4(-0.26267925,-0.15393783,-0.19603795,0.40302762),vec4(-0.096744016,-0.1264731,-0.031627323,0.034018666)) * bufB[1] + mat4(vec4(0.118637286,0.098707,-0.0033334557,-0.27536437),vec4(0.013678931,-0.05539885,-0.15061684,0.07745106),vec4(-0.16639648,0.023306401,-0.024806743,0.13587837),vec4(0.15036397,-0.27765334,0.16743138,-0.08037869)) * bufB[2] + mat4(vec4(0.018993536,-0.15666206,-0.3835861,-0.06030994),vec4(-0.46709102,0.08065059,-0.10073516,0.01293456),vec4(-0.0424774,0.16134067,-0.07098511,-0.18918127),vec4(-0.5694932,-0.035759334,-0.19459453,0.5676875)) * bufB[3] + mat4(vec4(-0.058242608,-0.07888551,0.22159904,-0.34712568),vec4(-0.35320446,-0.10271924,0.05546304,-0.1417273),vec4(0.33254153,0.1464682,-0.10212765,-0.536987),vec4(-0.27073473,-0.14644437,-0.040264297,0.37693933)) * bufB[4] + mat4(vec4(-0.015311457,-0.3966005,0.26290572,-0.14636812),vec4(-0.12571922,0.10044527,-0.2705476,-0.4111082),vec4(0.081123084,0.12182957,0.104449004,-0.17569709),vec4(0.08665508,0.12007782,0.06735327,-0.03077512)) * bufB[5] + mat4(vec4(0.06317278,-0.09348726,0.3560009,0.027309729),vec4(0.10408649,-0.007301974,-0.39786056,0.046263363),vec4(-0.001595027,0.101214886,-0.066650584,-0.0042936774),vec4(-0.0032575584,-0.32417697,0.21308367,-0.043196045)) * bufB[6] + mat4(vec4(0.13433386,0.15010639,0.018893886,0.020958876),vec4(0.299095,-0.02667441,0.13619652,-0.1303173),vec4(0.08667597,-0.047840983,-0.069365315,0.044957343),vec4(-0.13537405,0.10893353,0.10218989,0.100267604)) * bufB[7] + mat4(vec4(-0.17563227,-0.1105461,-0.15250364,0.15038855),vec4(0.3439302,-0.05082615,0.30567324,-0.015747461),vec4(-0.055596985,-0.20701382,0.17310114,0.20369966),vec4(-0.1177178,-0.15384074,0.13184997,0.25702736)) * bufB[8] + mat4(vec4(-0.27405122,-0.0008645043,-0.11351085,-0.20063922),vec4(-0.39311954,-0.075123176,0.6390602,-0.051834766),vec4(-0.23778845,-0.113872044,0.0012465701,-0.07176993),vec4(0.09431294,0.09156953,0.024718838,0.3208735)) * bufB[9] + mat4(vec4(-0.021773502,0.03659185,0.09949805,-0.38554013),vec4(0.20655926,-0.10080147,0.084118485,0.0687476),vec4(0.28509253,0.06296059,-0.12371236,-0.17376338),vec4(0.0676569,-0.013924914,0.10859443,-0.2562209)) * bufB[10] + mat4(vec4(-0.03289407,-0.035498925,-0.19007821,0.00907932),vec4(0.045720454,0.36401376,-0.3692698,-0.27731624),vec4(0.034868214,-0.08298503,-0.24344671,0.33314225),vec4(0.044874966,-0.24037753,0.082650006,0.20112877)) * bufB[11];\nbufA[3] = vec4(0.25337252,-0.16018115,-0.043259762,-0.44501442) + mat4(vec4(0.035700243,0.24397318,-0.12154247,-0.22873324),vec4(-0.23610377,-0.06386681,-0.03329343,-0.29478487),vec4(-0.2680377,-0.093729615,-0.06963023,-0.09167392),vec4(0.26033664,-0.09863316,0.31605068,0.056634847)) * bufB[0] + mat4(vec4(0.3410843,0.24489436,0.11092319,0.035830263),vec4(-0.27282795,0.11615963,-0.23532301,0.3597397),vec4(-0.12355356,0.07587853,-0.09540138,-0.030153409),vec4(-0.17044234,0.09932303,0.06939381,-0.15472873)) * bufB[1] + mat4(vec4(0.11123867,-0.052564554,-0.012899627,0.093504496),vec4(-0.0586632,0.11640523,-0.13579383,-0.20170762),vec4(0.05491513,0.12060704,-0.01240113,-0.37999946),vec4(0.26888925,-0.14773488,0.06089133,0.3862765)) * bufB[2] + mat4(vec4(0.27588844,-0.106937096,0.15171684,-0.022077093),vec4(-0.33894005,0.0070025157,-0.20245422,-0.18898366),vec4(-0.03643778,0.10832082,0.36612296,0.049958892),vec4(0.005265317,-0.01845033,-0.11245859,-0.28828526)) * bufB[3] + mat4(vec4(-0.07816944,0.008489824,0.24344297,-0.1284149),vec4(-0.1351223,-0.2706445,-0.46359155,-0.5618971),vec4(-0.23736541,-0.05249151,-0.105943106,0.15130183),vec4(0.24536632,-0.20163913,-0.006868077,-0.30569202)) * bufB[4] + mat4(vec4(-0.045177124,-0.2511141,-0.06293559,-0.0032163975),vec4(-0.10632339,0.22446136,-0.1785832,-0.09223119),vec4(0.07896376,-0.20467636,0.30958495,-0.27020097),vec4(0.02355472,-0.081884384,0.20850924,0.17423625)) * bufB[5] + mat4(vec4(-0.016252842,0.07550274,0.2436959,0.2386104),vec4(0.20355514,0.06322665,-0.10416814,-0.1533091),vec4(-0.32284203,-0.14015843,-0.16944766,0.17707723),vec4(0.13795747,0.08511564,-0.101577416,0.11022695)) * bufB[6] + mat4(vec4(0.11587962,-0.1698053,0.20711698,-0.1210554),vec4(0.032020636,-0.13264522,0.1546764,0.10053104),vec4(-0.1564123,-0.12713072,-0.016073903,0.12052941),vec4(-0.1804166,0.015682492,0.12474323,-0.05667386)) * bufB[7] + mat4(vec4(-0.1800323,-0.05877243,-0.029818371,0.05246345),vec4(0.13216838,0.22087532,0.20413584,0.26586008),vec4(-0.118172415,0.100374416,0.009665466,0.21620034),vec4(0.038581263,-0.5136523,0.062548324,-0.18731704)) * bufB[8] + mat4(vec4(-0.025383053,-0.4428938,-0.050355088,-0.06659105),vec4(0.05421195,-0.20803203,-0.14626862,0.0058367117),vec4(-0.06932801,0.01646723,-0.16414227,0.11945164),vec4(0.14748257,0.11931325,-0.19281435,-0.033638176)) * bufB[9] + mat4(vec4(0.067434326,-0.056172285,-0.19364055,0.2315236),vec4(-0.049235452,0.11954462,-0.13086525,-0.09284728),vec4(0.07337832,0.24514031,0.14267442,0.30278707),vec4(0.30295187,0.47685048,0.21190861,0.33956036)) * bufB[10] + mat4(vec4(-0.14093345,0.16246262,-0.19091913,0.04717731),vec4(-0.260575,-0.25854638,-0.31015643,-0.2217448),vec4(0.11876051,0.024361333,0.2374227,0.3157911),vec4(0.21006806,-0.05573729,0.061038963,0.2504499)) * bufB[11];\nbufA[4] = vec4(-0.18856612,0.2007782,0.1181292,0.11106312) + mat4(vec4(-0.21053289,0.23166987,0.023852235,-0.07387601),vec4(0.06383369,0.10875267,0.01831297,-0.026131658),vec4(0.12516007,0.07607449,-0.15549375,-0.21444452),vec4(-0.0621619,0.3697432,0.015304124,-0.024316939)) * bufB[0] + mat4(vec4(0.13414897,0.24939463,0.4892649,-0.10518994),vec4(0.01260661,-0.2029676,-0.011050637,0.16941607),vec4(-0.19258013,0.036949147,0.3346025,-0.117974445),vec4(0.15692744,0.14327432,0.1987924,-0.09249758)) * bufB[1] + mat4(vec4(-0.0022379274,0.1366935,0.22970743,0.055506907),vec4(0.09552811,-0.14546429,0.4371441,0.3698438),vec4(0.13458359,-0.06099559,-0.27298522,-0.120320745),vec4(-0.050682757,-0.26420566,0.15243116,-0.0722957)) * bufB[2] + mat4(vec4(0.029754195,0.2798349,0.08484625,0.20663409),vec4(0.14329122,-0.11834591,-0.05417901,0.24302042),vec4(0.05566743,0.24122965,-0.05719418,-0.038766284),vec4(-0.31886736,0.47342414,0.22668768,-0.4913984)) * bufB[3] + mat4(vec4(0.04815082,0.07409325,-0.15979537,0.050413106),vec4(-0.10594525,-0.1628421,-0.0052245855,0.027269915),vec4(0.12891495,0.119506255,0.19029327,0.117077366),vec4(0.13659766,0.17955504,0.4453018,0.007589544)) * bufB[4] + mat4(vec4(-0.27564383,0.035407085,-0.04784786,-0.15391727),vec4(0.15463793,0.24618515,0.31524017,0.07469732),vec4(0.07887678,0.3387806,0.15519597,0.47189263),vec4(0.010210102,0.07226234,-0.060683865,-0.23923142)) * bufB[5] + mat4(vec4(0.12449601,0.3487071,-0.45571417,0.20802099),vec4(0.20041859,-0.27847248,-0.020745534,0.038891386),vec4(0.22562115,-0.070046864,-0.025607616,-0.013164769),vec4(0.027692067,0.23978889,-0.028146213,-0.08206331)) * bufB[6] + mat4(vec4(-0.3460319,-0.14343658,0.10899129,0.05239455),vec4(0.09081524,0.3722771,0.13050386,-0.04492853),vec4(-0.26358962,0.10739399,-0.22938721,0.08948737),vec4(-0.010161461,0.12755574,-0.16994642,-0.34028485)) * bufB[7] + mat4(vec4(-0.046899125,0.15342641,-0.082473546,-0.059216376),vec4(0.12647015,0.043815337,-0.120002575,0.086201645),vec4(0.10228157,0.101339914,0.024897052,-0.13375026),vec4(0.25663677,-0.071127236,0.46029797,-0.18313211)) * bufB[8] + mat4(vec4(0.18827248,-0.2784879,-0.116775975,-0.24072228),vec4(0.22011866,0.062458813,0.18152688,0.00547609),vec4(0.08191696,-0.06561387,-0.037042465,-0.21023224),vec4(0.14642441,-0.368108,-0.059187654,-0.267981)) * bufB[9] + mat4(vec4(0.06796025,0.027954252,-0.13751101,-0.2054414),vec4(0.093564905,-0.34816137,-0.16997047,-0.06250325),vec4(0.07691683,0.16416126,-0.15335073,0.10510667),vec4(0.10989366,0.03070403,-0.20986964,0.55681443)) * bufB[10] + mat4(vec4(0.04426955,0.07019071,-0.19457294,-0.1616317),vec4(0.2488255,0.13658902,0.5764786,0.22611125),vec4(-0.006642617,0.032995775,-0.0009418534,-0.043273836),vec4(0.21450317,0.13487059,0.002392629,0.090641744)) * bufB[11];\nbufA[5] = vec4(0.035687238,0.0497342,-0.40549812,0.083205305) + mat4(vec4(0.029653005,0.20002009,-0.050281286,-0.09700976),vec4(0.030617451,0.25170055,-0.09475697,-0.20058364),vec4(-0.06066303,-0.2528941,-0.051713374,0.06869253),vec4(0.37330326,-0.5160422,0.10748737,0.014624957)) * bufB[0] + mat4(vec4(0.3528555,0.014495844,0.11711518,0.027725395),vec4(-0.27678102,-0.13695036,0.068897404,-0.42493787),vec4(-0.007121258,0.24150571,-0.27731946,-0.110884935),vec4(-0.017682258,0.09782308,0.18543273,-0.26911205)) * bufB[1] + mat4(vec4(0.2615341,-0.28518257,0.13097139,-0.41940686),vec4(0.07879877,0.20613705,-0.073223345,-0.28952375),vec4(-0.26203522,0.021203922,-0.04880924,0.083730064),vec4(0.06545011,-0.16222784,-0.26465723,0.25333112)) * bufB[2] + mat4(vec4(0.062317684,-0.22232537,0.4145253,-0.14451353),vec4(-0.12895162,-0.028501973,-0.022040848,-0.14378622),vec4(0.0932668,-0.17380738,0.08785859,-0.38430056),vec4(-0.21311286,0.09689564,-0.31497696,-0.06511877)) * bufB[3] + mat4(vec4(0.4424034,-0.29125687,0.110038206,0.06278887),vec4(0.31957218,-0.105209686,-0.0470059,-0.12413845),vec4(-0.080482,-0.23463893,0.09726514,-0.0072198403),vec4(0.048650805,-0.04488257,-0.20211592,0.023011634)) * bufB[4] + mat4(vec4(0.004116307,-0.08300516,-0.034858648,-0.15003216),vec4(-0.022824612,-0.21072586,0.40008783,0.008904061),vec4(0.45170167,-0.007146,0.09258737,-0.13498028),vec4(0.16771811,-0.37355617,-0.2552385,0.25332263)) * bufB[5] + mat4(vec4(-0.18896349,-0.14300816,0.03591246,0.13583174),vec4(0.34074932,0.1912322,0.094003595,-0.058325645),vec4(0.09250053,0.28454903,-0.3074156,0.1693063),vec4(0.19813395,0.054662485,0.27298903,0.033224415)) * bufB[6] + mat4(vec4(0.3580131,0.009103805,0.2186095,-0.36256367),vec4(0.06311708,-0.20224924,0.12177802,0.5416089),vec4(-0.18674831,0.004517015,-0.12892595,-0.004946982),vec4(0.14361031,-0.16458958,0.22684057,0.11465471)) * bufB[7] + mat4(vec4(0.48222515,0.088350795,0.14341067,0.12542926),vec4(0.25141838,-0.12595457,0.0007841992,-0.060231127),vec4(-0.017308654,-0.25732738,-0.2922867,-0.004140928),vec4(0.06634168,-0.11185753,0.04672815,0.16688569)) * bufB[8] + mat4(vec4(0.050016556,0.23550437,-0.4680652,0.00845442),vec4(-0.10031543,-0.03320678,-0.088428065,-0.155988),vec4(-0.114498235,-0.27655128,-0.28217635,-0.33157584),vec4(0.019526778,-0.12046654,-0.2328363,-0.102660805)) * bufB[9] + mat4(vec4(-0.13126262,-0.49565947,-0.050547272,0.24505724),vec4(-0.20085026,0.39684525,0.44941995,0.32511848),vec4(-0.07003071,-0.11066983,0.17200093,0.13410413),vec4(-0.6249023,-0.06934621,0.13570462,0.39312047)) * bufB[10] + mat4(vec4(-0.2624107,-0.21198228,0.34122112,-0.13298552),vec4(-0.14505677,-0.069839,-0.11423736,-0.08645838),vec4(0.06713551,0.093859985,-0.17682247,0.03484107),vec4(0.07725885,0.024986811,0.21957478,-0.09184395)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 5 \nbufA[0] = vec4(-0.348063,-0.5750687,-0.3908307,0.3603002) + mat4(vec4(0.16323668,-0.1459301,-0.20854056,0.010804966),vec4(0.30636138,-0.16644679,-0.009477334,0.035629794),vec4(-0.19267789,0.3625452,-0.12750086,0.2564457),vec4(-0.26185238,0.15663803,0.22870854,0.19364165)) * bufB[0] + mat4(vec4(0.18040596,0.52444154,0.4936849,0.15361866),vec4(0.12936065,0.32767293,0.09491719,0.2851585),vec4(0.0786131,-0.44248414,0.2520531,0.010397814),vec4(-0.042171553,0.09050607,0.12773594,0.25647408)) * bufB[1] + mat4(vec4(-0.10567389,-0.22256738,-0.19163612,-0.1624652),vec4(0.048597112,-0.37473223,0.04308743,0.104014255),vec4(-0.2929609,0.1610537,-0.23586191,0.26880372),vec4(0.5220849,0.068286836,0.25768864,0.4111606)) * bufB[2] + mat4(vec4(0.21565439,-0.18035792,0.063935824,0.060318407),vec4(-0.04839415,0.024629071,0.060602076,-0.23987928),vec4(0.166151,0.09459073,-0.15535808,0.04295134),vec4(-0.13081077,0.19914763,-0.14319244,-0.0010130558)) * bufB[3] + mat4(vec4(-0.03923174,-0.2413107,0.058721703,0.023598714),vec4(0.35920238,0.28501344,-0.068665184,-0.07435513),vec4(-0.1251704,0.31692672,-0.06701465,0.18037139),vec4(-0.3188742,0.043451212,-0.04673434,0.11076003)) * bufB[4] + mat4(vec4(0.2010443,-0.20885839,-0.03596064,0.08461805),vec4(0.37402278,0.100390546,0.16360283,0.036165867),vec4(0.21034545,0.13399309,-0.32018661,-0.19579864),vec4(-0.114345044,0.0010209207,0.28489977,-0.23225912)) * bufB[5] + mat4(vec4(-0.20133078,0.1212155,-0.02354636,0.05808092),vec4(-0.35796013,-0.010339539,0.09804415,0.084948756),vec4(-0.61853707,-0.047410745,-0.13414825,-0.2588845),vec4(-0.20106584,0.35817844,0.2800737,0.17644756)) * bufB[6] + mat4(vec4(0.40306887,-0.23803575,-0.42312294,-0.17277204),vec4(0.038670912,-0.22490533,0.023559464,-0.241706),vec4(0.025249762,-0.19246846,-0.008006479,-0.21127672),vec4(-0.15563591,-0.1842416,-0.22615837,0.05597719)) * bufB[7] + mat4(vec4(-0.011493245,-0.049624376,-0.0047848704,-0.040597834),vec4(-0.0027520682,0.23126735,0.11747984,-0.29167128),vec4(0.15233503,0.46224457,0.18875596,0.15146431),vec4(0.14456268,-0.1080293,0.21489015,-0.3850753)) * bufB[8] + mat4(vec4(-0.099897295,0.26204106,-0.20682186,0.15858355),vec4(-0.10735762,0.058122307,0.009212194,0.1772221),vec4(0.44530207,0.1013863,0.07968409,-0.057825197),vec4(-0.19702975,-0.04396125,0.20495819,0.008282452)) * bufB[9] + mat4(vec4(0.010392903,-0.21982244,-0.019226983,-0.04085163),vec4(-0.088090435,-0.1714136,-0.31635308,0.047816437),vec4(-0.123889394,-0.28249487,-0.21007006,0.067090146),vec4(0.110055886,0.028674295,-0.047856167,0.17587729)) * bufB[10] + mat4(vec4(0.19381775,-0.13218841,-0.028288802,-0.11317227),vec4(-0.12588924,0.042475194,0.07793764,-0.2277521),vec4(0.16391738,-0.00822733,0.23112991,-0.21891786),vec4(-0.2882753,0.19676743,-0.022462832,0.19953091)) * bufB[11];\nbufA[1] = vec4(-0.34775418,-0.23399349,0.12448516,-0.012739044) + mat4(vec4(-0.15409257,0.17652397,-0.48728848,-0.36744514),vec4(0.124108136,-0.18851073,-0.101511486,0.046954848),vec4(0.07678898,0.010825955,0.032331523,-0.029939746),vec4(0.2080173,0.29267445,0.05740881,-0.23927148)) * bufB[0] + mat4(vec4(-0.027889363,0.009156807,0.09503569,-0.0394854),vec4(0.21510178,0.12693316,0.3054868,-0.30689514),vec4(-0.15977758,0.12506747,0.028406976,0.31513888),vec4(-0.012984208,-0.100986265,-0.20528206,-0.25023055)) * bufB[1] + mat4(vec4(0.25671658,0.08327009,-0.0012814123,0.028025545),vec4(-0.058482416,0.017608298,-0.30706683,0.04348695),vec4(-0.099408045,-0.32608092,0.6665853,0.033435706),vec4(0.09602628,-0.094677486,-0.06636489,-0.1291435)) * bufB[2] + mat4(vec4(-0.05959162,0.19096331,-0.19570358,0.0061730477),vec4(-0.2758031,0.19541892,-0.10102992,-0.04109601),vec4(-0.222073,0.20768894,0.08855221,-0.0905166),vec4(0.16053556,-0.10637704,-0.056279305,0.1544078)) * bufB[3] + mat4(vec4(0.16241217,-0.09460887,-0.011598069,0.11002902),vec4(0.0061500925,-0.18589254,-0.2036907,-0.32299682),vec4(0.071530595,0.07570896,0.13929383,-0.02231534),vec4(-0.20777148,0.11950913,0.03732418,0.10144099)) * bufB[4] + mat4(vec4(0.3406864,-0.29322633,-0.18034212,-0.27222723),vec4(-0.0023844205,0.19335635,-0.17489117,-0.078129895),vec4(-0.29615113,0.074297525,-0.115798585,-0.086433336),vec4(0.104168676,0.14248618,-0.22534938,0.28705743)) * bufB[5] + mat4(vec4(-0.14865166,-0.059583433,0.3115889,-0.098413266),vec4(0.04588951,-0.31556135,-0.17149718,0.009145585),vec4(0.054296244,-0.550619,0.19764833,-0.11134313),vec4(-0.07522154,-0.041674703,0.14907238,0.3102016)) * bufB[6] + mat4(vec4(0.08301203,0.30989102,-0.33508164,0.083575994),vec4(-0.124368854,0.2044971,0.016885465,0.16827181),vec4(0.066586494,0.12802844,0.08458399,-0.45387203),vec4(-0.1532765,0.0909769,-0.06023729,0.092070736)) * bufB[7] + mat4(vec4(0.035962284,0.2873426,0.0686231,0.3886183),vec4(-0.04004885,0.14114603,0.21130183,-0.17989334),vec4(-0.050187156,-0.45178863,0.1901477,0.16708769),vec4(-0.28086078,-0.06931799,-0.18859087,-0.021442536)) * bufB[8] + mat4(vec4(0.15839347,0.15745045,-0.12731712,-0.22099027),vec4(0.30605608,-0.041695338,0.1352988,-0.06600374),vec4(0.18658374,-0.030773187,-0.18362461,-0.09838809),vec4(0.06760329,0.4891178,0.052964814,0.024151273)) * bufB[9] + mat4(vec4(-0.06593598,0.08916654,0.2693007,0.2284818),vec4(-0.01266469,0.064265534,0.03562842,-0.55096614),vec4(0.08699493,-0.027914263,0.16873191,0.14167488),vec4(-0.1431337,-0.14808872,-0.22116406,-0.29097417)) * bufB[10] + mat4(vec4(0.1840088,-0.22075704,-0.36552328,-0.082104735),vec4(-0.06828203,0.08760304,-0.009361435,-0.21629375),vec4(0.3017962,-0.22783755,-0.024672115,0.123397596),vec4(0.34390444,-0.04745894,-0.21713504,0.10350312)) * bufB[11];\nbufA[2] = vec4(0.36857712,-0.22944593,0.26296636,-0.19681278) + mat4(vec4(-0.026287112,0.25436273,0.3069129,0.33000454),vec4(-0.081831366,-0.22300917,0.12868257,0.23737314),vec4(0.13809608,0.0001059426,-0.39959925,-0.13304006),vec4(0.15214658,0.060813773,-0.091986254,-0.70848304)) * bufB[0] + mat4(vec4(-0.060601506,0.0860185,-0.25076145,-0.11797288),vec4(-0.15140292,0.0032222304,-0.09987762,0.009340493),vec4(-0.091952346,0.21206704,-0.13988006,-0.25039855),vec4(-0.14895308,-0.07623423,0.20690449,-0.13493074)) * bufB[1] + mat4(vec4(-0.10687887,-0.3145208,0.045531005,0.34239972),vec4(-0.24437988,-0.08585517,0.2874885,0.049312983),vec4(0.14252535,-0.060183097,0.10592911,-0.25127384),vec4(0.09267966,0.25280243,-0.43282983,0.10911143)) * bufB[2] + mat4(vec4(0.0045115985,-0.34790707,0.1410589,0.06245735),vec4(-0.36219922,0.13551024,-0.32098806,0.6224239),vec4(0.0041275644,-0.21656741,0.25751415,0.3601575),vec4(0.009828541,-0.27739292,-0.0009923854,0.2743325)) * bufB[3] + mat4(vec4(0.0018958083,0.05231251,0.18888375,0.07481059),vec4(-0.12020034,0.010684375,0.1979694,0.12355476),vec4(0.4265835,0.10571545,-0.12288525,-0.38420635),vec4(-0.1326262,0.03090763,0.09409608,0.188742)) * bufB[4] + mat4(vec4(0.26039758,0.002870206,0.11325264,-0.34810388),vec4(-0.016030373,-0.000783453,-0.15210679,0.03573392),vec4(-0.117778555,0.008914237,0.052413393,0.2516112),vec4(-0.17305627,-0.4203833,-0.08633954,0.2111916)) * bufB[5] + mat4(vec4(0.050865572,0.2512273,-0.2757723,-0.18104722),vec4(0.06688244,-0.009850763,-0.15535548,-0.4110214),vec4(-0.5678996,0.17223278,-0.25193718,0.046385534),vec4(0.38387558,-0.026864015,-0.030618317,0.44115514)) * bufB[6] + mat4(vec4(-0.14225405,-0.118918195,0.18288615,0.23037776),vec4(0.019532576,-0.12292065,0.28871492,-0.023803087),vec4(-0.07161174,0.020937456,-0.06647339,-0.07451699),vec4(-0.30400604,-0.17213053,0.19257951,-0.25849962)) * bufB[7] + mat4(vec4(0.03459388,-0.22866346,0.29745048,0.026997209),vec4(0.20597202,0.106252894,0.0803977,-0.09303933),vec4(0.014327465,0.18439823,0.13236968,0.1441752),vec4(-0.12949803,0.11082491,0.13839115,0.16046846)) * bufB[8] + mat4(vec4(0.15762869,0.17245668,0.15242259,0.13279042),vec4(0.27630648,-0.21788763,0.080162026,0.027911918),vec4(0.15225942,0.30152333,-0.05980668,-0.21329014),vec4(0.2194508,-0.50548065,-0.18596551,0.11393452)) * bufB[9] + mat4(vec4(0.0112916995,-0.15227342,0.16013262,-0.048416167),vec4(-0.19205351,0.063507535,-0.14571778,-0.05379155),vec4(-0.110019505,0.01840623,0.10615349,0.08780337),vec4(-0.20674291,-0.31462905,-0.17366654,-0.09695554)) * bufB[10] + mat4(vec4(-0.028292157,-0.09269929,0.15964319,-0.3252399),vec4(-0.38504842,0.08728798,0.067670345,-0.07597704),vec4(-0.22429436,-0.12267233,-0.15440178,-0.1615168),vec4(0.35215595,-0.06996104,-0.10787062,-0.1454091)) * bufB[11];\nbufA[3] = vec4(0.40892327,0.09422777,0.2961073,0.29386923) + mat4(vec4(0.29658273,0.3362873,0.23716044,0.09572045),vec4(-0.026100121,0.013127324,0.09403161,-0.11334191),vec4(-0.51080215,0.062437937,-0.19135179,-0.35604158),vec4(0.19127196,-0.14092197,-0.33402163,0.2602578)) * bufB[0] + mat4(vec4(0.01221001,0.13914466,-0.18152419,0.20827816),vec4(0.0068519823,-0.19922914,-0.12112395,0.03093433),vec4(0.45308322,0.012721442,0.013918896,0.031897686),vec4(-0.19934984,0.050477475,-0.17334737,0.15647875)) * bufB[1] + mat4(vec4(-0.2894357,-0.1528928,-0.128614,-0.34193146),vec4(0.037039127,0.055356596,-0.15374547,-0.15912917),vec4(0.009832985,-0.5527853,-0.05059821,-0.1610383),vec4(0.036088098,-0.02261556,-0.19065797,0.07326695)) * bufB[2] + mat4(vec4(-0.5531538,0.2369922,-0.12260264,-0.11051193),vec4(0.013907736,-0.30106083,0.04710068,-0.30163038),vec4(-0.08115648,-0.039577592,-0.061767973,-0.10234715),vec4(-0.003987191,-0.05425652,-0.35494468,-0.08168923)) * bufB[3] + mat4(vec4(-0.25885993,-0.15397327,0.21379766,0.009016188),vec4(0.031382762,-0.0326629,0.16994956,-0.19487783),vec4(-0.023405414,0.35846233,0.13192792,-0.17510404),vec4(-0.1456337,-0.10677501,0.11505057,-0.15749441)) * bufB[4] + mat4(vec4(0.44247937,0.26857853,-0.09292152,0.23511472),vec4(-0.059439458,-0.13740468,0.11169215,0.10397561),vec4(0.012116389,0.15683393,0.14179479,-0.15998568),vec4(-0.46742412,-0.060888868,-0.20956233,0.12806822)) * bufB[5] + mat4(vec4(0.16087785,0.12364401,0.2501256,0.20322472),vec4(0.12919886,0.10749187,-0.12544182,0.36945337),vec4(0.36759624,-0.46594566,0.14741057,-0.026410751),vec4(-0.12847234,-0.034201097,-0.03693343,0.31830865)) * bufB[6] + mat4(vec4(-0.10927475,-0.09686187,0.2956477,-0.30949813),vec4(-0.07141083,-0.26241922,-0.088736236,-0.3315846),vec4(0.24379662,-0.03096196,0.18708618,0.08720993),vec4(0.038223345,-0.10965179,0.28023472,-0.15066929)) * bufB[7] + mat4(vec4(-0.15700737,-0.19327438,0.02274903,-0.15659882),vec4(0.036151446,0.086291365,0.30550686,0.15865402),vec4(0.10120695,0.32938805,0.062274437,0.1416807),vec4(0.034294065,0.10881919,-0.10831806,0.3949299)) * bufB[8] + mat4(vec4(-0.7359038,0.13761882,-0.23016514,-0.1883945),vec4(-0.13186114,0.07423926,-0.1944489,0.21062687),vec4(-0.03763729,0.40759033,-0.41300058,-0.2501836),vec4(-0.17975545,0.066510856,-0.050846774,0.067429624)) * bufB[9] + mat4(vec4(-0.22442867,0.04647314,-0.08793734,-0.1544976),vec4(-0.3788765,0.25117022,-0.08308444,0.15700503),vec4(-0.13351361,-0.18245992,-0.042296495,-0.14217906),vec4(0.07807319,-0.06852487,-0.013241957,0.093089044)) * bufB[10] + mat4(vec4(-0.29284337,-0.08544125,0.26478934,-0.24110213),vec4(-0.06636201,0.13070057,-0.026038745,0.308531),vec4(0.10937689,-0.05711052,-0.4247723,-0.06816167),vec4(-0.20711541,0.007466661,-0.330387,-0.11007356)) * bufB[11];\nbufA[4] = vec4(0.040649563,-0.27424523,0.5049593,0.3485144) + mat4(vec4(-0.08937297,0.056713764,0.18056113,0.20929635),vec4(-0.2068353,0.15159252,0.47061625,0.12664543),vec4(0.018649733,-0.1001111,-0.18740164,0.33861464),vec4(-0.26367915,0.12727463,-0.116261594,-0.3502736)) * bufB[0] + mat4(vec4(-0.098187014,-0.052760858,-0.07469904,-0.2431836),vec4(-0.2549618,-0.027607309,0.041458093,0.20345725),vec4(0.008068111,-0.34129673,0.28342447,-0.018612752),vec4(0.19696935,0.036366753,0.0093176,-0.35929337)) * bufB[1] + mat4(vec4(0.027298063,-0.2551491,0.12645377,0.117541045),vec4(0.13134915,0.48599315,0.08079633,-0.13602929),vec4(-0.0019466714,-0.4176455,-0.22068973,-0.13457142),vec4(-0.264081,-0.19112527,0.41511807,-0.02596878)) * bufB[2] + mat4(vec4(-0.30668104,-0.16193852,0.13829467,0.08551177),vec4(0.033597045,0.11013408,0.22358157,0.15640786),vec4(0.09713392,-0.19255504,0.14650492,0.06316139),vec4(0.3045915,-0.3432476,0.15428106,-0.2210713)) * bufB[3] + mat4(vec4(-0.059681598,-0.004938676,0.2294599,0.14487858),vec4(0.011402567,-0.080621265,0.11523518,0.0117840925),vec4(0.08206916,-0.3332639,0.15102665,0.088566616),vec4(0.14134708,-0.4359194,0.26757804,-0.056508094)) * bufB[4] + mat4(vec4(-0.020556279,0.047263347,0.05590398,-0.13103084),vec4(-0.19278342,-0.33548185,0.11852439,0.048559275),vec4(-0.15363939,-0.087410524,0.24656725,0.3248958),vec4(-0.18637744,-0.12197224,-0.038685102,-0.13948762)) * bufB[5] + mat4(vec4(-0.06890452,-0.052746154,0.042569503,-0.17744856),vec4(0.6184678,0.1580134,-0.62057656,-0.07788131),vec4(0.15663882,-0.041897584,-0.0480603,-0.061250508),vec4(-0.10358459,0.1259527,-0.07199668,-0.4476712)) * bufB[6] + mat4(vec4(-0.24857561,-0.08281066,0.2260555,-0.026578663),vec4(0.118987456,-0.17362626,-0.02473429,-0.021374267),vec4(-0.19258796,0.20200689,0.11624213,-0.114307955),vec4(-0.0059194188,-0.1393291,-0.24904278,0.076407485)) * bufB[7] + mat4(vec4(0.099413194,0.11914057,0.04435787,-0.108541265),vec4(-0.11178775,0.05616884,0.054099888,0.014180327),vec4(0.12608106,-0.42113212,-0.17635462,0.1199636),vec4(0.1317471,-0.23416136,0.22945929,-0.04084752)) * bufB[8] + mat4(vec4(-0.28605554,-0.0812627,0.01977443,0.29096088),vec4(0.20764697,-0.23375186,-0.012506888,0.03314274),vec4(-0.11562442,0.023190668,0.25029168,0.110065125),vec4(0.087206066,-0.74814993,-0.052742645,-0.17547156)) * bufB[9] + mat4(vec4(0.13919425,0.056554943,-0.063395776,-0.18829717),vec4(-0.14687476,-0.07396369,0.30688536,0.2323962),vec4(0.2307515,-0.72099036,0.084584944,-0.11801465),vec4(0.33890766,-0.24837415,0.073825516,-0.087191604)) * bufB[10] + mat4(vec4(0.07067059,0.19420102,-0.33910683,0.025662728),vec4(0.31712955,0.1240613,0.1842048,-0.13235085),vec4(0.5049402,-0.40902287,-0.32360557,-0.17129482),vec4(0.037339285,0.1034104,-0.32185525,0.1882625)) * bufB[11];\nbufA[5] = vec4(0.4676301,-0.41461888,-0.40007186,0.042990662) + mat4(vec4(0.34069246,0.12053787,0.06848467,-0.38609448),vec4(0.08562858,-0.006825753,0.15868478,0.08414129),vec4(0.019123483,0.4722672,0.3063166,0.1602258),vec4(-0.082757436,-0.12519753,-0.12122969,0.039508946)) * bufB[0] + mat4(vec4(0.087925166,-0.37894621,-0.056708455,0.2549168),vec4(-0.09258909,-0.053515363,-0.23180243,0.027435798),vec4(0.2872118,0.14856985,0.6816002,0.10848892),vec4(0.03221304,-0.038711086,-0.13194382,0.012191183)) * bufB[1] + mat4(vec4(-0.2094213,0.31721804,0.20697515,0.1088923),vec4(-0.18841876,-0.03616187,-0.031257734,0.034101654),vec4(-0.07200155,0.08661035,0.17733571,0.351022),vec4(0.13007753,-0.30907762,0.09896708,0.0006328664)) * bufB[2] + mat4(vec4(-0.08014828,0.0019842752,0.31216687,-0.31778896),vec4(0.14217758,0.037008766,-0.15896884,0.53064936),vec4(0.002255924,0.101220995,0.29492992,0.1558478),vec4(-0.0618294,-0.07898699,0.081018634,0.10884817)) * bufB[3] + mat4(vec4(0.21444023,-0.01171985,0.00037251023,0.15749301),vec4(-0.22919671,-0.20190872,-0.31454444,-0.3740828),vec4(0.34492493,0.08981374,0.026742183,-0.041924726),vec4(0.58244246,-0.009983032,0.28107768,0.35600707)) * bufB[4] + mat4(vec4(-0.010170109,-0.43697354,0.1015642,-0.21954904),vec4(0.011634726,-0.046704445,-0.1859921,-0.0061068963),vec4(-0.09221122,-0.1913194,0.0023376483,0.073187344),vec4(0.007185265,0.051333163,0.24827936,-0.27786884)) * bufB[5] + mat4(vec4(0.04056439,-0.11750784,-0.12908152,-0.10131439),vec4(-0.28868458,0.048968755,-0.08675202,-0.15075572),vec4(-0.08814676,-0.16385907,0.048227165,0.07978496),vec4(-0.07311981,-0.69985336,0.15174295,-0.10244405)) * bufB[6] + mat4(vec4(-0.1801777,0.2994068,-0.01831421,0.100691214),vec4(-0.0689584,-0.031672277,0.0319934,0.26370594),vec4(-0.22715324,0.00444841,-0.23498102,-0.093635276),vec4(-0.06027033,0.08369181,-0.009447562,0.030663762)) * bufB[7] + mat4(vec4(0.23172832,0.21545494,0.20846845,-0.15729593),vec4(0.1081126,0.029503044,-0.11183026,0.0016690778),vec4(0.18233989,-0.118028075,0.2226868,0.060660064),vec4(0.14595267,-0.6969749,0.06114193,-0.07501016)) * bufB[8] + mat4(vec4(-0.027660955,0.07896165,-0.20238478,-0.40760407),vec4(-0.22305767,-0.3846097,-0.4459742,-0.12751403),vec4(0.3611085,-0.21668491,0.049394187,-0.16270335),vec4(-0.12520148,0.29083908,0.30666608,-0.17538825)) * bufB[9] + mat4(vec4(0.1710706,0.21559677,0.3023048,-0.10116401),vec4(0.07818643,-0.02337803,-0.27660647,0.025564631),vec4(-0.13016458,-0.044679884,-0.26035658,0.2732354),vec4(-0.014830897,0.04343019,-0.41591403,-0.0721768)) * bufB[10] + mat4(vec4(0.15106198,0.03917789,-0.04991297,0.05853197),vec4(-0.16518055,-0.2947669,-0.054026112,-0.058625877),vec4(0.06414799,-0.25502694,-0.1030324,-0.03824101),vec4(0.039380684,0.043335076,-0.08688407,-0.27697536)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 6 \nbufA[0] = vec4(0.22433811,0.34200606,-0.5520317,0.29106972) + mat4(vec4(-0.2534329,0.07501899,-0.35753283,-0.23217374),vec4(0.2667786,-0.3504613,0.2945152,0.015271034),vec4(-0.39668924,-0.43316966,0.3189253,-0.057358),vec4(0.2483401,-0.32017398,0.17104019,-0.26993635)) * bufB[0] + mat4(vec4(0.17730473,0.090214744,0.01718759,0.030761272),vec4(-0.18398975,0.27869302,-0.189799,-0.22149853),vec4(0.1542762,-0.3671018,0.2932395,0.043041423),vec4(-0.26396233,0.17566004,-0.08204093,-0.05339054)) * bufB[1] + mat4(vec4(-0.37267035,-0.11178126,-0.20840394,-0.16670187),vec4(0.17841491,-0.0024695562,-0.10509018,-0.03955174),vec4(-0.067800015,0.33286256,-0.039960805,0.05838739),vec4(0.030589543,0.1911813,-0.015978504,0.07848113)) * bufB[2] + mat4(vec4(0.13205758,0.1730839,-0.19542539,0.038186785),vec4(-0.43274218,-0.21958454,0.13716312,-0.04024069),vec4(0.030545272,0.1347139,0.17723744,0.21949735),vec4(0.22798504,-0.06361008,0.1525238,0.25491866)) * bufB[3] + mat4(vec4(-0.08649116,0.2460575,0.014962323,0.11995101),vec4(0.31516445,-0.14712769,-0.25809246,0.30762976),vec4(-0.079412594,-0.17619354,-0.1424996,-0.09773974),vec4(-0.17571706,-0.106380425,-0.059050836,-0.13598324)) * bufB[4] + mat4(vec4(-0.3648791,0.08135604,-0.14035285,-0.2995413),vec4(-0.03367745,-0.05967481,0.19740309,0.11779656),vec4(-0.12598655,-0.010936115,-0.034872368,-0.05877163),vec4(0.019826777,-0.15623416,0.09034622,-0.12129169)) * bufB[5] + mat4(vec4(0.15829547,0.013587225,0.38621634,-0.05440586),vec4(-0.2049655,-0.10055017,0.078505345,-0.06844058),vec4(-0.5907856,0.32064238,0.035251133,-0.15895899),vec4(0.013591403,-0.23741263,0.12570925,0.015281118)) * bufB[6] + mat4(vec4(0.08271385,0.03322175,-0.12702395,-0.43924442),vec4(0.13883692,0.049797364,0.43648997,0.16855219),vec4(0.35502017,-0.5330766,0.36392215,-0.3246296),vec4(0.07597778,0.017121548,-0.070998035,0.19537626)) * bufB[7] + mat4(vec4(-0.0051561734,0.15925553,0.11862663,-0.23016226),vec4(0.18643913,0.16112687,-0.24452655,0.14260627),vec4(-0.1955094,0.36660028,-0.18955138,0.036583945),vec4(-0.24988891,-0.0002714825,0.2514189,-0.04473637)) * bufB[8] + mat4(vec4(-0.15423702,-0.2526157,-0.38511947,-0.14585322),vec4(-0.22562332,-0.24432732,0.05344678,-0.14481561),vec4(0.16479817,0.15200077,-0.13879675,-0.24813658),vec4(0.15130714,-0.21336864,0.25019965,0.19056475)) * bufB[9] + mat4(vec4(-0.054524362,-4.5533525e-05,0.0034780381,-0.080410406),vec4(0.032396518,0.2795681,-0.07750461,-0.2537104),vec4(0.10739025,-0.3463557,0.0933399,-0.37417266),vec4(0.030100686,-0.17378384,0.19423506,0.015943708)) * bufB[10] + mat4(vec4(0.25002208,0.19804983,-0.21255389,0.4194053),vec4(-0.16278279,-0.27051574,0.23945504,0.1214777),vec4(0.12579107,-0.16483656,-0.2828444,-0.023073738),vec4(-0.23139429,0.17417334,-0.1851481,0.039518584)) * bufB[11];\nbufA[1] = vec4(0.509537,-0.4435785,0.36002064,-0.025931614) + mat4(vec4(-0.12630422,0.29903004,0.25759295,-0.21482955),vec4(-0.06405755,0.01819516,0.05932821,0.16549143),vec4(0.17920779,0.50384295,-0.28838068,0.2136646),vec4(0.11777753,-0.032092955,0.08055025,0.21687852)) * bufB[0] + mat4(vec4(0.10015886,-0.05516897,0.2586041,0.18338235),vec4(-0.23249681,-0.08274168,0.06753256,-0.14771149),vec4(0.06976187,-0.060348056,0.06396377,0.15887602),vec4(0.40865397,0.14035125,-0.3782149,0.08197022)) * bufB[1] + mat4(vec4(-0.4510183,0.042338435,-0.15885897,-0.026259435),vec4(-0.15607841,-0.24936989,0.17155845,-0.40791163),vec4(0.052537337,-0.30054736,0.01555044,-0.1516958),vec4(0.027564872,-0.21964605,0.14508894,-0.26967975)) * bufB[2] + mat4(vec4(-0.07014141,-0.25494957,-0.074963436,-0.04275073),vec4(-0.5351144,-0.07763117,-0.31771967,-0.12978186),vec4(-0.3232795,-0.25235912,-0.024228094,-0.25645515),vec4(0.3385186,0.08567855,-0.4522422,0.05057891)) * bufB[3] + mat4(vec4(0.21807915,0.12839247,-0.10996483,-0.088469155),vec4(0.3232003,0.35828394,0.2746386,0.04043339),vec4(0.028584642,-0.2627147,0.46205136,-0.07453056),vec4(-0.38194537,-0.04729541,0.41350195,0.0084723355)) * bufB[4] + mat4(vec4(-0.10122995,-0.13884905,0.008560103,-0.42358324),vec4(-0.19122267,-0.02056214,0.019244207,0.00978668),vec4(0.06508134,0.15414293,0.013927199,0.058266077),vec4(-0.062391832,0.1961453,-0.19798055,0.06025013)) * bufB[5] + mat4(vec4(0.038224667,-0.16039346,-0.18110159,-0.113885246),vec4(0.120424,-0.28232113,-0.25204962,-0.020812422),vec4(-0.077778116,0.1663861,0.20698705,-0.38046798),vec4(0.13919923,-0.19308926,-0.2913676,-0.04618133)) * bufB[6] + mat4(vec4(0.2579834,0.033160504,0.10224559,0.20266813),vec4(0.047170043,-0.042728793,-0.08323921,0.15146834),vec4(0.30776677,0.0077052545,-0.37596014,0.122744314),vec4(0.02249526,0.12740484,0.23962826,0.14423035)) * bufB[7] + mat4(vec4(-0.2245354,-0.37849876,-0.071950525,-0.2214632),vec4(0.26804245,-0.18516657,0.025206666,0.25564817),vec4(-0.17449987,-0.12781325,0.09465952,0.059470892),vec4(-0.14607921,0.1229101,-0.5903588,0.11944871)) * bufB[8] + mat4(vec4(-0.06925967,-0.37769815,0.15395415,0.16289428),vec4(-0.14878798,-0.01751912,-0.018044006,-0.11975145),vec4(-0.13083337,-0.005170228,-0.028338877,0.16669601),vec4(0.2896304,0.016204933,-0.22835116,0.34035528)) * bufB[9] + mat4(vec4(0.17536323,0.042499907,-0.25647014,0.0043505616),vec4(-0.004499302,-0.016761644,-0.094951384,-0.4125696),vec4(-0.033480346,-0.24807738,0.014036856,-0.15378593),vec4(-0.2510988,-0.11449364,-0.092027016,0.22352542)) * bufB[10] + mat4(vec4(0.10185643,-0.18485631,0.33047196,-0.15968217),vec4(0.04565426,0.21996194,-0.17299403,-0.22551544),vec4(0.047283173,0.106030814,0.0974941,0.004892623),vec4(-0.23876308,0.14936095,0.04778523,-0.028931972)) * bufB[11];\nbufA[2] = vec4(-0.11097453,0.5078061,-0.0385006,0.05734806) + mat4(vec4(0.53276646,-0.22703324,0.4910428,0.15223978),vec4(-0.08827465,0.17181186,-0.13340089,0.15993106),vec4(0.24656522,-0.14059469,-0.15212113,0.26064),vec4(0.15521221,0.38492718,0.036578923,-0.038224634)) * bufB[0] + mat4(vec4(0.19127832,0.3424501,0.050789323,-0.439952),vec4(-0.029364852,0.004050843,0.04991814,-0.26048052),vec4(0.004584319,0.0668037,-0.18362744,-0.13998997),vec4(0.10644858,0.15649812,0.10500945,-0.1598909)) * bufB[1] + mat4(vec4(-0.11070844,0.6143379,0.13455921,0.24109998),vec4(-0.04560144,-0.026140854,0.07605719,-0.019295085),vec4(-0.16831969,0.09594773,-0.115085,-0.0452651),vec4(0.08168948,-0.2513703,0.04856678,0.48844492)) * bufB[2] + mat4(vec4(0.21504253,0.083717436,-0.024596088,-0.1716081),vec4(0.27999455,0.42525005,-0.14579849,0.34419084),vec4(-0.107621595,-0.24789691,-0.29649636,0.098312944),vec4(-0.36531577,0.16586955,-0.014123375,0.3725462)) * bufB[3] + mat4(vec4(-0.028042577,0.083244994,0.12355373,-0.093172446),vec4(-0.033578917,0.27447516,-0.19605555,0.12613021),vec4(0.123890504,-0.21144061,0.2523515,-0.117175646),vec4(0.07918664,0.119345464,0.18839562,-0.13110462)) * bufB[4] + mat4(vec4(0.007117794,-0.018919589,-0.102564126,0.24600796),vec4(0.07193371,-0.013746241,0.2696367,-0.21243839),vec4(-0.07793729,-0.054435324,-0.17671658,0.03265774),vec4(0.11577725,-0.19184843,0.17935358,0.15391606)) * bufB[5] + mat4(vec4(-0.10896082,0.1360497,-0.0648542,0.007390387),vec4(-0.07409112,-0.05067702,-0.12979953,-0.13426015),vec4(0.16653028,0.24013136,0.30028835,-0.12368653),vec4(-0.28515252,-0.1605133,-0.11705851,0.19604103)) * bufB[6] + mat4(vec4(0.17038614,0.025157202,0.20746174,0.27124748),vec4(-0.097648636,0.08432693,0.24417381,0.17667274),vec4(0.0025513093,0.076979205,0.052814744,-0.07518888),vec4(-0.02945798,0.09778442,-0.14556043,-0.08144357)) * bufB[7] + mat4(vec4(-0.05228615,-0.4566759,-0.2679699,0.26108095),vec4(0.06572886,-0.07804969,-0.114767015,-0.19032155),vec4(-0.17485316,0.13008495,-0.120720595,0.06867632),vec4(-0.07963376,0.29573286,0.35463384,0.4318348)) * bufB[8] + mat4(vec4(-0.42447215,0.17153555,-0.058094926,-0.1035551),vec4(-0.2091078,-0.17166665,-0.09331115,-0.06877025),vec4(-0.027821885,-0.08442332,0.2543762,0.035327602),vec4(-0.12500891,-0.2355535,-0.03916743,0.3929595)) * bufB[9] + mat4(vec4(-0.17344825,0.042520836,-0.110023715,0.12481733),vec4(-0.20719557,0.28598902,0.14307247,0.010292365),vec4(-0.0052636056,-0.293054,0.108414575,0.19649783),vec4(0.057988264,-0.06182672,0.023961775,0.02494955)) * bufB[10] + mat4(vec4(-0.20514803,0.19490492,0.09850332,-0.26730427),vec4(0.2972582,-0.13400835,-0.18011932,0.72933686),vec4(-0.050931517,-0.08512903,-0.11896278,-0.12578882),vec4(0.042733088,0.23118535,-0.1798115,0.24262573)) * bufB[11];\nbufA[3] = vec4(0.36337483,0.3440402,-0.28470317,0.42041314) + mat4(vec4(0.24376336,-0.18812892,-0.009004985,0.2655548),vec4(0.020640522,0.09975639,0.23453842,-0.1004304),vec4(0.114927106,-0.16466357,0.16711503,0.14473957),vec4(0.0016392678,-0.32885867,0.009759845,0.047025993)) * bufB[0] + mat4(vec4(0.17874148,0.08648831,-0.13587765,0.25503096),vec4(-0.060973015,-0.20001593,-0.005983798,0.2758134),vec4(-0.12725717,-0.21057984,0.1795152,0.2333366),vec4(-0.3251781,0.041025203,0.1960261,0.4833263)) * bufB[1] + mat4(vec4(0.38130546,-0.08654434,-0.027361458,0.16146871),vec4(0.08052452,0.052866798,0.07519007,-0.050878048),vec4(0.05391235,0.1430615,0.2222557,-0.26287413),vec4(-0.14168909,0.41562828,0.24026018,-0.088662684)) * bufB[2] + mat4(vec4(0.19832498,-0.052854463,-0.07154795,0.10620761),vec4(0.21369983,0.21243171,-0.044655908,0.023010995),vec4(-0.23218703,0.27564782,-0.011977036,-0.18671635),vec4(0.08628535,0.020599628,0.0518011,-0.061033893)) * bufB[3] + mat4(vec4(-0.19195059,-0.054883283,-0.010324912,-0.046692587),vec4(0.190218,-0.1926986,0.045469902,-0.2389374),vec4(0.15228589,-0.25324264,-0.33205524,0.07094439),vec4(-0.09951376,0.25875908,0.04433807,-0.163086)) * bufB[4] + mat4(vec4(-0.36410382,0.019409118,-0.038409326,-0.0448599),vec4(-0.03945044,-0.07394355,0.07361426,0.16231693),vec4(-0.18425924,-0.18612294,0.11537056,0.14501615),vec4(-0.32894537,-0.08634081,0.07558297,-0.05919976)) * bufB[5] + mat4(vec4(-0.06396223,-0.013482286,-0.16534609,-0.03227613),vec4(-0.15498637,-0.24122785,0.0087387245,0.16189647),vec4(-0.035255987,0.11126213,-0.055366915,-0.043553114),vec4(-0.17279245,-0.14010268,-0.1791033,0.122861944)) * bufB[6] + mat4(vec4(0.17407581,0.09606969,-0.056823466,-0.007677525),vec4(0.42241892,-0.13235213,-0.30139753,-0.23323983),vec4(0.2146584,-0.13329068,-0.10563771,0.22566094),vec4(0.28659898,-0.31318045,-0.0030056578,-0.033368465)) * bufB[7] + mat4(vec4(-0.12891346,-0.40929833,-0.07338539,0.2345898),vec4(-0.01634428,0.28281602,-0.22472937,0.050929368),vec4(0.15973243,-0.18264705,-0.030411625,-0.43193048),vec4(-0.26270542,-0.46397883,-0.07885211,-0.23996077)) * bufB[8] + mat4(vec4(0.09141374,-0.015931219,-0.20992896,-0.0058229845),vec4(-0.45512757,-0.055054445,-0.09784132,-0.17081508),vec4(-0.074027486,-0.05930656,0.020501979,0.12600836),vec4(0.30253717,0.28817883,-0.13838117,-0.18040459)) * bufB[9] + mat4(vec4(-0.02787666,-0.17613553,-0.13473174,-0.118891954),vec4(0.045156274,0.16146669,-0.29125354,-0.20000228),vec4(0.0028556637,-0.30121747,-0.025104541,0.16355152),vec4(-0.16197363,-0.051327623,0.13547578,0.06599419)) * bufB[10] + mat4(vec4(0.24031182,0.0012514067,-0.17301275,-0.16233246),vec4(-0.009326597,-0.36412063,-0.2936455,-0.028606005),vec4(0.20838022,-0.16485398,-0.3837597,-0.054079827),vec4(0.2759757,0.12520272,-0.7096484,-0.047744274)) * bufB[11];\nbufA[4] = vec4(-0.43101704,-0.0720442,-0.058035187,-0.07030559) + mat4(vec4(-0.13541442,0.29088327,0.16758469,-0.025467005),vec4(-0.16186476,-0.34638193,-0.10654141,0.3947995),vec4(-0.12538846,-0.15660812,-0.112284414,-0.10437243),vec4(0.031756636,0.38083145,-0.14906193,0.16720197)) * bufB[0] + mat4(vec4(0.1676825,-0.12156109,-0.050419018,0.04286197),vec4(-0.59816885,0.23936233,-0.37984568,0.06738668),vec4(0.31939587,-0.06447158,-0.040898867,0.03574954),vec4(-0.2769297,-0.24054909,-0.06781185,-0.079547256)) * bufB[1] + mat4(vec4(0.21916547,0.006928103,-0.5038653,0.32320228),vec4(-0.1293644,0.14791958,0.117506966,-0.06605297),vec4(0.10204998,0.17874897,-0.09124087,0.01745384),vec4(-0.41355196,0.07405663,0.10256069,0.060799524)) * bufB[2] + mat4(vec4(0.220072,0.113651425,-0.026251836,0.24840358),vec4(0.033777654,-0.45643875,-0.19972688,0.19927013),vec4(-0.20579177,0.10394237,0.34555084,-0.016697995),vec4(0.6262493,-0.6502572,0.16862611,-0.22973166)) * bufB[3] + mat4(vec4(-0.10440444,-0.3569656,0.18059951,0.117806025),vec4(0.33473712,0.24643858,0.11910214,0.18641439),vec4(-0.43432382,0.18752879,0.35492235,0.10228829),vec4(0.0093366,0.0314991,-0.11036685,0.2075858)) * bufB[4] + mat4(vec4(-0.33088177,0.41471833,0.30092826,0.01024185),vec4(-0.17793566,0.26160875,-0.24311829,-0.027118884),vec4(0.0016038431,0.20536314,-0.05901233,0.06284569),vec4(0.04320251,0.0017833118,0.02705044,0.2412016)) * bufB[5] + mat4(vec4(0.13082041,-0.17274971,-0.25753748,0.13020508),vec4(-0.06486701,0.2118614,-0.34599626,0.023880094),vec4(0.057626165,0.22328164,-0.23556669,0.080443494),vec4(0.15378715,0.026249,0.42775348,-0.030281909)) * bufB[6] + mat4(vec4(-0.073847756,-0.046003737,-0.21473856,-0.18451002),vec4(-0.026136642,-0.055044133,-0.26834223,-0.19557951),vec4(-0.047204558,-0.31243876,-0.25345838,-0.05932375),vec4(0.25021216,0.0908366,0.09583807,-0.12390286)) * bufB[7] + mat4(vec4(-0.2639198,-0.3480244,0.20477392,-0.07535601),vec4(-0.015819842,0.05442994,-0.11303548,-0.28312585),vec4(0.05067134,0.02157291,0.12385605,-0.22775806),vec4(-0.3417759,-0.70149845,0.024514772,0.100642316)) * bufB[8] + mat4(vec4(-0.007973893,-0.009581305,-0.23936532,-0.10576855),vec4(-0.06194935,0.032445516,0.112888224,-0.05910583),vec4(-0.14877199,-0.15355974,-0.03822766,-0.25928837),vec4(0.0731241,0.042406958,0.32439217,-0.05737645)) * bufB[9] + mat4(vec4(0.4429909,-0.22378491,0.141401,-0.21736707),vec4(0.13520254,-0.028238699,-0.004729995,-0.46195292),vec4(0.18702999,0.000984873,0.031512752,0.04359629),vec4(-0.2169849,0.052799948,0.14160235,-0.035497118)) * bufB[10] + mat4(vec4(0.14323118,-0.1610176,0.047978833,0.14155546),vec4(0.052103832,-0.3878898,0.16127133,-0.14445072),vec4(0.29820058,-0.3762661,0.2325971,-0.131126),vec4(-0.0023536442,-0.06890634,-0.08223166,-0.020599779)) * bufB[11];\nbufA[5] = vec4(-0.17907883,-0.2998857,-0.36981106,0.06003693) + mat4(vec4(-0.11643522,-0.24226147,0.07369286,0.12983318),vec4(-0.21243764,-0.40792647,0.5542021,0.15731707),vec4(-0.042181283,0.26042336,0.38891816,-0.13437195),vec4(0.13531063,-0.05889829,0.20235826,-0.14688513)) * bufB[0] + mat4(vec4(0.22892636,0.025251785,0.13816038,0.3320935),vec4(0.18151543,0.33835575,-0.010602712,0.26113522),vec4(0.17411673,-0.48549244,0.34044355,-0.30535802),vec4(0.17124008,-0.08185372,-0.050316367,-0.26589823)) * bufB[1] + mat4(vec4(0.2142196,0.18242967,0.06668303,0.0020688744),vec4(-0.40461618,-0.034998987,-0.12265009,-0.11825716),vec4(0.102877244,0.025047652,-0.16928284,-0.19583665),vec4(0.25741827,0.18625993,-0.20790763,-0.21726467)) * bufB[2] + mat4(vec4(-0.2727291,-0.15036178,0.100678384,-0.2543774),vec4(-0.22247028,0.049128704,-0.06735608,0.17464666),vec4(-0.1864683,0.07513966,-0.16970554,0.07941512),vec4(-0.010723654,-0.22308789,0.3832255,-0.36595234)) * bufB[3] + mat4(vec4(0.039548144,0.11655808,-0.07529367,-0.007069746),vec4(-0.36514658,0.04094569,0.26687422,0.026495747),vec4(-0.050327223,0.1208969,-0.16274397,-0.2133234),vec4(-0.24407056,-0.0735573,-0.22783385,0.3102964)) * bufB[4] + mat4(vec4(-0.1631435,-0.024457796,-0.22595848,-0.41230255),vec4(0.36681357,-0.118604094,-0.03979474,0.30447254),vec4(0.0022501692,-0.19803594,0.0152039435,-0.10190356),vec4(-0.044143133,0.05034963,-0.03231666,-0.19771041)) * bufB[5] + mat4(vec4(0.10853048,-0.42401794,0.095914625,-0.04652871),vec4(-0.20124859,-0.14740023,0.114128776,-0.2166138),vec4(-0.072843164,0.14916915,-0.48292273,-0.06550335),vec4(0.20101212,-0.22696199,0.069509655,-0.12863693)) * bufB[6] + mat4(vec4(0.054978598,0.115497515,0.028998148,-0.06888529),vec4(-0.0032607107,-0.0144000845,-0.21807387,0.15865421),vec4(-0.0059886225,-0.08750095,0.14452595,0.17328708),vec4(-0.13195369,0.16522522,-0.0880413,0.09460414)) * bufB[7] + mat4(vec4(-0.24536303,-0.21633115,0.19706714,-0.22327127),vec4(0.45036253,0.056639142,-0.14261527,0.2770267),vec4(0.27794793,-0.21824431,-0.08008239,-0.15884285),vec4(-0.1557726,0.098600455,0.14479733,-0.19152294)) * bufB[8] + mat4(vec4(0.19040316,-0.03570954,0.06554694,0.039578125),vec4(-0.32430363,-0.26783276,0.017368242,0.3046959),vec4(-0.087343104,0.2500144,-0.16264503,-0.258429),vec4(-0.080779836,-0.043523435,-0.24138449,0.16375974)) * bufB[9] + mat4(vec4(0.07699102,0.12022126,-0.05955472,-0.07086325),vec4(0.21192984,-0.13758326,0.10532304,-0.13552487),vec4(-0.038646296,-0.09978189,-0.19750476,0.17405653),vec4(-0.088751025,-0.1119055,0.20070513,-0.5469105)) * bufB[10] + mat4(vec4(-0.03375985,0.09018216,0.08449547,-0.20983958),vec4(-0.076279104,0.43296453,0.0798549,0.022992972),vec4(-0.10399955,0.2588637,0.09516289,-0.118100606),vec4(-0.21620078,-0.011521535,-0.010892091,0.2556278)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 7 \nbufA[0] = vec4(-0.5266626,0.2912391,0.024591228,-0.33434668) + mat4(vec4(-0.06490226,-0.025906129,0.11337811,-0.041945215),vec4(0.21864636,-0.55991995,0.11747385,0.2900219),vec4(-0.085097775,0.019580754,-0.40916577,0.017828764),vec4(-0.22151215,-0.11180612,-0.10436466,0.36173555)) * bufB[0] + mat4(vec4(-0.33737555,0.084563665,-0.21162385,-0.21243827),vec4(-0.25520805,0.28831586,0.23497814,0.1220136),vec4(0.344176,-0.18568668,-0.0999219,0.03967959),vec4(0.010844878,-0.07420338,-0.06548718,-0.23568423)) * bufB[1] + mat4(vec4(0.08927494,0.036614843,0.31024736,-0.2060502),vec4(0.0033535464,-0.33649898,-0.14374983,0.015941244),vec4(-0.11875609,0.004063788,0.124844745,-0.1768901),vec4(0.08904797,-0.12377029,0.15400663,-0.025558364)) * bufB[2] + mat4(vec4(0.053626906,0.08291287,0.069032155,0.157574),vec4(-0.12617071,-0.01698664,-0.32149345,0.047513597),vec4(0.13430698,-0.15403749,0.04872083,-0.03521327),vec4(-0.052136607,0.10588772,-0.012255919,0.13006839)) * bufB[3] + mat4(vec4(-0.29185855,-0.21873142,-0.038822923,0.014243534),vec4(0.037945762,0.15630174,0.10342542,0.09206382),vec4(-0.12833238,0.12844184,-0.35469136,0.13423398),vec4(0.12284189,-0.10232486,-0.0924801,0.31982604)) * bufB[4] + mat4(vec4(-0.373471,0.019023601,-0.3090916,-0.0049079554),vec4(0.0034634792,0.15971136,0.0004985088,-0.10930392),vec4(-0.030667162,-0.14279357,-0.060879663,0.193994),vec4(0.16856681,-0.11891654,0.29304788,-0.16612017)) * bufB[5] + mat4(vec4(0.20755142,-0.08697826,-0.0377824,-0.22194056),vec4(-0.128314,-0.059772536,0.116117336,-0.014997269),vec4(0.0047446555,0.37005943,-0.09546138,0.19041039),vec4(-0.0043465677,0.046020493,0.12548292,0.1037602)) * bufB[6] + mat4(vec4(-0.3538966,0.01885601,-0.049323007,-0.008392946),vec4(0.0777316,-0.06351014,-0.16710465,-0.16137786),vec4(-0.38290435,0.25891772,-0.37507528,-0.08697481),vec4(-0.16974446,-0.23200712,0.10946811,-0.16949773)) * bufB[7] + mat4(vec4(-0.06732041,-0.33089662,-0.1760246,0.0053264447),vec4(0.20726834,0.123036444,0.27854395,-0.18304943),vec4(0.04125408,0.03265886,-0.21131748,0.017781973),vec4(0.13244307,-0.25680655,0.19108339,0.07578687)) * bufB[8] + mat4(vec4(-0.08073068,-0.0010385782,-0.09195159,-0.26558784),vec4(0.1876276,-0.044795547,-0.089255966,-0.31536946),vec4(0.16051136,-0.14019649,-0.11853429,-0.39728758),vec4(-0.029437747,-0.14068045,-0.110563494,0.02330343)) * bufB[9] + mat4(vec4(-0.20114765,0.051330186,-0.070472926,-0.00047258852),vec4(0.15959635,-0.06409838,-0.027228622,-0.17012364),vec4(-0.061647613,-0.004154872,-0.18529785,-0.09187884),vec4(-0.06979771,-0.037887644,-0.041071177,-0.030041369)) * bufB[10] + mat4(vec4(-0.06829565,-0.10842309,0.10182305,-0.2904645),vec4(-0.03702799,0.34167776,-0.00048600708,0.121469416),vec4(0.07633867,-0.07300627,-0.16573694,0.06800355),vec4(-0.03151532,-0.08768437,0.05642438,-0.26932812)) * bufB[11];\nbufA[1] = vec4(0.33887488,0.16722116,0.21372975,0.041618075) + mat4(vec4(-0.011061749,0.08864148,0.13791282,0.02207372),vec4(0.043215387,-0.0068592513,-0.55630946,0.13873295),vec4(0.055708736,0.30577543,0.47365183,0.30710992),vec4(0.16281453,0.05058891,-0.22755764,0.13509527)) * bufB[0] + mat4(vec4(-0.012928387,-0.08708952,0.027913023,-0.050849482),vec4(-0.04040536,-0.3177055,0.29994437,-0.1901694),vec4(-0.23842488,0.038821742,-0.19298701,-0.04053692),vec4(-0.025337718,0.10954708,0.051623713,-0.08975816)) * bufB[1] + mat4(vec4(-0.06531838,-0.20743671,-0.037726417,-0.038804866),vec4(0.039924774,0.52416456,0.23549417,-0.08649771),vec4(0.039422356,-0.33353058,0.27646083,-0.15913488),vec4(0.010827659,-0.01647525,0.0075080856,-0.14472173)) * bufB[2] + mat4(vec4(-0.10829615,0.30978045,-0.30182064,-0.13331877),vec4(0.24370822,-0.04590616,-0.39524257,0.25973085),vec4(-0.17207186,0.027116468,0.14469588,-0.1386624),vec4(-0.15419406,-0.2224274,0.09926244,0.021006752)) * bufB[3] + mat4(vec4(-0.007957696,0.6339635,0.18420795,-0.25283876),vec4(-0.10390347,0.050504427,0.24212018,0.26528984),vec4(0.06416175,0.08114477,-0.459624,0.48615882),vec4(0.077527106,0.19729544,0.24655528,0.07454262)) * bufB[4] + mat4(vec4(0.029157236,-0.032024343,0.15164284,-0.072086014),vec4(0.052053135,-0.0068439892,0.006638803,0.025510564),vec4(-0.14825167,0.33926687,0.549294,0.00416183),vec4(-0.24090983,-0.066126846,-0.21739045,-0.06932112)) * bufB[5] + mat4(vec4(0.037962534,-0.07560866,0.14259806,-0.24194223),vec4(0.031780228,0.25457853,0.08171598,0.024519349),vec4(-0.044166893,-0.28492874,-0.096806146,-0.016849315),vec4(0.026974479,-0.293551,-0.09811631,-0.20147622)) * bufB[6] + mat4(vec4(0.038064707,0.029305367,0.15803652,-0.029696664),vec4(0.29677916,-0.11212082,-0.18968618,0.27742833),vec4(0.08854107,0.28997564,0.33215263,0.25157),vec4(-0.11543066,0.04588363,-0.07851063,-0.03194546)) * bufB[7] + mat4(vec4(-0.2818862,0.03182525,-0.00021450076,0.17025931),vec4(0.15420844,0.24856448,0.08250269,-0.21373054),vec4(-0.07024027,0.49781018,-0.11834998,0.2277987),vec4(0.03610992,0.12395914,-0.022271248,-0.43932912)) * bufB[8] + mat4(vec4(0.16691467,-0.31665426,-0.14016756,0.32954535),vec4(0.21781208,-0.073216625,0.2779648,0.01725661),vec4(0.12703964,0.050476845,-0.30908448,-0.32000187),vec4(0.110649206,0.27528575,-0.111702785,-0.027450044)) * bufB[9] + mat4(vec4(0.025057098,0.012390036,-0.035072632,-0.089079365),vec4(0.07448397,0.07650584,0.14388925,-0.13986291),vec4(0.2509837,-0.220906,0.020767251,-0.17435911),vec4(-0.00475087,0.040560834,-0.16650705,-0.062428236)) * bufB[10] + mat4(vec4(0.14748387,-0.30274278,0.011172211,-0.3784406),vec4(-0.25144127,-0.015687322,-0.021334197,0.12312246),vec4(-0.13373238,-0.2181771,-0.0035371464,0.33877057),vec4(0.09841205,-0.13010153,0.17203334,-0.121202625)) * bufB[11];\nbufA[2] = vec4(-0.22292103,0.45436236,0.05342657,0.5033667) + mat4(vec4(0.010163053,-0.3164136,-0.08318572,-0.13809389),vec4(-0.14931005,-0.046550173,-0.12032609,-0.064871505),vec4(0.06716139,0.0014793861,0.24340533,-0.21038684),vec4(0.08617766,0.053490303,0.010529843,-0.11518157)) * bufB[0] + mat4(vec4(0.031358205,-0.03706411,0.21439078,-0.16783324),vec4(0.15242107,-0.3026525,-0.051052578,-0.17392315),vec4(0.07914163,0.015266598,-0.38789257,0.14354624),vec4(0.052465327,0.12767494,-0.054061957,0.11486334)) * bufB[1] + mat4(vec4(-0.0075525655,0.28282174,-0.14924254,0.14639601),vec4(-0.3407135,0.3655011,0.011650938,0.07232043),vec4(-0.079030044,0.062588625,0.0012487051,0.18784),vec4(-0.013719688,0.07731283,0.24000554,0.08115334)) * bufB[2] + mat4(vec4(-0.09468127,0.19956198,0.31857497,-0.17651947),vec4(0.052260093,-0.28969565,0.036293577,0.35392013),vec4(0.40557483,0.04678136,-0.0007422963,0.13222425),vec4(0.20820308,-0.037927542,0.078003265,-0.030642668)) * bufB[3] + mat4(vec4(0.08369287,-0.03970204,0.55759895,0.07903768),vec4(0.118016504,-0.1168064,-0.23726842,-0.094270736),vec4(0.15788166,-0.17857963,-0.039899547,-0.12418703),vec4(0.44157,0.08332818,0.19419646,-0.13397281)) * bufB[4] + mat4(vec4(-0.25989643,0.0027156207,0.020706557,0.366958),vec4(0.30561504,-0.13033938,-0.06809368,0.45148802),vec4(-0.049969587,-0.012116034,0.061249442,-0.20025279),vec4(-0.020123951,-0.26962948,-0.04502804,0.2982857)) * bufB[5] + mat4(vec4(0.27618065,0.44612086,-0.13642155,-0.4305882),vec4(-0.2770626,0.07876281,0.05671075,0.50159174),vec4(-0.21637619,-0.33907175,0.07501806,0.3285328),vec4(-0.116454676,0.14568564,-0.14933789,-0.050168592)) * bufB[6] + mat4(vec4(-0.21845087,-0.020727746,-0.14873399,0.10254017),vec4(0.002243779,0.1619101,0.065347955,-0.06702429),vec4(0.14732814,-0.2585881,-0.06452831,-0.11026533),vec4(-0.19915429,-0.076019906,0.13931322,-0.30489323)) * bufB[7] + mat4(vec4(0.12696913,0.21478751,-0.033229593,-0.03217898),vec4(0.02808368,0.23283798,0.618183,-0.093493395),vec4(-0.12686832,-0.0790705,-0.23638375,0.31813413),vec4(-0.15342197,0.4739623,0.3524729,-0.28384945)) * bufB[8] + mat4(vec4(-0.14519908,-0.12045875,-0.40792483,0.33308253),vec4(-0.21619152,0.08556501,0.15106346,-0.13972135),vec4(-0.29980862,-0.051510144,0.062219672,0.044646136),vec4(0.19451334,-0.1605984,0.11654841,0.09510771)) * bufB[9] + mat4(vec4(-0.18657166,-0.1273007,-0.10466237,-0.021699162),vec4(-0.08442581,0.21088186,0.27554566,-0.16913156),vec4(-0.3018362,-0.023304239,0.5879914,-0.06676671),vec4(-0.33519286,-0.2320085,0.098379694,-0.10526626)) * bufB[10] + mat4(vec4(-0.14085132,0.16368198,-0.25347403,-0.12283363),vec4(0.15084736,-0.16748528,-0.15660438,0.19423018),vec4(-0.2675843,-0.27761322,-0.20369591,-0.10807436),vec4(-0.026279598,0.031430677,-0.10855119,-0.4163793)) * bufB[11];\nbufA[3] = vec4(-0.021074215,-0.13294467,-0.17423986,-0.490017) + mat4(vec4(-0.057936437,-0.068342976,0.48125848,-0.04306792),vec4(0.35800746,-0.1255968,-0.61739177,0.27348942),vec4(0.102115266,-0.24225017,0.10179838,0.052353676),vec4(-0.10919166,-0.13695586,-0.06592179,0.1344606)) * bufB[0] + mat4(vec4(-0.1840695,-0.32181266,0.11815271,-0.0005684856),vec4(0.07068411,-0.17415962,0.29081708,0.12577303),vec4(-0.09890391,0.56243837,0.3519394,0.15541302),vec4(0.010228897,-0.080062225,0.052117173,0.07784646)) * bufB[1] + mat4(vec4(0.21852815,0.10265095,0.21223907,-0.15984924),vec4(0.094337076,-0.00065369875,-0.2598654,0.1774214),vec4(-0.16969788,0.09729922,-0.1342827,-0.10571258),vec4(-0.053616636,0.06643308,0.09698246,0.031042134)) * bufB[2] + mat4(vec4(-0.05324309,-0.09323489,0.023775311,0.20492624),vec4(-0.19983445,0.15752733,0.19005994,0.097462684),vec4(0.17033622,-0.15181093,0.31700936,-0.01902262),vec4(0.20604108,-0.2852604,0.08843917,0.18938997)) * bufB[3] + mat4(vec4(-0.25745073,-0.25150353,-0.13886078,0.25423434),vec4(-0.103311636,0.6173632,0.14604361,-0.007649687),vec4(-0.16842575,-0.1269563,0.048423033,0.07596113),vec4(-0.04214682,0.06182958,-0.02004117,0.23408112)) * bufB[4] + mat4(vec4(0.022790555,-0.33569366,0.12065342,-0.103937),vec4(0.08921298,0.18182847,-0.20824373,0.04296253),vec4(0.25027215,-0.28319436,0.31004423,-0.15432984),vec4(-0.13665569,-0.0048099733,-0.03488404,0.08718999)) * bufB[5] + mat4(vec4(-0.023140892,0.108772896,-0.16507693,-0.017184371),vec4(-0.15549907,-0.041436836,0.26853096,-0.32802892),vec4(-0.20983303,0.22581798,0.6914924,-0.13440065),vec4(-0.021115893,0.11530418,-0.27698305,-0.121932946)) * bufB[6] + mat4(vec4(0.13056791,-0.11343958,-0.068744466,-0.23735575),vec4(-0.21803752,-0.08544343,0.08653184,-0.14421487),vec4(-0.124766506,0.09112435,0.32702166,-0.029906321),vec4(-0.07913917,-0.23428261,0.027304158,0.18519966)) * bufB[7] + mat4(vec4(0.04494287,-0.30992523,0.14123902,0.0027852857),vec4(-0.0040508835,-0.025007192,-0.098314054,-0.31177238),vec4(-0.1828749,-0.046238687,-0.23714186,-0.18446073),vec4(0.17348053,-0.089043446,-0.42254752,-0.16195579)) * bufB[8] + mat4(vec4(-0.3610761,-0.135295,0.15300344,-0.19663766),vec4(0.19637613,0.064189576,0.09815343,-0.06896302),vec4(-0.15002,-0.113022044,-0.042376317,-0.19489022),vec4(-0.21588817,-0.21249348,0.11129854,0.050751362)) * bufB[9] + mat4(vec4(-0.23146047,-0.19365071,0.26025343,-0.14612928),vec4(0.02746207,-0.39321586,-0.00062992005,-0.16282612),vec4(0.023009785,-0.20536561,-0.08502706,-0.08423814),vec4(-0.061490837,-0.032728747,-0.16753447,-0.08855245)) * bufB[10] + mat4(vec4(0.07585303,0.119556285,-0.21615362,0.030834954),vec4(-0.122843266,-0.2341132,-0.16000232,0.0020479935),vec4(-0.2867084,0.09398181,0.6149142,0.30688593),vec4(0.0056291996,0.15322302,-0.07335743,-0.05792215)) * bufB[11];\nbufA[4] = vec4(-0.2763576,-0.38921458,-0.3647999,0.3152733) + mat4(vec4(0.111968085,-0.19859312,0.053174525,-0.17666872),vec4(-0.12849918,0.15527408,0.37706196,0.21738082),vec4(0.1380983,0.030133616,0.12948586,0.0634091),vec4(-0.083558254,0.05063875,0.01110596,0.35389042)) * bufB[0] + mat4(vec4(-0.07656409,0.013991658,0.12218476,-0.17930959),vec4(0.3906886,0.05795844,-0.059673123,0.17099355),vec4(0.46266508,0.017430283,0.0066581387,-0.16766639),vec4(-0.06762899,-0.03816887,0.45601386,0.17742312)) * bufB[1] + mat4(vec4(0.12424573,0.043152723,0.08700396,0.14061506),vec4(-0.2018906,0.13851205,0.21306524,-0.0033606638),vec4(-0.04692395,-0.04353674,0.08022685,-0.14084797),vec4(-0.12510799,0.14384213,-0.09309634,0.123991646)) * bufB[2] + mat4(vec4(-0.10088589,-0.029627647,0.12665996,0.026436616),vec4(0.29502004,0.14466318,-0.036765,-0.4054966),vec4(0.1554985,0.26336873,-0.051620547,0.05191806),vec4(0.021513438,0.35773784,0.061473414,-0.13848685)) * bufB[3] + mat4(vec4(0.08943859,0.13849191,0.31168133,0.17337146),vec4(0.29837224,0.27783093,-0.1665685,-0.31709033),vec4(-0.020622615,0.14697543,-0.20144556,-0.18876211),vec4(-0.02966548,0.27930444,0.07488138,-0.21201062)) * bufB[4] + mat4(vec4(0.007297973,-0.0021098848,0.43631887,0.25515634),vec4(0.09381087,0.23911582,-0.18712999,-0.2526369),vec4(0.49710616,0.116377,0.20981686,0.050946765),vec4(0.101723835,-0.24163255,-0.17660868,0.0690242)) * bufB[5] + mat4(vec4(0.11694138,0.12942557,0.3507992,0.07130883),vec4(-0.07007574,-0.13470735,-0.1394538,0.11026913),vec4(-0.13579857,-0.07963549,-0.24447833,-0.24729848),vec4(0.13235633,-0.0061426954,0.14507139,0.24086154)) * bufB[6] + mat4(vec4(0.107227854,-0.113688774,-0.015600466,-0.025430894),vec4(-0.009466809,-0.38747638,-0.2989928,-0.090721935),vec4(-0.10284944,-0.064319685,-0.04373516,-0.09446851),vec4(-0.075270765,-0.16791768,-0.07069211,-0.030419663)) * bufB[7] + mat4(vec4(-0.048071403,-0.027939973,-0.015535095,0.035546154),vec4(-0.06830438,-0.11824087,0.19246113,-0.16018191),vec4(-0.017174557,0.07314836,-0.10547882,0.32151198),vec4(-0.12961887,0.15072158,0.20512757,0.7993491)) * bufB[8] + mat4(vec4(0.07734806,-0.25528783,-0.39102837,0.02621643),vec4(0.13775201,-0.16625325,0.11470764,0.28067437),vec4(-0.13703936,-0.18263957,0.037063684,-0.016168065),vec4(0.09626833,-0.06717823,-0.287625,-0.06345588)) * bufB[9] + mat4(vec4(-0.23511186,-0.08186043,0.13341981,-0.17223398),vec4(-0.11328289,0.22309496,0.09490845,0.094091155),vec4(0.0040142057,-0.11622082,-0.20812358,0.09937644),vec4(-0.11037881,-0.17879,0.086373895,-0.021137465)) * bufB[10] + mat4(vec4(-0.28480604,0.06602485,0.28775135,0.32751635),vec4(0.051975437,-0.01816498,-0.08429584,-0.23520489),vec4(0.06339899,-0.04063914,-0.32574332,-0.16099031),vec4(-0.05652576,-0.021635229,0.17749833,-0.09601285)) * bufB[11];\nbufA[5] = vec4(0.3423935,0.13560027,-0.016619574,0.3662087) + mat4(vec4(-0.48384058,-0.08199454,0.3537123,-0.100701444),vec4(0.088632576,0.02017635,-0.24586718,-0.22111583),vec4(0.0063443147,-0.0073975055,0.26228985,-0.18918054),vec4(0.07945053,-0.13295056,-0.03771275,-0.17137215)) * bufB[0] + mat4(vec4(-0.39074668,-0.08462156,0.06704426,0.03497034),vec4(0.11640838,0.092805095,-0.17279105,0.0123876585),vec4(0.38831657,0.16460843,0.23980634,-0.15544975),vec4(-0.19438103,0.09182249,-0.17168236,0.1316804)) * bufB[1] + mat4(vec4(-0.045141038,-0.013647316,-0.36853072,-0.02985145),vec4(0.21143243,0.43138745,-0.24416982,0.09981341),vec4(-0.18195555,0.07549067,-0.2483166,-0.07031294),vec4(-0.010150508,-0.059097964,-0.1293206,-0.11308666)) * bufB[2] + mat4(vec4(0.045449983,-0.08253584,0.2885985,0.09147963),vec4(-0.0070861126,-0.15072288,-0.10839181,-0.38565794),vec4(-0.18200086,0.27607298,-0.046982832,-0.029572548),vec4(0.16505365,-0.128275,-0.033746082,-0.11901741)) * bufB[3] + mat4(vec4(-0.06513076,0.014990406,0.20734023,0.27575076),vec4(0.07925283,-0.28765145,0.00363152,-0.2535085),vec4(-0.0035068372,-0.3788649,-0.1312529,-0.029667381),vec4(0.023632165,-0.01287723,0.032456804,-0.08082833)) * bufB[4] + mat4(vec4(-0.35651132,0.22582357,-0.14185826,-0.09271952),vec4(-0.2069739,-0.17109382,-0.25104165,0.22207333),vec4(-0.05336577,0.04738088,-0.21152961,0.27316764),vec4(-0.2448475,-0.18851973,0.28088325,-0.06205984)) * bufB[5] + mat4(vec4(0.16514675,0.092136875,-0.32624927,0.12024121),vec4(0.012027592,0.05976022,-0.07980409,-0.03943988),vec4(-0.13423972,-0.17223567,-0.09559941,-0.21343672),vec4(0.004614356,-0.053106684,0.06809038,0.07761515)) * bufB[6] + mat4(vec4(-0.03295902,0.16572013,0.13043568,0.26519442),vec4(0.06437978,-0.16068125,0.07463278,0.13094425),vec4(0.107901536,-0.110287435,-0.17874125,0.0042688726),vec4(-0.10961424,0.28191978,0.32789725,0.08271247)) * bufB[7] + mat4(vec4(-0.099337235,-0.0864809,-0.23016146,-0.04113668),vec4(0.16515805,0.23823796,-0.20553951,0.08459713),vec4(-0.21860062,-0.15711904,0.026617514,-0.31250927),vec4(0.04315884,0.45455667,-0.2795458,0.2637022)) * bufB[8] + mat4(vec4(-0.49614212,-0.27019286,0.016100759,-0.20718879),vec4(0.3457839,0.13043934,0.0417429,0.2529039),vec4(0.062347274,-0.108595006,-0.0054722885,-0.21369131),vec4(-0.024945108,0.35999665,-0.03769311,0.13575111)) * bufB[9] + mat4(vec4(-0.08127423,-0.0998055,0.3858456,-0.11140206),vec4(-0.21210875,0.21544144,0.14903882,0.2921942),vec4(-0.21158254,0.18483698,0.17450155,-0.004191084),vec4(-0.28369105,-0.011062861,0.025011307,0.3211472)) * bufB[10] + mat4(vec4(0.30269045,0.014736456,-0.100947894,0.2744293),vec4(-0.024737133,0.19857046,-0.22323962,-0.28484252),vec4(-0.24038436,0.016310079,0.1573969,-0.26974863),vec4(0.105751246,0.145994,-0.17421184,0.41862667)) * bufB[11];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\n\n // layer 8 \nbufA[0] = vec4(0.07428152114152908,-0.11819204688072205,-0.004654873628169298,0.0) + mat4(vec4(0.08526551723480225,0.002847343683242798,0.09191641211509705,0.0),vec4(-0.03121897205710411,-0.02796873450279236,-0.02453651651740074,0.0),vec4(0.12357594817876816,0.0780385285615921,0.09497197717428207,0.0),vec4(-0.04790175333619118,0.06473134458065033,0.011307777836918831,0.0)) * bufB[0] + mat4(vec4(0.0061212643049657345,-0.01222165860235691,0.025118011981248856,0.0),vec4(-0.07133019715547562,0.0007124957628548145,0.053862422704696655,0.0),vec4(-0.06304217129945755,0.02980402670800686,0.1528972089290619,0.0),vec4(-0.1763516515493393,-0.052054524421691895,-0.034517910331487656,0.0)) * bufB[1] + mat4(vec4(-0.047066424041986465,0.08008217066526413,0.01521931029856205,0.0),vec4(0.1301794797182083,0.1212315559387207,0.059843599796295166,0.0),vec4(-0.057490523904561996,0.1567515730857849,0.1408407837152481,0.0),vec4(-0.0591198168694973,-0.10707326233386993,-0.11571364849805832,0.0)) * bufB[2] + mat4(vec4(0.08748608827590942,0.13214266300201416,0.14259684085845947,0.0),vec4(0.05112113058567047,-0.17476694285869598,-0.06971875578165054,0.0),vec4(-0.19968439638614655,-0.15467828512191772,-0.2275298535823822,0.0),vec4(-0.024499667808413506,-0.004723350051790476,-0.00809674896299839,0.0)) * bufB[3] + mat4(vec4(-0.03590633347630501,0.030063431710004807,0.022286493331193924,0.0),vec4(0.03790345415472984,0.1064373031258583,0.07362386584281921,0.0),vec4(0.09814291447401047,0.09954410791397095,0.04974295571446419,0.0),vec4(0.08085471391677856,0.1409679353237152,0.12122323364019394,0.0)) * bufB[4] + mat4(vec4(0.14324195683002472,0.12718583643436432,0.09721920639276505,0.0),vec4(0.12070483714342117,0.09766817092895508,0.06170717254281044,0.0),vec4(-0.0701121836900711,-0.08588968962430954,-0.026289334520697594,0.0),vec4(0.15183842182159424,0.09486488252878189,0.026217076927423477,0.0)) * bufB[5] + mat4(vec4(0.048389047384262085,-0.0350741483271122,-0.14820407330989838,0.0),vec4(0.0333840474486351,0.04740568995475769,0.09591309726238251,0.0),vec4(0.012327039614319801,0.052649565041065216,0.026047883555293083,0.0),vec4(0.024243591353297234,-0.023800630122423172,-0.017067506909370422,0.0)) * bufB[6] + mat4(vec4(-0.0006994674913585186,0.0020228526555001736,-0.027941666543483734,0.0),vec4(0.059394389390945435,0.11458931863307953,0.18232309818267822,0.0),vec4(-0.17169272899627686,-0.18583564460277557,-0.19209161400794983,0.0),vec4(0.10007726401090622,0.07117863744497299,0.044452518224716187,0.0)) * bufB[7] + mat4(vec4(0.023990973830223083,-0.062220245599746704,-0.01756587252020836,0.0),vec4(0.04361264407634735,0.07811016589403152,0.1807505041360855,0.0),vec4(-0.22202059626579285,-0.23898449540138245,-0.2500176429748535,0.0),vec4(0.0021234117448329926,0.07888834923505783,0.13500671088695526,0.0)) * bufB[8] + mat4(vec4(-0.05434556305408478,-0.08682034909725189,-0.08074229955673218,0.0),vec4(-0.1258304864168167,-0.07614978402853012,-0.05933456867933273,0.0),vec4(0.24211110174655914,0.25002625584602356,0.25205370783805847,0.0),vec4(-0.004699484910815954,-0.019833626225590706,-0.05702012777328491,0.0)) * bufB[9] + mat4(vec4(0.011371592991054058,0.02317560836672783,-0.03108704462647438,0.0),vec4(-0.0035617128014564514,-0.03616291657090187,-0.016661057248711586,0.0),vec4(0.08060238510370255,0.07804840058088303,0.10334230959415436,0.0),vec4(0.05898811295628548,0.09140726178884506,0.10165005922317505,0.0)) * bufB[10] + mat4(vec4(-0.031611617654561996,-0.08497247099876404,-0.13925738632678986,0.0),vec4(0.03623871132731438,0.056285541504621506,0.09181870520114899,0.0),vec4(-0.0661826953291893,-0.048722364008426666,-0.048610128462314606,0.0),vec4(0.05871628597378731,0.052603721618652344,0.06545109301805496,0.0)) * bufB[11];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(2.*uv, sin(iTime), 1.5*sin(0.69*iTime), 1.5*sin(0.44*iTime), 1.*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 144, 144, 126905], [126907, 126907, 126964, 127014, 127458]]}
{"id": "WsSGRc", "name": "firstBubble", "author": "DrRainBrain", "description": "einfache brechung", "tags": ["bubble"], "likes": 5, "viewed": 148, "published": "Public", "date": "1549487295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float n1=1.00; //air\n    float n2=1.33; //like whater on a wall\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 pos=vec2((1.0+cos(iTime)*0.5)*0.5,(1.0+sin(iTime)*0.5)*0.5);\n    float size=(iResolution.x+iResolution.x)/30.0* (1.5+cos(iTime*3.14156798)*0.0);\n    vec3 LP = vec3(iResolution.x*0.177,iResolution.x*0.75,size*4.0)*3.0;\n    vec3 VP = vec3(iResolution.x*0.5,iResolution.x*0.5,size*4.0);\n    vec3 speccol=vec3(0.0,0.0,0.0);\n    \n    col = texture(iChannel0,uv).xyz;\n    \n    if(pow(fragCoord.x-iResolution.x*pos.x,2.0)+pow(fragCoord.y-iResolution.y*pos.y,2.0)<pow(size*1.0,2.0)){ //sizecheck\n        vec2 dispos= fragCoord-(iResolution.xy*pos);\n    \tfloat h1=pow(size*1.0,2.0)-pow(dispos.x,2.0)-pow(dispos.y,2.0);\n    \t//if(h1<0.0){h1=0.0;} //increase sizecheck slightly\n        float h=pow(h1,0.5);\n        float alpha1 =  acos(h/size);\n    \t//if(h>size){alpha1 =  acos(size/h);}\n        float alpha=asin(sin(alpha1)*n1/n2);\n        \n        float diff = pow(pow(dispos.x,2.)+pow(dispos.y,2.0),0.5);\n        float faktor=(diff-tan(alpha1-alpha)*h)/diff;\n    \t//if(faktor<0.0){faktor=-faktor;}\n        dispos=dispos*faktor;//(1.5+cos(iTime));\n        uv=(dispos+(iResolution.xy*pos))/iResolution.xy;//vec2(512.0,288.0);\n        \n        vec3 SP = vec3(fragCoord,h);\n        vec3 MP = vec3(pos*iResolution.xy,0);\n        \n        vec3 ldir = normalize(SP-LP);\n        vec3 n=normalize(SP-MP);\n        \n        vec3 R = reflect(-ldir,n);\n        vec3 E = vec3(0.0,0.0,-1.0);\n        float cosAlpha = max(dot( E,R ),0.0);\n        \n        //speccol=vec3(0.8,0.8,0.8)*pow(cosAlpha,5.0)*0.9+vec3(0.1,0.1,0.1)*sin(alpha1);\n        speccol=vec3(1.0,1.0,1.0)*sin(alpha1/4.0)*0.7 + vec3(0.8,0.8,0.8)*pow(cosAlpha,5.0)*0.9;\n        col = texture(iChannel0,uv).xyz;\n    }\n    \n    //col = texture(iChannel1,uv).xyz;\n    fragColor = vec4(col+speccol,1.0);\n    //fragColor = vec4(uv,0.0,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2111]]}
{"id": "WsSGWG", "name": "Kaleidoscope Tunnel", "author": "kaneta", "description": "I was inspired by live VJ", "tags": ["2d", "ifs", "fold", "cineshader"], "likes": 33, "viewed": 6195, "published": "Public API", "date": "1549810341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI * 2. / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\n// TheGrid by dila\n// https://www.shadertoy.com/view/llcXWr\nfloat tex(vec2 p, float z)\n{\n    p = foldRotate(p, 8.0);\n    vec2 q = (fract(p / 10.0) - 0.5) * 10.0;\n    for (int i = 0; i < 3; ++i) {\n        for(int j = 0; j < 2; j++) {\n        \tq = abs(q) - .25;\n        \tq *= rot(PI * .25);\n        }\n        q = abs(q) - vec2(1.0, 1.5);\n        q *= rot(PI * .25 * z);\n\t\tq = foldRotate(q, 3.0);  \n    }\n\tfloat d = sdRect(q, vec2(1., 1.));\n    float f = 1.0 / (1.0 + abs(d));\n    return smoothstep(.9, 1., f);\n}\n\n// The Drive Home by BigWings\n// https://www.shadertoy.com/view/MdfBRX\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nfloat dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash(st);\n    return Bokeh(p, vec2(0.5, 0.5) + vec2(0.2) * rnd, 0.05, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    vec3 col = vec3(0.0);\n    #define N 6\n    #define NN float(N)\n    #define INTERVAL 3.0\n    #define INTENSITY vec3((NN * INTERVAL - t) / (NN * INTERVAL))\n    \n\n    float time = iTime;\n    for(int i = 0; i < N; i++) {\n        float t;\n        float ii = float(N - i);\n        t = ii * INTERVAL - mod(time - INTERVAL * 0.75, INTERVAL);\n        col = mix(col, INTENSITY, dirt(mod(uv * max(0.0, t) * 0.1 + vec2(.2, -.2) * time, 1.2), 3.5));\n        \n        t = ii * INTERVAL - mod(time + INTERVAL * 0.5, INTERVAL);\n        col = mix(col, INTENSITY * vec3(0.7, 0.8, 1.0) * 1.3,tex(uv * max(0.0, t), 4.45));\n        \n        t = ii * INTERVAL - mod(time - INTERVAL * 0.25, INTERVAL);\n        col = mix(col, INTENSITY * vec3(1.), dirt(mod(uv * max(0.0, t) * 0.1 + vec2(-.2, -.2) *  time, 1.2), 3.5));\n        \n        t = ii * INTERVAL - mod(time, INTERVAL);\n    \tfloat r = length(uv * 2.0 * max(0.0, t));\n    \tfloat rr = sm(-24.0, -0.0, (r - mod(time * 30.0, 90.0)), 10.0);\n        col = mix(col, mix(INTENSITY * vec3(1.), INTENSITY * vec3(0.7, 0.5, 1.0) * 3.0, rr),tex(uv * 2.0 * max(0.0, t), 0.27 + (2.0 * rr)));\n\n    }\n\n\tfragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 95], [97, 97, 137, 137, 262], [264, 264, 296, 296, 375], [377, 437, 465, 465, 886], [888, 959, 1023, 1023, 1172], [1174, 1174, 1194, 1194, 1305], [1307, 1307, 1337, 1337, 1546], [1548, 1548, 1602, 1602, 1682], [1684, 1684, 1741, 1741, 3023]]}
{"id": "wsSGzc", "name": "practice-20", "author": "kiyamada96", "description": "yugami", "tags": ["yugami"], "likes": 1, "viewed": 59, "published": "Public", "date": "1550118876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float square(vec2 p,float s)\n{\n\tvec2 k=vec2(abs(p.x)+abs(p.y),0.5); \n    return smoothstep(0.1*s,0.1*s+0.04,k.x);\n    \n}\n\nvec2 brickSquare(vec2 st,float n)\n{\n\tst*=n;\n    return fract(st)-0.5;\n}\n\nvec3 changeRGB(vec3 col)\n{\n\treturn col/256.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    p*=1.0+0.3*sin(p.x*5.+iTime)+0.1*sin(p.y*5.+iTime);\n    float n=5.0;\n   \tp=brickSquare(p,n);\n    float col=square(p,5.);\n    vec3 colA=changeRGB(vec3(15.0,92.0,120.0));\n    vec3 colB=changeRGB(vec3(15.0,92.0,160.0));\n    vec3 c=mix(colA,colB,p.x+0.4);\n    fragColor=vec4(vec3(c+(1.-col)),1.);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 120], [122, 122, 157, 157, 193], [195, 195, 221, 221, 242], [244, 244, 301, 301, 681]]}
{"id": "wsSGzG", "name": "Cloudy Julia Variante", "author": "aiekick", "description": "clcik and maintain for mandelbrot, release for julia", "tags": ["julia", "cloudy", "variante"], "likes": 6, "viewed": 367, "published": "Public API", "date": "1549136115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define lim 20.\n\nfloat shape(vec2 z)\n{\n\tfloat t = iTime;\n\tz *= mat2(cos(t),-sin(t),sin(t), cos(t));\n\t//float _dot = dot(z,z);\n\tfloat _quad = max(abs(z.x),abs(z.y));\n\tfloat _tri = max(abs(z.x)+z.y,-z.y);\n\treturn abs(mix(_quad, _tri, 0.5))+17.;\n}\n\nvoid mainImage( out vec4 f, vec2 z )\n{\n    f.xyz=iResolution;\n    z = (z+z-f.xy)/f.y;\n    vec2 g = z-z; // julia\n    \n    if (iMouse.z > 0.) g = z; // mandelbrot\n    \n   \tz -= g;\n    float it = 1.;\n    for (float i=0.;i<23.;i++)\n    {\t\n        z = mat2(z,-z.y,z.x) * z + g -\n    \t\t(iMouse.z>0. ? \n            \t vec2(0.5,0.) : // center mandelbrot\n            \t vec2(1,.3)); // julia\n        \n        if (shape(z) > lim)\n        {\n            it += i;\n            break;\n        }\n\t}\n \n\tfloat l = log(log(length(z))/log(sqrt(lim)))*0.8;\n\t\n\tf.rgb = cos(l+vec3(0.636,0.978,0.598)*\n                // use ceil if you wnat keep pink color\n                floor(it*(sin(iTime)*.5+.5))); \n    \n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 38, 38, 244], [246, 246, 284, 284, 936]]}
{"id": "wsSGzK", "name": "GLSL Workshop", "author": "lesleylai", "description": "GLSL workshop for the CU Computer Graphics Group", "tags": ["tutorial"], "likes": 0, "viewed": 100, "published": "Public", "date": "1549331225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TUTORIAL 12\n\n/**\n  * Lists\n  * 1. Hello world\n  * 2. The coordinate system\n  * 3. Step function\n  * 4. Line drawing\n  * 5. Smooth step function\n  * 6. Shapes: Rectangle\n  * 7. Color subtraction\n  * 8. Shapes: Circle\n  * 10: Transformation: Rotation\n  * 11: Rotation against arbitrary point\n  * 12: Some fun\n  */\n\n// Hello world\n#if TUTORIAL == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time varying pixel color\n    vec3 col = vec3(0., 0., 1.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// The coordinate system\n#if TUTORIAL == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0., 0., 1.);\n    if (uv.x < .2) {\n        col += vec3(0., 1., 0.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Step function\n#if TUTORIAL == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0., 0., 1.);\n    col += (1. - step(0.2, uv.x)) * vec3(0., 1., 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Line drawing\n#if TUTORIAL == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    col += (\n        step(fragCoord.x, fragCoord.y * 1.8) - (step(fragCoord.x, fragCoord.y * 1.8 - 5.))\n    )  * vec3(1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Smooth-step function\n#if TUTORIAL == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    col += (\n        smoothstep(fragCoord.x - 2., fragCoord.x + 2., fragCoord.y * 1.8)\n     - (smoothstep(fragCoord.x - 2., fragCoord.x + 2., fragCoord.y * 1.8 - 5.))\n    )  * vec3(1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Shapes: Rectangle\nfloat rectangle(vec2 start, vec2 end, vec2 coord) {\n    return smoothstep(start.x - 1., start.x + 1., coord.x)\n           * smoothstep(start.y - 1., start.y + 1., coord.y)\n           * (1. - smoothstep(end.x - 1., end.x + 1., coord.x))\n           * (1. - smoothstep(end.y - 1., end.y + 1., coord.y))\n        ;\n}\n\n#if TUTORIAL == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(1, 0.3, 0.3);\n    col += rectangle(vec2(100., 200.), vec2(200., 340.), fragCoord) * vec3(.0, .0, 1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n\n#if TUTORIAL == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(1, 0.3, 0.3);\n    float rect = rectangle(vec2(100., 200.), vec2(200., 340.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.0, .0, 1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Shapes: Circle\nfloat circle(float radius, vec2 center, vec2 coord) {\n    float distance2 = dot(center - coord, center - coord);\n    float radius2 = radius * radius;\n    return smoothstep(distance2, distance2*1.01, radius2);\n}\n\n#if TUTORIAL == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.3, 0.3, 1);\n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(100.);\n    float circle1 = circle(50., circle1_center, fragCoord);\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Transformation: Rotation\nmat2 rotate(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n#if TUTORIAL == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.3, 0.3, 1);\n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(100.);\n    circle1_center = rotate(iTime) * circle1_center;\n    float circle1 = circle(50., circle1_center, fragCoord);\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n// Rotation against arbitrary point\nvec2 rotate_against(vec2 center, vec2 pt, float angle){\n    pt -= center;\n    pt = rotate(angle) * pt;\n    pt += center;\n    return pt;\n}\n\n#if TUTORIAL == 11\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.3, 0.3, 1);\n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(0., 150.);\n    circle1_center = rotate_against(vec2(iResolution.x / 2., 130.), circle1_center, iTime);\n    float circle1 = circle(50., circle1_center, fragCoord);\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\nfloat sun(float radius, vec2 center, vec2 coord) {\n    float distance2 = dot(center - coord, center - coord);\n    float radius2 = radius * radius;\n    return smoothstep(distance2, distance2*2., radius2);\n}\n\n#if TUTORIAL == 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 skycolor = vec3(0.3, 0.3, 1)  * max(cos(iTime), 0.);\n    vec3 dawncolor = vec3(0.8, 0.3, 0.3) * abs(pow(sin(iTime), 3.));\n    vec3 nightcol = texture(iChannel0, uv).rgb * max(0., pow(1. - cos(iTime), 2.)) / 10.;\n    vec3 col = skycolor + dawncolor + nightcol;\n    \n    \n    vec2 circle1_center = iResolution.xy / 2. + vec2(0., 150.);\n    circle1_center = rotate_against(vec2(iResolution.x / 2., 130.), circle1_center, iTime);\n    float circle1 = sun(30., circle1_center, fragCoord);\n    circle1 *= abs(pow(sin(iTime), 3.));\n    col *= (1. - circle1) * vec3(1.);\n    col += circle1 * vec3(1., .3, 0.);\n    float circle2 = sun(32., circle1_center, fragCoord);\n    col += circle2 * vec3(1., 1., 1.);\n    \n    float rect = rectangle(vec2(0.), vec2(iResolution.x, 130.), fragCoord);\n    col *= (1. - rect) * vec3(1.);\n    col += rect * vec3(.6, 1., .3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\n#if TUTORIAL == 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2120, 2141, 2192, 2192, 2452], [3239, 3257, 3310, 3310, 3467], [4098, 4126, 4151, 4151, 4233], [4917, 4953, 5008, 5008, 5090], [5818, 5818, 5868, 5868, 6023]]}
{"id": "WsSGzV", "name": "Golfing Voxel Tunnel - 538 c", "author": "GregRostami", "description": "This is a quick golfing of the famous shader by lsdlive:\n[url]https://www.shadertoy.com/view/MscBRs[/url]\nPlease help me make this smaller ... Thank you.", "tags": ["golf"], "likes": 9, "viewed": 679, "published": "Public API", "date": "1549312093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 538 chars - Fabrice and coyote join FORCES to slay the BEAST by using SUPER clever math!\n// This version has contributions from adx and Greg.\n\n#define V vec3//\n#define S sin//\n#define P(v) v.xy += vec2(2, S(d = v.z*.2)) * S(d + 1.5)           //\nvoid mainImage(out vec4 o, vec2 U) {\n    V R=iResolution, O=R-R, X, Y=O, g=O, p=(U.xyy-R*.5)/R.y;\n    float d, T = Y.z = iTime*6.;\n    O.z = T-5.;\n    P(O); P(Y);\n    Y = p.xyx * V(-5, 5, Y-=O) - p.y * Y.y*Y/5. + Y;\n    Y.xy *= mat2( S( V(33,22,0).xyzx - .1*O.x ) );\n    R = sign(Y);\n    for ( p = round(O) ;\n          o.w++ < 99. && d > 0.;\n          p += X = R * step( X= (p-O +.5*R)/Y, min(X.yzx, X.zxy) )\n        )\n        X = p,\n        d = 5. - length( P(X)*-1. ),\n        X += S(X.z + T) * V( S(T), 1, 0 ),\n        X.z -= 6. + T,\n        d = min( d, dot(X,X) ),\n        g += .006 / (.01 + --d * d );\n    o.rgb = (  V( .2* S(T) + S(p.z*.5 - T), 0 , .5 )\n               - V(0,.3,1.5) * length(X/V(3,6,4)) + g\n            ) / exp( dot( p-=O, p ) /1e3 ) + .2; } /*\n\n\n// 599 chars - Fabrice added 6 chars (to initialize vars) but then removed 6 chars! #respect\n// 594 chars - Fabrice removed the mix from the final color calculation.\n// 591 chars - Code golfing legend, coyote, slays another 3 chars ...\n// 583 chars - Greg experiments with removing normalize()\n\n#define V vec3//\n#define S sin//\n#define P(v) v.xy += vec2(2, S(d = v.z*.2)) * S(d + 1.5)      //\n#define mainImage(o,U)                                        \\\n    V R=iResolution, O=R-R,X,Y=O,p, u=(U.xyy-R*.5)/R.y;       \\\n    float g=0., d, T = Y.z = iTime*6.;                        \\\n    O.z = T-5.;                                               \\\n    P(O); P(Y);                                               \\\n    Y = u.y/5. * cross( R = Y-O, X = V(5, 0, -R) )            \\\n       -u.x * X + R;                                          \\\n    Y.xy *= mat2( S( V(33,22,0).xyzx - .3* S(O.x / 3.) ) );   \\\n    p = round(O);                                             \\\n    R = sign(Y);                                              \\\n    for ( u = p-O + .5*R ; o.w++ < 99. && d > 0.; u += X )    \\\n        X = p,                                                \\\n        d = 4. - length( P(X)*-1. ),                          \\\n        X += S(X.z + T) * V( S(T), 1, 0 ),                    \\\n        X.z -= 6. + T,                                        \\\n        d = min( d, dot( X, sign(X)/1.7 ) - 1.),              \\\n        g += .006 / (.01 + d * d ),                           \\\n        p += X = R * step( X= u/Y, min(X.yzx, X.zxy) );       \\\n    o.rgb = V( .2, .1, .2 ) +                                 \\\n            (  V( .2* S(T) + S(p.z*.5 - T), .1 , .5 )         \\\n               - V(0,.3,1.5) * length(X/V(3,6,4)) + g         \\\n            )/  exp( dot( p-=O, p ) /1e3 )\n\n        \n\n// 601 chars\n\n#define V vec3//\n#define S sin//\n#define P(v) v.xy += vec2(2, S(d = v.z*n)) * S(d + 1.5)//\n#define mainImage(o,U)                                                \\\n    float g=0., d, T, n=.2;                                           \\\n    V O,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y;\t                  \\\n    Y.z = T = iTime * 6.;                                             \\\n    O.z = T-5.;                                                       \\\n    P(O);                                                             \\\n    P(Y);                                                             \\\n    Y = u.y*-cross(R=normalize(Y - O),                                \\\n                   X=V(-R.z, 0, R.x))+R + u.x*X;                      \\\n    Y.xy *= mat2( S(S(-O.x / 3.14)*.3 + vec4(33,0,0,55)) );           \\\n    p = round(O);                               \t                  \\\n    R = sign(Y);                                                      \\\n    for ( u = ( p - O + .5*R ) / Y ; o.w++ < 99. && d > 0.; u += X/Y )\\\n        X = p,\t\t\t\t\t\t\t\t\t\t                  \\\n        d = 4.-length(P(X) * -1.),                                    \\\n        X += S(X.z + T) * V(S(T),1,0),\t\t\t                      \\\n        X.z -= 6. + T,\t\t\t\t\t\t\t\t                  \\\n        d = min(d, dot(X, sign(X)/1.7) - 1.),                         \\\n        g += .006 / (.01 + d * d),\t\t\t\t\t                  \\\n        p += X = R * step(u, min(u.yzx, u.zxy));                      \\\n    o.rgb = mix( V(n,.1,n), V(n+S(T)*n + S(p.z*.5 - T),n,.7) - V(0,.3,1.5) * length(X/V(3,6,4)) + g  \\\n                , exp(-dot(p-=O, p)/1e3) )\n\n\n\n// 615 chars - This is almost HALF the size of the original shader!!\n\n#define V vec3//\n#define P(v) v.xy += vec2(2, sin(d = v.z*n)) * sin(d + 1.5)//\n#define mainImage(o,U)                                                \\\n    float g=0., d, T, n=.2;                                           \\\n    V O,A,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y;\t                  \\\n    A.z = T = iTime * 6.;                                             \\\n    O.z = T-5.;                                                       \\\n    P(O);                                                             \\\n    P(A);                                                             \\\n    Y = u.y*-cross(R=normalize(A - O),                                \\\n                   X=V(-R.z, 0, R.x))+R + u.x*X;                      \\\n    Y.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );       \\\n    p = round(O);                               \t                  \\\n    R = sign(Y);                                                      \\\n    for ( u = ( p - O + .5*R ) / Y ; o.w++ < 99. && d > 0.; u += X/Y )\\\n        X = p,\t\t\t\t\t\t\t\t\t\t                  \\\n        d = 4.-length(P(X) * -1.),                                    \\\n        X += cos(X.z + T) * V(sin(T),1,0),\t\t\t                  \\\n        X.z -= 6. + T,\t\t\t\t\t\t\t\t                  \\\n        d = min(d, dot(X, sign(X)/1.7) - 1.),                         \\\n        g += .006 / (.01 + d * d),\t\t\t\t\t                  \\\n        p += X = R * step(u, min(u.yzx, u.zxy));                      \\\n    A = V(n,n,.7) - V(0,.3,1.5) * length(X/V(3,6,4)) + g;             \\\n    A.r += sin(T)*n + sin(p.z*.5 - T);                                \\\n    o.rgb = mix( V(n,.1,n), A, exp(-dot(p-=O, p)/1e3) )\n\n\n\n// 625 chars - Fabrice and adx shaved many more chars\n\n#define V vec3\n#define P(v) v.xy += vec2(2, sin(d = v.z*.2)) * sin(d + 1.5)\nfloat g=0., d, T;\n\n#define mainImage(o,U)                                               \\\n\tV O,A,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y;\t                 \\\n\tA.z = T = iTime * 6.;                                            \\\n\tO.z = T-5.;                                                      \\\n\tP(O);                                                            \\\n\tP(A);                                                            \\\n\tY = u.y*-cross(R=normalize(A - O), X=V(-R.z, 0, R.x))+R + u.x*X; \\\n\tY.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );      \\\n\tp = round(O);                               \t                 \\\n\tR = sign(Y);                                                     \\\n\tu = R/Y * (R * (p - O) + .5);                                    \\\n\tfor (;o.w++ < 99. && d > 0.;)\t\t\t\t\t                 \\\n\t\tX = p,\t\t\t\t\t\t\t\t\t\t                 \\\n\t\td = 4.-length(P(X) * -1.),\t\t\t\t\t                 \\\n\t\tX += cos(X.z + T) * V(sin(T),1,0),\t\t\t                 \\\n\t\tX.z -= 6. + T,\t\t\t\t\t\t\t\t                 \\\n\t\td = min(d, dot(X, sign(X)/1.73) - 1.),\t\t                 \\\n\t\tg += .006 / (.01 + d * d),\t\t\t\t\t                 \\\n\t\tp += X = R * step(u, min(u.yzx, u.zxy)),                     \\\n\t\tu += X/Y;                         \t\t                     \\\n\tA = (V(2, 2, 7) - V(0, 3, 15) * length(X / V(3, 6, 4)))*.1 + g;  \\\n\tA.r += sin(T)*.2 + sin(p.z*.5 - T);             \\\n\to.rgb = mix(V(.2, .1, .2), A, exp(-dot(p-=O, p)/1e3))\n\n\n\n// 669 chars - adx and BigWIngs are on a ROLL ... \n\n#define V vec3\n#define P(v) v.xy += sin(v.z*.2 + 1.5) * vec2(2,sin(v.z*.2))\nfloat g = 0., B, d, T;\n\nfloat D(V p) {\n\tP(p) * -1.;\n\td = 4.-length(p.xy);\n\tp.xy += cos(p.z + T) * vec2(sin(T),1);\n\tp.z -= 6. + B;\n\td = min(d, dot(p, sign(p)/1.73) - 1.);\n\tg += .006 / (.01 + d * d);\n\treturn d;\n}\n\n#define mainImage(o,U)                              \\\n\tV O,A,X,Y,p, R=iResolution, u=(U.xyy-R*.5)/R.y; \\\n\tA.z = B = T = iTime*6.;                         \\\n\tO.z = B-5.;                                     \\\n\tP(O);                                           \\\n\tP(A);                                           \\\n\tR = normalize(A - O);                           \\\n\tX = V(-R.z, 0, R.x);                            \\\n\tY = R + u.x*X + u.y*cross(X, R);                \\\n\tY.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );  \\\n\tp = ceil(O) - .5;                               \\\n\tR = sign(Y);                                    \\\n\tu = R/Y * (R * (p - O) + .5);                   \\\n\twhile (o.w++ < 99. && D(p) > 0.)                \\\n        p += X = R * step(u, min(u.yzx, u.zxy)),    \\\n\t\tu += X/Y;                         \t\t    \\\n\tA = (V(2, 2, 7) - V(0, 1, 5) * length(X * V(1, .5, .8)))*.1 + g;  \\\n\tA.r += sin(T)*.2 + sin(p.z*.5 - B);             \\\n\to.rgb = mix(V(.2, .1, .2), A, exp(-dot(p-=O, p)/1e3))\n\n\n        \n// 700 chars - BigWIngs and adx squashed a LOT of chars\n\n#define V vec3\n#define P(v) v.xy += sin(v.z*.2 + 1.5) * vec2(2,sin(v.z*.2))\nfloat g = 0., B, d, T;\n\nfloat D(V p) {\n\tP(p) * -1.;\n\td = 4.-length(p.xy);\n\tp.xy += cos(p.z + T) * vec2(sin(T),1);\n\tp.z -= 6. + B;\n\td = min(d, dot(p, sign(p)/1.73) - 1.);\n\tg += .006 / (.01 + d * d);\n\treturn d;\n}\n\n#define mainImage(o,U)                          \\\n\tV O,A,F,X,Y,p,M,Z,S,c;                      \\\n\tvec2 R = iResolution.xy, u = (U-R*.5)/R.y;  \\\n\tT = iTime;                                  \\\n\tA.z = B = T*6.;                             \\\n\tO.z = B-5.;                                 \\\n\tP(O);                                       \\\n\tP(A);                                       \\\n\tF = normalize(A - O);                       \\\n\tX = V(-F.z, 0, F.x);                        \\\n\tY = F + u.x*X + u.y*cross(X, F);            \\\n\tY.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );  \\\n\tp = floor(O) + .5;                          \\\n\tZ = Y;                                      \\\n\tY = sign(Y);                                \\\n\tS = Y/Z * (Y * (p - O) + .5);               \\\n\tfor (int i; ++i < 99 && D(p) > 0.;)         \\\n\t\tM = step(S, min(S.yzx, S.zxy)),          \\\n\t\tS += Y/Z * M,                           \\\n\t\tp += Y * M;                             \\\n\tc = (V(2, 2, 7) - V(0, 1, 5) * length(M * V(1, .5, .75)))*.1 + g;  \\\n\tc.r += sin(T)*.2 + sin(p.z*.5 - B);         \\\n\to.rgb = mix(V(.2, .1, .2), c, exp(-dot(p-=O, p)/1e3))\n\n        \n\n// 773 chars - Greg Rostami's original golfed version\n\n#define T iTime\n#define P(t) sin(t*.2 + 1.5) * vec2(2,sin(t*.2))\nfloat g = 0., B, d;\n\nfloat D(vec3 p) {\n\tp.xy -= P(p.z);\n\td = 4.-length(p.xy);\n\tp.xy += cos(p.z + T) * vec2(sin(T),1);\n\tp.z -= 6. + B;\n\td = min(d, dot(p, normalize(sign(p))) - 1.);\n\tg += .015 / (.01 + d * d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 o,vec2 U){\n    vec3 O,A,F,X,Y,p,M,Z,S,c;\n\tvec2 R = iResolution.xy, u = .5*(U+U-R)/R.y;\n    \n         A.z = B = T*6.;\n\t     O.z = B-5.;\n\t     \n\t     O.xy += P(O.z);\n\t     A.xy += P(A.z);\n    \n\t     X = cross(F = normalize(A - O), vec3(0, 1, 0));\n\t     Y = F + u.x*X + u.y*cross(X, F);\n\t     Y.xy *= mat2( cos(sin(-O.x / 3.14)*.3 + vec4(0,33,55,0)) );\n\t     p = floor(O) + .5;\n\t     Z = 1. / abs(Y);\n\t     Y = sign(Y);\n\t     S = Z * (Y * (p - O) + .5);\n\t\n\tfor (int i; ++i < 99;) {\n\t\tif (D(p) < 0.) break;\n\t\tM = step(S, S.yzx) * step(S, S.zxy);\n\t\tS += Z * M;\n\t\tp += Y * M;\n\t}\n\tc = mix(vec3(.2, .2, .7), vec3(.2, .1, .2), length(M * vec3(1, .5, .75))) + g * .4;\n\tc.r += sin(T)*.2 + sin(p.z*.5 - B);\n\to.rgb = mix(c, vec3(.2, .1, .2), 1. - exp(-dot(p-O, p-O)/1e3));\n}\n\n\n\n// 1169 chars - Original shader:\n\n// @lsdlive\n\n// This was my shader for the shader showdown at Outline demoparty 2018 in Nederland.\n// Shader showdown is a live-coding competition where two participants are\n// facing each other during 25 minutes.\n// (Round 1)\n\n// I don't have access to the code I typed at the event, so it might be\n// slightly different.\n\n// Original algorithm on shadertoy from fb39ca4: https://www.shadertoy.com/view/4dX3zl\n// I used the implementation from shane: https://www.shadertoy.com/view/MdVSDh\n\n// Thanks to shadertoy community & shader showdown paris.\n\n// This is under CC-BY-NC-SA (shadertoy default licence)\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(2.*a, a*b);\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\tp.xy -= path(p.z);\n\n\tfloat d = -length(p.xy) + 4.;// tunnel (inverted cylinder)\n\n\tp.xy += vec2(cos(p.z + iTime)*sin(iTime), cos(p.z + iTime));\n\tp.z -= 6. + iTime * 6.;\n\td = min(d, dot(p, normalize(sign(p))) - 1.); // octahedron (LJ's formula)\n\t// I added this in the last 1-2 minutes, but I'm not sure if I like it actually!\n\n\t// Trick inspired by balkhan's shadertoys.\n\t// Usually, in raymarch shaders it gives a glow effect,\n\t// here, it gives a colors patchwork & transparent voxels effects.\n\tg += .015 / (.01 + d * d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat dt = iTime * 6.;\n\tvec3 ro = vec3(0, 0, -5. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = cross(fwd, vec3(0, 1, 0));\n\tvec3 up = cross(right, fwd);\n\tvec3 rd = normalize(fwd + uv.x*right + uv.y*up);\n\n\trd.xy *= r2d(sin(-ro.x / 3.14)*.3);\n\n\t// Raycast in 3d to get voxels.\n\t// Algorithm fully explained here in 2D (just look at dde algo):\n\t// http://lodev.org/cgtutor/raycasting.html\n\t// Basically, tracing a ray in a 3d grid space, and looking for \n\t// each voxel (think pixel with a third dimension) traversed by the ray.\n\tvec3 p = floor(ro) + .5;\n\tvec3 mask;\n\tvec3 drd = 1. / abs(rd);\n\trd = sign(rd);\n\tvec3 side = drd * (rd * (p - ro) + .5);\n\n\tfloat t = 0., ri = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\n\t\tif (de(p) < 0.) break;// distance field\n\t\t\t\t\t\t\t  // we test if we are inside the surface\n\n\t\tmask = step(side, side.yzx) * step(side, side.zxy);\n\t\t// minimum value between x,y,z, output 0 or 1\n\n\t\tside += drd * mask;\n\t\tp += rd * mask;\n\t}\n\tt = length(p - ro);\n\n\tvec3 c = vec3(1) * length(mask * vec3(1., .5, .75));\n\tc = mix(vec3(.2, .2, .7), vec3(.2, .1, .2), c);\n\tc += g * .4;\n\tc.r += sin(iTime)*.2 + sin(p.z*.5 - iTime * 6.);// red rings\n\tc = mix(c, vec3(.2, .1, .2), 1. - exp(-.001*t*t));// fog\n\n\tfragColor = vec4(c, 1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 249, 285, 285, 1013]]}
{"id": "wssSR7", "name": "Alien Digestion", "author": "cbrpnk", "description": "Everyday", "tags": ["raymarching"], "likes": 4, "viewed": 100, "published": "Public", "date": "1550971546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdfBox(vec3 p, vec3 d)\n{\n    p = abs(p) - d;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sdfTorus(vec3 p, float r, float w)\n{\n    return sqrt(pow(length(p.xz)-r, 2.) + pow(p.y, 2.)) - w;\n}\n\nfloat sdfCap(vec3 p, float r, float l)\n{\n    return length(p - vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat field(vec3 p)\n{\n    \n    p.xz *= rot(iTime*.1);\n    p.yz *= rot(-.7);\n    p.xz *= rot(dot(p, normalize(vec3(1., 5., -1.)))*.02);\n    p.xz = mod(p.xz+vec2(4.), 8.)-vec2(4.);\n    p.y += sin(iTime)*.5+.5;\n    p.xz *= sin(iTime+p.y)*.01*length(p)+1.;\n    \n    p.x += sin(p.y+iTime*2.)*.2;\n    p.y += iTime*.5;\n    p.xz /= abs(sin(p.y-iTime))*1.1+.3;\n    p.y = mod(p.y+.5, 1.)-.5;\n    \n    \n    float c = sdfCap(p, .65, 1.);\n    float s = sdfSphere(p, .79);\n    float s2 = sdfSphere(p, .75);\n    float s3 = sdfSphere(abs(p)-vec3(0, 1., 0), .8);\n    float t = sdfTorus(p, .9, .35);\n    float c2 = sdfCap(p, .5, 1.);\n    vec3 pp = abs(p.xzy);\n    pp.xy *= rot(.75);\n    float t2 = sdfTorus(pp-vec3(.8, 0., 0.), .3, .1);\n    pp.xy *= rot(-.5);\n    float t3 = sdfTorus(pp-vec3(.8, 0., 0.), .3, .1);\n    pp.xy *= rot(1.05);\n    float t4 = sdfTorus(pp-vec3(.8, 0., 0.), .3, .1);\n    float b = sdfBox(p, vec3(.6));\n    return max(max(max(max(max(max(max(min(max(c, s), s2), -s3), -t), -c2), -t2), -t3), -t4), b)*.2;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<228; ++i) {\n    \tfloat d = field(ro+rd*t);\n        if(d < .001) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.1, 0.);\n    return normalize(vec3(\n    \tfield(p+eps.xyy) - field(p-eps.xyy),\n        field(p+eps.yxy) - field(p-eps.yxy),\n        field(p+eps.yyx) - field(p-eps.yyx)\n    ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    // Time varying pixel color\n    vec3 cam = vec3(0, 0, 4);\n    vec3 dir = normalize(vec3(uv, -1));\n    float d = march(cam, dir);\n    vec3 p = cam+dir*d;\n    vec3 col = vec3(0., .1, .2);\n    \n    if(d < 50.) {\n    \tvec3 normal = getNormal(p);\n    \tcol = vec3(.5, .2, .1) * max(0., dot(normal,  normalize(vec3(1.))));\n        col += vec3(.1, .4, .1) * max(0., dot(normal,  normalize(vec3(-1., .1, -1.))));\n        col *= vec3(.3, .7, .1) * (1.-pow(max(0., dot(normal, -dir)), 1.));\n        col *= 2.+.5;\n    }\n    col = pow(col, vec3(.8)) + .03;\n    col *= vec3(.3, .6, .5) * 1.-(d/50.);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 127, 127, 185], [187, 187, 229, 229, 292], [294, 294, 334, 334, 396], [398, 398, 432, 432, 460], [462, 462, 483, 483, 1473], [1475, 1475, 1506, 1506, 1652], [1654, 1654, 1678, 1678, 1880], [1882, 1882, 1939, 1989, 2704]]}
{"id": "wssSRH", "name": "Experimenting with scalar fields", "author": "hackpoetic", "description": "Yesterday I learned about scalar fields. Today I realized I already knew them from ray marching (sign distance fields) and that in that context I'm just deciding what slice of the field to display. It opened my eyes and now my brain looks like this.", "tags": ["scalarfields"], "likes": 1, "viewed": 103, "published": "Public", "date": "1550639542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fun-alike license - have as much fun freely using/modifying/distributing this as I did.\n// https://www.instagram.com/hackpoetic\n\n\n// 2 * PI. The arc cosine of -1 is PI\n#define TAU (2. * acos(-1.))\n\n#define TIME (iTime / 2.)\n//#define TIME 0.53\n\n// Found this scalar field on wikipedia.\n// It's attractive because it oscilates between values across space and through time! \nfloat field(vec2 p) {\n    p *= 2.; return sin(TAU * (p.x * p.y + TIME));\n}\n\n// This function gives a nice combination of positive and negative values\n// as t increases. Fun fact, add a third component \"t\" and this is\n// a helix!\nvec2 circle(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    fragColor.rgb = vec3(0);\n    for (float i = 0.; i < 100.; i++) {\n        // alternate between color channels, offseting the field a bit each time\n        // this offset is proportional to i and scaled down a bit\n        fragColor[int(i) % 3] += field(uv + circle(i) * i * 0.01);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 376, 397, 397, 450], [452, 605, 627, 627, 662], [664, 664, 721, 721, 1078]]}
{"id": "wssSWH", "name": "Hue colour wheel", "author": "Chosen", "description": "Mouse x position: Spin rate/position\n1 Key: Gamma correction on/off\n2 Key: Gamma correction method\n3 Key: Spin manually\n4 Key: Hue→RGB method\n5 key: Hide state text\n\nTake it for a spin! huehuehue", "tags": ["colours"], "likes": 1, "viewed": 170, "published": "Public", "date": "1551212454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMouse x position: Spin/position\n1 key: Gamma correction on/off\n2 key: Gamma correction method\n3 key: Spin manually\n4 key: Hue→RGB method\n5 key: Hide state text\n*/\n#define KEY(k) (48 + k)\n\nbool keyToggle(int keycode)\n{\n    return texture(iChannel0,vec2((.5+float(keycode))/256.,0.75)).x > 0.;\n}\n\nvec3 hueToRGB(float hue)\n{\n    // https://www.shadertoy.com/view/ll2cDc\n    // Neither seems very close, could it be tweaked to be better?\n\tvec3 altRGB = //vec3(.5 * cos(6.3 * hue + vec4(0,23,21,0)));\n\t\tvec3(.6 + .6 * cos(6.3 * hue + vec4(0,23,21,0)));\n\n    return mix(clamp(abs(fract(hue + vec3(1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.),\n               altRGB, float(keyToggle(KEY(4))));\n}\n\n#define TEXT_GAMMA 0, 6\n#define TEXT_HUE 6, 10\n#define TEXT_APPROXIMATE 10, 21\n#define TEXT_ACCURATE 21, 29\n#define TEXT_OFF 29, 32\n#define KERN .46\n\nconst int[32] text = int[32](\n        71, 97, 109, 109, 97, 58, // Gamma:\n        72, 117, 101, 58, // Hue:\n        65, 112, 112, 114, 111, 120, 105, 109, 97, 116, // Approximate\n        101, 65, 99, 99, 117, 114, 97, 116, 101, // Accurate\n        79, 102, 102 // Off\n    );\nfloat writeText(out vec2 uv, int start, int end, float cond)\n{\n\n    float o = 0.;\n    vec2 p = uv;\n    \n    for(int i = start; i != end; ++i, p.x -= KERN){\n        o += float(fract(p) == p) * cond *\n            // https://www.shadertoy.com/view/ltcXzs\n            textureGrad(iChannel1, p/16. + fract(vec2(text[i], 15-text[i]/16) / 16.),\n                        dFdx(p/16.), dFdy(p/16.)).x;\n    }\n    uv = mix(uv, p, cond);\n    return o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 polarCoord = fragCoord - .5*iResolution.xy;\n    float theta = atan(polarCoord.y, polarCoord.x) / 6.283185;\n    \n\t// Spin it\n    theta += (float(!keyToggle(KEY(3))) * 10. * iTime + 10.)\n        * (.5 - iMouse.x / iResolution.x);\n    \n    vec3 col = hueToRGB(fract(theta));\n    col = mix(col, mix(sqrt(col),\n                       //pow(col, vec3(1./2.2)),\n                       // https://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\n                       1.055 * pow(col, vec3(0.416667)) - 0.055,\n                       float(keyToggle(KEY(2)))),\n              float(!keyToggle(KEY(1))));\n\n    float text = 0.;\n    vec2 uv = 20. * fragCoord / iResolution.y;\n\n    text += writeText(uv, TEXT_GAMMA, 1.)\n        + writeText(uv, TEXT_OFF, float(keyToggle(KEY(1))))\n        + writeText(uv, TEXT_APPROXIMATE, float(!keyToggle(KEY(1)) && !keyToggle(KEY(2))))\n        + writeText(uv, TEXT_ACCURATE, float(!keyToggle(KEY(1)) && keyToggle(KEY(2))));\n    uv.x -= 1.;\n    text += writeText(uv, TEXT_HUE, 1.)\n        + writeText(uv, TEXT_APPROXIMATE, float(keyToggle(KEY(4))))\n        + writeText(uv, TEXT_ACCURATE, float(!keyToggle(KEY(4))));\n    col = mix(col, vec3(0), smoothstep(0., 1., text * clamp(.2*iTime, 0., float(!keyToggle(KEY(5))))));\n//    col = mix(col, vec3(0), smoothstep(0., text, clamp(1. - iTime * .2, .25, text)));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 193, 222, 222, 298], [300, 300, 326, 438, 692], [1119, 1119, 1181, 1181, 1558], [1560, 1560, 1615, 1615, 3002]]}
{"id": "WssSz8", "name": "sun surface", "author": "Fab48", "description": "based on https://www.shadertoy.com/view/4sBfDw  by zaiyugi \n", "tags": ["sun"], "likes": 8, "viewed": 378, "published": "Public", "date": "1550656373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Based on : https://www.shadertoy.com/view/4sBfDw\n\n\n/*\nZachary Shore\nDPA8090: Rendering and Shading\nHW2: Fractal Brownian Motion\n*/\n\n#define M_PI 3.14159265359\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = \n        permute\n        (\n            permute\n            ( \n                permute\n                (\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0)\n                )\n                + i.y + vec4(0.0, i1.y, i2.y, 1.0 )\n            )\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 )\n        );\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\n// p: position\n// o: how many layers\n// f: frequency\n// lac: how fast frequency changes between layers\n// r: how fast amplitude changes between layers\nfloat fbm4(vec3 p, float theta, float f, float lac, float r)\n{\n    mat3 mtx = mat3(\n        cos(theta), -sin(theta), 0.0,\n        sin(theta), cos(theta), 0.0,\n        0.0, 0.0, 1.0);\n\n    float frequency = f;\n    float lacunarity = lac;\n    float roughness = r;\n    float amp = 1.0;\n    float total_amp = 0.0;\n\n    float accum = 0.0;\n    vec3 X = p * frequency;\n    for(int i = 0; i < 4; i++)\n    {\n        accum += amp * snoise(X);\n        X *= (lacunarity + (snoise(X) + 0.1) * 0.006);\n        X = mtx * X;\n\n        total_amp += amp;\n        amp *= roughness;\n    }\n\n    return accum / total_amp;\n}\n\n\nfloat turbulence(float val)\n{\n    float n = 1.0 - abs(val);\n    return n * n;\n}\n\nfloat pattern(in vec3 p, inout vec3 q, inout vec3 r)\n{\n    q.x = fbm4( p + 0.0, 0.0, 1.0, 2.0, 0.33 );\n    q.y = fbm4( p + 6.0, 0.0, 1.0, 2.0, 0.33 );\n\n    r.x = fbm4( p + q - 2.4, 2.0, 1.0, 2.0, 0.5 );\n    r.y = fbm4( p + q + 8.2, 02.0, 1.0, 2.0, 0.5 );\n\n    q.x = turbulence( q.x );\n    q.y = turbulence( q.y );\n\n    float f = fbm4( p + (1.0 * r), 0.0, 1.0, 2.0, 0.5);\n\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    st.x *= aspect;\n\n    vec2 uv = st;\n\n    float t = iTime * 0.1;\n\n    vec3 spectrum[4];\n    spectrum[0] = vec3(1.00, 1.00, 0.00);\n    spectrum[1] = vec3(0.50, 0.00, 0.00);\n    spectrum[2] = vec3(1.00, 0.40, 0.20);\n    spectrum[3] = vec3(1.00, 0.60, 0.00);\n\n    uv -= 0.5;\n    uv-=10.*iMouse.xy/ iResolution.xy;\n    uv *= 30.;\n\n    vec3 p = vec3(uv.x, uv.y, t);\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tvec3 brigth_q = vec3(0.0);\n    vec3 brigth_r = vec3(0.0);\n\tvec3 black_q = vec3(0.0);\n    vec3 black_r = vec3(0.0);\n\tvec3 p2=vec3(p.xy*0.02,p.z*0.1);\n    \n    float black= pattern(p2 ,black_q ,black_r );\n    black = smoothstep(0.9,0.1,length(black_q*black));\n           \n    float brigth= pattern( p2*2.,brigth_q ,brigth_r );\n    brigth = smoothstep(0.0,0.8,brigth*length(brigth_q));\n\n    p+=min(length(brigth_q) ,length(black_q)  )*5.;\n\n    float f = pattern(p, q, r);\n\n    vec3 color = vec3(0.0);\n    color = mix(spectrum[1], spectrum[3], pow(length(q), 2.0));\n    color = mix(color, spectrum[3], pow(length(r), 1.4));\n\n    color = pow(color, vec3(2.0));\n\n    fragColor =vec4( pow(black,2.)*(color +  spectrum[2]*brigth*5.), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 609, 630, 630, 681], [683, 683, 704, 704, 755], [757, 757, 779, 779, 818], [820, 820, 848, 848, 902], [904, 904, 926, 926, 3283], [3285, 3436, 3498, 3498, 4036], [4039, 4039, 4068, 4068, 4118], [4120, 4120, 4174, 4174, 4507], [4509, 4509, 4566, 4566, 5808]]}
{"id": "wssSzr", "name": "Particles study", "author": "murchanskii", "description": "I was looking at particle implementations and found an incredible simple function by laserdog: https://www.shadertoy.com/view/MsGBz3\nI am looking forward to experiment with it, so this is just the beginning :)", "tags": ["particles", "rainbow"], "likes": 2, "viewed": 148, "published": "Public", "date": "1550525268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 particleColor(vec2 uv, vec2 pos, float radius, vec3 color) {\n\tfloat dist = radius / distance(uv, pos);\n    return color * pow(dist, 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    \n    vec4 col = vec4(vec3(0.0), 1.0);\n    \n    vec3 lut = vec3(1.0);\n    \n    float n_particles = 126.0;\n    for (float i = 0.0; i < n_particles; ++i) {\n        float t =  i * 0.05;\n    \tvec2 pos = vec2(16.0 * pow(sin(t), 3.0), \n                        13.0 * cos(t) - 5.0 * cos(2.0 * t) - 2.0 * cos(3.0 * t) - cos(4.0 * t));//pow((y * y + x * x - 1.0), 3.0) - x * x * y * y * y);\n        pos *= 0.06;\n        pos.y *= 1.1;\n        pos.y += 0.15;\n        lut = vec3(abs(sin(t + 3.0 * 3.1415 / 4.0)), \n               abs(sin(t)), abs(cos(t)));\n        \n        col.rgb += particleColor(uv, \n                                 pos, \n                                 0.02 * (0.5 + abs(sin(4.0*iTime * 0.2)*0.5)),// * (n_particles - i), \n                                 lut);\n    }\n        \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 144], [146, 146, 203, 203, 1092]]}
{"id": "wssXzM", "name": "RAYMARCH", "author": "Teppar", "description": "a simple raymarch effect", "tags": ["raymarch"], "likes": 2, "viewed": 387, "published": "Public", "date": "1550942222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n    vec3 q = fract(p) *2.0 - 1.0;\n      \n    return length(q) - 0.25;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n float t = 0.0;\n    for(int i = 0; i < 32; i++)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n        \n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0,iTime,iTime);\n    \n    float t = trace(o,r);\n    \n    vec3 c = vec3(sin(1.0*iTime)+1.5,sin(1.0*iTime)+1.5*0.5,0.01);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n\n    vec3 col = vec3(fog);\n\n    // Output to screen\n    fragColor = vec4(col*c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 91], [93, 93, 122, 122, 283], [286, 286, 343, 393, 928]]}
{"id": "wssXzn", "name": "3d julia fog", "author": "pde", "description": "This is a 3d ray-marched view of the Julia set; move the mouse around to explore.\nIt could probably be sped up considerably with non-uniform ray step sizes...", "tags": ["raymarching", "juliaset"], "likes": 2, "viewed": 82, "published": "Public", "date": "1550515938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmult(vec2 a, vec2 b)\n{\n\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 spacify(vec2 p)\n{\n    return ( p - .5 * iResolution.xy ) / iResolution.y;\n}\n\n\n\nint julia(in vec2 z0, in vec2 c)\n{\n    vec2 z = z0;\n    if (length(z) > 4.0)\n        return 0;\n    for (int n=0; n <12; n++) {\n        z = cmult(z,z) +c;\n\n        if (length(z) > 4.0) return n;\n    }\n    return -1;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // start at 0,0,z=3, shoot a ray at the plane z=1\n    //vec3 camera = vec3(0.2*sin(iTime/2.3),0.2*cos(iTime/18.8),4.0);\n    vec3 camera = vec3(0,0,4.0);\n    vec2 xy = spacify(fragCoord);\n    vec3 coord = vec3(xy.x, xy.y, 3.0);\n    vec3 ray = coord - camera;\n    \n    vec2 mouse_xy=spacify(iMouse.xy);\n    mat3 rot = rotationMatrix(vec3(mouse_xy.y, mouse_xy.x, 0.0),1.5*length(mouse_xy));\n    \n    camera = camera*rot;\n    ray = ray*rot;\n    \n    float col =0.0;\n    float core = 0.0;\n    float steps = 50.0;\n    float z2 = sin(iTime/7.0);\n    vec3 pos; int inc;\n    for (float n=0.0; n<steps; n+=0.025) {\n        pos = camera + n*ray;\n        inc = julia(vec2(pos.x, pos.y), vec2(pos.z,z2));\n        \n        if (inc < 0)\n            // collisions with the core of the julia set\n            core += 1.0;\n        else {\n            // collisions with the halo\n            col+= float(inc);\n\n        }\n    }\n    float scale = 10.24 * steps, g=4.0*scale, b=2.0*scale;\n    float pen = core / 10.0;\n\n    fragColor = vec4(col/scale - pen, abs(sin(col/scale))-(pen/5.0), col/b - (pen/3.0), 0.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 64], [66, 66, 88, 88, 146], [150, 150, 184, 184, 366], [369, 369, 414, 414, 897], [899, 899, 954, 1078, 2050]]}
{"id": "wssXzr", "name": "Metal Vortex", "author": "BackwardsCap", "description": "Traveling into a vortex of metal", "tags": ["raymarching", "backwardscap", "cineshader"], "likes": 7, "viewed": 9096, "published": "Public API", "date": "1550593204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SURF_DIST 0.001\n#define MAX_STEPS 256\n#define MAX_STEPS_REF 32\n#define MAX_STEPS_SHAD 16\n#define AA 2\n\nint mat;\nvec3 ref = vec3(0.);\n\nvec2 rotate(vec2 a, float d){\n    float s  = sin(d);\n    float c = cos(d);\n    \n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c);\n}\n\nfloat noise(vec3 p){\n    \n    return fract(sin(dot(p,vec3(41932.238945,12398.5387294,18924.178293)))*123890.12893);\n    \n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    \n    vec3 d = abs(p)-b;\n    \n    return max(max(d.x,d.y),d.z);\n    \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    \n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nvec3 opTwist(in vec3 p , float k)\n{\n   \n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    \n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexScrew( vec3 p, vec2 h , float t)\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(opTwist(p,t));\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    \n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cog(vec3 p, vec3 tp ){\n    \n    float d = 1e10;\n    \n     vec3 bp = p+vec3(0,0,0);\n    bp.xy=rotate(bp.xy,sin(-iTime-tp.z*.05-p.x*.01)*10.);\n    \n    \n    float base = sdHexPrism(bp,vec2(2.,.2));\n    \n    d=min(d,base);\n    \n\n    bp.zy=rotate(bp.zy,1.5);\n    float base2 = sdHexScrew(bp,vec2(.95,1),2.0);\n    \n    d=max(d,-base2);\n\n    return d;\n\n}\n\n\nfloat map(vec3 p){\n    vec3 tp =p;\n    p.xy = rotate(p.xy,p.z*.02);\n    vec3 cell = vec3(5,40.5,21.5);\n    p=mod(p,cell)-cell*.5;    \n    \n    vec3 cp = p;\n    \n    \n    float s = sin(iTime+tp.z*.05)*10.;\n    \n    cp.z+=s;\n    \n    float d = 1e10;\n    \n\tfloat cog = cog(cp,tp);\n   \td=min(d,cog);\n\n    p.zy=rotate(p.zy,1.57);\n    float screw = sdHexScrew(p,vec2(.85,11.),2.0);\n    d=min(d,screw);\n    \n\n    \n    //assigning our material based on our distance value\n    if(d==cog){\n     \tmat=1;   \n    }\n\telse if(d==screw){\n        mat=3;\n    }\n    return d;\n}\n\n\nvec3 calcNormal(vec3 p){\n    \n    vec2 e =vec2(.01,0.);\n    \n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n    \n}\n\nvec4 trace(in vec3 ro, in vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.9);\n    float k = 0.;\n    \n    for(int i=0;i<MAX_STEPS;++i){\n        k=map(ro+rd*t);\n        t+=k*.5;\n        if(abs(k)<SURF_DIST){\n           \n            \n            if(mat==1)\n                col = vec3(0.5);\n            else if(mat==3)\n                col=vec3(.8);\n                else if(mat==2){\n                    col=vec3(1.0);\n                }\n\t\t\t\n            //col*=light;\n                \n\t\t\tbreak;\n        }\n    }\n    \n    \n    return vec4(t,col);\n    \n}\n\nvec4 traceRef(in vec3 ro, in vec3 rd, float start, float end){\n    \n    float t=0.;\n    vec3 col = vec3(0.9);\n    float k = 0.;\n    \n    for(int i=0;i<MAX_STEPS_REF;++i){\n        \n        k = map(ro+rd*t);\n        t+=k*.25;\n        if(k<SURF_DIST){\n            float light = dot(calcNormal(ro+rd*t),normalize(vec3(.1*10.,3.,-5)))*2.;\n            \n            if(mat==1)\n                col = vec3(0.5);\n            else if(mat==3)\n                col=vec3(.9);\n\t\t\t\n            //col*=light;\n            break;\n        }\n        \n        \n        \n    }\n    return vec4(t,col);\n}\n\nfloat calculateAO(vec3 p, vec3 n)\n{\n   const float AO_SAMPLES = 5.0;\n   float r = 0.0;\n   float w = 1.0;\n   for (float i=1.0; i<=AO_SAMPLES; i++)\n   {\n      float d0 = i * 0.2; // 1.0/AO_SAMPLES\n      r += w * (d0 - map(p + n * d0));\n      w *= 0.5;\n   }\n   return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n    \n    float shade = 1.0;\n    \n    float d = start;\n    \n    float stepDist = end/float(MAX_STEPS_SHAD);\n    \n    for(int i=0;i<MAX_STEPS_SHAD;i++){\n        //set the end to the distance from the light to surface point\n        //to avoid hitting a surface that shouldn't be lit\n        float h = map(ro+rd*d);\n        shade = min(shade, k*h/d);\n        \n        //alternatively could be +=h, +=min(h,0.1), +=stepDist...\n        d+=min(h,d/2.);\n        \n        if(h<SURF_DIST||d>end)break;\n    }\n    \n    \n    return min(max(shade,0.)+0.3,1.0);\n    \n}\n\nvec3 lighting(vec3 sp, vec3 camPos, int reflectionPass){\n    \n    vec3 col = vec3(0.);\n    \n    vec3 n = calcNormal(sp);\n    \n    vec3 objCol = vec3(0.5);\n    \n    //lighting stuff\n    //light pos\n    vec3 lp = vec3(sin(iTime)*50.,cos(iTime)*50.,0.+iTime*10.);//cos(iTime));\n    \n    //light direction and color\n    vec3 ld = lp - sp;\n    //subtly change color\n    vec3 lcolor = vec3(1.*sin(iTime*.2),1.*cos(iTime*.2),1.)/3.+vec3(1.);\n    \n    //falloff of our light\n    float len = length(ld);\n    \n    ld/=len; //normalize light-to-surface vector\n    float lightAtten= clamp((0.5*len*len),0.,1.);//clamp between 0 and 1\n    \n    //reflect our light at the position using the normal at sp\n    ref = reflect(-ld,n);\n    \n    //only do shadows when we aren't doing reflections\n    float shadowcol = 1.0;\n    if(reflectionPass==0)shadowcol = softShadow(sp,ld,0.005*2.0,len,32.0);\n    \n    float ao = .5+.5*calculateAO(sp,n);\n    float ambient = .05;\n    float specPow = 8.0;\n    float diff = max(0.0,dot(n,ld));//diffuse value\n    float spec = max(0.0,dot(ref,normalize(camPos-sp)));\n    spec = pow(spec,specPow);//ramp up sepcular value for some shinyness\n    \n    col += (objCol*(diff+ambient)+spec*0.5)*lcolor*lightAtten*shadowcol*ao;\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float depth = 0.;\n    vec3 tot = vec3(0.0);\n    for(int ii=0;ii<AA;ii++){\n        for(int jj=0;jj<AA;jj++){\n            \n            vec2 offset = vec2(float(ii),float(jj))/float(AA);\n\n            vec2 uv = ((fragCoord+offset)-.5*iResolution.xy)/iResolution.y;\n\n            float t =iTime*10.;\n\n\n            vec3 cam = vec3(0,0,-10.+t);\n            vec3 dir = normalize(vec3(uv,1));\n\n            //    dir.xy=rotate(dir.xy,-iTime/10.);\n\n            vec4 d =trace(cam,dir);\n\n            vec3 p =cam+dir*d.x;\n\n            vec3 n = calcNormal(p);\n\n\n\n            vec4 r=traceRef(p,reflect(dir,n),0.01*5.0,32.0);\n\n            vec3 l = lighting(p,cam,0);\n\n            depth=r.x;\n            \n            vec3 rsp = p+ref*r.x;\n            \n            \n\n            vec3 col = (lighting(rsp,p,1)*.05+l)/clamp((d.x*.015),1.,10.);//d.yzw\n            //vignette\n            col *= 1.-dot(uv,uv)*.75;\n\n\t\t\ttot+=col;\n        }\n    }\n    tot/=float(AA*AA);\n    fragColor.rgb = tot;\n    fragColor.a = depth;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 171, 171, 283], [285, 285, 305, 305, 407], [409, 409, 462, 462, 525], [527, 527, 570, 570, 669], [671, 671, 703, 703, 729], [731, 731, 759, 759, 833], [835, 835, 871, 871, 958], [960, 960, 1004, 1004, 1066], [1069, 1069, 1104, 1104, 1238], [1241, 1241, 1277, 1277, 1565], [1567, 1567, 1612, 1612, 1911], [1913, 1913, 1941, 1941, 2267], [2270, 2270, 2288, 2288, 2828], [2831, 2831, 2855, 2855, 3059], [3061, 3061, 3096, 3096, 3607], [3609, 3609, 3671, 3671, 4187], [4189, 4189, 4224, 4224, 4477], [4479, 4479, 4547, 4547, 5101], [5103, 5103, 5159, 5159, 6366], [6370, 6370, 6427, 6427, 7427]]}
{"id": "WsXSD4", "name": "Midi Spiral", "author": "cbrpnk", "description": "Everyday.", "tags": ["raymarching"], "likes": 4, "viewed": 195, "published": "Public", "date": "1551235777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdfBox(vec3 p, vec3 d)\n{\n    p = abs(p) - d;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat sdfCyl(vec3 p, float r, float l)\n{\n    return length(p-vec3(0., clamp(p.y, -l, l), 0.)) - r;\n}\n\nfloat sdfTorus(vec3 p, float r, float w)\n{\n    return sqrt(pow(length(p.xz)-r, 2.) + pow(p.y, 2.)) - w;\n}\n\nvec2 merge(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p)\n{\n    //p.xz *= rot(sin(iTime));\n    //p.yz *= rot(iTime);\n    //p.z -= iTime;\n    //p.y += sin(iTime*.25)*.1;\n    //p.xy *= rot(iTime*.02);\n    p.xy *= rot(p.z*.02*sin(iTime));\n    p = mod(p+vec3(5.), 10.)-vec3(5.);\n    \n    \n    \n    \n    vec3 wkp = p;\n    wkp.x += .1;\n    wkp.x = mod(wkp.x+.21, .41)-.21;\n    float wkeys = max(max(sdfBox(wkp, vec3(.2, .15, .85)), -sdfBox(wkp-vec3(0., -.05, 1.), vec3(.25, .15, .5))), sdfBox(p-vec3(0.25, 0., 0.), vec3(3.)));\n    \n    vec3 bkp = p;\n    bkp.yz *= rot(-.09);\n    bkp.x -= -.2;\n    bkp.x = mod(bkp.x-.16, .41)+.16;\n    \n    float bkeys = sdfBox(bkp-vec3(.3, .2, -.2), vec3(.1, .1, .6));\n    vec3 bhp = p;\n    bhp.x -= 1.;\n    bhp.x = mod(bhp.x-.16, 2.9)+.16;\n    float bholes = sdfBox(bhp-vec3(.3, .2, -.2), vec3(.17, .17, .65));\n    bhp = p;\n    bhp.x -= 2.7;\n    bhp.x = mod(bhp.x-.16, 2.9)+.16;\n    float bholes2 = sdfBox(bhp-vec3(.3, .2, -.2), vec3(.17, .17, .65));\n    bkeys = max(max(max(bkeys, -bholes), -bholes2), sdfBox(p-vec3(0.25, 0., 0.), vec3(3.)));\n    //float keys = min(wkeys, bkeys)*.5, sdfBox(p-vec3(0.25, 0., 0.), vec3(3.)));\n    \n    // Body\n    float body = max(sdfBox(p-vec3(0.25, -.1, -.9), vec3(3.1, .25, 1.75)), -sdfBox(p-vec3(.25, 0., 0.), vec3(3., .25, .9)));\n    \n    // Pads\n    vec3 pp = p;\n    pp.xz -= vec2(.6, -.1);\n    pp.xz = mod(pp.xz+vec2(.15), .73)-vec2(.15);\n    float pads = max(sdfBox(pp-vec3(0., .11, 0.), vec3(.45, .08, .45)), sdfBox(p-vec3(-.3, 0., -1.8), vec3(1.4, 1., .7)));\n    \n    // Knobs\n    vec3 kp = p;\n    kp.xz = mod(pp.xz+vec2(.2), .4)-vec2(.2);\n    float knobs = max(max(max(sdfCyl(kp-vec3(0., 0.2, 0.), .2, .1), sdfBox(p-vec3(2.3, 0., -2.1), vec3(.75, 1., .35))), -sdfTorus(kp-vec3(0., .3, 0.), .35, .25)), +(p.y-.3));\n    \n    return merge(merge(merge(merge(vec2(wkeys, 0.), vec2(bkeys, 1.)), vec2(body, 2.)), vec2(pads, 0.)), vec2(knobs, 1.));\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    vec2 t = vec2(0.);\n    for(int i=0; i<228; ++i) {\n    \tvec2 d = map(ro+rd*t.x);\n        if(d.x < .0001) break;\n        t.x += d.x;\n        t.y = d.y;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(.0001, 0.);\n    return normalize(vec3(\n    \tmap(p+eps.xyy).x - map(p-eps.xyy).x,\n        map(p+eps.yxy).x - map(p-eps.yxy).x,\n        map(p+eps.yyx).x - map(p-eps.yyx).x\n    ));\n}\n\nfloat getAo(vec3 p, vec3 normal)\n{\n    float t = 0.;\n    p += normal*.002;\n    for(int i=0; i<228; ++i) {\n    \tvec2 d = map(p+normal*t);\n        if(d.x < .001) break;\n        t += d.x;\n    }\n    return clamp(t, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 cam = vec3(2., 1.5, 2);\n    vec3 dir = normalize(vec3(uv, -1));\n    dir.yz *= rot(.3);\n    dir.xz *= rot(.3);\n    vec2 res = march(cam, dir);\n    vec3 col = vec3(.05, .2, .1);\n    \n    if(res.x < 100.) {\n        vec3 p = cam+dir*res.x;\n    \tvec3 normal = getNormal(p);\n        float ao = getAo(p, normal);\n        float light1 =  max(0., dot(normal, normalize(vec3(1.))));\n        float light2 =  max(0., dot(normal, normalize(vec3(-1., 1., 1.))));\n        float fresnel = pow(1.-max(0., dot(normal, -dir)), 10.);\n        \n        if(res.y == 0.) {\n            // While Keys\n    \t\tcol = vec3(.5) * light1;\n            col += vec3(.5, .5, .45) * light2;\n            //col += fresnel;\n        } else if(res.y == 1.) {\n            // Black keys\n        \tcol = vec3(.01) * light1;\n            col += vec3(.01) * light2;\n            col += vec3(1.) * fresnel;\n        } else if(res.y == 2.) {\n            // Body\n        \tcol = vec3(.01) * light1;\n            col += vec3(.01) * light2;\n        }\n        col = mix(col, vec3(.1, .3, .09), clamp(sqrt(res.x/100.), 0., 1.));\n    }\n    col = pow(col, vec3(1.5, 1., .5));\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 127, 127, 185], [187, 187, 227, 227, 287], [289, 289, 331, 331, 394], [396, 396, 424, 424, 456], [458, 458, 476, 615, 2331], [2333, 2333, 2363, 2363, 2539], [2541, 2541, 2565, 2565, 2765], [2767, 2767, 2801, 2801, 2988], [2990, 2990, 3047, 3097, 4356]]}
{"id": "WsXSRn", "name": "Green music bars 2", "author": "darkeclipz", "description": "Green music bars 2", "tags": ["raymarch", "music", "soundbars"], "likes": 2, "viewed": 211, "published": "Public", "date": "1550359602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define MaxSteps 100.\n#define MinDistance 0.01\n#define eps 0.001\n#define Iterations 22.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// from IQ\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// from IQ\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nvec2 scene(vec3 p) {\n    \n    \n    float plane = sdPlane(p - vec3(0,1,0) + 0.0005*texture(iChannel1, p.xz).xyz, vec4(0., 1., 0., 1.));  \n    float square1 = sdBox(p, vec3(.1));\n    float square = 1e10;\n    \n    float numSquares = 16.;\n    for(float i=0.; i < numSquares; i++) {\n        vec4 music = texture( iChannel0, vec2(i/numSquares,0.1));\n\t\tsquare = min(square, sdBox(p - vec3(.3 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .2,.05)));\n        square = min(square, sdBox(p - vec3(.10 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .5,.05)));\n        square = min(square, sdBox(p - vec3(-.1 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x,.05)));\n    }\n    \n    int closestId = 0;\n    if(square > plane) closestId = 1;\n    \n    return vec2(min(plane, square), closestId);\n}\n\nfloat shadowScene(vec3 p){\n\n    float square1 = sdBox(p, vec3(.1));\n    \n    float square = 1e10;\n    \n    float numSquares = 16.;\n    for(float i=0.; i < numSquares; i++) {\n        vec4 music = texture( iChannel0, vec2(i/numSquares,0.1));\n\t\tsquare = min(square, sdBox(p - vec3(.3 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .2,.05)));\n        square = min(square, sdBox(p - vec3(.10 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x * .5,.05)));\n        square = min(square, sdBox(p - vec3(-.1 + .3,0, -1.2 + i/numSquares * 2.2), vec3(.05,.05 + music.x,.05)));\n    }\n    \n    return square;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nvec2 marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0., dt = 0., minDist = 1e10;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        dt = shadowScene(p);\n        minDist = min(minDist, dt);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec2(t-MinDistance, dt);    \n        }\n    }\n    return vec2(0., minDist);\n}\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 32.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n\n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(0,5,0), 5., vec3(1));\n\n    vec3 ambient = vec3(.1);\n    return L1 + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    \n    vec2 random = texture(iChannel0, fragCoord/R.y).xy;\n    vec3 ro = vec3(0., 2.,-4. + random.y *.2); // ray origin\n\t\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateY(cos(iTime)*.2 + 1.);\n    \n    float w = texture(iChannel0, vec2(.01,0.1)).x;\n    ro -= vec3(0,0,w*.6 - w*.6/2.);\n    \n    ro *= rot;\n    rd *= rot;\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    float occl = hit.y;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        // bars\n        if(hit.z == 0.) {\n            col = vec3(.3, 1., .3);\n        }\n        \n        // floor\n        if(hit.z == 1.) {\n         \tcol = vec3(.2); \n            \n            col += light(p, n, rd);\n            \n            // reflection\n            \n            vec3 randxz = vec3(random.x, 0, random.y);\n            vec2 shadowHit = marchShadow(p, normalize(reflect(rd, n)));\n            float refl = shadowHit.x;\n            if(refl < eps) refl = 1e10;\n            col += clamp(vec3(.4,1.,.4) * (.1 / refl), 0., 1.);              \n        }\n        \n        // glow\n        vec2 sh = marchShadow(ro, rd);\n        float glow = sh.y;\n        col += 1.2*vec3(.4,1,.4) * (1.-3.*glow);\n                \n        // green lightning\n        float lightDistance = shadowScene(p);\n        col += clamp(vec3(0,1,0) * 0.1 / lightDistance, 0., 1.) * .8;\n\n\t\t// post\n        col -= occl;\n        float fog = 1. / (1. + t * 0.25);\n        col = mix(vec3(0), col, fog);\n        \n        if(hit.z == 0.) {\n        \tcol *= occl;    \n        }\n        \n        \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "ltsGWH", "previewfilepath": "https://soundcloud.com/novalight/nl-i-wanna-live", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/novalight/nl-i-wanna-live", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 141, 141, 227], [229, 229, 256, 256, 342], [344, 344, 371, 371, 449], [451, 462, 495, 521, 552], [554, 565, 594, 594, 650], [652, 652, 672, 672, 1470], [1472, 1472, 1498, 1498, 2091], [2093, 2104, 2129, 2129, 2401], [2403, 2481, 2511, 2511, 2802], [2804, 2804, 2840, 2840, 3156], [3158, 3225, 3332, 3332, 4090], [4092, 4167, 4205, 4205, 4331], [4333, 4333, 4390, 4390, 6135]]}
{"id": "WsXSz8", "name": "Oid Mortales", "author": "Kali", "description": "Argentine flag sound visualizer - Chiptune version of the National Anthem by Uctumi\nCancionero Argentino vol.1 - PVM - https://soundcloud.com/pungas/sets/cancionero-argentino-volumen-1", "tags": ["sound", "visualizer", "argentina", "tuvieja"], "likes": 9, "viewed": 353, "published": "Public", "date": "1550542186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cells vec2(12.,20.)\n#define persp 1.2\n#define height .7\n#define linewidth .5\n#define lineexp 6.\n#define brightness .6\n#define hcells (cells*.5)\n\n\nfloat segment(vec2 p, vec3 from, vec3 to, float width, float dist) {\n    width=1./width;\n    vec2 seg=from.xy-to.xy;\n    float halfdist=distance(from.xy,to.xy)*.5;\n    float ang=atan(seg.y,seg.x);\n    float sine=sin(ang);\n    float cose=cos(ang);\n    p-=from.xy; \n    p*=mat2(cose,sine,-sine,cose);\n    float dx=abs(p.x+halfdist)-halfdist;\n    float dy=abs(p.y);\n    float h=1.-abs(p.x+halfdist*2.)/halfdist/2.;\n    float pz=-from.z-(to.z-from.z)*h;\n    float l=1.-clamp(max(dx,dy)*width/(pz+dist)*dist*dist,0.,.1)/.1;\n    return pow(abs(l),lineexp)*(1.-pow(clamp(abs(dist-pz)*.45,0.,1.),.5))*5.;\n}\n\nmat3 rotmat(vec3 v, float angle)\n{\n\tangle=radians(angle);\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat getz(vec2 xy) {\n    xy=xy*10.+hcells;\n    float pos=(xy.y*cells.x+xy.x)/(cells.x*cells.y);\n    float s=texture(iChannel0,vec2(.5+pos*.5,.1)).x;\n    return .25-pow(s,1.5)*height;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (gl_FragCoord.xy / iResolution.xy-.5)*2.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tmat3 camrot=rotmat(normalize(vec3(0.,0.,1.)),iTime*25.)*rotmat(normalize(vec3(1.,0.*sin(iTime*.5),0.)),60.+30.*sin(iTime*.5));\n\tfloat s=.1,maxc=0.;\n\tvec3 p1,p2,p3;\n\tvec3 rotv=vec3(0.,0.,1.);\n\tfloat h;\n\tfloat dist=1.2+pow(abs(sin(iTime*.3)),5.)*.5;\n\tvec3 c=vec3(0.);\n\tfor (float y=0.; y<cells.y; y++) {\n\t\tfor (float x=0.; x<cells.x; x++) {\n\t\t\tp1=vec3(x-hcells.x,y-hcells.y,0.)*.1; p1.z=getz(p1.xy);\n\t\t\tp2=vec3(p1.x+.1,p1.y   ,0.); p2.z=getz(p2.xy);\n\t\t\tp3=vec3(p1.x   ,p1.y+.1,0.); p3.z=getz(p3.xy);\n\t\t\tp1*=camrot; p2*=camrot; p3*=camrot;\n\t\t\tp1.xy*=persp/max(0.1,p1.z+dist);\n\t\t\tp2.xy*=persp/max(0.1,p2.z+dist);\n\t\t\tp3.xy*=persp/max(0.1,p3.z+dist);\n            vec3 col=mix(vec3(1.),vec3(.4,.6,1.),step(1.,pow(abs(cells.x-(x+1.)*2.)/cells.x*2.5,3.)));\n\t\t\tif (length(abs(vec2(x,y)-cells/2.+1.))<1.5) col = vec3(1.,.7,.2);\n            if (max(p1.x,p2.x)>uv.x-linewidth/4. && min(p1.x,p2.x)<uv.x+linewidth/4. && x<cells.x-1.) {\n\t\t\t\tif (max(p1.y,p2.y)>uv.y-linewidth/4. && min(p1.y,p2.y)<uv.y+linewidth/4.) {\n\t\t\t\t\t\tc+=segment(uv,p1,p2,linewidth,dist)*col;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max(p1.x,p3.x)>uv.x-linewidth/4. && min(p1.x,p3.x)<uv.x+linewidth/4. && y<cells.y-1.) {\n\t\t\t\tif (max(p1.y,p3.y)>uv.y-linewidth/4. && min(p1.y,p3.y)<uv.y+linewidth/4.) {\n\t\t\t\t\t\tc+=segment(uv,p1,p3,linewidth,dist)*col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tc*=brightness;\n    c+=mix(vec3(.5,.6,1.),vec3(1.),-uv.y+.1)*.17*mod(gl_FragCoord.y,4.);\n    fragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "lts3WH", "previewfilepath": "https://soundcloud.com/pungas/uctumi-himno-argentino-version-c64", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pungas/uctumi-himno-argentino-version-c64", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 222, 222, 752], [754, 754, 788, 788, 1161], [1163, 1163, 1184, 1184, 1348], [1350, 1350, 1407, 1407, 2915]]}
{"id": "wsXSzM", "name": "Glare circle", "author": "noriben", "description": "Glare circle.", "tags": ["glare"], "likes": 2, "viewed": 409, "published": "Public API", "date": "1551107573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //mouse\n    vec2 mouse = (iMouse.xy *2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    \n \n    // 動いてるリング Ring\n    float circleHigh1 = 0.02 / abs(tan(2.0 * iTime) - distance(uv.xy, mouse));\n    // 色付け Coloring    \n    vec3 highCol1 = vec3(circleHigh1) * vec3(0.3, 0.3, 0.7);\n    \n    \n    // 円 Circle\n    float circle1 = 0.1 / distance(uv.xy, mouse.xy); //赤の円はマウスで動く\n    float circle2 = 0.1 / distance(uv.xy, vec2(0.1, 0.0));\n    \n    // 緑と赤に色付け Coloring\n    vec3 col1 = vec3(circle1) * vec3(0.7, 0.3, 0.3);\n    vec3 col2 = vec3(circle2) * vec3(0.3, 0.7, 0.3);\n    \n    //合成\n    vec3 color = col1 + col2 + highCol1;\n    \n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 74, 960]]}
{"id": "WsXXWr", "name": "Celestrial Harmony", "author": "arthurstammet", "description": "Grid with animated modulated Circles \n\nPlease wait for a while and look what's happening!\nConcentric Waves will turn into constantly changing harmonic patterns", "tags": ["starfield", "harmonics"], "likes": 5, "viewed": 495, "published": "Public API", "date": "1551000979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Grid with animated modulated Circles\n// A kind of waving regular starfield\n\n// Please wait for a while and look what's happening!\n// Concentric Waves will turn into constantly changing harmonic patterns\n\n\nfloat Xor(float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; // set center to the middle of the screen\n    vec3 col = vec3(0.,0.,0.); // black screen\t\n    \n    // ---- Play with the values -----------------------------------------------------------------------------------------------\n\n    float r1 = 0.; // 0 <> 1.5 for circles : smallest radius\n    float r2 = 0.2; // 0 <> 1.5 for circles : biggest radius\n\n    float c1 = 40.; // base amount of cells\n    float c2 = 18.; // max amount of added cells ( c2 < c1 )\n    \n    float t0 = iTime*2.; // change global speed\n    \n    float ta = t0*.2; // change animation speed : animation amplitude\n    float tr = t0*.008; // change animation speed : starfield rotation\n    float tn = t0*.009; // change animation speed : number of cells\n\n    float th1 = t0*.0002; // change animation speed : diameter of the circles\n    // calculate 4 harmonics\n    float h1 = sin(th1);\n    float th2 = t0*.1; // change animation speed of the 2nd harmonic \n    float h2 = 2.*h1*(th2/1.1); // change amplitude of the 2nd harmonic\n    float th3 = t0*.11; // change animation speed of the 3rd harmonic\n    float h3 = 7.*h1*(th3/7.); // change amplitude of the 3rd harmonic\n    float th4 = t0*.08; // change animation speed of the 4th harmonic\n    float h4 = 8.*h1*(th4/8.3); // change animation speed of the 4th harmonic\n    float th5 = t0*.12; // change animation speed of the 5th harmonic \n    float h5 = 2.*h1*(th2/9.4); // change amplitude of the 5th harmonic\n    float th6 = t0*.13; // change animation speed of the 6th harmonic\n    float h6 = 7.*h1*(th3/13.5); // change amplitude of the 6th harmonic\n    float th7 = t0*.05; // change animation speed of the 7th harmonic\n    float h7 = 8.*h1*(th4/14.6); // change animation speed of the 7th harmonic\n\n    // build a complex wave with 2, 3 ... 7 harmonics\n    // float tVarD = h1+h2;\n    // float tVarD = h1+h2+h3;\n    // float tVarD = h1+h2+h3+h4;\n    // float tVarD = h1+h2+h3+h4+h5;\n    // float tVarD = h1+h2+h3+h4+h5+h6;\n    float tVarD = h1+h2+h3+h4+h5+h6+h7;\n    \n    // -----------------------------------------------------------------------------------------------\n    \n\t// rotate the matrix\n    float a = tr;\n    float s = sin(a);\n    float c = cos(a);\n    uv *= mat2(c, -s, s, c);\n    uv *= c1 + (sin(tn)*c2);\n\n    vec2 gv = fract(uv)-.5; // set center of a single box\n    vec2 id = floor(uv)+.5; // give each single box an id\n\n    float m = 0.;\n\n    // using the 8 cells surrounding main cell for drawing the circles\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n\t        vec2 offs = vec2(x, y);\n\t        float d = length(gv-offs);\n            float dist = length(id+offs)*(.25+(tVarD*.25)); // make the diameters pulsate\n\t        float r = mix(r1, r2, sin(dist-ta)*.5+.5); // set min and max = animation amplitude\n\n            m = Xor(m, smoothstep(r, r-15./iResolution.y, d));\n        }\n    }\n\n    col += m;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 208, 237, 237, 271], [273, 273, 330, 330, 3291]]}
