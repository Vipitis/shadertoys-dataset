{"id": "4dfcDn", "name": "Yin-yang", "author": "voz", "description": "\"Cast aside your fear to live; only then can I show you the darkness in all it's blinding beauty...\"\n-Karkov the Slayer (>100 K.D.R.)\n\nThe poem below is meant to be read top-to-bottom, so I posted it in reverse order. Enjoy!", "tags": ["ying", "yang", "yin", "yinyang"], "likes": 2, "viewed": 532, "published": "Public API", "date": "1487608815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((.125-.25*saw(float(__LINE__)*PI*GR*E)/PI/GR/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define circle(x) (vec2(cos((x)*2.0*PI),sin(2.0*PI*(x))))\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float gradient = uv.y;\n    \n        float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    float rotation = -time*PI*GR*E;\n    \n    vec2 uv0 = uv;\n    \n    int max_iterations = 4;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float map = 0.0;\n    float border = 1.0;\n    vec4 final = vec4(0.0);\n    float c1 = 0.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n    \n        float d = -cos(float(i)*PI);\n        \n        vec2 o = circle(time*d)*(1.0-iteration)/2.0;\n        \n        \n        float c = smoothstep(0.0, 1.0/E/E, 1.0-length(uv));\n        if(i == 0) c1 = c;\n        \n        \n        \n        vec2 uv2 = (uv+o)*(E+iteration);\n        float c2 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv2)*2.0/PI)*c;\n        vec2 uv3 = (uv-o)*(E+iteration);\n        float c3 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv3)*2.0/PI)*c;\n        \n    \tuv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), d*rotation*2.0-PI/8.0).xy;\n        uv = ((uv)*(1.0-c2)*(1.0-c3)+\n            (uv2)*(c2)*(1.0-c3)+\n            (uv3)*(1.0-c2)*(c3))*(antispeckle)+uv*(1.0-antispeckle)*c;\n        \n        \n        border *= saw(1.0+c2*2.0)*saw(1.0+c3*2.0);\n\n        float b = pow(border, iteration);\n        float a = atan(uv.y, uv.x)/PI*.5+.5;\n        float l = d*length(uv)*.5;\n        map += smoothstep( 0.0, border*GR, GR*saw(c+c2+c3)*saw(border*saw(saw(2.0*(a+l))*saw(b*(d-c2)*(d-c3))*antispeckle)*(iteration+1.0)));\n        \n        antispeckle *= (clamp((c2+c3), 0.0, 1.0))*(1.0-saw(c2*2.0-c3)*saw(c3*2.0-c2));\n        final += vec4(flux(map*PI+time*GR*E), 1.0);\n    }\n    fragColor = vec4(uv, 0.0, 1.0);\n     \n    float w = smoothstep(.8, 1.0, saw(map));\n \n    \n    \n    map = smoothstep(0.0, 1.0, map);\n    fragColor = ((w+final*(1.0-w)))*map*c1+(1.0-c1)*gradient;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfcDn.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[152, 734, 754, 754, 859], [860, 860, 878, 878, 917], [919, 919, 937, 937, 986], [988, 988, 1006, 1006, 1065], [1068, 1134, 1191, 1191, 3231]], "test": "valid"}
{"id": "4dfcR4", "name": "Mirrored X,Y and Z!!", "author": "Torumu106", "description": "My shader practice.\nI implemented mirror.", "tags": ["shader"], "likes": 1, "viewed": 106, "published": "Public", "date": "1487156997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIRROR\n\nbool mirrortouch = false;\nfloat PI = 3.1415926535;\nvec3 col = vec3(1.0, 1.0, 1.0);\nvec3 mirror = vec3(0.0);\nbool ismired = false;\nvec3 stoppos = vec3(0.0);\nfloat map(vec3 p){\n    float mirrordis = dot(p,normalize(vec3(-2.0, 1.0, -1.0)));\n    #ifdef MIRROR\n    if(mirrordis < 0.01 && !ismired){\n    \tmirror = normalize(vec3(-2.0, 1.0, -1.0));\n        mirrortouch = true;\n    }\n    float mirrordis1 = dot(p,normalize(vec3(2.0, 1.0, -1.0)));\n    if(mirrordis1 < 0.01 && !ismired){\n    \tmirror = normalize(vec3(2.0, 1.0, -1.0));\n\t\tmirrortouch = true;\n    }\n    #endif\n\tvec3 q = fract(p) * 2.0 - 1.0;\n\tfloat ret = length(q) - 0.25;\n    vec3 r = fract(p) * 2.0 - 1.0;\n    float xpole = length(vec2(r.y, r.z));\n    float ypole = length(vec2(r.x, r.z));\n    float zpole = length(vec2(r.y, r.x));\n    ret = min(ret, xpole - 0.05);\n    ret = min(ret, ypole - 0.05);\n    ret = min(ret, zpole - 0.05);\n    if(!ismired){\n    \tret = min(ret, mirrordis - 0.001);\n        ret = min(ret, mirrordis1 - 0.001);\n    }\n\tif(xpole <= 0.051){\n    \tcol = vec3(1.0, 0.0, 0.0);\n    }\n\tif(ypole <= 0.051){\n    \tcol = vec3(0.0, 1.0, 0.0);\n    }\n\tif(zpole <= 0.051){\n    \tcol = vec3(0.0, 0.0, 1.0);\n    }\n    float yellowball = length(q - 0.5 * vec3(sin(iTime), sin(iTime + 1.0), sin(iTime + 2.0))) - 0.05;\n    if(yellowball <= 0.001){\n    \tcol = vec3(1.0, 1.0, 0.0);\n    }\n    ret = min(ret, yellowball);\n    yellowball = length(q - 0.5 * vec3(sin(iTime+ PI * 1.2), sin(iTime + 1.0 + PI * 1.2), sin(iTime + 2.0 + PI * 1.2))) - 0.05;\n    if(yellowball <= 0.001){\n    \tcol = vec3(1.0, 1.0, 0.0);\n    }\n    ret = min(ret, yellowball);\n    yellowball = length(q - 0.5 * vec3(sin(iTime+ PI * 0.4), sin(iTime + 1.0 + PI * 0.4), sin(iTime + 2.0 + PI * 0.4))) - 0.05;\n    if(yellowball <= 0.001){\n    \tcol = vec3(1.0, 1.0, 0.0);\n    }\n    ret = min(ret, yellowball);\n    yellowball = length(q - 0.5 * vec3(sin(iTime+ PI * 1.6), sin(iTime + 1.0 + PI * 1.6), sin(iTime + 2.0 + PI * 1.6))) - 0.05;\n    if(yellowball <= 0.001){\n    \tcol = vec3(1.0, 1.0, 0.0);\n    }\n    ret = min(ret, yellowball);\n    yellowball = length(q - 0.5 * vec3(sin(iTime+ PI * 0.8), sin(iTime + 1.0 + PI * 0.8), sin(iTime + 2.0 + PI * 0.8))) - 0.05;\n    if(yellowball <= 0.001){\n    \tcol = vec3(1.0, 1.0, 0.0);\n    }\n    ret = min(ret, yellowball);\n    return ret;\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    float t1 = 0.0;\n    vec3 p = vec3(0.0);\n    p = o + r * t;\n    for(int i = 0; i < 256; ++i){\n    \tp += r * t1; \n        float d = map(p);\n        /*if(mirror != vec3(0.0) && !ismired){\n        \tr = reflect(r,mirror);\n            mirror = vec3(0.0);\n            ismired = true;\n        }*/\n        t1 = d * 0.5;\n        t += t1;\n        if(d < 0.001){\n        \tbreak;\n        }\n    }\n    stoppos = p;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.5;\n    //r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0,2.5 + iTime, -3.0 + iTime);\n    float t = trace(o, r);\n    if(mirrortouch){\n    \tr = reflect(r, mirror);\n        ismired = true;\n        t += trace(stoppos, r);\n    }\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog) * col + vec3(0.1);\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 190, 190, 2317], [2318, 2318, 2346, 2346, 2782], [2783, 2783, 2840, 2840, 3401]], "test": "valid"}
{"id": "4dfcR7", "name": "Douglas Wheeler White Neon", "author": "SalikSyed", "description": "Nice little shader demonstrating that you can analytically solve for the total light from a line segment to a point. This cheats a little bit and assumes that the relationship is 1 / distance rather than 1/distance^2 ... but it still works and runs fast!", "tags": ["lightart"], "likes": 12, "viewed": 454, "published": "Public", "date": "1487377737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PADDING_X (0.1 * iResolution.x)\n#define PADDING_Y PADDING_X\n\n#define PADDING_X (0.1 * iResolution.x)\n#define PADDING_Y PADDING_X\n\n\n\nfloat integrate(vec2 start, vec2 end, vec2 pt) {\n    // start = start of segment, end = end of segment, point = point in space.\n    /* compute line segment to point light path integral... generated with\n \t\twolfram alpha ... good luck understanding this :) */\n\tfloat r = start.x;\n\tfloat s = end.x;\n\tfloat p = start.y;\n\tfloat q = end.y;\n\n\tfloat t = pt.x;\n\tfloat u = pt.y;\n\tfloat x = 1.0;\n\tfloat v1 = (log(sqrt(p*p - 2.0*p*q + q*q + (r - s)*(r - s)) * sqrt(p*p *x*x + 2.0* q * (x - 1.0)*(u - p*x) - 2.0*p*u*x + q*q*((x - 1.0)*(x - 1.0))+ r*r*x*x + 2.0*s*(x - 1.0)*(t - r*x) - 2.0*r*t*x + s*s*(x - 1.0)*(x - 1.0) + t*t + u*u) + p*p*x - 2.0*p*q*x + p*q - p*u + q*q*x - q*q + q*u + r*r*x - 2.0*r*s*x + r*s - r*t + s*s*x - s*s + s*t))/sqrt(p*p - 2.0*p*q + q*q + ((r - s)*(r - s)));\n\tx = 0.0;\n\tfloat v2 = (log(sqrt(p*p - 2.0*p*q + q*q + (r - s)*(r - s)) * sqrt(p*p *x*x + 2.0* q * (x - 1.0)*(u - p*x) - 2.0*p*u*x + q*q*((x - 1.0)*(x - 1.0))+ r*r*x*x + 2.0*s*(x - 1.0)*(t - r*x) - 2.0*r*t*x + s*s*(x - 1.0)*(x - 1.0) + t*t + u*u) + p*p*x - 2.0*p*q*x + p*q - p*u + q*q*x - q*q + q*u + r*r*x - 2.0*r*s*x + r*s - r*t + s*s*x - s*s + s*t))/sqrt(p*p - 2.0*p*q + q*q + ((r - s)*(r - s)));\n\treturn 1000.0*(v1 - v2);\n}\n\n\nfloat compute_light_from_segment(vec2 start, vec2 end, vec2 pt) {\n    return integrate(start, end, pt);\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    \n    vec2 outerMin = vec2(PADDING_X, PADDING_Y);\n    vec2 outerMax = vec2(250, 250);\n\n   \tfloat d = 0.0;\n    float sz = 1.3;\n    // compute the light contribution from each fluorescent segment\n    d += compute_light_from_segment(outerMin - vec2(sz, 0.0), vec2(outerMin.x, outerMax.y)  - vec2(sz, 0.0), pos);\n    d += compute_light_from_segment(vec2(outerMax.x, outerMin.y) + vec2(0.0, -sz), outerMin + vec2(0.0, -sz), pos);\n    d += compute_light_from_segment(vec2(outerMin.x, outerMax.y) + vec2(0.0, sz), outerMax+ vec2(0.0, sz), pos);\n    d += compute_light_from_segment(vec2(outerMax.x, outerMin.y)+ vec2(sz, 0.0), outerMax+ vec2(sz, 0.0), pos);\n\n    \n    vec4 mixColor =  vec4(111.0/255.0, 112.0/255.0, 106.0/255.0, 1.0);\n    if (pos.x > outerMin.x && pos.x < outerMax.x && pos.y > outerMin.y && pos.y < outerMax.y) {\n        mixColor = vec4(104.0/255.0, 109.0/255.0, 113.0/255.0, 1.0);\n    }\n    \n    vec4 mixColor2 = vec4(98.0/255.0, 94.0/255.0, 91.0/255.0, 1.0);\n    \n    float alpha = (sin(iTime) + 1.0) / 2.0;\n    \n    mixColor = alpha * mixColor + (1.0 - alpha) * mixColor2;\n    \n    fragColor = mix(max(0.04, 0.01*sin(iTime*0.2))* d * mixColor, mixColor, 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfcR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 188, 398, 1341], [1344, 1344, 1409, 1409, 1449], [1456, 1456, 1507, 1507, 2685]], "test": "valid"}
{"id": "4dfcW4", "name": "Coldshine: Flame explained", "author": "coldshine", "description": "Попытка разобраться как работает шейдер пламени", "tags": ["3d"], "likes": 5, "viewed": 305, "published": "Public API", "date": "1488136720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n/**\n *   Original: https://www.shadertoy.com/view/MdX3zr\n *   Попытка разобраться как работает шейдер пламени\n */\n\n\n/**\n * Функция генерации шума. Алгоритм:\n * 1. делим пространство на кубическую (т.к. 3D-шейдер) сетку\n * 2. находим некий псевдо-случайный угол для каждой вершины куба\n * 3. находим косинус псевдо-случайного угла для каждой вершины\n * 4. находим псевдо-случайное значеие для точки в кубе: \n *    - находим проекцию на горизонтальные ребра куба (интерполяция по x)\n *    - находим проекцию на перднюю и заднюю грань куба (интерполяция по y)\n *    - находим точку между передней и задней гранью (интерполяция по z)\n */\nfloat hash(float angle) {\n    return sin(cos(angle) * angle);\n}\n\nfloat valueNoise(vec3 currentRayPosition)\n{\n    // найдем координаты куба в котором находится currentRayPosition\n    \n    // вначале находим дальнюю левую нижнюю точку сетки куба:\n    vec3 integer = floor(currentRayPosition); \n    \n    // находим локальную позицию точки внутри куба\n    // можно было бы записать так:\n    // vec3 f = currentRayPosition - integer\n    // но можно проще, что равносильно:\n    vec3 f = fract(currentRayPosition);\n    \n    // в пределах куба f изменяется линейно, от 0 до 1\n    // мы можем использовать f в качестве функции для интерполяции \n    // то есть по f будем находить псевдо-рандомное значение для каждой точки куба\n    \n    // в оригинале - косинусная интерполяция, \n\t// vec3 f = cos(fractional * PI)*(-.5)+.5;    \n    // которая дает более сглаженый шум в сравнении с линейным:\n    // https://www.desmos.com/calculator/8zudfzbmyd\n    // но на данном шейдере разницы практически не заметно\n    // подробнее про функции интерполяции:\n    // http://paulbourke.net/miscellaneous/interpolation/\n    \n    float dx = 1.;   // изменение (дельта) угла по оси x\n    float dy = 57.;  // изменение (дельта) угла по оси y\n    float dz = 21.;  // изменение (дельта) угла по оси z\n    \n    // угол = скалярному произведению вектора i и вектора значений изменения угла\n    float angle = dot(integer, vec3(dx, dy, dz));\n    \n    // находим косинус для каждого угла по формуле y = sin(cos(x) * x), график функции \n    // https://www.desmos.com/calculator/nhkq8uwxqm\n    // для дальней стороны куба\n    float fbl = angle; // нижний левый угол\n    float fbr = angle + dx; // нижний правый\n    float ftl = angle + dy; // верхний левый\n    float ftr = angle + dy + dx; // верхний правый\n\n    // и для ближней стороны куба\n    float nbl = angle + dz; // нижний левый угол\n    float nbr = angle + dz + dx; // нижний правый\n    float ntl = angle + dz + dy; // верхний левый\n    float ntr = angle + dz + dy + dx; // верхний правый  \n\n    // находим проекцию точки на горизонтальные грани  интерполируя от левого к правому углу \n    // для дальней стороны\n    float ft = mix(hash(fbl), hash(fbr), f.x);\n    float fb = mix(hash(ftl), hash(ftr), f.x);\n    // и ближней\n    float nt = mix(hash(nbl), hash(nbr), f.x);\n    float nb = mix(hash(ntl), hash(ntr), f.x);\n    \n    // находим проекцию точки на сторону куба интерполируя от проекции на верхней грани к нижней\n    // для дальней стороны\n    float far = mix(ft, fb, f.y);\n    // и ближней     \n    float near = mix(nt, nb, f.y); \n    \n    // находим значение для точки интерполируя от дальней стороне куба к ближней     \n    float result = mix(far, near, f.z);\n    return result;\n}\n\nvec2 rotate(vec2 p, float theta) {\n\treturn vec2(\n\t\tp.x*cos(theta)+p.y*sin(theta),\n\t\tp.x*sin(theta)-p.y*cos(theta)\n\t);\n}\n\n\nfloat makeNoise(vec3 currentRayPosition) {\n    vec3 currentRayPositionForFlame = currentRayPosition;\n    currentRayPositionForFlame.y += iTime*2.;\n    \n    // первая октава шума Перлина\n    // http://libnoise.sourceforge.net/glossary/#octave\n    float distanceToFlame = valueNoise(currentRayPositionForFlame);\n    \n    // вторая октава\n    // 3 - частота (чем больше - тем больше зернистость, или деформация)\n    // 0.5 - сокращает амплитуду на 2 (чем меньше - тем больше скученность) \n    distanceToFlame += valueNoise(currentRayPosition*3.) * 0.5;\n\n    // придаем форму пламени\n    // с увеличением Y, увеличивается площадь по xz\n    distanceToFlame *= currentRayPosition.y * .25;\n\treturn distanceToFlame;\n}\n\n\n// signed-distance function - функция расстояния до сферы по признаку\n// currentRayPosition - это текущая позиция конкретного луча\nfloat sdSphere(vec3 currentRayPosition)\n{\n    float sphereRadius = 1.; // радиус сферы\n    vec3 spherePosition = vec3(0.0, 1., 0.0); //координаты сферы    \n    vec3 sphereModificator = vec3(1.0, 0.5, 1.0); //вытягиваем сферу по y (также влияет на пламя)\n    \n    float distanceToSphere = length(currentRayPosition * sphereModificator + spherePosition) - sphereRadius;\n    \n\treturn distanceToSphere; // внутри сферы < 0, на границе = 0, снаружи > 0\n}\n\n// signed distance function\n// функция расстояния до сферы с эффектом пламени\nfloat flame(vec3 currentRayPosition)\n{\n    // поворачиваем пламя по оси Y\n\t//currentRayPosition.xz = rotate(currentRayPosition.xz, iTime);\n    \n    float flameDistance = 0.;\n\tflameDistance += sdSphere(currentRayPosition);\n    flameDistance += makeNoise(currentRayPosition);\n        \n    // в итоге учитываем расстояние до сферы и до noise\n    // причем сфера и noise считаются как один объект\n    return flameDistance;\n}\n\n\n// signed distance function\n// сцена - то есть граница, за которой лучи перестают быть видимыми\nfloat scene(vec3 currentRayPosition)\n{\n    // abs - модуль, flameDistance всегда положительно\n    // значит пламя находится всегда в пределах сцены \n    float flameDistance = abs(flame(currentRayPosition)); \n    float rayMaxLength =  100.; // максимальная длина луча\n    \n    float cutoff = rayMaxLength - length(currentRayPosition);\n\t// если длина луча больше максимального значения (cutoff отрицательный) - \n    // отсекаем дальнейший рендеринг в raymarch условием if( distanceToScene > epsilon )\n    return min(cutoff, flameDistance); \n}\n\n\nvec4 raymarch(vec3 cameraOrigin, vec3 rayDirection)\n{\n    /**\n\t * Эта функция итеративно анализирует сцену \n     * чтобы приблизить ближайший момент достижения лучом поверхности\n\t */\n\tfloat distanceToScene = 0.0; \n    float color = 0.0; // если луч не достиг какого-либо объекта - возвращаем черный цвет\n    float epsilon = 0.02;\n\t\n    vec3 currentRayPosition = cameraOrigin; // луч начинает движение от камеры\n    \n    bool glowed = false;\n    \n    int maxRaySteps = 64; // максимальное число шагов луча\n\t\n    // с каждой итерацией двигаем луч дальше от камеры на расстояние = мин. дистанции до ближайшего объекта \n\tfor(int i=0; i<maxRaySteps; i++)\n\t{\n        \n\t\t// получаем расстояние от текущей позиции луча до сцены + погрешность epsilon \n        distanceToScene = scene(currentRayPosition) + epsilon;\n        \n        // двигаем луч в соответствии с направлением direction и шагом distanceToSphere (rayDirection направляет к текущему uv.xy)\n\t\tcurrentRayPosition += distanceToScene * rayDirection;\n        \n        // Если луч еще не преодалел максимальное значение\n\t\tif( distanceToScene > epsilon )\n\t\t{\n            float distanceToFlame = flame(currentRayPosition);\n            if(distanceToFlame < .0) {\n                // Луч достиг объекта пламени\n                // Ставим флаг что луч прошел сквозь пламя  \n\t\t\t\tglowed=true;\n            }\n            if (glowed) {\n                // Если наш луч начал проходить/прошел сквозь пламя\n                // увеличиваем интенсивность цвета от 0 до 63/64\n                // Чем дальше луч - тем ярче цвет\n            \tcolor = float(i) / float(maxRaySteps);\n            }\n\t\t}\n\t}\n\treturn vec4(currentRayPosition, color); // vec4(xyz позиция пикселя с формой, цвет)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0; //[0,0] - центр, [-1,-1] < [uv.x,uv.y] < [1,1]\n\tuv.x *= iResolution.x/iResolution.y; //пропорции\n    \n    // Чтобы было 3D - нам нужно \"отодвинуть\" источник векторов (или лучей) от плоскости по оси z.\n\t// Для этого создаем камеру. От нее будем запускать лучи к нашим объектам.\n    // x - это сдвиг камеры по горизонтали, y - по вертикали, z - отдаляет или приближает камеру\n    // положительный z - право-сторонняя система координат, отрицательный - левосторонняя\n    vec3 cameraOrigin = vec3(0., -2. , 4.);\n\n    // Далее, нам нужно задать направление движения лучей от камеры к объектам\n    // Для этого используем нормализованный вектор rayDirection\n    // xy - это текущие координаты точки в uv\n    // коэффициент при x - сплющили поле зрения на 1.6\n    // -1 при y - инверсия, перевернули всю картинку кверх ногами\n    // z - направление движения луча, должно быть от камеры, то есть у cameraOrigin мы будем уменьшать z\n    // число z также влияет на поле зрения (как зум у фотокамеры)\n    // чем меньше z, тем больше поле зрения\n    // вспоминаем свойство нормализации - xyz изменяются пропорционально\n    // чем больше значение какого-либо компонента - тем меньше значение других компонентов\n    // соответственно uv.x, uv.y будут меньше чем на самом деле и вся сцена будет казаться меньше\n    vec3 rayDirection = normalize(vec3(uv.x*1.6, -uv.y, -1.5));\n\n    vec3 currentRayPosition = vec3(0.);\n    float shape = 0.;\n    float limits = 0.5;\n    // сужаем область raymarch до ~1/3 экрана (от -0.5 до 0.5)\n    if (uv.x > -limits && uv.x < limits) {\n\t    vec4 result = raymarch(cameraOrigin, rayDirection);\n    \n\t    currentRayPosition = result.xyz;\n        shape = result.w;\n    }\n    \n    vec3 orange = vec3(1.,.5,.1); // оранжевый цвет\n    vec3 blue = vec3(0.1,.5,1.); // голубой цвет\n    float colorChange = currentRayPosition.y*.02+.4;\n\n    vec3 blueToOrange = mix(orange, blue, colorChange); // 3 аргументом задаем формулу перехода из голубого цвета в ораньжевый\n    \n    vec3 black = vec3(0.); //цвет фона - черный\n\tvec3 result = mix(black, blueToOrange, pow(shape*2., 4.)); //добавляем плавный переход в черный    \n\t\n    fragColor = vec4(result, 1.0);    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 1072, 1097, 1097, 1135], [1137, 1137, 1180, 1399, 4845], [4847, 4847, 4881, 4881, 4966], [4969, 4969, 5011, 5011, 5864], [5867, 6064, 6105, 6105, 6601], [6603, 6721, 6759, 6881, 7232], [7235, 7383, 7421, 7595, 8097], [8100, 8100, 8153, 8374, 10432], [10434, 10434, 10491, 10491, 13683]], "test": "valid"}
{"id": "4dlcD8", "name": "Simple Twister", "author": "TrueBoolean", "description": "Simple twister implementation. Not really code golf, more just me simplifying and breaking down the effect to understand it better. Based on code from this shader: https://www.shadertoy.com/view/Xt23z3", "tags": ["twister"], "likes": 4, "viewed": 158, "published": "Public", "date": "1487994588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 p ){\n\tconst float TAU = atan(0.,-1.) * 2.;\n    const float FACES = 4.;\n    p = ((p.xy/iResolution.y)-(iResolution.xy/iResolution.y)/2.)*2.;\n    o = vec4( .5 );\n    float twist = iTime + sin(p.y) * sin(iTime);\n    for( float i = 0.; i< FACES; i+=1.){\n        vec2 edge = vec2(i, i+1.);\n        edge = sin((edge/FACES) * TAU + twist );\n        if(p.x >= edge.x && p.x <= edge.y){\n            o = vec4( mod( i, 2.) );\n            return;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 488]], "test": "valid"}
{"id": "4dlcDn", "name": "TriangleAndHexagon", "author": "Longinus", "description": "Triangle and Hexagon shaders with distance to two closest points and id of cells.", "tags": ["triangle", "worley", "hexagon"], "likes": 3, "viewed": 87, "published": "Public", "date": "1487747572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float M_PI6 = 3.14159265359/6.0;\nconst float M_PI3 = 3.14159265359/3.0;\nconst float sqrt32 = 2.0/sqrt(3.0);\nconst float sr = sqrt(3.0)/2.0;\nconst vec2 rat = vec2(1.0,sr);\n\nfloat hash(vec2 v) { return dot(v,vec2(1., -1178.65)); }\n\nvec4 HexagonWithId(vec2 uv){\n    vec2 uv2 = (uv)/rat;\n    float dmin = 1e9, d2min=1e9, nmin=-1., nmin2 = -1.;\n    for (int i=0; i<7; i++)\n    {\n        float r = float(i)*M_PI3-M_PI6;\n        vec2 uv3 = uv2-vec2(0.5,0.75)+((i!=6)?vec2(sin(r),cos(r)*sqrt32):vec2(0.0,0.0));\n        vec2 hexas = uv3+vec2(floor(uv3.y)*0.5,1.0);      \n        vec2 c = uv3+vec2(1.0,1.0)-fract(hexas);\n        float n = hash(floor(hexas));\n        vec2 dv = (c-uv2)*rat;\n        float d = length(dv);\n        if (d<dmin) { d2min=dmin; dmin=d; nmin2=nmin; nmin=n; }\n        else if (d<d2min) { d2min=d; nmin2=n; }\n    }\n    return vec4(dmin,d2min,nmin,nmin2);\n}\n\nvec4 TriangularWithId(vec2 uv){\n  \tvec2 uv2 = (uv)/rat;\n  \tfloat dmin = 1e9, d2min=1e9, nmin=-1., nmin2 = -1.;\n    vec2 c =  (uv2+uv2.y*vec2(-0.5,1.0))*vec2(1.0,0.5);  \n    vec2 fr =fract(c);\n    float even = floor(fr.x+ fr.y);\n    float fix = floor(fract(uv2.y*0.5)*2.0)*0.5;\n    vec2 c2 = uv2-mod(c,vec2(1.0,1.0));\n    vec2 p = floor(c2)+vec2(0.5+fix,1.0/3.0);\n    vec2 dv = (p-uv2)*rat;\n\n    float d =length(dv);\n    dmin =d;\n    nmin= hash(floor(p+20.0));\n    p = (floor(c2)+vec2(1.0+fix,2.0/3.0));\n    dv = (p-uv2)*rat;\n    d =length(dv);\n    if(dmin>d) {\n        d2min=dmin;\n        dmin=d;\n        nmin2 = nmin;\n        nmin = hash(floor(p));\n    }\n    else {\n        d2min=d;\n        nmin2 = hash(floor(p));\n    }\n    for(int i=0; i<2;i++)\n    {\n        p = (floor(c2)+vec2(even+fix+0.5*float(i),2.0/3.0-float(i)*1.0+2.0/3.0*even));\n        dv = (p-uv2)*rat;\n        d =length(dv);\n        if (d<d2min) { d2min=d; nmin2=hash(floor(p+even*20.0));; }\n    }\n  return vec4(dmin,d2min,nmin,nmin2);\n}\n\nfloat rnd(float x) { return fract(1000.*sin(234.56*x)); }\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dz = (sin(iTime*0.057843));\n    float dw = (sin(iTime*0.084532)+1.0);\n    float dv = (sin(iTime*0.07328834));\n\tvec2 uv = vec2(fragCoord.xy / iResolution.xy)*\n      vec2(iResolution.x/iResolution.y,1.0); //scale to normal width\n    float r = iTime*0.054387;\n    float sr= sin(r);\n    float cr= cos(r);\n    float zx= 8.0-6.0*dz;\n    uv= uv- vec2(iResolution.x/iResolution.y, 1.0)*0.5;\n    uv= uv* mat2(sr,cr,-cr,sr)*zx;\n    uv= uv + vec2(iResolution.x/iResolution.y,1.0)*0.5;\n    vec3 color= vec3(0.0,0.0,0.0);\n    float bw = 0.0;\n    vec4 he=(((fragCoord.y/iResolution.y)-fragCoord.x/iResolution.x)<dv)?TriangularWithId(uv+vec2(0.5,0.0)):HexagonWithId(uv);\n    float dx = (sin(iTime)+1.0)*0.5;\n    float dy = (sin(0.52344*iTime)+1.0)*0.5;\n    if(fragCoord.x>iResolution.x*dy){\n        if(fragCoord.y>iResolution.y*dx) {\n          bw =he.z;\n    \t  color = rnd3(bw)*vec3(0.75,1.0,0.75);\n        }\n        else\n        {\n           bw =he.w;\n    \t   color = rnd3(bw)*vec3(0.75,1.0,0.75);\n        }\n    }\n    else{\n        if(fragCoord.y>iResolution.y*(1.0-dx)) {\n        \tbw = he.x;\n        \tcolor = vec3(bw);\n        }else{\n           bw =he.y;\n    \t   color = vec3(bw);\n        }\n    }\n    color = (abs(he.x-he.y) > 0.02 ||  (fragCoord.y/iResolution.y+fragCoord.x/iResolution.x)<dw)?color:vec3(0.0,0.0,0.0);\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 198, 198, 234], [236, 236, 264, 264, 875], [877, 877, 908, 908, 1879], [1881, 1881, 1901, 1901, 1938], [1939, 1939, 1959, 1959, 2002], [2004, 2004, 2061, 2061, 3409]], "test": "error"}
{"id": "4dlcDr", "name": "Midterm", "author": "Dreeryan", "description": "procedural", "tags": ["2d"], "likes": 2, "viewed": 103, "published": "Public", "date": "1487808769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Pattern 10\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n//.785 = 45 degrees\n\n//-----Colors-----\n\nvec3 blue = vec3(0.52, 0.81, 0.98);\nvec3 iGreen = vec3(0, 0.5, 0);\nvec3 iRed = vec3(0.86, 0.07, 0.23);\nvec3 iWhite = vec3(1.0, 1.0, 1.0);\nvec3 iYellow = vec3(1.0, 1.0, 0.0);\nvec3 brown = vec3(.87, .72, .52);\n\n\n//----Functions----\n\n//Extra function - Maps values\nfloat map(float x, float in_min, float in_max, float out_min, float out_max)\n{\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n//Function 1 - Creates Poligons\nfloat createPolygon(vec2 uv, float ratio, float sides, float size, vec2 pos)\n{\n    uv -= vec2(pos.x*ratio, pos.y);\n\tfloat a = atan(uv.x, uv.y)+PI;\n    float r = TWO_PI/sides;\n\tfloat dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    dist = 1.-step(size, dist);\n    return dist;\n}\n\n//Function 2 - Rotates by Angle\nmat2 rotate2d(float angle)\n{\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n//Function 3 - Scales by given value\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x, 0, 0, value.y);\n}\n\n//Function 4 - Creates circles\nfloat createCircle(vec2 uv, float ratio, float size, vec2 pos)\n{\n    vec2 center = vec2(pos.x*ratio, pos.y);\n\tfloat unr = abs(sin(size));\n\tfloat r = map(unr, 0.0, 1.0, 0.1, 0.3);\n    \n    float dist = distance(center, uv);\n    \n    float value = step(dist, r);\n    return value;\n}\n\n//Function 5 - Creates Rectangles (modifiable lenght and width)\nfloat createRect(vec2 uv, float ratio, vec2 size, vec2 pos)\n{\n    float value = step(pos.x - size.x, uv.x) - step(pos.x + size.x, uv.x);\n    float value2 = step(pos.y - size.y, uv.y) - step(pos.y + size.y, uv.y);\n    value *= value2;\n    return value;\n}\n//Function 6\n\n\n//-----Patterns------\n\n//-------------------------------------------------------------------------------------\n#if Pattern == 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 3.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    uv -= pos;\n    uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n        \n    vec3 dist;\n    \n    if(tileIdx.x == 0. && tileIdx.y == 0. ||\n       tileIdx.x == 0. && tileIdx.y == 1. ||\n       tileIdx.x == 0. && tileIdx.y == 2.)\n    {\n        dist = vec3(createCircle(uv, ratio, .5, vec2(0.5, 0.5))) * iGreen;\n    }\n    else if(tileIdx.x == 1. && tileIdx.y == 0. ||\n       tileIdx.x == 1. && tileIdx.y == 1. ||\n       tileIdx.x == 1. && tileIdx.y == 2.)\n    {\n        dist = vec3(createCircle(uv, ratio, .5, vec2(0.5, 0.5))) * iWhite;\n    }\n    else if(tileIdx.x == 2. && tileIdx.y == 0. ||\n       tileIdx.x == 2. && tileIdx.y == 1. ||\n       tileIdx.x == 2. && tileIdx.y == 2.)\n    {\n        dist = vec3(createCircle(uv, ratio, .5, vec2(0.5, 0.5))) * iRed;\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    \n    \n    vec2 upPos = vec2(0.5, mod(iTime, 1.0)+0.1);\n    vec2 downPos = vec2(0.5, mod(iTime, 1.0)+0.1);\n    \n    vec3 dist = vec3(createPolygon(uv, ratio, 3., .1, upPos)) * blue;\n    dist += vec3(createPolygon(uv, ratio, 3., .1, vec2(0., -1.0) + upPos)) * blue;\n    \n    if(mod(tileIdx.x, 2.0) == 0.0)\n    {\n        uv -= pos;\n        uv *= rotate2d(3.15);\n    \tuv += pos;\n        \n        dist = vec3(createPolygon(uv, ratio, 3., .1, downPos)) * iRed;\n    \tdist += vec3(createPolygon(uv, ratio, 3., .1, vec2(0., -1.0) + downPos)) * iRed;\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 25.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n        \n    uv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n  \n    uv -= pos;\n   \t\tuv *= rotate2d(PI * (1./4.));\n    \tuv += pos;\n    \n    float color = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n\tuv -= pos;\n    uv *= rotate2d(-1.);\n    uv += pos;\n\n\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n\t\n    //making the rotation 0\n   // uv *= rotate2d(.5);\n    \n    if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 0.)\n    {\n        uv -= pos;\n   \t\tuv *= rotate2d(PI * (2./4.));\n    \tuv += pos;\n        \n    \tcolor = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n        uv -= pos;\n   \t\tuv *= rotate2d(-1.);\n    \tuv += pos;\n        \n\t\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n    }\n    else if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 1.)\n    {\n        uv -= pos;\n   \t\tuv *= rotate2d(PI * (3./4.));\n    \tuv += pos;\n        \n        uv -= pos;\n   \t\tuv *= rotate2d(1.);\n    \tuv += pos;\n        \n    \tcolor = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n        uv -= pos;\n   \t\tuv *= rotate2d(-1.);\n    \tuv += pos;\n        \n\t\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n    }\n    else if(mod(tileIdx.x, 2.) == 0. && mod(tileIdx.y, 2.) == 1.)\n    {\n        uv -= pos;\n   \t\tuv *= rotate2d(PI);\n    \tuv += pos;\n        \n        uv -= pos;\n   \t\tuv *= rotate2d(-6.2);\n    \tuv += pos;\n        \n    \tcolor = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n        uv -= pos;\n   \t\tuv *= rotate2d(-1.);\n    \tuv += pos;\n        \n\t\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n    }\n    \n   \n  \tvec3 dist = vec3(color) * (iRed * vec3(abs(sin(iTime)))); \n        \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 7.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    vec2 leftPos = vec2(mod(iTime, 1.0)+0.1, 0.5);\n        \n    vec3 dist;\n    dist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)))*iRed;\n    \n    float size = 2.;\n    \n    if(mod(tileIdx.x, 2.) == 0.)\n    {\n        dist -= vec3(createCircle(uv, ratio, size, leftPos));\n        dist -= vec3(createCircle(uv, ratio, size, vec2(leftPos.x - 1., .5)));\n    }\n    else if(mod(tileIdx.x, 2.) == 1.)\n    {\n        dist += vec3(createCircle(uv, ratio, size, leftPos));\n        dist += vec3(createCircle(uv, ratio, size, vec2(leftPos.x - 1., .5)));\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    vec2 rightPos = vec2(mod(iTime, 1.)+.13, .5);\n        \n    vec3 dist;\n    \n    if(mod(tileIdx.x, 2.) == 0.)\n    {\n        if(mod(tileIdx.y, 2.) == 0.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x, .26))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x - 1., .26))) * blue;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .668))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - 1., .668))) * blue;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .15))) *iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - .999, .15))) * iGreen;\n        }\n        else if(mod(tileIdx.y, 2.) == 1.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 1., .256))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 2., .256))) * iGreen;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1., .667))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 2., .667))) * iGreen;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1., .15))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 2., .15))) * blue;\n        }\n    }\n    else if(mod(tileIdx.x, 2.) == 1.)\n    {\n        if(mod(tileIdx.y, 2.) == 0.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x, .26))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x - 1., .26))) * iGreen;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .668))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - 1., .668))) * iGreen;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .15))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - 1., .15))) * blue;\n        }\n        else if(mod(tileIdx.y, 2.) == 1.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 1., .256))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 2., .256))) * blue;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1., .665))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 2., .665))) * blue;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + .999, .15))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1.999, .15))) * iGreen;\n        }\n    \n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 5.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    \n        \n    vec3 dist;\n    \n    uv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n    \n    \n    dist = vec3(createPolygon(uv, ratio, 4., .3, vec2(0.5, 0.5))) * iGreen;\n    \n    uv -= pos;\n    uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.33, .22)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.33, .78)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.67, .22)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.67, .78)));\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    \n        \n    vec3 dist;\n    \n    uv -= pos;\n   // uv *= scale2d(vec2(abs(sin(iTime))));\n    uv *= rotate2d(PI/2.*sin(iTime));\n    uv += pos;\n    \n   \tdist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.3)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.1)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.1)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.3)));\n    \n     uv -= pos;\n   // uv *= scale2d(vec2(abs(sin(iTime))));\n    uv *= rotate2d(-PI/2.);\n    uv += pos;\n    \n    if(mod(tileIdx.x, 2.) == 0. && mod(tileIdx.y, 2.) == 0.)\n    {\n        dist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.3)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.1)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.3)));\n    }\n    else if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 1.)\n    {\n        dist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.3)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.1)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.3)));\n    }\n    \n\tfragColor = vec4(dist*brown,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 center = vec2(.5*ratio,.5);\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    uv -= pos;\n    uv *= rotate2d(.785);\n   \tuv *= scale2d(vec2(sin(abs(iTime))));\n    uv += pos;\n    \n    vec3 dist;\n    \n    dist = vec3(createPolygon(uv, ratio, 4., .01, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .05, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .15, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .20, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .25, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .30, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .35, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .40, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .45, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .50, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .55, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .60, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .65, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .70, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .75, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .80, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .85, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .90, vec2(.5, .5)));\n    \n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 5.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    uv -= pos;\n    //uv *= rotate2d(iTime);\n    //uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n        \n    vec3 dist;\n    \n    float posY = abs(sin(iTime));\n    \n    dist = vec3(createPolygon(uv, ratio, 4., .53, vec2(.5, .5))) * blue;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n    uv -= pos;\n    uv *= rotate2d(1.57);\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n    uv -= pos;\n    uv *= rotate2d(1.57);\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n    uv -= pos;\n    uv *= rotate2d(1.57);\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 25.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n     \n    vec3 dist;\n    \n    dist = vec3(createCircle(uv, ratio, .3, vec2(.0, .0)));\n    dist += vec3(createCircle(uv, ratio, .3, vec2(1., 1.)));\n    dist += vec3(createCircle(uv, ratio, .3, vec2(.0, 1.)));\n    dist += vec3(createCircle(uv, ratio, .3, vec2(1., .0)));\n    \n    \n    \n    if(mod(tileIdx.x, 2.) == 0. && mod(tileIdx.y, 2.) == 0.)\n    {\n        uv -= pos;\n   \t\t uv *= rotate2d(-iTime);\n  \t\t //uv *= scale2d(vec2(abs(sin(iTime))));\n   \t\t uv += pos;\n    \n  \t\t  dist += vec3(createCircle(uv, ratio, .25, vec2(.5, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.3, .5)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.7, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .85)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .15)));\n    \n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.15, .5)));\n  \t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.85, .5)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.5, 1.1)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, -.1)));\n    \n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .74)));\n\t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .26)));\n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.64, .74)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .26)));\n    }\n    else if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 1.)\n    {\n        uv -= pos;\n   \t\t uv *= rotate2d(-iTime);\n  \t\t //uv *= scale2d(vec2(abs(sin(iTime))));\n   \t\t uv += pos;\n    \n  \t\t  dist += vec3(createCircle(uv, ratio, .25, vec2(.5, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.3, .5)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.7, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .85)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .15)));\n    \n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.15, .5)));\n  \t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.85, .5)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.5, 1.1)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, -.1)));\n    \n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .74)));\n\t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .26)));\n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.64, .74)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .26)));\n    }\n    else\n    {\n    \tuv -= pos;\n    uv *= rotate2d(iTime);\n   //uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n    \n    dist += vec3(createCircle(uv, ratio, .25, vec2(.5, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.3, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.7, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .85)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .15)));\n    \n    dist += vec3(createCircle(uv, ratio, .001, vec2(.15, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.85, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, 1.1)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, -.1)));\n    \n    dist += vec3(createCircle(uv, ratio, .001, vec2(.36, .74)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.36, .26)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .74)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .26)));\n        dist *= blue;\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 377, 455, 455, 531], [533, 565, 643, 643, 839], [841, 873, 901, 901, 966], [968, 1005, 1031, 1031, 1074], [1076, 1107, 1171, 1171, 1387], [1389, 1453, 1514, 1514, 1706]], "test": "valid"}
{"id": "4dlyR4", "name": "Playing with water", "author": "andunai", "description": "One of my first shaders. Water based on sinusoide with additional distortion.", "tags": ["2d", "water"], "likes": 5, "viewed": 126, "published": "Public", "date": "1487250433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float amplitude = 5.0;\nfloat moveSpeed = 150.0;\nfloat waveSpeed = 2.0;\nfloat width = 40.0;\n\nvec2 distort(in vec2 point) {\n    float shift = iTime * 4.0;\n\n    // gl_FragColor = texture2D(uSampler, pixelCoord * pixelSize);\n\n    return vec2(\n        point.x + sin(point.y * 0.0125 + shift) * width / 4.0,\n        point.y + cos(point.x * 0.0125 + shift) * width / 8.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Current position in pixels\n    float shift = sin(iTime * 4.0);\n\n//    float border = (iResolution.y - amplitude) - sin((fragCoord.x + iTime) / (speed * width)) * amplitude * shift;\n    \n    fragCoord = distort(fragCoord);\n    // fragColor = vec4(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y, 0.0, 1.0);\n    // return;\n    \n    float border = iResolution.y / 2.0;\n    border = border + sin((fragCoord.x + iTime * moveSpeed) / width) * amplitude * sin(iTime * waveSpeed);\n\n    if (fragCoord.y < border) {\n        //fragColor = vec4(0.0, 0.25, max(0.0, border / (fragCoord.y * 2.0)), 0.5);\n        fragColor = vec4(0.0, (fragCoord.y / border), 0.75, 0.0);\n    } else {\n        // discard;\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        // gl_FragColor = vec4(abs(sin(vTextureCoord.x + time)), abs(sin(vTextureCoord.y + time)), 0, 1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 121, 121, 372], [374, 374, 429, 463, 1294]], "test": "valid"}
{"id": "4dlyRN", "name": "Mandelbrot with Distance Est", "author": "yumcyawiz", "description": "rendering mandelbrot with distance estimation\nreference : http://iquilezles.org/www/articles/distancefractals/distancefractals.htm", "tags": ["distanceestimation"], "likes": 6, "viewed": 135, "published": "Public", "date": "1487274800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 interpolate(vec3 x1, vec3 x2, float a) {\n    float k = pow((1.0 - cos(a*3.14))/2.0, 1.0);\n    return x1*(1.0 - k) + k*x2;\n}\n\nvec4 colormap(float x) {\n    vec3 c1 = vec3(0, 7, 100)/255.0;\n    vec3 c2 = vec3(32, 107, 203)/255.0;\n    vec3 c3 = vec3(237, 255, 255)/255.0;\n    vec3 c4 = vec3(255, 170, 0)/255.0;\n    vec3 c5 = vec3(0, 2, 0)/255.0;\n    \n    if(x < 0.16) {\n        float a = x/0.16;\n        return vec4(interpolate(c1, c2, a), 1.0); \n    }\n    else if(x < 0.42) {\n        float a = (x - 0.16)/(0.42 - 0.16);\n        return vec4(interpolate(c2, c3, a), 1.0);\n    }\n    else if(x < 0.6425) {\n        float a = (x - 0.42)/(0.6425 - 0.42);\n        return vec4(interpolate(c3, c4, a), 1.0);\n    }\n    else if(x < 0.8575) {\n        float a = (x - 0.6425)/(0.8575 - 0.6425);\n        return vec4(interpolate(c4, c5, a), 1.0);\n    }\n    else {\n        float a = (x - 0.8575)/(1.0 - 0.8575);\n        return vec4(interpolate(c5, c1, a), 1.0);\n    }\n}\n\n\n//math\nvec2 cmult(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x - z1.y*z2.y, z1.x*z2.y + z1.y*z2.x);\n}\n\n\nconst int maxIter = 300;\nfloat mandelbrot(vec2 c) {\n    vec2 z = vec2(0.0, 0.0);\n    vec2 zd = vec2(0.0, 0.0);\n    for(int i = 0; i < maxIter; i++) {\n        if(length(z) > 20.0) break;\n        zd = 2.0*cmult(z, zd) + vec2(1.0, 0.0);\n        z = cmult(z, z) + c;\n    }\n    \n    float d = 0.5*length(z)*log(length(z))/length(zd);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = vec2(-0.749, 0.101);\n    float scale = 1.0/pow((0.01*float(iFrame)), 3.0);\n\tvec2 uv = scale*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y + offset;\n    \n    float d = mandelbrot(uv);\n    vec3 color = vec3(0);\n    if(d > 0.0) {\n        d = clamp(8.0*d/scale, 0.0, 1.0);\n    \td = pow(d, 0.05);\n        color = colormap(1.0 - d).xyz;\n    }\n    else {\n        color = vec3(0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 128], [130, 130, 154, 154, 953], [956, 963, 993, 993, 1058], [1086, 1086, 1112, 1112, 1405], [1408, 1408, 1465, 1465, 1909]], "test": "valid"}
{"id": "4dscz4", "name": "phyllotaxis", "author": "mahalis", "description": "just a lil square dance", "tags": ["chromaticaberration", "blackandwhite", "squares"], "likes": 13, "viewed": 986, "published": "Public API", "date": "1487268447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 r(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nfloat sdSquare(vec2 p, float s) {\n\tvec2 d = abs(p) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n#define TWO_PI 6.2832\n\nvec2 opRepeatRadial(vec2 p, int sectorCount) {\n    float fSectors = float(sectorCount);\n    float segmentAngle = (floor((atan(p.y, p.x) / TWO_PI - 0.5) * fSectors) + 0.5) * TWO_PI / fSectors;\n    return -r(p, -segmentAngle);\n}\n\nfloat evaluate(vec2 uv, float time, float timeOffset) {\n\tfloat timeOffsetMultiplier = (1. - .8*length(uv)/0.5) * 0.913;\n\tuv *= (1. + .02 * sin(1.13 * time + (timeOffset * timeOffsetMultiplier)));\n\tconst float ringWidth = 0.07;\n\tfloat ringIndex = floor(length(uv) / ringWidth - 0.5) + 0.5;\n\tfloat centerX = (ringIndex + 0.5) * ringWidth;\n\tfloat centerness = 1. - ringWidth * ringIndex;\n\tfloat ringRotation = time * 0.6 * pow(centerness, 4.);\n\tvec2 repeatedUV = opRepeatRadial(r(uv, ringRotation), (int(ringIndex) + 1) * 6);\n\tfloat squareSize = 0.013 + 0.01 * sin(length(uv) * 11.1 + time * 0.6);\n\tfloat d = sdSquare(r(repeatedUV - vec2(centerX, 0.), sin(time * centerness * 2.3 + uv.y * 3.1 - uv.x * 2.3)), squareSize);\n\tfloat value = smoothstep(0., 0.001, d);\n\tvalue = max(max(value, float(ringIndex > 6.)), float(ringIndex < 1.));\n\treturn 1. - value;\n}\n\nvec4 aberrate(vec2 uv, float time) {\n\tfloat aberrationAmount = 0.2 * pow(max(0., 1. - length(uv) * 2.), 1.3) + 0.1 * sin(time * 0.73 + length(uv) * 1.1);\n\treturn (vec4(1.0) - evaluate(uv, time, 0.) * vec4(1,0,0,0) - evaluate(uv, time + aberrationAmount, 1.) * vec4(0,1,0,0) - evaluate(uv, time + 2. * aberrationAmount, 2.) * vec4(0,0,1,0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspect = iResolution.y / iResolution.x;\n\t\n\tuv -= 0.5;\n\tuv.y *= aspect;\n\t//uv *= 1.1;\n\n\tfragColor = aberrate(uv, iTime) * aberrate(uv*(1. + .12 * sin(iTime * 0.331)), 4.11 - iTime * 0.96);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dscz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 126], [128, 128, 161, 161, 240], [265, 265, 311, 311, 491], [493, 493, 548, 548, 1346], [1348, 1348, 1384, 1384, 1690], [1692, 1692, 1749, 1749, 1988]], "test": "valid"}
{"id": "4dsyDr", "name": "GRAPROG - Midterms", "author": "acmojado", "description": "GRAPROG - Midterms (Patterns)\nUnity, Chaos, Simplicity\n\nhab merci pls i tried :(", "tags": ["patterns"], "likes": 0, "viewed": 96, "published": "Public", "date": "1487778538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n// Select the pattern\n#define patternSelect 1\n\nfloat createPolygon(vec2 uv, int sides)\n{\n\t// Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI;\n\tfloat r = TWO_PI/float(sides);\n  \n\t// Shaping function that modulate the distance\n\tfloat dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    float value = 1. - smoothstep(0.4,0.41, dist * 3.);\n    return value;\n}\n\nfloat createPolygon2(vec2 uv, int sides)\n{\n    \n\t// Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI;\n\tfloat r = TWO_PI/float(sides);\n  \t\n\t// Shaping function that modulate the distance\n\tfloat dist = cos(floor(3.+a/r)*r-a)*length(uv);\n    \n    \n    float value = 1. - smoothstep(0.4,0.41, dist * 3.);\n    return value;\n}\n\nfloat createCircle(vec2 circle, vec2 uv, float radius, float parts)\n{\n    float dist = distance(circle,uv)*2.;\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n    \n   \tangle += sin(cos(iTime)) * 3.;\n    radius = cos(parts*angle);\n        \n    float value = 1. - step(radius,dist);\n \n    return value;\n}\n\nfloat createCircle2(vec2 circle, vec2 uv, float radius, float parts)\n{\n    float dist = distance(circle,uv);\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n    \n    radius = cos(parts*angle);\n    radius += sin(iTime);\n    radius -= cos((iTime)*3.);\n        \n    float value = 1. - step(radius,dist);\n \n    return value;\n}\n\nfloat createCircle3(vec2 circle, vec2 uv, float radius, float parts)\n{\n\tfloat dist = distance(circle, uv);\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n    \n    radius += cos(tan(iTime));\n    \n    float value = 1. - step(radius,dist);\n    \n    return value;\n}\n\nfloat createCircle4(vec2 circle, vec2 uv, float radius, float parts)\n{\n\tfloat dist = distance(circle, uv);\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n    \n\tangle += abs(sin(iTime));\n    radius -= floor(sin(parts*angle));\n    \n    float value = 1. - step(radius,dist);\n    \n    return value;\n}\n\nmat2 rotate2d(float angle)\n{\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n\treturn mat2(value.x, 0, 0, value.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec3 bgColor = vec3(0.0);\n    \n    if (patternSelect == 1)\n    {\n        uv *= 3.0;\n        vec2 tileID = floor(uv);\n        uv = fract(uv);\n    \tuv.x *= ratio;\n        \n        vec2 pos = vec2(0.5 * ratio,0.5);\n    \tuv -= pos;\n \t\tuv *= scale2d(vec2(abs(sin(iTime*2.) + 1.7)));\n        \n        bgColor = createPolygon(uv, 3) * vec3(1.0,0.0,0.0);\n        \n        uv *= pos * vec2(1.,2.);\n        uv *= scale2d(vec2(sin(iTime*2.) + 1.7));\n        uv *= rotate2d(abs(iTime));\n        \n        bgColor += createPolygon(uv,3) * vec3(0.0,0.0,1.0);\n    }\n    \n    else if (patternSelect == 2)\n    {\n        bgColor += vec3(0.2,0.2,0.2);\n        uv *= 3.0;\n        vec2 tileID = floor(uv);\n        uv = fract(uv);\n    \tuv.x *= ratio;\n        \n        vec2 pos = vec2(0.5 * ratio,0.5);\n    \tuv -= pos;\n        \n        \n        if(tileID.x == 0. && tileID.y == 0. ||\n       \ttileID.x == 1. && tileID.y == 1. ||\n       \ttileID.x == 2. && tileID.y == 2. ||\n       \ttileID.x == 2. && tileID.y == 0. ||\n       \ttileID.x == 0. && tileID.y == 2.)\n    \t{\n        \tuv *= rotate2d(iTime * -3.);\n            \n            \n            uv *= scale2d(vec2(2.,2.));\n        \tuv *= rotate2d(iTime * 1.2);\n        \tbgColor += createPolygon(uv, 3) * vec3 (1.,1.,1.);\n        }\n        \n        uv *= scale2d(vec2(sin(iTime)));\n        bgColor += createPolygon(uv, 15) * vec3(0.0,1.0,1.0);\n    }\n    \n    else if (patternSelect == 3)\n    {\n     \tuv *= 3.0;\n        vec2 tileID = floor(uv);\n        uv = fract(uv);\n    \tuv.x *= ratio;\n        \n        vec2 pos = vec2(0.5 * ratio,0.5);\n        \n        if(tileID.x == 0. && tileID.y == 0. || tileID.x == 1. && tileID.y == 2. || tileID.x == 2. && tileID.y == 0.)\n        {\n           uv = pos;\n           bgColor = vec3(0.,0.,0.);\n            \n           //bgColor += createPolygon(vec2(0.5 * ratio, 0.5), 3) * vec3(1.,1.,1.);\n        }\n        \n        bgColor += createCircle(vec2(0.5 * ratio,0.5), uv, 2., 3.) * vec3(1.0,1.0,1.0);                                 \n    }\n    \n \telse if (patternSelect == 4)\n    {\n        uv *= 6.;\n        uv = fract(uv);\n    \tuv.x *= ratio;\n        uv.y *= ratio;\n        \n        bgColor = createCircle2(vec2(1., 1.), uv, 0., 4.) * vec3(0.,0.7,1.);\n    }\n    \n    else if (patternSelect == 5)\n    {\n        uv *= 2.;\n        uv = fract(uv);\n        uv.x *= ratio;\n        \n        bgColor = createCircle3(vec2(0.5 * ratio , 0.5), uv, 0.01, 0.) * vec3(1.,0.7,0.3);\n    }\n    \n    else if (patternSelect == 6)\n    {\n        uv *= 100.;\n        uv = fract(uv);\n        uv.x *= ratio;\n        \n        uv *= rotate2d(abs(sin(iTime) * 2.));\n    \tuv *= scale2d(vec2(1., 1.));\n       \n        bgColor = createPolygon2(uv, 3) * vec3(1.,0.,0.);\n    }\n    \n    else if (patternSelect == 7)\n    {\n        \n    }\n    \n    else if (patternSelect == 8)\n    {\n        \n    }\n    \n    else if (patternSelect == 9)\n    {\n        \n    }\n    \n    else if (patternSelect == 10)\n    {\n        \n    }\n    \n    fragColor = vec4(bgColor,1.0);\n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsyDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 101, 142, 186, 430], [432, 432, 474, 523, 773], [775, 775, 844, 844, 1083], [1085, 1085, 1155, 1155, 1413], [1415, 1415, 1485, 1485, 1683], [1685, 1685, 1755, 1755, 1988], [1990, 1990, 2018, 2018, 2083], [2085, 2085, 2111, 2111, 2151], [2153, 2153, 2210, 2210, 5292]], "test": "valid"}
{"id": "4dsyW8", "name": "0-4 Order of Spherical Harmonics", "author": "starea", "description": "I have added the fifth band of SH functions based on iq's implementation at [url]https://www.shadertoy.com/view/lsfXWH[/url].\nBlue are positive, and red are negative.\nUse mouse for rotating the scene.", "tags": ["3d", "function", "sphericalharmonics", "spherical", "harmonics", "irradiance", "basis"], "likes": 12, "viewed": 1588, "published": "Public API", "date": "1487969692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Remixed by Ruofei Du\n// Added the polynomial mathematical expression for the fifth band\n// ruofei/2017\n//\n// Initially created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Five bands of Spherical Harmonics functions (or atomic orbitals if you want).\n// For reference and fun.\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 1\n// change TIME to 0 to stop rotating\n#define TIME iTime\n\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.28209479177387814 // Math.sqrt(  1/Math.PI)/2\n#define k02 0.4886025119029199  // Math.sqrt(  3/Math.PI)/2\n#define k03 1.0925484305920792  // Math.sqrt( 15/Math.PI)/2\n#define k04 0.31539156525252005 // Math.sqrt(  5/Math.PI)/4\n#define k05 0.5462742152960396  // Math.sqrt( 15/Math.PI)/4\n#define k06 0.5900435899266435  // Math.sqrt( 70/Math.PI)/8\n#define k07 2.890611442640554   // Math.sqrt(105/Math.PI)/2\n#define k08 0.4570457994644658  // Math.sqrt( 42/Math.PI)/8\n#define k09 0.3731763325901154  // Math.sqrt(  7/Math.PI)/4\n#define k10 1.445305721320277   // Math.sqrt(105/Math.PI)/4\n#define k11 2.5033429417967046  // Math.sqrt(  35/Math.PI) * 3 / 4\n#define k12 1.7701307697799304  // Math.sqrt(35/2/Math.PI) * 3 / 4\n#define k13 0.9461746957575601  // Math.sqrt(   5/Math.PI) * 3 / 4\n#define k14 0.6690465435572892  // Math.sqrt( 5/2/Math.PI) * 3 / 4\n#define k15 0.10578554691520431 // Math.sqrt(   1/Math.PI) * 3 / 16\n#define k16 0.47308734787878004 // Math.sqrt(   5/Math.PI) * 3 / 8\n#define k17 0.6258357354491761  // Math.sqrt(  35/Math.PI) * 3 / 16\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{ \n\tvec3 n = s.zxy;\n\t\n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n    if( l==3 && m==-3 ) return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);\n    if( l==3 && m==-2 ) return  k07*n.z*n.y*n.x;\n    if( l==3 && m==-1 ) return -k08*n.y*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 0 ) return  k09*n.z*(5.0*n.z*n.z-3.0);\n    if( l==3 && m== 1 ) return -k08*n.x*(5.0*n.z*n.z-1.0);\n    if( l==3 && m== 2 ) return  k10*n.z*(n.x*n.x-n.y*n.y);\n    if( l==3 && m== 3 ) return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 s ) { vec3 n = s.zxy; return  k01; }\n\nfloat SH_1_0( in vec3 s ) { vec3 n = s.zxy; return -k02*n.y; }\nfloat SH_1_1( in vec3 s ) { vec3 n = s.zxy; return  k02*n.z; }\nfloat SH_1_2( in vec3 s ) { vec3 n = s.zxy; return -k02*n.x; }\n\nfloat SH_2_0( in vec3 s ) { vec3 n = s.zxy; return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 s ) { vec3 n = s.zxy; return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 s ) { vec3 n = s.zxy; return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 s ) { vec3 n = s.zxy; return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 s ) { vec3 n = s.zxy; return  k05*(n.x*n.x-n.y*n.y); }\n\nfloat SH_3_0( in vec3 s ) { vec3 n = s.zxy; return -k06*n.y*(3.0*n.x*n.x-n.y*n.y);   }\nfloat SH_3_1( in vec3 s ) { vec3 n = s.zxy; return  k07*n.z*n.y*n.x;                 }\nfloat SH_3_2( in vec3 s ) { vec3 n = s.zxy; return -k08*n.y*(5.0*n.z*n.z-1.0);       }\nfloat SH_3_3( in vec3 s ) { vec3 n = s.zxy; return  k09*n.z*(5.0*n.z*n.z-3.0);       }\nfloat SH_3_4( in vec3 s ) { vec3 n = s.zxy; return -k08*n.x*(5.0*n.z*n.z-1.0);       }\nfloat SH_3_5( in vec3 s ) { vec3 n = s.zxy; return  k10*n.z*(n.x*n.x-n.y*n.y);       }\nfloat SH_3_6( in vec3 s ) { vec3 n = s.zxy; return -k06*n.x*(n.x*n.x-3.0*n.y*n.y);   }\n\nfloat SH_4_0( in vec3 s ) { vec3 n = s.zxy; return  k11 * (n.x*n.y * (n.x*n.x - n.y*n.y));              }\nfloat SH_4_1( in vec3 s ) { vec3 n = s.zxy; return -k12 * (3.0*n.x*n.x - n.y*n.y) * n.y * n.z;          }\nfloat SH_4_2( in vec3 s ) { vec3 n = s.zxy; return  k13 * (n.x*n.y * (7.0*n.z*n.z-dot(n,n)) );          }\nfloat SH_4_3( in vec3 s ) { vec3 n = s.zxy; return -k14 * (n.z*n.y * (7.0*n.z*n.z-3.0*dot(n,n)) );      } \nfloat SH_4_4( in vec3 s ) { vec3 n = s.zxy;  \n        float z2 = n.z*n.z; return  k15 * (35.0 * z2*z2 - 30.0 * z2 + 3.0);  }\nfloat SH_4_5( in vec3 s ) { vec3 n = s.zxy; return -k14 * (n.z*n.x * (7.0*n.z*n.z-3.0*dot(n,n)) );      } \nfloat SH_4_6( in vec3 s ) { vec3 n = s.zxy; return  k16 * ( (n.x*n.x-n.y*n.y)*(7.0*n.z*n.z-dot(n,n)) ); }\nfloat SH_4_7( in vec3 s ) { vec3 n = s.zxy; return -k12 * n.x*n.z*(n.x*n.x-3.0*n.y*n.y);                }\nfloat SH_4_8( in vec3 s ) { vec3 n = s.zxy;  \n          float x2 = n.x*n.x, y2 = n.y*n.y; return  k17 * (x2 * (x2-3.0*y2) - y2*(3.0*x2 - y2));        }\n \nvec3 map( in vec3 p )\n{\n    vec3 p00 = p - vec3( 0.00, 3.0, 0.0);\n\tvec3 p01 = p - vec3(-1.25, 2.0, 0.0);\n\tvec3 p02 = p - vec3( 0.00, 2.0, 0.0);\n\tvec3 p03 = p - vec3( 1.25, 2.0, 0.0);\n\tvec3 p04 = p - vec3(-2.50, 0.5, 0.0);\n\tvec3 p05 = p - vec3(-1.25, 0.5, 0.0);\n\tvec3 p06 = p - vec3( 0.00, 0.5, 0.0);\n\tvec3 p07 = p - vec3( 1.25, 0.5, 0.0);\n\tvec3 p08 = p - vec3( 2.50, 0.5, 0.0);\n\tvec3 p09 = p - vec3(-3.75,-1.0, 0.0);\n\tvec3 p10 = p - vec3(-2.50,-1.0, 0.0);\n\tvec3 p11 = p - vec3(-1.25,-1.0, 0.0);\n\tvec3 p12 = p - vec3( 0.00,-1.0, 0.0);\n\tvec3 p13 = p - vec3( 1.25,-1.0, 0.0);\n\tvec3 p14 = p - vec3( 2.50,-1.0, 0.0);\n\tvec3 p15 = p - vec3( 3.75,-1.0, 0.0);\n\t\n    vec3 p16 = p - vec3(-5.00,-2.7, 0.0);\n    vec3 p17 = p - vec3(-3.75,-2.7, 0.0);\n    vec3 p18 = p - vec3(-2.50,-2.7, 0.0);\n    vec3 p19 = p - vec3(-1.25,-2.7, 0.0);\n    vec3 p20 = p - vec3( 0.00,-2.7, 0.0);\n    vec3 p21 = p - vec3( 1.25,-2.7, 0.0);\n    vec3 p22 = p - vec3( 2.50,-2.7, 0.0);\n    vec3 p23 = p - vec3( 3.75,-2.7, 0.0);\n    vec3 p24 = p - vec3( 5.00,-2.7, 0.0);\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\td=length(p00); n=p00/d; r = SH_0_0( n ); s = SHAPE; res = s;\n\td=length(p01); n=p01/d; r = SH_1_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p02); n=p02/d; r = SH_1_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p03); n=p03/d; r = SH_1_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p04); n=p04/d; r = SH_2_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p05); n=p05/d; r = SH_2_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p06); n=p06/d; r = SH_2_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p07); n=p07/d; r = SH_2_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p08); n=p08/d; r = SH_2_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p09); n=p09/d; r = SH_3_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p10); n=p10/d; r = SH_3_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p11); n=p11/d; r = SH_3_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p12); n=p12/d; r = SH_3_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p13); n=p13/d; r = SH_3_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p14); n=p14/d; r = SH_3_5( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p15); n=p15/d; r = SH_3_6( n ); s = SHAPE; if( s.x<res.x ) res=s;\n    \n\td=length(p16); n=p16/d; r = SH_4_0( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p17); n=p17/d; r = SH_4_1( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p18); n=p18/d; r = SH_4_2( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p19); n=p19/d; r = SH_4_3( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p20); n=p20/d; r = SH_4_4( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p21); n=p21/d; r = SH_4_5( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p22); n=p22/d; r = SH_4_6( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p23); n=p23/d; r = SH_4_7( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\td=length(p24); n=p24/d; r = SH_4_8( n ); s = SHAPE; if( s.x<res.x ) res=s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 20.0;\n    float h = 1.0;\n    float t = 0.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t\tm = res.yz;\n        t += h*0.3;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // camera\n        float an = 0.314*TIME - 10.0*iMouse.x/iResolution.x;\n        float dist = 8.0;\n        vec3  ro = vec3(dist*sin(an),0.0,dist*cos(an));\n        vec3  ta = vec3(0.0,0.0,0.0);\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.5) * clamp(1.0-length(p)*0.5, 0.0, 1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.2,0.15), vec3(0.15,0.7,1.0), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsyW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1723, 1784, 1828, 1828, 2999], [3001, 3034, 3061, 3061, 3092], [3094, 3094, 3121, 3121, 3156], [3157, 3157, 3184, 3184, 3219], [3220, 3220, 3247, 3247, 3282], [3284, 3284, 3311, 3311, 3350], [3351, 3351, 3378, 3378, 3417], [3418, 3418, 3445, 3445, 3494], [3495, 3495, 3522, 3522, 3561], [3562, 3562, 3589, 3589, 3638], [3640, 3640, 3667, 3667, 3726], [3727, 3727, 3754, 3754, 3813], [3814, 3814, 3841, 3841, 3900], [3901, 3901, 3928, 3928, 3987], [3988, 3988, 4015, 4015, 4074], [4075, 4075, 4102, 4102, 4161], [4162, 4162, 4189, 4189, 4248], [4250, 4250, 4277, 4277, 4355], [4356, 4356, 4383, 4383, 4461], [4462, 4462, 4489, 4489, 4567], [4568, 4568, 4595, 4595, 4673], [4675, 4675, 4702, 4702, 4799], [4800, 4800, 4827, 4827, 4905], [4907, 4907, 4934, 4934, 5012], [5013, 5013, 5040, 5040, 5118], [5119, 5119, 5146, 5146, 5270], [5273, 5273, 5296, 5296, 8428], [8430, 8430, 8472, 8472, 8814], [8816, 8816, 8848, 8848, 9072], [9074, 9074, 9131, 9131, 10766]], "test": "valid"}
{"id": "4dsyWn", "name": "MidTerms Graprog", "author": "paulojiao", "description": "unfinished", "tags": ["proc"], "likes": 0, "viewed": 91, "published": "Public", "date": "1487821167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define TUTORIAL 2\n\nfloat createCircle(float rad, float dist);\nfloat createRectangle(vec2 size,vec2 pos, vec2 uv);\nfloat createTriangle(float locationX, float locationY,vec2 uv, float ratio,float angleToAdd, float smoothStepX, float smoothStepY, float smoothStepScale,float globalTime);\nfloat createStar(float locationX, float locationY,vec2 uv, float ratio,float angleToAdd, float smoothStepX, float smoothStepY, float smoothStepScale,float triangleScale,float globalTime) ;\nfloat createDiamond(float locationX, float locationY,vec2 uv, float ratio,float angleToAdd, float smoothStepX, float smoothStepY,float globalTime) ;\nfloat createPoly(float locationX, float locationY, int corners, vec2 uv, float ratio,float angleToAdd);\nmat2 rotate2d (float angle)\n{\nreturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\nmat2 scale2d (vec2 value){\nreturn mat2(value.x,0,0,value.y);\n}\n\n\n#if TUTORIAL == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = 7.;\n    uv *=scale;\n    vec2 tileIdx = floor(uv);\n    \n  \n    float offset = step(1.,mod(uv.x, 2.));\n   \tuv.y -= offset* iTime;\n\n    offset = step(1.,mod(-uv.x, 9.));\n    uv.y -= offset* iTime;\n    \n    uv = fract(uv);\n    \n    \n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n\tfloat rect = createRectangle(vec2(0.18,0.6),vec2(0.8,0.0), uv);\n    float triangle = createTriangle(.5,.6,uv,ratio,0.0,.4,.41,2.0,0.0);\n    float triangle2 = createTriangle(.5,.40,uv,ratio,0.0,.4,.41,2.0,0.0);\n    \n    \n    vec3 color = vec3(rect) * vec3(0,1,sin(iTime));\n    //color += vec3(triangle2) * vec3(1.0,vec2(sin(iTime)));\n    color += vec3(triangle2);\n    \n    if (triangle2 >0.)\n        color = vec3(sin(iTime),1,0);\n    \n    color += vec3(triangle) * vec3(0,1,0);\n      if (triangle >0.)\n        color = vec3(sin(iTime),1,0);\n\n\n    \n        \n    fragColor = vec4(color,1.0);\n}\n\n#elif TUTORIAL == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    float scale = 4.0;\n    uv *= scale;\n    \n    float offset = step(1.,mod(uv.x, 2.));\n   \tuv.y -= offset* iTime;\n    \n    offset = step(1.,mod(-uv.x, 2.));\n   \tuv.y += offset* iTime;\n    \n    \n    uv = fract(uv);\n    \n    \n    uv.x *= ratio;\n    float radius = 0.14;\n     \n    float angle = atan(uv.y, uv.x);\n    angle += iTime;  \n    \n    vec2 tileIdx = floor(uv);\n      \n    float star = createStar(.5,.7,uv,ratio,0.0,.4,.41,5.0 - (sin(iTime)),15.0 + (sin(iTime) - 4.0),iTime );\n    float circle = createCircle(radius * (sin(iTime)+1.5), distance(vec2(0.5*ratio,0.7), uv));\n    float star2 = createStar(.8,.3,uv,ratio,0.0,.4,.41,5.0 - (sin(iTime)),15.0 + (sin(iTime) - 4.0),iTime);\n    float circle2 = createCircle(radius * (sin(iTime)+1.5), distance(vec2(0.8*ratio,0.3), uv));\n    float star3 = createStar(.2,.3,uv,ratio,0.0,.4,.41,5.0 - (sin(iTime)),15.0 + (sin(iTime) - 4.0),iTime);\n    float circle3 = createCircle(radius * (sin(iTime)+1.5), distance(vec2(0.2*ratio,0.3), uv));\n    \n    vec3 color = vec3(circle) * vec3(cos(iTime) + 1.0,0,0);\n    \n    if (star >0.)\n    color = vec3(0,1,0);    \n    \n    if (circle2 >0.)\n    color = vec3(0,0,1);    \n    fragColor = vec4(vec3(color),1.0);\n    \n    if (star2 >0.)\n    color = vec3(1,1,0);    \n    fragColor = vec4(vec3(color),1.0);\n    \n    if (circle3 >0.)\n    color = vec3(0,1,0);    \n    fragColor = vec4(vec3(color),1.0);\n    \n    if (star3 >0.)\n    color = vec3(1,0,0);    \n    fragColor = vec4(vec3(color),1.0);\n        \n}\n\n#elif TUTORIAL == 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    float scale = 6.0;\n    uv *= scale;\n    \n    float offset = step(1.,mod(uv.y, 2.));\n   \tuv.x -= offset* iTime;\n    \n    offset = step(1.,mod(-uv.y, 2.));\n   \tuv.x += offset* iTime;\n    \n    \n    uv = fract(uv);\n    \n    \n    uv.x *= ratio;\n    float radius = 0.14; \n    \n    //vec2 startingPos = vec2(0.5*ratio,0.5);\n   // float dist = \n    \n\n    \n    vec2 tileIdx = floor(uv);\n    \n  \n    float hex = createPoly(.5,.5,6,uv,ratio,0.5);\n    float hexa = 1. - smoothstep(.4,.41, hex * 3.0);   \n    \n    float hex2 = createPoly(.67,.5,6,uv,ratio,0.5);\n    float hexa2 = 1. - smoothstep(.4,.41, hex2 * 3.0);   \n    \n    float hex3 = createPoly(.33,.5,6,uv,ratio,0.5);\n    float hexa3 = 1. - smoothstep(.4,.41, hex3 * 3.0); \n\n    float hex4 = createPoly(.16,.5,6,uv,ratio,0.5);\n    float hexa4 = 1. - smoothstep(.4,.41, hex4 * 3.0); \n    \n    float hex5 = createPoly(.84,.5,6,uv,ratio,0.5);\n    float hexa5 = 1. - smoothstep(.4,.41, hex5 * 3.0); \n    \n    float hex6 = createPoly(1.01,.5,6,uv,ratio,0.5);\n    float hexa6 = 1. - smoothstep(.4,.41, hex6 * 3.0); \n    \n    float hex7 = createPoly(0.0,.5,6,uv,ratio,0.5);\n    float hexa7 = 1. - smoothstep(.4,.41, hex7 * 3.0); \n    \n    float rect = createRectangle(vec2(1.8,1.0),vec2(0.0,0.0), uv);\n    vec3 color = vec3(rect) * vec3(.5,.5,.5);\n    \n    if (hexa >0.)\n    color = vec3(1,1,0);    \n    fragColor = vec4(vec3(color),1.0);\n    \n    if (hexa2 >0.)\n    color =  vec3(0,1,0);   \n    fragColor = vec4(vec3(color),1.0);\n    \n        if (hexa3 >0.)\n    color = vec3(0,0,1);  \n    fragColor = vec4(vec3(color),1.0);\n    \n        if (hexa4 >0.)\n    color = vec3(1,1,0);    \n    fragColor = vec4(vec3(color),1.0);\n    \n        if (hexa5 >0.)\n    color = vec3(1,0,1);    \n    fragColor = vec4(vec3(color),1.0);\n    \n        if (hexa6 >0.)\n    color = vec3(1,0,0);    \n    fragColor = vec4(vec3(color),1.0);\n    \n        if (hexa7 >0.)\n    color = vec3(1,0,0);    \n    fragColor = vec4(vec3(color),1.0);                              \n                                    \n    fragColor = vec4(vec3(color),1.0);\n        \n}\n\n\n\n\n#endif\n\nfloat createCircle(float rad, float dist){\n  float val = 1.0 - step(rad,dist);\n  //vec3 color = vec3(1.0);\n  //color = val * col;\n  return val;  \n  \n}\n\nfloat createRectangle(vec2 size,vec2 pos, vec2 uv){\n   float value = step(pos.x,uv.x) - step(pos.x+size.x,uv.x);\n   value *= step(pos.y,uv.y) - step(pos.y+size.y,uv.y);\n   return value;\n}\n\nfloat createStar(float locationX, float locationY,vec2 uv, float ratio,float angleToAdd, float smoothStepX, float smoothStepY, float smoothStepScale,float triangleScale,float globalTime) {\n\tvec2 shapePos = vec2(locationX*ratio, locationY);\n    uv -= shapePos;\n    \n  \n    float angle = atan(uv.x,uv.y)+PI;\n    angle += 0.65;\n    angle += angleToAdd;\n    angle += globalTime;\n    float radius = TWO_PI/float(5);\n    float dists =cos(floor(.5 +angle/radius)*radius-angle)*length(uv);\n    \n\t\n\tfloat value = 1. - smoothstep(smoothStepX,smoothStepY,dists * smoothStepScale);\n    value += createTriangle(0.0,.15,uv,ratio,0.0,.4,.41, triangleScale,globalTime);\n    value += createTriangle(- 0.08,0.05,uv,ratio,1.2,.4,.41,triangleScale,globalTime);\n    value += createTriangle(-.055,-0.11,uv,ratio,0.4,.4,.41,triangleScale,globalTime);\n    value += createTriangle(.08,.05,uv,ratio,0.90,.4,.41,triangleScale,globalTime);\n    value += createTriangle(.055,-0.11,uv,ratio,-0.4,.4,.41,triangleScale,globalTime);  \n    \n    \n    return value;\n\n}\n\nfloat createTriangle(float locationX, float locationY,vec2 uv, float ratio,float angleToAdd, float smoothStepX, float smoothStepY, float smoothStepScale,float globalTime){\n\tvec2 shapePos = vec2(locationX*ratio, locationY);\n    uv -= shapePos;\n    \n  \n    float angle = atan(uv.x,uv.y)+PI;\n    angle += angleToAdd;\n    angle += globalTime;\n    float radius = TWO_PI/float(3);\n    float dists =cos(floor(.5+angle/radius)*radius-angle)*length(uv);\n    \n\t\n\tfloat value = 1. - smoothstep(smoothStepX,smoothStepY,dists * smoothStepScale);\n    return value;\n}\n\nfloat createDiamond(float locationX, float locationY,vec2 uv, float ratio,float angleToAdd, float smoothStepX, float smoothStepY,float globalTime){\n    vec2 shapePos = vec2(locationX*ratio, locationY);\n    uv -= shapePos;\n    \n    float value = createTriangle(0.0,0.04,uv,ratio,0.0,smoothStepX,smoothStepY,11.6,globalTime);\n    value += createTriangle(0.0,-0.03,uv,ratio,1.05,smoothStepX,smoothStepY,11.6,globalTime);\n    return value;\n}\n\nfloat createPoly(float locationX, float locationY, int corners, vec2 uv, float ratio,float angleToAdd) \n{\n\n    vec2 shapePos = vec2(locationX*ratio, locationY);\n    uv -= shapePos;\n    \n  \n    float angle = atan(uv.x,uv.y)+PI;\n    angle += angleToAdd;\n    float radius = TWO_PI/float(corners);\n    float dist =cos(floor(.5+angle/radius)*radius-angle)*length(uv);\n    \n    return dist;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[783, 783, 812, 812, 873], [874, 874, 900, 900, 936], [5873, 5873, 5915, 5915, 6023], [6025, 6025, 6076, 6076, 6212], [6214, 6214, 6402, 6402, 7245], [7247, 7247, 7418, 7418, 7799], [7801, 7801, 7948, 7948, 8238], [8240, 8240, 8345, 8345, 8626]], "test": "valid"}
{"id": "4dXcWr", "name": "Exact Duplicate", "author": "voz", "description": "\"Cast aside your fear to live; only then can I show you the darkness in all it's blinding beauty...\"\n-Karkov the Slayer (>100 K.D.R.)\nThe poem below is meant to be read top-to-bottom, so I posted it in reverse order. Enjoy!", "tags": ["exact", "duplicate"], "likes": 1, "viewed": 464, "published": "Public API", "date": "1487620525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((.125-.25*saw(float(__LINE__)*PI*GR*E)/PI/GR/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define circle(x) (vec2(cos((x)*2.0*PI),sin(2.0*PI*(x))))\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float gradient = uv.y;\n    \n        float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    float rotation = -time*PI*GR*E;\n    \n    vec2 uv0 = uv;\n    \n    int max_iterations = 4;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float map = 0.0;\n    float border = 1.0;\n    vec4 final = vec4(0.0);\n    float c1 = 0.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n    \n        float d = -cos(float(i)*PI);\n        \n        vec2 o = circle(time*d)*(1.0-iteration)/2.0;\n        \n        \n        float c = smoothstep(0.0, 1.0/E/E, 1.0-length(uv));\n        if(i == 0) c1 = c;\n        \n        \n        \n        vec2 uv2 = (uv+o)*(E+iteration);\n        float c2 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv2)*2.0/PI)*c;\n        vec2 uv3 = (uv-o)*(E+iteration);\n        float c3 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv3)*2.0/PI)*c;\n        \n    \tuv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), d*rotation*2.0-PI/8.0).xy;\n        uv = ((uv)*(1.0-c2)*(1.0-c3)+\n            (uv2)*(c2)*(1.0-c3)+\n            (uv3)*(1.0-c2)*(c3))*(antispeckle)+uv*(1.0-antispeckle)*c;\n        \n        \n        border *= saw(1.0+c2*2.0)*saw(1.0+c3*2.0);\n\n        float b = pow(border, iteration);\n        float a = atan(uv.y, uv.x)/PI*.5+.5;\n        float l = d*length(uv)*.5;\n        map += smoothstep( 0.0, border*GR, GR*saw(c+c2+c3)*saw(border*saw(saw(2.0*(a+l))*saw(b*(d-c2)*(d-c3))*antispeckle)*(iteration+1.0)));\n        \n        antispeckle *= (clamp((c2+c3), 0.0, 1.0))*(1.0-saw(c2*2.0-c3)*saw(c3*2.0-c2));\n        final += vec4(flux(map*PI+time*GR*E), 1.0);\n    }\n    fragColor = vec4(uv, 0.0, 1.0);\n     \n    float w = smoothstep(.8, 1.0, saw(map));\n \n    \n    \n    map = smoothstep(0.0, 1.0, map);\n    fragColor = ((w+final*(1.0-w)))*map*c1+(1.0-c1)*gradient;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXcWr.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[152, 734, 754, 754, 859], [860, 860, 878, 878, 917], [919, 919, 937, 937, 986], [988, 988, 1006, 1006, 1065], [1068, 1134, 1191, 1191, 3231]], "test": "valid"}
{"id": "4dXyD8", "name": "Sphere shadow", "author": "miffy", "description": "raytracing shadow", "tags": ["shadow"], "likes": 4, "viewed": 140, "published": "Public", "date": "1487856388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @param x....radian around x-axis\n// @param y....radian around y-axis\n// @param z....radian around z-axis\n//from https://www.shadertoy.com/view/XdlGzn\nmat4 rotate( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x, y, z, 1.0 );\n}\n//from https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n//ray and triangle hit test\n// @param orig...origin of ray\n// @param dir...ray direction\n// @param a,b,c....triangle vertices\n// @return u,v,t\nbool hit(vec3 orig,vec3 dir,vec3 a,vec3 b,vec3 c,out vec3 uvt){\n   float eps= 0.0000001;\n   vec3 ab=b-a;\n   vec3 ac=c-a;\n   \n   vec3 n=cross(dir,ac);\n\n   float det=dot(ab,n);\n   // if the determinant is negative the triangle is backfacing\n   // if the determinant is close to 0, the ray misses the triangl\n   if(det<=eps){ return false;}\n   \n   vec3 ao=orig-a;\n   float u=dot(ao,n)/det;\n   if(u<0.0 || u>1.0){ return false;}\n    \n   vec3 e=cross(ao,ab);\n   float v=dot(dir,e)/det;\n   if(v<0.0||u+v>1.0){ return false;}\n\n   float t= dot(ac,e)/det;\n   uvt = vec3(u,v,t);\n   return true;\n}\n//hit ray sphere test\nbool hitSphere(vec3 orig,vec3 dir,vec3 center,float r,out vec3 intersect){\n    vec3 oc = orig - center;\n    float b = dot(oc,dir);\n    float c = dot(oc,oc) - r * r;\n    if(c>0.0 && b > 0.0) return false;\n    float discriminant = b*b -c;\n    if(discriminant < 0.0) return false;\n    float t= -b-sqrt(discriminant);\n    if(t<0.0) return false;\n    intersect = orig + t*dir;\n    return true;  \n}\nstruct Triangle\n{\n    vec4 a; vec2 aUV;\n    vec4 b; vec2 bUV;\n    vec4 c; vec2 cUV;\n    vec4 n;//normal\n};\nstruct Sphere{\n    vec3 center;\n    float radius;\n};\nTriangle triangles[2];\nSphere lightSource;\nSphere sphere;\nvoid createFloor( void )\n{\n    vec4 verts[8];\n\tfloat size = 5.0;\n    verts[0] = vec4( -size, -1.0, -size ,1.0);\n    verts[1] = vec4( -size, -1.0,  size ,1.0);\n    verts[2] = vec4(  size, -1.0,  size ,1.0);\n    verts[3] = vec4(  size, -1.0, -size ,1.0);\n\n    triangles[0].a = verts[0]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[1]; triangles[0].bUV = vec2(0.0,3.0);\n    triangles[0].c = verts[3]; triangles[0].cUV = vec2(3.0,0.0);\n    triangles[0].n = vec4( 0.0, 1.0, 0.0 ,0.0);\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,3.0);\n    triangles[1].b = verts[2]; triangles[1].bUV = vec2(3.0,3.0);\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(3.0,0.0);\n    triangles[1].n = vec4( 0.0, 1.0, 0.0 ,0.0);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.8*iTime;\n    mat4 mv = translate(0.0,0.0,-7.0)\n        *rotate(3.14*0.15,0.0,0.0)\n       *rotate(0.0,0.4,0.0);\n    \n    createFloor();\n    lightSource.radius = 0.1;\n    lightSource.center = (mv*vec4(2.5*sin(time),1.5,2.5*cos(time),1.0)).xyz;\n    vec4 origin = mv*vec4(0.0,-1.0,0.0,1.0);\n    vec3 lightdir = normalize(lightSource.center-origin.xyz);\n    sphere.center=(mv*vec4(0.0,0.0,0.0,1.0)).xyz;\n    sphere.radius = 0.8;\n\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    //triangle verts\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //z position of near clipping plane\n    float near=0.2;\n    vec3 p= vec3(uv*2.0-1.0,near);\n    //considering aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n    //calc ray direction\n    vec3 camera = vec3(0.0,0.0,5.0);\n    vec3 dir = p-camera;\n\tdir = normalize(dir);\n\n\n    // clear zbuffer\n    float mindist = -10000000.0;\n   \n    vec3 intersect;\n    bool isHit = hitSphere(camera,dir,sphere.center,sphere.radius,intersect);\n\n    if(isHit)\n    {\n        if( intersect.z > mindist )\n        {\n            mindist = intersect.z;\n        }\n        vec3 normal = intersect-sphere.center;\n        normal = normalize(normal);\n        //lambertian\n        float diffuse = dot(lightdir,normal);\n        color = vec4(165.0,217.0,221.0,255.0)/vec4(255.0,255.0,255.0,255.0);\n        color.rgb = diffuse*color.rgb;\n    }\n     //draw light source\n    isHit = hitSphere(camera,dir,lightSource.center,lightSource.radius,intersect);\n\n    if(isHit && intersect.z > mindist)\n    {\n        mindist = intersect.z;\n        color= vec4(1.0,1.0,1.0,1.0);\n    }\n    //each triangle in scene\n    for(int i=0;i<2;i++){\n        vec4 a=triangles[i].a;\n        vec4 b=triangles[i].b;\n        vec4 c=triangles[i].c;\n        vec4 n=triangles[i].n;\n\n        \n        vec4 ra = mv*a;\n        vec4 rb = mv*b;\n        vec4 rc = mv*c;\n        vec4 rn = mv*n;\n\n        vec3 uvt;\n        bool isHit =hit(camera,dir,ra.xyz,rb.xyz,rc.xyz,uvt);\n        if(isHit)\n        {\n            vec3 intersect = camera + dir*uvt.z;\n            float z = intersect.z;\n            // depth  buffer test\n\t\t\tif( z > mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                //lambertian\n                float diffuse = dot(lightdir,rn.xyz);\n                vec3 mate = texture( iChannel0, uv ).xyz;\n                color = vec4(mate,1.0);\n                color.rgb = diffuse*color.rgb;\n               \n                //shadow on floor test\n                \n                //hit point to light vector\n                vec3 shadowray = lightSource.center - intersect;\n               \tshadowray = normalize(shadowray);\n                \n                vec3 uvt;\n                //is shadow ray hits sphere?\n                bool isOccluded = hitSphere(intersect,shadowray,sphere.center,sphere.radius,uvt);\n                if(isOccluded){\n                    color.rgb *= 0.5;\n                }\n                \n\t\t\t}\n        }\n    }//end i loop\n   \n    fragColor = color;\n}\n//reference from https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/ligth-and-shadows", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 153, 195, 195, 552], [553, 553, 598, 598, 708], [709, 991, 1054, 1054, 1577], [1578, 1600, 1674, 1674, 1992], [2211, 2211, 2237, 2237, 2957], [2958, 2958, 3015, 3015, 5981]], "test": "error"}
{"id": "4dXyDN", "name": "ornate artifacts", "author": "jes5199", "description": "These artifacts started appearing in images I was rendering back in 2012. I just figured out how to control them. How much of this is math and how much of this is the limits of the physical processor architecture?", "tags": ["2d", "floatingpointerrors"], "likes": 1, "viewed": 104, "published": "Public", "date": "1488160069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (43.0 + pow(iTime / 5.0, 1.5)) * (fragCoord.xy / iResolution.xy - 0.5);\n    \n    float value = uv.x * uv.y;\n\tfragColor = sin(value) * 3. - vec4(0,1,2,0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 225]], "test": "valid"}
{"id": "4lGXWD", "name": "Sine-Wave", "author": "tkoram20", "description": "Testing SinWave, Need to add x-offset, Find cheaper method to generate gradient for lines. pow(x,4800) seems overkill.", "tags": ["wavesineline"], "likes": 13, "viewed": 1199, "published": "Public API", "date": "1487061132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float seed)\n{\n    return fract(sin(seed*1.0));\n}\n\n\nfloat horizontal(vec2 uv, float r)\n{\n    float result = abs(uv.y)-r;\n    float res2 = 1.0-result;\n    float res3 = result * -1.0;\n    res3 = 1.0 - res3;\n    result = res2 * res3;\n    //result = pow(result,8800.0);\n    //result += 1.0;\n    result = smoothstep(.05/iResolution.y,0.0,1.0-result);\n    return result;\n}\n\n/*float gradient(vec2 uv, float r)\n{\n     float result = length(vec2(0.0,uv.y));\n    float res2 = 1.0-result;\n    float res3 = res2*-1.0;\n    result = res2 * result;\n    result *= 4.0; \n    return result;\n    \n}*/\n\nfloat horiwaves(vec2 uv, float frequency, float Amplitude)\n{\n    float result = sin(uv.x*frequency);\n    return result*Amplitude*sin(uv.x);\n}\n\nvec3 makewave(vec2 uv,float frequency, float amplitude, float zoffset, vec3 color, float speed)\n{\n    uv.x += iTime*speed;\n    float mask = horiwaves(uv,frequency,amplitude);\n    float result = horizontal(uv-mask,zoffset);\n    //result = clamp(result,0.0,1.0);\n    vec3 colorpass = result*color;\n    return colorpass;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float SW = ((sin(iTime) + 1.0)*0.5)-.50;\n    //float grad = gradient(uv,0.5);\n    uv.x -= 2.0;\n    //SW *= mask;\n    vec3 color1 = makewave(uv,15.0,0.20*sin(iTime),0.5,vec3(1.0,0.1,0.0),0.5);\n    vec3 color2 = makewave(uv,12.0,0.40*sin(iTime+1.2),0.55,vec3(0.1,1.0,0.0),0.5);\n    vec3 color3 = makewave(uv,20.0,0.30*sin(iTime+2.5),0.45,vec3(1.0,1.0,0.0),0.5);\n    vec3 color4 = makewave(uv,5.0,0.50*sin(iTime+2.0),0.550,vec3(1.0,0.0,1.0),0.5);\n    vec3 gradient = vec3(uv.y);\n    vec3 finalColor = (color1-vec3(0.1)) + (color2-vec3(0.1)) + (color3-vec3(0.1)) + (color4-vec3(0.1));\n\t//fragColor = vec4(vec3(uv,0.0),1.0);\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 59], [62, 62, 98, 98, 376], [378, 593, 653, 653, 734], [736, 736, 833, 833, 1055], [1058, 1058, 1115, 1115, 1826]], "test": "valid"}
{"id": "4lK3Rc", "name": "Heart - 3D", "author": "iq", "description": "Code for the making of this video: [url]https://www.youtube.com/watch?v=aNR4n0i2ZlM[/url]", "tags": ["procedural", "3d", "raymarching", "video", "tutorial", "heart"], "likes": 93, "viewed": 12337, "published": "Public API", "date": "1487928218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2017\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Code for the making of this video:\n// https://www.youtube.com/watch?v=aNR4n0i2ZlM\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\n\nvec2 map( vec3 q )\n{\n    q *= 100.0;\n\n    vec2 res = vec2( q.y, 2.0 );\n\n\n    float r = 15.0;\n    q.y -= r;\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + q.y/25.0), 4.0 );\n    q *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    q.y -= 1.5*ani;\n    float x = abs(q.x);\n    \n    // x = almostIdentity( x, 1.0, 0.5 ); // remove discontinuity (http://www.iquilezles.org/www/articles/functions/functions.htm)\n\n        \n    float y = q.y;\n    float z = q.z;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    d = d/3.0;\n    if( d<res.x ) res = vec2( d, 1.0 );\n    \n    res.x /= 100.0;\n    return res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 1.0;\n\n    vec2 res = vec2(0.0);\n    float t = 0.2;\n    for( int i=0; i<300; i++ )\n    {\n\t    vec2 h = map( ro+rd*t );\n        if( (h.x<0.0) || (t>maxd) ) break;\n        t += h.x;\n        res = vec2( t, h.y );\n    }\n\n    if( t>maxd ) res=vec2(-1.0);\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 kk;\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.01 + ap*0.2 ).x*20.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec2 p )\n{\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 0.1*iTime;\n\n\tvec3 ro = vec3(0.4*sin(an),0.25,0.4*cos(an));\n    vec3 ta = vec3(0.0,0.15,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(1.0,0.9,0.7);\n\n\t// raymarch\n    vec3 uvw;\n    vec2 res = intersect(ro,rd);\n    float t = res.x;\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        \n        float occ = calcAO( pos, nor ); occ = occ*occ;\n\n        if( res.y<1.5 ) // heart\n        {\n            col = vec3(0.9,0.02,0.01);\n            col = col*0.72 + 0.2*fre*vec3(1.0,0.8,0.2);\n            \n            vec3 lin  = 4.0*vec3(0.7,0.80,1.00)*(0.5+0.5*nor.y)*occ;\n                 lin += 0.8*fre*vec3(1.0,1.0,1.00)*(0.6+0.4*occ);\n            col = col * lin;\n            col += 4.0*vec3(0.8,0.9,1.00)*smoothstep(0.0,0.4,ref.y)*(0.06+0.94*pow(fre,5.0))*occ;\n\n            col = pow(col,vec3(0.4545));\n        }\n        else // ground\n        {\n            col *= clamp(sqrt(occ*1.8),0.0,1.0);\n        }\n    }\n\n    col = clamp(col,0.0,1.0);\n\treturn col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA>1\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 px = fragCoord + vec2(float(m),float(n))/float(AA);\n        vec2 p = (2.0*px-iResolution.xy)/iResolution.y;\n    \tcol += render( p );    \n    }\n    col /= float(AA*AA);\n    \n#else\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = render( p );\n#endif    \n    \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lK3Rc.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[668, 817, 841, 841, 883], [992, 992, 1028, 1028, 1204], [1206, 1206, 1257, 1257, 1386], [1389, 1389, 1409, 1409, 2044], [2046, 2046, 2088, 2088, 2372], [2374, 2374, 2406, 2406, 2629], [2631, 2631, 2673, 2673, 2966], [2968, 2968, 2994, 3128, 4564], [4565, 4565, 4622, 4622, 5163]], "test": "valid"}
{"id": "4lKXDt", "name": "Political Map", "author": "Longinus", "description": "3d Worley with cell Ids for closest two. cell Ids are calculated same for some clusters. Clustering needs improving.", "tags": ["3d", "perlin", "worley", "combined"], "likes": 3, "viewed": 135, "published": "Public", "date": "1486504686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float x) { return fract(1000.*sin(234.56*x)); }\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n    \nvec4 Worley(vec3 uvw) {\n    \n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\n   float dmin = 1e9, d2min=1e9, nmin=-1., nmin2=-1.;\n    \n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\n          for (int k=-1; k<=1; k++) \n          {\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\n              float n2 = hash(floor(c/2.0));\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\n              if (d<dmin) { d2min=dmin; dmin=d; nmin2=nmin; nmin=n2; }\t\t// 2 closest dists\n              else if (d<d2min) { d2min=d; nmin2=n2; }\n          }\n\treturn vec4(dmin,d2min,nmin, nmin2);\t\t\t// 2 closest dists + 2 closest ID\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.919,.715)), .00*iTime);\n    float a = .02*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\n    uvw *= 2.*(.97+.25*vec3(vec2(cos(.20*iTime)),0.));\t\t\t\t\t// zoom\n\n    vec4 wor = Worley(uvw*2.0);\n    vec3 col =rnd3(wor.z)/16.0+0.5;\n    vec3 ccol = (abs(wor.x-wor.y) >0.02 || wor.z==wor.w)?col:vec3(0.0,0.0,0.0);\n    float n = cnoise(uvw.xy/2.0)+0.5*cnoise(uvw.xy)+0.25*cnoise(uvw.xy*2.0);\n    vec3 landsea = n<0.04?vec3(0.5,0.5,0.85):(n>0.06)?ccol:vec3(0,0,0);\n\tfragColor = vec4(landsea,1.0); //vec4(ccol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 57], [58, 58, 78, 78, 121], [122, 122, 159, 159, 193], [194, 194, 214, 214, 258], [264, 264, 287, 287, 1114], [1116, 1116, 1137, 1137, 1186], [1188, 1188, 1210, 1210, 1247], [1249, 1249, 1277, 1277, 1329], [1331, 1331, 1350, 1350, 1390], [1392, 1416, 1438, 1438, 2480], [2482, 2524, 2556, 2556, 3671], [3673, 3673, 3730, 3730, 4306]], "test": "valid"}
{"id": "4lKXWt", "name": "Elastic Checkerboard", "author": "PauloFalcao", "description": "Playing with softjoins\nMade after Checkerboard Flight (https://www.shadertoy.com/view/XtKXWt)\nUsing an app on Android called ShaderBox", "tags": ["raymarching", "simple", "checkerboard", "mobile", "softjoin", "elastic"], "likes": 12, "viewed": 822, "published": "Public API", "date": "1486491531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Elastic Checkerboard\n//\n//\n// Playing with softjoins\n//\n// Made after Checkerboard Flight (https://www.shadertoy.com/view/XtKXWt)\n// using an app on Android called ShaderBox\n//\n\n\n// Join\nfloat softjoin(float x,float y,float s){\n  if (x>s||y>s) return min(x,y);\n  else return -length(vec2(x,y)-s)+s;\n}\n\n// Distance function\nfloat objdist(vec3 p){\n  float g=sin(iTime)*2.0+2.0;\n  float c=length(p.xz)-2.0;\n  return max(softjoin(p.y,c,g),p.y-g+0.5);\n}\n\n// Object Color\nvec3 objcolor(vec3 p){\n  p*=0.9;\n  vec2 f=fract(p.xz)-0.5;\n  return vec3(f.x*f.y>0.0?1.0:0.0);\n}\n\nvec3 grad(in vec3 p){\n  //tetrahedron normal\n  const vec2 e=vec2(0.01,-0.01);\n  float v1=objdist(p+e.xyy);\n  float v2=objdist(p+e.yyx);\n  float v3=objdist(p+e.yxy);\n  float v4=objdist(p+e.xxx);\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nfloat shading(vec3 light,vec3 p,float global){\n  vec3 n=grad(p);\n  vec3 v=normalize(light-p);\n  return max(dot(n,v),0.0)+global;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec2 uv=fragCoord.xy/iResolution.xy-0.5;\n  uv.x*=iResolution.x/iResolution.y;\n\n  //Camera\n  vec3 lookat=vec3(0.0,0.0,0.0);\n  vec3 cam=vec3(sin(iTime)*10.0,5.0,cos(iTime)*10.0);\n  vec3 up=vec3(0.0,1.0,0.0);\n\n  vec3 light=vec3(10.0,5.0,10.0);\n  float globallight=0.2;\n\n  float camdist=2.0;\n  float camsize=2.0;\n  float maxdist=50.0;\n  float preci=0.001;\n\n  vec3 v=cam-lookat;\n  vec3 camx=normalize(cross(up,v))*camsize;\n  vec3 camy=normalize(cross(v,camx))*camsize;\n\n  vec3 campoint=cam-normalize(v)*camdist+\n    camx*uv.x+\n    camy*uv.y;\n\n  vec3 ray=normalize(campoint-cam);\n\n  //Ray marching\n  vec3 p=campoint;\n  float d=maxdist;\n  float s=0.0;\n  for(int i=0;i<256;i++){\n    d=objdist(p);\n    s+=d;\n    if (d<preci) break;\n    if (s>maxdist) break;\n    p=campoint+ray*s;\n  }\n\n  float fadeout=max(maxdist-s,0.0)/maxdist;\n  fragColor = vec4(objcolor(p)*fadeout*\n     shading(light,p,globallight),\n     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 190, 230, 230, 303], [305, 326, 348, 348, 451], [453, 469, 491, 491, 565], [567, 567, 588, 611, 825], [827, 827, 873, 873, 957], [959, 959, 1015, 1015, 1926]], "test": "valid"}
{"id": "4lVXDc", "name": "Raymarching balls", "author": "nomadiclizard", "description": "Messing around with the concept of raymarching. Colouring shows march iteration escape (brighter -> higher iteration count). VR enabled, works with my DK2/Firefox nightly. :D", "tags": ["3d", "raymarcher", "balls", "vr"], "likes": 0, "viewed": 134, "published": "Public", "date": "1486328658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// learning how to raymarch woopwoop!\n\n#define pi 3.141592653589793\n#define twoPi (2.0*pi)\n#define halfPi (0.5*pi)\n#define infinity 100.0\n\n#define obj_sky 0\n#define obj_s1 1\n#define obj_s2 2\n\n// raymarching algorithm will march maxsteps and stop when at epsilon from a surface\nconst int maxsteps = 50;\nconst float epsilon = 0.0005;\n\n// view stuff\nconst float fov = radians(45.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\nstruct Sphere {\n    int objid;\n    vec3 p;\n    float r;\n    vec3 axis;\n    float angle;\n};\n    \nstruct RayHit {\n    int objid;\n    vec3 p;\n    vec2 uv;\n    vec3 n;\n    int i;\n};\n    \n// useful\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\n// really useful\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// sorta useful\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\n// distance from point to surface of a sphere\nfloat spheredist(Sphere s, vec3 p)\n{\n    return length(p - s.p) - s.r;\n}\n\n// calc uv [0,1] texture and normal for point p on surface of a rotating sphere\nvec2 spheretex(Sphere s, vec3 p, out vec3 n)\n{\n    vec3 sp = s.p - p;\n    n = normalize(sp);\n    vec3 nn = vec3(normalize(rotationMatrix(s.axis, s.angle) * vec4(sp, 1.0)));\n    vec2 uv;\n    uv.x = 0.5 + atan(nn.z, nn.x) / twoPi;\n    uv.y = 0.5 - asin(nn.y) / pi;\n    return uv;\n}\n\n// check a sphere for ray intersection passing within epsilon of surface\n// computes rayhit and updates last distance to sphere and mindist\nbool checksphere(Sphere s, vec3 p, int i, inout float lastdist, inout float mindist, out RayHit hit) {\n    // if we know we're moving away from the sphere we can skip the calc\n    if(lastdist > 0.0) {\n        float d = spheredist(s, p);\n        if(d <= epsilon) {\n            // hit!\n            vec3 n;\n            vec2 uv = spheretex(s, p, n);\n            hit = RayHit(s.objid, p, uv, n, i);\n            return true;\n        } else {\n            // store distance so next time if it's further we can skip this sphere\n            mindist = d < mindist ? d : mindist;\n            lastdist = d > lastdist ? 0.0 : d;\n        }\n    }\n    return false;\n}\n\n\nSphere s_sky = Sphere(obj_sky, vec3(0.0), infinity, up, 0.0);\nSphere s_s1 = Sphere(obj_s1, vec3(1.5, 0.0, 0.0), 1.0, up, 0.0);\nSphere s_s2 = Sphere(obj_s2, vec3(-1.5, 0.0, 0.0), 1.0, up, 0.0);\n\n// march til we hit an object in the scene or the skybox\nbool raymarch(vec3 ro, vec3 rd, out RayHit hit) {\n    float d_s1 = infinity;\n    float d_s2 = infinity;\n    float t = 0.0;\n    int breakstep = maxsteps;\n    for(int i = 0; i < maxsteps; i++) {\n        float mindist = infinity;\n        vec3 p = ro + t * rd;\n        // check the spheres\n        if(checksphere(s_s1, p, i, d_s1, mindist, hit)) return true;\n        if(checksphere(s_s2, p, i, d_s2, mindist, hit)) return true;\n        // diverging from everything?\n        if(mindist == infinity) { breakstep = i; break; }\n        // march on\n        t += mindist;\n    }\n    // assume intersection with skybox (??or last object to get close to??)\n    {\n        vec3 n;\n        vec2 uv = spheretex(s_sky, ro + infinity * rd, n);\n        hit = RayHit(s_sky.objid, ro, uv, n, breakstep);\n        return false;\n    }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    // make the spheres orbit and spin\n    mat4 omatrix = rotationMatrix(up, 0.05 * twoPi * iTime);\n    mat4 rmatrix = rotationMatrix(vec3(1.0, 1.0, 0.0), radians(30.0));\n    mat4 tmatrix = translationMatrix(vec3(0.0, 0.0, -3.5));\n\n    s_s1.p = vec3(tmatrix * rmatrix * omatrix * vec4(s_s1.p, 1.0));\n    s_s1.axis = vec3(rmatrix * vec4(s_s1.axis, 1.0));\n    s_s1.angle += 0.15 * twoPi * iTime;\n    s_s2.p = vec3(tmatrix * rmatrix * omatrix * vec4(s_s2.p, 1.0));\n    s_s2.axis = vec3(rmatrix * vec4(s_s2.axis, 1.0));\n    s_s2.angle += 0.10 * twoPi * iTime;\n    \n    // raymarch in that direction\n    RayHit hit;\n    raymarch(fragRayOri, fragRayDir, hit);\n    float escapem = log(exp(2.5) * float(hit.i) / float(maxsteps)) / 2.5;\n    if(hit.objid == obj_sky) {\n\t\tfragColor = vec4(escapem, 0.0, 0.0, 0.0);\n    } else {\n        // oooo dot product lighting\n        float lightintensity = dot(fragRayDir, hit.n);\n\t\tif (hit.objid == obj_s1) {\n        \tfragColor = texture(iChannel0, hit.uv) * lightintensity;\n            fragColor.rb *= escapem;\n    \t} else if (hit.objid == obj_s2) {\n\t        fragColor = texture(iChannel1, hit.uv) * lightintensity;\n            fragColor.rg *= escapem;\n    \t}\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // figure out where to look (the VR version does it for us)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    \n    // render\n    mainVR( fragColor, fragCoord, ro, rd);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[684, 694, 725, 725, 758], [760, 777, 822, 822, 1450], [1452, 1468, 1500, 1500, 1647], [1649, 1695, 1731, 1731, 1767], [1769, 1849, 1895, 1895, 2128], [2130, 2270, 2372, 2445, 2920], [3117, 3174, 3223, 3223, 3985], [3987, 3987, 4081, 4120, 5278], [5280, 5280, 5337, 5405, 5645]], "test": "error"}
{"id": "4lySWd", "name": "SVG debug aid", "author": "TimoKinnunen", "description": "Showing not one but all corner problem areas in Bézier spline distance fields in [url=https://www.shadertoy.com/view/MlVSWc]SVG viewer[/url] by FabriceNeyret2", "tags": ["distance", "debug", "meter", "svg", "discontinuous"], "likes": 8, "viewed": 996, "published": "Public API", "date": "1486346428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////\n//\n// SVG Distance field discontinuities\n//\n// Adapting svg viewer / nVidia logo by FabriceNeyret2\n// @ https://www.shadertoy.com/view/MlVSWc\n//\n// And utilizing distance meter by cupe\n// @ https://www.shadertoy.com/view/ldK3zD\n\n//#define SHOW_GLITCH\n#define IMPROVE_ACCURACY\n#define REPLACE_ZERO_DISTANCE\n\n// splines discretization. Lower it on slow GPUs\nconst float N = 20.;\nvec2 uv;\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t);\nvoid pnpolyAdd(vec2 p, vec2 a, vec2 b);\nfloat fOpUnion(float a, float b);\nfloat fLineSegment(vec2 p, vec2 a, vec2 b);\n\nvoid bezier(vec2 A, vec2 B, vec2 C, vec2 D) {\n\tvec2 p = A;\n#ifdef SHOW_GLITCH\n\t\tfor(float t = 1.; t<= N; t++) {\n\t\t\t// The expression t/N here is problematic.\n\t\t\t// As division is expensive, the compiler\n\t\t\t// is allowed to instead do it as t*(1./N).\n\t\t\t// (1./N) for N=20 is about 0.050, or more\n\t\t\t// precisely 0.0500000007450580596923828125.\n\t\t\t// Multiplied by 20, before rounding that's\n\t\t\t// 1.00000001490116119384765625 which the\n\t\t\t// compiler can round freely to 1.0 or\n\t\t\t// something else. A gap between edges would\n\t\t\t// then be the result. This isn't the cause\n\t\t\t// of the glitch in this case, however...\n\t\t\tvec2 q = interpolate(A,B,C,D,t/ N);\n\t\t\tpnpolyAdd(uv,p,q);\n\t\t\tp = q;\n\t\t}\n#else\n\t\tfor(float t = 1.; t< N; t++) {\n\t\t\tvec2 q = interpolate(A,B,C,D,t/ N);\n\t\t\tpnpolyAdd(uv,p,q);\n\t\t\tp = q;\n\t\t}\n\t\tpnpolyAdd(uv,p,D);\n#endif\n}\n\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n\tvec2 A = G4- G1+ 3.* (G2- G3),B = 3.* (G1- 2.* G2+ G3),C = 3.* (G2- G1),D = G1;\n\t// When t=1, we would expect to get G4 from this\n\t// and mathematically speaking that's what we'd\n\t// get too as everything else cancels out. But\n\t// the route leading to G4 is not so simple and\n\t// straight-forward. For G4 to be the result,\n\t// G4-G1 needs to be calculated without causing\n\t// round-off. In addition, an expression like\n\t// 3.*(G2-G1) is problematic, as multiplying\n\t// something by 3 requires something to have 1\n\t// unused mantissa bit or else round-off will\n\t// again occur.\n\treturn t* (t* (t* A+ B)+ C)+ D;\n}\n\n// constants and stuff\n\n#define int1 int\n#define float1 float\n#define mul( a , b ) (a) * (b)\n#define div( a , b ) (a) / (b)\n#define add( a , b ) (a) + (b)\n#define sub( a , b ) (a) - (b)\n\n// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITY = 1e38;\nconst float FILL = 1.,CONTOUR = 0.,DIR = 1.,INDIR = -1.;\nfloat _d = INFINITY;\nfloat _x,_y,x0,y0;\n\nvec4 COL = vec4(0);\nfloat fill = FILL,dir = DIR,contrast = 1.;  // style state\n\nfloat saturate(float x) {\n\treturn clamp(x,0.,1.);\n}\nfloat fOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n// Distance to line segment between a and b\nfloat fLineSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b- a;\n\tfloat t = saturate(dot(p- a,ab)/ dot(ab,ab));\n\treturn length((ab* t+ a)- p);\n}\n//rotate p.x towards p.y by a radians\nvec2 pR(vec2 p, float a) {\n\treturn cos(a)* p+ sin(a)* vec2(p.y,-p.x);\n}\n// The original version of _pnpoly_ is available @\n// https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html or @\n// http://web.archive.org/web/20161116163747/https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n//\n// Copyright (c) 1970-2003, Wm. Randolph Franklin\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\n// Redistributions in binary form must reproduce the above copyright notice in the documentation and/or other materials provided with the distribution.\n// The name of W. Randolph Franklin may not be used to endorse or promote products derived from this Software without specific prior written permission.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\nbool pInPoly = false;\nfloat pInPolyDist = INFINITY;\nvoid pnpolyAdd(vec2 p, vec2 a, vec2 b) {\n#ifdef IMPROVE_ACCURACY\n\t\t// To improve the accuracy of the polygon insidedness test\n\t\t// and making the result consist with the distance field\n\t\t// gradient, the division forcing 2 things into the same\n\t\t// magnitude can be replaced with multiplication, making\n\t\t// sure not to flip signs in the process. After rearranging\n\t\t// the result is the same as in the algorithm\n\t\t// CrossingsMultiplyTest by Eric Haines @\n\t\t// http://www.realtimerendering.com/resources/GraphicsGems//gemsiv/ptpoly_haines/ptinpoly.c\n\t\tpInPoly = pInPoly!= (a.y> p.y!= b.y> p.y&& a.y> b.y!= (a.x- b.x)* (p.y- b.y)< (a.y- b.y)* (p.x- b.x));\n#else\n\t\tpInPoly = pInPoly!= (a.y> p.y!= b.y> p.y&& p.x< ((a.x- b.x)* (p.y- b.y))/ (a.y- b.y)+ b.x);\n#endif\n\tpInPolyDist = fOpUnion(pInPolyDist,fLineSegment(p,a,b));\n}\nfloat pnpolyEnd() {\n#ifdef REPLACE_ZERO_DISTANCE\n\tif(pInPolyDist== 0.) {\n\t\t// Arbitrary, chosen visually to be smaller than values nearby.\n\t\tpInPolyDist = 0.00000001490116119384765625;\n    }\n#endif\n\tfloat result = pInPoly? -pInPolyDist: pInPolyDist;\n\tpInPoly = false;\n\tpInPolyDist = INFINITY;\n\treturn result;\n}\nvoid C(float x1, float y1, float x2, float y2, float x, float y) {\n\tbezier(vec2(_x,_y),vec2(x1,y1),vec2(x2,y2),vec2(x,y));\n\t_x = x;\n\t_y = y;\n}\nvoid M(float x, float y) {\n\tx0 = _x = x;\n\ty0 = _y = y;\n}\nvoid L(float x, float y) {\n\tvec2 a = vec2(_x,_y);\n\tvec2 b = vec2(x,y);\n\tpnpolyAdd(uv,a,b);\n\t_x = x;\n\t_y = y;\n}\nvoid z() {\n\tif(pInPolyDist!= INFINITY) {\n\t\tif(_x!= x0|| _y!= y0) {\n\t\t\tvec2 _xy = vec2(_x,_y);\n\t\t\tvec2 xy0 = vec2(x0,y0);\n\t\t\tpnpolyAdd(uv,_xy,xy0);\n\t\t}\n\t\t_d = fOpUnion(_d,pnpolyEnd());\n\t}\n}\nvoid H(float x) {\n\tL(x,_y);\n}\nvoid V(float y) {\n\tL(_x,y);\n}\nvoid c(float x1, float y1, float x2, float y2, float x, float y) {\n\tC(_x+ x1,_y+ y1,_x+ x2,_y+ y2,_x+ x,_y+ y);\n}\nvoid m(float x, float y) {\n\tM(_x+ x,_y+ y);\n}\nvoid l(float x, float y) {\n\tL(_x+ x,_y+ y);\n}\nvoid h(float x) {\n\tH(_x+ x);\n}\nvoid v(float y) {\n\tV(_y+ y);\n}\n\nvoid Z() {\n\tz();\n}\n\nvoid style(float fillRule, uint rgb, float diection, float contrastBoost) {\n\tfill = fillRule;\n\tdir = diection;\n\tCOL = vec4((rgb>> uint(16))& uint(0xFF),(rgb>> uint(8))& uint(0xFF),rgb& uint(0xFF),1)/ 255.;\n\tcontrast = contrastBoost;\n}\nvoid style(float f, uint c, float d) {\n\tstyle(f,c,d,1.);\n}\nvoid path() {\n\tif(pInPolyDist!= INFINITY) {\n\t\tif(fill> 0.) {\n\t\t\tz();\n\t\t} else {\n\t\t\t_d = fOpUnion(_d,abs(pnpolyEnd()));\n\t\t}\n\t}\n}\n\n// === SVG drawing ===============================================================\n\nfloat fSvgWorldIcon(vec3 p) {\n\t_d = INFINITY;\n\tuv = p.xz;\n    // scaling\n\tuv *= 80.;\n\tuv += vec2(29.-251./ 1024.+240./ 1024./ 2048.,7.-33./ 1024.+475./ 1024./ 2048.);\n\n// SVG by Freepik http://www.flaticon.com/free-icon/world_52349\n#if 1\n\tpath();\n\tstyle(FILL,0x000060u,DIR);  // atlantic ocean\n\tM(28.755,6.968);\n\tl(-0.47,0.149);\n\tL(25.782,7.34);\n\tl(-0.707,1.129);\n\tl(-0.513,-0.163);\n\tL(22.57,6.51);\n\tl(-0.289,-0.934);\n\tL(21.894,4.58);\n\tl(-1.252,-1.123);\n\tl(-1.477,-0.289);\n\tl(-0.034,0.676);\n\tl(1.447,1.412);\n\tl(0.708,0.834);\n\tL(20.49,6.506);\n\tl(-0.648,-0.191);\n\tL(18.871,5.91);\n\tl(0.033,-0.783);\n\tl(-1.274,-0.524);\n\tl(-0.423,1.841);\n\tl(-1.284,0.291);\n\tl(0.127,1.027);\n\tl(1.673,0.322);\n\tl(0.289,-1.641);\n\tl(1.381,0.204);\n\tl(0.642,0.376);\n\th(1.03);\n\tl(0.705,1.412);\n\tl(1.869,1.896);\n\tl(-0.137,0.737);\n\tl(-1.507,-0.192);\n\tl(-2.604,1.315);\n\tl(-1.875,2.249);\n\tl(-0.244,0.996);\n\th(-0.673);\n\tl(-1.254,-0.578);\n\tl(-1.218,0.578);\n\tl(0.303,1.285);\n\tl(0.53,-0.611);\n\tl(0.932,-0.029);\n\tl(-0.065,1.154);\n\tl(0.772,0.226);\n\tl(0.771,0.866);\n\tl(1.259,-0.354);\n\tl(1.438,0.227);\n\tl(1.67,0.449);\n\tl(0.834,0.098);\n\tl(1.414,1.605);\n\tl(2.729,1.605);\n\tl(-1.765,3.372);\n\tl(-1.863,0.866);\n\tl(-0.707,1.927);\n\tl(-2.696,1.8);\n\tl(-0.287,1.038);\n\tc(6.892,-1.66,12.019,-7.851,12.019,-15.253);\n\tC(31.413,12.474,30.433,9.465,28.755,6.968);\n\tz();\n#endif\n#if 1\n\tpath();\n\tstyle(FILL,0x006000u,DIR);  // pacific ocean\n\tM(17.515,23.917);\n\tl(-1.144,-2.121);\n\tl(1.05,-2.188);\n\tl(-1.05,-0.314);\n\tl(-1.179,-1.184);\n\tl(-2.612,-0.586);\n\tl(-0.867,-1.814);\n\tv(1.077);\n\th(-0.382);\n\tl(-2.251,-3.052);\n\tv(-2.507);\n\tL(7.43,8.545);\n\tL(4.81,9.012);\n\tH(3.045);\n\tL(2.157,8.43);\n\tL(3.29,7.532);\n\tL(2.16,7.793);\n\tc(-1.362,2.326,-2.156,5.025,-2.156,7.916);\n\tc(0.,8.673,7.031,15.707,15.705,15.707);\n\tc(0.668,0.,1.323,-0.059,1.971,-0.137);\n\tl(-0.164,-1.903);\n\tc(0.,0.,0.721,-2.826,0.721,-2.922);\n\tC(18.236,26.357,17.515,23.917,17.515,23.917);\n\tz();\n#endif\n#if 1\n\tpath();\n\tstyle(FILL,0x600000u,DIR); // polar sea\n\tM(5.84,5.065);\n\tl(2.79,-0.389);\n\tl(1.286,-0.705);\n\tl(1.447,0.417);\n\tl(2.312,-0.128);\n\tl(0.792,-1.245);\n\tl(1.155,0.19);\n\tl(2.805,-0.263);\n\tL(19.2,2.09);\n\tl(1.09,-0.728);\n\tl(1.542,0.232);\n\tl(0.562,-0.085);\n\tC(20.363,0.553,18.103,0.,15.708,0.);\n\tC(10.833,0.,6.474,2.222,3.596,5.711);\n\th(0.008);\n\tL(5.84,5.065);\n\tz();\n\tM(16.372,1.562);\n\tl(1.604,-0.883);\n\tl(1.03,0.595);\n\tl(-1.491,1.135);\n\tl(-1.424,0.143);\n\tl(-0.641,-0.416);\n\tL(16.372,1.562);\n\tz();\n\tM(11.621,1.691);\n\tl(0.708,0.295);\n\tl(0.927,-0.295);\n\tl(0.505,0.875);\n\tl(-2.14,0.562);\n\tl(-1.029,-0.602);\n\tC(10.591,2.526,11.598,1.878,11.621,1.691);\n\tz();\n#endif\n    // unscaling\n\treturn _d/80.;\n}\n//\n// scale-invariant distance meter\n//\n// be less confused by your distances!\n//\n// (as seen in the screenshots on http://mercury.sexy/hg_sdf/)\n//\n// tries to paint a plane in useful colors. outputs HDR colors, so can easily\n// be integrated into your existing rendering without looking bad.\n//\n//\n\n// the actual SDF:\nfloat f(vec3 p) {\n    return fSvgWorldIcon(p);\n}\n\n// tone mapping stolen from zavie's shader\nvec3 Uncharted2ToneMapping(vec3 color) {\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color* (A* color+ C* B)+ D* E)/ (color* (A* color+ B)+ D* F))- E/ F;\n\tfloat white = ((W* (A* W+ C* B)+ D* E)/ (W* (A* W+ B)+ D* F))- E/ F;\n\tcolor /= white;\n\treturn color;\n}\n\nvec3 fusion(float x) {\n// the meter uses the \"fusion\" gradient, which goes from dark magenta (0) to white (1)\n// (often seen in heatmaps in papers etc)\n\tfloat t = clamp(x,0.0,1.0);\n\treturn clamp(vec3(sqrt(t),t* t* t,max(sin(PI* 1.75* t),pow(t,12.0))),0.0,1.0);\n}\nvec3 fusionHDR(float x) {\n// HDR version\n\tfloat t = clamp(x,0.0,1.0);\n\treturn fusion(sqrt(t))* (0.5+ 2.* t);\n}\n\nvec3 distanceMeter(float dist, float rayLength, vec3 rayDir, float camHeight) {\n// distance meter function. needs a bit more than just the distance\n// to estimate the zoom level that it paints at.\n//\n// if you have real opengl, you can additionally use derivatives (dFdx, dFdy)\n// to detect discontinuities, i had to strip that for webgl\n//\n// visualizing the magnitude of the gradient is also useful\n\tfloat idealGridDistance = 20.0/ rayLength* pow(abs(rayDir.y),0.8);\n\tfloat nearestBase = floor(log(idealGridDistance)/ log(10.));\n\tfloat relativeDist = abs(dist/ camHeight);\n\n\tfloat largerDistance = pow(10.0,nearestBase+ 1.);\n\tfloat smallerDistance = pow(10.0,nearestBase);\n\n\tvec3 col = fusionHDR(log(1.+ relativeDist));\n\tcol = max(vec3(0.),col);\n\tif((dist)< 0.) {\n\t\tcol = col.grb* 3.;\n\t}\n\n\tfloat l0 = (pow(0.5+ 0.5* cos(dist* PI* 2.* smallerDistance),10.0));\n\tfloat l1 = (pow(0.5+ 0.5* cos(dist* PI* 2.* largerDistance),10.0));\n\n\tfloat x = fract(log(idealGridDistance)/ log(10.));\n\tl0 = mix(l0,0.,smoothstep(0.5,1.0,x));\n\tl1 = mix(0.,l1,smoothstep(0.0,0.5,x));\n\n\tcol.rgb *= 0.1+ 0.9* (1.- l0)* (1.- l1);\n\treturn col;\n}\nvec4 mainImage_meter(vec2 fragCoord) {\n\tvec2 reso = iResolution.xy;\n\tvec2 screenCoord = (((2.0* fragCoord)- reso)/ iResolution.y);\n\tfloat camDolly = iMouse.z> 0.? iMouse.y/ iResolution.y: (.5)+ (.5)* sin(iTime* .5);\n\tfloat camRotation = iMouse.z> 0.? iMouse.x/ iResolution.x* PI* (2.)+ PI: (.2)* iTime;\n\tvec3 cam_pos = (vec3(0.0,1.0,1.4)* pow(10.,camDolly* 8.- 8.0));\n\tvec3 cam_dir = normalize(vec3(0.0,-0.8,-1.0));\n\tvec3 cam_up = normalize(vec3(0.0,1.0,-0.8));\n\tcam_up.xz = (pR(cam_up.xz,camRotation));\n\tcam_dir.xz = (pR(cam_dir.xz,camRotation));\n\tcam_pos.xz = (pR(cam_pos.xz,camRotation));\n\tfloat cam_fov = (45.);\n\tvec3 u = cross(cam_dir,cam_up);\n\tvec3 v = cam_up;\n\tvec3 w = -cam_dir;\n\tvec3 o = cam_pos;\n\tvec3 d = vec3(screenCoord,-1.0/ tan(radians(.5*cam_fov)));\n\td = normalize((mat3(u,v,w)* d));\n\tfloat t = INFINITY;\n\tif(d.y< 0.) {\n\t\tt = (o.y)/ -d.y;\n\t}\n\tvec3 p = ((d* t)+ o);\n\tfloat dist = f(p);\n\tvec3 col = distanceMeter(dist,t,d,cam_pos.y);\n\tcol = Uncharted2ToneMapping(col);\n\tvec4 fragColor = vec4(pow(col,vec3(1./ 2.2)),1);\n\treturn fragColor;\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor = mainImage_meter(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lySWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 597, 642, 642, 1433], [1435, 1526, 1589, 1589, 2202], [2736, 2752, 2777, 2777, 2803], [2804, 2804, 2838, 2838, 2858], [2859, 2903, 2947, 2947, 3044], [3045, 3083, 3109, 3109, 3154], [3155, 4854, 4894, 4894, 5676], [5677, 5677, 5696, 5696, 5987], [5988, 5988, 6054, 6054, 6130], [6131, 6131, 6157, 6157, 6187], [6188, 6188, 6214, 6214, 6298], [6299, 6299, 6309, 6309, 6487], [6488, 6488, 6505, 6505, 6517], [6518, 6518, 6535, 6535, 6547], [6548, 6548, 6614, 6614, 6661], [6662, 6662, 6688, 6688, 6707], [6708, 6708, 6734, 6734, 6753], [6754, 6754, 6771, 6771, 6784], [6785, 6785, 6802, 6802, 6815], [6817, 6817, 6827, 6827, 6835], [6837, 6837, 6912, 6912, 7071], [7072, 7072, 7110, 7110, 7130], [7131, 7131, 7144, 7144, 7258], [7260, 7344, 7373, 7373, 9939], [10240, 10259, 10276, 10276, 10307], [10309, 10352, 10392, 10392, 10737], [10739, 10739, 10761, 10890, 11001], [11002, 11002, 11027, 11042, 11112], [11114, 11114, 11193, 11514, 12234], [12235, 12235, 12273, 12273, 13288], [13289, 13289, 13341, 13341, 13384]], "test": "error"}
{"id": "4lyXDt", "name": "Ray Marching Shading Example2", "author": "yumcyawiz", "description": "this is the example code for my blog's articles.", "tags": ["raymarching"], "likes": 0, "viewed": 247, "published": "Public", "date": "1486338374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//primitives\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//distance field\nfloat df(vec3 p) {\n    float d = sdSphere(p, 1.5);\n    d = min(d, sdSphere(p + vec3(3.0*cos(iTime),  0, 3.0*sin(iTime)), 1.0));\n    d = min(d, sdBox(p + vec3(0, 2.0, 0), vec3(5.0, 0.1, 5.0)));\n    return d;\n}\n\n//calculate normal\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\treturn normalize(vec3(\n\t\tdf(p + vec3(eps, 0, 0)) - df(p + vec3(-eps, 0, 0)),\n\t\tdf(p + vec3(0, eps, 0)) - df(p + vec3(0, -eps, 0)),\n\t\tdf(p + vec3(0, 0, eps)) - df(p + vec3(0, 0, -eps))\n\t\t));\n}\n\n\nstruct Ray {\n    vec3 position;\n    vec3 rayDir;\n    int steps;\n    float t;\n};\n\n//it finds the intersection point and returns various data\nconst int maxSteps = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    vec3 p = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; i++) {\n        p = from + t*rayDir;\n        float d = df(p);\n        if(d < 0.001) {\n            steps = i;\n            break;\n        }\n        t += d/2.0;\n    }\n    return Ray(p, rayDir, steps, t);\n}\n\n\n//is point p visible from the light?\nbool isVisible(vec3 p, vec3 lightPos) {\n    Ray tr = trace(lightPos, normalize(p - lightPos));\n    if(distance(tr.position, p) < 0.01) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n//shading\nfloat kd = 0.7;\nvec3 cd = vec3(1.0);\n\nfloat ks = 0.3;\nvec3 cs = vec3(1.0);\nfloat alpha = 12.0;\n\nfloat ka = 1.0;\nvec3 ca = vec3(0.1, 0.2, 0.15);\nvec3 shading(Ray  tr, vec3 lightPos) {\n    vec3 p = tr.position;\n    vec3 normal = calcNormal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = -tr.rayDir;\n    vec3 r = reflect(-l, normal);\n    \n    //diffuse\n    vec3 Id = kd * max(dot(normal, l), 0.0) * cd;\n    \n    //specular\n    vec3 Is = ks * pow(max(dot(v, r), 0.0), alpha) * cs;\n    \n    //ambient\n    vec3 Ia = ka * ca;\n    \n    //visibility\n    if(isVisible(p, lightPos)) {\n        return Id + Is + Ia;\n    }\n    else {\n        return Ia;\n    }\n}\n\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(-1, -1) ~ (1, 1)\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    //camera settings\n    vec3 camPos = vec3(10.0*cos(iTime), 2, -10.0*sin(iTime));\n    vec3 camFront = normalize(-camPos);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camUp, camFront);\n    float focus = 1.0;\n    \n    //ray direction\n    vec3 rayDir = uv.x*camRight + uv.y*camUp + focus*camFront;\n    \n    //trace\n    Ray tr = trace(camPos, rayDir);\n    \n    //light position\n\tvec3 lightPos = vec3(5, 5, 5);\n    \n    //coloring\n    vec3 color = shading(tr, lightPos);\n    \n    //clipping with fog effect\n    if(tr.t > 20.0) {\n        color = color/(tr.t - 20.0);\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 46, 46, 74], [75, 75, 104, 104, 195], [197, 214, 232, 232, 422], [424, 443, 468, 468, 681], [765, 850, 885, 885, 1180], [1183, 1220, 1259, 1259, 1424], [1426, 1580, 1618, 1618, 2090], [2093, 2100, 2157, 2181, 2869]], "test": "valid"}
{"id": "4lyXW3", "name": "For Facebook guy", "author": "gilesruscoe", "description": "RGB offset", "tags": ["circlergb"], "likes": 3, "viewed": 172, "published": "Public", "date": "1486074281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Resolution stuffs\n\tvec2 uv = fragCoord.xy / min(iResolution.x,iResolution.y);\n    uv.x -= 0.4;\n    //offset UV's to the centered\n    vec2 uvCent = uv * 2.0 - 1.0;\n    float Pi = 3.141592;\n    //basically a circle (length(uvCent), but with added wave using sin(radians + time)\n    //Use different wave for each colour channel to create colour shift effect\n    //This could be anything, not just a sinwave, like a scrolling texture for example.\n    float circleR = step(length(uvCent + sin(iTime + atan(uvCent.y, uvCent.x) * 19.97) * 0.013), 0.9);\n    float circleG = step(length(uvCent + sin(iTime - atan(uvCent.y, uvCent.x) * 26.23) * 0.031), 0.9);\n    float circleB = step(length(uvCent + sin(iTime + atan(uvCent.y, uvCent.x) * 22.62) * 0.0552), 0.9);\n    //return comped circles and invert it (for black circle on white bg)\n    vec4 RGBCircle = vec4(1.0) - vec4(circleR, circleG, circleB, 1.0); \n\tfragColor = RGBCircle;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 987]], "test": "valid"}
{"id": "4sfczM", "name": "IWC Raymarching demo", "author": "tamassanta", "description": "Features:\n- Raymarching\n- object transformation based on real-time audio channel\n- 2 type of primitive distance field calculation (box, sphere)\n- volumetric fog effect\n- camera movement (sample animation using iGlobelTime)\n- vigneting", "tags": ["raymarching", "tutorial", "iwc"], "likes": 0, "viewed": 187, "published": "Public", "date": "1487360539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\n// ------ FEATURE DEFINITIONS -------\n// coloring & movement - hint: try max distance here!\nconst bool f_coloring_iteration = true;\nconst bool f_camera_movement \t= true;\nconst bool f_sphere_audio \t\t= true;\n\n// eye candies & post processing\nconst bool f_volumetric_fog \t= true;\nconst bool f_smooth_merge \t\t= true;\nconst bool f_vigneting \t\t\t= true;\n\n\n// ------ CONSTANTS -------\nconst float focalLength = 1.9; \t\t\t\t// Distance between the eye and the image plane\nconst int \trmSteps \t= 64; \t\t\t\t// Max raymarch steps\nconst float rmEpsilon \t= 0.001; \t\t\t// Surface threshold\nconst vec4 \tskyColor \t= vec4(1.0);\nconst vec3 \teye \t\t= vec3(0, 0, -2.5); // eye vector - normalised\nconst vec3 \tcamUp \t\t= vec3(0, 1, 0);\t// up vector - normalised\nconst vec3 \tcamRight \t= vec3(1, 0, 0);\t// right vector - normalised\nconst float fogDistance = 2.7;\t\t\t\t// fog fade out distance\n\n// smooth minimum function - credit goes to Iq\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// sphere distance field calculation\nfloat distSphere(vec3 p, float radius)\n{\n    float freq = (f_sphere_audio) ? texture( iChannel0, vec2( 0.01, 0.2 ) ).x * 1.1 : 1.0;    \n  \treturn length(p) - clamp(0.2, 1.0, radius * freq);\n}\n\n// returns the max component of the input vector (x, y or z)\nfloat maxcomp(in vec3 p ) {\n    return max(p.x,max(p.y,p.z));\n}\n\n// signed box primitive distance field calculation\n// b.x = Width\n// b.y = Height\n// b.z = Depth\n// Leave r=0 if radius not needed\nfloat distBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return min(maxcomp(d),0.0) - r + length(max(d,0.0));\n}\n\nfloat getDistanceOfNearestObject(vec3 point)\n{\n\t// calculate distances from the objects\n    float dSphere = distSphere(point, 0.6);  \n    float dBox = distBox(point, vec3(0.47,0.47,0.47), 0.05);    \n    float minDist = min(dSphere, dBox);\n    \n    // get the minimum distance from our objects   \n    return (f_smooth_merge) ? min(smin(dSphere, dBox, 32.0), minDist) : minDist;\n}\n\nvec4 getObjectColor(int iterationCount)\n{\n    float redChannel = (f_coloring_iteration) ? 1.0 / float(iterationCount) * 1.5 : 1.0;\n    return vec4(redChannel, 0.1,0.2, 1);\n}\n\nvec4 applyFog(vec4 color, float distFromEye)\n{\n    if(distFromEye > fogDistance && f_volumetric_fog)\n    {\n        return mix(color, \n                   vec4(1.0,1.0,1.0,1.0), \n                   clamp(0.0,1.0,distFromEye - fogDistance));\n    }\n\n    return color;\n}\n\nvec4 applyVignette(vec4 color, vec2 fragCoord)\n{\n    if(f_vigneting)\n    {\n\t\tvec2 q = fragCoord.xy/iResolution.xy;\n    \tcolor *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2);\n    }\n    \n    return color;\n}\n\n\nvec4 RayTrace(in vec2 fragCoord)\n{    \n    // forward vector from camera\n    vec3 camForward = cross(camRight, camUp);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // map the fragment coordinates to the 3D (UV) coordinate system\n    float u = fragCoord.x * 2.0 / iResolution.x - 1.0;\n    float v = fragCoord.y * 2.0 / iResolution.y - 1.0;   \n    float rotX, rotZ = 0.0;\n    \n    if(f_camera_movement)\n    {\n    \tfloat nRotate = iTime * 0.1; // slow rotation  \n    \trotX = cos(PI * nRotate);\n    \trotZ = sin(PI * nRotate);\n    }\n    \n    // Cast a ray from the eye through the pixel (using focal length)\n    vec3 rayOrigin = vec3(eye.x + rotX, eye.y, eye.z + rotZ);\n    vec3 rayDirection = normalize(camForward * focalLength + camRight * u * aspectRatio + camUp * v);;\n    \n    // set default color, this will be rendered if the ray doesn't hit anything\n    vec4 color = skyColor;\n    \n    // Raymarching starts here\n    float distFromEye = 0.0;\n    for(int i = 0; i < rmSteps; ++i)\n    {\n        // define current point on the ray\n        vec3 p = rayOrigin + rayDirection * distFromEye;      \n        float d = getDistanceOfNearestObject(p);     \n        \n        // if the point is close _enough_ to the object surface, render the object\n        if(d < rmEpsilon)\n        {\n            // render the object color - we use only one color here\n            color = getObjectColor(i);\n            color = applyFog(color, distFromEye);\n            break;\n        }\n\n        distFromEye += d;   \n    }\n\n    return color;\n}\n\n// the entry point of the shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = RayTrace(fragCoord);   \n    fragColor = applyVignette(color, fragCoord);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[883, 930, 971, 971, 1042], [1044, 1081, 1121, 1121, 1272], [1274, 1335, 1362, 1362, 1398], [1400, 1531, 1571, 1571, 1655], [1657, 1657, 1703, 1744, 2035], [2037, 2037, 2078, 2078, 2210], [2212, 2212, 2258, 2258, 2477], [2479, 2479, 2527, 2527, 2706], [2709, 2709, 2743, 2781, 4251], [4253, 4286, 4343, 4343, 4435]], "test": "error"}
{"id": "4sfczN", "name": "Julia Revolute 2", "author": "aiekick", "description": "Julia Revolute 2", "tags": ["julia", "2", "revolute"], "likes": 32, "viewed": 1093, "published": "Public API", "date": "1487190259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<30.;i++)\n    {\n        if (i>7.8) break;\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*0.5 +  iTime * 0.5; // axis y\n    \n    vec2 rev = vec2(length(p.xz),p.y) - 1.52;\n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a)); // rot near axis y\n\t\n\tvec2 res = vec2(100);\n\t\n\tfloat ftus = fractus(rev, vec2(-0.3,-0.649));\n\t\n\tfloat thickStep = 0.12;\n\t\n\tfor (int i =0;i <5;i++)\n\t{\n\t\tfloat lay = max(ftus, -ftus - thickStep * float(i+1)); // change only the interior thickness\n\t\tif (lay < res.x)\n\t\t\tres = vec2(lay, float(i));\n\t}\n\t\n\tvec2 q = p.xz;\n\tfloat a0 = mix(0.,1.57,res.y/5. * mix(-.1,.1,sin(iTime * 0.5)*.5+.5));\n\tq *= mat2(cos(a0),-sin(a0),sin(a0),cos(a0));\n\t\n\tvec2 cut = vec2(q.y, 10);\n\tif (cut.x > res.x)\n\t\tres = cut;\n\t\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,12);\n\t\t\n\treturn res;\n\t\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = 3.14159*0.5;\n\t\n\tvec2 camp = vec2(643./958.,356./816.) * 5.;\n\t\n\tvec3 rayOrg = vec3(cos(t),sin(camp.y),sin(t)) * camp.x;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.5,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.0001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (abs(s) < d*d*1e-5 || d>dMax) break; // thanks to iq for the simpler form of the condition\n\t\ts = df(p).x;\n\t\td += s * 0.3;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.01178);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\tfloat r = mod( floor(5.0*p.z) + floor(5.0*p.x), 2.0);\n        fragColor.rgb = 0.4 + 0.1*r*vec3(1.0);\n\n        // iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.4).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfczN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 206, 230, 230, 313], [315, 315, 346, 346, 613], [615, 615, 632, 632, 1372], [1374, 1374, 1406, 1406, 1584], [1586, 1602, 1676, 1676, 1915], [1917, 1933, 1975, 1975, 2274], [2276, 2471, 2528, 2528, 2816], [2818, 2818, 2875, 2875, 4607]], "test": "valid"}
{"id": "4sfyWn", "name": "heatmap1", "author": "listenheart", "description": "绘制热力图的过程", "tags": ["heatmap"], "likes": 1, "viewed": 166, "published": "Public", "date": "1487597517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Gradient stolen from https://www.shadertoy.com/view/ltlSRj\nvec3 colors [5];\nfloat points [5];\n\nvoid initia(){\n    colors[0]=vec3(0.,0.,0.6);\n    colors[1]=vec3(0.,1.,1.);\n    colors[2]=vec3(0.0,1.0,0.);\n    colors[3]=vec3(1.0,1.0,0.);\n    colors[4]=vec3(1.0,0.0,0.);\n    points[0]=0.;\n    points[1]=0.15;\n    points[2]=0.5;\n    points[3]=0.65;\n    points[4]=1.0;\n}\nvec3 gradian(vec3 c1,vec3 c2,float a){\n    return vec3(c1.x+a*(c2.x-c1.x),\n                c1.y+a*(c2.y-c1.y),\n                c1.z+a*(c2.z-c1.z));\n}\n\nvec3 heat4(float weight){\n    if(weight<=points[0]){\n        return colors[0];\n    }\n    if(weight>=points[4]){\n        return colors[4];\n    }\n    for(int i=1;i<5;i++){\n        if(weight<points[i]){\n           float a=(weight-points[i-1])/(points[i]-points[i-1]);\n            return gradian(colors[i-1],colors[i],a);\n        }\n    }\n}\n\n\nfloat d(vec2 a, vec2 b) {\n   return  pow(max(0.0, 1.0 - distance(a, b) / (0.6)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initia();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 4.0 - vec2(2.0);\n   uv.x *= iResolution.x / iResolution.y;\n    \n    float totalWeight = 0.0;\n    for (float i = 0.0; i < 112.0; ++i) {\n        //计算每个坐标点的权重\n    \ttotalWeight += 0.5*d(uv, vec2(\n            sin(1.0*iTime * 0.3 + float(i))*2. + 2.*sin(i * i), \n            cos(1.0*iTime * 0.4 + float(i *1.5))*2.\n        ));\n    }\n    \n    \n\tfragColor = vec4(heat4(totalWeight), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 112, 112, 367], [368, 368, 406, 406, 517], [519, 519, 544, 544, 854], [857, 857, 882, 882, 945], [947, 947, 1004, 1004, 1477]], "test": "error"}
{"id": "4sfyzN", "name": "Residual Background Radiation?", "author": "marquizzo", "description": "Learned how to make my own cellular noise function, thanks to The Book of Shaders. \nAlso a fan of Contact, so I made this in honor of Ellie Arroway. \nClick and drag for parallax effect.", "tags": ["2d", "noise", "random", "cell"], "likes": 21, "viewed": 605, "published": "Public", "date": "1487186596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define PI 3.14159265\n#define OCTAVES 4.0\n\n// Color transform from HSB to RGB\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a){\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// Hash without sine from:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Cell noise learned from:\n// https://thebookofshaders.com/12/\nfloat cell(vec2 x, float t){\n\tvec2 iPos = floor(x); // Cell integer position\n\tvec2 fPos = fract(x); // Cell fraction position\n\tfloat minDist1 = 2.0; // Stores minimum distance\n\n\t// Calculate neighboring cells\n\tfor(int y = -1; y <= 1; y ++){\n\t\tfor(int x = -1; x <= 1; x ++){\n\t\t\tvec2 neighborCell = vec2(x, y);\n\t\t\tvec2 randPoint = hash22(iPos + neighborCell);\n\t\t\t\n\t\t\t// Animate point\n\t\t\trandPoint = 0.5 + sin(t + randPoint * 2.0 * PI) * 0.5;\n\n\t\t\tvec2 fPosToPoint = neighborCell + randPoint - fPos;\n\n\t\t\t// Pick distance algorithm\n\t\t\tfloat dist = length(fPosToPoint);\t// Euclidean\n\t\t\t// float dist = max(abs(fPosToPoint.x), abs(fPosToPoint.y));\t// Chebyshev\n\t\t\t// float dist = abs(fPosToPoint.x) + abs(fPosToPoint.y);\t\t// Manhattan\n\t\t\t\n\t\t\t// Keep smallest distance\n\t\t\tminDist1 = min(dist, minDist1);\n\t\t}\n\t}\n\n\treturn minDist1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// Screen position\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t// Mouse position\n\tvec2 m = 1.0 - vec2(iMouse.xy / iResolution.xy);\n\n\t// Adjust view ratio + rotation\n\tvec2 pos = vec2(p.x * iResolution.x / iResolution.y, p.y);\n\tpos = rotate(pos, (m.x + m.y) * 0.1);\n\n\t// Store cell noise in brighness\n\tfloat brightness = 0.0;\n    \n    // Calculate cell noise\n\tfor(float i = 1.0; i <= OCTAVES; i++){\n\t\tbrightness += cell(pos - (m * 8.0), iTime * 0.5 * i) / i;\n\t\tpos *= OCTAVES;\n\t}\n\n\t// Square for contrast\n\tbrightness *= brightness;\n\t\n\tfloat hue = distance(p, m) * 0.2 + 0.5;\n\tfragColor = vec4(hsb2rgb(vec3(hue, 0.5, brightness)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 129, 155, 155, 333], [335, 366, 395, 395, 469], [471, 539, 559, 559, 677], [679, 743, 771, 771, 1566], [1568, 1568, 1624, 1644, 2259]], "test": "valid"}
{"id": "4slyRH", "name": "Hearts", "author": "monkeyscience", "description": "A heart shader.", "tags": ["barf"], "likes": 3, "viewed": 103, "published": "Public", "date": "1487032630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float point(vec2 base, float x, float y, float grid) {\n    float f = mod(base.x + x, grid) * mod(base.y + y, grid);\n    return 1.0 - min(1.0,f);\n}\n\nvec4 heart(vec2 fragCoord, float time, float spread) {\n\tvec4 result = vec4(0.0,0.0,0.0,0.0);\n\tvec2 base = fragCoord.xy;\n    \n    float invSpread = 1.0 / spread;\n    float halfSpread = spread * 0.5;\n    \n    float everyOther = floor(base.y * invSpread);\n    base.x += everyOther * halfSpread;\n        \n    float t = iTime;\n    t += 0.5 * everyOther;\n    t += 0.25 * floor((base.x + halfSpread) * invSpread);\n    t += 0.25 * floor((base.x + halfSpread) * invSpread);\n    float frame = 1.0;\n    \n    base.x += floor(0.5 * halfSpread * sin(t) + 0.5);\n    \n    frame = mod(t*4.0, 4.0);\n    frame = min(1.0, (frame));\n    \n    result.r += frame * point(base,  0.0,\t0.0,\tspread);\n    result.r += frame * point(base,  1.0,\t-1.0,\tspread);\n    result.r += frame * point(base, -1.0,\t-1.0,\tspread);\n    \n    frame = mod(t*3.0, 3.0);\n    frame = min(1.0, (frame));\n    \n    result.r += frame * point(base,  0.0,\t-1.0,\tspread);\n    result.r += frame * point(base,  1.0,\t-2.0,\tspread);\n    result.r += frame * point(base, -1.0,\t-2.0,\tspread);    \n    result.r += frame * point(base,  2.0,\t-2.0,\tspread);\n    result.r += frame * point(base, -2.0,\t-2.0,\tspread);\n    \n    frame = mod(t*2.0, 2.0);\n    frame = min(1.0, (frame));\n    \n    result.r += frame * point(base,  0.0,\t-2.0,\tspread);\n    result.r += frame * point(base,  1.0,\t-3.0,\tspread);\n    result.r += frame * point(base, -1.0,\t-3.0,\tspread);    \n    result.r += frame * point(base,  2.0,\t-3.0,\tspread);\n    result.r += frame * point(base, -2.0,\t-3.0,\tspread);\n    \n    result.r = min(1.0,result.r);\n    result.b = 0.25*result.r;\n    \n    frame = mod(t*2.5, 2.5);\n    frame = min(1.0, (frame));\n    frame *= 0.5;\n    result.b += frame * point(base,  0.0,\t-1.0,\tspread);\n    result.b += frame * point(base,  0.0,\t-2.0,\tspread);\n    result.b += frame * point(base,  1.0,\t-2.0,\tspread);\n    result.b += frame * point(base, -1.0,\t-2.0,\tspread);\n    result.a = min(1.0,result.r);\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = heart(fragCoord, iTime, 20.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 146], [148, 148, 202, 202, 2092], [2094, 2094, 2151, 2151, 2239]], "test": "valid"}
{"id": "4sscDn", "name": "Z-curve / Morton code", "author": "FabriceNeyret2", "description": "Among others, Z-curves are use in texture encoding, so that near (x,y) pixels are mapped in close memory location (as progressively drawn on top right).", "tags": ["zcurve", "mortoncode"], "likes": 9, "viewed": 1159, "published": "Public API", "date": "1487703010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Z-curve / Morton code\n// refs : https://en.wikipedia.org/wiki/Z-order_curve\n//        https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n\nint xy2z(vec2 U) {       // --- grid location to curve index\n    ivec2 I = ivec2(U);\n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n\nivec2 z2xy(int z) {      // --- curve index to grid location \n    int n=1;\n    ivec2 I = ivec2(z,z>>1) & MASKS[0];\n    for (int i=1; i<=4; i++)\n        I = (I | (I >>  n)) & MASKS[i],\n        n *= 2;\n    return I;\n}\n\n\n    \nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U /= 2.;\n    float R = exp2(floor(log2(iResolution.y/2.)));\n    O = max(U.x,U.y) < R ? vec4(U/R, .5,0) : vec4(0);\n    \n    int Z = xy2z(U);\n    \n // O = vec4( Z ) / R/R;               // display Z-index\n // O = vec4( z2xy(Z),0,0)/ R;         // pos from Z\n // O = vec4(ivec2(U)== z2xy(iFrame)); // browse index on Z-curve.\n    \n    if (Z < iFrame) O = vec4(Z)/float(iFrame); // * vec4(U,0,0)/R;\n    \n    if (fract(U.y)==.75) return;\n    U = iResolution.xy/2.-ceil(U);\n    if ( U.x < R) {\n        Z = int(U.x+R*U.y);\n        if (Z < iFrame ) O = fract(vec4(z2xy(Z),R/2.,0)/R);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sscDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 237, 255, 297, 450], [452, 452, 471, 513, 667], [675, 675, 714, 714, 1302]], "test": "error"}
{"id": "4sscz8", "name": "Voronoi Layers", "author": "ptrgags", "description": "Two layer Voronoi diagram", "tags": ["2d", "voronoi", "layers", "twolayeer"], "likes": 2, "viewed": 130, "published": "Public", "date": "1487120499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TILES 4.0\n#define INNER_TILES 10.0\n\nvec2 hash2(vec2 p) {\n    return fract(sin(vec2(\n        dot(p, vec2(127.0, 311.0)),\n        dot(p, vec2(269.0, 181.0) * 43759.0))));\n}\n\n//Create a voronoi distance field. Distances are to the nearest\n//seed point\nfloat voronoi(vec2 uv, float num_tiles) {\n    //Tile space\n    vec2 cell = floor(num_tiles * uv);\n    vec2 cell_uv = fract(num_tiles * uv);\n    \n    //Voronoi Level 1\n    float min_dist = 10000.0;\n    //Look at neighboring boxes only\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            //Find the random point in the neighbor box\n            vec2 offset = vec2(float(x), float(y));\n            vec2 neighbor_point = hash2(cell + offset);\n            neighbor_point = 0.5 + 0.5 * sin(45.0 * neighbor_point + iTime);\n            \n            //distance between pixel and neighbor center)\n            float dist = distance(offset + neighbor_point, cell_uv);\n            min_dist = min(dist, min_dist);\n        }\n    }\n    return min_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    fragColor += voronoi(uv, 10.0) * vec4(0.0, 0.5, 1.0, 1.0);\n    fragColor += voronoi(uv, 3.0) * vec4(1.0, 0.5, 0.0, 0.5);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sscz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 64, 64, 178], [180, 257, 298, 315, 1030], [1032, 1032, 1089, 1089, 1267]], "test": "valid"}
{"id": "4ssGWS", "name": "metal meta thing", "author": "Kecho", "description": "your typical SDF.", "tags": ["raymarchingfun"], "likes": 3, "viewed": 739, "published": "Public", "date": "1486230228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Kleber Garcia (c) 2017\n\nconst float EPSILON = 0.001;\nconst vec3 AMBIENT = vec3(0.6, 0.4, 0.3);\nvec3 gDirLight1 = normalize(vec3(-0.1, 0.2, -1));\nvec3 gLightPos1 = vec3(-1, 1, -8);\n\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define NORMOBJ(o,p) normalize(vec3(o(p.xyz + dif.xyy)-o(p.xyz - dif.xyy),o(p.xyz + dif.yxy)-o(p.xyz - dif.yxy),o(p.xyz+dif.yyx)-o(p.xyz-dif.yyx)))\n#define PI 3.14159265359\n#define HALF_PI (PI / 2.0)\nvec4 SPHERE1 = vec4(0, 0, 3, 2.5); //xyz pos, w radius\nfloat genericSphere(vec3 pos, vec4 sphere)\n{\n\treturn length(sphere.xyz - pos) - sphere.w;\n}\n\nfloat sphere1(vec3 pos)\n{\n\treturn genericSphere(pos, SPHERE1);\n}\n\nvec2 getSphereUv(const in vec3 pos, const vec3 center, vec3 norm)\n{\n\tvec3 dir = normalize(pos - center);\n\tvec2 orz = normalize(dir.xz);\n\tfloat sigmaU = 1.0 - (acos(orz.x) / PI);//optimize arccos with fast impl!!!\n\tfloat thetaV = acos(dir.y) / PI;\n\tfloat u = sigmaU * 0.5 + 0.5;\n\tfloat v = thetaV * 0.5 + 0.5;\n\treturn vec2(u, v);\n}\n\n\nvec2 scene(vec3 pos, out vec3 intersectP)\n{\n\n    intersectP = pos + vec3(sin(pos.y + iTime),0,0);\n    intersectP.y += 0.3*sin(pos.x + iTime);\n    intersectP.x -= 0.5*cos(4.0*(pos.y + iTime));\n    intersectP.y -= 0.5*cos(2.5+2.3*(pos.x + 3.0*iTime));    \n    intersectP.y -= 0.5*sin(0.8+pos.x + 2.0*iTime);\n    intersectP.z += 0.1*sin(0.9+pos.x + 1.35*iTime);\n    intersectP.x -= 0.2*cos(1.9+0.2*pos.y + 1.4*iTime);    \n    intersectP.x += 0.5*sin(1.9+4.2*pos.y + 0.3*iTime);\n    intersectP.y += 0.2*cos(2.5+0.7*pos.y + 0.32*iTime);\n    intersectP.x += 0.2*sin(4.6+6.5*pos.y + 1.45*iTime);\n    intersectP.x -= 0.1*cos(1.9+0.6*pos.y + 0.6*iTime);\n        \n\n\tfloat s1 = sphere1(intersectP);\n\tfloat d = s1;\n\tfloat matId = 1.0;\n\treturn vec2(d, matId);\n}\n\nvec2 raymarch(const in vec3 camPos, const in vec3 rayDir, out vec3 posOut, out vec3 pp)\n{\n\tvec2 d = vec2(1000.0, 0.0);\n\tvec3 pos = camPos;\n    vec3 intersectP = vec3(0,0,0);\n\tfor (int i = 0; i < 80; ++i)\n\t{\n\t\tif (d.x < EPSILON)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n        \n\t\td = scene(pos, intersectP);\n        pp = \n\t\tpos += d.x*rayDir;\n\t}\n\tposOut = intersectP;\n\treturn d;\n}\n\n\n\nvec3 norm(vec3 pos, float matId)\n{\n\tvec3 n = vec3(0,0,0);\n\tvec2 dif = vec2(EPSILON, 0.0);\n\tn = NORMOBJ(sphere1, pos);\t\n\t\n\treturn n;\n}\n\nvec3 material(float matId, vec3 normal, vec3 posOut, out vec3 normOut, out vec3 specTint)\n{\n\tvec3 col = vec3(1,1,1);\n\tspecTint = vec3(1,1,1);\n\tnormOut = normal;\n\tif (matId == 1.0)\n\t{\n\t\tvec2 uv = getSphereUv(posOut, SPHERE1.xyz, normal);\n\t\tcol = vec3(0.2,0.5,0.3) ;\n\t\tspecTint = vec3(0.5, 0.6, 0.2);\n\t\tnormOut.x += 0.2 * sin(uv.y*uv.x * 150.0) - 0.3 * cos(uv.y * 150.0);\n\t\tnormOut.y += 0.4 * sin(uv.x*uv.y * 250.0) + 0.3 * cos(uv.x * 150.0);\n\n\t\tnormOut = normalize(normOut);\n\t\tvec2 newUv = uv.xy + 0.001*normOut.xy;\n\t\t\n\t\t\n\t\tvec2 muls = abs(vec2(1, 1) - 900.0*abs(vec2(mod(newUv.x, 0.003) - 0.0002, mod(newUv.y, 0.003) - 0.0002)));// , );\n\t\tnormOut.xy -= 0.3 * muls;\n\t\tnormOut = normalize(normOut);\n\t\t\n\t}\n\telse if (matId == 2.0)\n\t{\n\t\tcol = vec3(1,1,1);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfloat gAspect = iResolution.x / iResolution.y;    \n\tvec2 gMouseHomogeneous = 4.0*((iMouse.xy / iResolution.xy) * 2.0 - 1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 homogeneousPos = vec3(uv * 2.0 - 1.0, 0.0);\n\thomogeneousPos.x *= gAspect;\n\tvec3 camPos = vec3(0, 0, -1);\n\tvec3 camPivot = vec3(0, 0, 3);\n\tvec3 seeDir = normalize(camPos - camPivot);\n\tvec3 screenDir = normalize(homogeneousPos - camPivot);\n\tfloat initAngle =  (HALF_PI / 150.0) * (sin(iTime * 2.7));\n\tfloat initAngleVet =  (HALF_PI / 150.0) * (cos(iTime * 3.0));\n\tfloat angle = HALF_PI + initAngle + (-gMouseHomogeneous.x) * 0.1;//(iTime * 0.9);\n\tfloat angleVert = HALF_PI + initAngleVet + (-gMouseHomogeneous.y) * 0.1;//(iTime * 0.9);;\n\t\n\tvec2 cosSinAngle = vec2(sin(angle), cos(angle));\n\tvec2 cosSinAngleVert = vec2(sin(angleVert), cos(angleVert));\n\t\n\tseeDir.xz = vec2( dot( seeDir.xz, cosSinAngle.xy ), dot( seeDir.xz, vec2(-cosSinAngle.y, cosSinAngle.x) ) );\n\tscreenDir.xz = vec2( dot( screenDir.xz, cosSinAngle.xy ), dot( screenDir.xz, vec2(-cosSinAngle.y, cosSinAngle.x) ) );\n\t\n\tseeDir.yz = vec2( dot( seeDir.yz, cosSinAngleVert.xy ), dot( seeDir.yz, vec2(-cosSinAngleVert.y, cosSinAngleVert.x) ) );\n\tscreenDir.yz = vec2( dot( screenDir.yz, cosSinAngleVert.xy ), dot( screenDir.yz, vec2(-cosSinAngleVert.y, cosSinAngleVert.x) ) );\n\t\n\t\n\tcamPos = seeDir * length(camPos - camPivot) + camPivot;\n\thomogeneousPos = screenDir * length(homogeneousPos - camPivot) + camPivot;\n\t\n\t\n\t\n\tvec3 rayDir = normalize(homogeneousPos - camPos);\n\tvec3 finalCol = 2.9*vec3(vec3(1.0 - uv.y) * 0.3) * vec3(0.7,0.7,0.8);\n\tvec3 posOut; vec3 pp;\n\tvec2 d = raymarch(camPos, rayDir, posOut, pp);\n\tif (d.x < EPSILON )\n\t{\n\t\tvec3 lightDir = normalize(gLightPos1 - posOut);\n\t\tvec3 n = norm(pp, d.y);\n\t\tvec3 normOut = vec3(0,0,0);\n\t\tvec3 specTint = vec3(0,0,0);\n\t\tvec3 col = material(d.y, n, pp, normOut, specTint);\n\t\tvec3 viewVec = normalize(camPos - posOut);\n\t\tfloat diff = max(dot(normOut, lightDir), 0.0);\n\t\tvec3 h = normalize(normOut + viewVec);\n\t\tvec3 spec = 1.0*pow(max(dot(h, lightDir), 0.0), 64.0)*specTint;\n\t\tvec3 fresnel = 0.08*vec3(pow(max(1.0-dot(viewVec, normOut), 0.0),8.0))*specTint;\n        \n\t\tfinalCol =  col*(diff + AMBIENT) + spec + fresnel ;\t\t\n\t}\n\t\n\tfragColor = vec4(pow(finalCol,vec3(2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 478, 522, 522, 569], [571, 571, 596, 596, 635], [637, 637, 704, 704, 967], [970, 970, 1013, 1013, 1718], [1720, 1720, 1809, 1809, 2080], [2084, 2084, 2118, 2118, 2217], [2219, 2219, 2310, 2310, 2989], [2991, 2991, 3048, 3048, 5323]], "test": "error"}
{"id": "4ssyz8", "name": "crazy spheres", "author": "LC", "description": "I am testing", "tags": ["2d"], "likes": 0, "viewed": 71, "published": "Public", "date": "1487021157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool isInCircle(in vec2 v, in vec2 center, in float radius)\n{\n\treturn distance(v, center) < radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n\tfloat ratioWH = iResolution.x / iResolution.y;\n\t\n\tvec2 center1 = vec2(0.5*ratioWH + 0.2*cos(3.0*iTime), 0.5 + 0.2*sin(5.0*iTime));\n\t\n\tvec2 center2 = vec2(0.5*ratioWH - 0.2*cos(5.0*iTime), 0.5 - 0.2*sin(3.0*iTime));\n\t\n\tif(isInCircle(uv, center1, 0.05))\n\t\tfragColor += vec4(1,0,0,1);\n\t\n\tif(isInCircle(uv, center2, 0.05))\n\t\tfragColor += vec4(0,0,1,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 101], [103, 103, 160, 160, 555]], "test": "valid"}
{"id": "4sXcWn", "name": "tonemapping experiment", "author": "madcake", "description": "Made by Zevie\nhttps://www.shadertoy.com/view/lslGzl\n\nI added two tonemapping algorithms that I came up with\n(bottom ones)\nsoon i realized i could fit the reinhard curve to match log curve by adjusting coefficients so it's kinda pointless)", "tags": ["tonemapping"], "likes": 7, "viewed": 449, "published": "Public", "date": "1487599882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n \nThis shader experiments the effect of different tone mapping operators.\nThis is still a work in progress.\n \nMore info:\nhttp://slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\nhttp://filmicgames.com/archives/75\nhttp://filmicgames.com/archives/183\nhttp://filmicgames.com/archives/190\nhttp://imdoingitwrong.wordpress.com/2010/08/19/why-reinhard-desaturates-my-blacks-3/\nhttp://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/\nhttp://renderwonk.com/publications/s2010-color-course/\n \n--\nZavie\n \n*/\n \nfloat gamma = 2.2;\n \nvec3 getBaseColor(int i)\n{\n    if (i == 0) return vec3(1.0, 0.4, 0.2);\n    if (i == 1) return vec3(0.4, 1.0, 0.2);\n    if (i == 2) return vec3(0.2, 1.0, 0.4);\n    if (i == 3) return vec3(0.2, 0.4, 1.0);\n    if (i == 4) return vec3(0.4, 0.2, 1.0);\n    if (i == 5) return vec3(1.0, 0.2, 0.4);\n \n    return vec3(1.);\n}\n \nvec3 getBaseColor()\n{\n    float colorPerSecond = 0.5;\n    int i = int(mod(colorPerSecond * iTime, 7.));\n    int j = int(mod(float(i) + 1., 7.));\n \n    return mix(getBaseColor(i), getBaseColor(j), fract(colorPerSecond * iTime));\n}\n \nvec3 linearToneMapping(vec3 color)\n{\n    float exposure = 1.;\n    color = clamp(exposure * color, 0., 1.);\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 simpleReinhardToneMapping(vec3 color)\n{\n    float exposure = 1.5;\n    color *= exposure/(1. + color / exposure);\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float toneMappedLuma = luma / (1. + luma);\n    color *= toneMappedLuma / luma;\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n    float white = 2.;\n    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n    color *= toneMappedLuma / luma;\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 filmicToneMapping(vec3 color)\n{\n    color = max(vec3(0.), color - vec3(0.004));\n    color = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n \nvec3 Uncharted2ToneMapping(vec3 color)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n    float exposure = 2.;\n    color *= exposure;\n    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n    float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n    color /= white;\n    color = pow(color, vec3(1. / gamma));\n    return color;\n}\n \nvec3 logToneMap(vec3 c){\n    \n    // in my experience limit=2.2 and contrast=0.35 gives nice result\n    // i prefer to leave a lot of highlights\n    // also log curve fades to highlights beautifully\n    // however i raised this parameters to make it look\n    // somewhat identical to other algorithms here\n    \n    // according to my information the dynamic range of\n    // human eye's light perception is around\n    // 2.5 of what monitor can provide\n    // though it's hightly questionable in terms of\n    // both the data and my understanding of it\n    \n    // P.S.\n    // i noticed that applying inverse tonemap transformation to\n    // diffuse textures improves the final render a lot\n    \n    float limit = 2.5;\n    float contrast = 0.3;\n    \n    // do the tone mapping\n    \n    c = log(c + 1.0) / log(limit + 1.0);\n    \n    // clamping for hackyContrast because s_curve\n    // does not behave properly outside [0; 1]\n    // if you want to keep values outside [0; 1]\n    // for example for bloom post-effect\n    // you would need comething better than\n    // hackyContrast()\n    \n    c = clamp(c,0.0,1.0);\n    \n    // hacky contrast s_curve\n    // btw it's a freatapproximation for 1-cos(x*3.14)*0.5\n    \n    c = mix(c, c * c * (3.0 - 2.0 * c), contrast);\n    \n    // this creates pleasant hue shifting\n    // i amplified the effect to demonstrate it more clearly\n    // usually i use it very subtle\n    \n    c = pow(c, vec3(1.05,0.9,1));\n    \n    // gamma correction\n    \n    return pow(c, vec3(1. / gamma));\n}\n\nvec3 limitedPerChannelReinhard(vec3 c){\n    float limit = 4.0;\n    float contrast = 0.6;\n    \n    c *= (c / (limit*limit) + 1.) / (c + 1.);\n    \n    return pow(c, vec3(1. / gamma));\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = getBaseColor();\n \n    float n = 8.;\n    if (uv.x > 0.2)\n    {\n        if (uv.x < 0.6)\n            // blacks\n            color *= (2.5 * uv.x - 0.5);\n        else\n            // whites\n            color *= 15.*(2.5 * uv.x - 1.5) + 1.;\n \n        int i = int(n * (1. - uv.y));\n        if (i == 0) color = linearToneMapping(color);\n        if (i == 1) color = simpleReinhardToneMapping(color);\n        if (i == 2) color = whitePreservingLumaBasedReinhardToneMapping(color);\n        if (i == 3) color = RomBinDaHouseToneMapping(color);\n        if (i == 4) color = filmicToneMapping(color);\n        if (i == 5) color = Uncharted2ToneMapping(color);\n        \n  //below are the ones i added\n        \n     //you can tweak reinhard to look like this\n        if (i == 6) color = logToneMap(color); \n        \n        if (i == 7) color = limitedPerChannelReinhard(color);\n        \n    }\n \n    if (abs(fract(n * uv.y + 0.5) - 0.5) < 0.02)\n        color = vec3(0.);\n    \n   \tvec3 diffC = vec3(1,1,1) - clamp(color,0.0,1.0);\n    float diff = max(diffC.r, max(diffC.g, diffC.g));\n    // color = ((diff > 0.0) && (diff < 0.01)) ? vec3(0,0,0) : color;\n    // this will show tha point where color fades to white\n \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXcWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 549, 575, 575, 864], [867, 867, 888, 888, 1096], [1099, 1099, 1135, 1135, 1267], [1270, 1270, 1314, 1314, 1449], [1452, 1452, 1499, 1499, 1703], [1706, 1706, 1768, 1768, 2024], [2027, 2027, 2070, 2070, 2181], [2184, 2184, 2220, 2220, 2369], [2372, 2372, 2412, 2412, 2866], [2869, 2869, 2893, 3558, 4386], [4388, 4388, 4427, 4427, 4571], [4574, 4574, 4631, 4631, 5922]], "test": "valid"}
{"id": "4sXczN", "name": "Julia Revolute 1", "author": "aiekick", "description": "Julia Revolute", "tags": ["julia", "revolute"], "likes": 2, "viewed": 496, "published": "Public API", "date": "1487188400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvec3 mat = vec3(28,250,43)/255.;\t\t\t\t\t\t\t\t\t\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<20.;i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*0.5 + iTime * 0.5;\n    \n    vec2 rev = vec2(length(p.xz),p.y) - 1.7;\n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n\tfloat ftus = fractus(rev, vec2(-0.2,-0.688));\n\tvec2 res = vec2(ftus, 0);\n\t\n\tif (p.z > res.x)\n\t\tres = vec2(p.z, 1);\n\t\t\n\treturn res;\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec3 nor( vec3 p , vec3 e)\n{\n\treturn normalize(vec3(\t\t\t\t\t\t\t\t\t\t\t\n\t    df(p+e.xyy).x - df(p-e.xyy).x,\t\t\t\t\t\t\t\t\n\t    df(p+e.yxy).x - df(p-e.yxy).x,\t\t\t\t\t\t\t\t\n\t    df(p+e.yyx).x - df(p-e.yyx).x ));\t\t\t\t\t\t\t\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,vec3( 0.0001, 0, 0)); \t\t\t\t\t\t\t\n\treturn df(p - n * s).x/s;\t\t\t\t\t\t\t\t\t\t\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\n\tvec3 n = nor(p, vec3( 0.0001, 0, 0));\t\t\t\t\t\t\t\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t\n\tfloat amb = 0.132; \t\t\t\t\t\t\t\t\t\t\t\t\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t\n\tfloat sss = 1. - SubDensity(p, 1.); \t\t\t\t\t\t\t\n\treturn vec2(\n        (diff + fre + spe) * amb * li, \t\t\t\t\t\t\t\t\n        (diff + fre + sss) * amb * li + spe \t\t\t\t\t\t\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = 1.57;\n\t\n\tvec2 camp = vec2(.74,.55) * 5.;\n\tvec3 rayOrg = vec3(cos(t),sin(camp.y),sin(t)) * camp.x;\n\tvec3 lpi = vec3(-cos(t),sin(camp.y),-sin(t)) * camp.x;\n\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.76,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\t\n\tfor (float i=0.; i<150.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>s || d>dMax) break;\n\t\ts = df(p).x;\n\t\td += s * 0.2;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    if (d<dMax)\n\t{\n\t\tvec3 p = rayOrg + rayDir * d;\n\t\tfloat m = df(p).y;\n\t\tif (m < 0.5)\n\t\t{\n\t\t\tvec3 n = nor(p, vec3( 0.1, 0, 0));\t\n\t\t\tfragColor.rgb = GetSky(reflect(n,rayDir), ld, vec3(50)) * .2 + vec3(73,28,94)/255. * .8;\n\t\t}\n\t\telse if (m < 1.5)\n\t\t{\n\t\t\tfragColor.rgb = mix(\n\t\t\t\tshade(p, rayDir, 1., lpi, 5.).y * mat, \t\t\t\t\t\t\n\t\t\t\tshade(rayOrg, rayDir, d, rayOrg, 1.).x * (mat+0.5), \t\t\t\t\n\t\t\t.5);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfragColor.rgb = GetSky(rayDir, ld, vec3(50));\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXczN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 306, 330, 330, 413], [415, 415, 446, 446, 693], [695, 695, 712, 712, 990], [992, 1187, 1244, 1244, 1532], [1534, 1534, 1562, 1562, 1733], [1735, 1735, 1771, 1771, 1856], [1858, 1858, 1916, 1916, 2446], [2448, 2448, 2505, 2505, 3751]], "test": "valid"}
{"id": "4sXyDr", "name": "Distance to Cubic Bezier Curve", "author": "mv", "description": "Unsigned sistance to a cubic bezier curve segment using Newton-Raphson. \n\nWorks alright for \"nice\" control points. Fails to find the global minima if the segment curvature is too large or if the curve intersects.", "tags": ["distance", "cubicbezier"], "likes": 18, "viewed": 996, "published": "Public API", "date": "1487626410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CLAMP\n\nfloat distanceBezier(vec2 p, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    // Cubic Bezier curve: \n    //\n    //     B(t) = (1-t)^3 P0 + (1-t)^2 t P1 + (1-t) t^2 P2 + t^3 P3\n    //\n    // or\n    //\n    //     B(t) = A t^3 + B t^2 + C t + D\n    //\n    // where\n    //\n    //     A = -P0 + 3 P1 - 3 P2 + P3\n    // \t   B = 3 (P0 - 2 P1 + P2)\n    //     C = 3 (P1 - P0)\n    //     D = P0\n    \n    vec2 A = -P0 + 3.0*P1 - 3.0*P2 + P3;\n    vec2 B = 3.0*(P0 - 2.0*P1 + P2);\n    vec2 C = 3.0*(P1 - P0);\n    vec2 D = P0;\n    \n    // Goal:\n    //\n    //     \"find t such that d^2 = ||B(t) - p||^2 is minimized\"\n    //\n    // i.e. the find t such that\n    //\n    //     f(t) = d/dt dot(B(t) - p, B(t) - p) = 0\n    // \n    // and hope that is a global minima\n    \n    // Expanding the above gives a 5th degree polynomial:\n    //\n    //     f(t) = a5 t^5 + a4 t^4 + a3 t^3 + a2 t^2 + a1 t + a0\n    //\n    // where \n    //\n    //     a5 = 6 A A\n    //     a4 = 10 A B\n    //     a3 = 8 A C + 4 B B\n    //     a2 = 6 A D' + 6 B C\n    //     a1 = 4 B D' + 2 C C\n    //     a0 = 2 C D'\n    //\n    // where\n    // \n    //     D' = D - p\n    \n    float a5 = 6.0*dot(A,A);\n    float a4 = 10.0*dot(A,B);\n    float a3 = 8.0*dot(A,C) + 4.0*dot(B,B);\n    float a2 = 6.0*dot(A,D-p) + 6.0*dot(B,C);\n    float a1 = 4.0*dot(B,D-p) + 2.0*dot(C,C);\n    float a0 = 2.0*dot(C,D-p);\n    \n    // calculate distances to the control points\n    float d0 = length(p-P0);\n    float d1 = length(p-P1);\n    float d2 = length(p-P2);\n    float d3 = length(p-P3);\n    float d = min(d0, min(d1, min(d2,d3)));\n    \n    \n    // Use the Newton-Raphson method to find a local minima, i.e. iterate:\n    //\n    //     t_{n+1} = t_n - f(t_n)/f'(t_n)\n    //\n    // until convergence is reached\n    \n    // Choose initial value of t\n    float t;\n    if (abs(d3 - d) < 1.0e-5)\n        t = 1.0;\n    else if (abs(d0 - d) < 1.0e-5)\n        t = 0.0;\n    else\n        t = 0.5;\n        \n\t// iterate\n    for (int i = 0; i < 10; i++) {\n        float t2 = t*t;\n        float t3 = t2*t;\n        float t4 = t3*t;\n        float t5 = t4*t;\n        \n        float f = a5*t5 + a4*t4 + a3*t3 + a2*t2 + a1*t + a0;\n        float df = 5.0*a5*t4 + 4.0*a4*t3 + 3.0*a3*t2 + 2.0*a2*t + a1;\n        \n        t = t - f/df;\n    }\n    \n    // clamp to edge of bezier segment\n#ifdef CLAMP\n    t = clamp(t, 0.0, 1.0);\n#endif\n    \n    // get the point on the curve\n    vec2 P = A*t*t*t + B*t*t + C*t + D;\n        \n    // return distance to the point on the curve\n    if (d < 0.1) { \n        // to see the control points\n        return -1000.0;\n    } else {\n        // Newton iteration converge to local minima that is not the global for some values\n        // return length(p-P); \n        \n        // Taking the union with the end point distances\n        // seem to fix the issue for most \"nice\" control points\n        // (since NR can only find interior points?)\n    \treturn min(length(p-P), min(d0, d3)); \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 5.0;\n    // calculate coordinates of fragment\n\tvec2 p = zoom*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n\n    // define control points\n    float a = 2.0*sin(0.5*0.5*0.5*2.0*3.1415925*iTime);\n    vec2 P0 = vec2(-1.00 - 1.00*cos(1.0*a), 1.0*sin(a));\n    vec2 P1 = vec2(-0.75 + 0.25*cos(0.5*a), 0.0*sin(a));\n    vec2 P2 = vec2( 0.75 - 0.25*cos(0.5*a), 0.0*sin(a));\n    vec2 P3 = vec2( 1.00 + 1.00*cos(1.0*a), 1.0*sin(a));\n    \n    // get the distance to the bezier curve\n    float r = distanceBezier(p, P0, P1, P2, P3);\n    \n    if (r < 0.0) {\n        // control point\n        fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    } else {\n        // make the distance field periodic, for viewing contour lines\n        \n        // 2 stripes per unit length\n        float f = 2.0*3.1416*2.0; \n        \n        // smoothen\n        float w = 1.5*fwidth(f*r);\n        float s = smoothstep(-w, w, 0.0+sin(f*r+3.1415/2.0));\n        \n        //\n        fragColor = vec4(vec3(s), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 81, 394, 2941], [2943, 2943, 3000, 3000, 3995]], "test": "valid"}
{"id": "4sXyzN", "name": "Gear Revolute", "author": "aiekick", "description": "the shadow is funny ! its like a fake df shape :)", "tags": ["gear", "revolute"], "likes": 21, "viewed": 587, "published": "Public API", "date": "1487185826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.14159 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat gear(vec2 p)\n{\n\tfloat r = min(max(.5 * (cos(atan(p.x, p.y) * 8. + 0.)) + 0.2, 0.), .5);\n\treturn length(p) - .9 - r;\n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*0.125 + iTime * .5;\n    \n    vec2 rev = vec2(length(p.xz),p.y) - 1.5;\n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n\tvec2 res = vec2(abs(gear(rev))-0.032, 0);\n\tif (p.z > res.x)\n\t\tres = vec2(p.z, 1);\n\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,2);\n\t\t\n\treturn res; \n\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tvec2 camp = vec2(.73,.37) * 5.;\n\tvec3 rayOrg = vec3(cos(1.57),sin(camp.y),sin(1.57)) * camp.x;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.2,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\t\n\tfor (float i=0.; i<150.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dMax) break;\n\t\ts = df(p).x;\n\t\td += s * 0.2;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyzN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 263, 287, 287, 365], [367, 367, 387, 387, 490], [492, 492, 509, 509, 826], [828, 828, 860, 860, 1038], [1040, 1056, 1130, 1130, 1369], [1371, 1387, 1429, 1429, 1728], [1730, 1925, 1982, 1982, 2270], [2272, 2272, 2329, 2329, 3780]], "test": "valid"}
{"id": "4tGXW3", "name": "test of anaglyph", "author": "loic_fejoz", "description": "A simple test for anaglyph rendering.\nIt is based on https://www.shadertoy.com/view/Xds3zN from @iq\nIt does no culling.\n", "tags": ["procedural", "3d", "raymarching", "distancefields", "anaglyph"], "likes": 2, "viewed": 579, "published": "Public API", "date": "1486069823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sum3(vec3 p) {\n  return p.x + p.y + p.z;\n}\n\n//----------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n/*\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = invert(m)*p;\n    return primitive(q);\n}\n*/\n\nvec2 map( in vec3 pos )\n{\n  vec2 res = vec2(\n\t\t  sdBox(pos-vec3(1.0, 0.0, 0.0),vec3(0.5, 0.6, 0.7)), 46.9);\n  res = opU( res, vec2( sdTorus(pos-vec3( 0.0,0.5, 0.5), vec2(0.50,0.1) ), 25.0 ) );\n  mat3 rotate90 = mat3(vec3(0, -1, 0), vec3(1, 0, 0), vec3(0, 0, 1));\n  res = opU( res, vec2( sdTorus(rotate90 * (pos-vec3( 0.0,0.5, 1.0)), vec2(0.50,0.1) ), 25.0 ) );\n\n  return opU(res, vec2(sdPlane(pos), 1.0));\n}\n\n// Copy'n paste from https://www.shadertoy.com/view/Xds3zN\n// Then modified from anaglyph\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 50.0;\n\n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n\n\tfloat precis = 0.0001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.00001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\n        // material\n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n        if( m<1.5 )\n        {\n\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lightning\n\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n\n\t\tfloat occ = calcAO( pos, nor );\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n\tfloat time = 15.0 + iTime;\n\n\t// Camera\n\tfloat dist = 3.0;\n\tvec3 ro = vec3(\n\t\t\t-0.5+dist*cos(0.1*time + 6.0*mo.x),\n\t\t\t1.0 + 2.0*mo.y,\n\t\t\t-0.5 + dist*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3(0.0);\n\tvec3 eyes_line = normalize(cross(vec3(0.0, 1.0, 0.0), ro));\n\tfloat d_eyes_2 = 0.08;\n\tvec3 ro_left = ro + d_eyes_2 * eyes_line;\n\tvec3 ro_right = ro - d_eyes_2 * eyes_line;\n    vec3 ta_left = ta + d_eyes_2 * eyes_line;\n    vec3 ta_right = ta - d_eyes_2 * eyes_line;\n\n\n\t// camera-to-world transformation\n    mat3 ca_left  = setCamera(ro_left, ta_left, 0.0);\n    mat3 ca_right = setCamera(ro_right, ta_right, 0.0);\n\n    // rays' direction\n\tvec3 rd_left = ca_left * normalize( vec3(p.xy,1.0) );\n\tvec3 rd_right = ca_right * normalize( vec3(p.xy,1.0) );\n\n    // render both eye\n    vec3 col_left = render( ro_left, rd_left );\n    vec3 col_right = render( ro_right, rd_right );\n\n    //vec3 col = vec3( col_right.r, col_left.g, col_left.b);\n    vec3 col = vec3( col_left.r, col_right.g, col_right.b);\n    col = pow( col, vec3(0.4545) );\n\n\tfragColor=vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 48], [50, 124, 154, 154, 187], [189, 189, 214, 214, 229], [231, 231, 262, 262, 349], [351, 351, 384, 384, 439], [441, 531, 556, 556, 938], [940, 1031, 1071, 1071, 1654], [1657, 1657, 1731, 1731, 1992], [1994, 1994, 2026, 2026, 2249], [2251, 2251, 2293, 2293, 2588], [2593, 2593, 2632, 2632, 4154], [4156, 4156, 4208, 4208, 4385], [4387, 4387, 4444, 4444, 5646]], "test": "valid"}
{"id": "4tGXWd", "name": "The Mandelgrim", "author": "marciot", "description": "Combined a Mandelbulb shader with Inigo Quilez's eye tutorial to make a creepy monster. Someday I'll have to make a game based on this! :)", "tags": ["procedural", "3d", "fractal", "interactive", "mandelbulb", "eye", "character", "vr", "creepy", "nightmare", "bloodshot"], "likes": 41, "viewed": 777, "published": "Public", "date": "1486354354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADER_TOY\n\n#ifdef SHADER_TOY\n#define CAMERA_Z 2.5\nconst vec3 cameraStart       = vec3(0.0,  0.7, -CAMERA_Z);\nconst vec3 cameraLookat      = vec3(0.0,  0.0, 0.0);\nconst vec3 lightDir          = vec3(2.0,  2.4, -1.0);\nconst vec3 lightColour       = vec3(1.6,  1.8,  2.2);\nconst float specular         = 64.0;\nconst float specularHardness = 512.0;\nconst vec3  diffuse          = vec3(0.25, 0.25, 0.25);\nconst float ambientFactor    = 0.65;\nconst bool ao                = true;\nconst bool shadows           = true;\nconst bool rotateWorld       = true;\nconst bool antialias         = false;\nconst float distanceMin      = 0.003;\n#else\nuniform vec2 iResolution;\nuniform float iTime;\nuniform vec3 cameraPos;\nuniform vec3 cameraLookat;\nuniform vec3 lightDir;\nuniform vec3 lightColour;\nuniform float specular;\nuniform float specularHardness;\nuniform vec3 diffuse;\nuniform float ambientFactor;\nuniform bool ao;\nuniform bool shadows;\nuniform bool rotateWorld;\nuniform bool antialias;\nuniform float distanceMin;\n#endif\n\n/* ****************** Eyeball Texture *********************** */\n\n// Based on tutorial by Inigo Quilez:\n//  https://www.youtube.com/watch?v=emjuqqyq_qc\n\n//alternative noise implementation\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat fbm(in vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise(p); p*=m*2.02;\n    f += 0.2500*noise(p); p*=m*2.03;\n    f += 0.1250*noise(p); p*=m*2.01;\n    f += 0.0625*noise(p); p*=m*2.04;\n    f /= 0.9375;\n    return f;\n}\n\nvec3 EyeUVMap( in vec2 uv )\n{\n    float pi            = 3.1415;\n    float irisCoverage  = 0.20;\n    \n    float r = uv.y*1.0/irisCoverage;\n    float a = uv.x * pi * 2.0;\n    vec2 p = vec2(r*cos(a), r*sin(a));\n\n    //change this to whatever you want the background\n    //color to be\n    vec3 bg_col = vec3(1.0);\n\n    vec3 col = bg_col;\n\n    //float ss = 0.5 + 0.25*sin(iTime);\n    float ss = 0.75;\n    float anim = 1.0 + 0.5*ss*clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n\n    if (r < 0.8) {\n        // Outer iris, color variation\n        col = vec3(0.0, 0.3, 0.4);\n\n        float f = fbm(5.0*p);\n        col = mix(col, vec3(0.2, 0.5, 0.4), f);\n\n        // Central iris\n        f = 1.0 - smoothstep(0.2, 0.5, r);\n        col = mix(col, vec3(0.9, 0.6, 0.2), f);\n\n        a += 0.05*fbm(20.0*p);\n\n        // Iris, white striations\n        f = smoothstep(0.3, 1.0, fbm(vec2((6.0+ss*0.25)*r, 20.0*a)));\n        col = mix(col, vec3(1.0), f);\n\n        // Iris, black striations\n        f = smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)));\n        col *= 1.0 - 0.5*f;\n\n        // Iris, outer shadow\n        f = smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n\n        // Pupil\n        f = smoothstep(0.2, 0.25, r);\n        col *= f;\n\n        // Blend iris into sclera\n        f = smoothstep(0.75, 0.8, r);\n        col = mix(col, bg_col, f);\n    } else {\n        // Veins\n        a += 0.15*fbm(10.0*p);\n        \n        float f = smoothstep(0.35, 1.0, fbm(vec2(0.5*r, 30.0*a)));\n        col -= vec3(0.0,1.0,1.0) * (1.0 - uv.y) * f;\n    }\n\n    return col;\n}\n\n/* ****************** Mandelbulb Scene *********************** */\n\n// Source code adapted from:\n// https://github.com/kevinroast/webglshaders/blob/master/mandelbulb.html\n\n#define AO_SAMPLES 5\n#define RAY_DEPTH 256\n#define MAX_DEPTH 20.0\n#define PI 3.14159265\n\n#define FLOOR_YPOS -2.0\n#define EYE_ZPOS   -0.82\n\nvec2 delta = vec2(distanceMin, 0.);\n\nvec3 RotateY(vec3 p, float a)\n{\n    float c,s;\n    vec3 q=p;\n    c = cos(a);\n    s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n    return p;\n}\n\nvec3 RotateX(vec3 p, float a) {\n    return RotateY(p.yxz, a).yxz;\n}\n\n#ifdef SHADER_TOY\nfloat FlatPeakFunc(float t) {\n    // http://math.stackexchange.com/questions/100655/cosine-esque-function-with-flat-peaks-and-valleys\n    return sin(0.5*PI*cos(t));\n    /* Alternative:\n        const float b = 2.;\n        return sqrt((1.+b*b)/(1.+pow(b*cos(t),2.)))*cos(t);\n     */    \n}\n\nfloat CameraOrbitAngle() {\n    return PI - FlatPeakFunc(iTime*0.5) * PI * 1.1;\n}\n\nvec3 CameraOrbit() {\n    vec3 pos = cameraStart - cameraLookat;\n    if (rotateWorld) pos = RotateY(pos, CameraOrbitAngle());\n    return pos + cameraLookat;\n}\n\nvec3 CameraInvariant(vec3 pos) {\n    if (rotateWorld) pos = RotateY(pos, -CameraOrbitAngle());\n    return pos;\n}\n#endif\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Added by marciot, to render an eye.\nfloat EyeBall(vec3 p) {\n    return Sphere(p-vec3(0.,0.,EYE_ZPOS), 0.37);\n}\n\n// Formula for original MandelBulb from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat MandelBulb(vec3 pos, const int limitIterations)\n{\n    const int Iterations = 12;\n    const float Bailout = 8.0;\n    //float Power = 5.0 + cos(iTime*0.0125)*4.0;\n    //float Power = 5.0 + sin(0.5)*4.0;\n    float Power = 9.0;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < Iterations; i++)\n    {\n        r = length(z);\n        if (r > Bailout || i == limitIterations) break;   // TODO: test if better to continue loop and if() rather than break?\n\n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr = pow(r, Power-1.0)*Power*dr + 1.0;\n\n        // scale and rotate the point\n        float zr = pow(r,Power);\n        theta = theta*Power;\n        phi = phi*Power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nfloat MandelBulb(vec3 pos) {\n    return MandelBulb(pos, 12);\n}\n\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Dist(vec3 pos)\n{\n    return min(\n        // Floor is at y=-2.0\n        min(\n            Plane(pos-vec3(0.,FLOOR_YPOS,0.), vec3(0.,1.,0.)),\n            MandelBulb(pos)\n        ),\n        EyeBall(pos)\n    );\n}\n\n// Based on original by IQ - optimized to remove a divide\nfloat CalcAO(vec3 p, vec3 n)\n{\n    float r = 0.0;\n    float w = 1.0;\n    for (int i=1; i<=AO_SAMPLES; i++)\n    {\n        float d0 = float(i) * 0.3;\n        r += w * (d0 - Dist(p + n * d0));\n        w *= 0.5;\n    }\n    return 1.0 - clamp(r,0.0,1.0);\n}\n\n// Based on original code by IQ\nfloat SelfShadow(vec3 ro, vec3 rd)\n{\n    float k = 32.0;\n    float res = 1.0;\n    float t = 0.1;          // min-t see http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    for (int i=0; i<16; i++)\n    {\n        float h = Dist(ro + rd * t);\n        res = min(res, k*h/t);\n        t += h;\n        if (t > 4.0) break; // max-t\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat SoftShadow(vec3 ro, vec3 rd)\n{\n    float k = 16.0;\n    float res = 1.0;\n    float t = 0.1;          // min-t see http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    for (int i=0; i<48; i++)\n    {\n        float h = Dist(ro + rd * t);\n        res = min(res, k*h/t);\n        t += h;\n        if (t > 8.0) break; // max-t\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    if (pos.y < FLOOR_YPOS + distanceMin)\n    {\n        return vec3(0.0,1.0,0.0);\n    }\n    else\n    {\n        vec3 n;\n        n.x = Dist( pos + delta.xyy ) - Dist( pos - delta.xyy );\n        n.y = Dist( pos + delta.yxy ) - Dist( pos - delta.yxy );\n        n.z = Dist( pos + delta.yyx ) - Dist( pos - delta.yyx );\n\n        return normalize(n);\n    }\n}\n\n// Added by marciot, for creepy eye\nvec3 EyeBallColor(vec3 p) {\n    vec3 eyeCenter = vec3(0.,0.,EYE_ZPOS);\n    vec3 p0 = p-eyeCenter;\n\n#ifdef SHADER_TOY\n    // TODO: This is kind of spaghetti code, probably better way to do this\n    const float eyeRollMax = PI/4.;\n    vec3 mouseVector = vec3(\n        (iMouse.x/iResolution.x - 0.5) * 2.,\n        (iMouse.y/iResolution.y - 0.5) * 2.,\n        CAMERA_Z\n    );\n    mouseVector = CameraInvariant(mouseVector);\n    vec3  cameraPointDir = cameraLookat - cameraStart;\n    float cameraElevation = atan(cameraPointDir.y/cameraPointDir.z);\n    float eyeRollLateral  = atan(mouseVector.x/mouseVector.z);\n    float eyeRollVertical = atan(mouseVector.y/mouseVector.z)-cameraElevation;\n    p0 = RotateY(p0, clamp(eyeRollLateral, -eyeRollMax, eyeRollMax));\n    p0 = RotateX(p0, clamp(eyeRollVertical,-eyeRollMax, eyeRollMax));\n#endif\n    vec2 uv = vec2(\n        atan(p0.y,p0.x)/(2.*PI), \n        acos(-p0.z/length(p0))/PI\n    );\n    return EyeUVMap(uv);\n}\n\n// Added by marciot, colorize the mandelbulb.\nvec3 MandelBulbColor(vec3 pos) {\n    float d1  = MandelBulb(pos, 1);\n    float d6  = MandelBulb(pos, 6);\n    float d9  = MandelBulb(pos, 9);\n    float g = clamp( 0.5  + abs((d6-d1)*50.) ,0.,1.);\n    float b = clamp( 0.25 + abs((d9-d1)*25.) ,0.,5.);\n    return vec3(1., g, b);\n}\n\n// Based on a shading method by Ben Weston. Added AO and SoftShadows to original.\nconst vec3 sssColour = vec3(0.5,0.5,1.0);\nvec4 Shading(vec3 pos, vec3 rd, vec3 norm)\n{\n    vec3 light;\n    bool isEye   = EyeBall(pos) < distanceMin;\n    bool isFloor = pos.y < FLOOR_YPOS+distanceMin;\n    bool isBulb  = !isEye && !isFloor;\n\n    // simple pos test on pos.y for floor (see Dist() above) - different colour and no spec for floor\n    if(isFloor) {\n        light = vec3(0.1,0.66,0.2) * max(0.0, dot(norm, lightDir));\n        if (shadows) light *= SoftShadow(pos, lightDir);   // softer edged shadows on floor\n        if (ao) light += CalcAO(pos, norm) * max(ambientFactor-0.25, 0.0);\n    }\n    else\n    {\n        light = lightColour * max(0.0, dot(norm, lightDir));\n        vec3 heading = normalize(-rd + lightDir);\n        float spec = pow(max(0.0, dot(heading, norm)), specularHardness);\n        light = (diffuse * light) + (spec * specular * lightColour);\n        if (shadows) light *= SelfShadow(pos, lightDir);   // harder edged shadows on object\n        if (ao) light += CalcAO(pos, norm) * ambientFactor;\n    }\n\n    if(isBulb) light     *= MandelBulbColor(pos);\n    if(isEye)  light.rgb *= EyeBallColor(pos);\n    \n    return vec4(light, 1.0);\n}\n\n// Original method by David Hoskins\nvec3 Sky(in vec3 rd)\n{\n    rd = CameraInvariant(rd);\n    float sunAmount = max(dot(rd, lightDir), 0.0);\n    float v = pow(1.0 - max(rd.y,0.0),6.);\n    vec3 sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n    sky += lightColour * sunAmount * sunAmount * .25 + lightColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\n    return clamp(sky, 0.0, 1.0);\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n    pos = pos - 0.5;\n    pos.x *= iResolution.x/iResolution.y;\n\n    dir = normalize(dir);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n    vec3 up = normalize(cross(dir,right));\n\n    return dir + right*pos.x + up*pos.y;\n}\n\nvec4 March(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i=0; i<RAY_DEPTH; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = Dist(p);\n        if (abs(d) < distanceMin)\n        {\n            return vec4(p, 1.0);\n        }\n        t += d;\n        if (t >= MAX_DEPTH) break;\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int ANTIALIAS_SAMPLES = 4;\n    const int DOF_SAMPLES = 16;\n\n    const bool dof = false;\n\n    vec4 res = vec4(0.0);\n    \n#ifdef SHADER_TOY\n    vec3 cameraPos = CameraOrbit();\n#endif\n\n    if (antialias)\n    {\n        vec2 p;\n        float d_ang = 2.*PI / float(ANTIALIAS_SAMPLES);\n        float ang = d_ang * 0.33333;\n        float r = 0.3;\n        for (int i = 0; i < ANTIALIAS_SAMPLES; i++)\n        {\n            p = vec2((fragCoord.x + cos(ang)*r) / iResolution.x, (fragCoord.y + sin(ang)*r) / iResolution.y);\n            vec3 ro = cameraPos;\n            vec3 rd = normalize(GetRay(cameraLookat-cameraPos, p));\n            vec4 _res = March(ro, rd);\n            if (_res.a == 1.0) res.xyz += clamp(Shading(_res.xyz, rd, GetNormal(_res.xyz)).xyz, 0.0, 1.0);\n            else res.xyz += Sky(rd);\n            ang += d_ang;\n        }\n        res.xyz /= float(ANTIALIAS_SAMPLES);\n    }\n    else if (dof)\n    {\n        vec2 p = fragCoord.xy / iResolution.xy;\n        vec3 ro = cameraPos;\n        vec3 rd = normalize(GetRay(cameraLookat-cameraPos, p));\n        vec4 _res = March(ro, rd);\n\n        float d_ang = 2.*PI / float(DOF_SAMPLES);\n        float ang = d_ang * 0.33333;\n        // cheap DOF! - offset by camera zdiff (as cam/lookat are quite far apart)\n        float r = max(0.3, abs(cameraLookat.z - _res.z + 0.0) * .2);\n        for (int i = 0; i < DOF_SAMPLES; i++)\n        {\n            p = vec2((fragCoord.x + cos(ang)*r) / iResolution.x, (fragCoord.y + sin(ang)*r) / iResolution.y);\n            ro = cameraPos;\n            rd = normalize(GetRay(cameraLookat-cameraPos, p));\n            _res = March(ro, rd);\n            if (_res.a == 1.0) res.xyz += clamp(Shading(_res.xyz, rd, GetNormal(_res.xyz)).xyz, 0.0, 1.0);\n            else res.xyz += Sky(rd);\n            ang += d_ang;\n        }\n        res.xyz /= float(DOF_SAMPLES);\n    }\n    else\n    {\n        vec2 p = fragCoord.xy / iResolution.xy;\n        vec3 ro = cameraPos;\n        vec3 rd = normalize(GetRay(cameraLookat-cameraPos, p));\n        vec4 intersect = March(ro, rd);\n        if (intersect.a == 1.0) {\n            res.xyz = clamp(Shading(intersect.xyz, rd, GetNormal(intersect.xyz)).xyz, 0.0, 1.0);\n        } else {\n            res.xyz = Sky(rd);\n        }\n    }\n\n    fragColor = vec4(res.rgb, 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(0.0);\n    \n    ro += vec3(0., 0., -.5);\n    \n    float scale = 0.15;\n    ro /= scale;\n    \n    vec4 intersect = March(ro, rd);\n    if (intersect.a == 1.0) {\n        res.xyz = clamp(Shading(intersect.xyz, rd, GetNormal(intersect.xyz)).xyz, 0.0, 1.0);\n    } else {\n        res.xyz = Sky(rd);\n    }\n    fragColor = vec4(res.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1170, 1205, 1228, 1228, 1270], [1272, 1272, 1298, 1298, 1504], [1543, 1543, 1565, 1565, 1765], [1767, 1767, 1796, 1796, 3312], [3381, 3661, 3692, 3692, 3828], [3830, 3830, 3861, 3861, 3897], [4567, 4567, 4596, 4596, 4619], [4621, 4621, 4652, 4652, 4680], [4682, 4721, 4744, 4744, 4795], [4797, 4960, 5015, 5015, 5907], [5909, 5909, 5937, 5937, 5971], [5973, 6126, 6148, 6148, 6339], [6341, 6399, 6429, 6429, 6649], [6651, 6683, 6719, 6719, 7061], [7063, 7063, 7099, 7099, 7441], [7443, 7443, 7469, 7469, 7821], [7823, 7859, 7886, 7886, 8813], [8815, 8861, 8893, 8893, 9138], [9140, 9264, 9308, 9308, 10385], [10387, 10423, 10445, 10445, 10772], [10774, 10839, 10872, 10872, 11104], [11106, 11106, 11136, 11136, 11422], [11424, 11424, 11481, 11481, 13759], [13761, 13761, 13839, 13839, 14193]], "test": "valid"}
{"id": "4tKXD3", "name": "Infinite zooming noise", "author": "nomadiclizard", "description": "Zooms forever into simplex noise, fading in and out successive octaves.", "tags": ["procedural", "2d", "noise", "simplex", "infinitezoom"], "likes": 11, "viewed": 420, "published": "Public", "date": "1486218827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265358979\n#define twoPi (2.0*pi)\n\n// snoise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nvec3 permutezz(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoisezz(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permutezz( permutezz( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// number of octaves of noise\n#define octaves\t\t4\n// zoom level between each successive octave\n#define octave_zoom 20.0\n// how long in seconds it takes to zoom in one octave\n#define zoom_time   2.0\n// scaling multiplier of the zoomiest octave\n#define base_zoom   1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uvspin = vec2(0.1 * cos(0.7 * twoPi * iTime),\n                       0.1 * sin(0.35 * twoPi * iTime));\n    float timeI = floor(iTime / zoom_time);\n    float timeF = mod(iTime, zoom_time) / zoom_time;\n    float smoothtimeF = timeF;//sin(twoPi * timeF) / (2.0 * twoPi) + timeF;\n    float zoom = base_zoom / pow(octave_zoom, smoothtimeF);\n    for(int i=0; i<octaves; i++) {\n        // linear interpolate contribution from last and first octaves to make it supersmooth <3\n        float contrib = i==0 ? (1.0-timeF) : i==octaves-1 ? timeF : 1.0;\n        // offset ensures infinite randomness as octaves no longer repeat :D\n        vec2 offset = vec2(float(i) + timeI);\n        fragColor += contrib * (0.5 * vec4(snoisezz((uv + uvspin) * zoom + offset)));\n        zoom *= octave_zoom;\n        \n        // TODO make it zoom in on the mouse location :v\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 134, 158, 158, 197], [199, 199, 222, 222, 1046], [1245, 1315, 1372, 1372, 2300]], "test": "valid"}
{"id": "4tKXDc", "name": "raymarch tunnel pipes", "author": "ShaderLyf", "description": "test, just experimenting with making some tunnels!", "tags": ["tunneltest"], "likes": 1, "viewed": 133, "published": "Public", "date": "1486230987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float eps = 0.01;\nconst vec3 floorColor = vec3(0.5,0.0,1.0);\nconst vec3 otherColor = vec3(1.0,0.0,0.0);\n\nvec2 rotate(vec2 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * p;\n}\n\nfloat fCylinder(vec3 p, float r, float height) \n{\n\tfloat d = length(p.xy) - r; // xy and xz give cool results\n\td = max(d, abs(p.z) - height);\n\treturn d;\n}\n\nfloat sphere(vec3 p)\n{ \n    p.xy = rotate(p.xy,0.5+p.z*sin(iTime*0.1)*-0.03+0.4);\n //   p.xy = rotate(p.xy,(iTime*0.5)*-0.531);\n    p = mod(p + 1.0, 18.0)-9.; // plus 2 to get it out the way of the camera\n  //  p.xy = rotate(p.xy, iTime);\n\n //return length(p)-0.9;\n    \n    return fCylinder(p,1.5,7.5);\n}\n\nfloat scene (vec3 p)\n{\n   return sphere(p);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(eps,0.0,0.0);\n    normal.x = scene(p+ep.xyz) - scene(p-ep.xyz);\n    normal.y = scene(p+ep.yxz) - scene(p-ep.yxz);\n    normal.z = scene(p+ep.yzx) - scene(p-ep.yzx);\n    return normalize(normal);\n}\n\nfloat calcShadowFactor(vec3 p, vec3 norm, vec3 lightDir)\n{\n    float t = .0;\n    vec3 rayStart = p + norm + eps*2.0;\n        for (int i =0; i<16;i++)\n        {\n            vec3 sP = rayStart - lightDir * t;\n            float dist = scene(sP);\n            if(dist < eps)\n            {\n                return 1.0;\n            }\n            t+=dist;\n        }\n    return 0.0;\n}\n\nvec3 albedo(vec3 pos)\n{\n   // pos *= 1.0;\n //return fract(pos.x * fract(pos.z)) * vec3(1.0);  \n    float f = smoothstep(0.5,0.51,fract(pos.x));\n   // f *= smoothstep(0.5,0.51,fract(pos.y));\n    return f * vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec4 finalColor = vec4(0.0,0.0,0.0,1.);\n    \n    uv = uv * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    \n    vec3 o = vec3(0.0,0.0,4.0*sin(iTime*0.1)*90.9);\n    float t = 0.0;\n    float sq = sqrt(dot(uv,uv));\n    for (int i = 0; i < 16; ++i)\n    {\n    \tvec3 p = o + r *t;\n        float d = scene(p);\n        \n        if (d < eps)\n        {\n        \tvec3 norml = getNormal(p);\n        \tvec3 ldir = vec3(-0.5,0.1,1.0);\n            float diffuseFactor = max(dot(norml,-ldir),0.42);\n\n        \tfloat shadow = calcShadowFactor(p,norml,ldir);   \n        \tvec3 diffuseColor = albedo(p);\n        \tfinalColor = vec4((2.1-shadow*sq)*diffuseFactor*(sin(r+1.7))*diffuseColor,1); \n        }\n        t += d;\n    }\n    \n    float fog = 0.2 / (0.9 +t*t*0.1);\n   \n    //finalColor += fog; \n\tfragColor = vec4(finalColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 145, 145, 235], [237, 237, 286, 286, 391], [393, 393, 415, 415, 697], [699, 699, 721, 721, 744], [746, 746, 770, 770, 999], [1001, 1001, 1059, 1059, 1375], [1377, 1377, 1400, 1471, 1594], [1596, 1596, 1653, 1653, 2556]], "test": "valid"}
{"id": "4tVSDc", "name": "Ray marched ambient occlusion", "author": "qnope", "description": "It is a copy and paste of IQ shader. I just change the AO Section and draw only the AO.\n\nOrgiinal is : https://www.shadertoy.com/view/Xds3zN", "tags": ["ambientocclusion"], "likes": 10, "viewed": 311, "published": "Public", "date": "1486227641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\tres = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res.x;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, float tmax)\n{\n    float tmin = 1.0;\n    \n    float t = tmin;\n\tfloat precis = 0.0005;\n    for( int i=0; i<64; i++ )\n    {\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float r = 0.01 + 0.1*float(i);\n        vec3 aopos =  nor * r + pos;\n        float d = map( aopos );\n        occ += (r - d)*sca;\n       /* if(d < 0.01)\n            break;*/\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - occ / 3.14, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = castRay(ro,rd, 20.0);\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n        \n    float occ = calcAO( pos, nor );\n    return vec3(occ, occ, occ);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\t// camera\t\n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n     // render\t\n     fragColor.rgb = render( ro, rd );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 40], [42, 42, 77, 77, 103], [105, 105, 136, 136, 227], [229, 229, 272, 272, 332], [334, 334, 379, 379, 421], [423, 423, 456, 456, 511], [513, 513, 549, 549, 791], [793, 793, 845, 845, 959], [961, 961, 997, 997, 1245], [1247, 1247, 1283, 1283, 1382], [1384, 1384, 1422, 1422, 1591], [1593, 1593, 1665, 1665, 1880], [1882, 1882, 1949, 1988, 2360], [2362, 2362, 2387, 2387, 2424], [2426, 2426, 2451, 2451, 2509], [2511, 2511, 2536, 2536, 2601], [2603, 2603, 2638, 2638, 2709], [2711, 2711, 2746, 2746, 2817], [2819, 2819, 2856, 2856, 2909], [2911, 2981, 3014, 3014, 3040], [3042, 3042, 3072, 3072, 3105], [3107, 3107, 3137, 3137, 3166], [3168, 3168, 3192, 3192, 3324], [3326, 3396, 3422, 3422, 5555], [5557, 5557, 5609, 5609, 5831], [5833, 5833, 5865, 5865, 6058], [6060, 6060, 6102, 6102, 6438], [6440, 6440, 6479, 6479, 6706], [6708, 6708, 6760, 6760, 6937], [6939, 6939, 6996, 6996, 7498]], "test": "valid"}
{"id": "4tVSRW", "name": "Blinking stars", "author": "gaz", "description": "2d", "tags": ["2d"], "likes": 1, "viewed": 196, "published": "Public", "date": "1487917352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 hsv(in float h, in float s, in float v)\n{\n  return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n    \nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat hash(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat star(in vec2 p)\n{\n  float a = radians(72.); \n  return dot(abs(rotate(floor(0.5 + atan(p.x, p.y) /a) *a) * p), vec2(2, 1));\n}\n\nvec2 paturn( in vec2 p )\n{\n    vec2 i = floor(p);    \n    float t = iTime + hash(i.x*5. + i.y*9.)*radians(360.);\n    float f = sin(t +sin(t*2.+i.x))*0.5+0.5;\n    p = fract(p)-0.5;\n    float d = mix(length(p)+0.05, star(p)-0.1, f);\n    float n= i.x*5. + i.y*9.+floor(iTime);    \n    return vec2(d  - 0.3*mix(hash(n),hash(n+1.0),smoothstep(0.0,1.0,fract(iTime))),f);\n}\n\nfloat scene(in float w, in float s)\n{\n    float time = mod(iTime,30.0);\n    return clamp(time - w, 0.0, s) / s;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    p *= 1.5 * pow(sin(smoothstep(0.0,20.0,mod(time,13.)) * radians(90.0)), 0.3);\n    float t = floor(time*0.5);\n    p += vec2(cos(2.*t+3.0*cos(3.0*t)),sin(2.*t+3.0*sin(3.*t))) * 1.0;\n    p = mix(vec2(inversesqrt(length(p)) * 5., atan(p.x, p.y)*3.), p, step(0.5,fract(time*0.3)));\n    \n    float s1 = scene(5.0, 10.0);\n    float r1 = mix(0.3, 10.0,s1);\n    vec2 n = paturn(p*r1+0.5);\n    vec3 col = hsv(n.y+time*0.2,0.7,0.9)*smoothstep(0.03, 0.,n.x);\n    \n    col *= smoothstep(1.5, 0.11,length(q*2.-1.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 47, 47, 129], [135, 135, 157, 157, 207], [209, 209, 229, 229, 267], [269, 269, 292, 292, 399], [401, 401, 427, 427, 767], [769, 769, 806, 806, 884], [886, 886, 943, 943, 1616]], "test": "valid"}
{"id": "4tyXDd", "name": "Ray Marching Experiment 62", "author": "aiekick", "description": " [url=https://www.shadertoy.com/view/lttXDn]Ray Marching Experiment 60[/url] with another lighting try :)", "tags": ["ray", "experiment", "marching", "62"], "likes": 28, "viewed": 846, "published": "Public API", "date": "1486390571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 rotx(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 roty(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rotz(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec4 df(vec3 p) // from https://www.shadertoy.com/view/ltcSDr\n{\n\tp *= rotz(p.z * 0.07);\n\tvec2 uv = p.xz;\n\tfloat a = length(uv) - iTime*2.;\n\tuv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\tuv = abs(uv);\n\tuv = vec2(atan(uv.x, uv.y)/3.14159, length(uv));\n\tfloat b = sqrt(uv.x) + sqrt(uv.y);\n\tfloat c = sqrt(uv.x + uv.y);\n\tfloat s = b-c;\n\tfloat d = 6. - abs(p.y)  - smoothstep(0.128,1.-0.128, s*1.32);\n\treturn vec4(d);\n}\n\nvec3 nor( in vec3 p, float prec )\n{\n\tvec3 e = vec3( prec, 0., 0. );\n\tvec3 n = vec3(\n\t    df(p+e.xyy).x - df(p-e.xyy).x,\n\t    df(p+e.yxy).x - df(p-e.yxy).x,\n\t    df(p+e.yyx).x - df(p-e.yyx).x );\n\treturn normalize(n);\n}\n\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n    //return col;\n    \n    // thansk to public_int_i\n    float i1 = sin(iTime)*0.5+0.5,\n          i2 = cos(iTime)*0.5+0.5;\n   \treturn col*max(0., 1.0-(i1+i2))+\n           col.zxy*i1+\n           col.yzx*i2;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t\n\treturn df(p - n * s).x;\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tfloat t = -iTime * 0.2;\n\tvec3 ro = vec3(cos(t),0., sin(t)) * 12.; \n    vec3 cv = vec3(0); \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    float fov = .9;\n  \tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n    \n    float s = 1., d = 0.;\n\tfor (int i=0; i<200; i++) \n\t{\n\t\tif (log(d*d/s/1e5)>0.) break;\n\t\td += (s=df(ro+rd*d).x)*.5;\n        fragColor.rgb += d/400.; // new lighting try system\n\t}\n\t\n    fragColor.rgb = mix(fragColor.rgb, vec3(d*d/400.), .5);\n    \n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    float sss = df(p - n*0.001).x/0.1;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\tfloat sb = SubDensity(p, 1., 0.1);\t\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 1. - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n    fragColor.rgb *= (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe * 1.2;\n\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n    vec2 q = g/si;\n    fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyXDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 196, 215, 215, 273], [274, 274, 293, 293, 351], [352, 352, 371, 371, 429], [431, 431, 494, 494, 845], [847, 847, 882, 882, 1064], [1067, 1288, 1316, 1316, 1831], [1833, 1915, 1972, 1972, 2198], [2200, 2200, 2236, 2236, 2297], [2299, 2299, 2356, 2356, 4084]], "test": "valid"}
{"id": "4tyXWt", "name": "Rocket In The Sky", "author": "TheSodOfGod", "description": "Rocket smoke trail I made on a lazy Sunday afternoon. I've taken the distance functions from IQ https://www.shadertoy.com/view/Xds3zN . The trail looks a bit artificial but I'll work on it. The rocket DF is from https://www.shadertoy.com/view/ltjGD1", "tags": ["raymarching", "scattering", "smoke", "rocket"], "likes": 6, "viewed": 356, "published": "Public", "date": "1486339982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants\n#define PI 3.1415\n#define MOD2 vec2(3.07965, 7.4235)\n\n// Time Scaling\n#define time iTime*0.1\n\n// Raymarching\nfloat minPrimStepSize = 0.1 ;\nconst int primNumSamples = 100 ;\n\n// Colours\nconst vec3 smokeCol = vec3(30./255., 31./255., 30./255.) ;\nconst vec3 sunCol = vec3(1.0,1.0,1.0) ;\nconst vec3 backCol = vec3(206./255., 146./255., 14./255.) ;\nconst vec3 skyCol = vec3(135.,206.,250.)/255. ;\nconst vec3 rocketCol = vec3(230.,10.,10.)/255. ;\nconst vec3 ambientCol = vec3(0.4) ;\n\n// SmokeVals\nconst int octavesSmoke =  12 ;\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);  \n}\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 smokeStart = vec3(5.0,-5.0,5.0) ;\nvec3 smokeEnd = vec3(5.0,5.0,5.0) ;\nfloat smokeThickness = 1.0 ;\nfloat offset = 0.1 ;\n\nfloat sampleSmoke(vec3 position) {\n  float noiseVal = 0.0 ;\n  float amplitude = 1.0 ;\n  float freq = 4.5 ;\n  float lac = 2.0 ;\n  float scaling = 2.0 ;\n  for (int i = 0 ; i < octavesSmoke ; ++i) {\n    noiseVal += amplitude * noise(freq*position+vec3(0.0,time*200.0,3.0*time)) ;\n    amplitude /= lac ;\n    freq *= lac ;\n  }\n    \n  vec3 smokeDir = normalize(smokeEnd-smokeStart) ;\n  float dist = length((smokeStart - position) - (dot((smokeStart - position),smokeDir))*smokeDir) ;\n  noiseVal *= exp(-2.5*dist) ;\n  noiseVal -= offset ;\n  noiseVal *= (1.0 - exp(-0.05 * length(smokeStart-position))) ;\n  noiseVal = clamp(noiseVal,0.0,1.0) ;\n\n  return scaling * noiseVal ;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid rotate(const float a, inout vec2 v) {\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat pi = 3.1415 ;\n\nfloat mBox(vec3 p, vec3 b) {\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nvec2 frot(const float a, in vec2 v) {\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n    return v;\n}\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\n\nfloat dfRocketBody(vec3 p) {\n    float rocketRotation = 1.5*sin(0.9*time) ;\n    rotate(rocketRotation,p.xz);\n    vec3 p2 = p;\n    vec3 pWindow = p;\n\n    angularRepeat(pi*.25,p2.zx);\n    float d = p2.z;\n    d = max(d, frot(pi*-.125, p2.yz+vec2(-.7,0)).y);\n    d = max(d, frot(pi*-.25*.75, p2.yz+vec2(-0.95,0)).y);\n    d = max(d, frot(pi*-.125*.5, p2.yz+vec2(-0.4,0)).y);\n    d = max(d, frot(pi*.125*.25, p2.yz+vec2(+0.2,0)).y);\n    d = max(d, frot(pi*.125*.8, p2.yz+vec2(.55,0)).y);\n    d = max(d,-.8-p.x);\n    d -= .5;\n    \n    vec3 pThruster = p2;\n    pThruster -= vec3(-1.46,.0,.0);\n    rotate(pi*-.2,pThruster.yz);\n    d = min(d,mBox(pThruster,vec3(.1,.4,.27)));\n    d = min(d,mBox(pThruster-vec3(-.09,.0,.0),vec3(.1,.3,.07)));\n    \n    \n    pWindow -= vec3(.1,.0,.0);\n    angularRepeat(pi*.25,pWindow.xy);\n    pWindow -= vec3(.17,.0,.0);\n    d = min(d,mBox(pWindow,vec3(.03,.2,.55)));\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p) {       \n    float rocketRotation = 1.5*sin(0.9*time) ;\n    rotate(rocketRotation,p.xz);\n    \n    vec3 pFins = p;\n    angularRepeat(pi*.5,pFins.zx);\n    pFins -= vec3(0.0,-1.0+cos(p.y+.2)*.5,.0);\n    rotate(pi*.25,pFins.yz);\n    float scale = 1.0-pFins.y*.5;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat dfRocket(vec3 p) {\n    float proxy = mBox(p,vec3(2.5,.8,.8));\n    if (proxy>1.0)\n    \treturn proxy;\n    return min(dfRocketBody(p),dfRocketFins(p));\n}\n\n\nfloat sampleSmokeCap(vec3 position) {\n\treturn sdCapsule(position,smokeStart,smokeEnd,smokeThickness) ;  \n}\n\nfloat sampleRocketCCy(vec3 position) {\n    return dfRocket(position-(smokeEnd+vec3(0.0,2.3,0.0))) ;\n}\n\nbool isIntersectingSmokeShape(vec3 position, float precis, out float dist) {\n    dist = sampleSmokeCap(position) ;\n    return dist < precis ;\n}\n\nbool isIntersectingRocket(vec3 position, float precis, out float dist) {\n    dist = sampleRocketCCy(position) ;\n    return dist < precis ;\n}\n                          \nbool rayMarchTrans(vec3 startPos, vec3 direction, out float rayDist) {\n    vec3 position = startPos ;\n    bool intersected = false ;\n    rayDist = 0.0 ;\n    float delta = minPrimStepSize ;\n    float precis = 0.0005 ;\n    \n    for (int i = 0 ; i < primNumSamples ; ++i) {\n\t\tif (isIntersectingSmokeShape(position,precis,delta)) {\n            return true ;\n        } else {\n            precis = 0.00005 * rayDist ;\n\t\t    rayDist += delta ;\n            position = (rayDist)*direction + startPos ;\n        }\n    }\n    \n    return false ;\n}\n\nbool rayMarchSolids(vec3 startPos, vec3 direction, out float rayDist) {\n    vec3 position = startPos ;\n    bool intersected = false ;\n    rayDist = 0.0 ;\n    float delta = minPrimStepSize ;\n    float precis = 0.0005 ;\n    \n    for (int i = 0 ; i < primNumSamples ; ++i) {\n\t\tif (isIntersectingRocket(position,precis,delta)) {\n            return true ;\n        } else {\n            precis = 0.0005 * rayDist ;\n\t\t    rayDist += delta ;\n            position = (rayDist)*direction + startPos ;\n        }\n    }\n    \n    return false ;\n}\n\n\nconst float extinctionCoeff = 13.0 ;\nconst float scatteringCoeff = 12.5 ;\nconst float secSmokeSampleSize = 0.2 ;\nconst int secSmokeNumSamples = 5 ;\n\nfloat getIncidentSunlight(vec3 startPos, vec3 lightDir) {\n    vec3 position = startPos ;\n    vec3 stepVector = lightDir * secSmokeSampleSize ;\n    float extinction = 1.0 ;\n    float dist = 0.0 ;\n    for (int i = 0 ; i < secSmokeNumSamples ; ++i) {\n        if (!isIntersectingSmokeShape(position,0.005,dist))\n            break ;\n\t    float density = sampleSmoke(position) ;\n        extinction *= exp(-extinctionCoeff*density*secSmokeSampleSize) ;\n        position += stepVector ;\n    }\n    return extinction ;\n}\n\nconst float primSmokeSampleSize = 0.1 ;\nconst int primSmokeNumSamples = 50 ;\n\nvec4 primaryRayMarchSmoke(vec3 startPos, vec3 direction, vec3 lightDir) {\n    vec3 position = startPos ;\n    vec3 stepVector = direction * primSmokeSampleSize ;\n    float dist ;\n    float extinction = 1.0 ;\n    vec3 colour = vec3(0.0) ;\n    for (int i = 0 ; i < primSmokeNumSamples ; ++i) {\n        if (extinction < 0.05 || !isIntersectingSmokeShape(position,0.005,dist))\n            break ;\n     \tfloat vertDistFromRocket = abs(position.y - smokeEnd.y) ;\n        float deltaYDensityMod = (1.f-(vertDistFromRocket)/(smokeEnd.y-smokeStart.y));\n\t\tfloat density = sampleSmoke(position) * deltaYDensityMod * deltaYDensityMod;\n        extinction *= exp(-extinctionCoeff*density*primSmokeSampleSize);\n        vec3 scattering = primSmokeSampleSize * density * scatteringCoeff * (ambientCol +  sunCol * getIncidentSunlight(position, lightDir)) ;\n        colour += scattering * extinction ;\n        position += stepVector ;\n    }\n    \n    return vec4(colour,extinction) ;    \n}\n\nvec3 calcSkyCol(in vec3 direction, in vec3 lightDir) {\t\n    float sunAmount = max( dot(direction, lightDir), 0.0 );\n\tfloat v = pow(1.0-max(direction.y,0.0),5.)*.5;\n\tvec3  sky = vec3(v*sunCol.x*0.4+skyCol.x, v*sunCol.y*0.4+skyCol.y, v*sunCol.z*0.4+skyCol.z);\n\tsky = sky + sunCol * pow(sunAmount, 6.5)*.12;\n\tsky = sky+ sunCol * min(pow(sunAmount, 1200.), .3)*.65;\n\treturn sky;\n}\n\n// Taken from IQ : https://www.shadertoy.com/view/Xds3zN\nvec3 calcRocketNormal( in vec3 pos ) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sampleRocketCCy( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sampleRocketCCy( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sampleRocketCCy( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sampleRocketCCy( pos + e.xxx ));\n}\n\nvec4 calcRocketColour(in vec3 position,in vec3 direction, in vec3 lightDir) {\t\n\tvec3 nor = calcRocketNormal(position) ;\n    vec3 ref = reflect( direction, nor);\n    vec3 col = vec3(0.0) ;\n    // lighting        \n\tvec3  lig = lightDir ;\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n    if (dfRocketBody(position)>dfRocketFins(position)) {\n    \tif (position.y<smokeEnd.y-0.85 || position.y>smokeEnd.y+1.34)\n        \tif (position.y>smokeEnd.y+3.41)\n            \tcol = vec3(.1,.1,.1);\n            else\n                col = vec3(.9,.9,.9);\n        else {\n        \tcol = vec3(.1,.1,.1);\n        }\n    }\n    \n\tvec3 lin = vec3(0.0);\n    lin += 4.30*dif*vec3(1.00,0.80,0.55);\n\tlin += 7.00*spe*vec3(1.00,0.90,0.70)*dif;\n    lin += 1.00*amb ;\n\tcol = col*lin;\n    \n    return vec4(col,0.0) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    vec2  m = 2.*((iMouse.xy / iResolution.xy) - 0.5);\n    \n    if (iMouse.xy == vec2(0)) {\n       m.y = 0.0 ;   \n    }\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n    dir.xz = rot2D(dir.xz, 45.);\n    dir = normalize(dir) ;\n    \n    vec3 cameraPos = vec3(0.0,7.0,3.0*offset) ;\n    \n\n   float lightElev = 10. * 3.14/180. ;\n   float lightAzi = 90. * 3.14/180. + time * 20. ;\n   vec3 lightDir = vec3(cos(lightAzi)*cos(lightElev),sin(lightElev),sin(lightAzi)*cos(lightElev));\n\n    \n    float rayDistTrans = 0.0 ;\n    float rayDistSolid = 0.0 ;\n    vec4 colour = vec4(vec3(0.0),1.0) ;\n    bool isTransPresent = rayMarchTrans(cameraPos,dir,rayDistTrans) ;\n    bool isSolidPresent = rayMarchSolids(cameraPos,dir,rayDistSolid) ;\n    \n    if (isTransPresent && isSolidPresent) {\n        if (rayDistSolid < rayDistTrans) {\n            colour = calcRocketColour(cameraPos+dir*rayDistSolid,dir,lightDir) ; \n        } else {\n        \tcolour = primaryRayMarchSmoke(cameraPos+dir*rayDistTrans,dir,lightDir) ; \n            colour = vec4(mix(colour.rgb,calcRocketColour(cameraPos+dir*rayDistSolid,dir,lightDir).rgb,colour.a),0.0) ;\n        }\n    } else if (isTransPresent) {\n        colour = primaryRayMarchSmoke(cameraPos+dir*rayDistTrans,dir,lightDir) ;\n    } else if (isSolidPresent) {\n        colour = calcRocketColour(cameraPos+dir*rayDistSolid,dir,lightDir) ;    \n    }\n    vec3 skyCol = calcSkyCol(dir,lightDir) ;\n    colour.rgb = mix(colour.rgb,skyCol,colour.a) ;\n    fragColor = vec4(colour.rgb,1.0) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 535, 568, 568, 688], [690, 690, 747, 747, 842], [844, 844, 870, 870, 1344], [1472, 1472, 1506, 1506, 2140], [2142, 2142, 2194, 2194, 2321], [2323, 2323, 2365, 2365, 2473], [2496, 2496, 2524, 2524, 2584], [2586, 2586, 2623, 2623, 2745], [2747, 2747, 2796, 2796, 2920], [2923, 2923, 2951, 2951, 3831], [3833, 3833, 3861, 3861, 4187], [4189, 4189, 4213, 4213, 4345], [4348, 4348, 4385, 4385, 4454], [4456, 4456, 4494, 4494, 4557], [4559, 4559, 4635, 4635, 4702], [4704, 4704, 4776, 4776, 4844], [4872, 4872, 4942, 4942, 5406], [5408, 5408, 5479, 5479, 5938], [6090, 6090, 6147, 6147, 6600], [6680, 6680, 6753, 6753, 7648], [7650, 7650, 7704, 7704, 8026], [8028, 8085, 8123, 8123, 8370], [8372, 8372, 8449, 8449, 9282], [9285, 9285, 9342, 9342, 10933]], "test": "valid"}
{"id": "ldfyzH", "name": "Sun Party Time", "author": "Ilygos", "description": "PARTY HARD !!!", "tags": ["partyhard"], "likes": 0, "viewed": 67, "published": "Public", "date": "1486994192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nbool wave(in vec2 coord, float pDistance)\n{\n    float myTime = iTime * 1.0;\n\tfloat WidthSea = cos(coord.x*2.0*1.5*pDistance*3.1415/360.0 - myTime) * 50.0*1.0/pDistance+125.0+25.0*1.0/pDistance;    \n    return coord.y <= WidthSea;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 pixCoord )\n{\n\t\tfloat h = 0.0;\n\n\tfloat m = pow( texture( iChannel0, vec2(h*0.5,0.25) ).x, 2.0 )*(1.0+2.0*h);\n    \n    //Camera\n    float camCenterX = iResolution.x/5.25 + 5.0*cos(m*1000.0);\n    float camCenterY = iResolution.y/5.25+ 5.0*sin(m*927.0);\n    float zoom = 0.4-0.3*m;\n\n    pixCoord.x = (pixCoord.x - camCenterX) / zoom;\n    pixCoord.y = (pixCoord.y - camCenterY) / zoom;\n    \n    float xTemp = pixCoord.x * cos(iTime) + pixCoord.y * sin(iTime);\n    float yTemp = -pixCoord.x * sin(iTime) + pixCoord.y * cos(iTime);\n    pixCoord.x = xTemp;\n    pixCoord.y = yTemp;\n   \n    //Drawing\n    float radius = 50.0;\n    float radtodeg = 180.0/3.1415;\n    float centerX = iResolution.x/1.25;\n    float centerY = iResolution.y/1.25;    \n    float angle = atan((centerX - pixCoord.x), (centerY - pixCoord.y))*radtodeg + iTime;\n    float distance = sqrt( pow(centerX - pixCoord.x, 2.0) + pow(centerY - pixCoord.y, 2.0));\n    \n    \n    if (wave(pixCoord, 1.0))\n        color  = vec4(0.0,0.0,1.0,1.0);\n    else if (distance < radius)\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n    else if (wave(pixCoord, 2.0))\n        color  = vec4(0.2,0.2,1.0,1.0);\n    else if (wave(pixCoord, 3.0))\n        color = vec4(0.3,0.3,1.0,1.0);\n    else if ((mod(angle, 15.0) >= 0.0 )&& mod(angle, 15.0) < 6.0)\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n    else\n       \tcolor = vec4(0.6, 0.6, 1.0, 1.0);\n\n}\n\n\n\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 45, 45, 233], [236, 236, 288, 288, 1654]], "test": "error"}
{"id": "ldlyWN", "name": "chaos pyramid", "author": "jes5199", "description": "chaos is no illusion: order is the illusiom", "tags": ["2d", "aliasing"], "likes": 1, "viewed": 142, "published": "Public", "date": "1488317140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((120.0 + iTime) / 3.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n  \n    float r = mod(iTime / 100.0 + acos(-1.0) / 4.0, acos(-1.0)*2.0);\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    uv = uv * rot;\n    \n    float value = (uv.x * sign(uv.y) + uv.y * sign(uv.x)) * sin(uv.x) * sin(uv.y);\n    float color = sin(value) * 3.0;\n    color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, high,1.0);\n    } else {\n      fragColor = vec4(high, high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 709]], "test": "valid"}
{"id": "ldlyzH", "name": "Circle ray intersection test", "author": "SalikSyed", "description": "just trying to get ray circle intersection working", "tags": ["raytracing"], "likes": 1, "viewed": 128, "published": "Public", "date": "1487113228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 intersectCircle(vec2 target, vec2 origin, vec2 sphereCenter, float r) {\n    vec2 d = target - origin;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, origin - sphereCenter);\n    float c = dot(sphereCenter, sphereCenter) + dot(origin, origin) - 2.0 * dot(sphereCenter, origin) - r*r;\n    float test = b*b - 4.0*a*c;\n\n    bool behind = length(origin - target) < length(origin - sphereCenter);\n    \n\tif (test >= 0.0 && !behind) {\n  \t\tfloat u = (-b - sqrt(test)) / (2.0 * a);\n  \t    vec2 hitp = origin + u * (target - origin);\n        \n        if (length(hitp.xy - target) > length(target - origin)) {\n            return vec3(-1.0,0.0,.0); \n        }\n        return vec3(1.0, hitp);\n    } else {\n        return vec3(-1.0,0.0,.0);   \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= aspectRatio;\n    vec2 sphereCenter = vec2(0.5 * aspectRatio, 0.5);\n    float sphereRadius = 0.3;\n    float orbitRadius = 0.5;\n    \n    vec2 lightPos = sphereCenter + vec2(orbitRadius * sin(iTime), orbitRadius * cos(iTime));\n    float lightRadius = 0.02;\n    \n    if (length(uv-sphereCenter) < sphereRadius) {\n        fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    } else if (length(uv-lightPos) < lightRadius) {\n        fragColor = vec4(1.0, 1.0, 0.0,1.0);\n    } else {\n        vec3 hit = intersectCircle(lightPos, uv, sphereCenter, sphereRadius);\n        if (hit.x >= 0.0) {\n            fragColor = vec4(vec3(0.0),1.0);\n        } else {\n            fragColor = vec4(0.8, 0.78, 0.85, 1.0);\n        }\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 77, 77, 747], [750, 750, 807, 807, 1625]], "test": "valid"}
{"id": "ldscWH", "name": "Smooth Noise Contours", "author": "Shane", "description": "Using a cheap - but effective - hack to produce antialiased-looking contour lines without the need for supersampling.", "tags": ["noise", "simplex", "antialias", "contour"], "likes": 122, "viewed": 6863, "published": "Public API", "date": "1488286653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tSmooth Noise Contours\n\t---------------------\n\n    Using a cheap - but effective - hack to produce antialiased-looking contour lines without the \n\tneed for supersampling. I had Airtight's elegant \"Cartoon Fire\" shader in mind when making this, \n\tand have provided a link to it below. \n\n\tI've always liked the abstract look of functional contour segments, lines, etc. There's a couple \n\tof ways to produce them, depending on the look you're going for. One method involves combining\n\tyour function value (noise, Voronoi, etc) with the \"fract\" function and the other involves \n\tstepping the function values with the \"floor\" function.\n\n    Each looks all right, except for the aliasing. You could take care of that with supersampling,\n\tbut it's a lot of work for the GPU, so I figured there might be a way to combine the \"smoothstep\" \n\tand \"fwidth\" functions to produce a smooth \"fract\" function. Since \"x - fract(x)\" is \"floor(x),\" \n\tyou'd get the \"floor\" function too.\n\n\tAfter playing around for a while, I came up with something that seems to work. As you can see,\n\tthe partitioned contours look relatively jaggy free, even after the application of border lines \n\tand highlighting.\n\n\tAnyway, the smooth fract \"sFract\" and complimentary smooth floor \"sFloor\" functions are below.\n\tThey haven't undergone extensive testing, so I'd use them cautiously. :)\n\n\tThe rest is just coloring and highlighting. I went for a simplistic cardboard cutout, vector-graphic\n\tstyle.\n\n\tSimilar examples:\n\n    Cartoon Fire - airtight\n\thttps://www.shadertoy.com/view/lsscWr\n\n    // More sophisticated smoothing method, but I might switch to this one in future.\n\tSmooth Voronoi Contours - Shane\n    https://www.shadertoy.com/view/4sdXDX\n\n\n*/\n\n\n// Variable to a keep a copy of the noise value prior to palettization. Used to run a soft gradient \n// over the surface, just to break things up a little.\nfloat ns;\n\n\n//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }\n//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat sFract(float x, float sm){\n    \n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.; \n    \n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n    \n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x){ return x - sFract(x, 1.); } \n\n// Standard hue rotation formula with a bit of streamlining. \nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n/*\n// Fabrices concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime*2., 6.2831853));\t\n\t//p.xy = m * p.xy;//rotate gradient vector\n    //p.yz = m * p.yz;//rotate gradient vector\n    //p.xz = m * p.xz;//rotate gradient vector\n    \n    //mat3 m = r3(mod(iTime*2., 6.2831853));\t\n    //vec3 th = mod(vec3(.31, .53, .97) + iTime*2., 6.2831853);\n    //mat3 m = r3(th.x, th.y, th.z);\n    //p *= m;\n\treturn p;\n\n}\n*/\n\n// vec3 to vec3 hash algorithm.\nvec3 hash33(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p)\n{\n    // Skewing the cubic grid, then determining the first vertice and fractional position.\n    vec3 i = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertice points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Dotting the fractional position with a random vector, generated for each corner, in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n     \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n\n}\n\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat func(vec2 p){\n    \n    // The noise value.\n    float n = tetraNoise(vec3(p.x*4., p.y*4., 0) - vec3(0, .25, .5)*iTime);\n    \n    // A tapering function, similar in principle to a smooth combine. Used to mutate or shape \n    // the value above. This one tapers it off into an oval shape and punches in a few extra holes.\n    // Airtight uses a more interesting triangular version in his \"Cartoon Fire\" shader.\n    float taper = .1 + dot(p, p*vec2(.35, 1));\n\tn = max(n - taper, 0.)/max(1. - taper, .0001);\n    \n    // Saving the noise value prior to palettization. Used for a bit of gradient highlighting.\n    ns = n; \n    \n    // I remember reasoning to myself that the following would take a continuous function ranging\n    // from zero to one, then palettize it over \"palNum\" discreet values between zero and one\n    // inclusive. It seems to work, but if my logic is lacking (and it often is), feel free to \n    // let me know. :)\n    const float palNum = 9.; \n    // The range should strictly fall between zero and one, but for some crazy reason, numbers fall\n    // outside the range, so I've had to clamp it. I know the computer is never wrong, so I'm \n    // probably overlooking something. Having said that, I don't trust the GPU \"fract\" function much.\n    //return clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.);\n    return n*.25 + clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.)*.75;\n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    // Function value.\n    float f = func(u);\n    float ssd = ns; // Saving the unpalettized noise value to add a little gradient to the color, etc.\n    \n    // Four sample values around the original. Used for edging and highlighting.\n    vec2 e = vec2(1.5/iResolution.y, 0);\n    float fxl = func(u + e.xy);\n    float fxr = func(u - e.xy);\n    float fyt = func(u + e.yx);\n    float fyb = func(u - e.yx);\n    \n    // Colorizing the function value, and applying some hue rotation based on position.\n    // Most of it was made up.\n    vec3 col = pow(min(vec3(1.5, 1, 1)*(f*.7 + ssd*.35), 1.), vec3(1, 2., 10)*2.) + .01;\n    col = rotHue(col, -.25+.4*length(u));\n\n    // Applying the dark edges.\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*5., 0.);\n    //col *= max(1. - length(vec2(fxl, fyt) - vec2(fxr, fyb))*7., 0.);\n    // Resampling with a slightly larger spread to provide some highlighting.\n    fxl = func(u + e.xy*1.5);\n    fyt = func(u + e.yx*1.5);\n    col += vec3(.5, .7, 1)*(max(f - fyt, 0.) + max(f - fxl, 0.))*ssd*10.;\n    \n    // Subtle, bluish vignette.\n    //u = fragCoord/iResolution.xy;\n    //col = mix(vec3(0, .1, 1), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.15 + .85);\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldscWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2103, 2146, 2178, 2231, 2636], [2640, 2726, 2748, 2748, 2776], [2779, 2841, 2870, 2870, 3240], [4230, 4262, 4283, 4649, 5028], [5032, 5422, 5451, 5542, 7031], [7034, 7114, 7133, 7162, 8533], [8537, 8537, 8591, 8619, 9983]], "test": "valid"}
{"id": "ldsyz4", "name": "Numbers with LUT and Bits", "author": "iq", "description": "Converted Paul Malin's shader ([url=https://www.shadertoy.com/view/4sf3RN]4sf3RN[/url]) to using a Look Up Table and bit operations", "tags": ["2d", "utility", "numbers", "array", "lut"], "likes": 20, "viewed": 1182, "published": "Public API", "date": "1487310154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader shows how to initialize arrays, and to to perform bit operations\n\n\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt( in vec2 uv, in int value, const int maxDigits )\n{\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2( -iResolution.x + 2.0*fragCoord)/iResolution.x;\n    p = p*2.2 + vec2(1.9,1.4);\n    \n    int f = PrintInt( p, iFrame % 10000, 4 );\n    \n    vec3 col = vec3( f );\n\n    fragColor = vec4( col, 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsyz4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1161, 1413, 1476, 1476, 1835], [1837, 1837, 1894, 1894, 2115]], "test": "error"}
{"id": "ldXyDn", "name": "Ben's first SDF shader", "author": "bio998", "description": "playing around with SDF tutorials", "tags": ["sdf"], "likes": 1, "viewed": 513, "published": "Public API", "date": "1487659347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ben's first shader. Well really it is Cabbibo's shader tutorial available at\n// https://www.shadertoy.com/view/Xl2XWt\n\n\n/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp://tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps://www.shadertoy.com/view/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps://www.shadertoy.com/view/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps://www.shadertoy.com/view/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https://www.shadertoy.com/view/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps://www.shadertoy.com/view/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https://www.shadertoy.com/view/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left / right\n\ty = up / down\n\tz = forwards / backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t//---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t//---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t//---------------------------------------------------\n    // SECTION 'C' : NAVIGATING THE WORLD\n    //---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    //--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'E' : COLORING THE WORLD!\n    //--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps://en.wikipedia.org/wiki/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*/\n\n\n\n//---------------------------------------------------\n// SECTION 'B' : BUILDING THE WINDOW\n//---------------------------------------------------\n\n// Most of this is taken from many of the shaders\n// that @iq have worked on. Make sure to check out\n// more of his magic!!!\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n//--------------------------------------------------------------\n\n\n//'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  // First we define our balloon position\n  vec3 balloonPosition = vec3( .0 , .3 , -0.2 );\n    \n  // than we define our balloon radius\n  float balloonRadius = .8;\n    \n  // Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  // finally we get the distance to the balloon surface\n  // by substacting the balloon radius. This means that if\n  // the distance to the balloon is less than the balloon radius\n  // the value we get will be negative! giving us the 'Signed' in\n  // Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  // Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  // And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  // First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 sdfRoundBox( vec3 currentRayPosition ){\n    \n  float xpos = sin(iTime);\n  \n  // First we define our box position\n  //vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n  vec3 boxPosition = vec3( xpos , -.4 , 0.2 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  //float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  vec3 zero = vec3(0.2);\n  float distanceToBoxSurface = udRoundBox(adjustedRayPosition, zero, 0.15);\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 3.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\nfloat smin( float a, float b)\n{\n   // float k = 0.77521;\n        \n    float k = 0.2521;\n\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  vec2 box     = sdfRoundBox( currentRayPosition );\n        \n  result = whichThingAmICloserTo( balloon , box );\n  result.x = opBlend( balloon.x, box.x);\n\n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.001;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 100;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.1,0.2,0.2 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 0.1 , 0.8 , 0.1 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n}\n\n\nvec3 doCurveBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 0.8 , 0.1 , 0.1 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n}\n\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }else if( rayHitInfo.y == 3.0 ){\n          \n      \tcolor = doCurveBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    vec3 eyePosition = vec3( 0., 0., 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXyDn.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[15180, 15582, 15665, 15665, 15843], [16047, 16064, 16107, 16152, 17019], [17022, 17022, 17061, 17102, 18187], [18189, 18189, 18233, 18233, 18274], [18276, 18276, 18320, 18320, 19633], [19635, 19635, 19666, 19691, 19816], [19819, 19819, 19855, 19919, 19948], [19950, 20145, 20201, 20201, 20585], [20593, 20745, 20789, 20789, 21042], [22215, 22410, 22473, 22678, 26864], [27041, 27403, 27452, 27452, 28449], [28455, 28543, 28568, 28568, 28599], [28604, 28604, 28668, 28668, 29763], [29766, 29766, 29831, 29831, 30926], [30930, 31051, 31111, 31111, 31310], [31315, 31416, 31493, 31557, 32897], [32901, 32901, 32958, 33402, 36319]], "test": "valid"}
{"id": "ll3Gz7", "name": "ellipse circle intersection area", "author": "wdobbie", "description": "Numerical approximation to area of intersection of ellipse and circle", "tags": ["intersection", "circle", "ellipse"], "likes": 0, "viewed": 139, "published": "Public", "date": "1487992856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NSTEPS 16\n#define pi 3.1415926535\n\nfloat computeCoverage(vec2 eo, vec2 es)\n{\n    bool swapped = false;\n    if (es.x * es.y > 1.0 || true) {\n        es = 1.0 / es;\n        eo *= -es;\n        swapped = true;\n    }\n    \n    float area = 0.0;\n    float theta = 0.0;\n    float thetaStep = 2.0*pi/float(NSTEPS);\n\tvec2 prev = vec2(es.x * cos(0.0) + eo.x,\n                     es.y * sin(0.0) + eo.y);\n    float r = length(prev);\n    if (r > 1.0) {\n        prev /= r;\n    }\n    \n    for (int i=0; i<NSTEPS; i++) {\n        theta += thetaStep;\n        float x = es.x * cos(theta) + eo.x;\n        float y = es.y * sin(theta) + eo.y;\n\n        float r = length(vec2(x, y));\n        if (r > 1.0) {\n            x /= r;\n            y /= r;\n        }\n\n        area += prev.x * y;\n        area -= prev.y * x;\n        \n        prev = vec2(x, y);\n    }\n    \n    area *= 0.5;\n\t\n    if (swapped) {\n        return area / (pi * es.x * es.y);\n    }\n    \n    return area / pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 eo = fragCoord - iResolution.xy / 2.0;\n    eo *= 5.0;\n    float osc1 = sin(iTime * 2.0) + 2.0;\n    float osc2 = sin(iTime * 3.0) + 2.0;\n    vec2 es = vec2(200.0, 400.0);\n    \n    vec2 off = iMouse.xy - iResolution.xy * 0.5;\n    off = vec2((sin(iTime) * 0.5 + 0.5) * 200.0);\n    float circleRadius = off.x * 3.0 + 1.0;\n    eo /= circleRadius;\n    es /= circleRadius;\n    \n    float coverage = 1.0 - computeCoverage(eo, es);\n    \n    fragColor = vec4(coverage, coverage, coverage, 1.0);\n}\n    \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3Gz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 84, 84, 960], [962, 962, 1019, 1019, 1562]], "test": "valid"}
{"id": "llGSD3", "name": "Scanlines--moving", "author": "agconti", "description": "Simple scanline implementation ", "tags": ["scanline"], "likes": 2, "viewed": 667, "published": "Public API", "date": "1486136544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float scanlineIntesnsity = 0.125;\n    float scanlineCount = 800.0;\n    float scanlineYDelta = sin(iTime / 200.0);\n    \n\tfloat scanline = sin((uv.y - scanlineYDelta) * scanlineCount) * scanlineIntesnsity;\n\n\tcol -= scanline;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 382]], "test": "valid"}
{"id": "llGSDK", "name": "Clouds cover", "author": "piluve", "description": "This is a WIP! ;P\n\nThis is a prototype that I would like to implement in a demo that I am working on.\nI am performing a raycast to a plane and then sampling some noise from the intersection point.\n\nThanks @iq for the noise functions!", "tags": ["noise", "raycast", "cloud"], "likes": 2, "viewed": 679, "published": "Public API", "date": "1485950160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t..::Clouds cover nachocpol@gmail.com::..\n\t\n\tThis is a WIP! ;P\n\n\tThis is a prototype that I would like to implement in a \n\tdemo that I am working on.\n\tI am performing a raycast to a plane and then sampling some noise from the \n\tintersection point.\n\n\tThanks @iq for the noise functions!\n*/\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n/*\n\tFractal noise 7 iter [0,1]\n*/\nfloat fractn(vec3 p)\n{\n    float f = 0.0;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n    f += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p); p = 2.0 * p;\n    f += 0.015625 * noise(p); p = 2.0 * p;\n    f += 0.0078125 * noise (p); p = 2.0 * p;\n    \n    return f;\n}\n\nstruct Plane\n{\n    vec3 Point;\n    vec3 Normal;\n};\n\nfloat iPlane( vec3 ro, vec3 rd, Plane plane)\n{\n    float hit = 0.0;\n    float dotP = dot(rd,plane.Normal);\n    if(dotP == 0.0)\n    {\n        return hit;\n    }\n    \n    float distToHit = dot(plane.Point - ro, plane.Normal) / dotP;\n    if(distToHit < 0.0)\n    {\n        return hit;\n    }\n    \n    hit = distToHit;\n    return hit;\n}\n\n/*\n\tWe perform a set of samples from the point that we hit the cloud\n\tby a distance. The returned value will tell us how \"thick\" each cloud\n\tis so we can simulate light absorption.\n\tWith 16 samples we can see some banding.\n\tIf I increase the samples my WebGl just crashes :C\n*/\nfloat scattering(vec3 ro,vec3 rd)\n{\n    const int samples = 16;\n    float sampleDist = 1.0;\n    float acum = 0.0;\n    for(int i = 0; i < samples; i++)\n    {\n        float idx = float(i) / float(samples);\n        acum += fractn(ro + (rd * (idx * sampleDist)));\n    }\n    return acum / float(samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = (fragCoord.xy/iResolution.xy) - 0.5;\n    \n    // Colors\n    vec3 color = vec3(0.0,0.0,0.0); \n    vec3 skyColor = mix(vec3(1.0,1.0,1.0),vec3(0.5,0.8,0.98),sqrt(uv.y + 0.5));\n    color = skyColor;\n    \n    // Plane clouds\n    Plane clouds;\n    clouds.Point = vec3(0.0,200.0,0.0);\n    clouds.Normal = vec3(0.0,1.0,0.0);\n    \n    // Setup camera\n    vec3 camUp = vec3(0,1,0);\n    vec3 camFront = vec3(0,0.1,1);\n    vec3 camRight = vec3(1,0,0);\n    vec3 camPos = vec3(0,0,-1) * 0.0;\n    vec3 camRay = camUp * uv.y + camRight * uv.x + camFront;\n    \n\t// Check clouds intersection\n    float id = 0.0;\n    float dPlane = iPlane(camPos,camRay,clouds);\n    vec3 cloudColor = vec3(0.0,0.0,0.0);\n    if(dPlane > 0.0)\n    {\n        // Sample noise and modulate noise\n        vec3 pos = camPos + (camRay * dPlane);\n        vec2 off = vec2(iTime,iTime) * vec2(-10,0);\n        float n = fractn(vec3(pos.x + off.x,pos.y,pos.z + off.y) *0.002);\n        n = smoothstep(0.2,1.0,n);\n        cloudColor = mix(skyColor,vec3(1.0,1.0,1.0),n);\n        \n        // Fade with distance\n        float alpha = abs(1.0 - clamp(dPlane/5000.0,0.0,1.0));\n        cloudColor = mix(skyColor,cloudColor,alpha);\n        \n        // Cloud Scattering\n        float scat = scattering(vec3(pos.x + off.x,pos.y,pos.z + off.y) *0.002,camRay);\n        scat = smoothstep(0.0,0.7,scat);\n        color = mix(skyColor,cloudColor * scat,alpha);\n\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 293, 314, 314, 409], [411, 411, 437, 437, 911], [913, 947, 969, 969, 1318], [1372, 1372, 1418, 1418, 1701], [1703, 1981, 2016, 2016, 2282], [2284, 2284, 2341, 2341, 3797]], "test": "valid"}
{"id": "llGSzw", "name": "Integer Hash - I", "author": "iq", "description": "Using integer arithmetic and bit operations to create a hash. Traditionally in Shadertoy and most WebGL demos people used aliasing through fract(sin(dot())) to generate random numbers, which was machine dependent. That approach is no longer needed.", "tags": ["2d", "hash", "integers"], "likes": 76, "viewed": 6836, "published": "Public API", "date": "1487235724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// See these too: \n//\n// - https://www.shadertoy.com/view/llGSzw\n// - https://www.shadertoy.com/view/XlXcW4\n// - https://www.shadertoy.com/view/4tXyWN\n//\n// Do NOT use this hash as a random number generator. Use it only to inialize\n// the seed of a random number generator. Do NOT call this hash recursivelly,\n// it is NOT a random number generator.\n\n// Enable this for color noise\n#define RGB\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(fragCoord);\n\n#ifdef RGB\n\tvec3 c = hash3( p.x + 1920U*p.y + (1920U*1080U)*uint(iFrame) );\n#else    \n    vec3 c = vec3( hash1( p.x + 1920U*p.y + (1920U*1080U)*uint(iFrame) ) );\n#endif    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGSzw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1430, 1474, 1498, 1541, 1679], [1681, 1681, 1704, 1747, 1930], [1933, 1933, 1990, 1990, 2224]], "test": "valid"}
{"id": "llGXDK", "name": "Humming Circles", "author": "AllWeather", "description": "Simple shrinking shader intended to be used to form concentric circles on a 2D face", "tags": ["2d", "circles"], "likes": 0, "viewed": 87, "published": "Public", "date": "1485910011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // As time tends towards infinity, The pattern starts to warp into a ripple effect.\n    // Assuming this is because as Time trends towards infinity, then x = sin(Time) - cos(Time), y = sin(Time). \n    // Will need to hassle the Maths Learning Center guys to know for certain.\n\t\n    vec2 uv; // leaving the superfluous uv as a negative reminder that I can write direct to fragColor (Thanks GregRostami!)\n    uv.y = sin(iTime * length(fragCoord/iResolution.xy));\n    uv.x = uv.y - cos(iTime);\n    fragColor = vec4(uv,0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 337, 588]], "test": "valid"}
{"id": "llKSDc", "name": "Oxford CompSoc logo animated", "author": "Guthix", "description": "Alternates between a binary representation of \"OX\" (the CompSoc logo) and a binary representation of CS (short for Computer Science). Created by me during a society geek night.", "tags": ["2d", "circles", "logo", "ox", "cs"], "likes": 0, "viewed": 72, "published": "Public", "date": "1486304361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float d = iResolution.y*3.0/34.0;\nconst vec4 light = vec4(205.0,214.0,224.0,255.0)/255.0;\nconst vec4 dark = vec4(32.0,74.0,135.0,255.0)/255.0;\nvec2 foo;\nbool bar;\n\nvec4 circle(vec2 pos,vec2 fragCoord, float theta){\n    vec2 opos = pos; //\n    for(float i=0.0;i<4.0;i++){\n        for(float j=0.0;j<4.0;j++){\n            \n            pos.x = opos.x + j*8.0*d*(abs(sin(iTime)))/3.0;\n            pos.y = opos.y + i*sin(iTime)*-8.0*d/3.0;\n            \n            if (length(pos-fragCoord)<=d){\n                foo = vec2(i,j);\n                bar = (sin(iTime)>0.0);\n                if(!bar){\n                \treturn ((i==2.0&&j<3.0)||j==1.0||foo==vec2(0,2)||foo==vec2(3,3)) ? dark:light;\n                }else{\n                    return ((i==3.0&&j>0.0)||(i==2.0&&mod(j,2.0)==1.0)||(i==1.0&&mod(j,2.0)==0.0)) ? dark:light;\n                }\n            }\n        }\n    }\n    //return vec4(0.5*sin(iTime*4.0)+0.5,0.5*cos(iTime)+0.5,0.5*sin(3.0*iTime + 45.0)+0.5,1.0);\n    return vec4(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = circle(vec2((2.0/3.0-(2.0/3.0)*abs(sin(iTime)))*iResolution.x/3.5 +5.0*d/3.0,(1.0+sin(iTime))*iResolution.y/3.0 +5.0*d/3.0), fragCoord, iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 214, 214, 988], [990, 990, 1046, 1046, 1208]], "test": "valid"}
{"id": "llKXDt", "name": "magic number 0x9e3779b1", "author": "slarsen", "description": "does a int overflow and can be used to lightly randomize. Gives some interesting patterns", "tags": ["0x9e3779b1"], "likes": 1, "viewed": 468, "published": "Public API", "date": "1486588324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    highp int rando = int(iTime * 10.0);\n    rando *= 0x9e3779b1;\n    \n    highp int r = int(fragCoord.x + float(rando));\n    \n    rando *= 0x9e3779b1;\n    \n    highp int g = int(fragCoord.y + float(rando));\n    \n    rando *= 0x9e3779b1;\n    \n    highp int b = int(fragCoord.x + fragCoord.y + float(rando));\n    \n    r *= 0x9e3779b1;\n    g *= 0x9e3779b1; \n    b *= 0x9e3779b1; \n    \n    vec3 color = vec3(float(r), float(g), float(b));\n    color /= 2000000000.0;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 605]], "test": "valid"}
{"id": "llyXDV", "name": "Signed Distance to PolySpline", "author": "arkamarante", "description": "Inspired by CPU's Bezier SDF shader   https://www.shadertoy.com/view/MtVSRD\nand ajs15822's  polyspline https://www.shadertoy.com/view/ltXSDB\n", "tags": ["2d", "bezier", "spline", "distance"], "likes": 30, "viewed": 1683, "published": "Public API", "date": "1485944200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Signed Distance to a polySpline \n//\n// Inspired by CPU's shader   https://www.shadertoy.com/view/MtVSRD\n// and ajs15822's  https://www.shadertoy.com/view/ltXSDB\n// \n//My first objective was to make an anti-aliased version of CPU's polyspline shader,\n//but without the distance field seems impossible for me, at least without calculating 4 samples of each pixel,\n//so i tried a distance field aproach and mix 3 distance fields.\n\n//Calculating the 3 distance field to the 3 beziers like ajs15822's shader did not work either,\n//but using the sign calculation of the first polyspline shader into this second shader did the job.\n//Pretty slow to use it on anything real.\n\n\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;    // * signBezier(A, B, C, p);  //No need for this sign\n}\n\n\n#define setX(f) if (f>=0.&& f<1. && mix(mix(a.x,b.x,f),mix(b.x,c.x,f),f)<X) odd=!odd;\n\n\tfloat polySpline(vec2 p,vec2 AA,vec2 BB,vec2 CC,vec2 FF,vec2 GG,vec2 HH) {\n\t\tbool odd = false;\n\t\tfloat eps = 1e-7, root, A, B, C, X = p.x, Y = p.y;\n\t\t\n\t\tvec2 a = AA.xy;// readCell(np - 1., 0.).xy;\n\t\n\t\tvec2 b = BB.xy;\n\t\tvec2 c = CC.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\t//------\n\t\tb = FF.xy;\n\t\tc = GG.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\t\t\n\t\t//------\n\t\tb = HH.xy;\n\t\tc = AA.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\treturn float(odd);\n\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(-0.4, -0.6), C = vec2(-0.6, +0.4001), B = (4.0 * m - A - C) / 2.0;\n    B= vec2(-1.4,0.0);\n    \n    vec2 F=vec2(0.5,0.5);\n    vec2 G=vec2(1.25,0.5);\n    vec2 H=vec2(0.5,-0.5);\n    \n    F.x += cos(iTime * 0.5) * 0.8;\n    F.y += cos(iTime * 3.5) * 0.4;\n        \n    H.x += cos(iTime * 0.53) * 0.8;\n    H.y += cos(iTime * 3.35) * 0.4;\n    \n    B.x += 0.7 + cos(iTime * 0.53) * 0.45;\n    B.y += cos(iTime * 3.35) * 0.4;\n        \n    G.x += cos(iTime * 0.3) * 0.4;\n    G.y += cos(iTime * 2.35) * 0.2;\n        \n    A.x += cos(iTime * 0.3) * 0.4;\n    A.y += cos(iTime * 2.35) * 0.2;\n    \n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G), min(distance(p,B),   min(distance(p, A),(min(distance(p, F),distance(p, C)))))) );\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n       \n    float spSign =polySpline(p,A,B,C,F,G,H);\n    \n    d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n       \n    // Visualize the distance field using iq's orange/blue scheme\n    fragColor = vec4(1.0) - sign(d)*vec4(0.1,0.4,0.7,1.0);\n    fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[673, 736, 777, 777, 843], [845, 915, 965, 965, 1316], [1318, 1352, 1396, 1396, 1909], [1911, 1970, 2018, 2018, 2563], [2654, 2654, 2728, 2728, 3798], [3801, 3801, 3858, 3858, 5642]], "test": "valid"}
{"id": "lsfcD4", "name": "chaos portal", "author": "jes5199", "description": "aliasing effects in squares and diamonds", "tags": ["2d", "diamonds", "artifacts"], "likes": 4, "viewed": 209, "published": "Public", "date": "1488225734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((130.0 + iTime) / 3.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    float value = (uv.x * sign(uv.y) + uv.y * sign(uv.x)) * sin(uv.x) * sin(uv.y);\n    float color = sin(value) * 3.0;\n    color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(high, med, high,1.0);\n    } else {\n      fragColor = vec4(med, high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfcD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 563]], "test": "valid"}
{"id": "lsfcD8", "name": "Upper Half Plane", "author": "soma_arc", "description": "Hyperbolic Tessellation on the upper half plane.\nMapping function for the upper half plane to the Poincare disk :  f(z) = (z - i)/(z + i)", "tags": ["2d", "tiling", "tessellation"], "likes": 10, "viewed": 209, "published": "Public", "date": "1487946823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 tp1 = vec2(0.26607724, 0);\nvec2 tp2 = vec2(0, 0.14062592);\nvec2 cPos = vec2(2.01219217, 3.62584500);\nfloat r = 4.02438434;\nconst float PI = 3.14159265359;\n\nvoid calcCircle(float theta, float phi){\n\tfloat tanTheta = tan(PI/2. - theta);\n    float tanPhi = tan(phi);\n    float tanTheta2 = tanTheta * tanTheta;\n    float tanPhi2 = tanPhi * tanPhi;\n    \n    tp1 = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)) - \n               tanTheta * sqrt((1. + tanPhi2)/(-tanPhi2 + tanTheta2))/tanTheta, 0.);\n    tp2 = vec2(0., -tanPhi * sqrt(-(1. + tanTheta2)/(tanPhi2 - tanTheta2))+\n              tanTheta * sqrt(-(1. + tanPhi2)/(tanPhi2 - tanTheta2)));\n    \n    \n    cPos = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)),\n                 sqrt((1. + tanPhi2)*tanTheta2/(-tanPhi2 + tanTheta2))\n               );\n    r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 20;\nfloat colCount = 0.;\nint IIS(vec2 pos){\n    if(length(pos) > 1.) return 0;\n\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) < r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            colCount++;\n            fund = false;\n        }\n        if(fund)\n        \treturn invCount;\n    }\n\n\treturn invCount;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 compQuot(const vec2 a, const vec2 b){\n\tfloat denom = dot(b, b);\n    return vec2((a.x * b.x + a.y * b.y) / denom,\n                (a.y * b.x - a.x * b.y) / denom);\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\n\n\nfloat quartEasingInOut(float t) {\n\tt *= 2.;\n\tif (t < 1.) return .5*t*t*t*t*t;\n\tt -= 2.;\n\treturn .5*(t*t*t*t*t + 2.);\n}\n\t\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nconst float sampleNum = 30.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    vec3 sum = vec3(0);\n    calcCircle(PI/4., PI/8.);\n\tfloat t = mod(iTime, 4.);    \n    float zoomingTime = 2.;\n    float stay = 0.;\n    const float maxZoomOut = 5.;\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        position.y += 0.3;\n\n        //position = position * 2.;\n        \n        if(t < zoomingTime + stay)\n        \tposition *= mix(maxZoomOut, 0.01,\n                            quartEasingInOut(scene(t, 0., zoomingTime)));\n        else\n            position *= mix(0.01, maxZoomOut,\n                            quartEasingInOut(scene(t, zoomingTime + stay, zoomingTime)));\n\n        //position += vec2(cos(iTime), 0.3 * sin(iTime));\n\t\t\n        if(position.y < 0.) continue;\n        \n        // upper half plane -> Poincare disk\n        vec2 poincare = compQuot(position - vec2(0, 1), position + vec2(0, 1));\n      \t\n        int d = IIS(poincare);\n\n       \tif(d == 0){\n           \tsum += vec3(0.,0.,0.);\n       \t}else{\n           \tif(mod(float(d), 2.) == 0.){\n               \tsum += hsv2rgb(vec3(0.5 + position.y * 0.05, 1., 1.));\n        \t}else{\n            \tsum += hsv2rgb(vec3(1., 1., 1.));\n        \t}\n        }\n    }\n    fragColor = vec4(sum/sampleNum, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 91, 132, 132, 421], [584, 584, 624, 624, 1307], [1309, 1309, 1369, 1369, 1485], [1535, 1535, 1553, 1553, 2160], [2162, 2162, 2184, 2184, 2353], [2355, 2355, 2397, 2397, 2524], [2526, 2526, 2557, 2557, 2664], [2666, 2666, 2694, 2694, 2730], [2732, 2732, 2759, 2759, 2799], [2802, 2802, 2835, 2835, 2920], [2924, 2924, 2972, 2972, 3013], [3044, 3044, 3100, 3100, 4436]], "test": "valid"}
{"id": "lsfcDH", "name": "Circle Grid", "author": "SalikSyed", "description": "Just another test", "tags": ["lightcircles"], "likes": 7, "viewed": 242, "published": "Public", "date": "1488040338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat integrate(vec2 center, float radius, vec2 pt) {\n    if (length(pt - center) > 0.5) {\n     \treturn 0.0;   \n    }\n    float sum = 0.0;\n    for(int i  = 0; i < 28; i++) {\n     \tfloat theta = (float(i) / 28.0) * 2.0 * 3.14 + 0.1*iTime;\n        vec2 curr = center + radius * vec2(cos(theta), sin(theta));\n        float d = length(curr - pt);\n        sum += 1.0 / (pow(d, 1.44));\n    }\n    return 0.005*sum;\n}    \n\n\n\n\n\nfloat compute_light_from_square(vec2 outerMin, vec2 outerMax, vec2 pos) {\n   \tfloat d = 0.0;\n    // compute the light contribution from each fluorescent segment\n    d += integrate(0.5*(outerMin+outerMax), 0.5 * (outerMax.x - outerMin.x), pos);\n    return d;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoordinate )\n{\n    fragColor = vec4(0.0);\n    vec2 pos = fragCoordinate/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    pos.x *=aspect;\n    float PADDING_X = 0.1;\n    float PADDING_Y = 0.1;\n    int NUM_BOXES = 6;\n    float BOX_PADDING = 0.009;\n    float boxWidth = (1.0-2.0*PADDING_X-0.5*float(NUM_BOXES-1)*BOX_PADDING)/float(NUM_BOXES);\n    float boxHeight = (1.0-2.0*PADDING_X-0.5*float(NUM_BOXES-1)*BOX_PADDING)/float(NUM_BOXES);\n    float d = 0.0;\n    for(int i = 0; i < 2*NUM_BOXES; i++) {\n        for(int j = 0; j < NUM_BOXES; j++) {\n\t\t\tvec2 outerMin = vec2(float(i) * boxWidth + PADDING_X, float(j) * boxHeight + PADDING_Y);\n            vec2 outerMax = outerMin + vec2(boxWidth, boxHeight);\n            outerMin += vec2(BOX_PADDING, BOX_PADDING);\n            outerMax -= vec2(BOX_PADDING, BOX_PADDING);\n\t\t\td += compute_light_from_square(outerMin, outerMax, pos);\n        }\n    }\n    vec4 mixColor =  vec4(19.0/255.0, 98.0/255.0, 128.0/255.0, 1.0);\n    fragColor =  mix(0.00015 *vec4(pow(d, 2.0 + 0.23)), mixColor, 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfcDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 55, 55, 411], [421, 421, 494, 494, 680], [687, 687, 749, 749, 1783]], "test": "valid"}
{"id": "lsfyRH", "name": "Light on a sphere", "author": "Teurkidosh", "description": "Light on a sphere, using dot product.", "tags": ["3d"], "likes": 1, "viewed": 84, "published": "Public", "date": "1486984486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SPEED = 1.5;\n\nvoid drawSphere( out vec4 fragColor, in vec2 fragCoord, in vec2 center, in vec4 color, in float radius)\n{    \n    vec2 pos = fragCoord - center;\n    \n    vec3 lumVector = vec3(sin(iTime*SPEED),0.39,cos(iTime*SPEED));\n    vec3 posVector = vec3(pos.x, pos.y, sqrt(pow(radius, 2.0)-pow(pos.x, 2.0)-pow(pos.y, 2.0)));\n    \n    vec3 unitLumVector = normalize(lumVector);\n    vec3 unitPosVector = normalize(posVector);\n    \n    float lumIntensity = unitLumVector.x*unitPosVector.x+unitLumVector.y*unitPosVector.y+unitLumVector.z*unitPosVector.z;   \n    \n    if(sqrt(pow(pos.x,2.0)+pow(pos.y,2.0))<radius){\n        fragColor = color * lumIntensity;\n    }\n}\n\nvoid drawSphereDiagonal(out vec4 fragColor, in vec2 fragCoord, in vec4 beginColor, in vec4 endColor, in float nbSphere)\n{\n    vec4 deltaColor = endColor-beginColor;\n    vec4 stepColor = deltaColor / (nbSphere-1.0);\n   \n    float radius = iResolution.y/(nbSphere+5.0);\n    vec2 beginCenter = vec2(iResolution.x/(nbSphere+1.0), iResolution.y/(nbSphere+1.0));\n    \n    vec2 center;\n    vec4 color;\n    \n    for(float i = 1.0; i<=nbSphere; i += 1.0)\n    {\n        center = beginCenter * i;\n        color = beginColor + stepColor*(i-1.0);\n        \n        drawSphere(fragColor, fragCoord, center, color, radius);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 myBlue = vec4(0.1,0.65,0.9,0.0);\n    vec4 myRed = vec4(0.9,0.225,0,0.0);\n    vec4 myViolet = vec4(0.9,0.1,0.9,0.0);\n    float nbSpheres = 2.0;\n    /*\n    float radius = iResolution.y/5.0;\n    \n    fragColor = vec4(0.1,0.1,0.1,0.5);\n    \n    vec2 camCenter = vec2(iResolution.x/4.0, iResolution.y/4.0);\n    \n    \n    drawSphere(fragColor, fragCoord, camCenter, myBlue, radius);\n    \n    camCenter = vec2(3.0*iResolution.x/4.0, 3.0*iResolution.y/4.0);\n    vec4 myRed = vec4(0.9,0.225,0,0.0);\n    \n    drawSphere(fragColor, fragCoord, camCenter, myRed, radius);\n    \n    camCenter = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    \n    \n    drawSphere(fragColor, fragCoord, camCenter, myViolet, radius);\n\t*/\n    \n    drawSphereDiagonal(fragColor, fragCoord, myBlue, myRed, nbSpheres);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 131, 131, 675], [677, 677, 798, 798, 1292], [1294, 1294, 1351, 1351, 2144]], "test": "valid"}
{"id": "lsfyW4", "name": "Tunnel Beauty 8", "author": "aiekick", "description": "Tunnel Beauty 8", "tags": ["tunnel", "8", "beauty"], "likes": 19, "viewed": 841, "published": "Public API", "date": "1488201199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvec2 df(vec3 p)\n{\n\tfloat z = p.z * .13;\n\tp.xy *= mat2(cos(z),-sin(z),sin(z),cos(z));\n\tfloat mesh = length(cos(p.xz)) - 1.;\n\tfloat tri = max(abs(p.x)+p.y,-p.y) - 5.;\n\treturn vec2(length(vec2(mesh,tri)) - 0.15, 0);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nfloat SubDensity(vec3 p, float ms) \n{\n\treturn df(p - nor(p,0.0001) * ms).x/ms;\n}\n\nvec2 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 ldo, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 ldp = normalize(lp-n*1.5-p);\n\tvec3 refl = reflect(rd,n);\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, ldp ), 0.0, 1.0);\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4.);\n\tfloat spe = pow(clamp( dot( refl, ldo ), 0.0, 1.0 ), 16.);\n\tfloat sss = 1. - SubDensity(p, 0.1);\n\treturn vec2(\n        (diff + fre + spe) * amb * li,\n        (diff + fre + sss) * amb * li + spe\n    );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfloat t = iTime * 5.;\n\n    vec3 ld = vec3(0.,1., .5);\n    \n\tvec3 ro = vec3(0,0,t);\n\tvec3 cu = vec3(0,1,0);\n\tvec3 tg = ro + vec3(0,0,.1);\n\t\n\tfloat fov = .5;\n\tvec3 z = normalize(tg - ro);\n\tvec3 x = normalize(cross(cu, z));\n\tvec3 y = normalize(cross(z, x));\n\tvec3 rd = normalize(z + fov * (uv.x * x + uv.y * y));\n\t\n\tfloat s = 1., d = 1.;\n\tfloat dm = 200.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dm) break;\n\t\td += (s = df(ro + rd * d).x) * .3;\n\t}\n\t\n    fragColor.rgb = GetSky(rd, ld, vec3(1.5));\n    \n\tif (d<dm)\n\t{\n\t\tvec2 sh = shade(ro, rd, d, ro, ld, 1.);\n\t\tfragColor.rgb = mix( \n            vec3(.49,1,.32) * sh.y * .6 + vec3(.45,0,.72) * sh.x * 1.2, \n            fragColor.rgb, \n            1.0 - exp( -0.001*d*d ) ); \n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfyW4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 231, 231, 428], [430, 430, 462, 462, 640], [642, 704, 761, 761, 1049], [1051, 1051, 1088, 1088, 1131], [1133, 1133, 1201, 1201, 1634], [1636, 1636, 1690, 1690, 2499]], "test": "valid"}
{"id": "lslyRH", "name": "Quantum-178", "author": "rubelson", "description": "The simple spirograph from the russian magazine 'Kvant' No. 1 1978. A demo the taken 2nd place of the competition tiny intro on demoparty Chaos Constructions 2014", "tags": ["2d", "graph", "polar", "spirograph"], "likes": 8, "viewed": 221, "published": "Public", "date": "1487105736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{vec2 R = iResolution.xy; \nvec2 u = fragCoord - R/2.; \nfloat a = 0.32; \nfloat b = 0.2; \nfloat d = 1.0125 / 32.; \nfloat c = 159. * d; \nconst float pi = 3.14159265; \nfloat fi=atan(u.x,u.y); \nvec3 col = vec3(0.,0.,1.); \nfor (float i=0.; i<pi; i+=pi/16.) \n{float temp1 = i + c*fi - iTime; \nfloat temp2 = i + d*fi + iTime; \ncol += 0.0005 / abs(a + b*sin(temp1)*sin(temp2) - length(u)/(R.y/1.15));} \nfragColor = vec4(col, 1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 479]], "test": "valid"}
{"id": "lslyRn", "name": "Star Nest VR", "author": "conclusio", "description": "Copied from user Kali to make this simple yet beautiful shader available through the API and for VR.\nSee https://www.shadertoy.com/view/XlfGRj", "tags": ["fractal", "space", "stars", "vr"], "likes": 22, "viewed": 3995, "published": "Public API", "date": "1486763025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Nest by Pablo RomÃ¡n Andrioli\n// copied from https://www.shadertoy.com/view/XlfGRj\n//\n// This content is under the MIT License.\n// (copied for API availability + VR)\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslyRn.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 434, 512, 540, 1335], [1337, 1337, 1394, 1422, 1925]], "test": "valid"}
{"id": "lsscW4", "name": "Game Maker Studio Shader -Lights", "author": "Glim888", "description": "A Lights shader for Game Maker Studio\n\nMy App´s:\nBluetooth Multiplayer: play.google.com/store/apps/details?id=com.gaming_apps.bluetooth_game_duel\nWater Physics Simulation: play.google.com/store/apps/details?id=com.gaming_apps.water_physics_simulation", "tags": ["light", "gamemakerstudio", "glim888", "gamemakerstudioshaders"], "likes": 2, "viewed": 872, "published": "Public API", "date": "1488307656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\niResolution.x = screen_width\niResolution.y = screen_height\n\nfragCoord.x = number of the pixel from left\nfragCoord.y = number of the pixel from bottom\n*/\n\n#define PI 3.14159\n\n//################################\n//######## CHANGE ME #############\n//################################\nconst float POINT_SIZE = 0.09;\t\t  //radius (higher == bigger)\nconst float BRIGHTNESS = 0.15;\t\t  \nconst vec3 COLOR = vec3(0.4,1.0,0.8); //r,g,b (0 to 1)\n//################################\n//################################\n//################################\n\n\n///point(global time, uv, center of the point, xScale, yScale, )\nfloat point(float time, vec2 _uv, vec2 pos, float xs, float ys, float timeAdd, float size)\n{\n   float hypo = distance(vec2(pos.x * sin(time+(timeAdd*2.0*PI))*xs,\n                              pos.y * cos(time+(timeAdd*2.0*PI))*ys),_uv);\n   return size / pow(length (hypo),1.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \t\n    /*\n\tuv = -1 -- 0 -- 1\n\t*/\n\tvec2 uv = (fragCoord.xy - (iResolution.xy/2.0)) / iResolution.xy;\n\tuv *= 2.0; \n    \n    vec2 mouse = (iMouse.xy - (iResolution.xy/2.0)) / iResolution.xy;\n    mouse *= 2.0;   \n    float col = 0.0;\n    \n    //Add Points\n    col += point(iTime,uv,mouse, 0.1,0.1,0.0,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.5,0.3,0.0,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.3,0.5,0.1,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.5,0.3,0.2,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.3,0.5,0.3,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.5,0.3,0.4,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.3,0.5,0.5,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.5,0.3,0.6,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.3,0.5,0.7,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.5,0.3,0.8,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 0.3,0.5,0.9,POINT_SIZE);\n    \n    col += point(iTime,uv,vec2(0.5,0.5), 1.5,1.5,0.0,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 1.5,1.5,0.25,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 1.5,1.5,0.5,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 1.5,1.5,0.75,POINT_SIZE);\n    \n    col += point(iTime,uv,vec2(0.5,0.5), 1.0,2.5,0.0,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 2.5,-1.0,0.25,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 1.0,2.5,0.5,POINT_SIZE);\n    col += point(iTime,uv,vec2(0.5,0.5), 2.5,-1.0,0.75,POINT_SIZE);\n    \n    col -= point(iTime,uv,vec2(0.5,0.5), 0.5,0.4,0.0,POINT_SIZE*0.8);\n    col -= point(iTime,uv,vec2(0.5,0.5), 0.5,-0.2,0.25,POINT_SIZE*0.8);\n    col -= point(iTime,uv,vec2(0.5,0.5), 0.5,0.2,0.5,POINT_SIZE*0.8);\n    col -= point(iTime,uv,vec2(0.5,0.5), 0.5,-0.4,0.75,POINT_SIZE*0.8);\n    \n    col += point(iTime,uv,vec2(0.5,0.5), 5.5,0.2,0.5,POINT_SIZE*2.0);\n    col += point(iTime,uv,vec2(0.5,0.5), -5.5,-0.2,0.0,POINT_SIZE*2.0);\n\n    col *= BRIGHTNESS;\n    \n\tfragColor = vec4(COLOR.r * col, COLOR.g * col, COLOR.b* col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsscW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 606, 698, 698, 885], [887, 887, 944, 976, 2991]], "test": "valid"}
{"id": "lssyDn", "name": "Reflections_", "author": "hexointed", "description": "reflections", "tags": ["raymarching"], "likes": 0, "viewed": 439, "published": "Public API", "date": "1487768428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float epsilon = 0.0001;\nconst float speed = 10.0;\nvec3 light;\n\nfloat scene(vec3, inout int);\nbool march (out vec3, in vec3, in vec3, inout int);\nvec3 calc_gradient(in vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = vec3(2.0 * sin(iTime/12.0 * speed), 2.0 * cos(iTime/12.0 * speed), 0.0)/1.5;\n\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 cameraFocalPoint = cameraPosition - vec3(0.0, 0.0, 0.3);\n    cameraPosition.xy += (fragCoord.xy - iResolution.xy/2.0) / iResolution.xx;\n\t\n    vec3 norm = cameraPosition - cameraFocalPoint;\n    vec3 hitPosition = cameraPosition;\n    int id = 1;\n    \n    for(int i = 0; i < 5; i++) {\n    \tcameraPosition = hitPosition;\n        \n        bool hit = march(hitPosition, hitPosition + 2.0*norm*epsilon, norm, id);\n        \n        norm = calc_gradient(hitPosition);\n        vec3 lm = normalize(cameraPosition - hitPosition);\n        norm = normalize(2.0 * dot(lm, norm) * norm - lm);\n\n        if(!hit) {\n            fragColor*=0.0;\n            return;\n        }\n\n\n        if(id == 0){\n            fragColor = vec4 (1.0, 1.0, 1.0, 1.0);\n            return;\n        }\n        if(id == 1){ \n            fragColor = vec4 (1.0, 0.0, 0.0, 1.0);\n            break;\n        }\n        if(id == 2){\n            fragColor = vec4 (1.0, 1.0, 1.0, 1.0);\n            continue;\n        }\n        if(id == 3){ \n            fragColor = vec4 (0.0, 1.0, 1.0, 1.0);\n            break;\n        }\n        if(id == 4){\n            fragColor = vec4 (0.0, 0.0, 1.0, 1.0);\n            continue;\n        }\n        if(id == 5){\n        \tfragColor = vec4 (0.0, 1.0, 0.0, 1.0);\n            break;\n        }\n    }\n\n    \n    vec3 normal = calc_gradient(hitPosition);\n    vec3 lm = normalize(light - hitPosition);\n    vec3 rm = normalize(2.0 * dot(lm, normal) * normal - lm);\n    vec3 v = normalize(cameraPosition - hitPosition);\n    \n    vec3 lightEnd;\n    int occId;\n    \n    march(lightEnd, hitPosition + 2.0*lm*epsilon + 2.0*normal*epsilon, lm, occId);\n    \n    vec3 lightcoefficient = vec3(0.2, 0.2, 0.2);\n    \n    if(length(lightEnd-light) < 0.1) {\n\t\tlightcoefficient += \n            0.35 * dot(lm, normal) + \n            0.4 * pow(clamp(dot(rm, v),0.0,1.0), 4.0);\n    }\n    \n    fragColor.xyz *= lightcoefficient;\n}\n\nfloat max3(float a, float b, float c) {\n    return max(a, max(b, c));\n}\n\nvec3 calc_gradient(vec3 p) {\n    vec3 delta = vec3(epsilon, 0.0, 0.0);\n    int id;\n    float t = scene(p,id);\n \treturn normalize(vec3 (\n        (scene(p + delta.xyz,id) - t), \n        (scene(p + delta.yxz,id) - t), \n        (scene(p + delta.zyx,id) - t)\n   \t));\n    \n}\n\nbool march(out vec3 endPosition, in vec3 startPosition, in vec3 direction, inout int id) {\n    \n    vec3 mdir = normalize(direction);\n    endPosition = startPosition;\n    \n    for(int i = 0; i < 400; i++) {\n        float distance = scene(endPosition,id);\n        \n        if(distance < epsilon)\n            return true;\n        \n        if(distance > 1000.0)\n            return false;\n        \n        endPosition += distance * mdir;\n    }\n    \n    return false;\n    \n}\n\nfloat scene (vec3 p, inout int id) {\n\tfloat s1 = length(p) - 0.5;\n    float s2 = length(p - vec3(1.0 * sin(-iTime*0.025 * speed), 2.0*cos(iTime*0.025 * speed), 0.0)) - 0.4;\n    float l = length(p-light)-0.05;\n    float b = max(abs(p.x - 2.0), max(abs(p.y),abs(p.z))) - 0.5;\n    float c = max3(\n    \tabs(p.x + 2.0) - 0.4,\n    \tabs(p.y - 0.0) - 3.0,\n    \tabs(p.z - 0.0) - 4.0\n    );\n    float d = max3(\n    \tabs(p.x + 0.0) - 8.0,\n    \tabs(p.y + 4.5) - 2.0,\n    \tabs(p.z - 0.0) - 4.0\n    );\n    \n    if (l < s1 && l < s2 && l < b && l < c && l < d) id = 0;\n    else if(s1 < s2 && s1 < b && s1 < c && s1 < d) id = 1;\n    else if(s2 < b && s2 < c && s2 < d) id = 2;\n    else if(b < c && b < d) id = 3;\n    else if(c < d) id = 4;\n    else id = 5;\n    \n    return min(s1,min(s2,min(l,min(b,min(c,d)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 238, 238, 2267], [2269, 2269, 2308, 2308, 2340], [2342, 2342, 2370, 2370, 2610], [2612, 2612, 2702, 2702, 3081], [3083, 3083, 3119, 3119, 3881]], "test": "error"}
{"id": "lssyRH", "name": "Spinning Circle Grid", "author": "SalikSyed", "description": "Just a test", "tags": ["circles"], "likes": 5, "viewed": 279, "published": "Public", "date": "1487107085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 10\n#define M 5\n#define K 24\n#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float h = 1.0;\n    float w = aspectRatio;\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x * aspectRatio, fragCoord.y / iResolution.y); \n\n    float radius = 0.01;\n    float orbitR = 0.02;\n    float orbiterRadius = 0.005;\n    float centerRadius = 0.002;\n    float encloseR = 2.0 * orbitR;\n    float encloserRadius = 0.002;\n    float spacingX = (w / (float(N) + 1.0));\n    float spacingY = h / (float(M) + 1.0);\n    float x = 0.0;\n    float y = 0.0;\n    vec4 totalLight = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) { \n            // compute the center of the diagram\n            vec2 center = vec2(spacingX * (float(i) + 1.0), spacingY * (float(j) + 1.0));\n            x =  center.x + orbitR * cos(iTime );\n            y =  center.y + orbitR * sin(iTime );\n            vec2 bulb = vec2(x,y);\n            if (length(uv - center) > encloserRadius + encloseR) {\n                continue;\n            } else if (length(uv - center) < centerRadius) {\n                // frag intersects white center marker                   \n                fragColor = vec4(1.0);\n                return;               \n            } else if (length(uv - bulb) < radius) {\n                // intersects rotating \"light\"\n                fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n                return;\n            } else {\n                // intersects one of the enclosing 24 cylinders\n                for(int k = 0; k < K; k++) {\n                    float theta = M_PI * 2.0 * float(k)/ float(K);\n                    x = center.x + cos(theta) * encloseR;\n                    y = center.y + sin(theta) * encloseR;\n                    vec2 encloser = vec2(x,y);\n                    if (length(uv - encloser) < encloserRadius) {\n                        fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n                    \treturn;\n                    }\n                }   \n            }\n        }\n    }\n\tfragColor = vec4(0.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 143, 143, 2160]], "test": "valid"}
{"id": "lssyWn", "name": "GRAPROG - Midterm", "author": "Gracefrnandz", "description": "10 different patterns Simplicity, order, unity", "tags": ["midterm"], "likes": 0, "viewed": 69, "published": "Public", "date": "1487755588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define PATTERN 10\n\nvec3 colorPink = vec3(1., .68, .79 );\nvec3 white = vec3(1., 1., 1.);\nvec3 peach = vec3(.78, .56, .47);\nvec3 darkpeach = vec3(0.83, 0.47, 0.40);\nvec3 color1 = vec3(0.38, 0.34, 0.32 );\nvec3 color2 = vec3(.52, .45, .41);\nvec3 color3 = vec3(.65, .58, .51);\n\nfloat createShape(vec2 position, float numOfCorners)\n{\n    float a = atan(position.x, position.y) + PI;\n\tfloat r = TWO_PI/float(numOfCorners);\n    \n    float dist = cos(floor(.5+a/r)*r-a)*length(position);\n    return dist;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(float value)\n{\n    return mat2(value, 0, 0,value);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    float bilog = step(distance(center,uv), radius);\n    return bilog;\n}\n\nfloat rectangle(vec2 uv, vec2 position, vec2 size, float border)\n{\n    float leftSide = position.x;\n    float rightSide = position.x + size.x;\n    float bottom = position.y;\n    float top = position.y + size.y;\n    \n    //Border\n    float rect = step(leftSide, uv.x) - step(rightSide, uv.x); \n    float rect2 = step(bottom, uv.y) - step(top, uv.y);\n    \n    float rect3 = step(leftSide + border , uv.x) - step(rightSide - border, uv.x); \n    float rect4 = step(bottom + border, uv.y) - step(top - border, uv.y);\n    \n    return (rect * rect2) - (rect3 * rect4);\n}\n\nfloat rectangle2(vec2 uv, vec2 position, vec2 size, float border)\n{\n    float leftSide = position.x;\n    float rightSide = position.x + size.x;\n    float bottom = position.y;\n    float top = position.y + size.y;\n    \n    float rect = step(leftSide, uv.x) - step(rightSide, uv.x); \n    float rect2 = step(bottom, uv.y) - step(top, uv.y);\n    \n    return (rect * rect2);\n}\n\n#if PATTERN == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 5.;\n    uv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n   \tvec2 position = vec2(.5, .5);\n    vec2 position2 = vec2(.6, .6);\n    float size = 0.4;\n    \n\tfloat hexagon = createShape((uv - position), 6.);\n    hexagon = step(hexagon, size);\n    \n    float hexagon2 = createShape((uv - position2), 6.);\n    hexagon = step(hexagon, size);\n\n    fragColor = vec4(vec3((hexagon * hexagon2) * sin(iTime * 2.) + 1.) / 3. * colorPink,1.0);\n}\n\n#elif PATTERN == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= 8.;\n    uv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n    vec2 position = vec2(0., 0.);\n    vec2 position2 = vec2(0.5, 0.0);\n    \n    vec2 position3 = vec2(0.0, 0.0);\n    vec2 position4 = vec2(0.0, 0.25);\n    vec2 position5 = vec2(0.0, 0.50);\n    vec2 position6 = vec2(0.0, 0.75);\n    \n    vec2 size = vec2(0.5, 1.0);\n    vec2 size2 = vec2(1.0, 0.25);\n    float border = 0.02;\n   \n    float shape = rectangle(uv, position, size, border);\n    float shape2 = rectangle(uv, position2, size, border);\n    \n    float shapes = shape + shape2;\n    \n    if (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv *= scale2d(abs(sin(iTime)));\n    \tfloat shape3 = rectangle(uv, position3, size2, border); \n    \tfloat shape4 = rectangle(uv, position4, size2, border);\n    \tfloat shape5 = rectangle(uv, position5, size2, border);\n    \tfloat shape6 = rectangle(uv, position6, size2, border);\n    \tshapes = shape3 + shape4 + shape5 + shape6;\n    }\n    fragColor = vec4(vec3(shapes),1.0);\n}\n\n#elif PATTERN == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= 1.;\n    uv *= 5.;\n    uv = fract(uv);\n    \n    vec2 center = vec2(0.5 * 1. , 0.5);\n    float dist = distance(center,uv)*2.;\n    \n    uv -= center;\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = cos(3. * angle);\n    \n    radius = cos(angle * 5000. + iTime) * cos(angle * 2000. + iTime) * cos(angle * 10. + iTime); \n    float value = 1.-step(radius, dist);\n    \n    vec3 color = vec3(value);\n\tfragColor = vec4(color * colorPink, 1.0);\n}\n\n#elif PATTERN == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= 7.;\n   \tuv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n        \n    float size = .1;\n   \tfloat size2 = .12;\n    \n    vec2 position = vec2(0.5 , 0.2);\n    vec2 position2 = vec2(0.5 , 0.5);\n    vec2 position5 = vec2(0.5 , 0.8);\n    \n\tvec2 position3 = vec2(0.5 , 0.21);\n    vec2 position4 = vec2(0.5 , 0.6);\n    \n    vec2 positions = position + position2 + position3 + position4;\n    uv -= positions;\n    uv *= rotate2d(sin(iTime) / 4.);\n    uv += positions;\n    \n    float createPolygon1 = createShape(-(uv - position), 3.);\n    createPolygon1 = step(createPolygon1, size);\n   \n    float createPolygon2 = createShape(-(uv - position2), 3.);\n    createPolygon2 = step(createPolygon2, size);\n    \n    float createPolygon5 = createShape(-(uv - position5), 3.);\n    createPolygon5 = step(createPolygon5, size);\n    \n    vec3 polygon = vec3(createPolygon1) * color1;\n    vec3 polygon2 = vec3(createPolygon2) * color2;\n    vec3 polygon5 = vec3(createPolygon5) * color3;\n\n    vec3 polygons = polygon + polygon2 + polygon5;\n    \n    if (tile.x == 1. || tile.x == 3. || tile.x == 5.)\n    {\n        float createPolygon3 = createShape(uv - position3, 3.);\n    \tcreatePolygon3 = step(createPolygon3, size2);\n        \n        float createPolygon4 = createShape(uv - position4, 3.);\n    \tcreatePolygon4 = step(createPolygon4, size);\n        \n        vec3 polygon3 = vec3(createPolygon3) * peach;\n    \tvec3 polygon4 = vec3(createPolygon4) * darkpeach;\n        polygons = polygon3 + polygon4;\n    }\n    fragColor = vec4(polygons, 1.0);\n}\n\n#elif PATTERN == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n   \tuv.x *= 7.;\n   \tuv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    float N = 3.0;\n    float size = .5;\n    float size2 = .2;\n    \n    vec2 position2 = vec2(0.5 , 0.5);\n    \n    uv -= position2;\n    uv *= rotate2d(iTime);\n    uv += position2;\n    \n    float createPolygon2 = createShape(uv - position2, 8.);\n    createPolygon2 = step(createPolygon2, size);\n    \n    float createPolygon1 = createShape(uv - position2, 2.);\n    createPolygon1 = step(createPolygon1, size2);\n    \n   vec3 polygon1 = createPolygon1 * white;\n   vec3 polygon2 = createPolygon2 * white;\n    \n   vec3 polygons = polygon1 + 1.-polygon2;\n   \n    fragColor = vec4(vec3( polygons ), 1.0);\n}\n\n#elif PATTERN == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n   \tuv.x *= 7.;\n   \tuv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n    float size = .5;\n    float size2 = .2;\n    float size3 = .15;\n    \n    vec2 position2 = vec2(0.5 , 0.5);\n    \n  \tuv -= position2;\n    uv *= scale2d(sin(iTime));\n    uv += position2;\n    \n    float createPolygon2 = createShape(uv - position2, 8.);\n    createPolygon2 = step(createPolygon2, size);\n    \n    float createPolygon1 = createShape(uv - position2, 2.);\n    createPolygon1 = step(createPolygon1, size2);\n    \n    vec3 polygon1 = createPolygon1 * color1;\n   \tvec3 polygon2 = createPolygon2 * white;\n    \n   \tvec3 polygons = polygon1 + 1.-polygon2;\n    \n    if (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        float createPolygon2 = createShape(uv - position2, 8.);\n   \t\tcreatePolygon2 = step(createPolygon2, size);\n        \n    \tuv -= position2;\n    \tuv *= rotate2d(1.57);\n    \tuv+= position2; \n    \n    \tfloat createPolygon1 = createShape(uv - position2, 2.);\n    \tcreatePolygon1 = step(createPolygon1, size3);\n        \n        polygon1 = createPolygon1 * color2;\n   \t\tpolygon2 = createPolygon2 * white;\n        \n        polygons = polygon1 + 1.-polygon2;\n    }\n    fragColor = vec4(vec3( polygons ), 1.0);\n}\n\n#elif PATTERN == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv.x *= 5.;\n   \tuv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.5, 0.65);\n\tvec2 position2 = vec2(0.5, 0.5);\n    vec2 position3 = vec2(0.5 , 0.37);\n    vec2 position4 = vec2(0.38, 0.57);\n    vec2 position5 = vec2(.62, 0.57);\n    vec2 position6 = vec2(0.38 , 0.44);\n    vec2 position7 = vec2(.62, 0.44);\n\t\n   \tuv -= position2;\n    uv *= rotate2d(iTime);\n    uv += position2;\n    \n    if (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv -= position2;\n    \tuv *= scale2d(sin(iTime));\n    \tuv += position2;\n    }\n    \n   \tfloat circleOne = circle(uv, position, .15);\n    float circleTwo = circle(uv, position2, .15);\n    float circleThree = circle(uv, position3, .15);\n    float circleFour = circle(uv, position4, .15);\n    float circleFive = circle(uv, position5, .15);\n    float circleSix = circle(uv, position6, .15);\n    float circleSeven = circle(uv, position7, .15);\n    \n    float circle1 = circle(uv, position, .13);\n    float circle2 = circle(uv, position2, .13);\n    float circle3 = circle(uv, position3, .13);\n    float circle4 = circle(uv, position4, .13);\n    float circle5 = circle(uv, position5, .13);\n    float circle6 = circle(uv, position6, .13);\n    float circle7 = circle(uv, position7, .13);\n    \n    float minusCircle = circleOne - circle1 ;\n    float minusCircle2 = circleTwo - circle2;\n    float minusCircle3 = circleThree - circle3;\n    float minusCircle4 = circleFour - circle4;\n    float minusCircle5 = circleFive - circle5;\n    float minusCircle6 = circleSix - circle6;\n    float minusCircle7 = circleSeven - circle7;\n    \n    vec3 circles = (minusCircle + minusCircle2 + minusCircle3 + minusCircle4 + minusCircle5 + \n        minusCircle6 + minusCircle7) * colorPink;\n    fragColor = vec4(vec3(circles), 1.0);\n}\n\n#elif PATTERN == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 5.;\n   \tuv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.5, 1.25);\n    vec2 position2 = vec2(0.5, -.25);\n \tvec2 position3 = vec2(01.25, .5);\n    vec2 position4 = vec2(-0.25, .5);\n    vec2 position5 = vec2(.35, .355);\n    \n\tvec2 size = vec2(0.3, 0.3);\n    float border = 0.1;\n    \n\tif (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv -= position2;\n    \tuv *= scale2d(sin(iTime));\n    \tuv += position2;\n    \n    }\n    \n   \tfloat circle1 = circle(uv, position, 0.5);\n   \tfloat circle2 = circle(uv, position2,.5);\n    float circle3 = circle(uv, position3, .5);\n    float circle4 = circle(uv, position4,0.5);\n    \n    float rect = rectangle2(uv, position5, size, border); \n   \n    vec3 circles = circle1 + circle2 + circle3 + circle4 * white;\n\n    fragColor = vec4(vec3( 1. -circles - rect) * (sin(iTime * 2.) + 1.) / 2., 1.0);\n}\n\n#elif PATTERN == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 5.;\n   \tuv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.5, 1.);\n    vec2 position2 = vec2(0.5, .0);\n \tvec2 position3 = vec2(01., 0.5);\n    vec2 position4 = vec2(0., .5);\n    \n    vec2 positions = position + position2 + position3 + position4;\n    \n\tif (mod(tile.x, 4.) == mod(tile.y, 4.))\n    {\n        uv -= positions;\n    \tuv *= rotate2d(iTime);\n    \tuv += positions;\n    }\n   \tfloat circleOne = circle(uv, position, 0.5);\n   \tfloat circleTwo = circle(uv, position2,0.5);\n    float circleThree = circle(uv, position3, .5);\n    float circleFour = circle(uv, position4,0.5);\n    \n    float circle1 = circle(uv, position, 0.45);\n   \tfloat circle2 = circle(uv, position2, 0.45);\n    float circle3 = circle(uv, position3, 0.45);\n    float circle4 = circle(uv, position4, 0.45);\n    \n    float minusCircle = circleOne - circle1;\n   \tfloat minusCircle2 = circleTwo - circle2;\n    float minusCircle3 = circleThree - circle3;\n    float minusCircle4 = circleFour - circle4;\n    \n    vec3 circles = minusCircle + minusCircle2 + minusCircle3 + minusCircle4 * white;\n\n    fragColor = vec4(vec3( circles), 1.0);\n}\n\n#elif PATTERN == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= 6.;\n   \tuv.y *= 6.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.1, .9);\n    vec2 position2 = vec2(1., .0);\n   \n   \tfloat circleOne = circle(uv, position, 0.5);\n   \tfloat circleTwo = circle(uv, position2,0.5);\n    \n    float circle1 = circle(uv, position, 0.4);\n   \tfloat circle2 = circle(uv, position2, 0.4);\n    \n    float minusCircle = circleOne - circle1;\n   \tfloat minusCircle2 = circleTwo - circle2;\n    \n    float circles = minusCircle + minusCircle2;\n\n    fragColor = vec4(uv,0.5+0.5*sin(iTime) * circles,1.0);\n}\n\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssyWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 328, 382, 382, 552], [554, 554, 582, 582, 650], [652, 652, 679, 679, 717], [719, 719, 769, 769, 842], [844, 844, 910, 910, 1407], [1409, 1409, 1476, 1476, 1779]], "test": "valid"}
{"id": "lsXcRH", "name": "Whorl", "author": "aiekick", "description": "Whorl", "tags": ["whorl"], "likes": 8, "viewed": 509, "published": "Public API", "date": "1486990966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nfloat camd,time;\n\t\nmat3 RotX(float a){a = radians(a); return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 RotY(float a){a = radians(a); return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 RotZ(float a){a = radians(a); return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n    \n/* original\nfloat fullAtan(vec2 p)\n{\n\tfloat a = 0.;\n\tif (p.x >= 0.) a = atan(p.x, p.y);\n    if (p.x < 0.) a = 3.14159 - atan(p.x, -p.y);\n    return a;\n}*/\n\n/* thanks to 4onen */\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat shape(vec2 p)\n{\n\treturn length(p); // cylindric revolute\n    //return max(abs(p.x), abs(p.y)); // quad revolute\n    //return max(abs(p.x)+p.y,-p.y); // trianular revolute\n}\n\nvec2 Whorl(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*16.; // axis y\n    \n    vec2 q = vec2(shape(p.xz),p.y) + vec2(-2., -0.25); // torus base space formula\n    \n    q *= mat2(cos(a),-sin(a),sin(a),cos(a)); // rot near axis y\n    \n\tfloat interior = length(q-vec2(mix(0.32,1.,sin(time * .5)*.5 + .5), 0)) - .72;\n\tvec2 res = vec2(interior, 1.);\n\t\n\tfloat exterior = length(q) -.38;\n\tif (res.x < exterior)\n\t\tres = vec2(exterior, 2.);\n\t\n    return res;\n}\n\nvec2 df(vec3 p)\n{\n    float plane = p.y + 8.;\n\tvec2 res = vec2(plane, 0.);\n\tp *= RotX(time * 75.) * RotY(time * 50.) * RotZ(time * 25.);\n\tvec2 obj = Whorl(p);\n\tif (obj.x < res.x)\n\t\tres = obj;\n\treturn res;\n}\n\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 lc, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 ld = normalize(lp-p);\n\tvec3 n = nor(p, 0.01);\n\tvec3 refl = reflect(rd,n);\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\tfloat sha = softshadow( p, ld, 0.5, 50. );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\n\treturn ((diff * sha + fre + spe) * lc * li + spe) * sha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\n    time = iTime;\n    camd = 3.;\n    if (iMouse.z > 0.)\n\t{\n\t\tcamd = 20. * iMouse.y / si.y; // distance to origin axis\n    }\n\t\n\tvec3 ro = vec3(cos(4.4), sin(2.2), sin(4.4)) * camd;\n  \tvec3 rov = normalize(vec3(0)-ro);\n    vec3 u = normalize(cross(vec3(0,1,0),rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float s = 1.;float d = 0.;\n    for(int i=0;i<100;i++)\n    {      \n        if (0.<log(d/s/1e5)) break;\n        s = df(ro+rd*d).x;\n        d += s * 0.5;\n    }\n   \n\tvec3 lp0 = ro;\n\t\n\tvec3 lc = vec3(0);\n\tfloat mat = df(ro+rd*d).y;\n\tif (mat < 2.5) lc = vec3(0.5,0.2,0.8);\n\tif (mat < 1.5) lc = vec3(0.2,0.5,0.8);\n\tif (mat < 0.5) lc = vec3(0.8,0.5,0.2);\n\n\tfragColor.rgb = shade(ro, rd, d, lp0, lc, 2.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXcRH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 215, 234, 234, 308], [309, 309, 328, 328, 402], [403, 403, 422, 422, 496], [658, 680, 704, 704, 787], [789, 789, 810, 810, 967], [969, 969, 989, 989, 1411], [1413, 1413, 1430, 1430, 1619], [1621, 1676, 1750, 1750, 2009], [2011, 2011, 2045, 2045, 2257], [2259, 2259, 2326, 2326, 2694], [2696, 2696, 2753, 2753, 3582]], "test": "valid"}
{"id": "lsXcWn", "name": "Smiley Tutorial", "author": "BigWIngs", "description": "This is a smiley I did as part of a tutorial on YouTube. Use the mouse to look around! Hope you like it!\n[url]https://www.youtube.com/watch?v=ZlNnrpM0TRg[/url]\n", "tags": ["2d", "tutorial", "cartoon", "animated", "smiley"], "likes": 201, "viewed": 7853, "published": "Public", "date": "1487816332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Smiley Tutorial\" by Martijn Steinrucken aka BigWings - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n//\n// This Smiley is part of my ShaderToy Tutorial series on YouTube:\n// Part 1 - Creating the Smiley - https://www.youtube.com/watch?v=ZlNnrpM0TRg\n// Part 2 - Animating the Smiley - https://www.youtube.com/watch?v=vlD_KOrzGDc&t=83s\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile) {\n    float offs = mix(.2, 0., smile);\n    uv.y += offs;\n    \n    float y = uv.y;\n    uv.y += uv.x*mix(.5, .8, smile)-mix(.1, .3, smile);\n    uv.x -= mix(.0, .1, smile);\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n   \tfloat d1 = length(uv);\n    float s1 = S(.45, .45-blur, d1);\n    float d2 = length(uv-vec2(.1, -.2)*.7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(.7, .8, y)*.75;\n    colMask *= S(.6, .9, browMask);\n    colMask *= smile;\n    vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); \n   \n    uv.y += .15-offs*.5;\n    blur += mix(.0, .1, smile);\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile) {\n    uv -= .5;\n    uv.x *= side;\n    \n\tfloat d = length(uv);\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5);\t\t// gradient in eye-white\n    col.a = S(.5, .48, d);\t\t\t\t\t\t\t\t\t// eye mask\n    \n    col.rgb *= 1. - S(.45, .5, d)*.5*sat(-uv.y-uv.x*side); \t// eye shadow\n    \n    d = length(uv-m*.4);\t\t\t\t\t\t\t\t\t// offset iris pos to look at mouse cursor\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); \t\t// iris outline\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\t\t\t\t\t\t// iris lighter in center\n    float irisMask = S(.28, .25, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\t\t\t// blend in iris\n    \n    d = length(uv-m*.45);\t\t\t\t\t\t\t\t\t// offset pupile to look at mouse cursor\n    \n    float pupilSize = mix(.4, .16, smile);\n    float pupilMask = S(pupilSize, pupilSize*.85, d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask);\t\t// blend in pupil\n    \n    float t = iTime*3.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-smile);\n    \n    uv += offs;\n    float highlight = S(.1, .09, length(uv-vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\t\t\t// blend in highlight\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile) {\n    uv -= .5;\n\tvec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    \n    uv.x *= mix(2.5, 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x)*.5+.1)*(1.-smile);\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv) {\n\tvec4 col = vec4(.9, .65, .1, 1.);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));\n    \n    float highlight = S(.41, .405, d);\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= S(.18, .19, length(uv-vec2(.21, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25, -.2));\n    float cheek = S(.2,.01, d)*.4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile) {\n\tvec4 col = vec4(0.);\n    \n    if(length(uv)<.5) {\t\t\t\t\t// only bother about pixels that are actually inside the head\n        float side = sign(uv.x);\n        uv.x = abs(uv.x);\n        vec4 head = Head(uv);\n        col = mix(col, head, head.a);\n\n        if(length(uv-vec2(.2, .075))<.175) {\n            vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n            col = mix(col, eye, eye.a);\n        }\n\n        if(length(uv-vec2(.0, -.15))<.3) {\n            vec4 mouth = Mouth(within(uv, vec4(-.3, -.43, .3, -.13)), smile);\n            col = mix(col, mouth, mouth.a);\n        }\n\n        if(length(uv-vec2(.185, .325))<.18) {\n            vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .45)), smile);\n            col = mix(col, brow, brow.a);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    if(m.x<-.49 && m.y<-.49) {\t\t\t// make it that he looks around when the mouse hasn't been used\n    \tfloat s = sin(t*.5);\n        float c = cos(t*.38);\n        \n        m = vec2(s, c)*.4;\n    }\n    \n    if(length(m) > .707) m *= 0.;\t\t// fix bug when coming back from fullscreen\n    \n    float d = dot(uv, uv);\n    uv -= m*sat(.23-d);\n    \n    float smile = sin(t*.5)*.5+.5;\n\tfragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXcWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 578, 620, 620, 648], [650, 650, 708, 708, 748], [750, 750, 783, 783, 825], [827, 827, 860, 860, 1833], [1835, 1835, 1887, 1887, 3157], [3159, 3159, 3193, 3193, 3722], [3724, 3724, 3744, 3744, 4396], [4398, 4398, 4441, 4441, 5240], [5242, 5242, 5299, 5299, 5898]], "test": "valid"}
{"id": "lsXcz8", "name": "[TDF2017] Ocean", "author": "Pheema", "description": "The shader for GLSL Graphics Compo in Tokyo Demo Fest 2017!!!\nYou can change the height of the sun by mouse dragging.", "tags": ["raymarching", "sea", "sunset", "water", "ocean", "sunrise"], "likes": 51, "viewed": 2232, "published": "Public", "date": "1487511508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Pheema - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define M_PI (3.14159265358979)\n#define GRAVITY (9.80665)\n#define EPS (1e-3)\n#define RAYMARCH_CLOUD_ITER (16)\n#define WAVENUM (32)\n\nconst float kSensorWidth = 36e-3;\nconst float kFocalLength = 18e-3;\n\nconst vec2 kWind = vec2(0.0, 1.0);\nconst float kCloudHeight = 100.0;\nconst float kOceanScale = 10.0;\n\nconst float kCameraSpeed = 10.0;\nconst float kCameraHeight = 1.0;\nconst float kCameraShakeAmp = 0.002;\nconst float kCameraRollNoiseAmp = 0.2;\n\nstruct Ray\n{\n\tvec3 o;\n    vec3 dir;\n};\n\nstruct HitInfo\n{\n\tvec3 pos;\n    vec3 normal;\n    float dist;\n    Ray ray;\n};\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(vec3 n)\n{\n    return fract(sin(dot(n, vec3(12.9898, 4.1414, 5.87924))) * 43758.5453);\n}\n\nfloat Noise2D(vec2 p)\n{\n    vec2 e = vec2(0.0, 1.0);\n    vec2 mn = floor(p);\n    vec2 xy = fract(p);\n    \n    float val = mix(\n        mix(rand(mn + e.xx), rand(mn + e.yx), xy.x),\n        mix(rand(mn + e.xy), rand(mn + e.yy), xy.x),\n        xy.y\n    );  \n    \n    val = val * val * (3.0 - 2.0 * val);\n    return val;\n}\n\nfloat Noise3D(vec3 p)\n{\n    vec2 e = vec2(0.0, 1.0);\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    float x0 = mix(rand(i + e.xxx), rand(i + e.yxx), f.x);\n    float x1 = mix(rand(i + e.xyx), rand(i + e.yyx), f.x);\n    float x2 = mix(rand(i + e.xxy), rand(i + e.yxy), f.x);\n    float x3 = mix(rand(i + e.xyy), rand(i + e.yyy), f.x);\n    \n    float y0 = mix(x0, x1, f.y);\n    float y1 = mix(x2, x3, f.y);\n    \n    float val = mix(y0, y1, f.z);\n    \n    val = val * val * (3.0 - 2.0 * val);\n    return val;\n}\n\nfloat SmoothNoise(vec3 p)\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float val = 0.0;\n    \n    for (int i = 0; i < 4; i++)\n    {   \n        amp *= 0.5;\n        val += amp * Noise3D(freq * p - float(i) * 11.7179);\n        freq *= 2.0;\n    }\n    \n    return val;\n}\n\nfloat Pow5(float x)\n{\n    return (x * x) * (x * x) * x;\n}\n\n// Schlick approx\n// Ref: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat FTerm(float LDotH, float f0)\n{\n    return f0 + (1.0 - f0) * Pow5(1.0 - LDotH);\n}\n\nfloat OceanHeight(vec2 p)\n{    \n    float height = 0.0;\n    vec2 grad = vec2(0.0, 0.0);\n    float t = iTime;\n\n    float windNorm = length(kWind);\n    float windDir = atan(kWind.y, kWind.x);\n\n    for (int i = 1; i < WAVENUM; i++)\n    {   \n        float rndPhi = windDir + asin(2.0 * rand(vec2(0.141 * float(i), 0.1981)) - 1.0);\n        float kNorm = 2.0 * M_PI * float(i) / kOceanScale;\n        vec2 kDir = vec2(cos(rndPhi), sin(rndPhi)); \n        vec2 k = kNorm * kDir;\n        float l = (windNorm * windNorm) / GRAVITY;\n        float amp = exp(-0.5 / (kNorm * kNorm * l * l)) / (kNorm * kNorm);\n        float omega = sqrt(GRAVITY * kNorm + 0.01 * sin(p.x));\n        float phase = 2.0 * M_PI * rand(vec2(0.6814 * float(i), 0.7315));\n\n        vec2 p2 = p;\n        p2 -= amp * k * cos(dot(k, p2) - omega * t + phase);\n        height += amp * sin(dot(k, p2) - omega * t + phase);\n    }\n    return height;\n}\n\nvec3 OceanNormal(vec2 p, vec3 camPos)\n{\n    vec2 e = vec2(0, 1.0 * EPS);\n    float l = 20.0 * distance(vec3(p.x, 0.0, p.y), camPos);\n    e.y *= l;\n    \n    float hx = OceanHeight(p + e.yx) - OceanHeight(p - e.yx);\n    float hz = OceanHeight(p + e.xy) - OceanHeight(p - e.xy);\n    return normalize(vec3(-hx, 2.0 * e.y, -hz));\n}\n\nHitInfo IntersectOcean(Ray ray) {\n    HitInfo hit;\n    vec3 rayPos = ray.o;\n    float dl = rayPos.y / abs(ray.dir.y);\n    rayPos += ray.dir * dl;\n    hit.pos = rayPos;\n    hit.normal = OceanNormal(rayPos.xz, ray.o);\n    hit.dist = length(rayPos - ray.o);\n    return hit;\n}\n\nvec3 RayMarchCloud(Ray ray, vec3 sunDir, vec3 bgColor)\n{\n    vec3 rayPos = ray.o;\n    rayPos += ray.dir * (kCloudHeight - rayPos.y) / ray.dir.y;\n    \n    float dl = 1.0;\n    float scatter = 0.0;\n    vec3 t = bgColor;\n    for(int i = 0; i < RAYMARCH_CLOUD_ITER; i++) {\n        rayPos += dl * ray.dir;\n        float dens = SmoothNoise(vec3(0.05, 0.001 - 0.001 * iTime, 0.1) * rayPos - vec3(0,0, 0.2 * iTime)) * \n            SmoothNoise(vec3(0.01, 0.01, 0.01) * rayPos);\n        t -= 0.01 * t * dens * dl;\n        t += 0.02 * dens * dl;\n\t}\n    return t;\n}\n\n// Environment map\nvec3 BGColor(vec3 dir, vec3 sunDir) {\n    vec3 color = vec3(0);\n    \n    color += mix(\n        vec3(0.094, 0.2266, 0.3711),\n        vec3(0.988, 0.6953, 0.3805),\n       \tclamp(0.0, 1.0, dot(sunDir, dir) * dot(sunDir, dir)) * smoothstep(-0.1, 0.1, sunDir.y)\n    );\n    \n    dir.x += 0.01 * sin(312.47 * dir.y + iTime) * exp(-40.0 * dir.y);\n    dir = normalize(dir);\n    \n    color += smoothstep(0.995, 1.0, dot(sunDir, dir)); \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( gl_FragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tfloat aspect = iResolution.y / iResolution.x;\n    \n    // Camera settings\n\tvec3 camPos = vec3(0, kCameraHeight, -kCameraSpeed * iTime);\n    vec3 camDir = vec3(kCameraShakeAmp * (rand(vec2(iTime, 0.0)) - 0.5), kCameraShakeAmp * (rand(vec2(iTime, 0.1)) - 0.5), -1);\n    \n    vec3 up = vec3(kCameraRollNoiseAmp * (SmoothNoise(vec3(0.2 * iTime, 0.0, 0.0)) - 0.5), 1.0, 0.0);\n    \n\tvec3 camForward = normalize(camDir);\n\tvec3 camRight = cross(camForward, up);\n\tvec3 camUp = cross(camRight, camForward);\n\t\n    // Ray\n    Ray ray;\n    ray.o = camPos;\n    ray.dir = normalize(\n        kFocalLength * camForward + \n        kSensorWidth * 0.5 * uv.x * camRight + \n        kSensorWidth * 0.5 * aspect * uv.y * camUp\n    );\n\t\n    // Controll the height of the sun\n    float mouseY = iMouse.y;\n    if (mouseY <= 0.0) mouseY = 0.5 * iResolution.y;\n    vec3 sunDir = normalize(vec3(0, -0.1 + 0.3 * mouseY / iResolution.y, -1));\n    \n    vec3 color = vec3(0);\n\tHitInfo hit;\n    float l = 0.0;\n    if (ray.dir.y < 0.0) \n    {\n        // Render an ocean\n        HitInfo hit = IntersectOcean(ray);\n        \n        vec3 oceanColor = vec3(0.0, 0.2648, 0.4421) * dot(-ray.dir, vec3(0, 1, 0));\n        vec3 refDir = reflect(ray.dir, hit.normal);\n        refDir.y = abs(refDir.y);\n        l = -camPos.y / ray.dir.y;\n        color = oceanColor + BGColor(refDir, sunDir) * FTerm(dot(refDir, hit.normal), 0.5);\n    } \n    else \n    {\n        // Render clouds\n        vec3 bgColor = BGColor(ray.dir, sunDir);\n        color += RayMarchCloud(ray, sunDir, bgColor);\n        l = (kCloudHeight - camPos.y) / ray.dir.y;\n    }\n    \n    // Fog\n    color = mix(color, BGColor(ray.dir, sunDir), 1.0 - exp(-0.0001 * l));\n    \n    // Color grading\n    color = smoothstep(0.3, 0.8, color);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXcz8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 680, 700, 700, 770], [772, 772, 792, 792, 870], [872, 872, 895, 895, 1190], [1192, 1192, 1215, 1215, 1705], [1707, 1707, 1734, 1734, 1975], [1977, 1977, 1998, 1998, 2034], [2036, 2116, 2152, 2152, 2202], [2204, 2204, 2231, 2231, 3107], [3109, 3109, 3148, 3148, 3435], [3437, 3437, 3470, 3470, 3709], [3711, 3711, 3767, 3767, 4263], [4265, 4284, 4321, 4321, 4725], [4727, 4727, 4784, 4784, 6628]], "test": "valid"}
{"id": "lsXyWN", "name": "shortest Menger sponge (236 ch)", "author": "FabriceNeyret2", "description": " golfing of abje's https://www.shadertoy.com/view/MsfyW4\n+ coyotes's https://www.shadertoy.com/view/ltfGzS", "tags": ["2tweets", "mengersponge", "short", "golf", "cuberaymarching"], "likes": 9, "viewed": 1028, "published": "Public API", "date": "1488226536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 238: coyote\nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 r, q=O-=O;\n    q.z = iTime;\n \n    float d=1.,s;\n    for (++O; d>1e-4 ; q += vec4(U/iResolution.x-.5,1,1)*d, O -= .01 )   // windows bug if s init in loop while reused in next loop\n        for ( s=1.,d=0. ; s<99. ; s*=3. )\n            d = max(d, (.33-min(min(r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),r.z).y, r.x)) / s );\n         // r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n         // d = max(d, (.33-min(r.x,min(r.y,r.z))) / s );    // try .66 :-)\n}\n\n\n/** // 243: Fabrice   +1 to fix windows bug\nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 p = vec4(U/iResolution.x-.5,1,1), r, q=p-p;\n    q.z = iTime;\n    O = p/p;\n \n    float d=1.,s;\n    for (; d>1e-4 ; q += p*d, O -= .01 )   // windows bug if s init in loop while reused in next loop\n        for ( s=1.,d=0. ; s<99. ; s*=3. )\n            r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n            d = max(d, (.33-min(r.x,min(r.y,r.z))) / s );    // try .66 :-)\n    \n}\n/**/\n\n/** // 247: iapafoto \nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 p = vec4(U/iResolution.x-.5,1,1), r, q=p-p;\n    q.z = iTime;\n    O = p/p;\n \n    float d=.1, s;\n    while(d>1e-4) {\n        q += p*d; O -= .01;\n        for(s=1.,d=0.; s<99.; s*=3. )\n            r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n            d = max(d, (.33-min(r.x,min(r.y,r.z))) / s );    // try .66 :-)\n    }\n}\n/**/\n\n/** // 258: iapafoto \nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 p = vec4(U/iResolution.x-.5,1,1), r, q=p-p;\n    q.z = iTime;\n    O = p/p;\n    \n    float d=.1, s=1.;\n    while( O.x>.1  && d>1e-4) {\n        q += p*d; O -= .01;\n        for(s=1.,d=0.; s<99.; s*=3. )\n            r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n            d = max(d, (.33-min(r.x,min(r.y,r.z))) / s );    // try .66 :-)\n    }\n}\n**/\n\n\n/** // 264: Fab                    -2: vec3, O -= O++;  \n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 p = vec4(U/iResolution.x-.5,1,1), r, q=p-p;\n    q.z = iTime;\n    O = p/p;\n    \n    float d=1., s, j;\n    for( int i=0 ;  i++ < 90 && d > 1e-4 ; q += p*d, O -= .01 ) \n        for( j=d=0.,s=1. ; j++ < 5. ; s *= 3. )\n            r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n            d = max(d, (.33-min(r.x,min(r.y,r.z))) / s );    // try .66 :-)\n}\n/**/\n\n\n\n/** // 266: coyote  \"while\" approach.\n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 p = vec4(U/iResolution.x-.5,1,1), r, q=p-p;\n    q.z = iTime;\n    O = p/p;\n    \n    float d=1., s, i=d, j;\n    while( i++ < 91. && d > 1e-4 ) {\n        for( j=d=0.,s=1.; j++ < 5.; )\n            r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n            d = max(d, (.33-min(r.x,min(r.y,r.z))) / s ), \n            s *= 3.;\n        q += p*d, O -= .01;\n    }\n}\n/**/\n\n\n\n/** // 267: Greg mixing with https://www.shadertoy.com/view/ltfGzS\n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    vec4 p = vec4(U/iResolution.x-.5,1,1), r, q=p-p;\n    q.z = iTime;\n    O = p/p;\n    \n    for (int i=0; i < 90; i++) {\n        float d=0.,s=1.;\n        for (int i=0; i < 5; i++)\n            r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ),\n            d = max(d, (.33-min(r.x,min(r.y,r.z))) / s ),\n            s *= 3.;\n        d > 1e-4 ? q += p*d, O -= .01 : O;\n    }\n}\n**/\n\n \n    \n/** // golfing of https://www.shadertoy.com/view/MsfyW4    375\n\nvoid mainImage( out vec4 O,  vec2 U )\n{    \n    vec3 p = vec3(0,.37,iTime*.1),\n         D = normalize(vec3(U+U - (O.xy=iResolution.xy) , O.y)), m,q,r;\n    \n    float d = 0., n;\n    \n    for (int i = 0; i < 99; i++) {\n        m -= m;\n        n = 1.;\n        for (int j = 0; j < 5; j++) {        \n            q = n/3. - abs(mod(p+D*d +n,n*2.)-n),\n            r = q.z<q.y ? q.xzy : q;\n            r.y<r.x ? r.xy=r.yx : U;\n            r.z<r.y ? r.yz=r.zy : U;\n            m = max(m, step(q,r.yyy)*q);\n            n /= 3.;    \n        }\n        d += n = max(max(m.x,m.y),m.z);\n        \n        if (n < 1e-3 || d > 4.) break;\n    }\n    \n    O += exp(-d) -O;               // grey version\n  //O.rgb = n < 1e-3 ? m/n : m-m;  // color version\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 50, 50, 523]], "test": "valid"}
{"id": "ltGXRV", "name": "Parallax Mapping Comparision", "author": "AxleMike", "description": "A quick comparison between some normal/parallax mapping techniques.  \nI feel like there's a bug somewhere with my implementation but I need to dig into it some more. \nPlease correct me if you notice any mistakes.", "tags": ["normalmapping", "parallaxmapping", "pom", "steepparallaxmapping"], "likes": 20, "viewed": 826, "published": "Public", "date": "1486308434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Alexander Lemke, 2017\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         48\n#define \tAA \t\t\t\t\t\t4\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 300.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\nconst float \tCUBE \t\t\t= 2.0;\nconst float \tGROUND \t\t\t= 1.0;\nconst vec3 \t\tBoxCenter \t\t= vec3(0.0, -2.0, 0.0);\nconst vec3 \t\tBoxSize \t\t= vec3(3.5, 10.0, 3.5);\n\n//////////////////////////////////////////////////\n// Globals\nvec3 gCameraPosition;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat DrawCharacter(inout vec2 p, in int c)\n{\n    float fC = float(c);\n    float color = 0.0;\n\tif(p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)\n    {\n        color = step(texture(iChannel1, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);\n    }\n    p.x -= 0.5;\n    return color;\n}\n\n#define DrawNone(c, x) character += DrawCharacter(uv, 78); character += DrawCharacter(uv, 111); character += DrawCharacter(uv, 110); character += DrawCharacter(uv, 101)\n#define DrawNormal(c, x) c += DrawCharacter(x, 78); c += DrawCharacter(x, 111); c += DrawCharacter(x, 114); c += DrawCharacter(x, 109); c += DrawCharacter(x, 97); c += DrawCharacter(x, 108)\n#define DrawMapping(c, x) c += DrawCharacter(x, 77); c += DrawCharacter(x, 97); c += DrawCharacter(x, 112); c += DrawCharacter(x, 112); c += DrawCharacter(x, 105); c += DrawCharacter(x, 110); c += DrawCharacter(x, 103)\n#define DrawParallax(c, x) c += DrawCharacter(x, 80); c += DrawCharacter(x, 97); c += DrawCharacter(x, 114); c += DrawCharacter(x, 97); c += DrawCharacter(x, 108); c += DrawCharacter(x, 108); c += DrawCharacter(x, 97); c += DrawCharacter(x, 120)\n#define DrawSteep(c, x) character += DrawCharacter(uv, 83); character += DrawCharacter(uv, 116); character += DrawCharacter(uv, 101); character += DrawCharacter(uv, 101); character += DrawCharacter(uv, 112)\n\n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterial;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdfBox(in vec3 p, in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfPlane(in vec3 p, in vec4 n)\n{\n\treturn dot(p, n.xyz) + n.w; // normal must be normalized\n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);  \n    IntersectionData cubeIntersectionData = IntersectionData(sdfBox(p + BoxCenter, BoxSize), CUBE);\n\n    return GetClosestIntersection(planeIntersectionData, cubeIntersectionData);\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition);   \n        t += sceneIntersection.mT;\n    }   \n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Normals\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nfloat SampleTexture(in vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nvec3 SampleNormalMap(in vec2 uv, in float height)\n{\n    const float strength = 40.0;    \n    float d0 = SampleTexture(uv.xy);\n    float dX = SampleTexture(uv.xy - vec2(EPSILON, 0.0));\n    float dY = SampleTexture(uv.xy - vec2(0.0, EPSILON));\n    return normalize(vec3((dX - d0) * strength, (dY - d0) * strength, 1.0));\n}\n\nvec3 CalculateNormalMapNormal(in vec2 uv, in float height, in vec3 normal, in vec3 tangent, in vec3 binormal)\n{   \n    vec3 normalMap = SampleNormalMap(uv, height).rgb;\n\treturn normalize((normal * normalMap.b) + (binormal * normalMap.g) + (tangent * normalMap.r));\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)\n{       \n    return (albedo * Saturate(dot(normal, vec3(0.0, -1.0, 0.25)))) + (albedo * ambient);\n}\n\nvec3 ParallaxMapping(in vec3 position, inout vec3 normal, in float d, in int toggle)\n{\n    vec3 toBox = -position - BoxCenter;\n    vec3 uvBoxSize = vec3(BoxSize.x, 3.5, BoxSize.z);\n\n    vec2 textureCoords = (abs(normal.x) == 1.0) ? (toBox.zy / uvBoxSize.zy) : vec2(0.0);\n    textureCoords += (abs(normal.y) == 1.0) ? (toBox.xz / uvBoxSize.xz) : vec2(0.0);\n    textureCoords += (abs(normal.z) == 1.0) ? (toBox.xy / uvBoxSize.xy) : vec2(0.0);\n    textureCoords = (textureCoords * 0.5 + 0.5) + vec2(0.0, 0.5);   \n    \n    float height = SampleTexture(textureCoords);\n    \n    vec3 tangent = normalize(dFdy(textureCoords).y * dFdx(position) - dFdx(textureCoords).y * dFdy(position));\n    vec3 temp = cross(normal, tangent);\n    tangent = cross(temp, normal);\n    tangent = normalize(tangent);\n    vec3 binormal = cross(-tangent, normal);\n     \n    vec3 viewTangentSpace = normalize(gCameraPosition - position) * mat3(tangent, binormal, normal);\n   \n    const float scale = 0.04;\n    const float bias = 0.02; \n\tvec2 textureOffset = (viewTangentSpace.xy * (height * scale - bias)) / viewTangentSpace.z;\n    \n    // Steep Parallax Mapping and POM\n    const float numberOfSamples = 10.0;\n\tconst float stepSize = 1.0 / numberOfSamples;\n\tvec2 deltaOffset = textureOffset / numberOfSamples;\n\tfloat currentLayerDepth = 0.0;\n    float currentDepth = 0.0;       \n    \n    if ((toggle == 3) || (toggle == 4))  // Steep Parallax Mapping or POM\n    {   \n        for(float i = 0.0; i <= numberOfSamples; ++i)\n        {\n            currentDepth -= stepSize;           \n        \ttextureCoords += deltaOffset;\n            height = SampleTexture(textureCoords);\n            \n            if(currentDepth < height) \n            {\t\n                break;\n            }\n        }\n        \n        if (toggle == 4) // POM\n        {\n            vec2 previousTextureCoords = textureCoords - deltaOffset;\n            float collisionDepth = height - currentDepth;\n            float previousDepth = SampleTexture(previousTextureCoords) - currentDepth - stepSize;\n\n            float weight = collisionDepth / (collisionDepth - previousDepth);\n            textureCoords = mix(textureCoords, previousTextureCoords, weight);    \n            height = SampleTexture(textureCoords);\n        }\n    }\n    else if(toggle == 2) // Parallax Mapping  \n    {\n        textureCoords = textureCoords + textureOffset; \n        height = SampleTexture(textureCoords);\n    }\n\n    // Final Display\n    if((toggle >= 1) && (toggle <= 4))\n    {\n        normal = CalculateNormalMapNormal(textureCoords, height, normal, tangent, binormal);        \n    }\n    return SampleTexture(textureCoords) * vec3(0.85, 0.85, 1.0);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv)\n{\n    int toggle = int(floor(mod(iTime, 5.0)));\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n       \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        if(intersection.mMaterial == CUBE)\n        {\n\t\t\tdiffuse = ParallaxMapping(intersectionPoint, normal, intersection.mT, toggle);\n        }\n        else if(intersection.mMaterial == GROUND)\n        {\n            diffuse = vec3(0.5) + mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;\n        }\n        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, 0.2);     \n    }\n    finalColor = mix(finalColor, vec3(0.85, 0.85, 1.0), 1.0 - exp(-intersection.mT * 0.015));\n\n    \n    float character = 0.0;\n    if(toggle == 0)\n    {\n        DrawNone(character, uv);\n    }\n    else if(toggle == 1)\n    {\n        DrawNormal(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 2)\n    {\n        DrawParallax(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 3)\n    {\n        DrawSteep(character, uv);\n        uv.x -= 0.5;\n        DrawParallax(character, uv);\n        uv.x -= 0.5;\n        DrawMapping(character, uv);\n    }\n    else if(toggle == 4)\n    {\n        character += DrawCharacter(uv, 80); \n        character += DrawCharacter(uv, 79); \n        character += DrawCharacter(uv, 77);\n    }\n    return vec4(mix(finalColor, vec3(1.0), character), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec4 finalColor = vec4(0.0);\n\n    float xRot = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRot);\n    float yRot = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.02;\n    mat3 yRotMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRot);\n    \n    const float originDistance = 8.0;\n    gCameraPosition = vec3(originDistance * sin(yRot) * cos(xRot), originDistance * sin(xRot), originDistance * cos(yRot) * cos(xRot)) + vec3(0.0, 4.0, 0.0);\n    vec2 offset = vec2(0.0);\n    \n#if (AA > 1)\n    for(int x = 0; x < AA; ++x)\n    {\n    \tfor(int y = 0; y < AA; ++y)\n        {\n    \t\toffset = vec2(float(x), float(y)) / float(AA) - 0.5; \t \n#endif // (AA > 1)\n            vec2 screenCoord = ((fragCoord.xy + offset) / iResolution.xy);\n            vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n\n            // Determine our camera info          \n            vec3 cameraDirection = normalize(yRotMatrix * xRotMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));                   \n            finalColor += DisplayScene(gCameraPosition, cameraDirection, ((fragCoord.xy + offset) / iResolution.yy) * 8.0);\n#if (AA > 1)\n    \t}\n    }\n\tfinalColor /= float(AA * AA);        \n#endif // (AA > 1)     \n\tfragColor = finalColor;\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 646, 674, 674, 707], [709, 709, 769, 769, 1235], [1237, 1237, 1282, 1282, 1546], [2580, 2740, 2827, 2827, 2893], [2960, 3119, 3155, 3155, 3246], [3248, 3248, 3286, 3286, 3346], [3348, 3421, 3476, 3476, 3771], [3773, 3773, 3820, 3820, 4455], [4457, 4523, 4555, 4555, 4948], [4950, 4950, 4983, 4983, 5022], [5024, 5024, 5075, 5075, 5344], [5346, 5346, 5457, 5457, 5612], [5614, 5681, 5783, 5783, 5881], [5883, 5883, 5969, 5969, 8545], [8547, 8620, 8700, 8700, 10462], [10464, 10464, 10519, 10519, 11949]], "test": "error"}
{"id": "ltKSW3", "name": "OXCS", "author": "sauyon", "description": "Animated compsoc logo", "tags": ["oxcompsoc"], "likes": 0, "viewed": 104, "published": "Public", "date": "1486240639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int ox = 0x4F58;\nconst int cs = 0x4353;\nconst vec3 light_blue = vec3(0.8, 0.84, 0.88);\n//const vec3 inv_lb = 1.0 - light_blue;\nconst vec3 dark_blue = vec3(0.13, 0.3, 0.53);\n//const vec3 inv_db = 1.0 - dark_blue;\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ssize = min(iResolution.x, iResolution.y) / 4.0;\n    vec2 a = vec2(fragCoord.x, ssize * 4.0 - fragCoord.y);\n\tvec2 gloc = floor(a.xy / ssize);\n\tvec2 rloc = mod(a.xy, ssize);\n\n\tint pos = int(floor(gloc.y + 4.0*gloc.x + 0.5));\n    float dist = length(rloc - vec2(ssize/2.0, ssize/2.0));\n\n    if (gloc.x < 4.0) {\n        vec3 oxcolor, cscolor;    \n        if (pos == 1 || pos / 4 == 1 || pos == 9 || pos == 11 || pos == 12) {\n            oxcolor = dark_blue;\n        } else {\n            oxcolor = light_blue;\n        }\n        \n        if (pos == 1 || pos == 6 || pos == 7 || pos == 9 || pos == 11 || pos == 14 || pos == 15) {\n            cscolor = dark_blue;\n        } else {\n            cscolor = light_blue;\n        }\n\n        vec4 ox_circle_layer = circle(rloc, vec2(ssize/2.0, ssize/2.0), ssize/3.0, oxcolor);\n        vec4 cs_circle_layer = circle(rloc, vec2(ssize/2.0, ssize/2.0), ssize/3.0, cscolor);\n\n        vec4 oxpart = mix(white, ox_circle_layer, ox_circle_layer.a);\n        vec4 cspart = mix(white, cs_circle_layer, cs_circle_layer.a);\n        fragColor = mix(oxpart, cspart, abs(sin(iTime/3.0)));\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 343, 398, 398, 496], [498, 498, 555, 555, 1725]], "test": "valid"}
{"id": "ltKXDt", "name": "Abstract Fragments Plane", "author": "aiekick", "description": "Abstract Fragments Plane", "tags": ["abstract", "plane", "fragments"], "likes": 3, "viewed": 475, "published": "Public API", "date": "1488070083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// count radial section. \n// with this you can have more section. \n// more sections need more id check, but the tech is exactly the same\nconst float sections = 4.; \t\n\n// some varas\nfloat time = 0.;\t\t\t\t// time\nfloat cid = 0., lid = 0.; \t// current id, last id\nmat3 m1;\t\t\t\t\t\t// matrix used by the pattern merging\nmat3 m2;\t\t\t\t\t\t// matrix used by the pattern merging\n\n// Matrix operations\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\n// tunnel and cam path\nvec2 path(float t)\n{\n    return vec2(2., 5.1) * 1.;\n}\n\n// continuous angle from atan\nfloat cAtan(vec2 uv)\n{\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y);\n    if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n    return a;\n}\n\n// return id of region \nfloat GetID(vec2 uv) \n{\n    return cAtan(uv) * floor(sections) * .5 / 3.14159;\n}\n\n// one pettern for each ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat pattern(vec3 p, mat3 m, float s, float id)\n{\n\tfloat r = 0.;\n\tp = abs(fract(p*m*s) - 0.5);\n\tif (id > 3.) r= max(min(abs(p.x),abs(p.z)),abs(p.y));\n    else if (id > 2.) r= max(p.x,abs(p.y)+p.z);\n\telse if (id > 1.) r= length(p);\n    else if (id > 0.) r= max(p.x,-p.y);\n\treturn r;\n}\n\n// redirect dispalce func according to ID\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nfloat displace(vec3 p, float id)\n{\n\tvec3 a = vec3(0), b = a;\n\tif (id > 3.) a = vec3(-0.32,0.5,.5), b = vec3(0);\n    else if (id > 2.) a = vec3(0.46,0.42,-1.5), b = vec3(0);\n    else if (id > 1.) a = vec3(0.36,0.2,-2.28), b = vec3(0.36,0.24,1.62);\n\telse if (id > 0.) a = vec3(0.62,0.62,-1.02), b = vec3(0);\n        \n    return \n        (1.-min(pattern(p, m1, a.x, id), pattern(p, m2, a.y, id))) * a.z + \n    \t(1.-min(pattern(p, m1, b.x, id), pattern(p, m2, b.y, id))) * b.z;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = 1.;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\t\t\t\t\t\t\t\t\t\t\t\t\t// tunnel path\n\t\n    // mix from displace of last section id with displace of current section id accroding to id range \n    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); \t// id range [0-1]\n\t\n    p *= getRotZMat(p.z*0.05);\n\t\n    p = mod(p, 10.) - 5.;\n    \n    return vec4(abs(p.y)+2. - 1. + r, p);\n}\n\nvec3 nor( vec3 pos, float k)\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// color arangement is what i choose\n// its easy to have another coloration wothout modified the lighting.\n// here is an easy way i choose, but you can do alterate more as you want\n// here id is from range 0 to 1\n// so i use Id > section numbers to have continuity\nvec4 params(vec4 f, float id)\n{\n\tvec4 c = f;\n    if (id > 3.) c = f.zwyw; \n    else if (id > 2.) c = f.zyzw; \n    else if (id > 1.) c = f.yzyx; \n    else if (id > 0.) c = f.xyzw; \n    return c;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// blackbody color according to the subdensity value\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\t\t\t\t\t// use bumpmap fnc of shane here\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 5.) * 0.5; \t\t\t\t\t// one step sub density of df\n\treturn vec4(\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\n// get cam \n// g will be gl_FragCoord.xy or uMouse.xy\n//  si is screensize\nvec3 cam(vec2 g, vec2 si, vec3 ro, vec3 cv)\n{\n\tvec2 uv = (g+g-si)/si.y;\n\tvec3 cu = normalize(vec3(0,1,0) * getRotZMat(ro.z*-0.03));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n\t// matrix used by the pattern\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n    time = iTime * 8.;\n    \n    vec3 cu = vec3(0,1,0);\t\t\t\t\t\t\t\t\t\t\t// Camera Up\n  \tvec3 cv = vec3(path(time + .1),time + .1); \t\t\t\t\t// Camera View\n    vec3 ro = vec3(path(time),time);\t\t\t\t\t\t\t\t// Camera Origin\n    ro *= getRotZMat(ro.z*0.05);\n\tcv *= getRotZMat(ro.z*0.05);\n\t\n\tvec3 lp = vec3(path(ro.z + 7.),ro.z + 7.); \t\t\t\t\t// light point\n    vec3 cp = vec3(path(ro.z + 25.2),ro.z + 25.2); \t\t// center point for Smooth RadClick\n\tvec3 rd = cam(g, si, ro, cv);\t\t\t\t\t\t\t\t\t// Camera Direction\n\n\t// center point for calculate section id accroding to the tunnel path\n\tvec2 rdID = rd.xy - normalize(cp-ro).xy;\n\t\n\trdID = cam(si*0.5, si, ro, cv).xy - normalize(cp-ro).xy;\n\n\t// radial section id\n    float id = 0.;//GetID(rdID); // 0 to 4\n\n    // circular sections id \n    cid = id; \t\t\t\t\t\t\t\t\t// current section id\n\tlid = cid - 1.; \t\t\t\t\t\t\t// last section id\n\tif (lid < 0.) lid = id + sections - 1.;\t// circular \n\t\n\t// Ray Marching\n    float s = 1.;\n    float d = 1.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e5)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n\t// Color\n    f = shade(ro, rd, d, lp);\n\t\n\t// mix Color Arangement according to Radial Section Range \n\t// mix from params of last section id with params of current section id \n\t// according to the range between the two sections with fract(cid) => range 0 to 1\n\tf = mix(params(f, lid), params(f, cid), fract(cid)); // id range [0-1]\n\t\n\t// improve light a little bit\n\tf = f + f.x*0.3;\n\n\t// fog for hide some ray marching artifact cause by the low count iteration (60 here )\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n\t// gamma correction for add some contrast without saturation\n   \tfragColor = sqrt(f*f*f*2.); // gamma correction\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKXDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[560, 581, 606, 606, 664], [665, 665, 690, 690, 748], [749, 749, 774, 774, 832], [834, 857, 877, 877, 910], [912, 942, 964, 964, 1086], [1088, 1112, 1135, 1135, 1192], [1194, 1305, 1355, 1355, 1589], [1591, 1717, 1751, 1751, 2192], [2194, 2194, 2226, 2226, 2330], [2332, 2332, 2350, 2350, 2698], [2700, 2700, 2730, 2730, 2945], [2947, 3168, 3196, 3196, 3521], [3523, 3605, 3662, 3662, 3886], [3888, 3888, 3924, 3924, 4060], [4062, 4238, 4289, 4289, 4460], [4462, 4671, 4734, 4734, 5202], [5204, 5469, 5500, 5500, 5664], [5666, 5666, 5714, 5714, 6832], [6834, 6909, 6954, 6954, 7174], [7176, 7176, 7233, 7233, 9202]], "test": "error"}
{"id": "ltySWV", "name": "Test Shader - Gradient", "author": "Rxanadu", "description": "Test gradient shader\n\nUpdate 1 - 02/01/2017\n  \t**see code comments for more information**", "tags": ["test", "gradient"], "likes": 4, "viewed": 161, "published": "Public", "date": "1485915574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///\n//\tUpdate 1 - 02/01/2017\n//  \tUsed a code snippet from user 'GregRostami' to reduce  the shader code down to \n//\t\troughly 62 charaters\n//\t\tAdded alternation of colors in gradient shader via iTime\n//\t\t<remarks>I still don't know what I'm doing, but this is kinda cool\n//\t\tI'm still trying to find a way to share this on Twitter without \n//\t\tpresenting just a link to this website</remarks>\n///\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o -= o;\n    o.r = u.y/iResolution.y;\n    o.b = abs(-(u.x/iResolution.x) + cos(iTime));\n    o.g = abs((u.y/iResolution.y) + sin(iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltySWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 398, 433, 433, 575]], "test": "valid"}
{"id": "ltyXD3", "name": "Raymarching Primitives Commented", "author": "huttarl", "description": "I took IQ's https://www.shadertoy.com/view/Xds3zN and am commenting it extensively to make it easier to learn from. Also added demos of scaling, intersection, smooth blending, and bending.", "tags": ["procedural", "3d", "raymarching", "distancefields", "tutorial", "primitives"], "likes": 72, "viewed": 3243, "published": "Public API", "date": "1486176867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nTaking IQ's https://www.shadertoy.com/view/Xds3zN and commenting it extensively to make it easier to learn from.\n*/\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 1   // make this 1 if your machine is too slow\n\n//------------------------------------------------------------------\n// Distance functions\n//\n// Each function gives the distance from p to a primitive centered at the origin.\n// The position and orientation of the primitive is fixed. To simulate moving\n// the primitive, transform p in the opposite way.\n//\n// The s and u prefixes tell whether the result is signed or unsigned.\n// A signed function will return negative values for p inside the primitive;\n// an unsigned function will return 0.\n\n// Distance from p to plane (at y = 0)\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Distance from p to sphere of radius s (centered at origin)\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// Distance from p to box whose half-dimensions are b.x, b.y, b.z\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Distance from p to ellipsoid the length of whose semi-principal axes is r.x, r.y, r.z\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Distance from p to box of half-dimensions b.x,y,z plus buffer radius r\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// Distance from p to horizontal torus with major radius t.x and minor radius t.y\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// Distance from p to cylinder of radius r with spherical ends centered at a and b.\n// This is a rare exception to the rule that all primitives are centered at the origin.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// Distance from p to cylinder with radius h.x and half-length h.y.\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance from p to a cone of height c.z whose vertex is at the origin\n// and is pointing up.\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2(length(p.xz), p.y );\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\n// Euclidean distance function (same as builtin length(p)?)\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// Non-Euclidean distance function, so the sphere \"length6(p) = k\" is squarish.\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// Non-Euclidean distance function, so the sphere \"length8(p) = k\" is more squarish.\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// A torus with a squarish minor cross section, using non-Euclidean distance function.\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// A torus with squarish major and minor cross sections, using non-Euclidean distance function.\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// a cylinder with squarish horizontal cross-section, with radius h.x and half-length h.y.\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n// CSG operations\n\n// subtract primitive 2 from primitive 1, where d1 is distance to primitive 1.\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n// union primitives 1 and 2\n// d1 is a vec2 where .x is the distance, and .y is the color/material code.\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// intersection of two primitives\nfloat opI( float d1, float d2 )\n{\n    return max(d1, d2);\n}\n\n// Smooth minimum (polynomial smin())\n// See http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat opBlend( float d1, float d2 ) {\n    const float k = 0.1;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n//------------------------------------------------------------------\n// Domain operations\n\n// Repetition over grid with spacing c.x, c.y, c.z\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Domain deformation: transform the input point p before passing to distance function.\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(20.0 * p.y);\n    float s = sin(20.0 * p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n\n//------------------------------------------------------------------\n// Return (x,y) where x is minimum distance from pos to objects in the scene, and\n// y is the material of the closest object.\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\tres = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opI( sdBox(    pos-vec3( 2.0,0.2, 1.0), vec3(0.20)),\n\t                           sdSphere( pos-vec3( 2.0,0.2, 1.0), 0.25)), 113.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    // distance deformation (knobbly sphere):\n\tres = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 )\n                           + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z)\n                         , 65.0 ) );\n    \n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(    pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\tres = opU( res, vec2( 0.3*sdTorus( opCheapBend(pos-vec3( 2.0,0.25,-1.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n    // scaled primitive:\n    const float scale = .4;\n    res = opU( res, vec2( sdSphere((pos - vec3(-2.0, 0.25, -2.0))/scale, 0.25)*scale, 70. ) );\n    \n    res = opU( res, vec2( opBlend( sdBox(      pos-vec3( 2.0,0.25, 0.0), vec3(.15,.05,.15) ),\n                                   sdCylinder( pos-vec3( 2.0,0.25, 0.0), vec2(0.04,0.2))), 75. ) );\n    return res;\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal( in vec3 pos )\n{\n    // epsilon = a small number\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    // background sky color gradient\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    // cast ray to nearest object\n    vec2 res = castRay(ro,rd);\n    float t = res.x; // distance\n\tfloat m = res.y; // material code\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor ); // reflected ray\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m < 1.5 )\n        {\n            // gray checkerboard floor material\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighting        \n        float occ = calcAO( pos, nor ); // ambient occlusion\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) ); // sunlight\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 ); // ambient light\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n        // backlight\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y ); // dome light\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 ); // fresnel\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0); // specular reflection\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n        // mix in fog?\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera (ro = ray origin)\t\n        vec3 ro = vec3( 4.0*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1110, 1149, 1174, 1174, 1189], [1191, 1253, 1288, 1288, 1314], [1316, 1382, 1413, 1413, 1504], [1506, 1595, 1638, 1638, 1698], [1700, 1774, 1819, 1819, 1861], [1863, 1945, 1978, 1978, 2035], [2037, 2037, 2073, 2073, 2315], [2317, 2489, 2541, 2541, 2655], [2657, 2657, 2693, 2693, 2941], [2943, 3011, 3047, 3047, 3146], [3148, 3244, 3282, 3282, 3451], [3453, 3453, 3525, 3525, 3740], [3742, 3742, 3809, 3848, 4220], [4222, 4282, 4307, 4307, 4344], [4346, 4426, 4451, 4451, 4509], [4511, 4596, 4621, 4621, 4686], [4688, 4775, 4810, 4810, 4881], [4883, 4979, 5014, 5014, 5085], [5087, 5178, 5215, 5215, 5268], [5358, 5437, 5470, 5470, 5496], [5498, 5603, 5633, 5633, 5666], [5668, 5702, 5735, 5735, 5761], [5763, 5861, 5898, 5898, 6020], [6114, 6165, 6195, 6195, 6224], [6226, 6315, 6339, 6339, 6471], [6473, 6473, 6501, 6501, 6624], [6627, 6822, 6847, 6847, 9688], [9690, 9864, 9904, 9904, 10523], [10525, 10748, 10822, 10822, 11082], [11084, 11162, 11194, 11226, 11670], [11672, 11732, 11774, 11774, 12073], [12075, 12150, 12189, 12227, 14094], [14096, 14139, 14191, 14191, 14370], [14372, 14372, 14429, 14429, 15405]], "test": "valid"}
{"id": "ltyXDV", "name": "cartoon water icon", "author": "bolloxim", "description": "meh", "tags": ["meh"], "likes": 2, "viewed": 64, "published": "Public", "date": "1485943825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Andi Smithers \n// wave effect using curves\n\n#define C(x)   a*cos(x-t) \n#define S(x)   a*sin(x-t)\n#define X0(x,xx)  x-C(xx)\n\nfloat trochoid(float x, float t, float a) \n{\n    return S(X0(x,X0(x,X0(x,X0(x,X0(x,x))))));\n}\n\n#define plot(Y) o += smoothstep(40.0/R.y, 0.0, abs(Y-uv.y))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.05;\n    float antiAliasSize = 0.03;\n    vec4 borderColor = vec4(1.0,1.0,0.95, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float t = iTime;\n\n    vec2 shadowVec = vec2(-0.01, 0.05);\n    float scaleBox = 1.2;\n\n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv.y+=0.3;\n    \n    float wave = trochoid(uv.x*1.4, t-1.0, sin(t))*0.3;\n  //  float alpha2 = clamp(1.0-abs(mod(sin(t)+uv.x*1.5, 3.142)-1.57)*1.3, 0.0, 1.0);\n    float alpha3 = smoothstep(0.0, 0.7, 1.0-abs(iuv.x*2.0-1.0));\n    float alpha = smoothstep(30.0/iResolution.y, 0.0, abs(wave-uv.y+0.5));\n    float alpha2 = uv.y>0.6 ? 1.0 : max(uv.y*5.0 -2.0, 0.0);\n //   float wave = abs(sin(iuv.x + rounding ) - iuv.y*32.0+16.0);\n //   wave = clamp(1.0-wave, 0.0, 1.0);\n    \n    // blend against a background texture - because shadeoy\n    vec4 background = vec4(0.2,0.5,1.0,1.0);\n    vec4 color = vec4(1.0, 1.0, 1.0, clamp(alpha*40.0, 0.0, 1.0)*alpha2*alpha3);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 171, 171, 220], [283, 283, 340, 356, 1485]], "test": "valid"}
{"id": "ltyXWt", "name": "Transformed Triangles", "author": "remony", "description": "My First Shader!\nuse your mouse to change the two centers", "tags": ["2d", "triangle", "sinus", "fragment"], "likes": 1, "viewed": 104, "published": "Public", "date": "1486399940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RS(a,b,x) (smoothstep(a-1.0, a+1.0,x)*1.0-smoothstep(b-1.0, b+1.0, x))\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\nvec3 triangleUP(vec2 uv, vec2 center, float radius, float height){\n     vec2 d = uv - center;\n    return RS(0.0, height, d.y+radius) * blue4\n        +(1.0-smoothstep( height-1.0-d.y-radius,height-1.0-d.y-radius, abs(d.x)))*red;\n    //replace plus with * to get triangle\n}\n\nvec3 triangleDOWN(vec2 uv, vec2 center, float radius, float height){\n     vec2 d = uv - center;\n    return RS(-height, 0.0, d.y-radius) * blue4\n        +(1.0-smoothstep( height-1.0+d.y-radius,height-1.0+d.y-radius, abs(d.x)))*red;\n    //replace plus with * to get triangle\n}\n\nvec3 triangleLEFT(vec2 uv, vec2 center, float radius, float height){\n     vec2 d = uv - center;\n    return RS(-height, 0.0, d.x-radius) * blue4\n        +(1.0-smoothstep( height-1.0+d.x-radius,height-1.0+d.x-radius, abs(d.y)))*red;\n    //replace plus with * to get triangle\n}\n\nvec3 triangleRIGHT(vec2 uv, vec2 center, float radius, float height){\n     vec2 d = uv - center;\n    return RS(0.0, height, d.x+radius) * blue4\n        +(1.0-smoothstep( height-1.0-d.x-radius,height-1.0-d.x-radius, abs(d.y)))*red;\n    //replace plus with * to get triangle\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    vec2 c = iMouse.xy;\n\tvec3 finalColor = vec3(0.0);\n    vec2 m = iMouse.xy/iResolution.xy;\n    finalColor += triangleDOWN(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    finalColor += triangleUP(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    finalColor += triangleLEFT(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    finalColor += triangleRIGHT(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n\t\n    c=iResolution.xy-c;\n    finalColor += triangleDOWN(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    finalColor += triangleUP(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    finalColor += triangleLEFT(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    finalColor += triangleRIGHT(uv, c, sin(iTime)*100.0, 100.0)*0.2;\n    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 219, 219, 424], [426, 426, 494, 494, 700], [702, 702, 770, 770, 976], [978, 978, 1047, 1047, 1252], [1255, 1255, 1312, 1312, 2043]], "test": "valid"}
{"id": "MdfcD8", "name": "passerby gems", "author": "visy", "description": "some pleasant gems to make you feel glowing inside", "tags": ["glowing", "gems"], "likes": 0, "viewed": 76, "published": "Public", "date": "1487932481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if (uv.x > 0.5) uv.x = 1.0-uv.x;\n    if (uv.y > 0.5) uv.y = 1.0-uv.y;\n    //uv.y+=fract(uv.y*10.+uv.x*10.)*0.01;\n    //uv.x+=fract(uv.y*10.+uv.x*10.)*0.01;\n\tfloat t = uv.y*0.5+iTime*0.5+uv.y*1.1+uv.x*2.;\n    uv+=fract(t+uv.x*2.)*0.1;\n\tvec3 c;\n    float ss;\n    for (float i = 0.0; i < 10.; i+=0.8) {\n        vec3 co = vec3(1.0);\n        ss = abs(0.3-0.2*(-fract(uv.x+t+i*t*0.01)*cos(uv.y+t+i*t*0.01))*i+i*0.1);\n        vec2 ce = vec2(0.5);\n        c += vec3(0.0+i*0.1*uv.y*1.2);\n\n        c+=abs(cos(uv.x-t)+abs(sin(uv.y-t)*i*uv.y*0.1));\n\n        if (uv.x < ce.x-ss || uv.x > ce.x+ss) c += co;\n        if (uv.y < ce.y-ss || uv.y > ce.y+ss) c += co;\n\n        c/=8.0-ss;\n\n    }\n\tc/=1.0;\n        \n    c = clamp(c,0.0,1.0);\n    \n\tfragColor = vec4(vec3(c.r*2.0+ss,c.g*3.0,c.b*4.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 886]], "test": "valid"}
{"id": "MdfcR8", "name": "Ray tracing rasterizer Triangle", "author": "miffy", "description": "my experiment of ray trace rasterizer.\ntrying to make simple easy to understand.\n", "tags": ["3d"], "likes": 4, "viewed": 668, "published": "Public", "date": "1486998274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @param x....radian around x-axis\n// @param y....radian around y-axis\n// @param z....radian around z-axis\n//from https://www.shadertoy.com/view/XdlGzn\nmat4 rotate( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\nmat4 ortho(float left,float right,float bottom,float top,float near,float far){\n    return mat4(2.0/(right-left),             0.0,            0.0, -(right+left)/(right-left),\n                              0.0,2.0/(top-bottom),            0.0,-(top+bottom)/(top-bottom),\n                              0.0,             0.0,-2.0/(far-near),    -(far+near)/(far-near),\n                              0.0,             0.0,             0.0,                      1.0);\n}\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, x,\n  \t\t\t\t 0.0, 1.0, 0.0, y,\n\t\t\t\t 0.0, 0.0, 1.0, z,\n\t\t\t\t 0.0,  0.0, 0.0, 1.0 );\n\n}\n\n//from https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n//ray and triangle hit test\n// @param orig...origin of ray\n// @param dir...ray direction\n// @param a,b,c....triangle vertices\n// @return vec3(0,0,0) if ray is not hit triangle\nvec3 hit(vec3 orig,vec3 dir,vec3 a,vec3 b,vec3 c){\n   float eps= 0.0000001;\n   vec3 ab=b-a;\n   vec3 ac=c-a;\n   \n   vec3 n=cross(dir,ac);\n\n   float det=dot(ab,n);\n    \n   if(det<=eps){ return vec3(0.3,0.3,0.3);}\n   // if the determinant is negative the triangle is backfacing\n   // if the determinant is close to 0, the ray misses the triangl\n   vec3 ao=orig-a;\n   float u=dot(ao,n)/det;\n   if(u<0.0 || u>1.0){ return vec3(0.3,0.3,0.3);}\n    \n   vec3 e=cross(ao,ab);\n   float v=dot(dir,e)/det;\n   if(v<0.0||u+v>1.0){ return vec3(0.3,0.3,0.3);}\n\n   float t = dot(ac,e)/det;\n   return vec3(u,v,t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //triangle verts\n    vec4 a=vec4(0.0,0.5,0.0,1.0);\n    vec4 b=vec4(-0.5,-0.5,0.0,1.0);\n    vec4 c=vec4(0.5,-0.5,0.0,1.0);\n    \n    mat4 rot = rotate( 0.0,sin(iTime),0.0);\n   \ta = rot*a;\n    b = rot*b;\n    c = rot*c;\n\n    \n    vec2 uv = fragCoord/iResolution.xy;     \n    //z position of near clipping plane\n    float near=0.2;\n    vec3 p= vec3(uv*2.0-1.0,near);\n\n\t//calc ray direction\n    vec3 camera = vec3(0.0,0.0,5.0);\n    vec3 dir = p-camera;\n\tdir = normalize(dir);\n    fragColor =vec4(hit(camera,dir,a.xyz,b.xyz,c.xyz),1.0); \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 153, 195, 195, 552], [553, 553, 632, 632, 1015], [1016, 1016, 1061, 1061, 1175], [1177, 1492, 1542, 1542, 2088], [2089, 2089, 2146, 2167, 2684]], "test": "valid"}
{"id": "Mdlcz4", "name": "diamonds", "author": "thaga", "description": ".", "tags": ["sb69"], "likes": 3, "viewed": 148, "published": "Public", "date": "1487322075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 diamond(vec2 center, float size, vec2 fragCoord)\n{\n    vec2 offs = (fragCoord.xy - center) / size;\n    vec2 dist = abs(offs);\n    float R = -0.5 * offs.x - 0.866 * offs.y + 0.3;\n    float G = -0.5 * offs.x + 0.866 * offs.y + 0.3;\n    float B =  0.9 * offs.x + 0.6 * offs.y + 0.7;\n    return vec3(R, G, B) * (1.0 - smoothstep(0.45, 0.5, dist.x + dist.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 bgColor = vec3(0.2, 0.1, 0.6);\n    \n    vec3 c = vec3(0.0);\n    for (float i = 0.0; i < 16.0; i += 1.0) {\n        float size = iResolution.y / (5.4 + 2.0 * cos(i*23.3));\n        float x = iResolution.x * 0.06 * (i + 1.02 * cos(i*24.3));\n        float y = iResolution.y * (0.3 + 0.1 * sin(i*2.2) + 0.0002 * iTime * size);\n        c += diamond(vec2(x, y), size, fragCoord.xy);    \n    }\n        \n    fragColor.rgb = bgColor + c;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 361], [363, 363, 420, 420, 858]], "test": "valid"}
{"id": "MdscRM", "name": "3 blobs", "author": "BattleJohnFantastica", "description": "blobs", "tags": ["blobs"], "likes": 0, "viewed": 118, "published": "Public", "date": "1487554011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat dist(vec2 x, vec3 y) {\n    float a = abs(sqrt(pow((x.x - y.x),2.0) + pow((x.y - y.y),2.0)));\n    return a;\n\n}\nvec3 position(vec3 deft, vec2 alternative, float speed){\n    float move = abs(sin(time * speed));\n    vec2 difference = deft.xy - alternative.xy;\n    vec2 factor = difference * vec2(move);\n    vec2 position = deft.xy - factor;\n    return vec3(position,deft.z);\n}\n\nvec4 layer1(vec2 uv){\n    #define NUM 4\n    vec3 point[NUM];\n    point[0] = position(vec3(0.1,0.5,0.03),vec2(0.1, 0.1),0.5);\n    point[1] = position(vec3(0.3,0.5,0.05),vec2(0.3, 0.1),0.9);\n    point[2] = position(vec3(0.5,0.1,0.03),vec2(0.5, 0.5),3.14159);\n    point[3] = position(vec3(0.8,0.4,0.09),vec2(0.8, 0.1),0.5);\n    vec4 color = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        for(int i = 0; i < NUM; i++){\n            float borderSize = 1.02;\n            float fixedBorder = 0.002;\n            float totalRadius = point[i].z * borderSize;\n            float totalRadiusFixedBorder = point[i].z + fixedBorder;\n            float different = sqrt(pow((uv.x - point[i].x),2.0) + pow((uv.y - point[i].y),2.0));\n            vec4 main = vec4(1.0,1.0,1.0,1.0);\n            if(different < point[i].z){   \n           \t\tcolor = main;\n            } else if(different < totalRadiusFixedBorder) {\n            \tfloat radius = point[i].z;\n           \t\tvec4 diff = abs(vec4(uv,0.5+0.5*sin(iTime),1.0) -  main);\n                float a = dist(uv, point[i]) - point[i].z;\n            \tfloat b = a / (totalRadiusFixedBorder - point[i].z);\n            \tcolor = main - (diff *vec4(b));\n            }\n        }\n    return color;\n}\n\n\nvec4 layer2(vec4 x, vec2 y) {\n    vec3 post = position(vec3(0.9, 0.9, 1.0), vec2(0.1, 0.1), 1.0);\n    float size = 0.09;\n    float total = size + 0.3;\n    vec4 bright = x + vec4(vec3(0.4), 1.0);\n    vec4 dark = x - vec4(vec3(0.9), 1.0);\n    if (dist(y, post) < size){   \n\t\treturn bright;\n    } else if (dist(y, post) < total) {\n    \tfloat percent = (dist(y, post) - size) / (total - size);\n    \tvec3 difference = bright.xyz - dark.xyz;\n        vec3 color = bright.xyz - (difference * pow(percent, 1.4));\n        return vec4( color ,1.0);\n    } else {\n    \treturn dark;\n    }\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.x;\n    fragColor = layer2(layer1(uv), uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdscRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 48, 48, 135], [136, 136, 192, 192, 398], [400, 400, 421, 421, 1609], [1612, 1612, 1641, 1641, 2189], [2190, 2190, 2247, 2247, 2333]], "test": "valid"}
{"id": "MdscWH", "name": "Firkant 1", "author": "muslidyr", "description": "Coding πrates Firkant", "tags": ["codingpirates"], "likes": 0, "viewed": 66, "published": "Public", "date": "1488109892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 farve1 = vec3(uv,0.5+0.5*sin(iTime));\n    \n    vec3 farve2 = farve1 - vec3(1./4.);\n    \n    vec3 pixel = farve1;\n    \n    if (uv.x > 1./4. \n    &&  uv.x < 3./4. \n    &&  uv.y > 1./4. \n    &&  uv.y < 3./4.) {\n        pixel = farve2;\n    }    \n    \n    fragColor = vec4(clamp(pixel, 0.0, 1.0),1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdscWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 414]], "test": "valid"}
{"id": "Mdscz8", "name": "Isometric", "author": "MacroMachines", "description": "isometric based on https://www.shadertoy.com/view/Md2XRd by fizzle", "tags": ["isometric"], "likes": 6, "viewed": 225, "published": "Public", "date": "1487104219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 z=mat2(1,1,1,-1);\nfloat m(vec2 p)\n{\n    return step(cos(\n        1.4257*(texture(iChannel0, \n                          floor(z*p*.1)\n                          /64.,-32.).\n                r >.5 ? p.y : p.x)),\n                .17);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = z * (fragCoord.xy / iResolution.y * 25. \n                  + iMouse.xy*.1 \n                  + iTime*vec2(1.5,1.08)),\n        c = floor(p);\n    float s = step(1. - p.x + c.x, p.y - c.y), \n        f = m(c), \n        g = m(c + vec2(-1, 0) + s);\n    s/=4.;\n    vec2 sz = vec2(0);\n\tfragColor.rgb = mix(vec3(.3,.3,.25),\n                        vec3(1),\n                        m(c-z[1])+(g < f ? \n                                   f*(.75-s) : \n                                   g*(.5+s)));\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdscz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 40, 40, 236], [237, 237, 294, 294, 796]], "test": "error"}
{"id": "MdsyRN", "name": "Ball Lighting", "author": "GinCastaway", "description": "ID", "tags": ["lighttest"], "likes": 0, "viewed": 68, "published": "Public", "date": "1487323474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 pixCoords) {   \n    /* == Background == */\n    color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    /* == Camera == */\n    float centerX = (iResolution.x / 2.0);\n   \tfloat centerY = (iResolution.y / 2.0);\n    \n    pixCoords.x = (pixCoords.x - centerX);\n    pixCoords.y = (pixCoords.y - centerY);\n    \n    /* == Red circle == */\n    vec2 center = vec2(0,0);\n    float radius = (iResolution.y * 25.0) / 100.0;\n    \n    /* == In the circle.. == */\n    if ( sqrt(pow(pixCoords.x - center.x, 2.0) + pow(pixCoords.y - center.y, 2.0)) < radius ) {\n        \n        float z = sqrt(pow(radius, 2.0) - pow(pixCoords.x, 2.0) - pow(pixCoords.y, 2.0));\n        vec3 pixel = vec3(pixCoords.x, pixCoords.y, z);\n       \n        vec3 haut = pixel / radius;\n        vec3 sun = vec3(cos(iTime * 3.0), 1.0, sin(iTime * 3.0));\n        \n        vec4 colorBase = vec4(0.7, 0.2, 0.2, 1.0);\n        float lum = dot(haut, sun);\n        \n    \tcolor = colorBase * max(lum, 0.2);\n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 81, 984]], "test": "valid"}
{"id": "MdXcW8", "name": "Simple parallax snow", "author": "fenwick67", "description": "Pretty snow!  I'm pretty new to writing shaders so I figured this would be a good one to try.  \n\nI generate grids of circles using fract() and then selectively color them in.  Then, I repeat for N layers and move each layer.", "tags": ["2d", "parallax", "snow"], "likes": 15, "viewed": 763, "published": "Public", "date": "1487985905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cc vec2(0.5,0.5)\n#define smoothness 1.0\n#define SNOW_COL vec4(1.0,1.0,1.0,1.0)\n#define N_LAYERS 8.0\n#define SNOW_ALPHA 1.0\n#define SPEED 0.3\n#define bg vec4(0.8,0.8,0.9,1.0)\n\nfloat smoothCircle(vec2 position,float relativeSize){\n    float d = distance(cc,position)*2./relativeSize;\n    if (d > 1.0){\n    \treturn 0.0;\n    }\n    else{\n    \treturn clamp(smoothness/d-smoothness,-1.0,1.0);\n    }\n}\n\n// fake random stolen from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat randF(float n){\n    return fract(sin(n) * 43758.5453123);\n}\n\n// used to determine whether to draw a flake in the grid\n// the magic number is just me mashing the keyboard\nbool rand2d(float i, float j, float probability){\n\treturn  (randF(i + j*7.8124861) > probability);\n}\n\n\n// create the grid of circles, with a bunch missing, and fanaggle the sizes a bit\nfloat circleGrid(vec2 position, float spacing, float dotSize){\n    \n    // idx => which dot we are showing in the grid.\n    \n    // check x and y index to see if we should draw it or not.\n    float idx = floor(1./spacing * position.x);\n    float yIdx = floor(1./spacing * position.y);\n\n    // much higher than .06 causes the grid to be obvious\n    if (rand2d(idx,yIdx,0.06)){\n    \treturn 0.0;\n    }\n    \n    // modify the size of the flake a bit\n    float relativeSize = (0.5 + 0.5*randF(yIdx))*dotSize / spacing;\n    \n    return smoothCircle(vec2(\n        fract(1./spacing*position.x),\n        fract(1./spacing*position.y + yIdx)\n    ),relativeSize);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvsq = vec2(uv.x* iResolution.x/iResolution.y,uv.y);\n    float amnt = 0.0;\n    \n    float rotX = 0.0;\n    float rotY = 0.0;\n    rotX = -2.0*iMouse.x / iResolution.x;\n    rotY = -2.0*iMouse.y / iResolution.y;\n    \n    \n    for (float i = 0.0; i < N_LAYERS; i ++){\n        float p = 0.5 + ((i+1.) / N_LAYERS)*0.4;\n        // small flakes in bg drawn first with lower speed\n        \n        // the only reason we add \"i\" is so it tweaks the noise called on this position later.\n        vec2 fallPosition = vec2(\n            rotX * (1.0-p) + uvsq.x + i + p*sin(iTime/2.+i)/4.*SPEED,\n            rotY * (1.0-p) + i * 3.0 + uvsq.y + iTime*p/1.*SPEED\n        );\n    \tamnt = amnt + SNOW_ALPHA * circleGrid(fallPosition, 0.06* p, 0.04* p*p); \n    }\n    \n    fragColor = mix(SNOW_COL,bg,1.0-amnt);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXcW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 236, 236, 401], [403, 496, 517, 517, 561], [563, 672, 721, 721, 772], [775, 857, 919, 1044, 1510], [1512, 1512, 1569, 1569, 2415]], "test": "valid"}
{"id": "MdXcWN", "name": "Rays", "author": "t91", "description": "ray marching", "tags": ["raymarching"], "likes": 1, "viewed": 69, "published": "Public", "date": "1488230379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3  v_cam_pos = vec3(0.0, 1.0, -6.0);\nvec3  v_cam_forward = vec3(0.0, 0.0, 1.0);\nvec3  v_cam_right = vec3(1.0, 0.0, 0.0);\nvec3  v_cam_up = vec3(0.0, 1.0, 0.0);\nvec3  v_sundir = normalize(vec3(0.0, 0.7, 1.0));\nfloat f_near = 2.3;\n\n#define FLOOR 999\n#define INFINITY 99999.0\n\nvec3 ToRay(in vec2 fragCoord, in mat3 m)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 invResolution = 1.0 / iResolution.xy;\n\tvec2 ndc = (fragCoord.xy * invResolution) * 2.0 - 1.0; \n\tvec3 ray = vec3(aspect * ndc.x, ndc.y, f_near);\n    \n\treturn m * normalize(ray);\n}\n\nvec3 IdToColor(int id)\n{\n\tif (id == FLOOR)\n        return vec3(3.4, 3.4, 5.0);\n    \n    float f = float(id);\n    \n    float sf = sin(f * 2.0) * 0.5 + 0.5;\n    float cf = cos(f * 3.0) * 0.5 + 0.5;\n    \n    return vec3(sf, cf, fract(sf+cf + 0.5)) * 2.0;\n}\n\nfloat Scene(vec3 point, out int id)\n{\n    vec3 offset = vec3(0.0, 3.4, 0.0);\n    float distance = INFINITY;\n\n    id = -1;\n    \n    #define ITER 6  \n    for (int i = 0; i < ITER*ITER; ++i)\n    {\n        int h = ITER / 2;\n        int a = i / ITER;\n        int b = i % ITER;\n        \n        vec3 position = vec3(float(a - h), 0.0, float(b - h)) * 5.0;\n        float radius = 0.9 + sin(float(a) + float(b)) * 0.5 + 0.5;\n        \n        position.y = 4.0; \n        \n        \n        float l2c = length(point - position) - radius;\n        l2c = max(0.0, l2c);\n        \n        if (l2c < distance)\n        {\n        \tdistance = l2c;\n            id = i;\n        }\n    }\n\n    float t = iTime;\n    float H = sin(length(point.xz) - iTime * 2.0) * 0.3;\n    \n    float h = point.y - H;\n    \n    if (h < distance)\n    {\n        id = FLOOR;\n    \tdistance = h;\n    }\n    \n\n\treturn distance;\n}\n\nvec4 March(vec3 start, vec3 ray, out int id)\n{   \n    float step = 0.0;\n    \n\tfor (int i = 0; i < 100; ++i)\n    {\n        start = start + (step * ray);\n        step = Scene( start, id );\n\n        if (step < 0.0005)\n        {\n            return vec4(start, float(i));\n        }  \n        \n        if (step > 30.0)\n        {\n        \tbreak;\n        }\n\n    }\n    \n    return vec4(0,0,0,-1);\n}\n\n\nfloat ShadowSample(vec3 pos)\n{\n    int id = -1;\n    float shadow = 1.0;\n    vec4 shadow_pos = March(pos + v_sundir * 80.0, -v_sundir, id);\n\n    if (shadow_pos.w < 0.0)\n        return 1.0;\n    \n    float distToShadowCaster = length(shadow_pos.xyz - pos.xyz);\n    \n    shadow = min(1.0, max(0.0, 1.0 - distToShadowCaster));\n    \n    \n    return shadow;\n}\n\nfloat Shadow(vec3 pos)\n{\n    return ShadowSample(pos);\n}\n\nvec3 Ambient()\n{\n\treturn vec3(1.0, 1.0, 1.0) * 0.3;\n}\n\nvec3 Diffuse(vec3 nrm)\n{\n\treturn dot(nrm, v_sundir) * vec3(0.9, 0.2, 0.2) * 6.0;\n}\n\nvec3 Opq(vec3 pos, int id)\n{\n    vec2 uv = pos.xz;\n    uv.x += fract(pos.y);\n    uv.y += fract(pos.y);\n    \n    uv = fract(uv);\n    uv *= 0.2;\n\n    vec3 color = vec3(1,1,1);\n    \n    if (id == FLOOR)\n    {\n        uv *= 0.04;\n    \tcolor = texture(iChannel0, uv).xyz;\n    }\n    \n    color *= IdToColor(id);\n    \n\treturn color;\n}\n\nvec3 Reflection(vec3 ray, vec4 pos, vec3 nrm, int surface_id)\n{  \n    vec3 reflected = reflect(ray, nrm);\n    \n    int id = -1;\n    vec4 hit = March(pos.xyz + nrm*0.01, reflected, id);\n    \n    if (hit.w < 0.0)\n\t\treturn vec3(0, 0, 0);\n    \n    \n    return Opq(hit.xyz, id);\n}\n\nvec3 Fog(vec4 pos)\n{\n    if (pos.w < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    \n    float distance = length(pos.xyz - v_cam_pos);\n\n\treturn max(0.0, exp(-distance * 0.04 )) * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 Specular(vec3 pos, vec3 nrm)\n{\n    vec3 VertexToEye = normalize(v_cam_pos - pos);\n    vec3 LightReflect  = normalize(reflect(-v_sundir, nrm));\n    \n    float str = max(0.0, dot(VertexToEye, LightReflect));\n    \n\tvec3 spc = pow(str, 30.0) * vec3(1.0, 1.0, 1.0);\n    \n    return spc;\n}\n\nfloat AmbientOcclusion(vec4 pos)\n{\n\treturn (1.0-clamp(pow(pos.w / 100.0, 0.2), 0.0, 1.0));\n}\n\nmat3 CameraMatrix()\n{\n\tfloat radius = 30.0;\n    float param = iMouse.x * 0.03;//obalTime * 0.3;\n    \n    v_cam_pos.x = sin(param) * radius;\n    v_cam_pos.y = 1.0 + iMouse.y * 0.01;\n    v_cam_pos.z = cos(param) * radius;\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    v_cam_forward.y = 0.0;\n    v_cam_forward = normalize(v_cam_forward);\n    \n    v_cam_forward = -normalize(v_cam_pos);\n    \n    v_cam_right   = cross(v_cam_forward, v_cam_up);\n \n    mat3 m;\n    m[0] = v_cam_right;\n    m[1] = v_cam_up;\n    m[2] = v_cam_forward;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat3 cam = CameraMatrix();\n\n    int id = -1;\n    \n    vec3 ray   = ToRay(fragCoord, cam);\n    vec4 pos   = March(v_cam_pos, ray, id);\n    \n    \n    \n    int id_alt = -1;\n    vec3 ray_A = ToRay(fragCoord + vec2(0.2, 0.0), cam);\n    vec3 ray_B = ToRay(fragCoord + vec2(0.0, 0.2), cam);\n    vec3 pos_A = March(v_cam_pos, ray_A, id_alt).xyz;\n    vec3 pos_B = March(v_cam_pos, ray_B, id_alt).xyz;\n    vec3 diff1 = normalize(pos.xyz - pos_A);\n    vec3 diff2 = normalize(pos.xyz - pos_B);\n    vec3 nrm = normalize(cross(diff1, diff2));\n\n    vec3  opq = Opq(pos.xyz, id);\n    vec3  rfl = Reflection(ray, pos, nrm, id);\n    vec3  spc = Specular(pos.xyz, nrm);\n    vec3  amb = Ambient();\n    vec3  dif = Diffuse(nrm);\n    vec3  fog = Fog(pos);\n    float shd = Shadow(pos.xyz);\n    \n    vec3 color;\n\n    color = (amb + dif * shd + (spc + rfl)) * opq;\n\n    color *= AmbientOcclusion(pos);\n    fragColor.xyz = color * fog;\n\n    \n    fragColor.w = 1.0;  \n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 276, 318, 318, 556], [558, 558, 582, 582, 811], [813, 813, 850, 850, 1690], [1692, 1692, 1738, 1738, 2081], [2084, 2084, 2114, 2114, 2436], [2438, 2438, 2462, 2462, 2494], [2496, 2496, 2512, 2512, 2549], [2551, 2551, 2575, 2575, 2633], [2635, 2635, 2663, 2663, 2962], [2964, 2964, 3027, 3027, 3239], [3241, 3241, 3261, 3261, 3440], [3442, 3442, 3477, 3477, 3730], [3732, 3732, 3766, 3766, 3824], [3826, 3826, 3847, 3847, 4377], [4379, 4379, 4436, 4436, 5385]], "test": "error"}
{"id": "MdXyR8", "name": "256b checkerboard zoom", "author": "psonice", "description": "Always loved this effect in the old amiga demos, so tried to make it in 256 chars as a fun challenge.", "tags": ["demoscene", "checkerboard", "check", "256b"], "likes": 1, "viewed": 653, "published": "Public API", "date": "1486939370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r iResolution\nvoid mainImage(out vec4 c,vec2 f){vec2 u=f.xy/r.xy-.5,s;u.y*=r.y/r.x;float y=-iTime,p,t,d;for(float i=0.;i<8.;i+=2.){t=mod(y+i,8.);d=t*t;s=floor(mod((u+vec2(sin(-y*1.57),cos(y*1.57))/d)*d,2.));d=s.x+s.y-1.;c=max(c,d*d/t-.1);}}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 56, 56, 248]], "test": "valid"}
{"id": "MdXyz7", "name": "[ #04 ] - Disco balls", "author": "Yrai", "description": "For fun animation, testing lights on 2D scenes.", "tags": ["2d", "sound", "light", "animation", "disco"], "likes": 1, "viewed": 584, "published": "Public API", "date": "1487491708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res_     iResolution\n#define time_    iTime\n#define pi_      3.14159265\n\n#define crot(a)  mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2  domain(vec2 uv, float s);\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Initial calculations\n    // ---------------------------------------------------------------------------\n    vec2 p = domain(fragCoord, 2.);\n    vec2 np = fragCoord / res_.xy;\n    float sound = texture(iChannel0, vec2(-.2)).x;\n    float sound_movement = 2.*smoothstep(0., 3., sound);\n    // ---------------------------------------------------------------------------\n    \n    // Scene multiplication, depending on sound\n    // ---------------------------------------------------------------------------\n    if(sound_movement > .22) {\n        p.x = mod(p.x, 3.6) - .1;\n        p.y *= 2.1;\n        p.x *= 1.05;\n    \tp.y = mod(p.y, 4.2) - 2.3;\n    }\n\t// ---------------------------------------------------------------------------\n    \n    // Diagonal line\n    // --------------------------------------------------------------------------\n    float d_diagonal_line = abs(p.x - p.y) + .1*sound_movement*sin(21.*sound*p.x);\n    // --------------------------------------------------------------------------\n    \n    float fq = 1.;\n    \n    // Pendulum string\n    // --------------------------------------------------------------------------\n    vec2 pendulum_string_domain = p;\n    pendulum_string_domain -= vec2(2., 2.);\n    pendulum_string_domain *= crot(sound_movement * sin(fq*time_));\n    float d_vertical_line = abs(pendulum_string_domain.x) + .02*sin(11.*p.y);\n    // --------------------------------------------------------------------------\n    \n    // Circle\n    // --------------------------------------------------------------------------\n    float movment_angle = (-3.*pi_/2. - 1. * sound_movement*sin(fq*time_));\n    vec2 circle_domain = p;\n    circle_domain  -= vec2(2., 1.7 + sound_movement * 2.);  \n    circle_domain  += vec2(3.2 * cos(movment_angle), 3.2 * sin(movment_angle));\n    float d_circle  = abs(length(circle_domain) - .5);\n\tfloat d_disk    = (length(circle_domain) - .5);\n    // --------------------------------------------------------------------------\n    \n    // Light\n    // ---------------------------------------------------------------------\n    vec2 light = vec2(6., 2.); \n    float diffuse = 1. + max(0., dot(p, light));\n    // ---------------------------------------------------------------------\n    \n    // Shading\n    // ---------------------------------------------------------------------\n    vec3 color = vec3(0.);\n    \n    vec3 lb = vec3(0.1, 0.4, 1.7)*.5 + .3;\n    vec3 lg = vec3(0.1, 0.7, 0.1);\n    \n    color += fract(mix(lg, vec3(sin(14.*time_)*.5, .2, .4), p.x))*smoothstep(.06, .01, d_diagonal_line);\n   \t\n    if(pendulum_string_domain.y > -3. + sound_movement * 2.) \n        color += mix(lg, vec3(sin(14.*time_)*.5, .2, .4), pendulum_string_domain.y)*smoothstep(.06, .01, d_vertical_line);\n    \n    color += mix(lg, vec3(sin(14.*time_)*.5, .2, .4), p.x) * smoothstep(.04, .01, d_circle);\n    color += mix(lb, vec3(sin(14.*time_))*.5, 2.5*length(circle_domain + vec2(-.2)) - .001)\n             * smoothstep(.02, .01, d_disk);\n    \n    if(p.y > 2.01) color= vec3(0.);\n    // ---------------------------------------------------------------------\n   \n    color *= .12*diffuse * (vec3(250., 250., 175.) / 255.);\n   \n    fragColor = vec4(color, 1.);\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2.*uv.xy-res_.xy) / res_.y*s;\n}", "image_inputs": [{"id": "lsB3Dy", "previewfilepath": "https://soundcloud.com/tom-m-c/who-da-funk-shiny-disco-balls-tom-mc-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tom-m-c/who-da-funk-shiny-disco-balls-tom-mc-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXyz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 219, 330, 3416], [3418, 3418, 3449, 3449, 3493]], "test": "error"}
{"id": "MdXyzN", "name": "Circle_02", "author": "SantaroGL", "description": "just play around", "tags": ["circle"], "likes": 0, "viewed": 77, "published": "Public", "date": "1487233488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle (vec2 uv, vec2 pos, float rad, float blur) {\n \n    float dist = length(uv-pos);    \n    float circle = smoothstep(rad, rad-blur, dist);\n    \n    //if (dist < 0.2) circle = 0.4; //else circle = 0.0;\n    \n    return circle;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    float x = 0.2;\n    \n    float c0 = circle(uv, vec2(0.0, 0.0), 0.1, 0.01);\n    float c1 = circle(uv, vec2(sin(iTime)*0.3, 0.0), 0.1, 0.01);\n    float c2 = circle(uv, vec2(0.0, sin(iTime)*0.3), 0.1, 0.01);\n    float c3 = circle(uv, vec2(sin(iTime)*-0.3, 0.0), 0.1, 0.01);\n    float c4 = circle(uv, vec2(0.0, sin(iTime)*-0.3), 0.1, 0.01);\n    \n    float c5 = circle(uv, vec2(0.0, 0.0), 0.1, 0.01);\n    float c6 = circle(uv, vec2(sin(iTime)*-x, 0.0), 0.1, 0.01);\n    float c7 = circle(uv, vec2(0.0, sin(iTime)*-x), 0.1, 0.01);\n    float c8 = circle(uv, vec2(sin(iTime)*x, 0.0), 0.1, 0.01);\n    float c9 = circle(uv, vec2(0.0, sin(iTime)*x), 0.1, 0.01);\n    \n    vec3 c = vec3 (0.0, 1.0, 0.0)*c5;\n    vec3 col = vec3(0.0, 1.0, 0.0)*((c0+c1+c2+c3+c4)-(c6+c7+c8+c9));\n        \n    fragColor = vec4(col+c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 241], [243, 243, 300, 300, 1225]], "test": "valid"}
{"id": "MlGSDt", "name": "Dynamic Mandelbrot", "author": "yumcyawiz", "description": "it's ... creepy.", "tags": ["fractal"], "likes": 2, "viewed": 108, "published": "Public", "date": "1486410850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(float h, float s, float v) {\n\tfloat c = v*s;\n\tfloat x = c*(1.0 - abs(mod(h/60.0, 2.0) - 1.0));\n\tfloat m = v - c;\n\t\n\tvec3 color;\n\tif(h < 60.0) {\n\t\tcolor = vec3(c + m, x + m, 0.0);\n\t}\n\telse if(h < 120.0) {\n\t\tcolor = vec3(x + m, c + m, 0.0);\n\t}\n\telse if(h < 180.0) {\n\t\tcolor = vec3(0.0, c + m, x + m);\n\t}\n\telse if(h < 240.0) {\n\t\tcolor = vec3(0.0, x + m, c + m);\n\t}\n\telse if(h < 300.0) {\n\t\tcolor = vec3(x + m, 0.0, c + m);\n\t}\n\telse if(h < 360.0) {\n\t\tcolor = vec3(c + m, 0.0, x + m);\n\t}\n\treturn color;\n}\n\n\n//math\nvec2 cmult(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x - z1.y*z2.y, z1.x*z2.y + z1.y*z2.x);\n}\nvec2 cpow(vec2 z, int n) {\n    vec2 ret = vec2(1.0, 0);\n    int count = 0;\n    for(int i = 0; i < 10; i++) {\n        ret = cmult(ret, z);\n        count++;\n        if(count == n) break;\n    }\n    return ret;\n}\nfloat carg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\n\n//float smooth(vec2 z, int iter) {\n\t//return float(iter + 1) - log(log(length(z)))/log(2.0);\n//}\nfloat smooth2(vec2 z, int iter) {\n    float s = float(iter) - log(log(length(z))/log(7.0))/log(7.0);\n    return s;\n}\n\n\nconst int maxIter = 100;\n//complex system\nvec3 system(vec2 c) {\n    vec2 z = vec2(0);\n    vec2 zp = vec2(0);\n    int iter = 0;\n    for(int i = 0; i < maxIter; i++) {\n        zp = z;\n        z = cmult(cpow(z, 7), c) + cmult(vec2(length(z)*cos(iTime*3.2), carg(z)*sin(iTime*3.3)) - c, cpow(z, 3)) + c;\n        //z = cmult(z, z) + c;\n        if(length(z) > 2.0) {\n            iter = i;\n            break;\n        }\n    }\n    //vec4 color = vec4(hsv2rgb(240.0 - smooth2(z, iter)/float(maxIter)*240.0, 1.0, 1.0), 1.0);\n    vec4 color = vec4(vec3(5.0*smooth2(z, iter)/float(maxIter)), 1.0);\n    return color.xyz;\n}\n            \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfragColor = vec4(system(uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 511], [514, 521, 551, 551, 616], [617, 617, 643, 643, 825], [826, 826, 846, 846, 875], [878, 975, 1008, 1008, 1091], [1119, 1136, 1157, 1157, 1702], [1717, 1717, 1774, 1774, 1876]], "test": "valid"}
{"id": "MlGSRz", "name": "Shape Noise", "author": "gaz", "description": "noise", "tags": ["noise"], "likes": 1, "viewed": 197, "published": "Public", "date": "1487499903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// rewrote 2018/02/01\nvec3  hsv(float h,float s,float v)\n{\n    return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat hash(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat de(in vec2 p)\n{\n    float de1 = length(p)-0.1;\n    float a = radians(72.);    \n    p *= rotate(floor(0.5 - atan(p.x, p.y) /a) *a);\n    float de2 = p.y + abs(p.x) * 2.5- 0.3;\n    return mix(de1, de2, sin(iTime*0.5 +sin(iTime))*0.5+0.5);\n}\n\nfloat noise( in vec2 p)\n{\n    float t = iTime*0.5;\n    p += sin(t + sin(3.0*t +sin(6.0*t +sin(12.0*t))));\n    vec2 i = floor(p);\n    float n = dot(i,vec2(1,9))+ floor(t);\n    return mix(hash(n),hash(n+1.0),smoothstep(0.0,1.0,fract(t))) * smoothstep(0.9,0.1,de(fract(p)-0.5));\n}\n\nfloat fbm( vec2 p)\n{\n    float t = iTime*0.02;\n    float n=0.0;\n    for (int i=1;i<5;i++){\n        p *= rotate(t);t*=2.0;\n        n += noise(p)/pow(2.0,float(i)); p*=2.0;\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*gl_FragCoord.xy-iResolution.xy) / iResolution.y;\n    p *= 1.5/(1.5-pow(p.y-2.5, 2.)); // perspective    \n    float t = floor(iTime*0.5);\n    p += vec2(cos(2.*t+3.0*cos(3.0*t)),sin(2.*t+3.0*sin(3.*t))) * 1.0;\n    p = mix(vec2(inversesqrt(length(p)) * 5., atan(p.x, p.y)*3.), p, step(0.0,sin(iTime*0.3+2.*sin(iTime*0.5))));\n\tvec3 col = hsv(iTime*0.1,0.3,0.5) ;\n \tcol += smoothstep(0.3, 0.8, fbm(2.0*p + fbm(8.0*p + fbm(32.0*p ))));\n    col += hsv(fract(iTime*0.1),0.8,1.0)*vec3(1,0.15,0)      *smoothstep(0.5, 0.8, fbm(p.yx*3.0));\n    col += vec3(0.8,0.3,0.1)*min(1.0,fwidth(col.x*5.0)*0.5);\n    vec2 q = gl_FragCoord.xy / iResolution.xy;\n    col *= 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\n    col = pow(col, vec3(1.5));\n    fragColor = vec4(col,1);\n}\n\n\n\n\n/*\nvec3 hsv(in float h, in float s, in float v)\n{\n  return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n    \nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat hash( float n ) { return fract(sin(n)+iTime*2.0); }\n\nfloat noise( in vec2 x )\n{\n    float t = iTime*0.2;\n   // x += sin(t + sin(3.0*t +sin(6.0*t)));\n    x+=t;\n    vec2 p = floor(x);\n    return fract(sin(p.x + p.y*9.));\n}\n\nfloat fbm( vec2 p)\n{\n    mat2 m = rotate(iTime*0.02);\n    float n=0.0;\n    for (int i=1;i<5;i++){\n        //n += noise(p)/pow(2.0,float(i)); p *= m*2.0*sign(float(i)); \n        n += noise(p)/exp2(float(i)); p *= m*2.0; \n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float time = iTime;\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    //p *= 1.5/(1.5-pow(p.y-2.5, 1.5)); // pars\n    vec2 pp =p;\n    p *= 1.5 * pow(sin(smoothstep(0.0,20.0,mod(time,23.)) * radians(90.0)), 0.3);\n    \n    float t = floor(time*0.01);\n    p += vec2(cos(2.*t+3.0*cos(3.0*t)),sin(2.*t+3.0*sin(3.*t))) * 2.0;\n    \n    p = mix(vec2(inversesqrt(length(p)) * 5., atan(p.x, p.y)*3.), p, step(0.5,fract(time*0.3)));\n\tcol = vec3(0.15);//hsv(fract(time*0.1),0.3,0.5) ;\n\t//col += vec3(0.8,0.5,0.1)*smoothstep(0.5, 0.8, fbm(p.yx*3.0));\n\tcol += smoothstep(0.5, 0.8, fbm(2.0*p + fbm(sin(time*3.0)*p + fbm(32.0*p ))));\n    //col *= min(0.9,1.4-length(q*2.-1.));\n    col *= 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\n    \n    //col += vec3(0.8,0.5,0.1)*smoothstep(0.5, 0.8, fbm(pp.yx*.5));\n    \n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 58, 58, 136], [138, 138, 160, 160, 210], [212, 212, 232, 232, 270], [272, 272, 293, 293, 515], [517, 517, 542, 542, 794], [796, 796, 816, 816, 988], [990, 990, 1047, 1047, 1809]], "test": "valid"}
{"id": "MlGXDt", "name": "free AntiAliasing / cone tracing", "author": "FabriceNeyret2", "description": "WIP\nWhen the ray \"almost hit\" a surface by less than a pixel radius, we add an partial contribution+alpha.\n(  differential cone-tracing upon shader https://www.shadertoy.com/view/XtlXRB )\n\nPB: the pixel radius seems bad estimated at the very front. why ?", "tags": ["3d", "raymarching", "antialiasing", "conetracing", "short", "spheremarching"], "likes": 34, "viewed": 1922, "published": "Public API", "date": "1486415571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// differential cone-tracing version of https://www.shadertoy.com/view/XtlXRB\n// which was the compact simplified version of https://www.shadertoy.com/view/MllXz7\n\n// using the base ray-marcher of Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n#define r(t) mat2(C=cos(t*T),S=sin(t*T),-S,C)\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    f-=f;\n    vec2 R = iResolution.xy;\n    float T=iTime, C,S, x,\n        trsp=1.,dist=0.,  _x = 0., pix;         // <><><> for AA\n    vec4 p = vec4( (w-.5*R)/R.y, -.5,-.5), d;\n \n    p.xz *= r(.13);  p.yz *= r(.2); \n    d = normalize(p);  \n    p.z += 5.*T;\n    \n    if (mod(T,2.)>1.) R.y = 1e10;  // demo: AA on/off half-time\n  //if (w.x/R.x>.5) R.y = 1e10;    // demo: AA on/off half-window\n   \n    for (float i=1.; i>0.; i-=.01) {\n        \n        vec4 u = sin(78.+ceil(p/8.)), t = mod(p,8.)-4., a; \n        x = 1e9;\n        \n        for (float j=2.3; j>1.; j-= .3)\n            t.xy *= r(u.x),  t.xz *= r(u.y),\n            a = abs(t),\n            x = min(x, max(abs(length(t.xyz)-j*1.26),  max(a.x,max(a.y,a.z))-j)); \n \n        dist += x; pix = 2.*dist/R.y;           // <><><>  added for AA\n        if(x <.01) {                    // hit\n            f += trsp * vec4(i*i*1.2);          // <><><> += trsp*  added for AA\n            break;  \n        } else if (x<pix && x>_x) {             // <><><> AA: almost hit < pixel radius\n            float da = 1.-x/pix;\n            f += trsp*da* vec4(i*i*1.2); \n            trsp *= 1.-da;\n        }\n        p -= d*x;  \n        _x = x; //dist += x;                    // <><><>  added for AA\n     }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 296, 334, 334, 1578]], "test": "valid"}
{"id": "MlKXDK", "name": "simple spiral", "author": "mds2", "description": "just stare at it, it'll be fun.", "tags": ["spirals"], "likes": 0, "viewed": 101, "published": "Public", "date": "1486006300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ramp(float minval, float maxval, float x) {\n    return clamp((x-minval) / (maxval - minval), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float speed = 1.0; // <-- change this to change speed\n\n    const float lines_per_screen = 40.0; // <-- change this to change\n    \n    const float fuzz = 1.0;\n    \n    float pixels_per_line = fuzz * lines_per_screen / max(iResolution.x, iResolution.y);\n\t\n\n    vec2 uv = \n        (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    float angleness = atan (uv.y, uv.x) / 3.141592654;\n    float rad = length(uv.xy);\n    \n    float lineness =\n        ramp (0.25 - 0.5 * pixels_per_line, 0.25 + 0.5 * pixels_per_line,\n                    abs(mod(lines_per_screen * rad + angleness + speed * iTime,\n                            1.0) - 0.5));\n    \n\tfragColor = vec4(vec3(1.0) * lineness,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 111], [113, 113, 170, 170, 894]], "test": "valid"}
{"id": "MlKXDV", "name": "Sonar - Immersion", "author": "LLB", "description": "Was initially created for H-Immersion (http://www.pouet.net/prod.php?which=69654), but we finally didn't use it.", "tags": ["sonar"], "likes": 1, "viewed": 94, "published": "Public", "date": "1486055156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise generation functions borrowed from: \n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec4 content(vec2 p) {\n\tfloat x =// max(0.5, abs(snoise(p * 3.))) *\n        snoise(p * 1.) *\n        snoise(p * 5.) *\n        snoise(p * 50.) *\n        snoise(p * 300.);\n    \n    return mix(\n      vec4(0.1,0.3,0.1,0.),\n      vec4(0.1,0.1,0.1,0.),\n      10.*x);   \n}\n\nvec4 staticScreen(vec2 p) {\n    float d = length(p);\n    float circles = smoothstep(0., 0.15\t, abs(sin(d * 50.))) + 0.5;\n\tfloat grid = smoothstep(0., 0.003, min(abs(p.x), abs(p.y)));\n    \n\tfloat angle = atan(p.x, p.y);\n    float ticks1 = min(\n        smoothstep(0.15, 0., abs(sin(angle * 20.))),\n        smoothstep(0.22, 0.25, d));\n\tfloat ticks2 = min(\n        smoothstep(0.3, 0., abs(sin(angle * 100.))),\n        smoothstep(0.24, 0.25, d));\n    float ticks = max(ticks1, ticks2);\n    \n    return mix(\n        mix(\n          vec4(0.2,0.5,0.2,0.),\n          content(p), // vec4(0.1,0.3,0.1,0.),\n          min(grid, circles)),\n\n\t\tvec4(0.,0.8,0.,0.),\n        ticks);\n}\n\nvec4 sonar(vec2 p, float style) {\n    float d = length(p);\n    \n\tvec4 circles = staticScreen(p);\n\n    float angle = atan(p.x, p.y);\n\tfloat a = mod(-angle + iTime, 2.*3.1415);\n    float line = pow(2., 1.-4.*a);\n    \n    vec4 foreground1 = mix(circles, vec4(0.,0.7,0.,0.), line);\n    vec4 foreground2 = circles * vec4(0.,0.7,0.,0.) * clamp(line, 0.45, 1.);\n    vec4 foreground = mix(foreground1, foreground2, style);\n    \n    vec4 background = clamp(2.5*p.y, 0.5, 1.)*vec4(0.3, 0.4, 0.2, 0.);\n    vec4 col = mix(background, foreground, smoothstep(0.255, 0.25, d));\n    return col;\n}\n\nvec2 distortion(vec2 uv) {\n    float amplitude = clamp(sin(iTime), 0.1, 1.);\n\n    // from https://www.shadertoy.com/view/4dBGzK\n    uv.x = uv.x + rand(vec2(iTime*0.03,uv.y*0.42)) * 0.02 * amplitude;\n\tuv.x += sin(rand(vec2(iTime*0.2, uv.y)))*0.005 * amplitude;\n    \n    // from https://www.shadertoy.com/view/ldXGW4\n    float vertJerkOpt = 1.;\n    float vertJerk = (1.0-step(snoise(vec2(iTime*1.5,5.0)),0.6))*vertJerkOpt;\n    float vertJerk2 = (1.0-step(snoise(vec2(iTime*5.5,5.0)),0.2))*vertJerkOpt;\n\tfloat vertMovementOpt = 1.;\n    float vertMovementOn = (1.0-step(snoise(vec2(iTime*0.2,8.0)),0.4)) * vertMovementOpt;\n    float yOffset = abs(sin(iTime)*2.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n\tuv.y = y;\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xx;\n\tuv = distortion(uv);\n    \n\tvec2 c = vec2(0.5, 0.3);\n    vec2 p = uv - c;\n    \n    vec2 bootSize = vec2(smoothstep(0., 0.1, iTime), smoothstep(0., 0.8, iTime));\n\tp /= bootSize;\n\tvec2 bounds = smoothstep(0.501, 0.5, p) * smoothstep(-0.501, -0.5, p);\n\tfloat warmup = 1. - pow(2., -(iTime+0.2));\n\tfloat intensity = bounds.x*bounds.y * warmup/(bootSize.x*bootSize.y);\n    \n    float style = 0.;//smoothstep(0.45, 0.55, 0.5+0.5*sin(iTime*0.5));\n    vec4 col = sonar(p, style);\n\n    // postprocessing from https://www.shadertoy.com/view/4dfGzn\n    col *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);\n    col *= 0.9+0.1*sin(10.0*iTime+uv.y*1000.0);\n    //col *= 0.97+0.03*sin(110.0*iTime);\n\n    col *= 0.7 + 0.3*snoise(p * 1000. + 100.*vec2(iTime));\n    fragColor = col * intensity;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 117, 138, 138, 187], [189, 189, 210, 210, 259], [261, 261, 283, 283, 320], [322, 322, 346, 346, 1852], [2083, 2083, 2105, 2105, 2348], [2350, 2350, 2377, 2377, 3015], [3017, 3017, 3050, 3050, 3597], [3599, 3599, 3625, 3625, 4366], [4368, 4368, 4425, 4425, 5249]], "test": "valid"}
{"id": "MlKXz3", "name": "Panelled Tube", "author": "Shane", "description": "A tunnel with some faux timber panelling.", "tags": ["tunnel", "polar", "tube"], "likes": 32, "viewed": 1048, "published": "Public API", "date": "1486731747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tPanelled Tube\n\t-------------\n\n\tNothing exciting. Just a less detailed, slightly cleaner rehash of my previous tunnel\n\texample. I was going for a hard-lacquered faux timber panel look, because I wanted \n\tsomething reflective and shiny, but it's possible to make it look like real timber with \n\ta few setting and material changes here and there.\n\n\tI'm on a very fast laptop at the moment, so I have no idea how well - or badly - this \n\truns. My mother used to say that the best optimizing tool is a slow computer. I tend to \n\tagree, but sometimes it can be disappointing getting something looking the way you want \n\ton your good machine, then having to throw out details in order to cater for older \n\thardware... OK, reading that sentence back to myself brings the \"First World Problems\" \n\tmeme to mind. :D\t\n\n\tAnyway, without the cheap (12 iteration) reflective pass, I'd imagine this would run \n\tat 60 fps on most systems. With it... between 30 and 60 fps, although that's just a \n\tguess.\n\t\n\n*/\n\n// Maximum ray distance.\n#define FAR 50.\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic picture focus adjusting thing with your eyes.\n//#define THREE_D \n\n// Object ID, used for the gold trimming in the bump mapping section.\nfloat svObjID, svObjID2;\nvec3 vObjID;\n\n#define TUN 0. // Tunnel: Basically, the metal plates.\n#define ROD 1. // Rod:  Silver rod, and washer, attached to the bolts.\n#define BLT 2. // Bolts:  The hexagonal fasteners.\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    \n    // Curvy path. Weaving around the columns.\n    float a = sin(t*3.14159265/16. + 1.5707963);\n    float b = cos(t*3.14159265/16.);\n    \n    return vec3(a, b*a*.5, t);     \n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPathPL(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    \n    float it = floor(t + 1.);\n    float ft = t - it;\n    \n    // Curvy path. Weaving around the columns.\n    float a = sin(it*3.14159265/16. + 1.5707963);\n    float b = cos(it*3.14159265/16.);\n    \n    vec2 p0 = vec2(a, b*a*.5);\n    \n    a = sin((it + 1.)*3.14159265/16. + 1.5707963);\n    b = cos((it + 1.)*3.14159265/16.);\n    \n    vec2 p1 = vec2(a, b*a*.5);\n    \n    vec2 p = mix(p0, p1, ft);\n    \n    return vec3(p, t);     \n}\n\n\n// Minimum - with corresponding object ID.\nvec2 objMin(vec2 a, vec2 b){ \n    \n    // Returning the minimum distance along with the ID of the\n    // object. This is one way to do it. There are others.\n    return a.x < b.x ? a : b;\n    \n    //Equivalent to: return a.x < b.x ? a: b; \n    //float s = step(a.x, b.x);\n    //return s*a + (1. - s)*b;\n}\n\n\n// The tunnel scene. There's a bit of code, but it's nothing more than a bunch of boxes\n// and cylinders spread out around some repeat cylindrical coordinates.\nfloat map(vec3 p){\n    \n    const float depth = .25; // Depth of the rounded metal plates.\n    \n    // Mold the scene around the path.\n    p.xy -= camPath(p.z).xy;\n    \n    // The edge of the tunnel. Set at a radius of one, plus the depth.\n    float tun = (1. + depth) - length(p.xy); \n    //max(abs(p.x)*.866025 + abs(p.y)*.5, abs(p.y));//\n\n    \n    ///////////////\n    \n    // The tunnel walls. Due to the amount of detailing and the polar conversion, it \n    // looks more complicated than it actually is. To repeat across the XY plane we\n    // do something along the lines of \"p.xz = mod(p.xz, c) - c/2.\" To repeat around\n    // a circle in the XY plane, we convert to polar coordinates, \"p.xy = rot(angle),\"\n    // (angle is based on \"atan(p.y, p.x),\" then do the same thing. The rest is basic\n    // unit circle trigonometry, etc. By the way, this is a rough description, so if\n    // something doesn't quite make sense, it probably doesn't. :)\n    \n    // Converting the XY plane to polar coordinates. I'm handling the panels (five per\n    // circle) and the bolts (15 per circle) at the same time to share some calculations.\n    // I'd love to use the geometry of one to constuct the other - in order to save\n    // some instructions, but I'm leaving it alone for now.\n    vec3 q = p; \n    vec3 q2 = p;    \n    \n    float a = atan(q.y, q.x)/6.2831853; // Polar angle of \"p.xy\" coordinate.\n    float ia = (floor(a*5.) + .5)/5.*6.2831853; // Angle between \"PI/5\" intervals.\n    float ia2 = (floor(a*15.) + .5)/15.*6.2831853; // Angle between \"PI/15\" intervals.\n    \n     // Polar conversion for 5 segments, but offset every second panel.\n    q.xy *= rot(ia + sign(mod(q.z + 1., 4.) - 2.)*3.14159/15.);// \n    //float of2 = sign(mod(q.z + .5, 2.) - 1.)*3.14159/15.;\n    q2.xy *= rot(ia2); // Polar conversion for 15 segments (for the bolts).\n   \n    // The X-coordinate is now the radial coordinate, which radiates from the center\n    // to infinity. We want to break it into cells that are 2 units wide, but centered\n    // in the middle. The result is that the panels will start at radius one.\n    q.x = mod(q.x, 2.) - 1.;\n    // Plain old linear Z repetion. We want the panels and bolts to be repeated in the\n    // Z-direction (down the tunnel) every half unit.\n    q.z = mod(q.z, 2.) - 1.;\n    \n    // Moving the bolts out to a distance of 2.25.\n    q2.x = mod(q2.x, (2. + .25)) - (2. + .25)/2.;\n    \n    // Now, it's just a case of drawing and positioning some basic shapes. Boxes and\n    // tubes with a hexagonal cross-section.\n    q = abs(q);\n    q2 = abs(q2);\n\n    // Panelling details.\n    float tunDetail = max(min(q.y, q.z) - .07, -(min(q.y, q.z) - .007));     \n \n    // Adding the tunnel details (with a circular center taken out) to the tunnel.\n    tun = min(tun, max(tunDetail, tun-depth));  \n    \n    ///////////////\n    \n    // Bolts: Hexagon shapes spaced out fifteen times around the tunnel walls. The \n    // panels are spaced out in fifths, so that means three per panel. And yes, they're\n    // technically nuts (not bolts), but I was too lazy to change the variable names\n    // for the previous example. :)\n    float blt = max(max(q2.x*.866025 + q2.y*.5, q2.y) - .055, q.z - .16);\n    //blt = min(blt, max(length(q2.xy) - .07, q.z - .08));\n    \n    float thread = max(sin(q.z*6.283*64.)*2., 0.)*.002;\n    float rod = max(length(q2.xy) - .025 + thread, q.z - .19);\n    rod = min(rod, max(length(q2.xy) - .075, q.z - .09));\n\n\n    \n    // Determine the overall closest object and its corresponding object ID. There's a way\n    // to save some cycles and take the object-ID calculations out of the distance function, \n    // but I'm leaving them here for simplicity.\n    //vec2 d = objMin(vec2(tun, TUN), vec2(blt, BLT));\n    //d = objMin(d, vec2(rod, ROD));\n    \n    // Save all the object IDs here, then sort them later. It's overcomplicated, but saves \n    // a few cycles.\n    vObjID = vec3(tun, blt, rod);\n    \n    return min(min(tun, blt), rod); // Return the closest distance.\n\n\n    \n    \n}\n\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\n// For faster machines, use about 32 iterations, and you'll get a more accurate reflection.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0.0;\n    for(int i=0; i<12; i++){\n        float d = map(ro + rd*t);\n        if (abs(d) < 0.005*(t*.25 + 1.) || t>FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n\n// Raymarching.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    // Adjusting the texture calculations to the camera path. Add in the checkered texture,\n    // then comment it out to see what it's for.\n    p.xy -= camPath(p.z).xy;\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\n\n/*\n// The normal function with some 6-tap curvature rolled into it. Sometimes, it's possible to get away\n// with six taps overall, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float crv, float ef){ \n\t//ef/iResolution.y\n    vec2 e = vec2(ef/450., 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p);\t// The hit point itself - Doubled to cut down on calculations. See below.\n    \n    // Seven-tap curvature calculation. You can get away with four taps, but this is a little\n    // more accurate.\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*6.)*32. + .5, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.005, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*/\n\n\n// The normal function with some cheaper 4-tap curvature rolled into it. The 4-tap curvature\n// came from Nimitz.\nvec3 nrHyb(vec3 p, inout float crv, float ef){ \n\t\n    // Edging thickness. I wanted the edges to be resolution independent... or to put it\n    // another way, I wanted the lines to be a certain pixel width regardless of the \n    // canvas size. If you don't, then the lines can look too fat in fullscreen.\n    vec2 e = vec2(-1., 1.)*.66*ef/450.;  \n    \n    // The hit point value, and four nearby samples, spaced out in a tetrahedral fashion.\n\tfloat d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\tfloat d3 = map(p + e.xyx), d4 = map(p + e.yyy);\n    float d = map(p);\n    float d5, d6;\n    \n    crv = clamp((d1 + d2 + d3 + d4 - d*4.)*24. + .5, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.005, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so am saving a few map calls.\n// I've added to the function to include a rough tetrahedral edge calculation.\nvec3 nrRef(in vec3 p, inout float crv, in float ef){\n  \n    // Edging thickness. I wanted the edges to be resolution independent... or to put it\n    // another way, I wanted the lines to be a certain pixel width regardless of the \n    // canvas size. If you don't, then the lines can look too fat in fullscreen.\n    vec2 e = vec2(-1., 1.)*.66*ef/450.;  \n    \n    // The hit point value, and four nearby samples, spaced out in a tetrahedral fashion.\n\tfloat d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\tfloat d3 = map(p + e.xyx), d4 = map(p + e.yyy); \n    float d = map(p);\n    \n    // Edge calculation. Taking for samples around the hit point and determining how\n    // much they vary. Large variances tend to indicate an edge.\n    //crv = abs(d1 + d2 + d3 + d4 - d*4.);\n    //crv = smoothstep(0., 1., sqrt(crv/e.y*2.));\n    \n    crv = clamp((d1 + d2 + d3 + d4 - d*4.)*24. + .5, 0., 1.);\n    \n    // Recalculating for the normal. I didn't want the sample spacing to change from\n    // one resolution to the next. Hence, the fixed number. Just for the record, I tend\n    // to work within the 800 by 450 window. \n    e = vec2(-1., 1.)*.002;  \n\td1 = map(p + e.yxx), d2 = map(p + e.xxy);\n\td3 = map(p + e.xyx), d4 = map(p + e.yyy); \n    \n    // Normalizing.\n\treturn normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );   \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return tx*.5 + smoothstep(0.02, .8, tx);\n}\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    u.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    float speed = 2.;\n    vec3 ro = camPath(iTime*speed + .0); // Camera position, doubling as the ray origin.\n    \n    vec3 lk = camPath(iTime*speed + .5);  // \"Look At\" position.\n    //ro.y -= .1; // Hack to lower the camera.\n    //lk.y -= .1;\n    \n    vec3 lp = camPath(iTime*speed + 2.); // Light position, somewhere near the moving camera.\n    lp.y += .5;\n    // Alternative. Moving the light to the right a bit. \n    //float th = 6.283*1./12.;\n    //lp += vec3(sin(th)*.6, cos(th)*.6, 0); \n    \n    #ifdef THREE_D\n    ro.x -= sg*.15; lk.x -= sg*.15; lp.x -= sg*.15;\n    #endif\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    // Mild lens distortion to fit more of the scene in, and to mix things up a little.\n    vec3 rd = fwd + FOV*(u.x*rgt + u.y*up);\n    rd = normalize(vec3(rd.xy, (rd.z - length(rd.xy)*.25)*.75));\n    \n    // Swiveling the camera from left to right when turning corners.\n    float swivel = camPath(lk.z).x;\n    rd.xy = rot(swivel/48. )*rd.xy;\n    rd.xz = rot(swivel/32. )*rd.xz;\n \n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    \n    // Determine the object ID here. It's a more cumbersome method, but a saves a\n    // heap of sorting in the distance function, so is a lot faster.\n    vec2 vObj = objMin(vec2(vObjID.x, TUN), vec2(vObjID.y, BLT));\n    vObj = objMin(vObj, vec2(vObjID.z, ROD));\n    svObjID = vObj.y;\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Offset path. It's handy to have an adjusted hit point \n    // that aligns with the path contour.\n    //vec3 pathSp = sp - camPath(sp.z);\n    \n    \n    // Normal with curvature component.\n    float crv = 1., ef = 8.; // ef - Edge and curvature factor.\n    \n    // Normal and curvature calculations.\n    vec3 sn = nrHyb(sp, crv, ef);\n    \n    //vec3 svN = sn; // Sometimes, it's handy to save the normal before bumpping it.\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .0001);\n    ld /= lDist;\n    \n    // Attenuation.\n    float atten = 1./(1.0 + lDist*.25 + lDist*lDist*.025);\n    \n    // Texturing the object.\n    const float tSize0 = 1./1.;\n    vec3 tx = tex3D(iChannel0, sp*tSize0, sn);\n    tx = tx*.5 + smoothstep(0.02, .8, tx)*1.;\n \n    // Ugly \"if\" statements for object coloring. They do the job though. \n    float gr = dot(tx, vec3(.299, .587, .114));    \n    if(svObjID==TUN) tx *= vec3(1); \n\telse if(svObjID==ROD) tx = (gr*.5 + .5)*vec3(1);//vec3(1.25, 1, .75);\n    else if(svObjID==BLT) tx = (tx*.5 + .5)*vec3(1.4, .7, .05);\n\n \n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(ld, sn), 0.);\n    \n    float spe = pow(max(dot(reflect(rd, sn), ld), 0.), 64.);\n    //float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 2.);\n    \n    // The specular looks a little too full on at particular angles, so I've had to do\n    // the Schlick thing to tone them down a little.\n    float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n    Schlick = mix(.5, 1., Schlick);\n    \n    // Ramp up the diffuse on the metallic objects.\n    if(svObjID!=TUN)\n        dif = (pow(dif, 4.)*.5 + pow(dif, 8.)*.5)*3.;\n\n  \n    /////////////////////\n    // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n    // effort is being put in. By the way, this is really ugly, and there are definitely neater\n    // ways to get the job done.\n    //\n    vec3 ref = reflect(rd, sn); // Reflected ray. //svN*.1 + sn*.9\n    float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n    vObj = objMin(vec2(vObjID.x, TUN), vec2(vObjID.y, BLT));\n    vObj = objMin(vObj, vec2(vObjID.z, ROD));\n    svObjID2 = vObj.y;\n    float crv2 = 1.;\n    vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n    vec3 rsn = nrRef(rsp, crv2, ef); // Normal at the reflected surface. //, cr2, ef\n\n    vec3 rCol = tex3D(iChannel0, rsp*tSize0, rsn);\n    rCol = smoothstep(0.02, .8, rCol)*2.;\n\n    gr = dot(rCol, vec3(.299, .587, .114)); \n    if(svObjID2==TUN) rCol *= vec3(1); \n    else if(svObjID2==ROD) rCol = (gr*.5 + .5)*vec3(1);\n    else if(svObjID2==BLT) rCol = (rCol*.5 + .5)*vec3(1.4, .7, .05);\n\n    float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse light at \"rsp.\"\n    float rSpec = pow(max(dot(reflect(ref, rsn), normalize(lp-rsp)), 0.), 8.); // Diffuse light at \"rsp.\"\n    float rlDist = length(lp - rsp);\n\n    if(svObjID2!=TUN) rDiff = (pow(rDiff, 4.)*.5 + pow(rDiff, 8.)*.5)*3.;\n\n    // Reflected color. Not entirely accurate, but close enough. \n    rCol = rCol*(rDiff + .25) + vec3(1., .6, .2)*rSpec*2.;\n    rCol *= 1./(1. + rlDist*0.25 + rlDist*rlDist*.025); \n    rCol *= min(crv2*1.5, 1.);\n    ///////////////////\n    \n     \n    // Combining the terms above to produce the final color.\n    // Note the ambient occlusion term in place of a constant ambient term. It makes for a subtle\n    // difference in ambient lighting in the corners. It's fake, obviously. :)\n    vec3 fc = tx*(dif + ao*.3) + vec3(1, .6, .2)*spe*Schlick*2.; // + vec3(1, .9, .7)*spot*4.\n    \n    \n    if(svObjID != TUN) fc += rCol*.5;\n    else fc += rCol*.25;\n    \n\n    \n    // Very uninspiring, fake environment mapping.. but much cheaper than the raymarched\n    // reflective pass above.\n    //fc += (dif*dif + spe)*eMap(reflect(rd, sn)/1.5, sn)*.15;\n    \n    \n       \n    fc *= atten*sh*ao;\n    //fc *= (1. - crv*.8);\n    fc *= clamp(crv*1.5, 0., 1.);\n    \n  \n    \n    // Mixing in some fog.\n    vec3 bg = vec3(1, .7, .4);\n    fc = mix(fc, bg*2., smoothstep(0., .95, t/FAR));\n    \n     \n    // Post processing.\n    //float gr = dot(fc, vec3(.299, .587, .114));\n    //fc = fc*.5 + pow(min(vec3(1.5, 1, 1)*gr, 1.), vec3(1, 3, 16))*.5;\n    \n     // Approximate gamma correction.\n\tfragColor = vec4(pow(clamp(fc, 0., 1.), vec3(1./2.)), 1.0); // 1./2.2, etc.\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1537, 1602, 1623, 1623, 1691], [1694, 1766, 1788, 1889, 2018], [2020, 2092, 2116, 2165, 2600], [2603, 2646, 2674, 2802, 2949], [2952, 3112, 3130, 3130, 7136], [7139, 7335, 7368, 7368, 7547], [7550, 7566, 7596, 7596, 7779], [7781, 7935, 7981, 8127, 8680], [9967, 10081, 10127, 10386, 11104], [11107, 11276, 11328, 11587, 12594], [12597, 12749, 12781, 12781, 13027], [13030, 13221, 13265, 13382, 14498], [14500, 14884, 14938, 14966, 21433]], "test": "error"}
{"id": "MlyXDV", "name": "Voronoian Waterway", "author": "dr2", "description": "Balloon flight in Voronoia", "tags": ["voronoi", "landscape", "flight"], "likes": 25, "viewed": 2659, "published": "Public API", "date": "1485945143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Voronoian Waterway\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Balloon flight in Voronoia.\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\n#define N_BAL 5\n\nmat3 vuMat;\nvec3 balPos[N_BAL], qHit, qHitFlm, vuPos, sunDir;\nfloat balRad, flmCylRad, flmCylLen, tCur, dstFar;\nint idObj, idGrp;\nbool balFlm[N_BAL], balFlmCur;\nconst float pi = 3.14159;\n\nfloat VorDist (vec2 p)\n{\n  vec3 dv;\n  vec2 ip, fp, g, b;\n  ip = floor (p);\n  fp = fract (p);\n  dv = vec3 (8.);\n  b.x = 0.;\n  for (float gy = -1.; gy <= 1.; gy ++) {\n    for (float gx = -1.; gx <= 1.; gx ++) {\n      g = vec2 (gx, gy);\n      dv.z = length (g + 0.9 * Hashv2v2 (ip + g) - fp);\n      b.y = step (dv.z, dv.y) * (dv.z - dv.y);\n      dv.xy += b + step (dv.z, dv.x) * (dv.zx - dv.xy - b);\n    }\n  }\n  return dv.y - dv.x;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float s;\n  s = Noisefv2 (0.7 * p.yx);\n  p += 0.2 * sin (2. * pi * s) +\n     0.1 * sin (2. * pi * Noisefv2 (2. * p.xy));\n  return 5. * smoothstep (0.05, 0.6 + 0.2 * s, VorDist (0.07 * p));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  float h;\n  h = GrndHt (p.xz);\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x,\n     h - GrndHt (p.xz + e.yx)));\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_BAL; k ++) {\n    if (balFlm[k]) {\n      q = p - (balPos[k] - vec3 (0., 0.8 * balRad, 0.));\n      d = PrCylDf (q.xzy, flmCylRad + 0.3 * q.y / flmCylLen, flmCylLen);\n      d = max (d, - q.y - 0.5 * flmCylLen);\n      if (d < dMin) { dMin = d;  qHitFlm = q; }\n    }\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = FlmDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat BalDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = max (PrSphDf (q, balRad), - PrSphDf (q, 0.98 * balRad));\n  q.y -= - balRad;\n  d = max (d, - PrCylDf (q.xzy, 0.3 * balRad, 0.1 * balRad));\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = p;}\n  q = p;\n  q.y -= -1.42 * balRad;\n  d = PrCylDf (q.xzy, 0.05 * balRad, 0.13 * balRad);\n  q.y -= 0.02 * balRad;\n  d = max (d, - PrCylDf (q.xzy, 0.03 * balRad, 0.13 * balRad));\n  if (d < dMin) { dMin = d;  idObj = 2;  qHit = p;}\n  q = p;\n  q.y -= -1.5 * balRad;\n  d = PrCylDf (q.xzy, 0.2 * balRad, 0.07 * balRad);\n  q.y -= 0.02 * balRad;\n  d = max (d, - PrCylDf (q.xzy, 0.18 * balRad, 0.07 * balRad));\n  if (d < dMin) { dMin = d;  idObj = 3;  qHit = p;}\n  q = p;\n  q.xz = abs (q.xz) - 0.25 * balRad;\n  q.y -= -1.15 * balRad;\n  q.yz = Rot2D (q.yz, -0.35);\n  q.xy = Rot2D (q.xy, 0.35);\n  d = PrCylDf (q.xzy, 0.005 * balRad, 0.35 * balRad);\n  if (d < dMin) { dMin = d;  idObj = 4;  qHit = p;}\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < N_BAL; k ++) {\n    d = BalDf (p - balPos[k], dMin);\n    if (d < dMin) { dMin = d;  idGrp = k;  balFlmCur = balFlm[k]; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.5) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  sd = pow (max (dot (rd, sunDir), 0.), 64.);\n  col = SkyBg (rd) + (0.35 * sd + 0.65 * min (pow (sd, 4.), 0.3)) *\n     vec3 (1., 1., 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 FlmCol (vec3 p, vec3 rd)\n{\n  vec3 q, qq;\n  float a, f, dr;\n  a = 0.;\n  p.y -= - flmCylLen;\n  dr = 0.05 / flmCylRad;\n  for (int j = 0; j < 20; j ++) {\n    p += dr * rd;\n    q = 15. * p / flmCylLen;\n    q.y -= 40. * tCur;\n    qq.y = Noisefv3 (q + 0.1 * vec3 (sin (tCur)));\n    qq.x = Noisefv3 (q + vec3 (qq.y));\n    qq.z = Noisefv3 (q + vec3 (qq.x));\n    q = p + 0.25 * (1. - 3. * p.y / flmCylLen) * (qq - 0.5);\n    f = 0.45 * q.y - 2.5 * length (q.xz);\n    f = clamp (sign (f) * f * f, 0., 1.) * (3. - 0.9 * q.y);\n    a += f;\n  }\n  return clamp (a * vec3 (1., 0.5, 0.3), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, colFlm;\n  float dstObj, dstFlm, dstGrnd, f, a;\n  bool inSun, inFlm;\n  dstGrnd = GrndRay (ro, rd);\n  dstFlm = FlmRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  inSun = true;\n  inFlm = false;\n  if (dstObj < min (dstGrnd, dstFar)) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col = HsvToRgb (vec3 (float (idGrp) / float (N_BAL), 0.9, 0.8));\n      inFlm = balFlmCur;\n      if (length (qHit) < 0.99 * balRad) {\n        col *= 0.2;\n        if (inFlm) col += 0.1 * vec3 (1., 0.5, 0.);\n        inSun = false;\n      } else {\n        if (length (qHit) > 0.99 * balRad) {\n          a = atan (qHit.x, qHit.z) / (2. * pi) + 0.5;\n          vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (24. * a, 1.))));\n        }\n      }\n    } else if (idObj == 2) {\n       a = atan (qHit.x, qHit.z) / (2. * pi) + 0.5;\n       vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (12. * a, 1.))));\n      col = vec3 (0.6);\n    } else if (idObj == 3) {\n      a = atan (qHit.x, qHit.z) / (2. * pi) + 0.5;\n      vn.xz = Rot2D (vn.xz, 0.1 * pi * sin (pi * (0.5 - mod (32. * a, 1.))));\n      col = vec3 (0.6, 0.3, 0.);\n    } else if (idObj == 4) {\n      col = vec3 (0.3);\n    }\n    if (inSun) col = col * (0.2 +\n       0.2 * max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.) +\n       0.6 * max (dot (vn, sunDir), 0.)) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n  } else if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    if (ro.y > 0.1) {\n      vn = VaryNf (1.3 * ro, GrndNf (ro), 5.);\n      f = clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.);\n      col = mix (mix (vec3 (0.4, 0.3, 0.), vec3 (0.5, 0.4, 0.1), f),\n         mix (vec3 (0.3, 0.7, 0.3), vec3 (0.5, 0.6, 0.1), f),\n         (0.1 + 0.9 * smoothstep (0.1, 0.2, ro.y)) *\n         clamp (1.2 * vn.y - 0.2, 0.2, 1.)) *\n         (0.3 + 0.7 * max (0., max (dot (vn, sunDir), 0.))) +\n         0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    } else {\n      vn = VaryNf (5.1 * ro, vec3 (0., 1., 0.), 0.2);\n      rd = reflect (rd, vn);\n      col = mix (vec3 (0.15, 0.2, 0.15), vec3 (0.1, 0.1, 0.2), Fbm2 (ro.xz));\n      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.8, 0.95,\n          1. - pow (dot (rd, vn), 3.)));\n    }\n    col = mix (col, SkyBg (rd), max (pow (dstGrnd / dstFar, 4.) - 0.1, 0.));\n  } else col = SkyCol (ro, rd);\n  if (dstFlm < min (min (dstGrnd, dstObj), dstFar)) {\n    colFlm = FlmCol (qHitFlm, rd);\n    col = mix (col, colFlm, 0.6 * length (colFlm));\n  }\n  if (inFlm) col = mix (col, vec3 (1., 0.5, 0.),\n     0.3 * pow (clamp (dot (normalize (qHit), - rd), 0., 1.), 4.));\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.35 * t) * sin (0.12 * t) * cos (0.1 * t) +\n     26. * sin (0.032 * t), 1. + 3. * sin (0.21 * t) * sin (1. + 0.23 * t),\n     10. * t);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  vuPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * vuPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 0.02 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  vuMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat2;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, s, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  sunDir = normalize (vec3 (1., 0.5, 0.5));\n  dstFar = 200.;\n  balRad = 2.;\n  for (int k = 0; k < N_BAL; k ++) {\n    s = float (k - 1) / float (N_BAL);\n    balPos[k] = TrackPath (0.5 * tCur + 3. + 7. * s);\n    a = 2. * pi * fract (0.037 * tCur + s);\n    balPos[k].y = 6.5 * balRad + 2. * balRad * sin (a);\n    balFlm[k] = (a > pi);\n  }\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el - 1.3 * pi * mPtr.y, - 0.49 * pi, 0.49 * pi);\n    az = clamp (az - 1.8 * pi * mPtr.x, - pi, pi);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat2 = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  VuPM (0.5 * tCur);\n  ro = vuPos;\n  ro.y += 6.5 * balRad + 2. * balRad * sin (2. * pi * fract (0.07 * tCur));\n  rd = normalize (vec3 (uv, 2.))* vuMat2 * vuMat;\n  flmCylRad = 0.4;\n  flmCylLen = 2.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyXDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 627, 651, 651, 1057], [1059, 1059, 1082, 1082, 1274], [1276, 1276, 1310, 1310, 1803], [1805, 1805, 1827, 1827, 1979], [1981, 1981, 2003, 2003, 2354], [2356, 2356, 2389, 2389, 2598], [2600, 2600, 2634, 2634, 3565], [3567, 3567, 3589, 3589, 3786], [3788, 3788, 3821, 3821, 3997], [3999, 3999, 4020, 4020, 4227], [4229, 4229, 4251, 4251, 4322], [4324, 4324, 4356, 4356, 4671], [4673, 4673, 4704, 4704, 5258], [5260, 5260, 5295, 5295, 7961], [7963, 7963, 7989, 7989, 8153], [8155, 8155, 8176, 8176, 8776], [8778, 8778, 8834, 8834, 10024], [10026, 10026, 10059, 10059, 10086], [10088, 10088, 10130, 10130, 10181], [10183, 10183, 10213, 10213, 10271], [10273, 10273, 10297, 10297, 10428], [10551, 10551, 10575, 10575, 10622], [10624, 10624, 10648, 10648, 10821], [10823, 10823, 10847, 10847, 11086], [11088, 11088, 11113, 11113, 11292], [11294, 11294, 11319, 11319, 11663], [11664, 11664, 11685, 11685, 11840], [11842, 11842, 11871, 11871, 12099], [12101, 12101, 12140, 12140, 12363]], "test": "error"}
{"id": "MlyXWV", "name": "Fun with metaballs", "author": "fwilliams", "description": "Render some metaballs", "tags": ["metaballs"], "likes": 5, "viewed": 109, "published": "Public", "date": "1485925736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_ITERS = 64;\nconst float EPSILON = 1e-2;\n\n#define SPHERE1_CTR vec4(0.75*sin(0.5*iTime), -1.5*sin(0.5*iTime), 5.0, 1.0)\n#define SPHERE2_CTR vec4(-0.69*cos(0.5*iTime), 1.5*sin(0.5*iTime), 5.0, 1.0)\n#define SPHERE3_CTR vec4(0.83*cos(0.5*iTime), -1.0*cos(0.5*iTime), 5.0, 1.0)\n#define SPHERE4_CTR vec4(1.7*cos(0.6*iTime), 1.7*cos(0.7*iTime), 5.0, 1.0)\nconst vec4 SPHERE1_COLOR = vec4(0.9, 0.2, 0.2, 1.0);\nconst vec4 SPHERE2_COLOR = vec4(0.1, 0.1, 0.9, 1.0);\nconst vec4 SPHERE3_COLOR = vec4(0.2, 0.9, 0.2, 1.0);\nconst vec4 SPHERE4_COLOR = vec4(0.9, 0.9, 0.05, 1.0);\nconst float SPHERE1_RAD = 0.5;\nconst float SPHERE2_RAD = 0.5;\nconst float SPHERE3_RAD = 0.5;\nconst float SPHERE4_RAD = 0.5;\n\nconst vec4 LIGHT1_POS = vec4(10.0, -10.0, -10.0, 1.0);\nconst vec4 LIGHT2_POS = vec4(0.0, 0.0, -10.0, 1.0);\nconst vec4 LIGHT3_POS = vec4(-10.0, 10.0, -10.0, 1.0);\nconst vec4 LIGHT_COLOR = vec4(0.5, 0.5, 0.5, 1.0);\nconst float SHINE = 499.0;\nconst vec4 AMBIENT = vec4(0.0); //vec4(0.06, 0.05, 0.05, 1.0);\n\n//vec4 GROUND_COLOR = vec4(0.5* (0.5 + cos(0.05*iTime)), 0.65, 0.7 * (0.5 + sin(0.5*iTime)), 1.0);\nvec4 GROUND_COLOR = vec4(0.5, 0.5, 0.7, 1.0);\n\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat sphereImplicit(in vec4 pt, in float radius, in vec4 position) {\n\treturn length(pt - position) - radius;\n}\n\nfloat smin(float a, float b, float blendRadius) {\n    float c = saturate(0.5 + (b - a) * (0.5 / blendRadius));\n    return mix(b, a, c) - blendRadius * c * (1.0 - c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    \n    vec4 rayDir = vec4(fragCoord.xy / iResolution.xy - vec2(0.5, 0.5), 1.0, 0.0);\n    vec4 iterPos = vec4(rayDir.xyz, 1.0);\n    rayDir = rayDir / length(rayDir);\n    \n    float specular = 0.0;\n    \n    vec4 color = GROUND_COLOR;\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n\n    for (int i = 0; i < MAX_ITERS; i++) {\n    \tfloat d = smin(smin(smin(sphereImplicit(iterPos, SPHERE1_RAD, SPHERE1_CTR),\n                                 sphereImplicit(iterPos, SPHERE2_RAD, SPHERE2_CTR), 1.3),\n                            sphereImplicit(iterPos, SPHERE3_RAD, SPHERE3_CTR), 1.2),\n                            sphereImplicit(iterPos, SPHERE4_RAD, SPHERE4_CTR), 1.25);\n                      ;\n        if (d < EPSILON) {\n            specular = ( 8.0 * SHINE ) / ( 8.0 * 3.14159265 );\n            float d1 = abs(1.0/(EPSILON + sphereImplicit(iterPos, 0.5, SPHERE1_CTR)));\n            float d2 = abs(1.0/(EPSILON + sphereImplicit(iterPos, 0.5, SPHERE2_CTR)));\n            float d3 = abs(1.0/(EPSILON + sphereImplicit(iterPos, 0.5, SPHERE3_CTR)));\n\t\t\tfloat d4 = abs(1.0/(EPSILON + sphereImplicit(iterPos, 0.5, SPHERE4_CTR)));\n            \n            float i1 = d1 / (d1+d2+d3+d4);\n            float i2 = d2 / (d1+d2+d3+d4);\n            float i3 = d3 / (d1+d2+d3+d4);\n\t\t\tfloat i4 = d4 / (d1+d2+d3+d4);\n            \n            vec3 normal1 = normalize(vec3(iterPos - SPHERE1_CTR));\n            vec3 normal2 = normalize(vec3(iterPos - SPHERE2_CTR));\n            vec3 normal3 = normalize(vec3(iterPos - SPHERE3_CTR));\n            vec3 normal4 = normalize(vec3(iterPos - SPHERE4_CTR));\n            \n            normal = normalize(i1*normal1 + i2*normal2 + i3*normal3 + i4*normal4);\n            color = (i1*SPHERE1_COLOR + i2*SPHERE2_COLOR + i3*SPHERE3_COLOR + i4*SPHERE4_COLOR);\n            break;\n        } else {\n            iterPos += d*rayDir;\n        }\n    }\n\n    vec3 light1dir = normalize(vec3(LIGHT1_POS - iterPos));\n    vec3 light2dir = normalize(vec3(LIGHT2_POS - iterPos));\n    vec3 light3dir = normalize(vec3(LIGHT3_POS - iterPos));\n\n    vec3 r1 = -normalize(reflect(light1dir, vec3(normal))); \n    vec3 r2 = -normalize(reflect(light2dir, vec3(normal))); \n    vec3 r3 = -normalize(reflect(light3dir, vec3(normal))); \n\n   \tvec3 v = -normalize(vec3(iterPos));\n    vec3 h1 = normalize(light1dir + v);\n    vec3 h2 = normalize(light2dir + v);\n    vec3 h3 = normalize(light3dir + v);\n\n    fragColor = LIGHT_COLOR * (\n        dot(normal, light1dir) + specular*pow(max(dot(r1, h1), 0.0), SHINE) + \n        dot(normal, light2dir) + specular*pow(max(dot(r2, h2), 0.0), SHINE) + \n        dot(normal, light3dir) + specular*pow(max(dot(r3, h3), 0.0), SHINE)\n    );\n    fragColor *= color;\n    fragColor += AMBIENT;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1004, 1150, 1175, 1175, 1204], [1206, 1206, 1275, 1275, 1317], [1319, 1319, 1368, 1368, 1486], [1488, 1488, 1543, 1543, 4268]], "test": "valid"}
{"id": "MsfcDr", "name": "Melty SDF Torus Lattice", "author": "bio998", "description": "messing around with sdfs and lattices", "tags": ["sdf", "columns", "lattice", "camfer", "cabbibo"], "likes": 0, "viewed": 470, "published": "Public API", "date": "1487683940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// If you came here to learn, I just began this so!  Check out the Cabbibo SDF tutorial:\n// Well really it is Cabbibo's shader tutorial available at\n// https://www.shadertoy.com/view/Xl2XWt\n\n// Also using some of the following library\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n\n//Also using code from for the torus sdf\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n//this is from\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n//Union function from the SDF library\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  //vec2 q = vec2(length(p.xz)-t.x,p.y);\n  //return length(q)-t.y;\n    \n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nvec2 sdfTorus( vec3 currentRayPosition){\n    \n      currentRayPosition.x -= iTime * 0.3;\n      currentRayPosition.z += iTime * 0.3;\n      currentRayPosition.z -= iTime * 0.5;\n\n\n  currentRayPosition.z -= 0.3;\n      currentRayPosition.y -= 0.5;\n\n    \n    pMod1(currentRayPosition.x,1.);\n    pMod1(currentRayPosition.y,1.);\n    pMod1(currentRayPosition.z,1.);\n\n    \n    vec2 torusRadii = vec2(0.4,0.03);\n    float torusID = 4.;\n    \n    vec2 torus = vec2( sdTorus(currentRayPosition,torusRadii), torusID);\n    return torus;\n    \n}\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 sdfRoundBox( vec3 currentRayPosition ){\n    \n  currentRayPosition.x -= sin(iTime) * 0.3;\n  currentRayPosition.z -= iTime * 0.3;\n  currentRayPosition.z -= iTime * 0.5;\n\n\n  currentRayPosition.z -= 0.3;\n  currentRayPosition.y -= 0.3;\n\n  \n\n    \n  pMod1(currentRayPosition.x,1.);\n  pMod1(currentRayPosition.y,0.6);\n  pMod1(currentRayPosition.z,1.);\n    \n    \n  \n    \n  float xpos = 0.3 * sin(iTime);\n  \n  // First we define our box position\n  //vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n  vec3 boxPosition = vec3( xpos , 0.0 , 0.0 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .08 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  //float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  vec3 zero = vec3(0.2);\n  float distanceToBoxSurface = udRoundBox(adjustedRayPosition, boxSize, 0.05);\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 3.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\nfloat smin( float a, float b)\n{\n   // float k = 0.77521;\n        \n    float k = 0.2521;\n\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\n\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 torus = sdfTorus( currentRayPosition );\n  vec2 box     = sdfRoundBox( currentRayPosition );\n        \n  result = whichThingAmICloserTo( torus , box );\n  //result.x = opBlend( torus.x, box.x);\n    \n  float chamferRadius = 0.15;\n  float numberOfColumns = 3.;\n  float colUnion =  fOpUnionColumns(torus.x, box.x, chamferRadius, numberOfColumns);\n  result.x = colUnion;\n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.005;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 30.;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\n//const int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 800;\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 21;\n\n\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.1,0.2,0.2 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 0.8 , 0.8 , 0.8 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n}\n\n\nvec3 doCurveBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 0.9 , 0.9 , 0.9 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n}\n\nvec3 doTorusColor(vec3 positionOfHit, vec3 normalOfSurface){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 1. , .4 , 0.3 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n    \n}\n\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }else if( rayHitInfo.y == 3.0 ){\n          \n      \tcolor = doCurveBoxColor( positionOfHit , normalOfSurface );   \n          \n      }else if( rayHitInfo.y == 4.0 ){\n          \n      \tcolor = doTorusColor( positionOfHit , normalOfSurface );   \n          \n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    vec3 eyePosition = vec3( 0., 0., 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 1063, 1146, 1146, 1324], [1327, 1486, 1526, 1526, 1647], [1649, 1685, 1710, 1710, 1750], [1752, 1864, 1923, 1923, 2534], [2539, 2539, 2572, 2639, 2709], [2712, 2712, 2752, 2752, 3239], [3243, 3243, 3287, 3287, 3328], [3330, 3330, 3374, 3374, 5004], [5006, 5006, 5037, 5062, 5187], [5190, 5190, 5226, 5290, 5319], [5321, 5516, 5572, 5572, 5956], [5964, 6117, 6161, 6161, 6580], [7753, 8000, 8063, 8268, 12454], [12631, 12993, 13042, 13042, 14039], [14045, 14133, 14158, 14158, 14189], [14194, 14194, 14258, 14258, 15353], [15356, 15356, 15421, 15421, 16516], [16518, 16518, 16578, 16578, 17672], [17676, 17797, 17857, 17857, 18056], [18061, 18162, 18239, 18303, 19771], [19775, 19775, 19832, 20276, 23193]], "test": "error"}
{"id": "MsfcWH", "name": "Simplex Raymarching", "author": "Tidensbarn", "description": "Simplex noise raymarching\nMouse enabled", "tags": ["raymarching"], "likes": 2, "viewed": 133, "published": "Public", "date": "1488040273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash( vec3 p ) \n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy *2. - 1.;\n\t\n    float len = length((iMouse.xy / iResolution.xy) * 2. - 1. - uv);\n    float len2 = len * len;\n    \n    vec3 v = vec3(uv * 4.3 * len2, iTime * 3.61 );\n    \n    float n=0.;\n    \n    float z = 1. + 1. / (5.+len *  115.);\n    \n    float max = 6.;\n    \n    float m = iMouse.x * 1. + iResolution.x /2.;\n    \n    \n    for(float i = 0.01;i<1.;i+=.009) {\n        \n        v.z += 7112.*(log(1.+i*0.00003));\n        v.xy *= z;\n        float f = noise(v);\n        if(f > .009 * (28.-len2)) {\n            n = 1.0- i;\n            break;\n        }\n    }\n    \n    \n    fragColor = vec4(n*n*0.6*len,0.,n*n*1.0,1.);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfcWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 219, 219, 1044], [1047, 1047, 1104, 1104, 1760]], "test": "valid"}
{"id": "MsfcWn", "name": "Neon Sines", "author": "lherm", "description": "Making my own plasma(ish) thing.", "tags": ["plasma", "2tweets"], "likes": 11, "viewed": 1126, "published": "Public API", "date": "1487654830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fabrice's 2nd optomization\nvoid mainImage( out vec4 O,  vec2 p )\n{\n\tp *= 5. / iResolution.xy;\n\n    vec4 a = vec4(.1,.4,.222,0) + iTime + atan(p.y, p.x), \n         b = a; b.y+=.4;\n    a = cos( sin(p.x)-cos(p.y) +a ),\n    b = sin( a*p.x*p.y - p.y   +b );\n\n    a =  abs(b*b-a*a);\n\n    O =  1.6 * pow(1.-a+a*a,  16.+a-a);\n}\n\n/*\n// Fabrice's optimization\nvoid mainImage( out vec4 O,  vec2 p )\n{\n\tp *= 5. / iResolution.xy;\n\n    float  T = iTime + atan(p.y, p.x);\n    vec4 a = cos(sin(p.x)-cos(p.y)+vec4(.1,.4,.222,0)+T),\n         b = sin(a*p.x*p.y - p.y  +vec4(.1,.8,.222,0)+T);\n\n    a =  abs(b*b-a*a);\n    O =  1.6 * pow(1.-a+a*a, vec4(16.));\n}\n*/\n\n/*\nOriginal implementation\n------------------------\n\n#define PI 3.1415926\n#define T iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 5.;\n    float phi = atan(p.y, p.x);\n    vec3 a = cos(sin(p.x)-cos(p.y)+vec3(.1,.4,.222)+T+phi);\n    vec3 b = sin(a*p.x*p.y-p.y+T+vec3(.1,.8,.222)+phi);\n    vec3 col = vec3(0.);\n    for (int i = 0; i < 3; i++)\n    {\n        col = 1.-abs(b*b-a*a)*col;\n    }\n    col = pow(col, vec3(8.));\n    col = smoothstep(0., 1., col);\n\tfragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfcWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 69, 69, 322]], "test": "valid"}
{"id": "MsfyD4", "name": "the situation with circles", "author": "jes5199", "description": "another exploration of artifacts", "tags": ["2d", "circles", "aliasing", "floatingpointerrors"], "likes": 4, "viewed": 142, "published": "Public", "date": "1488222676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((60.0 + iTime) / 5.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    float value = pow(uv.x,2.0) + pow(uv.y,2.0);\n    float color = sin(value) * 3.0;\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(low, med, high,1.0);\n    } else {\n      fragColor = vec4(med, med, low,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 466]], "test": "valid"}
{"id": "MsfyW8", "name": "Spinning Pattern", "author": "mende", "description": "Spinning Radial Design\n\nI know some of you will play \"code golf\" with this shader, it is not intended to be minified, just working.", "tags": ["test", "pattern", "spin", "design"], "likes": 0, "viewed": 89, "published": "Public", "date": "1487906395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define PI2 6.283184\n#define SEGMENTS 4.0 / 2.0\n#define COLOR1 vec3(0.0,0.0,0.0)\n#define COLOR2 vec3(0.1,0.1,0.1)\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.y / iResolution.x;\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    //uv.x += 0.2;\n    uv.y *= aspect;\n    float theta = (atan(uv.y, uv.x) + PI) / PI2 - iTime * 0.09;\n    if(theta > 1.0) theta = mod(theta, 1.0);\n    if(theta < 0.0) theta = 1.0 - mod(abs(theta), 1.0);\n    vec3 value = length(uv) < 0.05 ? COLOR1 : floor(mod(theta * SEGMENTS, 1.0) * 2.0) == 0.0 ? COLOR1 : COLOR2;\n\tfragColor = vec4(value, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= aspect;\n    vec3 value = fract((uv.x * sin(iTime) + uv.y * cos(iTime)) * (SEGMENTS + (sin(iTime * 8.0) * 0.5 + 0.5) * 1.5)) < 0.5 ? COLOR1 : COLOR2;\n\tfragColor = vec4(value, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 193, 193, 640], [642, 642, 699, 699, 991]], "test": "valid"}
{"id": "MslcD4", "name": "Paper sheets", "author": "josemorval", "description": "A bunch of overlapping sheets", "tags": ["waves", "shadow", "organic", "paper", "overlap", "sheets"], "likes": 25, "viewed": 972, "published": "Public API", "date": "1488313130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float dist,dist1,dist2,mask,l,final = 1.0;\n\t//This parameter controls how many sheets are in the picture\n    float s = 0.03;\n\t\n    float amp,freq;\n\tuv.x-=iResolution.x/iResolution.y;\n    \n    //This parameter controls when the algorithm stop drawing sheets (-1 is no sheet, 1 all sheets)\n    float factorSheets = iResolution.x/iResolution.y;\n    //Optional: very funny :)\n    //factorSheets*=sin(0.4*iTime);\n    \n    for(float f = -iResolution.x/iResolution.y;f<factorSheets;f+=s){\n        uv.x+=s;\n        //This parameter controls the frequency of the waves, modulated by an exp along the x-axis \n        freq = 5.0*exp(-20.0*(f*f));\n        //This parameter controls the amplitude of the waves, modulated by an exp along the x-axis \n        amp = 0.12*exp(-7.0*(f*f));\n        dist = amp*pow(sin(freq*uv.y+2.0*iTime+100.0*sin(122434.0*f)),2.0)*exp(-5.0*uv.y*uv.y)-uv.x;\n        mask = 1.0-smoothstep(0.0,0.005,dist);\n\n        //Draw each line of the sheet\n        dist1 = abs(dist);\n        dist1 = smoothstep(0.0,0.01,dist1);\n\t\t\n        //Draw the shadow of each line\n        dist2 =abs(dist);\n        dist2 = smoothstep(0.0,0.03,dist2);\n        dist2 = mix(0.5,1.0,dist2);\n        dist2 *= mask;\n\t\t\n        //Combine shadow and line\n        l = mix(dist1,dist2,mask);\n        //Combine the current sheet with the last drawn\n        final=mix(l,l*final,mask);\n\t}\n    \n //Add some color   \n //\tvec3 white = vec3(1.0,1.0,1.0);\n //\tvec3 blue = vec3(0.0/255.0,204.0/255.0,255.0/255.0);\n //\tvec3 color = mix(white,blue,final);\n //\tfragColor = vec4(color,1.0);\n\n\tfragColor = vec4(final,final,final,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslcD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1765]], "test": "valid"}
{"id": "MslcDn", "name": "Midterms   GRAPHPROG", "author": "mcad_30", "description": "ONE HELL OF A SHADER. 10 SHADES OF GREY DARKER", "tags": ["2d"], "likes": 0, "viewed": 82, "published": "Public", "date": "1487771785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define TWOPI 6.2831\n\n#define patternNo 1\n\nvec3 colorRed = vec3 (1.0, 0.0, 0.0);\nvec3 colorBlack = vec3(1.0, 1.0, 1.0);\nmat2 rotate2d(float angle);\nfloat createShape(vec2 centerPosition, float side);\nmat2 scale2d(vec2 size);\n\n#if patternNo == 1\n// Opposition, Sequence, Diversity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    //uv.x *= ratio;\n    uv *= 10.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n        \n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    \n    square1 = vec3(step(createShape(uv - squarePosition, 2.0), 0.4));\n    \tif (mod(tileIdx.x, 2.) == mod(tileIdx.y, 2.))\n    {\n    \tuv -= squarePosition;\n    \tuv *= rotate2d(-iTime * 8.0);\n   \t\tuv += squarePosition;\n    \tsquare1 = vec3(step(createShape(uv - squarePosition, 2.0), 0.4));\n    }\n    \n    vec3 square2 = vec3(1.0);\n        \n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 6.0), 0.2));\n        if (mod(tileIdx.x, 2.) == mod(tileIdx.y, 2.))\n    {\n    \tuv -= squarePosition;\n    \tuv *= rotate2d(-iTime * 8.0);\n   \t\tuv += squarePosition;\n    \tsquare2 = vec3(step(createShape(uv - squarePosition, 6.0), 0.2));\n    }\n    vec3 squares = square1 - square2;\n    squares *= colorRed;\n   \tfragColor = vec4(squares,1.0);\n}\n\n//Unity, Chaos, Sequence\n#elif patternNo == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 10.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n   \tuv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 100.0), 0.5));\n    \n    vec3 square2 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n    uv *= scale2d(vec2(sin(iTime * 10.0)));\n   \tuv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 4.0), 0.3));\n    \n        if (mod(tileIdx.x, 2.) == mod(tileIdx.y, 2.))\n        {\n    \t\t\tuv -= squarePosition;\n    \t\t\tuv *= rotate2d(-iTime * 8.0);\n   \t\t\t\tuv += squarePosition;\n    \t\t\tsquare2 = vec3(step(createShape(uv - squarePosition, 4.0), 0.3));\n        }\n    vec3 squares1 = square1 - square2;\n    squares1 *= colorRed;\n    fragColor = vec4(squares1,1.0);\n}\n\n// Simplicity, Elegance, Opposition\n#elif patternNo == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    //uv.x *= ratio;\n    uv *= 9.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    if (mod(tileIdx.x, 2.) == mod(tileIdx.y, 2.))\n    {\n        uv -= squarePosition;\n    \tuv *= rotate2d(45.0 * PI / 180.0);\n        uv *= scale2d(vec2(sin(iTime * 10.0)));\n   \t\tuv += squarePosition;\n        square1 = vec3(step(createShape(uv - squarePosition, 4.0), 0.4));\n    }\n   \tfragColor = vec4(square1,1.0);\n}\n\n// Harmony, Order, Unity\n#elif patternNo == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 10.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime);\n   \tuv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 4.0), 0.3));\n    \n    \n    vec3 square2= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(-iTime * 2.0);\n   \tuv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 4.0), 0.3));\n    \n    vec3 square3= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    square3 = vec3(step(createShape(uv - squarePosition, 2.0), 0.1));\n   \n    vec3 square4= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(-iTime * 8.0);\n   \tuv += squarePosition;\n    square4 = vec3(step(createShape(uv - squarePosition, 2.0), 0.1));\n    \n    vec3 squares = square1 - square2 + square3 + square4;\n    squares *= colorRed;\n    fragColor = vec4(squares,1.0);\n}\n\n// Chaos, Opposition, Unity\n#elif patternNo == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 4.0;\n    uv.y *= 1.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime);\n   \tuv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 8.0), 0.5));\n    \n    vec3 square2 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(-iTime * 4.0);\n   \tuv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 7.0), 0.4));\n    \n    vec3 square3= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    square3= vec3(step(createShape(uv - squarePosition, 6.0), 0.3));\n    \n    vec3 square4= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d( -iTime * 4.0);\n   \tuv += squarePosition;\n    square4= vec3(step(createShape(uv - squarePosition, 5.0), 0.2));\n    \n    vec3 square5= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    square5= vec3(step(createShape(uv - squarePosition, 4.0), 0.1));\n    \n    vec3 square6= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d( -iTime * 4.0);\n   \tuv += squarePosition;\n    square6= vec3(step(createShape(uv - squarePosition, 100.0), 0.04));\n    \n    vec3 squares1 = square1 - square2 + square3 - square4 + square5 - square6;\n    squares1 *= colorRed;\n    fragColor = vec4(squares1,1.0);\n}\n\n//Chaos, Emphasis, Unity\n#elif patternNo == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 10.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 2.0), 0.1));\n    \n    vec3 square3 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(-iTime * 8.0);\n   \tuv += squarePosition;\n    square3 = vec3(step(createShape(uv - squarePosition, 2.0), 0.1));\n    \n    vec3 square2= vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(-iTime);\n   \tuv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 9.0), 0.2));\n    \n    vec3 squares = square1 - square2 + square3;\n    squares *= colorRed;\n    fragColor = vec4(squares,1.0);\n}\n\n// Chaos, Opposition, Hallucinating\n#elif patternNo == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 3.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    uv -= squarePosition;\n    uv *= rotate2d(45.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));\n    uv += squarePosition;\n    \n    vec3 square1 = vec3(step(createShape(uv - squarePosition, 4.0), 0.9));\n    vec3 square2 = vec3(step(createShape(uv - squarePosition, 4.0), 0.8));\n    vec3 square3 = vec3(step(createShape(uv - squarePosition, 4.0), 0.7));\n    vec3 square4 = vec3(step(createShape(uv - squarePosition, 4.0), 0.6));\n    vec3 square5 = vec3(step(createShape(uv - squarePosition, 4.0), 0.5));\n    vec3 square6 = vec3(step(createShape(uv - squarePosition, 4.0), 0.4));\n    vec3 square7 = vec3(step(createShape(uv - squarePosition, 4.0), 0.3));\n    vec3 square8 = vec3(step(createShape(uv - squarePosition, 4.0), 0.2));\n    vec3 square9 = vec3(step(createShape(uv - squarePosition, 4.0), 0.1));\n    vec3 square10 = vec3(step(createShape(uv - squarePosition, 4.0), 0.05));\n    \n    vec3 squares1 = (square1 - square2);\n    vec3 squares2 = (square3 - square4);\n    vec3 squares3 = (square5 - square6);\n    vec3 squares4 = (square7 - square8);\n    vec3 squares5 = (square9 - square10);\n    \n    vec3 squares = squares1 + squares2 + squares3 + squares4 + squares5;\n\tfragColor = vec4(squares,1.0);\n}\n\n//Beauty, Elegant, Harmony\n#elif patternNo == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 3.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n   \tuv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 100.0), 0.5));\n    \n    vec3 square2 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n   \tuv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 2.0), 0.4));\n    \n    \tif (mod(tileIdx.x, 2.) == mod(tileIdx.y, 2.))\n    \t{\n        uv -= squarePosition;\n   \t \tuv *= rotate2d(-iTime * 8.0);\n   \t\tuv += squarePosition;\n    \tsquare2 = vec3(step(createShape(uv - squarePosition, 2.0), 0.4));\n   \t \t}\n    vec3 squares1 = square1 - square2;\n    squares1 *= colorRed;\n    fragColor = vec4(squares1,1.0);\n}\n\n//Simplicity, Beat, Elegant\n#elif patternNo == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 7.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(iTime * 4.0);\n    uv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 8.0), 0.5));\n    \n    \tif (mod(tileIdx.x, 2.) == mod(tileIdx.y, 2.))\n    \t{\n    \tuv -= squarePosition;\n    \tuv *= rotate2d(-iTime *8.0);\n        uv *= scale2d(vec2(sin(iTime * 6.0)));\n   \t \tuv += squarePosition;\n    \tsquare1 = vec3(step(createShape(uv - squarePosition, 8.0), 0.5));\n    \t}\n    \n\tvec3 square2= vec3(1.0);\n    uv -= squarePosition;\n   \tuv += squarePosition;\n    square2= vec3(step(createShape(uv - squarePosition, 8.0), 0.4));\n\n    \n    vec3 squares = square1 - square2;\n    squares *= colorRed;\n    fragColor = vec4(squares,1.0);\n}\n\n// Chaos, Diversity, Dark\n#elif patternNo == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv *= 5.0;\n    vec2 tileIdx = floor(uv);\n    uv = fract(uv);\n    \n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    vec3 square1 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(45.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));\n    uv += squarePosition;\n    square1 = vec3(step(createShape(uv - squarePosition, 4.0), 0.4));\n    \n    vec3 square2 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));\n    uv += squarePosition;\n    square2 = vec3(step(createShape(uv - squarePosition, 4.0), 0.35));\n    \n    vec3 square3 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));    \n    uv += squarePosition;\n    square3 = vec3(step(createShape(uv - squarePosition, 4.0), 0.3));\n    \n    vec3 square4 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));    \n    uv += squarePosition;\n    square4 = vec3(step(createShape(uv - squarePosition, 4.0), 0.26));\n    \n    vec3 square5 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));    \n    uv += squarePosition;\n    square5 = vec3(step(createShape(uv - squarePosition, 4.0), 0.22));\n    \n    vec3 square6 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));    \n    uv += squarePosition;\n    square6 = vec3(step(createShape(uv - squarePosition, 4.0), 0.2));\n    \n    vec3 square7 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));    \n    uv += squarePosition;\n    square7 = vec3(step(createShape(uv - squarePosition, 4.0), 0.17));\n    \n    vec3 square8 = vec3(1.0);\n    uv -= squarePosition;\n    uv *= rotate2d(80.0 * PI / 180.0);\n    uv *= scale2d(vec2(sin(iTime * 100.0)));    \n    uv += squarePosition;\n    square8 = vec3(step(createShape(uv - squarePosition, 4.0), 0.15));\n    \n    vec3 squares1 = square1 - square2;\n    vec3 squares2 = square3 - square4;\n    vec3 squares3 = square5 - square6;\n    vec3 squares4 = square7 - square8;\n    vec3 allsquares = squares1 + squares2 + squares3 + squares4;\n    allsquares *= colorRed;\n    fragColor = vec4(allsquares,1.0);\n    \n}\n\n#endif\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat createShape(vec2 centerPosition, float side)\n{  \n    float a = atan(centerPosition.y,centerPosition.x);\n    float r = TWOPI/side;\n    return cos(floor(.5+a/r)*r-a)*length(centerPosition.xy);\n}\n\nmat2 scale2d(vec2 size)\n{\n    return mat2(size.x, 0.0, 0.0, size.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13392, 13392, 13420, 13420, 13488], [13490, 13490, 13542, 13542, 13688], [13690, 13690, 13715, 13715, 13760]], "test": "valid"}
{"id": "Mslczn", "name": "Lonely Voxel", "author": "SudoNhim", "description": "Just reading through some of shane's code learning how to do surfaces. I'm going to integrate this into my voxel tracer :)", "tags": ["cube"], "likes": 6, "viewed": 227, "published": "Public", "date": "1486868185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel1, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel1, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat dfVoxel(vec3 p)\n{\n    vec3 cube = vec3(0.5, 0.5, 0.5);\n    return length(max(abs(p)-(cube - 0.1),0.0)) - 0.1;\n}\n\nvec3 nrmVoxel(vec3 p) \n{\n    p += 0.001 * normalize(p);\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy) - base,\n        dfVoxel(p+dd.yxy) - base,\n        dfVoxel(p+dd.yyx) - base\n    ));\n}\n\n// Stolen from shane's Voxel Corridor: https://www.shadertoy.com/view/MdVSDh# :)\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Stolen from shane's Voxel Corridor: https://www.shadertoy.com/view/MdVSDh# :)\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvec3 lightVoxel(vec3 p, vec3 rd)\n{\n    vec3 n = nrmVoxel(p);\n    vec3 color = tex3D(iChannel1, p, n) * vec3(1.0, 0.7, 0.7);\n    vec3 bumpedN = doBumpMap(iChannel1, p, n, 0.02);\n    vec3 ldir = normalize(vec3(1.0));\n    float diffuse = max(0.0, dot(bumpedN, ldir));\n    float specular = pow(max(0.0, dot(-rd, reflect(-ldir, bumpedN))), 16.0);\n    return color * (diffuse + 0.3) + specular*0.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float p = iMouse.x/iResolution.x*10.0;\n    vec3 ro = vec3(sin(iTime*0.5+p)*2.0, sin(iTime*0.3)+1.4, cos(iTime*0.5+p)*2.0);\n    ro = ro + ro*pow(iMouse.y/iResolution.y, 2.0)*10.0;\n    vec3 rd = normalize(-ro);\n    \n\tvec3 ax1 = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 ax2 = normalize(cross(rd, ax1));\n    \n    rd = normalize(rd*3.0 + ax1*uv.x + ax2*uv.y);\n    \n    // iq's cube intersection :)\n    vec3 cubeIntersect = (-ro -0.8*sign(rd))/rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    float incr = 0.0;\n    \n    for (int i=0; i<32; i++) {\n        incr = dfVoxel(ro + rd*dist)/2.0;\n        dist += incr;\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (incr < 0.05) {\n        fragColor.rgb = lightVoxel(dist*rd + ro, rd);\n    } else {\n     \tfragColor.rgb = sin(texture(iChannel0, vec2((uv.x+1.0)*0.5, 0.5)).r*vec3(9.3, 7.5, 5.9));   \n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dSGWG", "previewfilepath": "https://soundcloud.com/llama-lamp/ice-ice-polkka", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/llama-lamp/ice-ice-polkka", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mslczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 72, 72, 382], [384, 384, 407, 407, 501], [503, 503, 527, 527, 756], [758, 905, 955, 955, 1164], [1166, 1434, 1496, 1496, 2006], [2008, 2008, 2042, 2042, 2402], [2405, 2405, 2462, 2462, 3482]], "test": "error"}
{"id": "MslyRr", "name": "Dragon egg", "author": "nomadiclizard", "description": "Voronoi cells on a fibonacci sphere. Isotropic without any distortion at poles due to regular distribution of fib points and use of spherical distances. Colouring by summing functions of cell index gives lovely spirals :3", "tags": ["3d", "voronoi", "fibonacci"], "likes": 13, "viewed": 532, "published": "Public", "date": "1486852157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// voronoi cells on a fibonacci sphere\n// looks like a magical dragon egg rawr!\n\n#define pi 3.14159265359\n#define twoPi 6.28318530718\n#define halfPi 1.57079632679\n#define infinity 100.0\n#define phi 1.61803398875\n#define phiMinusOne 0.61803398875\n#define twoPiOnPhi 3.88322207745\n#define root5 2.2360679775\n#define logPhiPlusOne 0.96242365011\n\n// egg definition and colouring\nconst float maxn = 2500.0;\nconst float growtime = 5.0;\nconst bool convex = true;\nconst float f1 = 856.0, s1 = 3.0, a1 = 0.15;\nconst float f2 = 335.0, s2 = 2.0, a2 = 0.10;\n\n// SIMPLE STUFF THAT WOULD BE COOL IF WEBGL HAD IN A STANDARD LIBRARY :V\n\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec4 rotationQuat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float c = cos(0.5 * angle);\n    float s = sqrt(1.0 - c * c);\n    return vec4(axis.x * s, axis.y * s, axis.z * s, c);\n}\n\nvec3 rotate(vec3 p, vec4 q)\n{\n\treturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    return rotate(p, rotationQuat(axis, angle));\n}\n\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\nmat4 scaleMatrix(float s)\n{\n    return mat4(s,   0.0, 0.0, 0.0,\n                0.0, s,   0.0, 0.0,\n                0.0, 0.0, s,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// INVERSE SPHERICAL FIBONACCI MAPPING\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping.pdf\n\n// k'th fibonacci number\nfloat calcfk(float k)\n{\n\treturn round(pow(phi, k) / root5);\n}\n\n// calculates a basis vector for fibonacci sphere n\nvec2 calcbk(float fk, float n)\n{\n    return vec2(twoPi * fract((fk + 1.0) * phiMinusOne) - twoPiOnPhi,\n                -2.0 * fk / n);\n}\n\n// calc point i of n in spherical coordinates\nvec2 calcpoint(float i, float n)\n{\n    return vec2(twoPi * fract(i * phiMinusOne),\n                1.0 - (2.0 * i + 1.0) / n);\n}\n\n// converts [phi,cos theta] into [x,y,z] for unit sphere\nvec3 s2c(vec2 s)\n{\n    float sinTheta = sqrt(1.0 - s.y * s.y);\n    return vec3(cos(s.x) * sinTheta,\n                sin(s.x) * sinTheta,\n                s.y);\n}\n\n// converts [x,y,z] into [phi, cos theta] for unit sphere\nvec2 c2s(vec3 c)\n{\n    return vec2(atan(c.y, c.x),\n                c.z);\n}\n\n// angle between two points in spherical coords\nfloat angdist(vec2 sp1, vec2 sp2)\n{\n    float sinTheta1 = sqrt(1.0 - sp1.y * sp1.y);\n    float sinTheta2 = sqrt(1.0 - sp2.y * sp2.y);\n    return acos(sp1.y * sp2.y + sinTheta1 * sinTheta2 * cos(sp2.x - sp1.x));\n}\n\n// calculate new point [phi, cos theta] if walking point sp on bearing ib distance d\nvec2 gcircle(vec2 sp, float ib, float d)\n{\n    float cosd = cos(d);\n    float sind = sin(d);\n    float sinTheta1 = -sp.y;\n    float cosTheta1 = sqrt(1.0 - sp.y * sp.y);\n    float sinTheta2 = sinTheta1 * cosd + cosTheta1 * sind * cos(ib);\n    float theta2 = asin(sinTheta2);\n    float phi2 = sp.x + atan(sin(ib) * sind * cosTheta1, cosd - sinTheta1 * sinTheta2);\n    return vec2(mod(phi2, twoPi), cos(theta2 + halfPi));\n}\n\n// 0..1 for seed x\nfloat random(float x)\n{\n    return fract(abs(sin(x * 12.9898) * 43758.5453));\n}\n\n// distance to nearest cell on a fibonacci sphere\nfloat fibspheren(vec3 p, float n, out float minidx, out vec3 sn)\n{\n    // get spherical coords for point p on surface of unit sphere\n    vec2 sp = c2s(p);\n    float avdist = sqrt(4.0 * pi / n);\n    \n    // calc the dominant zone number\n    float k = max(2.0, floor(log(root5 * n * pi * (1.0 - sp.y * sp.y)) / logPhiPlusOne));   \n    \n    // calc basis vectors for this zone\n    // [could all be precalculated and looked up for k,n]\n    vec2 f = vec2(calcfk(k), calcfk(k + 1.0));\n    vec2 bk = calcbk(f[0], n);\n    vec2 bk1 = calcbk(f[1], n);\n    mat2 b = mat2(bk, bk1);\n    mat2 invb = inverse(b);\n    \n    // change of basis for point sp to local grid uv\n    float z0 = 1.0 - 1.0 / n;\n    vec2 c = floor(invb * (sp - vec2(0.0, z0)));\n    \n    // for k<=4 paper suggests using (-1,0,+1)^2 offset factors but we'll\n    // stick with (0,1)^2 and live with the occasional glitches\n    float mindist = pi;\n    vec2 minisp;\n    for (int s = 0; s < 4; s++) {\n        // figure out the point index and generate fib point\n        vec2 o = vec2(s - (s/2) * 2, s / 2);\n        float idx = dot(f, c + o);\n        if (idx > n) continue;        \n        vec2 isp = calcpoint(idx, n);\n        \n        // walk on a random bearing a random distance to make cells move a bit\n        //float b = mod((-0.05 + 0.1 * random(idx + 42.39)) * iTime, twoPi);\n        //float d = dist * random(idx + 28.93) * cos((-0.5 + 1.0 * random(idx + 42.39)) * iTime);\n        //isp = gcircle(isp, b, d);\n        \n        // closest?\n        float dist = angdist(isp, sp);\n        if (dist < mindist) {\n\t\t\tmindist = dist;\n            minidx = idx;\n            minisp = isp;\n        }\n    }\n    \n    // use nearest point to calculate surface normal via rotation around cotangent from p -> ip\n    // ohhhh wow I can make keeled scales real easy if dist varies by direction!\n    vec3 ip = s2c(minisp), cotan;\n    if (convex) {\n        cotan = cross(ip - p, p);\n    } else {\n        cotan = cross(p - ip, p);\n    }\n    sn = rotate(p, cotan, mindist / avdist);\n    return mindist;\n}\n\n// view stuff\nconst float fov = radians(50.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\n// calculates intersection parameters for a ray through a sphere at sp radius r\n// return true if the halfray ro + t1.rd is hitting\nbool spherehit(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    vec3 rosp = ro - sp;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, rosp);\n    float c = dot(rosp, rosp) - (r * r);\n    float b2m4ac = b * b - 4.0 * a * c;\n    if (b2m4ac >= 0.0) {\n        float r = sqrt(b2m4ac);\n        t1 = (-b - r) / (2.0 * a);\n        t2 = (-b + r) / (2.0 * a);\n        return t1 >= 0.0 || t2 >= 0.0;\n    } else {\n        return false;\n    }\n}\n\n// black -> white via red and yellow for 0,1\nvec4 falsecolourr(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\n// black -> white via green and cyan for 0,1\nvec4 falsecolourg(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // number of points in fibsphere\n    float n = pow(2.0, log(maxn) / log(2.0) * smoothstep(0.0,1.0,iTime / growtime)); \n    \n    // fibsphere location and size\n    vec3 sp = vec3(0.0, 0.0, -2.0);\n    float sr = pow((n / maxn), 0.333) * (1.0 + 0.01 * cos(iTime));\n    \n    // mouse rotates it\n    float r1 = (iMouse.x / iResolution.x - 0.5) * twoPi;\n    float r2 = (iMouse.y / iResolution.y - 0.5) * twoPi;\n    r1 += iTime * 0.25;\n    \n    // transform and inverse matrices\n    mat4 ms = scaleMatrix(1.0 / sr) *\n              translationMatrix(-sp);\n    mat4 mr = rotationMatrix(forward, -r1) *\n              rotationMatrix(right, -r2);\n    mat4 mmr = rotationMatrix(right, r2) *\n        \t   rotationMatrix(forward, r1);\n    \n    // check if an intersection is possible (in world space)\n    float t1, t2;\n    if (spherehit(sp, sr, ro, rd, t1, t2)) {\n        vec4 wp = vec4(ro + t1 * rd, 1.0);\n    \t// calculate hit of fibsphere (back in model space)\n        vec3 mp = vec3(mr * ms * wp), msn;\n        float idx, ir = fibspheren(mp, n, idx, msn);\n        \n        // surface normal back in world coords\n        vec3 sn = vec3(mmr * vec4(msn, 1.0));\n        \n        // colour it all pretty - similar to adding octaves of noise\n        // overlaying lots of waves gives it a cool mesmerising effect\n        float vrange = 0.5 + a1 * cos(f1 * (idx / maxn) + s1 * iTime) +\n            \t\t\ta2 * cos(f2 * (idx / maxn) + s2 * iTime);\n        vec4 c = falsecolourg(vrange, 1.3);\n        \n        // light it up like a bossss\n        float light = 0.9 * pow(dot(-forward, sn), 2.0);\n        fragColor = c * light;\n    } else {\n        fragColor = 0.3 + 0.3 * vec4(fragCoord.y / iResolution.y);\n    }\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // the VR version does it for us\n    render(fragColor, fragCoord, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // figure out where to look\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    render(fragColor, fragCoord, ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 621, 652, 652, 685], [687, 687, 732, 732, 1355], [1357, 1357, 1400, 1400, 1551], [1553, 1553, 1582, 1582, 1643], [1645, 1645, 1690, 1690, 1741], [1743, 1743, 1775, 1775, 1922], [1924, 1924, 1951, 1951, 2098], [2218, 2243, 2266, 2266, 2304], [2306, 2358, 2390, 2390, 2494], [2496, 2542, 2576, 2576, 2670], [2672, 2729, 2747, 2747, 2889], [2891, 2949, 2967, 2967, 3023], [3025, 3073, 3108, 3108, 3285], [3287, 3372, 3414, 3414, 3792], [3794, 3813, 3836, 3836, 3892], [3894, 3944, 4010, 4076, 5986], [6156, 6288, 6368, 6368, 6745], [6747, 6792, 6835, 6835, 7076], [7078, 7123, 7166, 7166, 7407], [7409, 7409, 7485, 7522, 9179], [9181, 9181, 9257, 9294, 9338], [9340, 9340, 9395, 9431, 9651]], "test": "error"}
{"id": "MslyzH", "name": "HSV To RGB with cosine palettes", "author": "mmerchante", "description": "HSV to RGB approximation with iq's color palettes. It is not perfect, because the original HSV mapping uses linear functions. I'll work on the inverse mapping when I have more time!", "tags": ["rgb", "hsv", "mapping"], "likes": 4, "viewed": 201, "published": "Public", "date": "1487120728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Classic approach\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, .6666, .3333, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 d )\n{\n    return a + b * cos(6.28318 * (t + d));\n}\n\n// Color palette approach\nvec3 hsv2rgb_p(vec3 c) \n{\n    float h = c.x;\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    \n    // Can remove some parameters, but I'll leave them as reference\t\n    return palette(h, vec3(s_n), vec3(s), vec3(1.0, 0.667, .3334));\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float s = step(uv.y, .5);\n    vec3 c = vec3(uv.x, 0.5+0.5*sin(iTime * .5),  .5 + .5 * cos(iTime * .5));\n    \n    vec3 hsv = mix(hsv2rgb(c), hsv2rgb_p(c), s);\n\tfragColor = vec4(hsv,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 42, 42, 197], [199, 199, 260, 260, 305], [307, 333, 358, 358, 576], [579, 579, 636, 636, 875]], "test": "valid"}
{"id": "MslyzN", "name": "Isart 3D Light", "author": "ccappann", "description": "First time make a little light on a special ball.", "tags": ["3d", "light"], "likes": 0, "viewed": 85, "published": "Public", "date": "1487328145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 pixCoords )\n{\n    \n    float radius = 300.0;\n    \n    pixCoords.y -= iResolution.y / 2.0;\n    //pixCoords.x -= cos(iTime)*iResolution.x;\n    pixCoords.x -= iResolution.x / 2.0;\n    \n    float angle = iTime *2.0;\n    float angle2 = 90.0;\n    float newX = (pixCoords.x*cos(angle2)) + (pixCoords.y*sin(angle2));\n    float newY = (- pixCoords.x * sin(angle2)) + (pixCoords.y * cos(angle2));\n    float alpha = atan(newY,newX);\n    float rayon = 0.5*iResolution.y -100.0 + 10.0 * cos(20.0 * alpha) * sin(100.0);\n    float distance = sqrt(pow(newX,2.0) + pow(newY, 2.0));\n    \n    \n    vec3 height = vec3(newX, newY, sqrt(pow(rayon,2.0) - pow(newX,2.0) - pow(newY,2.0))) / rayon;\n    vec3 light = vec3(cos(iTime), cos(iTime), sin(iTime));\n    \n   \t\n\n    \n    float sunDistance = sqrt(pow(light.x - newX,2.0) + pow(light.y - newY,2.0));\n    \n   \tfloat lum = (height.x * light.x) + (height.y * light.y) + (height.z * light.z);\n    \n    \n    if ( distance < rayon)\n    {\n        color = vec4(0.0, 0.0, 1.0, 1.0) * max(lum,0.1);\n    }\n    else\n    {\n        color = vec4(0.0 , 0.0 , 0.0 , 1.0);\n    }\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 1145]], "test": "valid"}
{"id": "MsscR7", "name": "aaa it's a tube", "author": "floopfloop", "description": "tube and bloob", "tags": ["implicitsurface"], "likes": 0, "viewed": 66, "published": "Public", "date": "1487567500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*float metaball(vec2 position, vec2 parent_position, float radius) {\n \treturn smoothstep(0.0, radius, length(parent_position - position));\n}*/\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.1 * abs(cos(iTime));\n    \n\t//vec2 uv_position = (fragCoord.xy / iResolution.y); // non stretched uv space\n    //vec2 uv_position = (iResolution.xy - fragCoord.xy) / iResolution.y; // top-right instead of bottom left\n    vec2 uv_position = (iResolution.xy - 2.0*fragCoord.xy) / iResolution.y; // push it to center\n\t\n    vec2 position_1 = sin(iTime + vec2(0.25, 0.25));\n    vec2 position_2 = ((iResolution.xy - 2.0*iMouse.xy) / iResolution.y); // why negative why\n    vec2 position_3 = cos(iTime + vec2(0.25, 0.25));\n    \n    float potential = 0.0;\n    potential += 1.0 - sdCapsule(uv_position, position_1, position_2, radius);\n    \n    potential += 1.0 - smoothstep(0.0, 0.4, length(uv_position + position_3)); // remove 1.0 for COOLNESS\n   //potential += 1.0 - smoothstep(0.0, radius, length(screen_origin + position_2));\n\t//potential += 1.0 - smoothstep(0.0, radius, length(position_2));\n    //potential += 1.0 - smoothstep(0.0, radius, length(screen_origin + (position_1 + position_2)));\n    //potential += 1.0 - smoothstep(0.0, radius, length(screen_origin + (position_1 - position_2)));\n\n    \n\tvec3 color = vec3(potential);\n    \n    fragColor = vec4(smoothstep(0.99, 1.0, color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsscR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 145, 197, 197, 324], [326, 326, 383, 383, 1596]], "test": "valid"}
{"id": "MsscRn", "name": "Moo Cow", "author": "vox", "description": "\"Cast aside your fear to live; only then can I show you the darkness in all it's blinding beauty...\"\n-Karkov the Slayer (>100 K.D.R.)\n", "tags": ["moo", "cow"], "likes": 1, "viewed": 356, "published": "Public API", "date": "1486771220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((.125-.25*saw(float(__LINE__)*PI*GR*E)/PI/GR/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define circle(x) (vec2(cos((x)*2.0*PI),sin(2.0*PI*(x))))\n\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float gradient = uv.y;\n    \n        float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    float rotation = -time*PI*GR*E;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations =  4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float map = 0.0;\n    float border = 1.0;\n    vec4 final = vec4(0.0);\n    float c1 = 0.0;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n    \n        float d = -cos(float(i)*PI);\n        \n        vec2 o = circle(time*d)*(1.0-iteration)/2.0;\n        \n        \n        float c = smoothstep(0.0, 1.0/E/E, 1.0-length(uv));\n        if(i == 0) c1 = c;\n        \n        \n        \n        vec2 uv2 = (uv+o)*(E+iteration);\n        float c2 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv2)*2.0/PI)*c;\n        vec2 uv3 = (uv-o)*(E+iteration);\n        float c3 = smoothstep(1.0/E, 1.0/GR, 1.0-length(uv3)*2.0/PI)*c;\n        \n    \tuv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), d*rotation*2.0-PI/8.0).xy;\n        uv = ((uv)*(1.0-c2)*(1.0-c3)+\n            (uv2)*(c2)*(1.0-c3)+\n            (uv3)*(1.0-c2)*(c3))*(antispeckle)+uv*(1.0-antispeckle)*c;\n        \n        \n        border *= saw(1.0+c2*2.0)*saw(1.0+c3*2.0);\n\n        float b = pow(border, iteration);\n        \n        float a = atan(uv.y, uv.x)/PI*.5+.5;\n        float l = d*length(uv)*.5;\n        \n        map += smoothstep( 0.0, border*GR, GR*saw(c+c2+c3)*saw(border*saw(saw(2.0*(a+l))*saw(b*(d-c2)*(d-c3))*antispeckle)*(iteration+1.0)));\n        \n        antispeckle *= (clamp((c2+c3), 0.0, 1.0))*(1.0-saw(c2*2.0-c3)*saw(c3*2.0-c2));\n        final += vec4(flux(map*PI+time*GR*E), 1.0);\n    }\n   \n    \n    fragColor = vec4(uv, 0.0, 1.0);\n     \n    float w = smoothstep(.8, 1.0, saw(map));\n    \n    map = smoothstep(0.0, 1.0, map);\n    fragColor = ((w+final*(1.0-w)))*map*c1+(1.0-c1)*gradient;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsscRn.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[152, 734, 754, 754, 859], [860, 860, 878, 878, 917], [919, 919, 937, 937, 986], [988, 988, 1006, 1006, 1065], [1068, 1134, 1191, 1191, 3288]], "test": "valid"}
{"id": "Msscz7", "name": "Fusioned Bismuth", "author": "gam0022", "description": "TokyoDemoFest 2017 GLSL Graphics Compo 3rd place\nhttp://gam0022.net/webgl/#raymarching_tdf2017", "tags": ["3d", "raymarching", "fractal"], "likes": 14, "viewed": 463, "published": "Public", "date": "1487606923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: Fusioned Bismuth (TokyoDemoFest 2017 GLSL Graphics Compo 3rd place)\n// Copyright (c) 2017 gam0022\n// License: Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n//\n// Thanks\n// - DE used folding by gaz (https://www.shadertoy.com/view/Mlf3Wj)\n// - Just snow by baldand (https://www.shadertoy.com/view/ldsGDn)\n// - Sky and Ground by morgan3d (https://www.shadertoy.com/view/4sKGWt)\n\nprecision highp float;\n\n#define DEBUG 0\n#define SHADER_TOY 1\n\n// uniforms\n#if SHADER_TOY == 0\nuniform float iTime;\nuniform vec2 iMouse;\nuniform vec2 iResolution.xy;\n#endif\n\n// debug for camera\n#if DEBUG\nuniform bool debugCamera;\nuniform vec3 cameraPos;\nuniform vec3 cameraDir;\n#endif\n\n// consts\nconst float INF = 1e+10;\nconst float EPS = 1e-2;\nconst float EPS_N = 1e-3;\nconst float OFFSET = EPS * 100.0;\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float PIH = 1.57079632679;\nconst float PIQ = 0.78539816339;\n\n\n// globals\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\nfloat lTime;\n\n// ray\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\n// camera\nstruct Camera {\n\tvec3 eye, target;\n\tvec3 forward, right, up;\n\tfloat zoom;\n};\n\nRay cameraShootRay(Camera c, vec2 uv) {\n    c.forward = normalize(c.target - c.eye);\n    c.right = normalize(cross(c.forward, c.up));\n    c.up    = normalize(cross(c.right, c.forward));\n\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(uv.x * c.right + uv.y * c.up + c.zoom * c.forward);\n\n    return r;\n}\n\n// intersection\nstruct Intersection {\n\tbool hit;\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n\tvec2 uv;\n\tfloat count;\n\n\t//int material;\n\tvec3 color;\n\tfloat metalness;\n};\n\n//#define METAL_MATERIAL   0\n//#define MIRROR_MATERIAL  1\n\n\n// util\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// https://www.shadertoy.com/view/4sKGWt\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\n\tp.xy += 0.1 * lTime;\n\n\tfloat f = 0.5000 * noise(p); p = m2 * p * 2.02;\n\tf += 0.2500 * noise(p); p = m2 * p * 2.03;\n\tf += 0.1250 * noise(p); p = m2 * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f / 0.9375;\n}\n\nfloat easeInCubic( float t ) {\n\treturn t * t * t;\n}\n\nfloat easeInOutCubic(float t) {\n\treturn t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n}\n\nfloat gauss(float x) {\n\tfloat a = 50.0;\n\treturn exp(-x * x / a);\n}\n\n\n// Distance Functions\n\n// operations\n//vec3 opRep( vec3 p, float interval ) {\n//\treturn mod( p, interval ) - 0.5 * interval;\n//}\n#define opRep(p, interval) (mod(p, interval) - 0.5 * interval)\n\n//vec2 opRepLimit(vec2 p, float interval, float limit) {\n//\treturn mod(clamp(p, -limit, limit), interval) - 0.5 * interval;\n//}\n#define opRepLimit(p, interval, limit) (mod(clamp(p, -limit, limit), interval) - 0.5 * interval)\n\n// https://www.shadertoy.com/view/Mlf3Wj\nmat2 rotate(in float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 fold(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\nfloat smin(float d1, float d2, float k) {\n\tfloat h = exp(-k * d1) + exp(-k * d2);\n\treturn -log(h) / k;\n}\n\n// Distance Functions\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat dBar( vec2 p, float interval, float width) {\n\treturn length( max( abs( opRep( p, interval ) ) - width, 0.0 ) );\n}\n\n\n#define META_SCENE_END_TIME (32.0)\n#define UFO_SCENE_END_TIME (117.0)\n#define SNOW_SCENE_END_TIME (182.0)\n\nfloat dFract(inout vec3 p) {\n\tfloat radius = 1.0;\n\tfloat radiusScale = 0.45 * abs(sin(0.3 * lTime));\n\tfloat d = sdBox(p, vec3(radius));\n\tfor (int i = 0; i < 5; i++) {\n\t\tvec3 q = abs(p) + normalize(vec3(-1.0)) * radius * (1.0 + radiusScale);\n\t\td = min(d, sdBox(p, vec3(radius)));\n\t\tp = q;\n\t\tradius *= radiusScale;\n\t}\n\treturn d;\n}\n\nfloat dTree(vec3 p) {\n\tfloat scale = 0.6 * saturate(1.5 * sin(0.05 * (lTime - UFO_SCENE_END_TIME - 2.0)));\n\tfloat width = mix(0.3 * scale, 0.0, saturate(p.y));\n\tvec3 size = vec3(width, 1.0, width);\n\tfloat d = sdBox(p, size);\n\tfor (int i = 0; i < 10; i++) {\n\t\tvec3 q = p;\n\t\tq.x = abs(q.x);\n\t\tq.y -= 0.5 * size.y;\n\t\tq.xy *= rotate(-1.2);\n\t\td = min(d, sdBox(p, size));\n\t\tp = q;\n\t\tsize *= scale;\n\t}\n\treturn d;\n}\n\nfloat dSnowCrystal(inout vec3 p) {\n\tp.xy = fold(p.xy, 6.0);\n\treturn dTree(p);\n}\n\nfloat dMix(inout vec3 p) {\n\tfloat sphere = dSphere(p, 1.5);\n\tfloat box = sdBox(p, vec3(1.1));\n\tfloat d = mix(sphere, box, 0.5 + clamp(sin(PIQ * lTime), -0.5, 0.5));\n\treturn d;\n}\n\nfloat dMeta(inout vec3 p) {\n\t// copy from cameraControl\n\tvec3 target = vec3(0.0);\n\tfloat t1 = lTime - META_SCENE_END_TIME;\n\ttarget.y = clamp(-0.7 * t1, -2.8, 100.0);\n\n\tfloat a = max(0.0, 2.0 - lTime * 0.1) + cos(lTime * 0.3);\n\tfloat b = 0.2 * sin(lTime);\n\tfloat d1 = dSphere(p - target - vec3(a, 0, b), 1.0);\n\tfloat d2 = dSphere(p - target + vec3(a, 0, b), 1.0);\n\tfloat d = smin(d1, d2, 1.0);\n\treturn d;\n}\n\nfloat hWave(vec2 p, float t) {\n\tfloat h = 1.0;\n\tfloat a = 1.0;\n\tfloat b = 6.0;\n\n\tfor(float i = 0.0; i < 3.0; i++) {\n\t\tfloat f = pow(2.0, i);\n\t\th += 1.0 / f * (sin(f * a * p.x + b * t) + sin(f * a * p.y + b * t));\n\t}\n\n\treturn h;\n}\n\nfloat dWing(in vec3 p) {\n\tfloat t = lTime - META_SCENE_END_TIME;\n\tfloat l = length(p.xz);\n\tfloat fusion = gauss((lTime - META_SCENE_END_TIME - 5.0) * 2.0);\n\n\tfloat a = 0.1 + 0.06 * (1.0 + sin(PI * t + l));\n\tfloat b = min(0.2 * t, 10.0) * gauss(l) + 0.1 * fusion * hWave(p.xz, t);\n\tp.y += -b + 15.0;\n\n\tvec3 p1 = p;\n\tp1.xz = opRepLimit(p.xz, 1.0, 20.0);\n\n\tvec3 p2 = p;\n\tp2 = opRep(p, 0.5);\n\n\tfloat d =   sdBox(p1, vec3(0.2 + a * 3.0, 12.0 - a,       0.2 + a));\n\td = min(d,  sdBox(p1, vec3(0.4 - a,       13.0 - 4.0 * a, 0.1 + a)));\n\td = max(d, -sdBox(p1, vec3(0.3 - a,       14.0 - 4.0 * a, a)));\n\td = max(d, -sdBox(p2, vec3(0.8 * a, 1.0 - a, 0.8 * a)));\n\treturn d;\n}\n\nfloat dUfo(inout vec3 p) {\n\tfloat t = max((lTime - META_SCENE_END_TIME - 10.0) * 0.5, 1.0);\n\tfloat t1 = floor(t);\n\tfloat t2 = t1 + easeInOutCubic(t - t1);\n\n\tp.xz = fold(p.xz, min(t2, 10.0));\n\tp.z -= 0.5;\n\n\tfloat d = dWing(p);\n\t//float t3 = lTime - META_SCENE_END_TIME;\n\t//if (t3 < 10.0) {\n\t//\td -= mix(0.08, 0.0, saturate(t3 * 0.1)) * fbm(10.0 * p.xz + 5.0 * p.y);\n\t//}\n\treturn d;\n}\n\nfloat dScene(vec3 p) {\n\tif (lTime < UFO_SCENE_END_TIME - 2.0) {\n\t\tfloat d = dMeta(p);\n\t\td = smin(d, dUfo(p), clamp(lTime - META_SCENE_END_TIME, 1.0, 15.0));\n\t\treturn d;\n\t} else {\n\t\t//return dFract(p);\n\t\treturn dSnowCrystal(p);\n\t}\n}\n\nfloat dSceneBump(vec3 p) {\n\tfloat d = dScene(p);\n\n\tfloat t3 = lTime - META_SCENE_END_TIME;\n\tif (t3 < 10.0) {\n\t\td -= mix(0.08, 0.0, saturate(t3 * 0.1)) * fbm(10.0 * p.xz + 5.0 * p.y);\n\t}\n\n\treturn d;\n}\n\n\n// color functions\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\n//vec3 calcNormal( vec3 p ) {\n//\tvec2 e = vec2( 1.0, -1.0 ) * 0.001;\n//\treturn normalize(\n//\t\te.xyy * dScene( p + e.xyy ) + e.yyx * dScene( p + e.yyx ) +\n//\t\t\te.yxy * dScene( p + e.yxy ) + e.xxx * dScene( p + e.xxx ) );\n//}\n\n#define calcNormal(p, dFunc) normalize(vec2(EPS_N, -EPS_N).xyy * dFunc(p + vec2(EPS_N, -EPS_N).xyy) + vec2(EPS_N, -EPS_N).yyx * dFunc(p + vec2(EPS_N, -EPS_N).yyx ) + vec2(EPS_N, -EPS_N).yxy * dFunc(p + vec2(EPS_N, -EPS_N).yxy) + vec2(EPS_N, -EPS_N).xxx * dFunc(p + vec2(EPS_N, -EPS_N).xxx))\n\nfloat calcRate(float a, float b) {\n\treturn a / (a + b);\n}\n\nvoid setMaterialAndUv(inout Intersection intersection, vec3 p) {\n\t//intersection.material = METAL_MATERIAL;\n\n\tfloat d1 = dUfo(p);\n\tfloat d2 = dMeta(p);\n\tfloat rate = calcRate(abs(d1), abs(d2));\n\tintersection.metalness = rate;\n\n\tfloat t = lTime - META_SCENE_END_TIME;\n\tintersection.metalness = mix(intersection.metalness, 1.0, saturate(t * 0.05));\n\tintersection.metalness = mix(intersection.metalness, 2.0, gauss((t - 13.0) * 3.0));\n\n\t//if ( false && lTime <= META_SCENE_END_TIME ) {\n\t//\tintersection.material = MIRROR_MATERIAL;\n\t//} else {\n\t//\tdUfo(p);\n\t//\tintersection.material = METAL_MATERIAL;\n\t//\tintersection.uv = p.xz;\n\t//}\n}\n\nvoid intersectScene(inout Intersection intersection, inout Ray ray ) {\n\tfloat d;\n\tintersection.distance = 0.0;\n\tvec3 p = ray.origin;\n\n\tfor (float i = 0.0; i < 128.0; i++) {\n\t\td = dScene(p);\n\t\tintersection.distance += d;\n\t\tp = ray.origin + intersection.distance * ray.direction;\n\t\tintersection.count = i;\n\t\tif (abs(d) < EPS || intersection.distance > 100.0) break;\n\t}\n\n\tif (abs(d) < EPS) {\n\t\tintersection.hit = true;\n\t\tintersection.position = p;\n\t\tintersection.normal = calcNormal(p, dScene);\n\t\tsetMaterialAndUv(intersection, p);\n\t}\n}\n\nfloat calcAo(in vec3 p, in vec3 n){\n\tfloat sca = 1.0, occ = 0.0;\n\tfor(float i=0.; i<5.; i++){\n\t\tfloat hr = 0.05 + i * 0.08;\n\t\tfloat dd = dScene(n * hr + p);\n\t\tocc += (hr - dd) * sca;\n\t\tsca *= 0.5;\n\t}\n\treturn saturate(1.0 - occ);\n}\n\nfloat calcShadow(in vec3 p, in vec3 rd) {\n\tfloat d;\n\tfloat distance = OFFSET;\n\tfloat bright = 1.0;\n\tfloat shadowIntensity = 0.5;\n\tfloat shadowSharpness = 16.0;\n\n\tfor (int i = 0; i < 30; i++) {\n\t\td = dScene(p + rd * distance);\n\t\tif (d < EPS) return shadowIntensity;\n\t\tbright = min(bright, shadowSharpness * d / distance);\n\t\tdistance += d;\n\t}\n\n\treturn shadowIntensity + (1.0 - shadowIntensity) * bright;\n}\n\n\n// Just snow by baldand \n// https://www.shadertoy.com/view/ldsGDn\n#define LAYERS 50\n#define DEPTH .5\n#define WIDTH .3\n#define SPEED .6\n\nfloat screenSpaceSnow(vec2 uv) {\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tfloat acc = 0.0;\n\tfloat dof = 5.*sin(lTime*.1);\n\tfor (int i=0;i<LAYERS;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uv*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*lTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\ts += .01*abs(2.*fract(10.*q.yx)-1.);\n\t\tfloat d = .6*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .005+.05*min(.5*abs(fi-5.-dof),1.);\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/(1.+.02*fi*DEPTH));\n\t}\n\treturn acc;\n}\n\nvoid calcRadiance(inout Intersection intersection, inout Ray ray, int bounce) {\n\tintersection.hit = false;\n\tintersectScene(intersection, ray);\n\n\tif ( intersection.hit ) {\n\t\tfloat diffuse = clamp(dot(lightDir, intersection.normal), 0.2, 1.0) * 0.5 + 0.5;\n\t\tfloat specular = pow(saturate(dot(reflect(lightDir, intersection.normal), ray.direction)), 10.0);\n\t\tfloat ao = calcAo(intersection.position, intersection.normal);\n\t\tfloat shadow = calcShadow(intersection.position, lightDir);\n\n\t\tvec3 fleshNormal = calcNormal(intersection.position, dSceneBump);\n\t\tfloat fleshDiffuse = clamp(dot(lightDir, fleshNormal), 0.2, 1.0) * 0.5 + 0.5;\n\t\tvec3 fleshBase =  mix(vec3(1.0, 0.2, 0.2), vec3(0.3, 0.0, 0.0), fbm(2.0 * intersection.position.xz));\n\t\tvec3 flesh = fleshBase * fleshDiffuse * ao * shadow + 0.1 * specular;\n\n\t\tfloat v = (META_SCENE_END_TIME <= lTime && lTime <= UFO_SCENE_END_TIME) ? 0.8 : 0.5;\n\t\tvec3 metalBase = hsv2rgb(vec3(0.1 * intersection.count, 0.3 * sin(lTime), v));\n\t\tvec3 metal = metalBase * diffuse * ao * shadow + 0.1 * specular;\n\n\t\tintersection.color = mix(flesh, metal, intersection.metalness);\n\t\tintersection.normal = mix(fleshNormal, intersection.normal, intersection.metalness);\n\n\t\t// fog\n\t\tintersection.color = mix(intersection.color, 0.8 * vec3(0.7, 0.75, 0.8), min(1.0, pow(0.02 * intersection.distance, 2.0)));\n\t} else {\n\t\tvec3 sunnySky = vec3(0.4, 0.55, 0.8);\n\t\tvec3 cloudySky = vec3(0.7);\n\t\tvec3 cloud = vec3(1.0, 0.95, 1.0);\n\t\tvec3 base = mix(sunnySky, cloudySky, step(UFO_SCENE_END_TIME - 20.0, lTime)) * (1.0 - 0.8 * ray.direction.y) * 0.9;\n\n\t\t// Sun\n\t\tfloat sundot = saturate(dot(ray.direction, lightDir));\n\t\tbase += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 8.0);\n\t\tbase += 0.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 64.0);\n\n\t\t// Clouds\n\t\tfloat rd = ray.direction.y + 0.3;\n\t\tintersection.color = mix(base, cloud, 0.5 *\n\t\t\tsmoothstep(0.5, 0.8, fbm((ray.origin.xz + ray.direction.xz * (250000.0 - ray.origin.y) / rd) * 0.000008)));\n\n\t\tintersection.color = mix(intersection.color, vec3(0.7, 0.75, 0.8), pow(1.0 - max(rd, 0.0), 4.0));\n\t}\n\n\t// Whiteout\n\t//intersection.color = mix(intersection.color, vec3(1.0), gauss((lTime - UFO_SCENE_END_TIME) * 1.0));\n\tintersection.color = mix(intersection.color, vec3(1.0), gauss((lTime - SNOW_SCENE_END_TIME) * 0.5));\n}\n\nvoid cameraControl(inout Camera camera) {\n\t// iTime\n\tfloat t1 = lTime - META_SCENE_END_TIME;\n\tfloat t2 = t1 - 25.0;\n\tfloat t3 = t2 - 16.0;\n\tfloat t4 = t3 - 20.0;\n\n\tfloat t5 = lTime - UFO_SCENE_END_TIME;\n\tfloat t6 = t5 - 7.0;\n\tfloat t7 = t6 - 10.0;\n\n\t// blend\n\n\t// ufo\n\tfloat b1 = easeInOutCubic(saturate(t1 * 0.2));\n\tfloat b2 = easeInOutCubic(saturate(t2 * 0.4));\n\tfloat b3 = easeInOutCubic(saturate(t3 * 0.4));\n\tfloat b4 = easeInOutCubic(saturate(t4 * 0.2));\n\n\t// snow\n\tfloat b5 = easeInOutCubic(saturate(t5 * 0.2));\n\tfloat b6 = easeInOutCubic(saturate(t6 * 0.5));\n\tfloat b7 = easeInOutCubic(saturate(t7));\n\n\t// camera target\n\tcamera.target = vec3(0.0);\n\n\tcamera.target.y = clamp(-0.7 * t1, -2.8, 100.0);\n\tcamera.target.y = mix(camera.target.y, 1.0 + t2 * 0.3, b2);\n\tcamera.target.y = mix(camera.target.y, 0.0, b3);\n\tcamera.target.y = mix(camera.target.y, 0.0 + 0.6 * t4, b4);\n\n\tcamera.target.y = mix(camera.target.y, 0.0, b5);\n\tcamera.target.x = mix(camera.target.x, -0.7, b6);\n\tcamera.target.x = mix(camera.target.x, 0.0, b7);\n\n\t// camera position\n\tvec3 p0 = camera.target + vec3(0.0, 0.0, -5.0); // down\n\tvec3 p1 = vec3(1.0, 0.3 * abs(t1 - 0.5), 1.0);  // look down\n\tvec3 p2 = vec3(2.5 + t2 * 0.9, 0.5 + t2 * 0.1, 0.0); // side\n\tvec3 p3 = vec3(0.01, 4.0 + t3 * 0.2, 0.0); // zoom\n\tvec3 p4 = vec3(1.5, 10.0 + t4 * 0.1, 2.0); // leave\n\n\tvec3 p5 = vec3(0.0, 0.1, 6.0 - t5 * 0.3);\n\tfloat v = 0.3 + t5 * 0.07;\n\tvec3 p6 = vec3(1.7 * cos(v) - 1.0, 0.1, (0.5 + t6 * 0.01) * sin(v));\n\tvec3 p7 = vec3(0.0, 0.0, 0.5 + t7 * 0.1);\n\n\tcamera.eye = mix(p0,         p1, b1);\n\tcamera.eye = mix(camera.eye, p2, b2);\n\tcamera.eye = mix(camera.eye, p3, b3);\n\tcamera.eye = mix(camera.eye, p4, b4);\n\tcamera.eye = mix(camera.eye, p5, b5);\n\tcamera.eye = mix(camera.eye, p6, b6);\n\tcamera.eye = mix(camera.eye, p7, b7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// local iTime\n\tlTime = mod(iTime, SNOW_SCENE_END_TIME + 1.0);\n\n\t// fragment position\n\tvec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / min( iResolution.xy.x, iResolution.xy.y );\n\n\t// camera and ray\n\tCamera camera;\n\tcameraControl(camera);\n#if DEBUG\n\tif (debugCamera) {\n\t\tcamera.eye    = cameraPos;\n\t\tcamera.target = cameraPos + cameraDir;\n\t}\n#endif\n\n\tcamera.up = vec3(0.0, 1.0, 0.0);// y-up\n\tcamera.zoom = 1.3;\n\tRay ray = cameraShootRay(camera, uv);\n\n\tvec3 color = vec3(0.0);\n\tfloat reflection = 1.0;\n\tIntersection intersection;\n\n\tfor (int bounce = 0; bounce <= 2; bounce++) {\n\t\tcalcRadiance(intersection, ray, bounce);\n\n\t\tcolor += reflection * intersection.color;\n\t\tif (!intersection.hit /* || intersection.material != METAL_MATERIAL*/) break;\n\n\t\treflection *= (intersection.metalness * 0.7);\n\t\tray.origin = intersection.position + intersection.normal * OFFSET;\n\t\tray.direction = normalize(reflect(ray.direction, intersection.normal));\n\t}\n\n\tcolor += screenSpaceSnow(uv) * saturate((lTime - UFO_SCENE_END_TIME + 20.0) * 0.1);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msscz7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1150, 1238, 1277, 1277, 1554], [1789, 1837, 1857, 1857, 1945], [1947, 1947, 1968, 1968, 2248], [2250, 2291, 2310, 2310, 2562], [2564, 2564, 2594, 2594, 2615], [2617, 2617, 2648, 2648, 2739], [2741, 2741, 2763, 2763, 2807], [3229, 3270, 3295, 3295, 3353], [3355, 3355, 3389, 3389, 3513], [3515, 3515, 3556, 3556, 3619], [3621, 3643, 3674, 3674, 3761], [3763, 3763, 3795, 3795, 3820], [3822, 3822, 3872, 3872, 3941], [4051, 4051, 4079, 4079, 4379], [4381, 4381, 4402, 4402, 4788], [4790, 4790, 4824, 4824, 4869], [4871, 4871, 4897, 4897, 5048], [5050, 5050, 5077, 5105, 5455], [5457, 5457, 5487, 5487, 5686], [5688, 5688, 5712, 5712, 6353], [6355, 6355, 6381, 6381, 6737], [6739, 6739, 6761, 6761, 6970], [6972, 6972, 6998, 6998, 7171], [7174, 7193, 7215, 7215, 7368], [7370, 7887, 7921, 7921, 7944], [7946, 7946, 8010, 8053, 8577], [8579, 8579, 8649, 8649, 9112], [9114, 9114, 9149, 9149, 9344], [9346, 9346, 9387, 9387, 9749], [9752, 9888, 9920, 9920, 10631], [10633, 10633, 10712, 10712, 12912], [12914, 12914, 12955, 12965, 14711], [14713, 14713, 14770, 14786, 15834]], "test": "valid"}
{"id": "MssyR7", "name": "Learning Raymarching - Jest", "author": "Jestersheepy", "description": "Learning Stuff", "tags": ["raymarching"], "likes": 1, "viewed": 84, "published": "Public", "date": "1487558260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    return length(q) - 0.5;\n    \n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 2.5;\n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t +=d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tuv = uv *2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n   \n        \n\tvec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.5; //Time defined\n    \n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the)); //Camera Rotation\n    \n    vec3 o = vec3(0, -iTime, iTime);\n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t*t*0.10);\n    vec3 fc = vec3(fog);\n\tfragColor = vec4(fc, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 89], [91, 91, 120, 120, 275], [277, 277, 334, 334, 793]], "test": "valid"}
{"id": "MssyRH", "name": "Lights with shadows", "author": "SalikSyed", "description": "Just a pattern of circles with a rotating light. Needs to be performance tuned.", "tags": ["circles"], "likes": 1, "viewed": 167, "published": "Public", "date": "1487194280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 5\n#define M 5\n#define K 12\n#define RING_RADIUS 0.04\n#define OBSTACLE_RADIUS 0.004\n#define M_PI 3.1415926535897932384626433832795\n#define DEBUG\n\nvec3 isectCircle(vec2 target, vec2 origin, vec2 sphereCenter, float r, float depth, float max) {\n    vec2 d = target - origin;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, origin - sphereCenter);\n    float c = dot(sphereCenter, sphereCenter) + dot(origin, origin) - 2.0 * dot(sphereCenter, origin) - r*r;\n    float test = b*b - 4.0*a*c;\n\n    bool behind = length(origin - target) < length(origin - sphereCenter);\n    \n\tif (test >= 0.0 && !behind) {\n  \t\tfloat u = (-b - sqrt(test)) / (2.0 * a);\n  \t    vec2 hitp = origin + u * (target - origin);\n        \n        vec2 offset = (sphereCenter - origin);\n        vec2 ray_dir = normalize(target-origin);\n        float b = dot(ray_dir, offset);\n        float c = dot(offset, offset) - r;\n        float disc = b*b - c;\n    \tfloat disr = sqrt(disc);\n    \tfloat factor = clamp(depth*0.15/disr, 0.15, max);\n        \n        if (length(hitp.xy - target) > length(target - origin)) {\n            return vec3(-1.0,0.0,.0); \n        }\n        if (depth < 0.0) {\n            return vec3(1.0, hitp);\n        } else {\n            \n        \treturn vec3(factor, hitp);\n        }\n    } else {\n        return vec3(-1.0,0.0,.0);   \n    }\n}\n\n\n// Computes a light bloom amount for a given light position\nfloat light_bloom(vec2 light_pos, float light_rad, float dist)\n{\n    // Apply an inverse square fall-off model\n    return light_rad/(180.0*dist+1.0);\n}\n\n\nfloat samplef(vec2 pt, vec2 lightPos) {\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float h = 1.0;\n    float w = aspectRatio;\n\n\n    float encloseR = RING_RADIUS;\n    float encloserRadius = OBSTACLE_RADIUS;\n    float spacingX = (w / (float(N) + 1.0));\n    float spacingY = h / (float(M) + 1.0);\n    float darkness = 0.0;\n    float num = 0.0;\n    float dist = length(pt - lightPos);\n    bool found = false;\n    float factor = 1.0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) { \n            // check if the ray from pt->lightPos intersects the outer group of circles:\n            vec2 center = vec2(spacingX * (float(i) + 1.0), spacingY * (float(j) + 1.0));\n            bool insideEncloser = length(pt - center) < encloserRadius + encloseR ;\n            if (!insideEncloser && isectCircle(lightPos, pt, center, encloserRadius + encloseR, -1.0, -1.0).x < 0.0) {\n                continue;\n            } else {\n                // intersects one of the enclosing cylinders\n                for(int k = 0; k < K; k++) {\n                    float theta = M_PI * 2.0 * float(k)/ float(K);\n                    float x = center.x + cos(theta) * encloseR;\n                    float y = center.y + sin(theta) * encloseR;\n                    vec2 encloser = vec2(x,y);\n                    vec3 isect = isectCircle(lightPos, pt, encloser, encloserRadius, dist, factor);\n                    if (isect.x > 0.0) {\n                        found = true;\n\t\t\t\t\t\tfactor = isect.x;\n                        if (factor <= 0.15) {\n                         \tbreak;   \n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (found) {\n     \treturn factor * light_bloom(lightPos, .5, dist); \n    } else {\n        return light_bloom(lightPos, .5, dist); \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float h = 1.0;\n    float w = aspectRatio;\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x * aspectRatio, fragCoord.y / iResolution.y); \n\n    float encloseR = RING_RADIUS;\n    float encloserRadius = OBSTACLE_RADIUS;\n    float spacingX = (w / (float(N) + 1.0));\n    float spacingY = h / (float(M) + 1.0);\n    float x = 0.0;\n    float y = 0.0;\n    vec2 lightPos = vec2(aspectRatio/2.0 + sin(iTime)*0.1, 0.5+ cos(iTime)*0.1);\n    \n    #ifdef DEBUG\n    if (length(lightPos - uv) < encloseR) {\n     \t   //fragColor = vec4(1.0);\n           //return;\n    }\n\n\tvec3 color = vec3(0.48, 0.55, 0.57);\n    color += clamp(step(mod(uv.x, 45.0),1.0) + step(mod(uv.y, 45.0),1.0), 0.0, 0.055);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) { \n            // compute the center of the diagram\n            vec2 center = vec2(spacingX * (float(i) + 1.0), spacingY * (float(j) + 1.0));\n            \n    \t\tvec2 offsetVec = vec2(sin(iTime)*0.06, 0.06);\n    \t\tcolor += vec3(1.0, 0.7, 0.4) * samplef(uv, center + offsetVec);\n    \n\t\n            \n            if (length(uv - center) > encloserRadius + encloseR) {\n                continue;\n                return;\n            } else {\n                // intersects one of the enclosing 24 cylinders\n                for(int k = 0; k < K; k++) {\n                    float theta = M_PI * 2.0 * float(k)/ float(K);\n                    x = center.x + cos(theta) * encloseR;\n                    y = center.y + sin(theta) * encloseR;\n                    vec2 encloser = vec2(x,y);\n                    if (length(uv - encloser) < encloserRadius) {\n                        fragColor = vec4(0.85,0.87,0.84, 1.0);\n                    \treturn;\n                    }\n                    \n                }   \n            }\n        }\n    }\n    #endif\n    \n\n\n    fragColor = vec4(color, 1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 250, 250, 1330], [1333, 1393, 1457, 1503, 1544], [1547, 1547, 1586, 1586, 3365], [3368, 3368, 3425, 3425, 5312]], "test": "valid"}
{"id": "MssyRN", "name": "2d-Primitive collection", "author": "gPlatl", "description": "Corrected test frame for animated 2d primitives and different 2d & 3d backgrounds. \nChange background animation by pressing mouse button at different x positions. \nY position of mouse changes the background speed and direction.\nIs this shader useful 4 u ?", "tags": ["2d", "line", "circle", "primitives", "rectangle", "disc", "frame", "backgrounds"], "likes": 30, "viewed": 4000, "published": "Public", "date": "1487327301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Shader: 2dPrimitives.glsl by gPlatl\n//         v1.0  2015-09-13  initial release\n//         v1.1  2016-02-14  added primitives\n//         v1.2  2016-03-30  circleBox added\n//         v1.3  2016-08-15  line & line segment added\n//         v1.4  2016-09-09  circle2 & ring2 added\n//         v1.5  2017-03-05  code corrections\n//         v1.6  2017-03-15  donjon tunnel added\n//         v1.7  2017-10-29  rotateCCW added\n//               2018-12-17  working on...  \n// Tags:   2d, primitives, line, disc, circle, rectangle, frame, backgrounds \n// Test frame for animated 2d primitives and different 2d & 3d backgrounds.\n// Change background by pressing mouse button on different x positions.\n// Y position of mouse changes the background speed and direction.\n// Note:     Will be enhanced from time to time...\n// see also: http://glslsandbox.com/e#26010\n//           https://www.shadertoy.com/view/XtjGzt\n//           https://www.shadertoy.com/view/lsy3zz\n//           http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//---------------------------------------------------------\n\nconst float HALF_PI = 1.57079632679;\nconst float      PI = 3.14159265359;\nconst float  TWO_PI = 6.28318530718;\n\nvec2 uv = vec2(0);  // centered pixel position -1 .. 1\n\n#define BACKGROUNDS 7\n\n//---------------------------------------------------------\n// get moving background texture\n//---------------------------------------------------------\n#define TILES_COUNT_X 4.0\n#define TILES_COUNT_Y 3.0\nvec3 BackgroundColor (vec2 position, sampler2D tilesTexture, vec2 resolution)\n{\n  //vec2 p = TILES_COUNT_X * position.xy / resolution.x;\n  vec2 p = TILES_COUNT_Y * position.xy / resolution.y;\n  return texture (tilesTexture, p).xyz;\n}\n//---------------------------------------------------------\n// get pseudo 3d bump background\n//---------------------------------------------------------\nvec3 BumpyBackground (vec2 pos, sampler2D aTexture, float time)\n{\n  #define ANIMATE_TEXTURE true\n  #define LINEAR_STEPS 20.0\n  #define DISTANCE 0.16\n  #define FEATURES 0.5\n\n  vec3 color;\n  vec2 dir = 0.6*vec2(pos - vec2(0.5, 0.5)) * (DISTANCE / LINEAR_STEPS);\n  if (ANIMATE_TEXTURE)\n    pos += time * vec2(0.3, 1e-5* sin(time));\n    \n  for (float i = 1.0; i < LINEAR_STEPS; i++) \n  {\n    vec3 pixel1 = texture(aTexture, pos - i * dir).xyz;\n      \n      \n    if (pow(length(pixel1) / 1.4, 0.20) * (1.0 - FEATURES)\n       +pow(length(texture(aTexture, (pos - i * dir) * 2.0).rgb) / 1.4, 0.90) * FEATURES\n       > i / LINEAR_STEPS) \n    color = pixel1 * i / LINEAR_STEPS;\n    //color += 0.16 * pixel1 * i / LINEAR_STEPS;\n  }\n  return color;\n}\n//---------------------------------------------------------\n// perspective ground texture\n//---------------------------------------------------------\nvec3 BaseGround (vec2 pos, sampler2D tilesTexture, float atime)\n{\n  vec3 camera = vec3(atime, 1.0, atime);\n  vec3 raydelta = vec3(sin(pos.x)\n                      ,abs(sin(pos.y)-0.88)\n                      ,cos(pos.x));\n  vec3 mapped = raydelta * (camera.y / raydelta.y) + camera;\n  vec3 col = vec3(texture( tilesTexture, mapped.xz ));\n//  col *= abs(pos.y - 1.0);  // darkness based on the horizon\n  return col;\n}\n//---------------------------------------------------------\n// pipe tunnel with 1 texture\n//---------------------------------------------------------\nvec3 PipeTunnel (vec2 pos, sampler2D tilesTexture, float atime)\n{\n  float a = atan(pos.y, pos.x) / HALF_PI;\n  float r = sqrt(dot(pos, pos));\n  vec2 k = mod(vec2(atime + 1.0 / r, a), 1.0);\n  return r * texture(tilesTexture, k).xyz;\n}\n//---------------------------------------------------------\n// donjon tunnel with 2 textures\n//---------------------------------------------------------\nvec4 DonjonTunnel(vec2 p, float aTime)\n{\n    // p.y += sin(aTime) * 0.15;   // up/down\n    float a = atan(p.x,p.y) / HALF_PI;\n    p.x = abs(p.x);\n    float d = max(max(p.x,abs(p.y)), min(p.x+p.y, length(p)));\n    vec2 k = vec2(a, 1.2/d + aTime);  \n    if (d > p.x && (d > p.x+p.y))\n      return texture(iChannel3, k) * d;    // ground\n    return texture(iChannel0, k) * d;      // wall\n}\n//---------------------------------------------------------\n// square tunnel with 3 textures\n//---------------------------------------------------------\nvec3 SquareTunnel(vec2 p, float atime)\n{\n  float r = pow(pow(p.x*p.x,6.0) + pow(p.y*p.y,6.0), 1.0/16.0);\n  vec2 pp = 2.0 * vec2 (atime + 1.0/r, atan(p.y,p.x)/3.1416);\n\t\n  vec3 col = vec3(0);\n  if (p.y > 0.0)\n    col = texture(iChannel1, pp).rgb; \n  else col = texture(iChannel0, pp).rgb;\n  col = mix( col, texture(iChannel2, pp).rgb, smoothstep(0.9,1.1,abs(p.x/p.y) ) );\n  return vec3( col*r);\n}\n\n\n//=== 2d geometric primitives ===\n\n// y position ranges from -1.0 .. +1.0\n\n// functions return intensity (0.0 .. 1.0) with antialiased edges\n\n//---------------------------------------------------------\n// draw endless line through point A and B with radius r\n//---------------------------------------------------------\nfloat line(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n  return smoothstep(r, 0.5*r, d);\n}\n\n//---------------------------------------------------------\n// draw segment line from point A to point B and radius r\n// see also sdCapsule(p,a,b,r) from inigo quilez\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\nfloat segment(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  vec2 h = P - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return smoothstep(r, 0.5*r, d);\n}\n//---------------------------------------------------------\nfloat segment2(vec2 P, vec2 A, vec2 B, float r)\n{\n  float d = length((P-=A)-(B-=A)*clamp(dot(P,B)/dot(B,B), 0.0, 1.0 ));\n  return smoothstep(r, 0.5*r, d);;   \n}\n\n//---------------------------------------------------------\n// draw rectangle at pos(-1..+1) with given size\n//---------------------------------------------------------\nfloat rectangle(vec2 pos, vec2 size)\n{\n  size *= 0.5;\n  vec2 r = abs(uv - pos - size) - size;\n  return step( max(r.x,r.y),0.0);\n}\n//---------------------------------------------------------\n// draw rectangle at pos with given size\n//---------------------------------------------------------\nfloat rectangle2(vec2 pos, vec2 size)\n{\n  return (step(pos.x, uv.x)         - step(pos.x + size.x,uv.x))\n       * (step(pos.y - size.y,uv.y) - step(pos.y, uv.y));\n}\n//---------------------------------------------------------\n// draw rounded rectangle\n//---------------------------------------------------------\nfloat roundedRectangle (vec2 pos, vec2 size, float radius, float thickness)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.66, 0.33, d / thickness * 5.0);\n}\n//---------------------------------------------------------\n// draw rectangle frame with rounded edges\n//---------------------------------------------------------\nfloat roundedFrame (vec2 pos, vec2 size, float radius, float thickness)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.55, 0.45, abs(d / thickness) * 5.0);\n}\n//---------------------------------------------------------\n// draw circle at pos with given radius\n//---------------------------------------------------------\nfloat circle(vec2 pos, float radius)\n{\n    float d = length(uv-pos);\n    return smoothstep(d,d+0.01,radius);\n}\n//---------------------------------------------------------\n// draw circle at pos with given radius and halo\n//---------------------------------------------------------\nfloat circle(vec2 pos, float radius, float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n//---------------------------------------------------------\nfloat circle2(vec2 pos, float radius, float halo)\n{\n  return clamp(((1.0-(length(uv-pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\n//---------------------------------------------------------\n// interpolation between a circle and a box with rounded corner\n//---------------------------------------------------------\nfloat circleBox(vec2 pos            // position\n               ,vec2 size           // shape size\n               ,float cornerRadius  // radius of rounded box corner\n               ,float between)      // interpolation value: 0.0 .. 1.0\n{\n  float sd = (length(uv-pos) - size.x); // circle\n  size -= vec2(cornerRadius);           // rounded box\n  vec2 d = (abs(uv-pos) - size);\n  float box = min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - cornerRadius;\n  float v = (1.0 - between)*sd + box*between;  //mix\n  return clamp (-88.0*v , 0.0, 1.0);\n}\n\n//---------------------------------------------------------\n// return 2d rotation matrix\n//---------------------------------------------------------\nmat2 rotate2D(float angle)\n{\n  float c = cos(angle), s = sin(angle);\n  return mat2(c, s, -s, c);\n}\n//---------------------------------------------------------\n// return point p rotated with given angle\n//---------------------------------------------------------\nvec2 rotateCCW (vec2 pos, float angle)\n{ \n  float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, sa, -sa, ca);  \n}\n\n//---------------------------------------------------------\n// squircle: a variable shape (star..rectangle..circle)\n// http://en.wikipedia.org/wiki/Squircle\n//---------------------------------------------------------\nfloat squircle(vec2 pos, float radius, float power)\n{\n  vec2 p = abs(pos - uv) / radius;\n  float d = (pow(p.x,power) + pow(p.y, power) - pow(radius, power)) -1.0;\n  return 1.0 - clamp (16.0*d, 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw ring at given position\n//---------------------------------------------------------\nfloat ring(vec2 pos, float radius, float thick)\n{\n  return mix(1.0, 0.0, smoothstep(thick, thick + 0.01, abs(length(uv-pos) - radius)));\n}\n//---------------------------------------------------------\nfloat ring2(vec2 pos, float radius, float thick)\n{\n  return clamp((thick-abs(length(uv-pos) - radius))*100.0, 0.0, 1.0); \n}\n//---------------------------------------------------------\n// draw ring at pos \n//---------------------------------------------------------\nfloat haloRing(vec2 pos, float radius, float thick)\n{\n  return clamp(-(abs(length(uv-pos) - radius) * 100.0 / thick) + 0.9, 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw polygon with n edges at pos \n//---------------------------------------------------------\nfloat polygon(vec2 pos, float n, float radius)\n{\n  vec2 p = pos;\n  float angle = atan(p.x, p.y) + PI;\n  float r = TWO_PI / n;\n  float d = cos(floor(0.5 + angle / r) * r - angle) * length(p) / radius;\n  return smoothstep(0.41,0.4,d);\n}\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime;\n  vec2 pos, size;\n  vec2 npos = fragCoord.xy / iResolution.xy;   // 0.0 .. 1.0\n  \n  // get uv position with origin at window center\n  float aspect = iResolution.x / iResolution.y;   // aspect ratio x/y\n  vec2 ratio = vec2(aspect, 1.0);                 // aspect ratio (x/y,1)     \n  uv = (2.0 * npos - 1.0) * ratio;             // -1.0 .. 1.0\n    \n  vec2 mpos = iMouse.xy / iResolution.xy;      //  0.0 .. 1.0\n  vec2 mp = (2.0 * mpos - 1.0) * ratio;        // -1.0 .. 1.0  \n  float speed = (mpos.y - 0.4) * time;    \n    \n  vec3 col;\n  int selection = int((iMouse.x / iResolution.x) * float(BACKGROUNDS));\n    \n  if      (selection == 6)   \n    col = BackgroundColor(fragCoord, iChannel0, iResolution.xy);\n    \n  else if (selection == 5)\n    col = BackgroundColor(fragCoord+vec2(-180.0*speed,0.0), iChannel0, iResolution.xy);\n      \n  else if (selection == 4)\n    col = BumpyBackground (uv, iChannel2, 4.0 * speed);\n\n  else if (selection == 3)\n    col = BaseGround(npos, iChannel1, speed);\n\n  else if (selection == 2)\n    col = PipeTunnel(uv, iChannel1, speed);\n     \n  else if (selection == 1)\n    col = DonjonTunnel (uv, speed).rgb;\n\n  else\n    col = SquareTunnel(uv, speed);\n\n  float intensity = 0.0;\n      \n  //--- line --- \n  pos = vec2(-0.5*sin(time), 0.0);\n  const vec3 lineColor1 = vec3(0.1, 0.4, 0.7);\n  intensity = line (uv, pos, mp, 0.016);\n  if ((intensity > 0.0) && (intensity <= 1.0))\n    col = mix(col, lineColor1, intensity);\n    \n  //--- line segment --- \n  const vec3 lineColor2 = vec3(0.9, 0.9, 0.2);\n  intensity = segment (uv, pos, mp, 0.02);     \n  if ((intensity > 0.0) && (intensity <= 1.0))\n    col = mix(col, lineColor2, intensity);\n    \n  //--- green rectangle ---\n  const vec3 rectangleColor = vec3(0.2, 0.8, 0.5);\n  intensity = 0.6 * rectangle (vec2(sin(time),-0.9),vec2(0.5, 0.1));\n  col = mix(col, rectangleColor.rgb, intensity);\n\n  //--- rounded rectangle ---\n  const vec3 rectColor = vec3(0.1, 0.8, 0.5);\n  pos = vec2(-sin(time), 0.6);\n  size = vec2(0.16, 0.02);\n  intensity = 0.6 * roundedRectangle (pos, size, 0.1, 0.2);\n  col = mix(col, rectColor, intensity);\n    \n  //--- rounded frame ---\n  const vec3 frameColor = vec3(0.5, 0.3, 0.6);\n  size = vec2(0.28, 0.10);\n  intensity = roundedFrame (pos, size, 0.08, 0.2);\n  col = mix(col, frameColor, intensity);\n    \n  //--- red dot ---\n  const vec3 circleColor2 = vec3(0.6, 0.2, 0.2);\n  vec2 redPos = vec2(-0.5*sin(time), 0.0);\n  intensity = circle(redPos, 0.05, 100.0);\n  col = mix(col, circleColor2, intensity);\n\n  //--- mouse dot ---\n  if (iMouse.z > 0.0)\n  {\n    const vec3 circleColorM = vec3(1.6, 1.2, 0.6);\n    intensity = circle(mp, 0.05, 100.0);\n    col = mix(col, circleColorM, intensity);\n  }\n\n  //--- yellow circle ---\n  const vec3 circleColor = vec3(1, 0.8, 0.3);\n  intensity = circle(vec2(sin(time), 0.6), 0.2);\n  //intensity = circle(vec2(sin(time), 0.6), 0.2, 6.);\n  col = mix(col, circleColor, intensity);\n\n  //--- violet circleBox ---\n  const vec3 cbColor = vec3(0.5, 0.3, 0.8);\n  pos = vec2(-sin(time), -0.6);\n  float between = 0.5+0.5*sin(time);  // mix value\n  size = vec2(0.15, 0.10);\n  intensity = 0.8 * circleBox(pos, size, 0.02, between);\n  col = mix(col, cbColor, intensity);\n  \n  //--- brown squircle ---\n  const vec3 sqColor = vec3(0.8, 0.5, 0.3);\n  pos = vec2(1.3, 0.6*sin(time+HALF_PI));\n  float power = 0.8 + 2.0*(1.0+sin(time));\n  intensity = 0.9 * squircle (pos, 0.1, power);\n  if (intensity > 0.0) \n    col = mix(col, sqColor, intensity);\n  \n  //--- pink ring ---\n  vec3 ringColor = vec3(0.9, 0.4, 0.6);\n  pos = vec2(0.5*sin(time), 0.0);\n  intensity = ring2(pos, 0.2 +0.05*sin(time), 0.04);\n  if (intensity > 0.0) \n    col = mix(col, ringColor, intensity);\n  \n  //--- haloRing ---\n  ringColor = vec3(1.0, 1.0, 1.5);\n  intensity = haloRing (vec2(-sin(time), 0.0), 0.3, 6.0);\n  col = mix(col, ringColor, intensity);\n  \n  //--- polygon ---\n  const vec3 polygonColor = vec3(0.5, 0.9, 0.3);\n  pos = vec2(sin(time), -0.5);\n  pos = rotateCCW(uv - pos,time);\n  float n = floor (6.0 + 3.0 * sin(time));\n  intensity = 0.8 * polygon(pos,n, 0.4);\n  col = mix(col, polygonColor.rgb, intensity);\n    \n  fragColor = vec4 (col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1353, 1558, 1637, 1694, 1791], [1792, 1945, 2010, 2010, 2684], [2685, 2835, 2900, 2900, 3250], [3251, 3401, 3466, 3466, 3633], [3634, 3787, 3827, 3873, 4174], [4175, 4328, 4368, 4368, 4723], [4868, 5045, 5090, 5090, 5201], [5203, 5500, 5548, 5548, 5687], [5688, 5748, 5797, 5797, 5908], [5910, 6079, 6117, 6117, 6208], [6209, 6370, 6409, 6409, 6534], [6535, 6681, 6758, 6758, 6875], [6876, 7039, 7112, 7112, 7234], [7235, 7395, 7433, 7433, 7505], [7506, 7675, 7725, 7725, 7788], [7789, 7849, 7900, 7900, 7975], [7977, 8161, 8399, 8399, 8705], [8707, 8856, 8884, 8884, 8954], [8955, 9118, 9158, 9158, 9244], [9246, 9463, 9516, 9516, 9668], [9669, 9820, 9869, 9869, 9958], [9959, 10019, 10069, 10069, 10142], [10143, 10284, 10337, 10337, 10420], [10421, 10578, 10626, 10626, 10812], [10814, 10874, 10931, 10931, 15088]], "test": "error"}
{"id": "MsXcRM", "name": "-Mandelbulb-", "author": "yumcyawiz", "description": "1.0 ~ 8.0 powered mandelbulb rendered with simple \"steps AO\".", "tags": ["fractal"], "likes": 5, "viewed": 169, "published": "Public", "date": "1487416632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int maxIter = 100;\nfloat df(vec3 p, float power) {\n    vec3 z = p;\n    float r = 0.0;\n    float dr = 1.0;\n    for(int i = 0; i < maxIter; i++) {\n        r = length(z);\n        if(r > 100.0) break;\n        \n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        \n        dr = power*pow(r, power-1.0)*dr + 1.0;\n        \n        r = pow(r, power);\n        theta *= power;\n        phi *= power;\n        \n        z = r*vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n        z += p;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    float t;\n    int steps;\n};\nconst int maxSteps = 100;\nRay trace(vec3 camPos, vec3 rayDir) {\n    vec3 p = vec3(0);\n    float t = 0.0; \n    int steps = 0;\n    bool hit = false;\n    for(int i = 0; i < maxSteps; i++) {\n        p = camPos + t*rayDir;\n        float d = df(p, 8.0*abs(sin(0.5*iTime)) + 1.0);\n        if(d < 0.001) {\n            hit = true;\n            steps = i;\n            break;\n        }\n        t += d*0.9;\n    }\n    return Ray(hit, p, t, steps);\n}\n\n\nvec3 shading(Ray tr) {\n    if(tr.hit) {\n    \treturn vec3(pow(1.0 - float(tr.steps)/float(maxSteps), 0.7));\n    }\n    else {\n        return vec3(0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    //vec3 camPos = vec3(-2, 0, 0);\n    vec3 camPos = 2.0*vec3(cos(iTime), 0, sin(iTime));\n    vec3 camFront = normalize(-camPos);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camFront, camUp);\n    float focus = 1.0;\n    \n    vec3 rayDir = normalize(uv.x*camRight + uv.y*camUp + focus*camFront);\n    Ray tr = trace(camPos, rayDir);\n    \n\tfragColor = vec4(shading(tr), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXcRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 56, 56, 555], [659, 659, 696, 696, 1068], [1071, 1071, 1093, 1093, 1226], [1229, 1229, 1286, 1286, 1744]], "test": "valid"}
{"id": "MtGSDt", "name": "Square spiral test", "author": "nomadiclizard", "description": "Playing with 2D", "tags": ["2d", "spiral"], "likes": 4, "viewed": 281, "published": "Public", "date": "1486409469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a spiral of successive twisted squares\n\n// a twisted square can be defined as a transformation (rotation and scaling) of the unit square\n// so the inverse matrix will be calculated to turn a point (x,y) back onto this unit square\n// the point is then coloured if it is within a certain distance of the edge of the unit square\n// to do this I clamp a function f(x) that peaks at (0,1) and goes <=0 quickly between them\n// e.g. f(x) = -(x^100-1)^2+1\n// each pixel is then an accumulation of all the squares in the spiral multiplied by a colour\n// which can be parameterised to give ripples outwards \n\n#define pi 3.14159265\n#define twoPi (2.0 * pi)\n\n// matrix to scale and rotate a unit square\nmat2 square(float scale, float angle)\n{\n    mat2 mrot = mat2(cos(angle), sin(angle),\n                     -sin(angle), cos(angle));\n    mat2 mscale = mat2(scale, 0.0,\n                       0.0, scale);\n    return mrot * mscale;\n}\n\n// colour function returns 1 when within step of the unit square\nfloat colour(float x, float y)\n{\n    float step = 0.02;\n    if((x >= -1.0 && x <= -1.0 + step) || (x <= 1.0 && x >= 1.0 - step)) {\n         if(y >= -1.0 && y <= 1.0) {\n             return 1.0;\n         }\n    } else if((y >= -1.0 && y <= -1.0 + step) || (y <= 1.0 && y >= 1.0 - step)) {\n        if(x >= -1.0 && x <= 1.0) {\n             return 1.0;\n         }\n    }\n    return 0.0;\n}\n\n// smooth version of above\nfloat colour2(float x, float y)\n{\n    float xx = x * x;\n    float yy = y * y;\n    float xxxx1 = (pow(xx, 8.0) - 1.0);\n    float yyyy1 = (pow(yy, 8.0) - 1.0);\n    float xy = (1.0 - xxxx1 * xxxx1) * step(-yy, 0.0);\n    float yx = (1.0 - yyyy1 * yyyy1) * step(-xx, 0.0);\n    return clamp(xy + yx, 0.0, 1.0);\n}\n\nconst float speed = 0.15;\nconst float scalem = 0.08;\nconst float anglem = 0.25;\nconst float angles = 0.03;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    for (int i = 0; i < 55; i++) {\n        float ii = pow(1.1, float(i) + fract(iTime * speed)) * 0.1;\n        float scale = scalem * ii;\n        float angle = twoPi * (anglem * ii + iTime * angles);\n    \tmat2 s = square(scale, angle);\n    \tmat2 is = inverse(s);\n    \tvec2 p = is * uv;\n        float intensity = 0.4 * colour2(p.x, p.y);\n        fragColor += clamp(vec4(intensity * sin(-iTime + ii), intensity * sin(-1.5 * iTime + ii), intensity * sin(-2.0 * iTime + ii), 0.0), 0.0, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[650, 694, 733, 733, 924], [926, 991, 1023, 1023, 1372], [1374, 1401, 1434, 1434, 1707], [1817, 1817, 1874, 1874, 2436]], "test": "error"}
{"id": "MtKXWt", "name": "Voronoi Lava", "author": "zackpudil", "description": "f", "tags": ["f"], "likes": 27, "viewed": 528, "published": "Public", "date": "1486562190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n  return fract(sin(n)*43578.5453);\n}\n\nvec2 hash(vec2 n) {\n  float m = hash(dot(n, vec2(12.23, 30.343)));\n  return vec2(hash(m + 2.34), hash(m + 93.34));\n}\n\nfloat noise(vec2 g) {\n  vec2 p = floor(g);\n  vec2 f = fract(g);\n  \n  f = f*f*(3.0 - 2.0*f);\n  float n = p.x + 57.0*p.y;\n  \n  float x = mix(hash(n), hash(n + 1.0), f.x);\n  float y = mix(hash(n + 57.0), hash(n + 58.0), f.x);\n  return mix(x, y, f.y);\n}\n\nfloat noise(float g) {\n  float p = floor(g);\n  float f = fract(g);\n  \n  f = f*f*(3.0 - 2.0*f);\n  return mix(hash(p), hash(p + 1.0), f);\n}\n\nfloat voronoi(vec2 x) {\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n\n  vec2 res = vec2(8.0);\n\n  for(int i = -1; i <= 1; i++)\n  for(int j = -1; j <= 1; j++) {\n    vec2 g = vec2(float(i), float(j));\n    vec2 o = hash(p + g);\n    if(i == 0)\n      o = 0.5 + 0.5*sin(6.28138*o + 0.2*iTime);\n    \n    vec2 r = g + o - f;\n\n    float d = max(abs(r.x), abs(r.y));\n\n    if(d < res.x) {\n      res.y = res.x;\n      res.x = d;\n    } else if(d < res.y) {\n      res.y = d;\n    }\n  }\n\n  return res.y - res.x;\n}\n\nvec3 formula(vec2 p) {\n  p *= mat2(cos(iTime*0.1), sin(iTime*0.1), -sin(iTime*0.1), cos(iTime*0.1));\n  p += vec2(iTime*0.5, sin(iTime*0.7));\n  \n  float v = 0.0;\n  float a = 0.7, f = 1.0;\n\n  for(int i = 0; i < 4; i++) {\n    float v1 = voronoi(p*f + 5.0);\n    float v2 = 0.0;\n    \n    v1 = 1.0 - smoothstep(0.0, 0.4, v1);\n    v2 =  a*noise(v1*5.5 + 0.3);\n\n    v += v2;\n\n    f *= 1.6;\n    a *= 0.55;\n  }\n\n  return vec3(pow(v, 6.0), pow(v, 4.0), pow(v, 2.0));\n}\n\nvec3 grey = vec3(0.21, 0.72, 0.07);\n\nvec3 cube(vec3 p, vec3 n) {\n  vec3 m = pow(abs(n), vec3(10.0));\n  \n  vec3 x = formula(p.yz);\n  vec3 y = formula(p.xz);\n  vec3 z = formula(p.xy);\n  \n  return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 bump(vec2 p, float e) {\n  vec2 h = vec2(e, 0.0);\n  \n  vec3 g = grey*mat3(\n    formula(p + h) - formula(p - h),\n    formula(p + h.yx) - formula(p - h.yx),\n    -0.1/grey);\n  \n  return normalize(g);\n}\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n  \n  vec3 rd = normalize(vec3(p, 1.97));\n  vec3 sn = normalize(bump(p, 0.008));\n  vec3 re = reflect(rd, sn);\n  \n  vec3 col = vec3(0);\n  \n  vec3 mat = formula(p);\n  \n  col += pow(clamp(dot(-rd, re), 0.0, 1.0), 8.0);\n  col *= vec3(0.2, 0.5, 1.4)*mat.b;\n  \n  col += vec3(0.2, 1.0, 0.5)*smoothstep(0.0, 2.0, sin(mat.r*mat.b));\n\n  col = pow(col, vec3(1.0/2.2));\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 58], [60, 60, 79, 79, 176], [178, 178, 199, 199, 427], [429, 429, 451, 451, 566], [568, 568, 591, 591, 1060], [1062, 1062, 1084, 1084, 1519], [1558, 1558, 1585, 1585, 1759], [1761, 1761, 1789, 1789, 1963], [1967, 1967, 2023, 2023, 2470]], "test": "valid"}
{"id": "MtVSDc", "name": "Ray Marching Shading Example", "author": "yumcyawiz", "description": "this is the example code of ray marching ADS(ambient + diffuse + specular) shading.", "tags": ["raymarching"], "likes": 5, "viewed": 178, "published": "Public", "date": "1486306521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n//rotation matrix\n//mat3 ry = mat3(cos(time), 0, -sin(time), 0, 1, 0, sin(time), 0, cos(time));\n\n\n//lots of these functions are imported from here\n//http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\nfloat opS(float d1, float d2) {\n\treturn max(-d1, d2);\n}\nfloat opI(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat displace(vec3 p) {\n\treturn sin(p.x + 1.1*time)*sin(p.y + 1.3*time)*sin(p.z + 1.2*time);\n}\n\nfloat opDisplace(vec3 p) {\n\tfloat d1 = opS(sdBox(mod(p, vec3(2.0)) - 0.5*vec3(2.0), vec3(1.0)), sdSphere(p, 3.0));\n\tfloat d2 = displace(p);\n\treturn d1+d2;\n}\n\n\n//distance field\nfloat dist(vec3 p) {\n\treturn opU(opDisplace(p), sdBox(p + vec3(0, 1.1, 0), vec3(6, 0.1, 6)));\n}\n\n\n//normal\nvec3 calcNormal(vec3 p) {\n\tfloat d = 0.001;\n\treturn normalize(vec3(\n\t\tdist(p + vec3(d, 0, 0)) - dist(p + vec3(-d, 0, 0)),\n\t\tdist(p + vec3(0, d, 0)) - dist(p + vec3(0, -d, 0)),\n\t\tdist(p + vec3(0, 0, d)) - dist(p + vec3(0, 0, -d))\n\t\t));\n}\n\n\nstruct ray {\n\tvec3 rayDir;\n\tvec3 position;\n\tvec3 normal;\n\tint steps;\n\tfloat t;\n};\n\n//ray marching\nconst int maxStep = 100;\nray trace(vec3 from, vec3 rayDir) {\n\tfloat t = 0.0;\n\tvec3 p;\n\tint steps;\n\tfor(int i = 0; i < maxStep; i++) {\n\t\tp = from + t*rayDir;\n\t\tfloat d = dist(p)/2.0;\n\t\tt += d;\n\t\tif(d < 0.01) {\n\t\t\tp -= 0.001*rayDir;\n\t\t\tsteps = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ray(rayDir, p, calcNormal(p), steps, t);\n}\n\n//shading function\nvec3 lightPos = vec3(0, 10, 10);\nconst float mix1 = 0.3;\nconst float mix2 = 0.5;\nconst float shininess = 12.0;\nvec3 shade(vec3 position, vec3 rayDir, vec3 normal, int steps) {\n\tray tr = trace(lightPos, normalize(position - lightPos));\n\tbool visible;\n\tif(distance(tr.position, position) < 0.1) {\n\t\tvisible = true;\n\t}\n\telse {\n\t\tvisible = false;\n\t}\n\t\n\tfloat diffuse = max(dot(normal, -tr.rayDir), 0.0);\n\tfloat specular = pow(max(dot(rayDir, reflect(normal, -tr.rayDir)), 0.0), shininess);\n\tvec3 directColor = vec3(0);\n\tif(visible) directColor = vec3(mix(diffuse, specular, mix1));\n\t\n\tfloat ao = 1.0 - float(steps)/float(maxStep);\n\tvec3 indirectColor = ao * vec3(0.6, 0.7, 1);\n\t\n\treturn 2.0*mix(directColor, indirectColor, mix2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*gl_FragCoord.xy - iResolution.xy)/iResolution.x;\n\t\n    //camera settings\n\tvec3 camPos = vec3(10.0*cos(time/2.0), 1, -10.0*sin(time/2.0));\n\tvec3 camFront = normalize(-camPos);\n\tvec3 camUp = vec3(0, 1.0, 0);\n\tvec3 camRight = cross(camFront, camUp);\n\t\n    //ray marching\n\tvec3 rayDir = normalize(uv.x*camRight + uv.y*camUp + 1.0*camFront);\n\tray tr = trace(camPos, rayDir);\n    //shading\n\tvec3 color = shade(tr.position, tr.rayDir, tr.normal, tr.steps);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 240, 273, 273, 298], [299, 299, 328, 328, 417], [419, 419, 450, 450, 473], [474, 474, 505, 505, 529], [530, 530, 561, 561, 584], [586, 586, 610, 610, 681], [683, 683, 709, 709, 839], [842, 859, 879, 879, 954], [957, 966, 991, 991, 1202], [1288, 1328, 1363, 1363, 1615], [1617, 1747, 1811, 1811, 2363], [2366, 2366, 2423, 2423, 2927]], "test": "valid"}
{"id": "MtyXWc", "name": "Block Row", "author": "TrueBoolean", "description": "Psuedo 3d effect that looks like a row of blocks.", "tags": ["scrolling"], "likes": 0, "viewed": 74, "published": "Public", "date": "1487827442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 p ){\n    p =  (-iResolution.xy + 2.0 * p.xy )/iResolution.y;\n    p.y = abs( p.y +sin(iTime) );\n    vec3 col = vec3( 1.0 * 1.-p.y );\n    p.x/=p.y - 2.;\n    p.x+=iTime;\n    if( mod( p.x, 2. ) < 1. ) col.yx=vec2(0.);\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 290]], "test": "valid"}
{"id": "XdfyDN", "name": "ornate artifacts of polarity", "author": "jes5199", "description": "These artifacts started appearing in images I was rendering back in 2012. I just figured out how to control them. How much of this is math and how much of this is the limits of the physical processor architecture?", "tags": ["2d", "cathedral", "floatingpointerrors"], "likes": 3, "viewed": 123, "published": "Public", "date": "1488162176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (23.0 + pow(iTime / 5.0, 1.5)) * (fragCoord.xy / iResolution.xy - 0.5);\n    \n    float value = uv.x * uv.y;\n    float color = sin(value) * 3.0;\n    //float low = abs(color);\n    //float med = abs(color) - 1.0;\n    //float high = abs(color) - 2.0;\n    if(color > 0.0) {\n   \t  //fragColor = vec4(low, med, high,1.0);\n      fragColor = color - vec4(0,1,2,0); \n    } else {\n      //fragColor = vec4(med, med, low,1.0);\n      fragColor = -color - vec4(1,1,0,0); \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 534]], "test": "valid"}
{"id": "XdlcD8", "name": "JS Mandelbrot Set", "author": "jscoggin", "description": "Mandelbrot Set", "tags": ["fractal"], "likes": 0, "viewed": 90, "published": "Public", "date": "1487987989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smooth_step( float edge0, float edge1, float x )\n{\n    float p = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    float v = p * p * (3.0 - 2.0 * p); // smoothstep formula\n    \n    //v = smoothstep( edge0, edge1, x ); // Compare with built-in\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y < iResolution.y / 100.0)\n    {\n        float pct = (fragCoord.x / iResolution.x) + (iTime / 400.0);\n        fragColor = vec4(sin(mix(0.0, 125.664, pct)),sin(mix(0.0, 125.664, pct + 0.33)),sin(mix(0.0, 125.664, pct + 0.66)),1.0);\n    }\n    else\n    {\n        float localTime = smooth_step(0.0, 1.0, mod(iTime, 30.0) / 30.0);\n        float time = sqrt(sin(localTime * 3.14159));\n        //float time = mod(iTime, 32.0) * 0.2;\n        //float scale = min(200.0, 2.0 / pow(time, time));\n        float scale = mix(1.5, 0.00001, time);\n        float sizeX = 3.5 * scale;\n        float sizeY = 2.0 * scale;\n        //float centerX = -0.75;\n        //float centerY = 0.0;\n        float centerX = -1.78;\n        float centerY = 0.0;\n        float minX = centerX - sizeX / 2.0;\n        float maxX = minX + sizeX;\n        float minY = centerY - sizeY / 2.0;\n        float maxY = minY + sizeY;\n        float xPercent = fragCoord.x / iResolution.x;\n        float yPercent = fragCoord.y / iResolution.y;\n        float x0 = mix(minX, maxX, xPercent); //scaled x coordinate of pixel (scaled to lie in the Mandelbrot X scale (-2.5, 1))\n        float y0 = mix(minY, maxY, yPercent); //scaled y coordinate of pixel (scaled to lie in the Mandelbrot Y scale (-1, 1))\n        float x = 0.0;\n        float y = 0.0;\n        int iteration = 0;\n        int max_iteration = 1000;\n        while (x*x + y*y < 2.0*2.0  &&  iteration < max_iteration) {\n            float xtemp = x*x - y*y + x0;\n            y = 2.0*x*y + y0;\n            x = xtemp;\n            iteration = iteration + 1;\n        }\n        //float color = sin(float(iteration) / float(max_iteration)); //palette[iteration]\n        //fragColor = vec4(color);\n        float pct = (float(iteration) / float(max_iteration)) + (iTime / 400.0);\n        fragColor = vec4(sin(mix(0.0, 125.664, pct)),sin(mix(0.0, 125.664, pct + 0.33)),sin(mix(0.0, 125.664, pct + 0.66)),1.0);\n    }\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlcD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 271], [273, 273, 330, 330, 2259]], "test": "valid"}
{"id": "XdlcR4", "name": "Shadows___", "author": "hexointed", "description": "description", "tags": ["shadows"], "likes": 2, "viewed": 449, "published": "Public API", "date": "1487255360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float epsilon = 0.0001;\nvec3 light;\n\nfloat scene(vec3, inout int);\nbool march (out vec3, in vec3, in vec3, inout int);\nvec3 calc_gradient(in vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light = vec3(2.0 * sin(iTime), 2.0 * cos(iTime), 0.0)/1.5;\n\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 cameraFocalPoint = cameraPosition - vec3(0.0, 0.0, 1.0);\n    cameraPosition.xy += (fragCoord.xy - iResolution.xy/2.0) / iResolution.xx;\n\n    vec3 hitPosition;\n    int id = 1;\n    \n    bool hit = march(hitPosition, cameraPosition, cameraPosition - cameraFocalPoint, id);\n    \n    if(!hit) {\n        fragColor*=0.0;\n        return;\n    }\n    \n    if(id == 0){\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    \treturn;\n    }\n    if(id == 1) fragColor = vec4 (1.0, 0.0, 0.0, 1.0);\n    if(id == 2) fragColor = vec4 (1.0, 1.0, 1.0, 1.0);\n    if(id == 3) fragColor = vec4 (0.0, 1.0, 1.0, 1.0);\n    if(id == 4) fragColor = vec4 (0.0, 0.0, 1.0, 1.0);\n\n    \n    vec3 normal = normalize(calc_gradient(hitPosition));\n    vec3 lm = normalize(light - hitPosition);\n    vec3 rm = normalize(2.0 * dot(lm, normal) * normal - lm);\n    vec3 v = normalize(cameraPosition - hitPosition);\n    \n    vec3 lightEnd;\n    int occId;\n    \n    march(lightEnd, hitPosition + 2.0*lm*epsilon + 2.0*normal*epsilon, lm, occId);\n    \n    vec3 lightcoefficient = vec3(0.12, 0.12, 0.12);\n    \n    if(length(lightEnd-light) < 0.2 || false) {\n\t\tlightcoefficient += \n            0.35 * dot(lm, normal) + \n            0.4 * pow(clamp(dot(rm, v),0.0,1.0), 4.0);\n    }\n    \n    fragColor.xyz *= lightcoefficient;\n}\n\nfloat max3(float a, float b, float c) {\n    return max(a, max(b, c));\n}\n\nvec3 calc_gradient(vec3 p) {\n    vec3 delta = vec3(epsilon, 0.0, 0.0);\n    int id;\n \treturn normalize(vec3 (\n        (scene(p + delta.xyz,id) - scene(p,id))/ epsilon, \n        (scene(p + delta.yxz,id) - scene(p,id))/ epsilon, \n        (scene(p + delta.zyx,id) - scene(p,id))/ epsilon\n   \t));\n    \n}\n\nbool march(out vec3 endPosition, in vec3 startPosition, in vec3 direction, inout int id) {\n    \n    vec3 mdir = normalize(direction);\n    endPosition = startPosition;\n    \n    for(int i = 0; i < 400; i++) {\n        float distance = scene(endPosition,id);\n        \n        if(distance < epsilon)\n            return true;\n        \n        if(distance > 1000.0)\n            return false;\n        \n        endPosition += distance * mdir;\n    }\n    \n    return false;\n    \n}\n\nfloat scene (vec3 p, inout int id) {\n\tfloat s1 = length(p) - 0.5;\n    float s2 = length(p - vec3(1.0 * sin(-iTime*0.3), 2.0*cos(iTime*0.3), 0.0)) - 0.2;\n    float l = length(p-light)-0.05;\n    float b = max(abs(p.x - 2.0), max(abs(p.y),abs(p.z))) - 0.5;\n    float c = max3(\n    \tabs(p.x + 2.0) - 0.4,\n    \tabs(p.y - 0.0) - 2.0,\n    \tabs(p.z - 0.0) - 4.0\n    );\n    \n    if (l < s1 && l < s2 && l < b && l < c) id = 0;\n    else if(s1 < s2 && s1 < b && s1 < c) id = 1;\n    else if(s2 < b && s2 < c) id = 2;\n    else if(b < c) id = 3;\n    else id = 4;\n    \n    return min(s1,min(s2,min(l,min(b,c))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 212, 212, 1603], [1605, 1605, 1644, 1644, 1676], [1678, 1678, 1706, 1706, 1976], [1978, 1978, 2068, 2068, 2447], [2449, 2449, 2485, 2485, 3048]], "test": "error"}
{"id": "Xdlczn", "name": "svg mapper / Earth", "author": "FabriceNeyret2", "description": "svg textured on the sphere.\nTry larger N for real splines if your GPU&compiler allows. (more compilation time, longer shader).", "tags": ["bezier", "map", "world", "svg"], "likes": 6, "viewed": 747, "published": "Public API", "date": "1486742972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\n#define N 1.  // splines discretization. Lower it on slow GPUs\n// absolute main SVG commands\n#define M(x,y)             x0 = _x = x;   y0 = _y = y;\n#define L(x,y)             d = min(d, line(uv, vec2(_x,_y), vec2(x,y)) ); _x=x,_y=y;\n#define C(x1,y1,x2,y2,x,y) d = min(d, bezier(uv, vec2(_x,_y), vec2(x1,y1),vec2(x2,y2), vec2(x,y)) ); _x=x,_y=y; \n#define H(x)               d = min(d, line(uv, vec2(_x,_y), vec2(x,_y)) ); _x=x;\n#define V(y)               d = min(d, line(uv, vec2(_x,_y), vec2(_x,y)) ); _y=y;\n#define Z                  d = min(d, line(uv, vec2(_x,_y), vec2(x0,y0)) );\n// relative main SVG commands\n#define m(x,y)             M(_x+x,_y+y)\n#define l(x,y)             L(_x+x,_y+y)\n#define c(x1,y1,x2,y2,x,y) C(_x+x1,_y+y1,_x+x2,_y+y2,_x+x,_y+y)\n#define h(x)               H(_x+x)\n#define v(y)               V(_y+y)\n#define z                  Z\n\n#define style(f,c)         fill=f; S=1.; COL = mod(vec4((c)/65536,(c)/256,c,1),256.)/255.;\n#define path(cmd)          d = 1e38; cmd; draw(d,O);\n#define path1(cmd)         d = 1e38; cmd;                // to overcome compiler overflow\n#define path2(cmd)                   cmd; draw(d,O);\n\nfloat bezier(vec2,vec2,vec2,vec2,vec2);\nfloat line(vec2,vec2,vec2);\nvoid  draw(float,inout vec4);\nconst float FILL=1., CONTOUR=0.;\nvec4 COL = vec4(0); float fill=FILL, S=1., contrast=1.;  // style state\nfloat d = 1e38;   // global to allow unique distance field\n\n// === SVG drawing ===============================================================\nvoid SVG(vec2 uv, inout vec4 O) \n{\n    int _x, _y, x0, y0; // <><><> int  just for this svg file (coords are all ints)\n\n    uv.y -= .1;\n    uv *= 2500.;                         // scaling\n   //contrast = 1./10.; // <><><> set in main\n    \n// Copy-paste your SVG pathes here.  Slight adaptations : \n//  - add () around command params and  comma between points, \n//  - split polylines and polybéziers into sets of 1 vs 3 pairs of coordinates\n//  - path( style( FILL/CONTOUR, color(hexa) )\n//          commands \n//        )    \n\n// converted from http://www.clipartpanda.com/clipart_images/worldmap-gif-6189430\n// using http://www.online-convert.com/\n\npath( style( FILL, 0x000000)\n    M( 880, 2045)\n    c( 7, -8, 24, -15, 39, -15)\n    c( 14, 0, 50, -16, 78, -35)\n    c( 29, -19, 57, -35, 63, -35)\n    c( 5, 0, 10, -6, 10, -13)\n    c( 0, -20, 71, -84, 101, -91)\n    c( 23, -5, 26, -3, 22, 18)\n    c( -6, 28, 24, 75, 47, 76)\n    c( 9, 0, 5, 6, -10, 15)\n    c( -19, 11, -21, 14, -7, 15)\n    c( 14, 0, 13, 5, -10, 30)\n    c( -14, 17, -34, 30, -44, 30)\n    c( -10, 0, -21, 5, -24, 10)\n    c( -4, 6, -62, 10, -142, 10)\n    c( -119, 0, -134, -2, -123, -15)\n    z\n)\n\npath( style( FILL, 0x000000)\n    M( 220, 1991)\n    c( -26, -4, -36, -12, -38, -28)\n    c( -2, -16, -11, -23, -35, -25)\n    c( -27, -2, -32, -7, -30, -26)\n    c( 2, -18, -5, -26, -30, -37)\n    l( -32, -14)\n    l( 25, -10)\n    c( 18, -7, 20, -10, 8, -10)\n    c( -10, -1, -18, -5, -18, -11)\n    c( 0, -5, -12, -17, -27, -25)\n    c( -31, -18, -36, -18, 55, 5)\n    c( 19, 4, 41, 15, 51, 24)\n    c( 10, 9, 26, 16, 37, 16)\n    c( 11, 0, 25, 5, 31, 11)\n    c( 15, 15, 90, -25, 99, -53)\n    c( 4, -13, 18, -40, 32, -61)\n    l( 25, -38)\n    l( -17, -50)\n    c( -21, -57, -15, -135, 14, -171)\n    c( 24, -31, 51, -98, 44, -109)\n    c( -3, -5, 1, -9, 9, -9)\n    c( 8, 0, 20, -13, 27, -30)\n    c( 7, -16, 16, -30, 20, -30)\n    c( 5, 0, -4, 26, -20, 58)\n    c( -15, 31, -26, 61, -23, 65)\n    c( 5, 7, 19, -15, 55, -83)\n    c( 7, -14, 18, -29, 25, -35)\n    c( 6, -5, 16, -28, 22, -51)\n    c( 9, -35, 18, -44, 64, -67)\n    c( 29, -15, 60, -27, 69, -27)\n    c( 10, 0, 34, -11, 54, -25)\n    c( 20, -14, 45, -25, 56, -25)\n    c( 11, 0, 18, -6, 16, -14)\n    c( -5, -24, 63, -78, 89, -71)\n    c( 43, 10, 59, -72, 20, -105)\n    c( -21, -18, -41, -80, -25, -80)\n    c( 6, 0, 4, -8, -5, -18)\n    c( -18, -20, -22, -42, -9, -42)\n    c( 5, 0, 27, -36, 51, -81)\n    c( 23, -44, 54, -91, 68, -103)\n    l( 25, -22)\n    l( -12, -85)\n    c( -7, -46, -16, -106, -19, -134)\n    c( -4, -27, -15, -68, -25, -90)\n    c( -12, -28, -16, -53, -12, -85)\n    c( 4, -33, 2, -52, -9, -65)\n    c( -16, -22, -19, -63, -7, -82)\n    c( 5, -9, 16, -4, 36, 17)\n    c( 15, 17, 32, 30, 38, 30)\n    c( 6, 0, 8, 6, 5, 14)\n    c( -3, 7, 5, 24, 17, 37)\n    c( 12, 13, 23, 28, 24, 32)\n    c( 3, 16, 61, 57, 81, 57)\n    c( 11, 0, 25, 9, 31, 20)\n    c( 7, 14, 7, 20, 0, 20)\n    c( -5, 0, -10, 5, -10, 11)\n    c( 0, 6, 9, 8, 20, 4)\n    c( 31, -10, 60, 4, 60, 28)\n    c( 0, 16, 3, 18, 9, 9)\n    c( 6, -10, 17, -2, 40, 33)\n    c( 17, 25, 29, 51, 26, 56)\n    c( -6, 9, 56, 69, 81, 79)\n    c( 17, 7, 86, 109, 80, 119)\n    c( -8, 12, 23, 72, 51, 98)\n    c( 37, 35, 31, 77, -14, 108)\n    c( -21, 14, -50, 25, -66, 25)\n    c( -16, 0, -36, 7, -45, 16)\n    c( -11, 11, -27, 15, -54, 11)\n    c( -42, -6, -43, -5, -27, 25)\n    c( 21, 40, -26, 88, -86, 88)\n    c( -16, 0, -25, 6, -25, 16)\n    c( 0, 8, -11, 30, -25, 48)\n    c( -24, 31, -28, 33, -90, 32)\n    c( -47, -1, -68, -5, -75, -16)\n    c( -8, -12, -10, -11, -10, 8)\n    c( 0, 12, -4, 22, -8, 22)\n    c( -14, 0, -53, -46, -45, -53)\n    c( 3, -4, -1, -7, -11, -7)\n    c( -9, 0, -14, 5, -11, 10)\n    c( 4, 6, -6, 10, -24, 10)\n    c( -53, 0, -61, 8, -61, 61)\n    c( 0, 48, 0, 49, -31, 49)\n    l( -32, 0)\n    l( 6, 50)\n    c( 5, 44, 4, 50, -13, 50)\n    c( -10, 0, -22, -9, -25, -20)\n    c( -5, -15, -15, -20, -39, -20)\n    c( -31, 0, -34, 3, -40, 38)\n    c( -10, 61, -7, 127, 7, 144)\n    c( 8, 11, 37, 18, 95, 22)\n    l( 82, 6)\n    l( 0, -28)\n    c( 0, -29, 24, -72, 34, -61)\n    c( 3, 3, 2, 20, -4, 37)\n    c( -7, 27, -4, 42, 21, 90)\n    c( 16, 31, 33, 62, 39, 69)\n    c( 5, 7, 10, 17, 10, 22)\n    c( 0, 5, 11, 18, 25, 29)\n    c( 14, 11, 25, 25, 25, 31)\n    c( 0, 10, 37, 24, 56, 20)\n    c( 22, -4, 22, 3, -1, 27)\n    c( -21, 23, -27, 25, -40, 14)\n    c( -14, -12, -15, -11, -4, 13)\n    c( 10, 22, 19, 27, 50, 27)\n    c( 53, 0, 73, 9, 58, 26)\n    c( -6, 8, -15, 11, -20, 8)\n    c( -5, -3, -9, 2, -9, 10)\n    c( 0, 9, -6, 16, -14, 16)\n    c( -7, 0, -25, 12, -40, 27)\n    c( -21, 21, -29, 24, -36, 14)\n    c( -10, -17, -40, -7, -40, 12)\n    c( 0, 10, -58, 47, -74, 47)\n    c( -2, 0, -2, -34, 0, -76)\n    c( 3, -72, 2, -75, -19, -72)\n    c( -14, 2, -23, 11, -25, 26)\n    c( -3, 17, -10, 22, -35, 22)\n    c( -64, 0, -74, 7, -70, 53)\n    c( 2, 25, -2, 44, -9, 49)\n    c( -8, 5, -1, 8, 20, 8)\n    c( 21, 0, 32, 5, 32, 14)\n    c( 0, 8, 14, 17, 30, 21)\n    c( 35, 8, 32, 24, -4, 18)\n    c( -16, -3, -31, 2, -46, 17)\n    c( -17, 17, -24, 19, -31, 9)\n    c( -4, -7, -5, -17, -3, -21)\n    c( 3, -4, -29, -8, -71, -8)\n    c( -44, 0, -74, 4, -70, 9)\n    c( 3, 5, -3, 12, -12, 15)\n    c( -16, 5, -308, 38, -308, 35)\n    c( 0, -1, -16, -4, -35, -8)\n    z\n)\n\n\npath1( style( FILL, 0x000000)\n    M( 3110, 1985)\n    c( -19, -7, -52, -16, -73, -20)\n    c( -24, -4, -35, -10, -31, -17)\n    c( 5, -7, 1, -9, -9, -5)\n    c( -12, 5, -17, 1, -17, -13)\n    c( 0, -11, 6, -20, 14, -20)\n    c( 35, 0, 20, -15, -17, -18)\n    c( -27, -1, -37, 1, -28, 7)\n    c( 8, 5, 11, 16, 6, 30)\n    c( -6, 21, -8, 21, -24, 7)\n    c( -10, -9, -33, -16, -52, -16)\n    c( -45, -1, -115, -16, -162, -37)\n    c( -35, -15, -39, -15, -54, 0)\n    c( -15, 15, -14, 16, 20, 10)\n    c( 51, -8, 48, 13, -5, 37)\n    c( -60, 27, -90, 25, -167, -14)\n    c( -36, -18, -84, -41, -106, -50)\n    c( -23, -10, -46, -26, -53, -37)\n    c( -11, -16, -9, -19, 9, -19)\n    c( 16, 0, 19, -4, 14, -20)\n    c( -8, -26, 8, -26, 44, 1)\n    c( 42, 31, 71, 7, 34, -29)\n    c( -12, -13, -31, -16, -85, -13)\n    c( -59, 2, -74, -1, -112, -23)\n    c( -25, -14, -56, -26, -70, -26)\n    c( -14, 0, -26, -4, -26, -10)\n    c( 0, -5, -10, -10, -21, -10)\n    c( -19, 0, -20, -2, -8, -16)\n    c( 11, -14, 10, -19, -11, -36)\n    c( -13, -10, -33, -18, -44, -17)\n    c( -36, 2, -42, 0, -64, -30)\n    c( -25, -34, -20, -71, 10, -71)\n    c( 23, 0, 88, 37, 88, 50)\n    c( 0, 4, 8, 10, 18, 13)\n    c( 9, 3, 41, 14, 69, 25)\n    l( 53, 20)\n    l( 30, -34)\n    c( 16, -19, 30, -40, 30, -46)\n    c( 0, -7, 6, -3, 14, 8)\n    c( 13, 17, 12, 21, -10, 42)\n    c( -27, 26, -24, 43, 6, 35)\n    c( 21, -6, 44, -68, 42, -110)\n    c( -1, -14, 4, -23, 13, -23)\n    c( 10, 0, 15, 10, 15, 29)\n    c( 0, 31, 23, 57, 40, 46)\n    c( 7, -4, 10, -15, 7, -25)\n    c( -8, -33, 11, -51, 48, -44)\n    c( 47, 9, 58, -1, 38, -34)\n    c( -10, -15, -23, -31, -30, -37)\n    c( -6, -5, -13, -19, -16, -30)\n    c( -4, -19, -5, -19, -6, 1)\n    c( -1, 19, -9, 22, -67, 27)\n    c( -39, 4, -74, 2, -86, -4)\n    c( -25, -13, -104, 29, -100, 53)\n    c( 4, 24, -25, 29, -133, 24)\n    c( -85, -5, -102, -9, -132, -31)\n    c( -73, -57, -183, -214, -183, -264)\n    c( 0, -7, -9, -28, -20, -45)\n    l( -19, -32)\n    l( 36, -71)\n    c( 22, -44, 45, -75, 60, -82)\n    c( 29, -13, 107, -14, 150, -2)\n    c( 24, 7, 41, 6, 62, -5)\n    c( 45, -22, 55, -39, 43, -73)\n    c( -9, -25, -6, -35, 16, -67)\n    c( 25, -37, 27, -45, 28, -174)\n    c( 1, -134, 8, -180, 49, -289)\n    c( 29, -78, 31, -81, 83, -81)\n    c( 41, 0, 53, 5, 90, 39)\n    c( 32, 29, 42, 46, 42, 69)\n    c( 0, 21, 6, 32, 19, 37)\n    c( 13, 4, 20, 19, 25, 53)\n    c( 5, 37, 14, 56, 41, 82)\n    c( 49, 47, 62, 91, 40, 136)\n    c( -26, 56, -7, 95, 93, 188)\n    c( 23, 22, 42, 44, 42, 50)\n    c( 0, 6, 11, 35, 25, 64)\n    l( 24, 52)\n    l( -23, 0)\n    c( -90, 0, -119, 25, -161, 139)\n    c( -39, 105, -47, 180, -18, 177)\n    c( 18, -1, 36, -39, 48, -104)\n    c( 6, -31, 59, -169, 69, -180)\n)\npath2(   // to overcome out of memory when compiling macro\n    c( 2, -1, 25, 9, 51, 23)\n    c( 26, 14, 53, 25, 59, 25)\n    c( 14, 0, 96, 76, 96, 89)\n    c( 0, 6, -11, 27, -25, 47)\n    c( -14, 20, -25, 32, -25, 25)\n    c( 0, -6, -11, -11, -25, -11)\n    c( -14, 0, -25, 5, -25, 11)\n    c( 0, 5, -4, 8, -9, 4)\n    c( -14, -8, -31, 28, -31, 64)\n    c( 0, 41, 22, 40, 41, -1)\n    c( 10, -24, 22, -34, 42, -36)\n    c( 15, -2, 27, -8, 27, -13)\n    c( 0, -5, 12, -9, 28, -9)\n    c( 75, 0, 100, -11, 128, -56)\n    c( 16, -24, 34, -44, 41, -44)\n    c( 7, 0, 15, -12, 19, -27)\n    c( 13, -59, 16, -70, 36, -125)\n    c( 23, -66, 43, -74, 52, -23)\n    c( 4, 19, 11, 35, 16, 35)\n    c( 6, 0, 10, 9, 10, 20)\n    c( 0, 11, 16, 34, 35, 51)\n    c( 19, 17, 37, 39, 40, 50)\n    c( 4, 10, 17, 22, 30, 25)\n    c( 18, 4, 31, -3, 59, -33)\n    c( 19, -21, 36, -46, 36, -55)\n    c( 0, -11, 8, -18, 20, -18)\n    c( 24, 0, 35, -35, 27, -90)\n    c( -3, -27, -1, -43, 10, -51)\n    c( 8, -7, 24, -31, 36, -53)\n    c( 22, -41, 22, -41, 25, -13)\n    c( 2, 20, -5, 38, -28, 63)\n    c( -26, 30, -30, 41, -24, 68)\n    c( 3, 17, 8, 33, 9, 34)\n    c( 5, 6, 65, -41, 65, -50)\n    c( 0, -14, 22, -8, 36, 10)\n    c( 21, 27, 16, 56, -15, 100)\n    c( -28, 38, -29, 41, -13, 56)\n    c( 10, 8, 26, 14, 37, 14)\n    c( 34, -3, 101, 50, 129, 101)\n    l( 26, 48)\n    l( -30, 54)\n    c( -21, 39, -26, 57, -18, 66)\n    c( 8, 10, 3, 14, -21, 19)\n    c( -34, 7, -50, 22, -34, 33)\n    c( 5, 3, 15, 15, 21, 26)\n    c( 11, 19, 11, 19, 12, -2)\n    c( 0, -18, 6, -23, 25, -23)\n    c( 14, 0, 25, -4, 25, -8)\n    c( 0, -15, 58, -77, 65, -70)\n    c( 4, 4, -3, 23, -15, 43)\n    c( -25, 41, -21, 85, 8, 85)\n    c( 10, 0, 31, 13, 46, 29)\n    l( 29, 30)\n    l( 19, -22)\n    l( 19, -22)\n    l( -10, 22)\n    c( -6, 12, -11, 30, -11, 39)\n    c( 0, 18, -47, 74, -62, 74)\n    c( -5, 0, -4, -10, 2, -22)\n    c( 9, -18, 6, -17, -10, 5)\n    c( -12, 15, -30, 27, -40, 27)\n    c( -18, 0, -37, 46, -25, 59)\n    c( 4, 3, 32, 6, 63, 5)\n    c( 41, 0, 60, 4, 69, 15)\n    c( 10, 14, 15, 12, 42, -13)\n    c( 17, -17, 31, -37, 31, -47)\n    c( 0, -9, 17, -32, 38, -50)\n    c( 35, -31, 37, -32, 40, -11)\n    c( 2, 15, -8, 31, -32, 53)\n    c( -20, 17, -36, 34, -36, 38)\n    c( 0, 4, 16, 13, 35, 20)\n    c( 35, 12, 46, 35, 23, 44)\n    c( -7, 3, 3, 3, 22, 0)\n    c( 32, -5, 34, -4, 19, 11)\n    c( -9, 10, -45, 21, -85, 28)\n    c( -38, 5, -80, 16, -94, 23)\n    c( -16, 8, -46, 11, -81, 8)\n    c( -42, -4, -75, 1, -125, 17)\n    c( -38, 12, -73, 26, -79, 31)\n    c( -13, 13, -78, 11, -70, -1)\n    c( 8, -13, -138, -13, -151, 0)\n    c( -6, 6, -29, 11, -52, 13)\n    c( -32, 1, -42, 6, -42, 20)\n    c( 0, 21, -30, 22, -80, 2)\n    z\n)\n\n    \npath( style( FILL, 0x000000)\n    M( 3852, 795)\n    c( 6, -14, 17, -25, 24, -25)\n    c( 7, 0, 31, -18, 53, -39)\n    c( 40, -38, 92, -67, 77, -42)\n    c( -4, 6, -2, 11, 4, 11)\n    c( 19, 0, 60, -32, 60, -46)\n    c( 0, -8, 9, -14, 20, -14)\n    c( 25, 0, 25, 11, -1, 44)\n    c( -12, 16, -16, 26, -8, 26)\n    c( 22, 0, -24, 41, -75, 67)\n    c( -26, 13, -53, 22, -60, 20)\n    c( -6, -3, -20, 1, -31, 9)\n    c( -10, 8, -31, 14, -47, 14)\n    c( -26, 0, -27, -2, -16, -25)\n    z\n)\n\npath( style( FILL, 0x000000)\n    M( 3820, 606)\n    c( 0, -9, -4, -16, -10, -16)\n    c( -5, 0, -10, -10, -10, -22)\n    c( -1, -23, -1, -23, -16, -3)\n    c( -15, 20, -15, 20, -35, -5)\n    c( -10, -14, -22, -34, -25, -46)\n    c( -3, -11, -21, -28, -39, -38)\n    c( -19, -11, -42, -27, -51, -38)\n    c( -22, -23, -25, -81, -7, -132)\n    c( 7, -21, 13, -50, 13, -63)\n    c( 0, -22, 3, -25, 28, -19)\n    c( 15, 3, 43, 9, 62, 12)\n    c( 19, 4, 43, 13, 52, 21)\n    c( 20, 17, 73, 10, 100, -14)\n    c( 15, -13, 20, -14, 34, -2)\n    c( 14, 11, 16, 10, 14, -6)\n    c( -1, -11, 1, -31, 5, -44)\n    c( 7, -21, 12, -23, 63, -19)\n    c( 46, 4, 60, 10, 83, 36)\n    c( 39, 44, 54, 105, 38, 155)\n    c( -7, 21, -18, 41, -25, 45)\n    c( -14, 8, -64, 109, -64, 129)\n    c( 0, 7, -9, 27, -19, 44)\n    l( -19, 32)\n    l(-7, -46)\n    c( -8, -55, -27, -65, -66, -35)\n    c( -23, 18, -28, 29, -24, 51)\n    c( 3, 21, 1, 27, -13, 27)\n    c( -9, 0, -27, 3, -39, 6)\n    c( -17, 5, -23, 2, -23, -10)\n    z\n)    \n\n}\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t)\n{\n    vec2 A = G4-G1 + 3.*(G2-G3),\n         B = 3.*(G1-2.*G2+G3),\n         C = 3.*(G2-G1),\n         D = G1;\n    return t * (t * (t * A + B) + C) + D;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) \n{\n\tvec2 pa = p-a, ba = b-a,\n\t     d = pa - ba * clamp(dot(pa, ba) / dot(ba, ba) , 0., 1.); // distance to segment\n    if  ( (a.y>p.y) != (b.y>p.y) &&\n           pa.x < ba.x * pa.y / ba.y ) S = -S;     // track interior vs exterior.\n\treturn dot(d,d); //length(d);                  // optimization by deferring sqrt\n}\n// interior detection (sign S): ( thanks TimoKinnunen https://www.shadertoy.com/view/4lySWd )\n// see http://web.archive.org/web/20161116163747/https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html - previously on https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\nfloat bezier( vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D)    \n{\n    //float d = 1e5;                               // for global field\n    vec2 p = A;\n    for (float t = 1.; t <= N; t++) {\n        vec2 q = interpolate(A, B, C, D, t/N);\n        float l = line(uv, p, q);\n        d = min(d, l );\n\t\tp = q;\n\t}\n    // line(uv, p, D); // explicit last segment to avoid approx (and thus leaks) ?\n\treturn d;\n}\n\nvoid draw(float d, inout vec4 O) \n{\n    d = min(sqrt(d)*contrast,1.);                // optimization by deferring sqrt here\n    O = mix(COL, O, fill>0. ? .5+.5*S*d : d);    // paint \n}\n\n\n// sphere mapping from https://www.shadertoy.com/view/XstXzs\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = vec4(1);\n  //SVG( U/R.x*1.78, O ); return;                // display map\n    \n    float t = iTime-1.2,y,g,\n        zoom = exp2(2.*sin(t));  // zoom = 1.;\n    U = (U+U-R) / R.y *zoom;  \n    U.x = .5*acos( U.x / sin( U.y = -acos(U.y) )) - t; // longitude / lattitude\n    contrast = R.y/2e3/zoom;\n    SVG(vec2(0,-.15)+vec2(1.78,1.2)*fract(U/3.14),O);  // map\n  //vec2 V = step(.995,cos(8.*U)); O -= V.x+V.y;     // debug: show longitude/lattitude\n    // Earth color\n    #define SQR(x) ((x)*(x))\n    y = abs(-U.y/1.57-1.); g = smoothstep(.03,.0,SQR(y-.27));\n    O = mix(vec4(sqrt(g),.6,0,1),vec4(0,0,1,0), O);\n  //O += step(.8,y);\n    // clouds\n#define T(U)   2.*texture(iChannel0,vec2(1,2)/2.*(U)/3.14).r \n    O = mix(O,vec4(1), T(U)*T(2.*U)*T(4.*U)*T(8.*U))\n        + 1e-5/U.x;                      // trick for black background\n // O = mix(O,vec4(1), (T(U)+.5*T(2.*U)+.25*T(4.*U))/2.);\n}\n\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdlczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1511, 1594, 1628, 1628, 13548], [13549, 13640, 13703, 13703, 13853], [13855, 13855, 13892, 13892, 14206], [14207, 14511, 14571, 14642, 14909], [14911, 14911, 14946, 14946, 15095], [15098, 15159, 15197, 15197, 16121]], "test": "error"}
{"id": "XdlyR4", "name": "Sp", "author": "Bas1ck", "description": "Raymarch", "tags": ["spheres"], "likes": 0, "viewed": 71, "published": "Public", "date": "1487249923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float epsilon = 0.001;\nfloat sphere_r = 0.20;\nvec3 sphere_c = vec3(0.9,0.5,0.5);\nvec3 point_behind_screen = vec3 (0.9,0.5,-2.0); \nfloat z = 0.0;\nvec3 camera_pos = vec3(0.0,0.0,-3.0);\n\n\nfloat SDF(vec3 p, inout int id){\n    vec3 sphere_c2 = vec3(0.1 + cos(iTime),0.35, 3.5 + 3.8*sin(iTime));\n    float c1 = length(p - sphere_c) - sphere_r;\n    float c2 = length(p - sphere_c - sphere_c2) - sphere_r;\n    \n    if(c1 < c2){ \n        id = 0;\n    }\n    else{ \n        id = 1;\n    }\n    \n    return min(c1,c2);\n}\n\nvec3 calc_gradient (in vec3 p){\n    int id;\n    return normalize (vec3((SDF(vec3(p.x+epsilon,p.y,p.z),id) - SDF(vec3(p.x,p.y,p.z),id))/epsilon, \n             (SDF(vec3(p.x,p.y + epsilon,p.z),id) - SDF(vec3(p.x,p.y,p.z),id))/epsilon, \n             (SDF(vec3(p.x,p.y,p.z + epsilon),id) - SDF(vec3(p.x,p.y,p.z),id))/epsilon));\n}\n\n\nbool ray_march(in vec3 start, in vec3 dir, out vec3 end, inout int id){\n    end = start;\n    \n    for(int i = 0; i < 200; i++){\n    \t\n        float dist_to_object = SDF(end,id);\n        \n        if(dist_to_object < epsilon){\n            return true;\n        }\n        \n        if(dist_to_object > 1000.0){\n            return false;\n        }\n        \n        end += dist_to_object * dir;\n        \n    }\n    return false;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light_point = vec3(2.0*sin(iTime),0.5,2.0*cos(iTime));\n    vec2 screen = fragCoord/iResolution.y;\n    vec3 point_on_screen = vec3(screen,z);\n    vec3 end;\n\tvec3 point_dir = normalize (point_on_screen - point_behind_screen);\n    int id = 1;\n    \n    if(!ray_march(point_on_screen, point_dir,end,id)){\n        fragColor = vec4(0.0,0.0,0.0,0.1);\n        return;\n    }\n    \n    if(id == 0)\n    \tfragColor = vec4 (0.0, 0.0, 0.1, 1.0);\n    if(id == 1)\n        fragColor = vec4 (0.1, 0.0, 0.1, 1.0);\n    \n    vec3 lm = normalize (light_point - end) ;\n\tvec3 normal = normalize (calc_gradient(end));\n\tvec3 rm = normalize (2.0 * dot(lm , normal) * normal-lm);\n    vec3 v = normalize (camera_pos - point_on_screen); \n    fragColor.xyz += vec3(0.1, 0.1, 0.1) +\n        0.3 * dot(lm, normal) +\n        0.4 * pow(clamp(dot(rm, v),0.0,1.0), 10.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 217, 217, 505], [507, 507, 538, 538, 832], [835, 835, 906, 906, 1257], [1261, 1261, 1318, 1318, 2167]], "test": "valid"}
{"id": "XdlyRN", "name": "Gear Revolute 2", "author": "aiekick", "description": "click for see the cut section", "tags": ["2", "gear", "revolute"], "likes": 5, "viewed": 470, "published": "Public API", "date": "1487270725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.14159 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat gear(vec2 p)\n{\n\tfloat r = min(max(.5 * (cos(atan(p.x, p.y) * 16.)) + 0.9, 0.4), .6);\n\treturn length(p) - .9 - r;\n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz) + iTime;\n    \n    vec2 rev = vec2(\n        max(max(abs(p.x*.866 - p.z*.5), abs(-p.x*.866 - p.z*.5)), abs(p.z)), // 2d hex\n            p.y) - 2.5;\n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n\tvec2 res = vec2(abs(gear(rev))-0.032, 0);\n    if (iMouse.z > 0.)\n\t\tif (p.z-1. > res.x) \n            res = vec2(p.z-1., 1);\n\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,2);\n\t\t\n\treturn res; \n\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tvec2 camp = vec2(.73,.37) * 5.;\n\tvec3 rayOrg = vec3(cos(1.57),sin(camp.y),sin(1.57)) * camp.x * 2.;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.2,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e5)>0. || d>dMax) break;\n\t\ts = df(p).x;\n\t\td += s * 0.2;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 263, 287, 287, 365], [367, 367, 387, 387, 487], [489, 489, 506, 506, 940], [942, 942, 974, 974, 1152], [1154, 1170, 1244, 1244, 1483], [1485, 1501, 1543, 1543, 1842], [1844, 2039, 2096, 2096, 2384], [2386, 2386, 2443, 2443, 3899]], "test": "valid"}
{"id": "XdlyzN", "name": "Odecee Demo", "author": "rubixcom", "description": "ShaderToy demo", "tags": ["raymarching", "simple"], "likes": 1, "viewed": 101, "published": "Public", "date": "1487284296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat map(vec3 p)\n{\n   float len=1.45;\n   float thick=.1;\n   float rad=.3;\n    p.z = p.z + .4 * p.y;\n  return min(\n\tmin(udRoundBox(p, vec3(thick,thick,len), rad),\n\t\tudRoundBox(p+vec3(0.,len,0.), vec3(thick,thick,len), rad)),\n\tmin(udRoundBox(p+vec3(0.,0.+(len-8.*thick),0.-(len-8.*thick)), vec3(thick,len,thick), rad),\n\t\tudRoundBox(p+vec3(0.,0.+(len-8.*thick),len-(len-8.*thick)), vec3(thick,len,thick), rad)));\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n    return normalize( e.xyy*map( pos + e.xyy ) +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 cameraRay(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    float focalDistance = .8;\n    return (normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix) * .5;\n}\n\n\nvec4 shade(in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec4 lightColor, in vec4 surface)\n{\n    vec3 light = normalize(lightPos - pos);\n    float diffuse = -dot(normal, -cameraVector);\n    return mix(surface, vec4(1.), diffuse * 20. / length(pos));\n}\n\nvec4 march(in vec3 ro, in vec3 rd, vec3 shapeLoc, vec3 light)\n{\n\n    vec4 color = vec4(118.0,195.0,101.0,255.0) / vec4(255.); // Sky color\n\n    float t = 0.0;\n    const int maxSteps = 110;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n\n        vec3 po = p + vec3(0.0,8.0*iTime, 5.*(p.z - mod(p.z, 8.)));\n\n        float ang = iTime+20.*(length(po)-mod(length(po),8.));\n        float scale = 1.;\n        mat3 rotation = mat3(scale*cos(ang),-sin(ang), 0.,\n                  sin(ang),scale*cos(ang), 0.,\n                   0.,0.,scale);\n\n        vec3 pm = mod(po,8.0) - shapeLoc;\n\n        pm = rotation * pm;\n\n        float d = map(pm);\n        \n        if(d < 0.001)\n        {\n            vec3 normal = calcNormal(pm, t);\n            ang = -ang;\n            mat3 rotationI = mat3(cos(ang),-sin(ang), 0.,\n                  sin(ang),cos(ang), 0.,\n                   0.,0.,1.);\n            normal = rotationI * normal;\n\t\t\tcolor = shade(p, normal, -rd, light,\n                          vec4(1.), \n                          color);\n            break;\n        }\n\n        t += d;\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shapeLoc = vec3(3.0,3.0,3.0);\n    vec3 cameraLoc = vec3(4.0 * sin(0.6*iTime), 6.0 + 4.0 * sin(0.4*iTime) , 4.0) + shapeLoc;\n    vec3 cameraTarget = shapeLoc;// + vec3(0.0,1.+1.*sin(iTime*.01),0.0);\n    vec3 light = vec3(-1.);\n    \n    vec3 ro = cameraLoc;\n    vec3 rd = cameraRay(cameraLoc, cameraTarget, fragCoord);\n\n    fragColor = march(ro, rd, shapeLoc, light);\n}", "image_inputs": [{"id": "4sfGzn", "previewfilepath": "/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 85], [87, 87, 106, 106, 499], [501, 501, 545, 545, 736], [738, 738, 807, 807, 1292], [1295, 1295, 1413, 1413, 1572], [1574, 1574, 1637, 1637, 2698], [2700, 2700, 2757, 2757, 3134]], "test": "valid"}
{"id": "Xdsczr", "name": "Playing around with circles", "author": "kodde", "description": "Was inspired by a cool gif with similar growing circles where odd/even areas are visualized as 1/0.", "tags": ["circles", "pattern"], "likes": 2, "viewed": 202, "published": "Public", "date": "1486757528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTH_SHAPE_CONTOURS 1\n\n//Functions\nvec2 rotate2dVec(vec2 uv, float rotation)\n{\n    float cs = cos(rotation);\n\tfloat sn = sin(rotation);\n    \n    float px = uv.x * cs - uv.y * sn; \n\tfloat py = uv.x * sn + uv.y * cs;\n    \n    return vec2(px,py);\n}\n\nfloat drawSmoothCircle(vec2 uv, float distance, float rotation, float size, float smoothStepMin)\n{\n    vec2 circleCenter = rotate2dVec(uv,rotation) - vec2(0.0, distance);\n    float circleShape = 1.0 - smoothstep(smoothStepMin,1.0,length(circleCenter)*size);\n    \n    return circleShape;\n}\n\nfloat drawCircle(vec2 uv, float distance, float rotation, float size)\n{\n    vec2 circleCenter = rotate2dVec(uv,rotation) - vec2(0.0, distance);\n    float circleShape = 1.0 - min(floor(length(circleCenter)*size),1.0);\n    \n    return circleShape;\n}\n\n\nfloat smoothCheckIfOdd(float value)\n{\n    float result = abs(mod(value*0.5-0.5,1.0)-0.5)*2.0;\n    return result;\n}\n\n//This palette solution is from http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 colorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a+b*cos(6.28318530718*(c*t+d));\n}\n\n\n//Constants\nfloat myTime;\nfloat pi = 3.14159265358979323846264338327950288419716;\nfloat numCircles;\nfloat sinTime;\nfloat circleSize;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    myTime = iTime * 2.0;\n    numCircles = (floor((myTime+pi) * 0.5 * (1.0/(2.0*pi)))*2.0)+3.0;\n    sinTime = (sin(myTime*0.5)+1.0)*0.35;\n    circleSize = 1.0/sinTime;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centeredUv = uv - 0.5;\n    centeredUv.x *= iResolution.x/iResolution.y;\n    centeredUv = rotate2dVec(centeredUv,(sin(myTime)+myTime*1.5)*0.25);\n\n    float circlesResult;\n    float smoothStepMin = 1.0-0.002-circleSize*0.002;\n    \n    if(SMOOTH_SHAPE_CONTOURS==1)\n    {    \n        for(int i = 0; i < 48; i++)\n        {\n            if(i > int(numCircles))\n            {\n                break;\n            }\n            circlesResult += drawSmoothCircle(centeredUv, 0.45, ((pi*2.0)/min(numCircles+1.0,48.0))*float(i),circleSize, smoothStepMin);\n        }\n    }\n    else \n    {\n        for(int i = 0; i < 48; i++)\n        {\n            if(i > int(numCircles))\n            {\n                break;\n            }\n            circlesResult += drawCircle(centeredUv, 0.45, ((pi*2.0)/min(numCircles+1.0,48.0))*float(i),circleSize);\n        }\n    }\n    \n    circlesResult = smoothCheckIfOdd(circlesResult);\n\t\n    vec3 outColor = colorPalette(myTime*0.05 + length(centeredUv), vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67)) * circlesResult;\n    \n    fragColor = vec4(outColor,1.0);\n        \n}", "image_inputs": [{"id": "MlSGDc", "previewfilepath": "https://soundcloud.com/faders/faders-avalon-one", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/faders/faders-avalon-one", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdsczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 45, 88, 88, 255], [257, 257, 355, 355, 545], [547, 547, 618, 618, 794], [797, 797, 834, 834, 911], [913, 1002, 1077, 1077, 1119], [1122, 1256, 1313, 1313, 2650]], "test": "valid"}
{"id": "XdsyzN", "name": "-Burning Ship Fractal-", "author": "yumcyawiz", "description": "burning ship fractal", "tags": ["fractal"], "likes": 5, "viewed": 153, "published": "Public", "date": "1487285283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//MATLAB Jet Colormap\n//kbinani/glsl-colormap\n//https://github.com/kbinani/glsl-colormap/blob/master/LICENSE\nfloat colormap_red(float x) {\n    if (x < 0.7) {\n        return 4.0 * x - 1.5;\n    } else {\n        return -4.0 * x + 4.5;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 0.5) {\n        return 4.0 * x - 0.5;\n    } else {\n        return -4.0 * x + 3.5;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.3) {\n       return 4.0 * x + 0.5;\n    } else {\n       return -4.0 * x + 2.5;\n    }\n}\n\nvec4 colormap(float x) {\n    float r = clamp(colormap_red(x), 0.0, 1.0);\n    float g = clamp(colormap_green(x), 0.0, 1.0);\n    float b = clamp(colormap_blue(x), 0.0, 1.0);\n    return vec4(r, g, b, 1.0);\n}\n\n\n//math\nvec2 cmult(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x - z1.y*z2.y, z1.x*z2.y + z1.y*z2.x);\n}\n\n\nconst int maxIter = 300;\nfloat mandelbrot(vec2 c) {\n    vec2 z = vec2(0.0, 0.0);\n    vec2 zd = vec2(0.0, 0.0);\n    for(int i = 0; i < maxIter; i++) {\n        if(length(z) > 10.0) break;\n        zd = 2.0*cmult(z, zd) + vec2(1.0, 0.0);\n        vec2 za = vec2(abs(z.x), abs(z.y));\n        z = cmult(za, za) + c;\n    }\n    \n    float d = 0.5*length(z)*log(length(z))/length(zd);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = vec2(-1.75, -0.03);\n    float scale = 1.0/pow((0.01*float(iFrame)), 2.0);\n\tvec2 uv = -scale*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y + offset;\n    \n    float d = mandelbrot(uv);\n    float color = clamp(8.0*d/scale, 0.0, 1.0);\n    color = pow(color, 0.2);\n    \n\tfragColor = colormap(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 138, 138, 239], [241, 241, 272, 272, 373], [375, 375, 405, 405, 504], [506, 506, 530, 530, 710], [713, 720, 750, 750, 815], [843, 843, 869, 869, 1208], [1211, 1211, 1268, 1268, 1589]], "test": "valid"}
{"id": "XdXcRN", "name": "ncl01: Road Trip", "author": "cxw", "description": "Tokyo Demo Fest 2017 compo entry.  By cxw/Incline", "tags": ["compo", "tdf2017"], "likes": 0, "viewed": 462, "published": "Public API", "date": "1487177133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//tdf17.frag by cxw/incline.  CC-BY-SA 3.0\n//ncl01: Road Trip.  Released at Tokyo Demo Fest 2017.\n//This file is generated from tdf17.frag.in using perlpp.  DO NOT EDIT.\n//Use https://github.com/cxw42/perlpp/, branch 'defines'.\n\n\n\n// Reminder: OpenGL-style coord system: +X right, +Y up, +Z toward viewer\n// CONFIG CONSTANTS STRUCTS GLOBALS ///////////////////\n// {{{1\n\n\n#define LOADING_FREQ (0.2)\n\n#define S_SINE_FREQ (0.02380952380952380952380952380952)\n    // 1/42.  sine letter frequency in cycles per X unit.\n#define S_SINE_GROUP_FREQ (0.03125)\n    // 1/32.  sine group frequency.  If > S_SINE_FREQ, sine gradually\n    // shifts right on screen.\n#define CYL_RADIUS (15.0)\n    // radius of the cylinder for CYL and later parts\n#define TUNNEL_ACCEL (17.0)\n    // Acceleration during TUNNEL, in x units per sec^2\n#define CUBE_FADEIN_TIME (3.0)\n    //fadein in seconds\n\n#define TWOSIDED_RATE (0.3)\n    // how fast you go back and forth\n\n#define PI (3.1415926535897932384626433832795028841971)\n    // from memory :)\n#define PI_OVER_2 (1.5707963267948966192313216916398)\n#define PI_OVER_4 (0.78539816339744830961566084581988)\n#define THREE_PI_OVER_4 (2.3561944901923449288469825374596)\n#define TWO_PI (6.283185307179586)\n#define ONE_OVER_TWO_PI (0.15915494309644431437107064141535)\n    // not from memory :) :)\n\n#define TEE_ZERO (0.001)\n#define TEE_ONE (99999999999999999999.0)\n    // +Inf => 1.0/0.0 gives \"divide by zero during constant folding\" error\n\n#define LTR_Z_THICKNESS (1.0)\n    // in voxels\n#define EPS (0.000001)\n    // Arbitrary choice\n\n#define MAX_VOXEL_STEPS (60)\n    // Empirical - gives a nice disappearing effect at the edges on my\n    // test system\n#define MAX_DIST (100.0)\n\n// xport config\n#define XP_GAIN_HZ (3.0)\n\n#define XP_SHINE_LOW (6.0)\n#define XP_SHINE_HIGH (32.0)\n#define XP_SHINE_AIM (24.0)\n    // what it settles down to\n#define XP_SHINE_HZ (5.5)\n\n// Sinusoids across the u axis (horz)\n\n#define XP_H0_PER_U (30.00000000000000000000)\n    // cycles per screen width (u coordinate 0..1)\n#define XP_H0_PHASE (0.00000000000000000000)\n    // initial phase\n#define XP_H0_PHASE_PER_SEC (1.36590984938686665906)\n    // how much the phase of the sinusoid changes per second\n\n#define XP_H1_PER_U (10.00000000000000000000)\n    // cycles per screen width (u coordinate 0..1)\n#define XP_H1_PHASE (1.00000000000000000000)\n    // initial phase\n#define XP_H1_PHASE_PER_SEC (0.10000000000000000555)\n    // how much the phase of the sinusoid changes per second\n\n#define XP_H2_PER_U (5.00000000000000000000)\n    // cycles per screen width (u coordinate 0..1)\n#define XP_H2_PHASE (0.00000000000000000000)\n    // initial phase\n#define XP_H2_PHASE_PER_SEC (1.00000000000000000000)\n    // how much the phase of the sinusoid changes per second\n\n\n// }}}1\n\n// CHARSET FOR WORLD-COORDINATE LETTERS ///////////////\n// {{{1\n/*\n9    00000\n8  1   2   3\n7  1   2   3\n6  1   2   3\n5    44444\n4  5       6\n3  5       6\n2 858      6\n1 88877777\n0 888\n   0 12345 6\n(lowercase x, dot, and bang are handled separately)\n*/\n\n// Character storage\n#define NSEGS (9)\nvec4 SEG_SHAPES[NSEGS];\n    // All polys will be quads in the X-Y plane, Z=0.\n    // All quad edges are parallel to the X or Y axis.\n    // These quads are encoded in a vec4: (.x,.y) is the LL corner and\n    // (.z,.w) is the UR corner (coords (x,y)).\n\nvec4 SEG_VOXELS[NSEGS];\n    // Same deal, but voxel offsets, start->last+1\n\n// Grid parameters - 2D\n#define GRID_CHARHT (10.0)\n#define GRID_CHARWD (6.0)\n    // Size of each character\n#define GRID_PITCH (7.0)\n    //each char takes up this much space.  Margin is added on the right\n    //and is GRID_PITCH-GRID_CHARWD wide.\n#define GRID_PITCH_RECIP (0.14285714285714285714285714285714)\n    // avoid a division\n#define GRID_VPITCH (12.0)\n    // margin is added on top\n#define THICKNESS (1.0)\n    // how thick each stroke is\n\n#define GRID_XSHIFT (GRID_PITCH * 0.5)\n    // + pitch/0.5 because letters were snapping into\n    // existence at the right side of the screen.\n\n// Grid parameters - voxels.  Twice the size.\n#define VGRID_CHARHT (GRID_CHARHT*2.0)\n#define VGRID_CHARWD (GRID_CHARWD*2.0)\n#define VGRID_PITCH (GRID_PITCH*2.0)\n#define VGRID_PITCH_RECIP (GRID_PITCH_RECIP*0.5)\n#define VGRID_VPITCH (GRID_VPITCH*2.0)\n\n// For upright chars, each char (X,Y) goes from (PITCH*ofs, 0)->(.+WD,HT).\n\nvoid init_charset()\n{\n    float halft = THICKNESS*0.5;\n    float halfht = GRID_CHARHT * 0.5;\n\n    SEG_SHAPES[0] = vec4(THICKNESS, GRID_CHARHT - THICKNESS, GRID_CHARWD-THICKNESS, GRID_CHARHT);\n    SEG_SHAPES[1] = vec4(0.0,                   halfht, THICKNESS,             GRID_CHARHT - halft);\n    SEG_SHAPES[2] = vec4(GRID_CHARWD*0.5-halft, halfht, GRID_CHARWD*0.5+halft, GRID_CHARHT - halft);\n    SEG_SHAPES[3] = vec4(GRID_CHARWD-THICKNESS, halfht, GRID_CHARWD,           GRID_CHARHT - halft);\n    SEG_SHAPES[4] = vec4(THICKNESS, halfht - halft, GRID_CHARWD-THICKNESS, halfht + halft);\n    SEG_SHAPES[5] = vec4(0.0,                   halft,    THICKNESS,             halfht );\n    SEG_SHAPES[6] = vec4(GRID_CHARWD-THICKNESS, halft,    GRID_CHARWD,           halfht );\n    SEG_SHAPES[7] = vec4(THICKNESS, 0, GRID_CHARWD-THICKNESS, THICKNESS);\n    SEG_SHAPES[8] = vec4(0.0, 0.0, THICKNESS, THICKNESS); //dot\n\n    // Voxel grid #1 - not currently in use\n    //Grid_Origin = vec3(GRID_XSHIFT, 0, 0);\n    //Grid_Spacings = vec3(1.0);\n    //Grid_Spacings_Inv = vec3(1.0)/Grid_Spacings;\n\n    // TODO rewrite in terms of #defines.\n    // Z, W are +1 so can use IsPointInRectXY, which does not include the\n    // UR corner in the poly.\n    // Size has been doubled, so we can use multiples of 0.5.\n    SEG_VOXELS[0] = vec4(1.0, 9.0, 5.0,10.0)*vec4(2.0);\n    SEG_VOXELS[1] = vec4(0.0, 5.5, 1.0, 9.5)*vec4(2.0);\n    SEG_VOXELS[2] = vec4(3.0, 6.0, 4.0, 9.0)*vec4(2.0);\n    SEG_VOXELS[3] = vec4(5.0, 5.5, 6.0, 9.5)*vec4(2.0);\n    SEG_VOXELS[4] = vec4(1.0, 5.0, 5.0, 6.0)*vec4(2.0);\n    SEG_VOXELS[5] = vec4(0.0, 1.5, 1.0, 5.5)*vec4(2.0);\n    SEG_VOXELS[6] = vec4(5.0, 1.5, 6.0, 5.5)*vec4(2.0);\n    SEG_VOXELS[7] = vec4(1.0, 1.0, 6.0, 2.0)*vec4(2.0);\n    SEG_VOXELS[8] = vec4(0.0, 0.0, 2.0, 2.0)*vec4(2.0);\n\n} //init_charset\n\n// }}}1\n\n// MESSAGE ////////////////////////////////////////////\n// No music sync found\n// Parts and start times\n#define LOADING (0.0)\n#define LOADING_START (0.00000000000000000000)\n#define NOP (1.0)\n#define NOP_START (30.00000000000000000000)\n#define HEY (2.0)\n#define HEY_START (31.00000000000000000000)\n#define FALKEN (3.0)\n#define FALKEN_START (32.00000000000000000000)\n#define NOP2 (4.0)\n#define NOP2_START (33.50000000000000000000)\n#define LINE1 (5.0)\n#define LINE1_START (34.25000000000000000000)\n#define XPORT (6.0)\n#define XPORT_START (41.00000000000000000000)\n#define LINE2 (7.0)\n#define LINE2_START (49.00000000000000000000)\n#define LINE3 (8.0)\n#define LINE3_START (58.75000000000000000000)\n#define HOWTO (9.0)\n#define HOWTO_START (85.75000000000000000000)\n#define ENDPART (10.0)\n#define ENDPART_START (98.00000000000000000000)\n\nvec4 get_story(in float time)\n{   //returns vec4(partnum, charidx_frac, first_charidx, clip_charidx)\n    // NOTE: charidx_frac restarts at 0 each part!\n    // first_charidx and clip_charidx are with respect to the whole messge.\n    // Character indices starting with clip_charidx should not be displayed.\n    float partnum, charidx_frac, first_charidx, clip_charidx;\n    if(time<30.00000000000000000000) {\n        partnum=LOADING;\n        charidx_frac=(time-LOADING_START)*0.36666666666666664076;\n        first_charidx=0.0;\n        clip_charidx=10.0;\n    } else\n\n    if(time<31.00000000000000000000) {\n        partnum=NOP;\n        charidx_frac=(time-NOP_START)*1.00000000000000000000;\n        first_charidx=11.0;\n        clip_charidx=11.0;\n    } else\n\n    if(time<32.00000000000000000000) {\n        partnum=HEY;\n        charidx_frac=(time-HEY_START)*8.00000000000000000000;\n        first_charidx=12.0;\n        clip_charidx=19.0;\n    } else\n\n    if(time<33.50000000000000000000) {\n        partnum=FALKEN;\n        charidx_frac=(time-FALKEN_START)*8.00000000000000000000;\n        first_charidx=20.0;\n        clip_charidx=31.0;\n    } else\n\n    if(time<34.25000000000000000000) {\n        partnum=NOP2;\n        charidx_frac=(time-NOP2_START)*1.33333333333333325932;\n        first_charidx=32.0;\n        clip_charidx=32.0;\n    } else\n\n    if(time<41.00000000000000000000) {\n        partnum=LINE1;\n        charidx_frac=(time-LINE1_START)*4.00000000000000000000;\n        first_charidx=33.0;\n        clip_charidx=56.0;\n    } else\n\n    if(time<49.00000000000000000000) {\n        partnum=XPORT;\n        charidx_frac=(time-XPORT_START)*1.50000000000000000000;\n        first_charidx=60.0;\n        clip_charidx=71.0;\n    } else\n\n    if(time<58.75000000000000000000) {\n        partnum=LINE2;\n        charidx_frac=(time-LINE2_START)*4.00000000000000000000;\n        first_charidx=72.0;\n        clip_charidx=107.0;\n    } else\n\n    if(time<85.75000000000000000000) {\n        partnum=LINE3;\n        charidx_frac=(time-LINE3_START)*4.00000000000000000000;\n        first_charidx=111.0;\n        clip_charidx=215.0;\n    } else\n\n    if(time<98.00000000000000000000) {\n        partnum=HOWTO;\n        charidx_frac=(time-HOWTO_START)*4.00000000000000000000;\n        first_charidx=219.0;\n        clip_charidx=264.0;\n    } else\n\n    if(time<100.00000000000000000000) {\n        partnum=ENDPART;\n        charidx_frac=(time-ENDPART_START)*0.50000000000000000000;\n        first_charidx=268.0;\n        clip_charidx=268.0;\n    } else\n\n    {\n        partnum=0.0;\n        charidx_frac=0.0;\n        first_charidx=0.0;\n        clip_charidx=0.0;\n    }\n\n    return vec4(partnum,charidx_frac,first_charidx,clip_charidx);\n} //get_story\n\nvec4 get_seg_vec4(float vecidx) {\n    if(vecidx>=34.0){\n        if(vecidx>=51.0){\n            if(vecidx>=59.0){\n                if(vecidx>=63.0){\n                    if(vecidx>=65.0){\n                        if(vecidx>=67.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=66.0) return vec4(0.0,0.0,0.0,0.0);\n                        if(vecidx>=65.0) return vec4(235.0,235.0,107.0,258.0);\n                    }else{\n                        if(vecidx>=64.0) return vec4(11.0,219.0,0.0,211.0);\n                        if(vecidx>=63.0) return vec4(19.0,27.0,15.0,21.0);\n                    }\n                }else{\n                    if(vecidx>=62.0) return vec4(107.0,179.0,178.0,0.0);\n                    if(vecidx>=61.0) return vec4(178.0,16.0,248.0,256.0);\n                    if(vecidx>=60.0) return vec4(162.0,123.0,107.0,179.0);\n                    if(vecidx>=59.0) return vec4(178.0,235.0,256.0,59.0);\n                }\n            }else{\n                if(vecidx>=55.0){\n                    if(vecidx>=58.0) return vec4(0.0,122.0,235.0,30.0);\n                    if(vecidx>=57.0) return vec4(0.0,27.0,26.0,178.0);\n                    if(vecidx>=56.0) return vec4(114.0,187.0,19.0,118.0);\n                    if(vecidx>=55.0) return vec4(0.0,0.0,0.0,163.0);\n                }else{\n                    if(vecidx>=54.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=53.0) return vec4(234.0,258.0,258.0,0.0);\n                    if(vecidx>=52.0) return vec4(248.0,0.0,218.0,235.0);\n                    if(vecidx>=51.0) return vec4(211.0,0.0,123.0,11.0);\n                }\n            }\n        }else{\n            if(vecidx>=42.0){\n                if(vecidx>=46.0){\n                    if(vecidx>=48.0){\n                        if(vecidx>=50.0) return vec4(51.0,178.0,0.0,59.0);\n                        if(vecidx>=49.0) return vec4(0.0,248.0,3.0,21.0);\n                        if(vecidx>=48.0) return vec4(19.0,26.0,219.0,15.0);\n                    }else{\n                        if(vecidx>=47.0) return vec4(26.0,19.0,19.0,0.0);\n                        if(vecidx>=46.0) return vec4(211.0,0.0,19.0,15.0);\n                    }\n                }else{\n                    if(vecidx>=45.0) return vec4(27.0,0.0,242.0,35.0);\n                    if(vecidx>=44.0) return vec4(30.0,123.0,0.0,178.0);\n                    if(vecidx>=43.0) return vec4(107.0,242.0,123.0,107.0);\n                    if(vecidx>=42.0) return vec4(16.0,0.0,118.0,235.0);\n                }\n            }else{\n                if(vecidx>=38.0){\n                    if(vecidx>=41.0) return vec4(26.0,178.0,187.0,0.0);\n                    if(vecidx>=40.0) return vec4(0.0,15.0,2.0,11.0);\n                    if(vecidx>=39.0) return vec4(18.0,123.0,211.0,178.0);\n                    if(vecidx>=38.0) return vec4(187.0,3.0,218.0,0.0);\n                }else{\n                    if(vecidx>=37.0) return vec4(114.0,187.0,0.0,26.0);\n                    if(vecidx>=36.0) return vec4(123.0,178.0,0.0,178.0);\n                    if(vecidx>=35.0) return vec4(123.0,248.0,187.0,0.0);\n                    if(vecidx>=34.0) return vec4(0.0,16.0,0.0,15.0);\n                }\n            }\n        }\n    }else{\n        if(vecidx>=17.0){\n            if(vecidx>=25.0){\n                if(vecidx>=29.0){\n                    if(vecidx>=31.0){\n                        if(vecidx>=33.0) return vec4(0.0,19.0,124.0,30.0);\n                        if(vecidx>=32.0) return vec4(11.0,187.0,0.0,16.0);\n                        if(vecidx>=31.0) return vec4(11.0,19.0,18.0,21.0);\n                    }else{\n                        if(vecidx>=30.0) return vec4(0.0,16.0,0.0,21.0);\n                        if(vecidx>=29.0) return vec4(163.0,162.0,235.0,72.0);\n                    }\n                }else{\n                    if(vecidx>=28.0) return vec4(0.0,0.0,0.0,107.0);\n                    if(vecidx>=27.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=26.0) return vec4(235.0,107.0,258.0,0.0);\n                    if(vecidx>=25.0) return vec4(59.0,187.0,35.0,211.0);\n                }\n            }else{\n                if(vecidx>=21.0){\n                    if(vecidx>=24.0) return vec4(0.0,21.0,11.0,0.0);\n                    if(vecidx>=23.0) return vec4(178.0,187.0,11.0,248.0);\n                    if(vecidx>=22.0) return vec4(11.0,0.0,123.0,178.0);\n                    if(vecidx>=21.0) return vec4(21.0,0.0,19.0,123.0);\n                }else{\n                    if(vecidx>=20.0) return vec4(0.0,211.0,27.0,0.0);\n                    if(vecidx>=19.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=18.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=17.0) return vec4(178.0,179.0,35.0,0.0);\n                }\n            }\n        }else{\n            if(vecidx>=8.0){\n                if(vecidx>=12.0){\n                    if(vecidx>=14.0){\n                        if(vecidx>=16.0) return vec4(211.0,59.0,235.0,35.0);\n                        if(vecidx>=15.0) return vec4(178.0,35.0,123.0,107.0);\n                        if(vecidx>=14.0) return vec4(0.0,0.0,0.0,0.0);\n                    }else{\n                        if(vecidx>=13.0) return vec4(178.0,114.0,123.0,178.0);\n                        if(vecidx>=12.0) return vec4(21.0,178.0,114.0,0.0);\n                    }\n                }else{\n                    if(vecidx>=11.0) return vec4(26.0,59.0,0.0,30.0);\n                    if(vecidx>=10.0) return vec4(35.0,35.0,218.0,0.0);\n                    if(vecidx>=9.0) return vec4(0.0,0.0,122.0,234.0);\n                    if(vecidx>=8.0) return vec4(0.0,0.0,0.0,0.0);\n                }\n            }else{\n                if(vecidx>=4.0){\n                    if(vecidx>=7.0) return vec4(179.0,107.0,258.0,0.0);\n                    if(vecidx>=6.0) return vec4(51.0,123.0,162.0,118.0);\n                    if(vecidx>=5.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=4.0) return vec4(122.0,179.0,218.0,0.0);\n                }else{\n                    if(vecidx>=3.0) return vec4(0.0,0.0,0.0,0.0);\n                    if(vecidx>=2.0) return vec4(256.0,256.0,0.0,0.0);\n                    if(vecidx>=1.0) return vec4(21.0,11.0,219.0,256.0);\n                    if(vecidx>=0.0) return vec4(162.0,235.0,123.0,248.0);\n                }\n            }\n        }\n    }\n    return vec4(0.0);\n} //get_seg_vec4\n\n#define NUM_CHARS_IN_MESSAGE (269.0)\nfloat get_seg_mask(float charidx)\n{\n    if(charidx>=NUM_CHARS_IN_MESSAGE) return 0.0; //blank at the end\n    float vecidx = charidx * 0.250000000;\n    float subidx = mod(charidx, 4.0);\n    vec4 v = get_seg_vec4(vecidx);\n    float rv = v[0];\n    rv = mix(rv, v[1], step(1.0, subidx));\n    rv = mix(rv, v[2], step(2.0, subidx));\n    rv = mix(rv, v[3], step(3.0, subidx));\n    return rv;\n} //get_seg_mask\n\n// Camera and light prototypes\n\nvoid do_cl_loading(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_nop(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_hey(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_falken(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_nop2(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_line1(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_xport(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_line2(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_line3(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_howto(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\nvoid do_cl_endpart(in float partnum, in float charidx_frac, out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg, out vec3 light_pos);\n\nvoid do_camera_light(in float partnum, in float charidx_frac,\n                        out vec3 camera_pos,\n                        out vec3 camera_look_at, out vec3 camera_up,\n                        out float fovy_deg, out vec3 light_pos)\n{   // Camera and light dispatcher\n    if(partnum>=LINE1) {\n\n        if(partnum==LINE1) {\n            do_cl_line1(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==XPORT) {\n            do_cl_xport(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==LINE2) {\n            do_cl_line2(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==LINE3) {\n            do_cl_line3(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==HOWTO) {\n            do_cl_howto(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==ENDPART) {\n            do_cl_endpart(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        {\n            camera_pos=vec3(0.0,0.0,10.0);    //default\n            camera_look_at=vec3(0.0);\n            camera_up=vec3(0.0, 1.0, 0.0);\n            fovy_deg=45.0;\n            light_pos=camera_pos;\n        }\n    } else {\n\n        if(partnum==LOADING) {\n            do_cl_loading(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==NOP) {\n            do_cl_nop(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==HEY) {\n            do_cl_hey(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==FALKEN) {\n            do_cl_falken(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        if(partnum==NOP2) {\n            do_cl_nop2(partnum,charidx_frac,camera_pos,camera_look_at,camera_up,fovy_deg,light_pos);\n        } else\n\n        {\n            camera_pos=vec3(0.0,0.0,10.0);    //default\n            camera_look_at=vec3(0.0);\n            camera_up=vec3(0.0, 1.0, 0.0);\n            fovy_deg=45.0;\n            light_pos=camera_pos;\n        }\n    }\n} //do_camera_light\n\n#define HEY_REALSTART (16.00000000000000000000)\n#define FALKEN_REALSTART (24.00000000000000000000)\n#define XPORT_NCHARS (11.00000000000000000000)\n#define LOADING_NCHARS (10.00000000000000000000)\n#define XPORT_FADEIN_DURATION (5.0)\n\n\n// UTIL ///////////////////////////////////////////////\n// {{{1\nmat4 my_transpose(in mat4 inMatrix)\n\n{\n    // Modified from\n    // http://stackoverflow.com/a/18038495/2877364 by\n    // http://stackoverflow.com/users/2507370/jeb\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n\n    vec4 o0 = vec4(i0.x, i1.x, i2.x, i3.x);\n    vec4 o1 = vec4(i0.y, i1.y, i2.y, i3.y);\n    vec4 o2 = vec4(i0.z, i1.z, i2.z, i3.z);\n    vec4 o3 = vec4(i0.w, i1.w, i2.w, i3.w);\n\n    mat4 outMatrix = mat4(o0, o1, o2, o3);\n\n    return outMatrix;\n}\n\nvoid lookat(in vec3 in_eye, in vec3 in_ctr, in vec3 in_up,\n            out mat4 view, out mat4 view_inv)\n{\n    // From Mesa glu.  Thanks to\n    // http://learnopengl.com/#!Getting-started/Camera\n    // and https://www.opengl.org/wiki/GluLookAt_code\n\n    vec3 forward, side, up;\n\n    forward=normalize(in_ctr-in_eye);\n    up = in_up;\n    side = normalize(cross(forward,up));\n    up = cross(side,forward);   // already normalized since both inputs are\n        //now side, up, and forward are orthonormal\n\n    mat4 orient, where;\n\n    // Note: in Mesa gluLookAt, a C matrix is used, so the indices\n    // have to be swapped compared to that code.\n    vec4 x4, y4, z4, w4;\n    x4 = vec4(side,0);\n    y4 = vec4(up,0);\n    z4 = vec4(-forward,0);\n    w4 = vec4(0,0,0,1);\n    orient = my_transpose(mat4(x4, y4, z4, w4));\n\n    where = mat4(1.0); //identity (1.0 diagonal matrix)\n    where[3] = vec4(-in_eye, 1);\n\n    view = (orient * where);\n\n    // Compute the inverse for later\n    view_inv = mat4(x4, y4, z4, -where[3]);\n    view_inv[3][3] = 1.0;   // since -where[3].w == -1, not what we want\n        // Per https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations ,\n        // M_{view->world}\n} //lookat\n\nvoid gluPerspective(in float fovy_deg, in float aspect,\n                    in float near, in float far,\n                    out mat4 proj, out mat4 proj_inv)\n{   // from mesa glu-9.0.0/src/libutil/project.c.\n    // Thanks to https://unspecified.wordpress.com/2012/06/21/calculating-the-gluperspective-matrix-and-other-opengl-matrix-maths/\n\n    float fovy_rad = radians(fovy_deg);\n    float dz = far-near;\n    float sin_fovy = sin(fovy_rad);\n    float cot_fovy = cos(fovy_rad) / sin_fovy;\n\n    proj=mat4(0);\n    //[col][row]\n    proj[0][0] = cot_fovy / aspect;\n    proj[1][1] = cot_fovy;\n\n    proj[2][2] = -(far+near)/dz;\n    proj[2][3] = -1.0;\n\n    proj[3][2] = -2.0*near*far/dz;\n\n    // Compute the inverse matrix.\n    // http://bookofhook.com/mousepick.pdf\n    float a = proj[0][0];\n    float b = proj[1][1];\n    float c = proj[2][2];\n    float d = proj[3][2];\n    float e = proj[2][3];\n\n    proj_inv = mat4(0);\n    proj_inv[0][0] = 1.0/a;\n    proj_inv[1][1] = 1.0/b;\n    proj_inv[3][2] = 1.0/e;\n    proj_inv[2][3] = 1.0/d;\n    proj_inv[3][3] = -c/(d*e);\n} //gluPerspective\n\nvoid compute_viewport(in float x, in float y, in float w, in float h,\n                        out mat4 viewp, out mat4 viewp_inv)\n{\n    // See https://en.wikibooks.org/wiki/GLSL_Programming/Vertex_Transformations#Viewport_Transformation\n    // Also mesa src/mesa/main/viewport.c:_mesa_get_viewport_xform()\n\n    viewp = mat4(0);\n    // Reminder: indexing is [col][row]\n    viewp[0][0] = w/2.0;\n    viewp[3][0] = x+w/2.0;\n\n    viewp[1][1] = h/2.0;\n    viewp[3][1] = y+h/2.0;\n\n    // assumes n=0 and f=1,\n    // which are the default for glDepthRange.\n    viewp[2][2] = 0.5;  // actually 0.5 * (f-n);\n    viewp[3][2] = 0.5;  // actually 0.5 * (n+f);\n\n    viewp[3][3] = 1.0;\n\n    //Invert.  Done by hand.\n    viewp_inv = mat4(1.0);\n    viewp_inv[0][0] = 2.0/w;    // x->x\n    viewp_inv[3][0] = -1.0 - (2.0*x/w);\n\n    viewp_inv[1][1] = 2.0/h;    // y->y\n    viewp_inv[3][1] = -1.0 - (2.0*y/h);\n\n    viewp_inv[2][2] = 2.0;      // z->z\n    viewp_inv[3][2] = -1.0;\n\n}  //compute_viewport\n\n// https://www.opengl.org/wiki/Compute_eye_space_from_window_space\n\nvec4 wts(in mat4 modelviewproj, in mat4 viewport,\n                in vec3 pos)\n{   // world to screen coordinates\n    vec4 clipvertex = modelviewproj * vec4(pos,1.0);\n    vec4 ndc = clipvertex/clipvertex.w;\n    vec4 transformed = viewport * ndc;\n    return transformed;\n} //wts\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec4 WorldRayFromScreenPoint(in vec2 scr_pt,\n    in mat4 view_inv,\n    in mat4 proj_inv,\n    in mat4 viewp_inv)\n{   // Returns world coords of a point on a ray passing through\n    // the camera position and scr_pt.\n\n    vec4 ndc = viewp_inv * vec4(scr_pt,0.0,1.0);\n        // z=0.0 => it's a ray.  0 is an arbitrary choice in the\n        // view volume.\n        // w=1.0 => we don't need to undo the perspective divide.\n        //      So clip coords == NDC\n\n    vec4 view_coords = proj_inv * ndc;\n        // At this point, z=0 will have become something in the\n        // middle of the projection volume, somewhere between\n        // near and far.\n    view_coords = view_coords / view_coords.w;\n        // Keepin' it real?  Not sure what happens if you skip this.\n    //view_coords.w = 0.0;\n        // Remove translation components.  Note that we\n        // don't use this trick.\n    vec4 world_ray_point = view_inv * view_coords;\n        // Now scr_pt is on the ray through camera_pos and world_ray_point\n    return world_ray_point;\n} //WorldRayFromScreenPoint\n\nvec3 hsv2rgb(vec3 c) {\n    // by hughsk, from https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl .\n    // All inputs range from 0 to 1.\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scalesin(in float bot, in float top, in float x)\n{   //rescale [-1,1] to [bot, top]\n    return mix(bot, top, clamp((x+1.0)*0.5, 0.0, 1.0));\n}\n\n\n\n// }}}1\n\n// VOXEL MARCHING\n// {{{1\n\n// Variables for voxel marching\nstruct VM2State {\n    // Parameters\n    vec3 origin;\n    vec3 direction;\n    vec3 world_min;\n    vec3 world_max;\n\n    // Internals\n    vec3 curr;      //where we are now - was x, y, z vars\n    vec3 stepdir;   //was step[XYZ]\n    vec3 tMax;\n    vec3 tDelta;\n    float max_t;\n}; //VM2State\n\n// By http://gamedev.stackexchange.com/users/8806/maxim-kamalov , aka\n// dogfuntom, https://gist.github.com/dogfuntom .\n// See http://gamedev.stackexchange.com/questions/47362/cast-ray-to-select-block-in-voxel-game#comment188335_49423\n// Modified from https://gist.github.com/cc881c8fc86ad43d55d8.git\n//// Heavily based on:\n//// http://gamedev.stackexchange.com/a/49423/8806\n\nfloat intbound(float s, float ds)\n{\n    // Some kind of edge case, see:\n    // http://gamedev.stackexchange.com/questions/47362/cast-ray-to-select-block-in-voxel-game#comment160436_49423 :\n        // \"The edge case is where a coordinate of the ray origin is an\n        //integer value, and the corresponding part of the ray direction is\n        //negative. The initial tMax value for that axis should be zero, since\n        //the origin is already at the bottom edge of its cell, but it is\n        //instead 1/ds causing one of the other axes to be incremented instead.\n        //The fix is to write intfloor to check if both ds is negative and s is\n        //an integer value (mod returns 0), and return 0.0 in that case. â€“\n        //codewarrior Dec 24 '14 at 12:00\"\n\n    // by http://gamedev.stackexchange.com/users/57468/codewarrior\n    bool sIsInteger = (fract(s)==0.0);  //TODO check against epsilon?\n    if (ds < 0.0 && sIsInteger)\n        return 0.0;\n\n    return (\n        ( (ds > 0.0) ? (ceil(s) - s) : (s - floor(s)) ) / abs(ds)\n    );\n} //intbound\n\nbool VM2_init(out VM2State state,\n    in vec3 origin, in vec3 direction, in float max_dist,\n    in vec3 world_min, in vec3 world_max)\n{ //The initialization portion of VM2_raycast (q.v.).\n  //Returns true if successful.\n\n    if(length(direction)==0.0) {\n        return false;   // *** EXIT POINT ***\n    }\n\n    state.origin = origin;\n    state.direction = direction;\n    state.world_min = world_min;     // TODO? make sure they are ints?\n    state.world_max = world_max;\n\n    state.curr = floor(origin);\n    state.stepdir = sign(direction);\n\n    state.tMax.x = intbound(origin.x, direction.x);\n    state.tMax.y = intbound(origin.y, direction.y);\n    state.tMax.z = intbound(origin.z, direction.z);\n\n    state.tDelta.x = state.stepdir.x / direction.x;\n    state.tDelta.y = state.stepdir.y / direction.y;\n    state.tDelta.z = state.stepdir.z / direction.z;\n\n    state.max_t = max_dist / length(direction);\n    return true;\n} //VM2_init\n\n//DEBUG: these are floats.  For production, change them back to int.\n#define VM2_HIT (1.0)\n#define VM2_NOTYET (-1.0)\n#define VM2_DONE (0.0)\n\nvec4 VM2_step(inout VM2State state,\n                out vec3 voxel, out vec3 hitpoint, out vec3 normal)\n{ //returns:\n  // VM2_HIT    if we hit a voxel in the world;\n  // VM2_NOTYET if we have not yet reached the world; or\n  // VM2_DONE   if we have traced off the end of the world or have gone\n  //            too far along the ray.\n  // If VM2_HIT, voxel and normal are filled in:\n  //    voxel       coordinates of the voxel we're in\n  //    hitpoint    The actual point where the ray hit the voxel\n  //    normal      normal of the voxel at hitpoint\n\n    vec3 ret_normal;    //value to be returned\n    float hit_t;        //where we actually hit\n\n    // Go to the next voxel.\n    //DEBUG: The *0.05's below are to rescale for visibility, and are debug.\n    if (state.tMax.x < state.tMax.y) {\n        if (state.tMax.x < state.tMax.z) {\n            if (state.tMax.x > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.x += state.stepdir.x;    // Update which cube we are now in.\n            hit_t = state.tMax.x;               // Record where we hit the cube\n            state.tMax.x += state.tDelta.x;\n                // Adjust state.tMax.x to the next X-oriented crossing\n            ret_normal = vec3(-state.stepdir.x, 0.0, 0.0);\n                // Record the normal vector of the voxel we just entered.\n        } else {\n            if (state.tMax.z > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.z += state.stepdir.z;\n            hit_t = state.tMax.z;\n            state.tMax.z += state.tDelta.z;\n            ret_normal = vec3(0.0, 0.0, -state.stepdir.z);\n        }\n    } else {\n        if (state.tMax.y < state.tMax.z) {\n            if (state.tMax.y > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.y += state.stepdir.y;\n            hit_t = state.tMax.y;\n            state.tMax.y += state.tDelta.y;\n            ret_normal = vec3(0.0, -state.stepdir.y, 0.0);\n        } else {\n            if (state.tMax.z > state.max_t) return vec4(state.tMax*0.05,VM2_DONE);\n            state.curr.z += state.stepdir.z;\n            hit_t = state.tMax.z;\n            state.tMax.z += state.tDelta.z;\n            ret_normal = vec3(0.0, 0.0, -state.stepdir.z);\n        }\n    } //end conditionals\n\n    // Check if we're past the world\n    if( (state.stepdir.x>0.0) ?\n        (state.curr.x>=state.world_max.x) : (state.curr.x<state.world_min.x) )\n        return vec4(1.0,0.0,0.0,VM2_DONE);\n    if( (state.stepdir.y>0.0) ?\n        (state.curr.y>=state.world_max.y) : (state.curr.y<state.world_min.y) )\n        return vec4(0.0,1.0,0.0,VM2_DONE);\n    if( (state.stepdir.z>0.0) ?\n        (state.curr.z>=state.world_max.z) : (state.curr.z<state.world_min.z) )\n        return vec4(0.0,0.0,1.0,VM2_DONE);\n\n    // Check if we're not yet at the world.\n    // TODO in VM2_init, fast-forward to the boundary of the world so that\n    // this case never happens.\n    if( (state.stepdir.x>0.0) ?\n        (state.curr.x<state.world_min.x) : (state.curr.x>=state.world_max.x) )\n        return vec4(0.5,0.0,0.0,VM2_NOTYET);\n    if( (state.stepdir.y>0.0) ?\n        (state.curr.y<state.world_min.y) : (state.curr.y>=state.world_max.y) )\n        return vec4(0.0,0.5,0.0,VM2_NOTYET);\n    if( (state.stepdir.z>0.0) ?\n        (state.curr.z<state.world_min.z) : (state.curr.z>=state.world_max.z) )\n        return vec4(0.0,0.0,0.5,VM2_NOTYET);\n\n    // If we made it here, we are in a voxel cell.\n    voxel = state.curr;\n    hitpoint = state.origin + hit_t*state.direction;\n    normal = ret_normal;\n    return vec4(voxel,VM2_HIT);     //voxel is debug\n} //VM2_step\n\n// }}}1\n\n// GEOMETRY HIT-TESTING ///////////////////////////////\n// {{{1\n\n\n\n// Faster routine for the special case of the main text\nvec3 HitZZero(vec3 camera_pos, vec3 rayend)\n{   // Find where the ray meets the z=0 plane.  The ray is\n    // camera_pos + t*(rayend - camera_pos) per Hook.\n    float hit_t = -camera_pos.z / (rayend.z - camera_pos.z);\n    return (camera_pos + hit_t * (rayend-camera_pos));\n} //HitZZero\n\n// --- IsPointInRectXY ---\n// All polys will be quads in the X-Y plane, Z=0.\n// All quad edges are parallel to the X or Y axis.\n// These quads are encoded in a vec4: (.x,.y) is the LL corner and\n// (.z,.w) is the UR corner (coords (x,y)).  The UR corner is not\n// inclued in the poly.\n\nbool IsPointInRectXY(in vec4 poly_coords, in vec2 world_xy_of_point)\n{\n    // return true if world_xy_of_point is within the poly defined by\n    // poly_coords in the Z=0 plane.\n    // I.e., xy >= poly_coords.xy, and xy < poly_coords.zw.\n    // I can test in 2D rather than 3D because all the geometry\n    // has z=0 and all the quads are planar.\n\n    float x_test, y_test;\n    x_test = step(poly_coords.x, world_xy_of_point.x) *\n            (1.0 - step(poly_coords.z, world_xy_of_point.x));\n        // step() is 1.0 if world.x >= poly_coords.x\n        // 1-step() is 1.0 if world.x < poly_coords.z\n    y_test = step(poly_coords.y, world_xy_of_point.y) *\n            (1.0 - step(poly_coords.w, world_xy_of_point.y));\n\n    return ( (x_test>=0.9) && (y_test >= 0.9) );\n        // Not ==1.0 because these are floats!\n\n} //IsPointInRectXY\n\n\n\n// }}}1\n\n// TEXT RENDERING /////////////////////////////////////\n// {{{1\n\n// Text-rendering internal parameters\n#define LETTER_EPSILON (0.001)\n    // small enough for our purposes.\n#define SIDE_LETTERS (4)\n    // How many letters to render on each side of the current one.\n    // Set to fill the screen at the desired aspect ratio and orientation.\n\nbool is_in_zzero_message(in vec2 world_xy_of_point,\n                         in float middle_charidx, in float middle_x,\n                         in float clip_charidx)\n{   // returns true iff world_xy_of_point is in a letter\n    // upright in the z=0 plane.\n    // Letters are extracted from the message, with message[middle_charidx]\n    // being displayed with its LL corner at (middle_x, 0, 0).\n    // Characters starting from clip_charidx are not hit.\n\n    // Check each letter in turn\n    for(int ltr_idx=0; ltr_idx<(2*SIDE_LETTERS+1); ++ltr_idx) {\n        float letter_delta = float(ltr_idx-SIDE_LETTERS-1);\n        float thisletterindex = letter_delta + middle_charidx;\n            // so the middle element of ltr_idx maps to middle_charidx\n\n        if(thisletterindex >= clip_charidx) {\n            break;  // no more letters\n        }\n\n        float mask = get_seg_mask(thisletterindex);\n            // the segments for this letter\n\n        // Early exit on spaces\n        if(mask <= LETTER_EPSILON) {\n            continue; //to next letter\n        }\n\n        // Where is this letter on the X axis?\n        float ofs = (letter_delta*GRID_PITCH) + middle_x;\n\n        // check each segment in turn\n        for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n            if(mod(mask, 2.0)>LETTER_EPSILON) {\n                // Where is this segment of this letter?\n                vec4 theshape = SEG_SHAPES[seg_idx];\n                theshape += vec4(ofs, 0.0, ofs, 0.0);\n                    //shift it over to the right place\n\n                // Check if we are in the segment\n                if(IsPointInRectXY(theshape, world_xy_of_point)) {\n                    return true;    // as soon as we're in a segment, we don't need to check any others\n                }\n\n            } //endif this segment is in mask\n\n            mask = floor(mask * 0.5);\n                //move to next bit and drop fractional part\n\n            // Early exit when you run out of segments\n            if(mask<=LETTER_EPSILON) {\n                break; //to next letter\n            }\n        } //foreach segment\n\n    } //foreach letter\n\n    return false;\n} //is_in_zzero_message\n\nbool is_in_basic_message(in vec2 pt,\n    in float first_charidx, in float clip_charidx)\n{   // returns true iff world_xy_of_point is the message for this part,\n    // which begins with first_charidx at x=0, upright in the z=0 plane.\n\n    float nchars = (clip_charidx-first_charidx);\n        //not ()+1 because clip_charidx is one past the last char to show.\n    if( (pt.x<0.0) || (pt.x>=nchars*GRID_PITCH) ) {\n        return false;   //outside - can't hit\n    }\n\n    if( (pt.y<0.0) || (pt.y>GRID_CHARHT*GRID_VPITCH) ) {\n        return false;   //ditto\n    }\n\n    // Which letter are we in?  There can be only one.\n    float ltridx = floor(pt.x/GRID_PITCH);\n    float ofs = ltridx * GRID_PITCH;\n    float mask = get_seg_mask(first_charidx + ltridx);\n\n    // Early exit on spaces\n    if(mask <= LETTER_EPSILON) {\n        return false;\n    }\n\n    // check each segment in turn\n    for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n        if(mod(mask, 2.0)>LETTER_EPSILON) {\n            // Where is this segment of this letter?\n            vec4 theshape = SEG_SHAPES[seg_idx];\n            theshape += vec4(ofs, 0.0, ofs, 0.0);\n                //shift it over to the right place\n\n            // Check if we are in the segment\n            if(IsPointInRectXY(theshape, pt)) {\n                return true;    // as soon as we're in a segment,\n            }                   // we don't need to check any others\n\n        } //endif this segment is in mask\n\n        mask = floor(mask * 0.5);\n            //move to next bit and drop fractional part\n\n        // Early exit when you run out of segments\n        if(mask<=LETTER_EPSILON) {\n            return false;       // no more chances\n        }\n    } //foreach segment\n\n    return false;\n} //is_in_basic_message\n\n// }}}1\n\n// LETTER RENDERING ///////////////////////////////////\n// {{{1\n\n// Text-rendering internal parameters\n#define LETTER_EPSILON (0.001)\n    // small enough for our purposes.\n\n/*vec3*/ bool voxel_is_in_message(\n    in vec3 origin, in vec3 direction,\n    in float charidx_frac, in float first_charidx, in float clip_charidx,\n    out vec3 voxel, out vec3 hitpoint, out vec3 normal)\n{   //Determine whether _hitlocn_ is in the upright message at the current\n    //point in the story, as determined by charidx_frac.\n    //Returns true on hit.  If true, _voxel_ holds the grid coordinates of the\n    //voxel that was hit, _hitpoint_ holds the actual point hit, and\n    //_normal_ is the normal of the voxel face that was hit.\n\n    //Retval storage, so we don't trash the out parameters if there's no hit.\n    vec3 ret_voxel, ret_hitpoint, ret_normal;\n\n    // Setup voxel marching\n    bool ok;\n    VM2State state;\n    ok = VM2_init(state, origin, direction, MAX_DIST,\n        vec3(0.0,0.0,-LTR_Z_THICKNESS),  //world_min\n        vec3((clip_charidx-first_charidx)*VGRID_PITCH,   //world_max - last+1\n            VGRID_CHARHT,\n            1.0));  // 1.0 => voxels (:,:,0) are the farthest voxels forward.\n                    // (+Z is towards viewer normally)\n\n    if(!ok) return false;   // *** EXIT POINT *** can't init => can't hit\n\n    // Run the marching loop.  At each voxel, check the mask for only\n    // the letter that voxel might be in.\n    for(int step_idx=0; step_idx<MAX_VOXEL_STEPS; ++step_idx) {\n        vec4 /*int*/ hit = VM2_step(state, ret_voxel, ret_hitpoint, ret_normal);\n\n        if(hit.w == VM2_DONE) return false;   // *** EXIT POINT ***\n\n        if(hit.w == VM2_NOTYET) continue;     // to the next voxel step\n\n        // If we got here, we are in a voxel that is in the world.\n\n        // Determine which character cell this voxel is in.\n        // The text starts at x=0 for each part.\n        float voxel_rel_charidx = floor(ret_voxel.x * VGRID_PITCH_RECIP);\n            //which grid cell we're in\n        float voxel_abs_charidx = voxel_rel_charidx + first_charidx;\n            // Where we are in the story.\n            // Don't need to check clip_charidx since that is rolled into\n            // the world_max limits in VM2_init().\n        float mask = get_seg_mask(voxel_abs_charidx);\n            // the segments for this letter\n        //return vec3(mask/255.0); //DEBUG\n\n        // Early exit on spaces\n        if(mask <= LETTER_EPSILON) {\n            continue; //to next voxel step\n        }\n\n        // Where is this letter on the X axis?\n        float letter_xorigin = voxel_rel_charidx * VGRID_PITCH;\n        float voxel_x_within_cell = ret_voxel.x - letter_xorigin;\n            // since voxel cells are every 1 unit at present\n\n        //return vec3(voxel_x_within_cell/20.0, voxel.y/10.0, voxel.z/10.0);  //DEBUG\n\n        // check each segment in turn\n        for(int seg_idx=0; seg_idx<NSEGS; ++seg_idx) {\n            if(mod(mask, 2.0)>LETTER_EPSILON) {     //this segment is lit\n                // Are we in this segment?\n                if(IsPointInRectXY(SEG_VOXELS[seg_idx],\n                                    vec2(voxel_x_within_cell, ret_voxel.y))) {\n                   // A hit!  A very palpable hit.\n                   voxel = ret_voxel;\n                   hitpoint = ret_hitpoint;\n                   normal = ret_normal;\n                   return /*vec3(1.0)*/ true;\n                }\n            } //endif this segment is in mask\n\n            mask = floor(mask * 0.5);\n                //move to next bit and drop any fractional part\n\n            // Early exit when you run out of segments\n            if(mask<=LETTER_EPSILON) {\n                break;  //done with this letter - go to next voxel step\n            }\n        } //foreach segment\n\n    } //for each voxel step\n\n    return false;   //else return no-hit\n} //voxel_is_in_message\n\n// }}}1\n\n// CAMERA AND LIGHT ///////////////////////////////////\n// {{{1\n\n// --- Helpers ---\n\n#define GAMMA (2.2)\n#define ONE_OVER_GAMMA (0.45454545454545454545454545454545)\n\nvec3 phong_color(\n    in vec3 pixel_pos, in vec3 normal, in vec3 camera_pos,      // Scene\n    in vec3 light_pos, in vec3 ambient_matl,                    // Lights\n    in vec3 diffuse_matl, in vec3 specular_matl,                // Lights\n    in float shininess)                                         // Material\n{   // Compute pixel color using Blinn-Phong shading with a white light.\n    // Modified from\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    // Normal must be normalized on input.  All inputs are world coords.\n    // Set shininess <=0 to turn off specular highlights.\n    // Objects are one-sided.\n\n    vec3 light_dir = normalize(light_pos - pixel_pos);\n    vec3 eye_dir = normalize(camera_pos - pixel_pos);\n\n    if(dot(light_dir, eye_dir) < 0.0) {\n        return ambient_matl;       // Camera behind the object\n    }\n\n    float lambertian = max(0.0, dot(light_dir, normal));        // Diffuse\n\n    float specular = 0.0;\n    if((lambertian > 0.0) && (shininess > 0.0)) {               // Specular\n        vec3 reflectDir = reflect(-light_dir, normal);\n        float specAngle = max(dot(reflectDir, eye_dir), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    lambertian = pow(lambertian, ONE_OVER_GAMMA);\n    specular = pow(specular, ONE_OVER_GAMMA);\n\n    vec3 retval = ambient_matl + lambertian*diffuse_matl +\n        specular*specular_matl;\n\n    return clamp(retval, 0.0, 1.0);     // no out-of-range values, please!\n\n} //phong_color\n\nhighp vec3 pos_clelies(in float the_time, in float radius)\n{   //Clelies curve\n    //thanks to http://wiki.roblox.com/index.php?title=Parametric_equations\n    vec3 pos; float m = 0.8;\n    highp float smt = sin(m*the_time);\n    pos.x = radius * smt*cos(the_time);\n    pos.y = radius * smt*sin(the_time);\n    pos.z = radius * cos(m*the_time);\n    return pos;\n} //camerapos\n\n// --- Per-part routines ---\n\nvoid do_cl_nop(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    camera_pos = vec3(0.0,0.0,10.0);    //default\n    camera_look_at = vec3(0.0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = camera_pos;\n} //do_cl_nop\n\nvoid do_cl_loading(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\nvoid do_cl_hey(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\nvoid do_cl_falken(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\nvoid do_cl_nop2(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\n\n//s_plain = Scroller, Plain\nvoid do_cl_s_plain(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{\n    camera_pos = vec3(charidx_frac*GRID_PITCH-5.0, GRID_CHARHT*0.5, 10.0);\n    camera_look_at = vec3(camera_pos.x+3.0, GRID_CHARHT*0.5,0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = camera_pos;\n    light_pos.y += 4.0 * sin(charidx_frac);\n} //do_cl_s_plain\n\nvoid do_cl_line1(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_s_plain(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_xport(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{ //static camera\n    camera_pos = vec3(/*charidx_frac*/\n        floor(XPORT_NCHARS/2.0)*GRID_PITCH+GRID_PITCH*0.3, GRID_CHARHT*0.5 + 0.5, 10.0);\n    camera_look_at = vec3(camera_pos.x, GRID_CHARHT*0.5,0);\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 68.0;\n    light_pos = camera_pos;\n} //do_cl_xport\n\nvoid do_cl_line2(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_s_plain(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_line3(in float partnum, in float charidx_frac, out vec3 camera_pos,\n     out vec3 camera_look_at, out vec3 camera_up, out float fovy_deg,\n     out vec3 light_pos)\n{ //For the voxel part.\n    camera_pos = vec3(charidx_frac*VGRID_PITCH-5.0, VGRID_CHARHT*0.5+0.5, 20.0);\n    camera_look_at = vec3(camera_pos.x-0.5, VGRID_CHARHT*0.5,0.0);\n\n    camera_up = vec3(0.0, 1.0, 0.0);\n    fovy_deg = 45.0;\n    light_pos = vec3(\n        camera_pos.x + VGRID_PITCH*sin(TWO_PI*0.125*charidx_frac),\n        camera_pos.y+6.0,\n        camera_pos.z-2.0\n    );\n} //do_cl_line3\n\nvoid do_cl_howto(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_line3(pn, cf, cp, cla, cu, fd, lp); }\n\nvoid do_cl_endpart(in float pn, in float cf, out vec3 cp, out vec3 cla, out vec3 cu, out float fd, out vec3 lp) { do_cl_nop(pn, cf, cp, cla, cu, fd, lp); }\n\n// }}}1\n\n// ARTISTRY ///////////////////////////////////////////\n// {{{1\nvoid do_hey(in float partnum, in vec2 charpos, in float clip_charidx,\n            out vec3 diffuse_matl)\n{\n    vec2 pos;\n    diffuse_matl = vec3(0.0);\n\n    //\"Hey\"\n    pos = charpos - vec2(0.0, 1.0*GRID_VPITCH); // move up one line\n    if(is_in_zzero_message(pos, HEY_REALSTART+4.0, GRID_PITCH*5.0, clip_charidx)) {\n        diffuse_matl = vec3(1.0, 0.0, 0.0);\n        return;\n    }\n\n    pos = charpos; // - vec2(0.0, 0.0*GRID_VPITCH);\n    if( (partnum==FALKEN) &&\n        is_in_zzero_message(pos, FALKEN_REALSTART+4.0, GRID_PITCH*5.0, clip_charidx)) {\n        diffuse_matl = vec3(1.0, 1.0, 1.0);\n        return;\n    }\n} //do_hey\n\nvoid color_xport(in vec2 wpt, in vec2 uvpt, in float dt,\n                out vec3 ambient_matl, out vec3 diffuse_matl,\n                out float shininess)\n{ // World point, Fragment point ([0,1] range), time within the effect.\n  // Fades in over time=[0, XPORT_FADEIN_DURATION].\n\n    float ramp = smoothstep(0.0, XPORT_FADEIN_DURATION, dt);\n    ambient_matl = vec3(0.0);   //for now\n\n    // Shininess\n    float s_dt = scalesin(-PI_OVER_2, PI_OVER_2, dt/XPORT_FADEIN_DURATION);\n        // s_dt goes from 0 to pi/2\n    float s_top = mix(XP_SHINE_HIGH, XP_SHINE_AIM, dt/XPORT_FADEIN_DURATION);\n    float s_bot = mix(XP_SHINE_LOW, XP_SHINE_AIM, dt/XPORT_FADEIN_DURATION);\n    float shine = sin(TWO_PI*XP_SHINE_HZ*dt);\n    shininess = scalesin(s_bot, s_top, shine); // [XP_SHINE_LOW, X~_HIGH]\n\n    // Overall gain\n    float g_top = clamp(ramp*1.5, 0.0, 1.0);\n    float g_bot = ramp*ramp;    // <=ramp, so <= g_top\n    float gain = sin(TWO_PI*XP_GAIN_HZ*dt);\n    gain = scalesin(g_bot, g_top, gain);    // [0,1]\n\n    // Localized gain - horizontal\n    float s;\n    \n        s = sin(TWO_PI*XP_H0_PER_U * uvpt.x +\n            TWO_PI*XP_H0_PHASE +\n            TWO_PI*XP_H0_PHASE_PER_SEC * dt);\n        s = mix(s, 1.0, ramp);     // gain effects are 1.0 at the end\n        gain *= scalesin(0.0, 1.0, s);\n    \n        s = sin(TWO_PI*XP_H1_PER_U * uvpt.x +\n            TWO_PI*XP_H1_PHASE +\n            TWO_PI*XP_H1_PHASE_PER_SEC * dt);\n        s = mix(s, 1.0, ramp);     // gain effects are 1.0 at the end\n        gain *= scalesin(0.0, 1.0, s);\n    \n        s = sin(TWO_PI*XP_H2_PER_U * uvpt.x +\n            TWO_PI*XP_H2_PHASE +\n            TWO_PI*XP_H2_PHASE_PER_SEC * dt);\n        s = mix(s, 1.0, ramp);     // gain effects are 1.0 at the end\n        gain *= scalesin(0.0, 1.0, s);\n    \n\n    diffuse_matl = gain * vec3(0.2, 0.2, 1.0);\n} //color_xport\n\n// }}}1\n\n// MAIN ///////////////////////////////////////////////\n// {{{1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init\n    float the_time = iTime; //0.5*mod(iTime, 16.0)+S_PLAIN_START;\n    //float the_time = iTime + XPORT_START - 2.0;\n    //float the_time = mod(iTime,LINE2_START-XPORT_START)+XPORT_START; //DEBUG\n        //0.05*mod(3.48, 20.0)+S_PLAIN_START; //DEBUG test case\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    init_charset();\n\n#if 0\n    // Grayscale ramp for reference\n    if(fragCoord.y<10.0) {\n        fragColor = vec4(vec3(fragCoord.x/iResolution.x),1.0);\n        return; //EXIT POINT\n    }\n#endif\n\n    // --- Story ---\n    vec4 story = get_story(the_time);\n    float partnum=story[0], charidx_frac=story[1];\n    float first_charidx=story[2], clip_charidx=story[3];\n\n    // --- Camera and light ---\n    vec3 camera_pos, camera_look_at, camera_up, light_pos;\n    float fovy_deg;\n\n    do_camera_light(partnum, charidx_frac,\n        camera_pos, camera_look_at, camera_up, fovy_deg, light_pos);\n\n    // Camera processing\n    mat4 view, view_inv;\n    lookat(camera_pos, camera_look_at, camera_up,\n            view, view_inv);\n\n    mat4 proj, proj_inv;\n    gluPerspective(fovy_deg, iResolution.x/iResolution.y, 1.0, 10.0,\n                    proj, proj_inv);\n\n    mat4 viewport, viewport_inv;\n    compute_viewport(0.0, 0.0, iResolution.x, iResolution.y,\n                        viewport, viewport_inv);\n\n    // --- Geometry ---\n\n    vec3 rayend = WorldRayFromScreenPoint(fragCoord,\n                                    view_inv, proj_inv, viewport_inv).xyz;\n    vec3 ray_direction = rayend - camera_pos;\n\n    // Each part determines world coords of the hit, normal at the\n    // hit point, and base color of the geometry.\n\n    vec3 wc_pixel;  // world coords of this pixel\n    vec3 wc_normal; // ditto for the normal\n    vec3 ambient_matl = vec3(0.1);\n    vec3 diffuse_matl = vec3(0.0);\n        // material - light is always white.  Alpha is always 1.\n    float shininess = 4.0;  //Phong shininess\n    bool did_hit = false;   //if not did_hit, just use _diffuse_.\n\n    if(partnum == LOADING) {\n        // Are we in the message?\n        \n            // Grid of character cells\n\n        vec3 hitlocn = HitZZero(camera_pos, rayend);\n            // hitlocn is where it hits z=0, where the letters are\n\n        // Size and move the letters\n        hitlocn.xy *= vec2( 5.00000000000000000000, 3.00000000000000000000);\n        hitlocn.xy += vec2( -15.00000000000000000000, 24.00000000000000000000);\n        did_hit = is_in_basic_message(hitlocn.xy, first_charidx, clip_charidx);\n\n        if(did_hit) {\n            float dt = mod(the_time * 0.2, 1.0);\n            diffuse_matl = hsv2rgb(vec3(\n                mod(the_time, 1.0),\n                1.0,\n                smoothstep(0.0, 0.5, dt) * (1.0-smoothstep(0.5, 1.0, dt))\n            ));\n            did_hit = false;    // only use diffuse_matl\n        } else {    // not in the text\n            // GLSL Sandbox default, tweaked slightly\n            float color = 0.0;\n            float rotation = mod(LOADING_FREQ*the_time, TWO_PI);\n            mat2 rot = mat2(cos(rotation), sin(rotation), -sin(rotation), cos(rotation));\n            vec2 position = rot * uv;\n            color += sin( position.x * cos( the_time / 15.0 ) * 80.0 ) + cos( position.y * cos( the_time / 15.0 ) * 10.0 );\n            color += sin( position.y * sin( the_time / 10.0 ) * 40.0 ) + cos( position.x * sin( the_time / 25.0 ) * 40.0 );\n            color += sin( position.x * sin( the_time / 5.0 ) * 10.0 ) + sin( position.y * sin( the_time / 35.0 ) * 80.0 );\n            color *= sin( the_time / 10.0 ) * 0.5;\n\n            diffuse_matl = vec3( color, color * 0.5, sin( color + the_time / 3.0 ) * 0.75 );\n        } //endif in text else\n\n        diffuse_matl *= (1.0-smoothstep(NOP_START-2.0, NOP_START, the_time));\n            // fade out gently\n\n    } else if( (partnum == NOP) || (partnum == ENDPART) ) {    // black screens\n        diffuse_matl = vec3(0.0);\n\n    } else if( (partnum == HEY) || (partnum == FALKEN) ) {  // Static text\n        // Straight 2d\n        // Grid for this part is 9 chars across and 3 high,\n        // offset by half a character vertically.\n        vec2 charpos = uv * vec2(9.0,3.0);\n            //now charpos is 0..8 horz and 0..3 vert\n        charpos.y -= 0.5;    // now -0.5..2.5 vert are on screen\n        charpos *= vec2(GRID_PITCH, GRID_VPITCH);\n            // Now in coordinates of the segments\n\n        do_hey(partnum, charpos, clip_charidx, diffuse_matl);\n            //did_hit stays false so we just use diffuse_matl.\n\n    } else if(partnum == XPORT) {                       // Beam me up\n        diffuse_matl = vec3(0.0);\n        vec3 hitlocn = HitZZero(camera_pos, rayend);\n            // hitlocn is where it hits z=0, where the letters are\n        did_hit = is_in_basic_message(hitlocn.xy, first_charidx, clip_charidx);\n        if(did_hit) {\n            color_xport(hitlocn.xy, uv, the_time - XPORT_START,\n                ambient_matl, diffuse_matl, shininess);\n            did_hit = false;    // only use diffuse_matl\n            //diffuse_matl = vec3(0.0,1.0,0.0); did_hit = false; //DEBUG\n        }\n    } else if(partnum <= LINE2) {      // Basic scrollers, 2d\n\n        vec3 hitlocn = HitZZero(camera_pos, rayend);\n            // hitlocn is where it hits z=0, where the letters are\n        did_hit = is_in_basic_message(hitlocn.xy, first_charidx, clip_charidx);\n        if(did_hit) {\n            wc_pixel = hitlocn;\n            wc_normal = vec3(0.0,0.0,-1.0 + 2.0*step(0.0, camera_pos.z));\n                // normal Z is -1 if camera_pos.z<0.0, and +1 otherwise.\n                // This benefits TWOSIDED.\n            ambient_matl = vec3(0.2, 0.2, 0.1);\n            diffuse_matl = vec3(0.6,0.6,0.3);\n            shininess = 50.0;\n        }  // else diffuse is the default (0,0,0).\n\n    } else {        // Basic scrollers, voxel\n        diffuse_matl = vec3(0.0);\n        vec3 voxel;\n        did_hit =\n            voxel_is_in_message(camera_pos, ray_direction,\n                                  charidx_frac, first_charidx, clip_charidx,\n                                  voxel, wc_pixel, wc_normal);\n        if(did_hit) {\n            diffuse_matl = vec3(0.2, 0.3, 0.9);\n            shininess = 20.0;\n        }\n    } //endif part switch\n\n    // --- Lighting ---\n    // Phong shading based on the Geometry section's output values\n\n    if(did_hit) {               // a hit\n        vec3 rgb = phong_color(\n            wc_pixel, wc_normal, camera_pos, light_pos,\n            ambient_matl, diffuse_matl, vec3(1.0), shininess);\n\n        fragColor = vec4(rgb, 1.0);\n    } else {                    // no hit - just use diffuse_matl\n        fragColor = vec4(diffuse_matl, 1.0);\n    }\n\n} //mainImage\n\n// }}}1\n\n// vi: set ts=4 sts=4 sw=4 et ai foldmethod=marker foldenable foldlevel=0: //\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcRN.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[4221, 4297, 4318, 4318, 6093], [6119, 6950, 6981, 7254, 9627], [9628, 9641, 9674, 9674, 15956], [15957, 16010, 16045, 16045, 16396], [16413, 18261, 18502, 18535, 20636], [20889, 20953, 20991, 21116, 21470], [21472, 21472, 21578, 21720, 22675], [22676, 22686, 22846, 23025, 23745], [23746, 23764, 23895, 24069, 24724], [24746, 24814, 24894, 24927, 25085], [25093, 25149, 25262, 25363, 26185], [26186, 26213, 26235, 26359, 26528], [26530, 26530, 26586, 26619, 26677], [27038, 27414, 27449, 28256, 28467], [28468, 28480, 28615, 28699, 29402], [29415, 29556, 29661, 30108, 33147], [33236, 33292, 33337, 33448, 33566], [33579, 33865, 33935, 34211, 34681], [34913, 35052, 35222, 35541, 37186], [37187, 37210, 37299, 37442, 38938], [39144, 39153, 39349, 39767, 42825], [42923, 43024, 43340, 43664, 44499], [44887, 44917, 45090, 45090, 45260], [45261, 45274, 45387, 45387, 45429], [45430, 45430, 45539, 45539, 45581], [45582, 45582, 45694, 45694, 45736], [45737, 45737, 45847, 45847, 45889], [45891, 45919, 46096, 46096, 46367], [46368, 46385, 46496, 46496, 46542], [46544, 46544, 46719, 46735, 47011], [47012, 47027, 47138, 47138, 47184], [47186, 47186, 47361, 47383, 47739], [47740, 47755, 47866, 47866, 47910], [47912, 47912, 48025, 48025, 48067], [48078, 48142, 48248, 48248, 48761], [48762, 48772, 48929, 49051, 50599], [50624, 50689, 50746, 50758, 57389]], "test": "error"}
{"id": "XdXcW4", "name": "peacock monster2", "author": "pde", "description": "Here we have an IFS that generalises from the Julia set; and a plasma tiled out according to the distance covered  by a certain number of iterations of that map. Clicking and dragging alters the IFS parameters.", "tags": ["plasma", "ifs"], "likes": 2, "viewed": 155, "published": "Public", "date": "1488131790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmult(vec2 a, vec2 b)\n{\n    vec2 c;\n    c.x = a.x * b.x - a.y * b.y;\n    c.y = a.x * b.y + a.y * b.x;\n    return c;\n}\n\nvec2 weirdmap(vec2 a, vec2 b, float exp)\n{\n    vec2 c;\n    c.x = a.x * b.x - pow(abs(a.y), abs(0.25 + exp));\n    c.y = a.x * b.y + a.y * b.x;\n    return c;\n}\n\nvec2 spacify(vec2 p)\n{\n    vec2 c = (p.xy / (iResolution.xy * 0.8)) - vec2(0.9, 0.6);\n\treturn c;\n}\n\nvec2 unspacify(vec2 p)\n{\n    vec2 screenPos;\n    screenPos.xy = p.xy + vec2(0.9, 0.6);\n    screenPos.xy *= iResolution.xy * 0.8;\n    return screenPos;\n}\n\n\nvec2 startwalk()\n{\n    vec2 z;\n    vec2 mouse = iMouse.xy;\n    clamp(mouse.x, 0.0, iResolution.x);\n    clamp(mouse.y, 0.0, iResolution.y);\n\n    z = 2.0 * spacify(mouse.xy);\n    z.x += 0.2 * sin(iTime*3.0) * cos(iTime * 0.22);\n    z.y += 0.2 * sin(iTime*2.0) * cos(iTime * 1.3);\n    return z;\n}\n\nfloat pi2 = 0.5 * 3.14159265359;\n\nfloat piecewise(float x)\n{\n\tif (x <= 2.0 ) return sin(x);\n    if (x <= 10.0) return sin(log(x));\n    return sin(log(log(x)));\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 colour(vec2 start, vec2 end, int n)\n{\n    float g = piecewise(length(start - end));\n    //g -= float(floor(g));\n    float b = piecewise(length(spacify(iMouse.xy) - end)*2.0);\n    //b -= float(floor(g));\n    //float invsq = 1.0 / (length(start) * length(start));\n    /*float v = g;\n    float h = float(mod(float(n), 12.0))/12.0;\n    float s = b;\n    vec3 rgb = hsv2rgb(vec3(h,s,v));\n    return vec4(rgb[0], rgb[1], rgb[2], 1.0);*/\n    \n    return vec4(float(n)/64.0, g, b, 1.0);\n}\n\n\nvoid pdeMainImage(out vec4 fragColor, in vec2 fragCoord, out vec2 zplas )\n{\n\tvec2 c = spacify(fragCoord);\n   \n    vec2 c1 = c * 2.5;\n    vec2 c2 = c * (2.3 + 0.2 * sin(iTime));\n    float vert = 5.0*(iMouse.y / iResolution.y) + 0.4 * sin(iTime / 2.1);\n    \n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    vec2 z = startwalk();\n    int i = 0;\n    vec2 z2;\n    zplas = z;\n    for (int n = 0; n < 64; n++) {\n        if (i == 0 && length(z) > 16.0) i = n;\n        if (n == 3) zplas = z;\n        /*if (n == 4 && length(z) > 2.0) zplas = z; \n        if (n == 5 && length(z) > 3.0) zplas = z;*/\n        if (n == 10) z2 = z;\n        z = weirdmap(z, z, vert) + c2;                \n    }\n    fragColor = colour(c1, z2, i);\n    \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}\n\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nfloat PI = 3.14;\n\nvec3 RotateVec3Z(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nvec2 RotateVec2Z(vec2 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec2(cos * v.x + sin * v.y, -sin * v.x + cos * v.y);\n}\n\nvoid daisyMainImage( out vec4 fragColor, in vec2 fragCoord, in vec2 zplas )\n{\n    fragCoord = unspacify(zplas);\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    r = RotateVec2Z(r, 0.5 * PI + iTime / 3.0);\n\n    float t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) + t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\t\n\t// mix colors\n\tv *= 1.0;\n\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\nfloat max4(vec4 a)\n{\n    return max(max(a.x, a.y), a.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c1, c2, c3, shadow;\n    vec2 zplas;\n    pdeMainImage(c1, fragCoord, zplas);\n    daisyMainImage(c2, fragCoord, zplas);\n    c3 = vec4(0.0);\n    c3[0] = c2[0];\n    c3[1] = c2[1] * c1[1];\n    c3[2] = c2[2] * max4(c1);\n\t//fragColor = softmax(c1, c2);\n    fragColor = c3;\n    /*vec2 offset = spacify(fragCoord);\n    offset *= 1.2;\n    offset = unspacify(offset);\n    pdeMainImage(shadow, offset);    \n    fragColor = max(c3, 0.0 * shadow);*/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 122], [124, 124, 166, 166, 281], [283, 283, 305, 305, 381], [383, 383, 407, 407, 535], [538, 538, 556, 556, 831], [867, 867, 893, 893, 994], [997, 997, 1019, 1019, 1182], [1184, 1184, 1226, 1226, 1668], [1671, 1671, 1746, 1746, 2432], [2434, 2768, 2805, 2805, 2946], [2948, 2948, 2985, 2985, 3121], [3123, 3123, 3200, 3200, 3774], [3776, 3776, 3796, 3796, 3834], [3836, 3836, 3893, 3893, 4340]], "test": "valid"}
{"id": "XdXcW8", "name": "Xor Texture", "author": "TrueBoolean", "description": "Finally, some bit-wise operator support! Its gonna be fun!", "tags": ["xorbitwise"], "likes": 1, "viewed": 266, "published": "Public", "date": "1487827296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coords = ivec2( fragCoord.xy*256./iResolution.xy );\n    vec3 col = vec3( float( (((coords.x)^ coords.y)^iFrame)%256 ) / 255.);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 224]], "test": "valid"}
{"id": "XdXyz8", "name": "Cloudball", "author": "Hadyn", "description": "Experimenting with 3D noise functions and raymarching.", "tags": ["raymarching", "cloud", "3dnoise"], "likes": 18, "viewed": 408, "published": "Public", "date": "1486887992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by hadyn lander\n\n#define STEPS 16\n#define FOV 120.\n#define NEARPLANE 0.0001\n#define UP vec3(0.0, 1.0, 0.0)\n#define SUN_VECTOR normalize(vec3(1,0.65,0))\n\n// I borrowed this useful function from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// 3D noise by IQ https://www.shadertoy.com/view/Xsl3Dl\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n// knightly's rotated gradient suggestion\nvec3 knightlyHash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n#if 1\n\tfloat t=iTime*0.5;\n\tmat2 m=mat2(cos(t),-sin(t), sin(t),cos(t));\n\tp.xz=m*p.xz;\n#endif\n\treturn p;\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( knightlyHash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( knightlyHash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( knightlyHash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( knightlyHash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( knightlyHash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( knightlyHash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( knightlyHash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( knightlyHash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fractalNoise( in vec3 pos)\n{\n \tvec3 q = pos + vec3(0, -iTime*0.025, 0);\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n\n    //f = noise(pos*2.0);\n\tf = smoothstep( -0.7, 0.7, f ); \n    return f;\n}\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n// Based on IQ's tutorial http://www.iquilezles.org/blog/?p=2411\nvec2 sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(1.0 / 0.0);\n    h = sqrt( h );\n    return vec2(-b - h, -b +h);\n}\n\n\nvoid marchRay( vec3 ro, vec3 rd, inout vec3 finalCol)\n{ \n    \n    vec2 intersect = sphIntersect(ro, rd, vec4(0,0,0.0,1.5));\n    if(intersect.x == 1.0/0.0 || intersect.y < 0.0)\n        return;\n    \n    intersect.x = max(intersect.x, 0.0);\n    ro += rd * intersect.x;    \n    float intersectionLength = (intersect.y - intersect.x);\n    \n    float stepLength = intersectionLength/float(STEPS-1);\n    \n    float density = 0.0;\n    float t = 0.0;\n\tfor( int i=0; i<STEPS; i++ )\n\t{        \n        vec3 p = ro + t*rd;\n        density += smoothstep(0.5, 0.65, fractalNoise(p*0.65));\n        t += stepLength;\n\t}\n    density /= float(STEPS);\n    float edgeDot = abs(dot(rd, normalize(ro)));\n    float edgeFade = 1.0-pow(1.0-edgeDot, 4.0);\n    density *= edgeFade;\n    //density += 0.5*abs(dot(rd, normalize(ro)));\n    density = smoothstep(0.2, 0.65, density);\n    density *= intersectionLength/3.0;\n    \n    // Cloud colour\n    finalCol.rgb = mix(finalCol, vec3(1), density);\n    \n    // Orb shading\n    float orbDot = 0.5+0.5*(dot(SUN_VECTOR, normalize(ro)));\n    finalCol = mix(finalCol, vec3(1.0), 0.5*orbDot*edgeFade*(intersectionLength/3.0) );\n    \n    // Edge halo\n    float edgeRing = 0.75*pow(1.0-abs(2.0*pow(1.0-edgeDot, 2.0)-1.0), 4.0);\n    finalCol = mix(finalCol, vec3(0.5) + 0.5*(finalCol + vec3(0.5)), edgeRing);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 R = iResolution.xy,\n    uv = ( fragCoord - .5*R) / R.y;\n    \n    vec2 mouse = ( iMouse.xy - .5*R) / R.y;\n    mouse *= step(0.0,iMouse.z);\n    \n    float camDist = 1.0/tan(radians(FOV*0.5));\n    \n    vec3 camForward = vec3(0, 0, 1);\n    camForward = mat3(rotationMatrix(UP, mouse.x*-radians(180.0) + iTime*radians(10.0))) * camForward;\n\tvec3 camRight = cross(UP, camForward);\n    camForward = mat3(rotationMatrix(camRight, mouse.y*radians(90.0) )) * camForward;\n\tvec3 camUp = cross(camForward, camRight);\n    vec3 vectorToPixel = vec3(uv.xy,camDist)*NEARPLANE;\n   \tvectorToPixel = (uv.x*camRight + uv.y*camUp + camDist*camForward)*NEARPLANE;\n    vec3 camPosition = camForward * (-2.4 + 0.5*sin(0.1*(iTime-32.0)));\n\n    float skyDot = dot(normalize(vectorToPixel), SUN_VECTOR);\n    // BG gradient:\n    vec3 bgCol = mix(vec3(0.2, 0.1, 0.4), vec3(0.4, 0.6, 1.0), 0.5+0.5*skyDot);\n    // Add sun flare:\n    bgCol = mix( bgCol, vec3(1.15, 1.0, 1.5), pow(max(1.0-degrees(acos(clamp(skyDot, 0.0, 1.0)))*0.015, 0.0), 8.0));\n    vec3 result = vec3(bgCol);\n    marchRay(camPosition, normalize(vectorToPixel), result);\n    //fragColor = vec4(mix(bgCol, result.rgb, result.a), 1.0);\n    fragColor = vec4(result, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 268, 313, 313, 941], [1295, 1337, 1366, 1366, 1634], [1637, 1637, 1663, 1663, 2552], [2680, 2680, 2714, 2714, 3008], [3501, 3566, 3615, 3615, 3831], [3834, 3834, 3889, 3889, 5152], [5154, 5154, 5211, 5211, 6426]], "test": "valid"}
{"id": "XlGSDd", "name": "n-powered Mandelbrot", "author": "yumcyawiz", "description": "n-powered", "tags": ["fractal"], "likes": 2, "viewed": 90, "published": "Public", "date": "1487301056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//math\nvec2 cmult(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x - z1.y*z2.y, z1.x*z2.y + z1.y*z2.x);\n}\nvec2 cpow(vec2 z, float a) {\n    float r = length(z);\n    float arg = atan(z.y, z.x);\n    \n    r = pow(r, a);\n    arg *= a;\n    \n    return vec2(r*cos(arg), r*sin(arg));\n}\n\n\nconst int maxIter = 300;\nfloat mandelbrot(vec2 c, float n) {\n    vec2 z = vec2(0.0, 0.0);\n    vec2 zd = vec2(0.0, 0.0);\n    for(int i = 0; i < maxIter; i++) {\n        if(length(z) > 10.0) break;\n        zd = n*cmult(cpow(z, n-1.0), zd) + vec2(1.0, 0.0);\n        z = cpow(z, n) + c;\n    }\n    \n    float d = 0.5*length(z)*log(length(z))/length(zd);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = vec2(-0.749, 0.101);\n    float scale = 1.0/pow((0.01*float(iFrame)), 1.0);\n    scale = 1.0;\n\tvec2 uv = scale*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y + offset;\n    \n    float d = mandelbrot(uv, float(iTime)/2.0 + 1.0);\n    float color = clamp(8.0*d/scale, 0.0, 1.0);\n    color = pow(color, 0.2);\n    \n\tfragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 37, 37, 102], [103, 103, 131, 131, 274], [302, 302, 337, 337, 640], [643, 643, 700, 700, 1069]], "test": "valid"}
{"id": "XlGXW3", "name": "Menger Sponge Anaglyph", "author": "loic_fejoz", "description": "An anaglyph rendering of https://www.shadertoy.com/view/4sX3Rn", "tags": ["3d", "raymarching", "fractal", "anaglyph", "menger", "vr"], "likes": 0, "viewed": 645, "published": "Public API", "date": "1486070509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n\tfloat off = 1.5*sin( 0.01*iTime );\n\t\n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\n// light\nvec3 light = normalize(vec3(1.0,0.9,0.3));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\n    vec3 col = mix( vec3(0.3,0.2,0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y );\n\t\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.x>0.0 )\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n\t\t\n        float occ = tmat.y;\n\t\tfloat sha = softshadow( pos, light, 0.01, 64.0 );\n\n\t\tfloat dif = max(0.1 + 0.9*dot(nor,light),0.0);\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float bac = max(0.4 + 0.6*dot(nor,vec3(-light.x,light.y,-light.z)),0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00*dif*vec3(1.10,0.85,0.60)*sha;\n        lin += 0.50*sky*vec3(0.10,0.20,0.40)*occ;\n        lin += 0.10*bac*vec3(1.00,1.00,1.00)*(0.5+0.5*occ);\n        lin += 0.25*occ*vec3(0.15,0.17,0.20);\t \n\n        vec3 matcol = vec3(\n            0.5+0.5*cos(0.0+2.0*tmat.z),\n            0.5+0.5*cos(1.0+2.0*tmat.z),\n            0.5+0.5*cos(2.0+2.0*tmat.z) );\n        col = matcol * lin;\n    }\n\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.0,1.0,2.5), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainPlain(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // camera\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*ctime),1.0+1.0*cos(ctime*.13),2.5*cos(0.25*ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    vec4 col;\n    mainVR(col, fragCoord, ro - vec3(0.0,1.0,2.5), rd);\n\n    fragColor = col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainAnaglyph(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // camera\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*ctime),1.0+1.0*cos(ctime*.13),2.5*cos(0.25*ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    //vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    vec3 ta = vec3(0.0);\n\n\tvec3 eyes_line = normalize(cross(vec3(0.0, 1.0, 0.0), ro));\n\tfloat d_eyes_2 = 0.08;\n\tvec3 ro_left = ro + d_eyes_2 * eyes_line;\n\tvec3 ro_right = ro - d_eyes_2 * eyes_line;\n    vec3 ta_left = ta + d_eyes_2 * eyes_line;\n    vec3 ta_right = ta - d_eyes_2 * eyes_line;\n\n\n\t// camera-to-world transformation\n    mat3 ca_left  = setCamera(ro_left, ta_left, 0.0);\n    mat3 ca_right = setCamera(ro_right, ta_right, 0.0);\n\n    // rays' direction\n\tvec3 rd_left = ca_left * normalize( vec3(p.xy,1.0) );\n\tvec3 rd_right = ca_right * normalize( vec3(p.xy,1.0) );\n\n    // render both eye\n    vec4 col_left;\n    mainVR(col_left, fragCoord, ro_left - vec3(0.0,1.0,2.5), rd_left);\n    vec4 col_right;\n    mainVR(col_right, fragCoord, ro_left - vec3(0.0,1.0,2.5), rd_right);\n\n    //vec3 col = vec3( col_right.r, col_left.g, col_left.b);\n    vec3 col = vec3( col_left.r, col_right.g, col_right.b);\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // mainPlain(fragColor, fragCoord);\n    mainAnaglyph(fragColor, fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 58], [59, 59, 90, 90, 181], [309, 309, 332, 332, 1001], [1003, 1003, 1045, 1045, 1312], [1314, 1314, 1379, 1379, 1605], [1607, 1607, 1637, 1637, 1875], [1877, 1930, 1969, 1993, 2924], [2926, 2926, 3020, 3020, 3125], [3127, 3127, 3183, 3183, 3693], [3695, 3695, 3747, 3747, 3924], [3926, 3926, 3985, 3985, 5340], [5342, 5342, 5398, 5438, 5480]], "test": "valid"}
{"id": "XlKXD3", "name": "Smoothstep/haversine/linear", "author": "ConorStokes", "description": "Expands won3d's https://www.shadertoy.com/view/MlGXD3 to show haversine as well as smoothstep and bilinear (smoothstep, followed by haversine, followed by bilinear)", "tags": ["filtering", "linear", "smoothstep", "haversine"], "likes": 6, "viewed": 569, "published": "Public API", "date": "1486211119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on won3d's smoothstep filter example (https://www.shadertoy.com/view/MlGXD3)\n// Which was in turn based on hornet's bicubic filter example (https://www.shadertoy.com/view/MtVGWz)\n\nvec4 sampleLevel0( vec2 uv )\n{\n    return texture( iChannel0, uv, -10.0 );\n}\n\n\nvec4 SampleSmoothlinear( vec2 uv, vec2 texSize )\n{\n    // Round  down the sample location to get the exact center of our \"starting\" texel\n    // The starting texel will be at location [1, 1] in the grid, where [0, 0] is the\n    // top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample.\n    vec2 f = samplePos - texPos1;\n\n    // !!! smoothstep fractional offsets. Cheaper things would likey work as well but \n    // this is simple as a PoC.\n    f = smoothstep(vec2(0.0), vec2(1.0), f);\n    \n    // That's it!\n    return sampleLevel0((texPos1 + f)/texSize);\n}\n\n\nvec4 SampleHaversinelinear( vec2 uv, vec2 texSize )\n{\n    // Round  down the sample location to get the exact center of our \"starting\" texel\n    // The starting texel will be at location [1, 1] in the grid, where [0, 0] is the\n    // top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample.\n    vec2 f = samplePos - texPos1;\n\n    // !!! change smoothstep to haversine\n    f = ( vec2( 1.0 ) - cos( f * 3.141592) ) * 0.5;\n    \n    // That's it!\n    return sampleLevel0((texPos1 + f)/texSize);\n}\n\n//note: uniform pdf rand [0;1[\nvec3 hash32n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4307, p.x * p.y * 97.5901, p.x * p.y * 93.8369));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.33333 );\n   \tsample_uv += 0.01 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= (iMouse.z>0.0)? iMouse.x * 0.001 : 0.06125;\n    \n    vec4 samplev;\n    if ( uv.x < 0.3333 )\n    \tsamplev = SampleSmoothlinear( sample_uv, iChannelResolution[0].xy );\n    else if ( uv.x < 0.66667 )\n        samplev = SampleHaversinelinear( sample_uv, iChannelResolution[ 0 ].xy );\n    else\n        samplev = sampleLevel0( sample_uv );\n\n    fragColor = samplev;\n    fragColor -= step(abs(uv.x-0.3333), 0.001);\n    fragColor -= step(abs(uv.x-0.6667), 0.001);\n    fragColor.rgb += (hash32n(uv+fract(iTime))+hash32n(uv+0.1337*fract(iTime))-1.0)/255.0; //dither output\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 189, 219, 219, 265], [268, 268, 318, 515, 957], [960, 960, 1013, 1210, 1582], [1584, 1615, 1637, 1637, 1814], [1816, 1816, 1873, 1873, 2629]], "test": "error"}
{"id": "XlKXDc", "name": "Hall for the gifted", "author": "lherm", "description": "Some loop practice", "tags": ["raymarch"], "likes": 4, "viewed": 499, "published": "Public API", "date": "1486239473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime\n#define PI 3.1415926\nvoid r(inout vec2 p, in float a) {p = cos(a)*p + sin(a)*vec2(p.y, -p.x);}\nfloat sb(in vec3 p, in vec3 b) {vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)), 0.) + length(max(d, 0.));}\nfloat sp(in vec3 p, in vec4 n) {return dot(p,n.xyz) + n.w;}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(in vec3 p)\n{\n    p.y += sin(p.z*.5 + T);\n    p.x += 2.;\n    vec3 c = p*.5;\n    p = mod(p-2., 4.)-2.;\n    p = abs(p);\n    float s = .3;\n    float d = sb(p, vec3(s, p.y, s));\n    d = smin(d, sp(c+vec3(0., .5, 0.), vec4(0., 1., 0., 1.)), .2);\n    d = smin(d, length(cos(p)) - .1, .4);\n    for (int i = 0; i < 3; i++)\n    {\n        p.y -= 1.;\n        r(p.xy, PI / 2. + T * float(i));\n        r(p.yz, PI / 2. - T * float(i));\n        r(p.zx, PI / 4. * c.y + T);\n        d = smin(d, sb(p, vec3(s, p.y, s)), .5);\n        s *= .75;\n    }\n    return d;\n}\n\n// lj's raymarch from Revision\nfloat df(in vec3 ro, in vec3 rd)\n{\n    float d = 0.;\n    float ii;\n    for (int i = 0; i < 100; i++)\n    {\n        ii = float(i);\n        float m = map(ro + rd * d);\n        d += m*.9;\n        if (abs(m) < 0.02) break;\n        if (d > 40.) break;\n    }\n    return 1.-ii/30.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(uv, -T), rd = normalize(vec3(uv, -1.)), p, n, col;\n    float m = df(ro, rd);\n    p = ro + rd * m;\n    col = vec3(m);\n    col = abs(sin(col + vec3(.92424, .122, .5245) + T))+clamp(tan(1.+ T*.5)*.5, .1, .2);\n\tfragColor = vec4(col,1.0);\n    fragColor = 1.-fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 71, 71, 110], [111, 111, 143, 143, 224], [225, 225, 257, 257, 284], [286, 286, 327, 327, 420], [422, 422, 444, 444, 977], [979, 1010, 1044, 1044, 1286], [1288, 1288, 1345, 1345, 1721]], "test": "valid"}
{"id": "XlKXDV", "name": "Crappy Water", "author": "pineapplemachine", "description": "I make the best water shaders. They're terrific. Everyone agrees.", "tags": ["water"], "likes": 3, "viewed": 142, "published": "Public", "date": "1485985174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nconst vec4 deepblue = vec4(0.05, 0.3, 0.74, 1.0);\nconst vec4 midblue = vec4(0.12, 0.36, 0.85, 1.0);\nconst vec4 whiteblue = vec4(0.5, 0.76, 0.94, 1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = (fragCoord.xy / iResolution.xy - vec2(0.5, 0.5)) * 4.0;\n    uv.x += cos(iTime * 0.25) * 0.2;\n    uv = uv + uv * sin(iTime * 0.2) * 0.1;\n    float waves1 = abs(cos(uv.x * cos(uv.y / PI) * PI) + sin(uv.y * PI + iTime)) / 2.0;\n    float waves2 = (cos(sin(uv.x - uv.y) + iTime) + sin(uv.x * uv.x * uv.y)) / 2.0;\n    vec4 color = midblue;\n    if(waves2 < 0.125) color = deepblue;\n    if(waves1 < 0.125) color = whiteblue;\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 252, 252, 702]], "test": "valid"}
{"id": "XlVSDc", "name": "Headache Experiment 2", "author": "aiekick", "description": "Headache Experiment 2", "tags": ["experiment", "headache", "2"], "likes": 3, "viewed": 429, "published": "Public API", "date": "1486229216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 path(vec3 p)\n{\n\tp *= RotZ(p.z * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n    p *= RotZ(p.z * 0.01);\n   \treturn sin(p.zxy * 0.2) * 2.;\n}\n\nfloat wireShape(vec3 p, float df, float size, float thick, vec3 space) \n{\n\treturn length(\n\t\tmin(\n\t\t\tmin(\n\t\t\t\tvec2(df - size,abs(p.y)-space.y),\n\t\t\t\tvec2(df - size,abs(p.z)-space.z)\n\t\t\t),\n\t\t\tvec2(df - size,abs(p.x)-space.x)\n\t\t)\n\t) - thick;\n}\n\nfloat thick = 0.05;\nfloat space = 0.5;\nfloat radius = 2.;\nfloat dist = 0.;\n    \nfloat df(vec3 p)\n{\n\tp += path(p);\n\tp.z = mod(p.z,space)-space*.5;\n    dist = max(abs(p.x),abs(p.y));\n    dist += length(p);\n    //dist += max(abs(p.y)+p.x,-p.x);\n    //dist += abs(p.y);\n    return wireShape(p, dist, radius, thick, vec3(0.15));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 3;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s)/s;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = iTime*2.5*(sin(iTime*0.01)*.5+.5);\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n\tro -= path(ro)*.95;\n\t\n\tvec3 cv = ro + vec3(0,0,4); // cam view\n\t\n    cv -= path(cv)*.5;\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<100; i++) \n\t{\n\t\tif (log(d*d/s/1e6)>0.|| d > 100.) break; \n\t\td += (s = df(ro+rd*d))*0.5;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(0.8,0.5,0.2);\n\tfloat sss = df(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.01);\t\t\t\t\t\t\t// deep subdensity \n\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 1.0 - SubDensity(p, 1.5); \t\t\t\t\t\t\t// one step sub density of df of 1.5 of subsurface\n\t\n\tvec3 a = (diff + fre + bb * sss * .8 + col * sss * .2) * 0.35 + spe;\n    vec3 b = col * sss2;\n    \n\tfragColor.rgb = mix(a, b, .8-exp(-0.005*d*d));\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVSDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [293, 293, 312, 312, 454], [456, 456, 529, 529, 695], [777, 777, 795, 795, 1022], [1024, 1024, 1058, 1058, 1258], [1260, 1481, 1509, 1509, 1834], [1836, 1918, 1975, 1975, 2198], [2200, 2200, 2236, 2236, 2371], [2373, 2373, 2430, 2430, 3967]], "test": "valid"}
{"id": "XlySWd", "name": "Proton", "author": "Nimajamin", "description": "Music: https://soundcloud.com/ngc4244/breathe-and-do-shit\n\n(C) 2016-17 Intrepid & N-e-b-u-l-o-u-s", "tags": ["raymarching", "time", "audio", "gravity", "soundcloud", "proton"], "likes": 16, "viewed": 764, "published": "Public", "date": "1486342360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// [ \"Breathe\" ] - Nimajamin, iq & chronos 2017\n//\n\n// Ray-marching based on: \"[NV15] Space Curvature\" by iq\n    \n// Created by inigo quilez - iq/2015\n// Modified by benjamin hathaway - nimajamin/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n// Audio visualisation..\n//\n// - Modified version of the Soundcloud example by: chronos\n// - https://www.shadertoy.com/view/lsdGR8\n//\n\n//\n// Music: https://soundcloud.com/ngc4244/breathe-and-do-shit\n// \n// (C) 2016-17 Intrepid & N-e-b-u-l-o-u-s\n// All rights reserved\n//\n// [ ncg 4244 ]\n//\n\n#define speed1  \t\t\t0.0003330 \n#define K_MAX_DISTANCE\t\t200.0\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    \n    float b = dot( rd, oc );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float h = dot( oc, oc ) - b*b;\n    return sqrt( max(0.0,h)) - sph.w;\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );\n}    \n   \n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return (pos - sph.xyz)/sph.w;    \n}\n\n//=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel2, d, 0.91, 0.0 ).x );\n\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 50.0*d.xy );\n    vec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n // Green / Blue / Salmon Tint.. (Purple without!)  \n //   col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n\n}\n\n//--------------------------------------------------------------------\n\nvec4 sph1 = vec4(  0.00, 0.00,  0.00, 1.0 );\nvec4 sph2 = vec4( -0.10, 0.00,  0.00, 0.015 );\nvec4 sph3 = vec4(  0.10, 0.00,  0.00, 0.015 );\nvec4 sph4 = vec4(  0.00, 0.00, -0.10, 0.03 );\n\nfloat rayTrace( in vec3 ro, in vec3 rd )\n{\n    return shpIntersect( ro, rd, sph1 );\n}\n\nfloat map( in vec3 pos, in float sample1 )\n{\n    vec2 delta = (pos.xz - sph1.xz);\n    vec2 r = delta;//mix( delta, fract(delta), sample1 );\n    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));\n    return pos.y - h;\n}\n\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax, in vec3 samples123 )\n{\n    float t = 0.0;\n    \n    // bounding plane\n    float h = (1.0-ro.y)/rd.y;\n    if( h>0.0 ) t=h;\n\n    // raymarch\n    for( int i=0; i<20; i++ )    \n    {        \n        vec3 pos = ro + t*rd;\n        float h = map( pos, samples123.x );\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    return t;    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 samples123, in vec3 spline )\n{\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col = background( rd, lig );\n    \n    // Raytrace stuff..\n    float t1 = shpIntersect( ro, rd, sph1 );\n    float t2 = shpIntersect( ro, rd, sph2 );\n    float t3 = shpIntersect( ro, rd, sph3 );\n    float t4 = shpIntersect( ro, rd, sph4 );\n\n    if ( t1>0.0 )\n    {\n        vec3 mat = vec3( 0.18 );\n        vec3 pos = ro + t1*rd;\n        vec3 nor = sphNormal( pos, sph1 );\n            \n        float am = 0.1*iTime;\n        vec2 pr = vec2( cos(am), sin(am) );\n        vec3 tnor = nor;\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\n\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\n        pr = vec2( cos(am2), sin(am2) );\n        vec3 tnor2 = nor;\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\n\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\n\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\n\n        col -= col * 0.6;\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\n    }\n    \n    // Raymarch stuff..\n    float tmax = K_MAX_DISTANCE;\n    if ( t1>0.0 ) tmax = t1; \n    t1 = rayMarch( ro, rd, tmax, samples123 );    \n    if ( t1 < tmax )\n    {\n    \t\t//\n    \t\t// ! !! !!! - Time Warp the camera position using the audio freuency data..! :))\n    \t\t//\n    \t\tt1 += (0.9 + (0.1*samples123.x)) * samples123.z * 0.25;\n\n        \tvec3 pos = ro + t1 * rd;\n\n            vec2 scp = sin(2.0*6.2831*pos.xz);\n            \n            vec3 wir = vec3( 0.0 );\n        \n        \tfloat offset = samples123.z * (1.0 + (samples123.x * 3.0));\n        \n            wir += 1.00*exp(-12.0*offset*abs(scp.x));\n            wir += 1.00*exp(-12.0*offset*abs(scp.y));\n            wir += 0.50*exp( -4.0*offset*abs(scp.x));\n            wir += 0.50*exp( -4.0*offset*abs(scp.y));\n        \n        \twir += 1.00*exp(-12.0*(1.0-samples123.x)*2.0*abs(scp.x));\n          \twir += 1.00*exp(-12.0*(1.0-samples123.x)*2.0*abs(scp.y));\n          \twir += 0.50*exp( -4.0*(1.0-samples123.x)*2.0*abs(scp.x));\n          \twir += 0.50*exp( -4.0*(1.0-samples123.x)*2.0*abs(scp.y));\n\t\t\twir *= 0.5;\n        \n        \twir *= 0.2 + 1.0 * sphSoftShadow( pos, lig, sph1, 4.0 );\n    \n            col += wir * 0.5 * exp( -0.05 * t1 * t1 );\n    }        \n\n    // Main sphere...\n    if ( dot(rd,sph1.xyz-ro) > 0.0 )\n    {\n    \tfloat d = sphDistance( ro, rd, sph1 );\n    \tvec3 glo = vec3(0.0);\n    \tglo += vec3(0.6, 0.7, 1.0) * 0.3 * exp(  -2.0 * abs(d)) * step(0.0,d);\n    \tglo += 0.6 * vec3(0.6,0.7,1.0)*0.3*exp(  -8.0 * abs(d));\n    \tglo += 0.6 * vec3(0.8,0.9,1.0)*0.4*exp(-100.0 * abs(d));\n    \tcol += glo * 2.0 * ( samples123.y + samples123.x );\n        \n        // R U\n        if ( dot(rd,sph2.xyz-ro) > 0.0 )\n        {\n            float d = sphDistance( ro, rd, sph2 );\n            vec3 glo = vec3(0.0);\n            glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n            glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n            glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n            col.x += glo.x*20.0*(samples123.x*(0.3+spline.x));\n        }        \n\n        // G U\n        if ( dot(rd,sph3.xyz-ro) > 0.0 )\n        {\n            float d = sphDistance( ro, rd, sph3 );\n            vec3 glo = vec3(0.0);\n            glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n            glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n            glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n            col.y += glo.y*20.0*(samples123.x*(0.3+spline.y));\n        }        \n\n        // B D\n        if ( dot(rd,sph4.xyz-ro) > 0.0 )\n        {\n            float d = sphDistance( ro, rd, sph4 );\n            vec3 glo = vec3(0.0);\n            glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n            glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n            glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n            col.z += glo.z*20.0*(samples123.y*spline.z);\n        }        \n    }        \n    \n    col *= smoothstep( 0.0, 6.0, iTime );\n\n    return col;\n}\n\nvec2 grid_metric( in vec3 ro, in vec3 rd, in vec3 samples123 )\n{\n    // raytrace stuff    \n    float t = rayTrace( ro, rd );\n\n    // raymarch stuff    \n    float tmax = K_MAX_DISTANCE;\n    if( t>0.0 ) tmax = t; \n    t = rayMarch( ro, rd, tmax, samples123 );    \n    if( t<tmax )\n    {\n      \tvec3 pos = ro + t*rd;\n\n        vec2 scp = ( sin( ( pos.xz * 0.1 ) + 0.0 ) + 0.5 ) * 1.0;\n\t    return scp;\n    }        \n\n    return vec2(0.0, 0.0);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n// RGB Eye response..\n\nconst vec3 deSatConst = vec3( 0.299, 0.587, 0.114 );\n\n// Audio sampling helper..\n\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\n\n// Returns 3 B-spline functions of degree 2..\n\nvec3 B2_spline(vec3 x) \n{ \n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\n\n//    vec2 uv = p;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime * speed1 + 0.25;\n\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\n    \n    uv = grid_metric( ro, rd, vec3(0.0) );\n    vec2 centered = 2.0 * uv - 1.0;\n    centered.x *= iResolution.x / iResolution.y;\n    float dist2 = dot(centered, centered);\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\n    float arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\n    vec2 fft = uv.xy;\n    fft -= 0.5;\n    fft *= 1.75;\n    fft.x *= iResolution.x / iResolution.y;\n    float sample1 = audio_freq(iChannel3, abs(2.0 * sqrt(dot(fft,fft)) - 1.0) + 0.01);\n    float sample2 = audio_ampl(iChannel3, clamped_dist);\n    float sample3 = audio_ampl(iChannel3, arclength);\n\n    sph1.w = sample2 * 0.3 + 0.707;\n    \n    uv = grid_metric( ro, rd, vec3( (sample1 + sample3 * 0.7 * sample1) * sample3 * 0.7, sample2, sample3 ) );\n   \n    centered = 2.0 * uv - 1.0;\n    centered.x *= iResolution.x / iResolution.y;\n    dist2 = dot(centered, centered);\n    clamped_dist = smoothstep(0.0, 1.0, dist2);\n    arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\n    \n    //\n    // Audio visualisation..\n    //\n\t// - Modified version of the Soundcloud example by: chronos\n\t// - https://www.shadertoy.com/view/lsdGR8\n    //\n    float t = iTime / 100.0;\n    float polychrome = (1.0 + sin(t*10.0))/2.0; // 0 -> uniform color, 1 -> full spectrum\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\n    vec3 spline = B2_spline(spline_args);\n    \n    float f = abs(centered.y);\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\n    vec3 flame_color = pow(base_color, vec3(3.0));\n    vec3 disc_color  = 0.20 * base_color;\n    vec3 wave_color  = 0.10 * base_color;\n    vec3 flash_color = 0.05 * base_color;\n    \n    fft    = uv.xy;\n    fft   -= 0.5;\n    fft   *= 1.75;\n    fft.x *= iResolution.x / iResolution.y;\n    \n    sample1 = audio_freq(iChannel3, abs(2.0 * sqrt(dot(fft,fft)) - 1.0) + 0.01);\n    sample2 = 0.6 * audio_ampl(iChannel3, clamped_dist);\n    sample3 = 0.6 * audio_ampl(iChannel3, arclength);\n    \n    float disp_dist = smoothstep(-0.2, -0.1, sample3-dist2);\n    disp_dist *= (1.0 - disp_dist);\n\t\n    vec3 color = vec3(0.0);\n    \n    // Quark Spline R G B..\n  \tvec3 s = smoothstep(-0.01, 0.01, spline-uv.y); \n    color += clamp((1.0-s) * s,0.0,1.0);\n  \t     s = smoothstep(-0.03, 0.03, spline-uv.y);\n    color += clamp((1.0-s) * s * 0.09,0.0,1.0);\n\n    float v = abs(uv.y - 0.5);\n  //  vec3 flame = flame_color * smoothstep(v, v*28.0, sample1);\n  //  color += clamp( flame, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0) );\n    color += disc_color  * smoothstep(0.5, 1.0, sample2) * (1.0 - clamped_dist);\n    color += flash_color * smoothstep(0.5, 1.0, sample3) * clamped_dist;\n    color += wave_color  * disp_dist;\n    color = pow(clamp(color+0.0001,0.0,1.0), vec3(0.4545));\n\tvec3 sonicColor = color+ wave_color * 3.0;\n    \n    vec3 col = render( ro, rd, vec3( sample1, sample2, (1.0-disp_dist) + sample3 ), spline );\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n//\tfragColor = vec4( col, 1.0 );\n\tfragColor = vec4( clamp(col + sonicColor.xyz,0.0,1.0), 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    \n    fragColor = vec4( render( ro + cam*fragRayOri,\n                                   cam*fragRayDir,\n                            \t   vec3(0.0,0.0,0.0),\n                            \t   vec3(0.0,0.0,0.0) ), 1.0 );\n\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4djGzt", "previewfilepath": "https://soundcloud.com/ngc4244/breathe-and-do-shit", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ngc4244/breathe-and-do-shit", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[430, 647, 715, 715, 975], [978, 978, 999, 999, 1093], [1095, 1095, 1122, 1122, 1495], [1497, 1497, 1556, 1556, 1736], [1738, 1738, 1796, 1796, 1925], [1927, 1927, 1999, 1999, 2188], [2198, 2198, 2242, 2242, 2282], [2284, 2343, 2384, 2384, 3311], [3313, 3571, 3613, 3613, 3656], [3658, 3658, 3702, 3702, 3865], [3867, 3867, 3941, 3941, 4259], [4261, 4261, 4336, 4336, 8360], [8362, 8362, 8426, 8452, 8803], [8806, 8806, 8861, 8861, 9039], [9118, 9146, 9199, 9199, 9245], [9246, 9246, 9299, 9299, 9345], [9347, 9394, 9419, 9419, 9727], [9729, 9733, 9790, 9790, 13379], [13381, 13381, 13475, 13475, 13928]], "test": "error"}
{"id": "XsfcR4", "name": "Pink fog", "author": "13x666", "description": "Pink wisp effect", "tags": ["fog"], "likes": 1, "viewed": 126, "published": "Public", "date": "1487157086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float alterDistance(vec2 v1, vec2 v2, float strength, float speed) \n{\n  return sin(dot(normalize(v1), normalize(v2)) * strength + speed * iTime) / 100.0;\n}\n\nfloat alterDistance(vec2 uv, vec2 center) \n{\n  vec2 diff = center - uv;\n  float len = length(diff);\n\n  len += alterDistance(diff, vec2(0.0, 1.0), 10.0, 2.0);\n  len -= alterDistance(diff, vec2(1.0, 0.0), 10.0, 2.0);\n\n  return len;\n}\n\nfloat limit(float x, float min, float max)\n{\n    if (x < min)\n        x = 0.0;\n    \n    if (x > max)\n        x = 1.0;\n    \n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv);\n\n    vec2 center = vec2(0.5, .5); \n    \n    vec2 p = ceil(uv * 300.0) / 300.0;\n  \n  \tfloat d = alterDistance(center, p);\n    \n    vec4 pink = vec4(0.89, 0.0, 0.69, 1.0);\n    \n    float r1 = 0.18;\n    float r2 = 0.225;\n    float r3 = 0.3;\n    \n    if (d <= r1)\n    {\n        fragColor =  color;\n    }\n    else if (d <= r2)\n    {\n        fragColor = color * smoothstep(0.25, r1, d);\n    }\n    else\n    {\n        float t = iTime * 0.075;\n    \n        float cloud1 = texture(iChannel1, p + vec2(t, t)).r + 0.1 * sin(t * 10.0);\n        float cloud2 = texture(iChannel1, 0.7 * p + vec2(-t, t)).r - 0.1 * sin(t * 10.0);\n\n        float cloud3 = mix(cloud1, cloud2, 0.5);\n        if (d <= r3)\n            cloud3 = min(1.0, cloud3 + smoothstep(r3, 0.14, d));\n        float cloud = step(0.6, cloud3) * 0.6;\n        if (cloud < 0.01) \n            cloud = step(0.4, cloud3) * 0.4;\n        if (cloud < 0.01) \n            cloud = step(0.3, cloud3) * 0.2;  \n\n      fragColor = cloud * pink;\n    }\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 155], [157, 157, 201, 201, 388], [390, 390, 434, 434, 528], [530, 530, 587, 587, 1657]], "test": "error"}
{"id": "XslcR4", "name": "Hotline Miami 2: Wrong Number", "author": "andunai", "description": "Playing with deformations. I wanted to implement something similar to the \"Hotline Miami 2: Wrong Number\" final level shader.", "tags": ["2d", "camera", "wobbly"], "likes": 8, "viewed": 710, "published": "Public", "date": "1487255839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 size = vec2(50.0, 50.0);\nvec2 distortion = vec2(20.0, 20.0);\nfloat speed = 0.75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 transformed = vec2(\n        fragCoord.x + sin(fragCoord.y / size.x + iTime * speed) * distortion.x,\n        fragCoord.y + cos(fragCoord.x / size.y + iTime * speed) * distortion.y\n    );\n    vec2 relCoord = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, transformed / iResolution.xy) + vec4(\n        (cos(relCoord.x + iTime * speed * 4.0) + 1.0) / 2.0,\n        (relCoord.x + relCoord.y) / 2.0,\n        (sin(relCoord.y + iTime * speed) + 1.0) / 2.0,\n        0\n    );\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 144, 144, 639]], "test": "error"}
{"id": "XslcWn", "name": "Rainy mood", "author": "Zavie", "description": "Nothing complicated here.\nNewer version: https://www.shadertoy.com/view/ldfyzl", "tags": ["2d", "rain", "ripple", "hash"], "likes": 19, "viewed": 1502, "published": "Public API", "date": "1487689957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nJust a quick experiment with rain drop ripples.\n\n-- \nZavie\n\n*/\n\n// Maximum number of cells a ripple can cross.\n#define MAX_RADIUS 2\n\n// Set to 1 to hash twice. Slower, but less patterns.\n#define DOUBLE_HASH 0\n\n// Hash functions shamefully stolen from:\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = 10. * exp2(-3.*iMouse.x/iResolution.x);\n\tvec2 uv = fragCoord.xy / iResolution.y * resolution;\n    vec2 p0 = floor(uv);\n\n    float circles = 0.;\n    for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)\n    {\n        for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)\n        {\n\t\t\tvec2 pi = p0 + vec2(i, j);\n            #if DOUBLE_HASH\n            vec2 h = hash22(pi);\n            #else\n            vec2 h = pi;\n            #endif\n            vec2 p = pi + hash22(h);\n\n            float t = fract(0.3*iTime + hash12(h));\n            float d = length(p - uv) - (float(MAX_RADIUS) + 1.)*t;\n\n            circles += (1. - t) * (1. - t)\n                * mix(sin(31.*d) * 0.5 + 0.5, 1., 0.1)\n                * smoothstep(-0.6, -0.3, d)\n                * smoothstep(0., -0.3, d);\n        }\n    }\n\n    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n    vec3 n = vec3(dFdx(circles), dFdy(circles), 0.);\n    n.z = sqrt(1. - dot(n.xy, n.xy));\n    vec3 color = texture(iChannel0, uv/resolution - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslcWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 368, 390, 390, 512], [514, 514, 535, 535, 654], [656, 656, 713, 713, 1878]], "test": "error"}
{"id": "XslyRH", "name": "Terrain Lattice", "author": "Shane", "description": "A hybrid point-lit, flat-shaded terrain with a mesh structure on it.", "tags": ["noise", "grid", "terrain", "lines", "mesh"], "likes": 79, "viewed": 5247, "published": "Public API", "date": "1487071088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Terrain Lattice\n    ---------------\n\n\tThis is a raymarched heightmap subdivided into grid squares, which are each subdivided\n\tinto two triangles to emulate the flat shaded look. It's been done before, so just to \n\tbe different, I put a mesh on top... It seemed like a good idea at the time. :)\n\n    There are two ways to render flat grid squares. One is to linearly interpolate between\n\tthe height values of all four vertices to produce a quad that looks flat on account of\n    its straight edge joins. The other is to split the quad into two triangles and linearly \n\tinterpolate between the three verticies of each of those. I tried both methods, but \n\tliked the look of the genuinely flat-planed triangles more.\n\n    A flat shaded triangle render usually requires a barycentric approach, but since the\n\tgrid triangles are essentially half squares, it's possible to use, vector \n\tperpendicularity, symmetry, etc, to cut down on the calculations considerably.\n\n\tThe extra cycles were used to render the mesh. I originally rendered the diagonal rods \n\talso, but it made things look a little too busy, so I've left them out. Rendering straight \n\tcapsule-like tubes along grid seams can also be expensive, but it was possible to cut \n\tcorners there as well, so to speak.\n\n\tAnyway, this was just a practice run for a more ambitious example I have in mind. By\n\tthe way, I have a simplex grid version as well that I'll put up later.\n    \n\n\tOther examples:\n    \n\t// Simple, and really nicely lit.\n    Triangulator - nimitz\n\thttps://www.shadertoy.com/view/lllGRr   \n\t\n\n\t// Nice example that takes an intuitive vectorized approach.\n\tRay Marched Mesh Terrain - Flyguy\n\thttps://www.shadertoy.com/view/ltjSRD\n\n*/\n\n// Max ray distance.\n#define FAR 40.\n\n// The point of the exercise was to polygonize the terrain and give it a flat shaded triangulated\n// appearance, but if you'd prefer to see smooth quads, just uncomment the following:\n//#define SMOOTH_QUAD\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Height map values. Just a couple of animated sinusoidal layers, but you could put anything\n// here... so long as it's cheap. :)\nfloat hm(in vec2 p){\n    \n    // Scaling, plus some movement.\n    p = p/2. + iTime/4.;\n    \n    // Layer one.\n    float n = dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.66;\n    p = p*1.5;  // Increase frequency.\n  \n    p.xy = mat2(.866025, .5, -.5, .866025)*p.xy; // Rotate.\n    \n    // Add another layer.\n    n += dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.34;\n    \n    return n; // Range [0, 1]... hopefully. :)\n\n}\n\n// Used to scale the grid without having to move the camera.\n#define scale 2. \nvec3 hVal; // Global variable to hold the three height values for reuse.\n\n// The terrain - tesselated in a flat-grid triangle-pair fashion... Needs rewording. :D\nfloat triTerrain(vec2 p){ \n\n    \n    \n    vec2 ip = floor(p); // Integer value. Used for the unique corner height values.\n    p -= ip; // Fractional grid value.\n \n    \n    //p *= p*(3.-2.*p); // Weird Gouraud-looking triangles, or smooth quad.\n     \n    \n    // The barycentric coordinates, so to speak, and the corresponding height value.\n    // For those of you familiar with the process, you may note that there are far \n    // fewer operations than usual.\n   \n    float s = step(1., p.x + p.y); // Determines which side of the diagonal we're on.\n    \n    // Storing the heights at the three triangle vertices. Normally, it wouldn't be\n    // necessary, but we're reusing them to render the mesh.\n    hVal = vec3(hm(ip+s), hm(ip + vec2(1, 0)), hm(ip+vec2(0, 1)));\n    \n    #ifdef SMOOTH_QUAD\n    // A simple, interpolated quad. It's not really flat, but the edge-joins are straight,\n    // so it looks that way. Because the mesh is set up on triangle logic, there two\n    // extra height values. Normally, you'd only need one extra.\n    return mix(mix(hm(ip), hVal.y, p.x), mix(hVal.z, hm(ip+1.), p.x), p.y);\n    #else\n    // Barycentric setup: This is a very trimmed down version of the generalized barycentric\n    // calculations that involve cross-products, and so forth. Without going into detail, I'm\n    // sure you could imagine that three points in space can be used to generate a plane \n    // equation via cross products and such, and the fractional grid points could be used in\n    // unison with the vertice coordinates to determine the exact coordinate on the plane, or\n    // the height value at that coordinate.\n    //\n    // Anyway, the grid triangles are shaped in such a way that a lot of the operations cancel \n    // out, and the lines below are the result. You could just use them. However, if you require\n    // more information, look up a few barycentric coordinate examples.\n    //\n    vec3 b = abs(vec3(1.0 - p.x - p.y, p.x - (p.x - p.y + 1.)*s, p.y - (p.y - p.x + 1.)*s));\n    \n    // The linearly interpolated triangle height.\n    return dot(b, hVal);\n    #endif\n    \n/* \n\n    // Triangulating across the other diagonal. Handy, if you want to make patterns.\n    float s = step(p.x, p.y);\n    hVal = vec3(hm(ip), hm(ip + vec2(1. - s, s)), hm(ip+1.));\n\n    //return mix(mix(hVal.x, hm(ip+vec2(1, 0)), f.x), mix(hm(ip+vec2(0, 1)), hVal.z, f.x),f.y);\n\n    vec3 b = abs(vec3(1. - (1. - s)*p.x - p.y*s, (1.-2.*s)*(p.x - p.y), p.x*s + p.y*(1. - s)));\n    \n    return dot(b, hVal);\n*/\n   \n \n}\n\n// The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    \n    // The terrain. By the way, when you scale coordinates, you have to scale back\n    // the distance value to keep things in check. I often forget this.\n    float ter = triTerrain(p.xz*scale)/scale; \n \n    const float hPert = .25; // Terrain height perturbation.\n    float fl = p.y  + (.5 - ter)*hPert;//*.25; // Adding it to a flat plane.\n\n\n    hVal = hVal*hPert - .175; // Rescaling the height values to match the terrain perturbation.\n    \n    // The grid boundary railings. As usual, the code looks more complicated than it is. Basically, we're\n    // positioning four tubes around the grid boundaries. The Y-value is just a height interpolation\n    // from one vertice to the adjoining one. The \"abs\" business is just a cheap trick to stack the \n    // railings on top of one another without having to render another four tubes. \n    vec3 q = p*scale;\n    q.xz = fract(q.xz); // Break space into squares along the XZ plane.\n        \n    // Tubes on the left and right boundaries.\n    float ln = length(vec2(q.x, abs(q.y - hVal.x -(hVal.z - hVal.x)*q.z - .25) -.25));\n    ln = min(ln, length(vec2(q.x - 1., abs(q.y - hVal.y - (hVal.x - hVal.y)*q.z - .25) - .25)));\n\n    // Tubes on the bottom and top boundaries.\n    ln = min(ln, length(vec2(abs(q.y - hVal.x - (hVal.y - hVal.x)*q.x - .25) -.25, q.z)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.z - (hVal.x - hVal.z)*q.x - .25) -.25, q.z - 1.)));\n\n    // The diagonal tube lines. Makes things look too busy, but comment them out, if you feel like it.\n    //vec2 diag = vec2(q.x + q.z - 1., abs(q.y - hVal.z - (hVal.y - hVal.z)*q.x- .25) -.25);//*.7071;\n    //ln = min(ln, length(diag));\n        \n    \n/*    \n    \n    // If you wanted to use the reverse diagonal on the triangulation. See the comments in the \n    // \"triTerrain\" function first.\n    \n    ln =   length(vec2(q.x, abs(q.y - hVal.x - (hVal.y - hVal.x)*q.z - .25) -.25));\n    ln = min(ln, length(vec2(q.x - 1., abs(q.y - hVal.y - (hVal.z - hVal.y)*q.z - .25) -.25)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.x - (hVal.y - hVal.x)*q.x - .25) -.25, q.z)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.y - (hVal.z - hVal.y)*q.x - .25) -.25, q.z - 1.)));\n\n\n    vec2 diag = vec2(q.x - q.z, abs(q.y - hVal.x - (hVal.z - hVal.x)*q.z - .25) -.25);//*.7071;\n    ln = min(ln, length(diag));\n*/         \n   \n    \n    \n    // Vertical column and the balls. We've calculated another height value offset by half the grid in \n    // order to draw just one each - instead of four. It's a little hard to explain why but it has to\n    // do with repetitive cell boundaries.\n    float hgt = hm(floor(p.xz*scale + .5))*hPert - .175;\n    //float hgtZ = hm(floor(p.xz*scale + .5) + vec2(0, 1))*pert - .025;\n    vec2 offXZ = fract(p.xz*scale + .5) - .5;\n    ln = min(ln, max(length(offXZ), abs(q.y - hgt) - .5));\n\n    // The metallic balls. Stacked two high using the \"abs\" trick.\n    float sp = length(vec3(offXZ.x, abs(abs(q.y - hgt - .25) - .25), offXZ.y));\n    \n    \n    ln -= .04; // Line thickness.\n    sp -= .125; // Ball thickness.\n    ln = min(ln, sp);\n    \n    \n    ln /= scale;\n    sp /= scale;\n  \n \n    // Object ID.\n    objID = step(fl, ln);\n    \n    \n    // Combining the mesh with the terrain.\n    return min(fl, ln); //smin(fl, ln, .025);\n \n}\n\n \n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.; //fract(sin(dot(rd, vec3(7, 157, 113)))*45758.5453)*.1;\n   \n    for (int i=0; i<96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.8;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 getNormal(in vec3 p, float t)\n{  \n    vec2 e = vec2(-1., 1.)*0.001*min(1. + t, 5.);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(0.002, 0); //vec2(0.002*min(1. + t*.5, 2.), 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, .5);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*.8, c*.9, c);//vec3(c*c, c*sqrt(c), c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.\n\n}\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, -.5 - .125*.5, iTime + 1.);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(0, 2.5, -2.); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, .75, 2);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= r2( path(lk.z).x/128. );\n\n    \n/*       \n    // Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n*/    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    float svObjID = objID;\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n        // Edge and edge-factor.\n        //float edge, crv = 1., ef = 4.; // Curvature variable not used.\n        \n        // Texture scale factor.\n        float tSize0 = 1./2.;\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Texture-based bump mapping. I've left it out for this.\n        //if(svObjID>0.5) sn = texBump(iChannel0, sp*tSize0, sn, .003);\n\t    \n        \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        \n        if(svObjID>0.5) { // Terrain texturing.\n            \n            texCol = tex3D(iChannel0, sp*tSize0, sn);\n            //texCol = texture(iChannel0, sp.xz*tSize0).xyz;\n            //texCol *= texCol;\n            texCol = smoothstep(0.0, .5, texCol);//*vec3(1, .9, .8);//\n            //texCol *= triTerrain(sp.xz)*.25 + .75; // Adds more definition to the squares.\n \n            // Color some of the squares brown.\n            if(mod(dot(floor(sp.xz*scale), vec2(1, -1)), 5.)>=2.) texCol *= vec3(1, .5, .25);\n            \n                        \n            /*\n            // Blinking lights. Too much, I think.\n            float rnd = fract(sin(dot(floor(sp.xz*scale), vec2(141.13, 289.97)))*43758.5453);\n            rnd = sin(rnd*6.283 + iTime)*.5 + .5;\n            if(rnd>.33) texCol *= vec3(1, .5, .25);\n            else { texCol *= 2.;  }\n            //texCol *= mix(vec3(2.), vec3(1, .5, .25), rnd); // Alternative: Random mix.\n            */\n            \n        }\n        else { // The chrome lattice.\n            \n            texCol = tex3D(iChannel0, sp*tSize0, sn)*.25;\n \n        }\n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp-sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, 8.);\n    \tfloat ao = cAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*2.;\n        if(svObjID>.5) { // Lowering the terrain settings a bit.\n            env *= .25;\n            spec *= .5;            \n            fre *= .5;\n        }\n        \n\n        // Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff + 0.25 + vec3(1, .9, .7)*fre) + env + vec3(1, .95, .8)*spec);\n        \n\n        // Shading.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    // the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(.6, .5, 1), vec3(.025, .05, .1), clamp(rd.y + .75, 0., 1.));//vec3(1, .9, .8);//\n    sceneCol = mix(sceneCol, bg, smoothstep(0., .95, t/FAR));\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2034, 2186, 2204, 2204, 2272], [2275, 2406, 2426, 2467, 2878], [3033, 3121, 3146, 3146, 5635], [5637, 5678, 5696, 5856, 8962], [8967, 9000, 9030, 9030, 9349], [9859, 9959, 9995, 9995, 10190], [10194, 10385, 10429, 10546, 11660], [11663, 11815, 11852, 11852, 12111], [12116, 12270, 12316, 12316, 12840], [12842, 13029, 13089, 13089, 13596], [13600, 13743, 13764, 13764, 14110], [14114, 14413, 14433, 14433, 14805], [14807, 14859, 14881, 14881, 14940], [14944, 14944, 15000, 15033, 20688]], "test": "error"}
{"id": "XslyzH", "name": "[TDF2017] Schottky Waltz", "author": "soma_arc", "description": "Tokyo Demo Fest 2017 GLSL Graphics compo 1st place.\nPlay with circles.", "tags": ["2d", "fractal", "kleiniangroups", "schottky"], "likes": 43, "viewed": 1272, "published": "Public", "date": "1487514951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;\n}\n\nmat2 getRotationMat2(float angleRadians){\n\treturn mat2(cos(angleRadians), -sin(angleRadians),\n                sin(angleRadians), cos(angleRadians));\n}\nconst mat2 UNI_MAT = mat2(1, 0, 0, 1);\n\nconst float PI = 3.1415926535;\nconst float PI_2 = 3.1415926535/2.;\nconst float PI_4 = 3.1415926535/4.;\n\n\nconst float R = 100. * sqrt(2.) / 2.;\nvec3 c1 = vec3(100, 0, 0);\nvec3 c3 = vec3(-100, 0, 0);\nvec3 c2 = vec3(0, 100, 0);\nvec3 c4 = vec3(0, -100, 0);\nvec3 c5 = vec3(0);\n\nfloat l1Angle = PI_4;\nvec2 l1p = vec2(500, 0);\nmat2 l1m;\nmat2 l1mInv;\n\nfloat l2Angle = PI + PI_4;\nvec2 l2p = vec2(-800, 0);\nmat2 l2m;\nmat2 l2mInv;\n\nfloat l3Angle = PI + PI_4;\nvec2 l3p = vec2(-1500, 0);\nmat2 l3m;\nmat2 l3mInv;\n\nfloat l4Angle = PI_2 + PI_4;\nvec2 l4p = vec2(0, -1500);\nmat2 l4m;\nmat2 l4mInv;\n\nbool enableL1 = false;\nbool enableL2 = false;\nbool enableL3 = false;\nbool enableL4 = false;\n\nconst int MAX_ITERATIONS = 35;\nfloat IIS(vec2 pos){\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < MAX_ITERATIONS ; i++){\n\t\tcont = false;\n\t\t\n        if(length(pos - c1.xy) < c1.z){\n\t\t\tpos = circleInvert(pos, c1);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c2.xy) < c2.z){\n\t\t\tpos = circleInvert(pos, c2);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c3.xy) < c3.z){\n\t\t\tpos = circleInvert(pos, c3);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c4.xy) < c4.z){\n\t\t\tpos = circleInvert(pos, c4);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c5.xy) < c5.z){\n\t\t\tpos = circleInvert(pos, c5);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n        \n        if(enableL1){\n        \tpos -= l1p;\n        \tpos = l1mInv * pos;\n        \tif(pos.x > 0.){\n        \t\tpos.x *= -1.;\n            \tloopNum++;\n            \tcont = true;\n        \t}\n        \tpos = l1m * pos;\n        \tpos += l1p;\n        }\n        \n        if(enableL2){\n        pos -= l2p;\n        pos = l2mInv * pos;\n        if(pos.x > 0.){\n        \tpos.x *= -1.;\n            loopNum++;\n            cont = true;\n        }\n        pos = l2m * pos;\n        pos += l2p;\n        }\n        \n        if(enableL3){\n        pos -= l3p;\n        pos = l3mInv * pos;\n        if(pos.x > 0.){\n        \tpos.x *= -1.;\n            loopNum++;\n            cont = true;\n        }\n        pos = l3m * pos;\n        pos += l3p;\n        }\n         \n        if(enableL4){\n        \tpos -= l4p;\n        \tpos = l4mInv * pos;\n        \tif(pos.x > 0.){\n        \t\tpos.x *= -1.;\n            \tloopNum++;\n\t\t\t\tcont = true;\n        \t}\n        \tpos = l4m * pos;\n        \tpos += l4p;\n        }\n        \n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 sum = vec3(0);\n    float t = mod(iTime, 20.);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    enableL1 = enableL2 = enableL3 = enableL4 = false;\n\n\tfloat start = 0.;\n    c1.z = mix(0., R, expEasingIn(scene(t, start, 1.)));\n    c2.z = mix(0., R, expEasingIn(scene(t, start + .1, 1.)));\n\tc3.z = mix(0., R, expEasingIn(scene(t, start + .3, 1.)));\n\tc4.z = mix(0., R, expEasingIn(scene(t, start + .5, 1.)));\n    \n    float rotationStart = start + 1.7;\n    float scaleFactor = 150.;    \n    float theta = mix(0., 2. * PI + PI_4, circEasingInOut(scene(t, rotationStart, 1.)));\n    scaleFactor += mix(0., 800., circEasingInOut(scene(t, rotationStart, 1.)));\n        \n\tl1p.x = mix(1500., 200., expEasingIn(scene(t, rotationStart, 1.)));\n\tl2p.x = mix(-1500., -200., expEasingIn(scene(t, rotationStart, 1.5)));\n    enableL1 = t > rotationStart + .5;\n    enableL2 = t > rotationStart + .5;\n    \n\tfloat lineStart = rotationStart + 1.5;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, lineStart, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, lineStart, 1.)));\n    float lpRotateAngle1 = mix(0., PI_2, circEasingInOut(scene(t, lineStart, 1.)));\n   \tl3p.x = mix(-1500., -200., expEasingIn(scene(t, lineStart, 1.)));\n    enableL3 = t > lineStart;\n    \n    float rotateStart2 = lineStart + 1.1;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart2, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart2, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart2, 1.)));    \n\tlpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart2, 1.)));    \n    l4p.y = mix(-1500., -200., expEasingIn(scene(t, rotateStart2, 1.)));\n    enableL4 = t > rotateStart2;\n    \n    float rotateStart3 = rotateStart2 + 1.1;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart3, 1.)));    \n\tfloat lpRotateAngle2 = mix(0., PI_2, circEasingInOut(scene(t, rotateStart3, 1.))); \n\n    float rotateStart4 = rotateStart3 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart4, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart4, 1.))); \n    scaleFactor += mix(0., -600., circEasingInOut(scene(t, rotateStart4, 1.)));\n\n    float rotateStart5 = rotateStart4 + 1.1;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart5, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart5, 1.))); \n \n    float rotateStart6 = rotateStart5 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart6, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart6, 1.))); \n    \n    float rotateStart7 = rotateStart6 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart7, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart7, 1.)));\n    \n    float rotateStart8 = rotateStart7 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart8, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart8, 1.)));\n\n    float rotateStart9 = rotateStart8 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart9, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart9, 1.)));\n\n    float rotateStart10 = rotateStart9 + 1.2;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart10, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart10, 1.)));\n        \n    \n    float circleStart = rotateStart5;\n    float deformR = 100.;\n    c1.z += mix(0., deformR, expEasingOut(scene(t, rotateStart5, 1.)));\n    c1.z += mix(0., -deformR, expEasingOut(scene(t, rotateStart6, 1.)));\n\t\n\tc3.z += mix(0., deformR, expEasingOut(scene(t, rotateStart6, 1.)));\n  \tc3.z += mix(0., -deformR, expEasingOut(scene(t, rotateStart7, 1.)));\n\n    c5.z += mix(0., 50., circEasingInOut(scene(t, rotateStart7, 1.)));\n    \n    scaleFactor += mix(0., -300., circEasingInOut(scene(t, rotateStart7, 1.)));\n    scaleFactor /= mix(1., 4., circEasingInOut(scene(t, rotateStart8, 1.)));\n    scaleFactor /= mix(1., 4., circEasingInOut(scene(t, rotateStart9, 1.)));\n    scaleFactor /= mix(1., 4., circEasingInOut(scene(t, rotateStart10, 1.)));\n\n    float endingStart = rotateStart10 + 1.3;\n    if(t >= endingStart){\n        \n        float rotateStart11 = endingStart;\n   \t\tl1Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));\n    \tl2Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));\n\t\tl3Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));  \n   \t\tl4Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));\n    \tlpRotateAngle1 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart11, 1.)));    \n\t\tlpRotateAngle2 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart11, 1.)));\n        \n        float rotateStart12 = rotateStart11 + 1.3;\n   \t\tl1Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));\n    \tl2Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));\n\t\tl3Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));  \n   \t\tl4Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));\n    \tlpRotateAngle1 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart12, 1.)));    \n\t\tlpRotateAngle2 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart12, 1.)));\n        \n        float rotateStart13 = rotateStart12+1.3;\n   \t\tl1Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));\n    \tl2Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));\n\t\tl3Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));  \n   \t\tl4Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));\n    \tlpRotateAngle1 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart13, 1.)));    \n\t\tlpRotateAngle2 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart13, 1.)));\n        \n        \n        float endingTime = 1.;\n   \t\t\n\t\tc5.z  = mix(50., 0., circEasingInOut(scene(t, rotateStart12, endingTime)));\n        l1p.x = mix(200., 5000., circEasingIn(scene(t, rotateStart13, endingTime)));  \n\t\tl2p.x = mix(-200., -5000., circEasingIn(scene(t, rotateStart13, endingTime)));\n    \tl3p.y = mix(0., -5000., circEasingIn(scene(t, rotateStart13, endingTime)));  \n\t\tl4p.y = mix(-200., -5000., circEasingIn(scene(t, rotateStart13, endingTime)));\n        c1.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n    \tc2.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n\t\tc3.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n\t\tc4.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n\n        theta += mix(0., -PI_2, circEasingInOut(scene(t, rotateStart13, 1.)));\n\n        scaleFactor *= mix(1., 650., circEasingInOut(scene(t, endingStart, 1.)));\n\n    }\n    \n    mat2 lpRotate1 = getRotationMat2(lpRotateAngle1);    \n    l1m = getRotationMat2(l1Angle);\n    l1mInv = getRotationMat2(-l1Angle);\n    l2m = getRotationMat2(l2Angle);\n    l2mInv = getRotationMat2(-l2Angle);\n    l3m = getRotationMat2(l3Angle);\n    l3mInv = getRotationMat2(-l3Angle);    \n\tl4m = getRotationMat2(l4Angle);\n    l4mInv = getRotationMat2(-l4Angle); \n    \n    l1p = lpRotate1 * l1p;\n\tl2p = lpRotate1 * l2p;\n\tl3p = lpRotate1 * l3p;\n    \n    mat2 lpRotate2 = getRotationMat2(lpRotateAngle2);    \n \tl4p = lpRotate2 * l4p;    \n    \n    mat2 m = getRotationMat2(theta);    \n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        \n        position = position * scaleFactor;\n        position = m * position;\n        \n        \n        float loopNum = IIS(position);\n\n        if(loopNum >  0.){\n            sum += hsv2rgb(vec3(0.01 + 0.05 * (loopNum-1.),1.0,1.0));\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslyzH.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[116, 205, 246, 246, 535], [537, 537, 578, 578, 696], [698, 698, 739, 739, 848], [1592, 1592, 1612, 1612, 3303], [3305, 3305, 3327, 3327, 3496], [3498, 3528, 3576, 3576, 3617], [3620, 3620, 3647, 3647, 3687], [3688, 3688, 3717, 3717, 3753], [3755, 3755, 3786, 3786, 3893], [3895, 3895, 3923, 3923, 3959], [4005, 4005, 4034, 4034, 4211], [4243, 4243, 4297, 4297, 14692]], "test": "error"}
{"id": "Xslyzn", "name": "Distance Bounds & Operations", "author": "plabatut", "description": "Play with signed distance bounds and operations. Click and move the mouse: horizontally for the divider between standard and isolevel rendering, vertically for the plane. A choice of distance bounds is available at the stop of the code (SDF macro).", "tags": ["procedural", "3d", "raymarching"], "likes": 7, "viewed": 217, "published": "Public", "date": "1486732600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO: Add missing primitive(s): capped cone\n\n#define SDF_SPHERE              0\n#define SDF_BOX                 1\n#define SDF_ROUND_BOX           2\n\n#define SDF_TETRAHEDRON         3\n#define SDF_CUBE                4\n#define SDF_OCTAHEDRON          5\n#define SDF_DODECAHEDRON        6\n#define SDF_ICOSAHEDRON         7\n\n#define SDF_TORUS               8\n#define SDF_CYLINDER            9\n#define SDF_CONE                10\n#define SDF_ELLIPSOID           11\n\n#define SDF_CAPPED_CYLINDER     12\n#define SDF_CAPPED_CONE         13 // TODO\n#define SDF_CAPSULE             14\n\n#define SDF_TORUS_8_2           15 // FIXME: Shadow\n#define SDF_TORUS_8_8           16 // FIXME: Shadow\n\n#define SDF_UNION               17\n#define SDF_INTERSECTION        18\n#define SDF_DIFFERENCE          19\n#define SDF_SMOOTH_UNION        20\n#define SDF_SMOOTH_INTERSECTION 21\n#define SDF_SMOOTH_DIFFERENCE   22\n\n#define SDF_UNION_CAPSULES      23\n#define SDF_PIPE_CYLINDERS      24\n\n#define SDF_POLAR_CYLINDERS     25\n#define SDF_TRIANGULAR_CYLINDER 26\n#define SDF_HEXAGONAL_CYLINDER  27\n\n#define SDF_DISPLACEMENT        28\n#define SDF_TWIST               29\n#define SDF_BEND                30\n#define SDF_BOX_MINUS_CYLINDERS 31\n\n#define SDF_STAR                32\n\n\n#define SDF SDF_BOX_MINUS_CYLINDERS\n\n\nconst float Pi = 3.14159265358;\nconst int MaxNumSteps = 256;\nconst float MaxT = 1024.0;\nconst float Epsilon = 0.001;\nconst int MaxNumSamples = 4;\n\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\n\nfloat vmin(vec3 v) {\n    return min(v.x, min(v.y, v.z));\n}\n\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\n\nfloat length8(vec2 v) {\n    float x = v.x;\n    float y = v.y;\n\n    float x2 = x * x;\n    float y2 = y * y;\n\n    float x4 = x2 * x2;\n    float y4 = y2 * y2;\n\n    float x8 = x4 * x4;\n    float y8 = y4 * y4;\n\n    return sqrt(sqrt(sqrt(sqrt(x8 + y8))));\n}\n\n\nfloat length8(vec3 v) {\n    float x = v.x;\n    float y = v.y;\n    float z = v.z;\n\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n\n    float x4 = x2 * x2;\n    float y4 = y2 * y2;\n    float z4 = z2 * z2;\n\n    float x8 = x4 * x4;\n    float y8 = y4 * y4;\n    float z8 = z4 * z4;\n\n    return pow(x8 + y8 + z8, 0.0625);\n}\n\n\n// See: https://en.wikipedia.org/wiki/Platonic_solid#Cartesian_coordinates\n\nconst float Phi = 0.5 * (1.0 + sqrt(5.0));\n\n// See: Generalized Distance Functions, Akleman and Chen, 1999\nconst vec3 gdfN01 = vec3(1.0, 0.0, 0.0);\nconst vec3 gdfN02 = vec3(0.0, 1.0, 0.0);\nconst vec3 gdfN03 = vec3(0.0, 0.0, 1.0);\n\nconst vec3 gdfN04 = normalize(vec3( 1.0,  1.0,  1.0));\nconst vec3 gdfN05 = normalize(vec3(-1.0,  1.0,  1.0));\nconst vec3 gdfN06 = normalize(vec3( 1.0, -1.0,  1.0));\nconst vec3 gdfN07 = normalize(vec3( 1.0,  1.0, -1.0));\n\n// Phi^2 = Phi + 1\n// (1 / Phi, Phi) ~ (1, Phi + 1)\nconst vec3 gdfN08 = normalize(vec3(       0.0,       1.0, Phi + 1.0));\nconst vec3 gdfN09 = normalize(vec3(       0.0,      -1.0, Phi + 1.0));\nconst vec3 gdfN10 = normalize(vec3( Phi + 1.0,       0.0,       1.0));\nconst vec3 gdfN11 = normalize(vec3(-Phi - 1.0,       0.0,       1.0));\nconst vec3 gdfN12 = normalize(vec3(       1.0, Phi + 1.0,       0.0));\nconst vec3 gdfN13 = normalize(vec3(      -1.0, Phi + 1.0,       0.0));\n\nconst vec3 gdfN14 = normalize(vec3( 0.0,  Phi, 1.0));\nconst vec3 gdfN15 = normalize(vec3( 0.0, -Phi, 1.0));\nconst vec3 gdfN16 = normalize(vec3( 1.0,  0.0, Phi));\nconst vec3 gdfN17 = normalize(vec3(-1.0,  0.0, Phi));\nconst vec3 gdfN18 = normalize(vec3( Phi,  1.0, 0.0));\nconst vec3 gdfN19 = normalize(vec3(-Phi,  1.0, 0.0));\n\n\nfloat sdfTetrahedron(vec3 P, float R) {\n    const vec3 n1 = normalize(vec3( 1.0,  1.0,  1.0));\n    const vec3 n2 = normalize(vec3(-1.0, -1.0,  1.0));\n    const vec3 n3 = normalize(vec3( 1.0, -1.0, -1.0));\n    const vec3 n4 = normalize(vec3(-1.0,  1.0, -1.0));\n\n    R /= sqrt(3.0);\n\n    float d = dot(n1, P) - R;\n    d = max(d, dot(n2, P) - R);\n    d = max(d, dot(n3, P) - R);\n    d = max(d, dot(n4, P) - R);\n\n    return d;\n}\n\n\nfloat sdfCube(vec3 P, float R) {\n    const vec3 n1 = gdfN01;\n    const vec3 n2 = gdfN02;\n    const vec3 n3 = gdfN03;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n\n    return d - R;\n}\n\n\nfloat sdfOctahedron(vec3 P, float R) {\n    const vec3 n1 = gdfN04;\n    const vec3 n2 = gdfN05;\n    const vec3 n3 = gdfN06;\n    const vec3 n4 = gdfN07;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n    d = max(d, abs(dot(n4, P)));\n\n    return d - R;\n}\n\n\nfloat sdfDodecahedron(vec3 P, float R) {\n    const vec3 n1 = gdfN14;\n    const vec3 n2 = gdfN15;\n    const vec3 n3 = gdfN16;\n    const vec3 n4 = gdfN17;\n    const vec3 n5 = gdfN18;\n    const vec3 n6 = gdfN19;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n    d = max(d, abs(dot(n4, P)));\n    d = max(d, abs(dot(n5, P)));\n    d = max(d, abs(dot(n6, P)));\n\n    return d - R;\n}\n\n\nfloat sdfIcosahedron(vec3 P, float R) {\n    const vec3 n1 = gdfN04;\n    const vec3 n2 = gdfN05;\n    const vec3 n3 = gdfN06;\n    const vec3 n4 = gdfN07;\n    const vec3 n5 = gdfN08;\n    const vec3 n6 = gdfN09;\n    const vec3 n7 = gdfN10;\n    const vec3 n8 = gdfN11;\n    const vec3 n9 = gdfN12;\n    const vec3 n10 = gdfN13;\n\n    float d = abs(dot(n1, P));\n    d = max(d, abs(dot(n2, P)));\n    d = max(d, abs(dot(n3, P)));\n    d = max(d, abs(dot(n4, P)));\n    d = max(d, abs(dot(n5, P)));\n    d = max(d, abs(dot(n6, P)));\n    d = max(d, abs(dot(n7, P)));\n    d = max(d, abs(dot(n8, P)));\n    d = max(d, abs(dot(n9, P)));\n    d = max(d, abs(dot(n10, P)));\n\n    return d - R;\n}\n\n\nfloat sdfTorus(vec3 P, float R1, float R2) {\n    vec2 d = vec2(length(P.xy) - R1, P.z);\n    return length(d) - R2;\n}\n\n\nfloat sdfTorus82(vec3 P, float R1, float R2) {\n    vec2 d = vec2(length(P.xy) - R1, P.z);\n    return length8(d) - R2;\n}\n\n\nfloat sdfTorus88(vec3 P, float R1, float R2) {\n    vec2 d = vec2(length8(P.xy) - R1, P.z);\n    return length8(d) - R2;\n}\n\n\nfloat sdfSphere(vec3 P, float R) {\n    return length(P) - R;\n}\n\n\nfloat sdfBox2(vec3 P, vec3 s) {\n    return vmax(abs(P) - s);\n}\n\n\nfloat sdfBox(vec3 P, vec3 s) {\n    vec3 d = abs(P) - s;\n    return length(max(d, 0.0)) + min(vmax(d), 0.0);\n}\n\n\nfloat sdfRoundBox(vec3 P, vec3 s, float R) {\n    return sdfBox(P, s) - R;\n}\n\n\nfloat sdfPlane(vec3 P, vec3 n, float o) {\n    return dot(n, P) - o;\n}\n\n\nfloat sdfEllipsoid(vec3 P, vec3 s) {\n    return vmin(s) * (length(P / s) - 1.0);\n}\n\n\nfloat sdfEllipsoid8(vec3 P, vec3 s) {\n    return vmin(s) * (length8(P / s) - 1.0);\n}\n\n\nfloat sdfCapsule(vec3 P, vec3 P1, vec3 P2, float R) {\n    vec3 u = P - P1;\n    vec3 v = P2 - P1;\n\n    float d = clamp(dot(u, v) / dot(v, v), 0.0, 1.0);\n\n    return length(u - d * v) - R;\n}\n\n\nfloat sdfCylinder(vec3 P, float R) {\n    return length(P.xy) - R;\n}\n\n\nfloat sdfCappedCylinder(vec3 P, float R, float h) {\n    vec2 d = abs(vec2(length(P.xy), P.z)) - vec2(R, h);\n    return min(vmax(d), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat sdfCone(vec3 P, vec2 u) {\n    float d = length(P.xy);\n    return dot(u, vec2(d, P.z));\n}\n\n\nfloat sdfCappedCone(vec3 P, vec2 u, float size) {\n    float d = length(P.xy);\n    return dot(u, vec2(d, P.z));\n}\n\n\nfloat sdfTriangularCylinder(vec3 P, float R) {\n    const float s2 = sqrt(2.0);\n    const float s3 = sqrt(3.0);\n\n    const vec2 n1 = vec2(0.0, 1.0);\n    const vec2 n2 = 0.5 * vec2(-s3, -1.0);\n    const vec2 n3 = 0.5 * vec2( s3, -1.0);\n\n    R /= s3; // FIXME: ?\n\n    float d = dot(n1, P.xy) - R;\n    d = max(d, dot(n2, P.xy) - R);\n    d = max(d, dot(n3, P.xy) - R);\n\n    return d;\n}\n\n\nfloat sdfBoxCylinder(vec3 P, vec2 s) {\n    vec2 d = abs(P.xy) - s;\n    return length(max(d, 0.0)) + min(vmax(d), 0.0);\n}\n\n\nfloat sdfHexagonalCylinder(vec3 P, float R) {\n    const float s3 = sqrt(3.0);\n\n    const vec2 n1 = 0.5 * vec2(1.0, s3);\n    const vec2 n2 = 0.5 * vec2(-1.0, s3);\n    const vec2 n3 = vec2(-1.0, 0.0);\n\n    float d = abs(dot(n1, P.xy));\n    d = max(d, abs(dot(n2, P.xy)));\n    d = max(d, abs(dot(n3, P.xy)));\n\n    return d - R;\n}\n\n\nfloat sdfSmoothMin(float d1, float d2, float f) {\n    float t = clamp(0.5 - 0.5 * (d2 - d1) / f, 0.0, 1.0);\n\n    return mix(d1, d2, t) - f * t * (1.0 - t);\n}\n\n\nfloat sdfSmoothMax(float d1, float d2, float f) {\n    return -sdfSmoothMin(-d1, -d2, f);\n}\n\n\nfloat sdfSmoothDifference(float d1, float d2, float f) {\n  //return sdfSmoothMax(d1, -d2, f);\n    return -sdfSmoothMin(-d1, d2, f);\n}\n\n\nfloat sdfBackground(vec3 P, float p) {\n    return sdfPlane(P, vec3(0.0, 0.0, 1.0), p);\n}\n\n\nvec3 spTwist(vec3 P, float f) {\n    float c = cos(f * P.z);\n    float s = sin(f * P.z);\n\n    mat2 R = mat2(c, -s, s, c);\n\n    return vec3(R * P.xy, P.z);\n}\n\n\nvec3 spBend(vec3 P, float f) {\n    float c = cos(f * P.z);\n    float s = sin(f * P.z);\n\n    mat2 R = mat2(c, -s, s, c);\n\n    return vec3(R * P.xz, P.y);\n}\n\n\nfloat sdfForeground(vec3 P) {\n#if SDF == SDF_SPHERE\n    return sdfSphere(P, 1.0);\n#elif SDF == SDF_BOX\n  //return sdfBox2(P, vec3(0.5, 0.75, 1.0));\n    return sdfBox(P, vec3(0.5, 0.75, 1.0));\n#elif SDF == SDF_ROUND_BOX\n    return sdfRoundBox(P, vec3(0.375, 0.5, 0.75), 0.125);\n#elif SDF == SDF_TETRAHEDRON\n    return sdfTetrahedron(P, 1.0);\n#elif SDF == SDF_CUBE\n    return sdfCube(P, 1.0);\n#elif SDF == SDF_OCTAHEDRON\n    return sdfOctahedron(P, 0.5);\n#elif SDF == SDF_DODECAHEDRON\n    return sdfDodecahedron(P, 0.75);\n#elif SDF == SDF_ICOSAHEDRON\n    return sdfIcosahedron(P, 0.75);\n#elif SDF == SDF_TORUS\n    return sdfTorus(P, 1.0, 1.0 / 2.5);\n#elif SDF == SDF_CYLINDER\n    return sdfCylinder(P, 1.0);\n#elif SDF == SDF_CONE\n    return sdfCone(P, normalize(vec2(1.0, 1.0)));\n#elif SDF == SDF_ELLIPSOID\n    return sdfEllipsoid(P, vec3(1.5, 0.75, 1.0));\n#elif SDF == SDF_CAPPED_CYLINDER\n    return sdfCappedCylinder(P, 0.75, 1.0);\n#elif SDF == SDF_CAPPED_CONE\n    return sdfCappedCone(P, 1.0, 0.25); // TODO\n#elif SDF == SDF_CAPSULE\n    return sdfCapsule(P,\n                      vec3(-1.0, 0.0, 0.0),\n                      vec3( 1.0, 0.0, 0.0),\n                      0.5);\n#elif SDF == SDF_TORUS_8_2\n    return sdfTorus82(P, 1.0, 1.0 / 2.5);\n#elif SDF == SDF_TORUS_8_8\n    return sdfTorus88(P, 1.0, 1.0 / 2.5);\n#elif SDF == SDF_UNION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return min(d1, d2);\n#elif SDF == SDF_INTERSECTION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return max(d1, d2);\n#elif SDF == SDF_DIFFERENCE\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return max(d1, -d2);\n#elif SDF == SDF_SMOOTH_UNION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return sdfSmoothMin(d1, d2, 0.5);\n#elif SDF == SDF_SMOOTH_INTERSECTION\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return sdfSmoothMax(d1, d2, 0.5);\n#elif SDF == SDF_SMOOTH_DIFFERENCE\n    float d1 = sdfCappedCylinder(P, 0.75, 1.0);\n    float d2 = sdfTorus(P, 0.75, 1.0 / 2.5);\n\n    return sdfSmoothDifference(d1, d2, 0.5);\n#elif SDF == SDF_UNION_CAPSULES\n    float d1 = sdfCapsule(P,\n                          vec3(-1.0,  0.0,  0.0),\n                          vec3( 1.0,  0.0,  0.0),\n                          0.25);\n    float d2 = sdfCapsule(P,\n                          vec3( 0.0, -1.0,  0.0),\n                          vec3( 0.0,  1.0,  0.0),\n                          0.25);\n    float d3 = sdfCapsule(P,\n                          vec3( 0.0,  0.0, -1.0),\n                          vec3( 0.0,  0.0,  1.0),\n                          0.25);\n    return min(d1, min(d2, d3));\n#elif SDF == SDF_PIPE_CYLINDERS\n    float d1 = sdfCylinder(P, 0.75);\n    float d2 = sdfCylinder(P.yzx - vec3(0.75, 0.0, 0.0), 0.75);\n  //float d3 = sdfCylinder(P.zxy, 0.75);\n\n  //return min(d1, d2);\n    return length(vec2(d1, d2)) - 0.25;\n  //return length(vec3(d1, d2, d3)) - 0.25;\n#elif SDF == SDF_POLAR_CYLINDERS\n    float theta = atan(P.y, P.x);\n    theta = mod(theta + Pi / 6.0, Pi / 3.0) - Pi / 6.0;\n    float r = length(P.xy);\n\n    P.xy = r * vec2(cos(theta), sin(theta));\n\n    return sdfCylinder(P.yzx, 0.5);\n#elif SDF == SDF_TRIANGULAR_CYLINDER\n    return sdfTriangularCylinder(P, 1.0);\n#elif SDF == SDF_HEXAGONAL_CYLINDER\n    return sdfHexagonalCylinder(P, 1.0);\n#elif SDF == SDF_DISPLACEMENT\n    float d1 = sdfSphere(P, 1.0);\n  //float d2 = 0.05 * sin(12.0 * P.x);\n  //float d2 = 0.05 * sin(12.0 * P.x) * sin(12.0 * P.y) * sin(12.0 * P.z);\n    float d2 = 0.05 * sin(12.0 * P.x) * sin(12.0 * P.y) * sin(12.0 * P.z);\n  //float d2 = 0.05 * sin(12.0 * P.x + sin(6.0 * iTime)) * sin(12.0 * P.y + sin(6.0 * iTime)) * sin(12.0 * P.z + sin(6.0 * iTime));\n\n    return d1 + d2;\n#elif SDF == SDF_TWIST\n    P = spTwist(P, 1.0);\n    return sdfRoundBox(P, vec3(0.375, 0.5, 0.75), 0.125);\n#elif SDF == SDF_BEND\n    P = spBend(P, 0.25);\n    return sdfRoundBox(P, vec3(0.375, 0.5, 0.75), 0.125);\n#elif SDF == SDF_BOX_MINUS_CYLINDERS\n    P = P.xzy;\n\n    float d1 = sdfRoundBox(P, vec3(2.25, 0.75, 0.5), 0.125);\n    float d2 = sdfCylinder(P -vec3(1.5, 0.0, 0.0), 0.5);\n    float d3 = sdfBoxCylinder(P, vec2(0.5));\n  //float d3 = sdfTriangularCylinder(P, 0.5);\n    float d4 = sdfHexagonalCylinder(P + vec3(1.5, 0.0, 0.0), 0.5);\n\n    float d234 = -min(d2, min(d3, d4));\n\n  //return max(d1, d234);\n    float r = 0.0625;\n    vec2 u = max(vec2(r + d1, r + d234), vec2(0.0));\n    return min(-r, max(d1, d234)) + length(u);\n#elif SDF == SDF_STAR\n    float theta = atan(P.x, P.z); // - iTime;\n    theta = mod(theta + Pi / 5.0, Pi / 2.5) - Pi / 5.0;\n    float r = length(P.xz);\n    P.zx = r * vec2(cos(theta), sin(theta));\n\n    P.xy = abs(P.xy);\n    float d = sdfPlane(P, normalize(vec3(3.0, 5.0, 1.0)), 0.2);\n\n    return d;\n#endif // SDF\n}\n\n\nvec2 sdf(vec3 P, float p) {\n    float d1 = sdfBackground(P, p);\n    float d2 = sdfForeground(P);\n\n    float d = min(d1, d2);\n\n    return vec2(d, d1 <= d2 ? 0.0 : 1.0);\n}\n\n\nvec3 sdfNormal(vec3 P, float s) {\n    const vec3 h = Epsilon * vec3(1.0, 0.0, 0.0);\n\n    return normalize(vec3(sdf(P + h.xyz, s).x - sdf(P - h.xyz, s).x,\n                          sdf(P + h.zxy, s).x - sdf(P - h.zxy, s).x,\n                          sdf(P + h.yzx, s).x - sdf(P - h.yzx, s).x));\n}\n\n\nvec2 intersect(vec3 O, vec3 d, float p) {\n    float t = 0.0;\n\n    for (int i = 0; i < MaxNumSteps; ++i) {\n        vec3 P = O + t * d;\n        vec2 result = sdf(P, p);\n        float distance_ = result.x;\n\n        if (distance_ < Epsilon)\n            return vec2(t, result.y);\n\n        t += distance_;\n    }\n\n    return vec2(MaxT, 0.0);\n}\n\n\nmat3 makeRotation(float theta, vec3 u) {\n    mat3 I = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    mat3 K = mat3(0.0, u.z, -u.y, -u.z, 0.0, u.x, u.y, -u.x, 0.0);\n    return I + sin(theta) * K + (1.0 - cos(theta)) * K * K;\n}\n\n\nvoid makeRay(vec2 xy, out vec3 O, out vec3 d) {\n    O = vec3(0.0, 0.0, 5.0);\n    d = normalize(vec3(xy, -1.0));\n\n    float theta = Pi / 24.0 + mod(iTime / 50.0, 2.0 * Pi);\n\n    mat3 Rz = makeRotation(theta, vec3(0.0, 0.0, 1.0));\n    mat3 Rx = makeRotation(Pi / 3.0, vec3(1.0, 0.0, 0.0));\n    mat3 R = Rz * Rx;\n\n    O = R * O;\n    d = R * d;\n}\n\n\nconst vec3 LightVector = -normalize(vec3(1.0, 1.0, -1.0));\n\n\nfloat intersectShadow(vec3 O, vec3 d,\n                      float tmin, float tmax,\n                      float k, float p) {\n    float t = tmin;\n    float s = 1.0;\n    float distance_ = 0.0;\n\n    if (t >= tmax)\n        return s;\n    \n    for (int i = 0; i < MaxNumSteps; ++i) {\n        vec3 P = O + t * d;\n        float distance_ = sdf(P, p).x;\n\n        if (distance_ < Epsilon)\n            return 0.0;\n\n        s = min(s, k * distance_ / t);\n        t += distance_;\n\n        if (t >= tmax)\n            return s;        \n    }\n\n    return s;\n}\n\n\nfloat shadow(vec3 P, float p) {\n#if SDF == SDF_PIPE_CYLINDERS || SDF_DISPLACEMENT || SDF == SDF_TWIST || SDF == SDF_BEND || SDF_STAR\n    float tmin = 0.5;\n#else\n    float tmin = 0.01;\n#endif\n    vec3 l = LightVector;\n\n    return intersectShadow(P, l, tmin, 8.0, 2.0, p);\n}\n\n\nvec3 sampleTexture(vec3 T) {\n    float d = sdfForeground(T);\n\n    vec3 fgColor1 = vec3(0.125, 0.125, 0.625);\n    vec3 fgColor0 = vec3(0.625, 0.625, 0.125);\n\n    float fgAlpha = exp(-0.1875 * floor(2.0 * d));\n    vec3 fgColor = mix(fgColor0, fgColor1, fgAlpha);\n\n    vec3 bgColor = vec3(0.0, 0.0, 0.0);\n    float x = mod(2.0 * d + 0.5, 1.0) - 0.5;\n    float sigma = 0.02;\n    float alpha = exp(-x * x / (sigma * sigma));\n\n    return mix(fgColor, bgColor, alpha);\n}\n\n\nvec3 sampleTexture(vec3 T, vec3 dTdx, vec3 dTdy) {\n    const float MaxSize = float(MaxNumSamples);\n    const float Scale = 48.0;\n\n    ivec2 size = ivec2(clamp(1.0 + Scale * length(dTdx), 1.0, MaxSize),\n                       clamp(1.0 + Scale * length(dTdy), 1.0, MaxSize));\n\n    vec3 T0 = T;\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < MaxNumSamples; ++i) {\n        for (int j = 0; j < MaxNumSamples; ++j) {\n            if (i >= size.x || j >= size.y)\n                continue;\n\n            vec2 xy = vec2(i, j) / vec2(size);\n            vec3 T = T0 + xy.x * dTdx + xy.y * dTdy;\n\n            color += sampleTexture(T);\n        }\n    }\n\n    return color / float(size.x * size.y);\n}\n\n\nvec3 shade(vec3 P, vec3 n, vec3 d, float m, float p) {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n\n    if (m == 0.0) {\n        float i = floor(P.x);\n        float j = floor(P.y);\n        float c = mod(i + j, 2.0);\n\n        ambient = c == 0.0 ? vec3(0.1) : vec3(0.2);\n        diffuse = vec3(0.5);\n        specular = vec3(0.1);\n        shininess = 10.0;\n    } else if (m == 1.0) {\n        ambient = vec3(0.05, 0.075, 0.1);\n        diffuse = vec3(0.15, 0.3, 0.5);\n        specular = vec3(0.4, 0.4, 0.4);\n        shininess = 20.0;\n    } else if (m == 2.0) {\n        vec3 T = P;\n        vec3 dTdx = dFdx(T);\n        vec3 dTdy = dFdy(T);\n\n      //ambient = sampleTexture(T);\n        ambient = sampleTexture(T, dTdx, dTdy);\n        diffuse = vec3(0.5);\n        specular = vec3(0.1);\n        shininess = 10.0;\n    } else if (m == 3.0) {\n        float i = floor(2.0 * P.x);\n        float j = floor(2.0 * P.y);\n        float k = floor(2.0 * P.z);\n        float c = mod(i + j + k, 2.0);\n\n        ambient = c == 0.0 ? vec3(0.6) : vec3(0.2);\n        diffuse = vec3(0.2);\n        specular = vec3(0.4);\n        shininess = 20.0;\n    }\n\n    vec3 l = LightVector;\n    vec3 r = reflect(d, n);\n\n    return ambient\n        + shadow(P, p) * (diffuse * max(dot(n, l), 0.0)\n                        + specular * pow(max(dot(r, l), 0.0), shininess));\n}\n\n\nvec3 applyFog(vec3 color, float distance_) {\n    const vec3 FogColor = vec3(0.05);\n    float t = 1.0 - exp(-0.001 * distance_ * distance_);\n\n    return mix(color, FogColor, t);\n}\n\n\nvec2 normalizeCoord(vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = normalizeCoord(fragCoord);\n    vec2 mouse = normalizeCoord(iMouse.xy);\n\n    vec3 O, d;\n    makeRay(xy, O, d);\n\n    float p = -1.0;\n\n    if (iMouse.y > 0.0 && iMouse.y < iResolution.y)\n        p = mouse.y * iResolution.x / iResolution.y;\n\n    vec2 result = intersect(O, d, p);\n    float t = result.x;\n\n    if (t >= MaxT)\n        return;\n\n    vec3 P = O + t * d;\n    vec3 n = sdfNormal(P, p);\n    float m = result.y;\n\n    float x0 = 0.0;\n\n    if (iMouse.x > 0.0 && iMouse.x < iResolution.x)\n        x0 = mouse.x;\n\n    if (xy.x >= x0)\n        m += 2.0;\n\n    vec3 color = shade(P, n, d, m, p);\n    color = applyFog(color, t);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xslyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1432, 1452, 1452, 1480], [1483, 1483, 1503, 1503, 1541], [1544, 1544, 1564, 1564, 1592], [1595, 1595, 1615, 1615, 1653], [1656, 1656, 1679, 1679, 1907], [1910, 1910, 1933, 1933, 2244], [2775, 3580, 3619, 3619, 4004], [4007, 4007, 4039, 4039, 4242], [4245, 4245, 4283, 4283, 4547], [4550, 4550, 4590, 4590, 4976], [4979, 4979, 5018, 5018, 5650], [5653, 5653, 5697, 5697, 5769], [5772, 5772, 5818, 5818, 5891], [5894, 5894, 5940, 5940, 6014], [6017, 6017, 6051, 6051, 6079], [6082, 6082, 6113, 6113, 6144], [6147, 6147, 6177, 6177, 6256], [6259, 6259, 6303, 6303, 6334], [6337, 6337, 6378, 6378, 6406], [6409, 6409, 6445, 6445, 6491], [6494, 6494, 6531, 6531, 6578], [6581, 6581, 6634, 6634, 6769], [6772, 6772, 6808, 6808, 6839], [6842, 6842, 6893, 6893, 7003], [7006, 7006, 7037, 7037, 7100], [7103, 7103, 7152, 7152, 7215], [7218, 7218, 7264, 7264, 7598], [7601, 7601, 7639, 7639, 7721], [7724, 7724, 7769, 7769, 8050], [8053, 8053, 8102, 8102, 8210], [8213, 8213, 8262, 8262, 8303], [8306, 8306, 8362, 8399, 8439], [8442, 8442, 8480, 8480, 8530], [8533, 8533, 8564, 8564, 8688], [8691, 8691, 8721, 8721, 8845], [8848, 8848, 8877, 8877, 13776], [13779, 13779, 13806, 13806, 13948], [13951, 13951, 13984, 13984, 14246], [14249, 14249, 14290, 14290, 14585], [14588, 14588, 14628, 14628, 14821], [14824, 14824, 14871, 14871, 15166], [15230, 15230, 15355, 15355, 15774], [15777, 15777, 15808, 15808, 16049], [16052, 16052, 16080, 16080, 16515], [16518, 16518, 16568, 16568, 17208], [17211, 17211, 17265, 17265, 18571], [18574, 18574, 18618, 18618, 18752], [18755, 18755, 18792, 18792, 18860], [18863, 18863, 18918, 18918, 19591]], "test": "error"}
{"id": "XsscD8", "name": "Heart 2D", "author": "TrueBoolean", "description": "Based on IQ's awesome youtube video: https://www.youtube.com/watch?v=aNR4n0i2ZlM&t=1s\n\nReally helped me see how to make shapes and animation more organic-looking in shaders.", "tags": ["heart"], "likes": 1, "viewed": 91, "published": "Public", "date": "1487997848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 p ){\n    const float TAU = atan(0., -1.) *2.;\n    float aa = 6.0 / iResolution.y;\n\tp = ((p.xy/iResolution.y)-(iResolution.xy/iResolution.y)/2.)*4.;\n    o = vec4(1.);\n    //Shape\n    float r = 1. + 0.2*pow(0.5 + 0.5*sin(iTime * TAU + p.y/2.), 4.);\n    p.x = abs(p.x);\n    p.y = p.y - p.x*sqrt((1.7-p.x));\n    p.y/=0.7;\n    o.gb*= smoothstep( r, r+aa, length(p) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsscD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 400]], "test": "valid"}
{"id": "XsscWn", "name": "shader patterns", "author": "JaoCaragg", "description": "asckhbdlmvndl;k", "tags": ["10patterns"], "likes": 0, "viewed": 85, "published": "Public", "date": "1487808617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define pick 2\n\nmat2 scale(float size)\n{\n    return mat2(size,0,0,size);\n}\n\nvec2 multScreen (vec2 uv , float value)\n{\n    uv*=value;\n    return fract(uv);\n}\n\nmat2 rotation(float angle)\n{\n    float rot = radians(angle);\n\treturn mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n}\n\nvec3 createShape(vec2 uv, float sides, vec2 pos, vec3 color, float angle, float size, float thickness)\n{\n    uv = uv *2.-1.2;\n    uv /= size;\n    uv*=rotation(angle);\n    uv.x+=pos.x;\n    uv.y+=pos.y;\n    \n    float a = atan(uv.x,uv.y)+PI;\n  \tfloat r = TWO_PI/float(sides);\n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return vec3(step(thickness,dist)-step(1.,dist)) * color;\n}\n\nvec3 rectangle(vec2 uv , vec2 position , vec2 size , vec3 color)\n{\n    float xBorder = position.x + size.x;\n    float yBorder = position.y + size.y;\n    \n    float hor = step(0.0,uv.x-position.x)-step(0.0,uv.x-xBorder);\n    float ver = step(0.0,uv.y-position.y)-step(0.0,uv.y-yBorder);\n    \n    return (ver * hor) * color;\n}\n\nvec3 verticalStripe(vec2 uv, float start, float end , vec3 color)\n{\n    return (step(start,uv.x)-step(end,uv.x))*color;\n}\n\nvec3 horizontalStripe(vec2 uv, float start, float end , vec3 color)\n{\n    return (step(start,uv.y)-step(end,uv.y))*color;\n}\n\n\nvec3 createCircle(vec2 uv, vec2 position,float radius,vec3 color)\n{\n    uv += position;\n  \tfloat pos =  (distance(uv,vec2(0.4)),distance(uv,vec2(0.6)));\n  \treturn step(pos,radius) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x*= ratio;\n    vec3 frag = vec3(0,0,0);\n    \n    //Patern 1\n    if (pick == 1)\n    {\n    uv = multScreen(uv,5.);\n    uv.x+=0.4;\n    vec3 verStripe =horizontalStripe(uv,0.45,0.55,vec3(0.400,0.400,0.400));\n    vec3 horStripe =verticalStripe(uv,0.85,0.95,vec3(0.400,0.400,0.400));\n    frag = (verStripe + horStripe);\n    }\n    \n    //Patern 2\n    else if (pick == 2)\n    {\n    uv = multScreen(uv,12.);\n    uv.x+=-.5;\n    uv.y-=0.5;\n    uv*=rotation(100.*iTime)*5.;\n    vec3 horStripe =horizontalStripe(uv,0.45,0.55,vec3(cos(iTime*10.)*0.455,cos(iTime*7.)*0.200,cos(iTime*12.)*0.900));\n    vec3 verStripe =verticalStripe(uv,0.85,0.95,vec3(sin(iTime*10.)*0.455,sin(iTime*7.)*0.200,sin(iTime*12.)*0.900));\n    frag = verStripe+horStripe;\n    }\n    \n    //Patern 3\n    else if (pick == 3)\n    {\n    uv*=multScreen(uv,5.0);\n    uv.x+=0.3;\n    float angle = (iTime/3.) + atan(uv.y,uv.x);\n    float radius = (exp(abs(cos(angle * 26.) * sin (angle * 12.)) * .3+ .2/10.)/2.);\n    vec3 circle = createCircle(uv,vec2(-0.3,0.1),radius,vec3(1,1,1));\n    frag = circle;\n    }\n    \n    //patern 4\n    else if (pick == 4)\n    {\n    uv=multScreen(uv,5.);\n    uv.x+=0.75;\n    uv.y+=0.50;\n    float rand1 = (abs(sin(iTime/2.)))*16.;\n    float rand2 = fract(cos(iTime/3.5))*9.;\n    float rand3 = abs(log(tan(iTime/2.5)))/2.;\n    float rand4 = ceil(acos(iTime/2.));\n    vec3 rect1 = rectangle(uv,vec2(rand1*0.1/2.,rand2*0.1/2.),vec2(0.3,0.3),vec3(0.300,0.0,0.0));\n    vec3 rect2 = rectangle(uv,vec2(rand3*0.8,0.2),vec2(0.5,0.3),vec3(0.0,0.300,0.0));\n    vec3 rect3 = rectangle(uv,vec2(0.7,rand1/10.*0.6),vec2(0.3,0.2),vec3(0.0,0.0,0.300));\n    vec3 rect4 = rectangle(uv,vec2(rand1*rand2*0.01,0.7),vec2(0.6,0.2),vec3(0.300,0.300,0.0));\n    vec3 rect5 = rectangle(uv,vec2(0.9,0.7*sin(iTime/2.)),vec2(0.6,0.2),vec3(0.0,0.300,0.0));\n    vec3 rect6 = rectangle(uv,vec2(0.0,0.0),vec2(2.0*abs(sin(iTime)),2.6*abs(sin(iTime))),vec3(0.300,0.300,0.300));\n    vec3 rect7 = rectangle(uv,vec2(rand1*0.5/3.,rand2*0.2/3.),vec2(0.3,0.3),vec3(0.300,0.0,0.300));\n    frag = rect1+rect2+rect3+rect4+rect5+rect6+rect7;\n    }\n    \n    //patern 5\n    else if (pick == 5)\n    {\n    uv=multScreen(uv,10.);\n    uv.x+=0.50;\n    vec3 stripe1 = horizontalStripe(uv, 0.45,0.50 , vec3(0.,0.300,0.));\n    vec3 stripe2 = verticalStripe(uv,0.90,0.95,vec3(0.,0.300,0.300));\n    vec3 stripe3 = horizontalStripe(uv*rotation(45.)-0.515, 0.45,0.50 , vec3(0.,0.,0.300));\n    vec3 stripe4 = horizontalStripe(uv*rotation(135.)+0.155, 0.45,0.50 , vec3(0.300,0.,0.));\n    vec3 circle = createCircle(uv,vec2(-0.32,0.12),0.3,vec3(sin(iTime)*0.300,cos(iTime)*0.300,cos(iTime)*0.400));\n    frag = stripe1+stripe2+stripe3+stripe4+circle;\n    }\n    \n    //patern 6\n    else if (pick == 6)\n    {\n    uv =multScreen(uv,4.);\n    vec3 stripe1 = verticalStripe(uv,0.90,0.95,vec3(0.,0.,0.400));\n    vec3 stripe2 = verticalStripe(uv,1.0,1.05,vec3(0.,0.400,0.));\n    vec3 stripe3 = verticalStripe(uv,1.10,1.15,vec3(0.400,0.,0.));\n    vec3 stripe4 = verticalStripe(uv,1.20,1.25,vec3(0.,0.,0.400));\n    vec3 stripe5 = verticalStripe(uv,1.30,1.35,vec3(0.,0.400,0.));\n    vec3 stripe6 = verticalStripe(uv,1.40,1.45,vec3(0.,0.,0.400));\n    vec3 stripe7 = verticalStripe(uv,1.50,1.55,vec3(0.400,0.,0.));\n    vec3 stripe8 = verticalStripe(uv,1.60,1.65,vec3(0.,0.400,0.));\n    vec3 stripe9 = verticalStripe(uv,1.70,1.75,vec3(0.,0.,0.400));\n    vec3 stripe10 = verticalStripe(uv,0.80,0.85,vec3(0.400,0.400,0.));\n    vec3 stripe11 = verticalStripe(uv,0.70,0.75,vec3(0.,0.400,0.400));\n    vec3 stripe12 = verticalStripe(uv,0.60,0.65,vec3(0.400,0.,0.400));\n    vec3 stripe13 = verticalStripe(uv,0.50,0.55,vec3(0.400,0.400,0.));\n    vec3 stripe14 = verticalStripe(uv,0.40,0.45,vec3(0.400,0.,0.400));\n    vec3 stripe15 = verticalStripe(uv,0.30,0.35,vec3(0.,0.400,0.400));\n    vec3 stripe16 = verticalStripe(uv,0.20,0.25,vec3(0.400,0.400,0.));\n    vec3 stripe17 = verticalStripe(uv,0.10,0.15,vec3(0.400,0.,0.400));\n    vec3 stripe18 = verticalStripe(uv,0.0,0.05,vec3(0.360,0.250,0.100));\n    vec3 stripe19 = verticalStripe(uv,abs(0.0+sin(iTime/2.))*2.,abs(0.05+sin(iTime/2.))*2.,vec3(0.360,0.250,0.100));\n    frag = stripe1+stripe2+stripe3+stripe4+stripe5+stripe6+stripe7+stripe8+stripe9+stripe10+stripe11+stripe12+stripe13+stripe14\n        +stripe15+stripe16+stripe17+stripe18+stripe19;\n    }\n    \n    //patern 7\n    else if (pick == 7)\n    {\n    uv=multScreen(uv,12.0);\n    uv*=rotation(sin(iTime)*45.);\n    vec2 shapePos = vec2(.5*ratio , .5);\n    float dist = distance(shapePos,uv)*2.0;\n    uv-= shapePos;\n    float angle = (iTime) + atan(uv.y,uv.x);\n    float radius = sin(3.0*angle);\n    radius = sin(angle*74.0)*sin(angle*40.0)*sin(angle * 8.0);\n    radius = sqrt(exp(abs(cos(angle * 26.) * sin (angle * 12.))) * .3+ .2/10.);\n    float value = 1.-step(radius, dist);\n    frag = value * abs(vec3(sin(iTime)*0.400,cos(iTime)*0.400,cos(iTime)*0.400));\n    }\n    \n    //patern 8\n    else if (pick == 8)\n    {\n    uv = multScreen(uv,3.);\n    vec3 stripe1 = verticalStripe(uv*rotation(45.),-0.60,-0.50 , vec3(0.400,0.400,0.400));\n    vec3 stripe2 = verticalStripe(uv*rotation(45.),-0.40,-0.30 , vec3(0.400,0.400,0.400));\n    vec3 stripe3 = verticalStripe(uv*rotation(45.),-0.20,-0.10 , vec3(0.400,0.400,0.400));\n    vec3 stripe4 = verticalStripe(uv*rotation(45.),0.00,0.10 , vec3(0.400,0.400,0.400));\n    vec3 stripe5 = verticalStripe(uv*rotation(45.),0.20,0.30 , vec3(0.400,0.400,0.400));\n    vec3 stripe6 = verticalStripe(uv*rotation(45.),0.40,0.50 , vec3(0.400,0.400,0.400));\n    vec3 stripe7 = verticalStripe(uv*rotation(45.),0.60,0.70 , vec3(0.400,0.400,0.400));\n    vec3 stripe8 = verticalStripe(uv*rotation(45.),0.80,0.90 , vec3(0.400,0.400,0.400));\n    vec3 stripe9 = verticalStripe(uv*rotation(45.),1.00,1.10 , vec3(0.400,0.400,0.400));\n    vec3 stripe10 = horizontalStripe(uv,0.0,0.05,vec3(0.400,0.400,0.400));\n    vec3 stripe11 = horizontalStripe(uv,0.10,0.15,vec3(0.400,0.400,0.400));\n    vec3 stripe12 = horizontalStripe(uv,0.20,0.25,vec3(0.400,0.400,0.400));\n    vec3 stripe13 = horizontalStripe(uv,0.30,0.35,vec3(0.400,0.400,0.400));\n    vec3 stripe14 = horizontalStripe(uv,0.40,0.45,vec3(0.400,0.400,0.400));\n    vec3 stripe15 = horizontalStripe(uv,0.50,0.55,vec3(0.400,0.400,0.400));\n    vec3 stripe16 = horizontalStripe(uv,0.60,0.65,vec3(0.400,0.400,0.400));\n    vec3 stripe17 = horizontalStripe(uv,0.70,0.75,vec3(0.400,0.400,0.400));\n    vec3 stripe18 = horizontalStripe(uv,0.80,0.85,vec3(0.400,0.400,0.400));\n    vec3 stripe19 = horizontalStripe(uv,0.90,0.95,vec3(0.400,0.400,0.400));\n    vec3 stripe20 = horizontalStripe(uv,1.0,1.05,vec3(0.400,0.400,0.400));\n    frag = stripe1+stripe2+stripe3+stripe4+stripe5+stripe6+stripe7+stripe8+stripe9+stripe10+stripe11+stripe12+stripe13+stripe14\n        +stripe15+stripe16+stripe17+stripe18+stripe19+stripe20;\n    }\n    \n\tfragColor = vec4(vec3(frag),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsscWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 95, 95, 129], [131, 131, 172, 172, 211], [213, 213, 241, 241, 330], [332, 332, 436, 436, 725], [727, 727, 793, 793, 1051], [1053, 1053, 1120, 1120, 1174], [1176, 1176, 1245, 1245, 1299], [1302, 1302, 1369, 1369, 1492], [1494, 1494, 1551, 1551, 8472]], "test": "valid"}
{"id": "XsXcWH", "name": "Light Square Grid test", "author": "SalikSyed", "description": "A grid of light squares", "tags": ["lightsquares"], "likes": 8, "viewed": 310, "published": "Public", "date": "1487876991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat integrate_montecarlo(vec2 start, vec2 end, vec2 pt) {\n    if (length(pt - (start*0.5 + end*0.5)) > 0.5) {\n     \treturn 0.0;   \n    }\n    float sum = 0.0;\n    for(int i  = 0; i <= 15; i++) {\n     \tfloat alpha = float(i) / 15.0;\n        float d = length((alpha * start + (1.0 - alpha) * end) - pt);\n        sum += 1.0 / (pow(d, 1.44));\n    }\n    return 0.005*sum;\n}    \n\n\n\n\nfloat integrate(vec2 start, vec2 end, vec2 pt) {\n\treturn integrate_montecarlo(start, end, pt); \n}\n\n\nfloat compute_light_from_square(vec2 outerMin, vec2 outerMax, vec2 pos) {\n   \tfloat d = 0.0;\n    // compute the light contribution from each fluorescent segment\n    d += integrate(outerMin, vec2(outerMin.x, outerMax.y), pos);\n    d += integrate(vec2(outerMax.x, outerMin.y), outerMin, pos);\n    d += integrate(vec2(outerMin.x, outerMax.y), outerMax, pos);\n    d += integrate(vec2(outerMax.x, outerMin.y), outerMax, pos);\n    return d;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoordinate )\n{\n    fragColor = vec4(0.0);\n    vec2 pos = fragCoordinate/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    pos.x *=aspect;\n    float PADDING_X = 0.1;\n    float PADDING_Y = 0.1;\n    int NUM_BOXES = 5;\n    float BOX_PADDING = 0.009;\n    float boxWidth = (1.0-2.0*PADDING_X-0.5*float(NUM_BOXES-1)*BOX_PADDING)/float(NUM_BOXES);\n    float boxHeight = (1.0-2.0*PADDING_X-0.5*float(NUM_BOXES-1)*BOX_PADDING)/float(NUM_BOXES);\n    float d = 0.0;\n    for(int i = 0; i < NUM_BOXES; i++) {\n        for(int j = 0; j < NUM_BOXES; j++) {\n\t\t\tvec2 outerMin = vec2(float(i) * boxWidth + PADDING_X, float(j) * boxHeight + PADDING_Y);\n            vec2 outerMax = outerMin + vec2(boxWidth, boxHeight);\n            outerMin += vec2(BOX_PADDING, BOX_PADDING);\n            outerMax -= vec2(BOX_PADDING, BOX_PADDING);\n\t\t\td += compute_light_from_square(outerMin, outerMax, pos);\n        }\n    }\n    vec4 mixColor =  vec4(19.0/255.0, 98.0/255.0, 128.0/255.0, 1.0);\n    fragColor =  mix(0.00028 *vec4(pow(d, 1.77 + 0.43*(sin(iTime*5.0)*0.5 + 0.5) )), mixColor, 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXcWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 61, 61, 371], [380, 380, 428, 428, 477], [480, 480, 553, 553, 916], [923, 923, 985, 985, 2046]], "test": "valid"}
{"id": "XsXyD8", "name": "Color tension", "author": "SereznoKot", "description": "Experiments wit h sound, color and cyclic noise", "tags": ["hsv", "soundcloud"], "likes": 1, "viewed": 84, "published": "Public", "date": "1487840814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 toRGB(in float h, in float s, in float v) {\n    float i = floor(h * 6.0);\n    float f = h * 6.0 - i;\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - f * s);\n    float t = v * (1.0 - (1.0 - f) * s);\n    \n    float path = mod(i, 6.0);\n    \n    if (path == 0.0) \n        return vec3(v, t, p);\n    if (path == 1.0) \n        return vec3(q, v, p);\n    if (path == 2.0) \n        return vec3(p, v, t);\n    if (path == 3.0) \n        return vec3(p, q, v);\n    if (path == 4.0) \n        return vec3(t, p, v);\n    if (path == 5.0) \n        return vec3(v, p, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 sound = texture(iChannel0, uv).rgb;\n    \n    float last = iResolution.x * iResolution.y / mod(iTime, sin(iTime));\n    float n = fragCoord.x + fragCoord.y * iResolution.x;\n    vec3 color = toRGB(fract(n / last) * 1.5, 1.0, 1.0);\n    \n\tfragColor = vec4(color + sound, 1.0);\n}", "image_inputs": [{"id": "4sB3DK", "previewfilepath": "https://soundcloud.com/hadouken/hadouken-levitate-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/hadouken/hadouken-levitate-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 562], [564, 564, 621, 621, 946]], "test": "error"}
{"id": "XtGXDt", "name": "Ray Marching isVisible Example", "author": "yumcyawiz", "description": "this is the example code for my blog's ray marching articles.", "tags": ["raymarching"], "likes": 0, "viewed": 218, "published": "Public", "date": "1486333709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//distance field\nfloat df(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nstruct Ray {\n    vec3 position;\n    int steps;\n    float t;\n};\n\n//it finds the intersection point and returns various data\nconst int maxSteps = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    vec3 p = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; i++) {\n        p = from + t*rayDir;\n        float d = df(p, 1.0);\n        if(d < 0.001) {\n            steps = i;\n            break;\n        }\n        t += d;\n    }\n    return Ray(p, steps, t);\n}\n\n\n//is point p is visible from the light?\nbool isVisible(vec3 p, vec3 lightPos) {\n    Ray tr = trace(lightPos, normalize(p - lightPos));\n    if(distance(tr.position, p) < 0.1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(-1, -1) ~ (1, 1)\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    //camera settings\n    vec3 camPos = vec3(0, 0, -5);\n    vec3 camFront = vec3(0, 0, 1);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camUp, camFront);\n    float focus = 1.0;\n    \n    //ray direction\n    vec3 rayDir = uv.x*camRight + uv.y*camUp + focus*camFront;\n    \n    //trace\n    Ray tr = trace(camPos, rayDir);\n    \n    //light position\n\tvec3 lightPos = vec3(cos(iTime), 3, sin(iTime));\n    \n    //coloring\n    vec3 color = vec3(clamp(1.0 - pow(float(tr.t)/6.0, 4.0), 0.0, 1.0));\n    if(isVisible(tr.position, lightPos)) {\n    \tcolor = 1.0*color;\n    }\n    else {\n        color = 0.5*color;\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 44, 44, 72], [139, 224, 259, 259, 547], [550, 590, 629, 629, 793], [796, 803, 860, 884, 1606]], "test": "valid"}
{"id": "XtKXWt", "name": "Checkerboard Flight", "author": "PauloFalcao", "description": "Made from scratch on my phone in my last vacation using an app on Android called ShaderBox.\nI've always loved this kind of effects.\nTried to keep the code as readable as possible.", "tags": ["raytracing", "raymarching", "simple", "checkerboard", "flight", "mobile"], "likes": 6, "viewed": 787, "published": "Public API", "date": "1486488805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Checkerboard Flight\n//\n// I've always loved this kind of effects\n//\n// Made from scratch on my phone when I was on vacation using an app on Android called ShaderBox\n// Tried to keep the code as readable as possible.\n\n\n// Textures\nvec3 checkerboard(vec2 p,float size){\n  p*=size;\n  vec2 f=fract(p.xy)-0.5;\n  return vec3(f.x*f.y>0.0?1.0:0.0);\n}\n\n// Object Color\nvec3 objcolor(vec3 p){\n  return checkerboard(p.xz,0.4);\n}\n\n/*\n\n// Ray marching Distance function\n\n// Objects\nfloat plane(float p, float dist){\n  return p-dist;\n}\n\nfloat objdistance(vec3 p){\n   return min(plane(p.y,-2.0),plane(-p.y,-1.0));\n   //return min(plane(sin(p.z)*0.3+sin(p.x+iTime*8.0)*0.3+p.y,-2.0),plane(-p.y,-1.0)); //use raymarching\n}\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n  vec2 uv=fragCoord.xy/iResolution.xy-0.5;\n  uv.x*=iResolution.x/iResolution.y;\n\n  //Camera\n  vec3 lookat=vec3(0.0,-2.0,-iTime*16.0);\n  vec3 cam=vec3(sin(iTime*2.0)*4.0,0.0,10.0)+vec3(0.0,0.0,lookat.z);\n  vec3 up=vec3(sin(iTime*2.0+3.14)*0.5,1.0,0.0);\n\n  float camdist=2.0;\n  float camsize=2.0;\n  float maxdist=50.0;\n  float preci=0.001;\n\n  vec3 v=cam-lookat;\n  vec3 camx=normalize(cross(up,v))*camsize;\n  vec3 camy=normalize(cross(v,camx))*camsize;\n\n  vec3 campoint=cam-normalize(v)*camdist+\n      camx*uv.x+\n      camy*uv.y;\n\n  vec3 ray=normalize(campoint-cam);\n\n  //Ray tracing plane y=-2.0 and y=1.0\n  float s = (-2.0-campoint.y)/ray.y;\n  if( s<0.0 ) s = (1.0-campoint.y)/ray.y;\n  vec3 p=campoint + ray*s;\n    \n  /*\n  //Ray marching\n  //\n  vec3 p=campoint;\n  float d=maxdist;\n  float s=0.0;\n  for(int i=0;i<64;i++){\n      d=objdistance(p);\n      s+=d;\n      if (d<preci) break;\n      if (s>maxdist) break;\n      p=campoint+ray*s;\n  }\n  */\n\n  float fadeout=max(maxdist-s,0.0)/maxdist;\n  fragColor = vec4(objcolor(p)*fadeout, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtKXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 233, 270, 270, 345], [347, 363, 385, 385, 420], [422, 715, 771, 771, 1812]], "test": "valid"}
{"id": "XttSRs", "name": "Lava Archipelgo", "author": "TheSodOfGod", "description": "Made by combining approaches from [url] https://www.shadertoy.com/view/4slGD4 [/url](Terrain) and [url]https://www.shadertoy.com/view/lslXRS[/url] / [url]https://www.shadertoy.com/view/MdBSRW[/url] for the lava.\n\nFrom my point of view the Jedi are evil.\n", "tags": ["raymarching", "perlinnoise", "lava", "islands"], "likes": 18, "viewed": 658, "published": "Public", "date": "1486057378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants\n#define PI 3.1415\n#define MOD2 vec2(3.07965, 7.4235)\n\n// Raymarching\nfloat minPrimStepSize = 0.4 ;\nconst int primNumSamples = 150 ;\n\n// Colours\nconst vec3 obsidianCol = vec3(30./255., 31./255., 30./255.) ;\nconst vec3 sunCol = vec3(1.0,1.0,1.0) ;\nconst vec3 skyCol = vec3(206./255., 146./255., 14./255.) ;\nconst float ambientCol = 0.3 ;\n\n// Sun\nconst float lightElev = 20. * 3.14/180. ;\nconst float lightAzi = 100. * 3.14/180. ;\nconst vec3 lightDir = vec3(cos(lightAzi)*cos(lightElev),sin(lightElev),sin(lightAzi)*cos(lightElev));\n\n// Terrain\nconst int octavesTerrain =  12 ;\nconst float sharpness = 0.35 ;\nconst float offset = 0.85 ;\n\n// Lava\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);  \n}\n\nfloat rand(vec2 c){\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash12(vec2 p) {\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nconst vec2 add = vec2(1.0, 0.0);\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix( hash12(p),          hash12(p + add.xy),f.x),\n                    mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nfloat noiseEmber(vec2 p) {\n    return hash12(p);\n}\n\nfloat smoothNoiseEmber(vec2 p) {\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x),mix(noise(p2), noiseEmber(p3), pf.x), pf.y);\n}\n\nconst int octavesEmber = 5 ;\n\nfloat fbmEmber(in vec2 p) {\n    float f=0.0;\n    for(int i=0; i < octavesEmber; ++i)\n        f+=smoothNoiseEmber(2.0*p*exp2(float(i)))/exp2(float(i+1));\n    return f;\n}\n\nfloat sampleField(vec3 position) {\n  float noiseVal = 0.0 ;\n  float amplitude = 1.0 ;\n  float scaling = 75. ;\n  float freq = 0.009 ;\n  float lac = 2.0 ;\n  for (int i = 0 ; i < octavesTerrain ; ++i) {\n    noiseVal += amplitude * noise(freq*position.xz) ;\n    amplitude /= lac ;\n    freq *= lac ;\n  }\n    \n  // Islandise terrain //\n  noiseVal -= offset ;\n  noiseVal = clamp(noiseVal,0.,1.5) ;\n  noiseVal = pow(sharpness, noiseVal) ;\n  noiseVal = 1.0 - (noiseVal) ;\n  return noiseVal * scaling ;\n}\n\n#define time iTime*0.1\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noiseLava( in vec2 x ){return texture(iChannel0, x*0.02).x;}\n\nfloat sampleFreq = 0.2 ;\nvec2 gradn(vec2 p) {\n\tfloat ep = .09;\n\tfloat gradx = noiseLava(sampleFreq*vec2(p.x+ep,p.y))-noiseLava(sampleFreq*vec2(p.x-ep,p.y));\n\tfloat grady = noiseLava(sampleFreq*vec2(p.x,p.y+ep))-noiseLava(sampleFreq*vec2(p.x,p.y-ep));\n\treturn vec2(gradx,grady);\n}\n\n\n// ...... Taken from https://www.shadertoy.com/view/MdBSRW\n#define TEMPERATURE 2200.0\n\nvec3 blackbody(float t)\n{\n    t *= TEMPERATURE;\n    \n    float u = ( 0.860117757 + 1.54118254e-4 * t + 1.28641212e-7 * t*t ) \n            / ( 1.0 + 8.42420235e-4 * t + 7.08145163e-7 * t*t );\n    \n    float v = ( 0.317398726 + 4.22806245e-5 * t + 4.20481691e-8 * t*t ) \n            / ( 1.0 - 2.89741816e-5 * t + 1.61456053e-7 * t*t );\n\n    float x = 3.0*u / (2.0*u - 8.0*v + 4.0);\n    float y = 2.0*v / (2.0*u - 8.0*v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = Y / y * x;\n    float Z = Y / y * z;\n\n    mat3 XYZtoRGB = mat3(3.2404542, -1.5371385, -0.4985314,\n                        -0.9692660,  1.8760108,  0.0415560,\n                         0.0556434, -0.2040259,  1.0572252);\n\n    return max(vec3(0.0), (vec3(X,Y,Z) * XYZtoRGB) * pow(t * 0.0004, 4.0));\n}\n\n\n// ..... Taken from https://www.shadertoy.com/view/lslXRS\nfloat flowFBM(in vec2 p)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i < 9.;i++ ){\n\t\t//primary flow speed\n\t\tp += time*.006;\n\t\t//secondary flow speed (speed of the perceived flow)\n\t\tbp += time*0.00009;\n\t\t//displacement field (try changing time multiplier)\n\t\tvec2 gr = gradn(i*p*1.4+time*0.1);\n\t\t//rotation of the displacement field\n\t\tgr*=makem2(time*2.-(0.05*p.x+0.03*p.y)*40.);\n\t\t//displace the system\n\t\tp += gr*.5;\n\t\t//add noise octave\n\t\trz+= (sin(noise(p)*7.)*0.5+0.5)/z;\n\t\t//blend factor (blending displaced system with base system)\n\t\t//you could call this advection factor (.5 being low, .95 being high)\n\t\tp = mix(bp,p,.77);\n\t\t//intensity scaling\n\t\tz *= 1.4;\n\t\t//octave scaling\n\t\tp *= 3.1;\n\t\tbp *= 1.5;\n\t}\n\treturn rz;\t\n}\n\n\nvec3 getFieldNormal(in vec3 cameraPos, in vec3 direction, float dist) {\n  float p = min(.3, .0005+.00005 * dist*dist);\n  vec3 position = cameraPos + direction * dist ;\n  vec3 nor = vec3(0.0,sampleField(position), 0.0);\n  vec3 v2 = nor-vec3(p,sampleField(position+vec3(p,0.0,0.0)), 0.0);\n  vec3 v3 = nor-vec3(0.0,sampleField(position+vec3(0.0,0.0,-p)), -p);\n  nor = cross(v2, v3);\n  return normalize(nor);   \n}\n\nvec3 calcSkyCol(in vec3 direction)\n{\n\tfloat sunAmount = max( dot(direction, lightDir), 0.0 );\n\tfloat v = pow(1.0-max(direction.y,0.0),5.)*.5;\n\tvec3  sky = vec3(v*sunCol.x*0.4+skyCol.x, v*sunCol.y*0.4+skyCol.y, v*sunCol.z*0.4+skyCol.z);\n\tsky = sky + sunCol * pow(sunAmount, 6.5)*.32;\n\tsky = sky+ sunCol * min(pow(sunAmount, 1600.), .3)*.65;\n\treturn sky;\n}\n\nfloat fineRayMarchBinarySearch(vec3 startPos, vec3 direction, in vec2 rayDists, out float height) {\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (rayDists.x + rayDists.y) * .5;\n\t\tvec3 p = startPos + halfwayT*direction;\n\t\tif ((height = sampleField(p)) - p.y > 0.5) {\n\t\t\trayDists.x = halfwayT;\n\t\t} else {\n\t\t\trayDists.y = halfwayT;\n\t\t}\n\t}\n\treturn rayDists.x;\n}\n\nbool coarseRayMarch(vec3 startPos, vec3 direction, out float rayDist, out float height) {\n    vec3 position = startPos ;\n    bool intersected = false ;\n    rayDist = 0.0 ;\n    float oldRayDist = rayDist ;\n    \n    for (int i = 0 ; i < primNumSamples ; ++i) {\n        if (position.y > 66.) {\n            break ;\n        }\n\t\tif ((height = sampleField(position)) - position.y > 0.5) {            \n            intersected = true ;\n            break ;\n        } else {\n            oldRayDist = rayDist ;\n            float delta = max(minPrimStepSize,height*0.001) + (rayDist*0.025);\n\t\t    rayDist += delta;\n            position = (rayDist)*direction + startPos ;\n        }\n    }\n    \n    if (intersected) {\n       rayDist = fineRayMarchBinarySearch(startPos,direction,vec2(rayDist,oldRayDist),height) ;   \n    }\n    \n    return intersected ;\n}\n\n// Calculate sun light...\nvec3 calcColour(in vec3 pos, in vec3 normal, in vec3 eyeDir, float dis, float height)\n{\n  \tfloat h = dot(lightDir,normal);\n\tfloat c = max(h, 0.0)+ambientCol;\n    vec2 samplePosition = (eyeDir * dis + pos).xz  ;\n    vec3 lavCol = blackbody(flowFBM(samplePosition*0.005)) ;\n    float specular = 0.0 ;\n    vec3 col ;\n    if (height > 0.0) {\n        specular = 0.6 ;\n        col = obsidianCol ;\n        col = col * (sunCol + lavCol * 6.0/(height)) * c ;\n        if (h  > 0.0) {\n          vec3 R = reflect(lightDir, normal);\n\t  \t  float specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\n\t\t  col = mix(col, sunCol , specAmount);\n        }\n    } else {\n        col = lavCol ;\n    }\n    \n    return col ;\n}\n\nvec3 calcFog( in vec3  rgb, in float dis, in vec3 dir) {\n\tfloat fogAmount = exp(-dis* 0.002);\n\treturn mix(calcSkyCol(dir), rgb, fogAmount);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    vec2  m = 2.*((iMouse.xy / iResolution.xy) - 0.5);\n    \n    if (iMouse.xy == vec2(0)) {\n       m.y = 0.0 ;   \n    }\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n    dir.xz = rot2D(dir.xz, 180. * m.x + 180.);\n    dir = normalize(dir) ;\n\n    float offset = iTime ;\n    vec3 cameraPos = vec3(0.0,0.0,3.0*offset) ;\n    float heightOffset = sampleField(cameraPos) ;\n    cameraPos.y = 20.0 + heightOffset ;\n    float rayInterDist = -1.0 ;\n    float height = 0.0 ;\n\tbool hasIntersected = coarseRayMarch(cameraPos,dir,rayInterDist,height) ;\n    vec3 col = vec3(0.0) ;\n    if (hasIntersected) {\n      vec3 normal = getFieldNormal(cameraPos,dir,rayInterDist) ;\n      col = calcColour(cameraPos + dir*rayInterDist, normal, dir, rayInterDist, height) ;\n    } else {\n      col = calcSkyCol(dir) ;     \n    }\n    col =  calcFog(col,rayInterDist,dir) ;\n    \n    // Taken from \n    vec3 embers=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(time*5.0)*0.01+sin(time)*0.01,1.0,fbmEmber(uv*10.0+vec2(cos(uv.y*0.8+time*1.0)*10.0,time*40.0)));\n    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(time*82.0)*0.01+sin(time*1.2)*0.01,1.0,fbmEmber(vec2(100.0)+uv*8.0+vec2(time*1.0+cos(uv.y*0.3+time*1.0)*10.0,time*30.0)));\n\n\tfragColor = vec4(col + 8.*embers,1) ;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[648, 657, 690, 690, 810], [812, 812, 831, 831, 902], [904, 904, 926, 926, 1012], [1048, 1048, 1074, 1074, 1308], [1310, 1310, 1336, 1336, 1360], [1362, 1362, 1394, 1394, 1677], [1709, 1709, 1736, 1736, 1877], [1879, 1879, 1913, 1913, 2373], [2399, 2399, 2423, 2423, 2488], [2489, 2489, 2517, 2517, 2582], [2583, 2583, 2612, 2612, 2649], [2676, 2676, 2696, 2696, 2930], [2933, 3020, 3045, 3045, 3806], [3809, 3867, 3893, 3893, 4610], [4613, 4613, 4684, 4684, 5022], [5024, 5024, 5060, 5060, 5378], [5380, 5380, 5479, 5479, 5757], [5759, 5759, 5848, 5848, 6597], [6599, 6625, 6712, 6712, 7343], [7345, 7345, 7401, 7401, 7486], [7493, 7493, 7549, 7549, 8887]], "test": "error"}
{"id": "XtVSDc", "name": "Headache Experiment 1", "author": "aiekick", "description": "Headache Experiment 1", "tags": ["experiment", "headache", "1"], "likes": 6, "viewed": 420, "published": "Public API", "date": "1486228511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 path(vec3 p)\n{\n\tp *= RotZ(p.z * 0.1);\n    p += sin(p.zxy * 0.5) * 0.5;\n\tp *= RotZ(p.z * 0.2);\n   \treturn sin(p.zxy * 0.2) * 2.;\n}\n\nfloat wireShape(vec3 p, float df, float size, float thick, vec3 space) \n{\n\treturn length(\n\t\tmin(\n\t\t\tmin(\n\t\t\t\tvec2(df - size,abs(p.y)-space.y),\n\t\t\t\tvec2(df - size,abs(p.z)-space.z)\n\t\t\t),\n\t\t\tvec2(df - size,abs(p.x)-space.x)\n\t\t)\n\t) - thick;\n}\n\nfloat thick = 0.05;\nfloat space = 0.5;\nfloat radius = 2.;\nfloat dist = 0.;\n    \nfloat df(vec3 p)\n{\n\tp += path(p);\n\tp *= RotZ(p.z * 0.01);\n    p.z = mod(p.z,space)-space*.5;\n    //dist = max(abs(p.x),abs(p.y));\n    //dist = length(p);\n    //dist = max(abs(p.y)+p.x,-p.x);\n    dist = abs(p.y);\n    return wireShape(p, dist, radius, thick, vec3(0.15));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 3;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s)/s;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\t\n\tvec2 uv = (g+g-si)/si.y;\n\n\tfloat time = iTime;\n\t\n\tvec3 ro = vec3(0,0, time*5.);\n\tro -= path(ro);\n\t\n\tvec3 cv = ro + vec3(0,0,4); // cam view\n\tcv -= path(cv);\n\t\n\tvec3 lp = ro;\t// light pos\n\t\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<250; i++) \n\t{\n\t\tif (log(d*d/s/1e6)>0.|| d > 50.) break; \n\t\td += (s = df(ro+rd*d))*0.5;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(0.8,0.5,0.2);\n\tfloat sss = df(p - n*0.001)/0.01;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.01);\t\t\t\t\t\t\t// deep subdensity \n\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 1.0 - SubDensity(p, 1.5); \t\t\t\t\t\t\t// one step sub density of df of 1.5 of subsurface\n\t\n\tvec3 a = (diff + fre + bb * sss * .8 + col * sss * .2) * 0.35 + spe;\n    vec3 b = col * sss2;\n    \n\tfragColor.rgb = clamp(mix(a, b, .8-exp(-0.005*d*d)),0.,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVSDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 214, 233, 233, 291], [293, 293, 312, 312, 427], [429, 429, 502, 502, 668], [750, 750, 768, 768, 1021], [1023, 1023, 1057, 1057, 1257], [1259, 1480, 1508, 1508, 1833], [1835, 1917, 1974, 1974, 2197], [2199, 2199, 2235, 2235, 2370], [2372, 2372, 2429, 2429, 3916]], "test": "valid"}
{"id": "XtVSDt", "name": "Soap Bubble Music Visualizer #1", "author": "Ruzzyr", "description": "playing around with shaders. Killing time. Having fun", "tags": ["raymarching", "simple", "music"], "likes": 9, "viewed": 419, "published": "Public", "date": "1486543085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotateYmat(float ang)\n{\n    return mat3(cos(ang), 0.0, sin(ang),\n                0.0, 1.0, 0.0,\n                -sin(ang), 0.0, cos(ang));\n}\nmat3 rotateXmat(float ang)\n{\n    return mat3(1.0, -0.0, 0.0,\n                0.0, cos(ang), -sin(ang),\n                0.0, sin(ang), cos(ang));\n}\n\nmat3 rotateZmat(float ang)\n{\n    return mat3(cos(ang), -sin(ang), 0.0,\n                sin(ang), cos(ang), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat map( vec3 p, vec3 origin, float s )\n{    \n    vec3 offset = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\n\tfloat d = length(p + offset - origin)- s;\n\toffset = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\n    for(int i = 0; i < 3; i++)\n    {\n        \n        float prism2 = length(p + offset*float(i) - origin)- s;\n        d = max(d, -prism2);\n    }\n  \treturn d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    mat3 rotation = //mat3(1.0);\n      rotateXmat(iTime*0.4)*rotateYmat(iTime*0.5);\n    vec3 direction = normalize(vec3(uv.x,uv.y, 1.0)*rotation);\n\n\n   \n    \n    float t = 0.0;\n\tvec3 p;\n    vec3 finalColor; \n\t\n    vec3 origin = vec3(0.,0.,-4.)*rotation;\n    vec3 offset;\n    vec3 sphereOrigin = vec3(0., 0., 0.0);\t\t\t\t\n\n    vec4 sound = texture (iChannel0,vec2(fragCoord.x/iResolution.x, 0.75));      \n    float soundColor = texture (iChannel0,vec2(0.5, 0.75)).x;   \n \n    vec3 color = vec3(.5 + sin(uv.x+iTime +soundColor*50.)*.4,.5 +cos(uv.y+iTime + soundColor*5.)*.5,.5);\n    for (int k = 0; k <15; k++)\n    {\n        p = origin + t*direction;\n        float d = map(p,sphereOrigin, 2.0);\n\n        {\n            vec3 directionalOffset = -normalize(p)*sound.x*normalize(vec3(uv, 1.0));\n            vec3 position = p + directionalOffset;\n            float radius = 0.1+float(k)*.5;        \n            float lineThickness = 0.02 + float(k)*0.01;\n            //position.y += position.y*abs(uv.x);\n            float distanceFromCenter = length(position);\n            float condition = step( distanceFromCenter, radius)\n                - step(distanceFromCenter, radius - lineThickness);\n            finalColor += color*condition;\n        }\n\n        t += d;\n    }\n    float fog = 1.0/(1.0+t*t*0.1);\n    fragColor = vec4(finalColor+color*vec3(fog), fog);    \n    \n}", "image_inputs": [{"id": "4lf3Dj", "previewfilepath": "https://soundcloud.com/salar-yazdani/old-friends-darren-korb", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/salar-yazdani/old-friends-darren-korb", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 145], [146, 146, 174, 174, 292], [294, 294, 322, 322, 439], [441, 441, 484, 484, 842], [843, 843, 900, 900, 2371]], "test": "error"}
{"id": "XtVSWV", "name": "cartoon wave 2", "author": "bolloxim", "description": "more meh", "tags": ["meh"], "likes": 0, "viewed": 58, "published": "Public", "date": "1485975892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Andi Smithers \n// wave effect using curves\n\n#define C(x)   a*cos(x-t) \n#define S(x)   a*sin(x-t)\n#define X0(x,xx)  x-C(xx)\n\nfloat trochoid(float x, float t, float a) \n{\n    return S(X0(x,X0(x,X0(x,X0(x,X0(x,x))))));\n}\n\n#define plot(Y) o += smoothstep(40.0/R.y, 0.0, abs(Y-uv.y))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.05;\n    float antiAliasSize = 0.03;\n    vec4 borderColor = vec4(1.0,1.0,0.95, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float t = iTime;\n\n    vec2 shadowVec = vec2(-0.01, 0.05);\n    float scaleBox = 1.2;\n\n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tuv.y+=0.3;\n    \n    float wave = trochoid(uv.x*8.0, 0.0, sin(t))*0.05;\n  //  float alpha2 = clamp(1.0-abs(mod(sin(t)+uv.x*1.5, 3.142)-1.57)*1.3, 0.0, 1.0);\n    float alpha3 = smoothstep(0.0, 0.7, 1.0-abs(iuv.x*2.0-1.0));\n    float alpha = smoothstep(10.0/iResolution.y, 0.0, abs(wave-uv.y+0.5));\n    float alpha2 = uv.y>0.6 ? 1.0 : max(uv.y*5.0 -2.0, 0.0);\n //   float wave = abs(sin(iuv.x + rounding ) - iuv.y*32.0+16.0);\n //   wave = clamp(1.0-wave, 0.0, 1.0);\n    \n    // blend against a background texture - because shadeoy\n    vec4 background = vec4(0.2,0.5,1.0,1.0);\n    vec4 color = vec4(1.0, 1.0, 1.0, clamp(alpha*40.0, 0.0, 1.0)*alpha2*alpha3);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 171, 171, 220], [283, 283, 340, 356, 1481]], "test": "valid"}
{"id": "XtVXWV", "name": "Oil Port", "author": "airtight", "description": "Simplified Port of 'Oil' by Patricio Gonzalez Vivo \nfrom https://thebookofshaders.com/log/160712002432.frag ", "tags": ["noise", "perlin"], "likes": 15, "viewed": 499, "published": "Public", "date": "1485981223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplfied port of Oil by Patricio Gonzalez Vivo\n// http://www.kamend.com/2012/06/perlin-noise-and-glsl/\n\nvec4 mod289 (vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute (vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt (vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 fade (vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\n// Classic 2D Perlin noise\nfloat cnoise (vec2 P) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    \n    vec4 i = permute(permute(ix) + iy);\n    \n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n    \n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    \n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\nfloat noise(vec2 p){         \n\treturn  0.4 * cnoise(p);    \n}\n\nfloat pattern( in vec2 uv, in float time){   \n    \n    //instead of just getting a noise field value on uv position and time,\n    //we first warp the uv space by noise a couple of times\n    //this gives more intersting 'curly' looking noise\n    //this is known as domain warping: http://www.iquilezles.org/www/articles/warp/warp.htm\n    \n    //get a noise value q\n    vec2 q = vec2(9.0, 0.);\n    q.y = noise(uv + vec2(5.2*time,1.3*time)) ;\n    \n    //now warp uv space by q and get noise on that\n    vec2 r = vec2(0.);\n    r.x = noise(uv + 4.0 * q + vec2(1.7,9.2));\n    \n    //now warp uv space by r and get noise on that\n    return noise(uv + 4.0*r);\n\n}\n\nconst float SCALE = 2.0;\nconst float BRIGHTNESS = 3.5;\nconst float SPEED = 0.3;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2. * st;\n    uv *= SCALE;\n    float time = iTime*SPEED;\n    vec3 color = vec3(pattern(uv,time)*BRIGHTNESS);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 108, 130, 130, 177], [178, 178, 201, 201, 236], [237, 237, 266, 266, 316], [317, 317, 337, 337, 375], [377, 404, 427, 427, 1551], [1554, 1554, 1574, 1574, 1615], [1617, 1617, 1659, 1980, 2271], [2354, 2354, 2409, 2409, 2623]], "test": "valid"}
{"id": "Xty3Ww", "name": "Raymarching AA test", "author": "Shirooo", "description": "At the edges of the shapes just interpolate its color with the background color, based on the distance to the shape. \nTurn \"SHOW_AA_FACTOR\" on to see the factor of this interpolation.\nAll raymarching theory learned from Iñigo Quilez videos and articles.", "tags": ["raymarchingantialiasingaa"], "likes": 10, "viewed": 354, "published": "Public", "date": "1487515190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RM_DIST 0.001\n#define AA_DIST 0.025\n\n#define SHOW_AA_FACTOR 0\n\nfloat dsphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat dplane(vec3 p, vec3 o, vec3 n, float h)\n{\n    vec3 op = p-(o+n*h);\n    return dot(op,n);\n}\n\nfloat opU(float d1,float d2,out float idx)\n{\n    idx = d1 < d2 ? 0.0 : 1.0;\n    return min(d1,d2);\n}\n\nfloat opB(in float d1, in float d2, in float k)\n{\n    float h = clamp( 0.5+0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p , out float idx)\n{\n    float d1 = dsphere(p,vec3(0.0),1.0);\n    d1+=0.05*sin(p.x*10.0+iTime*2.0)*sin(p.y*10.0)*sin(p.z*10.0);\n    \n    float d2 = dsphere(p,vec3(2.15,0.0,0.0),0.5);\n    d2 += 0.02*sin(p.x*10.0 + iTime*3.0);\n    \n    float d3 = dplane(p,vec3(0.0),normalize(vec3(0.0,1.0,0.0)),-1.5);\n    \n    float d4 = opB(d1,d2,1.3);\n    \n    return opU(d3,d4,idx);\n}\n\nvec3 norm( vec3 p )\n{\n    vec2 e = vec2(0.01,0.0);\n    float idx =0.0;\n\treturn normalize( vec3( map( p + e.xyy ,idx) - map( p - e.xyy,idx ),\n                            map( p + e.yxy,idx ) - map( p - e.yxy,idx ),\n                            map( p + e.yyx,idx ) - map( p - e.yyx,idx )\n                            ));\n}\n\nvoid accumColor(out vec3 acc_c, in vec3 new_c, in float aa_factor)\n{\n    if(acc_c == vec3(1.0,2.0,3.0))\n    {\n        acc_c = new_c;\n    }\n    else\n    {\n#if SHOW_AA_FACTOR\n        acc_c = vec3(aa_factor);\n#else\n        acc_c = mix(acc_c,new_c,aa_factor);\n#endif\n    }\n}\n\nfloat shadow(vec3 pi, vec3 l,float k)\n{\n    float t = 1.0;\n    float tmax = 30.0;\n    float res = 1.0;\n    for(int i=0; i<256; ++i)\n    {\n        vec3 p = pi + t * l;\n        float idx;\n        float d = map(p,idx);\n        \n        res = min(res, k * d/t);\n        if(d < 0.0001 || t > tmax) break;\n        \n        t+=d;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shadeP( in vec3 p,in vec3 rd, float idx)\n{\n    vec3 mat = idx < 0.5 ? vec3(0.6,0.2,0.1) : vec3(0.4,0.7,0.9);\n    vec3 l = normalize(vec3(1.0,1.0,1.0));\n    vec3 n = norm(p);\n    float s = shadow(p,l,8.0);\n    float rs = shadow(p,reflect(rd,n),12.0);\n    \n    vec3 col = vec3(0.1)*mat;\n    col += clamp(dot(l,n),0.0,1.0)*mat*s*0.8;\n    col += pow(clamp(dot(reflect(rd,n),l),0.0,1.0),150.0)*0.1;\n    col += pow(1.0-clamp(dot(-rd,n),0.0,1.0),3.0)*vec3(0.6,0.7,1.0)*0.2;\n    col += 0.1*rs*vec3(0.5,0.8,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 iMouseN = iMouse.xy / iResolution.xy;\n    iMouseN = iMouseN*2.0 -1.0;\n    iMouseN.x*=iResolution.x/iResolution.y;\n    \n    float xLimit = iMouse.z > 0.5 ? iMouseN.x : 0.0;\n    float time = iTime * 2.0;;\n    vec3 ro = vec3(9.0*sin(0.2*time),3.0+sin(0.3*time),9.0*cos(0.2*time));\n    vec3 camt = vec3(0.0,0.0,0.0);\n    \n    float alpha = 0.2;\n    vec3 f = normalize(vec3(camt-ro));\n    vec3 rf = normalize(vec3(sin(alpha),cos(alpha),0.0));\n    vec3 r = normalize(cross(f,rf));\n    vec3 u = normalize(cross(r,f));\n    \n    vec3 rd = normalize(uv.x*r+uv.y*u+f*3.0);\n    \n    vec3 col = vec3(1.0,2.0,3.0);\n    float aa_d = uv.x < xLimit ? AA_DIST : 0.0;\n    \n    float t = 0.0;\n    float tmax = 15.0;\n    float lastd = 0.0;\n    float aa_factor = 1.0;\n    float idx;\n    bool pickColor = false;\n    for(int i = 0; i<256; ++i)\n    {\n        vec3 p = ro+rd*t;\n        \n        float newd = map(p,idx);\n        \n        if(newd < lastd)\n        {   \n            pickColor = true;\n        }\n        else if(newd <= aa_d)\n        {   \n            if(pickColor)\n            {\n                pickColor = false;\n                accumColor(col,shadeP(p,rd,idx),aa_factor);\n                aa_factor = clamp(aa_factor - smoothstep(aa_d,0.0,lastd),0.0,1.0);\n            }\n        }\n        lastd = newd;\n        \n        if( newd < RM_DIST || t >= tmax) break;\n        \n        t+=newd;\n    }\n    \n    \n    vec3 bckcol = vec3(0.0,0.0,0.0);\n    \n    if(t<tmax)\n    {\n        vec3 p = ro + rd * t;\n        float parm = uv.x < xLimit ? smoothstep(0.985,1.0,t/tmax) : 0.0;\n        vec3 scol = mix(shadeP(p,rd,idx),bckcol, parm );\n        accumColor(col,scol,aa_factor);\n    }\n    else\n    {\n        accumColor(col,bckcol,aa_factor);\n    }\n    \n    \n    float w = 0.004;\n    float l = step(xLimit+w,uv.x) + 1.0-step(xLimit-w,uv.x);\n    col*=l;\n    \n    col = pow(col,vec3(1.0/2.2));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xty3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 111, 111, 141], [143, 143, 190, 190, 239], [241, 241, 285, 285, 341], [343, 343, 392, 392, 482], [484, 484, 519, 519, 868], [870, 870, 891, 891, 1189], [1191, 1191, 1259, 1259, 1461], [1463, 1463, 1502, 1502, 1824], [1826, 1826, 1873, 1873, 2357], [2359, 2359, 2416, 2416, 4430]], "test": "valid"}
{"id": "XtySD3", "name": "Slinky Spiro Graph", "author": "Linx", "description": "Rings attached to other rings that are rotating slightly offset from each other. creates a Spiro Graph like design then whiplashes out like a slinky at the end of the pattern.", "tags": ["circle"], "likes": 1, "viewed": 97, "published": "Public", "date": "1486097761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //pattern center point\n    vec2 center = vec2(iResolution/2.0);\n    \n    //postion of inside and outside rings to set size and thickness \n    float outRadius = 91.0;\n    float inRadius = 90.0;\n    \n    //multiplier for rotation offset\n    float spinMulti = 80.0;\n    \n    //number of rings in chain\n\tconst int ringCount = 20;\n    \n    //multiplier for pattern speed\n    float timeMulti = 0.50;\n    \n    //offsets for distorting x and y postions of pattern\n    int xOffset = 5;\n    int yOffset = 10;\n    \n    vec2 rings[ringCount];\n    \n    rings[0] = center;\n    \n    for(int x = 0;x<ringCount;x++){\n        \n        rings[x] = rings[x-1] + vec2( \n            sin(iTime * float(x + xOffset) * timeMulti) * spinMulti,\n            cos(iTime * float(x + yOffset) * timeMulti) * spinMulti\n        );\n        \n        if(distance(fragCoord,rings[x-1]) < outRadius && distance(fragCoord,rings[x-1]) > inRadius){\n            \n            if(distance(rings[x],fragCoord) > 50.0 ){\n                fragColor = vec4(0,0,1,1);\n            }\n            else{\n            \tfragColor = vec4(1,0.5,0,1);\n            }\n            \n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 84, 1193]], "test": "error"}
{"id": "XtyXW3", "name": "Radio Mickeys", "author": "shadowlion", "description": "My first shader (Class assignment - VFS PG07)", "tags": ["2d"], "likes": 1, "viewed": 113, "published": "Public", "date": "1486072031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// My frist Shadertoy Shader\n\n\nfloat MakeCircle(vec2 uv, vec2 pos, float rad, float edgeblur)\n {\n     float dist = length(uv-pos); // lenght from center\n     \n     // using smoothstep to make circles and nice edges\n     float c = smoothstep(rad,rad-edgeblur, dist); \n     \n     return c;\n }\n\nfloat mickey (vec2 uv, vec2 pos)\n {\n     float mask = MakeCircle(uv, vec2(pos.x, pos.y), .15, 0.01);   // Face\n     mask += MakeCircle(uv, vec2(.12 + pos.x, .15 + pos.y), .075, .01);  // Ears\n     mask += MakeCircle(uv, vec2(-.12 + pos.x,.15 + pos.y), .075, .01);  // Ears\n     \n     float mouth = .0;\n     mouth += MakeCircle(uv, vec2(pos.x, pos.y), .1, .01);\n     mouth -= MakeCircle(uv, vec2(pos.x, 0.03 + pos.y), .1, .01);\n     mouth -= MakeCircle(uv, vec2(-.095 + pos.x, -.005 + pos.y), .04, .01);\n     mouth -= MakeCircle(uv, vec2(.095 + pos.x, -.005 + pos.y), .04, .01);\n     mask -= mouth;\n     \n     float eyes = .0;\n     eyes += MakeCircle(uv, vec2(-.08 + pos.x, .05 + pos.y), .04, .01);\n     eyes += MakeCircle(uv, vec2(.08 + pos.x, .05 + pos.y), .04, .01);\n     mask -= eyes;\n     \n     return mask;\n }\n\nfloat mickeyGrid(vec2 uv, vec2 pos)\n {\n     // I think this could be done with a XOR loop...\n     float mask =0.0;\n     mask += mickey(uv, vec2(pos.x, pos.y));\n     mask += mickey(uv, vec2(pos.x, 0.5 + pos.y));\n     mask += mickey(uv, vec2(pos.x, 1.0 + pos.y));\n     mask += mickey(uv, vec2(pos.x, -0.5 + pos.y));\n     mask += mickey(uv, vec2(pos.x, -1.0 + pos.y));\n     mask += mickey(uv, vec2(pos.x + 0.5, pos.y));\n     mask += mickey(uv, vec2(pos.x + 1.0, pos.y));\n     mask += mickey(uv, vec2(pos.x + -0.5, pos.y));\n     mask += mickey(uv, vec2(pos.x + -1.0, pos.y));\n     mask += mickey(uv, vec2(pos.x + 0.5, pos.y + 0.5));\n     mask += mickey(uv, vec2(pos.x + 1.0, pos.y + 0.5));\n     mask += mickey(uv, vec2(pos.x + 0.5, pos.y + 1.0));\n     mask += mickey(uv, vec2(pos.x + 1.0, pos.y + 1.0));\n     mask += mickey(uv, vec2(pos.x + 0.5, pos.y + -0.5));\n     mask += mickey(uv, vec2(pos.x + 0.5, pos.y + -1.0));\n     mask += mickey(uv, vec2(pos.x + -0.5, pos.y + 0.5));\n     mask += mickey(uv, vec2(pos.x + -1.0, pos.y + 0.5));\n     mask += mickey(uv, vec2(pos.x + -1.0, pos.y + -0.5));\n     mask += mickey(uv, vec2(pos.x + -0.5, pos.y + -1.0));\n     mask += mickey(uv, vec2(pos.x + -0.5, pos.y + -0.5));\n     mask += mickey(uv, vec2(pos.x + -1.0, pos.y + -1.0));\n     \n     return mask;\n }\n\nfloat funkyColorCircles(vec2 uv, float rings, float ringThickness, float speed)\n {\n     vec2 r = uv * rings; // ++ == more rings\n     \n     float v1 = sin(r.x + iTime) * 2.0;   // Color fade Grid x\n     float v2 = cos(r.y + iTime);    // Color fade Grid y\n     float v3 = sin(r.x + r.y + iTime);  // Color fade Grid xy mod\n     \n     // makes reducing circles (over time)\n     float v4 = tan(sqrt(r.x * r.x + r.y * r.y) + iTime * speed) * ringThickness; \n     \n     return v1 + v2 + v3 + v4; \n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n  vec2 uv = fragCoord.xy / iResolution.xy; // Screen Coords\n     \n     uv -= 0.5; // Pos Middle of screen\n     uv.x *= iResolution.x/iResolution.y; // fix X Stretch\n\n    float rot = radians(iTime * 35.0); // Rotation Speed (using time)\n     float move = sin(iTime) * 0.4; // Simple move back and forth on sin wave (using time)\n     \n     uv = mat2(cos(rot), -sin(rot), sin(rot), cos(rot)) * uv; // uv rotation\n\n    // Background Color fade mix on sin wave (using time)\n     vec3 color = mix(vec3(1., 1., 1.), vec3(0., 1., 1.), uv.y ) * sin(iTime);\n\n    color += funkyColorCircles(uv, 12.0,  0.25, 4.0) * move; // Added move just because...\n     \n     color +=  vec3(1., 1., 1.) * mickeyGrid(uv, vec2(move,move)); // Add Mickey Color Mask\n     \n     fragColor = vec4(color, 1.0); // output to screen\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 96, 96, 290], [292, 292, 327, 327, 1106], [1108, 1108, 1146, 1200, 2402], [2404, 2404, 2486, 2486, 2899], [2901, 2901, 2959, 2959, 3761]], "test": "valid"}
