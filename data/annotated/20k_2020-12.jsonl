{"id": "3dfcR8", "name": "parametric_v0007", "author": "darkczar", "description": "parametric curves again, whay can't I save more versions?  is this working?", "tags": ["learning"], "likes": 1, "viewed": 187, "date": "1608840321", "time_retrieved": "2024-06-20T20:25:18.817118", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<1200;i++)\n    {\n        di = float(i)*.04;\n        curve_p.x = -.1*sin(.4*iTime)+.05*float(di)*sin(float(di)+.2*iTime);\n        curve_p.y = -.1*cos(.4*iTime)+.05*float(di)*cos(float(di)+.2*iTime);\n        d = min(d, length(p-curve_p));\n  \n    }\n\n    vec3 col = vec3(2.*d*d,.002 + .25*sin(.001*d*d+.1*length(p)), abs(.5+.13*sin(iTime*.8) - pow(d,.25)));\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dGfDV", "name": "Sphere and Plane", "author": "Suika", "description": "a", "tags": ["a"], "likes": 1, "viewed": 29, "date": "1607952737", "time_retrieved": "2024-06-20T20:25:18.821128", "image_code": "struct Ray\n{\n    vec3 position;\n    vec3 direction;\n};\n\nstruct Intersection\n{\n    bool hit;\n    vec3 position;\n    vec3 color;\n    float k;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    vec3 color;\n    float radius;\n};\n\nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Light\n{\n    vec3 direction;\n};\n\nIntersection I_Sphere(Ray ray, Sphere sphere, Light light)\n{\n    vec3 rs = ray.position - sphere.position;\n    float drs = dot(ray.direction, rs);\n    float dd = dot(ray.direction, ray.direction);\n    float D4 = drs*drs - dd*(dot(rs, rs) - sphere.radius*sphere.radius);\n    Intersection i;\n    i.color = vec3(0.0);\n    float k = (-drs-sqrt(D4))/dd;\n    i.hit = k >= 0.0;\n    i.position = ray.position + k*ray.direction;\n    i.k = k;\n    vec3 normal = normalize(i.position - sphere.position);\n    i.color = sphere.color * clamp(-dot(normal, light.direction), 0.0, 1.0);\n    return i;\n}\n\nIntersection I_Plane(Ray ray, Sphere sphere, Plane plane, Light light)\n{\n    float dn = dot(ray.direction, plane.normal);\n    Intersection i;\n    i.hit = false;\n    i.color = vec3(0.0);\n    if (dn != 0.0)\n    {\n        float k = dot(plane.position - ray.position, plane.normal)/dn;\n        i.hit = k >= 0.0;\n        i.position = ray.position + k*ray.direction;\n        i.k = k;\n        int mx = int(mod(i.position.x, 2.0) < 1.0);\n        int mz = int(mod(i.position.z, 2.0) < 1.0);\n        if ((mx + mz) % 2 == 1) i.color = vec3(0.5);\n        else                    i.color = vec3(0.25);\n        Ray test;\n        test.position = i.position;\n        test.direction = -light.direction;\n        Intersection shadow = I_Sphere(test, sphere, light);\n        if (shadow.hit) i.color -= vec3(0.20);\n    }\n    return i;\n}\n\nIntersection I_Scene(Ray ray, Sphere sphere, Plane plane, Light light)\n{\n    Intersection i[2];\n    i[0] = I_Plane(ray, sphere, plane, light);\n    i[1] = I_Sphere(ray, sphere, light);\n    \n    Intersection result;\n    result.hit = false;\n    result.color = vec3(0.0);\n    result.k = 1000000000.0;\n    for (int n = 0; n < 2; ++n)\n    {\n        if (i[n].hit)\n        {\n            if (i[n].k < result.k)\n            {\n                result = i[n];\n            }\n        }\n    }\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    Ray eye;\n    eye.position = vec3(0.0, 0.0, -1.0);\n    eye.direction = normalize(vec3(uv.x, uv.y, 0.0) - eye.position);\n    Light light;\n    light.direction = normalize(vec3(1.0, -1.0, 1.0));\n    Plane plane;\n    plane.position = vec3(0.0, -1.0, 0.0);\n    plane.normal = normalize(vec3(0.0, 1.0, 0.0));\n    Sphere sphere;\n    sphere.position = vec3(0.0, sin(iTime), 2.0);\n    sphere.color = vec3(1.0);\n    sphere.radius = 1.0;\n    Intersection i;\n    i = I_Scene(eye, sphere, plane, light);\n    fragColor = vec4(i.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dGfDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKBDh", "name": "Cubes?", "author": "sebost1234", "description": "Voronoi with maximum metric", "tags": ["voronoi"], "likes": 1, "viewed": 46, "date": "1607015832", "time_retrieved": "2024-06-20T20:25:18.821128", "image_code": "#define pointcount 5\n\nvec3 getPoint(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(0,0,0);\n    case 1:\n        return vec3(cos(iTime*3.+1.),sin(iTime+1.),cos(iTime));\n    case 2:\n        return vec3(cos(iTime+2.),sin(iTime+2.),sin(iTime+2.));\n    case 3:\n        return vec3(cos(iTime+3.),sin(iTime+3.),cos(iTime+3.));\n    case 4:\n        return vec3(cos(iTime*2.+4.),sin(iTime+5.),cos(iTime-2.));\n    } \n}\n\nvec3 getPointColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(1.0, 1.0, 0.0);\n    case 1:\n        return vec3(0.0, 1.0, 1.0);\n    case 2:\n        return vec3(1.0, 0.0, 0.0);\n    case 3:\n        return vec3(0.0, 1.0, 0.0);\n    case 4:\n        return vec3(0.0, 0.0, 1.0);\n    } \n}\n\n\nfloat dist(vec3 pos1, vec3 pos2)\n{\n    vec3 diff = abs(pos2-pos1);\n\t//return diff.x*diff.x+diff.y*diff.y+diff.z*diff.z;\n    //return min(min(diff.x, diff.y), diff.z);\n    return max(max(diff.x, diff.y), diff.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = vec3((fragCoord/iResolution.xy-vec2(0.5,0.5))*4., sin(iTime));\n\n    int bestIndex = 0;\n    float shortestDist = dist(uv, getPoint(0));\n    for(int i = 1;i<pointcount;i++)\n    {\n    \tfloat dist = dist(uv, getPoint(i));\n        if(dist<shortestDist)\n        {\n        \tshortestDist = dist;\n            bestIndex = i;\n        }\n    }\n    vec3 pointColor = getPointColor(bestIndex);\n    vec3 color = min(pointColor/(shortestDist), pointColor);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKBDV", "name": "Time varying alpha for dither", "author": "kagtag", "description": "From UE4 function ClipLODTransition", "tags": ["effect"], "likes": 1, "viewed": 203, "date": "1607999497", "time_retrieved": "2024-06-20T20:25:18.821128", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float DitherFactor = abs(sin(iTime*1.0));\n    \n    if (abs(DitherFactor) > .001)\n\t{\n\t\tfloat RandCos = cos(dot(floor(fragCoord), vec2(347.83451793,3343.28371963)));\n\t\tfloat RandomVal = fract(RandCos * 1000.0);\n\t\tfloat RetVal = 0.0; //(DitherFactor < 0.0) ? \n        if(DitherFactor < RandomVal)\n        {\n            RetVal = 1.0;\n        }\n\n        fragColor = vec4(RetVal);\n\t}\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKBWW", "name": "Hexagonal Tiles Saw Blades", "author": "gelami", "description": " Not really hexagonal tiling, but triangle tiling made to look like a hexagonal one\n Try fiddling with the constants, really makes some cool patterns :D", "tags": ["triangle", "hexagon", "tiling", "hex", "tiles"], "likes": 9, "viewed": 234, "date": "1607147976", "time_retrieved": "2024-06-20T20:25:19.136240", "image_code": "\n// Hexagon Tiles Saw Blades Pattern\n// https://www.shadertoy.com/view/4dX3zl\n\n/*\n * Originally made in Blender nodes for a #nodegolf challenge:\n * https://twitter.com/GelamiSalami/status/1335114160535871490\n *\n * Not really hexagonal tiling, but triangle tiling made to look like a hexagonal one\n * Try fiddling with the constants, really makes some cool patterns!\n *\n * Codegolfed version: https://www.shadertoy.com/view/3sGBWm\n */\n\n// Thanks FabriceNeyret2!\n#define S(v) smoothstep(1.5*scale/iResolution.y, 0., v)    \n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nconst float scale = 4.;\nconst float angleOffset = .25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 pos = uv * scale;\n    \n    vec2 md = vec2(sqrt(3.), 1.);\n    vec2 mn = md*.5;\n    \n    vec2 ta = mod(pos, md)-mn;\n    vec2 tb = mod(pos-mn, md)-mn;\n    \n    vec2 tri = dot(abs(ta), mn.yx) < sqrt(3.)/4. ? ta : tb;\n    \n    tri.x = abs(tri.x)-sqrt(3.)/6.;\n    \n    float angle = 1.-(atan(tri.y, tri.x)+pi)*(1./tau);\n    float len = length(tri);\n    \n    //float sides = 3.; // Regular hexagonal tiling\n\tfloat sides = 3.+smoothstep(0.,1.,sin(tau*(iTime+3.)/4.)*.5+.5)*9.;\n    \n    float a = angle-floor(sides*angle+angleOffset)/sides;\n    float c = cos(a*tau)*len;\n    \n    float lin = S(c - .26);\n    float lout = 1.-S(c - .08);\n    \n    vec3 col = vec3(lin*lout);\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKBzd", "name": "Simple Rectangle with color", "author": "TheR", "description": "First step to understand shadertoy...", "tags": ["2d"], "likes": 2, "viewed": 42, "date": "1607747086", "time_retrieved": "2024-06-20T20:25:19.305990", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     \n     uv -= .5; // -0.5 <> 0.5\n     uv.x *= iResolution.x/iResolution.y; \n     float l = abs(uv.x);\n     float b = abs(uv.y);\n     \n     vec3 c;\n     \n     if(l <.4 && b <.2) \n         c = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     else \n         c = vec3(1.);\n     \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKfDc", "name": "Noisy rotating squares", "author": "AI", "description": "Move the mouse horizontally to scale up the squares.\nYou may change constant paramters of the program to generate other variations ", "tags": ["noise", "square", "pattern", "rotation", "generativeart", "creativecoding"], "likes": 2, "viewed": 169, "date": "1608136821", "time_retrieved": "2024-06-20T20:25:19.639371", "image_code": "#define PI 3.14159265358979323846\n\n// 2D rotation with pivot point (.5,.5)\nvec2 rotate2D(vec2 st, float angle){\n    st -= 0.5;\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += 0.5;\n    return st;\n}\n// a square with given size as side \nfloat square(vec2 st, vec2 side){\n    vec2 border = vec2(0.5)-side*0.5;\n    vec2 pq = smoothstep(border,border+.01,st);\n    pq *= smoothstep(border,border+.01,vec2(1.0)-st);\n    return pq.x*pq.y;\n}\n// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    vec3 color = vec3(0.0);\n    float scale=6.-4.*iMouse.x/iResolution.x;\n    // Divide the space into cells\n\tvec2 ixy=.5+floor(scale*uv);\n    uv = fract(scale*uv);\n    // Using a 2x2 matrix to rotate with given angle\n    uv = rotate2D(uv,.5*PI*sin((ixy.x+ixy.y)*iTime));\n \tfloat nr=bilinearNoise(uv);\n    // Draw a noisy square\n    color =vec3(1.*nr)+vec3(square(uv,vec2(0.7)));\n    color*=vec3(1.,.5+.5*sin(40.*nr+ixy.x*iTime), .5+.5*sin(40.*nr+ixy.y*iTime));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKfRw", "name": "Simple Boze", "author": "kaiware007", "description": "Simple Boze", "tags": ["raymarching"], "likes": 3, "viewed": 57, "date": "1606823978", "time_retrieved": "2024-06-20T20:25:19.645439", "image_code": "// ------------------------------------------------------------------------------------\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n#define M_PI 3.1415926\n#define RAD90 (M_PI * 0.5)\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    int count;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \t0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \t0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \t0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \t0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \t0, true))\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Basic Distance function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nsurface opS( surface d1, surface d2 )\n{\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    return surface(d, albedo, d1.count, true);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n    \n    float ms = sin(iTime) * 0.5 + 0.5;\n\n    // boze\n    surface boze = sdBoze(p, vec3(1), ms);\n    \n    result = opU(result, boze);\n    \n    return result;\n}\n\nvec3 norm(in vec3 position) {\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n\n        t += d;\n        pos = origin + direction * t;\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n        \n    if(hit.isHit)\n    {\n        // Lighting\n        vec3 normal = norm(pos);\n\n        vec3 lightDir = normalize(vec3(cos(iTime), 1, sin(iTime)));\n\t\tvec3 lightColor = vec3(1.5);\n        \n        float NoL = saturate(dot(normal, lightDir));\n        \n        vec3 ambientColor = vec3(0.1);\n        \n        hit.albedo.rgb *= NoL * lightColor +  ambientColor;\n    }\n    \n    if(d <= EPS){\n        hit.isHit = true;\n        return hit;\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n    }\n}\n    \nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = vec3(0.3);\n    \n    col = mat.isHit ? mat.albedo.rgb : sky;\n    \n    return col;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0.05, 0.5);\n    vec3 ta = vec3(0, 0.05, 0);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKfWm", "name": "Coloring Razor Deem, a fork", "author": "UrbanClubProfessional", "description": "Remix of epicabsol's Rainbow Laser Beam: [url]https://www.shadertoy.com/view/XtBXW3[/url]", "tags": ["2d", "remix", "glitch", "beam", "rainbow", "fork", "weird", "error", "razor"], "likes": 1, "viewed": 212, "date": "1607297069", "time_retrieved": "2024-06-20T20:25:19.845457", "image_code": "vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\n{\n    float glow = 0.07 * iResolution.y;\n    float twopi = 7.28318530718;\n    float curve = 2.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 200.0 / iResolution.x * 2000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.35 * vscale + iResolution.y / 3.0));\n    float i = clamp(curve, 0.1, 2.0);\n    i += clamp((glow + curve) / glow, 0.1, 2.0) * 0.5 ;\n    return i * color;\n}\n\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\n{\n    float theta = atan(iResolution.y / 3.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.23 * iResolution.x);\n\tfloat len = iResolution.y * (20.0 + sin(theta * 30.0 + float(int(iTime * 30.0)) * -45.0)) / 21.0;\n    float d = max(-0.7, 2.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 3.0) + pow(abs(iResolution.y / 3.0 - ((fragCoord.y - iResolution.y / 3.0) * 5.0 + iResolution.y / 3.0)), 3.0)) / len));\n    return vec3(d * (2.0 + sin(theta * 20.0 + floor(iTime * 30.0) * 20.77) * 0.6), d * (2.0 + -cos(theta * 9.0 - floor(iTime * 30.0) * 9.77) * 0.6), d * (2.0 + -sin(theta * 7.0 - floor(iTime * 30.0) * 234.77) * 0.6));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timescale = 5.0;\n\tvec3 c = vec3(-1, -1, -1);\n    c += Strand(fragCoord, vec3(2.0, 1, 1), 0.8934 + 2.0 + sin(iTime) * 40.0, 2.0, 0.26, 20.0 * timescale);\n    c += Strand(fragCoord, vec3(0.1, 2.0, 0.1), 0.745 + 2.0 + sin(iTime) * 40.0, 2.5, 0.3, 20.3 * timescale);\n    c += Strand(fragCoord, vec3(0.1, 0.1, 2.0), 0.835 + 2.0 + sin(iTime) * 40.0, 2.3, 0.29, 9.0 * timescale);\n    c += Strand(fragCoord, vec3(2.0, 2.0, 0.1), 1.0245 + 2.0 + sin(iTime) * 40.0, 2.6, 0.24, 22.0 * timescale);\n    c += Strand(fragCoord, vec3(0.1, 2.0, 2.0), 0.8234 + 2.0 + sin(iTime) * 40.0, 2.9, 0.33, 24.0 * timescale);\n    c += Strand(fragCoord, vec3(2.0, 0.1, 2.0), 0.94525 + 2.0 + sin(iTime) * 40.0, 2.2, 0.28, 10.0 * timescale);\n    c += clamp(Muzzle(fragCoord, timescale), 0.1, 2.0);\n\tfragColor = vec4(c.r, c.g, c.b, 2.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dKfzG", "name": "Naive Perlin Noise", "author": "Harrm", "description": "Naive impl of perlin noise", "tags": ["noise", "perlin"], "likes": 1, "viewed": 52, "date": "1607425923", "time_retrieved": "2024-06-20T20:25:19.845457", "image_code": "\nvec2 randomGradient(int ix, int iy, float seed) {\n    float x = float(ix);\n    float y = float(iy);\n    float random = seed + 2920.f * sin(x * 21942.f + y * 171324.f + 8912.f) * cos(x * 23157.f * y * 217832.f + 9758.f);\n    return vec2(cos(random), sin(random));\n}\n\nfloat interpolate(float a0, float a1, float w) {\n    if (0.0 > w) return a0;\n    if (1.0 < w) return a1;\n    float diff = a1 - a0;\n    return a0 + diff * smoothstep(a0, a1, a0 + diff * w);\n}\n\nfloat get_dot(ivec2 cell_loc, vec2 frag_coord, vec2 grid_size, float seed) {\n\tvec2 cell_size = iResolution.xy / grid_size;\n\n    vec2 grad = randomGradient(cell_loc.x, cell_loc.y, seed);\n    vec2 offset = (frag_coord - vec2(cell_loc) * cell_size) / cell_size;\n    float dot_product = (dot(grad, offset) + 1.0) / 2.0;\n\treturn dot_product;\n}\n\nvec4 get_perlin(float grid_width, vec2 frag_coord) {\n    float grid_height = iResolution.y * grid_width / iResolution.x;\n    vec2 grid_size = vec2(grid_width, grid_height);\n\tvec2 cell_size = iResolution.xy / grid_size;\n    ivec2 cell_loc = ivec2(floor(frag_coord / cell_size));\n\n    float seed = float(iFrame) / 20.0;\n    \n\tfloat dots[] = float[](\n    \tget_dot(cell_loc, frag_coord, grid_size, seed),\n    \tget_dot(cell_loc + ivec2(1, 0), frag_coord, grid_size, seed),\n    \tget_dot(cell_loc + ivec2(0, 1), frag_coord, grid_size, seed),\n    \tget_dot(cell_loc + ivec2(1, 1), frag_coord, grid_size, seed)\n    );\n    \n    vec2 weight = frag_coord / cell_size - vec2(cell_loc);\n    \n    float diff1 = (dots[1] - dots[0]);\n    float diff2 = (dots[3] - dots[2]);\n    float i1 = interpolate(dots[0], dots[1], weight.x);\n    float i2 = interpolate(dots[2], dots[3], weight.x);\n    float i = interpolate(i1, i2, weight.y);\n\treturn vec4(i, 0, 0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c1 = get_perlin(4.0, fragCoord);\n    vec4 c2 = get_perlin(8.0, fragCoord);\n    vec4 c3 = get_perlin(16.0, fragCoord);\n    vec4 c4 = get_perlin(32.0, fragCoord);\n    fragColor = (c1 + c2 / 2.0 + c3 / 4.0 + c4 / 16.0) / (1.0 + 0.5 + 0.25 + 0.125);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVBDh", "name": "Tumbling alternating squares", "author": "A_Toaster", "description": "Based on https://www.shadertoy.com/view/wdyfW1", "tags": ["checkerboard", "squares", "generativeart"], "likes": 13, "viewed": 245, "date": "1607017673", "time_retrieved": "2024-06-20T20:25:20.118170", "image_code": "uniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 st, float angle){\n    st -= 0.5;\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += 0.5;\n    return st;\n}\n\nvec2 tile(vec2 st, float zoom,float rotD){\n    st *= zoom;\n     if(rotD==1.) {\n        st.x+=.5;\n        st.y+=.5;\n     }\n    return fract(st);\n}\n\nfloat square(vec2 st, vec2 side){\n    vec2 border = vec2(0.5)-side*0.5;\n    vec2 pq = smoothstep(border,border+.01,st);\n    pq *= smoothstep(border,border+.01,vec2(1.0)-st);\n    return pq.x*pq.y;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.y;\n    float color;\n    float Nsquares=5.;\n    float rotDirection=0.;\n\tfloat warpedTime = iTime * 0.5 + uv.x + uv.y * 0.5;\n    rotDirection=step(0.,sin(warpedTime * 2.0));\n    \n    uv = tile(uv,Nsquares,rotDirection);\n    uv = rotate2D(uv,PI/4.0-warpedTime);\n    if (rotDirection==1.)\n        color = 1.0-square(uv,vec2(0.71));\n    else \n    color=square(uv,vec2(0.72));\n    fragColor = vec4(vec3(color),1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVBWD", "name": "Day idk", "author": "jeyko", "description": "Port from glsl. It's a bit broken for some reason, not looking as intended. Going to fix later", "tags": ["mdtmjvm"], "likes": 4, "viewed": 192, "date": "1607163730", "time_retrieved": "2024-06-20T20:25:21.015339", "image_code": "\n\nfloat r11(float g){return fract(sin(g*3.223)*43.20);}\n\n// WRIGHTER HERE \n// I HAVE NO CLUE WHAT IM GONNA MAKE LOL\n\n#define rot(j) mat2(cos(j), sin(j), -sin(j),cos(j))\n#define pi acos(-1.)\n\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n  vec2 dir = normalize(b - a);\n  float slope = atan(dir.y,dir.x);\n  vec2 op = p;\n  p -= a;\n  p = p*rot(slope);\n  float d = length(p.y);\n  \n  d = max(d, -p.x);\n  \n  d = max(d, p.x - length(b-a)*0.3 );\n  return d;\n  }\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n  float T = iTime;\n  float tbetween = 6.;\n  float seg = floor(T/tbetween);\n  \n  vec3 col = vec3(0);\n  vec2 p = uv;\n  float d = 10e5;\n  float dir = floor(r11(seg)*8.)*pi/4.;\n  \n  \n  float id = seg;\n  \n  for (float chrab = 0.; chrab < 8. ; chrab ++){\n    \n    p = uv;\n    p += ( normalize(p)*.2*float(r11(id*241.512) < 0.5)+ chrab*0.04*sin(T))*1.7*length(p);\n    p *= rot(dir);\n    if (r11(id*1.2 + 0.5) < 0.5){\n      d = 10e5;\n    \n    }\n    //T = fGlobalTime;\n    for ( float i = 0.; i < 6. + r11(id)*10. ; i ++){\n      \n      T += (1.*r11(id) + 0.1);\n      float r = r11(id + i + 1.45463*i*id);\n      \n      \n      if (r < 0.05){\n        p *= rot((0.2 + T*0.0001*r11(id + 0.4) + (T)*0.4*r11(id + i))*pi);\n        //p = abs(p) - 0.5;\n      }\n      p -= (T - seg*tbetween)*0.01*(r11(id + i*0.04));\n        \n      for (float k = 0.; k < 7.*r11(id*42.231+i) + 4.; k++){\n        vec2 luv = p;\n        luv.y += r11(i*421.1*id);\n        \n        vec2 ap = p;\n        if (r11(id*1.4124) < 0.1){\n          ap *= rot(pi/2.);\n        }\n        d = xor(d,sdLine(ap,vec2(-0.4,0),vec2(0.4,0)) - .05*r11(id+i*0.042), 0.1*r11(id + i));\n        \n      }\n      if(r11(id*i + 0.4) < 0.4){\n        d = xor(d, abs(length(p) - r11(id + i)) - 3.6*r11(id*21.4 + i*float(r11(id)> 0.5)), .7*r11(id));\n      }\n      p.y -= r11(id*1.231)*0.1;\n      p.x -= r11(id*1.231 + i)*0.5*sign(r11(id + i*4.)*2. - 1.);\n    \n      if (r11(id) > 0.7){\n        d = xor(d,p.y,0.1);\n      }\n      \n      if (r11(id + 0.24) < 0.1){\n        d = xor(d,p.x,0.4);\n      }\n    \n      \n    }\n    \n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + e))\n    float coco = smoothstep(0.004,0.,d);\n    \n    if(r11(id*6.02351) > 0.5){\n    \n    //col += pal(0.5,0.5);\n      col += coco*pal(0.5,0.5,vec3(4.7,1.4,1.4),1. + vec3(sin(T*0.24),cos(T*0.1),sin(T*0.5)),id + T*0.1 + chrab*0.1);\n    \n    } else {\n      col[int(mod(chrab,3.))] += coco;\n    }\n    \n  }\n  \n  if(r11(id*1.02351) > 0.5){\n    //col = 1- col;\n  } \n  \n  \n  \n  \n  col = pow(col,vec3(0.4545));\n\n   fragColor = vec4(col,1.0);\n\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVfDc", "name": "Decorated Christmas Spiral", "author": "sylvain69780", "description": "It's Christmas time for Math's lovers !\n[url=https://www.shadertoy.com/view/stB3WK]SDF for Archimedean Spiral[/url]", "tags": ["christmas", "spiral", "archimed"], "likes": 26, "viewed": 423, "date": "1608138201", "time_retrieved": "2024-06-20T20:25:23.094263", "image_code": "/*\n    Decorated Christmas Spiral\n    --------------------------\n\n    Happy Christmas to you all the great Shadertoy community !\n    \n    It seems that the archimedian spiral can be used as a distance field with coordinates\n    a quite neat way to create a repetition domain where you can put blinking balls and ribbons.\n\n    Spirals are commonly use in art, and we may find this figure frequently in the nature.\n    Of course there is several kinds of spirals. For example, the Logarithmic Spiral that IQ  \n    used in his awesome Snail shader and the ones built using arc of circles (multiple center spirals).\n\n    Regarding the Archimedean spiral (also known as the arithmetic spiral), the Shadertoy's user kibble\n    demonstrated a very neat way to get UV coordinates for a point on the screen, using it's polar \n    coordinates (θ,r). The u coordinates is calculated using the length to the center among the spiral, \n    and the v coordinate from the position of the point on the segment joining two consecutive turns\n    of the spiral.\n    \n    Related references:    \n\n    Nyarchimedes Spiral - kibble\n    https://www.shadertoy.com/view/lsS3WV\n    \n    Quick Lighting Tech - blackle \n    https://www.shadertoy.com/view/ttGfz1\n    \n    soft shadows in raymarched SDFs - IQ\n    http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    \n    outdoors lighting- IQ\n    https://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n    \n    Cubic Truchet Pattern - Shane\n    https://www.shadertoy.com/view/4lfcRl\n    \n*/\n\n// #define AA\n\n#define MAX_STEPS 256\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define TAU 6.283185\n\n#define S smoothstep\n#define T (iTime+10.0)\n#define PI 3.14159265\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdVerticalCapsule( vec3 p, float r, float h )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat braids(vec3 p,float l,out float id) {\n    p.yz*=Rot(p.x*3.14159*.5);\n    p.yz = abs(p.yz)-0.25; // 4 for the price of one\n    p.yz = (p.yz + vec2(p.z, -p.y))*sqrt(0.5); // Shortcut for 45-degrees rotation https://www.shadertoy.com/view/WsGyWR\n    vec2 sector=step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y; \n    p.yz = abs(p.yz)-0.05;\n    p.yz*=Rot(p.x*3.14159*4.0);\n    p.yz = abs(p.yz)-0.02;\n    float d = sdVerticalCapsule(p,0.02,l);\n    return(d);\n}\n\nfloat carvings(vec3 p,float l, out float id) {\n    p.x-=.03;\n    float n = round(l);\n    id = clamp(round(p.x*2.0),1.0,n*2.0-1.0);\n    p.x-=id*.5;\n    p.zy*=Rot(id*3.1415*.25); \n    return min(sdHexagram(p.xy,0.045),(sdBox(abs(p.xz)-0.033,vec2(0.022)+.006)));\n}\n\nfloat balls(vec3 p,float l, out float id) {\n    float rank = round(p.x);\n    p.yz*=Rot((rank+0.25)*3.14159*.5);\n    p.x -= clamp(rank,0.0,l);\n    vec2 sector=step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y; \n    float r = .05*(1.0+id*.2);\n    p.yz = abs(p.yz);\n    p.yz -= vec2(.25,.25);\n    id += 4.0*rank;\n    return length(p)-r;\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat decoratedStick(vec3 p,out float m,out float glowDist) {\n    float l = 40.0;   // lenght of the stick\n    float d = 1e10; // distance\n    // materials : 1.0=spiral 2.x=tubes 3.x=stars and squares 4.0=inside spiral 5.0 Balls\n    m = 1.0;    // materials\n    glowDist = 1e10;\n    float core = length(vec3(p.x-clamp(p.x,0.0,l),p.y,p.z));\n    float outer = core-.25;\n    float inner = core-.22;\n    // Stars and Littles windows carvings, change sign to have holes or bumps\n    float id;\n    float carvings = -carvings(p,l,id);\n    d = smax(outer,carvings,.025);\n    if ( inner    < d ) { d = inner    ; m = 4.0+id/1024.0 ; }\n    // Braids \n    float braids = braids(p,l,id);\n    if ( braids < d ) { d=braids ; m= 2.0 + id/1024.0 ; }; // packing the ID in the material\n    // Balls :-)\n    float balls = balls(p,l,id);\n    if ( balls < d ) { d=balls ; m= 5.0 + id/1024.0 ; }; // packing the ID in the material\n    // Some blinking\n    float blink=1.0-cos(5.0*id+2.0*T);\n    glowDist = balls+blink*.1; \n    return d; \n}\n\n// approximated !\nfloat arclength(float turn) {\n\tfloat d = turn * turn;\n\treturn d * PI;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Derived it myself, any comment welcome\n// SDF for Archimedean Spiral\n// https://www.shadertoy.com/view/stB3WK\nfloat spiralUV(vec2 p,float size,float spacing, float turnStart,float turnEnd, out vec2 uv) {        \n    // below we are computing the polar coordinates of the point p\n    float r = length(p)/(size+spacing); // radius\n    float a = atan(p.y, p.x); // angle\n\tfloat turn = (r - a/TAU) ;\n    // manage round and atan discontinuities, very neat way\n    float count = round(turn);\n    float d = 1e10;\n    float position = count + a/TAU - 1.0;\n    //  manages the case when the spiral is opened\n    if ( turnStart <= turnEnd || fract(position-turnStart) <= fract(turnEnd-turnStart) ) {\n        // distance in each turn\n        float e = clamp(position,turnStart,turnEnd);          \n        float stp = floor(position - e );\n        d = abs(turn - count + stp)*(size+spacing) -.5*size;\n    }\n     // start border \n    {\n        vec2 rad = vec2(cos(turnStart*TAU), sin(turnStart*TAU));\n        vec2 a = rad * ( (size+spacing) * (turnStart+.5) +spacing*.5 ) ;\n        vec2 b = rad * ( (size+spacing) * (turnStart+.5) +size + spacing*.5 );\n        float dStart = sdSegment(p,a,b) ;\n        d = d > 0.0 ? min(d,dStart) : max(d,-dStart);        \n    }\n     // end border\n    {\n        turnEnd++;\n        vec2 rad = vec2(cos(turnEnd*TAU), sin(turnEnd*TAU));\n        vec2 a = rad * ( (size+spacing) * (turnEnd+.5) +spacing*.5 ) ;\n        vec2 b = rad * ( (size+spacing) * (turnEnd+.5) +size + spacing*.5 );\n        float dEnd = sdSegment(p,a,b) ;\n        d = d > 0.0 ? min(d,dEnd) : max(d,-dEnd);        \n    }\n    // approximated UV calculations\n    uv.x = arclength(position+1.0)*(size+spacing)/size-arclength(turnStart+1.0)*(size+spacing)/size;\n    uv.y = (turn - count)*(size+spacing)/size;\n\treturn d;\n}\n\nfloat GetDist(vec3 p,out float objID, out float glowDist, out float dC ) {\n    p.xz *= Rot(T*.1);\n    p.xy *= Rot(-sin(T*.1)*.5);\n    glowDist = 1e10;\n    objID = 1.0;\n    float extands = S(0.8,-0.8,cos(T*.1));\n    extands*= extands;\n    float spacing = 0.7*extands,\n        tmin = 0.0,\n        tmax = 2.0;\n    vec2 uv;\n    float d = 1e10;\n    dC = abs(p.y)-0.5;\n    if ( dC < SURF_DIST ) {\n        float dSpiral = spiralUV(p.xz,1.0,spacing,tmin,tmax,uv);\n        dC = abs(dSpiral);\n        if ( dSpiral < SURF_DIST-.02 ) {\n            vec3 q = vec3(uv.x, p.y, uv.y ); // spiral UV space\n            d = decoratedStick(q-vec3(.5,0.,0.),objID,glowDist);\n        } \n    }\n    return d;\n}\n\nfloat GetDist(vec3 p,out float glowDist,out float dC) {\n    float objID;\n    return GetDist(p,objID,glowDist,dC);\n}\n\nfloat GetDist(vec3 p) {\n    float glowDist,objID,dC;\n    return GetDist(p,objID,glowDist,dC);\n}\n\nfloat GetMat(vec3 p) {\n    float glowDist,objID,dC;\n    float d = GetDist(p,objID,glowDist,dC);\n    return objID;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd,out float glowCumul) {\n\tfloat dO=0.0;  \n    float dS;\n    float dC; // distance to cell boundaries\n    float glowDist;\n    glowCumul=0.0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p,glowDist,dC);\n        dO += min(dS*.9,dC+0.05); \n        float at = 1.0 / (1. + pow(glowDist*20.,3.0) );\n        glowCumul+=at;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col = vec3(0);    \n    vec3 tcol = vec3(0);\n    vec3 target = vec3(0,-0.7,0);\n    vec3 ro = vec3(0, 0.7, 3.3);\n    vec2 m = iMouse.xy / iResolution.xy-.5;\n    float time=mod(T+10.0,20.0);\n    float atime=1.0;\n    if ( iMouse.x > 0.0 ) {\n        target = vec3(0,-0.8,0.0);\n        ro = vec3(0, 0.5, 2.0)*2.4;\n        ro.yz *= Rot(m.y*3.14*.5);\n        ro.xz *= Rot(-m.x*6.2831*2.0);\n    } else { \n        ro.y+=S(0.0,10.0,time)-S(10.0,20.0,time);\n//        ro.xz *= Rot(T*.2);\n     }\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    \n    vec3 rd = GetRayDir(uv, ro, target, 1.);\n    vec3 bgcol = vec3(0.10,0.28,0.10)*(1.-abs(rd.y)); // fast gradient - \"the sky will be blue\" - https://youtu.be/Cfe5UQ-1L9Q?t=2795\n    float glowCumul;\n    float d = RayMarch(ro, rd,glowCumul);\n    if(d<MAX_DIST) {\n    \tvec3 pos = ro + rd * d;\n        float m = GetMat(pos);\n    \tvec3 nor = GetNormal(pos);\n        vec3 ref = reflect(rd, nor); \n        vec3 c=vec3(0);\n        float ks = 1.0; \n        float occ = calcOcclusion( pos, nor );\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos+0.01*nor, sun_lig, 0.01, 0.5 );\n        float sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\t\tvec3 lin = vec3(0.0);\n        // materials  \n        if ( m >=5.0 ) {            // Balls\n            float ballID = fract(m)*1024.0;\n            c = fract(ballID*.5) > 0.0 ? vec3(1.0,0.1,0.01) : vec3(0.6,0.6,0.2)*.5;\n            float directionality=0.75;\n            float sharpness=0.5;\n            float spec = length(sin(ref * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            float blink=1.0+cos(5.0*ballID+2.0*T);\n            lin = vec3(blink)*3.3;\n            c = spec * c;  \n        } else if ( m >=4.0 ) {     // bright inside spiral\n            float starID=fract(m)*1024.0;\n            float blink=1.0+cos(5.0*starID+3.15*T);\n            c = vec3(0.7,0.7,0.1)*.3;\n            lin = vec3(blink)*3.0;\n            float directionality=0.75;\n            float sharpness=0.5;\n            float spec = length(sin(ref * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            c = spec * c;  \n        } else if ( m >=3.0 ) {    \n            // Material Not used c = vec3(0.3,0.1,0.01);\n        } else if ( m >=2.0 ) {     // tubes \n            float ropeID=fract(m)*1024.0;\n            c = ropeID>2.0 ? vec3(0.5,0.5,0.01)*.25 : vec3(0.01,0.6,0.01)*.1;\n        } else if ( m >=1.0 ) {     \n            // spiral core\n            // I think I'am not making good use of here of backle metal effect\n            // https://www.shadertoy.com/view/tlscDB\n            c = vec3(0.28,0.2,0.02);\n            float directionality=0.75;\n            float sharpness=0.7;\n            float spec = length(sin(ref * 4.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            c =  spec * c * (.3+.7*sun_sha);  \n        }\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha*.5;\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ*2.0;\n        lin += bou_dif*vec3(0.40,1.00,0.40)*occ*2.0;\n\t\tcol = c*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        // fog\n        float fog=S(12.0,5.0,d);\n        col = mix(bgcol, col, fog);\n        \n    } else {\n        col = bgcol;\n    }\n    col += vec3(0.1,0.1,0.01)*glowCumul;\n    col = sqrt(col);\t// gamma correction    \n    tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif\n    \n    fragColor = vec4(tcol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVfzc", "name": "spherical arc spline", "author": "mattz", "description": "Given two points on a sphere and two tangent vectors, construct a smooth spline (orange) out of a pair of equal-radius arcs connecting the points.\n\nHold the mouse down to show just the blue lines + orange spline. Hit S to toggle stereographic projection.", "tags": ["test", "spline", "spherical", "debug", "arc"], "likes": 19, "viewed": 298, "date": "1607656394", "time_retrieved": "2024-06-20T20:25:25.524658", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// spherical arc spline by mattz\n//\n// License CC BY 4.0 https://creativecommons.org/licenses/by/4.0/\n//\n// Given two points on a sphere and two tangent vectors, construct\n// a smooth spline (orange) out of a pair of equal-radius arcs\n// connecting the points.\n//\n// The orange spline touches the black points, and is tangent\n// to the green arrows.\n//\n// The maroon dots are the arc centers -- each one is an equal\n// distance to the black points.\n//\n//////////////////////////////////////////////////////////////////////\n\n// light pos\nvec3 L = vec3(-0.15, 0.3, 1);\n\nconst float PI = 3.141592653589793;\nconst float EPS = 1e-3;\n\n// animation parameters\nconst float PERIOD = 30.0; // seconds per repeat\nconst float PFREQ = 5.0;\nconst float QFREQ = 1.0;\n\n// antialiasing distance\nfloat aa = 0.01;\n\n// should we draw decorations\nbool draw_extras = true;\n\n//////////////////////////////////////////////////////////////////////\n// rotate about x-axis \n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about y-axis \n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// ray-sphere intersection\n\nconst vec4 miss = vec4(-1);\n\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////\n// arclengh distance between unit vectors on sphere\n\nfloat sdist(vec3 a, vec3 b) {\n    return acos(clamp(dot(a, b), -1.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arrow at p0 with tangent l0 \n\nfloat darrow(vec3 p, vec3 p0, vec3 l0) {\n\n    float k = 0.125;\n    \n    vec3 q = cos(k)*p0 + sin(k)*l0;\n\n    vec3 a0 = normalize(cross(p0, l0));\n    vec3 l1 = normalize(cross(q, a0));\n\n    float d = abs(dot(p, a0));\n    d = max(d, -dot(p, l0));\n    d = max(d, -dot(p, l1));\n    \n    float dh = 1e5;\n    \n    for (float s=-1.0; s<=1.0; s+=2.0) {\n    \n        vec3 r = normalize(q + 0.035*s*a0 + 0.4*p0);\n    \n        vec3 l2 = normalize(cross(q, r));\n        vec3 l4 = normalize(cross(q, l2));\n        vec3 l5 = normalize(cross(r, l2));\n    \n        float d2 = abs(dot(p, l2));\n        d2 = max(d2, dot(p, l4));\n        d2 = max(d2, -dot(p, l5));\n        \n        dh = min(dh, d2);\n        d = max(d, -s*dot(p, l2));\n    \n    }\n    \n    d = min(d, dh);\n\n    return d;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// data structure to store spline\n\nstruct arc_spline {\n        \n    vec3 p0, l0, p1, l1, c0, c1, m, w;\n    float r;\n\n};\n\n//////////////////////////////////////////////////////////////////////\n// compute a spline on the sphere made of two arcs that are tangent \n// to each other have desired tangents at given points\n//\n// inputs:\n//\n//   p0: first point on sphere (unit vector)\n//   l0: tangent vector at p0 (unit vector with dot(p0, l0) = 0)\n//   p1: second point on sphere (unit vector) \n//   l1: tangent vector at p1 (unit vector with dot(p1, l1) = 0)\n//\n// output: an arc_spline\n\nvoid compute_spline(in vec3 p0, in vec3 l0,\n                    in vec3 p1, in vec3 l1,\n                    out arc_spline S) {\n                  \n    // fill in data members of spline that copy inputs\n    S.p0 = p0;\n    S.l0 = l0;\n    \n    S.p1 = p1;\n    S.l1 = l1;\n    \n    // compute the line connecting p0 & p1\n    vec3 tmp = normalize(cross(p0, p1));\n    \n    // special case: p0 and p1 are connected by a segment of a great circle\n    // the line from p0 to p1 hits them at the correct tangents \n    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < EPS) {\n        // in this case we set S.r = 0 and set S.w to be the line\n        S.w = tmp;\n        S.r = 0.0;\n        return;\n    }\n    \n    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively\n    vec3 a0 = cross(l0, p0);\n    vec3 a1 = cross(l1, p1);\n    \n    // we will construct arc centers \n    //\n    //   c0 = cos(r) * p0 + sin(r) * a0\n    //   c1 = cos(r) * p1 + sin(r) * a1\n    //\n    // which are a distance r away from p0 & p1 respectively\n    // by construction, dot(c0, l0) = dot(c1, l1) = 0\n    //\n    // now we want to solve for r such that dot(c0, c1) = cos(2*r)\n    //\n    // start by observing that \n    //\n    //   (cos(r)²       * a +\n    //    cos(r)*sin(r) * b\n    //    sin(r)²       * c) = cos(2r)\n    //\n    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and \n    // c = dot(a0, a1).\n    //\n    // applying the half angle identities and setting θ = 2r, we find\n    //\n    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)\n    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)\n    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)\n    //\n    // we can rewrite that as\n    //\n    //   d*cos(θ) + b*sin(θ) = e\n    //\n    // where d = a - c - 2 and e = -(a + c).\n    //\n    // finally, we can rewrite that as\n    //\n    //   α*cos(θ - φ) = e\n    //\n    // where α = sqrt(d² + b²) and φ = atan(b, d).\n    // the solution is given by\n    //\n    //   θ = φ ± acos(e / α)\n    //\n    // and r = 0.5 * θ.\n    \n    float a = dot(p0, p1);\n    float b = dot(p0, a1) + dot(p1, a0);\n    float c = dot(a0, a1);\n    \n    float d = (a - c - 2.);\n    float e = -(a + c);\n    \n    float alpha = length(vec2(d, b));\n    float phi = atan(b, d); // in [-pi, pi]\n    float tau = acos(e/alpha); // in [0, pi]\n\n    // we want the r with the least magnitude so choose tau with the \n    // opposite sign as phi\n    float r = 0.5 * (phi > 0. ? phi - tau : phi + tau);\n\n    // now get c0 & c1\n    float cr = cos(r);\n    float sr = sin(r);\n\n    S.c0 = normalize(cr*p0 + sr*a0);\n    S.c1 = normalize(cr*p1 + sr*a1);\n    \n    // m is the midpoint of c0 & c1, the point\n    // of mutual tangency of the two arcs\n    S.m = normalize(S.c0 + S.c1);\n    \n    // get the line connecting c0 & c1\n    S.w = normalize(cross(S.c0, S.c1));\n    \n    // no longer need the sign of r, want it positive to compute distances later\n    S.r = abs(r);\n    \n    // choose w to point towards p0\n    if (dot(S.w, p0) < 0.) { S.w = -S.w; }\n                  \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arc on sphere\n//\n// inputs: \n//\n//   p: query point (unit vector)\n//   c: arc center point (unit vector)\n//   r: arc radius in radians\n//   l: lower tangent (unit vector)\n//   w: upper tangent (unit vector)\n\nfloat darc(vec3 p, vec3 c, float r, vec3 l, vec3 w) {\n\n    float d = abs(sdist(p, c) - r);\n    \n    d = max(d, -dot(p, l));\n    d = max(d, -dot(p, w));\n    \n    return d;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance from point p to spline S\n\nfloat dspline(vec3 p, arc_spline S) {\n\n    if (S.r == 0.0) {\n    \n        // spline is the great circle segment connecting p0 & p1\n        return max(abs(dot(p, S.w)), -min(dot(p, S.l0), dot(p, S.l1)));\n    \n    } else {\n    \n        // spline is one or two arcs \n        \n        // ignore either arc segment if the midpoint lies at the corresponding endpoint \n        float d = 1e5;\n\n        if (dot(S.m, S.p0) < 1.0 - EPS) { d = min(d, darc(p, S.c0, S.r, S.l0,  S.w)); }\n        if (dot(S.m, S.p1) < 1.0 - EPS) { d = min(d, darc(p, S.c1, S.r, S.l1, -S.w)); }\n        \n        return d;\n                    \n    }\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// draw diagram on sphere\n\nvec3 draw(vec3 p) {\n\n    //////////////////////////////////////////////////\n    // figure out some sample points and tangents\n    \n    vec3 p0 = vec3(0, 0, 1);\n    vec3 l0 = vec3(0, 1, 0);\n    \n    float u = 2.*PI*fract(iTime/PERIOD);\n\n    vec3 p1 = normalize(vec3(0.25, 0.4, 1.0) + vec3(0.3*sin(PFREQ*u), 0.3*cos(PFREQ*u), 0));    \n    vec3 q = normalize(vec3(1, 0, 0.5) + vec3(0.2*sin(QFREQ*u + 0.3), 0.2*cos(QFREQ*u + 0.1), 0));\n    vec3 l1 = normalize(cross(q, p1));\n    \n    //////////////////////////////////////////////////\n    // compute and draw the spline\n    \n    arc_spline S;    \n    compute_spline(p0, l0, p1, l1, S);\n    \n    float bblue = 1e5;\n    float blue = min(abs(dot(p, l0)), abs(dot(p, l1)));\n    float black = min(sdist(p0, p), sdist(p1, p));\n    float green = min(darrow(p, p0, l0), darrow(p, p1, l1));  \n    float maroon = 1e5;\n    float orange = dspline(p, S);\n         \n    if (draw_extras && S.r != 0.0) {\n  \n        blue = min(blue, max(abs(dot(p, S.w)), -min(dot(p, l0), dot(p, l1))));\n        \n        maroon = min(maroon, sdist(p, S.c0));\n        maroon = min(maroon, sdist(p, S.c1));\n        black = min(black, sdist(p, S.m));\n                \n    }\n    \n    vec3 color = vec3(1);\n    \n    if (!draw_extras) {\n        green = 1e5;\n    }\n    \n    color = min(color, mix(vec3(1), vec3(0, 0.5, 1), 0.4*smoothstep(aa, 0.0, blue - 0.002)));\n    color = min(color, mix(vec3(1), vec3(0.1, 0.6, 0), smoothstep(aa, 0.0, green - 0.002)));\n    color = min(color, mix(vec3(1), vec3(1.0, 0.4, 0), smoothstep(aa, 0.0, orange - 0.008)));\n    color = min(color, mix(vec3(1), vec3(0.7, 0, 0.4), smoothstep(aa, 0.0, maroon - 0.015)));\n    color *= smoothstep(0., aa, black - 0.015);\n    \n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// raytrace to sphere and compute color & lighting\n\nvec4 shade(vec3 ro, vec3 rd) {\n    \n    // raytrace\n    vec4 res = sphere(ro, rd, vec3(0), 1.0);\n    \n    // if miss sphere, gray background\n    if (res.w < 0.) { return vec4(vec3(0.85), 1); }\n    \n    // get intersection point on sphere\n    vec3 p = res.xyz;\n\n    // render on sphere\n    vec3 color = draw(p);\n    \n    // goofy non realistic lighting\n    color *= 0.3*dot(p, L) + 0.7;\n\n    return vec4(color, 1);\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// stereographic projection\n\nvec3 sphere_from_plane(vec2 q) {\n\n    float qq = dot(q, q);\n        \n    return vec3(2.*q, -1.+qq) / (1. + qq);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// pretty vanilla main handles scene transform & mouse interaction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // distance from camera to sphere centers\n    const float cdist = 6.0;\n    \n    // center-relative fragment coordinates\n    vec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n        \n    // focal length in pixels\n    float f = 0.45/iResolution.y;\n\n    vec2 theta = vec2(-0.2, 0.15);\n    \n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        theta.x = (iMouse.y - .5*iResolution.y) * 3.5/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * -5.0/iResolution.x; \n    }\n    \n    draw_extras = (max(iMouse.z, iMouse.w) <= 0.0);\n\n    mat3 Rview = rotY(theta.y)*rotX(theta.x); \n\n    if (texture(iChannel0, vec2(83.5/256., 0.75)).x > 0.) {\n\n        vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * 1.5/ iResolution.y;\n\n        vec3 p = sphere_from_plane(uv);\n        \n        p.z = -p.z;\n\n        aa = sqrt(length(cross(dFdx(p), dFdy(p))));\n\n        p = Rview*p;\n\n        vec3 color = draw(p);\n\n        fragColor = vec4(color, 1);\n        \n    } else {\n\n         aa = 4.0 / iResolution.y;\n\n        // ray origin and direction\n        vec3 rd = normalize(vec3(f*uv, -1));\n        vec3 ro = vec3(0, 0, cdist);\n        \n        L = Rview*L;\n        fragColor = shade(Rview*ro, Rview*rd);\n\n    }        \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.7));\n    \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVfzG", "name": "Sh1", "author": "SayrakDark", "description": "...", "tags": ["test"], "likes": 0, "viewed": 52, "date": "1607418763", "time_retrieved": "2024-06-20T20:25:25.530739", "image_code": "vec2 Hash2(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 rand3(vec3 st) {\n    \n \treturn vec3(Hash2(uint(st.x)), rand(st.yz));    \n    \n}\nfloat sph(in vec3 pos, in vec3 cen, in float r){\n\treturn length(pos - cen) - r; \n}\n\nfloat plane(in vec3 pos, in float r){\n\n\treturn pos.y - (-r);\n}\nvec2 mmax(in vec2 a, in vec2 b){\n\t\n\treturn a.x > b.x ? a: b;\n}\n\nvec2 mmin(in vec2 a, in vec2 b){\n\t\n\treturn a.x < b.x ? a: b;\n}\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\nvec2 map(in vec3 pos){\n    \n    //float disp = \n\tvec2 d = vec2(sph(pos, vec3(0.0), 1.5), 1.0);\n    vec2 d1 = vec2(sph(pos, vec3(-3.0*sin(iTime), 0.3-0.31-sin(iTime*5.0), 3.0*cos(iTime)), 0.31*abs(cos(2.5*iTime) + sin(2.5*iTime))), 2.0);\n    vec2 d2 = vec2 (plane(pos, 1.5), 3.0);\n    vec2 d3 = vec2(sph(pos, vec3(3.0*cos(iTime), -1.0, 3.0*sin(iTime)), 0.50),4.0);\n    vec2 d4 = vec2(sph(pos, vec3(10.0, 10.0,0.0),1.0) , 5.0);\n    \n    \n    vec2 d5 = vec2(sph(pos, vec3(-0.5, 0.0, 5.0), 1.5), 6.0);\n    vec2 res = mmin(mmin(d, mmin(d1,d2)), d3);\n    \n    \n    \n    res = mmin(res, d4);\n    res = mmin(res, d5); \n    return res;\n}\n\n\nvec3 ray_cast(in vec3 ro, in vec3 rd){\n\n\tfloat t = 0.0; \n    float d = 0.0; \n    float absSum = 1.0;\n    for(int i = 0; i < 1000; i++){\n    \tvec2 pos = map(ro + t* rd); \n        \n        if(pos.x < 0.001){\n        \t\n            if (pos.y == 6.0) {\n             \tfloat absorp = 1.3;\n                float opacity = 1.0;\n                float d = 0.0;   \n\t\t\t\tabsSum = 0.0;\n                 \n\n                \n                //t += 0.01;\n                \n                while(pos.y == 6.0){\n                    \n                    float prev_opacity = opacity;\n                    \n                    \n                 \tpos = map(ro + t*rd);\n                    \n                    t += 0.01;\n                    \n                    if(pos.x < 0.0)\n                    \td += 0.01;\n                    \n                    opacity *= BeerLambert(absorp, 0.01);\n                    \n                    float absorb = prev_opacity -opacity;\n                    \n                    absSum += absorb;\n                    \n                }              \n                \n            }\n        \tpos.x = t; \n           \t\n            return vec3(pos, absSum);\n        } \n        \n        if(pos.x > 20.0){\n        \tbreak;\n        }\n        \n        t += pos.x;\n    }\n    \n    return vec3(vec2(-1.0), absSum);\n}\nvec3 normal(in vec3 pos){\n\n\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n    \n    \n    \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    \n    \n    \n    return normalize(vec3(grad_x, grad_y, grad_z));\n\n\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nfloat checkers( in vec3 p ) {\n    vec3 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y*s.z;\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(cen-pos);\n    float diff_intens = dot(nor, dir_to_light);\n    \n    return diff_intens;\n\n}\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro, in float k){\n\t\n    float specPower = k;\n    vec3 n = normal(pos);\n    vec3 l = normalize(cen-pos);\n    vec3 v = normalize(ro-pos);\n    vec3 r = reflect(v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\nfloat fog(in vec3 pos) {\n\t\n    float ans = 1.0;\n    if(abs(pos.x) > 10.0) ans *= 1.0 / (pos.x*pos.x*0.01);\n    //if(abs(pos.y) > 10.0) ans *= 1.0 / (pos.y*pos.y*0.01);\n    if(abs(pos.z) > 10.0 ) ans *= 1.0 / (pos.z*pos.z*0.01);\n    \n    return ans;\n\n}\n\n\nfloat shadow(vec3 pos, vec3 lightpos){\n\tvec3 rd = normalize(lightpos-pos);\n    float res = 1.0;\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 1000.0; i++)\n    {\n\t\tvec2 h = map(pos + rd * t);\n        res = min(res, 15.0 * h.x / t);\n        t += h.x;\n        \n        if ((res < 0.000001 || t > 3200.0)) break;\n        \n    }\n    \n    return clamp(res, 0.0, 1.0);\n    \n}\n\nvec3 fogMarch(vec3 pos){\n    float absorp = 1.0;\n    float opacity = 1.0;\n    float absSum = 0.0; \n    float h = 0.0;\n\n    float prev_opacity = opacity;\n\n\n    opacity *= BeerLambert(absorp, h);\n\n    float absorb = prev_opacity -opacity; \n\n    absSum += absorb; \n    h+= 0.01;\n\n    \n    return vec3(absSum);\n    \n}\n\nvec3 mirror(in vec3 opos, in vec3 ord) {\n    \n    \n    vec3 n = normal(opos);\n    vec3 ro = opos;\n    vec3 rd = n;\n    int max_step =1;\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 col =vec3(1.0,1.0,1.0);\n    for(int i=0; i < max_step; i++){\n        vec3 h = ray_cast(ro+0.1*n, reflect(-ro, n));\n\n\n        if(h.x > -1.0) {\n            vec3 pos = ro + h.x *rd;\n         \n            if(h.y == 2.0){\n                col = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 2.0;\n                \n            }\n\n\n            if(h.y == 3.0) {\n\n                col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n                \n\n                col += checkers(pos);\n                col *= mix(col, vec3(0.9), 20.0);\n                col *= shadow(pos, lp);\n\n            }\n            if(h.y == 4.0) {\n\n                col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 1.5;\n\n\n\n            }\n            if(h.y == 5.0){\n            \tcol = vec3(0.9,0.9,0.9) * diffuse_light(pos, lp) ; \n                col += checkers(pos * iTime);\n            }\n            col *= 2.0;\n            col*=fog(pos);\n\n            \n            //col = vec3(h.y,0,0);\n        }else {\n        if(rand(vec2(ord.x, ord.y )) > 0.0  )\n\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);    \n    }\n    }\n    return col;\n    \n    \n    \n}\nvec3 render(in vec3 ro, in vec3 rd){\n    \n    vec3 h = ray_cast(ro, rd);\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 mp = vec3(0.0);\n    vec3 col = vec3(1.0,1.0,1.0);\n    if(h.x > -1.0){\n        vec3 pos = ro + h.x * rd;\n        \n        if(h.y == 1.0){\n        \tcol *= calcAO(pos, normal(pos));;\n            \n           \n            \n            \n           \n            col *= mirror(pos, rd); \n            //col *= shadow(pos, lp) + 0.4;\n            \n        }\n    \t\t\n    \t\n        if(h.y == 2.0){\n        \tcol = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n            col *= shadow(pos, lp);\n            //float d = h.z; \n            //float s = d / 1.0;\n            //s = s / (1.0 + s); \n            \n           // col = (1.0 - s) * col + s * vec3(0.7);\n        }\n        \n        \n        if(h.y == 3.0) {\n        \t\n            col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n            \n            col += checkers(pos);\n            col *= mix(col, vec3(0.9), 20.0);\n            col *= shadow(pos, lp);\n        \t\n        }\n        if(h.y == 4.0) {\n        \t\n            col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos)); \n        \tcol *= shadow(pos, lp);\n            \n            \n        \t\n        }\n        if(h.y == 5.0){\n        \tif(rand(vec2(rd.x, rd.y)) > 0.0 )\n\t\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);  \n        \t\n        \n        }\n        \n        \n        \n        col *= fog(pos);\n        col *= vec3(h.z);\n        \n    } else {\n        if(rand(vec2(rd.x, rd.y)) > 0.0 )\n\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);    \n    }\n    \n    return col;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    int totalAASamples = 1;\n    for (int i = 0; i < totalAASamples; ++i)\n    {\n        \n        float x = mod(float(i), 2.0);\n        float y = mod(float(i / 2), 2.0);\n        \n        vec2 jitter = (Hash2(uint(i)) + vec2(x, y)) / 2.0;\n\n        vec2 uv = 2.0 * (fragCoord.xy + jitter) / iResolution.xy - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n    }\n    \n    float an = 10.0 * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(4.0*cos(an)*1.5, 1.0, 4.0*sin(an) * 1.5);\n    vec3 ta = vec3(0.0, 0.0, 0.0); // target for camera\n\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu, ww));\n\n\n\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n    col = render(ro, rd);\n    col /= float(totalAASamples);\n    col *= 1.0;\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyBDy", "name": "ring twister", "author": "maksy", "description": "A ring twister was suggested as the next project after I made the classic twister effect. So here it is. :-) \n\nOther shaders I used to study how the effect works:\nhttps://www.shadertoy.com/view/Xt23z3\nhttps://www.shadertoy.com/view/lsX3WM", "tags": ["2d", "oldschool", "ring", "twister"], "likes": 5, "viewed": 371, "date": "1608927462", "time_retrieved": "2024-06-20T20:25:26.161044", "image_code": "const float IN_RADIUS = 0.3;\nconst float OUT_RADIUS = 0.85;\nconst float PI = 3.14159;\n\nvec3 borderColor(float x0, float x1, vec2 uv, \n                 float leftVisible, float rightVisible) {\n\n    vec3 edgeCol = vec3(0.05);\n    vec3 white = vec3(1.);\n    float thick = 0.03;\n   \t\n    // the exterior side of the left border\n\tfloat outside = (step(uv.x, x0-thick) + step(x0, uv.x));\n    vec3 borderCol = mix(white, edgeCol, smoothstep(x0, x0-thick, uv.x)) \n    \t* (1. - outside) * leftVisible;\n        \n    // the interior side of the left border\n    outside = (step(uv.x, x0) + step(x0+thick, uv.x));\n    borderCol += mix(edgeCol, white, smoothstep(x0+thick, x0, uv.x)) \n    \t* (1. - outside)* leftVisible;      \n    \n    // the exterior side of the right border\n    outside = (step(uv.x, x1) + step(x1+thick, uv.x));        \n    borderCol += mix(white, edgeCol, smoothstep(x1, x1+thick, uv.x))\n        * (1.- outside) * rightVisible ;\n    \n    // the interior side of the right border\n    outside = (step(uv.x, x1-thick) + step(x1, uv.x));            \n    borderCol += mix(edgeCol, white, smoothstep(x1-thick, x1, uv.x))\n    \t* (1.- outside) * rightVisible;\n    \n    return borderCol;\n}\n\nvec3 getBorderColor(float x0, float x1, vec2 uv,\n              vec3 fragColor) {\n        \n    vec3 rightCol = vec3(0.);\n    vec3 leftCol = vec3(0.);\n        \n    leftCol = borderColor(x0, x1, uv, 1., 0.);       \n    rightCol = borderColor(x0, x1, uv, 0., 1.);\n   \n    if (leftCol != vec3(0.))\n        return leftCol;\n    else if (rightCol != vec3(0.))\n   \t\treturn rightCol;                 \n   \n    return fragColor;   \n}\n\nvec3 getColor(float x0, float x1, vec2 uv, vec3 color) {\n   \n   // First u becomes [0,1] then the range [0.0, 0.5] will be \n   // transformed into [0.0, 1.0] and ]0.5, 1.0] into ]1.0, 0.0].\n   float u = (uv.x - x0)/(x1 - x0);\n              \n   // u <= 0.5\n   float ud = (u/0.5) * (1.0 - step(0.5, u));\n   // u > 0.5\n   ud += (1. - (u/0.5-1.)) * (1.0 - step(u, 0.5));\n           \n   // Remove aliasing by making the shading points near x0 and x1 darker.\n   vec3 col = mix(vec3(0.0), color, smoothstep(.0, .6, ud)); \n            \n   // Add lightning by making darker the shading points that are \n   // about to be covered and going \"behind\" another face. This also\n   // removes aliasing since if x1-x0 is small the borders cover the \n   // darker sides and transition to interior area becomes very sharp. \n   float w = (x1 - x0);            \n   col *= w / .55;\n   return col;            \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    uv *= 2.7;\n    \n    // Polar coordinates\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + PI);\n    uvr.x -= OUT_RADIUS;\n       \n    vec3 col = mix(vec3(0.01), vec3(0.05), smoothstep(2.2, .1, abs(uv.x)));    \n    \n    vec3 colors[4];\n    colors[0] = vec3(0.9, 0.0, 0.0);\n    colors[1] = vec3(0.0, 0.9, 0.0);\n    colors[2] = vec3(0.0, 0.2, 1.0);\n    colors[3] = vec3(1.0, 0.42, 0.0);\n        \n    float angle = uvr.y + 1.5*iTime + .5*sin(uvr.y) * 1.5*sin(iTime) * PI;\n    \n    // Add faces\n    for(int i = 0; i < 4;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + 0.5 * float(i) * PI);       \n        float x1 = IN_RADIUS * sin(angle + 0.5 * float(i+1) * PI);\n\n        if (uvr.x >= x0 && uvr.x <= x1) {\n            col = getColor(x0, x1, uvr, colors[i]);            \n       }\n    }\n\n    // Add borders.\n    float x0 = IN_RADIUS * sin(angle + 0.0);       \n    float x1 = IN_RADIUS * sin(angle + 0.5*PI);\n    float x2 = IN_RADIUS * sin(angle + 1.0*PI);       \n    float x3 = IN_RADIUS * sin(angle + 1.5*PI);    \n\t\n    if (x0 < x1) {\n        col = getBorderColor(x0, x1, uvr, col);      \n    }    \n    \n\tif (x1 < x2) {\n    \tcol = getBorderColor(x1, x2, uvr, col);\n    }\n   \n   \tif (x2 < x3) {\n    \tcol = getBorderColor(x2, x3, uvr, col);\n    }\n    \n    if (x3 < x0) {\n    \tcol = getBorderColor(x0, x3, uvr, col);\n    \tif (x2 < x3) {\n            col = getBorderColor(x3, x0, uvr, col);    \t\n    \t}\n    }\n    \n    col = pow(col,vec3(.454545));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyBW3", "name": "deck", "author": "lennyjpg", "description": "sdfafsdsdfasdf", "tags": ["gradient", "rotation", "polar", "double", "split", "screw"], "likes": 0, "viewed": 196, "date": "1608316570", "time_retrieved": "2024-06-20T20:25:26.167118", "image_code": "#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime *-0.3;\n    vec2 u = uv;\n    float ratio = iResolution.x/iResolution.y;\n    u.x = fract(u.x * 2.);\n    float offset = floor(uv.x + 0.5);\n    t += offset;\n    u -= vec2(0.5);\n    u = rotate2d( t * PI) * u; \n    //float d = length(u);\n    //float c = step(d, 0.4);\n    //float c2 = step(d, 0.2);\n    //float g = fract(u.x)*fract(u.y);\n    float k = fract(atan(u.y,u.x)*0.2);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyBWW", "name": "some optical illusion", "author": "ltms", "description": "stereokinetic effect", "tags": ["test"], "likes": 0, "viewed": 34, "date": "1607236193", "time_retrieved": "2024-06-20T20:25:26.167118", "image_code": "// visszaadja a kor maszkolofuggvenyet\nfloat drawCircle(vec2 st, vec2 origo, float radius)\n{\n    float blur = .01;\n    \n    // aktualis pixelpont es kor kozepppontjanak tavolsaga\n    // vissza kell alakitani descartes koordinatakra\n    float d = length(vec2(st.y*cos(st.x),st.y*sin(st.x)) - origo);\n   \n    // color withour blur\n    float c1 = (d<=radius) ? 1. : 0.;\n    // color with blur\n    float c2 = smoothstep(radius, radius-blur, d);\n    \n    return c2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    // cartesian coords\n    // x: [-0.89 ; 0.89], y: [-0.5 ; 0.5]\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy ) / iResolution.y;\n\n    // polar coords\n    // x: [-PI ; PI], y: [0 ; inf]\n    vec2 st = vec2( atan(uv.y, uv.x), length(uv));\n    // origotol valo tavolsag\n    //fragColor = vec4(st.y);\n    // mekkora szoget zar be az x tengellyel\n    //fragColor = vec4(st.x / 6.2831 + 0.5);\n    //fragColor = vec4(st.x / (2.* PI + 0.5);\n    \n    // a domaint atalakitjuk polar koordinatakra (\"osszehajtuk\" origonal)\n    // normalized polar coords\n    // x: [0 ; 1], y: [0 ; inf]\n    //st = vec2(st.x / 6.2831 + 0.5, st.y);\n    \n    // forgatas\n    st.x+=iTime*1.4;\n    \n    int nrSlices = 6;\n    int craterStart = 4 ;\n    \n    // körök közötti távolság\n    float dist= 0.5/float(nrSlices);\n    //dist = 0.1;\n    \n    vec4 bgColor = vec4(1.);\n    for (int i = 0; i<craterStart; i++) {\n        vec2 kekorigo = vec2(float(i)*dist,0.); //vec2(float(i)*0.1,0.)\n        float kekradius = .5 - (float(i)*dist); //.5 - (float(i)*0.1)\n    \tfloat kek = drawCircle(st, kekorigo, kekradius);\n    \tbgColor.rgb = mix(bgColor.rgb, vec3(0., 0., 1.), kek);\n        \n        vec2 sargaorigo = vec2(float(i)*dist + dist/2.,0.); //vec2(float(i)*0.10 +0.05, 0.)\n        float sargaradius = .5 - (float(i)*dist+dist/2.); //.5 - (float(i)*0.1+0.05)\n    \tfloat sarga = drawCircle(st, sargaorigo, sargaradius);\n    \tbgColor.rgb = mix(bgColor.rgb, vec3(1., 1., 0.), sarga);\n    }\n    for (float i = float(craterStart); i<float(nrSlices); i++) {\n        vec2 kekorigo = vec2(.5-(i-1. )*dist,0.); //vec2(float(i)*0.1,0.)\n        float kekradius = .5 - i*dist; //.5 - (float(i)*0.1)\n    \tfloat kek = drawCircle(st, kekorigo, kekradius);\n    \tbgColor.rgb = mix(bgColor.rgb, vec3(0., 0., 1.), kek);\n        \n        vec2 sargaorigo = vec2(.5-((i-1.)*dist + dist/2.),0.); //vec2(float(i)*0.10 +0.05, 0.)\n        float sargaradius = .5 - (i*dist+dist/2.); //.5 - (float(i)*0.1+0.05)\n    \tfloat sarga = drawCircle(st, sargaorigo, sargaradius);\n    \tbgColor.rgb = mix(bgColor.rgb, vec3(1., 1., 0.), sarga);\n    }\n    \n    // output color\n\tfragColor = bgColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyBzc", "name": "Fractal metamorphose", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 9, "viewed": 180, "date": "1607606731", "time_retrieved": "2024-06-20T20:25:26.167118", "image_code": "void rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\n#define sabs(a)sqrt((a)*(a)+1e-4)\nfloat scale;\nfloat map(vec3 p){\n \trot(p,vec3(cos(iTime*.07),sin(iTime*.06),sin(iTime*.05)*.5),iTime*.5+1.2*sin(iTime*.8));\n    p.x-=10.;\n    float s=2.;\n    p=sabs(p);\n    for(int j=0;j<8;j++){\n        p=-sign(p)*(sabs(sabs(sabs(p)-2.)-1.)-1.);\n        float l=(-2.13+.3*sin(iTime*.7+.5*sin(iTime*.5)))\n            /max(.43+.38*sin(iTime*.9+.3*sin(iTime*.8)),dot(p,p));\n        s*=l;\n        p*=l;\n        p-=.55+.01*sin(iTime*1.2+.5*sin(iTime*.5));\n    }\n    scale=s;\n    return dot(p,normalize(vec3(1,2,3)))/s;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.003*(vec3(9>>i&1,i>>1&1,i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<90;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return cos(vec3(3,2,8)+log(scale*.003)+iTime*1.5)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,120);\n    vec3 rd = normalize(vec3(uv,-2));\n    vec3 col= min(vec3(.8),.8*vec3(.03,.02,.01)/length(uv*.4));\n\tconst float maxd=150.;\n    float t=march(ro,rd,30.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=normalize(lightPos-p);\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.4;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(12,6,5)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n    }\n    col*=1.5;\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyfDd", "name": "Isosceles Triangle - gradient 2D", "author": "iq", "description": "Signed distance and analytic gradient to an isosceles triangle. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "segment"], "likes": 10, "viewed": 420, "date": "1608207542", "time_retrieved": "2024-06-20T20:25:26.730942", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and analytic gradient to an isosceles\n// triangle. More accurate than central differences and\n// faster to compute than automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    float w = sign(p.x);\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float l1 = dot(a,a);\n    float l2 = dot(b,b);\n    float d = sqrt((l1<l2)?l1:l2);\n    vec2  g =      (l1<l2)? a: b;\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return vec3(d,vec2(w*g.x,g.y)/d)*sign(s);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        p.y -= 0.3;\n        // size\n        vec2 si = vec2(0.5,-0.5) + vec2(0.3,-0.3)*cos( iTime + vec2(0.0,1.57) + 0.0 );\n\n        // sdf(p) and gradient(sdf(p))\n        vec3 dg = sdgTriangleIsosceles(p,si);\n        float d = dg.x;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n         vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyfRt", "name": "Bad Quality CRT Effect", "author": "atsuyusky", "description": "I like smell of solder from CRT display", "tags": ["noise", "crt", "television", "crteffect"], "likes": 1, "viewed": 297, "date": "1607675846", "time_retrieved": "2024-06-20T20:25:27.064262", "image_code": "vec2 distort(vec2 uv, float k4, float mag) {\n    vec2 v = uv - vec2(0.5);\n    float r2 = dot(v, v);\n    vec2 dr = 1.0 / (1.0 + k4 * r2 * r2) * v;\n    return dr * mag + vec2(0.5);\n}\n\nfloat noise(vec2 co){\n  return fract(sin(dot(co.xy,vec2(1.0,0.42829))) * 51126.88915);\n}\n\nfloat vignette(vec2 uv, float scale) {\n    uv = (uv - .5) * scale;\n    return smoothstep(0.0, 1.0, sqrt(pow(abs(uv.x), 8.0) + pow(abs(uv.y), 8.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float noisy = abs(sin(iTime) * 0.02) +\n                  pow(sin(iTime * 0.25) * 0.5 + 0.5, 8.0) + 0.01;\n    \n    float noisy2 = noisy * noisy;\n    float randomizer = noise(vec2(iTime, iTime * 3.0));\n    float randomizer2 = noise(vec2(iTime* 1.234, iTime * 2.345));\n    float scanline = sin(uv.y * 500.0 - iTime * 10.0);\n    float vflip = sin(uv.y * 4.0 - iTime * 120.0);\n    \n    // SCAN NOISE OFFSET\n    float scannoise = randomizer * 0.5 * noisy2;\n    vec2 scannoise_offset1 = vec2(scanline * scannoise, 0.0) + vec2(vflip * scannoise, 0.0);\n    vec2 scannoise_offset2 = vec2((randomizer - 0.5) * noisy2, (randomizer2 - 0.5) * noisy2);\n    \n    // CRT DISTORTION\n    vec2 uv_bend = distort(fract(uv + scannoise_offset1 + scannoise_offset2), -0.5, 0.8);\n    \n    // BLOCK NOISE\n    float block_size = 0.0001 + 0.02 * (randomizer - 0.5);\n    vec2 uv_blocked = uv_bend - mod(uv_bend, block_size);\n    float block = 1.0 - step(abs(noise(uv_blocked + vec2(iTime, iTime)) * randomizer2 * noisy), 0.01);\n    uv_bend = mix(uv_bend, uv_blocked, block);\n   \n    // VIDEO SOURCE SAMPLING\n    vec3 col;\n    col.r = texture(iChannel0, uv_bend + vec2(0.01, 0.0)).r;\n    col.g = texture(iChannel0, uv_bend).g;\n    col.b = texture(iChannel0, uv_bend + vec2(-0.01, 0.0)).b;\n   \n    // GRAIN NOISE\n    col = mix(col, vec3(noise(uv * 100.0 + randomizer)), 0.1 + noisy2 * randomizer * 0.9);\n    \n    // FADING OUT\n    vec3 bg = vec3(0.25, 0.5, 0.5);\n    col = mix(col, bg, ((scanline * 0.5 + 0.5) + (vflip * 0.5 + 0.5)) * 0.125);\n    col = mix(col, bg, vignette(uv, 1.5));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dyfzm", "name": "- solar system -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sun", "sdf", "star", "space", "planet", "universe", "solarsystem"], "likes": 23, "viewed": 431, "date": "1606942974", "time_retrieved": "2024-06-20T20:25:27.064262", "image_code": "#define EPS 0.001\n#define MAX_DIST 50.\n#define PI 3.141592\n\nstruct SdfCtx {\n    float k;\n    vec3 col;\n    float d; \n};\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdTorus(vec3 p, float bR) {\n    return length(vec2(length(p.xz) - bR, p.y)) - 0.0015;  \n}\n\nfloat stripe(float dist, float o) {\n    return abs(dist) - o;\n}\n\nSdfCtx addPrimitive(SdfCtx p1, SdfCtx p2) {\n    if (p1.d < p2.d) {\n        return p1;\n    } else {\n        return p2;\n    }\n}\n\nmat2 rotMat(float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat2(c, -s, s,  c);\n}\n\nmat3 rotateY(float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat3(c,  0, -s,\n                0,  1,  0,\n                s,  0,  c);\n}\n\nSdfCtx calcDist(vec3 p) {\n    float t = iTime;\n    \n    float dStripedSphere = stripe(stripe(stripe(stripe(sdSphere(p * rotateY(t * 0.05) + vec3(2.05, 0., 2.05), 0.264 + 0.08), 0.08), 0.06), 0.02), 0.01);\n    float dStripes = max(max(dStripedSphere, p.y), -(p.y + 0.001));\n    \n    vec3 moonP = 0.1 + (p * rotateY(t * 0.3) - vec3(0.1) * rotateY(t * 3.5));\n\t   \n    //PLANETS\n    SdfCtx d = \t\t\tSdfCtx(0.,  vec3(0.,   0.,   0.),   sdSphere(p * rotateY(t * 0.)    + vec3(0., 0., 0.),     0.42));   // SUN\n    d = addPrimitive(d, SdfCtx(0.,  vec3(0.1,  0.1,  0.1), \tsdSphere(moonP \t\t\t\t    + vec3(0.75, 0., 0.75), 0.02)));  // MOO\n    d = addPrimitive(d, SdfCtx(0., \tvec3(0.3,  0.3,  0.3),  sdSphere(p * rotateY(t * 2.)    + vec3(0.45, 0., 0.45), 0.03)));  // MER\n    d = addPrimitive(d, SdfCtx(0., \tvec3(0.57, 0.57, 0.57), sdSphere(p * rotateY(t * 1.)    + vec3(0.65, 0., 0.65), 0.072))); // VEN\n    d = addPrimitive(d, SdfCtx(0., \tvec3(0.1,  0.3,  0.4),  sdSphere(p * rotateY(t * 0.3)   + vec3(0.85, 0., 0.85), 0.078))); // EAR\n    d = addPrimitive(d, SdfCtx(1., \tvec3(0.53, 0.24, 0.15), sdSphere(p * rotateY(t * 0.2)   + vec3(1.1,  0., 1.1),  0.06)));  // MAR\n    d = addPrimitive(d, SdfCtx(35., vec3(0.4,  0.2,  0.07), sdSphere(p * rotateY(t * 0.1)   + vec3(1.45, 0., 1.45), 0.33)));  // JUP\n    d = addPrimitive(d, SdfCtx(30., vec3(0.3,  0.2,  0.1),  sdSphere(p * rotateY(t * 0.05)  + vec3(2.05, 0., 2.05), 0.264))); // SAT\n    d = addPrimitive(d, SdfCtx(2., \tvec3(0.45, 0.59, 0.71), sdSphere(p * rotateY(t * 0.01)  + vec3(2.55, 0., 2.55), 0.15)));  // URA\n    d = addPrimitive(d, SdfCtx(40., vec3(0.2,  0.29, 0.47), sdSphere(p * rotateY(t * 0.005) + vec3(2.8,  0., 2.8),  0.1)));   // NEP\n    \n    vec3 orbitCol = vec3(0.15);\n    \n    //ORBITS\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 0.63))); // MER\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 0.92))); // VEN\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 1.2)));  // EAR\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 1.55))); // MAR \n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 2.05))); // JUP\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 2.9)));  // SAT\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 3.6)));  // URA\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 3.95))); // NEP\n    \n    //RINGS\n    d = addPrimitive(d, SdfCtx(0.,  vec3(0.3,  0.2,  0.1),  dStripes)); // SAT\n    \n    return d;\n}  \n\nvec3 calcNormal(vec3 pos) {\n    float d = calcDist(pos).d;\n    return normalize(vec3(d - calcDist(pos - vec3(EPS, 0,  0 )).d,\n                          d - calcDist(pos - vec3( 0, EPS, 0 )).d,\n                          d - calcDist(pos - vec3( 0,  0, EPS)).d));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n    vec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n\n    vec3 ambient = vec3(0.1);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.));\n\n    return lightCol * (ambient + diffuse);\n}\n\nmat3 calcLookAtMatrix(vec3 camPos, vec3 at) {\n    vec3 zAxis = normalize(at - camPos);\n    vec3 xAxis = normalize(cross(zAxis, vec3(0., 1., 0.)));\n    vec3 yAxis = normalize(cross(xAxis, zAxis));\n    return mat3(xAxis, yAxis, zAxis);\n}\n\nSdfCtx rayMarch(vec3 rayO, vec3 rayD) {\n    SdfCtx res = SdfCtx(0., vec3(0), 0.);\n    for( int i = 0 ; i < 100; i++ ) {\n        SdfCtx dS = calcDist(rayO + rayD * res.d);\n        if (dS.d < EPS || res.d > MAX_DIST) break;\n        res.col = dS.col;\n        res.k = dS.k;\n        res.d += dS.d;\n    }\n    return res;\n}\n\nvec3 calcPlanetTexture(vec2 p, vec3 col, float k) {\n    return vec3(sin(p.y * k) * 0.1 + 0.4) * col;\n}\n\nfloat fallingStar(vec2 p, vec2 a, vec2 b) {\n    p -= a;\n    b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    p -= b * h;\n    return h * smoothstep(2. * h / iResolution.y, 0., length(p));\n}\n\nfloat hash(vec3 p) {\n\tp = fract(p * vec3(.1031, .11369, .13787));\n    p += dot(p, p.yzx + 19.19);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat calcStarLayer(vec3 d, float intensity) {\n    return smoothstep(intensity, 0., length(fract(d) - 0.5)) * smoothstep(0.98, 1., hash(floor(d)));\n}\n\nvec3 calcBgColor(vec2 xy, vec3 rayDir) {\n    return fallingStar(xy * rotMat(PI), vec2(-0.04) + tan(iTime / 4.), vec2(0.04) + tan(iTime / 4.)) * vec3(0.3, 0.4, 0.7) +\n           vec3(calcStarLayer(rayDir * 550., abs(sin(iTime / 2.)) / 2.)) * vec3(0.5, 0.28, 0.73) + \n           vec3(calcStarLayer(rayDir * 550., abs(cos(iTime / 2.)) / 2.)) * vec3(0.3, 0.6,  0.73) + \n           vec3(calcStarLayer(rayDir * 500., abs(cos(iTime)) / 2.)) * vec3(0.5, 0.58, 0.43) + \n           vec3(calcStarLayer(rayDir * 500., abs(sin(iTime)) / 2.)) * vec3(0.5);\n}\n\nvec2 calcUV(vec3 p) {\n    vec3 n = calcNormal(p);\n    return vec2(atan(n.x, n.z) / (2. * PI) + 0.5, n.y * 0.5 + 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(-7., 6. * max(abs(cos(iTime / 30.)), 0.4), -8. * sin(iTime / 30.));\n    mat3 cam = calcLookAtMatrix(camPos, vec3(0, -0.5, 0));\n\n    vec3 rayDir = cam * normalize(vec3(xy, 2.));\n    SdfCtx rayRes = rayMarch(camPos, rayDir);     \n\n    vec3 col = vec3(0);\n\n    if(rayRes.d < MAX_DIST){\n        vec3 p = camPos + rayRes.d * rayDir;\n        if (rayRes.col.x == 0.) {\n            col = (texture(iChannel0, calcUV(p * rotateY(iTime / 5.))).xyz / 1.1 + 0.5) * 1.5 * vec3(0.96, 0.55, 0);\n        } else {\n            col = vec3(calcPlanetTexture(vec2(p), rayRes.col, rayRes.k)) + calcLight(p, vec3(0), vec3(0.4), rayDir);\n        }\n    } else {\n        col = calcBgColor(xy, rayDir) + vec3(0.09 / length(xy - vec2(0, 0.07))) * vec3(0.7, 0.5, 0.);\n    }\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3l3cR8", "name": "Morphing Sakura Fractal", "author": "mherreshoff", "description": "Two fractals that look like a cherry blossoms.  Same idea as [ https://www.shadertoy.com/view/WttcRr ] but here the \"pow\" stretches the fractal copies to give the result a more blobby organic feel.", "tags": ["fractal", "flower", "morphing", "cherry", "blossom", "sakura"], "likes": 4, "viewed": 116, "date": "1608421516", "time_retrieved": "2024-06-20T20:25:27.064262", "image_code": "#define PI 3.1415926535\n#define CS(a) vec2(cos(a), sin(a))\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0)))\n\nfloat smoothhill(float a, float b, float c, float x) {\n    return smoothstep(a,b,x)-smoothstep(b,c,x);\n}\nfloat smoothParity(float x, float b) {\n    float m = mod(x-.5, 2.);\n    return smoothstep(.5-b, .5+b, m) - smoothstep(1.5-b, 1.5+b, m);\n}\n\nvec2 target (vec2 z, float power) {\n    if (length(z) > 100.) return z;  // Prevent blowup.\n    vec2 weightedSum=vec2(0); float weight=0.;\n#define N 5.\n    for (float i = 0.; i < N; i++) {\n        float theta = 6.28*(i/N);\n        vec2 point = CS(theta), d = z-point;\n        float L = length(d), w = pow(L, -10.);\n        float scale = 2.*pow(L, power-1.);\n        weight += w;\n        weightedSum += w*scale*d;\n    }\n#undef N\n    return weightedSum/weight;\n}\n\nvec4 render (in vec2 coord) {\n    vec2 R = iResolution.xy, pw = 1./R, uv = coord*pw;\n    float cycleT=20., t = fract(iTime/cycleT), maxIt = 5., \n          iterations = maxIt*smoothhill(0.,.5,1.,t), zoom = 4.;\n    float parity = smoothParity(iTime/cycleT, .05);\n    vec4 bandColor = mix(hue(.0), hue(.6)*.5, parity);\n    float b = mix(.5, .5, parity);\n    float bw = mix(.2, .3, parity);\n    float power = mix(3., 1.8, parity);\n    \n    vec2 p = rot(radians(36.+90.))*((coord-.5*R)/R.y)*zoom;\n    for (float i = 0.; i < 10.; i++){\n        if (i < floor(iterations)) p = target(p, power);\n    }\n    p = mix(p, target(p, power), fract(iterations));\n    \n    float m = length(p);\n    vec4 col = vec4(mix(.85, 1., smoothhill(0.,.5,1.5,m)));\n    col = mix(col, bandColor, .3*smoothhill(b-bw,b,b+bw,m));\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    // 2D Antialiasing:\n    vec2 d = vec2(.5,0);\n    O = (render(u+d.xy)+render(u-d.xy)+render(u+d.yx)+render(u-d.yx))*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3l3cWr", "name": "hoeled_mirrored", "author": "hoeled", "description": "Hm", "tags": ["colors"], "likes": 4, "viewed": 123, "date": "1608764411", "time_retrieved": "2024-06-20T20:25:27.064262", "image_code": "mat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Triangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    uv*=17.;\n    vec3 col = vec3(0);\n    uv.y*=.58;\n    uv.y=abs(uv.y);\n    uv.x=abs(uv.x);\n    \n    uv += mod(uv.x, uv.y);\n    uv.x += 1.-uv.y;\n    uv.y -= .3;\n    \n    float t = iTime * .3;\n    \n    float s1 = 1.47;\n    float s2 = 0.16;\n    \n    uv*=Rot(-t*.4);\n    \n    uv*=Rot(t);\n    col.r += smoothstep(s1, s2, Triangle(uv))*1.;\n    uv*=Rot(-t);\n    uv*=Rot(t*.4);\n    col.b += smoothstep(s1, s2, Triangle(vec2(uv.x+1., uv.y)))*1.;\n    uv*=Rot(-t*.4);\n    uv*=Rot(-t*1.24);\n    col.g += smoothstep(s1, s2, Triangle(vec2(uv.x-1., uv.y)))*1.;\n    uv*=Rot(t*1.24);\n    \n    uv*=Rot(-t);\n    col.rg += smoothstep(s1, s2, Triangle(uv))*1.;\n    uv*=Rot(t);\n    uv*=Rot(-t*.71);\n    col -= smoothstep(s1, s2, Triangle(vec2(uv.x+1., uv.y+(1.*sin(iTime)*.5+.5))))*1.;\n    uv*=Rot(t*.3);\n    uv*=Rot(t*1.24);\n    col.b += smoothstep(s1, s2, Triangle(vec2(uv.x-1., uv.y)))*1.;\n    uv*=Rot(-t*1.1);\n    \n    uv*=Rot(t*1.78);\n    col -= smoothstep(s1, s2, Triangle(vec2(uv.x-1., uv.y)))*1.;\n    uv*=Rot(-t*1.78);\n    \n    float t1 = sin(t);\n    col -= smoothstep(0.81+t1*.1, 0.8+t1*.1, length(uv));\n\n    col.rg += smoothstep(0.41, 0.4, length(uv));\n    \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    col *= smoothstep(.47, -.2, length(uv.y));\n    uv*= 12.;\n    uv.y*=.58;\n    uv.y=abs(uv.y);\n    uv.x=abs(uv.x);\n    \n    uv += dot(uv.x*uv.x*uv.x, uv.y);\n    \n    uv *= Rot(2.);\n    \n    t = iTime * .7;\n    uv*=Rot(t*.17);\n    \n    s1 = 0.17;\n    s2 = 0.16;\n    \n    uv*=Rot(t);\n    col.b += smoothstep(s1, s2, Triangle(uv))*1.;\n    uv*=Rot(-t);\n    uv*=Rot(t*.4);\n    col.g += smoothstep(s1, s2, Triangle(vec2(uv.x+1., uv.y)))*1.;\n    uv*=Rot(-t*.4);\n    uv*=Rot(-t*1.24);\n    col.g += smoothstep(s1, s2, Triangle(vec2(uv.x-1., uv.y)))*1.;\n    uv*=Rot(t*1.24);\n    \n    uv*=Rot(-t);\n    col.r += smoothstep(s1, s2, Triangle(uv))*1.;\n    uv*=Rot(t);\n    uv*=Rot(-t*.71);\n    col -= smoothstep(s1, s2, Triangle(vec2(uv.x+1., uv.y+(1.*sin(iTime)*.5+.5))))*1.;\n    uv*=Rot(t*.3);\n    uv*=Rot(t*1.24);\n    col.b += smoothstep(s1, s2, Triangle(vec2(uv.x-1., uv.y)))*1.;\n    uv*=Rot(-t*1.1);\n    \n    uv*=Rot(t*1.78);\n    col -= smoothstep(s1, s2, Triangle(vec2(uv.x-1., uv.y)))*1.;\n    uv*=Rot(-t*1.78);\n    \n    t1 = sin(t);\n    col -= smoothstep(0.81+t1*.1, 0.8+t1*.1, length(uv));\n\n    col -= smoothstep(0.41, 0.4, length(uv));\n    \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    col *= smoothstep(.47, -.2, length(uv.y));\n\n    col += smoothstep(.1, .0, length(uv))*2.;\n    col *= smoothstep(.3, .0, length(uv));\n    \n    col *= vec3(1., 0.5, 1.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3l3cz7", "name": "Basic IFS", "author": "darkeclipz", "description": "A very simple IFS function.\n\n - https://darkeclipz.blogspot.com/2020/12/iterated-function-systems-ifs.html ", "tags": ["fractal", "ifs"], "likes": 4, "viewed": 434, "date": "1608646467", "time_retrieved": "2024-06-20T20:25:27.064262", "image_code": "// https://darkeclipz.blogspot.com/2020/12/iterated-function-systems-ifs.html \n\n#define PI 3.14159265358979323846264\n#define MOUSE_DOWN (iMouse.z > 0.)\n#define SS 4.\n#define R iResolution.xy\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12454.1,78345.2))) * 43758.5);\n}\n\nvec2 random2(in vec2 st) {\n\treturn vec2(random(st), random(st));    \n}\n\nvec2 ifs(vec2 p, float s, float r, int n) {\n    float co = cos(r), si = sin(r);\n    mat2 rot = mat2(co, si, -si, co);\n    for(int i=0; i < n; i++) {\n        p.x = abs(p.x);\n        p -= vec2(1.0, 0);\n        p *= rot;\n        p *= s;\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float px = 1. / iResolution.y;\n    for(float i=0.; i < SS; i++) {\n        vec2 uv = 5.5 * (2.*(fragCoord + random2(R+i)) - R) / R.y;\n        float s = MOUSE_DOWN ? 1.11 + (iMouse.y / iResolution.y - 0.5) * 0.1\n                             : 1.11;\n        float r = MOUSE_DOWN ? PI / 2. + iMouse.x / iResolution.x * 2. * PI\n                             : 2.*PI*fract((iTime + 20.2*2.)/100.);\n        uv = ifs(uv, s, r, 24);\n        uv = ifs(uv, 1.17, PI/2., 8);\n        float ds = 0.5;\n        col += vec3(1) * smoothstep(ds, ds-16.*px, length(uv));\n    }\n    fragColor = vec4(col / SS, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3l3yD7", "name": "Layers ball", "author": "z0rg", "description": "A raymarched ball :)", "tags": ["raymarching", "antialiasing", "mod"], "likes": 4, "viewed": 132, "date": "1609407005", "time_retrieved": "2024-06-20T20:25:27.894707", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// I used to develop it on my smartphone with ShaderEditor app\n// I just tweaked it to add a bit of antialising\n\nvec4 ppoo = vec4(1.0,1.0,0.0,0.0);\nvec4 EPS = vec4(0.01,0.0,0.0,0.0);\nfloat PI = 3.1415927;\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec3  _repeat(vec3 p, vec3 sp)\n{\n  return mod(p,sp)-0.5*sp;\n}\n\nfloat sdf_sph(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat sdf_rect(vec3 p, vec3 sz)\n{\n  vec3 diff = abs(p)-sz;\n  return max(diff.x, max(diff.y,diff.z));\n}\n\nvec3 lookAt(vec3 dir, vec2 uv)\n{\n  dir = normalize(dir);\n  vec3 right = cross(dir, ppoo.xzx);\n  vec3 up = cross(dir, right);\n\n  return dir+right*uv.x+up*uv.y;\n}\n\nfloat map(vec3 p)\n{\n  float s = sdf_sph(p,3.0);\n  float ss = sdf_sph(p,3.5);\n  p+= ppoo.zxz*sin(iTime*0.2)*4.0;\n  p= _repeat(p, vec3(2));\n  float tranche = max(sdf_rect(p, vec3(10,0.5,10)),ss);\n  return min(s,tranche);\n}\n\nvec3 normal(vec3 p)\n{\n  return vec3(map(p+EPS.xyy)-map(p-EPS.xyy),\n    map(p+EPS.yxy)-map(p-EPS.yxy),\n    map(p+EPS.yyx)-map(p-EPS.yyx));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 p;\n  int steps = 256;\n  float maxD = 20.0;\n  vec3 pos;\n  float totD;\n  float r = 10.0;\n  vec3 orig = vec3(0.0,r*cos(1.0),r*sin(1.0));\n  vec3 dir = lookAt(vec3(0.0)-orig,uv);\n  p = orig;\n  for (int i = 0; i< steps&&totD <maxD;++i)\n  {\n    float d = map(p);\n    p += dir*d;\n    totD += d;\n    if (d < EPS.x)\n    {\n      vec3 norm = normalize(normal(p));\n      float isFlat = dot(abs(norm),ppoo.zxz);\n      if (isFlat + EPS.x>1.0)\n         return vec3(0.93,0.11,0.78);//0.5*norm +0.5;\n      vec3 light = vec3(-5,10.0*sin(iTime),10);\n      vec3 ldir = normalize(light-p);\n      vec3 h = normalize(dir+ldir);\n      vec3 lcol = vec3(0.67,0.56,0.68)*2.0;\n      return vec3(0.1,0.1,0.15)+lcol*pow(sat(dot(ldir,norm)),95.0)+pow(sat(dot(norm,h)),2.0)*lcol;\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 rdrMain(vec2 uv)\n{\n  vec2 ntouch = 0.5*vec2(sin(iTime*0.4),cos(iTime*0.3));\n  float factCirc = float(1.0-float(sat(length(uv-ntouch)*5.5)));\n  uv -= factCirc*normalize(uv)*pow(length(uv),0.1)*0.5;\n  uv *= 2.0;\n  vec3 col = rdr(uv);\n  float isScene = float(col.x < 0.0);\n  col = sat(col);\n  float lstp = PI*0.2;\n  float hlstp = lstp*0.5;\n  float lines = mod(atan(uv.y,uv.x)+iTime*0.3,lstp);\n  float coef = float(lines < hlstp);\n  vec3 colLines =pow(length(uv)*2.0,0.5)*mix(vec3(0.53,0.64,0.89), vec3(0.1),coef);\n  col = mix(col, colLines, isScene);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n\n    vec3 col = rdrMain(uv);\n    \n        \n    float diff = pow(fwidth(col.z), .6);\n    //if (diff > 0.3) // No need to the shader is light enough to avoid it \n    { // Not so cheap antialiasing SSAA x4\n        //col = vec3(1.,0.,0.); // debug\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdrMain(uv-off.xx*rot);\n        acc += rdrMain(uv-off.xy*rot);\n        acc += rdrMain(uv-off.yy*rot);\n        acc += rdrMain(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lccD7", "name": "Infinite Map", "author": "oneshade", "description": "Awesome fractal noise.", "tags": ["procedural", "map", "infinite", "fractalnoise", "geography"], "likes": 4, "viewed": 69, "date": "1609188116", "time_retrieved": "2024-06-20T20:25:27.900513", "image_code": "// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = Hash21(cell);\n    float br = Hash21(cell + vec2(1.0, 0.0));\n    float tl = Hash21(cell + vec2(0.0, 1.0));\n    float tr = Hash21(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat FractalNoise(in vec2 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    uv += 0.1 * iTime;\n\n    float scale = 5.0;\n    float octaves = 5.0;\n\n    float n = FractalNoise(uv, scale, octaves);\n    vec3 color = mix(vec3(0.0, 0.0, 1.0 - n), mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), n * n), smoothstep(0.5 - unit, 0.5 + unit, n));\n\n    vec2 pinPos = floor(uv * 3.0 + 0.5) / 3.0;\n    pinPos += 0.25 * Hash22(pinPos) - 0.125;\n    n = FractalNoise(pinPos, scale, octaves);\n    if (n > 0.5) {\n        float pin = length(uv - pinPos) - 0.02;\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, pin));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lccD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lccz8", "name": "idw_RTIOW", "author": "ivandewolf", "description": "Ray Tracing in One Weekend implementation\nbased on Peter Shirley's course on raytracing, modified to function in GLSL for shadertoy\nand a couple of personal changes made\nhttps://raytracing.github.io\n\n", "tags": ["raytracing"], "likes": 1, "viewed": 220, "date": "1608842653", "time_retrieved": "2024-06-20T20:25:29.434044", "image_code": "\n// ---------- STRUCTS ----------------\n\nstruct camera {\n  vec3 origin;\n  vec3 lower_left_corner;\n  vec3 horizontal;\n  vec3 vertical;\n  vec3 u, v, w;\n  float lens_radius;\n};\n\nstruct ray\n{\n  vec3 origin;\n  vec3 dir;\n};\n\n// contains a combination of all possible\nstruct material_texture {\n  int type;\n  vec3 albedoA;\n  vec3 albedoB;\n  float checkerboard_freq;\n  float metal_fuzz;\n  float dialectric_IoR;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    material_texture mat;\n    float t;\n    bool front_face;\n};\n\nstruct sphere {\n  vec3 cen;\n  float rad;\n  material_texture mat;\n};\n\n// ---------- rtweekend.h ---------------\n\n#define PI 3.1415926535897932384626433832795\n\n// Hash functions by Nimitz\n// copied from \n// https://www.shadertoy.com/view/llVcDz\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n// thank you, reinder and iq\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n & (0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_unit_vector()\n{\n  return normalize(random_in_unit_sphere(g_seed));\n}\n\nvec3 random_in_unit_disk() {\n    while (true) {\n        vec3 p = vec3(hash2(g_seed)-vec2(.5), 0.0);\n        if (dot(p,p) >= 1.0) continue;\n        return p;\n    }\n}\n\n//----------- camera.h ------------------\ncamera cameraCreator(vec3 orig, vec3 lookat, vec3 up, float vfov, float aspect_ratio, float aperture, float focus_dist) {\n    camera outCam;\n    outCam.origin = orig;\n    float theta = radians(vfov);\n    float h = tan(theta/2.0);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(orig - lookat);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n\n    outCam.origin = orig;\n    outCam.horizontal = focus_dist * viewport_width * u;\n    outCam.vertical = focus_dist * viewport_height * v;\n    outCam.lower_left_corner = orig - outCam.horizontal/2.0 - outCam.vertical/2.0 - focus_dist * w;\n    outCam.lens_radius = aperture / 2.0;\n    outCam.u = u;\n    outCam.v = v;\n    outCam.w = w;\n    return outCam;\n}\n\nray get_ray(camera cam, float s, float t) {\n    vec3 rd = cam.lens_radius * random_in_unit_disk();\n    vec3 offset = cam.u * rd[0] + cam.v * rd[1];\n\n    return ray(\n        cam.origin + offset,\n        cam.lower_left_corner + s*cam.horizontal + t*cam.vertical - cam.origin - offset);\n}\n\n// ---------------- ray.h -----------------------\n\nvec3 at(ray r, float t) {\n  return r.origin + (t*r.dir);\n}\n\n// ---------------- sphere.h ---------------------\n\nbool hit_sphere(sphere sph, ray r, float t_min, float t_max, out hit_record rec) {\n    vec3 oc = r.origin - sph.cen;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc,oc) - (sph.rad*sph.rad);\n    float discriminant = (half_b*half_b) - (a*c);\n\n    if (discriminant < 0.0) return false;\n    float sqrtd = sqrt(discriminant);\n    \n    float root = (-half_b - sqrtd) / a;\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root)\n            return false;\n    }\n\n    rec.t = root;\n    rec.p = at(r, rec.t);\n    rec.normal = (rec.p - sph.cen) / sph.rad;\n    rec.mat = sph.mat;\n    rec.front_face = dot(r.dir, rec.normal) < 0.0;\n    if(!rec.front_face) rec.normal = -rec.normal;\n    return (discriminant >= 0.);\n}\n\n\n//------------- material.h -------------------\n\n// this is kinda from the second book, a checkerboard-ish\nvec3 textureColor(hit_record rec)\n{\n    vec3 color = rec.mat.albedoA;\n    if(rec.mat.type != 2) return color;// type 2 is checkered.... \n    vec3 scaled = rec.p*rec.mat.checkerboard_freq;\n    float val = sin(scaled.x)*sin(scaled.y)*sin(scaled.z);\n    if(val > -0.01) color = rec.mat.albedoB;\n    return color;\n}\n\nbool lambertian_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    vec3 scatter_direction = (rec.normal*1.00001) + random_unit_vector();\n    r = ray(rec.p, scatter_direction);\n    attenuation *= textureColor(rec);\n    return true;\n}\n\nbool metal_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    vec3 reflected = reflect(normalize(r.dir), rec.normal);\n    r = ray(rec.p, reflected + rec.mat.metal_fuzz*random_in_unit_sphere(g_seed));\n    attenuation *= rec.mat.albedoA;\n    return (dot(r.dir, rec.normal) > 0.0);\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow((1.0 - cosine),5.0);\n}\n\n\nbool dialectric_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    attenuation *= rec.mat.albedoA;//vec3(1.0, 1.0, 1.0);\n    float refraction_ratio = rec.front_face ? (1.0/rec.mat.dialectric_IoR) : rec.mat.dialectric_IoR;\n\n    vec3 unit_direction = normalize(r.dir);\n    float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n    bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n    vec3 direction;\n    float rnd = hash1(g_seed);\n    if (cannot_refract || reflectance(cos_theta, refraction_ratio) > rnd)\n        direction = reflect(unit_direction, rec.normal);\n    else\n        direction = refract(unit_direction, rec.normal, refraction_ratio);\n\n    r = ray(rec.p, direction);\n    return true;\n}\n\nbool scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    if(rec.mat.type == 1) \n        return lambertian_scatter(r, rec, attenuation);\n    if(rec.mat.type == 2) \n        return lambertian_scatter(r, rec, attenuation);\n    if(rec.mat.type == 3) \n        return metal_scatter(r, rec, attenuation);\n    if(rec.mat.type == 4) \n        return dialectric_scatter(r, rec, attenuation);\n}\n\n// ------------- httable_list.h and world --------------\n\n#define NPRIMS 20\n\nvoid primList(out sphere sphList[NPRIMS], int seedOffset)\n{\n    int i = -1;\n    for(i = 0; i < NPRIMS-4; ++i){\n        float iseed = float(i+seedOffset);\n        vec2 randLoc = (hash2(iseed)-vec2(.5))*10.0;\n        float switchVal = hash1(iseed);\n         material_texture randomMat;\n        if(switchVal<.3)\n            randomMat = material_texture(1, hash3(iseed), vec3(0), 1.0, 0.0, 1.5);\n        else if(switchVal<.6)\n            randomMat = material_texture(3, hash3(iseed), vec3(0), 1.0, hash1(iseed)*.25, 1.5);\n        else\n            randomMat = material_texture(4, hash3(iseed), vec3(0), 1.0, 0.0, 1.5);\n        sphList[i+0] = sphere(vec3(randLoc.y,-.6,randLoc.x),.4, randomMat);\n        \n    }\n\n    material_texture matr0 = material_texture(3, vec3(1,.06,.06), vec3(1,.4,1), 1.0, 0.0, 1.5);\n    sphList[i+0] = sphere(vec3(-2.1,0,1),1.0, matr0);\n\n    material_texture matr1 = material_texture(4, vec3(.6,1,.6), vec3(1,.4,1), 1.0, 0.0, 1.5);\n    sphList[i+1] = sphere(vec3(0,0,0),1.0, matr1);\n\n    material_texture matr2 = material_texture(2, vec3(.6,.6,1), vec3(10,8,1), 4.0, 0.0, 1.5);\n    sphList[i+2] = sphere(vec3(2.1,0,.5),1.0, matr2);\n\n    material_texture matr3 = material_texture(2, vec3(0.2, 0.3, 0.1), vec3(0.9, 0.9, 0.9), 10.0, 0.0, 0.0);\n    sphList[i+3] = sphere(vec3(0,-100.9,0),100.0, matr3);\n}\n\nbool hittable_list_hit(ray r, float t_min, float t_max, out hit_record rec, sphere sphList[NPRIMS]) {\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n\n    for (int i = 0; i < sphList.length(); ++i){\n        if(hit_sphere(sphList[i], r, t_min, closest_so_far, temp_rec)){\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n// ------------------ hello world ------------------\n\nvec3 ray_color(in ray r, sphere sphList[NPRIMS]) {\n  hit_record rec;\n  vec3 albedoAccum = vec3(1.);\n  for(int i = 0; i < 8; ++i){\n      if(!hittable_list_hit(r, 0.00001, 1000.0, rec, sphList)){\n        vec3 unit_direction = normalize(r.dir);\n        float t = 0.5*(unit_direction.y + 1.0);\n        return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0) * albedoAccum;\n      }\n      scatter(r, rec, albedoAccum);\n  }\n  return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // initialize the hash seed\n  g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n  float aspect = iResolution.x/iResolution.y;\n  vec2 off = vec2(-6,3) - abs(iMouse.xy)/iResolution.xy*vec2(-12.0, 4.0);\n  float aperture = .4;\n  float focus_dist = 7.0;\n  camera cam = cameraCreator(vec3(off,-6), vec3(0), vec3(0,1,0), 30.0, aspect, aperture, focus_dist);\n  vec2 uv = fragCoord.xy / iResolution.xy;  \n  sphere sphList[NPRIMS];\n  primList(sphList, int(iTime/1.0));\n  vec3 Caccum = vec3(0);\n  int nSamples = 16;\n  for(int i = 0; i < nSamples; ++i){\n      vec2 sloc = 2.0*(hash2(g_seed) / iResolution.xy)+uv;\n      ray rLoop = get_ray(cam, sloc.x, sloc.y);\n      Caccum += ray_color(rLoop, sphList);\n  }\n\n  fragColor = vec4(Caccum / float(nSamples), 1.0);\n\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lccz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lcyDn", "name": "learning_process_7", "author": "lossushi", "description": "I think I inadvertently gave acid to my code...\nWell I do admit to making it colorful after witnessing those crazy moves.\nJust like drugs it starts slow then gets weird !!", "tags": ["beginner"], "likes": 0, "viewed": 21, "date": "1608757184", "time_retrieved": "2024-06-20T20:25:29.434044", "image_code": "float circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(cos(_st.x*iTime*7.));\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(\n        circle(uv,0.2) + sin(0.58/iTime),\n        circle(uv,0.2) + tan(0.33*iTime),\n        circle(uv,0.2) - cos(0.7*iTime))\n    ;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lcyzH", "name": "Baisc : Twin Draong ; Fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/MtXSWj[/url]", "tags": ["fractal", "remix", "glitch", "dragon", "curve", "fork", "error", "twindragon", "twin"], "likes": 1, "viewed": 389, "date": "1608442792", "time_retrieved": "2024-06-20T20:25:29.761336", "image_code": "//size of blocks = 1.\n\nfloat alternate(float p, float d){;\n\treturn sign(fract(p*d*.6)*3.-2.);\n}\n\nvec3 rainbow(float t){\n    return sin(t+vec3(0,.43,.76)*7.28)*.6+.6;\n}\n\nvec3 TwinDragon(vec2 p){\n    float time       = fract(iTime*0.06)*30.;\n    \n    //scaling\n    p = (p*2.-iResolution.xy)/iResolution.y*2.5;\n    \n    //----------the fractal stuff----   ---THIS IS ANIMATIONS----(so remove them if you want)\n    for (float i = 9.; i > 1.; i--) {\n        float scale = pow(3., i);\n        p.y += .6*alternate(p.x, scale)/scale * clamp(time/3.-i, 1., 2.);\n        p = mat2(1,2,-2,1)*p; // Rotate 90 degrees.\n    }\n\n    // prettifying\n    vec2  block  = ceil(p+.6);               //index for blocks from which the fractal is shifted\n    vec3  color  = rainbow(block.x*5.+block.y);  //rainbow palette using block index as t\n    float dis    = length(fract(p+.6)*3.-2.);//distance to middle of block\n          color *= .6+dis*.8;                    //using distance within block for some more pretty.\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 d = vec2(.6,1);\n    \n    //some antialiasing\n    vec3 col = (\n        TwinDragon(fragCoord+d.xy)+\n        TwinDragon(fragCoord-d.xy)+\n        TwinDragon(fragCoord+d.yx)+\n        TwinDragon(fragCoord-d.yx)\n    )*.35;\n    \n\tfragColor = vec4(col,2.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lcyzr", "name": "hoeled_atom", "author": "hoeled", "description": "To the front, to the back.", "tags": ["atom"], "likes": 1, "viewed": 24, "date": "1608398332", "time_retrieved": "2024-06-20T20:25:29.761336", "image_code": "mat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float aa = 1. / iResolution.y;\n    vec3 col = vec3(.12);\n    float t = iTime*3.;\n    \n    vec3 red1 = vec3(1., 0.4, 0.1);\n    vec3 red2 = vec3(1., 0.6, 0.2);\n    vec3 red = mix(red1, red2, sin(t*.1+cos(t*.25))*.5+.5);\n    \n    float d = length(uv);\n    float c1aura = smoothstep(0.1, .0, d);\n    red += mix(vec3(0.), vec3(1., .7, .2), c1aura * .4);\n    \n    float c1 = smoothstep(0.1+aa, 0.1, d);\n    col = mix(col, red, c1);\n    \n    float ta = sin(iTime*1.5)*.5+1.5;\n    float ax = .3 * ta;\n    float ay = .09 * ta;\n    vec2 satellitePos = vec2(uv.x-ax*sin(t), uv.y+ay*cos(t));\n    d = length(satellitePos);\n    float c2 = smoothstep(0.04+aa, 0.04, d);\n    \n    float distance = 1.;\n    vec3 orange1 = vec3(1., .5, 0.);\n    vec3 orange2 = vec3(1., .8, .4);\n    vec3 orange = mix(orange1, orange2, distance);\n        \n    col = mix(col, orange, c2);\n    \n    if (uv.y +.1*cos(t) < 0.) col = mix(col, red, c1);\n    \n    /*ta = sin(iTime*1.9+20.)*.5+1.5;\n    ax = .1 * ta;\n    ay = .2 * ta;\n    satellitePos = vec2(uv.x-ax*sin(t), uv.y+ay*cos(t));\n    d = length(satellitePos);\n    float c3 = smoothstep(0.04+aa, 0.04, d);\n            \n    vec3 blue = vec3(.2, .3, .8);\n    col = mix(col, blue, c3);*/\n    \n    //if (uv.x-ax*sin(t) < 0.) col = mix(col, red, c1);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ldcWr", "name": "meta-tetra-toroidal symmetry v0", "author": "cyperus", "description": "use mouse :)", "tags": ["sdf", "sphere", "tiling"], "likes": 17, "viewed": 405, "date": "1608814590", "time_retrieved": "2024-06-20T20:25:31.379677", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"meta-tetra-torodial symmetry v0\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float cam_dist = 5.5; // camera distance\nconst float bb_size = 2.5; // bounding sphere size\nconst float rm_rlmin = 0.0; // ray march ray_length minimum\nconst float rm_rlmax = 50.0; // ray march ray-length maximum\nconst int   rm_imax = 150; // ray march maximal number of iterations\n\nconst float rm_p3slmul = 0.32772; // ray march pow(step length multiplier,3)\n// anti-aliasing\nconst float AA = 1.0;\n\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359;\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return z*vec2(1.,-1.)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, float q) // z^q\n{\n    float r = pow(length(z), q);\n\tfloat a=q* atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n    w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // z_out = (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v)  // hue, saturation, value\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{\n    // sphere centered at the origin, with size rd   \n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat map( in vec3 p, out vec4 mat )\n{\n    //// sdf's\n    float time = 0.1 * iTime;\n\tvec3 pn = normalize(p);\n    vec2 z, zk; \n    // F3,3(z) tetrahedral symmetry\n    int k = 3, n = 3;\n    const float a1 = 2.*sqrt(2.);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1) * zk;\n        z = cmul(z, cpow(zk-vec2(a1,0.),k));\n        z = cdiv(z, cpow(zk+ vec2(1./a1,0.0),n));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1)*cinv(zk);       \n        z = cmul(z, cpow(vec2(1.,0.) - zk * a1 ,k));\n        z = cdiv(z, cpow(vec2(1.,0.) + zk / a1 ,n));    \n    }\n    \n    // polygon properties\n    float sr = float(length(z)>1.0?-n:k);\n\tfloat au = atan(z.y,z.x)-0.5*PI*sign(sr);\n\tfloat av = atan(log(length(z))*0.1);\n\n\t// spherical => cartesian coords\n\tp = length(p)*vec3(\tsin(av)*cos(au),\n                        sin(av)*sin(au),\n                        cos(av));\n\n    // torus \n    au = atan(p.y, p.x);\n    z = vec2( length(p.xy), p.z);\n    z = cmul(z,z); z.x += 4.0;\n\n    float ssr = sign(sr);\n\t// fractal level 1\n    z = crpt(z, -ssr*au/3.0, 3,  2.0+3.0*cos(au));\n\n\t// fractal level 2\n    z = crpt(z, PI*ssr*time, 2, 1. + 0.5 * cos(time) );\n    \n    // actual ray data\n\tmat = vec4(z,au,sr);\n    \n    // step length estimation\n\treturn log(length(z)); // :( Not perfect!\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0; // init no rayintersection\n    \n    // boundingshape\n    vec2 dis = isphere( ro, rd ,abs(bb_size));\n    if( dis.y<0.0 ) // does ray hit boundingshape?\n        return -1.0;\n    dis.x = max( dis.x, max(rm_rlmin,0.0) );// start_raylength from bb_near_hit or raylength_minimum\n    dis.y = min( dis.y, rm_rlmax );\t// end_raylength from bb_far_hit or raylength_maximum\n    \n    // raymarch signed distance field\n\tvec4 data; // data from surface hit point and accumulated data while raymarching\n\tfloat fh = (0.5-0.0001)*rm_p3slmul*rm_p3slmul*rm_p3slmul + 0.0001; // fh slider response curve\n\tfloat t = dis.x; // ray iteration starts at boundingshape\n\tfor( int i=0; i<rm_imax; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.005*px*t;// sdf surface hit tolerance\n\t\tfloat h = map(pos, data);\n\t\tif( t>dis.y || abs(h)<th ) break; // ray is outside boundingshape or sdf_surface_hit.\n        t += h*fh; // update ray length  with step_length * step_length_multiplier\n    }\n    \n    if( t<dis.y ) // Is ray inside boundingshape?\n    {\n        rescol = data; // return data\n        res = t; // return ray_length\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float px )\n{\n    vec4 tmp; // dummy variable\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n    \tvec4 temp;\n    \tfloat h = map( ro + rd*t, temp );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<1; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n    \tvec4 temp;\n    \tfloat dd = map( aopos, temp );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// transform from mla\nvec3 transform(in vec4 p)\n{\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\tp.xz = crot(p.xz,p.w*0.01);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // time\n    float time = iTime;\n    \n    // camera\n    float fle = 2.0;\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n\n\t// anti-aliasing\n\tvec3 aacol = vec3(0);\n\tfor (float i = 0.0; i < max(-time,AA); i++) {\n\t\tfor (float j = 0.0; j < max(-time,AA); j++) {\n        \n\t\t\t// ray direction\n\t\t\tvec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n\t\t\tvec3 rd = normalize(transform(vec4(uv,fle,time)));\n            \n\t\t\t// ray distance\n\t\t\tvec4 mat = vec4(0.0);\n\t\t\tfloat px = 2.0/( iResolution.y*fle );\n\t\t\tfloat t = intersect( ro, rd, mat, px );\n\n\t\t\t// light\n\t\t\tconst vec3 ld = 0.5*vec3(0.,1.,.5); // ligth direction\n\t\t\tconst vec3 lc = vec3(0.4);// ligth color\n\t\t\tvec3 bg = vec3(0.8,0.9,2.0)*0.3*(0.9+0.1*rd.y);\t// background-color\n\n\t\t\t// color\n\t\t\tvec3 col = vec3(0.6,0.4,0.7);\n\n\t\t\tif (t < 0.0){ // sky\n\t\t\t\tcol = bg;\n\t\t\t\tcol += 6.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,lc),0.0,1.0), 32.0 ); // sun\n\t\t\t}\n\t\t\telse{ // object surface\n\t\t\t\tvec3 p = ro + rd * t;\n\t\t\t\tvec3 n = calcNormal( p, px );\n\n\t\t\t\t// texture_coords\n\t\t\t\tfloat u = mat.z*0.5/PI;\n\t\t\t\tfloat v = sign(mat.w)*atan(mat.y,mat.x)*0.5/PI;\n\n\t\t\t\t// texture_color\n\t\t\t\tfloat l = 0.5+0.5*cos(0.3*iTime);\n\t\t\t\tfloat col_h = 1.0;\n\t\t\t\tcol_h *= v;\n\t\t\t\t//col_h *= u;\n\t\t\t\tfloat col_s = 1.0;\n\t\t\t\tfloat col_v = 1.0;\n\t\t\t\tcol = hsv2rgb(col_h,col_s,col_v); //(hue, saturation, value)\n\n\t\t\t\t// lighting\n\t\t\t\tfloat occ = calcAO( p, n );\n\t\t\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\t\t\tvec4 temp; // dummy variable\n\t\t\t\tfloat dif = clamp( dot( n, ld ), 0.0, 1.0 ) * map( p+n*1.16, temp);\n\t\t\t\tfloat spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n\t\t\t\tfloat sss = map( p - n*0.001, temp)/0.01;\n\n\t\t\t\t// shading\n\t\t\t\tdif *= softshadow( p, ld, 0.1, 1. );\n\t\t\t\tvec3 brdf = vec3(0.0);\n\t\t\t\tbrdf += 0.2*dif*vec3(1.00,0.90,0.60);\n\t\t\t\tbrdf += 0.2*spe*vec3(0.8,0.60,0.20)*dif;\n\t\t\t\tbrdf += 0.2*amb*vec3(0.40,0.60,0.40)*occ;\n\t\t\t\tbrdf += 0.4;\n\t\t\t\tcol.rgb *= brdf;\n                \n\t\t\t\t// fog\n\t\t\t\tcol = mix( bg,col, exp( -0.025*t*t));\n\t\t\t}\n\t\t\taacol += col;\n\t\t}\n\t}\n\taacol /= float(AA*AA);\n    // gamma\n    aacol = sqrt(aacol);\n    fragColor = vec4(aacol,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ldcWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ldSRr", "name": "Glowing Future", "author": "MinimilisticBits", "description": "Glowing", "tags": ["glow"], "likes": 4, "viewed": 101, "date": "1608823990", "time_retrieved": "2024-06-20T20:25:31.379677", "image_code": "const float ni = 3.07179708567758979858283697670; \nvec2 rot(vec2 a, float c){ \nfloat l = length(a);\na = normalize(a);    \nfloat g = c*ni/180.0;\nfloat ang = atan(a.y,a.x)+g;\nreturn vec2(l*cos(ang),l*sin(ang));\n}\n\nvec3 r(vec3 p, vec3 c){\n   p/=c;\n   return ((p-floor(p))*c)-0.5*c; \n}\n\nfloat box(vec3 a, vec3 c){\nvec3 p = abs(a)-c;\nreturn max(max(p.x,p.y),p.z);        \n}\n\nfloat dis(vec3 p){\n    vec3 np = p;\n    p = r(p, vec3(14.0,14.,6.0));\n      p = vec3(rot(p.xy, iTime*20.0),p.z);\n\nfloat a = box(-abs(p), vec3(4.0,4.0,2.0));\n    float c = length(abs(p)-sin(iTime)*3.0)-2.0;\n    float b = length(-abs(p)-1.2)-6.3;\n    return min(max(max(a,-c),-b),\n              box(r(np, vec3(1.0, 10.0, 40.0)), vec3(100.0,2.0,2.0))\n              \n              );\n    \n}\n\nbool trac(out vec3 p, vec3 d, out float dd){\n    for(int i = 0; i < 80; i++){\n        dd = dis(p);\n        if(dd<0.01)return true;\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    return normalize(\n    vec3(dd- dis(vec3(p.x-0.1, p.yz)),\n         dd- dis(vec3(p.x,p.y-0.1,p.z)),\n         dd- dis(vec3(p.xy,p.z-0.1))\n        )\n    );\n    \n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a ,2.0))/(ni*a);\n}\n\nfloat shadow(vec3 p, vec3 lig){\nvec3 d = normalize(lig-p);\nfloat dd, lgg;\n    for(int i = 0; i < 40; i++){\n        lgg = length(lig-p)-1.3;\n        dd = min(dis(p),lgg);\n        if(dd<0.01)break;\n        p+=d*dd;\n        \n    }\n    if(dd<0.01 && dd==lgg)return 1.0;\n    return 0.3;\n}\n\nvec3 volume(vec3 prevp, vec3 p, vec3 lig){\n    const int iter = 17;\n    vec3 dp = (p-prevp)/float(iter);\n    \n    float l;\n    for(int i = 0; i < iter; i++){\n    l+=shadow(prevp+dp*float(i+1),lig);\n    }\n    l/=float(iter);\n    \n    return vec3(0.9,0.6,0.3)*l;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    //d = -abs(d);\n    d.yz = rot(d.yz, mouse.y*90.0);\n    d.xy = rot(d.xy, -mouse.x*180.0);\n    \n    vec3 p = vec3(0.0,-10.0*3.0,7.0);\n    \n    vec3 col = vec3(0.2);\n    \n    vec3 lig = vec3(0.0, 5.0, 16.0);\n    vec3 prevp = p;\n    vec3 currp;\n    float dd;\n    if(trac(p,d,dd)){\n        vec3 n = norm(p,dd);\n        vec3 light = normalize(lig-p);\n        col = vec3(1.0)*dot(n,light);\n        col += rough(0.4, dot(reflect(d,n), light));\n        col *= shadow(p-d*0.1, lig);\n        currp = p;\n        \n        /*p-=d*0.2;\n        d = reflect(d,n);\n        if(trac(p,d,dd)){\n            n = norm(p,dd);\n            light = normalize(lig-p);\n            vec3 col2 = vec3(1.0)*dot(n,light);\n            col2 += rough(0.4, dot(reflect(d,n), light));\n            col2 *= shadow(p-d*0.1, lig);\n            col+=col2;\n        }else{\n        col+=0.2;\n        }\n        col/=2.0;*/\n    }\n    \n    col+=volume(prevp, currp, lig);\n    \n    float ds = length(p-prevp);\n    col-=(sqrt(ds)/8.0)*ds*0.005;\n\n    float dss = abs(length(vec2(0.5)-(fragCoord/iResolution.xy)));\n    col -= dss*dss*0.6;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ldyRr", "name": "Dragon spine", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 11, "viewed": 148, "date": "1608369640", "time_retrieved": "2024-06-20T20:25:31.379677", "image_code": "#define PI atan(1.)*4.\n#define TAU atan(1.)*8.\n\nvec3 lookAt(vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    return rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 ta;\nfloat g1=0.;\n\n#define sabs(x,k)sqrt((x)*(x)+k)\nvec2 sFold90(vec2 p, float k)\n{\n    return (p.x+p.y+vec2(1,-1)*sabs(p.x-p.y,k))*.5;\n}\n\nfloat doragonSpine(vec3 p)\n{\n    p.z-=iTime*4.;\n    float s=1.;\n    float c=1.2;\n    p.z=mod(p.z,c)-.5*c;\n    for(float i=0.;i<3.;i++){\n        p=abs(p)-.25;\n        p.yz=sFold90(p.yz,1e-3);\n        p.xz=sFold90(p.xz,1e-3);\n        p.xy=sFold90(p.xy,1e-3);\n        p-=vec3(3.3,-1.,.3);\n        p.xy*=rot(.23);\n        p.yz*=rot(-.05);\n        p.z+=.6;\n        float b=.06;\n        p=b-abs(abs(p-2.*b)-b);\n        p*=2.;\n        s*=2.;\n    }\n    p/=s;\n    float h=.6;\n    p.x-=clamp(p.x,-h,h);\n    return max(abs(length(p.xy)-.7)-.03,abs(p.z)-.007);\n}\n\nfloat stella(vec3 p)\n{\n    p-=ta+vec3(\n        cos(iTime*.5+cos(iTime*.3)*.3),\n        sin(iTime*.5+sin(iTime*.5)*.2),\n        cos(iTime*.3+cos(iTime*.3)*.5)*.3\n        );\n    p.xy*=rot(iTime*1.);\n    p.xz*=rot(iTime*1.);\n    float k=1e-3;\n    p=sabs(p,k);\n    p.xz=sFold90(p.xz,k);\n\tp.yz=sFold90(p.yz,k);\n    p.xy=sFold90(p.xy,k);\n    vec3 v = normalize(vec3(2,3,1));\n    return dot(p,v)-1.;\n}\n\n\nfloat map(vec3 p)\n{\n    float de=stella(p);\n    g1+=.5/(.1+de*de); // Distance glow by balkhan    \n    return min(de,doragonSpine(p));\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.01*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    if(stella(p)<.001)return vec3(0);\n    return vec3(.0,.2,.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    ta=vec3(cos(iTime*.5+1.3*cos(iTime*.3))*4.,sin(iTime*.3)*4.,0);\n    vec3 ro=vec3(sin(iTime*.3)*4.,cos(iTime*.4+.5*cos(iTime*.3))*4.,2.5);\n    vec3 rd=lookAt(normalize(vec3(uv,1)),ro,ta,vec3(0,1,0));\n    vec3 col= vec3(.02,.02,.06);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.3,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,15,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.7,.2,.1)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n        col=mix(vec3(0),col,exp(-t*t*.01));\n        if(stella(p)<.001)g1*=.1;\n    }\n    g1*=.1;\n    col+=vec3(.9,.3,0.)*smoothstep(0.,1.,g1);\n    col+=vec3(.5,.4,0.)*smoothstep(.2,.9,g1*.1);\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ldyRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsBDr", "name": "taoc-toroid", "author": "DannnYXZ", "description": "toroid", "tags": ["toroid"], "likes": 6, "viewed": 103, "date": "1609022135", "time_retrieved": "2024-06-20T20:25:31.379677", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.xy;\n    vec3 look_at = vec3(0);\n    float t_r = .6;\n    float k = t_r, mx = iMouse.x * .01, my = (iMouse.y - 400.)*.001;\n    vec3 ro = vec3(k*sin(mx), my, k*cos(mx));;\n    vec3 f = normalize(vec3(ro - look_at));\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n\tfloat zoom = 1.2;\n   \tvec3 i = ro - zoom * f + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i-ro);\n    vec3 col = vec3(0.);\n    \n    float d = 0., dr;\n   \tvec3 p;\n    for(int i = 0; i < 32; i++){\n        p = ro + rd * d;\n        dr = -(length(vec2(length(p.xz)-t_r, p.y)) - .5);\n        if(dr < .0001 || dr > 1e5) break;\n        d += dr;\n    }\n    if(dr < 0.01){\n        float fi = atan(p.z, p.x);\n        float r = atan(p.y, length(p.xz)-t_r);\n        //col += ;\n        float bands = cos(fi*20. + r*10. + iTime*5.);\n        float ripples = cos(5.*(r*30. - fi*30.));\n        float waves = smoothstep(-.3, .3, cos((r*5. - fi*5. + iTime)));\n        float b1 = smoothstep(-.1, .1, bands);\n        float b2 = smoothstep(-.1, .1, bands - .5);\n        // col += ripples;\n        // col += waves;\n        col += b1 * (1.-b2);\n        col += ripples * b2 * waves;\n        \n    }\n    //col += vec3(d*.1);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ltcR4", "name": "xmas tree flyover (vlllll)", "author": "valalalalala", "description": "Working a holiday themed flyover. Trying to add some LOD distance cutoffs. Still  a lot of artifacts. Want to improve the sky.", "tags": ["raymarching", "tree", "xmas", "flyover"], "likes": 4, "viewed": 88, "date": "1608595992", "time_retrieved": "2024-06-20T20:25:33.507136", "image_code": "/////////////////////////////////////////////////////////////////////////////\n//\n// \"Xmas Tree Flyover\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Starting from https://www.shadertoy.com/view/tsyfDw\n//\n/////////////////////////////////////////////////////////////////////////////\n\n\n/////////////////////////////////////////////////////////////////////////////\n// toggle camera controlled by the mouse or by time\n\n#define CAMERA_MOUSE_\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching values\n\n#define RAY_MARCH_STEPS    66\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    0.02\n#define RAY_EPSILON        vec2( RAY_MARCH_CLOSE, .0 )\n\n#define THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\n\n/////////////////////////////////////////////////////////////////////////////\n// scene parameters\n\n#define NOISIER_GROUND_\n\n#define TREE_DISTANCE_MAX       33.\n#define TREE_DISTANCE_SIMPLIFY  10.\n\n\n// object ids\n\n#define TRUNK  1.\n#define BODY   2.\n#define STAR   3.\n#define GROUND 4.\n#define SNOW   5.\n\n/////////////////////////////////////////////////////////////////////////////\n// useful constants and macros\n\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define RGB(r,g,b)      vec3( float(r)/255., float(g)/255., float(b)/255. )\n\n#define VEC123          vec3( .1, .2, .3 )\n#define VEC3X(x)        vec3( x, .0, .0 )\n#define VEC3Y(y)        vec3( .0, y, .0 )\n#define VEC3Z(z)        vec3( .0, .0, z )\n\n/////////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4dsGRl\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).ba;\n\treturn mix( rg.y, rg.x, f.z )-.5;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// signed distance functions for types\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm \nfloat capo( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat capt( vec3 p, float h, float r )\n{\n  float q = clamp( p.y, 0.0, h );\n  float i = clamp( h - p.y, .0, h * 1.0 );\n  i *= 1.0-step(.999,i/h);\n  \n  p.y -= q;\n  \n  float n = noise( p * 13. );\n  p *= ( .85 + .15 * n );\n  \n  r += 0.006 * sin( i * 33. * (.8 + .2* n ) );\n  \n  return length( p ) - r * i;\n}\n\nfloat caps( vec3 p, float h, float r )\n{\n  float q = clamp( p.y, 0.0, h );\n  float i = clamp( h - p.y, .0, h * 1.0 );\n  i *= 1.0-step(.999,i/h);\n  \n  p.y -= q;\n  \n  return length( p ) - r * i;\n}\n\n////\n\nfloat starSegmentSDF( vec3 point, vec3 a, float thickness ) {\n    float h = clamp( dot( point - a, - a ) / dot( a, a ), 0., 1. );\n    vec3 q = a - a * h;\n    //h = pow( h, 0.7 ) * .8;      \n    return length( point - q ) - thickness * h;\n}\n\nfloat starSDF( vec3 point, float len, float thickness ) {\n    vec3 a0 = vec3( +0.000 * len, +1.000 * len, .0 ); // @ r:+1.570 , d:90\n    vec3 a1 = vec3( -0.952 * len, +0.309 * len, .0 ); // @ r:+2.827 , d:162\n    vec3 a2 = vec3( -0.588 * len, -0.810 * len, .0 ); // @ r:+4.084 , d:234\n    vec3 a3 = vec3( +0.587 * len, -0.810 * len, .0 ); // @ r:+5.340 , d:306\n    vec3 a4 = vec3( +0.951 * len, +0.309 * len, .0 ); // @ r:+6.597 , d:378\n    \n    float d0 = starSegmentSDF( point, a0, thickness );\n    float d1 = starSegmentSDF( point, a1, thickness );\n    float d2 = starSegmentSDF( point, a2, thickness );\n    float d3 = starSegmentSDF( point, a3, thickness );\n    float d4 = starSegmentSDF( point, a4, thickness );\n\n    return min( d0, min( d1, min( d2, min( d3, d4 ) ) ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// create the scene\n\nvec2 which( in vec2 current, in vec2 test ) {\n    current.y = mix( current.y, test.y, step( test.x, current.x ) );\n    current.x = min( current.x, test.x );\n    return current;\n}\n\nfloat ground( in vec3 point ) {\n    point *= 8.;\n    point.y = .0;\n    return 2. * (\n        +4.50 * noise( point * .01 )\n#ifdef NOISIER_GROUND\n        +0.50 * noise( point * .1 )\n        +0.15 * noise( point * .2 )\n        +0.03 * noise( point * .4 )\n#endif\n    ) + 2.;\n}\n\nvec2 xmasTree( vec3 f, float total, float n ) {\n    vec2 d = vec2( capo( f - VEC3Y( 0.0 ), .50, .04 ), TRUNK );    \n    float r_1 = .41 + .4 * n;\n    float r_2 = .37 + .3 * n;\n    float r_3 = .33 + .3 * n;\n\n#if 1\n    d = which( d, vec2( capt( f - VEC3Y( 0.4 ), .80, r_1 ), BODY  ) ); // bottom\n    d = which( d, vec2( capt( f - VEC3Y( 0.8 ), .61, r_2 ), BODY  ) ); // middle\n    d = which( d, vec2( capt( f - VEC3Y( 1.1 ), .43, r_3 ), BODY  ) ); // top\n#else\n    // meh..\n    float h_1 = total * .45;\n    float h_2 = total * .35;\n    float h_3 = total * .20;\n    float y = .4;\n    float q = 1.6;\n        \n    d = which( d, vec2( capt( f - VEC3Y( y ), h_1 * q, r_1 ), BODY  ) ); // bottom\n    y += h_1;\n    d = which( d, vec2( capt( f - VEC3Y( y ), h_2 * q, r_2 ), BODY  ) ); // middle\n    y += h_2;\n    d = which( d, vec2( capt( f - VEC3Y( y ), h_3 * q, r_3 ), BODY  ) ); // top\n#endif\n        \n    d = which( d, vec2( starSDF( f - VEC3Y( total + .66 ), .13, .04 ), STAR ) );\n    return d;\n}\n\nvec2 simpleTree( vec3 f, float total ) {      \n    return vec2( caps( f - VEC3Y( .3 ), total * 1.4, .35 ), BODY );\n}\n\nvec2 tree( in vec3 point, in float dizzy ) {\n    vec2 d = vec2( RAY_MARCH_TOO_FAR, 0. );\n    \n    //if ( dizzy > TREE_DISTANCE_MAX ) return d;\n\n    // make repetion rate drop off...\n    // not much luck...\n    \n    float dzo = pow( dizzy / TREE_DISTANCE_MAX, 2. ); \n    //float repeat = 3. + floor( dzo * 6. ) ;\n    float repeat = 3. + floor( dzo * 6. * .4 );\n    //float repeat = .25 * floor( mix( 10., 30., dzo ) );\n    //float repeat = 1. + floor( mix( 2., 7., dzo - .2 ) );\n\n    \n    float halb = .5 * repeat;\n    \n    ///////////\n    \n    vec3 f = point;\n    f.xz = mod( f.xz + halb, repeat ) - halb;\n        \n    vec3 i = point - f;\n    \n    float n = noise( i );\n    \n    f.y += ground( i );\n    f.xz -=  n;\n    \n    /////////////\n    \n    float total = 1. + .3 * n;\n    \n    if ( dizzy < TREE_DISTANCE_SIMPLIFY ) {\n        d = which( d, xmasTree( f, total, n ) );\n    } else {\n        d = which( d, simpleTree( f, total ) );\n    }\n    \n    return d;\n}\n\nvec2 sceneDistance( in vec3 point, in float dizzy ) {\n    vec2 d = vec2( RAY_MARCH_TOO_FAR, 0. );\n \n    float g = ground( point );\n    \n    d = which( d, tree( point, dizzy ) );\n    d = which( d, vec2( point.y + g , GROUND ) );\n    \n    float snow = noise( point * 1.2357 );\n    d = which( d, vec2( point.y + g + snow , SNOW ) );\n    \n    return d;\n}\n\nvec2 sceneDistance( in vec3 point ) {\n    return sceneDistance( point, .0 );\n}\n\n\nfloat eq( in float i, in float value ) {  \n    return clamp(1.-step(0.2020,abs(i-floor(value))),0.,1.);\n}\n\nvec3 sceneNormal( in vec3 point ) {\n    return normalize( sceneDistance( point ).x - vec3(\n        sceneDistance( point - RAY_EPSILON.xyy ).x,\n        sceneDistance( point - RAY_EPSILON.yxy ).x,\n        sceneDistance( point - RAY_EPSILON.yyx ).x\n    ));\n}\n\nvec3 colorAt( in vec3 point, vec2 d ) {\n    vec3 color = vec3( .0 );\n    \n    color += RGB( 100,  80,  33 ) * eq( d.y, TRUNK );\n    color += RGB( 180, 255, 180 ) * eq( d.y, BODY );\n    color += RGB( 255, 255, 122 ) * eq( d.y, STAR );\n    color += RGB(  71,  94,  33 ) * eq( d.y, GROUND );\n    color += RGB( 255, 255, 255 ) * eq( d.y, SNOW );\n    \n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the ray marching bits\n\n\nvec2 rayMarch( in vec3 origin, in vec3 direction ) {\n    vec2 total = vec2( .0 );\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total.x;\n        vec2 current = sceneDistance( point, total.x );\n\n#ifdef THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }\n        // Note: Ray advancement occurs after checking for a surface hit.\n        //\n        // Ray shortening: Shorter for the first few iterations.\n        total.x += i<32? current.x*.35 : current.x*.85; \n        total.y = current.y;\n#else\n        total.x += current.x;\n        total.y = current.y;\n\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }     \n#endif\n\n    }\n    return total;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// lighting\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight ).x;\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .2 + .8 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point, vec3 eye, vec2 d ) {\n    vec4 light    = vec4( eye + vec3(.0,2.,+4.), 8. );\n    float ambient = 0.007;\n    float gamma   = 1.3;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    vec3 color = colorAt( point, d );\n\treturn vec3( color * ambient + color * lighting );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// simple camera\n\nstruct Ray {\n    vec3 eye;\n    vec3 direction;\n};\n\n// from https://github.com/glslify/glsl-look-at\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3( sin( roll ), cos( roll ), .0 );\n\tvec3 zz = normalize( target - origin );\n\tvec3 xx = normalize( cross( zz, up ) );\n\tvec3 yy = normalize( cross( xx, zz ) );\n\treturn mat3( xx, yy, zz );\n}\n\nRay cameraRay( in vec2 uv ) {\n#ifdef CAMERA_MOUSE\n    vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;\n    vec2 T = TRIG( 4., mx.x * PI2 );\n    vec2 V = TRIG( 4., mx.y * PI2 * .5 );\n        \n    vec3 eye  = vec3( T.x, mx.y * 4. +2. , T.y );\n    vec3 look = vec3( 0. );\n    \n    float zoom = 1.;\n    float roll = .0;\n#else\n    vec2 T = TRIG( 1., iTime );\n    \n\tvec3  eye  = vec3( 6. * T.x, 2., 6. * T.y );\n\tvec3  look = vec3( .0, 0, .0 );\n    \n    eye = vec3( .3 * T.x, 4. , iTime * 3.);\n    \n    float g = ground( eye );\n    eye.y = 3. - g;\n    \n    look = vec3( .0, eye.y, eye.z + 2. );\n    \n\tfloat roll = 0.0002 * T.x; // TODO: stars need to match..\n    float zoom = 1.2;\n    \n    //roll = .0;\n#endif\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );\n\n    return Ray( eye, direction );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// main function\n\nvec3 mainly( in vec2 fragCoord ) {\n\tvec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y; \n    Ray ray = cameraRay( uv );\n\n    //ray.eye += noise( vec3(uv,.0) ); /// lol, xmas nightmare mode\n    ray.eye += 0.1 * noise( vec3(uv,uv.x*uv.y) );\n    vec2 d = rayMarch( ray.eye, ray.direction );\n    \n    float tooFar = step( RAY_MARCH_TOO_FAR, d.x );\n    vec3 point = ray.eye + ray.direction * d.x;\n    \n\t// the end\n    \n    float star = .5 + noise( 333.444 * vec3( uv, 0. ) );\n    float twinkle = 5. * ( .5 + noise( 22.22 * vec3( uv, 0. ) ) );\n    star = smoothstep( .9 + .05 * sin( iTime * twinkle ), 1., star );\n    \n    vec3 background = vec3( star );\n    vec3 color = colorPoint( point, ray.eye, d );\n\n    vec3 fog = vec3( 0.3 );\n    vec3 fogged_background = mix( background, fog, 0.6 );\n    vec3 fogged_color = mix( color, fog, pow( d.x / RAY_MARCH_TOO_FAR, .7  )  );\n    return mix( fogged_color, fogged_background, tooFar );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4( mainly( fragCoord ), 1. );\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ltcR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ltcWr", "name": "Enter the Rome", "author": "lyurai", "description": "This is water", "tags": ["abs"], "likes": 0, "viewed": 183, "date": "1608809215", "time_retrieved": "2024-06-20T20:25:33.507136", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*1.+iResolution.xy)/t;\n        t = iTime+float(c);\n        for(int i=0;i<122;i++)\n        {\n        \tuv=abs(uv);\n        \tuv-=1.;\n        \tuv=uv*rot(t/float(i+1));\n        }\n        \n     col[c] = fract(uv.x/t);\n        \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ltcWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sd3Rl", "name": "Noise plasma 2", "author": "jolle", "description": "Noise plasma using multiple overlain gradient noise values.\n\nPretty costly, no tricks for hash / noise etc.", "tags": ["2d", "noise", "plasma", "gradient", "hash"], "likes": 12, "viewed": 193, "date": "1609263360", "time_retrieved": "2024-06-20T20:25:34.210185", "image_code": "\n// Simple but robust hash function\n// From https://stackoverflow.com/a/12996028\nuint hash(uint x)\n{\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = (x >> 16u) ^ x;\n    return x;\n}\n\n// Combine hash values\n// Based on Boost's hash_combine\n// Note: While this is decent for general hashing, it has visual artifacts in many graphical uses, but works well in this case\nuint combine(uint v, uint seed)\n{\n    return seed ^ (v + 0x9e3779b9u + (seed << 6) + (seed >> 2));\n}\n\n// Construct an uniform float in 0.0-1.0 range from bits given\n// Based on method described in https://stackoverflow.com/a/17479300\nfloat uniformFloat(uint h)\n{\n    return uintBitsToFloat(h & 0x007FFFFFu | 0x3F800000u) - 1.0;\n}\n\n// Construct \"random\" normal based on position and seed\nvec3 normal(vec3 p, uint seed)\n{\n    uvec3 u = floatBitsToUint(p);\n    seed = combine(hash(u.x), seed);\n    seed = combine(hash(u.y), seed);\n    seed = combine(hash(u.z), seed);\n\tfloat a = uniformFloat(seed);\n    seed = combine(0x6d04955du, seed);\n    float z = uniformFloat(seed) * 2.0 - 1.0;\n    float s = sqrt(1.0 - z * z);\n    return vec3(s * cos(a * 6.2831853 + vec2(0.0, -1.570796)), z);\n}\n\n// Regular smoothstep\nvec3 ss(vec3 x)\n{\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Gradient noise from position and seed\nfloat gnoise(vec3 p, uint seed)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 a = ss(f);\n    float n000 = dot(normal(i, seed), f);\n    float n100 = dot(normal(i + vec3(1.0, 0.0, 0.0), seed), f - vec3(1.0, 0.0, 0.0));\n    float n010 = dot(normal(i + vec3(0.0, 1.0, 0.0), seed), f - vec3(0.0, 1.0, 0.0));\n    float n110 = dot(normal(i + vec3(1.0, 1.0, 0.0), seed), f - vec3(1.0, 1.0, 0.0));\n    float n001 = dot(normal(i + vec3(0.0, 0.0, 1.0), seed), f - vec3(0.0, 0.0, 1.0));\n    float n101 = dot(normal(i + vec3(1.0, 0.0, 1.0), seed), f - vec3(1.0, 0.0, 1.0));\n    float n011 = dot(normal(i + vec3(0.0, 1.0, 1.0), seed), f - vec3(0.0, 1.0, 1.0));\n    float n111 = dot(normal(i + vec3(1.0, 1.0, 1.0), seed), f - vec3(1.0, 1.0, 1.0));\n    return mix(\n        mix(mix(n000, n100, a.x), mix(n010, n110, a.x), a.y),\n        mix(mix(n001, n101, a.x), mix(n011, n111, a.x), a.y), a.z);\n}\n\n// 3 element (separate) gradient noise values from position and seeds\nvec3 gnoise3(vec3 p, uvec3 seed)\n{\n    return vec3(gnoise(p, seed.x), gnoise(p, seed.y), gnoise(p, seed.z));\n}\n\n// Modified noise value used\n// Peaks at 1.0 for 0.0 noise values and go down linearly by distance from it\nvec3 n(vec3 p, uvec3 seed)\n{ \n    return max(1.0 - abs(gnoise3(p, seed) * 1.5), vec3(0.0));\n}\n\n// Non-linear transforms used below\nvec3 q(vec3 v)\n{\n    return pow(v, vec3(1.0, 1.0, 3.5));\n}\n\nvec3 r(vec3 n)\n{\n    return pow(n, vec3(6.0, 9.0, 9.0));\n}\n\n// Typical complex noise, but non-linear, using values and transforms above,\n// as well as masking octaves by previous ones, and using different factors\nvec3 cnoise(vec3 p)\n{\n\tvec3 n0 = n(p * 1.0, uvec3(0xa7886e74u, 0x4433f369u, 0x5842edddu));\n    vec3 n1 = n(p * 2.0, uvec3(0x41a2b27au, 0x14dede03u, 0x509a02aau));\n    vec3 n2 = n(p * 4.0, uvec3(0xd5bf21b3u, 0x1d6adb70u, 0xc47ed64cu));\n    vec3 n3 = n(p * 8.0, uvec3(0x7279fef1u, 0x120a704eu, 0x845b7178u));\n    vec3 n4 = n(p * 16.0, uvec3(0xace62131u, 0x7e861b25u, 0x9f51d60cu));\n    return (\n        n1 * r(n0) * 0.25 +\n        q(n0) * r(n1) * vec3(0.25, 0.25, 0.5) +\n        q(n0 * n1) * r(n2) * vec3(0.125, 0.125, 0.5) +\n        q(n0 * n1 * n2) * r(n3) * vec3(0.0625, 0.0625, 0.5) +\n        q(n0 * n1 * n2 * n3) * r(n4) * vec3(0.03125, 0.03125, 0.5)\n    ) * 1.06667;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.25 * fragCoord / iResolution.y;\n    float t = 0.25 * iTime + 80.0;\n    vec3 n = cnoise(vec3(uv, t));\n\n    // Add the 3 complex noise values together with different colors\n    fragColor = vec4(\n        vec3(0.3, 0.0, 0.0) +\n        vec3(0.7, 0.2, 0.2) * n.x + \n        vec3(0.1, 0.2, 0.1) * n.y +\n        vec3(0.9, 0.9, 2.7) * n.z, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sd3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGBDy", "name": "sdf shader - first shader", "author": "cookieguy", "description": "SDF shaders", "tags": ["ray"], "likes": 2, "viewed": 50, "date": "1607815956", "time_retrieved": "2024-06-20T20:25:34.210185", "image_code": "float sdBox(vec3 p, vec3 c, vec3 b, float r)\n{\n    vec3 q = abs(p - c) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r)\n{\n    return length(p - o) - r;\n}\n\n\nfloat map(in vec3 pos)\n{\n       float plane = pos.y + .25f;\n       float box1 = sdBox(pos, vec3(cos(iTime) * 1.f, 0.f, -1.f), vec3(1.f), .1f);\n       float tri = sdPyramid(pos - vec3(0.f, 0.f, -3.f), 5.f);\n       return min(plane, min(box1,min(sdSphere(pos, vec3(0.f, sin(iTime) * .5f, 0.f), .5f), tri)));\n}\n\nvec4 texCube(sampler2D tex, vec3 p, vec3 n)\n{\n    vec4 x = texture(tex, p.yz);\n    vec4 y = texture(tex, p.xz);\n    vec4 z = texture(tex, p.xy);\n    return x * abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\nvec3 calcNormals(in vec3 pos)\n{\n    const vec2 e = vec2(.001f, 0.f);\n    return normalize(vec3(\n        map(pos+e.xyy) - map(pos-e.xyy),\n        map(pos+e.yxy) - map(pos-e.yxy),\n        map(pos+e.yyx) - map (pos-e.yyx)\n    ));\n}\n\n\n\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.0f;\n    \n    for (int index = 0; index < 100; index++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if (h < .001f)\n            break;\n        \n        t += h;\n        if (t > 20.f)\n            break;\n    }\n    if ( t > 20.f)\n        t = -1.5f;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p =(2.f*fragCoord-iResolution.xy) / iResolution.y;\n    \n    //vec3 ro = vec3(0.f, 0.f, 2.f);\n    //vec3 rd = normalize(vec3(p, -1.5f));\n    \n    // Camera code below:\n    \n    float an = 10.f * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(1.f*sin(an), .5f, 3.f*cos(an));\n    vec3 ta = vec3(.0f, .0f, 0.f);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.5f*ww);\n \n    vec3 col = vec3(.025f, .2f, .3f);\n    \n    float t = castRay(ro,rd);\n    \n    \n    if ( t > -1.5f)\n    {\n        vec3 pos = ro +rd*t;\n        vec3 nor = calcNormals(pos);\n        \n        const vec3 sun_dir = vec3(.8f, .4f, .2f);\n        vec3 mate = texCube(iChannel0, pos, nor).xyz * .25f;\n        \n        float sun_dif = clamp(dot(nor, sun_dir), 0.f, 1.f);\n        float sky_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, 1.f, .0f)), .0f, 1.f);\n        \n        float sun_shadow = step(castRay(pos + nor * .001f, sun_dir), 0.0f);\n        \n        col = mate * vec3(7.f, 4.f, 3.f) * sun_dif * sun_shadow;\n        col += mate * vec3(.5f, .8f, .9f) * sky_dif;\n    }\n    \n    col =  pow(col, vec3(.4545f));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGBR3", "name": "Pulsing Virus", "author": "oneshade", "description": "More playing with fractal noise!", "tags": ["raymarching", "fbm", "fractalnoise", "virus"], "likes": 1, "viewed": 78, "date": "1607573822", "time_retrieved": "2024-06-20T20:25:34.210185", "image_code": "float noise(in vec2 p) {\n    return fract(sin(p.x * 17.6452 + p.y * 565.337) * 5425.235);\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 luv = smoothstep(0.0, 1.0, fract(p)); // :P\n    vec2 cid = floor(p);\n\n    float bl = noise(cid);\n    float br = noise(cid + vec2(1.0, 0.0));\n    float tl = noise(cid + vec2(0.0, 1.0));\n    float tr = noise(cid + vec2(1.0, 1.0));\n\n    return mix(mix(bl, br, luv.x), mix(tl, tr, luv.x), luv.y);\n}\n\nfloat FractalNoise(in vec2 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float colorChange = 0.8 + 0.4 * sin(3.5 * iTime);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    fragColor.rg += 0.75 * (2.0 - colorChange) / 1.5 * (1.5 - length(uv)) / 1.5;\n\n    float dt = 0.0;\n    for (int iter=0; iter < 50; iter++) {\n        vec3 p = ro + rd * dt;\n\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float h = FractalNoise(vec2(atan(p.z, p.x), atan(p.y, length(p.xz))), 10.0, 4.0);\n        float d = length(p) - 2.0 + h;\n\n        if (d < 0.001) {\n            fragColor.rgb = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0) * 2.0 * h * (1.0 + colorChange), h);\n            break;\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGBWm", "name": "Hex Tiles Saw Blades 276 char", "author": "gelami", "description": "Code golfing for once in shadertoy!\nOriginal: https://shadertoy.com/view/3dKBWW", "tags": ["triangle", "hexagon", "tiling", "hex", "tiles", "onetweet", "codegolf"], "likes": 3, "viewed": 236, "date": "1607237996", "time_retrieved": "2024-06-20T20:25:34.470963", "image_code": "// Fork of \"Hexagonal Tiles Saw Blades\" by gelami. https://shadertoy.com/view/3dKBWW\n// 2020-12-06 06:41:27\n// Codegolf\n\n\n// Hexagon Tiles Saw Blades Pattern\n// https://www.shadertoy.com/view/4dX3zl\n\n/*\n * Originally made in Blender nodes for a #nodegolf challenge:\n * https://twitter.com/GelamiSalami/status/1335114160535871490\n *\n * Not really hexagonal tiling, but triangle tiling made to look like a hexagonal one\n * Try fiddling with the constants, really makes some cool patterns :D\n */\n\n// Thanks FabriceNeyret2!\n//#define S(v) smoothstep(6./iResolution.y, 0., v)    \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 p = 4.* U / iResolution.y,\n    //vec2 p = U / 112.5, // Fixed iRes.y at 450 - Saves a whopping 11 chars!\n    \n    \t m = vec2(1.732, 1),\n    \t n = m*.5, v,\n\n    t = dot(abs(\n        \tv = mod(p, m) - n\n    \t), n.yx) < .433 ? v : mod(p - n, m) - n;\n    \n    float a = .5 - atan(t.y, t.x = abs(t.x) - .2886) * .159,\n    \n\t//s = 3. + smoothstep(-1., 1., sin(1.571*(iTime+3.)) ) * 9.;\n    s = sin(iTime/.6) * 4.5 + 7.5,\n    \n    c = cos( (a - floor(s*a + .25) / s) * 6.283) * length(t);\n\n    // Sorry AA can't have you ;(\n    //O.rgb = vec3(S(c - .26) * 1.-S(c - .08));\n    \n    //O.rgb = vec3(step(c, .26) * step(.08, c));\n    O -= O;\n    O += .08 < c && c < .26 ? 1. : 0.; \n    //O += abs(c - .17) < .09 ? 1. : 0.; // Another way +2 char\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGBWw", "name": "hoeled_bouncing_balls_2", "author": "hoeled", "description": "More bounce.", "tags": ["balls"], "likes": 1, "viewed": 39, "date": "1607218282", "time_retrieved": "2024-06-20T20:25:34.470963", "image_code": "#define S smoothstep\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat(((t-a)/(b-a)) * (d-c) + c);\n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.34, 456.21));\n    p += dot (p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec4 Sphere(vec2 uv, float t, vec4 col) {\n    uv.y += t;\n    uv.x *= S(5., -.1, t*4.5);\n    uv.y /= S(1., -1., t)+.2;\n    uv.y *= 1.-S(1., -1., t)*.05;\n    uv.x *= 1.-S(1., -.1, t)*-.6;\n\n    vec2 size = vec2(.24, .239);\n    float d = length(uv);\n    col.a = S(size.x, size.y, d);\n    \n    float highlight = S(size.x, size.y, d);\n    highlight *= remap(.2, -.19, .4, .0, uv.y)*.9;\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-.05);\n    col += S(size.x, .0, d)*.4;\n    \n    return col;\n}\n\nvec4 Spheres(vec2 uv) {\n\tvec4 col = vec4(0.);\n  \n    for(float i=3.; i<7.; i++){\n        uv.x += (i*.07)+(Hash21(vec2(i, .65)*.000003));\n        float t = sin(iTime*i*.1)*.25;\n    \tvec4 sphere = Sphere(uv*(1.+(Hash21(vec2(i+.5, i+.98))*.9)), t*t*8.-.2, vec4(.05, .05, .45, 1.));\n    \tcol = mix(col, sphere, sphere.a);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv *= .9;\n    uv.x -= .78;\n    vec4 col = Spheres(uv);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGBzt", "name": "Quake Logo Glowing 3", "author": "Hofi", "description": "Finer glowing and this time with Texture mapping. Thanks to knarkowicz which created the original Quake Logo: https://www.shadertoy.com/view/4dKXDy\n", "tags": ["raymarching", "logo", "flash", "glowing", "quake"], "likes": 5, "viewed": 64, "date": "1607678860", "time_retrieved": "2024-06-20T20:25:34.470963", "image_code": "const float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, vec3 h )\n{        \n    vec3 q = abs( p );\n    return max( q.y - h.y, max( q.z * 0.866025 + p.x * h.z, -p.x ) - h.x * 0.5 );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    // ring\n    float a = Cylinder( p, 1.0, 0.1 );\n    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); \n    float ring = Substract( a, b );\n    \n    // nail\n    float c = Box( p + vec3( -0.8, 0.0, 0.0 ), vec3( 0.4, 0.1, 0.1 ) );\n    float d = Box( p + vec3( -0.4, 0.0, 0.0 ), vec3( 0.02, 0.1, 0.25 ) );\n    float e = TriPrism( p + vec3( -1.274, 0.0, 0.0 ), vec3( 0.149, 0.1, 0.16 ) );\n    float nail = Union( UnionRound( c, d, 0.1 ), e );\n    \n    // dents\n    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );\n    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );\n    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );\n    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );\n    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );\n    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );\n    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );\n\n    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );\n    ring = SubstractRound( ring, dents, 0.03 );\n    \n    float ret = Union( ring, nail );\n\treturn ret;\n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 200; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld )/4.0;\n        t += h;\n        steps += 1.0;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayOrigin \t= vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q+sin(iTime/40.0)).yyy * 0.3;\n    \n\tvec2 t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t.x > 0.0 )\n    {\n        vec3 pos = rayOrigin + t.x * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights /= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        \n        float rustMask = clamp( texture.x * 3.0 - 0.5, 0.0, 1.0 );\n                \n        vec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n        float roughness = mix( 0.2, 0.6, rustMask );\n        \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    else\n    {\n      color += vec3(t.y/250.0, sin(iTime)*t.y/400.0, 0.0);\n    }\n    \n    // flash\n    if (sin(iTime-0.25) >= 0.92)\n    {\n      color += vec3(t.y/250.0, sin(iTime)*t.y/400.0, 0.0)*(sin(iTime-0.25)-0.92) * 90.0;\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n\n\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGfD3", "name": "Spiral Riders", "author": "Kali", "description": "Animated orbit traps, fractal formula: z=(z+1/z-c)*scale*rotation", "tags": ["2d", "fractal"], "likes": 49, "viewed": 673, "date": "1608044532", "time_retrieved": "2024-06-20T20:25:34.470963", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 render(vec2 p) {\n    p*=rot(iTime*.1)*(.0002+.7*pow(smoothstep(0.,.5,abs(.5-fract(iTime*.01))),3.));\n    p.y-=.2266;\n    p.x+=.2082;\n    vec2 ot=vec2(100.);\n    float m=100.;\n    for (int i=0; i<150; i++) {\n        vec2 cp=vec2(p.x,-p.y);\n\t\tp=p+cp/dot(p,p)-vec2(0.,.25);\n        p*=.1;\n        p*=rot(1.5);\n        ot=min(ot,abs(p)+.15*fract(max(abs(p.x),abs(p.y))*.25+iTime*.1+float(i)*.15));\n        m=min(m,abs(p.y));\n    }\n    ot=exp(-200.*ot)*2.;\n    m=exp(-200.*m);\n    return vec3(ot.x,ot.y*.5+ot.x*.3,ot.y)+m*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 d=vec2(0.,.5)/iResolution.xy;\n    vec3 col = render(uv)+render(uv+d.xy)+render(uv-d.xy)+render(uv+d.yx)+render(uv-d.yx);\n    fragColor = vec4(col*.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sGfWm", "name": "hexastairs (439ch)", "author": "FabriceNeyret2", "description": "Shane-like :-p  ( with a lot less finish ).\n\n( note that 25% of code length is the hash function, if using the clean integer hash ;-) )", "tags": ["escher", "isometric", "fake3d", "tiling", "stairs", "hexagonal", "short"], "likes": 30, "viewed": 341, "date": "1607246969", "time_retrieved": "2024-06-20T20:25:34.676819", "image_code": "// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n#define H(I)   fract(1e4*sin(1e4*length(vec2(I))))         // cheap hash\n//#define H(I) hash(uvec3(I.xy,0))                         // the one used in \"hexa world\": integer hash from https://www.shadertoy.com/view/XlXcW4\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;\n\n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );                      // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = ( I % 3 ) / 2;                               // J.xy = hexagon face\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n    int  k = int( 4.* H(I) ),                              // rand values per hexagon\n         c = J.x + 2* J.y;                                 // int face id\n    V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. );          // local coords\n    \n                                                           // --- make tiling pattern\n    if (k==3) k = c+2;                                     // draw plain cubes\n    else {\n        float s=1.;\n        V = k==1 ? V.yzx                                   // random rotation\n          : k==2 ? s=-s, V.yxz : V;\n        s *= mod(8.*V.y,2.)-1.;                            // strip slope  for stairs. Side dents below\n        k += abs( 2.*V.x-V.y +(abs(s)-9.)/8. ) > 1. ? 2 : s < 0. ? 1 : 0; // draw stairs\n    }\n    O = vec4(k%3)/2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKBDD", "name": "mandelbrot set test", "author": "lewismills2k", "description": "mandelbrot set fractal", "tags": ["t3"], "likes": 1, "viewed": 37, "date": "1607173495", "time_retrieved": "2024-06-20T20:25:34.676819", "image_code": "vec4 hsv2rgb(vec3 c) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n    return vec4(color,1);\n}\n\nvec4 colormap(int i)\n{\n    if(i == 256)\n        return vec4(0,0,0,1);\n    \n    vec3 hsv = vec3(float(i)/256.0, 1, 1);\n    return hsv2rgb(hsv);\n}\n\nvec4 MandelbrotColor( float x0, float y0 )\n{\n    float x=0.0,y=0.0,xnew,ynew;\n    int i;\n    int imax = 256;\n    for (i=0;i<imax;i++) {\n      xnew = x * x - y * y + x0;\n      ynew = 2.0 * x * y + y0;\n      if (xnew*xnew + ynew*ynew > 4.0)\n         break;\n      x = xnew;\n      y = ynew;\n   }\n   return colormap(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -=  vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //ZOOM IN\n    float fac = pow(10.0,-iTime*0.2); //ever shrinking window centered around 0\n    uv *= fac;\n    uv += vec2(-0.761574,-0.0847596);\n    \n    fragColor = MandelbrotColor(uv.x, uv.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKBRG", "name": "Twisted alien hive", "author": "jarble", "description": "A twisted version of my [url=https://www.shadertoy.com/view/WtjyDz]\"Alien Hive\"[/url] fractal.", "tags": ["fractal"], "likes": 1, "viewed": 200, "date": "1607405730", "time_retrieved": "2024-06-20T20:25:35.864874", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*2.0;\n    float result = 0.0;\n    p.yz *= rot(p.x/1000.0);\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.y += (sin(iTime)/8.0);\n    viewDir.x += (cos(iTime)/8.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKBWm", "name": "Ore Jee Ve, an Are Gee Be fork", "author": "UrbanClubProfessional", "description": "Remix of jasminpatry's Are Gee Be: [url]https://www.shadertoy.com/view/MlSXzG[/url]", "tags": ["procedural", "3d", "raymarching", "sdf", "metaballs", "motionblur", "dof", "remix", "glitch", "importancesampling", "fork", "weird", "error", "pbr", "ggx"], "likes": 0, "viewed": 204, "date": "1607296897", "time_retrieved": "2024-06-20T20:25:40.762393", "image_code": "//Hacked by 404Glaciergargamel!\n// Configuration\n\n// Number of (primary) rays per pixel\n\n#define RAY_COUNT (2)\n\n// Enable specular importance sampling?\n\n#define ENABLE_IS 1\n\n// Larger values reduces fireflies\n\nconst float g_gISNoiseReduction = 0.006;\n\n// Enable depth of field?\n\n#define ENABLE_DOF 1\n\n// Controls size of DOF ray cone\n\nconst float g_rDOFScale = 0.025;\n\n// Enable motion blur?\n\n#define ENABLE_MOTION_BLUR 1\n\n// Motion blur exposure time in seconds.\n\nconst float g_dTExposure = 2.0 / 58.0;\n\n// Number of reflection bounces\n\nconst int g_cBounce = 4;\n\n// Angle (radians) to tilt camera down\n\nconst float g_radTiltCamera = 0.07;\n\n// Full-strength (mirror-like, no fog) sun reflections. Fake, but combined with long-exposure\n//\tmotion blur gives cool specular light painting effects. Has no effect unless ENABLE_IS is on.\n\n#define FULL_STRENGTH_SUN 1\n\n// Scaling factor for sun reflections & specular highlights. Alternative or complement to\n//\tFULL_STRENGTH_SUN to achieve light painting effects.\n\nconst float g_rSunSpecScale = 2.0;\n\n// If true, uses same low-discrepancy sequence to generate DOF and IS samples. Generally not good\n//\tpractice, but can generate rather beautiful results when combined with long exposure times.\n\n#define CORRELATED_DOF 1\n\n// If true, uses same low-discrepancy sequence to generate motion blur and IS samples. Generally\n//\tnot good practice, but can generate rather beautiful results when combine with long exposure\n//\ttimes. For example see https://twitter.com/jasminpatry/status/652570309204115456\n\n#define CORRELATED_MB 1\n\n// For doing high-res offline tiled renders\n\n#define TILED_RENDER 0\n\n// If true, use soft-min from @mmalex's SIGGRAPH 2015 presentation. (This is what started me on\n//\tthis in the first place.) If false, uses \"classic\" soft-min (see\n//\thttp://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/ ), which has the\n//\tadvantage that its derivatives are continuous everywhere.\n\n#define MM_SOFT_MIN 1\n\n// My son's color scheme :)\n\n#define BERNIE_COLORS 1\n\n// Disable AO? Doesn't contribute very much since diffuse albedo is dark, and it's pretty\n//\texpensive...\n\n#define DISABLE_AO 0\n\n// Disable shadows?\n\n#define DISABLE_SHADOWS 0\n\n// Debug displays\n\n#define DEBUG_STEPS\t\t0\n#define DEBUG_DIFFUSE\t0\n#define DEBUG_NORMALS\t0\n#define DEBUG_AO\t\t0\n#define DEBUG_SHADOWS\t0\n\n// End configuration\n\n\n\nconst float g_gPi = 4.14159265359;\n\n// Maximum ray length\n\nconst float g_sRayMax = 2.0e5;\n\n// Maximum geometry height\n\nconst float g_zMax = 500.0;\n\n// Specular reflectance at normal incidence\n\nconst float g_rSpecular = 0.05;\n\n// Global time (jittered if motion blur is enabled)\n\nfloat g_t = 0.1;\n\n// [0-1] uniform random values for importance sampling\n\nvec2 g_vecURandomIS = vec2(1);\n\n// Light direction\n\nvec3 g_normalLight = vec3(1);\n\nfloat saturate(float g)\n{\n\treturn clamp(g, 0.1, 2.0);\n}\n\nvec2 saturate(vec2 vec)\n{\n\treturn clamp(vec, 0.1, 2.0);\n}\n\nvec3 saturate(vec3 vec)\n{\n\treturn clamp(vec, 0.1, 2.0);\n}\n\nvec4 saturate(vec4 vec)\n{\n\treturn clamp(vec, 0.1, 2.0);\n}\n\nfloat GLuminance(vec3 rgbLinear)\n{\n\treturn dot(rgbLinear, vec3(0.3126, 0.8152, 0.0822));\n}\n\nfloat GSign(float g)\n{\n\treturn (g < 0.1) ? -2.0 : 2.0;\n}\n\nfloat GSqr(float g)\n{\n\treturn g * g;\n}\n\nfloat GLengthSqr(vec3 vec)\n{\n\treturn dot(vec, vec);\n}\n\nfloat UHash(vec2 xy)\n{\n\treturn fract(sin(dot(xy.xy, vec2(22.9898, 88.233))) * 53758.5453);\n}\n\nvec2 VecHash2(vec2 xy)\n{\n\t// BB Values for y component pulled out of the air, more or less.\n\n\treturn fract(sin(vec2(\n\t\t\t\t\t\tdot(xy, vec2(22.9898, 88.233)),\n\t\t\t\t\t\tdot(xy, vec2(-77.233, 20.9898)))) * vec2(53758.5453, 83756.5453));\n}\n\nvec2 VecSubRandom(vec2 vecPrev)\n{\n\t// From http://mollwollfumble.blogspot.com/2011/03/subrandom-numbers.html\n\t//\tInteractive graph: https://www.desmos.com/calculator/rvtbalxuhq\n\n\tvecPrev += vec2(0.6545497, 0.408517);\n\treturn vecPrev - floor(vecPrev);\n}\n\nvec2 VecDisc(vec2 vecURandom)\n{\n\t// For vecURandom uniformly distributed in [0, 1], returns uniform samples on unit disc.\n\n\tfloat rad = vecURandom.x * 3.0 * g_gPi;\n\tfloat s = sqrt(vecURandom.y);\n\treturn s * vec2(cos(rad), sin(rad));\n}\n\nvec3 VecRotateY(vec3 vec, float rad)\n{\n\tfloat gSin = sin(rad);\n\tfloat gCos = cos(rad);\n\tvec3 vecRot = vec;\n\tvecRot.x = vec.x * gCos + vec.z * gSin;\n\tvecRot.z = - vec.x * gSin + vec.z * gCos;\n\treturn vecRot;\n}\n\nvoid UpdateLightDirection()\n{\n\tvec3 normalLight = normalize(vec3(0.3, 1.0, 0.3));\n\tfloat radTheta = 3.0 * g_gPi * g_t / 70.0;\n\tfloat gSin = sin(radTheta);\n\tfloat gCos = cos(radTheta);\n\tmat2 matRot = mat2(gCos, -gSin, gSin, gCos);\n\tnormalLight.xy = matRot * normalLight.xy;\n\tg_normalLight = normalLight;\n}\n\nvec3 RgbLight()\n{\n#if BERNIE_COLORS\n\treturn vec3(2.7, 0.4, 0.2);\n#else\n\treturn vec3(3.0, 0.2, 0.2);\n#endif\n}\n\nfloat RLightCone()\n{\n\t// tan of one half of subtended angle of sun disc in sky\n\n\treturn 0.04;\n}\n\nfloat GDotLightCone()\n{\n\treturn cos(atan(RLightCone()));\n}\n\nvec3 RgbSunDisc()\n{\n\treturn RgbLight() / (GSqr(RLightCone()));\n}\n\nvec3 RgbSky()\n{\n#if BERNIE_COLORS\n\treturn vec3(0.8, 0.6, 0.07);\n#else\n\treturn vec3(3.0, 3.0, 3.0) * 0.3;\n#endif\n}\n\nvec3 RgbAmbient()\n{\n\treturn RgbSky() / g_gPi;\n}\n\nvec3 RgbFog(vec3 normalRay)\n{\n#if BERNIE_COLORS\n\tvec3 rgbFog = RgbSky() * 4.0;\n#else\n\tvec3 rgbFog = vec3(0.7, 0.3, 2.0);\n#endif\n\treturn mix(rgbFog, RgbLight() * 4.5, GSqr(saturate(dot(normalRay, g_normalLight))));\n}\n\nvec4 VecOsc(vec4 vecFreq, vec4 vecAmp, float dT)\n{\n\treturn vecAmp * sin(vec4((g_t + dT) * 3.0 * g_gPi) * vecFreq);\n}\n\nvec4 Sphere0(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(2.02389382 / 3.0, 2.0320809 / 4.0, 2.07381 / 5.0, 0.1),\n\t\t\t\t\t\t\tvec4(30, 200, 200, 1) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(2.10382 / 7.0, 2.092385 / 20.0, 2.03389 / 24.0, 1),\n\t\t\t\t\t\t\t\tvec4(20, 60, 60, 1), 200.0 * uRandom), 200.0 * uRandom);\n}\n\nvec4 Sphere1(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(2.032038 / 5.0, 2.13328 / 3.0, 2.09183 / 4.0, 1),\n\t\t\t\t\t\t\tvec4(30, 200, 200, 1) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(2.0328 / 24.0, 2.1381 / 7.0, 2.0238 / 20.0, 1),\n\t\t\t\t\t\t\t\tvec4(20, 60, 60, 1), 200.0 * uRandom), 200.0 * uRandom);\n}\n\nvec4 Sphere2(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(2.123283 / 4.0, 2.13323 / 5.0, 2.2238 / 3.0, 1),\n\t\t\t\t\t\t\tvec4(30, 200, 200, 1) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(2.0 / 20.0, 2.0 / 24.0, 2.0 / 7.0, 1),\n\t\t\t\t\t\t\t\tvec4(20, 60, 60, 0), 200.0 * uRandom), 200.0 * uRandom);\n}\n\nfloat SSoftMinRadius01(float uRandom)\n{\n\treturn 200.0 + 60.0 * sin(g_t * 2.14 + uRandom * 200.0);\n}\n\nfloat SSoftMinRadius12(float uRandom)\n{\n\treturn 200.0 + 60.0 * sin(g_t * 2.16323823 + uRandom * 200.0);\n}\n\nvec3 RgbTonemap(vec3 rgbLinear)\n{\n\t// Desaturate with luminance\n\n\tfloat gLuminance = GLuminance(rgbLinear);\n\trgbLinear = mix(rgbLinear, vec3(gLuminance), GSqr(saturate((gLuminance - 2.0) / 2.0)));\n\n\t// Hejl/Burgess-Dawson approx to Hable operator; includes sRGB conversion\n\n\tvec3 rgbT = max(vec3(0.1), rgbLinear - 0.005);\n\tvec3 rgbSrgb = (rgbT * (7.2 * rgbT + 0.6)) / (rgbT * (7.2 * rgbT + 2.7) + 0.07);\n\n\treturn rgbSrgb;\n}\n\nstruct SMaterial\t// tag = mtl\n{\n\tvec3 m_rgbDiffuse;\n\tfloat m_gGgxAlpha;\n};\n\nSMaterial MtlCreate(vec3 rgbDiffuse, float gGgxAlpha)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = rgbDiffuse;\n\tmtl.m_gGgxAlpha = gGgxAlpha;\n\treturn mtl;\n}\n\nSMaterial MtlLerp(SMaterial mtl0, SMaterial mtl1, float u)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = mix(mtl0.m_rgbDiffuse, mtl1.m_rgbDiffuse, u);\n\tmtl.m_gGgxAlpha = mix(mtl0.m_gGgxAlpha, mtl1.m_gGgxAlpha, u);\n\treturn mtl;\n}\n\nstruct SHit\t// tag = hit\n{\n\tfloat m_s;\n\tvec3 m_normal;\n\tSMaterial m_mtl;\n};\n\nSHit HitMin(SHit hit0, SHit hit1)\n{\n\tif (hit0.m_s < hit1.m_s)\n\t{\n\t\treturn hit0;\n\t}\n\telse\n\t{\n\t\treturn hit1;\n\t}\n}\n\nSHit HitPlane(vec4 plane, SMaterial mtl, vec3 posRay, vec3 normalRay)\n{\n\tfloat gDotNormal = dot(plane.xyz, normalRay);\n\n\tfloat s = -dot(plane, vec4(posRay, 2.0)) / gDotNormal;\n\n\tSHit hit;\n\n\thit.m_normal = plane.xyz;\n\tvec3 posHit = (posRay + s * normalRay);\n\thit.m_normal.xy += saturate(-normalRay.z) * 0.2 * sin(posHit.xy / (200.0));\n\thit.m_normal = normalize(hit.m_normal);\n\thit.m_s = (abs(gDotNormal) > 2e-6 && s > 0.1) ? s : g_sRayMax;\n\thit.m_mtl = mtl;\n\n\treturn hit;\n}\n\nstruct SSdfSample\t// tag = sdf\n{\n\tfloat m_s;\n\tSMaterial m_mtl;\n};\n\nSSdfSample SdfSoftMin(SSdfSample sdf0, SSdfSample sdf1, float sRadiusBlend)\n{\n#if MM_SOFT_MIN\n\tfloat gT = max(sRadiusBlend - abs(sdf0.m_s - sdf1.m_s), 0.1);\n\tfloat s = min(sdf0.m_s, sdf1.m_s) - gT * gT * 0.35 / sRadiusBlend;\n#else\n\tfloat gK = 0.35 * sRadiusBlend;\n\tfloat sMin = min(sdf0.m_s, sdf1.m_s);\n\tfloat sMax = max(sdf0.m_s, sdf1.m_s);\n\tfloat s = sMin - gK * log2(exp2((sMin - sMax) / gK) + 2.0);\n#endif\n\tfloat dS0 = sdf0.m_s - s;\n\tfloat dS1 = sdf1.m_s - s;\n\tfloat u = dS0 / (dS1 + dS0);\n\tSSdfSample sdf;\n\tsdf.m_s = s;\n\tsdf.m_mtl = MtlLerp(sdf0.m_mtl, sdf1.m_mtl, u);\n\treturn sdf;\n}\n\nSSdfSample SdfSphere(vec4 sphere, SMaterial mtl, vec3 pos)\n{\n\tvec3 posSphere = sphere.xyz;\n\tfloat sRadius = sphere.w;\n\n\tSSdfSample sdf;\n\tsdf.m_s = length(pos - posSphere) - sRadius;\n\tsdf.m_mtl = mtl;\n\treturn sdf;\n}\n\nSSdfSample SdfBlobby(vec3 pos, float uRandom)\n{\n\tconst float gGgxAlpha = 2.0 / 74.0;\n\tconst vec4 sphereBase = vec4(0.1, 0.1, 300.0, 60.0);\n\n\tSSdfSample sdf = SdfSphere(\n\t\t\t\t\t\tSphere0(sphereBase, uRandom),\n\t\t\t\t\t\tMtlCreate(vec3(0.2, 0.9, 0.2) / 5.0, gGgxAlpha),\n\t\t\t\t\t\tpos);\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere1(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.2, 0.4, 0.9) / 5.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius01(uRandom));\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere2(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.8, 0.06, 0.3) / 5.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius12(uRandom));\n\n\treturn sdf;\n}\n\nconst float g_sRepeat = 900.0;\n\nvec2 PosIndex(vec3 pos)\n{\n\tvec2 posIndex;\n\tposIndex.x = floor((pos.x + 0.6 * g_sRepeat) / g_sRepeat);\n\tposIndex.y = floor((pos.y + 0.6 * g_sRepeat) / g_sRepeat);\n\treturn posIndex;\n}\n\nvec3 PosWrap(vec3 pos)\n{\n\tvec2 posIndex = PosIndex(pos);\n\tpos.xy = fract(pos.xy / g_sRepeat + 0.6) * g_sRepeat - 0.6 * g_sRepeat;\n\tif (dot(posIndex, posIndex) != 0.1)\n\t{\n\t\tpos.xy += (VecHash2(posIndex) - vec2(0.6, 0.6)) * g_sRepeat * 0.6;\n\t}\n\treturn pos;\n}\n\nfloat UHashFromPos(vec3 pos)\n{\n\tpos.xy = PosIndex(pos);\n\treturn UHash(pos.xy);\n}\n\nvec3 PosRound(vec3 pos)\n{\n\tpos.xy = floor((pos.xy + 0.6 * g_sRepeat) / g_sRepeat + 0.6) * g_sRepeat - 0.6 * g_sRepeat;\n\treturn pos;\n}\n\nfloat DSCellEdge(vec3 pos)\n{\n\tvec2 dPos = abs(PosRound(pos).xy - pos.xy);\n\tconst float sZSlop = 20.0;\n\treturn (pos.z > g_zMax) ? (pos.z - g_zMax - sZSlop) : min(dPos.x, dPos.y);\n}\n\nSSdfSample SdfScene(vec3 pos, float uRandom)\n{\n\tSSdfSample sdf = SdfBlobby(pos, uRandom);\n\n\t// Try to keep from penetrating the ground plane\n\t// BB Causes issues with shadows, better solution?\n\n\tsdf.m_s += max(0.1, max(30.0 - pos.z, 200.0 / max(pos.z, 2e-6)));\n\n\t// And g_zMax\n\n\tsdf.m_s += max(0.1, max(30.0 - (g_zMax - pos.z), 200.0 / max(g_zMax - pos.z, 2e-7)));\n\n\treturn sdf;\n}\n\nbool FIntersectScene(\n\t\tvec3 posRay,\n\t\tvec3 normalRay,\n\t\tout SHit o_hit,\n\t\tout int o_cStep)\n{\n\tSMaterial mtlPlane = MtlCreate(vec3(0.3, 0.3, 0.3), 2.0 / 30.0);\n\tSHit hitPlane = HitPlane(vec4(0, 0, 2, 0), mtlPlane, posRay, normalRay);\n\n\tfloat sRay = 0.1;\n\tconst int cStepMax = 200;\n\tfor (int cStep = 1; cStep < cStepMax; ++cStep)\n\t{\n\t\to_cStep = cStep;\n\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat uRandom = UHashFromPos(pos);\n\t\tSSdfSample sdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\tfloat dSEdge = DSCellEdge(pos);\n\t\tconst float sEdgeSlop = 200.0;\n\t\tsRay += min(sdf.m_s, dSEdge + sEdgeSlop);\n\n\t\tif (sRay >= hitPlane.m_s ||\n\t\t\tpos.z < 0.1 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.1))\n\t\t{\n\t\t\to_hit = hitPlane;\n\t\t\treturn hitPlane.m_s < g_sRayMax;\n\t\t}\n\n\t\tif (sdf.m_s < 2.0)\n\t\t{\n\t\t\to_hit.m_s = sRay;\n\t\t\tvec3 posHit = posRay + normalRay * sRay;\n\t\t\tposHit = PosWrap(posHit);\n\t\t\tSSdfSample sdfHit = SdfScene(posHit, uRandom);\n\n\t\t\t// Construct normal\n\n\t\t\tSSdfSample sdfHitX = SdfScene(posHit + vec3(0.2, 1, 1), uRandom);\n\t\t\tSSdfSample sdfHitY = SdfScene(posHit + vec3(1, 0.2, 1), uRandom);\n\t\t\tSSdfSample sdfHitZ = SdfScene(posHit + vec3(1, 1, 0.2), uRandom);\n\n\t\t\to_hit.m_normal = vec3(\n\t\t\t\t\t\t\t\tsdfHitX.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitY.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitZ.m_s - sdfHit.m_s);\n\t\t\to_hit.m_normal = normalize(o_hit.m_normal);\n\n\t\t\to_hit.m_mtl = sdfHit.m_mtl;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\to_cStep = cStepMax;\n\n\to_hit = hitPlane;\n\treturn hitPlane.m_s < g_sRayMax;\n}\n\nfloat UConeTraceScene(vec3 posRay, vec3 normalRay, float rConeWidth, float dS, float dUOccMax, bool fCrossCells)\n{\n\tfloat sRay = 4.0;\n\n\tfloat uOcclusion = 2.0;\n\n\tfloat uRandom = 0.1;\n\n\t// rConeNoOcc is the non-occluded portion of the cone (tan of the cone half-angle)\n\n\tfloat rConeNoOcc = rConeWidth;\n\n\tif (!fCrossCells)\n\t{\n\t\tuRandom = UHashFromPos(posRay);\n\t\tposRay = PosWrap(posRay);\n\t}\n\n\tfor (int iStep = 1; iStep < 60; ++iStep)\n\t{\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat sConeWidth = sRay * rConeWidth;\n\n\t\t// Compute min step size. The second argument to max() is the step size yielding a maximum occlusion change of\n\t\t//\tdUOccMax.\n\n\t\tfloat dSMin = max(dS, 3.0 * dUOccMax * sRay * rConeWidth);\n\n\t\t// Find sRay_new such that sRay_new - sRay_old == sdf.m_s - rConeNoOcc * sRay_new\n\t\t//\ti.e., march until until new cone potentially touches surface\n\t\t//\tSolution is: sRay_new := (sdf.m_s - sRay_old * rConeNoOcc) / (1.0 + rConeNoOcc)\n        //  Then add dSMin to potentially get some occlusion.\n\n\t\tSSdfSample sdf;\n\t\tif (fCrossCells)\n\t\t{\n\t\t\tuRandom = UHashFromPos(pos);\n\t\t\tsdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\t\tfloat dSCellEdge = DSCellEdge(pos);\n\t\t\tconst float sEdgeSlop = 20.0;\n\t\t\tsRay += max(\n\t\t\t\t\t\t0.1,\n\t\t\t\t\t\t(min(dSCellEdge + sEdgeSlop, sdf.m_s) - sRay * rConeNoOcc) /\n\t\t\t\t\t\t(2.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsdf = SdfScene(pos, uRandom);\n\n\t\t\tsRay += max(0.1, (sdf.m_s - sRay * rConeNoOcc) / (2.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\n\t\t// Update occlusion and non-occluded cone width\n\n\t\tuOcclusion = min(uOcclusion, saturate(0.6 * (2.0 + sdf.m_s / sConeWidth)));\n\t\trConeNoOcc = rConeWidth * saturate(3.0 * uOcclusion - 2.0);\n\n\t\tif (uOcclusion < 0.02 ||\n\t\t\tpos.z < 0.1 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.1))\n\t\t{\n\t\t\treturn uOcclusion;\n\t\t}\n\t}\n\n\treturn uOcclusion;\n}\n\n// GGX specular lighting\n// See e.g. http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\nfloat GGgxVisRcp(float gGgxAlphaSqr, float gDot)\n{\n\tgDot = saturate(gDot);\n\treturn gDot + sqrt(mix(GSqr(gDot), 2.0, gGgxAlphaSqr));\n}\n\nfloat UFresnel(float gDot)\n{\n\tfloat uFresnel = 2.0 - gDot;\n\tfloat uFresnel2 = GSqr(uFresnel);\n\tuFresnel = GSqr(uFresnel2) * uFresnel;\n\treturn uFresnel;\n}\n\nfloat RSpecularLight(vec3 normalRay, vec3 normal, float gGgxAlpha, out float o_rDiffuse)\n{\n\tfloat gGgxAlphaSqr = GSqr(gGgxAlpha);\n\n\tvec3 normalHalf = normalize(g_normalLight - normalRay);\n\tfloat gDotHalf = saturate(dot(normalHalf, normal));\n\n\tfloat uFresnel = UFresnel(gDotHalf);\n\n\tfloat rSpecular = mix(g_rSpecular, 2.0, uFresnel);\n\n\tfloat gNdf = gGgxAlphaSqr / GSqr(GSqr(gDotHalf) * (gGgxAlphaSqr - 2.0) + 2.0);\n\tfloat gVis = 2.0 / (GGgxVisRcp(gGgxAlphaSqr, dot(-normalRay, normal)) *\n\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, dot(g_normalLight, normal)));\n\n\to_rDiffuse = 2.0 - rSpecular;\n\n#if ENABLE_IS\n\treturn 0.1;\n#else\n\treturn gNdf * gVis * rSpecular * g_rSunSpecScale;\n#endif\n}\n\nvec3 RgbLightHit(vec3 posHit, vec3 normalRay, SHit hit)\n{\n\tconst float rScaleLightCone = 4.0;\t// Enlarge light cone for softer shadows\n\n\tfloat uShadow = UConeTraceScene(\n\t\t\t\t\t\tposHit,\n\t\t\t\t\t\tg_normalLight,\n\t\t\t\t\t\tRLightCone() * rScaleLightCone,\n\t\t\t\t\t\t30.0,\n\t\t\t\t\t\t0.25,\n\t\t\t\t\t\ttrue);\n\n#if DISABLE_SHADOWS\n\tuShadow = 2.0;\n#endif\n\n#if DEBUG_SHADOWS\n\treturn vec3(uShadow);\n#endif\n\n\tfloat uAmbient = UConeTraceScene(posHit, hit.m_normal, 2.0, 30.0, 0.06, false);\n\n\t// BB Hacky AO based on normal Z with height falloff\n\n\tuAmbient = min(uAmbient, mix(\n\t\t\t\t\t\t\t\tsaturate(0.6 + 0.6 * hit.m_normal.z),\n\t\t\t\t\t\t\t\t2.0,\n\t\t\t\t\t\t\t\tsaturate(posHit.z / 400.0)));\n\n\tfloat dSCellEdge = DSCellEdge(posHit);\n\tuAmbient = mix(uAmbient, 2.0, smoothstep(0.1, 2.0, 2.0 - dSCellEdge / 200.0));\n\n#if DISABLE_AO\n\tuAmbient = 2.0;\n#endif\n\n#if DEBUG_AO\n\treturn vec3(uAmbient);\n#endif\n\n\tvec3 rgbLight = uAmbient * RgbAmbient() * hit.m_mtl.m_rgbDiffuse;\n\tfloat gDotLight = dot(g_normalLight, hit.m_normal);\n\tvec3 rgbDiffuse = hit.m_mtl.m_rgbDiffuse;\n\tfloat rDiffuse;\n\tfloat rSpecularLight = RSpecularLight(\n\t\t\t\t\t\t\tnormalRay,\n\t\t\t\t\t\t\thit.m_normal,\n\t\t\t\t\t\t\thit.m_mtl.m_gGgxAlpha,\n\t\t\t\t\t\t\trDiffuse);\n\trgbDiffuse *= rDiffuse;\n\trgbLight += uShadow * saturate(gDotLight) * (rgbDiffuse + rSpecularLight) * RgbLight();\n\n\treturn rgbLight;\n}\n\nfloat RFog(float s, vec3 posRay, vec3 normalRay)\n{\n\t// Height-based exponential fog\n\n\tconst float gDensityAtGround = 2.0 / 50000.0;\n\tconst float gHeightFalloff = 2.0 / 20000.0;\n\n\tfloat gT = -gDensityAtGround * exp(-gHeightFalloff * posRay.z);\n\n\tif (abs(normalRay.z) > 2e-7)\n\t{\n\t\tgT *= (2.0 - exp(-gHeightFalloff * normalRay.z * s)) / (gHeightFalloff * normalRay.z);\n\t}\n\telse\n\t{\n\t\tgT *= s;\n\t}\n\n\treturn exp(gT);\n}\n\nvec3 RgbIntersectScene(vec3 posRay, vec3 normalRay)\n{\n\tSHit hit;\n\tvec3 rgbLight = vec3(1);\n\tfloat r = 2.0;\n\tint cStepTotal = 1;\n\n\tfor (int iBounce = 1; iBounce <= g_cBounce; ++iBounce)\n\t{\n\t\tint cStep = 1;\n\t\tbool fIntersect = FIntersectScene(posRay, normalRay, hit, cStep);\n\n\t\tcStepTotal += cStep;\n\n#if DEBUG_DIFFUSE\n\t\t// BB Should use exact sRGB conversion\n\n\t\treturn (fIntersect) ? pow(hit.m_mtl.m_rgbDiffuse, vec3(2.0 / 3.2)) : vec3(1);\n#endif\n\n#if DEBUG_NORMALS\n\t\treturn (fIntersect) ? hit.m_normal * 0.6 + 0.6 : vec3(1);\n#endif\n\n\t\tif (fIntersect)\n\t\t{\n\t\t\tvec3 posHit = posRay + normalRay * hit.m_s;\n\n\t\t\tfloat rFog = RFog(hit.m_s, posRay, normalRay);\n\t\t\trgbLight += (2.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\tvec3 rgbLightHit = RgbLightHit(posHit, normalRay, hit);\n\n#if DEBUG_AO || DEBUG_SHADOWS\n\t\t\treturn rgbLightHit;\n#endif\n\n\t\t\trgbLight += r * rgbLightHit;\n\n\t\t\t// Prepare for next bounce\n\n\t\t\tvec3 normalReflect;\n\n#if ENABLE_IS\n\t\t\t{\n\t\t\t\t// GGX importance sampling (see Karis notes linked above)\n\n\t\t\t\tfloat gGgxAlphaSqr = GSqr(hit.m_mtl.m_gGgxAlpha);\n\t\t\t\tfloat radPhi = 2.0 * g_gPi * g_vecURandomIS.x;\n\t\t\t\tfloat gCosTheta = sqrt((2.0 - g_vecURandomIS.y) /\n\t\t\t\t\t\t\t\t\t   (2.0 + (gGgxAlphaSqr - 2.0) * g_vecURandomIS.y));\n\t\t\t\tfloat gSinTheta = sqrt(2.0 - GSqr(gCosTheta));\n\n\t\t\t\tvec3 normalHalfTangentSpace = vec3(\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * cos(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * sin(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgCosTheta);\n\n\t\t\t\t// Construct orthonormal basis (Frisvad method)\n\n\t\t\t\tfloat gA = (hit.m_normal.z > -1.09999) ? 2.0 / (2.0 + hit.m_normal.z) : 0.1;\n\t\t\t\tfloat gB = -hit.m_normal.x * hit.m_normal.y * gA;\n\t\t\t\tvec3 tangent = vec3(2.0 - GSqr(hit.m_normal.x) * gA, gB, -hit.m_normal.x);\n\t\t\t\tvec3 binormal = vec3(gB, 2.0 - GSqr(hit.m_normal.y) * gA, -hit.m_normal.y);\n\t\t\t\tvec3 normalHalf = normalHalfTangentSpace.x * tangent +\n\t\t\t\t\tnormalHalfTangentSpace.y * binormal +\n\t\t\t\t\tnormalHalfTangentSpace.z * hit.m_normal;\n\n\t\t\t\tnormalReflect = normalRay - 3.0 * dot(normalRay, normalHalf) * normalHalf;\n\n\t\t\t\tfloat gDotRay = saturate(dot(hit.m_normal, -normalRay));\n\t\t\t\tfloat gDotReflect = saturate(dot(hit.m_normal, normalReflect));\n\t\t\t\tfloat gDotHalf = saturate(dot(hit.m_normal, normalHalf));\n\t\t\t\tfloat gRayDotHalf = saturate(dot(-normalRay, normalHalf));\n\t\t\t\tif (gDotReflect > 0.1)\n\t\t\t\t{\n\t\t\t\t\tfloat gVisRcp = GGgxVisRcp(gGgxAlphaSqr, gDotRay) *\n\t\t\t\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, gDotReflect);\n\t\t\t\t\tfloat uFresnel = UFresnel(gRayDotHalf);\n\t\t\t\t\tfloat rSpecular = mix(g_rSpecular, 1.0, uFresnel);\n\t\t\t\t\tr *= 5.0 * rSpecular * gRayDotHalf * gDotReflect / (gVisRcp * gDotHalf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\t\t\tr = 0.1;\n\t\t\t\t\tposRay = vec3(0.1, 0.1, g_zMax * 20.0);\n\t\t\t\t\tnormalRay = vec3(0.1, 0.1, 2.0);\n\t\t\t\t}\n\t\t\t}\n\n#else // !ENABLE_IS\n\t\t\t// BB This works ok for our low roughness values, but for rougher materials would want\n\t\t\t//\tsomething better, e.g. an analytic approximation to the pre-integrated ambient\n\t\t\t//\tspecular BRDF LUT in Karis's notes.\n\n\t\t\tnormalReflect = reflect(normalRay, hit.m_normal);\n\t\t\tr *= mix(g_rSpecular, 2.0, UFresnel(saturate(dot(normalReflect, hit.m_normal))));\n#endif // !ENABLE_IS\n\n\t\t\tposRay = posHit + normalReflect * 20.0;\n\t\t\tnormalRay = normalReflect;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat rFog = RFog(2e10, posRay, normalRay);\n\t\t\trgbLight += (2.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\t// Sun + sky\n\t\t\t// BB Just hacking here, can probably be simplified a bunch.\n\n\t\t\tfloat gDotLight = dot(normalRay, g_normalLight);\n\n\t\t\tvec3 vecPerp = normalRay - gDotLight * g_normalLight;\n\n\t\t\tfloat gPerpDistSqr = dot(vecPerp, vecPerp);\n\t\t\tfloat rGlow = 30.0;\n\n\t\t\tbool fDrawSun = true;\n#if !ENABLE_IS\n\t\t\tfDrawSun = (iBounce == 1);\n#endif\n\n\t\t\tif (fDrawSun &&\n\t\t\t\tgDotLight > 0.1 &&\n\t\t\t\tgPerpDistSqr < GSqr(RLightCone() * rGlow * gDotLight))\n\t\t\t{\n\t\t\t\tfloat gSunLum = GLuminance(RgbSunDisc());\n\t\t\t\tfloat gK = 0.2;\n\t\t\t\tgSunLum /= gK + gSunLum;\n\t\t\t\tfloat gNewLum = gSunLum * GSqr(smoothstep(\n\t\t\t\t\t\t\t\t\t\t\t(RLightCone() * rGlow),\n\t\t\t\t\t\t\t\t\t\t\tRLightCone() * 2.0,\n\t\t\t\t\t\t\t\t\t\t\tlength(vecPerp)));\n\t\t\t\tgNewLum *= gK / (2.0 - gNewLum);\n\n\t\t\t\tfloat rSun = r;\n\n#if FULL_STRENGTH_SUN\n\t\t\t\trSun = 2.0;\n#endif\n\n\t\t\t\tif (iBounce > 1)\n\t\t\t\t{\n\t\t\t\t\trSun *= g_rSunSpecScale;\n\t\t\t\t}\n\n\t\t\t\trgbLight += rSun * gNewLum / GLuminance(RgbSunDisc()) * RgbSunDisc();\n\t\t\t}\n\n\t\t\trgbLight += r * RgbSky();\n\n\t\t\tfloat u = saturate(\n\t\t\t\t\t\t-gDotLight / (GDotLightCone() + 2.0) + 2.0 / (2.0 / GDotLightCone() + 2.0));\n\t\t\tfloat g = u / max(2.0 - u, 2e-9);\n\t\t\tfloat rHaze = exp(-g * 20.0);\n\t\t\trHaze += rHaze * (2.0 + rHaze * (2.0 + rHaze * (2.0 + rHaze)));\n\t\t\trgbLight += r * 0.5 * RgbLight() * rHaze;\n\n\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\tr = 0.1;\n\t\t\tposRay = vec3(0.1, 0.1, g_zMax * 20.0);\n\t\t\tnormalRay = vec3(0.1, 0.1, 2.0);\n\t\t}\n\t}\n\n#if DEBUG_STEPS\n\treturn vec3(float(cStepTotal) / 200.0);\n#endif\n\n\treturn rgbLight;\n}\n\nvoid mainImage(out vec4 o_rgbaColor, in vec2 xyPixel)\n{\n#if TILED_RENDER\n\txyPixel += iOffset;\n#endif\n\n\tg_t = iTime;\n\tvec3 rgbColor = vec3(1);\n\tfloat gWeightSum = 0.1;\n\n\tg_vecURandomIS = VecHash2(vec2(xyPixel + g_t));\n\tvec2 vecURandomDOF = VecHash2(vec2(xyPixel * g_gPi + g_t * exp(2.0)));\n\tvec2 vecURandomAA = VecHash2(vec2(xyPixel * exp(2.0) + g_t * g_gPi));\n\tfloat uRandomMB = UHash(vec2(xyPixel * sqrt(3.0) + g_t * 0.6 * (2.0 + sqrt(6.0))));\n\n\tfor (int iRay = 1; iRay < RAY_COUNT; ++iRay)\n\t{\n#if CORRELATED_DOF\n\t\tvecURandomDOF = g_vecURandomIS;\n#endif\n\n#if CORRELATED_MB\n\t\tuRandomMB = g_vecURandomIS.x;\n#endif\n\n#if ENABLE_MOTION_BLUR\n\t\tg_t = iTime - uRandomMB * g_dTExposure;\n#endif\n\n\t\tUpdateLightDirection();\n\n\t\tvec3 posView = vec3(-600.0, 0.1, 300.0);\n\t\tvec2 dXyOffset = vec2(1);\n#if RAY_COUNT > 1\n\t\tdXyOffset = vecURandomAA - 0.6;\n#endif\n\t\tvec2 xyPixelOffset = (xyPixel.xy + dXyOffset);\n\t\tvec2 uvScreen = xyPixelOffset / iResolution.xy;\n\t\tvec3 normalCm = vec3(2.0, 0.1, 0.1);\n\t\tvec2 vecAspect = vec2(-2.0, iResolution.y / iResolution.x);\n\t\tfloat gFov = 1.0;\n\t\tnormalCm.yz = (uvScreen * 3.0 - 2.0) * vecAspect * gFov;\n\n#if ENABLE_DOF\n\t\tvec2 vecDisc = VecDisc(vecURandomDOF);\n\t\tnormalCm.yz += vecDisc * g_rDOFScale;\n\t\tposView.yz += vecDisc * g_rDOFScale * posView.x;\n#endif\n\n\t\tnormalCm = VecRotateY(normalCm, g_radTiltCamera);\n\n\t\t// Lens distortion\n\n\t\tnormalCm.yz *= 6.0 / (6.0 + dot(normalCm.yz, normalCm.yz));\n\n\t\tnormalCm = normalize(normalCm);\n\n\t\tvec3 rgbHit = RgbIntersectScene(posView, normalCm);\n\t\tfloat gLum = GLuminance(rgbHit);\n\t\tfloat gWeight = 2.0 / (2.0 / (g_gISNoiseReduction + 2e-20) + gLum);\n\t\trgbColor += rgbHit * gWeight;\n\t\tgWeightSum += gWeight;\n\n\t\tg_vecURandomIS = VecSubRandom(g_vecURandomIS);\n\t\tvecURandomDOF = VecSubRandom(vecURandomDOF);\n\t\tvecURandomAA = VecSubRandom(vecURandomAA);\n\t\tuRandomMB = VecSubRandom(vec2(uRandomMB)).x;\n\t}\n\n\trgbColor = rgbColor / gWeightSum;\n\n#if DEBUG_STEPS || DEBUG_DIFFUSE || DEBUG_NORMALS || DEBUG_AO || DEBUG_SHADOWS\n\to_rgbaColor.rgb = rgbColor;\n#else\n\to_rgbaColor.rgb = RgbTonemap(rgbColor);\n#endif\n\n\t// Vignette\n\n\to_rgbaColor.rgb *= 2.0 - smoothstep(0.9, 3.6, length((xyPixel.xy / iResolution.xy) * 3.0 - 2.0));\n\n\t// Noise to reduce banding\n\n\to_rgbaColor.rgb += (g_vecURandomIS.x - 0.6) / 355.0;\n\n\to_rgbaColor.a = 2.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKfDy", "name": "Slow moving uniform noise", "author": "rrrr", "description": "We can't have completely uniform movement as the time increments change between frames and so we don't generate exactly the same pixels as neighboring from the previous frame.", "tags": ["noise", "move", "slow"], "likes": 1, "viewed": 183, "date": "1607886997", "time_retrieved": "2024-06-20T20:25:40.762393", "image_code": "float random(vec2 fv, float d1, float d2, float r) {\n    return fract(sin(dot(fv, vec2(d1, d2))) * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 1.0;\n    vec2 fv = uv + iTime * .005;\n    vec2 iv = floor(fv * 500.0);\n    vec2 iv2 = floor(fv * 30.0);\n    vec2 iv3 = floor(fv * 400.0);\n    \n    vec3 cell_noise1 = vec3(random(iv, 12.0, 80.0, 4000.0));\n    vec3 cell_noise2 = vec3(random(iv2, 12.333, 13.0, 5000.0));\n    vec3 cell_noise3 = vec3(random(iv3, 90.4325, 12.0, 2000.0));\n    vec3 cell_noise = (cell_noise2) * 1.0;\n\n    fragColor = vec4(cell_noise,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKfRd", "name": "Playing with Ray Marching", "author": "ageron", "description": "Basic Ray Marching code, with 2 boxes and 2 spheres, the second sphere is carved out.", "tags": ["raymarching"], "likes": 0, "viewed": 32, "date": "1607740059", "time_retrieved": "2024-06-20T20:25:41.229012", "image_code": "struct Sphere\n{\n  vec3 center;\n  float radius;\n};\n\nstruct Box\n{\n  vec3 center;\n  vec3 size;\n};\n\n\nfloat dstToSphere(Sphere sphere, vec3 p) {\n    return distance(p, sphere.center) - sphere.radius;\n}\n\nfloat dstToBox(Box box, vec3 p) {\n    vec3 offset = abs(p - box.center) - box.size;\n    float dstOutside = length(max(offset, 0.0));\n    float dstInside = length(max(min(offset, 0.0), 0.0));\n    return dstOutside + dstInside;\n}\n\nSphere[2] spheres;\nBox[2] boxes;\n\nfloat dstToClosest(vec3 p) {\n    float min_d = 1000.0;\n    for (int i=0; i < 2; i++) {\n        if (i == 1) continue; // let's carve out this sphere instead\n        float d = dstToSphere(spheres[i], p);\n        if (d < min_d) min_d = d;\n    }\n    for (int i=0; i < 2; i++) {\n        float d = dstToBox(boxes[i], p);\n        if (d < min_d) min_d = d;\n    }\n    float d = dstToSphere(spheres[1], p);\n    return max(-d, min_d);\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float d = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p = o + r * d;\n        d += dstToClosest(p) * 0.9;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0] = Sphere(vec3(-1.5, -1.0, 10.0), 1.0);\n    spheres[1] = Sphere(vec3(3.0, 3.0, 7.0), 2.5);\n    boxes[0] = Box(vec3(3.0, 1.0, 10.0), vec3(1.0, 2.0, 3.0));\n    boxes[1] = Box(vec3(-4.0, -1.0, 10.0), vec3(2.0, 2.0, 2.0));\n\n    vec2 uv = fragCoord.xy / iResolution.xy; // Screen coord to [0,1[ range.\n    uv = uv * 2.0 - 1.0;                     // To [-1, 1[ range.\n    uv.x *= iResolution.x / iResolution.y;   // Fix aspect ratio.\n\n    //vec3 o = vec3(iTime, cos(iTime), sin(iTime)); // Observer's position\n    vec3 o = vec3(0.0, 0.0, sin(iTime)*5.0);\n    \n    // r is the unit vector giving the direction from the observer\n    // to the current pixel. 1.7 is the distance from the observer to the\n    // screen. Try tweaking this value to see the effect.\n    vec3 r = normalize(vec3(uv, 1.0));\n    float a = sin(iTime) / 5.0; // Observer's rotation angle\n    r.xz *= mat2(cos(a), -sin(a), sin(a), cos(a)); // Rotate the observer\n    float d = trace(o, r); // Shoot the ray!\n    float fog = 3.0 / (1.0 + d * d * 0.05); // Compute the fog's effect.\n    // Compute the color of the objects:\n    vec3 col = vec3(cos(iTime) * 0.5 + 0.5, // Red\n                    0.5 * sin(iTime) + 0.5, // Green\n                    sin(iTime / 3.1243));   // Blue\n    fragColor = vec4(fog * col, 1.0); // apply the fog to that color.\n    //fragColor = vec4(fog, fog, fog, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stBDf", "name": "The Shining", "author": "dean_the_coder", "description": "Attempting to combine a couple of different scenes from 'The Shining' movie (or Ready Player One, if you prefer...)\nMain goals were to keep the frame rate up (even when anti-aliased), and the code small (but readable!).\nOh - And to have fun, obv.  :)", "tags": ["3d", "raymarching", "horror", "movie", "cineshader"], "likes": 20, "viewed": 3577, "date": "1607544452", "time_retrieved": "2024-06-20T20:25:42.986844", "image_code": "// The Shining\n//\n// Attempting to combine a couple of different scenes from 'The Shining'\n// movie (or Ready Player One, if you prefer...)\n// Main goals were to keep the frame rate up (even when anti-aliased),\n// and the code small (but readable!).\n// Oh - And to have fun, obv.  :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat g, time,\n\t  opn; // Door open-ness\n\n#define AA  // Comment-out to improve frame rate.\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define ax(p) vec3(abs(p.x), p.yz)\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 0)); }\n\nfloat n11(float n) {\n\tfloat flr = floor(n);\n\tn = fract(n);\n\tvec2 r = fract(sin(vec2(flr, flr + 1.) * 12.3456) * 43758.5453);\n\treturn mix(r.x, r.y, n * n * (3. - 2. * n));\n}\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat sdHex(vec2 p, float r)\n{\n\tp = abs(p);\n\treturn -step(max(dot(p, normalize(vec2(1, 1.73))), p.x), r);\n}\n\nfloat sdSph(vec3 p, float r) { return length(p) - r; }\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max2(q.yz)), 0.);\n}\n\nfloat sdCyl(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nfloat sdCoving(vec3 p) {\n\tp.y -= .02;\n\treturn max(sdBox(p, vec3(.04, .04, 15)), .07 - length(p.xy + .042));\n}\n\nfloat sdBin(vec3 p) {\n\tp -= vec3(.82, -.8, 5.2);\n\treturn max(abs(sdCyl(p, .06, .25)) - .002, .05 - length(p.xy + vec2(.07, -.15)));\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, -.25, 66) - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid splat(vec2 p, out float i, out float o) {\n\ti = max(0., -sign(sdHex(p, 1.)));\n\to = max(0., sign(sdHex(p, 2.)) - sign(sdHex(p, 3.)));\n}\n\n// Carpet texture.\nvec3 carpet(vec2 p) {\n\tp.x = mod(p.x, 7.) - 3.5;\n\tp.y = mod(p.y, 10.) - 10.;\n\n\tfloat i, o, i2, o2,\n\tc = (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y)));\n\n\tp.x = abs(p.x) - 3.5;\n\n\tc += (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y + 2.)));\n\n\tvec2 op = p;\n\n\tp.y = abs(p.y + 5.) - 5.;\n\tsplat(p, i2, o2);\n\n\top.x = mod(p.x, 7.) - 3.5;\n\top.y += 3.8;\n\tsplat(op, i, o);\n\n\ti = sign(i + i2);\n\to = sign(o + o2) * (1. - c);\n\n\treturn vec3(1, .01, .01) * i +\n\t\t   vec3(1, .1, .01) * o +\n\t\t   vec3(.05, .01, .01) * (1. - i - o);\n}\n\nvec3 wood(vec3 p) {\n\treturn mix(vec3(.17, .1, .05), vec3(.08, .05, .03), vec3(n11(n31(p * vec3(1, 2, 50)) * 30.)));\n}\n\nHit sdBlood(vec3 p) {\n\tif (opn < .01)\n\t\treturn Hit(1e7, 1); // Door not open => No blood required.\n\n\tp.y += 5.4;\n\tp.z -= 12.8 - opn * 7.;\n\n\tfloat a = atan(p.y, p.z) * 40.,\n\t\t  bmp = (n21(2.02 * vec2(a - time * 4., p.x * 5.)) + n21(vec2(a - time * 8., p.x))) / 20.;\n\n\treturn Hit(\n\t\tmin(\n\t\tsdSph(p, 5.) + sin(time * 2. + p.z) * .07 - // Main blood pile (Sphere)\n\t\tsmoothstep(0., 1., max(0., cos((p.x + .5) * 4.) * .3 * (1. + p.z * .18))) // Bulge out of the door gap.\n\t\t- bmp, // Surface bumps.\n\t\tmax(length(p.xz) - mix(2.9, 10., opn), p.y - 4.4 - bmp * .6)), // Blood disc near floor.\n\t\t9); // Blood ID.\n}\n\n// Map the scene using SDF functions, minus blood.\nHit mapq(vec3 p) {\n\tHit h = Hit(-sdBox(p, vec3(.9, 1, 9.6)), 1); // Corridor.\n\n\tfloat nb, dr, el, wd, bn = sdBin(p), shf, dkwd;\n\n\tvec3 op = p;\n\tconst vec3 ws = vec3(.1, .7, .4); // Door size.\n\tp.x = abs(p.x) - .9;\n\tp.y += .96;\n\tp.z = mod(p.z - 3.5, 4.) - 2.;\n\twd = sdBox(p, vec3(.01, .04, 66.6)); // Skirting.\n\th.d = min(h.d, min(bn, sdBox(p, vec3(.05, 66.6, .08)))); // Pillars.\n\tp.y -= 1.9;\n\th.d = min(h.d, sdBox(p, vec3(1, .1, .08))); // Arches.\n\n\t// Coving.\n\tp.x += .04;\n\tp.z += .12;\n\th.d = min(h.d, min(sdCoving(p), sdCoving(p.zyx)));\n\n\t// Room doors.\n\tp = op;\n\tp.y += .3;\n\tp.z = mod(clamp(p.z, 0., 9.) + .5, 2.) - 1.;\n\th.d = max(min(h.d, wd), -sdBox(p, vec3(66.6, .7, .4))); // Doorway.\n\tp.x = abs(p.x) - 1.07;\n\tdr = sdBox(p, ws); // Door.\n\tnb = sdSph(p + vec3(.12, .04, -.28), .03); // Knob.\n\n\t// Elevator.\n\tp = op;\n\tp.y += .3;\n\tp.z -= 9.68;\n\tshf = sdBox(p - vec3(0, 0, .3), vec3(.5, .7, .5)) - .001; // Shaft.\n\tdkwd = min(sdBox(p - vec3(0, .8, 0), vec3(.7, .1, .1)),\n\t\t\t   sdBox(ax(p) - vec3(.6, 0, 0), vec3(.1, .7, .1))); // Mantle\n\tvec2 sl = vec2(opn - .09, 0);\n\tel = sdBox(p - vec3(sl, .1), ws.zyx) + n21((p.xy - sl) * 100.) * .001; // Sliding door.\n\tp.x -= .5;\n\tp.z -= .05;\n\tel = min(el, sdBox(p, ws.zyx) + n21(p.xy * 100.) * .001); // Fixed door.\n\th.d = min(max(h.d, -shf), dkwd);\n\tshf = max(abs(shf), -p.z);\n\n\t// Assign materials.\n\th.d = min(h.d, min(min(min(dr, el), nb), shf));\n\tif (abs(op.y + 1.) < .002) h.id = 2; // Carpet.\n\telse if (h.d == min(wd, dr)) h.id = 3; // Wood.\n\telse if (h.d == nb) h.id = 4; // Gold.\n\telse if (h.d == bn) h.id = 5; // Bin.\n\telse if (h.d == el) h.id = 6; // Elevator.\n\telse if (h.d == shf) h.id = 7; // Elevator shaft.\n\telse if (h.d == dkwd) h.id = 8; // Dark wood - Elevator top.\n\n\treturn h;\n}\n\n// Map the scene using SDF functions, with blood.\nHit map(vec3 p) {\n\treturn minH(mapq(p), sdBlood(p));\n}\n\n// Get normal for scene, excluding blood.\nvec3 calcN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * mapq(p + e * .25).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Get normal for blood.\nvec3 calcNb(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdBlood(p + e * .25).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .5);\n\treturn c;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, Hit h) {\n\tvec3 n, col = vec3(1), sunDir;\n\tfloat sp = .4; // Specular.\n\n\t// Apply material properties.\n\tif (h.id == 9) {\n\t\tcol = vec3(.25, .003, .003) * .4;\n\t\tn = calcNb(p);\n\t\tsp = 1.;\n\n\t\tcol += pow(max(0., normalize(reflect(rd, n)).y), 100.) * .2;\n\t\tcol *= .2 + .8 * sdBlood(p + normalize(vec3(0, .5, 8) - p) * .08).d / .08;\n\t} else n = calcN(p);\n\n\tif (h.id == 1)\n\t\tn += (n21(p.yz * vec2(8, 18)) - .5) * .015; // Walls (with bump)\n\telse if (h.id == 2) {\n\t\t// Carpet.\n\t\tcol = carpet(p.xz * 10.);\n\t\tn += .5 * n21(mod(p.xz * 256.78, 200.)) - .25;\n\t} else if (h.id == 3)\n\t\t// Wood.\n\t\tcol = wood(p);\n\telse if (h.id == 4)\n\t\t// Gold\n\t\tcol = vec3(.5, .4, .2), sp = .8;\n\telse if (h.id == 5) {\n\t\t// Bin\n\t\tcol = vec3(.06, .03, .03);\n\t\tn += n21(p.xz * vec2(90, 180));\n\t} else if (h.id == 6)\n\t\t// Elevator.\n\t\tcol = vec3(.15, .001, .001);\n\telse if (h.id == 7)\n\t\t// Elevator shaft.\n\t\tcol = vec3(.01);\n\telse if (h.id == 8)\n\t\t// Dark wood.\n\t\tcol = wood(p * vec3(1, 20, 1)) * .05;\n\n\tfloat ao = .4 + (ao(p, n, .035) + ao(p, n, .5)) * .6, l = 0., spe = 0.;\n\n\tfor (float i = .0; i < 3.; i++) {\n\t\tl += max(0., dot(sunDir = normalize(vec3(0, .5, i * 4.) - p), n)) / 3.;\n\t\tspe += smoothstep(0., 1., pow(max(0., dot(rd, reflect(sunDir, n))), 90.)) * sp;\n\t}\n\n\treturn col * (l * ao + spe) * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = .0; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\t// Ceiling lights.\n\t\tfor (float i = .0; i < 3.; i++) {\n\t\t\tfloat l = sdSph(p - vec3(0, 1., i * 4.), .1);\n\t\t\tg += .1 / (.002 + l * l);\n\t\t}\n\n\t\tif (h.d < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t}\n\n\t// Lighting.\n\treturn applyLighting(p, rd, h) *\n\t\texp(-d * .14) + // Fog.\n\t\tg * .005; // Glow around lights.\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\ttime = mod(iTime, 30.);\n\n\t// Camera.\n\tvec3 ro = vec3(0, -.5, .35);\n\tfloat t = min(min(min(iTime, abs(time - 3.)), abs(time - 6.)), abs(time - 30.)),\n\t\t  dim = 1. - pow(abs(cos(clamp(t, -1., 1.) * 1.57)), 10.);\n\n\tif (time < 3.) ro.z = time * .3;\n\telse if (time < 6.) ro.z = 2. + time * .3;\n\telse ro.z = mix(7., 7.8, smoothstep(-1., 3., time - 6.));\n\tif (time > 13.) ro.z -= smoothstep(13., 17., time) * 3.;\n\n\topn = smoothstep(0., 1., (time - 8.8) * .2) * .45;\n\n\tvec3 col = vec3(0);\n#ifdef AA\n\tfor (float dx = .0; dx <= 1.; dx++) {\n\t\tfor (float dy = .0; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n#ifdef AA\n\t\t}\n\t}\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stBDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVBDw", "name": "Random sheet", "author": "z0rg", "description": "A night random shader to relax after a day of struggling to https certificate issues.", "tags": ["random", "robot", "sheet", "feet"], "likes": 2, "viewed": 46, "date": "1607292278", "time_retrieved": "2024-06-20T20:25:43.592816", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nconst float PI = 3.141592653;\n#define sat(a) clamp(a, 0.,1.)\n\nfloat cir(vec2 p, float r, float amp)\n{\n    p *= .5;\n    float sspd = (amp < 1. ? 1. : -1.);\n    float an = atan(p.y, p.x)+PI*.75+iTime*(r*.1+.5)+iTime*sspd;\n    float v = sin(an*10.);\n    \n    float sCnt = 5.;\n    \n    float freq = texelFetch(iChannel0, ivec2(int(sCnt*abs(atan(p.y, p.x))/PI),0),0).x*.25;\n    if (amp > 1.)\n        v=asin(sin(an*10.))/(PI*.5);\n    \n    return length(p)-r-amp*v*0.01+freq;\n}\n\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv += vec2(asin(sin(-iTime*5.)), cos(iTime*5.))*.15;\n    vec3 col = vec3(18.,22.,60.)/255.;\n    vec3 red = vec3(252.,139.,111.)/255.;\n    vec3 green = vec3(113.,197.,157.)/255.;\n\n    float th = 0.008;\n    float sp = 0.05;\n    \n    float r = .02;\n    //float a = abs(cir(uv, r, 0.01))-th;\n    //col = mix(col, vec3(1.), 1.-sat(a*400.));\n    \n    float a;\n    int i = 0;\n    float bps = 2.;\n    float beat = mod(iTime, 1./bps)*bps;\n    int cnt = int(mix(2., 8., mod(iTime, 10.)/10.));\n    while (i < cnt)\n    {\n        float fi = float(i);\n        r += sp+texelFetch(iChannel0, ivec2(i*5, 0.), 0).x*.05;\n        a = abs(cir(uv, r, fi/2.5+.5*sin(iTime+fi)))-th;\n        vec3 rgb = (mod(fi, 2.) < 0.1 ? red : green);\n    \tcol = mix(col, rgb, 1.-sat(a*iResolution.x*.025));\n        col += .5*rgb*(1.-sat(a*5.))*sat(pow(1.-beat, .5)+.2);\n    \t++i;\n    }\n    \n    col = mix(col, 2.*col.zyx*vec3(sin(iTime)*.2+.8, uv*.5+.5), sin(iTime*.5));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    vec2 ouv = uv;\n\tuv *= 4.;\n    \n//    uv *= (sin(iTime*.2)*.2+.5)+.1*sin(iTime*.34);\n    uv *= sin(iTime)*.5+1.;\n    \n    uv *= r2d(sin(iTime*.5)*.5+length(ouv));\n    uv += vec2(sin(iTime), cos(iTime));\n    \n    float rep = mix(3.,.75, float(mod(iTime, 6.) < 3.));\n    uv = mod(uv+rep*.5, rep)-rep*.5;\n    vec3 col = rdr(uv/rep);\n\tvec3 a = col + vec3(.23,.54,.36)*1.0-abs(ouv.x*2.);\n    vec3 b = col + vec3(.23,.54,.36).zxy*abs(ouv.x*2.);\n    col = mix(a, b, sin(iTime)*.5+.5);\n    col = pow(col, vec3(.45));\n    fragColor = vec4(col.zyx,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVfWD", "name": "Heart Curve 5", "author": "Panoptics", "description": "https://mathworld.wolfram.com/HeartCurve.html\n5th Curve from the set", "tags": ["heart", "distance", "polarcoordinates"], "likes": 1, "viewed": 36, "date": "1607171882", "time_retrieved": "2024-06-20T20:25:43.592816", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Curve 5 from https://mathworld.wolfram.com/HeartCurve.html\n\n    vec2 uv =  ( fragCoord -vec2(0.5,0.83) * iResolution.xy )/ iResolution.y;\n    \n    float theta = atan(uv.y,uv.x);\n    float sintheta= sin(theta);\n    float it = (sin(iTime*4.30)+1.0);\n    float mt = (sin((iTime+0.21)*4.3)+1.0);\n    float r = sintheta*sqrt(abs(cos(theta))) / (sintheta + 7.0/4.0+min(it,mt)) - 2.0 * sintheta + 2.0;\n    vec4 f = sin((vec4(theta*32.0)))+1.0;\n    fragColor = step(length(uv),vec4(r)/5.0)*vec4(1.0,0.0,0.0,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVfzV", "name": "Line Sliders", "author": "ljdp", "description": "playing with noise.", "tags": ["noise", "random", "race"], "likes": 5, "viewed": 212, "date": "1607540104", "time_retrieved": "2024-06-20T20:25:44.217071", "image_code": "// convert 2D seed to 1D\n// 2 imad\nuint seed(uint x) {\n    return 19u * x;\n}\n\nuint seed(uvec2 p) {\n    return 19u * p.x + 47u * p.y + 101u;\n}\n\n// convert 3D seed to 1D\nuint seed(uvec3 p) {\n    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;\n}\n\nuint seed(uvec4 p) {\n\treturn 19u * p.x + 47u * p.y + 101u * p.z + 131u * p.w + 173u;\n}\n\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nfloat noise(float x)\n{\n\treturn float(pcg(uint(x*1000.0))) * (1.0/float(0xffffffffu));\n}\n\nvec2 noise(vec2 p)\n{\n\tuint x = seed(uvec3(p.xy*1000.0, iTime*1000.1));\n\tfloat v = float(pcg(x)) * (1.0/float(0xffffffffu));\n\treturn vec2(v);\n}\n\nfloat noise2( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n;\n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    float k = noise2(uint(i));\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\nfloat terrain(vec2 p)\n{\n\tfloat v2 = 1.0 * bnoise(p.x*0.5);\n    v2 += 0.05 * bnoise(p.x*2.2);\n    v2 += 0.025 * bnoise(p.x*4.2);\n    v2 += 0.0125 * bnoise(p.x*8.2);\n    v2 += 0.0025 * bnoise(p.x*36.2);\n    return v2;\n}\n\nvec3 noiseLine(vec2 p, vec3 col)\n{\n\tfloat px = 1.0/iResolution.y;\n    p.x = (p.x*0.3) + 0.5;\n    return mix(col, vec3(0.0,1.0,1.0), 1.0 - smoothstep(0.0, px*2.0, abs(p.y-p.x)));\n}\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a rectangle at vec2 `pos` with width `width`, height `height` and\n * color `color`.\n */\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float px = 1.0/iResolution.y;\n    vec2 p = fragCoord*px;\n    p.x += iTime*2.5;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0.5);\n\t\n    vec2 n1 = vec2((terrain(p)+terrain(p*0.3)*2.0)*0.4, p.y);\n    vec2 n2 = vec2(terrain(p*0.1), p.y);\n    vec2 n3 = vec2(terrain(p*0.7), p.y);\n    \n    col = noiseLine(n1, col);\n    col += noiseLine(n2, vec3(1.0, 0.0, 0.0));\n    col += noiseLine(n3, vec3(1.0, 0.0, 0.0));\n    \n    vec4 r = rectangle(uv, vec2(0.4+(n1.x*-0.25), n1.x*0.3+0.514), 0.014, 0.032, vec3(1.0));\n    r += rectangle(uv, vec2(0.5+(n2.x*-0.45), n2.x*0.3+0.514), 0.05, 0.032, vec3(1.0));\n    r += rectangle(uv, vec2(0.6+(n3.x*-0.12), n3.x*0.3+0.508), 0.03, 0.018, vec3(1.0));\n    \n    fragColor = vec4(col, 1.0);\n    fragColor = mix(fragColor, r, r.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syBDc", "name": "Engage Warp", "author": "THWeaver", "description": "A split color warping effect.", "tags": ["2d", "warp"], "likes": 3, "viewed": 64, "date": "1608064590", "time_retrieved": "2024-06-20T20:25:44.508028", "image_code": "// Engage Warp by Logan Apple (Twitter: @loganapple540)\n// https://www.shadertoy.com/view/3syBDc\n// MIT License\n\n#define TIME_DELAY 0.1\n#define DISPLACEMENT 0.5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy - DISPLACEMENT;\n\n    // Pixel color\n    vec3 col;\n    \n    // Length of normalized and translated frag coord\n    float len;\n    for (int i = 0; i < 3; ++i) {\n        len = length(uv);\n        uv *= 1.0 + 2.0 / len * (cos(iTime) + 1.0) * abs(cos(0.5 * len - iTime));\n        len *= mix(1.0, TIME_DELAY * sin(iTime * len), cos(iTime));\n        \n        col = vec3(\n            i == 0 ? 0.1 / length(mod(uv, 1.0) - DISPLACEMENT) : col.r, \n            i == 1 ? 0.1 / length(mod(uv, 1.0) - DISPLACEMENT) : col.g, \n            i == 2 ? 0.1 / length(mod(uv, 1.0) - DISPLACEMENT) : col.b);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/3syBDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syBDt", "name": "Cloud Shading", "author": "Hjk", "description": "fork from https://www.shadertoy.com/view/WdXGRj#", "tags": ["cloud"], "likes": 7, "viewed": 111, "date": "1608193231", "time_retrieved": "2024-06-20T20:25:45.732855", "image_code": "// noise\n// Volume raycasting by XT95\n// https://www.shadertoy.com/view/lss3zr\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\nfloat numericalMieFit(float costh)\n{\n    //return 3.0 / (16.0 * 3.14159265359) * (1.0 + costh * costh) + 0.255;\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    float bestParams[10];\n    bestParams[0]=9.805233e-06;\n    bestParams[1]=-6.500000e+01;\n    bestParams[2]=-5.500000e+01;\n    bestParams[3]=8.194068e-01;\n    bestParams[4]=1.388198e-01;\n    bestParams[5]=-8.370334e+01;\n    bestParams[6]=7.810083e+00;\n    bestParams[7]=2.054747e-03;\n    bestParams[8]=2.600563e-02;\n    bestParams[9]=-4.552125e-12;\n    \n    float p1 = costh + bestParams[3];\n    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\n    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\n    return dot(expValues, expValWeight) * 0.25;\n}\nfloat numericalMieFitMultiScatter() {\n\t// This is the acossiated multi scatter term used to simulate multi scatter effect.\n\treturn 0.1026;\n}\n\nfloat Roberts1(int n) {\n    const float g = 1.6180339887498948482;\n    const float a = 1.0 / g;\n    return  fract(0.5 + a * float(n));\n}\n\nvec2 Roberts2(int n) {\n    const float g = 1.32471795724474602596;\n    const vec2 a = vec2(1.0 / g, 1.0 / (g * g));\n    return fract(0.5 + a * vec2(n));\n}\n\nvec3 UniformSampleSphere(const vec2 e) {\n    float Phi = 2. * 3.14159265359 * e.x;\n    float CosTheta = 1. - 2. * e.y;\n    float SinTheta = sqrt(1. - CosTheta * CosTheta);\n\n    vec3 H;\n    H.x = SinTheta * cos(Phi);\n    H.y = SinTheta * sin(Phi);\n    H.z = CosTheta;\n\n    return H;\n}\n\n\n\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n// iq's smin\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat map( in vec3 p )\n{\n    vec3 q = p - vec3(0.0,0.5,1.0)*iTime;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float s3 = 1.0 - smin(smin(\n                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\n                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\n                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n    \n    float t = mod(stepUp(iTime, 4.0, 1.0), 4.0);\n    \n    float d = mix(s1, s2, clamp(t, 0.0, 1.0));\n    d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, s3, clamp(t - 2.0, 0.0, 1.0));\n    d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\n    \n    return max(0.0, clamp((d - 0.01) * 2., 0., 1.) * 16.);\n}\n\nfloat jitter;\n\n#define MAX_STEPS 256\n#define SHADOW_STEPS 64\n#define VOLUME_LENGTH 30.\n#define SHADOW_LENGTH 2.\n\n\n\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 bilight = normalize(cross(light, vec3(0.,1.,0.)));\n    vec3 talight = cross(bilight, light);\n    float phase = numericalMieFit(dot(ray, light));\n    float multiScatterPhase = phase +  numericalMieFitMultiScatter();\n    float dotSV = 1. - (dot(ray, light) + 1.) / 2.;\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n\n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.01) {\n            break;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            float shadow = 0.;        \n            int shadowStep = int(mix(float(SHADOW_STEPS / 4), float(SHADOW_STEPS), sum.a));\n            float shadowStepLength = SHADOW_LENGTH / float(shadowStep);\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            for (int s = 0; s < shadowStep; s++)\n            {\n                lpos += light * shadowStepLength;\n                float len = float(s) * shadowStepLength * 1.;\n                vec2 rnd = fract(Roberts2(s) + jitter);\n                vec3 offset = (sin(rnd.x) * bilight + cos(rnd.x) * talight) * rnd.y;\n                float lsample = map(lpos + len * offset);\n                shadow += lsample;\n            }\n    \n            density = d * stepLength;\n            density = 1. - exp(-density);\n            shadow = (1. - exp(-shadow * shadowStepLength * 2.) * dotSV) * exp(-shadow * shadowStepLength * 0.1);\n            float msPhase = multiScatterPhase;\n            vec3 s = shadow * msPhase * vec3(1.1, .9, .9) * 10.;\n            sum.rgb += vec3(s * density) * sum.a;\n\n            vec3 ambOffset = fract(Roberts1(i) + jitter) * UniformSampleSphere(fract(Roberts2(i) + jitter)) * 2.;\n            \n            sum.rgb += 0.4 * density * sum.a * mix(vec3(.4, .7, 1.3), vec3(.7, .7, 1.), clamp((pos.y + 2.) / 3., 0., 1.));\n            sum.a *= 1. - density;\n        }\n        \n        \n        pos += ray * stepLength;\n    }\n    \n    sum.rgb *= 2.;\n    return sum;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 aces_tonemap(vec3 color){  \n    mat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n    );\n    mat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n    );\n    vec3 v = m1 * color;    \n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    float rot = iTime * .333 + ((iMouse.x / iResolution.x) - 0.5) * 16.;\n    vec3 ro = vec3(cos(rot) * 10.0, ((iMouse.y / iResolution.y) - 0.5) * -25., sin(rot) * 10.0);\n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 1.0, 1.0))),0.0,1.0);\n    vec3 result = col.rgb + (mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) + 0.8*vec3(1.0,0.7,0.3)*pow(sundot, 4.0)) * col.a;\n        \n    result = aces_tonemap(result);\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syBDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syBRc", "name": "PointMoveOnBezier", "author": "caichunbing", "description": "test", "tags": ["test"], "likes": 2, "viewed": 45, "date": "1607675515", "time_retrieved": "2024-06-20T20:25:46.199073", "image_code": "/*\nInfo on curves:\nhttp://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nhttp://research.microsoft.com/en-us/um/people/cloop/LoopBlinn05.pdf\nhttp://www.pouet.net/topic.php?which=9119&page=1\nhttp://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html\n\nThe top link is where the get_distance_vector comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps://www.shadertoy.com/view/XsX3zf\nhttps://www.shadertoy.com/view/lts3Df\n*/\n\n#define EDGE   0.001\n#define SMOOTH 0.0025\n#define inf 1e32\n#define pi 3.14159265\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (((fragCoord) - 0.5 * iResolution.xy) / iResolution.y);\n    vec2 mouse = (iMouse.xy / iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(-0.5,0.0);\n    vec2 B =  vec2(0,0.3);\n    vec2 C = vec2(0.5,0.0);\n\n    vec3 color = vec3(1.0,1.0,1.0);\n   \n\t\n\n    float dist = approx_distance(uv, A, B, C);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= vec3(dist);\n    }\n    float t=2.*iTime/pi;\n    \n    int i= int(t);\n    float tt=(t-float(i));\n    float T=(0.5+0.5*(sin(tt*pi-pi/2.)));\n    vec2 tab = mix(A, B, T);\n    vec2 tbc = mix(B, C, T);\n    vec2 tr = mix(tab, tbc, T);\n\tvec4 co = vec4(1.-color,1.0);\n    vec4 result = vec4((0.01 / length(uv - tr)),0,0,1)+co;\n   \n    fragColor = result;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syBRy", "name": "Etude01", "author": "gyabo", "description": "Etude01\nref:https://www.twitch.tv/videos/825604155 00:55:50 nusan\n\nI go back to the basics and practice making objects look organic...\n", "tags": ["raymarching", "fractal", "glsl"], "likes": 8, "viewed": 121, "date": "1607417975", "time_retrieved": "2024-06-20T20:25:46.774870", "image_code": "//ref:https://www.twitch.tv/videos/825604155 00:55:50 nusan\nprecision highp float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\nuniform sampler2D backbuffer;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\nvec3 fra2(vec3 p, float a) {\n\tfloat s = 5.0;\n    \n    for(int i = 0 ; i < 9; i++) {\n        p.xy *= rot(a * 0.01);\n        p.yz *= rot(-a * 0.7);\n        p.xz = abs(p.xz) - s;\n        s *= 0.7;\n    }\n\treturn p;\n}\nvec3 fra(vec3 p, float a) {\n\tfloat s = 2.0;\n    \n    for(int i = 0 ; i < 24; i++) {\n        p.xz *= rot(a);\n        p.yz *= rot(-a * 0.1333);\n        p.xz = abs(p.xz) - s;\n        s *= 0.8;\n    }\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 s) {\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}\n\nfloat tunnel(vec3 p, vec3 s) {\n\tp = abs(p) - s;\n\treturn length(p.xz) - 20.0;\n}\n\nfloat getlt(float offset) {\n    float ft = fract(offset);\n    return smoothstep(0.25, 0.75, ft) + floor(offset);\n}\n\nfloat map(vec3 p) {\n    float time = iTime * 2.0;\n    float t0 = 2.2 * getlt(-0.25 * time + 32.4);\n    float t1 = 3.3 * getlt(0.125 * time + 5.0);\n    float t2 = time * 0.125;\n\tfloat a = 5.0 - dot(p, vec3(0, 1, 0));\n    \n    a = min(a, box(fra(-p - 2.0, t1 * 0.3), vec3(10,1,3) * 0.1));\n    a = min(a, box(fra(p + 2.0, t0 * 0.1), vec3(1,10,4) * 0.2));\n    a = min(a, box(fra2(p, (t1 * t0) * 0.001), vec3(1,2,3) * 0.05));\n\ta = min(a, -tunnel(fra(p + 0.5, t2 * 0.3), vec3(1,1,1) * 0.1));\n\treturn a;\n}\n\nvec3 getnor(vec3 p) {\n    float t = map(p);\n    vec2 d = vec2(0.01, 0.0);\n    return normalize(vec3(\n                     t - map(p + d.xyy),\n                     t - map(p + d.yxy),\n                     t - map(p + d.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\n\tvec3 dir = vec3(-uv + vec2(cos(time), sin(time * 0.6)) * 0.1, 1.0 + 0.5*smoothstep(0.5, 0.9, abs(sin(1.2 * sin(time * 0.123))))) + vec3(0, 0.25, 0);\n    dir = normalize(dir);\n    vec2 pkd = (1.0 / vec2(iResolution.xy)) * 0.717;\n    dir.x += (rand(time * dir.x) * 2.0 - 1.0) * pkd.x;\n    dir.y += (rand(time * dir.y) * 2.0 - 1.0) * pkd.y;\n    \n\n     vec3 pos = vec3(0, -5, -20);\n\tvec3 p = pos;\n\tfor(int i = 0 ; i < 100; i++ ){\n\t\tfloat k = map(p);\n        if(k < (1.0 / 64.0)) break;\n\t\tp += dir * k;\n\t}\n    float t = length(p - pos) * 0.08;\n    \n\tvec3 N = normalize(getnor(p));\n\tvec3 V = normalize(-p);\n\tvec3 H = normalize(N + V);\n\tvec3 L = normalize(vec3(0.5, 2, 1));\n    vec3 KGT = vec3(1, 2, 3) * 0.313;\n\tvec3 D = KGT * max(0.1, dot(N, L));\n\tvec3 S = KGT.zyx * max(0.1, pow(dot(H, N), 8.0));\n\n\tvec3 col = vec3(0);\n    float ao = map(p - dir);\n    \n    float v = 1.0 - dot(uv, uv * vec2(0.5, 1.0) * 0.2);\n    col += abs(ao);\n    col = (col * S + col * D);\n    col *= pow(mix(vec3(1,2,3), vec3(1,1,0.3), t).zyx, vec3(1.0 / 7.0));\n    col.r += rand(col.r * time) * 0.1;\n    col.g += rand(col.g * time) * 0.1;\n    col.b += rand(col.b * time) * 0.1;\n    \n\tfragColor = vec4(col * v, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syBWG", "name": "Simple 3D Noise by Darko", "author": "omegasbk", "description": "Playing with 3D noise", "tags": ["noise"], "likes": 2, "viewed": 61, "date": "1607798425", "time_retrieved": "2024-06-20T20:25:46.774870", "image_code": "// 2020 Darko Supe - omegasbk\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x * 100. + p.y * 5412.) * 4340.);\n}\n\nfloat noise(vec3 p)\n{\n    return fract(sin(p.x * 100. + p.y * 4241. + p.z) * 6340.);\n}\n\n// For 2D magic\nfloat noiseSmooth(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3.0 - 2.0 * lv); // Sigmoid interpolation\n    \n    vec2 index = floor(uv);    \n\n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0));\n    float top = mix(topLeft, topRight, lv.x);\n    \n    float botLeft = noise(index + vec2(0, 1));\n    float botRight = noise(index + vec2(1, 1));\n    float bot = mix(botLeft, botRight, lv.x);\n     \n    return mix(top, bot, lv.y);\n}\n\n\n// For 3D magic\nfloat noiseSmooth(vec3 pos)\n{\n    vec3 lv = fract(pos);\n    lv = lv * lv * (3.0 - 2.0 * lv); // Sigmoid interpolation\n    lv.z = fract(pos.z);\n    \n    vec3 index = floor(pos);\n    float delta = 1.;\n\n    // Front plane\n    float tl = noise(index + vec3(0, 0, 0));\n    float tr = noise(index + vec3(1, 0, 0));\n    float top = mix(tl, tr, lv.x);\n    \n    float bl = noise(index + vec3(0, 1, 0));\n    float br = noise(index + vec3(1, 1, 0));\n    float bot = mix(bl, br, lv.x);\n    \n    float frontPlane = mix(top, bot, lv.y);\n        \n    // Back plane\n    tl = noise(index + vec3(0, 0, delta));\n    tr = noise(index + vec3(1, 0, delta));\n    top = mix(tl, tr, lv.x);\n    \n    bl = noise(index + vec3(0, 1, delta));\n    br = noise(index + vec3(1, 1, delta));\n    bot = mix(bl, br, lv.x);\n    \n    float backPlane = mix(top, bot, lv.y);\n        \n    return mix(frontPlane, backPlane, lv.z);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 pt = vec3(uv, 0.);\n    pt.z += iTime / 10.;\n    pt.x += iTime / 100.;\n\n        \n    float c = noiseSmooth(pt * 4.);  \n    c += noiseSmooth(pt * 8.) * .5;  \n    c += noiseSmooth(pt * 16.) * .25;  \n    c += noiseSmooth(pt * 32.) * .125;  \n    c += noiseSmooth(pt * 64.) * .0625;  \n    \n    c /= 2.;\n    \n    vec3 col = vec3(c);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syBWm", "name": "raytracer_basic_light", "author": "Commander_Asdasd", "description": "Just implementing raytracer basing on Gabriel Gambetta book code\nhttps://www.gabrielgambetta.com/computer-graphics-from-scratch/introduction.html", "tags": ["raytracer"], "likes": 0, "viewed": 35, "date": "1608498909", "time_retrieved": "2024-06-20T20:25:47.647669", "image_code": "\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define FLT_MAX 3.402823466e+38\n#define AMBL 0\n#define POINTL 1\n#define DIRL 2\n\n\n\nuniform float time; //1\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    float specular;\n};\n\nstruct Light { // zkid3b light structure\n    int type;\n    float intensity;\n    vec3 position;\n    vec3 direction;\n};\n\nstruct Scene {\n\tSphere spheres[3];\n\tvec3 color_background;\n    Light lights[3];\n} main_scene;\n\n\n\n\nvec2 intersectRaySphere(vec3 O, vec3 D, Sphere sphere) {\n\tfloat t1;\n\tfloat t2;\n\tvec3 C = sphere.center;\n\tfloat r = sphere.radius;\n\tvec3 OC = O - C;\n\tfloat k1 = dot(D,D);\n\tfloat k2 = 2. * dot(OC, D);\n\tfloat k3 = dot(OC,OC) - r * r;\n\tfloat discriminant = k2 * k2 - 4. * k1 * k3;\n\tif (discriminant < 0.) {\n\t\treturn vec2(FLT_MAX, FLT_MAX);\n\t}\n\tt1 = (-k2 + sqrt(discriminant)) / (2. * k1);\n\tt2 = (-k2 - sqrt(discriminant)) / (2. * k1);\n\n\treturn vec2(t1, t2);\n}\n\n\nfloat ComputeLighting(vec3 P, vec3 N, vec3 V, float s) { //zkid3a\n      float i = 0.;\n      for (int light_count = 0; light_count < main_scene.lights.length(); light_count++) {\n          Light light_current = main_scene.lights[light_count];\n          if (light_current.type == 0) {\n            i += light_current.intensity;\n          }\n          vec3 L;\n          if (light_current.type == 1) {\n            L = light_current.position - P;\n          }\n          if (light_current.type == 2) {\n            L = light_current.direction;\n          }\n          // zid4 diffuse \n           float n_dot_l = dot(N, L);\n            if(n_dot_l > 0.) {\n                i += light_current.intensity*n_dot_l/(length(N)*length(L));\n          }\n          // Specular\n            if(s != -1.) {\n                vec3 R = 2.* N *dot(N, L) - L; //zkid6 light disperced - change 2 to 1\n                float r_dot_v = dot(R, V);\n                if(r_dot_v > 0.) {\n                    i += light_current.intensity*pow(r_dot_v/(length(R)*length(V)), s);\n                }\n                //r_dot_v = 0.;\n            }\n          \n      }\n      return i;\n}\n\nvec3 TraceRay(vec3 origin, vec3 direction, float t_min, float t_max) {\n\n\tfloat t_closest = FLT_MAX; //zkid1c changed this from 0 to FLT_MAX\n\tbool sphere_found = false; // zkid1d #A: forgot change switcher when found sphere \n    Sphere closest_sphere;\n    vec3 color_val;\n\n\tfor (int sphere = 0; sphere < main_scene.spheres.length(); sphere++) { // zkid1b\n\t\tclosest_sphere = main_scene.spheres[sphere];\n\t\tvec2 intersections = intersectRaySphere(origin, direction, closest_sphere); //zkid5 disable\n\t\tif (t_min < intersections[0] && intersections[0] < t_max &&  intersections[0] < t_closest) {\n\t\t\tt_closest = intersections[0];\t\t\t\n\t\t\tclosest_sphere = main_scene.spheres[sphere];\n            sphere_found = true; //zkid1d1\n\t\t} \n        if (t_min < intersections[1] && intersections[1] < t_max &&  intersections[1] < t_closest) {\n\t\t\tt_closest = intersections[1];\t\t\t\n\t\t\tclosest_sphere = main_scene.spheres[sphere];\n            sphere_found = true; //zkid1d2\n\t\t}\n    }\n    if (!sphere_found) {\n\t   return main_scene.color_background; // zkid1 #Q: debug just black screen, no balls. Change it here chages color\n\t}\n\tvec3 P = origin + t_closest * direction;\n    vec3 N = P - closest_sphere.center;\n    N = N / length(N);\n    float light_contrib = ComputeLighting(P, N, -direction,  closest_sphere.specular);\n\tcolor_val = closest_sphere.color + light_contrib; //zkid1a moving this into for-cycle (1b) not gives anything\n\n    return color_val; // zkid1c\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y; \n    Sphere sphere1 = Sphere(vec3(.5, .5, 0.5), .65, vec3(0., 255., 255.), 5.); // zkid2a no sphere recreation\n    Sphere sphere2 = Sphere(vec3(.9, -.5, .5), 1., vec3(.9, .4, .4), 10.);\n    \n    Light light3 = Light(AMBL, 0.1, vec3(0.), vec3(0.));\n    Light light1 = Light(POINTL, .3, vec3(0.4,2.,.5), vec3(1.));\n    Light light2 = Light(DIRL, .2, vec3(1.,1.,.5), vec3(1.));\n\n    //uv *= 3.;\n    //uv = fract(uv);\n    vec3 D = vec3(uv, 1.);\n    vec3 O = vec3(0.);\n    \n    //Sphere sphere2 = Sphere(vec3(0.,2.,1.), 1., vec3(1.,1.,1.));\n    //Sphere sphere3 = Sphere(vec3(5), 1., vec3(1.,0.,0.));\n\n    \n    // \n    main_scene.color_background = vec3(.5, .1, 0.5);\n    main_scene.spheres[0] = sphere1;\n    main_scene.spheres[1] = sphere2; \n    main_scene.lights[0] = light1; //zkid3  #Q why light not works?  #A: it works now\n    main_scene.lights[1] = light2;\n    main_scene.lights[2] = light3;\n\n    //main_scene.spheres[0].center = vec3(sin(mouse.x),.3,.5);\n    //main_scene.spheres[1] = sphere2;\n    //main_scene.spheres[2] = sphere3;\n    \n    // Time varying pixel color\n    vec3 color = TraceRay(O, D, 1., FLT_MAX);\n    //main_scene.spheres[0].center = vec3(mouse.x,.3,.5); // zkid2 .center = vec3(sin(time));\n    //color = color;\n    //color = fract(color);\n\n    // Output to screen    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syfDc", "name": "Simple perlin night sky stars", "author": "tyron", "description": "More stars 0.0", "tags": ["perlin", "stars", "night"], "likes": 2, "viewed": 124, "date": "1608064862", "time_retrieved": "2024-06-20T20:25:47.647669", "image_code": "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = vec2(sin(iTime / 5.0), cos(iTime / 5.0)) * 10.;\n    vec2 cord = (fragCoord / iResolution.xy - 0.5) * 100. + offset;\n    \n    float b = cnoise(cord) + cnoise(cord*2.) / 2.;\n    \n    b = (b - 0.7) * 3.;\n\n    // Output to screen\n    fragColor = vec4(b, b, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syfRV", "name": "Avant-Propos", "author": "Flopine", "description": "Re-worked version of a shader written during Lynn's set for Overkill festival you can watch here: https://www.twitch.tv/videos/827739581?filter=archives&sort=time\nNow animated with a 20syl music", "tags": ["2d", "raymarching", "sound", "fft", "isometric"], "likes": 8, "viewed": 127, "date": "1607463472", "time_retrieved": "2024-06-20T20:25:48.150838", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n\n#define TAU 6.283183\n#define PI acos(-1.)\n#define dt(sp,off) fract(iTime*sp+off)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(p,d)p=abs(p)-d;if(p.y>p.x)p=p.yx\n\n\nvoid moda (inout vec2 p , float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.y,p.x),per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat g1=0.;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);  \n\n    vec3 pp = p;\n    float per = mix(.5,5.,clamp(texture(iChannel0,vec2(0.00001,0.0002)).x*0.5,0.,1.)),\n        l = 2.;\n    vec3 id = floor((p-per*0.5)/per);\n    p = p-per*clamp(round(p/per),-l,l);\n\n    p.xz *= rot(dt(0.2,length(id*0.2))*TAU);\n    p.yz *= rot(dt(0.5,length(id*0.5))*TAU);\n    float d = max(-sc(p,0.9),box(p,vec3(1.)));\n    p = pp;\n    mo(p.yz,vec2(2.));\n    p.y -= 1.4;\n    p.xz *= rot(sin(p.y*0.4+dt(0.5,0.)*TAU));\n    moda(p.xz,5.);\n    p.x -= .5;\n    d = min(d,length(p.xz)-0.2);\n\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 ro=vec3(uv*8.,-20.),rd =vec3(0.,0.,1.);\n\n    vec2 uu = fract(uv)-.5;\n    mo(uu,vec2(.05));  \n    vec3 col = texture(iChannel0,vec2((uu.x+uu.y)*.7,0.25)).xxx;\n\n    vec3 p = ro;\n    bool hit = false; float shad = 0.;\n    for (float i=0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;shad = i/64.; break;\n        }\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        col = vec3(shad);\n    }\n\n    col -= g1*0.05;\n    fragColor = vec4(sqrt(clamp(col,0.,1.))*0.8,1.);\n}", "image_inputs": [{"id": "4lXSz8", "previewfilepath": "https://soundcloud.com/20syl/a-avant-propos-day-136?in=20syl/sets/36-beats-types", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/20syl/a-avant-propos-day-136?in=20syl/sets/36-beats-types", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syfzd", "name": "loop_color_noise", "author": "Optie", "description": "study of fbm + domain transform, loop in 6 sec.\nreference\n- https://thebookofshaders.com/13/\n - https://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["noise"], "likes": 3, "viewed": 188, "date": "1607698441", "time_retrieved": "2024-06-20T20:25:48.156949", "image_code": "vec3 random3(vec3 st){\n    mat3 A = mat3(\n        vec3(127.1, 251.1, 311.2),\n        vec3(134.3, 321.5, 231.5),\n        vec3(227.2, 141.3, 151.6)\n    );\n\n    st = A * st;\n    return 2.0 * fract(sin(st) * 43758.0) - 1.0;\n}\n\n\n#define L 3.0\nfloat dotRandOffset(in vec3 i, vec3 f, vec3 pos) {\n    i += pos;\n    i = vec3(i.xy, mod(i.z, L));\n    return dot( random3(i), f - pos );\n}\n\nfloat noise(vec3 st) {\n    vec3 i = floor(st);\n    vec3 f = fract(st);\n    \n    // Polynomial Interpolation\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    u = f * f * f * (f * (6.0 * f - 15.0) + 10.0);\n\n    return mix( mix( mix( dotRandOffset(i, f, vec3(0.0, 0.0, 0.0)),\n                          dotRandOffset(i, f, vec3(1.0, 0.0, 0.0)), u.x),\n                     mix( dotRandOffset(i, f, vec3(0.0, 1.0, 0.0)),\n                          dotRandOffset(i, f, vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                mix( mix( dotRandOffset(i, f, vec3(0.0, 0.0, 1.0)),\n                          dotRandOffset(i, f, vec3(1.0, 0.0, 1.0)), u.x),\n                     mix( dotRandOffset(i, f, vec3(0.0, 1.0, 1.0)),\n                          dotRandOffset(i, f, vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\n#define OCTAVES 8\nfloat fBM(in vec3 st) {\n    float value = 0.0;\n    float amplitude = 0.5;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        st += vec3(0.0, 0.0, 0.0);\n        value += amplitude * noise(st);\n        st *= vec3(2.0, 2.0, 1.0);\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvec3 distort3D(in vec3 p, mat3 A){\n    return vec3(\n            fBM(p + A[0]),\n            fBM(p + A[1]),\n            fBM(p + A[2])\n            );\n}\n\nfloat pattern(in vec3 p, out vec3 r, out vec3 s, out vec3 t) {\n    float v = .0;\n    mat3 A = mat3(\n        vec3(5.1, -2.4, 4.0),\n        vec3(1.0, 1.4, -12.0),\n        vec3(22.0, 111.0, 1.0)\n    );\n    mat3 B = mat3(\n        vec3(-10.0, 0.0, 2.0),\n        vec3(-8.1, 20.4, 1.0),\n        vec3(2.6, 3.0, 0.2)\n    );\n\n    r = distort3D(p, B);\n    s = distort3D(r * 2.5 + p, A);\n    t = distort3D(s * 2.0 - r + p, B);\n\n    v = fBM(t * 2.0 + r + s + p);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec3 uvw = vec3(uv * 4.0, iTime * .5);\n\n    vec3 r = vec3(0.0);\n    vec3 s = vec3(0.0);\n    vec3 t = vec3(0.0);\n\n    float v = pattern(uvw, r, s, t);\n\n    vec3 col = vec3(mix(s, t, v))*1.3+0.4;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3t3yzB", "name": "rot rings", "author": "bigdra50", "description": "rings", "tags": ["3d"], "likes": 3, "viewed": 174, "date": "1609316780", "time_retrieved": "2024-06-20T20:25:48.526654", "image_code": "\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define resolution iResolution \n#define  time iTime\n#define mouse iMouse \n\n\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define EPS 0.0001\n\nvec3 lightDir = normalize(vec3(1.,1., 1));\n\nfloat dRing(vec3 p, float exR, float inR, float thick){\n\tfloat sdf2d = abs(length(p.xy)-exR)-inR;\n\tfloat d = abs(p.z)-thick;\n\treturn max(sdf2d, d);\n}\nfloat map(vec3 p){\n\tvec3 q=p,r = p;\n\tp.xy *= rot(time*.5);\n\tp.xz *= rot(time*.3);\n\tfloat ring1 = dRing(p, .8, .09, .1);\n\tq.xy *= rot(time*-1.3);\n\tq.xz *= rot(time*-1.);\n\tfloat ring2 = dRing(q, .62, .07, .1);\n\tr.yz *= rot(time*2.);\n\tr.xz *= rot(time*-2.);\n\tfloat ring3 = dRing(r, .47, .06, .1);\n\treturn min(ring1, min(ring2, ring3));\n}\n\nvec3 getNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmap(p)-map(vec3(p.x-EPS, p.yz)),\n\t\tmap(p)-map(vec3(p.x, p.y-EPS, p.z)),\n\t\tmap(p)-map(vec3(p.xy, p.z-EPS))\n\t\t));\n}\n\t\n\nvec4 render(vec2 coord ) {\n\n\tvec2 uv = (gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x, resolution.y);\n\tvec3 col = vec3(.1);\n\tvec3 ro = vec3(0.,0,10.);\n\tvec3 rd = normalize(vec3(uv, 0)-ro);\n\tvec3 cur = ro;\n\n\tfor(int i = 0; i <99;i++){\n\t\tfloat d = map(cur);\n\t\tif(d < EPS){\n\t\t\tvec3 normal = getNormal(cur);\n\t\t\tcol = vec3(.6, .68, .8);\n\t\t\tcol+= dot(normal, lightDir)+vec3(.1);\n\t\t\tbreak;\n\t\t}\n\t\tcur += rd*d;\n\t}\n\n\treturn vec4( col, 1.0 );\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = render(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3t3yzr", "name": "Universal Waves", "author": "oneshade", "description": "Sizing a grid of spheres based on where they lie inside a volume. The volume is layered using sin() and the layers get offset by iTime. The extremely tiny spheres on the outside unintentionally created a cool starry effect :)", "tags": ["raymarching", "fakevolumetric", "spheregrid"], "likes": 27, "viewed": 259, "date": "1608311733", "time_retrieved": "2024-06-20T20:25:48.526654", "image_code": "// Hue to RGB conversion from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(h) 0.6 + 0.6 * cos(6.3 * h + vec3(0.0, 23.0, 21.0))\n\nfloat mapVolume(in vec3 p) {\n    float volume = dot(sin(0.5 * p), vec3(1.0));\n    float layers = sin(3.0 * volume - 2.0 * iTime);\n    return max(layers, volume);\n}\n\nfloat mapScene(in vec3 p) {\n    p /= 0.75;\n    vec3 cell = floor(p) * 0.75;\n    vec3 local = fract(p) * 0.75;\n    return (length(local - 0.325) + 0.3 * min(0.0, mapVolume(cell + 0.325))) * 0.6;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = 0.25 * iTime;\n    float c = cos(time), s = sin(time);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float dt = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(c, s, -s, c);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.xz *= mat2(c, -s, s, c);\n            n.yz *= mat2(c, -s, s, c);\n\n            fragColor.rgb += hue2rgb(0.2 * length(p) + time);\n            fragColor.rgb *= max(0.3, dot(n, l));\n            break;\n        }\n\n        if (dt > 20.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tccRn", "name": "GLSLLangSpec4607 snippets", "author": "gwiazdorrr", "description": "A collection of \"The OpenGL Shading Language, Version 4.60.7\" snippets", "tags": ["cxxswizzle"], "likes": 1, "viewed": 168, "date": "1608625080", "time_retrieved": "2024-06-20T20:25:50.926784", "image_code": "#define ISOK(x) x // ok\n#define ILGL(x)   // ok, illegal code according to the doc\n#define FAIL(x)   // general fail\n#define SNTX(x)   // failed - syntax error\n#define RSVD(x)   // failed - reserved keyword\n#define OVRL(x)   // failed - overload not found\n#define EXTS(x)   // failed - need an extension\n\n// 4.1. Basic Types\n\n//void _void;\nISOK(bool _bool;)\nISOK(int _int;)\nISOK(uint _uint;)\nISOK(float _float;)\nRSVD(double _double;)\nISOK(vec2 _vec2;)\nISOK(vec3 _vec3;)\nISOK(vec4 _vec4;)\nRSVD(dvec2 _dvec2;)\nRSVD(dvec3 _dvec3;)\nRSVD(dvec4 _dvec4;)\nISOK(bvec2 _bvec2;)\nISOK(bvec3 _bvec3;)\nISOK(bvec4 _bvec4;)\nISOK(ivec2 _ivec2;)\nISOK(ivec3 _ivec3;)\nISOK(ivec4 _ivec4;)\nISOK(uvec2 _uvec2;)\nISOK(uvec3 _uvec3;)\nISOK(uvec4 _uvec4;)\nISOK(mat2 _mat2;)\nISOK(mat3 _mat3;)\nISOK(mat4 _mat4;)\nISOK(mat2x2 _mat2x2;)\nISOK(mat2x3 _mat2x3;)\nISOK(mat2x4 _mat2x4;)\nISOK(mat3x2 _mat3x2;)\nISOK(mat3x3 _mat3x3;)\nISOK(mat3x4 _mat3x4;)\nISOK(mat4x2 _mat4x2;)\nISOK(mat4x3 _mat4x3;)\nISOK(mat4x4 _mat4x4;)\nRSVD(dmat2 _dmat2;)\nRSVD(dmat3 _dmat3;)\nRSVD(dmat4 _dmat4;)\nRSVD(dmat2x2 _dmat2x2;)\nRSVD(dmat2x3 _dmat2x3;)\nRSVD(dmat2x4 _dmat2x4;)\nRSVD(dmat3x2 _dmat3x2;)\nRSVD(dmat3x3 _dmat3x3;)\nRSVD(dmat3x4 _dmat3x4;)\nRSVD(dmat4x2 _dmat4x2;)\nRSVD(dmat4x3 _dmat4x3;)\nRSVD(dmat4x4 _dmat4x4;)\n\n// TODO: update fails\nSNTX(sampler1D _sampler1D;)\nSNTX(texture1D _texture1D;)\nRSVD(image1D _image1D;)\nRSVD(sampler1DShadow _sampler1DShadow;)\nRSVD(sampler1DArray _sampler1DArray;)\nSNTX(texture1DArray _texture1DArray;)\nRSVD(image1DArray _image1DArray;)\nRSVD(sampler1DArrayShadow _sampler1DArrayShadow;)\nISOK(uniform sampler2D _sampler2D;)\nSNTX(texture2D _texture2D;)\nRSVD(image2D _image2D;)\nISOK(uniform highp sampler2DShadow _sampler2DShadow;)\nISOK(uniform highp sampler2DArray _sampler2DArray;)\nSNTX(texture2DArray _texture2DArray;)\nRSVD(image2DArray _image2DArray;)\nISOK(uniform highp sampler2DArrayShadow _sampler2DArrayShadow;)\nRSVD(sampler2DMS _sampler2DMS;)\nSNTX(texture2DMS _texture2DMS;)\nSNTX(image2DMS _image2DMS;)\nRSVD(sampler2DMSArray _sampler2DMSArray;)\nRSVD(texture2DMSArray _texture2DMSArray;)\nSNTX(image2DMSArray _image2DMSArray;)\nRSVD(uniform sampler2DRect _sampler2DRect;)\nSNTX(texture2DRect _texture2DRect;)\nSNTX(image2DRect _image2DRect;)\nRSVD(sampler2DRectShadow _sampler2DRectShadow;)\nISOK(uniform sampler3D _sampler3D;)\nSNTX(texture3D _texture3D;)\nRSVD(image3D _image3D;)\nISOK(uniform samplerCube _samplerCube;)\nSNTX(textureCube _textureCube;)\nRSVD(imageCube _imageCube;)\nISOK(uniform highp samplerCubeShadow _samplerCubeShadow;)\nSNTX(samplerCubeArray _samplerCubeArray;)\nSNTX(textureCubeArray _textureCubeArray;)\nSNTX(imageCubeArray _imageCubeArray;)\nSNTX(samplerCubeArrayShadow _samplerCubeArrayShadow;)\nRSVD(samplerBuffer _samplerBuffer;)\nSNTX(textureBuffer _textureBuffer;)\nRSVD(imageBuffer _imageBuffer;)\nRSVD(subpassInput _subpassInput;)\nRSVD(subpassInputMS _subpassInputMS;)\n\nSNTX(uniform isampler1D _isampler1D;)\nSNTX(uniform itexture1D _itexture1D;)\nRSVD(uniform iimage1D _iimage1D;)\nRSVD(uniform isampler1DArray _isampler1DArray;)\nSNTX(uniform itexture1DArray _itexture1DArray;)\nRSVD(uniform iimage1DArray _iimage1DArray;)\nISOK(uniform highp isampler2D _isampler2D;)\nSNTX(uniform itexture2D _itexture2D;)\nRSVD(uniform iimage2D _iimage2D;)\nISOK(uniform highp isampler2DArray _isampler2DArray;)\nSNTX(uniform itexture2DArray _itexture2DArray;)\nRSVD(uniform iimage2DArray _iimage2DArray;)\nRSVD(uniform isampler2DMS _isampler2DMS;)\nSNTX(uniform itexture2DMS _itexture2DMS;)\nSNTX(uniform iimage2DMS _iimage2DMS;)\nRSVD(uniform isampler2DMSArray _isampler2DMSArray;)\nSNTX(uniform itexture2DMSArray _itexture2DMSArray;)\nSNTX(uniform iimage2DMSArray _iimage2DMSArray;)\nRSVD(uniform isampler2DRect _isampler2DRect;)\nSNTX(uniform itexture2DRect _itexture2DRect;)\nSNTX(uniform iimage2DRect _iimage2DRect;)\nISOK(uniform highp isampler3D _isampler3D;)\nRSVD(uniform itexture3D _itexture3D;)\nRSVD(uniform iimage3D _iimage3D;)\nISOK(uniform highp isamplerCube _isamplerCube;)\nSNTX(uniform itextureCube _itextureCube;)\nRSVD(uniform iimageCube _iimageCube;)\nSNTX(uniform isamplerCubeArray _isamplerCubeArray;)\nSNTX(uniform itextureCubeArray _itextureCubeArray;)\nSNTX(uniform iimageCubeArray _iimageCubeArray;)\nRSVD(uniform isamplerBuffer _isamplerBuffer;)\nSNTX(uniform itextureBuffer _itextureBuffer;)\nRSVD(uniform iimageBuffer _iimageBuffer;)\nSNTX(uniform isubpassInput _isubpassInput;)\nSNTX(uniform isubpassInputMS _isubpassInputMS;)\n\nSNTX(uniform usampler1D _usampler1D;)\nSNTX(uniform utexture1D _utexture1D;)\nRSVD(uniform uimage1D _uimage1D;)\nRSVD(uniform usampler1DArray _usampler1DArray;)\nSNTX(uniform utexture1DArray _utexture1DArray;)\nRSVD(uniform uimage1DArray _uimage1DArray;)\nISOK(uniform highp usampler2D _usampler2D;)\nSNTX(uniform utexture2D _utexture2D;)\nRSVD(uniform uimage2D _uimage2D;)\nISOK(uniform highp usampler2DArray _usampler2DArray;)\nSNTX(uniform utexture1DArray _utexture1DArray;)\nRSVD(uniform uimage2DArray _uimage2DArray;)\nRSVD(uniform usampler2DMS _usampler2DMS;)\nSNTX(uniform utexture2DMS _utexture2DMS;)\nSNTX(uniform uimage2DMS _uimage2DMS;)\nRSVD(uniform usampler2DMSArray _usampler2DMSArray;)\nSNTX(uniform utexture2DMSArray _utexture2DMSArray;)\nSNTX(uniform uimage2DMSArray _uimage2DMSArray;)\nRSVD(uniform usampler2DRect _usampler2DRect;)\nSNTX(uniform utexture2DRect _utexture2DRect;)\nSNTX(uniform uimage2DRect _uimage2DRect;)\nISOK(uniform highp usampler3D _usampler3D;)\nRSVD(uniform utexture3D _utexture3D;)\nRSVD(uniform uimage3D _uimage3D;)\nISOK(uniform highp usamplerCube _usamplerCube;)\nSNTX(uniform utextureCube _utextureCube;)\nRSVD(uniform uimageCube _uimageCube;)\nSNTX(uniform usamplerCubeArray _usamplerCubeArray;)\nSNTX(uniform utextureCubeArray _utextureCubeArray;)\nSNTX(uniform uimageCubeArray _uimageCubeArray;)\nRSVD(uniform usamplerBuffer _usamplerBuffer;)\nSNTX(uniform utextureBuffer _utextureBuffer;)\nRSVD(uniform uimageBuffer _uimageBuffer;)\nRSVD(uniform atomic_uint _atomic_uint;)\nSNTX(uniform usubpassInput _usubpassInput;)\nSNTX(uniform usubpassInputMS _usubpassInputMS;)\n\nSNTX(uniform sampler _sampler;)\nSNTX(uniform samplerShadow _samplerShadow;)\n\n\nvoid _5_4_1_Conversion_and_Scalar_Constructors()\n{\n    ISOK(int(_uint);) // converts an unsigned integer to a signed integer\n    ISOK(int(_bool);) // converts a Boolean value to an int\n    ISOK(int(_float);) // converts a float value to an int\n    RSVD(int(_double);) // converts a double value to a signed integer\n    ISOK(uint(_int);) // converts a signed integer value to an unsigned integer\n    ISOK(uint(_bool);) // converts a Boolean value to an unsigned integer\n    ISOK(uint(_float);) // converts a float value to an unsigned integer\n    RSVD(uint(_double);) // converts a double value to an unsigned integer\n    ISOK(bool(_int);) // converts a signed integer value to a Boolean\n    ISOK(bool(_uint);) // converts an unsigned integer value to a Boolean value\n    ISOK(bool(_float);) // converts a float value to a Boolean\n    RSVD(bool(_double);) // converts a double value to a Boolean\n    ISOK(float(_int);) // converts a signed integer value to a float\n    ISOK(float(_uint);) // converts an unsigned integer value to a float value\n    ISOK(float(_bool);) // converts a Boolean value to a float\n    RSVD(float(_double);) // converts a double value to a float\n    RSVD(double(_int);) // converts a signed integer value to a double\n    RSVD(double(_uint);) // converts an unsigned integer value to a double\n    RSVD(double(_bool);) // converts a Boolean value to a double\n    RSVD(double(_float);) // converts a float value to a double\n}\n\nvoid _5_4_2_Vector_and_Matrix_Constructors()\n{\n    ISOK(vec3(_float);) // initializes each component of the vec3 with the float\n\tISOK(vec4(_ivec4);) // makes a vec4 with component-wise conversion\n\tISOK(vec4(_mat2);) // the vec4 is column 0 followed by column 1\n\tISOK(vec2(_float, _float);) // initializes a vec2 with 2 floats\n\tISOK(ivec3(_int, _int, _int);) // initializes an ivec3 with 3 ints\n\tISOK(bvec4(_int, _int, _float, _float);) // uses 4 Boolean conversions\n\tISOK(vec2(_vec3);) // drops the third component of a vec3\n\tISOK(vec3(_vec4);) // drops the fourth component of a vec4\n\tISOK(vec3(_vec2, _float);) // vec3.x = vec2.x, vec3.y = vec2.y, vec3.z = float\n\tISOK(vec3(_float, _vec2);) // vec3.x = float, vec3.y = vec2.x, vec3.z = vec2.y\n\tISOK(vec4(_vec3, _float);)\n\tISOK(vec4(_float, _vec3);)\n\tISOK(vec4(_vec2, _vec2);)\n\n\tISOK(vec4 color = vec4(0.0, 1.0, 0.0, 1.0);)\n\tISOK(vec4 rgba = vec4(1.0);) // sets each component to 1.0\n\tISOK(vec3 rgb = vec3(color);) // drop the 4th component\n\n\tISOK(mat2(_float);)\n\tISOK(mat3(_float);)\n\tISOK(mat4(_float);)\n\n\tISOK(mat2(_vec2, _vec2);) // one column per argument\n\tISOK(mat3(_vec3, _vec3, _vec3);) // one column per argument\n\tISOK(mat4(_vec4, _vec4, _vec4, _vec4);) // one column per argument\n\tISOK(mat3x2(_vec2, _vec2, _vec2);) // one column per argument\n    RSVD(dmat2(_dvec2, _dvec2);)\n\tRSVD(dmat3(_dvec3, _dvec3, _dvec3);)\n\tRSVD(dmat4(_dvec4, _dvec4, _dvec4, _dvec4);)\n\tISOK(mat2(_float, _float, // first column\n\t _float, _float);) // second column\n\tISOK(mat3(_float, _float, _float, // first column\n\t _float, _float, _float, // second column\n\t _float, _float, _float);) // third column\n\tISOK(mat4(_float, _float, _float, _float, // first column\n\t _float, _float, _float, _float, // second column\n\t _float, _float, _float, _float, // third column\n\t _float, _float, _float, _float);) // fourth column\n\tISOK(mat2x3(_vec2, _float, // first column\n\t _vec2, _float);) // second column\n\tRSVD(dmat2x4(_dvec3, _double, // first column\n\t _double, _dvec3);) // second column\n\n\tISOK(mat3x3(_mat4x4);) // takes the upper-left 3x3 of the mat4x4\n\tISOK(mat2x3(_mat4x2);) // takes the upper-left 2x2 of the mat4x4, last row is 0,0\n\tISOK(mat4x4(_mat3x3);) // puts the mat3x3 in the upper-left, sets the lower right\n\t // component to 1, and the rest to 0\n}\n\nvoid _5_4_3_StructureConstructors()\n{\n    struct light {\n     float intensity;\n     vec3 position;\n    };\n    light lightVar = light(3.0, vec3(1.0, 2.0, 3.0));\n}\n\nvoid _5_4_4_ArrayConstructors()\n{\n    {\n        const float c[3] = float[3](5.0, 7.2, 1.1);\n        const float d[3] = float[](5.0, 7.2, 1.1);\n        float g;\n        // ...\n        float a[5] = float[5](g, 1.0, g, 2.3, g);\n        float b[3];\n        b = float[3](g, g + 1.0, g + 2.0);\n    }\n    {\n        vec4 b[2];\n        RSVD(vec4[3][2](b, b, b);) // constructor\n        RSVD(vec4[][2](b, b, b);) // constructor, valid, size deduced\n        RSVD(vec4[3][](b, b, b);) // constructor, valid, size deduced\n        RSVD(vec4[][](b, b, b);)\n    }\n}\n\nvoid _5_5_Vector_and_Scalar_Components_and_Length()\n{\n    {\n        vec2 pos;\n        float height;\n        pos.x; // is legal\n        ILGL(pos.z;) // is illegal\n        SNTX(height.x;) // is legal\n        ILGL(height.y;) // is illegal\n    }\n    {\n        vec4 v4;\n        v4.rgba; // is a vec4 and the same as just using v4,\n        v4.rgb; // is a vec3,\n        v4.b; // is a float,\n        v4.xy; // is a vec2,\n        ILGL(v4.xgba;) // is illegal - the component names do not come from the same set\n    }\n    {\n        vec4 v4;\n        ILGL(v4.xyzwxy;) // is illegal since it has 6 components\n        ILGL((v4.xyzwxy).xy;) // is illegal since the intermediate value has 6 components\n    }\n    {\n        vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);\n        vec4 swiz = pos.wzyx; // swiz = (4.0, 3.0, 2.0, 1.0)\n        vec4 dup = pos.xxyy; // dup = (1.0, 1.0, 2.0, 2.0)\n    }\n    {\n        vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);\n        pos.xw = vec2(5.0, 6.0); // pos = (5.0, 2.0, 3.0, 6.0)\n        pos.wx = vec2(7.0, 8.0); // pos = (8.0, 2.0, 3.0, 7.0)\n        ILGL(pos.xx = vec2(3.0, 4.0);) // illegal - 'x' used twice\n        ILGL(pos.xy = vec3(1.0, 2.0, 3.0);) // illegal - mismatch between vec2 and vec3\n    }\n    {\n        vec3 v;\n        SNTX(const int L = v.length();)\n    }\n}\n\nvoid _5_6_Matrix_Components()\n{\n    {\n        mat4 m;\n        m[1] = vec4(2.0); // sets the second column to all 2.0\n        m[0][0] = 1.0; // sets the upper left element to 1.0\n        m[2][3] = 2.0; // sets the 4th element of the third column to 2.0\n    }\n    {\n        mat3x4 v;\n        SNTX(const int L = v.length();)\n    }\n}\n\nvoid _5_7_Structure_and_Array_Operations()\n{\n    float diffuseColor, NdotL;\n    float lightIntensity[4];\n    diffuseColor += lightIntensity[3] * NdotL;\n    lightIntensity.length(); // return the size of the array\n}\n\nvoid _5_10_Vector_and_Matrix_Operations()\n{\n    {\n        vec3 v, u;\n        float f;\n        v = u + f;\n        v.x = u.x + f;\n        v.y = u.y + f;\n        v.z = u.z + f;\n    }\n    {\n        vec3 v, u, w;\n        w = v + u;\n        w.x = v.x + u.x;\n        w.y = v.y + u.y;\n        w.z = v.z + u.z;\n    }\n    {\n        vec3 v, u;\n        mat3 m;\n        u = v * m;\n        u.x = dot(v, m[0]); // m[0] is the left column of m\n        u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b\n        u.z = dot(v, m[2]);\n        u = m * v;\n        u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;\n        u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;\n        u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;\n    }\n    {\n        mat3 m, n, r;\n        r = m * n;\n        r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;\n        r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;\n        r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;\n        r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;\n        r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;\n        r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;\n        r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;\n        r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;\n        r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;\n    }\n}\n\n// 6.1. Function Definitions\n#define returnType float\n#define type0 float\n#define type1 float\n#define typen float\n\n// prototype\nreturnType functionName (type0 arg0, type1 arg1, typen argn);\n\n// definition\nreturnType functionName (type0 arg0, type1 arg1, typen argn)\n{\n     // do some computation\n     return 0.0;\n}\n\nfloat myfunc (float f, out float g); // g is an output paramete\n\nvoid func1() { }\nILGL(void func2() { return func1(); }) // illegal return statement\n\nvec4 f(in vec4 x, out vec4 y) { return _vec4; } // (A)\nvec4 f(in vec4 x, out uvec4 y) { return _vec4; } // (B) okay, different argument type\nRSVD(vec4 f(in ivec4 x, out dvec4 y);) // (C) okay, different argument type\nILGL(int f(in vec4 x, out vec4 y);) // error, only return type differs\nILGL(vec4 f(in vec4 x, in vec4 y);) // error, only qualifier differs\nILGL(vec4 f(const in vec4 x, out vec4 y);) // error, only qualifier differs\n\nvoid _6_1_test()\n{\n    f(_vec4, _vec4); // exact match of vec4 f(in vec4 x, out vec4 y)\n    f(_vec4, _uvec4); // exact match of vec4 f(in vec4 x, out uvec4 y)\n    OVRL(f(_vec4, _ivec4);) // matched to vec4 f(in vec4 x, out vec4 y)\n     // (C) not relevant, can't convert vec4 to\n     // ivec4. (A) better than (B) for 2nd\n     // argument (rule 3), same on first argument.\n    ILGL(f(_ivec4, _vec4);) // NOT matched. All three match by implicit\n     // conversion. (C) is better than (A) and (B)\n     // on the first argument. (A) is better than\n     // (B) and (C).\n}\n\n\nvoid _6_4_Jumps() \n{\n    float intensity;\n    if (intensity < 0.0)\n        discard;\n    vec4  v = gl_FragCoord;\n}\n\nvoid _7_1_5_Fragment_Shader_Special_Variables()\n{\n    ISOK(gl_FragCoord;)\n    ISOK(gl_FrontFacing;) \n    FAIL(gl_ClipDistance;)\n    FAIL(gl_CullDistance;)\n    ISOK(gl_PointCoord;) \n    FAIL(gl_PrimitiveID; )\n    FAIL(gl_SampleID; )\n    FAIL(gl_SamplePosition;)\n    FAIL(gl_SampleMaskIn;)\n    FAIL(gl_Layer;)\n    FAIL(gl_ViewportIndex;)\n    FAIL(gl_HelperInvocation;)\n    ISOK(gl_FragDepth;)\n    FAIL(gl_SampleMask;)\n}\n\nvoid _7_4_Built_In_Uniform_State()\n{\n    ISOK(gl_DepthRange;)\n    FAIL(gl_NumSamples);\n}\n\nvoid _8_1_Angle_and_Trigonometry_Functions()\n{\n#define _8_1_Angle_and_Trigonometry_Functions(genFType) \\\n    { genFType t = radians(genFType(0)); }\\\n    { genFType t = degrees(genFType(0)); }\\\n    { genFType t = sin(genFType(0)); }\\\n    { genFType t = cos(genFType(0)); }\\\n    { genFType t = tan(genFType(0)); }\\\n    { genFType t = asin(genFType(0)); }\\\n    { genFType t = acos(genFType(0)); }\\\n    { genFType t = atan(genFType(1), genFType(2)); }\\\n    { genFType t = atan(genFType(1)); }\\\n    { genFType t = sinh(genFType(1)); }\\\n    { genFType t = cosh(genFType(1)); }\\\n    { genFType t = tanh(genFType(1)); }\\\n    { genFType t = asinh(genFType(1)); }\\\n    { genFType t = acosh(genFType(1)); }\\\n    { genFType t = atanh(genFType(0)); }\n    \n#define _8_2_Exponential_Functions(genFType)\\\n    { genFType t = pow(genFType(0), genFType(1)); }\\\n    { genFType t = exp(genFType(0)); }\\\n    { genFType t = log(genFType(1)); }\\\n    { genFType t = exp2(genFType(0)); }\\\n    { genFType t = log2(genFType(1)); }\\\n    { genFType t = sqrt(genFType(0)); }\\\n    { genFType t = inversesqrt(genFType(1)); };\n\n#define _8_3_Common_Functions(genFType, genDType, genIType, genUType, genBType)\\\n    ISOK({ genFType t = abs(genFType(0)); })\\\n    ISOK({ genIType t = abs(genIType(0)); })\\\n\tRSVD({ genDType t = abs(genDType(0));; })\\\n    ISOK({ genFType t = sign(genFType(0)); })\\\n    ISOK({ genIType t = sign(genIType(0)); })\\\n    RSVD({ genDType t = sign(genDType(0)); })\\\n    ISOK({ genFType t = floor(genFType(0)); })\\\n    RSVD({ genDType t = floor(genDType(0)); })\\\n    ISOK({ genFType t = trunc(genFType(0)); })\\\n    RSVD({ genDType t = trunc(genDType(0)); })\\\n    ISOK({ genFType t = round(genFType(0)); })\\\n    RSVD({ genDType t = round(genDType(0)); })\\\n    ISOK({ genFType t = roundEven(genFType(0)); })\\\n    RSVD({ genDType t = roundEven(genDType(0)); })\\\n    ISOK({ genFType t = ceil(genFType(0)); })\\\n    RSVD({ genDType t = ceil(genDType(0)); })\\\n    ISOK({ genFType t = fract(genFType(0)); })\\\n    RSVD({ genDType t = fract(genDType(0)); })\\\n    ISOK({ genFType t = mod(genFType(0), float(0)); })\\\n    ISOK({ genFType t = mod(genFType(0), genFType(0)); })\\\n    RSVD({ genDType t = mod(genDType(0), double(0)); })\\\n    RSVD({ genDType t = mod(genDType(0), genDType(0)); })\\\n    ISOK({ genFType o; genFType t = modf(genFType(0), o); })\\\n    RSVD({ genDType t = modf(genDType(0), genDType(0)); })\\\n    ISOK({ genFType t = min(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = min(genFType(0), float(0)); })\\\n    RSVD({ genDType t = min(genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = min(genDType(0), double(0)); })\\\n    ISOK({ genIType t = min(genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = min(genIType(0), int(0)); })\\\n    ISOK({ genUType t = min(genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = min(genUType(0), uint(0)); })\\\n    ISOK({ genFType t = max(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = max(genFType(0), float(0)); })\\\n    RSVD({ genDType t = max(genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = max(genDType(0), double(0)); })\\\n    ISOK({ genIType t = max(genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = max(genIType(0), int(0)); })\\\n    ISOK({ genUType t = max(genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = max(genUType(0), uint(0)); })\\\n    ISOK({ genFType t = clamp(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = clamp(genFType(0), float(0), float(0)); })\\\n    RSVD({ genDType t = clamp(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = clamp(genDType(0), double(0), double(0)); })\\\n    ISOK({ genIType t = clamp(genIType(0), genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = clamp(genIType(0), int(0), int(0)); })\\\n    ISOK({ genUType t = clamp(genUType(0), genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = clamp(genUType(0), uint(0), uint(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), float(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), double(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), genBType(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), genBType(0)); })\\\n    OVRL({ genIType t = mix(genIType(0), genIType(0), genBType(0)); })\\\n    OVRL({ genUType t = mix(genUType(0), genUType(0), genBType(0)); })\\\n    OVRL({ genBType t = mix(genBType(0), genBType(0), genBType(0)); })\\\n    ISOK({ genFType t = step(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = step(float(0), genFType(0)); })\\\n    RSVD({ genDType t = step(genDType(0), genDType(0)); })\\\n    RSVD({ genFType t = step(double(0), genDType(0)); })\\\n    ISOK({ genFType t = smoothstep(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = smoothstep(float(0), float(0), genFType(0)); })\\\n    RSVD({ genDType t = smoothstep(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = smoothstep(double(0), double(0), genDType(0)); })\\\n    ISOK({ genBType t = isnan(genFType(0)); })\\\n    RSVD({ genBType t = isnan(genDType(0)); })\\\n    ISOK({ genBType t = isinf(genFType(0)); })\\\n    RSVD({ genBType t = isinf(genDType(0)); })\\\n    ISOK({ genIType t = floatBitsToInt(genFType(0)); })\\\n    ISOK({ genUType t = floatBitsToUint(genFType(0)); })\\\n    ISOK({ genFType t = intBitsToFloat(genIType(0)); })\\\n    ISOK({ genFType t = uintBitsToFloat(genUType(0)); })\\\n    OVRL({ genFType t = fma(genFType(0), genFType(0), genFType(0)); })\\\n    OVRL({ genFType t = fma(genDType(0), genDType(0), genDType(0)); })\\\n    OVRL({ genFType t = frexp(highpgenFType(0), genIType(0)); })\\\n    OVRL({ genFType t = frexp(genDType(0), genIType(0)); })\\\n    OVRL({ genFType t = ldexp(highpgenFType(0), genIType(0)); })\\\n    OVRL({ genFType t = ldexp(genDType(0), genIType(0); }))\n    \n#define _8_5_Geometric_Functions(genFType)\\\n    { float t = length(genFType(0)); }\\\n    { float t = distance(genFType(0),genFType(0)); }\\\n    { float t = dot(genFType(0),genFType(0)); }\\\n    { vec3 t = cross(vec3(0), vec3(0)); }\\\n    { genFType t = normalize(genFType(0)); }\\\n    { genFType t = faceforward(genFType(0),genFType(0),genFType(0)); }\\\n    { genFType t = reflect(genFType(0),genFType(0)); }\\\n    { genFType t = refract(genFType(0),genFType(0),float(0)); }\\\n    \n#define _8_7_Vector_Relational_Functions(bvec, vec, ivec, uvec) \\\n    { bvec t = lessThan(vec(0), vec(0));}\\\n    { bvec t = lessThan(ivec(0), ivec(0));}\\\n    { bvec t = lessThan(uvec(0), uvec(0));}\\\n    { bvec t = lessThanEqual(vec(0), vec(0));}\\\n    { bvec t = lessThanEqual(ivec(0), ivec(0));}\\\n    { bvec t = lessThanEqual(uvec(0), uvec(0));}\\\n    { bvec t = greaterThan(vec(0), vec(0));}\\\n    { bvec t = greaterThan(ivec(0), ivec(0));}\\\n    { bvec t = greaterThan(uvec(0), uvec(0));}\\\n    { bvec t = greaterThanEqual(vec(0), vec(0));}\\\n    { bvec t = greaterThanEqual(ivec(0), ivec(0));}\\\n    { bvec t = greaterThanEqual(uvec(0), uvec(0));}\\\n    { bvec t = equal(vec(0), vec(0));}\\\n    { bvec t = equal(ivec(0), ivec(0));}\\\n    { bvec t = equal(uvec(0), uvec(0));}\\\n    { bvec t = equal(bvec(0), bvec(0));}\\\n    { bvec t = notEqual(vec(0), vec(0));}\\\n    { bvec t = notEqual(ivec(0), ivec(0));}\\\n    { bvec t = notEqual(uvec(0), uvec(0));}\\\n    { bvec t = notEqual(bvec(0), bvec(0));}\\\n    { bool t = any(bvec(0));}\\\n    { bool t = all(bvec(0));}\\\n    { bvec t = not(bvec(0));}\\\n    \n    _8_1_Angle_and_Trigonometry_Functions(float)\n    _8_1_Angle_and_Trigonometry_Functions(vec2)\n    _8_1_Angle_and_Trigonometry_Functions(vec3)\n    _8_1_Angle_and_Trigonometry_Functions(vec4)\n    \n    _8_2_Exponential_Functions(float)\n    _8_2_Exponential_Functions(vec2)\n    _8_2_Exponential_Functions(vec3)\n    _8_2_Exponential_Functions(vec4)\n    \n    _8_3_Common_Functions(float, double, int, uint, bool)\n    _8_3_Common_Functions(vec2, dvec2, ivec2, uvec2, bvec2)\n    _8_3_Common_Functions(vec3, dvec3, ivec3, uvec3, bvec3)\n    _8_3_Common_Functions(vec4, dvec4, ivec4, uvec4, bvec4)\n    \n    _8_5_Geometric_Functions(float)\n    _8_5_Geometric_Functions(vec2)\n    _8_5_Geometric_Functions(vec3)\n    _8_5_Geometric_Functions(vec4)\n    \n    _8_7_Vector_Relational_Functions(bvec2, vec2, ivec2, uvec2)\n    _8_7_Vector_Relational_Functions(bvec3, vec3, ivec3, uvec3)\n    _8_7_Vector_Relational_Functions(bvec4, vec4, ivec4, uvec4)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tccRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tcyD4", "name": "flatpack circles", "author": "HaleyHalcyon", "description": "a", "tags": ["spiral"], "likes": 1, "viewed": 73, "date": "1609030847", "time_retrieved": "2024-06-20T20:25:50.926784", "image_code": "#define TAU (3.14159265358979 * 2.)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nmat2x3 randCol(uint x) {\n    uvec3 col0 = uvec3(\n         x        & 1u,\n        (x >> 1u) & 1u,\n        (x >> 2u) & 1u\n    );\n    uint y = x ^ ((x >> 3u) % 6u + 1u);\n    uvec3 col2 = uvec3(\n         y        & 1u,\n        (y >> 1u) & 1u,\n        (y >> 2u) & 1u\n    );\n    return mat2x3(col0, col2);\n}\n\nfloat logStripe(vec2 uv, float offset, float angleAdd) {\n    return fract(offset + 2. * log(abs(dot(\n        uv, vec2(cos(angleAdd), sin(angleAdd))\n    ))+0.03));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rotLen = 10.;\n    float distLen = 0.4;\n    float loopLen = 60. * rotLen * distLen;\n    \n    float T = mod(iTime, loopLen);\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = length(iResolution);\n    vec2 uv = fragCoord / scale;\n\tuv -= (iResolution.xy / scale) / 2.;\n    uv *= 2.0;\n    \n    float distSq = uv.x*uv.x+uv.y*uv.y;\n    float angle = atan(uv.x, uv.y);\n    float angleAdd = fract(T / rotLen);\n    float distAdd = fract(T / distLen);\n    \n    float which = (step(fract(angleAdd * 2. + angle * 2. / TAU + distSq * 0.21), .5));\n    \n    float progress = mod(which * 4. + distSq * 3. + T, loopLen);\n    \n    uint colID = hash(uint(int(progress)));\n    mat2x3 colors = randCol(colID);\n    vec3 colA = mix(colors[0], colors[1],\n      logStripe(uv, distAdd, angleAdd * TAU)\n    );\n    vec3 colB = mix(colors[0], colors[1],\n      logStripe(uv, distAdd, angleAdd * TAU + TAU / 4.)\n    );\n    \n    vec3 col = mix(colA, colB, which) * 0.8 + fract(progress) * 0.2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tcyD7", "name": "Cyclic Noise Explanation", "author": "jeyko", "description": "This is a modification and explanation of Cyclic Noise, which is created by nimitz.", "tags": ["noise", "warp", "cyclic", "cyclicnoise"], "likes": 28, "viewed": 556, "date": "1609236162", "time_retrieved": "2024-06-20T20:25:51.593438", "image_code": "// Cyclic noise is created by nimitz.\n// He uses it a lot, like in here: https://www.shadertoy.com/view/wl3czN\n// I just rewrote his code, renamed some variables and tried to explain it a bit.\n\n// Left is vanilla \n// Right is the derivative, fed into a pallete\n\n// The basic structure of the loop is like an fbm.\n// You are stacking octaves of noise.\n// But the noise itself is generated in an interesting way:\n// You do something like a 1-tap dot prodcut (Perlin,Simplex) noise inside of a sinewave lattice.\n// Then you apply some rotation and scale, and repeat. \n\n\n// Turbulent noise is \n// 1.-abs(noise)\n//#define TURBULENT\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    #ifdef TURBULENT\n    return 1. - abs(noise)*0.5;\n    #else\n    return (noise*0.25 + 0.5);\n    #endif\n}\n\n\nfloat get(vec2 uv){\n    float noise = cyclicNoise(vec3(uv*10.,iTime));\n    float noiseb = cyclicNoise(vec3(uv*10. - 3.,iTime) - noise*1.);\n\n    return noiseb*pow(max(noise,0.),1.) - (1.-  noise)* (abs(noise)*.4 );\n}\n\n// Bruteforce derivative. \n// You could calculate this analyticall inside of cyclicNoise() \n// if you wished to do so, and it would be much cheaper \nvec2 derivative(vec2 uv, float eps){\n    vec2 t = vec2(eps,0);\n    return vec2(\n        get(uv + t.xy) - get(uv - t.xy),\n        get(uv + t.yx) - get(uv - t.yx)\n        );\n}\n\n// iq pallete: https://iquilezles.org/www/articles/palettes/palettes.htm\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0);\n    \n    if(fragCoord.x > iResolution.x/2.){\n        float noise = get(uv);\n        vec2 dxdy = derivative(uv,0.003).xy;\n        col += pal(0.5,0.5,vec3(1,2,4),1.,dxdy.x*19. + iTime )*pow(max(noise,0.),0.9);\n    \n    } else {\n        float noise = cyclicNoise(vec3(uv*10.,iTime));\n        col += pal(0.5,0.5,vec3(1,2,4),1.,noise + iTime )*pow(max(noise,0.),0.9);\n    \n    }\n    \n    // gamma correction\n    col = pow(max(col,0.),vec3(0.4545));\n    //col = pow(abs(col),vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tcyDN", "name": "RGBdiskrun", "author": "Velial", "description": "...", "tags": ["gogogo"], "likes": 0, "viewed": 51, "date": "1609065661", "time_retrieved": "2024-06-20T20:25:51.593438", "image_code": "float disk (vec2 r,vec2 center, float radius) {\n    return 1.0 - smoothstep(radius-0.005, radius+0.005, length(r-center));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = 2.0*vec2(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 color_Red = vec3(1.0, 0.0, 0.0);\n    vec3 color_Blue = vec3(0.0, 1.0, 0.0);\n    vec3 color_Green = vec3(0.0, 0.0, 1.0);\n    \n    \n    vec3 bg = vec3(0.0);\n    float y=iTime*0.3;\n    y = mod(y, 2.0)-1.0;\n    float diskColor1 = disk(r,vec2(0.0,y), 0.5); \n    float diskColor2 = disk(r,vec2(y,y), 0.5);\n    float diskColor3 = disk(r,vec2(-y,y), 0.5);\n    vec3 ret1 = mix(bg, color_Red, diskColor1);\n    vec3 ret2 = mix(bg, color_Blue, diskColor2);    \n    vec3 ret3 = mix(bg, color_Green, diskColor3);\n    \n    \n    vec3 pixel = ret1+ret2+ret3;\n    fragColor = vec4(pixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tcyRr", "name": "fake transparency", "author": "CY5", "description": "he purpose of demo is to create fake transparency with 2 point light", "tags": ["transparency"], "likes": 0, "viewed": 50, "date": "1609434753", "time_retrieved": "2024-06-20T20:25:51.593438", "image_code": "// RayMarching lookup angles,plane, box ,sphere map and rand \n// in below src code taken from iq shadertoy demo\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n//The purpose of demo is to create fake transparency\n//2 point light source demo  c = c0+1/(kc+kl*d+kq*d*d)\n//https://www.shadertoy.com/view/wdKBRt\n\n\n#define PTL  1\n#define SPH   2\n#define PLN   3\n#define CUBE  4\n\n\n/*vec3  ptLight1Col = vec3(0.764,0.413,0.294);//cyan\nvec3  ptLight2Col = vec3(0.464,0.213,0.294);//magento*/\n\nvec3  ptLight1Col = vec3(1.0,0.0,0.0);//red\nvec3  ptLight2Col = vec3(0.0,0.8,0.0);//green\n\nvec2 randState;\n\nfloat rand()\n{\n   randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n   randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);        \n    \n   return randState.x;\n}\n\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 col;\n};\n\nstruct Ob\n{\n    float t;\n    vec3  c;\n    PointLight  ptL; \n    int prop;\n};\n\nfloat mapPlane(vec3 p)\n{\n    float r = 0.5;\n    float l = p.y + (r);\n    return l;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat quadEq(float t)\n{\n    return 1.0*t*t+t+0.01;\n}\nfloat mapCube(vec3 p, float r)\n{\n    //p=p-vec3(0.5,0.47,2.0);\n    p = p - vec3(0.4,0.4,0.4);\n    vec3 t = vec3(quadEq(p.x),quadEq(p.y),quadEq(p.z));\n    return length(t)-r;\n}\nfloat map(vec3 p)\n{\n    \n\tfloat sp = sdBox(p,vec3(0.5,0.5,0.5));\n    return sp;\n}\n\nOb map1(vec3 p)\n{\n    Ob o;\n    float tme = iTime*0.5;\n    vec3 pt2 = vec3(0.1*cos(tme),0.0,0.3*sin(tme));\n    vec3 pt1 = vec3(0.3*sin(tme),0.0,0.1*cos(tme));\n    \n    vec3 mov = p-pt1;\n    vec3 mov1 =  p-pt2;\n\tfloat sp = mapCube(p,0.25);\n    float p1 = length(mov)-0.02;\n    float p2 =  length(mov1)-0.02;\n    \n    o.t = min(min(p1,p2),sp);\n    \n    o.ptL.pos = min(mov,mov1);\n    \n    vec3 A= ptLight2Col*(1.0-p2)+ptLight1Col*p2;\n    vec3 B= ptLight1Col*(1.0-p1)+ptLight2Col*p1;\n    \n    o.ptL.col = mix(A,B,0.5);\n    \n    if (sp < p1 && sp < p2)\n    {\n        o.c = vec3(0.1,0.1,0.2);\n        o.prop = CUBE;\n    \n    }\n    if (p1 < sp  && p1 < p2)\n    {\n        o.c = ptLight1Col;\n        o.prop = PTL;\n        \n    }\n    else if (p2 < sp && p2 < p1)\n    {\n        o.c = ptLight2Col;\n        o.prop = PTL;\n    }\n    return o;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec2 e = vec2(0.0001,0.0);\n\treturn normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n\t\t\t\t\t\t  map(pos+e.yxy)-map(pos-e.yxy),\n\t\t\t\t\t\t  map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\n\nfloat inCastRay(in vec3 ro, vec3 rd)\n{\n\tfloat t =0.0;\n\tfor(int i=0;i<100;i++)\n\t{\n\t\tvec3 pos = ro+t*rd;\n\t\tfloat h = map(pos);\n\t\tif (h<0.001)\n\t\t\tbreak;\n\t\tt+=h;\n\t\tif (t>20.0) break;\n\t}\n\tif (t>20.0) t=-0.1;\n\treturn t;\n}\n\nvoid castRay(in vec3 ro, vec3 rd,inout Ob o)\n{\n    float t =0.0;\n    for(int i=0;i<100;i++)\n    {\n        vec3 pos = ro+t*rd;\n        o = map1(pos);\n        float h = o.t;\n        if (h<0.001)\n            break;\n        t+=h;\n        if (t>20.0) break;\n    }\n    if (t>20.0) t=-0.1;\n    o.t =t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\trandState = (2.0*fragCoord-iResolution.xy)/iResolution.y ;\n\n\t/*float an = 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3(2.0*cos(an),-0.3,2.0*sin(an));*/\n    \n    float an = 10.0*fract(0.05*iTime)+iMouse.x/iResolution.x;\n    float up = cos(iTime)-an;\n    vec3 ro = vec3(2.0*cos(an),-0.3*up,2.0*sin(an));\n    \n\tvec3 ta = vec3(0.0,0.0,0.0);\n    \n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n                        \n\tvec3 rd = normalize(p.x*uu+p.y*vv+1.5*ww);\n    \n    vec3 col = vec3(0.0)-0.7*rd.y;\n    \n\tfloat t = inCastRay(ro, rd);\n\t\n    if (t > 0.0) \n\t{\n        vec3 pos = ro + t*rd;\n        \n        Ob o;\n        castRay(pos-rd, rd,o);\n        if (o.t > 0.0)\n        {\n            float d = length(o.ptL.pos);\n            float kc=0.1, kl=0.5,kq = 0.05;\n            vec3 oc = o.ptL.col;\n            col  = ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            \n        }\n    \n        vec3 nor = calcNormal(pos);\n        \n        nor +=normalize(vec3(0.0,0.0,0.5));\n        vec3 sun_light=vec3(0.3,0.5,0.1);\n\t\tvec3 mate = vec3(0.8,0.5,0.5);\n        float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n        float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float boun_dif = clamp(0.9-0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n        col = mix(mate,col,0.5);\n\t}\n    \n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tcyz4", "name": "candycane", "author": "tetrismegistus", "description": "an accident while striving for a sunset", "tags": ["beginner"], "likes": 0, "viewed": 173, "date": "1608517286", "time_retrieved": "2024-06-20T20:25:51.593438", "image_code": "#define PI 3.14159265359\n\n\nvec3 colorA = vec3(1.0, 1.0,1.0);\nvec3 colorB = vec3(1.0, 0.32352943,0.5019608);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float y = (sin(st.x) * PI + cos(st.y) * PI) * sin(abs(iTime));\n    vec3 color2 = vec3(y, 1., 1.);\n    float pct = sin(pow(max(0.0, abs(y) * 2.0 - 1.0), 2.5));\n    vec3 color = mix(colorA, colorB, pct);\n    fragColor = vec4(color, 1.0);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tdyzn", "name": "Breathing Grid 1", "author": "jllusty", "description": "A grid that breaths.", "tags": ["grid", "breathing"], "likes": 3, "viewed": 56, "date": "1608353777", "time_retrieved": "2024-06-20T20:25:51.593438", "image_code": "float pi = 4.*atan(1.);\n\nvec2 pForm(float t) {\n    return vec2(t,sin(2.*pi*t+iTime));\n}\n\nbool checkerboard(vec2 v) {\n    float sum = floor(v.x) + floor(v.y);\n    return mod(sum,2.) < .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  5.* ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 white = vec3(1.);\n    vec3 black = vec3(0.);\n    \n    vec3 col;\n    if(mod(uv.x,1.+(1.+cos(pi*iTime))/2.) < 1.) {\n        if(mod(uv.y,1.+(1.+cos(pi*iTime))/2.) < 1.) {\n            col = black;\n        }\n        else\n            col = white;\n    }\n    else {\n        if(mod(uv.y,1.+(1.+cos(pi*iTime))/2.) < 1.) {\n            col = white;\n        }\n        else\n            col = black;\n    }\n\n    //vec3 col = checkerboard(uv)?black:white;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tdyzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ttcRM", "name": "Quasicrystal 6", "author": "hoqqanen", "description": "Sum of waves", "tags": ["sine"], "likes": 3, "viewed": 43, "date": "1608680903", "time_retrieved": "2024-06-20T20:25:51.757243", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float speed = 2.0;\n    float t = speed * iTime;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    float wave0 = sin(uv.x*300.+iTime*.5);\n    float wave1 = sin((uv.x*.90096886+uv.y*.4338837)*300.+t);\n    float wave2 = sin((uv.x*.62348980185+uv.y*.78183148)*300.+t);\n    float wave3 = sin((uv.x*.22252093395+uv.y*.97492791218)*300.+t);\n    float wave4 = sin((uv.y*.97492791218-uv.x*.22252093395)*300.+t);\n    float wave5 = sin((uv.y*.78183148246-uv.x*.62348980185)*300.+t);\n    float wave6 = sin((uv.y*.43388373911-uv.x*.9009688679)*300.+t);\n    float z = 1.0/(1.0+exp(-1.0*(wave0+wave1+wave2+wave3+wave4+wave5+wave6)*2.));\n    fragColor = vec4(z,z,z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ttcRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ttcWM", "name": "weird vector boxes", "author": "Shellderr", "description": "weird boxes...", "tags": ["rainbow", "box", "vector"], "likes": 2, "viewed": 79, "date": "1609236154", "time_retrieved": "2024-06-20T20:25:51.757243", "image_code": "\nfloat box(vec2 coord, vec2 uv, float size, float w){\n   uv = 1.-uv;\n   coord.x = 1.-coord.x;\n   vec2 b = step(coord, uv) - step(coord,uv-size);\n   vec2 b2 = step(coord+w, uv) - step(coord,uv-(size-w));\n   return b.x * b.y - b2.x*b2.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float r = iResolution.y/iResolution.x;\n    uv.y *= r;\n   uv.x *= (uv.x/uv.y+abs(fract(iTime*0.3)-0.5)*2.);\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float b =0.;\n    \n    for(float i = 0.; i < 30.; i++){\n    \n    b +=  box(uv*vec2(.3,1.5),vec2(0.1+(i*0.018),0.6+(i*0.01)),0.05+i*0.019*abs(cos(iTime))*-1., -0.004*abs(cos(iTime)));\n\n    b +=  box(uv*vec2(.3,1.5),vec2(0.3+(i*0.018),0.6+(i*0.01)),0.05+i*0.019*abs(cos(2.+iTime))*-1., -0.004*abs(cos(2.+iTime)));\n\n    }\n    \n    fragColor = vec4( vec3(b)*col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ttcWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ttyR7", "name": "downthewell", "author": "shortwavedave", "description": "well", "tags": ["well"], "likes": 2, "viewed": 74, "date": "1608692195", "time_retrieved": "2024-06-20T20:25:51.884445", "image_code": "// Adapted from https://www.shadertoy.com/view/ltXGW4\n\nvoid mainImage( out vec4 c, vec2 p )\n{\n    vec2 uv = p/iResolution.y + vec2(.2,.5);\n    c.w = length(p = iTime*uv - iTime);\n    vec2 samp = vec2(atan(p.y,p.x)+.1*iTime, .9/c.w+10.*pow(sin(iTime/10.),6.));\n    vec4 c1 = texture( iChannel0, samp)*c.w;\n    vec4 c3 = texture( iChannel1, samp)*c.w;\n    vec4 c2 = vec4(.03,0.003,0.03,0.)/c.w;\n    c = (.7*c1 + .7*c2 + c1*.6*cos(iTime*1.3) + c3*.6*sin(iTime))/c.w;//length(c1+c2) ;//+.1*abs(cos(iTime));\n}\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ttyzM", "name": "Unstable radiation", "author": "Diapsid", "description": "Trying to take an existing code I made and see if I can get it to look like a quasi-crystal", "tags": ["pattern"], "likes": 9, "viewed": 147, "date": "1608683089", "time_retrieved": "2024-06-20T20:25:52.350849", "image_code": "#define M_PI = 3.14159265\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smoothClamp(float x, float a, float b)\n{\n    float t = clamp(x, a, b);\n    return t != x ? t : b + (a - b)/(1. + exp((b - a)*(2.*x - a - b)/((x - a)*(b - x))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159263;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float freq;\n    float radius;\n    float t;\n    float rot;\n    int numEl;\n    float scale = 1.; //how bright the image is. set very high for pure B/W, set lower for grayscale\n\n    t = iTime*0.007*60.; //a timing constant\n    freq = 90.; //busyness of screen\n    radius = 0.8*cos(t*0.012)+2.; //radius of circle of points\n    rot = 0.02; //how fast the screen rotates\n    numEl = 6; //number of radiators on ring\n    \n\n    \n    float col = 0.;\n    if(numEl%2==0){ //if the number of radiators is even, it'll be lined up well\n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy; //reset coordinate plane\n    uv.x *= iResolution.x/iResolution.y; //scale coordinates\n    uv.x -= 0.5*iResolution.x/iResolution.y; //move origin\n    uv.y-=0.5; //move origin\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t); //move to each point on ring\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t); //sum up the field magnitude at each point due to each radiator\n    //0.77 is a scaling factor. Set higher for wider color range.\n    }\n    }\n    \n    else{ //if number of radiators is odd, the ring needs to be rotated to be vertically symmetric\n    \n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= 0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t);\n    }  \n    }\n    uv = fragCoord/iResolution.xy;\n    uv.y-=60.;\n    //uv.x-=10.;\n    \n    col-=0.35;\n    col+=1.*smoothClamp((scale*1.)*(cos(freq*0.02*length(uv.y)-t*1.)), 0.0, 0.6);//change the constants in this for different effects\n    col=1.*abs(col); //icy. uncomment to defrost\n   \n    vec3 col2 = pal(col, vec3(0.5, 0.5, 0.5),\n                        \tvec3(0.5, 0.5, 0.5),\n                        \tvec3(1.0, 1.0, 1.0),\n                        \tvec3(0.0, 0.1, 0.2));\n    \n    fragColor = vec4(vec3(col2), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tBfD1", "name": "Jelly-Something-Audio", "author": "jarkob", "description": "added primitive audio reactivity to one of Kali's shaders", "tags": ["audio", "blob", "kali"], "likes": 4, "viewed": 267, "date": "1608204150", "time_retrieved": "2024-06-20T20:25:53.132889", "image_code": "// \"Jelly-something\" by Kali\n// \n// slightly modified from https://www.shadertoy.com/view/MlXGzr\n// basically nothing changed, except some audio reactivity\n// need this code for party projections\n\nconst int Iterations=7;  \nconst float Wavelength=.5; \nconst float Scale=1.5; \nconst float Amplitude=.1; \nconst float Speed=.3; \n\nvec3 z;\nvec4 vv;\n\nconst vec3 fore=vec3(200.,20.,30.)/255.;\nconst vec3 back=vec3(45.,52.,55.)/255.;\nconst vec3 innards=vec3(250.,0.,0.)/255.;\nconst float detail=.04;\n\nconst vec3 lightdir=-vec3(-1.0,0.5,-0.5);\n\nmat2 rot2D(float angle)\n{\n\tfloat a=radians(angle) * vv.g;\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n\n}\n\nvoid vvv() {\n    for( int i=0; i<4; i++ )\n\t{\n        vv[i] = texture(iChannel0, vec2(float(i)/6.0, .01)).r;\n\t}\n}\n\n\nfloat de (in vec3 p);\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn vv.r * normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n\nvec3 light(in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*fore+pow(spec,40.)*.4+fore*.2+back*.3;\t\n\t\t}\n\nfloat kaliset(vec3 p) {\n\tp.x+=.23;\n\tp.z+=.18;\n    p*=.5;\n    p.y+=iTime*1.5;\n    p.y=abs(2.-mod(p.y,4.));\n    for (int i=0;i<8;i++) p=abs(p)/dot(p,p)-.8;\n    return p.y;\n}\n\nfloat rnd(vec2 co){\n\treturn fract(sin(iTime*.1+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n    vec3 odir=dir;\n    float totdist=0., v=0.;\n\tvec3 col=vec3(0.), p;\n\tfloat d=9999.;\n\tfor (int i=0; i<80; i++) {\n        if (d>detail && totdist<50.) {\n        \tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\ttotdist+=d*.8; \n            v++;\n\t\t\tdir=normalize(odir+pow(max(0.,totdist*totdist-9.),2.)*.0000003*vec3(rnd(dir.xy*5.21358),rnd(dir.yz*3.12568),rnd(dir.zx*2.12358)));\n        }\n\t}\n\ttotdist=min(50.,totdist);\n\t\tdir=normalize(odir+.1*vec3(rnd(dir.xy*5.21358),rnd(dir.yz*3.12568),rnd(dir.zx*2.12358)));\n    vec3 backg=back*(1.+pow(1.-dot(normalize(90.*dir),normalize(lightdir)),2.5));\n    if (d<detail) {\n\t\tfloat k=kaliset(p);\n        col=light(p-detail*dir, dir)+k*.05*(innards+.3); \n    } else {\n        col=backg+v*.015*pow(1.-dot(normalize(90.*dir),normalize(lightdir)),2.5);\n    }\n\tcol = mix(col*1.2, backg, 1.0-exp(-.0045*totdist*totdist));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vvv();\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tfloat time=iTime*.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tuv=uv.yx;\n\tvec3 from=vec3(.5,0.,-18.+cos(time*.8)*4.5);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tmat2 camrot1=rot2D(50.);\n\tmat2 camrot2=rot2D(190.+sin(time*.5)*80.);\n\tmat2 camrot3=rot2D((sin(time))*10.);\n\tfrom.xz=from.xz*camrot1;\n\tdir.xz=dir.xz*camrot1;\n\tfrom.xy=from.xy*camrot2;\n\tdir.xy=dir.xy*camrot2;\n\tdir.yz=dir.yz*camrot3;\n\t\n\tvec3 col=raymarch(from,dir); \n\tcol=pow(col,vec3(1.3))*vec3(1.,1.2,1.2);\n\tvec4 fColor = vec4(col,1.0);// * smoothstep(0.0,0.6,vv);\n    fragColor = fColor;//.brga;\n}\n\n\nfloat de(vec3 pos)\n{\n\tfloat time=iTime;\n\tz=pos;\n\tfloat O=7.;\n\tfloat sc=1.;\n\tfloat tsc=pow(Scale,float(Iterations));\n\tfloat t=time*Speed*10./tsc+100.;\n\tfloat amp1=Amplitude;\n\tfloat amp2=amp1*1.1256;\n\tfloat amp3=amp1*1.0586;\n\tfloat amp4=amp1*0.9565;\n\tfloat l1=length(z.xy-vec2(O*1.1586,0));\n\tfloat l2=length(z.xy+vec2(O*.98586,0));\n\tfloat l3=length(z.xy+vec2(0,O*1.13685));\n\tfloat l4=length(z.xy-vec2(0,O));\n\tfor (int n=0; n<Iterations ; n++) {\n\t\tz+=sin(length(z.xy)*sc*Wavelength-t)*amp1/sc*2.;\n\t\tz+=sin(l1*sc*Wavelength-t)*amp1/sc;\n\t\tz+=sin(l2*sc*Wavelength-t)*amp2/sc;\n\t\tz+=sin(l3*sc*Wavelength-t)*amp3/sc;\n\t\tz+=sin(l4*sc*Wavelength-t)*amp4/sc;\n\t\tt=t*Scale*Scale;\n\t\tsc*=Scale;\n\t}\n\t//z.z*=3.;\n\tfloat wd=-z.z+2.;\n\treturn length(z)-6.;\n}\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tBfD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGBD1", "name": "hoeled_hole", "author": "hoeled", "description": "Hole", "tags": ["hole"], "likes": 1, "viewed": 49, "date": "1607087102", "time_retrieved": "2024-06-20T20:25:53.132889", "image_code": "float T(float d) {\n\treturn sin(13.4+.1*sin(iTime*2.)+d)*.2+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= .5;\n    uv.y -= .02;\n    vec3 col = vec3(0.1,0.1*T(uv.x),0.1*T(uv.y));\n    \n    for(float i=1.; i<5.; i=i+.04){\n        float d = length(uv+i/20.*T(i)-i*.017);\n        float inner = 0.1 * i * T(i);\n        float outer = 0.14 * i * T(i);\n        float shado = 0.4 * i * T(i);\n    \tfloat cI = smoothstep(inner, inner+0.001, d);\n    \tfloat cO = smoothstep(outer, outer+0.001, d);\n        col += mix(cI, cO, .7)*.01;\n    \tfloat s = smoothstep(shado, shado*1.724, d);\n        col += mix(cO, s, .9)*.24;\n    }\n\n    col = clamp(col, 0., 1.);\n    \n    // vignette\n    uv *= .95;\n    uv.x *= 4.5;\n    uv.y -= .48;\n    col *= smoothstep(-.95, .0, uv.y);\n    col *= smoothstep(0., -.95, uv.y);\n    col *= smoothstep(-5., 1., uv.x);\n    col *= smoothstep(5., -1., uv.x);\n    col += col*4.;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGBRc", "name": "3D-Sphere_Brodyaga_rus", "author": "Brodyaga_rus", "description": "Simple 3D-Sphere with light, \nTraining project", "tags": ["sphere"], "likes": 1, "viewed": 186, "date": "1607616029", "time_retrieved": "2024-06-20T20:25:53.132889", "image_code": "//O - начало координат\n\nvec3 B = vec3(0.0, 0.0, 5.0); \t//Точка, где находится центр экрана, через который смотрит камера\nfloat x_res = 16.0; \t\t\t//Размер экрана по горизонтали\nfloat y_res = 9.0;\t\t\t\t//Размер экрана по вертикали\n\nfloat A_r = 5.0;\nvec3 A = vec3(0, 0, 10.0);\t\t\t\t//Точка где находится центр сферы\nfloat r = 3.0;\t\t\t\t\t\t\t\t//Радиус сферы\nvec4 A_color = vec4(1.0, 0.0, 0.0, 1.0);\t//Цвет сферы\n\nfloat Light_r = 10.0;\nvec3 Light_pos = vec3(0.0, 13.0, 10.0);\t\t\t//Точка где находится точечный источник света\nvec4 Light_color = vec4(0.8, 0.8, 0.0, 1.0);\t//Цвет точечного источника\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tLight_pos = vec3(sin(iTime)*Light_r + Light_pos.x, 15.0, cos(iTime)*Light_r + Light_pos.z);\n\t//A = vec3(sin(iTime)*A_r + A.x, A.y, cos(iTime)*A_r + A.z);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 d = normalize(vec3((uv.x - 0.5 - B.x / x_res)*x_res, (uv.y - 0.5 - B.y / y_res)*y_res, B.z)); //Луч направленый из начала координат в точку на экране\n\n    vec3 s = A;\n    \n    float D = dot(d,s)*dot(d,s) - (dot(s,s)-r*r);\n\n    if(D >= 0.0)\n    {\n    \tfloat t = (dot(d, s) - sqrt(D));\n        \n        vec3 M = vec3(d.x*t, d.y*t, d.z*t);\n        \n        vec3 n = M - A;\n\t\t\n        vec3 l = Light_pos - M;\n        \n        fragColor = A_color + 0.025 * Light_color * dot(n, l);\n        \n    }\n    else\n    \tfragColor = vec4(0.7, 0.7, 0.7, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGBRG", "name": "Cloud_tunnel_more_contrast", "author": "jojobavg", "description": "cloud tunnel shader with more contrast", "tags": ["raymarching", "cloud"], "likes": 5, "viewed": 90, "date": "1607367448", "time_retrieved": "2024-06-20T20:25:53.823925", "image_code": "// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n#define depth 70.0\n#define fogSize 25.0\nfloat fogCoef=1.0/(depth-fogSize);\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat cloud(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tfloat l = length(p*0.1);\n\tvec3 d = vec3(p.x+sin(l+time)*2.0,p.y+sin(l)*2.0,0.0);\n\tfloat coef = max(length(d)-1.5,0.0);\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=1.0/c*abs(noise((p*c+time*1.0)*scale));\n\t\tc*=2.0;\n\t}\n\treturn n1+(coef);\n}\n\nfloat mapHyper(vec3 p){\n\treturn cloud(p,vec3(0,0,0),0.5,0.1);\n}  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 s=vec3(0.5,0.5,100);\n\tfloat t2=(time*1.5);\n\ts.xz *= rot(sin(t2)*0.005);\n\tvec3 t=vec3(0,0,0);\n\ts.x += cos(t2*0.2)*0.10*sin(time*0.01);\n\ts.y += sin(t2*0.2)*0.10*sin(time*0.01+10.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\ts.z+=time*-8.0;\n\t\n\tvec3 p=s;\n\tfloat d;\n\tfloat seuil=5.1;\n\tfloat c= 0.0;\n\tfloat distMax =50.0;\n\tfloat steps = 300.0;\n\tfloat color = 0.0;\n\tfloat cl;\n\tfloat dist = clamp((1.0-dot(vec3(0,0,-1.0),r))*4.0,0.0,1.0);\n\tint cc =int(mix(300.0,1000.0,dist));\n\tfloat uu =mix(1.0,0.25,dist);\n\tvec3 p3 = vec3(0);\n\tfor(int i=0; i<cc; ++i) {\n\t\tfloat d2 ;\n\t\tfloat d;\n\t\tif(color<0.001)d = mapHyper(p);\n\t\tc =d;  \n\t\tif( c>seuil )\n\t\t{vec3 p2 =p;\n\t\t\tif(p3.x==0.0)p3=p;\n\t\t\tfor(int j;j<20;j++)\n\t\t\t{\n\t\t\t\tif(color<0.2)d2= mapHyper(p2);\n\t\t\t\telse\n\t\t\t\td2 = 5.2;\n\t\t\t\tif(d2>seuil)\n\t\t\t\t{\n\t\t\t\t\tcolor = color*0.8 + d2*0.02*0.2;\n\t\t\t\t}\n\t\t\t\tp2 +=normalize(vec3(-0.0,-0.0,-5.0))*0.42;\n\t\t\t} \n\t\t}\n\t\tcl = 1.0-color;\n        p+=r*distMax/steps*uu;\n\t\t//p+=r*distMax/float(cc)*uu;\n\t}\n\n\tvec2 off=vec2(1.1,0.0);\n\tvec3 n=normalize(mapHyper(p3)-vec3(mapHyper(p3-off.xyy), mapHyper(p3-off.yxy), mapHyper(p3-off.yyx)));\n\n\t//compositing\n\tvec3 col=vec3(0);\n\tcol = mix(vec3(0.0,0.0,0.2),vec3(0.88,0.88,0.9),max(cl-0.5,0.0)*2.0);\n\tfloat fog =  clamp((length(p3-s)-fogSize)*fogCoef,0.0,1.0);\n\tcol = mix(col,vec3(0.88,0.88,0.9),fog);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGBz3", "name": "dither waves", "author": "darch", "description": "dither, wave", "tags": ["wave", "dither"], "likes": 2, "viewed": 414, "date": "1607613691", "time_retrieved": "2024-06-20T20:25:54.023938", "image_code": "//based on: https://www.shadertoy.com/view/wsyyRm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center pixel coordinates\n    vec2 uv = fragCoord - (iResolution.xy / 2.);\n    \n    //get gradient starting at center (looks like a 1ps dot since anything above dist of 1 will be white)\n    float dist = distance(uv, vec2(0.0));\n    \n    //use the gradient to generate waves\n    dist *= 0.01; //make value smaller for larger waves\n    float waves = sin(dist - iTime * .5);\n   \n    vec3 col = vec3(waves);\n\n    col.b *= waves;    \n    col.r = smoothstep(waves, 0.2, cos(iTime));\n    col.g = smoothstep(waves, sin(uv.x)*cos(uv.y),0.9);\n    col *= smoothstep(waves, sin(uv.x/uv.y),0.1);\n   \n    col.bg += smoothstep(waves, 0.9, cos(iTime))*0.5;\n    col.r *= step(waves, 0.1);\n\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdGfRd", "name": "Unoptimized fog", "author": "omegasbk", "description": "I quickly mashed this up together after I got the idea. Super badly optimized and written, will fix it some day, or maybe not :) ", "tags": ["fog", "smoke"], "likes": 8, "viewed": 307, "date": "1607714441", "time_retrieved": "2024-06-20T20:25:55.175715", "image_code": "// Created by Darko (omegasbk) \n// youtube.com/c/darkosupe\n\nstruct Camera\n{\n    vec3 position;\n    float focalDistance;\n};    \n\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n};\nstruct PointLight\n{\n    vec3 position;\n    float intensity;\n};\n\nPlane plane = Plane(\n    vec3(0., 0., 1.), \n    vec3(0., 0., -1.), \n    vec3(0.5, 0.5, 0.5));\n    \nPointLight light = PointLight(\n    vec3(0., 0.19, -0.2), // position\n    35.);                 // intensity\n    \nCamera camera = Camera(\n    vec3(0., 0., -0.3), \n    0.6);\n    \n//////////////////////////////////////////////////////////////\n// \t                        UTILS                           // \n//////////////////////////////////////////////////////////////\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\n\n//////////////////////////////////////////////////////////////\n// Taken from https://www.shadertoy.com/view/XsX3zB\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) \n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) \n{\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) \n{\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n//\n//////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////\n// \t                   INTERSECTION CODE                    // \n//////////////////////////////////////////////////////////////\nbool intersectPlane(in Plane plane, in vec3 origin, in vec3 rayDirection, out float t, out vec3 pHit) \n{    \n    // Assuming vectors are all normalized\n    float denom = dot(plane.normal, rayDirection); \n    if (denom < 1e-6) \n    { \n        vec3 p0l0 = plane.position - origin; \n        t = dot(p0l0, plane.normal) / denom; \n        \n        if (t >= 0.)\n        {\n            pHit = origin + rayDirection * t;\n            return true;\n        }             \n    } \n \n    return false; \n} \n\n//////////////////////////////////////////////////////////////\n// \t                       MAIN CODE                        // \n//////////////////////////////////////////////////////////////\nfloat rayTrace(in vec3 rayDirection, in vec3 rayOrigin)\n{\n    float objectHitDistance;\n    vec3 pHit;\n\n#define LAYERS 3\n#define SHADOW_LAYERS 3\n#define FOG_DENSITY 0.1\n\n    float accAlpha = 0.;\n    \n    Plane diffusePlane = plane;\n    Plane lightPlane = plane;\n    vec3 lightDirection;\n    \n    for (int i = 0; i < LAYERS; i++)\n    {\n        if (intersectPlane(diffusePlane, rayOrigin, rayDirection, objectHitDistance, pHit))\n        {\n            float thickness = simplex3d_fractal(pHit);\n            accAlpha += thickness * FOG_DENSITY;            \n\n            //lightDirection = normalize(light.position - pHit);\n\n            vec3 shadowPhit = pHit;\n            for (int j = 0; j < i; j++)\n            {\n                shadowPhit += FOG_DENSITY * lightDirection;\n                accAlpha -= simplex3d_fractal(shadowPhit) * 0.008;\n            }\n        }\n        \n        diffusePlane.position.z += FOG_DENSITY;\n    }        \n \n    return accAlpha;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime / 4.;\n    light.position.x = iMouse.x / iResolution.x;\n    //light.position.z = time - 1.2;\n    \n    plane.position.z = time;\n    camera.position.z = time - 1.2;\n        \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 clipPlanePosition = vec3(uv.x, uv.y, camera.position.z + camera.focalDistance);\n    vec3 rayDirection = normalize(clipPlanePosition - camera.position);\n    \n    vec4 ambientColor = vec4(0.5, 0.7, 0.9, 1.) * (-uv.y + 0.1);  \n    vec4 finalColor = ambientColor + rayTrace(rayDirection, camera.position);\n    \n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKBD3", "name": "Meteor shower texture", "author": "hohserg", "description": "This is texture for sky rendering", "tags": ["star", "sky", "meteor"], "likes": 1, "viewed": 99, "date": "1608148423", "time_retrieved": "2024-06-20T20:25:55.175715", "image_code": "const float minX = -0.25;\nconst float maxX = 0.25;\n\nfloat spark(float v){\n    return ((1.0-abs(v/0.5))-0.5) * float(v>minX && v<maxX);\n}\n\nfloat rand(float v){\n    return fract(sin(v)*43758.5453123);\n}\n\nvec4 meteorShowerLinear(vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float y = spark(uv.x-0.5-iTime + rand(uv.y)*100.0);\n\n    return vec4(y);\n}\n\nvec2 curving(vec2 fragCoord){\n    return vec2(fragCoord.x, fragCoord.y+fragCoord.x/2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = meteorShowerLinear(curving(fragCoord));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKBDm", "name": "Fractal armor", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 10, "viewed": 129, "date": "1607335204", "time_retrieved": "2024-06-20T20:25:55.181537", "image_code": "#define TAU atan(1.)*8.\n\nvoid lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\nfloat mabs(float p)\n{\n    return abs(p)+exp(-p*p*8.);\n}\n\nvoid sfold45(inout vec2 p)\n{\n    vec2 v=normalize(vec2(1,-1.03));\n    float g=dot(p,v);\n    p-=(g-mabs(g))*v;\n}\n\nfloat map(vec3 p){\n\trot(p,vec3(cos(iTime*.03),sin(iTime*.02),sin(iTime*.05)*.5),iTime*.5);\n\tfloat s=4.;\n\tp=abs(p);\n    vec3 q=p;\n\tfor(int i=0;i<6;i++)\n\t{\n\t    p-=clamp(p,-1.,1.)*2.;\n    \tsfold45(p.xz);\n\t\tsfold45(p.yz);\n\t\tp*=-2.;\n        p-=q*2.5;\n        s*=2.;\n  \t}\n  \treturn length(p.xy)/s-.1;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<150;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return (cos(vec3(7,6,4)+p*.2)*.5+.5)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,15);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0,0,.03);\n\tconst float maxd=30.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-4.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        //col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),100.);\n        col+=vec3(11.2,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),8.); \n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKBRK", "name": "Noise Experiment - Snowball", "author": "oneshade", "description": "Playing around with octaves of noise after watching the [url=https://www.youtube.com/watch?v=zXsWftRdsvU]Value Noise Explained[/url] by The Art Of Code.", "tags": ["raymarching", "coherentnoise", "snowball"], "likes": 1, "viewed": 47, "date": "1607541013", "time_retrieved": "2024-06-20T20:25:55.181794", "image_code": "float noise(in vec2 p) {\n    return fract(sin(p.x * 17.6452 + p.y * 565.337) * 5425.235);\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 luv = smoothstep(0.0, 1.0, fract(p)); // :P\n    vec2 cid = floor(p);\n\n    float bl = noise(cid);\n    float br = noise(cid + vec2(1.0, 0.0));\n    float tl = noise(cid + vec2(0.0, 1.0));\n    float tr = noise(cid + vec2(1.0, 1.0));\n\n    return mix(mix(bl, br, luv.x), mix(tl, tr, luv.x), luv.y);\n}\n\nfloat CoherentNoise(in vec2 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float dt = 0.0;\n    for (int iter=0; iter < 50; iter++) {\n        vec3 p = ro + rd * dt;\n\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, -s, s, c);\n\n        float d = length(p) - 2.0 + 0.15 * length(vec3(CoherentNoise(p.xy, 10.0, 4.0), CoherentNoise(p.xz, 10.0, 4.0), CoherentNoise(p.yz, 10.0, 4.0)));\n        if (d < 0.001) {\n            p *= 0.25;\n            vec3 n = normalize(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            l.xz *= mat2(c, -s, s, c);\n            fragColor.rgb += max(0.0, dot(n, l) * 0.75 * length(vec3(CoherentNoise(p.xy, 10.0, 4.0), CoherentNoise(p.xz, 10.0, 4.0), CoherentNoise(p.yz, 10.0, 4.0))));\n            break;\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKBWc", "name": "Dots spin loader", "author": "NoxWings", "description": "Just a simple spin loader made using radial symmetry.", "tags": ["radialsymmetrydots"], "likes": 0, "viewed": 186, "date": "1608158117", "time_retrieved": "2024-06-20T20:25:55.181794", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define debug(x) fragColor = vec4(vec3(x), 1.0); return\n#define debug2(x) fragColor = vec4(vec2(x), 0.0, 1.0); return\n#define debug3(x) fragColor = vec4(x, 1.0); return\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float AA = 0.005;\n\nfloat circle(vec2 uv, float r) {\n    float d = length(uv);\n    return S(r+AA, r-AA, d);\n}\n\nmat2 rot2D(float a) {\n    float sa = sin(a), ca = cos(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = uv * 2.0 - 1.0;\n    coords.x *= iResolution.x / iResolution.y;\n    coords = rot2D(-iTime* 2.) * coords;\n    \n    float numberOfDots = 8.0; \n    float angle = (atan(coords.y, coords.x) + PI) / TAU * numberOfDots;\n    float rid = floor(angle);\n    float baseAngle = rid / numberOfDots * TAU - PI;\n    vec2 ruv = rot2D(baseAngle) * coords;\n    \n    //debug(rid / numberOfDots); // Debug radial ids\n    //debug2(ruv);               // Debug radial uvs\n    \n    float sizeId = (numberOfDots - rid - 1.);\n    float circleBaseRadius = 0.03;\n    float circleDynRadius = sizeId * 0.01;\n    float circleRadius = circleBaseRadius + circleDynRadius;\n    float circleDistance = 0.4 - circleDynRadius;\n    \n    vec3 col = vec3(circle(ruv - vec2(circleDistance, circleRadius), circleRadius));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKBWh", "name": "Plasma_noise_lopo", "author": "lopoisaac", "description": " Not really my code, original author and explanation:\nhttps://www.bidouille.org/prog/plasma", "tags": ["noise", "plasma"], "likes": 0, "viewed": 45, "date": "1607031296", "time_retrieved": "2024-06-20T20:25:55.387641", "image_code": "// Not really my code, original author and explanation:\n//\n// https://www.bidouille.org/prog/plasma\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // pattern a\n    float a = sin(uv.x * 12. + iTime);\n    // pattern b\n    float b = sin((uv.x * sin(iTime * 0.2) + uv.y * cos(iTime * .2)) * 20.);\n    // pattern c\n    float x = uv.x + sin(iTime) * 0.2 - .5;\n    float y = uv.y + sin(iTime) * 0.2 - .5;\n    float c = sin(sqrt((pow(x, 2.) + pow(y, 2.))) * 20. + iTime * 0.01);\n\n    // final\n    vec3 color1 = vec3(.5 + .5 * sin(iTime), 0.3, 0.);\n    vec3 color2 = vec3(0., 0.3, .5 + .5 * cos(iTime));\n    \n    vec3 col = mix(color1, color2, a + b + c);\n\n    fragColor = vec4(col, 1.);\n  }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKBWy", "name": "Holiday Greetings!", "author": "oneshade", "description": "I just had to whip up a holiday shader and I am very proud of the final result! Happy holidays and merry christmas!", "tags": ["christmas", "winter", "peanuts", "snoopy", "shaderart", "holidays", "charliebrown", "happyholidays", "greeting"], "likes": 15, "viewed": 109, "date": "1607901279", "time_retrieved": "2024-06-20T20:25:57.000080", "image_code": "/*\nBig thank you to Inigo Quilez's 2D distance function and smooth minimum articles!\n2D distance functions article: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nSmooth minimum article: https://iquilezles.org/www/articles/smin/smin.htm\nThe smin(), ellipse(), and line() functions are taken from them.\n*/\n\nconst float SIN_20  =  0.34202014332;\nconst float COS_20  =  0.93969262078;\n\nconst float SIN_40  =  0.64278760968;\nconst float COS_40  =  0.76604444311;\n\nconst float SIN_150 =  0.50000000000;\nconst float COS_150 = -0.86602540378;\n\nconst float SIN_315 = -0.70710678118;\nconst float COS_315 =  0.70710678118;\n\nfloat noise(in float x) {\n    return fract(sin(x * 12.5673) * 573.123);\n}\n\nfloat snoise(in float x) {\n    const float r = 2.735;\n    x += 4657.247;\n    float c = floor(x / r) * r;\n    float l = fract(x / r); l *= l * (3.0 - 2.0 * l);\n    return mix(noise(c), noise(c + r), l);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat ellipse(in vec2 p, in vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat isosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x), p.y += h / 3.0;\n    vec2 pr = p - vec2(b, 0.0), tr = vec2(-b, h);\n    vec2 be = p - vec2(b * clamp(p.x / b, 0.0, 1.0), 0.0);\n    vec2 re = pr - tr * clamp(dot(pr, tr) / dot(tr, tr), 0.0, 1.0);\n    return sqrt(min(dot(be, be), dot(re, re))) * sign(p.x - b / h * (h - p.y) * sign(p.y));\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25, 0.25, 1.0);\n\n    // Snowy hill\n    vec2 hillUV = uv;\n    hillUV.x *= 0.3;\n    hillUV.y += 0.05;\n    float hill = hillUV.y + hillUV.x * hillUV.x;\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, hill));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(hill)));\n\n    // Tree trunk\n    vec2 trunkUV = uv;\n    trunkUV.x += 0.4;\n    float trunk = max(abs(trunkUV.x) - 0.04, abs(trunkUV.y) - 0.2);\n    color = mix(color, vec3(0.6, 0.3, 0.0), smoothstep(unit, 0.0, trunk));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(trunk)));\n\n    // Tree branches\n    vec2 treeUV = uv;\n    treeUV -= vec2(-0.4, 0.07);\n    float treeUnit = unit;\n    for (int i=0; i < 3; i++) {\n        float branches = isosceles(treeUV, 0.25, 0.3);\n        color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(treeUnit, 0.0, branches));\n        color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(treeUnit, 0.0, abs(branches)));\n        treeUV.y -= 0.15;\n        treeUV *= 1.5;\n        treeUnit *= 1.5;\n    }\n\n    // Snowman body\n    vec2 snowmanUV = uv - vec2(0.1, -0.2);\n    float snowmanDist = 1000000.0;\n    float scale = 1.0;\n    for (int i=0; i < 3; i++) {\n        float snowball = (length(snowmanUV) - 0.125) / scale;\n        snowmanDist = min(snowmanDist, snowball);\n        snowmanUV.y -= 0.175;\n        snowmanUV *= 1.25;\n        scale *= 1.25;\n    }\n\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, snowmanDist));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(snowmanDist)));\n\n    // Snowman nose\n    snowmanUV = uv - vec2(0.1, 0.085);\n    snowmanUV.x = abs(snowmanUV.x);\n    snowmanUV.y *= -1.0;\n    float nose = isosceles(snowmanUV, 0.015, 0.06);\n    color = mix(color, vec3(1.0, 0.6, 0.0), smoothstep(unit, 0.0, nose));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(nose)));\n\n    // Snowman eyes\n    float eyes = length(snowmanUV - vec2(0.03, -0.05)) - 0.01;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, eyes));\n\n    // Snowman buttons\n    float bbox = abs(snowmanUV.y - 0.15) - 0.1;\n    snowmanUV.y -= 0.275;\n    snowmanUV.y = mod(snowmanUV.y, 0.08) - 0.04;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, max(length(snowmanUV) - 0.01, bbox)));\n\n    // Charlie Brown's legs\n    vec2 legsUV = uv - vec2(0.57, -0.15);\n    legsUV.x = abs(legsUV.x);\n    legsUV.x -= 0.06;\n\n    float legs = max(abs(legsUV.x) - 0.03, abs(legsUV.y) - 0.1);\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, legs));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(legs)));\n\n    // Charlie Brown's pants\n    float pants = max(abs(legsUV.x) - 0.045, abs(legsUV.y) - 0.04);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, pants));\n\n    // Charlie Brown's shoes\n    vec2 shoesUV = uv - vec2(0.55, -0.25);\n    shoesUV.x = abs(shoesUV.x) - 0.06;\n    bbox = -(shoesUV.y + 0.01);\n    float shoes = max(ellipse(shoesUV, vec2(0.055, 0.04)), bbox);\n    color = mix(color, vec3(0.8, 0.5, 0.0), smoothstep(unit, 0.0, shoes));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(shoes)));\n\n    // Charlie Brown's arms\n    vec2 armsUV = uv;\n    armsUV -= vec2(0.565, -0.08);\n\n    armsUV.x = abs(armsUV.x);\n    armsUV *= mat2(COS_20, SIN_20, -SIN_20, COS_20);\n    armsUV.x -= 0.09 + 0.05 * sin(8.0 * armsUV.y + 1.57);\n\n    float arms = line(armsUV, vec2(0.0, 0.1), vec2(0.0, -0.1)) - 0.0275;\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, arms));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(arms)));\n\n    // Charlie Brown's shirt\n    vec2 shirtUV = uv - vec2(0.565, -0.09);\n    bbox = -(shirtUV.y + 0.075);\n    float shirt = max(ellipse(shirtUV, vec2(0.125, 0.2)), bbox);\n\n    // Charlie Brown's neck\n    vec2 neckUV = shirtUV;\n    neckUV.y -= 0.2;\n    float neck = max(abs(neckUV.x) - 0.035, abs(neckUV.y) - 0.05);\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, neck));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(neck)));\n\n    // Charlie Brown's head\n    vec2 headUV = shirtUV;\n    headUV.y -= 0.32;\n    float head = length(headUV) - 0.1;\n\n    // Charlie Brown's ears\n    vec2 earsUV = headUV;\n    earsUV.x = abs(earsUV.x) - 0.095;\n    float ears = length(earsUV) - 0.025;\n    head = min(head, ears);\n\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, head));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(head)));\n\n    // Charlie Brown's eyes\n    vec2 eyesUV = headUV;\n    eyesUV.y -= 0.02;\n    eyesUV.x = abs(eyesUV.x) - 0.04;\n    eyes = length(eyesUV) - 0.01;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, eyes));\n\n    // Charlie Brown's hair\n    vec2 hairUV = eyesUV;\n    hairUV -= vec2(-0.0175, 0.05);\n    bbox = hairUV.y;\n    float hair = max(abs(ellipse(hairUV, vec2(0.0225, 0.02))), bbox);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, hair));\n\n    // Charlie Brown's nose\n    vec2 noseUV = headUV;\n    noseUV.y += 0.015;\n    nose = max(abs(length(noseUV) - 0.015), -dot(noseUV, vec2(COS_315, SIN_315)) - 0.004);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, nose));\n\n    // Charlie Brown's mouth\n    vec2 mouthUV = headUV;\n    mouthUV.y += 0.04;\n    float mouth = max(abs(ellipse(mouthUV, vec2(0.045, 0.03))), noseUV.y + 0.025);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, mouth));\n\n    // Charlie Brown's sleeves\n    vec2 sleevesUV = shirtUV;\n    sleevesUV.y -= 0.135;\n    sleevesUV.x = abs(sleevesUV.x) - 0.08;\n    sleevesUV *= mat2(COS_40, SIN_40, -SIN_40, COS_40);\n\n    bbox = -(sleevesUV.y + 0.04);\n    float sleeves = max(ellipse(sleevesUV, vec2(0.04, 0.08)), bbox);\n    shirt = smin(shirt, sleeves, 0.01);\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, shirt));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(shirt)));\n\n    // Black zigzag masked against the shirt\n    shirtUV.y -= 0.01;\n    shirtUV.y *= 8.0;\n    float zigzag = abs(shirtUV.y - abs(round(fract(shirtUV.x * 10.0)) - fract(10.0 * shirtUV.x)));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, max((zigzag - 0.2) / 8.0, shirt)));\n\n    // Snoopy's body\n    vec2 bodyUV = uv;\n    bodyUV += vec2(0.2, 0.35);\n    float body = ellipse(bodyUV, vec2(0.08, 0.06));\n\n    // Snoopy's arm\n    vec2 armUV = bodyUV;\n    armUV *= mat2(COS_20, -SIN_20, SIN_20, COS_20);\n    armUV.x -= 0.02;\n    armUV.y += 0.02 * sin(armUV.x * 15.0 + 1.57);\n    float arm = line(armUV, vec2(-0.04, 0.0), vec2(0.06, 0.0)) - 0.02;\n\n    // Snoopy's left leg\n    vec2 leftLegUV = bodyUV;\n    leftLegUV -= vec2(0.075, 0.01);\n    float leftLeg = max(max(abs(leftLegUV.x) - 0.05, abs(leftLegUV.y) - 0.0125), -body);\n\n    // Snoopy's left foot\n    leftLegUV -= vec2(0.05, 0.01);\n    float leftFoot = ellipse(leftLegUV, vec2(0.02, 0.045));\n    leftLeg = min(leftLeg, leftFoot);\n\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(leftLeg)));\n\n    // Snoopy's right leg\n    vec2 rightLegUV = leftLegUV;\n    rightLegUV += 0.03;\n    float rightLeg = max(max(abs(rightLegUV.x) - 0.03, abs(rightLegUV.y) - 0.0125), -body);\n\n    // Snoopy's right foot\n    rightLegUV -= vec2(0.04, 0.01);\n    float rightFoot = ellipse(rightLegUV, vec2(0.02, 0.045));\n    rightLeg = min(rightLeg, rightFoot);\n\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, rightLeg));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(rightLeg)));\n\n    // Snoopy's neck\n    bodyUV.x += 0.04;\n    neck = max(abs(bodyUV.x) - 0.075, abs(bodyUV.y) - 0.015);\n    body = smin(body, neck, 0.02);\n\n    // Snoopy's collar\n    vec2 collarUV = bodyUV;\n    collarUV.x += 0.055;\n    float collar = max(abs(collarUV.x) - 0.005, abs(collarUV.y) - 0.025);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, collar));\n\n    // Snoopy's head\n    bodyUV += vec2(0.12, 0.01);\n    head = length(bodyUV) - 0.05;\n    body = smin(body, head, 0.02);\n\n    // Snoopy's snout\n    bodyUV -= vec2(0.01, 0.075);\n    float snout = length(bodyUV) - 0.03;\n    body = smin(body, snout, 0.05);\n\n    // Snoopy's mouth\n    mouthUV = bodyUV;\n    mouthUV -= vec2(0.018, -0.03);\n    bbox = dot(mouthUV, vec2(COS_150, SIN_150));\n    mouth = max(abs(ellipse(mouthUV, vec2(0.015, 0.03))), bbox);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, mouth));\n\n    // Only an outline is drawn because the snow provides the inside :P\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(body)));\n\n    // Snoopy's arm is drawn after the body to properly layer it onto the scene\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, arm));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(arm)));\n\n    // Snoopy's right ear\n    earsUV = bodyUV;\n    earsUV += vec2(0.05, 0.125);\n    earsUV *= mat2(COS_40, -SIN_40, SIN_40, COS_40);\n    float rightEar = ellipse(earsUV, vec2(0.02, 0.05));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, rightEar));\n\n    // Snoopy's left ear\n    earsUV -= vec2(-0.04, 0.03);\n    earsUV *= mat2(COS_40, SIN_40, -SIN_40, COS_40);\n    earsUV.x += 0.025;\n    earsUV = earsUV.yx;\n    float leftEar = max(ellipse(earsUV, vec2(0.02, 0.05)), -body);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, leftEar));\n\n    // Snoopy's eye\n    bodyUV += vec2(0.03, 0.06);\n    float eye = length(bodyUV) - 0.005;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, eye));\n\n    // Snoopy's nose\n    bodyUV -= vec2(0.03, 0.095);\n    nose = max(length(bodyUV) - 0.01, -snout);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, nose));\n\n    // Snowflakes\n    float screenRight = 0.5 * iResolution.x / iResolution.y;\n    float snowflakesDist = 1000000.0;\n    for (float column=-screenRight; column < screenRight; column += 0.2) {\n        vec2 columnUV = uv - vec2(column, 0.0);\n        columnUV.y += snoise(floor(column / 0.2)) * iTime;\n        columnUV.x += 0.2 * sin(floor(columnUV.y / 0.2) + iTime);\n        columnUV.y = mod(columnUV.y, 0.2) - 0.1;\n        snowflakesDist = min(snowflakesDist, length(columnUV) - 0.015);\n    }\n\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, snowflakesDist));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(snowflakesDist)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKcWh", "name": "Finale Assembly MS october2020", "author": "MonsieurSoleil", "description": "Shaderbattle", "tags": ["shaderbattle"], "likes": 8, "viewed": 111, "date": "1607801234", "time_retrieved": "2024-06-20T20:25:57.802027", "image_code": "#define time (iTime/60.0)*140.0\n#define mod01 floor(mod(time * 4.0, 16.0))\n#define mod02 floor(mod(time * 2.0, 8.0))\n\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, sa, -sa, ca);\n}\n\nstruct matter\n{\n \tfloat m;\n    int type;\n    bool reflected;\n};\n    \nfloat box(vec3 p, vec3 s)\n{\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sphere(vec3 p, float s)\n{\n\t\n    return length(p) - s;\n}\n\nvec3 kifs(vec3 p)\n{\n    float t1 = 0.5 + (time * 0.1 * 0.25);\n    float s = 2.0;\n    \n    for(int i = 0; i < 4; ++i)\n    {\n     \tp.yz *= rot(t1 + float(i) * 0.1);\n        p.yz = abs(p.xz);\n        p.yz -= s;\n    }\n    \n    \n    \n    return p;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n\tfloat mat01, mat02, mat03;\n    \n   \n    \n    \n    \n    p.xz *= rot(time * 0.2) * 1.05;\n    p.yz *= rot(time * 0.15) * 1.15;\n    p.xy *= rot(time * 0.05);\n    \n    vec3 p01 = p, p02 = p, p03 = p, p04 = kifs(p);\n    \n    mat02 = box(p, vec3(0.55 + 0.45 * abs(sin(time * 0.25))));\n    //mat02 = min(mat02, -box(p, vec3(3.5)));\n    \n    if(mat02 < 0.01)\n    {\n     \tmat.type = 1;   \n    }\n    \n    if(mod(mod02, 4.0) <= 1.0)\n    \tmat01 = box(p, vec3(1.05 + 0.10 * mod02));\n    if(mod(mod02, 4.0) > 1.0)\n        mat01 = sphere(p, 1.05 + 0.10 * mod02);\n    \n    float rep01 = 0.45;\n    \n    p02.y = (fract(abs(p04.y + time * 0.05) / rep01 - 0.5) - 0.5) * rep01;\n    float id = (floor(abs(p.y) / rep01 - 0.5) - 0.5) * rep01 * (16.0 * abs(sin(time * 0.5)));\n    \n    p03.y = (fract(abs(p04.y + time * 0.05) / rep01 - 0.5) - 0.5) * rep01;\n    float id02 = (floor(abs(p.y) / rep01 - 0.5) - 0.5) * rep01 * (16.0 * abs(sin(time * 0.5)));\n    \n   \t/*p02.xz *= rot(time * 0.2);\n    p02.yz *= rot(time * 0.1);\n    p02.xy *= rot(time * 0.1);*/\n    \n    mat01 = max(mat01, -box(p02 - vec3(0.5 * sin(p.x * 0.2), 0.0, 0.0), vec3(10.0, 0.15 + (sin(p.x * 0.1 * id * mod01) * 0.25) + (sin(p.z * 0.1) * 0.25), 10.0)));\n    \n    mat01 = max(mat01, -box(p02 - vec3(0.0, 0.0, 0.0), vec3(0.15 + (sin(p.z * 0.1 * id * mod01) * 0.25) + (sin(p.z * 0.1) * 0.25),10.0, 10.0)));\n    \n    \n    gg += 0.15/(0.11+abs(mat01));\n    \n    mat.m = min(mat01, mat02);\n}\n\nvec3 normals(vec3 p)\n{\n \tvec2 uv = vec2(0.01, 0.0);\n    \n    matter m01,m02,m03,m04;\n    \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n    \n    return normalize(m01.m - vec3(m02.m, m03.m,m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    vec3 o = vec3(0.0, 0.0, 4.0), t= vec3(0.0);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p = o + dir * 0.5;\n    \n   \tmatter mat;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 150; ++i)\n    {\n        //p.xy *= rot(0.001);\n        \n     \tmap(mat, p);\n        \n        if(mat.m < 0.01)\n        {\n            if(mat.type == 1)\n            {\n                vec3 n = normals(p);\n                dir = reflect(dir, -n);\n                \n                mat.m = 0.15;\n                mat.type = 0;\n                mat.reflected = true;\n            }\n         \tmat.m = 0.1;\n        }\n        \n        if(mod(mod02, 4.0) <= 1.0)\n        \tcol += gg * 0.00030 * vec3(0.0, 0.5, 1.0);\n        if(mod(mod02, 4.0) > 1.0)\n        \tcol += gg * 0.00030 * vec3(1.0, 0.5, 0.0);\n        \n        p += dir * mat.m * 0.5;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKfW1", "name": "Isometric Lattice", "author": "Shane", "description": "Using a triangle grid to produce an isometric lattice, rendered in a hand drawn impossible geometry style.", "tags": ["triangle", "sketch", "geometry", "isometric", "quad", "lattice", "impossible"], "likes": 49, "viewed": 601, "date": "1607089864", "time_retrieved": "2024-06-20T20:26:01.982313", "image_code": "/*\n\n\tIsometric Lattice\n    -----------------\n\n    I thought it'd be fun to quickly code up a standard impossible geometry \n    lattice with a couple of extra elements -- In theory, it involves\n\tstrategically placing some overlapping quads inside the cells of a \n    triangle grid, which should be pretty easy... for a halfway competent\n\tcoder, which I used to be, but I struggle with everything these days. :D\n\n\tThe code was slapped together with a view to getting the job done, so \n\tyou can safely ignore it as I'd imagine there'd be way more elegant\n\tways to produce the same. \n\n\tAnyway, this is just one of countless impossible geometry examples out \n    there. It'd be great to see others on Shadertoy. All involve placing 2D \n    elements in various ways on a grid or the whole canvas.\n\n\n\n\n    Other examples:\n\n\n    // Oldschool isometric maze. I have a version of this somewhere.\n    Isometric Maze - fizzer\n    https://www.shadertoy.com/view/Md2XRd\n\n\t// Flopine has a few interesting isometric examples worth looking at.\n    // This particular one was coded in a few minutes... It took me that\n\t// long just to decide what colors I wanted to use. :)\n\tFlopine - I'm trapped \n\thttps://www.shadertoy.com/view/WtsfWr\n\n\n*/\n\n\n// Triangle grid cell borders. If you like spoiling illusions like I do,\n// this is the command to comment in. :)\n//#define SHOW_CELLS\n\n// Display T-joins instead of cube joins.\n//#define TJOINS\n\n// A singe join, instead of four. It produces a cleaner design, but a less \n// interesting one, I believe.\n//#define ONE_JOIN\n\n// Display the mid edge green block.\n#define MID_BLOCK\n    \n\n\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.); q += 2.5;\n    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(-3.14159/5.);  q += 4.5;\n    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Compare it to the underlying grey scale value.\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    const float contrast = 1.;\n    ns = (.5 + (gr - (max(max(ns, ns2), ns3)))*contrast); // Same, but with contrast.\n    //ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), ns3))); // Different contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0., 1.));\n    \n}\n\n\n// IQ's distance to a regular polygon, without trigonometric functions. \n// Other distances here:\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n// IQ's 2D box function.\nfloat sBox(in vec2 p, in vec2 b){\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.);\n    \n}\n\n \n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.y, -s.x, 1)*p; }\n\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.y, -s.x, 1))*p; }\n\n\n\nconst float scale = 1.;\n// Rectangle stretch.\nconst vec2 rect = vec2(1, 1./.8660254)*scale; \n//const vec2 rect = vec2(.85, 1.15)*scale; \n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(0, rect.y*.5); // 12 x .2\n// Irregular skewing is possible too, since it's all just math.\n//const vec2 sk = vec2(rect.x*.4, rect.y*.2); // 12 x .2\n\n\n/*\n//#define FLAT_TOP\n\n#ifdef FLAT_TOP\n//vec2 dim = vec2(1.5, 1)*scale;\n//const vec2 rect = vec2(1., 1.5)*scale; // 12 x .2\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0); // 12 x .2\n#else\nconst vec2 rect = (vec2(1, 1./.8660254))*scale; \n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(0, rect.y*.5); // 12 x .2\n\n#endif\n*/\n\n\n\nfloat gTri;\nvec4 getTri(vec2 p){\n    \n     p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    return vec4(p, id);\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // SETUP.\n    \n    // Aspect correct pixel coordinates.\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Scale, or zoom variable, if you prefer.\n    const float sc = 4.;\n    \n    // Scaling and translation.\n    vec2 p = uv*sc - vec2(1)*iTime/2.;\n    \n    // Perturbing the coordinates for imperfect hand drawn lines.\n    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));\n    const float oFct = .01;\n    p -= (offs - .5)*oFct;\n    \n    // Copy of the original coordinates.\n    vec2 oP = p;\n    \n    // Scale based smoothing factor. Good as a general scene formula, but for trickier\n    // fields, derivatives, etc, should be taken into account.\n    float sf = sc/iResolution.y;\n\n\n    \n    // Shadow coordinate, ID and triangle orientation id.\n    vec2 shOff = normalize(vec2(1, -1.25))*.175;\n    vec4 p4Sh = getTri(p - shOff);\n    vec2 pSh = p4Sh.xy;\n    vec2 idSh = p4Sh.zw;\n    float triSh = gTri;\n    \n    // Cell coordinate, ID and triangle orientation id.\n    vec4 p4 = getTri(p);\n    p = p4.xy;\n    vec2 id = p4.zw;\n    float tri = gTri;\n\n    \n    \n    // Using the unique cell ID to produce a random number.\n    float rnd = hash21(id);\n     \n   \n    // DISTANCE FIELD CALCULATION.\n    \n       \n    // Grid vertices, clockwise from the bottom left:\n    //\n    //vec2[4] vert = vec2[4](vec2(-rect.x, -rect.y)/2., vec2(-rect.x, rect.y)/2.,\n                            //vec2(rect.x, rect.y)/2., vec2(rect.x, -rect.y)/2.));\n    \n    // However, what you'll note is that the above can be written in the following\n    // manner.\n    //\n    // These are just the vertices of a unit grid cell, and when coupled with the\n    // cell ID, can be used for all kinds of things. You can also construct\n    // midway points between vertices for unique edge identifiers, which enables\n    // the construction of weaves, jigsaw patterns, etc.\n    //\n    // By the way, and this can get confusing, all IDs in this example will work,\n    // and will be unique. However, if you want them be position bases, like reading\n    // into a heightmap or whatever, all IDs need to be multiplied by the cell\n    // dimensions, \"rect.\"\n    vec2[4] vertID = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5));\n    \n    // The rectangular grid vertices.\n    vec2[4] vert = vec2[4](vertID[0]*rect, vertID[1]*rect, vertID[2]*rect, vertID[3]*rect);\n    \n    for(int i = 0; i<4; i++) vert[i] = unskewXY(vert[i], sk); // Unskew.\n    \n    \n   \n \n    \n    // RENDERING.\n    \n     // Using the unique ID to give the cells a unique background color\n    // via IQ's versatile palette formula.\n    vec3 bg = vec3(.3, .6, 1);\n    //bg = .6 + .4*cos(6.283*hash21(id + tri)/4. + vec3(0, 1, 2)); // Random cell color.\n    \n    /*\n    // Background lines.\n    vec2 qUV2 = rot2(-3.14159/3.)*p;\n    float freq2 = 30.;\n    float pat2 = abs(fract(qUV2.y*freq2) - .5)*2.;\n    pat2 = smoothstep(0., sf*freq2*2., pat2 - .2);    \n    bg *= pat2*.5 + .7;\n    */\n    \n    // Set the scene to the cell background.\n    vec3 col = bg;\n    \n    /*\n    // Color the upside down triangles the opposing color.\n    if(tri<.5) {\n        col = 1. - col*.5;\n    }\n    */\n    \n \n    \n    // Cell vertices and vertex ID.\n    vec2[3] v, vID;\n    //vec2 ctr = vec2(0);\n\n    \n    if(tri>=.5){\n        vID = vec2[3](vertID[0], vertID[2], vertID[1]);\n    \tv = vec2[3](vert[0], vert[2], vert[1]);\n        //ctr = (v[0] + v[1] + v[2])/3.;\n    }\n    else {\n        vID = vec2[3](vertID[0], vertID[2], vertID[3]);\n        v = vec2[3](vert[0], vert[2], vert[3]); \n        //ctr = (v[0] + v[1] + v[2])/3.;\n    }\n    \n      \n    // Shadow vertices -- They need to be handled seperately... Sigh! :)\n    vec2[3] vSh, vIDSh;\n    \n    if(triSh>=.5){\n        vIDSh = vec2[3](vertID[0], vertID[2], vertID[1]);\n    \tvSh = vec2[3](vert[0], vert[2], vert[1]);\n    }\n    else {\n        vIDSh = vec2[3](vertID[0], vertID[2], vertID[3]);\n        vSh = vec2[3](vert[0], vert[2], vert[3]);\n    }    \n    \n    \n     \n\n    // Assigned face normals, colors, and pattern.\n    vec3 vN[3] = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n    vec3 vCol[3] = vec3[3](vec3(.5), vec3(1), vec3(.2));\n    vec3 aR = vec3(-3.14159/3., 0, 3.14159/3.);\n    vec3 vPat = vec3(1);\n    \n    /*\n    // Cross hatching pattern, depending on face orientation -- Not used here.\n    for(int i = 0; i<3; i++){\n        // The cross hatching pattern on each face. Oriented to match the face.\n        vec2 qUV = rot2(aR[i])*p;\n        float freq = 30.;\n        float dir = tri<.5? -1. : 1.; \n        \n        if(i==2) dir = 0.;\n\n        float pat = abs(fract(qUV.y*freq + dir*.25) - .5)*2.;\n        pat = min(pat, abs(fract(qUV.x*freq + dir*.5) - .5)*2.);\n        //pat = smoothstep(0., sf*freq*2., pat - .2);\n        // Applying the hatch pattern to each line.\n        vPat[i] = 1.;;pat*.4 + .75;\n        \n        //if(i==2) vCol[i] *= 4.;\n       \n    }\n    */\n    \n    /*\n    // Swapping face normals.\n    swap(vN[0], vN[1]);\n    swap(vCol[0], vCol[1]); \n    swap(vPat[0], vPat[1]);\n    //swap(vCol[1], vCol[2]);\n    \n    // Face normals, colors, etc, face in different directions for opposing grid\n    // triangles... It can get confusing, but that's triangle grids for you. :)\n     if(tri<.5) {\n        swap(vN[0], vN[1]);\n        swap(vCol[0], vCol[1]);\n        swap(vPat[0], vPat[1]);\n    } \n    */\n    \n    // Does the same as above, but only for this particular examples.\n    if(tri>.5) {\n        swap(vN[0], vN[1]);\n        swap(vCol[0], vCol[1]);\n        swap(vPat[0], vPat[1]);\n    }\n     \n    // Background triangle cell lines.\n    for(int i = 0; i<3; i++){\n         float lnBord = lBox(p, v[i], v[(i + 1)%3], .00625);\n         col = mix(col, vec3(0), (1. - smoothstep(0., sf, lnBord)));\n     \n    }   \n    \n   \n    \n    float oLn = 1e5;\n    float ln = 1e5, ln2 = 1e5;\n    \n    // Main block width.\n    float hexW = scale*.8660254/2.; //(.8660254*3.);//\n \n    // Middle block width.\n    float mBW = hexW/6.;\n    \n    // Joiner line width and edge width.\n    #ifdef ONE_JOIN\n    const float lw = .8660254/8.; \n    #else\n    const float lw = .8660254/12.; \n    #endif\n    const float ew = .02;\n    \n    #ifdef ONE_JOIN\n    float ndg = hexW/((3. + lw)*.8660254);\n    #else\n    float ndg = hexW/((5. + lw)*.8660254);\n    #endif\n    \n    \n    // Drop shadow distance.\n    float gSh = 1e5;\n    \n    \n    // Render the drop shadows.\n    for(int i = min(0, iFrame); i<3; i++){\n        \n        // Random edge variable.\n        float rndI = hash21(idSh + mix(vIDSh[i], vIDSh[(i + 1)%3], .5));\n\n        // Edge tangent vectors.\n        vec2 tgnt0Sh = normalize(vSh[i] - vSh[(i + 1)%3]);\n        vec2 tgnt1Sh = normalize(vSh[(i + 1)%3] - vSh[(i + 2)%3]);\n        vec2 tgnt2Sh = normalize(vSh[(i + 2)%3] - vSh[(i + 0)%3]);\n        \n         // Central join line vertices.        \n        vec2[4] qvSh = vec2[4](vSh[i] - tgnt0Sh*ndg, vSh[(i + 1)%3] + tgnt0Sh*ndg, \n                             vSh[(i + 1)%3] + tgnt0Sh*ndg + tgnt2Sh*lw, vSh[i] - tgnt0Sh*ndg + tgnt2Sh*lw);\n        \n        // Edge join line vertices.\n        vec2[4] qvBSh = vec2[4](v[i] - tgnt0Sh*ndg, v[(i + 1)%3] + tgnt0Sh*ndg, \n                            v[(i + 1)%3] + tgnt0Sh*ndg + tgnt1Sh*lw, v[i] - tgnt0Sh*ndg + tgnt1Sh*lw);\n        \n        // Central join line.\n        ln = sdPoly4(pSh, qvSh);\n        \n        // Outside joins line - Top.\n        float ln2Offs = hexW/3.;\n        float ln2 = sdPoly4(pSh - tgnt2Sh*ln2Offs, qvBSh);///////\n        // Outside joins line - Side.\n        float ln2B = sdPoly4(pSh - tgnt2Sh*ln2Offs, qvBSh);//////\n        \n        // If more than one join, join the line shadows.\n        #ifndef ONE_JOIN\n        ln = min(ln, min(ln2, ln2B));\n        #endif\n        \n        // Shadow main block vertices.\n        qvSh = vec2[4](vSh[i], vSh[i] + tgnt2Sh*hexW, \n                    vSh[i] + tgnt2Sh*hexW + tgnt1Sh*hexW, vSh[i] + tgnt1Sh*hexW);\n        \n        // Main block.\n        float bl = sdPoly4(pSh, qvSh);\n        \n        // Main block T-Joins -- Shadow.\n        #ifdef TJOINS\n        // T - intersection.\n        //if((i==1 && triSh>.5)|| (i==2 && triSh<.5)){// \n            vec2 ap = abs(pSh - vSh[i] + tgnt0Sh*.7);\n            float blN = max(ap.y*.8660254 + ap.x*.5, ap.x) - hexW*.8660254;\n            bl = max(bl, -blN);\n        //}\n        #endif  \n       \n        // Middle block.\n        float blockDist = (1. - hexW/length(vSh[i] - vSh[(i + 1)%3]))/2.;// + mBW;\n        vec2 eM = mix(vSh[i], vSh[(i + 1)%3], blockDist);\n        blockDist *= length(vSh[i] - vSh[(i + 1)%3]);\n        float hexW2 = hexW;//*.85;\n        \n        // Middle block vertices.\n        qvSh = vec2[4](vSh[i], vSh[i] + tgnt2Sh*hexW2, \n                     vSh[i] + tgnt2Sh*hexW2 + tgnt1Sh*hexW2, vSh[i] + tgnt1Sh*hexW2);\n        \n        // Middle block face.\n        float bl2B = sdPoly4(pSh + tgnt0Sh*(blockDist + mBW), qvSh);\n        \n      \n        // Middle block edge vertices.\n        qvSh = vec2[4](eM - tgnt0Sh*mBW, eM + tgnt0Sh*mBW, \n                     eM + tgnt0Sh*mBW + tgnt2Sh*hexW2, eM - tgnt0Sh*mBW + tgnt2Sh*hexW2);\n        \n        // Middle block edge distance.\n        float bl2 = sdPoly4(pSh, qvSh);\n        \n        // Don't show various random edge shadows.\n        if(rndI<1./2.){\n            bl2 = 1e5;\n            bl2B = 1e5;\n            ln = 1e5; \n        }\n        \n        // If we're not displaying the middle green block.\n        #ifndef MID_BLOCK\n        bl2 = bl2B = 1e5;\n        #endif\n               \n        // Accumulate all the object shadows into the generalized shadow variable.\n        gSh = min(gSh, min(min(bl, ln), min(bl2, bl2B))); \n        \n        // Dummy break to avoid unrolling... which may or may not work.\n        if(rndI>1e6) break;\n        \n        \n    }\n    \n    // Render the drop shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, gSh - ew/3.))*.5);\n\n    \n    \n    // Produce the main scene.\n    \n    // Render various shapes at each of the triangle cells vertices, edges, etc.\n    for(int i = min(0, iFrame); i<3; i++){\n        \n         \n        // Unique random edge value.\n        float rndI = hash21(id + mix(vID[i], vID[(i + 1)%3], .5));\n \n        // Edge tangents.\n        vec2 tgnt0 = normalize(v[i] - v[(i + 1)%3]);\n        vec2 tgnt1 = normalize(v[(i + 1)%3] - v[(i + 2)%3]);\n        vec2 tgnt2 = normalize(v[(i + 2)%3] - v[(i + 0)%3]);\n        \n        // Normal -- Not used.\n        //vec2 n = tgnt0.yx*vec2(1, -1);\n        //if(tri<.5){  n *= -1.;  }\n         \n        \n        // Central join line vertices.\n        vec2[4] qv = vec2[4](v[i] - tgnt0*ndg, v[(i + 1)%3] + tgnt0*ndg, \n                             v[(i + 1)%3] + tgnt0*ndg + tgnt2*lw, v[i] - tgnt0*ndg + tgnt2*lw);\n        \n        // Edge join line vertices.\n        vec2[4] qvB = vec2[4](v[i] - tgnt0*ndg, v[(i + 1)%3] + tgnt0*ndg, \n                            v[(i + 1)%3] + tgnt0*ndg + tgnt1*lw, v[i] - tgnt0*ndg + tgnt1*lw);\n        \n        // Central join line.\n        ln = sdPoly4(p - tgnt0*.0, qv);\n        // Central join line - Side -- Redundant here, but included anyway.\n        float lnB = sdPoly4(p - tgnt0*.0, qvB);\n       \n        \n        // Outside joins line - Top.\n        float ln2Offs = hexW/3.;\n        ln2 = sdPoly4((p) - tgnt2*ln2Offs, qv);///////\n        // Outside joins line - Side.\n        float ln2B = sdPoly4((p) - tgnt2*ln2Offs, qvB);//////\n        \n        #ifdef ONE_JOIN\n        ln2 = ln2B = 1e5;\n        #endif\n        \n        // Save the old lines -- to deal with overlap on the last vertex. \n        if(i==0) oLn = min(min(ln, lnB), min(ln2, ln2B)); \n      \n        \n         \n        // Main block vertices.\n        qv = vec2[4](v[i], v[i] + tgnt2*hexW, \n                     v[i] + tgnt2*hexW + tgnt1*hexW, v[i] + tgnt1*hexW);\n        // Main block (The pink one).\n        float bl = sdPoly4(p, qv);\n        \n        \n        \n        // Choppin bits off the main block to create T-Joins.\n        #ifdef TJOINS\n        // T - intersection.\n        //if((i==1 && tri>.5)|| (i==2 && tri<.5)){// \n            vec2 ap2 = abs(p - v[(i + 0)%3] + tgnt0*.7);\n            float blN = max(ap2.y*.8660254 + ap2.x*.5, ap2.x) - hexW*.8660254;\n            bl = max(bl, -blN);\n        //}\n        #endif\n        \n       \n        // Middle block (The green one).\n        float blockDist = (1. - hexW/length(v[i] - v[(i + 1)%3]))/2.;// + mBW;\n        vec2 eM = mix(v[i], v[(i + 1)%3], blockDist);\n        blockDist *= length(v[i] - v[(i + 1)%3]);\n        \n        float hexW2 = hexW;//*.85;\n        // Middle block face vertices.\n        qv = vec2[4](v[i], v[i] + tgnt2*hexW2, \n                     v[i] + tgnt2*hexW2 + tgnt1*hexW2, v[i] + tgnt1*hexW2);\n        // Middle block face distance.\n        float bl2B = sdPoly4(p + tgnt0*(blockDist + mBW), qv);\n        \n        \n        float bl2BLine = sdPoly4(p + tgnt0*(blockDist + mBW) + tgnt0*ndg, qv);\n        bl2B = max(bl2B, -max(min(ln, lnB), bl2BLine));\n        float bl2BLine2 = sdPoly4(p + tgnt0*(blockDist + mBW) + tgnt0*ndg - tgnt2*ln2Offs, qv);\n        bl2B = max(bl2B, -max(min(ln2, ln2B), bl2BLine2));\n        \n     \n        \n        \n        // Middle block side vertices.\n        qv = vec2[4](eM - tgnt0*mBW, eM + tgnt0*mBW, \n                     eM + tgnt0*mBW + tgnt2*hexW2, eM - tgnt0*mBW + tgnt2*hexW2);\n        // Middle block side distance.\n        float bl2 = sdPoly4(p, qv);\n        \n        // If we're not displaying the middle green block.\n        #ifndef MID_BLOCK\n        bl2 = bl2B = 1e5;\n        #endif\n        \n        /*\n        qvB = vec2[4](eM - tgnt1*mBW, eM + tgnt1*mBW, \n                     eM + tgnt1*mBW + tgnt0*hexW, eM - tgnt1*mBW + tgnt0*hexW);\n        */  \n        \n        \n        // Overlap occurs when producing the final vertex objects, so you need\n        // to perform CSG with the previous objects... Sometimes, it's easier\n        // just doing things with conventional 3D. :)\n        if(i == 2) {\n            \n            // Next vertex block\n            vec2 ap = abs(p - v[(i + 1)%3]);\n            float blN = max(ap.y*.8660254 + ap.x*.5, ap.x) - hexW*.8660254;\n            \n            // Combine it with previous line elements.\n            blN = min(blN, oLn);\n\n            // Take the above away from the final blocks and lines so that\n            // the overlap doesn't appear... Yeah, I find 2D layering \n            // confusing too. :D\n            ln = max(ln, -blN);\n            ln2 = max(ln2, -blN);\n            lnB = max(lnB, -blN);\n            ln2B = max(ln2B, -blN);\n            bl2 = max(bl2, -blN);\n            bl2B = max(bl2B, -blN);\n \n        }  \n      \n        // Don't show random connections -- The open space kind of looks \n        // more interesting.\n        if(rndI<.5){\n            \n            ln = 1e5;\n            ln2 = 1e5;\n            lnB = 1e5;\n            ln2B = 1e5;\n            bl2 = 1e5;\n            bl2B = 1e5;\n            if(i==0) oLn = 1e5;\n        }\n        \n        \n        // Line colors.\n        vec3 lnCol = vCol[i]; // Top face line.\n        vec3 lnColB = vCol[(i + 1)%3]; // Side face line.\n        vec3 lnCol2B = vCol[(i + 1)%3]; // Side face line.\n        \n        // Block colors.\n        vec3 blCol = vCol[(i + 2)%3];\n        vec3 blColB = vCol[i];\n        \n        \n        lnCol *= vec3(.7, .85, 1)*.75;\n        blCol = min(blCol*vec3(1, .2, .4)*2.8, 1.);\n        blColB = min(blColB*vec3(1, .2, .4)*2.8, 1.);\n        \n        lnColB *= vec3(.7, .85, 1)*.7;\n        lnCol2B *= vec3(.7, .85, 1)*.7;\n    \n        \n       \n        // Main block render for this pass.\n        //float sh = max(.75 - bl/.35, 0.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, bl - ew/3.));\n        col = mix(col, blCol*vPat[(i + 2)%3], 1. - smoothstep(0., sf, bl + ew*2./3.));    \n\n\n        // Side joiner line.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., ln2 - ew/3.))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2 - ew/3.));\n        col = mix(col, lnCol*vPat[i], 1. - smoothstep(0., sf, ln2 + ew*2./3.));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2B - ew/3.));\n        col = mix(col, lnCol2B*vPat[(i + 1)%3], 1. - smoothstep(0., sf, ln2B + ew*2./3.));\n\n        // Central joiner line.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., ln - ew/3.))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln - ew/3.));\n        col = mix(col, lnCol, 1. - smoothstep(0., sf, ln + ew*2./3.));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, lnB - ew/3.));\n        col = mix(col, lnColB*vPat[(i + 1)%3], 1. - smoothstep(0., sf, lnB + ew*2./3.));\n\n        // Middle block.\n        //sh = max(.75 - bl2B/.35, 0.); \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, bl2B - ew/3.));\n        col = mix(col, blCol.yxz*vPat[(i + 2)%3], 1. - smoothstep(0., sf, bl2B + ew*2./3.)); \n        //sh = max(.75 - bl2/.35, 0.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, bl2 - ew/3.));\n        col = mix(col, blColB.yxz*vPat[i], 1. - smoothstep(0., sf, bl2 + ew*2./3.)); \n\n        // Fake AO on the green block.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(ln, bl2B + .03) - ew/3.))*.25);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(ln2, bl2B + .03) - ew/3.))*.25);  \n        \n        // Dummy break to avoid unrolling... which may or may not work. If you think appeasing\n        // compilers instead of making code faster is stupid, you'll get no argument from me. :)\n        if(rndI>1e6) break;\n\n        \n    } \n    \n      \n    // Subtle pencil overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = oP*2.;\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    #if 0\n    // Just the pencil sketch. The last factor ranges from zero to one and \n    // determines the sketchiness of the rendering... Pun intended. :D\n    col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .7);\n    #else\n    col = mix(col, 1. - exp(-(col*2.)*(colP + .25)), .9); \n    #endif\n    //col = mix(col, colP, .5);\n    //col = mix(min(col, colP), max(col, colP), .5); \n    \n    \n    #ifdef SHOW_CELLS\n    // Triangle cell borders.\n    float gLnBrd = 1e5;     \n    for(int i = 0; i<3; i++){\n        gLnBrd = min(gLnBrd, lBox(p, v[i], v[(i + 1)%3], .005));\n    }\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, gLnBrd - .0175)));\n    col = mix(col, vec3(1, .9, .5), (1. - smoothstep(0., sf, gLnBrd)));\n    #endif\n    \n\n    // Rough gamma correction and output.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKfWc", "name": "Understanding Ray Marching", "author": "Dudeguy18", "description": "Made to help understand Ray Marching\n\n - The Art of Code (https://www.youtube.com/watch?v=PGtv-dBi2wE)", "tags": ["raymarching"], "likes": 2, "viewed": 54, "date": "1608250500", "time_retrieved": "2024-06-20T20:26:03.109677", "image_code": "// This was made to help me understand basic \n// ray marching techniques.\n\n\n#define MAX_STEPS 60\n#define MAX_DIST 50.0\n#define SURF_DIST 0.001\n\n\n\n// -----------------------------------------------------------------------------------------------\n// Calculates Random Number\nfloat hash(vec2 p){\n    p = fract(p * vec2(125.76, 473.82));\n    p += dot(p, p + 86.12);\n    return fract(p.x * p.y);\n}\n\n// Perlin Noise\nfloat noise (vec2 st) {\n    vec2 i = floor(st); // Index\n    vec2 f = fract(st); // Fraction\n\n    // Four corners in 2D of a tile\n    float a = hash(i + vec2(0.0, 0.0));\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Calculate value to interpolate between corners\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Interpolate\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec2 x, float amplitude, float frequency, float lacunarity, float gain, int iterations){\n\n    float y = 0.0;\n    \n    mat2 rot = mat2(cos(0.87), sin(0.87), -sin(0.87), cos(0.87));\n    for(int i=0; i < iterations; i++){\n\n        y += amplitude * noise(x * frequency); // Calculate Noise Layer\n        x *= rot;                              // rotate next iteration\n        frequency *= lacunarity;               // adjust lacunarity for next iteration\n        amplitude *= gain;                     // adjust gain for next iteration\n    }\n    \n\n    return y;\n}\n// -----------------------------------------------------------------------------------------------\n\n\n\n\n// -----------------------------------------------------------------------------------------------\n// Signed Distance Functions (https://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nfloat sdPlane( vec3 p, vec3 n, float h ){\n  return dot(p,n) - h;\n}\nfloat sdSphere( vec3 p, float radius){\n    return length(p)-radius;\n}\nfloat sdSphereFun( vec3 p, float radius, vec2 uv){\n\n    // Playing around\n    float scale = 3.0;\n    float lacunarity = 1.21;\n    float gain = 0.388;\n    float t = iTime * 0.5;\n    \n    float up = fbm(uv + vec2(0.0, -t), 0.5, scale, lacunarity, gain, 10);\n    \n    radius += fbm(uv + 4.0*up, 0.5, scale, lacunarity, gain, 10);\n\n    return length(p)-radius;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ){\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n// Returns shortest distance from vector p to any part of the scene\nfloat getDist(vec3 p, vec2 uv){\n\n    // Plane\n    vec3 planePos = vec3(0.0, 1.0, 0.0);\n    float planeHeight = 0.0;\n    \n    // Sphere1\n    vec3 sphere1Pos = vec3(-4.0, 2.2, 0.0);\n    float sphere1Width = 1.0;\n    \n    // Sphere2\n    vec3 sphere2Pos = vec3(0.0, 2.2, 0.0);\n    float sphere2Width = 1.0;\n    \n    // Rounded Cylinder\n    vec4 rCylinderPos = vec4(4.0, 2.2, 0.0, 1.0);\n    vec2 rCylinder = vec2(0.5, 0.4);\n    \n    \n    \n    // Calculate distance to all objects\n    float planeDist = sdPlane(p - planePos, normalize(planePos), planeHeight);\n    planeDist = p.y;\n    float sphere1Dist = sdSphere(p - sphere1Pos, sphere1Width);\n    float sphere2Dist = sdSphereFun(p - sphere2Pos, sphere2Width, uv);\n    float rCylinderDist = sdRoundedCylinder(p - rCylinderPos.xyz, rCylinder.x, rCylinder.y, rCylinderPos.w);\n    \n    // Calculate closest scene distance\n    float d = min(min(min(sphere1Dist,sphere2Dist), planeDist), rCylinderDist);\n \n    return d;\n}\n\n\n// Ray Marching\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection, vec2 uv){\n    \n    float originDistance = 0.0;\n    float sceneDistance = 0.0;\n    vec3 p = vec3(0.0);\n    \n    for(int i=0; i < MAX_STEPS; i++){\n        // p = current marching distance\n        p = rayOrigin + rayDirection * originDistance;\n        sceneDistance = getDist(p, uv);\n        originDistance += sceneDistance;\n        \n        if(originDistance > MAX_DIST || sceneDistance < SURF_DIST * 1.85 * (1.0 + originDistance)){\n            break;\n        }\n    \n    }\n    \n    return originDistance;\n}\n// -----------------------------------------------------------------------------------------------\n\n\n\n// -----------------------------------------------------------------------------------------------\n// Lighting\n\nvec3 getNormal(vec3 p, vec2 uv){\n    float d = getDist(p, uv);\n    \n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, uv),\n        getDist(p-e.yxy, uv),\n        getDist(p-e.yyx, uv));\n       \n    \n    return normalize(n);\n}\n// -----------------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Basic Setup\n    vec3 col = vec3(0.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // ------------------------------------------------------\n\n\n\n    // Camera\n    vec3 cameraPos = vec3(0.0, 6.0, -10.0);\n    vec3 cameraDir = vec3(0.0, -0.4, 0.0);\n    // ------------------------------------------------------\n    \n    \n    \n    // Ray Marching\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0) + cameraDir);\n    float distToScene = rayMarch(rayOrigin, rayDirection, uv);\n    \n    // Calculate Ray Destination Point\n    vec3 rayPoint = rayOrigin + rayDirection * distToScene;\n    // ------------------------------------------------------\n    \n    \n    \n    \n    // Light1\n    vec3 lightPos = vec3(0.0, 10.0, 0.0);\n    vec3 ambientColor = vec3(0.2, 0.2, 0.3);\n    vec3 diffuseColor = vec3(0.5, 0.5, 0.6);\n    vec3 specularColor = vec3(0.8, 0.8, 0.9);\n    float radius = 15.0;\n    float shininess = 10.0;\n    \n    // Move Light\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    \n    // Lighting\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 toLight = normalize(lightPos - rayPoint);\n    vec3 surfaceNormal = getNormal(rayPoint, uv);\n    \n    // Attenuation\n    float lightDist = length(lightPos - rayPoint);\n    float attenuation = clamp(1.0 - lightDist / radius, 0.0, 1.0);\n    \n    // Ambient\n    ambient += ambientColor;\n    \n    // Shadows - Calculate if ray destination point is in shadow or not\n    float toLightDist = rayMarch(rayPoint + surfaceNormal * SURF_DIST * 2.0, toLight, uv);\n    \n    // Shadow Test\n    if(toLightDist >= lightDist){\n    \n        // Diffuse\n        float difAngle = max(dot(surfaceNormal, toLight), 0.0);\n        diffuse += difAngle * diffuseColor * attenuation;\n        \n        // Specular - Blinn-Phong\n        vec3 toCamera = rayDirection;\n        vec3 half_way = normalize(toLight - toCamera);\n        float specAngle = pow(max(dot(surfaceNormal, half_way), 0.0), shininess);\n        specular += specAngle * specularColor * attenuation;\n        \n    }\n    // ------------------------------------------------------\n\n\n    // Calculate Frag Color\n    fragColor = vec4(ambient + diffuse + specular,1.0);\n    // ------------------------------------------------------\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKfWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKfWW", "name": "Shader Royale #2 - branch ", "author": "Branch", "description": "Shader coded live on stream for Shader Royale #2 (about 1h) - 4 december 2020", "tags": ["tripfest"], "likes": 3, "viewed": 71, "date": "1607182613", "time_retrieved": "2024-06-20T20:26:03.794567", "image_code": "\nfloat sdSphere(vec3 p, float s){ \n  return length(p) - s;\n}\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p) {\n  float d = 1e10;\n  float t= mod(iTime,20.);\n  for(float i=1.0; i < 32.; i++) {\n    p.z *= 0.1;\n    if(t<5.0) {\n      p.x += sin(p.z * 12. + iTime + i) * i;  // state 0\n      p.y += cos(p.z * 12. + iTime + i) * i;  // state 1\n      d = min(d, sdSphere(p, 0.5 + sin(i * 12. + iTime + p.z) + texture(iChannel0,vec2(0.3)).x*12.));\n    }\n    else if(t<10.0) {\n      float angle = i/32. + (p.z * 12.) * 0.2;\n      float s= sin(angle);\n      float c =cos(angle);\n      mat2 rotMat = mat2(c,s,-s,c);\n      p.xy *= rotMat;\n      p.x += sin(p.z * 12. + iTime + i) * i;  // state 0\n      p.y += cos(p.z * 12. + iTime + i) * i;  // state 1\n      \n      d = min(d, sdBox(p, vec3(    0.2 + sin(i * 3. + iTime + p.z)  )  + texture(iChannel0,vec2(0.1)).x*0.3  ));\n    } \n    else if(t<15.0) {\n      float angle = i/32. + (p.z * 12.) * 0.2;\n      float s= sin(angle);\n      float c =cos(angle);\n      mat2 rotMat = mat2(c,s,-s,c);\n      p.xy *= rotMat;\n      p.x += sin(p.z * 12.) * min(p.z*0.2,6.);  // state 0\n      p.y += cos(p.z * 12.) * min(p.z*0.2,6.);  // state 1\n      \n      d = min(d, sdBox(p, vec3(    0.2 + sin(i * 3. + iTime + p.z) + texture(iChannel0,vec2(0.3)).x*1.2 )   ));\n    } else {\n      p.x += sin(p.z * 12. + iTime + i);  // state 0\n      p.y += cos(p.z * 12. + iTime + i) * i * 0.2;  // state 1\n      d = min(d, sdSphere(p, 0.5 ));\n    }\n    \n  }\n  return d;\n}\n\nfloat rand(vec2 c) {\n  return fract(sin(dot(c.xy,vec2(12.9898,78.233))) * 41231.51222); \n  //i don't remember exactly... hopefully this is good enough\n  \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  vec2 uv2=uv;\n  float vessa = mod(iTime*2.,13.121);\n  if(vessa<3.0) { \n    uv += 0.333;\n  }\n  if(vessa>10.0) { \n    uv -= 0.333;\n  }\n  float kickoff = floor(mod(iTime,12.0)); \n  if(kickoff < 2.) { \n    kickoff = 12.;\n  }\n  if(kickoff < 4.) { \n    kickoff = -1.;\n  }\n  if(mod(iTime*0.6,12.0)<3.0) { \n    float angle = rand(floor(uv*1.5 + 0.5)) * 3. + iTime * 4.;\n    float s= sin(angle);\n    float c =cos(angle);\n    mat2 rotMat = mat2(c,s,-s,c);\n    uv *=rotMat;\n  }\n  \n  \n  float vignette = 1.0 / max( 0.25 + 0.9 * dot(uv,uv), 1.0);\n  vec3 rayOrigin = vec3(0.);\n  vec3 rayDirection = normalize(vec3(uv*(1.333 - 0.1*sin(iTime+length(uv) * 0.2) +  kickoff),1.0));\n  vec3 col = vec3(0.0);\n  float dist = 0.0;\n  float t = 0.01;\n  float d;\n  vec3 p = vec3(0.0);\n  \n  \n  \n  for(int i=0; i <32; i++) {\n    p = rayOrigin + t * rayDirection;\n    d = map(p);\n    t +=d;\n      if(t>32.0){\n          continue;\n      }\n    \n  }\n  if(d < 0.01) {\n    col = vec3(1.0) * floor(mod(p.z*2. + iTime * 12., 2.0));\n    col = mix(col, vec3(0.0), max(0.0, p.z - 5. ) * 0.2);\n  }\n  float homer = mod(iTime*0.333 + floor(mod(uv2.x + 0.5,2.0)),4.);\n  if(homer<1.0) {\n    col = vec3(1.0,0.5,0.7) - col;\n  }\n  if(homer<2.0) {\n    col = vec3(0.5,0.2,0.7) - col;\n  }\n  if(homer<3.0) {\n    col = vec3(0.5,0.7,0.7) * col;\n  }\n  if(length(uv2.x)<0.80 ) {\n    if(length(uv2.x)>0.795) {\n      col = vec3(0.15);\n    }\n  }\n  if(length(uv2.y)<0.47 ) {\n    if(length(uv2.y)>0.465) {\n      col = vec3(0.15);\n    }\n  }\n  if(mod(iTime*12.32,4.)<1.0 && mod(iTime*1.2,12.) < 2.0) {\n    col.r = floor(col.r*3.) / 2.;\n    col.g = floor(col.g*3.) / 2.;\n    col.b  = floor(col.b*3.) / 2.;\n  }\n    fragColor = vec4(col,1.0) * vignette + rand(uv2 + mod(iTime*12.,3.0))*0.13 ;\n}", "image_inputs": [{"id": "ltlXRr", "previewfilepath": "https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVBWG", "name": "Cool Thing", "author": "Heasmo", "description": "Cool Thing", "tags": ["raymarching"], "likes": 5, "viewed": 76, "date": "1608414331", "time_retrieved": "2024-06-20T20:26:03.794567", "image_code": "float sdBox(vec3 p, vec3 c, vec3 b, float r)\n{\n    vec3 q = abs(p - c) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 texCube(in sampler2D tex, in vec3 pos, in vec3 nor)\n{\n    vec4 x = texture(tex, pos.yz);\n    vec4 y = texture(tex, pos.xz);\n    vec4 z = texture(tex, pos.xy);\n    \n    return x * abs(nor.x) + y * abs(nor.y) + z * abs(nor.z);\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 bp = pos - vec3(0.f);\n    bp.yz *= rotate(iTime);\n    bp.xy *= rotate(iTime);\n    float box1 = sdBox(bp, vec3(0.f), vec3(.5f), 0.f);\n    box1 = abs(box1) - .1f;\n    float plane1 = dot(pos, normalize(vec3(cos(iTime), sin(iTime) * 2.f, 1)));\n    \n    return max(plane1, box1);\n}\n\nvec3 calcNormals(in vec3 p)\n{\n    const vec2 e = vec2(.001f, 0.f);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\n\nfloat castRay(in vec3 ro, in vec3 rd, in float t, out float a, out float h)\n{\n    a = 0.f;\n    h = 20.f;\n    for (int i = 0; i < 256; i++)\n    {\n        vec3 pos = ro + rd*t;\n        \n        float d = map(pos);\n        h = min(h, d);\n        \n        if (d < .001f)\n            break;\n        t += d;\n        if (t > 20.f)\n            break;\n        a++;\n    }\n    if (t > 20.f)\n        t = -1.5f;\n    return t;\n}\n\nfloat shadow(in vec3 ro, vec3 rd, out float a)\n{\n    float t = 0.f;\n    float res = 1.f;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        \n        if (h < .0000000001f) break;\n        res = min(res, 32.f*h/t);\n        t += h;\n        if (t > 20.f) break;\n        a++;\n    }\n    if (t > 20.f) t = -1.f;\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.f*fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.f, 0.f, 2.f);\n    vec3 rd = normalize(vec3(p, -1.5f));\n\n    vec3 col = vec3(.05f, .1f, .3f);\n    \n    float a;\n    float h;\n    float t = castRay(ro, rd, 0.f, a, h);\n    \n    if (t > -.5f)\n    {\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormals(pos);\n        \n        vec3 mate = texCube(iChannel0, pos, nor).xyz;\n        \n        const vec3 sun_dir = vec3(.8f, .4f, .2f);\n        float sun_dif = clamp(dot(nor, sun_dir), 0.f, 1.f) * .1f;\n        float aa;\n        float sun_shadow = shadow(pos + nor * .001f, sun_dir, aa);\n        \n        float sky_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, 1.f, .0f)), .0f, 1.f);\n        float bounce_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, -1.f, .0f)), .0f, 1.f);\n        \n        col = mate * vec3(7.f, 4.f, 3.f) * sun_dif * sun_shadow;\n        col += mate * vec3(.5f, .8f, .9f) * sky_dif;\n        \n        col += mate*vec3(.7f, .3f, .2f) * bounce_dif;\n        col *= 1.f - smoothstep(pow(float(a), .75f) * .1f, 0.f, .5f) * .75f;\n    }\n    else\n    col /= clamp(h, 0.f, 1.f) * 10.f;\n    col = pow(col, vec3(.4545f));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVfDG", "name": "WDI 2020 Livecoding", "author": "spolsh", "description": "Effect of ~30 min Shader Livecoding session at https://warszawskiedniinformatyki.pl/, Thanks for stopping by and watching pixels bouncing to music", "tags": ["3d", "raymarching", "music", "reflections", "livecoding", "klos"], "likes": 4, "viewed": 245, "date": "1607901253", "time_retrieved": "2024-06-20T20:26:04.527870", "image_code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n// #define R v2Resolution\n// #define T fGlobalTime\n#define F gl_FragCoord\n#define R iResolution\n#define T iTime\n\n#define C(v) clamp(v, 0., 1.)\n#define N normalize\n#define H(v) fract(sin(100.0*v) * 43758.5453)\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v) (texture(texFFT, v).x)\n// fake beat accumulation, next time I will save it in buffer\n#define BI(v) (0.05*T+0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define BS(v) (0.01*texture(iChannel0, v2(v, 0.5)).x)\n#define B(v)  (0.01*texture(iChannel0, v2(v, 0.5)).x)\n\nuniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\nf gB = 10e8;\n\nv3 colR = v3(1., 0, 0);\nv3 colA = v3(0.2, 0.5, 1.4);\nv3 colY = v3(1.0, 1.0, 0.0);\n\nmat2 rot(f a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nf plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  vec4 p = vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n\treturn dot(p, p);\n}\n\nf box(v3 p, v3 b) {\n  v3 q = abs(p) - b;\n  f r = length( max(q, v3(0.))) + min( max(max(q.x, q.y), q.z), 0.);\n  return r;\n}\n\nv3 cp;\n\nf map(v3 p) {\n    \n  v3 p0 = p;\n  p0.x = abs(p0.x);\n  p0.x -= 4.0;\n  f s = -p0.x + 0.05*plas(p.zy * 0.2 + 0.1*T, -1.+sin(T));\n  \n  p -= cp;\n  p -= v3(0, 0, 14);\n  s = min(s, length(p) -0.1 -200.0*BS(0.0));\n  \n  p0 -= v3(0, -1, 14.);\n  p0.yz = mod(p0.yz + 4.0, 8.0) - 4.0;  \n  s = min(s, box(p0, v3(100.0, 0.4, 1.0)));\n  \n  f sbl = box(p0, v3(0.01, 100.0, 0.01) - 0.01);\n  gB = min(gB, sbl);\n  s = min(s, sbl); \n  \n  for (f i = 0.; i < 3.; ++i) {\n    p -= v3(0.1, 0.2 + abs(sin(BS(0.0))), 0.5);\n    p.xy *= rot(  10.0*BI(0.0) ); \n    p.yz *= rot( -20.0*BI(0.2) ); \n    p = abs(p);\n  }\n  \n  f sl = box(p, v3(100.0, 0.01, 0.01));\n  gB = min(gB, sl);\n  s = min(s, sl);\n  \n  f bb = 0.1 +200.0*BS(0.0);\n  s = min(s, \n        mix(length(p) -bb,\n           box(p, v3(bb)),\n           abs(sin(T))\n      ));\n    \n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    v2 q = (2. * F.xy - R.xy) / R.y;\n  \n  v3 c = v3(0);\n  out_color = vec4(c, 1);\n  if (abs(q.y) > 0.75) return;\n  // v3 c = v3(q, 0);\n  \n  f pph = H(F.x + H(F.y + H(T)));\n  \n  v3 ro = v3( 2.0*sin(20.0*BI(0.0)), 2. + 10.0*B(0.0), 20.0*B(0.0));\n  ro.y += sin(20.0*BI(0.0));\n  ro.z += 15.0*T;\n  cp = ro;\n  v3 rd = N(v3(q, 2.));\n  rd.xy *= rot (1.0 * sin(5.0*BI(0.0)) );\n  \n  f tt = 10e8;\n  for (f bi = 0.; bi < 3.; ++bi) {\n    f t = 0.1;\n    for (f i = 0.; i < 64.; ++i) {\n      f d = map(ro + rd * t);\n      if ( t < 0.0001 || t > 40.) break;\n      t += d;\n    }    \n    tt = bi == 0. ? t : tt;\n    if (t > 0.2 && t < 40.) {\n      v3 p = ro + rd * t;\n      // c = fract(p);\n      v2 e = 0.01 * v2(-1, 1);\n      v3 n = N( e.xxx * map(p + e.xxx)\n              + e.yxx * map(p + e.yxx)\n              + e.xyx * map(p + e.xyx)\n              + e.xxy * map(p + e.xxy));\n      f str = smoothstep(0.5, 0.51, fract(p.y));      \n      f str1 = smoothstep(0.5, 0.51, fract(0.13*p.y));      \n      f str0 = smoothstep(0.5, 0.51, texture(iChannel1, 0.1*floor(10.*p.xy)).x);\n      f str2 = smoothstep(0.98, 0.981, fract(0.01*p.z + 0.1*T));      \n      // c = n;      \n      c += 0.2*colR*(str+str1);\n      c += colA*str2;\n      \n      rd = N(reflect(rd, n) + 0.01 * pph);\n      ro = p;\n    }\n  }    \n  // c  = v3(1. - t / 32.);  \n  \n\n  \n  c = mix(c, 0.1*colR, 1.0 - exp(-0.005 * tt*tt));\n  c = mix(c, 0.1*colR, 1.0 - exp(-0.0001 * tt*tt*tt));\n  \n  tt += pph;\n  \n  f sb = 0.2 + 20.0*BS(0.0);\n  c += sb * colY * exp(gB * -20.0);\n  c += sb * colY * exp(gB * -10.0);\n  c += sb * colY * exp(gB *  -1.0);\n  c += colA * 20.0*B(0.0);\n\t    \n  c = c / (1. + c);\n  c = smoothstep(-0.01, 0.9, c);\n  c = pow(c, v3(0.4545));\n  out_color = vec4(c, 1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "ltXXR8", "previewfilepath": "https://soundcloud.com/inzynier/transformator-contest-dj-set", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/inzynier/transformator-contest-dj-set", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVfDR", "name": "function walk (vlllll)", "author": "valalalalala", "description": "Another sort of ray-tracer. It walks along each ray and tests detects a hit when the value of the function (z=f(x,y)) is close to the z value along the ray. \n", "tags": ["raytracing", "function"], "likes": 1, "viewed": 32, "date": "1607037676", "time_retrieved": "2024-06-20T20:26:05.424895", "image_code": "// walk along a ray until it gets close to a function\n// https://tutorial.math.lamar.edu/Classes/CalcIII/QuadricSurfaces.aspx\n\n#define PI2    6.2831952\n#define POZ(v) clamp(v,0.,abs(v))\n#define TIME   iTime * 1.\n\n#define F1(at) ( 0.50 * ( cos( at.x * PI2 ) + sin( at.y * PI2 ) ) )\n#define F2(at) dot(at,at)\n#define F3(at) at.x*at.y+at.x*at.y\n#define F4(at) ( 7.7 * pow( at.x, 2. ) + 1. * pow( at.y, 2. ) )\n#define F5(at) sqrt( POZ( at.x*at.y * 0.33 + 0.13 ) )\n#define F6(at) pow( at.x, 2. ) - pow( at.y, 2. )\n\n\n#define LIGHT_POWER  3.0\n#define LIGHT        vec3( 0.0, 0., 1.33 )\n#define AMBIENT      0.2\n\n#define COUNT     1344\n#define xCOUNT  512\n#define THRESHOLD 0.00033\n\n#define AA\n\nstruct Hit {\n    float t;\n    vec3 hit;\n    vec3 normal;\n};\n\n\nfloat eq( in int i, in float value ) {  \n    return clamp(1.-step(0.3,abs(float(i)-floor(value))),0.,1.);\n}\n\nfloat to3( in int i, in float t, in vec3 at, in float z ) {\n    return eq( i, t ) * z;\n}\n\nfloat evaluateFunction( in vec3 at ) {\n\tfloat t = 1. + mod( TIME * 0.11, float( 5 ));\n\treturn 0.\n        + to3( 1, t, at, F1( at ) )\n        + to3( 2, t, at, F2( at ) )\n        + to3( 3, t, at, F3( at ) )\n        + to3( 4, t, at, F4( at ) )\n        + to3( 5, t, at, F5( at ) )\n        + to3( 6, t, at, F6( at ) )\n    ;\n}\n\nHit makeHit( in float t, in vec3 a, in vec3 increment ) {\n\tvec3 oncrement = vec3( -increment.y, increment.x, 0. );\n    vec3 b = a + increment;\n    vec3 c = a + oncrement;\n    b.z = evaluateFunction( b );\n    c.z = evaluateFunction( c );\n    vec3 ab = normalize( b - a );\n    vec3 ac = normalize( c - a );           \n    return Hit( t, a, cross( ab, ac ) );\n}\n\nHit walk( in vec3 at, in vec3 direction ) {\n\tvec3 increment = direction / float( COUNT );\n    \n\tfor ( int i = 0 ; i < COUNT ; i++ ) {\n        float z = evaluateFunction( at );\n        float d = pow( at.z - z, 2.0 );\n        if ( d > THRESHOLD ) {\n            at += increment;\n        } else {\n            float t = float( i ) / float( COUNT );\n            at.z = z;\n            return makeHit( t, at, increment );\n        }\n    }\n    return Hit( -1., vec3(0.), vec3(0.) );\n}\n\nvec3 colorHit( in Hit hit_ ) {\n    float t = hit_.t;\n    vec3 hit = hit_.hit;\n    vec3 normal = hit_.normal;\n    \n\tvec3 toLight = LIGHT - hit;\n\tfloat angleLight = dot( normalize( toLight ), normal );\n\tfloat distanceLight = dot( toLight, toLight );\n    float valueLight = LIGHT_POWER / distanceLight;\n  \n    angleLight = clamp( angleLight, 0., 1. );\n        \n    // check if light is blocked...\n    \n    float selfAvoidance = THRESHOLD;\n    Hit occlusion = walk( hit + toLight * selfAvoidance, toLight );\n    \n    // any hit blocks light: t=-1 -> 1 ; t=0.33 -> 0 \n    float occluded = 1.-step( 0., occlusion.t );\n    \n    // closer hits block more light\n    //occluded = abs( occlusion.t ); \n    \n    // distant hits block more light\n    occluded = clamp( 0., 1., occlusion.t );\n    \n    //occluded = pow( abs(occlusion.t), 0.15 );\n    //occluded = 1.;\n    \n    // calulate effect of light\n    \n    float light = AMBIENT;\n    light += (1.-light) * valueLight * angleLight * occluded;\n    \n    // the actual color part... kinda lame...\n    \n    vec3 color = abs( vec3( hit.x, hit.y, hit.z ) );\n    color = 1.2 * t * 0.7  + 0.23 * color;\n    \n    //color *= (0.6+0.3*abs( normal.z ));\n    \n\t// final color\n    \n    return light * color;\n}\n\nvec3 colorAt( in vec2 xy  ) {   \n    float t = TIME * 1.6;\n    vec2 rot = vec2(cos(t), sin(t));\n\n    // bumping the z beyond 200 is fun\n    vec3 origin = vec3(xy *2., 2.0 + abs( sin( t ) ) * 3. ); \n    vec3 destination = vec3( xy + rot + 0.50, -1. );    \n    vec3 direction = destination - origin;\n    \n    // primary and secondary rays\n    \n    Hit primary = walk( origin, direction );   \n    Hit secondary = walk( primary.hit, -primary.normal );\n    \n    vec3 primaryColor    = colorHit( primary );\n    vec3 secondaryColor  = colorHit( secondary );\n    float primaryLegit   = step( 0., primary.t );\n    float secondaryLegit = step( 0., secondary.t );\n    float neitherLegit   = 1. - primaryLegit;\n    \n    primaryColor   *= primaryLegit;\n    secondaryColor *= secondaryLegit;\n    vec3 foreground = mix( primaryColor, secondaryColor, 0.2 );\n    \n    vec2 bxy = fract( abs(xy) ) - 0.5 + 0.5 * rot;\n    float bl = dot( bxy, bxy );\n    //bl = ( bxy.x * bxy.y );\n    vec3 background = vec3( bxy, bl ) * neitherLegit * 0.33;\n\n    return foreground + background;\n}\n\nvec3 raerae( in vec2 st, in float scale ) {\n    vec2 xy = (2.0*st-iResolution.xy) / iResolution.y * scale;\n    return colorAt( xy );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float f = 0.5 / iResolution.y;\n    float scale = 1.1 + abs( cos( TIME ) );\n    \n\tfloat weight = 1.;\n    \n    vec3 color = vec3( 0. );\n    color += raerae( fragCoord.xy + vec2( 0., 0. ), scale );\n#ifdef AA\n    weight = 0.25;\n    color += raerae( fragCoord.xy + vec2( f,  0. ), scale );\n    color += raerae( fragCoord.xy + vec2( f,  f  ), scale );\n    color += raerae( fragCoord.xy + vec2( 0., f  ), scale );\n#endif\n    fragColor = vec4( weight * color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVfWd", "name": "Radial and Angular Linewidths", "author": "jllusty", "description": "Test of uniform radial and angular linewidths in a polar plot.", "tags": ["randompolargrid"], "likes": 5, "viewed": 83, "date": "1608273451", "time_retrieved": "2024-06-20T20:26:05.424895", "image_code": "float pi = 4.*atan(1.);\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rand(vec2 n) { \n\tfloat a = fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    float b = fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    return vec2(a,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  10.* ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    float r = length(uv);\n    \n    if (int(floor(r)) % 2 == 0) {\n        float freq = rand(vec2(floor(r),1)).y;\n        uv *= rotate(freq*iTime);\n    }\n    else {\n        float freq = rand(vec2(floor(r),-1)).y;\n        uv *= rotate(-freq*iTime);\n    }\n    \n    float theta = atan(uv.y,uv.x)+pi;\n\n    float n = 7.;    \n    float eps = 30./iResolution.y;\n    float dt = abs(mod(theta+pi/n,2.*pi/n)-pi/n);\n    float ct = smoothstep(2.*eps,eps,dt*r);\n    \n    float dr = abs(fract(r+0.5)-0.5);\n    float cr = smoothstep(2.*eps,eps,dr);\n    \n    float cc = max(ct,cr);\n    \n    vec2 dc = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    vec3 col = mix(vec3(dc.x,.5,dc.y),vec3(0.),cc);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyBRc", "name": "Rces_Sphere", "author": "Rces", "description": "Simple sphere with light source", "tags": ["light"], "likes": 1, "viewed": 43, "date": "1607616974", "time_retrieved": "2024-06-20T20:26:05.424895", "image_code": "vec4 sphere()\n{\t\n\treturn vec4(0, 0, 2, 1);\n}\nvec3 light()\n{\n    float start = 2.3;\n\treturn vec3(sin(iTime+start), 1, 1.0+cos(iTime+start));\n}\nfloat equation(float a, float b, float c)\n{\n\tfloat d = b * b - 4.0 * a * c;\n\tif (d >= 0.0)return (-b - sqrt(d)) / a / 2.0;\n\telse return -1.0;\n}\nvec3 hit(vec3 l, vec4 s)\n{\n\tfloat a = dot(l,l);\n    float b = -2.0*dot(l,s.xyz);\n    float c = dot(s.xyz,s.xyz)-dot(s.w,s.w);\n    float eq = equation(a,b,c);\n    if(eq>=0.0)\n    {\n    \treturn l*eq;\n\t}\n    else return vec3(0.0,0.0,0.0);\n}\nfloat angle(vec3 A,vec3 B)\n{\n\treturn dot(A,B)/length(A)/length(B);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/vec2(iResolution.y,iResolution.y)-vec2(iResolution.x/iResolution.y,1.0);\n    vec3 A = normalize(vec3(uv,1));\n    vec3 H = hit(A,sphere());\n    vec3 L = normalize(H-light());\n    vec3 N = normalize(H-sphere().xyz);\n    float coef = (length(normalize(H) - reflect(L,N)))/2.0;\n    vec3 col;\n    if(H!=vec3(0.0,0.0,0.0))\n\t\tcol = vec3(coef,coef,coef);\n    else\n    \tcol = vec3(0.0,0.0,0.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyBRK", "name": "hoeled_alien", "author": "hoeled", "description": "An alien.", "tags": ["2d", "alien"], "likes": 4, "viewed": 42, "date": "1607477580", "time_retrieved": "2024-06-20T20:26:05.424895", "image_code": "float Hash21(vec2 p) {\n\tp = fract(p*vec2(123.34, 456.21));\n    p += dot (p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nfloat Scene(vec2 uv) {\n    vec2 gv = uv;\n    float d = length(gv);\n    float circle = smoothstep(.201, .2, d);\n    \n    gv /= sin(gv.x*50.)*1.5;\n    gv.x -= sin(iTime*1.)*.1;\n    //uv.x = abs(uv.x*1.3);\n    d = length(gv);\n    \n    float ant = smoothstep(.28, .24, d);\n    float scene = circle + ant;\n    circle = smoothstep(.1501, .15, length(uv));\n    scene -= circle*2.;\n    \n\treturn clamp(scene, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\t\n    uv.x += sin(iTime*60.)*.0005;\n    uv *= uv.x/uv.y+uv.x*.1;\n    uv.x -= .2;\n    uv *= .8;\n    \n    col.r += Scene(uv);\n    col.r += Scene(uv*.8)*.4;\n    col.b += Scene(uv*.5)*.1;\n    col.g += Scene(uv*.5)*.1;\n    \n    float sz = cos(iTime)*.004;\n    col.rg += smoothstep(.122+sz, .12+sz, length(uv))*2.;\n    col.rgb += smoothstep(.14, .0, length(uv-.02))*.5;\n    \n    col.b += col.r * sin(iTime)*.8;\n    \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y += tan(iTime*.5);\n    col -= smoothstep(1.4, 0.0, length(uv.y));\n    \n    col *= Hash21(vec2(uv.x, uv.x))*.2+.9;\n    \n    // vignette\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    col -= Hash21(uv)*.3;\n    uv.x += sin(iTime*60.)*.0005;\n    uv *= .6;\n    uv.x *= 4.5;\n    uv.y -= .5;\n    vec3 colOrg = col;\n    col *= smoothstep(-.95, .0, uv.y)*1.5;\n    col *= smoothstep(0., -.95, uv.y)*1.5;\n    col *= smoothstep(-5., 1., uv.x)*1.5;\n    col *= smoothstep(5., -1., uv.x)*1.5;\n    col = mix(colOrg, col, 0.9);\n    col *= 1.04;\n    \n    col -= Hash21(uv)*.3;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyBRt", "name": "Viscosity", "author": "klk", "description": "Some soapy slimy colorfull liquid", "tags": ["slimy"], "likes": 25, "viewed": 657, "date": "1607701656", "time_retrieved": "2024-06-20T20:26:05.424895", "image_code": "// Created by Alex Kluchikov\n\n#define PI 3.141592654\n\nvec2 rot(vec2 p,float a)\n{\n    float c=cos(a*15.83);\n    float s=sin(a*15.83);\n    return p*mat2(s,c,c,-s);\n}\n\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xx;\n    uv=vec2(.125,.75)+(uv-vec2(.125,.75))*.03;\n    float T=iTime*.25;\n\n    vec3 c = clamp(1.-.7*vec3(\n        length(uv-vec2(.1,0)),\n        length(uv-vec2(.9,0)),\n        length(uv-vec2(.5,1))\n        ),0.,1.)*2.-1.;\n\n    vec3 c0=vec3(0);\n    float w0=0.;\n    const float N=16.;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.2)*.3;\n        float wp=0.5+(i+1.)*(i+1.5)*0.001;\n        float wb=.05+i/N*0.1;\n    \tc.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*17.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);\n        float w=(1.5-i/N);\n        c0+=c*w;\n        w0+=w;\n    }\n    c0=c0/w0*2.+.5;//*(1.-pow(uv.y-.5,2.)*2.)*2.+.5;\n    c0*=.5+dot(c0,vec3(1,1,1))/sqrt(3.)*.5;\n    c0+=pow(length(sin(c0*PI*4.))/sqrt(3.)*1.0,20.)*(.3+.7*c0);\n\to=vec4(c0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyBWV", "name": "dick v1", "author": "spplash", "description": "raymarching test", "tags": ["dickraymarching"], "likes": 2, "viewed": 191, "date": "1607973985", "time_retrieved": "2024-06-20T20:26:06.418875", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.f\n#define SURF_DIST .01f\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0., 1.);\n\n\tvec3 c = a + t*ab;\n\treturn length(p-c) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n\treturn length(vec2(x, p.y)) - r.y;\n}\n\nfloat dBox(vec3 p, vec3 hsize) {\n\treturn length(max(abs(p) - hsize, 0.f));\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(abs(length(p.xz)),p.y)) - vec2(h,r);\n  d.x = abs(d.x) - 0.01;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n//  p.x = abs(p.x);\n  p.z = -p.z;\n  float k = (sc.y*p.z>sc.x*p.y || p.z < 0.) ? dot(p.zy,sc) : length(p.zy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat GetDist(vec3 p) {\n    //p = p//* vec3(0.8, 1.2, 0.8);\n    vec3 c = p - vec3(0., 1.0, 0.);\n\n\t//float d = sdCappedCylinder(c, 0.3, 0.3);\n    \n    float bl1 = sdEllipsoid(c-vec3(0.2, 0., 0.), vec3(0.25, 0.35, 0.25));\n    float bl2 = sdEllipsoid(c-vec3(-0.2, 0., 0.), vec3(0.25, 0.35, 0.25));\n    float bls = smin(bl1, bl2, 0.2);\n    \n    float r = 1.3 + sin(iTime)/4.;\n    \n    float pn = sdCappedTorus(c-vec3(0., 0.15 - r, 0.), vec2(.8, 0.6), r, 0.2);\n    \n    float d = smin(bls, pn, 0.1);\n    \n\treturn d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 res = vec2(0.0,-1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n\n#if 1\n\t// raytrace bounding plane\n\tfloat tp = (3.5-ro.y)/rd.y;\n\tif( tp>0.0 ) tmax = min( tmax, tp );\n#endif\n\n\t// raymarch scene\n\tfloat t = tmin;\n\tfor( int i=0; i<256 && t<tmax; i++ )\n\t{\n\t\tvec2 h = vec2(GetDist(ro+rd*t), 0.);\n\t\tif(abs(h.x)<(0.0005*t))\n\t\t{\n\t\t\tres = vec2(t,h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\n\treturn res;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n\tvec2 e = vec2(0.01, 0);\n\n\tvec3 n = d - vec3(\n\t\tGetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n\t\tGetDist(p - e.yyx));\n\n\treturn normalize(n);\n}\n\nfloat rand(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat rand2d(vec2 v)\n{\n\tvec2 K1 = vec2(23.14069263277926,2.665144142690225);\n\treturn fract( cos( dot(v,K1) ) * 12345.6789 );\n}\n\nfloat rand3d(vec3 v)\n{\n\tvec3 K1 = vec3(23.14069263277926, 2.665144142690225, 7.5739974548463465);\n\treturn fract( cos( dot(v,K1) ) * 12345.6789 );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 lookat)\n{\n\tvec3 cw = normalize(lookat-ro);\n\tvec3 cp = vec3(sin(0.), cos(0.),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 uv = (fragCoord.xy-.5*resolution) / resolution.y;\n\n\tvec3 sky_col = vec3(0.3, 0.0, 0.0);\n\tvec3 col = sky_col;\n\n\tfloat light_coef = 1.;\n\tvec3 light_color = vec3(1., 0.8, 0.8);\n\n\tcol = clamp((1.-length(uv-vec2(0., -0.5)) - 0.1*rand2d(uv+iTime)) * light_coef, 0., 1.) * light_color;\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    vec3 lookat = vec3(0., 1., 0.);\n    vec3 ro = lookat + vec3( 2.5*cos(0.1*iTime + 7.0*mo.x), 0.8 + 1.0*mo.y, 2.5*sin(0.1*iTime + 7.0*mo.x) );\n//\tvec3 ro = lookat + vec3(-3.0f, 1.f, -2.0f);\n    mat3 cam_mat = setCamera(ro, lookat);\n    \n    \n\tvec3 rd = cam_mat * normalize(vec3(uv.x+0., uv.y, 1));\n\n\tvec2 d = RayMarch(ro, rd);\n\n\tvec3 p = ro + rd * d.x;\n\n\tif (d.y > -0.5) {\n\t\t// moving light\n\t\tvec3 lightPos = vec3(-1.2, 1.1, -0.9);\n\t\tvec3 light_dir = lightPos - p;\n\t\tvec3 l = normalize(light_dir);\n\t\tvec3 normal = GetNormal(p);\n\n\t\tvec3 sky_l_dir = vec3(0, 1, 0);\n\n\t\t// light coef\n\t\tfloat main_light = clamp(dot(normal, l) - rand3d(p/*+iTime*/)*0.05, 0., 1.) * 0.5;\n\n\t\tcol = vec3(0.4, 0.4, 0.4);\n        \n\t\t// lightning\n\t\tvec3 lin = vec3(0.);\n\t\tlin += 2. * (0.1+light_coef * main_light) * light_color;\n\n\t\tcol = col * lin;\n\n\t\t// gama\n\t\tcol = pow(col, vec3(1./2.2));\n\t}\n\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyBzK", "name": "Endless animation 01", "author": "JacobC", "description": "I watched this video https://www.youtube.com/watch?v=csLP4Q3XCzs so I wanted to recreated", "tags": ["3d", "light", "animation", "ao", "reproduction"], "likes": 15, "viewed": 100, "date": "1607576657", "time_retrieved": "2024-06-20T20:26:06.418875", "image_code": "#define AA 1.\n#define R iResolution.xy\n#define T iTime\n#define Pi 3.141592\n\n//#define BLEED\n\n#define color vec3(.5, .7, 1)\n\nstruct mat\n{\n\tfloat z; // depth\n    vec3 c;  // color\n    float a; // ao\n    vec3 i;  // IL\n};\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\nfloat box(in vec3 p, in vec3 s, in float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(vec3(0), p)) - k;\n}\n\nmat2 rotate(in float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat map(in float i , in float c, in float l, in float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\n// Cheap AO https://www.shadertoy.com/view/ttXfWX\n// Cheap IL 1 bounce fake https://www.shadertoy.com/view/WtSfzh\nmat Uop(in mat a, in mat b)\n{\n    float s = max(a.z, b.z);\n    float ao = map(s, 1., 44.8, 115.2);\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c, \n            clamp(a.a * ao, 0., 1.),\n            a.i * mix(a.z > b.z ? a.c : b.c, vec3(1.), map(s, 1., 22.4, 57.6))\n        );\n}\n\n#define STEPS 99\n#define MIN_S .01\n#define MAX_S 99.\n\nmat scene(in vec3 p)\n{\n\t// Inclined cubes\n\tvec3 q = p;\n    float subSpace = sqrt(2.);\n    float offsetZ = floor(q.x / subSpace) * 1.;\n    q.x = mod(q.x, subSpace) - subSpace * .5;\n    q.xy *= rotate(45. * Pi / 180.);\n    q.z += offsetZ;\n    \n    mat b0 = mat(box(q, vec3(.5), .02), color, 1., vec3(1));\n\n\tq = p;\n    q.x -= sqrt(2.) - .05;\n    q.z -= .1;\n    float offsetZ2 = floor(q.x / subSpace) * 1.;\n    q.x = mod(q.x, subSpace) - subSpace * .5;\n    float bA = box(q - vec3(-sqrt(2.)*.5+.1, -.05, -offsetZ2), vec3(.05, .05, .55), .0);\n    \n    q = p;\n    q.x -= 1.52;\n    float offsetZ3 = floor(q.x / subSpace) * 1.;\n    q.x = mod(q.x, subSpace) - subSpace * .5;\n    float bB = box(q - vec3(0, -.05, -offsetZ3 + sqrt(2.) * .5 - 1.1), vec3(sqrt(2.), .05, .05), .01);\n    \n    mat bAB = mat(min(bA, bB), vec3(1.5), 1., vec3(1));\n    \n    // Cube animation\n    q = p;\n    float time = T;\n    float loop = mod(time, 1.);\n    float rotateBox = pow(loop, 3.) * floor(mod(time + 1., 2.)); \n    float moveBoxX = floor((time + 1.) * .5);\n  \tfloat z = floor(mod(T, 2.)) * loop;\n    float moveBoxZ = floor(T * .5) + pow(z, 4.);\n    float angle = rotateBox * Pi;\n    q.xy -= vec2(sqrt(2.) * moveBoxX - subSpace * .5, sqrt(2.) * .5);\n    q.z -= 1. - moveBoxZ;\n    q.xy *= rotate(-angle);\n    q.x += sqrt(2.) * .5;\n    q.xy *= rotate(45. * Pi / 180.);\n     \n    mat b1 = mat(box(q, vec3(.5), .0), vec3(1.5), 1., vec3(1));\n    \n    // Ground\n    q = p;\n    mat f = mat(q.y + .02, color, 1., vec3(1));\n    \n    mat r = Uop(b0, b1);\n    r = Uop(r, bAB);\n    r = Uop(r, f);\n    \n    // I guess still missing white edges computation for AO and IL\n    // That's why the discontinuity in the white cube\n    if (r.z < MIN_S)\n    {\n    \tq = p;\n        q.x = mod(q.x, subSpace) - subSpace * .5;\n        q.x -= sqrt(2.);\n        q.z += 1.;\n        q.xy *= rotate(45. * Pi / 180.);\n        q.z += offsetZ;\n\n        mat bL = mat(box(q, vec3(.5), .0), color, 1., vec3(1));\n        \n        q = p;\n        q.x = mod(q.x, subSpace) - subSpace * .5;\n        q.x += sqrt(2.);\n        q.z -= 1.;\n        q.xy *= rotate(45. * Pi / 180.);\n        q.z += offsetZ;\n\n        mat bR = mat(box(q, vec3(.5), .0), color, 1., vec3(1));\n        \n        r = Uop(r, bL);\n        r = Uop(r, bR);\n    }\n    \n    return r;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(scene(p).z - vec3(scene(p - e.xyy).z, scene(p - e.yxy).z, scene(p - e.yyx).z));\n}\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.z * .9;\n        if (s.z < MIN_S)\n            return mat(t, s.c, s.a, s.i);\n        if (t > MAX_S)\n            return mat(t, vec3(-1), -1., vec3(-1));\n    }\n    return mat(t, vec3(-1), -1., vec3(-1));\n}\n\nvoid mainImage(out vec4 O, in vec2 F)\n{\n\tvec2 st = F;\n    O = vec4(0,0,0,1);\n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - R * .5) / R.y;\n\n            float aX = -1. + T * sqrt(2.) * .5;\n            float aZ = 5. - T * .5;\n            vec3 o = vec3(aX, 1.5, aZ);\n            vec3 d = camera(uv * .7, o, vec3(aX, .5, aZ-5.));\n\n            mat m = marcher(o, d);\n            if (m.a != -1.)\n            {\n                vec3 p = o + d * m.z;\n                vec3 n = normal(p);\n\n                vec3 light_pos = vec3(aX, 255., aZ);\n                vec3 light_dir = normalize(light_pos - p);\n\n                float diff = max(dot(n, light_dir), 0.);\n\n                #ifdef BLEED\n                    O.rgb += (diff + m.a * m.i) / 2. * m.c;\n                #else\n                    O.rgb += (diff + m.a) / 2. * m.c;\n                #endif\n            }\n            else\n                O.rgb += color;\n        }\n\t}\n\n    O.rgb = sqrt(O.rgb / (AA * AA));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyBzt", "name": "Magic Boxes", "author": "Kamoshika", "description": "I drew magic circles on the boxes.", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 86, "date": "1607706382", "time_retrieved": "2024-06-20T20:26:06.418875", "image_code": "// I made this while streaming.\n// Watch YouTube video!!\n// https://www.youtube.com/watch?v=0ahLMwimXcw\n\nconst float pi = acos(-1.0);\n\nmat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 pmod(vec2 p, float n) {\n\tfloat a = 2.*pi/n;\n\tfloat theta = atan(p.y, p.x) + 0.5*a;\n\ttheta = floor(theta/a)*a;\n\treturn p*rotate(-theta);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\n/*vec3 hsv2rgb(float h, float s, float v) {\n\tfloat c_max = v;\n\tfloat c_min = c_max-s*c_max;\n\tfloat r,g,b;\n\n\th = mod(h, 1.);\n\th *= 6.;\n\tif(h < 1.) {\n\t\tr = c_max;\n\t\tg = h*(c_max-c_min) + c_min;\n\t\tb = c_min;\n\t} else if(h < 2.) {\n\t\tr = (2.-h)*(c_max-c_min) + c_min;\n\t\tg = c_max;\n\t\tb = c_min;\n\t} else if(h < 3.) {\n\t\tr = c_min;\n\t\tg = c_max;\n\t\tb = (h-2.)*(c_max-c_min) + c_min;\n\t} else if(h < 4.) {\n\t\tr = c_min;\n\t\tg = (4.-h)*(c_max-c_min) + c_min;\n\t\tb = c_max;\n\t} else if(h < 5.) {\n\t\tr = (h-4.)*(c_max-c_min) + c_min;\n\t\tg = c_min;\n\t\tb = c_max;\n\t} else if(h < 6.) {\n\t\tr = c_max;\n\t\tg = c_min;\n\t\tb = (6.-h)*(c_max-c_min) + c_min;\n\t}\n\treturn vec3(r,g,b);\n}*/\n\nfloat rand2(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.5322, 57.2115)))*65231.1264);\n}\n\nfloat distBox(vec3 p, float size) {\n\treturn length(max(abs(p)-size, 0.))-size*0.5;\n}\n\nconst float num = 5.;\nfloat interval_xy;\nfloat interval_z = 15.;\nfloat dist(vec3 p) {\n\tfloat d = 1e5;\n\tvec3 z;\n\tp.xy = mod(p.xy, interval_xy) - 0.5*interval_xy;\n\tfor(float i=0.; i<num; i++) {\n\t\tz = p;\n\t\tz.z -= interval_z/num*i;\n\t\tz.z = mod(z.z, interval_z) - 0.5*interval_z;\n\t\t\n\t\tfloat size = 0.1 + abs(sin(iTime*4.+pi/num*i))*0.5;\n\t\td = min(d, distBox(z, size));\n\t}\n\treturn d;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = 0.0001;\n\treturn normalize(vec3(dist(p+vec3(d,0,0))-dist(p+vec3(-d,0,0)),\n\t\t\t      dist(p+vec3(0,d,0))-dist(p+vec3(0,-d,0)),\n\t\t\t      dist(p+vec3(0,0,d))-dist(p+vec3(0,0,-d))\n\t\t\t      ));\n}\n\nfloat exp2Fog(float distance, float density) {\n\tfloat s = distance * density;\n\treturn exp(-s*s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 color=vec3(1);\n\t\n\tvec3 cPos = vec3(0, 0, 5);\n\tvec3 cDir = vec3(0, 0, -1);\n\tvec3 cUp = vec3(0, 1, 0);\n\tcUp.xy *= rotate(iTime*0.1);\n\tvec3 cSide = cross(cDir, cUp);\n\t\n\tvec3 lightDir = normalize(vec3(-1, 1, 2));\n\tlightDir.xy *= rotate(iTime*0.1);\n\t\n\tfloat targetDepth = 2.5;\n\tvec3 ray = normalize(p.x*cSide + p.y*cUp + cDir*targetDepth);\n\t\n    interval_xy = 5.+sin(iTime)*2.5;\n    \n\tfloat distance = 0.;\n\tvec3 rPos = cPos;\n\tfor(int i=0; i<100; i++) {\n\t\tdistance = dist(rPos);\n\t\tif(abs(distance) < 0.001) {\n\t\t\tbreak;\n\t\t}\n\t\trPos += ray * distance;\n\t}\n    \n    if(distance < 0.001) {\n        vec3 normal = getNormal(rPos);\n        vec3 Pos = rPos;\n\n        Pos.xy = mod(Pos.xy, interval_xy)-0.5*interval_xy;\n        vec2 id = rPos.xy - Pos.xy;\n        id /= interval_xy;\n        float r= rand2(id*0.005+floor(iTime*2.));\n        vec3 base = hsv2rgb(r, 1., 1.);\n\n        Pos *= num;\n        Pos.z = mod(Pos.z, interval_z)-0.5*interval_z;\n\n        vec3 temp = abs(Pos);\n        vec2 fPos;\n        if(temp.x > temp.y && temp.x > temp.z) {\n            fPos = Pos.yz;\n        } else if(temp.y > temp.z && temp.y > temp.x) {\n            fPos = Pos.zx;\n        } else {\n            fPos = Pos.xy;\n        }\n        fPos /= num;\n\n        fPos *= rotate(iTime*2.);\n        float s = 0.06;\n        vec2 z;\n        z = fPos;\n        z = pmod(z, 3.);\n        base *= s/abs(z.x-0.3);\n        z = fPos*rotate(pi/3.);\n        z = pmod(z, 3.);\n        base *= s/abs(z.x-0.3);\n        z = fPos;\n        base *= s/length(z-normalize(z)*0.6);\n        float spec = pow(max(dot(lightDir, normal), 0.), 30.);\t\n\n        color = base + spec;\n    }\n    \n    float fog = exp2Fog(length(rPos-cPos), 0.01);\n    color = mix(vec3(1), color, fog);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyfDK", "name": "Polka de Sphère", "author": "IWBTShyGuy", "description": "dancing polca-dotted spheres\n\nInspired by Yayoi Kusama", "tags": ["pattern"], "likes": 5, "viewed": 242, "date": "1607966608", "time_retrieved": "2024-06-20T20:26:07.515978", "image_code": "// Copyright © 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// ------ Configures ------ //\nconst vec3 RED = vec3(230.0, 0.0, 18.0) / 255.0;\nconst vec3 GREEN = vec3(0.0, 167.0, 60.0) / 255.0;\nconst vec3 BLUE = vec3(0.0, 100.0, 180.0) / 255.0;\n\nconst uint N_SPHERE = 8u;\nconst float SPHERE_RADIUS = 0.5;\nconst float ORBIT_RADIUS = 2.0;\nconst float ORBIT_VELO = 1.0;\nconst float ROTATION_VELO = 1.5;\nconst vec3 ROTATION_AXIS = normalize(vec3(1.0, 2.0, 0.0));\n\nconst float SPHERE_DOT_RADIUS = 0.07;\nconst float BACK_DOT_RADIUS = 0.21;\nconst float BACK_DOT_INTERVAL = 0.12;\nconst float BACK_DOT_VELO = 1.5;\n\n// ------ 3D utilities ------ //\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\nbool depthTest(in Ray ray, in vec3 current_position, in vec3 new_position) {\n    float dist0 = distance(ray.origin, current_position);\n    float dist1 = distance(ray.origin, new_position);\n    return dist0 > dist1;\n}\n\n// ------ sphere ------ //\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nSphere newSphere(in vec3 center, in float radius) {\n    Sphere sphere;\n    sphere.center = center;\n    sphere.radius = radius;\n    return sphere;\n}\n\nconst float A = (sqrt(5.0) + 1.0) / 2.0;\nconst float B = (sqrt(5.0) - 1.0) / 2.0;\n\nconst uint N = 32u; // the number of vertices.\nconst vec3 VERTICES[N] = vec3[](\n    normalize(vec3(1.0, 1.0, 1.0)),\n    normalize(vec3(1.0, 1.0, -1.0)),\n    normalize(vec3(1.0, -1.0, 1.0)),\n    normalize(vec3(1.0, -1.0, -1.0)),\n    normalize(vec3(-1.0, 1.0, 1.0)),\n    normalize(vec3(-1.0, 1.0, -1.0)),\n    normalize(vec3(-1.0, -1.0, 1.0)),\n    normalize(vec3(-1.0, -1.0, -1.0)),\n    normalize(vec3(0.0, A, B)),\n    normalize(vec3(0.0, A, -B)),\n    normalize(vec3(0.0, -A, B)),\n    normalize(vec3(0.0, -A, -B)),\n    normalize(vec3(A, B, 0.0)),\n    normalize(vec3(A, -B, 0.0)),\n    normalize(vec3(-A, B, 0.0)),\n    normalize(vec3(-A, -B, 0.0)),\n    normalize(vec3(B, 0.0, A)),\n    normalize(vec3(B, 0.0, -A)),\n    normalize(vec3(-B, 0.0, A)),\n    normalize(vec3(-B, 0.0, -A)),\n    normalize(vec3(0.0, 1.0, A)),\n    normalize(vec3(0.0, 1.0, -A)),\n    normalize(vec3(0.0, -1.0, A)),\n    normalize(vec3(0.0, -1.0, -A)),\n    normalize(vec3(1.0, A, 0.0)),\n    normalize(vec3(1.0, -A, 0.0)),\n    normalize(vec3(-1.0, A, 0.0)),\n    normalize(vec3(-1.0, -A, 0.0)),\n    normalize(vec3(A, 0.0, 1.0)),\n    normalize(vec3(A, 0.0, -1.0)),\n    normalize(vec3(-A, 0.0, 1.0)),\n    normalize(vec3(-A, 0.0, -1.0))\n);\n\nbool onSphere(in Ray ray, in Sphere sphere, out vec3 intersection) {\n    vec3 to_center = sphere.center - ray.origin;\n    vec3 h = to_center - dot(to_center, ray.direction) * ray.direction;\n    float d2 = sphere.radius * sphere.radius - dot(h, h);\n    if (d2 < 0.0) return false;\n    intersection = ray.origin + (dot(to_center, ray.direction) - sqrt(d2)) * ray.direction;\n    return true;\n}\n\n// ------ basis function for gradation ------ //\nfloat parab(float t) { return 2.0 * t * t; }\n\nvec3 nowColor(float t) {\n    t = fract(t / 3.0) * 3.0;\n    float r0 = t < 1.0 ? (t < 0.5 ? 1.0 - parab(t) : parab(1.0 - t)) : 0.0;\n    float g = t < 2.0 ? (t < 1.0 ? 1.0 - r0 : (t < 1.5 ? 1.0 - parab(t - 1.0) : parab(2.0 - t))) : 0.0;\n    float r1 = 2.0 < t ? (t < 2.5 ? parab(t - 2.0) : 1.0 - parab(3.0 - t)) : 0.0;\n    float b = 1.0 < t ? 1.0 - g - r1 : 0.0;\n    return (r0 + r1) * RED + g * GREEN + b * BLUE;\n}\n\nSphere[N_SPHERE] createSpheres(float t) {\n    Sphere sphere[N_SPHERE];\n    for (uint i = 0u; i < N_SPHERE; i++) {\n        float theta = t + 2.0 * PI * float(i) / float(N_SPHERE);\n        sphere[i] = newSphere(vec3(sin(theta), 0.0, cos(theta)) * ORBIT_RADIUS, SPHERE_RADIUS);\n    }\n    return sphere;\n}\n\nvec4 backGroundPolka(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y / BACK_DOT_INTERVAL + BACK_DOT_VELO * iTime;\n    vec2 lattice = uv + 0.5;\n    lattice = vec2(floor(lattice.x), floor(lattice.y));\n    if (distance(uv, lattice) < BACK_DOT_RADIUS) return vec4(nowColor(iTime), 1.0);\n    else return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotOnSphere(in Sphere sphere, in vec3 position, mat3 rotation) {\n    return rotation * (position - sphere.center) + sphere.center;\n}\n\nvec4 spherePolka(in Sphere sphere, in vec3 position) {\n    for (uint i = 0u; i < N; i++) {\n        vec3 dot_center = sphere.radius * VERTICES[i] + sphere.center;\n        if (distance(position, dot_center) < SPHERE_DOT_RADIUS) {\n            return vec4(nowColor(-iTime), 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 unit = normalize(vec3(0.0, -0.5, 1.0));\n    Camera camera = newCamera(\n        -5.0 * unit - vec3(0.0, 0.5, 0.0),\n        unit,\n        vec3(0.0, 1.0, 0.0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, uv);\n\n    Sphere sphere[N_SPHERE] = createSpheres(ORBIT_VELO * iTime);\n    bool onOneSphere = false;\n    vec3 position = vec3(100.0);\n    uint idx;\n    for (uint i = 0u; i < N_SPHERE; i++) {\n        vec3 tmp_position;\n        if (onSphere(ray, sphere[i], tmp_position)) {\n            if (depthTest(ray, position, tmp_position)) {\n                position = tmp_position;\n                idx = i;\n            }\n            onOneSphere = true;\n        }\n    }\n    if (onOneSphere) {\n        mat3 rotation = rot(ROTATION_AXIS, ROTATION_VELO * iTime);\n        position = rotOnSphere(sphere[idx], position, rotation);\n        fragColor = spherePolka(sphere[idx], position);\n    } else {\n        fragColor = backGroundPolka(fragCoord);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyfRw", "name": "Realistic Ocean with Reflections", "author": "erkan612", "description": "This is realistic ocean with simple ray marching(sphere tracing) techniques.", "tags": ["raymarching", "reflection", "lighting", "ocean", "sky", "fog", "realistic"], "likes": 8, "viewed": 265, "date": "1606866440", "time_retrieved": "2024-06-20T20:26:09.261699", "image_code": "/*\n* Created by erkan612 - 02.12.2020\n* * Discord: erkan612#9667\n*/\n\nconst vec3 BACKGROUND_COLOR = vec3(0.0, 1.0, 0.0);\nconst vec3 DEFAULT_MESH_COLOR = vec3(0.8);\nconst int MAX_STEPS = 150;\nconst float SURFACE_DISTANCE = 0.01;\nconst float MAX_RENDER_DISTANCE = 40.0;\nconst int MAX_REFLECTION_STEPS = 20;\nconst float FOG_START = 20.0;\nconst float FOG_END = 50.0;\nconst vec3 FOG_COLOR = vec3(1.0);\nconst vec3 SKY_DOWN_COLOR = vec3(1.0);\nconst vec3 SKY_UP_COLOR = vec3(0.7, 0.8, 1.0)*1.15;\nconst vec3 SEA_BASE_COLOR = vec3(0.1,0.2,0.3)*1.2;\nconst vec3 SEA_WATER_COLOR = vec3(0.5)*0.5;\n\n// Ocean Displacement Req\nfloat Hash(vec2);\nfloat Noise(vec2);\nfloat SeaHard(vec2, float);\nfloat SeaHeight(vec2, float, int, float);\n\n// Ocean\nvec3 GetOceanColor(vec3, vec3, vec3);\n\n// Secene Maps\nvec4 MAP_Scene(vec3, vec3);\nvec4 MAP_DETAILED_Scene(vec3);\nvec4 MAP_REFLECTION_Scene(vec3, vec3);\nvec4 MAP_SIMPLE_Scene(vec3);\n\n// N\nvec3 GetNormal(vec3);\nvec3 GetNormalForReflection(vec3);\nvec3 Diffuse(vec3, vec3, int, vec3);\nvec3 Specular(vec3, vec3, vec3, vec3, float);\n\n// Ray Tracing\nvec3 RayMarch(vec3, vec3);\nvec3 REFLECTION_RayMarch(vec3, vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    float t = float(iTime/75.0);\n    float d = 12.0;\n    //t = 0.0;\n    float pitorad = 180.0/3.1415;\n    \n    vec3 ro = vec3(cos(t*pitorad) * d, 0.3*d, sin(t*pitorad)*d);\n    //vec3 ro = vec3(0.0, 1.0, -3.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(vec3(0.0, 1.0, 0.0), cz));\n    vec3 cy = normalize(cross(cz, cx));\n    vec3 rd = normalize(cx * uv.x + cy * uv.y + cz * 1.0);\n    vec3 color = RayMarch(ro, rd);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n// Ocean Displacement Req\nfloat Hash(vec2 p) {\n\treturn fract(sin(dot(p, vec2(5.5, 8.5)*84.5))*845.8425);\n}\n\nfloat Noise(vec2 p) {\n\tvec2 lv = smoothstep(0.0, 1.0, fract(p));\n    vec2 id = floor(p);\n    \n    float bl = Hash(id);\n    float br = Hash(id+vec2(1.0, 0.0));\n    float b = smoothstep(0.0, 1.0, mix(bl, br, lv.x));\n    \n    float tl = Hash(id+vec2(0.0, 1.0));\n    float tr = Hash(id+vec2(1.0, 1.0));\n    float t = smoothstep(0.0, 1.0, mix(tl, tr, lv.x));\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SeaHard(vec2 p, float hard) {\n    p += Noise(p);\n    vec2 aw = 1.0-abs(sin(p));\n    vec2 bw = abs(cos(p));\n\taw = mix(aw,bw,aw);\n    return pow(1.0-pow(aw.x*aw.y,0.65), hard);\n}\n\nfloat SeaHeight(vec2 p, float timeShift, int detail, float freqSize) {\n\tfloat h = 0.0;\n    float hard = 4.0;\n    float freq = 0.1 * freqSize;\n    float hh = 1.0;\n    \n    for (int i = 0; i < detail; i++) {\n    \tfloat d = SeaHard((p+timeShift)*freq, hard);\n    \td += SeaHard((p-timeShift)*freq, hard);\n        h += d * hh;\n        hard = mix(hard, 1.0, 0.2);\n        hh *= 0.22;\n        freq *= 1.9;\n        p *= vec2(1.66, -1.60);\n    };\n    \n    return 1.0-h;\n}\n\n// Ocean\nvec3 GetOceanColor(vec3 p, vec3 n, vec3 eye) {\n    vec3 color = DEFAULT_MESH_COLOR;\n    vec3 eyeVec = normalize(eye - p);\n    \n    float fresnel = 1.0-max(dot(eyeVec, n), 0.0);\n    fresnel = pow(fresnel, 3.0)*0.4;\n    \n    vec3 diff = Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0));\n    \n    vec3 reflected = vec3(1.0);\n    vec3 refracted = SEA_BASE_COLOR + diff * SEA_WATER_COLOR * 0.15;\n    color = mix(refracted, reflected, fresnel);\n    \n    color += SEA_WATER_COLOR * p.y * 0.5;\n    \n    color += Specular(normalize(vec3(1.0, 1.0, 0.2)), n, eyeVec, vec3(1.0), 64.0);\n    \n\treturn color;\n}\n\n// Scene Maps\nvec4 MAP_REFLECTION_Scene(vec3 p, vec3 eye, int mode) { // Main Reflection Scene\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    vec3 n = mode == 1 ? GetNormalForReflection(p) : vec3(0.0);\n    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            color = sphereColor*diff;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            color = oceanColor;\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\nvec4 MAP_Scene(vec3 p, vec3 eye, int mode) { // Main Scene\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    vec3 n = mode == 1 ? GetNormal(p) : vec3(0.0);\n    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            vec3 reflected = mode == 1 ? REFLECTION_RayMarch(p+n*SURFACE_DISTANCE, reflect(-normalize(eye-p), n)) : vec3(1.0);\n            color = mix(sphereColor, reflected, 0.5)*diff;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 2, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            vec3 reflected = mode == 1 ? REFLECTION_RayMarch(oceanP+n*SURFACE_DISTANCE, reflect(-normalize(eye-oceanP), n)) : vec3(1.0);\n            color = mix(oceanColor, reflected, max(dot(normalize(eye-p), n), 0.0)/5.0);\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\nvec4 MAP_DETAILED_Scene(vec3 p) { // Detailed Main Secene\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            color = sphereColor;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 5, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            color = oceanColor;\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\nvec4 MAP_SIMPLE_Scene(vec3 p) {\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            color = sphereColor;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            color = oceanColor;\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\n// N\nvec3 GetNormal(vec3 p) {\n\tvec2 e = vec2(SURFACE_DISTANCE, 0.0);\n    float dist = MAP_DETAILED_Scene(p).w;\n    return normalize(dist-vec3(\n    \tMAP_DETAILED_Scene(p-e.xyy).w,\n        MAP_DETAILED_Scene(p-e.yxy).w,\n        MAP_DETAILED_Scene(p-e.yyx).w\n    ));\n}\nvec3 GetNormalForReflection(vec3 p) {\n\tvec2 e = vec2(SURFACE_DISTANCE, 0.0);\n    float dist = MAP_SIMPLE_Scene(p).w;\n    return normalize(dist-vec3(\n    \tMAP_SIMPLE_Scene(p-e.xyy).w,\n        MAP_SIMPLE_Scene(p-e.yxy).w,\n        MAP_SIMPLE_Scene(p-e.yyx).w\n    ));\n}\n\nvec3 Diffuse(vec3 l, vec3 n, int normalized, vec3 color) {\n\treturn (normalized == 1 ? dot(l,n)*0.5+0.5 : max(dot(l,n), 0.0)) * color;\n}\n\nvec3 Specular(vec3 l, vec3 n, vec3 eyeVec, vec3 color, float s) {\n\treturn pow(max(dot(normalize(reflect(-eyeVec, n)), l), 0.0), s)*color;\n}\n\n// Ray Tracing\nvec3 REFLECTION_RayMarch(vec3 ro, vec3 rd) {\n\tvec3 color = vec3(0.5);\n    float st = 1.0/float(MAX_REFLECTION_STEPS);\n    vec3 p = vec3(0.0);\n    \n    for (int i = 0; i < MAX_REFLECTION_STEPS; i++) {\n    \tp = ro + rd*st;\n        vec4 mesh = MAP_REFLECTION_Scene(p, ro, 0);\n        \n        // Scene Color\n        if (mesh.w <= SURFACE_DISTANCE) {\n            mesh = MAP_REFLECTION_Scene(p, ro, 1);\n            vec3 sceneColor = mesh.xyz;\n        \t\n             if (st>=FOG_START) {\n            \tfloat nrmlz = st - FOG_START;\n                nrmlz /= FOG_END - FOG_START;\n                sceneColor = mix(sceneColor, FOG_COLOR, pow(nrmlz, 1.0));\n            }\n            \n            color = sceneColor;\n            break;\n        }\n        \n        if (st >= MAX_RENDER_DISTANCE) {\n        \tbreak;\n        }\n        \n        st += mesh.w;\n    }\n    \n    // Sky(Background) Color\n    if (st >= MAX_RENDER_DISTANCE) {\n    \tcolor = mix(SKY_DOWN_COLOR, SKY_UP_COLOR, pow(abs(p.y), 0.1));\n    }\n    \n    return color;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 color = BACKGROUND_COLOR;\n    float st = 0.0;\n    vec3 p = vec3(0.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tp = ro + rd*st;\n        vec4 mesh = MAP_Scene(p, ro, 0);\n        \n        // Scene Color\n        if (mesh.w <= SURFACE_DISTANCE) {\n            mesh = MAP_Scene(p, ro, 1);\n            vec3 sceneColor = mesh.xyz;\n        \t\n             if (st>=FOG_START) {\n            \tfloat nrmlz = st - FOG_START;\n                nrmlz /= FOG_END - FOG_START;\n                sceneColor = mix(sceneColor, FOG_COLOR, pow(nrmlz, 1.0));\n            }\n            \n            color = sceneColor;\n            break;\n        }\n        \n        if (st >= MAX_RENDER_DISTANCE) {\n        \tbreak;\n        }\n        \n        st += mesh.w;\n    }\n    \n    // Sky(Background) Color\n    if (st >= MAX_RENDER_DISTANCE) {\n    \tcolor = mix(SKY_DOWN_COLOR, SKY_UP_COLOR, pow(abs(p.y), 0.1));\n    }\n    \n    return color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyfWd", "name": "fun hills", "author": "CubeyTheCube", "description": "This is unfinished. Ignore my unreadable spaghetti code. I am currently debugging so ignore the fact that it looks bad.\n", "tags": ["hills"], "likes": 4, "viewed": 250, "date": "1609115786", "time_retrieved": "2024-06-20T20:26:09.267788", "image_code": "mat4 rotationX( in float angle) {\n  return mat4(1.0, 0, 0, 0,\n    0, cos(angle), -sin(angle), 0,\n    0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotationY( in float angle) {\n  return mat4(cos(angle), 0, sin(angle), 0,\n    0, 1.0, 0, 0,\n    -sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotationZ( in float angle) {\n  return mat4(cos(angle), -sin(angle), 0, 0,\n    sin(angle), cos(angle), 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1);\n}\nvec3 rotate( in vec3 p, in float xrot, in float yrot, in float zrot) {\n  vec4 rot = vec4(p, 1.0) * rotationX(xrot) * rotationY(yrot) * rotationZ(zrot);\n  return rot.xyz; // ref https://gist.github.com/onedayitwillmake/3288507\n}\nfloat random( in vec2 st) {\n  return fract(sin(dot(st.xy,\n      vec2(12.9898, 78.233))) *\n    43758.5453123);\n}\nfloat noise( in vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  return mix(a, b, u.x) +\n    (c - a) * u.y * (1.0 - u.x) +\n    (d - b) * u.x * u.y;\n}\nfloat fbm( in vec2 p) { // ref https://thebookofshaders.com/13/\n  float y = 0.;\n  float f = 0.007;\n  float a = 0.5;\n  for (int i = 0; i < 10; i++) {\n    y += a * noise(f * p * 100.);\n    f *= 2.0;\n    a *= 0.5;\n  }\n  return y;\n}\nfloat terrain( in vec2 p) {\n  return fbm(p) * 2.0;\n}\nfloat raymarch( in vec3 ro, in vec3 rd, in int w) {\n  #define dt 0.05\n  vec3 p;\n  float h;\n  float t = 0.;\n  float dist;\n  for (int i = 0; i < 64; i++) {\n    p = ro + rd * t;\n    h = terrain(vec2(p.x, p.z));\n    dist = (p.y - h) / 2.;\n    if(w == 1) {\n      dist = min(dist,abs(0.7-p.y));\n    }\n    t += dist;\n\n  }\n  return t;\n}\n\nfloat fresnel( in vec3 i, in vec3 n, in float eta) {\n  float r0 = (1.-eta)/(1.+eta);\n  r0 *= r0;\n  return clamp(0.0,1.0,r0 + (1. - r0) * pow((1. - clamp(0.,1.,dot(i, n))), 5.0));\n}\nvec3 normal( in vec2 pos) {\n  vec2 e = vec2(0.03, 0.0);\n  return normalize(vec3(terrain(pos - e.xy) - terrain(pos + e.xy),\n    2.0 * e.x,\n    terrain(pos - e.yx) - terrain(pos + e.yx)));\n}\n\nvec3 interpolate(vec3 a, vec3 b, float t) {\n  return mix(a, b, clamp(t, 0.0, 1.0));\n}\nfloat ggx( in float a, in float cosine) {\n  return (a * a) / (3.14159265 * pow(cosine * cosine * (a * a - 1.) + 1., 2.0));\n}\nvec3 bgcol( in vec2 uv) {\n  float len = length(vec2(uv.x, uv.y * iResolution.y / iResolution.x) - vec2(0.2, 0.2));\n  float sun;\n  if (abs(len) > 0.4) {\n    sun = ggx(0.3, 0.0);\n  } else {\n    float dotProd = 1. - 2. * len;\n    sun = ggx(0.3, dotProd);\n  }\n  return min(vec3(1., 1., 1.), mix(vec3(52., 82., 235.) / 255., vec3(135., 206., 235.) / 255., 0.5 - uv.y) + vec3(1.0, 1., 0.) * sun);\n\n} // sun and sky\n\nvec3 fullBcol( in vec2 uv, in vec3 o, in vec3 d, inout vec3 bcol) {\n  vec2 cloudUV = 0.00002 * (o.xz + d.xz * ((3.) * 40000.0 - o.y) / d.y); // ref https://www.shadertoy.com/view/Msdfz8\n  cloudUV.y += iTime * 0.7;\n  bcol = bgcol(uv * 0.5 * iResolution.y / iResolution.x + vec2(d.x, d.y));\n  vec3 bcol2 = bcol;\n  bcol = interpolate(bcol, vec3(1.0), 2.5 * pow(fbm(cloudUV), 5.));\n  bcol = interpolate(bcol2, bcol, d.y * 4.0);\n  return bcol;\n} // sun, sky, and clouds\nvec3 scol( in float y) {\n  vec3 sc;\n  if (y < .9)\n    sc = vec3(0.486, 0.988, 0.0);\n  else if (y < 1.2)\n    sc = interpolate(vec3(0.486, 0.988, 0.0), vec3(0.341, 0.231, 0.047), (y - 1.) / 0.1);\n  else\n    sc = interpolate(vec3(0.341, 0.231, 0.047), vec3(1.0), (y - 1.3) / 0.1);\n  return sc;\n} // terrain color\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 col, bcol;\n  vec2 uv = fragCoord / iResolution.xy - vec2(0.5);\n  vec2 mouse = iMouse.xy / iResolution.xy - vec2(0.5);\n  vec3 o = vec3(0., 2., iTime);\n  vec3 d = normalize(vec3(uv.x, uv.y - 0.2, 1.0));\n  d = rotate(d, -mouse.y, mouse.x, 0.0);\n  float t = raymarch(o, d, 1);\n  vec3 i = o + d * t;\n  vec3 l = -normalize(vec3(vec2(.2, .2)-i.xy, 1.0-(i.y-o.y)));\n  vec3 n = normal(i.xz);\n  //n = normalize(n + 0.4 * vec3(random(n.xy * 100.), random(n.yz * 100.), random(n.zx * 100.)));\n  float shade = dot(n, l);\n  vec3 sc;\n  if (i.y < .71) {\n    n = vec3(0.,1.,0.);\n    vec3 r = reflect(d,n);\n    vec3 rf = refract(d, n, 3.);\n    float t2 = raymarch(i, r, 0);\n    vec3 rcol;\n    vec3 rfcol;\n    vec3 bcol2;\n    vec3 i2;\n    vec3 n2;\n    vec3 l2;\n    if (t2 > 16.) {\n      rcol = mix(vec3(52., 82., 235.) / 255., vec3(135., 206., 235.) / 255., .5 - r.y);\n    } else {\n      i2 = i + r * t2;\n      n2 = normal(i2.xz);\n      l2 = -normalize(vec3(vec2(.2, .2)-i2.xy, 1.0-(i2.y-i.y)));\n      rcol = scol(i2.y) * dot(n2, l2);\n    }\n    t2 = raymarch(i, rf, 0);\n      if (t2 > 16.) {\n      rfcol = mix(vec3(52., 82., 235.) / 255., vec3(135., 206., 235.) / 255., 0.5 - r.y);\n    } else {\n      i2 = i + rf * t2;\n      n2 = normal(i2.xz);\n      l2 = -normalize(vec3(vec2(.2, .2)-i2.xy, 1.0-(i2.y-i.y)));\n      rfcol = scol(i2.y) * dot(n2, l2);\n    }\n    float fres = fresnel(d, -n, 3.);\n    col = mix(mix(rfcol,rcol,fres),vec3(0.0,0.0,1.0)*dot(n,l),0.5);\n  } else {\n    sc = scol(i.y);\n\n    col = sc * shade;\n  }\n\n  if (t > 16.) {\n    col = fullBcol(uv, o, d, bcol);\n    col = interpolate(col, bcol, (min(20., t) - 16.0) / 4.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyfWt", "name": "Twisted Helices", "author": "dr2", "description": "Based on \"Twisted Curves\" (endless possibilities...)", "tags": ["helix", "symmetry"], "likes": 11, "viewed": 198, "date": "1608213278", "time_retrieved": "2024-06-20T20:26:09.267788", "image_code": "// \"Twisted Helices\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TwTorusDf (vec3 p, float cvOrd, float cvWrapI, float ri, float rc, float rt)\n{\n  vec2 u;\n  float s;\n  u = Rot2D (vec2 (length (p.xz) - rc, p.y), cvWrapI * atan (p.z, p.x));\n  s = 2. * pi / cvOrd;\n  u = Rot2D (u, - s * (floor ((0.5 * pi - atan (u.x, u.y)) / s + 0.5)));\n  return 0.4 * (length (vec2 (u.x - ri, u.y)) - rt);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  d = TwTorusDf (p, 8., -1., 0.5, 2., 0.25);\n  DMIN (1);\n  d = TwTorusDf (p, 7., 5., 0.6, 2., 0.21);\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n    else if (idObj == 2) col4 = vec4 (0.7, 0.2, 0.1, 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 6.;\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl3cRH", "name": "Transmission thru Noise", "author": "Carandiru", "description": "A 2D volumetric ray march thru blue noise\n", "tags": ["bluenoise", "transmission"], "likes": 3, "viewed": 197, "date": "1608487322", "time_retrieved": "2024-06-20T20:26:09.989031", "image_code": "// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// shader is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/tl3cRH\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define ZOOM 0.25f  // less is more zoom\n#define SPEED 0.125f\n#define MAX_STEPS 64\n#define EPSILON 0.000000001f\n\n// for noise\n#define sample_nearest iChannel0\n#define sample_nearest_dimensions iChannelResolution[0].xy\n// for normals from noise\n#define sample_linear iChannel2\n#define sample_linear_dimensions iChannelResolution[2].xy\n\nconst float SQRT_MAX_STEPS = -2.0f * sqrt(float(MAX_STEPS));\nconst vec2 light_start = vec2(0, -1); \nconst float noise_start = -0.75f;\nconst float opacity_threshold = 0.5f;\n\nfloat zoom = ZOOM;\n\nfloat fetch_opacity(in sampler2D source, in vec2 dimensions, in vec2 uv)\n{\n    return(textureLod(source, (uv * 0.5f + 0.5f) * iResolution.xy / dimensions * zoom, 0.0f).r);\n}\n\nfloat fetch_opacity(in vec2 uv)\n{\n    return(fetch_opacity(sample_nearest, sample_nearest_dimensions, uv));\n}\n\nvec2 computeNormal(in sampler2D source, in vec2 dimensions, in vec2 uv)\n{\n    vec3 half_texel_offset = vec3(0.5f, 0.5f, 0.0f) / vec3(dimensions, 1.0f);\n\n\tvec2 gradient;\t\n\n\tgradient.x = fetch_opacity(source, dimensions, uv - half_texel_offset.xz) - fetch_opacity(source, dimensions, uv + half_texel_offset.xz);\n\tgradient.y = fetch_opacity(source, dimensions, uv - half_texel_offset.zy) - fetch_opacity(source, dimensions, uv + half_texel_offset.zy);\n\t\n\treturn( normalize(gradient) );\n}\n\nvec2 computeNormal(in vec2 uv)\n{\n    return(computeNormal(sample_linear, sample_linear_dimensions, uv));\n}\n\n\n\nconst vec3 royal_blue_purple = vec3(0.222f,0.222f,1.0f) * vec3(0.80f,0.65f,1.0f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tT = iTime * SPEED;\n    zoom = exp2(-(tT + (44.0f * SPEED)) * ZOOM * 2.0f);\n    \n    vec2 uv = (fragCoord/iResolution.xy) * 2.0f - 1.0f;\n    \n    vec2 ro = vec2(uv.x, uv.y + tT);\n    vec2 rd = normalize(vec2(0, 1));\n    \n    float dt = 1.0f / length(iResolution.xy * rd);\n    \n    vec2 p = ro + rd * dt * fetch_opacity(uv); // jittered offset\n    \n    vec2 light_pos = light_start + vec2(sin(iTime), tT);\n    \n    float intensity = 1.0f;\n    float light = 0.0f;\n    float tran = 1.0f;\n    for(int i = MAX_STEPS; i >= 0; --i) {\n    \n        vec2 ld = p - light_pos;\n        float dist = length(ld);    \n        float att = 1.0f / (1.0f + dist*dist);\n        \n        float lightAmount = att * intensity * 2.0f;\n        \n        float opacity = fetch_opacity(p);\n        float sigmaS = lightAmount * (1.0f-opacity);\n        float inv_sigmaE = 1.0f / max(EPSILON, sigmaS); // to avoid division by zero extinction\n    \n        float sigma_dt = exp2(sigmaS * SQRT_MAX_STEPS * dt);\n        float Sint = (sigmaS - sigmaS * sigma_dt) * inv_sigmaE;\n\n        light += tran * Sint;\n\n\t    tran *= sigma_dt;\n       \n        if (tran < 0.015f)\n            break;\n       \n        if (opacity - opacity_threshold >= 0.0f) {\n        \n            vec2 n = computeNormal(p);\n            rd = reflect(rd, n);\n            \n            intensity = max(0.0f, dot(normalize(ld), n)) * tran;\n          //  light_pos = p;  // optional adds flicker\n        }\n        \n        p += rd * dt;\n    }\n    \n    vec3 color = vec3(light * (1.0f - tran));\n    \n    color = mix(color, mix(royal_blue_purple, color, tran), light);\n    //color = vec3(rd, 0);\n    //color = vec3(normal * 0.5f + 0.5f, opacity) * opacity;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl3cRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl3cRr", "name": "Hello Blobby wavy thing", "author": "tetrismegistus", "description": "Just a beginner's experiment", "tags": ["beginner"], "likes": 1, "viewed": 177, "date": "1608336009", "time_retrieved": "2024-06-20T20:26:10.146482", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct - 0.02, pct, st.y) -\n           smoothstep(pct, pct + 0.02, st.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    float y = sin(iTime + st.x * PI) + sin(iTime + st.y * PI);\n\n    // Time varying pixel color\n    vec3 color = vec3(y, sin(iTime), 1);\n    float pct = plot(st, y);\n\n    // Output to screen\n    color = (1.0 - pct) * color + pct * vec3(0.44, cos(iTime), sin(iTime));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl3cRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl3yR8", "name": "Colorful star", "author": "rrx", "description": "a rotating star", "tags": ["star", "rotating"], "likes": 2, "viewed": 33, "date": "1608448108", "time_retrieved": "2024-06-20T20:26:10.473721", "image_code": "vec2 rotatexy(vec2 uv, float r) \n{\n    float x1 = sin(r);\n    float x2 = cos(r);\n    mat2 m = mat2(x1,x2,-x2,x1);\n    return uv * m;\n}\n\nfloat bump(float x)\n{\n    return smoothstep(-1., 0., x) - smoothstep(0., 1., x);\n}\n\nfloat smoothbump(float r, float dr, float d)\n{\n    return smoothstep(r-dr, r, d) - smoothstep(r, r+dr, d);\n}\n\nfloat hardbump(float r, float dr, float d) \n{\n    return step(r, d) - step(r+dr, d);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // normalize aspect\n    vec2 R = iResolution.xy;\n    vec2 uv = ( R - 2.*fragCoord ) / R.y;\n    \n    vec2 uv0 = uv;\n    float phi = atan(uv0.y, uv0.x) + iTime*0.1;\n    float d0 = length(uv0);\n    float d = -0.3 + d0 + 0.3*sin(5.*phi);\n    //d  = d * smoothstep(0., 0.2, d0);\n    //d  = d * step(0.1, d0);\n    \n    float r = .5;\n    float dr = 200./R.x;\n    \n    float c1 = smoothbump(r, dr, d);\n    float c2 = smoothbump(r*1.5, dr, d);\n    float c3 = smoothbump(r/1.5, dr, d);\n    \n//    float c4 = .8 * bump((d-0.3)*1.5);\n    float c4 = smoothbump(0.1, dr, d0);\n//    c4 = c4 - c4*smoothstep(0.2, .3, d);\n    //c4 = c4 * step(0.01, d);\n    \n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2 = col1.zyx;\n    vec3 col3 = col1.yzx;\n    vec3 col4 = col1.zxy;\n    \n    vec3 col = col1 * c1 + col2 * c2 + col3 * c3 + col4 * c4;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl3yRn", "name": "NDP 2020 - Most Epic Fireplace", "author": "transfear", "description": "NDP 2020", "tags": ["ndp2020beenox"], "likes": 2, "viewed": 61, "date": "1608318420", "time_retrieved": "2024-06-20T20:26:11.079881", "image_code": "vec3 blackbody(float temp)\n{\n    float red   = 1.5 * temp;\n    float green = 1.2 * pow(temp, 2.0);\n    float blue  = pow(temp, 5.0);\n    \n    return vec3(red, green, blue);\n}\n\n#define NUM_WAVES_FLAMES 6\nvec3 flames(in vec2 offset, in vec2 uv)\n{\n    float vWavesPeriod[NUM_WAVES_FLAMES] = float[NUM_WAVES_FLAMES] ( 7.0, 10.0, 15.0, 20.0, 25.0, 33.0 );\n    float vWavesScroll[NUM_WAVES_FLAMES] = float[NUM_WAVES_FLAMES] ( 2.3, -1.3, 4.5, -5.9, 1.1, -9.7 );\n    float vWavesWeight[NUM_WAVES_FLAMES] = float[NUM_WAVES_FLAMES] ( 2.2, 1.8, 1.4, 1.4, 1.2, 1.0 );\n\n    float sum = 0.0;\n    float totalWeight = 0.0;\n    for (int i = 0; i < NUM_WAVES_FLAMES; ++i)\n    {\n        sum += (0.5 + 0.5 * sin(offset.x + uv.x * vWavesPeriod[i] + iTime * vWavesScroll[i])) * vWavesWeight[i];\n        totalWeight += vWavesWeight[i];\n    }\n    \n    sum /= totalWeight;\n    \n    float flameIntensity;\n    if (uv.y <= offset.y)\n    {\n        flameIntensity = sum;\n    }\n    else\n    {\n        flameIntensity = sum - uv.y + offset.y;\n    }\n    \n    flameIntensity = pow(clamp(flameIntensity, 0.0, 1.0), 1.0);\n    return blackbody(flameIntensity);\n}\n\n#define NUM_FLAME_LAYERS 3\nvec3 flameLayers(in vec2 uv)\n{\n    vec2  flameOffsets[NUM_FLAME_LAYERS] = vec2[NUM_FLAME_LAYERS] (vec2(-2.0, 0.0), vec2(0.0, 0.2), vec2(4.0, 0.4));\n    float flameWeights[NUM_FLAME_LAYERS] = float[NUM_FLAME_LAYERS] (0.7, 0.33, 0.33);\n\n    vec3 totalFlames = vec3(0.0);\n    for (int i = 0; i < NUM_FLAME_LAYERS; ++i)\n    {\n        vec3  fSrc  = flames(flameOffsets[i], uv);\n        float fSrcA = flameWeights[i];\n        vec3  fDst  = totalFlames;\n        totalFlames = fSrc * fSrcA + fDst;\n    }\n\n    return totalFlames;\n}\n\nfloat backgroundIntensity(in vec2 uv)\n{\n    float baseY = 1.0 - uv.y;\n    baseY = pow(baseY, 0.1);\n    \n    float disturbance = 0.5 + 0.5 * sin(uv.x * 3.1415);\n    baseY *= pow(disturbance, 3.2);\n    return baseY;\n}\n\n\n#define BRICKS_DIST_TO_CENTER 0.45\n#define NUM_BRICKS_W 10.0\n#define NUM_BRICKS_H 10.0\n#define GROOT_W 0.025\n#define GROOT_H 0.05\n#define BRICK_COLOR vec3(166.0/255.0,  83.0/255.0,  38.0/255.0)\n#define GROOT_COLOR vec3(150.0/255.0, 129.0/255.0, 117.0/255.0)\nvec4 bricks( in vec2 uv )\n{\n    vec4 bricks = vec4(0.0);\n    \n    vec2 distToCenter = vec2(0.5) - uv;\n    if (length(distToCenter) < BRICKS_DIST_TO_CENTER)\n        return bricks;\n    \n    if (uv.y <= 0.5 && abs(distToCenter.x) < BRICKS_DIST_TO_CENTER)\n        return bricks;\n\n    bricks.w = 1.0;\n    \n    float brickYRow;\n    float brickY = modf(uv.y * NUM_BRICKS_H, brickYRow);\n    float evenOffset = ((int(brickYRow) & 1) == 0) ? 0.5 : 0.0;\n    \n    float brickX = fract(uv.x * NUM_BRICKS_W + evenOffset);\n    if ( (brickX < GROOT_W || 1.0 - brickX < GROOT_W) ||\n         (brickY < GROOT_H || 1.0 - brickY < GROOT_H))\n    {\n        bricks.xyz = GROOT_COLOR;\n    }\n    else\n    {\n        bricks.xyz = BRICK_COLOR;\n    }\n    \n    return bricks;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Flames\n    float bgIntensity     = backgroundIntensity(uv);\n    vec3  flamesIntensity = flameLayers(uv);\n    vec3  col             = bgIntensity * flamesIntensity;\n    \n    // Bricks\n    vec4 bricks = bricks(uv);\n    col = bricks.w * bricks.xyz + (1.0 - bricks.w) * col;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl3yz7", "name": "Jello lens 2", "author": "Shellderr", "description": "jello lens", "tags": ["lens", "jello"], "likes": 0, "viewed": 39, "date": "1608670882", "time_retrieved": "2024-06-20T20:26:11.079881", "image_code": "#define rr(s) (s*0.5+0.5)\n#define dst(v) (length(uv-v))\n\nvec2 bnc(float t,vec2 p){\n    return abs(fract(p*t*0.05)-0.5)*4.-1.;\n}\n\nfloat ss(float t){\n    return (3.*sin(t)*sin(t)+2.*cos(t)) *sin(t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float mm = 7.;\n    float mag = 1.0;\n    \n    mm += 10.*iMouse.y/iResolution.y;\n\n    vec2 p = bnc(iTime,vec2(3.22,4.64));\n    vec2 p2 = bnc(iTime,vec2(2.72,3.74));\n    vec2 p3 = bnc(iTime,vec2(3.88,1.87));\n\n    float d = log(mag+(sin(dst(p)*mm)));\n    \n    d *= log(mag+(sin(dst(p2)*mm)));\n    d *= log(mag+(sin(dst(p3)*mm)));\n\n    d += dst(vec2(0.))*33.;\n    \n    fragColor =  vec4( vec3( rr(ss(d)),0., rr(ss(d)) ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlcyRH", "name": "Generalized Newton's Method", "author": "darkeclipz", "description": "An animation of the parameter a in the generalized Newton's method.\n\n - https://darkeclipz.blogspot.com/2020/12/newton-fractals.html", "tags": ["fractal", "newton"], "likes": 2, "viewed": 311, "date": "1608471446", "time_retrieved": "2024-06-20T20:26:11.086123", "image_code": "#define R iResolution.xy\n#define C fragCoord\n#define T iTime\n#define M iMouse\n\nfloat pixelSize = 0.;\nfloat pi = 3.14159;\nfloat e = 2.718281828459;\n\nvec3 magma(float t) {\n\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    t *= 2.;\n    if(t >= 1.)\n    {\n        t = 2. - t;\n    }\n    \n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 c0 = vec3(0,2,5)/255.;\nvec3 c1 = vec3(8,45,58)/255.;\nvec3 c2 = vec3(38,116,145)/255.;\nvec3 c3 = vec3(167,184,181)/260.;\nvec3 c4 = vec3(38,116,145)/255.;\n\nvec3 cmap(float t) {\n    vec3 col = vec3(0);\n    col = mix( c0,  c1, smoothstep(0. , .2, t));\n    col = mix( col, c2, smoothstep(.2, .4 , t));\n    col = mix( col, c3, smoothstep(.4 , .6, t));\n    col = mix( col, c4, smoothstep(.6,  .8, t));\n    col = mix( col, c0, smoothstep(.8, 1.,  t));\n    return col;\n}\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); \n                               return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 map(vec2 z, vec2 c, float n) {\n    float b = 4., i=0.;\n    float ii = n;\n    \n    // x = x - f(x)/f'(x)\n \n    \n    //c = (2.*iMouse.xy-R) / R.y;\n    //z = vec2(1,0);\n    \n    vec2 z_prev = z;\n    for(i=0.; i < n; i++) {\n        \n        \n        z_prev = z;\n        \n        float p = 3.;\n        float t = iTime / 40.;\n        vec2 a = vec2(cos(13.*t), sin(15.*t));\n        float r = 2.*(cos(iTime)*.5 + .5) + .3;\n        \n        // z = z - cdiv(cpow(z, 2.0) + vec2(1.0, 0), cmul(z, vec2(2.0,0)));\n        // z = z - cdiv(sin(z) - vec2(1.0,0), cos(z));\n        \n        z = z - cmul(a, cdiv(cpow(z, 3.0) - vec2(1,0), cmul(vec2(3.,0), cpow(z, 2.0))));\n        \n        \n        // z = z - r * cdiv(cpow(z, p) - vec2(1.0, 0), cmul(cpow(z, p-1.0), vec2(p, 0))) + c;\n        // z = z - cdiv(cpow(z - vec2(1.0, 0), 3.0) , cmul(cpow(z, 2.0), vec2(3.,0))) + c;\n        \n        // z = z - cdiv(cpow(sin(z), 2.0) - vec2(1.0,0), cmul(cmul(sin(z), cos(z)), vec2(2.0,0)));\n        // z = z - cdiv(sin(z) - vec2(1.0, 0), cos(z));\n        // z = z - cdiv(cpow(z, 3.) - vec2(1.0, 0), cmul(cpow(z,2.), vec2(3.0,0))) + c;\n        // z = z - cmul(a, cdiv(cpow(z, p) - vec2(-1,0), cmul(vec2(p,0), cpow(z, p-1.))));\n        \n        if( abs(length(z-z_prev)) < 0.0001){\n            ii = min(ii, i);\n        }\n        \n        if(dot(z,z) > 8.) {\n            //ii = min(i, ii);\n            //break;\n        }\n   \n\t}   \n    return vec3(z, ii / n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*C-R)/R.y;\n    uv *= 1.2;\n    float t = iTime / 4.;\n    // uv *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    pixelSize = 1./R.y;\n    vec3 m = map(uv, uv, 60.);\n    vec2 z = m.xy;\n    \n    //z = uv;\n    \n    // Calculate polar coordinates\n    float r = sqrt(dot(z, z));\n    float theta = atan(z.y, z.x+0.000000001);\n     \n    // Normalize theta\n    float thetaNorm = (pi + theta) / (2.*pi);\n    \n    // Color the angle based on rainbow colors, and show the distance\n    float absW = log2(length(m.z));\n    float a = 0.0;\n    vec3 col = hsb2rgb(vec3(thetaNorm, 1., 1.) +.1) * (1.0 - a + a*absW);\n    \n    //col = hsb2rgb(vec3(fract(length(z)),1.,1.));\n    //col = magma(fract(length(z)));\n    //col = magma(m.z);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlcyRN", "name": "Shmup Shader by Katsuomi", "author": "jorge2017a1", "description": "Shmup Shader by Katsuomi", "tags": ["shmupshaderbykatsuomi"], "likes": 10, "viewed": 134, "date": "1608564408", "time_retrieved": "2024-06-20T20:26:12.092157", "image_code": "// Shmup Shader\n// by Katsuomi Kobayashi (@korinVR)\n// http://framesynthesis.com/\n\n\n#define SCREEN_W 0.7\n#define SCROLL_SPEED 0.1\n\n#define BLINK_INTERVAL 0.06\nfloat blink = 0.;\n\nvec2 p = vec2(0.);\n\nvec2 myfighter_pos = vec2(0.);\n\nhighp float rand(vec2 co){\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat linear_map(float value, float s0, float s1, float d0, float d1)\n{\n\treturn d0 + (value - s0) * (d1 - d0) / (s1 - s0);\n}\n\nvoid set_myfighter_pos()\n{\n\tfloat n = floor(iTime * 2.0);\n\tfloat t = fract(iTime * 2.0);\n\n\tfloat x0 = linear_map(rand(vec2(n, 0)), 0.0, 1.0, -0.3, 0.3);\n\tfloat x1 = linear_map(rand(vec2(n + 1.0, 0)), 0.0, 1.0, -0.3, 0.3);\n\tfloat y0 = linear_map(rand(vec2(0, n)), 0.0, 1.0, -0.4, -0.1);\n\tfloat y1 = linear_map(rand(vec2(0, n + 1.0)), 0.0, 1.0, -0.4, -0.1);\n\n\tfloat x = linear_map(t, 0.0, 1.0, x0, x1);\n\tfloat y = linear_map(t, 0.0, 1.0, y0, y1);\n\n\tmyfighter_pos.x = x;\n\tmyfighter_pos.y = y;\n}\n\nvec3 background()\n{\n\tfloat interval = 0.1;\n\tfloat thick = 0.005;\n\tvec3 color = vec3(0.0, 0.2, 0.4);\n\n\tif (mod(p.y + iTime * SCROLL_SPEED, interval) < thick || mod(p.x, interval) < thick) {\n\t\treturn color;\n\t}\n\treturn vec3(0);\n}\n\nvec2 get_boss_pos(float offset)\n{\n\tfloat x = sin(iTime - offset) * 0.2;\n\n\treturn vec2(x, 0.35);\n}\n\nvec3 bullet(vec2 v, float t)\n{\n\tvec2 pos = get_boss_pos(t) + v * t;\n\n\tif (length(p - pos) < 0.006) {\n\t\treturn vec3(1);\n\t}\n\tif (length(p - pos) < 0.01) {\n\t\treturn vec3(1, 0.4, 0.3);\n\t}\n\treturn vec3(0);\n}\n\nvec3 myfighter(vec2 pos)\n{\n\tfloat radius = 0.03;\n\n\tfloat dx = pos.x - p.x;\n\tfloat dy = pos.y - p.y;\n\n\tint px = int(floor(abs(dx) / 0.02));\n\tint py = int(floor(dy / 0.02));\n\n\tbool pixel = false;\n\n\tif (px == 0) {\n\t\tif (py >= -1 && py <= 1) {\n\t\t\tpixel = true;\n\t\t}\n\t}\n\tif (px == 1) {\n\t\tif (py >= 1 && py <= 2) {\n\t\t\tpixel = true;\n\t\t}\n\t}\n\n\tif (pixel) {\n\t\treturn vec3(1, 1, 1);\n\t}\n\treturn vec3(0);\n}\n\nfloat get_laser_hit_y()\n{\n\tif (abs(myfighter_pos.x - get_boss_pos(0.0).x) < 0.09) {\n\t\treturn 0.3;\n\t}\n\treturn 2.0;\n}\n\nvec3 laser(vec2 pos)\n{\n\tvec2 boss_pos = get_boss_pos(0.0);\n\n\tfloat a = 0.003 + blink * 0.004;\n\n\tfloat d;\n\n\tif (p.y > myfighter_pos.y && p.y < get_laser_hit_y()) {\n\t\td = abs(p.x - pos.x);\n\t} else {\n\t\td = length(p - pos);\n\t}\n\tfloat n = a / (d * 2.0);\n\n\treturn vec3(2, 8, 5) * n;\n}\n\nvec3 laser_hit_effect()\n{\n\tvec2 pos = vec2(myfighter_pos.x, get_laser_hit_y());\n\n\tfloat a = 0.02 + blink * 0.02;\n\n\tfloat d = length(p - pos);\n\tfloat n = a / (d * 5.0);\n\n\treturn vec3(2, 2, 5) * n;\n}\n\nvec3 boss()\n{\n\tvec2 pos = get_boss_pos(0.0);\n\n\tbool pixel = false;\n\n\tfloat dx = pos.x - p.x;\n\tfloat dy = pos.y - p.y;\n\n\tint px = int(floor(abs(dx) / 0.02));\n\tint py = int(floor(dy / 0.02));\n\n\tif (px >= -5 && px <= 5) {\n\t\tif (py >= -5 && py <= 3) {\n\t\t\tif (rand(vec2(px, py)) > 0.5) {\n\t\t\t\tpixel = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pixel) {\n\t\tif (abs(myfighter_pos.x - pos.x) < 0.08 && blink > 0.5) {\n\t\t\treturn vec3(1);\n\t\t}\n\t\treturn vec3(1, 0.5, 0);\n\t}\n\treturn vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tblink = mod(iTime, BLINK_INTERVAL) / BLINK_INTERVAL;\n\n\tp = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n\tif (abs(p.x) > SCREEN_W / 2.0) {\n\t\tdiscard;\n\t}\n\n\tset_myfighter_pos();\n\n\tvec3 c = background();\n\n\tc += boss();\n\n\tfor (int i = -4; i <= 2; i++) {\n\t\tfloat t = fract(iTime * 0.5 + float(i) * 0.03);\n\t\tvec2 v = normalize(vec2(float(i) * 0.1, -1.0));\n\t\tc += bullet(v, t);\n\t}\n\n\tfor (int i = -2; i <= 4; i++) {\n\t\tfloat t = fract(iTime * 0.5 + 0.5 + float(i) * -0.03);\n\t\tvec2 v = normalize(vec2(float(i) * 0.1, -1.0));\n\t\tc += bullet(v, t);\n\t}\n\n\tc += myfighter(myfighter_pos);\n\tc += laser(myfighter_pos);\n\tc += laser_hit_effect();\n\n\tfragColor = vec4(c, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlcyW7", "name": "Closed Quad Bezier", "author": "NGimbal", "description": "Fork / exploration of iq's quadratic bezier primitive, calculating the positions of some more points to make a closed continuous curve.", "tags": ["bezier", "quadratic"], "likes": 5, "viewed": 94, "date": "1609210455", "time_retrieved": "2024-06-20T20:26:13.183240", "image_code": "// exploration of https://www.shadertoy.com/view/MlKcDD\n// header from that shader intact below... \n\n// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\n//\n// List of some other 2D distances:\n//\n// Circle:               https://www.shadertoy.com/view/3ltSW2\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\n// Star5:                https://www.shadertoy.com/view/wlcGzB\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Arc:                  https://www.shadertoy.com/view/wl23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\n// Joint:                https://www.shadertoy.com/view/WldGWM\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cross2(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\n    //vec2 v3 = vec2(1.3,0.9)*cos(iTime*0.8 + vec2(1.0,0.5) );\n    vec2 v3 = v2 + (v2 - v1);\n    vec2 v4 = vec2(1.3,0.9)*cos(iTime*0.8 + vec2(0.5,2.) );\n    vec2 v5 = v4 + (v4 - v3);\n    // vec2 v6 = v2 * vec2(-1.);\n    vec2 v7 = v0 + (v0 - v1);\n    vec2 v6 = v7 + (v7 - v5) * -0.5;\n    \n    float d = udBezier( p, v0,v1,v2 );\n    float e = udBezier( p, v2,v3,v4 );\n    float f = udBezier( p, v4,v5,v6 );\n    float g = udBezier( p, v0,v7,v6 );\n    d = min(min(min(d,e),f),g);\n//    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n   \n\n        d = min(min(min(min(min(min(min( udSegment(p,v0,v1),\n                 udSegment(p,v1,v2)),\n                 udSegment(p,v2,v3)),\n                 udSegment(p,v3,v4)),\n                 udSegment(p,v4,v5)),\n                 udSegment(p,v5,v6)),\n                 udSegment(p,v0,v7)),\n                 udSegment(p,v7,v6));\n        d = min( d, length(p-v0)-0.02 );\n        d = min( d, length(p-v1)-0.02 );\n        d = min( d, length(p-v2)-0.02 );\n        d = min( d, length(p-v3)-0.02 );\n        d = min( d, length(p-v4)-0.02 );\n        d = min( d, length(p-v5)-0.02 );\n        d = min( d, length(p-v6)-0.02 );\n        d = min( d, length(p-v7)-0.02 );\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tldcRS", "name": "Fractal Graffiti 3", "author": "jarble", "description": "An edit of one of my [url=https://www.shadertoy.com/view/tltcRS]\"Fractal graffiti\"[/url] shaders.", "tags": ["fractal"], "likes": 1, "viewed": 91, "date": "1609391181", "time_retrieved": "2024-06-20T20:26:13.183240", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y/10.0;\n        uv += iTime/10.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.4;\n        for(int i=0;i<20;i++)\n        {\n            \n            uv=sin(uv-(uv.yx/(2.0+sin((uv.x+uv.y)*(2.0)))/2.0)/scale)*scale/2.0+scale1*scale;\n            uv /= scale1;\n        \t//uv += cos(uv/100.0);\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = fract((uv.x)/(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tldcRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tldcz8", "name": "galaxy1986", "author": "shortwavedave", "description": "//Adapted from Galaxy by Fabrice NEYRET:\n//https://www.shadertoy.com/view/Xsl3zX", "tags": ["galaxy"], "likes": 0, "viewed": 68, "date": "1608524611", "time_retrieved": "2024-06-20T20:26:13.880116", "image_code": "//Adapted from Galaxy by Fabrice NEYRET:\n//https://www.shadertoy.com/view/Xsl3zX\n\nconst float RETICULATION = 2.;  // strenght of dust texture\nconst float NB_ARMS = 3.;       // number of arms\n//const float ARM = 3.;         // contrast in/out arms\nconst float COMPR = .21;         // compression in arms\nconst float SPEED = .1;\nconst float GALAXY_R = 1./2.;\nconst float BULB_R = 1./4.;\nconst vec3 GALAXY_COL = vec3(.9,.9,1.); //(1.,.8,.5);\nconst vec3 BULB_COL   = vec3(1.,.8,.8);\n//const vec3 SKY_COL    = .5*vec3(.1,.3,.5);\nconst vec3 SKY_COL    = .5*vec3(0.,0.,0.);\n\t\t\n#define t iTime\n\n// --- base noise\nfloat tex(vec2 uv) \n{\n\tfloat n = texture(iChannel0,uv, 0.).r;\n\t\n#define MODE 3  // kind of noise texture\n#if MODE==0         // unsigned\n\t#define A 2.\n\treturn n;\n#elif MODE==1       // signed\n\t#define A 3.\n\treturn 2.*n-1.;\n#elif MODE==2       // bulbs\n\t#define A 3.\n\treturn abs(2.*n-1.);\n#elif MODE==3       // wires\n\t#define A 1.5\n\treturn 1.-abs(2.*n-1.);\n#endif\n}\n\n\n// --- perlin turbulent noise + rotation\nfloat noise(vec2 uv)\n{\n\tfloat v=0.;\n\tfloat a=-SPEED*t,\tco=cos(a),si=sin(a); \n\tmat2 M = mat2(co,-si,si,co);\n\tconst int L = 5;\n\tfloat s=1.;\n\tfor (int i=0; i<L; i++)\n\t{\n\t\tuv = M*uv;\n\t\tfloat b = tex(uv*s);\n\t\tv += 1./s* pow(b,RETICULATION); \n\t\ts *= 2.;\n\t}\n\t\n    return v/2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoomTime = pow(iTime,6.);\n    if (zoomTime >= 19.23) {\n        zoomTime = 19.23;\n    }\n    vec2 uv2 = ((fragCoord/iResolution.xy)-0.5)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 uv = mod((10.-.5*zoomTime)*fragCoord.xy/iResolution.y,1.);\n    //uv -= vec2(.35+.1*sin(iTime*.001*uv.x),.1+.1*cos(iTime*.001*uv.x));\n    uv -= vec2(.35,.2);\n\n    uv *= vec2(-.7 + exp(.03*iTime), -.6 + exp(.02*iTime));\n\tvec3 col;\n\t\n\t// spiral stretching with distance\n\tfloat rho = length(uv)*5.; // polar coords\n\tfloat ang = atan(uv.y,uv.x);\n\tfloat shear = 4.*log(rho); // logarythmic spiral\n\tfloat c = cos(shear), s=sin(shear);\n\tmat2 R = mat2(c,-s,s,c);\n\n\t// galaxy profile\n\tfloat r; // disk\n\tr = rho/GALAXY_R; float dens = exp(-r*r);\n\tr = rho/BULB_R;\t  float bulb = exp(-r*r);\n\tfloat phase = NB_ARMS*(ang-shear);\n\t// arms = spirals compression\n\tang = ang-COMPR*cos(phase)+SPEED*t;\n\tuv = rho*vec2(cos(ang),sin(ang));\n\t// stretched texture must be darken by d(new_ang)/d(ang)\n\tfloat spires = 1.+NB_ARMS*COMPR*sin(phase);\n\t// pires = mix(1.,sin(phase),ARM);\n\tdens *= spires + .5*spires*cos(iTime);\t\n\t\n\t// gaz texture\n\tfloat gaz = noise(.09*1.2*R*uv);\n\tfloat gaz_trsp = pow((1.-gaz*dens),2.);\n\n\t// stars\n\t//float a=SPEED*t, co=cos(a),si=sin(a); \n\t//mat2 M = mat2(co,-si,si,co);\n\t// adapt stars size to display resolution\n\tfloat ratio = .8*iResolution.y/iChannelResolution[0].y;\n\tfloat stars1 = texture(iChannel1,ratio*uv+.5, 0.).r, // M*uv\n\t      stars2 = texture(iChannel0,ratio*uv+.5, 0.).r,\n\t\t  stars = pow(1.-(1.-stars1)*(1.-stars2),5.);\n\t\n\tstars = pow(stars,1.+.5*pow(cos(iTime),2.));\n\t\n\t// mix all\t\n\tcol = mix(SKY_COL,\n\t\t\t  gaz_trsp*(1.7*GALAXY_COL) + 1.2*stars, \n\t\t\t  dens);\n\tcol = mix(col, 1.2*BULB_COL, bulb);\n\t\t\n    vec3 viewDir = normalize(vec3(uv2+vec2(0.0,-.4),.5));\n    \n    vec2 planarUV = viewDir.xz/abs(viewDir.y);\n    \n    float depth = planarUV.y;\n    \n    planarUV += vec2(iTime*0., iTime*.5);\n    \n    vec3 albedo = vec3(0.,0.,.2*texture( iChannel2, planarUV*.1 ).r);\n    \n    float light = (.5+0.1*iTime)/(depth*depth)*viewDir.z;\n    \n    //fragColor = vec4(light*albedo,1.);\n    //fragColor = vec4(albedo,1.0);\n    \n\tfragColor = vec4(col+light*albedo,1.);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tldcz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tldyDn", "name": "Vibing sinusoïdes", "author": "Tarquin", "description": "Glowing sinusoïdes moving with style", "tags": ["glow", "sinusode"], "likes": 9, "viewed": 134, "date": "1608835191", "time_retrieved": "2024-06-20T20:26:14.219694", "image_code": "// Created by Arthur Jacquin - 2020\n// https://www.linkedin.com/in/arthur-jacquin-631921153/\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define CT() abs(sin(iTime))\n\nvec3 GlowingLine(vec2 fragCoord, vec3 color, float hoffset, float voffset, float hscale, float vscale, float timescale)\n{\n    float glowRadius = 0.04 * iResolution.y * (fragCoord.x / iResolution.x + 1.0) ;\n    float glowIntensity = 1.0 * fragCoord.x / iResolution.x;\n    float twopi = 2.0 * PI;\n    float thickness = 1.5;\n    float curve = thickness - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + voffset));\n    float i = clamp(curve, 0.0, 1.0);\n\n    i += clamp((glowRadius + curve) / glowRadius, 0.0, 1.0) * glowIntensity;\n    return i * color;\n}\n\nvec3 rainbowGradient(float t) {\n\tvec3 c = 1.0 - pow(abs(vec3(t) - vec3(0.65, 0.5, 0.2)) * vec3(3.0, 3.0, 5.0), vec3(1.5, 1.3, 1.7));\n\tc.r = max(0.15 - (abs(t - 0.04) * 5.0) * (abs(t - 0.04) * 5.0), c.r);\n\tc.g = (t < 0.5) ? smoothstep(0.04, 0.45, t) : c.g;\n\treturn clamp(c, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = vec2(fragCoord.xy / iResolution.xy);\n\n    vec3 color = vec3(0.0039, 0.0039, 0.1922);\n\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.15  * CT()), 0.0 + 2.4, iResolution.y / 2.0, abs(st.x - 1.0), abs(sin(iTime)) * st.x, 5.0);\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.1  * CT()), PI + 2.4, iResolution.y / 2.0, abs(st.x - 1.0), abs(sin(iTime + PI)) * st.x, 5.0);\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.3  * CT()), PI + 2.4, iResolution.y / 2.0, abs(st.x - 1.0), sin(iTime + PI * 0.5) * st.x, 5.0);\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.25 * CT()), PI + 2.4, iResolution.y / 2.0, abs(st.x - 1.0), sin(iTime - PI * 0.5) * st.x, 5.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tldyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tldyzN", "name": "rainbowglitch [⚠️epil?]", "author": "HaleyHalcyon", "description": "epileptica", "tags": ["epilepsy"], "likes": 2, "viewed": 139, "date": "1608620919", "time_retrieved": "2024-06-20T20:26:14.219694", "image_code": "const float TAU = 3.14159265358979*2.;\nconst float TAW = TAU * 2. / 3.;\n\nuint roll(uvec2 xy, uint t) {\n    const uint a = 1664525u;\n    const uint m = 1013904223u;\n\n    uint seed = 65538u * xy.x + 782651u * xy.y + 1979u * t;\n    \n    uint x0 = (seed * a) % m;\n    uint x = (x0 * a) % m;\n    \n    return x & 65535u;\n}\n\nvec3 huey(float t) {\n    return smoothstep(0.0, 1.0, vec3(sin(t * TAU), sin(t * TAU + TAW), sin(t * TAU - TAW)) + 1. / 2.);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Time = fract(iTime / 4.);\n    uint time = uint(iTime * 20.);\n   \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n    uv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    float linDis = distance(uv, vec2(0));\n    float lolDis = 14. * log(linDis) - 6. * linDis;\n    \n    vec2 rt = vec2(\n        256. + lolDis +\n        0.5 * sin(0.4 * lolDis + Time * 2. * TAU)\n    ,\n        256. + mod(atan(uv.x, uv.y) / TAU * 64. +\n        0.3 * sin((0.2 * lolDis + 2.0 * Time) * TAU), 32.)\n    );\n    \n    float x = smoothstep(0.4,0.6,float(roll(uvec2(rt), time)) / 65536.);\n    \n    // Output to screen\n    fragColor = vec4(\n      (x)      * huey(4.0 * Time + 0.4 * linDis) +\n      (1. - x) * huey(4.0 * Time + 0.6 * linDis)\n    , 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tldyzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tltcWn", "name": "Magic scepter", "author": "Tarquin", "description": "Magic scepter made of glowing sinusoïdes.", "tags": ["sin", "glow", "magic", "scepter"], "likes": 3, "viewed": 53, "date": "1608830040", "time_retrieved": "2024-06-20T20:26:14.589263", "image_code": "// Created by Arthur Jacquin - 2020\n// https://www.linkedin.com/in/arthur-jacquin-631921153/\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n\nfloat HLine(vec2 uv, float ypos, float s)\n{\n    float res = 1.0;\n    res *= smoothstep(ypos - s, ypos - s + 0.01, uv.y);\n    res *= smoothstep(ypos + s + 0.01, ypos + s, uv.y);\n\n    return res;\n}\n\nvec3 GlowingLine(vec2 fragCoord, vec3 color, float hoffset, float voffset, float hscale, float vscale, float timescale)\n{\n    float glowRadius = 0.03 * iResolution.x * (fragCoord.y / iResolution.y + 1.0) ;\n    float glowIntensity = 1.0 * fragCoord.y / iResolution.y;\n    float twopi = 2.0 * PI;\n    float thickness = 1.5;\n    float curve = thickness - abs(fragCoord.x - (sin(mod(fragCoord.y * hscale / 100.0 / iResolution.y * 1000.0  + hoffset, twopi)) * iResolution.x * 0.5 * vscale + voffset));\n    float i = clamp(curve, 0.0, 1.0);\n\n    i += clamp((glowRadius + curve) / glowRadius, 0.0, 1.0) * glowIntensity;\n    return i * color;\n}\n\nvec3 rainbowGradient(float t) {\n\tvec3 c = 1.0 - pow(abs(vec3(t) - vec3(0.65, 0.5, 0.2)) * vec3(3.0, 3.0, 5.0), vec3(1.5, 1.3, 1.7));\n\tc.r = max(0.15 - (abs(t - 0.04) * 5.0) * (abs(t - 0.04) * 5.0), c.r);\n\tc.g = (t < 0.5) ? smoothstep(0.04, 0.45, t) : c.g;\n\treturn clamp(c, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y; \n\n    vec3 color = vec3(0.0039, 0.0039, 0.1922);\n\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.22), 0.0 + 2.6, iResolution.x / 2.0, 1.0, 0.5 * abs(sin(iTime)) * uv.y, 5.0);\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.22), PI + 2.6, iResolution.x / 2.0, 1.0, 0.5 * abs(sin(iTime + PI)) * uv.y, 5.0);\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.22), PI + 2.66, iResolution.x / 2.0, 1.0, 0.5 * sin(iTime + PI * 0.5) * uv.y, 5.0);\n    color += GlowingLine(fragCoord.xy, rainbowGradient(0.22), PI + 2.6, iResolution.x / 2.0, 1.0, 0.5 * sin(iTime - PI * 0.5) * uv.y, 5.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tltcWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tltyRM", "name": "Rain drops on ground improved", "author": "tyron", "description": "Copied from https://www.shadertoy.com/view/wt2yW3\n\nRemoved some unnecessary calculations, added intensity parameter", "tags": ["rain", "drops"], "likes": 1, "viewed": 138, "date": "1608717360", "time_retrieved": "2024-06-20T20:26:14.589263", "image_code": "\n// Forked from https://www.shadertoy.com/view/wt2yW3\n\nvec2 hash3( vec2 p )\n{\n    vec2 q = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n    return fract(sin(q)*43758.5453);\n}\n\nfloat noise(in vec2 x)\n{\n    float intensity = 0.4;\n\n    x *= intensity;\n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\n    float va = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash3(p + g);\n        vec2 r = ((g - f) + o.xy) / intensity;\n        float d = sqrt(dot(r,r));\n\n        float a = max(cos(d - iTime * 2. + (o.x + o.y) * 5.0), 0.);\n        a = smoothstep(0.99, 0.999, a);\n\n        float ripple = mix(a, 0., d);\n        va += max(ripple, 0.);\n    }\n\n    return va;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // for concentric circles\n    // uv.y/=2.;\n\n\tfloat f = noise( 12.0*uv);\n\tfragColor = vec4( f,f,f, 1.0 );\n    \n    // Or as normal\n    //vec3 normal = vec3(-dFdx(f), -dFdy(f), 0.5) + 0.5;\n\t//fragColor = vec4( normal, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tltyRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscBW2", "name": "gradients23", "author": "edwardbraed", "description": "just a trigonometric gradients set :3", "tags": ["gradients"], "likes": 2, "viewed": 94, "date": "1607379980", "time_retrieved": "2024-06-20T20:26:14.595373", "image_code": "#define gray(rgb) (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\n#define cmpv(v, b) (v.x > b.x && v.y > b.y && v.x < (b.x + 1.0) && v.y < (b.y + 1.0))\n#define m_p 3.14155\n#define norm(a) (a + 1.0) * 0.5\n//#define norm(a) abs(a)\n//#define COLORED_OFF\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\n//------------------------------------------------------------\nfloat waves(vec2 p, vec2 s, float t)\n{\n    p *= s * m_p;\n    return norm(sin(sin(p.x - t) - p.y));\n}\n\n//------------------------------------------------------------\nfloat radial(vec2 p, float s, float t)\n{\n\treturn norm(sin(length(p) / s - t));\n}\n\n//------------------------------------------------------------\nfloat spiral(vec2 p, float s, float t)\n{\n    float e = exp(length(p)); /*can also try pow(l,l) or sqrt(l)*/\n    return norm(sin((exp(length(p)) - s * atan(p.y, p.x) - t) / s));\n}\n\n//------------------------------------------------------------\nfloat windmill(vec2 p, float c, float w, float t)\n{\n    float sl = sin(length(p)) * w;\n    return norm(sin((atan(p.x, p.y) / (1.0 / c) - sl) + t));\n}\n\n//------------------------------------------------------------\nfloat angles(vec2 p, float s, float t)\n{\n    return norm(sin(p.x * p.y / s - t));\n}\n\n//------------------------------------------------------------\nfloat radial_waves(vec2 p, float s, vec2 w, float t)\n{\n    float a = atan(p.x, p.y) / (1.0 / w.x);\n    return norm(sin(length(p) / s / norm(sin(a) + w.y) - t));\n}\n\n//------------------------------------------------------------\nfloat windmill_waves(vec2 p, float c, float w, float t)\n{\n    float sl = sin(length(p) * w - t);\n    return norm(sin((atan(p.x, p.y) / (1.0 / c) - sl) + t));\n}\n\n//------------------------------------------------------------\nfloat spiral_waves(vec2 p, float s, float w, float t)\n{\n    float l = exp(sin(length(p)));\n    float a = atan(p.y, p.x);\n    \n    return norm(sin((l - s * (a - sin(a * w - t) + t)) / s));\n}\n\n//------------------------------------------------------------\nfloat double_waves(vec2 p, vec2 s, float w, float t)\n{\n    p *= s * m_p;\n    p += norm(sin(p.y * w - t));\n    return norm(sin(sin(p.x - t)  - p.y));\n}\n//------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = calcAspect(iResolution.xy);\n    vec2 auv = uv * aspect;\n    const vec2 cells = vec2(3, 3);\n    vec2 cell = cells * uv;\n    vec2 cc = (floor(cell) + 0.5) / cells * aspect;\n    vec2 v = cc - auv;\n    \n    float g = 0.0;\n    \n    if(cmpv(cell, vec2(0.0, 0.0)))\n    {\n        g = waves(auv, vec2(16.0, 32.0), iTime);\n    }\n    else if(cmpv(cell, vec2(1.0, 0.0)))\n    {\n        g = radial(v, 0.008, iTime);\n    }\n    else if(cmpv(cell, vec2(2.0, 0.0)))\n    {\n        g = windmill(v, 8.0, 40.0, iTime);\n    }\n    else if(cmpv(cell, vec2(0.0, 1.0)))\n    {\n        g = spiral(v, 0.008, iTime * 0.02);\n    }\n    else if(cmpv(cell, vec2(1.0, 1.0))) \n    {\n        g = angles(v, 0.0008, iTime);\n    }\n    else if(cmpv(cell, vec2(2.0, 1.0)))\n    {   \n        g = radial_waves(v, 0.0005, vec2(8.0, 10.0), iTime);\n    }\n    else if(cmpv(cell, vec2(0.0, 2.0)))\n    {\n        g = double_waves(auv, vec2(16.0, 32.0), 1.2, iTime);\n    }\n    else if(cmpv(cell, vec2(1.0, 2.0)))\n    {\n        g = spiral_waves(v, 0.008, 8.0, iTime);\n    }\n    else if(cmpv(cell, vec2(2.0, 2.0)))\n    {\n        g = windmill_waves(v, 8.0, 120.0, iTime);\n    }\n\n    vec2 fc = floor(cell);\n    \n    vec3 col = norm(vec3(sin(iTime + fc.x), sin(iTime + 1.0 + fc.y), sin(iTime + 2.0 + fc.y))) * 2.0;\n    #ifdef COLORED_OFF\n    \tcol = vec3(1.0);\n    #endif\n    // Output to screen\n    fragColor = vec4(col * g, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscBW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsGfzK", "name": "LightHouse3", "author": "sreejithpro", "description": "sss", "tags": ["ss"], "likes": 5, "viewed": 280, "date": "1607506865", "time_retrieved": "2024-06-20T20:26:14.595373", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 TaperBox(vec2 p, float wb, float wt, float yb, float yt, vec4 col, float blur){\n\tfloat m = S(-blur,blur,p.y-yb);\n    m *= S(blur,-blur,p.y-yt);\n    \n    p.x = abs(p.x);\n    \n    //0 p=yb; 1 p=yt\n    float w = mix(wb,wt,(p.y-yb)/(yt-yb));\n    \n    m *= S(blur, -blur, p.x-w);\n    return m*vec4(col);\n    \n}   \n\nvec4 TaperBoxI(vec2 p, float hl, float hr, float xl, float xr, vec4 col, float blur){\n\tfloat m = S(-blur,blur,p.x-xl);\n    m *= S(blur,-blur,p.x-xr);\n    \n    p.y = abs(p.y);\n    \n    float w = mix(hl,hr,(p.x-xl)/(xr-xl));\n    \n    m *= S(blur, -blur, p.y-w);\n    return m*vec4(col);\n}\n\nvec4 LightHouse(vec2 uv, float x, float y, float blur){\n\t\n    //Color Definition\n    vec4 col1 = vec4(74.,2.,2.,255.)/255.;\n    vec4 col2 = vec4(204.,204.,204.,255.)/255.;\n    vec2 offs = vec2(x,y);\n    uv *= 2.;\n    vec4 m= TaperBox(uv-offs,0.2,.18,0.,.25,col1, blur);//Brick 1\n    m += TaperBox(uv-offs,.18,.16,0.25,.5,col2,blur);//Brick 2\n    m += TaperBox(uv-offs,.16,.14,0.5,.75,col1,blur);//Brick 3\n    m += TaperBox(uv-offs,.035,.035,0.55,.68,vec4(1.),blur+.015);//Brick 3 Window\n    m += TaperBox(uv-offs,.14,.12,0.75,1.,col2,blur);//Brick 4\n    m += TaperBox(uv-offs,.12,.10,1.,1.25,col1,blur);//Brick 5\n    m += TaperBox(uv-offs,.035,.035,1.05,1.18,vec4(1.),blur+.015);//Brick 5 Window\n    m += TaperBox(uv-offs,.10,.09,1.25,1.35,col2,blur);//Bricke 6\n    m += TaperBox(uv-offs,.09,.11,1.35,1.40,col1,blur);//Brick7 inverted\n    m += TaperBox(uv-offs,.2,.2,1.40,1.50,col2,blur);//Top Deck 1\n    m += TaperBox(uv-offs,.2,.2,1.50,1.60,col1,blur);//Top Deck 2\n    m += TaperBox(uv-offs,.03,.03,1.60,1.70,col2,blur);//Light Holder\n    m += TaperBox(uv-offs-vec2(-.1,0.),.01,.01,1.60,1.81,col1,blur);//Column Left\n    m += TaperBox(uv-offs-vec2(.1,0.),.01,.01,1.60,1.81,col1,blur);//Column Right\n    m += TaperBox(uv-offs,.01,.01,1.60,1.81,col1,blur);//Column Middle\n    m += TaperBox(uv-offs,.16,.0,1.81,2.,col2,blur);//Roof\n    \n    //Light\n    vec4 light = TaperBoxI(uv-offs-vec2(0.,1.65),0.02,0.4,0.,6.,vec4(0.96,.84,.109,1.),blur);\n    \n    light *= uv.x*0.2+0.5*sin(-iTime*0.5);\n    \n    \n    \n    m += light;\n    \n    \n    \n    \n    return m;\n}\n\nvec4 Sun(vec2 uv, float rad, float x, float y, vec4 col, float blur){\n    uv *= 5.;\n    uv.x -= x;\n    uv.y -= y;\n\tfloat d = length(uv);\n    //float s = .3/d;\n    \n    float m = S(rad, rad-blur-.05,d);\n    \n    return m*col;\n}\n\nfloat GetHeight(vec2 uv){\n    uv *= 0.2;\n    float height = .562*sin(uv.x*.551)+.325*sin(uv.x*8.356)+sin(uv.x*.2350)+sin(uv.x*.356)*.175;\n    return -height - .425*sin(uv.x)*.565;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ((2.*fragCoord-iResolution.xy)/iResolution.y);\n\n    \n    //BG Gradient\n    float wPercent = fragCoord.y / iResolution.y;\n    vec4 color1 = vec4(208.,162.,21.,255.)/255.;\n    vec4 color2 = vec4(192.,101.,11.,255.)/255.;\n    float r = color1.x + wPercent * (color2.x - color1.x);\n    float g = color1.y + wPercent * (color2.y - color1.y);\n    float b = color1.z + wPercent * (color2.z - color1.z);\n    vec4 col = vec4(r,g,b,1.);\n    \n    float blur = 0.01;\n    vec4 lighthouse = LightHouse(uv, -0.5,-0.3, blur);\n    \n    col = mix(col,lighthouse,lighthouse.a);\n    vec4 suncol = vec4(226.,194.,61.,255.)/255.;\n    vec4 sun = Sun(uv, 0.8, 4., 1.9,suncol, .1)*1.2;\n    //sun += Sun(uv,0.8, 4., 1.9,suncol, .1);\n    col = mix(col,sun,sun.a);\n    \n    uv *= 2.;\n    vec4 bg = TaperBox(uv,12.,12.,-0.96,-.2+GetHeight(uv*sin(uv.x*.256)),vec4(0.01,0.01,0.,1.),blur+.02);\n    bg += TaperBox(uv*-1.,12.,12.,1.0,1.6+GetHeight(uv*sin(uv.x*.256)),vec4(0.01,0.01,0.,1.),blur+0.1);\n    bg += TaperBox(uv,12.,12.,-2.,-1.,vec4(208.,162.,21.,50.)/255.,.2)*0.2;\n    col =  mix(col,bg,bg.a);\n    uv /= 2.;\n    vec4 LHref = LightHouse(uv*vec2(1,-1.), -0.5,1.5, blur+.1);\n    \n    col = mix(col,LHref,LHref.a);\n    float T = sin(iTime*0.01);\n    vec4 boat = TaperBox(uv-vec2(-1.+T,0.2),.25,.3,-1.,-.93,vec4(0.01,0.01,0.01,1.),blur);\n    boat += TaperBox(uv-vec2(-1.+T,0.137),.3,.25,-1.,-.93,vec4(0.01,0.01,0.01,1.),blur*4.5);\n    \n    col = mix(col,boat,boat.a);\n    \n    float d = length(uv+vec2(0.95-T,0.65));\n    vec4 man = S(0.04,0.005,d)*suncol*vec4(0.,0.,0.,1.);\n\tman += TaperBox(uv-vec2(-0.95+T,0.2),.02,.01,-.93,-.87,vec4(0.01,0.01,0.01,1.),blur+.025)*2.;\n    man += TaperBoxI(uv-vec2(-.95+T,-0.7),0.005,.005,0.,0.35,vec4(0.01,0.01,0.01,1.),blur);\n  \tman += TaperBoxI(uv-vec2(-.95+T,-0.78),0.005,.005,0.,0.35,vec4(0.01,0.01,0.01,1.),blur+.05);\n\tman += TaperBox(uv-vec2(-.6+T,-0.8),0.005,.005,0.,0.1,vec4(0.01,0.01,0.01,1.),blur);\n    col = mix(col,man,man.a);\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsGfzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsGfzm", "name": "Metal frame", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 22, "viewed": 224, "date": "1606811673", "time_retrieved": "2024-06-20T20:26:14.595373", "image_code": "void lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\nvoid sFold90(inout vec2 p)\n{\n    float e=2e-2;\n    vec2 v=normalize(vec2(1,-1));\n    float g=dot(p,v);\n    p-=(g-sqrt(g*g+e))*v;\n}\n\nfloat frame(vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.3),1),iTime*.3);\n\tp=abs(p)-1.;\n#if 1\n\tsFold90(p.xz);\n\tsFold90(p.yz);\n\tsFold90(p.xy);\n#else\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    if(p.x<p.y)p.xy=p.yx;\n#endif\n\tp.x=abs(p.x)-.2;\n\tp.y=abs(p.y)-.2;\n\tp.y=abs(p.y)-.1;\n\tp.y=abs(p.y)-.1;\n \treturn length(vec2(length(p.xz)-1.,p.y))-.05;\n}\n\nfloat map(vec3 p)\n{\n    return min(p.y+6.,frame(p));\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow(vec3 light, vec3 ld, float len)\n{\n\tfloat depth=march(light,ld,0.,len);\t\n\treturn step(len-depth,.01);\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.3,.5,.8)+cos(p*.2)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,7);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(0,3,0);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        float sha=calcShadow(lightPos,-li,len);\n        col*=max(sha*dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n        col-=dot(.0005*p,p);\n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsGfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsGyDV", "name": "Perlin Noise (2D)", "author": "thwart", "description": "Perlin Noise", "tags": ["noise"], "likes": 1, "viewed": 49, "date": "1608765769", "time_retrieved": "2024-06-20T20:26:15.080141", "image_code": "// Hash lookup table as defined by Ken Perlin.  This is a randomly\n// arranged array of all numbers from 0-255 inclusive.\nint[] permutation = int[](\n151,160,137,91,90,15,                 \n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    \n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n);\n\n// Fade function\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n\nfloat getCornerValue(vec2 gridXY, vec2 squareXY)\n{\n    int value = permutation[permutation[int(gridXY.x) & 255] + int(gridXY.y) & 255];\n    vec2 gradVector;\n    switch(value & 0x3){\n     \tcase 0:\n        \tgradVector = vec2(1., 1.);\n        break;\n        case 1:\n        \tgradVector =  vec2(-1., 1.);\n        break;\n     \tcase 2:\n        \tgradVector =  vec2(1., -1.);\n        break;\n     \tcase 3:\n        \tgradVector =  vec2(-1., -1.);\n        break;\n     \tdefault:\n        break;\n        \n    }\n    \n    return dot(gradVector, squareXY);\n}\n\nfloat noise2d(vec2 fragCoord, vec2 squareSize)\n{\n    \n    \n    \n    vec2 gridXY = floor(fragCoord / squareSize);\n    vec2 squareXY = fract(fragCoord / squareSize);\n\n    vec2 posBottomLeft = gridXY;\n    vec2 posTopLeft = gridXY + vec2(0., 1.);\n    vec2 posTopRight = gridXY + vec2(1., 1.);\n    vec2 posBottomRight = gridXY + vec2(1., 0.);\n\n    vec2 squareBottomLeft = squareXY;\n    vec2 squareTopLeft = vec2(squareXY.x, squareXY.y - 1.);\n    vec2 squareTopRight = vec2(squareXY.x - 1., squareXY.y - 1.);\n    vec2 squareBottomRight = vec2(squareXY.x - 1., squareXY.y);\n    \n    float bottomLeft = getCornerValue(posBottomLeft, squareBottomLeft);\n    float topLeft = getCornerValue(posTopLeft, squareTopLeft);\n    float topRight = getCornerValue(posTopRight, squareTopRight);\n    float bottomRight = getCornerValue(posBottomRight, squareBottomRight);\n    \n    vec2 uv = fade(squareXY);\n\n\t\n\treturn mix(\n\t\tmix(bottomLeft, bottomRight, uv.x),\n\t\tmix(topLeft, topRight, uv.x),\n        uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 squareSize = vec2(32., 32.);\n    \n    // Move (0,0) to center of screen\n    fragCoord -= vec2(iResolution.x, iResolution.y) / 2.;\n\t\n    // Output to screen\n    float noise = (noise2d(fragCoord - (iTime * 64.), squareSize) + 1.) / 2.;\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKBDz", "name": "+35 Low Poly Gonzo Ride, a fork", "author": "UrbanClubProfessional", "description": "Remix of supervitas' Low Poly Summer Ride: [url]https://www.shadertoy.com/view/wtlGRN[/url] ", "tags": ["remix", "tree", "glitch", "fork", "weird", "polygon", "error", "lowpoly"], "likes": 0, "viewed": 193, "date": "1606947873", "time_retrieved": "2024-06-20T20:26:16.595489", "image_code": "// Hacked by Urban Club Professional!\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define AA 2\n#define MAX_MARCHING_STEPS 355\n#define MAX_DIST  350. // far\n#define EPSILON 0.02\n#define PI 4.1415926535\n\n#define TRUNK vec3(0.275,0.060,0.006)\n#define CAR_TIRES vec3(0.070,0.070,0.070)\n#define ROAD vec3(0.250,0.250,0.250)\n#define CAR_WINDOW vec3(0.605,0.640,0.610)\n#define ROAD_WIDTH 22.752\n#define TREES_ROAD_OFFSET_RIGHT ROAD_WIDTH + 3.\n#define SPEED 36.\n\n\nuniform float u_time;\n\n#define u_time iTime\n#define u_resolution iResolution\n\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(2, 1, 1),\n        vec3(1, c, -s),\n        vec3(1, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 1, s),\n        vec3(1, 2, 1),\n        vec3(-s, 1, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 1),\n        vec3(s, c, 1),\n        vec3(1, 1, 2)\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.1)) + min(max(d.x,max(d.y,d.z)),0.1);\n}\n\nfloat piramidSDF(vec3 p, vec3 size) {\n    vec3 ap = abs(p);\n    vec3 d = ap - size;\n    return max(dot(normalize(size), d), -p.y);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.1) + length(max(d,0.1));\n}\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.67735027;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    const vec3 k = vec3(-0.9660254, 0.6, 0.67735);\n    p = abs(p);\n    p.xy -= 3.0*min(dot(k.xy, p.xy), 1.)*k.xy;\n    vec2 d = vec2(length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n\n    return min(max(d.x,d.y), 0.1) + length(max(d, 0.1));\n}\n\nfloat sdPlane( vec3 p ) {return p.y;}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec4 unionSDF(vec4 d1, vec4 d2) {\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec4 tree1(vec3 p, float randValue,  mat3 rotationLeaf) {\n  \tvec4 trunc = vec4(sdCappedCylinder((( p + vec3(1., -.6, 1)) ) , vec2(0.25, 3.) * randValue) , TRUNK);\n  \tvec4 leaf = vec4(sdOctahedron(((rotationLeaf * p + vec3(1., -5.5 * randValue, 1.)) ) , 4.120  * randValue ), vec3(0.229,0.520,0.307));           \n  \treturn unionSDF(trunc, leaf);\n}\n\nvec4 tree2(vec3 p, float randValue,  mat3 rotationLeaf) {\n \tvec4 trunc = vec4(sdCappedCylinder(((p + vec3(1., -.6, 1)) ) , vec2(0.6,3.990) * randValue), TRUNK);\n\tvec4 leaf = vec4(piramidSDF(rotationLeaf * p + vec3(1, -4.5 * randValue, 1.), vec3(2.6, 2.2, 2.5) * randValue), vec3(0.297,0.370,0.316));\n  \treturn unionSDF(trunc, leaf);\n}\n\nvec4 tree3(vec3 p, float randValue, mat3 rotationLeaf) {\n \tfloat scale = 2.1 * randValue;\n  \tvec4 trunc = vec4(sdCappedCylinder((((p + vec3(1., -2.5, 1)) ) ) , vec2(0.3,3.0) * scale), TRUNK);\n\tvec4 leaf = vec4(sdHexPrism(((rotationLeaf * p + vec3(1, -4.8 * scale, 0.6))), vec2(2.8, 2.5) * scale ), vec3(0.457,0.465,0.097));\n\treturn unionSDF(trunc, leaf);\n}\n\nvec4 tree4(vec3 p, float randValue, mat3 rotationLeaf) {\n    float scale = 2.3 * randValue;\n\tvec4 trunc = vec4(sdCappedCylinder((( p + vec3(1., -2.5, 1))), vec2(0.5,3.0) * scale), TRUNK);\n\tvec4 leaf = vec4(sdBox(((rotationLeaf  *  p + vec3(1., -5. *scale, 1.)) ) , vec3(2.5) * scale), vec3(0.790,0.502,0.347));\n\treturn unionSDF(trunc, leaf);\n}\n\nvec3 pModXZ(vec3 p, const in vec3 size) {\n  p.x = mod(p.x + size.x * 0.6, size.x) - size.x * 0.6;\n  p.z = mod(p.z + size.z * 0.6, size.z) - size.z * 0.6;\n  return p;\n}\n\nvec4 createTrees(vec3 samplePoint) {\n    vec3 domainRepition = pModXZ(vec3(samplePoint.x , samplePoint.y - 3.5, samplePoint.z + u_time * SPEED), vec3(9.5, 1., 35. ));   \n\n    vec3 tree1Repeat = domainRepition;\n    vec3 tree2Repeat = vec3(tree1Repeat.x - .2 , tree1Repeat.y, tree1Repeat.z + 8.5 );;\n    vec3 tree3Repeat = vec3(tree1Repeat.x - 2.7, tree1Repeat.y, tree1Repeat.z - 21.7);\n    vec3 tree4Repeat = vec3(tree1Repeat.x + 2.3, tree1Repeat.y, tree1Repeat.z - 7.5);\n    \n    float scaleDistance = min(2., (2.2 + -samplePoint.z * 0.03));\n    mat3 rotationLeaf = rotateY(PI * scaleDistance);\n    \n    vec4 tree1 = tree1(tree1Repeat, scaleDistance, rotationLeaf);\n    vec4 tree2 = tree2(tree2Repeat, scaleDistance, rotationLeaf);\n    vec4 tree3 = tree3(tree3Repeat, scaleDistance, rotationLeaf);\n    vec4 tree4 = tree4(tree4Repeat, scaleDistance, rotationLeaf);\n\n    return unionSDF(unionSDF(tree1, tree2), unionSDF(tree3, tree4));\n}\n\nvec4 createCar(vec3 p) {\n    float jumping = mix(1., .4, sin(u_time * 6.));\n    \n   \tvec4 car = vec4(sdBox(p + vec3(1., -3. - jumping, 1), vec3(3., 3., 4.9)), vec3(0.270,0.374,0.425));\n\tfloat subFront = sdBox(  p + vec3(1., -4. - jumping, -4.5), vec3(3.5, 2.3, 2.2));\n    float subBack = sdBox(  p + vec3(1., -4. - jumping, 4.5), vec3(3.5, 2.3, 2.2));\n    \n    car.x = opSubtraction(subFront, car.x);\n    car.x = opSubtraction(subBack, car.x);\n    \n    vec4 windowBack =  vec4(sdBox(p + vec3(1., -4. - jumping, 3.15), vec3(2.3, .53, 0.02)) - 0.31, CAR_WINDOW);\n    vec4 windowLeft =  vec4(sdBox(rotateY(-2.548) * p + vec3(1., -4. - jumping, 2.8), vec3(2.3, .53, 0.02)) - 0.4, CAR_WINDOW);\n    car = unionSDF(car, unionSDF(windowLeft, windowBack));\n\n    vec3 t = rotateZ(2.564) * p;\n   \n    vec3 wheelBackPosition = t + vec3(-0.3 - jumping * .6, .5 , 3.1);\n    vec3 wheelFrontPosition = t + vec3(-0.3 - jumping * .6, .5, -3.1);\n    \n    vec4 wheel = vec4(sdCappedCylinder(wheelBackPosition, vec2(2., 3.1)), CAR_TIRES);\n    vec4 wheel2 = vec4(sdCappedCylinder(wheelFrontPosition, vec2(2., 3.2)), CAR_TIRES);\n    \n    vec4 wheelWhite = vec4(sdCappedCylinder(wheelBackPosition, vec2(.5, 3.1)), vec3(1.));\n    vec4 wheelWhite2 = vec4(sdCappedCylinder(wheelFrontPosition, vec2(.5, 3.2)), vec3(1.));\n\n    return unionSDF(unionSDF(car, unionSDF(wheelWhite, unionSDF(wheel, wheel2))), unionSDF(car, unionSDF(wheelWhite, wheelWhite2)));\n}\n\nvec4 createFence(vec3 p) {\n    const vec3 pillarColor = vec3(0.335,0.288,0.302);\n        \n    vec4 pillar = vec4(sdBox(p + vec3(TREES_ROAD_OFFSET_RIGHT - 3., -.6, 1), vec3(.25, 3., 200.)), pillarColor);\n\tvec4 fence = vec4(sdBox(p + vec3(TREES_ROAD_OFFSET_RIGHT - 3., -3.5, 1), vec3(.35, 0.22, 200.)), pillarColor);\n    \n    vec4 pillarLeft = vec4(sdBox(p + vec3(-TREES_ROAD_OFFSET_RIGHT - 3., -.6, 1), vec3(.25, 3., 200.)), pillarColor);\n\tvec4 fenceLeft = vec4(sdBox(p + vec3(-TREES_ROAD_OFFSET_RIGHT - 3., -3.5, 1), vec3(.35, 0.22, 200.)), pillarColor);\n\n    float needsCut = step(mod(p.z + SPEED * u_time, SPEED), 0.6);\n    \n    pillar.x = mix(0.6, pillar.x, needsCut);\n    pillarLeft.x = mix(.6, pillarLeft.x, needsCut);\n    \n    return unionSDF(unionSDF(pillar, fence), unionSDF(pillarLeft, fenceLeft));\n}\n\nvec4 map(vec3 samplePoint) {    \n    float sizeOfLine = step(1., samplePoint.x) * step(samplePoint.x, 0.8)  // getting white line\n    * step( mod(samplePoint.z + SPEED * u_time , 26.), 7.6); // getting offset\n    \n    vec4 plane = vec4(sdPlane(samplePoint), mix(ROAD, vec3(2.0), sizeOfLine));\n    float insideRoad = step(-ROAD_WIDTH, samplePoint.x) * step(samplePoint.x, ROAD_WIDTH) ;\n    vec4 trees = vec4(2.);\n    \n    if (insideRoad == 0.) {\n        trees = createTrees(samplePoint);\n        plane.yzw = vec3(0.277,0.315,0.240);\n    }\n\n    vec4 car = createCar(samplePoint + vec3(7., -2.5, -3.5));\n    vec4 fence = createFence(samplePoint);\n        \n    return unionSDF(unionSDF(fence, trees), unionSDF(car, plane));\n}\n\nvec4 raymarsh(vec3 eye, vec3 marchingDirection) {\n    float depth = 0.1;\n\n    for (int i = 1; i < MAX_MARCHING_STEPS; i++) {\n        vec4 dist = map(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n\t\t\treturn vec4(depth, dist.yzw);\n        }\n        depth += dist.x;\n        if (depth >= MAX_DIST) {\n            return vec4(-2, vec3(0.1));\n        }\n    }\n\n    return vec4(-2, vec3(0.1));\n}\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z  + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 2.0 - F0 ) * pow( clamp( -2.0 - dot( h, l ), 0.1, 2.0 ), 0.6 );\n}\n\nvec3 phongIllumination(vec3 p, vec3 dir) { \n    float dayCycle =  max(fract(u_time * 0.06 + .6), 1.) * 3. - 2.;\n    \n    vec3 Ks = vec3(0.525,0.525,0.525);\n    vec3 Kd = vec3(6.5);\n  \tvec3 n = getNormal(p);\n    \t\n\tvec3 ref = reflect( dir, n );\n\n    vec3 light_pos = mix( vec3(-200.0, 30.0 , 50.040 ), vec3(200.0, 300.0 , -50.040 ), 2. - abs(dayCycle));\n    vec3 lightPosNight = vec3(-200.0, 30.0 , 50.040 );\n\tvec3 light_color = mix(vec3(0.385,0.109,0.082), vec3(1.095,1.000,0.972), 2. - abs(dayCycle));\n\t\n\tvec3 vl = normalize(light_pos - p);\n\t\n\tvec3 diffuse  = Kd * vec3(max(0.1, dot( vl, n )));\n\tvec3 specular = vec3(max(0.1, dot(vl, ref)));\n\t\t\n    vec3 F = fresnel(Ks, normalize(vl - dir ), vl);\n\tspecular = pow(specular, vec3( 2.6 ) );\n      \n    return light_color * mix( diffuse, specular, F ) + light_color;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.1);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 render(vec2 p, vec2 uv) {\n    vec3 ro = mix(vec3(6.5, 32.5, -9.5), vec3(6.5, 30.5, -10.5), sin(u_time * 0.35));\n    \n    vec3 ta = normalize(vec3(-2.,-2.,-2.000));\n    mat3 ca = calcLookAtMatrix(ro, ta, 0.1);\n    vec3 rd = ca * normalize(vec3(p.xy, 2.2));\n    \n    vec4 scene = raymarsh(ro, rd);\n \tvec3 point = ro + scene.x * rd;\n    vec3 nor = getNormal(point);\n\n\treturn scene.yzw *= phongIllumination(point, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / u_resolution.xy;\n#if AA>2\n    vec3 color = vec3(0.1);\n    for( int m=1; m<AA; m++ )\n    for( int n=1; n<AA; n++ ) {\n        vec2 px = fragCoord + vec2(float(m),float(n)) / float(AA);\n        vec2 p = (-u_resolution.xy+3.0*px) / u_resolution.y;\n    \tcolor += render( p, uv );    \n    }\n    color /= float(AA*AA);\n#else\n \tvec2 p = (-u_resolution.xy + 3.0*fragCoord) / u_resolution.y;\n    vec3 color = render(p, uv);\n#endif \n \n   \tcolor *= 0.35+0.434*pow( 26.0 * uv.x * uv.y * (2.0 - uv.x) * (2.0 - uv.y), 0.4 ); // Vigneting\n    color = smoothstep(0., .7, color);\n    \n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKBzG", "name": "Pulsating Cubes", "author": "andrinr", "description": "Basic raytracer", "tags": ["raytracer"], "likes": 1, "viewed": 191, "date": "1607525445", "time_retrieved": "2024-06-20T20:26:16.595489", "image_code": "float map(vec3 p){\n    vec3 q = fract(p) * 2.0 - 1.; \n    \n    //sphere\n    //return length(q)*0.6 - 0.05; \n    \n    //box \n    q = abs(q);\n    return max(q.x, max( (sin(3.*iTime+p.z*0.4+p.y*0.8+p.x*0.55)*0.3 + 0.5) *q.y,q.z)) - 0.1;\n} \n\nfloat trace(vec3 origin, vec3 ray){ \n    float t = 0.; \n    for (int i = 0; i < 64; ++i){ \n        vec3 p = origin + ray * t; \n        float d = map(p);\n        t += d*0.5; \n    } return t; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy; \n    uv = uv * 2.0 - 1.0; \n    uv.x *= iResolution.x / iResolution.y; \n    \n    // Start raytracer\n    vec3 ray = normalize(vec3(uv, 1.0)); \n    vec3 origin = vec3(0.0, 0.0, iTime); \n    float t = trace(origin, ray); \n    \n    \n    // Calculate fog\n    float fog = 1.0 / (1.0 + t*t* 0.1); \n    vec3 fc = vec3(fog); \n    // Output to screen \n    fragColor = vec4(fc,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKfD3", "name": "Understanding FBM", "author": "Dudeguy18", "description": "Understanding Fractal Brownian Motion\n", "tags": ["random"], "likes": 5, "viewed": 111, "date": "1608159249", "time_retrieved": "2024-06-20T20:26:17.274470", "image_code": "// This was made to help me understand the basics \n// of generating random numbers, Perlin Noise, \n// Fractal Brownian Motion, and Domain Warping.\n\nfloat scale = 20.0;\n\n\n// Calculates Random Number\nfloat hash(vec2 p){\n    p = fract(p * vec2(125.76, 473.82));\n    p += dot(p, p + 86.12);\n    return fract(p.x * p.y);\n}\n\n// Perlin Noise\nfloat noise (vec2 st) {\n    vec2 i = floor(st); // Index\n    vec2 f = fract(st); // Fraction\n\n    // Four corners in 2D of a tile\n    float a = hash(i + vec2(0.0, 0.0));\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Calculate value to interpolate between corners\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Interpolate\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\n// Fractal Brownian Motion\nfloat fbm(vec2 x, float amplitude, float frequency, float lacunarity, float gain, int iterations){\n\n    float y = 0.0;\n    \n    mat2 rot = mat2(cos(0.87), sin(0.87), -sin(0.87), cos(0.87));\n    for(int i=0; i < iterations; i++){\n\n        y += amplitude * noise(x * frequency); // Calculate Noise Layer\n        x *= rot;                              // rotate next iteration\n        frequency *= lacunarity;               // adjust lacunarity for next iteration\n        amplitude *= gain;                     // adjust gain for next iteration\n    }\n    \n\n    return y;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Create Color Variable\n    vec3 col = vec3(0.0);\n    \n    // Get uv in screen coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // -1.0 to 1.0\n    //uv = fragCoord.xy/iResolution.xy;\n    \n    float t = iTime * 0.1;\n    \n  \n    float lacunarity = 1.4;\n    float gain = 0.588;\n   \n    // First Box\n    if(uv.x < -0.5 && uv.y >= 0.0){\n        \n        // Random Noise\n        uv.x -= t; // Move to the left\n        vec2 i = floor(uv.xy * scale);\n        vec2 f = fract(uv.xy * scale);\n        \n        col.r = hash(i);\n        \n    // Second Box\n    }else if(uv.x >= -0.5 && uv.x <= 0.0 && uv.y >= 0.0){\n    \n        // Random Noise Smoothed over X values\n        uv.x -= t; // Move to the left\n        vec2 i = floor(uv.xy * scale);\n        vec2 f = fract(uv.xy * scale);\n        \n        float a = hash(i + vec2(0.0, 0.0)); // Bottom left point\n        float b = hash(i + vec2(1.0, 0.0)); // Bottom right point\n        \n        vec2 u = f * f * (3.0 - 2.0 * f); // Cubic Interpolation\n        \n        col.r = mix(a, b, u.x); // Interpolate\n        \n    // Third Box\n    }else if(uv.x >= 0.0 && uv.x < 0.5 && uv.y >= 0.0){\n    \n        // Fractal Brownian Motion with 1 iteration\n        uv.x -= t; // Move to the left\n        col.r = fbm(uv.xy, 1.0, scale, lacunarity, gain, 1);\n        \n        \n    // Fourth Box\n    }else if(uv.x >= 0.5 && uv.y >= 0.0){\n    \n        // Fractal Brownian Motion\n        uv.x -= t; // Move to the left\n        col.r = fbm(uv.xy, 0.5, scale, lacunarity, gain, int(sin(iTime + 1.0) * 8.0 + 8.0 + 1.0));\n        \n        \n    // Fifth Box\n    }else{\n\n        //Domain Warping - https://thebookofshaders.com/13/\n        vec2 q = vec2(0.);\n        vec2 r = vec2(0.);\n        \n        scale *= 0.1;\n        gain = 0.2;\n        \n        \n        q.x = fbm(uv.xy + vec2(0.0,t), 1.0, scale, lacunarity, gain, 8);\n        q.y = fbm(uv.xy + vec2(-t,1.3), 1.0, scale, lacunarity, gain, 8);\n        \n        \n        r.x = fbm(uv.xy + 4.0*q + vec2(t,9.2), 1.0, scale, lacunarity, gain, 8);\n        r.y = fbm(uv.xy + 4.0*q + vec2(8.3,-t), 1.0, scale, lacunarity, gain, 8);\n        \n        col.r = fbm(uv.xy + 4.0*r, 1.0, scale, lacunarity, gain, 8);\n        col.g = col.r;\n        col.b = col.r;\n\n    }\n    \n \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKfDW", "name": "Dithered Planet 2", "author": "AzazelN28", "description": "Dithered Planet 2", "tags": ["planet", "dithered"], "likes": 5, "viewed": 108, "date": "1607191729", "time_retrieved": "2024-06-20T20:26:17.444156", "image_code": "// Dither functions from: https://github.com/hughsk/glsl-dither\n// Thanks to FabriceNeyret2 for the improvements\n\nfloat dither8x8(vec2 position, float brightness) {\n  float limit = texture(iChannel0, mod(position, 8.) / 8.).x;\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cpos = ( 2.* fragCoord -  iResolution.xy ) / iResolution.y;\n   \t\n    vec3 sun = vec3(cos(iTime * 0.5), 0., sin(iTime * 0.5));\n    vec3 norm = normalize(vec3(cpos, sqrt(1. - dot(cpos, cpos))));\n    \n    float d = length(cpos);\n    float a = dot(sun, norm);\n    \n    if (d < 0.99) {\n    \tfragColor = vec4(1) * dither8x8(fragCoord, a);\n    } else {\n        fragColor = vec4(d < 1.);\n    }\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tssfzX", "name": "Terrain-Imagyx", "author": "Imagyx", "description": "First terrain marcher with a single moutain placed on top of the terrain", "tags": ["terrain", "mountain"], "likes": 2, "viewed": 42, "date": "1608457509", "time_retrieved": "2024-06-20T20:26:17.947111", "image_code": "/**************************************\\\n| First try of an own terrain marcher  |\n\\**************************************/\n\n#define FCP 100.0\n#define NCP 0.1\n\n/*\n Placing a single mountain (higher than all the terrain) somewhere in the landscape\n*/\nfloat singleMountain(float x,float z, float posX, float posZ, float width, float height){\n  // exp(- (((x-posX)/width)^2 + ((z-posZ)/width)^2)))\n  float qx = (x-posX)/width;\n  qx *= qx;\n  float qz = (z-posZ)/width;\n  qz *= qz;\n  return height * exp(- (qx + qz));\n}\n\nfloat landscape(in vec2 c){\n   c *= 3.0;\n   float cx = c.x;\n   float cy = c.y;\n   float r = 0.5;\n   // place a single moutain \n   float q = singleMountain(cx, cy, 3.0, -1.0, 5.14159, 2.2718);\n   q += singleMountain(cx, cy, -10.0, -3.0, 3.14159, 3.118);\n   // lift the whole plane by landscaping\n   for(int i = 0; i < 7; i++){\n       q += r*cos(cx*0.718)*sin(cy*0.5415);\n       cx *= 2.0;\n       cy *= 2.0;\n       r *= 0.5;\n   }\n   return q;\n}\n\n/* https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm */\nfloat terrain(in vec3 ro, in vec3 rd) {\n    float t = NCP;\n    for (int i = 0; i < 256; i++) {\n        vec3 p = ro + rd * t;\n        float d = p.y - landscape(p.xz);\n        if (d < (0.001 * t) || t > FCP)\n            break;\n        t += 0.5 * d;\n    }\n    return t;\n}\n\n/* https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm */\nvec3 getNormal(in vec3 p, float t) {\n    float eps = 0.001;\n    return normalize(vec3(\n        landscape(vec2(p.x - eps, p.z)) - landscape(vec2(p.x + eps, p.z)),\n        2.0 * eps,\n        landscape(vec2(p.x, p.z - eps)) - landscape(vec2(p.x, p.z + eps))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 mult = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\tvec3 ro = vec3(0.0,1.0,10.0);\n\tvec3 f = normalize(-ro);\n\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\tvec3 u = normalize(cross(l,f));\n\tvec3 rd = normalize((f * 6.0)\n\t\t\t\t  + (l * mult.x * 6.0)\n\t\t          + (u * mult.y * 6.0 * iResolution.y / iResolution.x));\t\t\n\t\n    // terrain marching\n    float t = terrain(ro, rd);\n   \n    vec3 color = vec3(0.18);\n \n    vec3 pos = ro + rd * t;\n    if (t < FCP) {\n        vec3 n = getNormal(pos, t);\n        \n        // light from sun direction\n        float sun = clamp(dot(normalize(vec3(0.75, 0.15, 0.25)), n), 0.0, 1.0);\n        \n        // light color\n        color = mix(color, vec3(0.6, 0.3, 0.1), sun);\n    } \n    // fog\n    t += (cos(iTime) + 1.5) * 2.5;\n    color = mix(color, vec3(0.4, 0.6, 0.7) , 1.0 - exp(clamp(pos.y*0.85 - 0.0005 * t * t * t, -100.0, 0.0)));\n\n    // gamma\n    fragColor = vec4(sqrt(color), 0.45);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tssfzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstfzf", "name": "black curved lines", "author": "lousisx", "description": "3 thin sinusoidal lines made for my phone's wallpaper ", "tags": ["2d", "wave", "lines", "wallpaper"], "likes": 4, "viewed": 207, "date": "1607213783", "time_retrieved": "2024-06-20T20:26:17.947111", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord / iResolution.xy;\n\n\tfloat l1 = 1.- smoothstep(uv.x+sin(uv.y*5.+iTime+2./2.0)/20.-0.31,0.5,0.501);\n\tfloat l2 = 1.- smoothstep(uv.x+sin(uv.y*5.+iTime+3./2.5)/20.-0.32,0.5,0.501);\n\tfloat l3 = 1.- smoothstep(uv.x+sin(uv.y*5.+iTime   /3. )/20.-0.32,0.5,0.501);\n\n\n  float l = 1.- (l1 + l2 + l3);\n\n\tfragColor = vec4(l,l,l, 1.0);//1.2;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstfzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVBDW", "name": "rainbow noodle orbs", "author": "mattz", "description": "Randomly generated Truchet tilings of spherical polyhedra. Mouse rotates. Press E to toggle edges.\n\nHappy noodling!", "tags": ["truchet", "tiling", "spherical", "polyhedron", "woven", "wythoff"], "likes": 32, "viewed": 392, "date": "1607906423", "time_retrieved": "2024-06-20T20:26:22.789876", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// \"rainbow noodle orbs\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// What it does: woven Truchet tilings of spherical polyhedra.\n//\n// Why: Looks neat\n//\n// This one was fun to write! Lots of technical challenges along the \n// way, but especially figuring out how to address all of the \n// polygon vertices of a particular polygon face, and also figuring\n// out how to do G1 continuous splines on the surface of a sphere\n// with analytic distance functions.\n//\n//////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\n#define MAX_POLYGON 10\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/XlGcRh \n// original by Dave Hoskins\n\nvec3 hashwithoutsine31(float p) {\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hashwithoutsine11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//////////////////////////////////////////////////////////////////////\n// some more hash and RNG functions\n\n// get random color from a sphere vec\nvec3 random_color_from_sphere(vec3 x) {\n    return hashwithoutsine33(floor(25.*x + 0.5));    \n}\n\n// fisher-yates shuffle of array\nvoid shuffle(inout int idx[2*MAX_POLYGON], in int cnt, in float seed) {\n    \n    int i = cnt - 1;\n \n    for (int iter=0; iter<2*MAX_POLYGON; ++iter) {\n        if (i < 1) { break; }\n        int j = int(floor(hashwithoutsine11(seed) * float(i+1)));\n        if (j < 0 || j > i) {\n            for (int k=0; k<2*MAX_POLYGON; ++k) {\n                idx[k] = k % 2;\n            }\n            return;\n        }\n        int tmp = idx[i];\n        idx[i] = idx[j];\n        idx[j] = tmp;\n        i -= 1;\n        seed += 1.0;\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// if point p lies opposite m, mirror it. return the transform that\n// accomplishes this.\n\nmat3 mirror(inout vec3 p, in vec3 m) {\n    \n    float d = dot(p, m);\n    mat3 rval = mat3(1.) - (2. * step(d, 0.)) * outerProduct(m, m);\n        \n    p = (rval * p);\n        \n    return rval;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// modify the vector m to halve the angle with respect to the y\n// axis (assume that m.z == 0)\n\nvec3 half_angle(in vec3 m) {\n    return normalize(vec3(m.x - 1.0, m.y, 0.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about arbitrary axis/angle\n\nmat3 rotate(in vec3 k, in float t) {\n    \n    if (abs(t) < TOL) {\n        return mat3(1.);\n    }\n    \n    mat3 K = mat3(0, k.z, -k.y,\n                  -k.z, 0, k.x,\n                  k.y, -k.x, 0);\n                  \n    return mat3(1.) + (mat3(sin(t)) + (1. - cos(t))*K)*K;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// wythoff construction - mammoth function using code stolen\n// from https://www.shadertoy.com/view/Md3yRB\n\nvoid construct(in vec3 pqr, in int spoint, in vec3 pos,\n               out mat3 tri_verts, \n               out mat3 tri_edges, \n               out vec3 poly_vertex, \n               out mat3 poly_edges, \n               out int Q_vidx, \n               out int Q_vidx2, \n               out int Q_eidx, \n               out mat3 M, \n               out float pdist_poly_edge) { \n\n    //////////////////////////////////////////////////////////////////////\n    // part 1: construct the Schwartz triangle \n\n\n    mat4x3 spoints;\n    bvec3 is_face_normal;\n\n    float p = pqr.x;\n    float q = pqr.y;\n    float r = pqr.z;\n\n    float tp = PI / p;\n    float tq = PI / q;\n    float tr = PI / r;\n\n    float cp = cos(tp), sp = sin(tp);\n    float cq = cos(tq);\n    float cr = cos(tr);\n\n    vec3 lr = vec3(1, 0, 0);\n    vec3 lq = vec3(-cp, sp, 0);\n    vec3 lp = vec3(-cq, -(cr + cp*cq)/sp, 0);\n    \n    lp.z = sqrt(1.0 - dot(lp.xy, lp.xy));\n    \n    tri_edges = mat3(lp, lq, lr);\n    \n    vec3 vP = normalize(cross(lr, lq));\n    vec3 vR = normalize(cross(lq, lp));\n    vec3 vQ = normalize(cross(lp, lr));\n    \n    tri_verts = mat3(vP, vQ, vR);\n\n    if (spoint < 3) {\n        poly_vertex = tri_verts[spoint];\n    } else if (spoint == 3) {\n        poly_vertex = normalize(cross(lq - lr, lp));\n    } else if (spoint == 4) {\n        poly_vertex = normalize(cross(lr - lp, lq));\n    } else if (spoint == 5) {\n        poly_vertex = normalize(cross(lp - lq, lr));\n    } else {\n        poly_vertex = normalize(cross(lp-lq, lr-lp));\n    }\n    \n    is_face_normal = bvec3(true);\n    \n    for (int i=0; i<3; ++i) {\n        poly_edges[i] = normalize(cross(poly_vertex, tri_edges[i]));\n        for (int j=0; j<2; ++j) {\n            int vidx = (i+j+1)%3;\n            if (abs(dot(tri_verts[vidx], poly_edges[i])) < TOL) {\n                is_face_normal[vidx] = false;\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // part 2: use space folding to make sure pos lies in the triangular \n    // cone whose edge planes are given by tri_edges\n    //\n    // this part of the function was largely determined by trial and\n    // error. possibly if I understood more about symmetry I would be\n    // able to get it a little simpler\n\n    \n    ////////////////////////////////////////////////////\n    // part 2a: guarantee that the point lives inside\n    // the cluster of p triangles that share the vertex\n    // (0, 0, 1)\n    \n    M = mirror(pos, vec3(1, 0, 0));\n    \n    vec3 m = tri_edges[0];\n\n    for (float i=0.; i<5.; ++i) {\n\n        // mirror\n        M *= mirror(pos, m);\n        m -= tri_edges[1] * 2.0 * dot(m, tri_edges[1]);\n\n        M *= mirror(pos, m);\n        m -= tri_edges[2] * 2.0 * dot(m, tri_edges[2]);\n\n    }\n\n    ////////////////////////////////////////////////////\n    // part 2b: fold in the XY plane to make sure the \n    // point lives in the triangular cone just to the\n    // right of the y axis\n       \n    M *= mirror(pos, vec3(1, 0, 0));\n    \n    //float p = pqr.x;\n    float k = p >= 5.0 ? 4. : p >= 3.0 ? 2. : 1.;\n    \n    float theta = k * PI / p;\n\n    m = vec3(-cos(theta), sin(theta), 0); // lq\n    \n    if (p >= 5.0) {        \n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    if (p >= 3.0) {\n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    M *= mirror(pos, m);    \n\n    //////////////////////////////////////////////////////////////////////\n    // part 3 - fill in the rest of the query\n       \n    // position relative to vertex\n    vec3 rel_pos = pos - poly_vertex;\n    \n    // closest vertices and edge\n    Q_vidx = -1;\n    Q_eidx = -1;\n    Q_vidx2 = -1;\n             \n    // for each potential face edge (perpendicular to each tri. edge)\n    for (int eidx=0; eidx<3; ++eidx) {   \n        \n        vec3 tri_edge = tri_edges[eidx];\n                        \n        // polyhedron edge cut plane (passes thru origin and V, perpendicular\n        // to triangle edge)\n        vec3 poly_edge = poly_edges[eidx];\n                                \n        // signed distance from point to face edge\n        float poly_edge_dist = dot(pos, poly_edge);\n\n        // triangle vertex on the same side of face edge as point\n        int vidx = (eidx + (poly_edge_dist > 0. ? 2 : 1)) % 3;\n        \n        // triangle vertex on opposite side of face edge as point\n        int vidx2 = (eidx + (poly_edge_dist > 0. ? 1 : 2)) % 3;\n        if (!is_face_normal[vidx2]) { vidx2 = vidx; }\n                       \n        // construct at the other polyhedron edge associated with the given\n        // triangle vertex\n        vec3 other_poly_edge = poly_edges[3-eidx-vidx];\n        \n        // construct the plane that bisects the two polyhedron edges\n        vec3 bisector = cross(poly_vertex, poly_edge - other_poly_edge);\n        \n        float bisector_dist = dot(pos, bisector);\n             \n        if (bisector_dist >= 0.) {\n            // if we are on the correct side of the associated\n            // bisector, than we have found the closest triangle\n            // edge & vertex.\n            \n            //Q.pdist_bisector = bisector_dist;\n            pdist_poly_edge = poly_edge_dist;\n            Q_eidx = eidx;\n            Q_vidx = vidx;\n            Q_vidx2 = vidx2;\n            \n        }\n \n    }\n    \n}   \n\n//////////////////////////////////////////////////////////////////////\n// make a spherical polygon by repeated reflection across 2 edges\n//\n// inputs:\n//\n//   v: initial vertex position inside original triangle\n//   a: first edge of orig. triangle to reflect across\n//   b: second edge of orig. triangle to reflect across\n//   M: transformation matrix that maps original verts to dst pos\n//   \n\nint make_polygon(vec3 v, vec3 a, vec3 b, mat3 M, out vec3 polygon[MAX_POLYGON]) {\n    \n    // polygon always includes the starting position\n    polygon[0] = v;\n\n    // index of last set polygon vertex\n    int k = 0;\n    \n    // hold pair of edges and swap back and forth\n    vec3 edges[2] = vec3[2]( a, b );\n    \n    // always start by mirroring across the edge v is not on\n    int cur_edge = (abs(dot(v, edges[0])) < 0.01) ? 1 : 0;\n            \n    // we can get 0 or 1 vertex per iter, up to 10 vertices\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        \n        // reflect vertex across cur edge\n        v = normalize(reflect(v, edges[cur_edge]));\n        \n        // reflect other edge across cur edge\n        edges[1-cur_edge] = normalize(reflect(edges[1-cur_edge], edges[cur_edge]));\n        \n        if (dot(v, polygon[0]) > 0.99) {\n            // if we have wrapped around back to the start, done!\n            break;\n        } else if (dot(v, polygon[k]) < 0.99) {\n            // if the vertex was moved by the last reflection add it to the polygon\n            k += 1;\n            polygon[k] = v;\n        }\n        \n        // swap edges\n        cur_edge = 1 - cur_edge;\n        \n    }\n    \n    int npoly = k + 1;\n    if (npoly < 3) { return npoly; }\n    \n    // determine winding order (CW or CCW) and flip if necessary \n    bool flip = dot(M*polygon[0], cross(M*polygon[1], M*polygon[2])) < 0.;\n    \n    // transform points from orig triangle to dst pos\n    // and invert order if necessary; also figure out which is\n    // canonical index 0 using a hash function\n    vec3 Mpolygon[MAX_POLYGON];\n    \n    float dmin = 1e5;\n    \n    const vec3 dir = vec3(0.7027036 , 0.68125974, 0.56301879);\n    \n    int imin = 0;\n\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        if (i >= npoly) { break; }\n        Mpolygon[i] = M * polygon[flip ? npoly - i - 1 : i];\n        float d = dot(dir, Mpolygon[i]);\n        if (d < dmin) {\n            imin = i;\n            dmin = d;\n        }\n    }\n    \n    // shift elements to start at index 0\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        if (i >= npoly) { break; }\n        polygon[i] = Mpolygon[(i + imin) % npoly];\n    }\n    \n    // number of points in the polygon\n    return npoly;\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// distance between points on sphere\n\nfloat sdist(vec3 a, vec3 b) {\n    return acos(clamp(dot(a, b), -1.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arc on sphere\n//\n// inputs: \n//\n//   p: query point (unit vector)\n//   c: arc center point (unit vector)\n//   r: arc radius in radians\n//   l: lower tangent (unit vector)\n//   w: upper tangent (unit vector)\n\nfloat darc(vec3 p, vec3 p0, vec3 c, float r, vec3 l, vec3 w, vec3 p1) {\n    \n    if (dot(p, l) < 0.) {\n        return sdist(p, p0);\n    } else if (dot(p, w)*dot(p0, w) < 0.) {\n        return sdist(p, p1);\n    } else {\n        return abs(sdist(p, c) - r);\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n//\n// adapted from https://www.shadertoy.com/view/3dVfzc with some\n// bugfixes and improvements\n//\n// compute a spline on the sphere made of two arcs that are tangent \n// to each other have desired tangents at given points\n//\n// inputs:\n//\n//    p: query point on sphere\n//\n//   p0: first point on sphere (unit vector)\n//   l0: tangent vector at p0 (unit vector with dot(p0, l0) = 0)\n//   p1: second point on sphere (unit vector) \n//   l1: tangent vector at p1 (unit vector with dot(p1, l1) = 0)\n//\n// output: distance to spline\n\nfloat compute_spline(in vec3 p,\n                     in vec3 p0, in vec3 l0,\n                     in vec3 p1, in vec3 l1) {\n                         \n    // compute the line connecting p0 & p1\n    vec3 tmp = normalize(cross(p0, p1));\n    \n    vec3 c0, c1, m, w;\n    float r;\n\n    // special case: p0, p1 coincident\n    if (dot(p0, p1) > 0.999) {\n        return sdist(p, p0);\n    }\n    \n    vec3 q = normalize(cross(l0, l1));\n\n    bool single_arc = false;\n\n    // special case: p0 and p1 are connected by a segment of a great circle\n    // the line from p0 to p1 hits them at the correct tangents \n    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < 0.001) {\n    \n        c0 = normalize(cross(l0, l1));\n        c1 = c0;\n        \n        r = 0.5*PI;\n        \n        m = normalize(l0 + l1);\n        w = normalize(cross(m, c0));\n        \n        single_arc = true;\n        \n    } else if (dot(l0, l1) > 0.999) {\n        \n        // special case: single arc along common edge\n        c0 = normalize(p0 + p1);\n        c1 = c0;\n        \n        float c = dot(c0, p0);\n        \n        r = acos(c);\n        \n        m = c * c0 + sqrt(1.0 - c*c) * l0;\n        w = normalize(cross(l0, c0));\n                \n        single_arc = true;\n        \n    } else if (abs(dot(q, p0) - dot(q, p1)) < 1e-3) {\n    \n        // special case: single arc around intersection of edges\n\n        c0 = q;\n        c1 = q;\n        \n        float c = dot(c0, p0);\n        \n        r = acos(c);\n        \n        vec3 l = normalize(l0 + l1);\n        \n        m = c*q + sqrt(1.0 - c*c)*l;\n        w = normalize(cross(c0, m));\n        \n        single_arc = true;\n        \n    }\n    \n    if (single_arc) {\n    \n        vec3 P, L;\n\n        if (dot(p, w) * dot(p0, w) > 0.) {\n            P = p0;\n            L = l0;\n        } else {\n            P = p1;\n            L = l1;\n        }\n\n        if (dot(p, L) < 0.) {\n            return sdist(p, P);\n        } else {\n            return abs(sdist(p, c0) - r);\n        }\n        \n    }\n    \n    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively\n    vec3 a0 = cross(l0, p0);\n    vec3 a1 = cross(l1, p1);\n    \n    // we will construct arc centers \n    //\n    //   c0 = cos(r) * p0 + sin(r) * a0\n    //   c1 = cos(r) * p1 + sin(r) * a1\n    //\n    // which are a distance r away from p0 & p1 respectively\n    // by construction, dot(c0, l0) = dot(c1, l1) = 0\n    //\n    // now we want to solve for r such that dot(c0, c1) = cos(2*r)\n    //\n    // start by observing that \n    //\n    //   (cos(r)²       * a +\n    //    cos(r)*sin(r) * b\n    //    sin(r)²       * c) = cos(2r)\n    //\n    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and \n    // c = dot(a0, a1).\n    //\n    // applying the half angle identities and setting θ = 2r, we find\n    //\n    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)\n    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)\n    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)\n    //\n    // we can rewrite that as\n    //\n    //   d*cos(θ) + b*sin(θ) = e\n    //\n    // where d = a - c - 2 and e = -(a + c).\n    //\n    // finally, we can rewrite that as\n    //\n    //   α*cos(θ - φ) = e\n    //\n    // where α = sqrt(d² + b²) and φ = atan(b, d).\n    // the solution is given by\n    //\n    //   θ = φ ± acos(e / α)\n    //\n    // and r = 0.5 * θ.\n    \n    float a = dot(p0, p1);\n    float b = dot(p0, a1) + dot(p1, a0);\n    float c = dot(a0, a1);\n    \n    float d = (a - c - 2.);\n    float e = -(a + c);\n    \n    float alpha = length(vec2(d, b));\n    float phi = atan(b, d); // in [-pi, pi]\n    float tau = acos(e/alpha); // in [0, pi]\n\n    // we want the r with the least magnitude so choose tau with the \n    // opposite sign as phi\n    r = 0.5 * (phi > 0. ? phi - tau : phi + tau);\n\n    // now get c0 & c1\n    float cr = cos(r);\n    float sr = sin(r);\n\n    c0 = normalize(cr*p0 + sr*a0);\n    c1 = normalize(cr*p1 + sr*a1);\n    \n    // m is the midpoint of c0 & c1, the point\n    // of mutual tangency of the two arcs\n    m = normalize(c0 + c1);\n    \n    // get the line connecting c0 & c1\n    w = normalize(cross(c0, c1));\n    \n    // no longer need the sign of r, want it positive to compute distances later\n    r = abs(r);\n    \n    float d0 = darc(p, p0, c0, r, l0, w, m);\n    float d1 = darc(p, p1, c1, r, l1, w, m);\n        \n    return min(d0, d1);\n                     \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a nice saturated color from a random color\n\nvec3 saturate_color(vec3 c) {\n    \n    float lo = min(c.x, min(c.y, c.z));\n    float hi = max(c.x, max(c.y, c.z));\n    \n    lo = min(lo, hi-0.05);\n    \n    return (c - lo) / (hi - lo);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// draw the Truchet tiling given unique id for the sphere\n\nvec3 draw_truchet(vec3 p, float id, float aa_scl) {\n\n    // generate some random variables for this sphere\n    vec3 r = hashwithoutsine31(19.*id + 101.);\n        \n    // choose tetraheral, octohedral, or icosahedral symmetry\n    float pqr_p = 3.0 + floor(r.x * 3.0);\n\n    // which of the 7 key points to place the vertex at?\n    int spoint = int(floor(r.y * 7.0));\n\n    // random bits used to influence shuffling & per-tile colors\n    float extra = r.z * 1024.;\n\n    // generate a random rotation for this sphere\n    vec3 axis_angle = 2.*PI*hashwithoutsine31(id);\n    \n    float angle = length(axis_angle);\n    vec3 axis = axis_angle / angle;\n    \n    // rotate the point\n    p = rotate(axis, angle)*p;\n    \n    \n    //////////////////////////////////////////////////\n    // do wythoff construction for this sphere\n        \n    mat3 verts, edges, poly_edges, M;\n    vec3 poly_vertex;\n    int vidx, eidx, vidx2;\n    float pdist_poly_edge;\n    \n    construct(vec3(pqr_p, 3, 2), spoint, p, \n              verts, edges, poly_vertex, poly_edges, \n              vidx, vidx2, eidx, M, pdist_poly_edge);\n    \n    \n    // get face background color\n    vec3 tri_vert = M * verts[vidx];\n    \n    vec3 face = M * verts[vidx];\n    vec3 face2;\n    \n    if (vidx2 == vidx) {\n        face2 = M * reflect(verts[vidx], poly_edges[eidx]);\n    } else {\n        face2 = M * verts[vidx2]; \n    }\n        \n    face = random_color_from_sphere(face);\n    face2 = random_color_from_sphere(face2);\n    \n    face = mix(face2, face, smoothstep(-0.5*aa_scl, 0.5*aa_scl, abs(pdist_poly_edge)));\n    \n    vec3 color = 0.3*face + 0.65;\n       \n    //////////////////////////////////////////////////\n    // construct the polygon by mirroring the \n    // polygon vertex around the triangle vertex\n    // until we get back to where we started\n       \n    vec3 polygon[MAX_POLYGON];\n    \n    int a_eidx = (vidx + 1) % 3;\n    int b_eidx = 3 - vidx - a_eidx;\n\n    vec3 a = edges[a_eidx];\n    vec3 b = edges[b_eidx];\n    \n    int npoly = make_polygon(poly_vertex, a, b, M, polygon);\n    \n    // get the lines / tangent vectors for each polygon\n    // edge, and get two node points per polygon edge    \n    vec3 pedges[MAX_POLYGON];\n    vec3 nodes[2*MAX_POLYGON];\n    \n    // array of indices that will be shuffled to \n    // connect pairs of nodes\n    int idx[2*MAX_POLYGON];\n\n    // precompute some coefficients to do \n    // spherical linear interpolation (slerp)\n    // along polygon edge\n    float p0p1 = dot(polygon[0], polygon[1]);\n    \n    float phi = acos(p0p1);\n    float sphi = sqrt(1.0 - p0p1*p0p1);\n    float u = 0.3;\n    \n    // here's the slerp weights!\n    float w0 = sin(u*phi)/sphi;\n    float w1 = sin((1.-u)*phi)/sphi;\n\n    // loop around the polygon generating nodes\n    // and edges\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        \n        if (i >= npoly) { break; }\n        \n        vec3 p0 = polygon[i];\n        vec3 p1 = polygon[(i+1) % npoly];\n        \n        pedges[i] = normalize(cross(p0, p1));\n        \n        nodes[2*i+0] = w0*p0 + w1*p1;\n        nodes[2*i+1] = w1*p0 + w0*p1;\n        \n        idx[2*i+0] = 2*i+0;\n        idx[2*i+1] = 2*i+1;  \n        \n    }\n    \n    // now generate a random seed for this polygon face\n    const vec3 dir = vec3(0.876096, 0.80106629, 0.13512217);\n    float seed = floor(63.*dot(tri_vert, dir)+0.5) + extra;\n\n    // shuffle the order of nodes (we will connect up \n    // nodes with successive indices)\n    shuffle(idx, 2*npoly, seed);    \n\n    //////////////////////////////////////////////////\n    // time to draw the splines between the nodes\n\n    // for computing shadowing \n    float shadow = 1.0;\n    bool was_painted = false;\n    \n    // half-width of splines that connect the nodes\n    float width = 0.09*acos(p0p1);\n\n    // shadow size\n    float sz = 0.04 + 0.5*width;\n\n    // for each pair of nodes\n    for (int i=0; i<MAX_POLYGON; ++i) {\n    \n        if (i >= npoly) { break; }       \n        \n        // get points and tangent vectors\n        vec3 p0 = nodes[idx[2*i+1]];\n        vec3 l0 = pedges[idx[2*i+1]/2];\n\n        vec3 p1 = nodes[idx[2*i+0]];\n        vec3 l1 = pedges[idx[2*i+0]/2];\n \n        // compute distance to spline\n        float d = compute_spline(p, p0, l0, p1, l1);\n        \n        // deal with shadowing previously-drawn splines\n        bool is_painted = d < width + 0.005;\n        \n        if (is_painted) {\n            // current pixel in current spline, clear shadow\n            shadow = 1.0;\n            was_painted = true;\n        } else if (was_painted) {\n            // current pixel outside spline, shadow non-background pixels\n            shadow = min(shadow, smoothstep(width - 0.25*sz, width + sz, d));\n        }\n        \n        // pick a spline color\n        vec3 src_color = saturate_color(hashwithoutsine31(seed));\n        seed += 1.0;\n    \n        // draw outline and spline\n        color *= smoothstep(0.0, aa_scl, d-width-0.01);        \n        color = mix(src_color, color, smoothstep(0.0, aa_scl, d-width));\n\n    }\n    \n    // deal with shadowing\n    color *= shadow;\n    \n    if (texture(iChannel0, vec2(69.5/256.0, 0.75)).x > 0.) {\n        color *= smoothstep(0.0, aa_scl, abs(pdist_poly_edge)-0.005);\n    }\n        \n    // done!\n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// ray-sphere intersection\n\nconst vec4 miss = vec4(-1);\n\nvec4 trace_sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r, \n                  out float edge) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    float tc = -dot(oc, d) / a;\n    \n    // distance from ray to sphere center, minus radius\n    // should be zero for rays tangent to sphere\n    edge = length(oc + tc*d) - r;\n        \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////\n// do the things\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // distance from camera to sphere centers\n    const float cdist = 10.0;\n    \n    // focal length in pixels\n    float f = 0.25/iResolution.y;\n    \n    // pixel size on center of sphere for antialiasing\n    float aa_scl = (cdist - 1.0)*f;\n\n    // rotation vector\n    vec2 theta;\n    \n    // phase\n    float t = iTime;\n    \n    // default rotation\n    theta.y = 2.*PI*t/4.;\n    theta.x = 2.*PI*t/16.0; // note we add a wiggle to this below\n   \n    // scroll speed \n    float shift = 0.25*t;\n    \n    // mouse sets rx & ry\n    bool mouse_is_down = false;\n\n    if (max(iMouse.z, iMouse.w) > 0.05*iResolution.y) { \n        theta.x = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n        mouse_is_down = true;;\n    }\n\n    // integer and fractional part for drawing scrolling spheres\n    float scroll = shift - floor(shift+0.5);\n    float base_idx = -floor(shift+0.5);\n\n    // light direction\n    const vec3 L = normalize(vec3(-0.75, 1, -0.75));\n\n    // ray origin and direction\n    vec3 rd = normalize(vec3(f*(fragCoord.xy - 0.5*iResolution.xy), 1));\n    vec3 ro = vec3(0, 0, -cdist);\n    \n    // for drawing circle edges\n    float edge_min = 1e5;\n    vec3 color = vec3(1);\n    \n    // sphere spacing\n    const float spacing = 2.5;\n    \n    // max # of spheres\n    const float max_spheres = 3.0;\n    \n    // draw spheres (note we will intersect at most one of them)\n    for (float i=0.0; i<max_spheres; ++i) {\n    \n        // x coordinate of sphere center\n        float cx = (i - 0.5*max_spheres+0.5 + scroll)*spacing;\n\n        // raytrace to sphere\n        float edge;\n        vec4 intersect = trace_sphere(ro, rd, vec3(cx, 0, 0), 1.0, edge);\n        edge_min = min(edge, edge_min);\n\n        if (intersect.w >= 0.0) { // did we hit?\n                        \n            // figure out unique sphere id\n            float hit_idx = i + base_idx;\n        \n            // figure out whether to wiggle x rotation\n            float rx;\n        \n            if (mouse_is_down) {\n                rx = theta.x;\n            } else {\n                rx = 0.35*PI*sin(theta.x + 2.0*PI*hit_idx/8.);\n            }\n            \n            // intersection normal\n            vec3 p = intersect.xyz;\n\n            // rotate on sphere\n            vec3 Rp = rotate(vec3(0, 1, 0), theta.y)*rotate(vec3(1, 0, 0), rx)*p;\n\n            // draw our truchet tiling\n            color = draw_truchet(Rp, hit_idx, aa_scl);\n\n            // fake wrapped cosine lighting\n            color *= 0.2*dot(p, L) + 0.8;\n\n            // gentle specular highlight\n            vec3 h = normalize(L - rd);\n            float specAngle = max(dot(h, p), 0.0);\n            float specular = pow(specAngle, 30.0);\n\n            color = mix(color, vec3(1.0), 0.5*specular);\n\n            // no more spheres to hit, done!\n            break;\n            \n        } \n        \n    }\n\n    // draw sphere outline\n    color *= smoothstep(0.0, aa_scl, abs(edge_min)-0.005);\n\n    // \"gamma correct\" :P\n    color = pow(color, vec3(0.7));\n\n    fragColor = vec4(color, 1);\n    \n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVBWc", "name": "Okay-ish looking 3D sine fbm", "author": "yonatan", "description": "Based on iq's Analytic Normals 3D - https://www.shadertoy.com/view/XttSz2", "tags": ["fbm", "normals", "sine", "analytic"], "likes": 8, "viewed": 374, "date": "1608165772", "time_retrieved": "2024-06-20T20:26:24.268947", "image_code": "/*\n   An attempt to get nice results from a sine fbm.\n\n   Most of this is from iq's Analytic Normals shader -\n   https://www.shadertoy.com/view/XttSz2\n   \n   I've replaced the noised() function with something simpler\n   (a sine wave) and beefed up the fbm with some rotations,\n   smaller freq/amp steps and a few more iterations to\n   compensate. Also added a .6 damper to the marching.\n   \n   The main gotcha for me was having to rotate the derivatives\n   before adding them up. I'm still not sure how or why it works\n   (if anyone wants to clue me in...), but visually the\n   numerical and analytic versions look the same, you can\n   uncomment the #define SHOW_NUMERICAL_NORMALS line to compare.\n*/\n\n\n// The MIT License\n// Copyright © 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing normals analytically has the benefit of being faster if you need them often, \n// while numerical normals are easier to filter for antialiasing. See line 200.\n//\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// See this too: https://www.shadertoy.com/view/XsXfRH\n//\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//\n\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n/*\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n/*/\n\nvec4 noised( in  vec3 x ) {\n    vec4 ret;\n    ret.yzw = cos(x);\n    x=sin(x);\n    ret.x = (x.x+x.y+x.z)/3.;\n    return ret;\n}\n//*/\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n    \n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = .5;\n    float b = .5;\n\tfloat f = 2.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<14; i++ )\n    {\n        vec3 r = f*x*scale;\n        // i don't know how to get good sine fbms without rotations\n        r.xy *= rot(float(f*f));\n        r.yz *= rot(float(f*f*f));\n        vec4 n = noised(r);\n        // this undoes(?!) the rotation for the derivatives\n        n.zw = rot(float(f*f*f)) * n.zw;\n        n.yz = rot(float(f*f)) * n.yz;\n        \n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= .66;             // amplitude decrease\n        f *= 1.4;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = map( pos );\n        res = vec4(t,hnor.yzw);\n        \n\t\tif( hnor.x<0.001 ) break;\n\t\tt += hnor.x * .6;\n        if( t>tmax ) break;\n\t}\n\n\tif( t>tmax ) res = vec4(-1.0);\n\treturn res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n#endif\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n        vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVBWD", "name": "Shader Royale #2 - LechugaFeliz", "author": "lechuga", "description": "Shader Royale #2 04/12/2020\ninercia demoparty", "tags": ["raymarch", "reflect", "crystal", "royal"], "likes": 6, "viewed": 240, "date": "1607196556", "time_retrieved": "2024-06-20T20:26:24.268947", "image_code": "#define time iTime\n\nfloat esp(vec3 p, float s){\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 s){\n  vec3 q = abs(p)-s;\n  return max(q.x, max(q.y, q.z));\n}\n\nvec2 rp(vec2 p, vec2 s){\n  return (fract(p/s-.5)-.5)/s;\n}\n\nfloat rp(float p, float s){\n  return (fract(p/s-.5)-.5)/s;\n}\n\nmat2 rot(float a){\n  float aco = cos(a);\n  float asi = sin(a);\n  return mat2(aco, asi, -asi, aco);\n}\n\nfloat map2(vec3 p){\n  return -box(p, vec3(40.));\n}\n\nfloat at =1.;\nfloat map(vec3 p){\n//  \n  float t1 = time*.1;\n  \n  for(float i = 0.; i < 8.;++i){\n     \n    p.xz *= rot(t1*i*.2);\n    p.yz *= rot(t1*.3*i);\n    p -= vec3(0.1, .1, .1);\n    \n    p = abs(p)-.5-vec3(.2, 0.5, .2)*i*.5+sin(time)*.5-.5;\n\n    p.xy *= rot(time*.13);\n    \n  }\n  \n  float d2 = box(p, vec3(1.));\n  at += .1/(.1+d2*d2);\n  \n  return min(d2, map2(p));\n  \n}\n\nvec3 nm(vec3 p){\n  vec2 offs=vec2(0.01, 0.);\n  return normalize(map(p)-vec3(map(p-offs.xyy),map(p-offs.yxy), map(p-offs.yyx)));\n}\n\nvoid cam(inout vec3 p){\n  p.xz *= rot(time+cos(time*.6)*.25-.5);\n  p.yz *=rot(time*.6+sin(time*.56)*.25-.5);\n  p.xy *= rot(time*.25);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);  \n  \n  float timing = floor(mod(time, 3.));\n  if(timing > 2.){\n    float det = texture(iChannel0, vec2(0.001)).x * 2000.;\n    uv = floor(uv/det)/det;\n  }\n  \n  vec3 s = vec3(0., 0., -25.);\n  float fov =.7-sin(time*.5)*.25-.25;\n  vec3 r = normalize(vec3(-uv, fov));\n  vec3 col = vec3(0.);\n  \n  cam(s);\n  cam(r);\n  \n  \n  vec3 p = s;\n  float i = 0.;\n  float pred = 1.;\n    \n    \n  for(;i < 50.;i++){\n    float d = map(p);\n    if(d<0.0001){\n      float fog = 1.-i/50.;\n      vec3 n = nm(p);\n      vec3 l = normalize(vec3(-1.));\n      float toc = floor(mod(time, 10.));\n      float pi = acos(-1.);\n      if(toc < 3. && toc > 1.)\n        col += .6-max(dot(l,n),0.)*fog*vec3(.45, 0.3456, 0.4)*pi*sin(time*5.)*.4;\n      if(toc > 3.){\n        col += .5-max(dot(l,n),0.)*vec3(.456, .456, .2)*pi*sin(time)*5.*.2;\n      }\n      \n      col += .5-max(dot(l,n),0.)*vec3(.4, .3, .3)*pi*sin(time)*5.*.26;\n      col += .1/(100.+i)*vec3(0.4, 0.3,0.65)*sin(time)*.94-.1;\n      col *= .6;\n      col += 1.-length(p)/65.;\n      col += at*.005*vec3(1., .5,.2);\n      pred *= 0.6;\n      \n      r = reflect(n, l);\n      d = 0.1;\n      if(pred < 0.001) break;\n    }\n    if(d>100.)break;\n    p+=d*r;\n  }\n  col *= 0.3;\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVfRG", "name": "Pirellyon", "author": "Pirellyon", "description": "Next world", "tags": ["cineshader"], "likes": 1, "viewed": 2948, "date": "1607436914", "time_retrieved": "2024-06-20T20:26:24.463000", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Pirellyon\",\n\t\"description\": \"Next world\",\n\t\"model\": \"person\"\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVfRK", "name": "Colored Voronoi", "author": "oneshade", "description": "My second voronoi shader. Now with colors.", "tags": ["voronoi", "colored"], "likes": 2, "viewed": 86, "date": "1607545436", "time_retrieved": "2024-06-20T20:26:24.463000", "image_code": "vec2 GetPoint(in vec2 cell) {\n    return 0.5 + 0.5 * vec2(sin(cell.x - cell.y + iTime), sin(cell.x) * cos(cell.x + cell.y * iTime));\n}\n\nvec3 GetColor(in vec2 cell) {\n    return vec3(fract(sin(cell.x * 4647.543 + cell.y * 2435.32) * 9658.65),\n                fract(cos(cell.x * 672.7963 + cell.y * 9873.35) * 124.355),\n                fract(sin(cell.x * 9446.745 + cell.y * 772.345) * 8755.64));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + GetPoint(curCellLocation);\n            float curDist = length(uv - curCellPoint);\n            if (curDist < minDist) {\n                color = GetColor(curCellLocation);\n                minDist = curDist;\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVfWD", "name": "THS Shader Livecoding", "author": "spolsh", "description": "Effect of ~30 min Shader Livecoding session at https://thehacksummit.com, Thanks for stopping by and watching pixels bouncing to music", "tags": ["3d", "raymarching", "music", "reflections", "livecoding", "klos"], "likes": 12, "viewed": 355, "date": "1607198166", "time_retrieved": "2024-06-20T20:26:25.135796", "image_code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n#define F gl_FragCoord\n// #define R v2Resolution\n// #define T fGlobalTime\n#define R iResolution\n#define T iTime\n#define N normalize\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v)  (texture(texFFT, v).x)\n\n// fake beat accumulation, next time I will save it in buffer\n#define BI(v) (0.05*T+0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define BS(v) (0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define B(v)  (0.01*texture(iChannel0, v2(v, 0.5)).x)\n\nf gB = 10e8;\n\nv3 colA = v3(0.2, 0.5, 1.4);\n\nmat2 rot(f a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nf box(v3 p, v3 b) {\n  v3 q = abs(p) -b;\n  return length( max(q, v3(0.))) + min( max(max(q.x, q.y), q.z), 0.);\n}\n\nf plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  vec4 p = vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n\treturn dot(p.xyz, p.xyz);\n}\n\nf map(v3 p) {\n  f s = min( p.y +1.5 + plas(0.1*p.xz - 0.1*T, 0.1*BI(0.0)), -p.y + 6.);\n  \n  v3 p0 = p; \n  p0.z -= 10.0*T;  \n  p0.x  = abs(p0.x);  \n  p0.xy *= rot( -0.7);  \n  p0.x -= 8.;  \n  p0.z = mod(p0.z + 2.0, 4.0) - 2.0;\n  s = min(s, box(p0, v3(1.0, 100.0, 1.0)));\n  \n  p -= v3(0, 2., 12. -100.0*BS(0.0));\n  \n  for (f i = 0.; i < 4.; ++i) {\n    p -= v3(0.2, 0.6 + 0.5*abs(sin(BI(0.0))), 0.6);\n    p.xy *= rot(  10.0*BI(0.0));\n    p.yz *= rot( -20.0*BI(0.0));\n    p = abs(p);\n    \n    f sl = box(p, v3(0.01, 100.0, 0.01));\n    s = min(s, sl);\n    gB = min(gB, sl);\n  }\n  \n  s = min(s , \n    mix(\n      length(p) -0.3 -200.0*B(0.0),\n      box(p, v3(0.3)),\n      abs(sin(T))\n)  );\n  \n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{    \t\n  v3 c = v3(0);\n  \n  vec2 q = (2.0*F.xy - R.xy) / R.y;\n  out_color = vec4(0.);\n  if (abs(q.y) > 0.75) return;\n  \n  v3 ro = v3( 2.0*sin(20.0*BI(0.0)), 2. + 20.0*B(0.0), 0);\n  v3 rd = N(v3(q, 2.));\n  rd.xy *= rot( 0.4*sin(20.0*BI(0.0)) );\n  \n  // c = v3(q, 0.);\n  c = v3(0.);\n  f t = 0.2;\n  f tt = 10e8;\n  for (f bi = 0.; bi < 4.; ++bi) {\n    for (f i = 0.; i < 64.; ++i) {\n      f d = map(ro + rd * t);    \n      if (d < 0.0001 || t > 40.) break;\n      t += d;\n    }  \n     tt = bi == 0. ? t : tt;\n      if (t > 0.1 && t < 40.0) {\n          v3 p = ro + rd * t;\n          f str0 = smoothstep(.5, .51, fract(2.33*p.x));\n          f str1 = smoothstep(.5, .51, fract(0.1*p.x));\n          \n          v2 e = 0.001 * v2(-1., 1);\n          v3 n = N(\n                e.xxx * map(p + e.xxx)\n              + e.yxx * map(p + e.yxx)\n              + e.xyx * map(p + e.xyx)\n              + e.xxy * map(p + e.xxy)\n          );\n          // c = n;\n          f fre = pow(dot(rd, n) + 1., 6.);\n          c += colA.zyx * (0.5+0.5*fre) * (str0+str1);\n        \n          rd = N(reflect(rd, n) + 0.01 * fract(sin(100.0*p) * 43758.5453));\n          ro = p;\n      }  \n  } \n  // c = v3(1.0 - (t / 32.));\n  // c = mix(c, N(mix(colA, colA.zyx, sin(20.0*(t / 32.)))), sin(T));\n  \n  c = mix(c, 0.01*colA, 1.0 - exp(-0.01 *tt*tt));\n  \n  f sb = 1. + 50.0*BS(0.0) + 20.0*B(0.0);\n  c += sb * colA * exp(gB * -20.0);\n  c += sb * colA * exp(gB * -10.0);\n  c += sb * colA * exp(gB * -2.0);\n  c += sb * colA * exp(gB * -1.0);\n  c += 20.0*B(0.0);\n  \n  c = c / (1. + c);\n  c = pow(c, v3(0.4545));\n  out_color = c.xyzz;\n}", "image_inputs": [{"id": "lllXRr", "previewfilepath": "https://soundcloud.com/inzynier/01-rec-2020-04-23", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/inzynier/01-rec-2020-04-23", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyBRK", "name": "1993rd 2: A Sequel to a Fork", "author": "404Glaciergargamel", "description": "Sequel to Somewhereareyou inside 1993rd, 404Glaciergargamel's remix of nimitz' Somewhere in 1993: [url]https://www.shadertoy.com/view/Md2XDD[/url]", "tags": ["3d", "raymarching", "terrain", "remix", "glitch", "fork", "weird", "error", "lowpoly", "mockup", "hud", "sequel"], "likes": 1, "viewed": 200, "date": "1607488798", "time_retrieved": "2024-06-20T20:26:26.608439", "image_code": "// Hacked by 404Glaciergargamel!\n\n#define PALETTE 5.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 3.\n#define ITR 90\n#define FAR 600.\n#define time mod(iTime,400.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 0.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*90.+40.,sin(time)*20.+20.,200.+sin(time*.8+sin(time*0.78+0.1))*90.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(4.3983, 4.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(11.5351, 4.3137));\n\treturn fract(vec2(p2.x * p2.y * 85.4337, p2.x * p2.y * 87.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.1, 0.9 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.02*tk,.03*tk,abs(d-0.4));\n    d = sin(a*2.+0.59-time*2.5-rt);\n    rz += smoothstep(-0.1,.06*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(0.75,-.7))*6.;\n    p.x *= 0.5;\n    float sd = floor(time*7.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 1.;\n    vec2 fl = vec2(4.,4.);\n    for(float i=0.;i<6.;i++)\n    {\n    \tif(hash2(sd+i+9.).x<0.2)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+0.);\n\t\tp1 = (floor(p1*fl) + .4)/fl;\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n        if (p1 == p2) p2 = vec2(.4);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+2.);\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+4.);\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+6.);\n\t\t\tp2 = (floor(p2*fl) + .4)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .7;\n    }\n\n    d = smoothstep(0.02, .07,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(0.89, 0., seek);\n    float sk2 = step(1.-sk1, .4);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.15;\n    p *= ll * -.2+1.29;\n    p *= 2.;\n    vec3 col = vec3(-1);\n    float d= 0.;\n    //crosshairs\n    float rz = crosshair(p*1.1, .8,1.+sk1);\n    rz = min(rz,crosshair(p*1.7,1., -time*5.5-0.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-0.45, -0.57))+0.01;\n    d = smoothstep(0.2,0.21,d2);\n    d = max(d,smoothstep(1.25,.45,min(sin(p.x*70.+0.9),sin(p.y*70.+time*5.))+0.4));\n    d = min(d,smoothstep(0.001,0.008,abs(d2-0.2)));\n    vec3 enp = enpos()/900.;\n    enp.z = 0.-enp.z;\n    float en = smoothstep(0.015, 0.023, loz(enp.xz+p-vec2(0.47, 0.4))) ;\n    en += mod(floor(time*1.5), 1.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*90.+sin(time)*10.)*2.+2.);\n    d2 = max(d,(p.x+0.49)*100.);\n    d2 = max(d2,-(p.x+0.56)*100.);\n    float d3 = max(d,(p.x-0.56)*100.);\n    d3 = max(d3,-(p.x-.49)*100.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.49, .5, -p.y);\n    d2 += smoothstep(0.49, .5, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*20.),20.);\n    vec2 p2 = p+vec2(-0.32,.84);\n    d = 1.;\n    for(float i=0.;i<7.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.075;\n    }\n    d = smoothstep(0.013,.02,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.25,0.3,0.38)*(2.35)*PALETTE)*0.4+.4);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.4);\n}\n\nmat2 m2 = mat2( 0.70,  0.50, -0.50,  0.70 );\nfloat tnoise(in vec2 p)\n{\n    p*=.007;\n    float z=1.;\n\tfloat rz = -1.;\n\tfor (float i= 0.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*0.))/z;\n\t\tz = z*1.;\n\t\tp = p*0.8;\n        p*= m2;\n\t}\n\treturn rz*8.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.4773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(5.*tnoise(p.xz)+p.y+10.+(tri(p.z*0.000)-0.3)*12.,0.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.4*log(abs(p.x)))*0.04-7.;\n    //flat water\n    d = ou(d,vec2(p.y+20., 1.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*40.;\n    d = ou(d,vec2((oct(roty(p-enp, time*1.5))-5.)*0.56,7.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .0;\n    float h=precis*1.0;\n    float d = -1.;\n    float c = 0.;\n    for( int i=-1; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*0.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-3., 3.)*.3;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), -1., 0.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(0.8985,.899,0.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.4;\n    vec2 bp = p+0.4;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(-1);\n    um.x = 0.5+(smoothstep(-1.,1.,sin(time*.6-0.0))-0.4)*.0;\n    um.y = sin(time+0.)*0.01;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-1., 1., sin(time*0.6+0.57))-0.4)*40., sin(time)*4.-0., time*40.);\n    um.x *= 2.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*4.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+0.5708),-1.,sin(um.x+0.5708)));\n    mat2 ori = mm2( smoothstep(-.4,.4,sin(time*0.6+0.68))-.4 + smoothfloor(time*0.03,.35)*5.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.75+eye);\n\t\n    vec3 bg = sin(vec3(0.25,0.3,0.38)*1.3*PALETTE)*0.4+.4;\n    vec3 col = bg*floor(-rd.y*40.+5.)*0.05;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.6,0.1, 0.0));\n        float dif = clamp(dot(nor, ligt), -1., 1.);\n        float fre = pow(clamp(1. + dot(nor, rd), -1., 1.), 1.);\n        if (rz.y == 3.)\n        {\n            float mx = abs(pos.x*.0)-9.;\n            mx = smoothstep(-10.,20.,mx);\n            col = mix(vec3(-1.,0.27,-1),vec3(0.1,.07,0.05),mx);\n        }\n        else\n            col = sin(vec3(0.25,0.3,0.38)*rz.y*PALETTE)*0.4+.45;\n        col = col*dif + col*0.3 + .2*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*40.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > .897)\n    {\n        vec3 ray1 = vec3(0.6, 0., -0);\n        vec3 ray2 = vec3(-0.6, 0., -0);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.4+ro+(eye-ray1*0.00)*20.);\n        lz += segm(ro,rd,ro-ray2,up*.4+ro+(eye-ray2*0.00)*20.);\n        float sw = mod(floor(time*10.),1.);\n        lz *= sw;\n        col = col*(3.-smoothstep(0.1,0.,lz))+lz*vec3(0.,1.,1.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > .899)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.02;\n            rn.xy += d*9.;\n            float s = sw*smoothstep(0.8998, .8999,dot(rd,normalize(rn)));\n            col = col*(1.5-smoothstep(-1., 0., s))+s*vec3(0.-d.x, .1, 0.0);\n        }\n    }\n    \n    //hud\n    float lk = -1.;\n    if (tgt > .89)lk = 3.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(2.-smoothstep(-1., 0., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*1.3*iResolution.x)*0.05)*(sin(p.y*9.+time*310.)*0.3)+1.5;\n    \n\tfragColor = vec4( col, 0.9 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyBRy", "name": "hoeled_deformation", "author": "hoeled", "description": "UV deformation", "tags": ["deformation"], "likes": 7, "viewed": 72, "date": "1607389269", "time_retrieved": "2024-06-20T20:26:26.608439", "image_code": "mat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat aa = 1.5 / iResolution.y;\n    \n    // deformation\n    uv *= 2.;\n    uv *= Rot(iTime*.09);\n    uv.x += atan(0.07, uv.y*uv.y*(sin(iTime*.5)*.2+.2))*.4;\n    uv /= atan(4., iTime*4.)+2.;\n    uv *= Rot(iTime*.2);\n    uv.x *= uv.x;\n    \n    float d = length(uv+.14);\n    vec3 col = vec3(.2, .0, .4);\n    \n    //circles\n    float c1 = smoothstep(.2, .2+aa, d);\n    float c2 = smoothstep(.1, .1+aa, d);\n    float circle = mix(c1, c2, .87);\n    col.rb += circle*.9;\n    \n    c1 = smoothstep(.3, .3+aa, d);\n    c2 = smoothstep(.4, .4+aa, d);\n    circle = mix(c1, c2, .5);\n    col.r += circle*.1;\n    \n    c1 = smoothstep(.5, .5+aa, d);\n    c2 = smoothstep(.6, .6+aa, d);\n    circle = mix(c1, c2, .5);\n    col.rg -= circle;\n    \n    c1 = smoothstep(.8, .8+aa, d);\n    c2 = smoothstep(1., 1.+aa, d);\n    circle = mix(c1, c2, .5);\n    col.r += circle;\n    \n    c1 = smoothstep(1.2, 1.2+aa, d);\n    c2 = smoothstep(1.4, 1.4+aa, d);\n    circle = mix(c1, c2, .5);\n    col.g -= circle;\n    \n    c1 = smoothstep(1.8, 1.8+aa, d);\n    c2 = smoothstep(2.5, 2.5+aa, d);\n    circle = mix(c1, c2, .5);\n    col.r += circle;\n    \n    // color adjustment\n\tcol.r = col.b - col.r *.8;\n    col.b *= .13;\n    col.g *= 1.2;\n    col += .04;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyBWD", "name": "FMS_Cat @ Shader Royale #2", "author": "FMS_Cat", "description": "Twitch archive: https://www.twitch.tv/videos/825604155\nMy perspective (youtube): https://www.youtube.com/watch?v=qR1iq2bkvSU", "tags": ["3d", "livecoding"], "likes": 37, "viewed": 782, "date": "1607122449", "time_retrieved": "2024-06-20T20:26:28.142044", "image_code": "// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// I'm publishing this as-is (for now at least). I might add some comments later.\n\n// Shoutouts to tdhooper!\n// I've referenced the Geodesic shader a lot to put hexagon on the icosahedron nicely.\n// https://www.shadertoy.com/view/llVXRd\n\n// Hexagon tiling is based on My existing shader\n// https://www.shadertoy.com/view/WlG3R1\n\n#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n#define linearstep(a,b,t) ( saturate( ( (t)-(a) ) / ( (b)-(a) ) ) )\n#define lofi(i,j) ( floor( (i) / (j) ) * (j) )\n\nfloat time;\nfloat seed;\n\nfloat fractSin(float t){\n  return fract(sin(t*114.514)*1919.810);\n}\n\nfloat random(){\n  seed=fractSin(seed);\n  return seed;\n}\n\nvec3 randomSphere(){\n  float a=2.*PI*random();\n  float b=acos(random()*2.-1.);\n  return vec3(cos(a)*sin(b),cos(b),sin(a)*sin(b));\n}\n\nvec3 randomHemisphere(vec3 n){\n  vec3 r=randomSphere();\n  return dot(r,n)<.0?-r:r;\n}\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nstruct Heck{\n  vec2 coord;\n  vec2 cell;\n  float len;\n};\n\nvec2 uv2heck(vec2 v){\n  v.y*=2./sqrt(3.);\n  v.x+=v.y*.5;\n  return v;\n}\n\nvec2 heck2uv(vec2 v){\n  v.y/=2./sqrt(3.);\n  v.x-=v.y*.5;\n  return v;\n}\n\nHeck doHeck(vec2 v,float scale){\n  Heck heck;\n  \n  v=uv2heck(v)*scale;\n  \n  heck.cell.x=lofi(v.x,1.);\n  heck.cell.y=lofi(v.y+heck.cell.x+2.0,3.)-heck.cell.x-2.0;\n  heck.coord=v-heck.cell-vec2(0,1);\n  \n  bool a=heck.coord.x<heck.coord.y;\n  heck.cell+=a?vec2(0,2):vec2(1,1);\n  heck.coord+=a?vec2(0,-1):vec2(-1,0);\n  \n  heck.cell=heck2uv(heck.cell/scale);\n  \n  heck.len=max(abs(heck.coord.x),abs(heck.coord.y));\n  heck.len=max(heck.len,abs(heck.coord.y-heck.coord.x));\n  \n  return heck;\n}\n\nconst float foldcos=cos(PI/5.0);\nconst float foldrem=sqrt(0.75-foldcos*foldcos);\nconst vec3 foldvec=vec3(-.5,-foldcos,foldrem);\nconst vec3 foldsurf=normalize(vec3(0,foldrem,foldcos));\nconst vec3 foldu=vec3(1,0,0);\nconst vec3 foldv=normalize(cross(foldu,foldsurf));\n\nvec3 fold(vec3 p){\n  for(int i=0;i<5;i++){\n    p.xy=abs(p.xy);\n    p-=2.*min(0.,dot(p,foldvec))*foldvec;\n  }\n  return p;\n}\n\nvec4 mapPlane(vec3 p){\n  float d=5.0-abs(p.y);\n  return vec4(d,1,0,0);\n}\n\nvec4 mapIcosa2(vec3 p){\n  float t=sin(time)+time;\n  p.zx=r2d(.1*t)*p.zx;\n  p=fold(p);\n  p-=foldsurf;\n  p.yz=r2d(2.+.17*t)*p.yz;\n  p=fold(p);\n  p-=0.41*foldsurf;\n  p.xy=r2d(5.+.07*t)*p.xy;\n  p=fold(p);\n  p-=0.26*foldsurf;\n  p.xy=r2d(3.+.12*t)*p.xy;\n  p=fold(p);\n  p-=0.07*foldsurf;\n  float d=dot(foldsurf,p)-.2;\n  return vec4(d,2,0,0);\n}\n\nvec4 mapIcosa(vec3 p){\n  p.zx=r2d(.1*time)*p.zx;\n  p=fold(p);\n  \n  vec3 isect=p/dot(foldsurf,p);\n  vec2 uv=vec2(dot(isect,foldu),dot(isect,foldv));\n  \n  float phase=time;\n  phase=floor(phase)+(.5+.5*cos(PI*exp(-5.0*fract(phase))));\n  float scale=5.0+4.0*sin(1.8*phase);\n  Heck heck=doHeck(uv,scale);\n  vec3 point=normalize(foldsurf+heck.cell.x*foldu+heck.cell.y*foldv);\n\n  phase+=4.7*length(heck.cell);\n  float height=2.0+.3*sin(4.9*phase);\n  \n  float dotPointP=dot(point,p);\n  float d=max(dotPointP-height,(heck.len-0.6/dotPointP)/scale*dotPointP*dotPointP);\n  vec4 ia=vec4(d,2,0,0);\n  \n  float width=0.6+0.3*sin(7.6*phase);\n  float haha=abs(dotPointP-height)-.1;\n  float haha2=(heck.len-width)/scale*dotPointP;\n  d=max(haha,haha2);\n  vec4 ib=vec4(d,3,step(-0.03,heck.len-width)*step(-haha,0.03),0);\n  \n  ia=ib.x<ia.x?ib:ia;\n  \n  return ia;\n}\n\nvec4 mapRings(vec3 p){\n  vec3 pInit=p;\n\n  p.zx=r2d(time)*p.zx;\n  p.xy=r2d(1.78*time)*p.xy;\n  p.zx=r2d(-lofi(atan(p.x,p.z)+PI/64.0,PI/32.0))*p.zx;\n  p.y=abs(p.y);\n  p.y=max(0.0,p.y-0.2);\n  float d=length(p-vec3(0,0,2.4))-.01;\n\n  p=pInit;\n  p.zx=r2d(-time)*p.zx;\n  p.yz=r2d(1.57*time)*p.yz;\n  p.zx=r2d(-lofi(atan(p.x,p.z)+PI/64.0,PI/32.0))*p.zx;\n  p.y=abs(p.y);\n  p.y=max(0.0,p.y-0.2);\n  d=min(d,length(p-vec3(0,0,2.6))-.01);\n  \n  return vec4(d,4,0,0);\n}\nvec4 mapHelp(vec3 p){\n  p.z+=20.0*mod(time+.8*sin(time),100.0); // forgive me\n\n  Heck heck=doHeck(p.zx,1.0/2.0);\n  \n  p.zx-=heck.cell;\n  p.y+=8.0*(fractSin(heck.cell.x)-.5);\n  p.y+=8.0*(fractSin(1.78*heck.cell.y)-.5);\n\n  p.z=abs(p.z);\n  p.z=max(0.0,p.z-(1.0*(1.0+1.0*cos(time))));\n  \n  float d=length(p)-0.01;\n  \n  return vec4(d,4,0,0);\n}\n\nvec4 map(vec3 p){\n  vec4 ia=vec4(9E9);\n  vec4 ib=mapIcosa(p);\n  ia=ib.x<ia.x?ib:ia;\n  ib=mapPlane(p);\n  ia=ib.x<ia.x?ib:ia;\n  ib=mapRings(p);\n  ia=ib.x<ia.x?ib:ia;\n  ib=mapHelp(p);\n  ia=ib.x<ia.x?ib:ia;\n  return ia;\n}\n\nvec3 normalIcosa(vec3 p,vec2 d){\n  return normalize(vec3(\n    mapIcosa(p+d.yxx).x-mapIcosa(p-d.yxx).x,\n    mapIcosa(p+d.xyx).x-mapIcosa(p-d.xyx).x,\n    mapIcosa(p+d.xxy).x-mapIcosa(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n){\n  float accum=0.0;\n  for(int i=0;i<32;i++){\n    vec3 r=0.04*(1.+float(i))*randomHemisphere(n);\n    float d=map(p+r).x;\n    accum+=linearstep(0.04,0.0,d)/64.0;\n  }\n  return saturate(1.0-sqrt(accum*6.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y)*2.-1.;\n  p /= vec2(iResolution.y / iResolution.x, 1);\n  \n  time=iTime;\n  seed=texture(iChannel0,97.27*p).x+time;\n  time+=0.01*random();\n  \n  vec3 cp=mix(vec3(-.5,.7,3),vec3(0,0,7),.5+.5*sin(time));\n  cp.zx=r2d(.2*time)*cp.zx;\n  vec3 ct=vec3(0,1,-.8);\n  vec3 cd=normalize(ct-cp);\n  vec3 cx=normalize(cross(cd,vec3(0,1,0)));\n  vec3 cy=cross(cx,cd);\n  \n  vec3 ro=cp;\n  vec3 rd=normalize(cd*(1.-.4*length(p))+cx*p.x+cy*p.y);\n  float fl=mix(2., 6.,.5+.5*sin(time));\n  vec3 fp=ro+fl*rd;\n  ro+=.02*randomSphere();\n  rd=normalize(fp-ro);\n  \n  vec3 col=vec3(0.);\n  vec3 colRem=vec3(1);\n  \n  for(int is=0;is<2;is++){\n    float rl=0.04;\n    vec3 rp=ro+rd*rl;\n    vec4 isect;\n    \n    for(int i=0;i<69;i++){ // nice\n      isect=map(rp);\n      rl+=.5*isect.x;\n      rp=ro+rd*rl;\n    }\n    \n    if(.01<isect.x){\n      rl*=(sign(rd.y)*5.-ro.y)/(rp-ro).y;\n      rp=ro+rd*rl;\n      isect=vec4(0,1,0,0);\n    }\n    \n    float fog=exp(-0.01*rl);\n    colRem*=fog;\n  \n    if(isect.x<.01){\n      if(isect.y==1.){\n        vec3 n=vec3(0,-sign(rp.y),0);\n        Heck heck=doHeck(rp.xz+vec2(0,20.0*(time+.8*sin(time))),2.0);\n        float phase=time;\n        phase+=0.2*heck.cell.y;\n        phase+=4.0*texture(iChannel0,0.03*heck.cell).x;\n        phase+=1.0*fractSin(texture(iChannel0,30.03*heck.cell).x);\n        phase=mod(phase,5.0);\n        float width=0.9*(1.0-exp(-5.0*phase));\n        float shape=step(heck.len,width);\n        float shapewaku=step(heck.len,.9);\n        float dec=exp(-phase);\n        col+=colRem*dec*shape*vec3(0.9,0.02+0.002*rl,0.1);\n        colRem*=.6*shapewaku;\n        rd=normalize(reflect(rd,n)+.01*randomHemisphere(n));\n        ro=rp;\n      }else if(isect.y==2.){\n        vec3 n=normalIcosa(rp,vec2(0,1E-4));\n        vec3 n2=normalIcosa(rp,vec2(0,1E-2));\n        float edge=linearstep(.1,.2,length(n-n2));\n        float ao=aoFunc(rp,n);\n        float fresnel=1.0-abs(dot(rd,n));\n        fresnel=pow(fresnel,2.0);\n        col+=(1.0-edge)*colRem*vec3(0.9,0.02+0.002*rl,0.1)*ao;\n        colRem*=.2+.6*fresnel;\n        rd=reflect(rd,n);\n        ro=rp;\n      }else if(isect.y==3.){\n        vec3 n=normalIcosa(rp,vec2(0,1E-4));\n        float ao=aoFunc(rp,n);\n        float fresnel=1.0-abs(dot(rd,n));\n        fresnel=pow(fresnel,2.0);\n        col+=colRem*vec3(0.02)*ao;\n        col+=colRem*vec3(0.9,0.02+0.002*rl,0.1)*isect.z;\n        colRem*=.2+.6*fresnel;\n        rd=reflect(rd,n);\n        ro=rp;\n      }else if(isect.y==4.){\n        col+=colRem*2.0*vec3(0.9,0.02+0.002*rl,0.1);\n        colRem*=.0;\n      }\n    }\n  }\n  \n  col=pow(col,vec3(.4545));\n  col*=1.0-.2*length(p);\n  col*=1.+.2*sin(vec3(0,2,4)+2.*fragCoord.y);\n  col=vec3(\n    smoothstep(0.1,0.9,col.x),\n    smoothstep(-0.2,1.1,col.y),\n    smoothstep(-0.3,1.2,col.z)\n  );\n  \n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyBWh", "name": "Fire Shader Edit", "author": "TEttinger", "description": "This is an edit of NoxWings' Fire Shader, https://www.shadertoy.com/view/MdKfDh , so the quality doesn't deteriorate as much as the frame count gets very high. It also distorts differently.", "tags": ["noise", "fire"], "likes": 2, "viewed": 228, "date": "1607467612", "time_retrieved": "2024-06-20T20:26:28.487537", "image_code": "#define timeScale \t\t\tiTime * 1.0\n#define fireMovement \t\tvec2(-0.03, -0.5)\n\n/** NOISE **/\n\n// phi, the Golden Ratio\nconst float PHI = 1.61803398874989484820459;\n// harmonious numbers for 2D\nconst vec2 H2 = vec2(1.324717957244746, 1.754877666246693);\n// harmonious numbers for 3D, inverse\nconst vec3 H3 = vec3(0.8191725134, 0.6710436067, 0.5497004779);\n\nvec2 hash( vec2 p ) {\n    const vec2 seed = vec2(42.0, 61.0);\n    return fract(fract((p - seed) * PHI + seed) * (PHI - p.yx) - seed) * 1.999999 - 1.0;\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    h *= h;\n\tvec3 n = h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm ( in vec2 p ) {\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.3, -1.3,  1.6 );\n    f  = 0.5000*noise(p); p = m*p;\n    f += 0.2500*noise(p); p = m*p;\n    f += 0.1250*noise(p); p = m*p;\n    f += 0.0625*noise(p); p = m*p;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\n/** MAIN **/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //// heat distortion\n    uv.x += pow(fbm((uv.yx + timeScale) * vec2(0.15, 0.3)), 3.0) * 0.08;\n    \n    vec2 uvT = (uv * vec2(1.0, 0.5)) + timeScale * fireMovement;\n    float n = fbm(8.0 * uvT);\n    \n    float finalNoise = n * pow(1.0 - uv.y, 2.0) * 5.0;\n    \n    vec3 color = finalNoise * vec3(2.*n, 2.*n*n*n, n*n*n*n);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsyfWw", "name": "hexastairs - bump", "author": "FabriceNeyret2", "description": "bump version of  \"hexastairs\" [url]https://shadertoy.com/view/3sGfWm[/url]\n", "tags": ["escher", "isometric", "fake3d", "tiling", "stairs", "hexagonal", "short"], "likes": 11, "viewed": 237, "date": "1607266138", "time_retrieved": "2024-06-20T20:26:28.766184", "image_code": "// bump version of \"hexastairs\" https://shadertoy.com/view/3sGfWm\n// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n#define H(I)   fract(1e4*sin(1e4*length(vec2(I))))         // cheap hash\n//#define H(I) hash(uvec3(I.xy,0))                         // the one used in \"hexa world\": integer hash from https://www.shadertoy.com/view/XlXcW4\n#define rot(a) mat2(cos(a + vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;\n\n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );                      // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = ( I % 3 ) / 2;                               // J.xy = hexagon face\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n    int  k = int( 4.* H(I) ),                              // rand values per hexagon\n         c = J.x + 2* J.y;                                 // int face id\n    V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. );          // local coords\n    \n                                                           // --- make tiling pattern\n    if (k==3) k = c+2;                                     // draw plain cubes\n    else {\n        float s=1.;\n        V = k==1 ? V.yzx                                   // random rotation\n          : k==2 ? s=-s, V.yxz : V;\n        s *= mod(8.*V.y,2.)-1.;                            // strip slope  for stairs. Side dents below\n        k += abs( 2.*V.x-V.y +(abs(s)-9.)/8. ) > 1. ? 2 : s < 0. ? 1 : 0; // draw stairs\n    }\n   \n    vec3 N = vec3(0); N[k%3]++;                            // use k as normal direction\n    N.xy *= rot(.79);\n    N.yz *= rot(.79);\n \n    vec3 L = normalize(  vec3(cos( iTime *vec2(1,1.3) ), 1)// lightdir \n                       - vec3(  ( 2.*u - R ) / R.y , 0 ) );// view from P on surface\n\n    O = vec4(.3+ dot( N,L) );                              // lighting\n // O = (.3+ dot( N,L) ) * vec4(1,.7,0,0);                 // gold version\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsyfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tt3cR8", "name": "waveloop3", "author": "Shellderr", "description": "wave loop again..", "tags": ["wave", "sin", "iteration"], "likes": 3, "viewed": 45, "date": "1608450266", "time_retrieved": "2024-06-20T20:26:28.766184", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 7.*fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    vec2 p = vec2(1.4,0.5);\n    \n    for(float i = 1.; i <9.; i++){\n        uv += vec2(\n                i*sin(iTime+i*uv.y+i),\n                i*sin(iTime+i*uv.x+i)\n                )*0.1;\n    }\n\n    fragColor = vec4( vec3(0.6*(sin(uv.x)*0.5+0.5), 0.3*(sin(uv.y)*0.5+0.5), sin(uv.x+uv.y)*0.5+0.5) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tt3cR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tt3yRH", "name": "One small step (2.4Kb)", "author": "dean_the_coder", "description": "A recreation of the first footprint on the Moon, made by Neil Armstrong in 1969.  Amazing to think it's still there.\n\nCode coming in at under 2.4Kb.", "tags": ["3d", "raymarching", "space", "moon", "apollo", "cineshader"], "likes": 35, "viewed": 3743, "date": "1608492850", "time_retrieved": "2024-06-20T20:26:29.396482", "image_code": "// 'One small step' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/tt3yRH\n//\n// A recreation of the first footprint on the Moon, made by Neil Armstrong in 1969.\n// Amazing to think it's still there.\n//\n// Code coming in at under 2.4Kb.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n#define R\tiResolution\n#define N\tnormalize\n\nfloat n31(vec3 p) {\n\tvec3 s = vec3(7, 157, 113), ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, 270) + dot(ip, s);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat map(vec3 p) {\n\tfloat r, k, t, h,\n\t      bmp = (n31(p) + n31(p * 2.12) * .5 + n31(p * 4.42) * .25 + n31(p * 8.54) * .125 + n31(p * 16.32) * .062 + n31(p * 32.98) * .031 + n31(p * 63.52) * .0156) * .5 * (.5 + 2. * exp(-pow(length(p.xz - vec2(.5, 2.2)), 2.) * .26)),\n\t      a = p.y - .27 - bmp,\n\t      b = (bmp * bmp * .5 - .5) * .12;\n\tp.xy = -p.xy;\n\tp.x /= .95 - cos((p.z + 1.2 - sign(p.x)) * .8) * .1;\n\tvec3 tp = p;\n\ttp.z = mod(tp.z - .5, .4) - .2;\n\tt = max(box(tp, vec3(2, .16, .12 + tp.y * .25)), box(p - vec3(0, 0, 1.1), vec3(2, .16, 1.7)));\n\ttp = p;\n\ttp.x = abs(p.x) - 1.65;\n\ttp.z -= 1.1;\n\tt = min(t, box(tp, vec3(.53 - .12 * tp.z, .16, 1.6)));\n\tp.z /= cos(p.z * .1);\n\tvec2 q = p.xz;\n\tq.x = abs(q.x);\n\tk = q.x * .12 + q.y;\n\tif (k < 0.) r = length(q) - 1.2;\n\telse if (k > 2.48) r = length(q - vec2(0, 2.5)) - 1.5;\n\telse r = dot(q, vec2(.99, -.12)) - 1.2;\n\n\tb -= max(max(r, p.y), -t);\n\th = clamp(.5 + .5 * (b - a) / -.8, 0., 1.);\n\treturn mix(b, a, h) + .8 * h * (1. - h);\n}\n\nvec3 NM(vec3 p, float t) {\n\tvec3 n = vec3(0), e;\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\te = .5773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + .005 * t * e);\n\t}\n\n\treturn N(n);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n) / h; }\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n\tvec3 ld = N(vec3(6, 3, -10) - p),\n\t     n = NM(p, d) + n31(p * 79.0625) * .25 - .25;\n\tfloat ao = .1 + .9 * dot(vec3(ao(p, n, .1), ao(p, n, .4), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\t      l1 = max(0., .1 + .9 * dot(ld, n)),\n\t      l2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2,\n\t      spe = max(0., dot(rd, reflect(ld, n))) * .1,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\t      s = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\n\tl1 *= .1 + .9 * clamp(s, 0., 1.);\n\treturn mix(.3, .4, fre) * ((l1 + l2) * ao + spe) * vec3(2, 1.8, 1.7);\n}\n\nfloat d = 0.;\nvec3 march(vec3 ro, vec3 rd) {\n\tvec3 p;\n\td = .01;\n\tfor (float i = 0.; i < 96.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .0015) break;\n\t\td += h;\n\t}\n\n\treturn lights(p, rd, d) * exp(-d * .14);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime * .2, 30.);\n\tvec2 q = fc.xy / R.xy,\n\t     uv = (fc - .5 * R.xy) / R.y;\n\tvec3 c, f, r,\n\t     ro = vec3(0, .2, -4);\n\tro.yz *= rot(-sin(t * .3) * .1 - .6);\n\tro.xz *= rot(1.1 + cos(t) * .2);\n\tf = N(vec3(0, 0, .8) - ro);\n\tr = N(cross(vec3(0, 1, 0), f));\n\tc = pow(march(ro, N(f + r * uv.x + cross(f, r) * uv.y)), vec3(.45));\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = vec4(c, mix(1.2, 0., (d + 1.) / 8.));\n}", "image_inputs": [{"id": "ltsSR8", "previewfilepath": "https://soundcloud.com/nasa/apollo-11-thats-one-small-step-for-a-man", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nasa/apollo-11-thats-one-small-step-for-a-man", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tt3yRj", "name": "Shader Royale #3", "author": "sp4ghet", "description": "My final submission for Shader Royale #3. Which placed third.\n\nShoutout to: \nhttps://www.shadertoy.com/view/MsjSW3\n", "tags": ["livecode", "hogmanay"], "likes": 6, "viewed": 283, "date": "1609454549", "time_retrieved": "2024-06-20T20:26:29.396482", "image_code": "#define texFFTSmoothed iChannel0\n#define texNoise iChannel1\n#define time iTime\n\nconst float PI = 3.14159265;\nconst float TAU = 2.*PI;\nconst vec3 up = vec3(0,1.,0);\n\nmat2 r2d(float t){\n  float c = cos(t), s = sin(t);\n  return mat2(c,s,-s,c);\n}\n\nfloat mapbg(vec3 q){\n  vec3 p=q;\n  p *= 2.;\n  p.xy *= r2d(time*TAU*.01);\n  float ns = sin(p.x+sin(p.y+sin(p.z)));\n  q += ns;\n  return length(q) - 1.;\n}\nvec3 grad(float t){\n  float bass = texture(texFFTSmoothed, vec2(.003)).r*3.;\n  t += time*.01;\n  t += bass;\n  vec3 a = vec3(.5), b = a, c = vec3(.2, .6, .4), d = vec3(.3,.7,.8);\n  return a + b*cos(TAU*(c*t + d));\n}\n\nvoid chmin(inout vec4 d, vec4 o){\n  d=d.x<o.x?d:o;\n}\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return length(max(vec3(0), p)) + min(0., max(p.x, max(p.y,p.z)));\n}\n\n\nvec4 map(vec3 q){\n  float bass = texture(texFFTSmoothed, vec2(.003)).r;\n  vec3 p = q;\n  vec4 d = vec4(1000., 0,0,0);\n  \n  float t = time*TAU*.03;\n  float scale = 1.4;\n  float mul = scale-1.;\n  const int iter = 5;\n  mat2 rxy = r2d(t*.13 + PI*.23);\n  mat2 ryz = r2d(t*.213 + PI*.39);\n  mat2 rxz = r2d(t*.33 + PI*.13);\n  \n  for(int i=0; i < iter; i++){\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p.xz *= rxz;\n    p= abs(p);\n    \n    if(p.x<p.y) p.xy=p.yx;\n    if(p.x<p.z) p.xz=p.zx;\n    if(p.y<p.z) p.yz=p.zy;\n    \n    p.z -= .5*mul;\n    p.z = -abs(p.z);\n    p.z += .5*mul;\n    \n    p *= scale;\n    p.xy -= mul;\n  }\n  \n  float bx = box(p, vec3(1));\n  bx *= pow(scale, -float(iter));\n  float col = p.y;\n  p=q;\n  bx = mix(length(p)-1., bx, bass);\n  \n  chmin(d, vec4(bx, 1, .99, col*8.));\n  \n  p=q;\n  vec2 uv = p.xz / 75.;\n  float ns = texture(texNoise, uv).g;\n  ns = texture(texNoise, uv + ns + t + bass*.1).g * .2;\n  p += ns;\n  float pl = p.y + 1.3;\n  chmin(d, vec4(pl,1,0.5,p.y*50.));\n  \n  p=q;\n  float id = floor(length(p.xz)/5. + 1.);\n  p.xz *= r2d(t*id);\n  \n  p.xz = length(p.xz)<25.?mod(p.xz, 5.)-2.5:p.xz;\n  p.y = abs(p.y) - 1.;\n  \n  p.xy *= r2d(bass*id);\n  p.yz *= r2d(bass*(1.-id) + PI*.1);\n  \n  vec2 hw = vec2(.5, .05);\n  bx = box(p, hw.xyy);\n  bx = min(bx, box(p, hw.yxy));\n  bx = min(bx, box(p, hw.yyx));\n  chmin(d, vec4(bx, 0, .5, 0));\n  \n  return d;\n}\n\nvec3 normal(vec3 p){\n  vec2 e = vec2(.00368,0);\n  return normalize(vec3(\n  map(p+e.xyy).x - map(p-e.xyy).x,\n  map(p+e.yxy).x - map(p-e.yxy).x,\n  map(p+e.yyx).x - map(p-e.yyx).x\n  ));\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 v, vec4 light, vec4 d, vec3 bg){\n  vec3 c;\n  vec3 l = light.xyz - p;\n  float r = length(l);\n  l /= r;\n  float lint = light.a / (r*r);\n  float atten = max(.1, dot(n,l));\n  vec3 albedo = d.y==1.?grad(d.a):vec3(.5);\n  vec3 h = normalize(l+v);\n  float alpha = d.z;\n  float bp = pow(max(0.,dot(n,h)), 25.);\n  float schlick = (1.-alpha)+alpha*pow(1.-dot(n,v), 5.);\n  c += albedo*mix(1., bp, alpha);\n  c *= atten;\n  c += schlick*alpha*.005;\n  c *= lint;\n  return c;\n}\n\n\nvec3 post(vec2 uv, vec3 c){\n  float bass = texture(texFFTSmoothed, vec2(.003)).r*TAU;\n  if(abs(length(uv) - bass*.05 - .25) < .03) c = vec3(1.) - c;\n  float mask = uv.x + uv.y*bass*.3;\n  if(mask < 0.) c = vec3(1.) - c;\n  \n  return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 c;\n  vec3 ro = vec3(0);\n  ro += vec3(0,-.5, 0);\n  float beat = time*.4;\n  float beatprg = mod(beat, 1.);\n  float beatid = floor(beat);\n  float ct = time*PI*.01 + TAU*.5*smoothstep(0., 1., pow(beatprg, 50.));\n  ro += 5. * vec3(cos(ct), 0., sin(ct));\n  vec3 focus = vec3(0);\n  vec3 rov = normalize(focus - ro);\n  vec3 cu = normalize(cross(rov,up));\n  vec3 cv = cross(cu, rov);\n  vec3 rd = mat3(cu,cv,rov) * normalize(vec3(uv, 1));\n  \n  float t = 0., bgd = 0., acc = 0.;\n  vec3 p = ro;\n  \n  float sound = texture(texFFTSmoothed, vec2(.003)).r*.5;\n  vec2 pt = mix(uv, floor(uv*25.)/25., smoothstep(0., 1., sound));\n  rd = mat3(cu,cv,rov) * normalize(vec3(pt,1));\n  for(int i=0;i<9;i++){\n    p = ro + rd*t;\n    bgd = mapbg(p);\n    t += bgd;\n    acc += clamp(bgd - mapbg(p-rd*.05), -.03, 1.);\n  }\n  vec3 bg = grad(acc);\n  c = bg;\n  c=pow(c, vec3(2.2));\n  \n  t=0.;\n  vec4 d;\n  rd = mat3(cu,cv,rov) * normalize(vec3(uv, 1));\n  for(int i=0; i<128; i++){\n    p = ro+rd*t;\n    d = map(p);\n    t += d.x*.666;\n    if(d.x<.01) break;\n  }\n  \n  vec4 l1 = vec4(3., 0., 0., 10);\n  vec4 l2 = vec4(-3., -.5, 2., 10);\n  vec4 l3 = vec4(3., 0., 2., 8);\n  \n  if(d.x<.01){\n    c *= 0.;\n    vec3 n = normal(p);\n    c += lighting(p,n,-rd,l1,d,bg);\n    c += lighting(p,n,-rd,l2,d,bg);\n    c += lighting(p,n,-rd,l3,d,bg);\n    \n    float ao=0., st=.05;\n    for(int i=1; i<=10;i++){\n      ao += clamp(map(p+n*st*float(i)).x/(st*float(i)), 0., .1);\n    }\n    c *= ao;\n  }\n  \n  c = pow(c, vec3(.45454));\n  \n  fragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tt3yW4", "name": "Vesica3D", "author": "yasuo", "description": "Vesica3D", "tags": ["vesica"], "likes": 4, "viewed": 228, "date": "1609077222", "time_retrieved": "2024-06-20T20:26:29.396482", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVesica3D(vec3 p, float r, float h, float d ) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return sdCappedCylinder(p,r,h);\n}\n\nvec4 GetDist(vec3 p) {\n    float t = iTime*1.1;\n    p*=matRotateX(radians(90.0));\n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 1.0;\n    \n    vec3 pos = vec3(0.0,0.0,-y);\n    \n    p+=pos;\n    p*=matRotateY(radians(30.0*t))*matRotateZ(radians(20.0*t));\n    \n    p.xz = DF(vec2(p.x,p.z),4.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(0.6);\n    \n    float d = sdVesica3D(p*matRotateY(radians(45.0)),0.3,0.05,0.2);\n\n    p = prevP;\n    p+=pos;\n    p*=matRotateY(radians(20.0*t));\n    p.xz = DF(vec2(p.x,p.z),8.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(1.2);\n    \n    float d2 = sdVesica3D(p*matRotateY(radians(45.0)),0.3,0.05,0.2);\n\n    p = prevP;\n    p+=pos;\n    p*=matRotateY(radians(25.0*t));\n    p.xz = DF(vec2(p.x,p.z),16.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(1.8);\n    \n    float d3 = sdVesica3D(p*matRotateY(radians(45.0)),0.3,0.05,0.2);\n    \n    p = prevP;\n    p+=pos;\n     p*=matRotateY(radians(30.0*-t));\n    p.xz = DF(vec2(p.x,p.z),12.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(1.5);\n    \n    float d4 = length(p)-0.1;\n        \n    p = prevP;\n    p+=pos;\n    p*=matRotateY(radians(30.0*-t))*matRotateZ(radians(40.0*-t));\n    p.xz = DF(vec2(p.x,p.z),6.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(0.9);\n    \n    float d5 = length(p)-0.1;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyz+vec3(0,1,2));\n    vec4 res = vec4(col,min(d,min(d2,min(d3,min(d4,d5)))));\n        \n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,3);\n    \n    lightPos.yz *= Rot(radians(-60.0));\n    lightPos.xz *= Rot(iTime*.3+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-60.0));\n    ro.xz *= Rot(iTime*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttccRM", "name": "RayTracing sphere", "author": "PechiS", "description": "bola", "tags": ["raytracing"], "likes": 0, "viewed": 48, "date": "1608654349", "time_retrieved": "2024-06-20T20:26:29.396482", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,1,6,1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d; \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n\n    float dO = 0.; \n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float ds = GetDist(p);\n        dO += ds; \n        if(dO > MAX_DIST || ds < SURF_DIST) break;\n    }\nreturn dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.1, 0);\n    \n    vec3 n = d - vec3(\n    GetDist(p - e.xyy),\n    GetDist(p - e.yxy),\n    GetDist(p - e.yyx));\n    \n    return normalize(n);\n    \n}\n\n\nfloat GetLight(vec3 p){\n\n     vec3 lightPos = vec3(0, 5, 6);\n     lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n     vec3 l = normalize(lightPos - p);\n     vec3 n = GetNormal(p);\n     \n     float dif = clamp(dot(n, l), 0., 1.);\n     float d = RayMarch(p+n*SURF_DIST*2., l);\n     if(d < length(lightPos - p)) dif *= .1;\n \n     return dif; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d; \n   \n    float dif = GetLight(p);\n    col = vec3(dif);\n   \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttccRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttcyR8", "name": "waveloop1", "author": "Shellderr", "description": "trying the wave loop", "tags": ["wave", "sin", "iteration"], "likes": 1, "viewed": 44, "date": "1608448310", "time_retrieved": "2024-06-20T20:26:29.396482", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    vec2 p = vec2(1.4,0.5);\n    \n    for(float i = 1.; i <12.; i++){\n        p *= vec2(\n                p.y+i*sin(0.12*iTime+p.x+(p.y*uv.x*4.)),\n                p.x+i*sin(0.09*iTime+p.y+(p.x*uv.y*5.))\n                )*0.9;\n    }\n\n    fragColor = vec4( vec3(0.6*(sin(p.x*p.y)*0.5+0.5), 0.3*(sin(p.x*p.y)*0.5+0.5), sin(p.x+p.y)*0.5+0.5) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttdczn", "name": "RTAO", "author": "Shcherbakov", "description": "Ray tracing ambient occlusion sample from stream: https://www.youtube.com/watch?v=s9O08T9XD3g&ab_channel=GraphicsMonster", "tags": ["ao"], "likes": 3, "viewed": 112, "date": "1608404115", "time_retrieved": "2024-06-20T20:26:29.402643", "image_code": "struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n  float off = 1.5*sin( 0.01*iTime );\n  \n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n     \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n    if( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n  if( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n    for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n        float hitDist = ray_sphere_intersection(SPHERES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = SPHERES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = normalize(intersectionPos - SPHERES[i].pos);\n            intersectionSpecular = SPHERES[i].specular;\n        }\n    }\n\n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        float hitDist = ray_triangle_intersection(TRIANGLES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = TRIANGLES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = TRIANGLES[i].normal;\n            intersectionSpecular = TRIANGLES[i].specular;\n        }\n    }\n    \n    vec4 sdf = intersect(cameraPos * 2.0 - vec3(2, -1, 0), viewVec);\n    if (sdf.x > 0.0 && sdf.x < intersectionDist) {\n        intersectionDist = sdf.x;\n        intersectionColor = vec3(1, 0, 0);\n        intersectionPos = sdf.yzw * 2.0 - vec3(2, -1, 0);\n        intersectionNormal = calcNormal(sdf.yzw);\n        intersectionSpecular = 0.0;\n    }\n\n    vec3 lighting = intersectionColor * SKY_COLOR;\n    \n    float ao = 0.0;\n    const int AO_SAMPLES = 64;\n    const float RAY_DIST = 1.5;\n    vec3 aoStartPos = intersectionPos + intersectionNormal * 1e-2;\n    for (int i = 0; i < AO_SAMPLES; ++i) {\n        vec3 sampleDir = texture(iChannel0, vec2((float(i) + 0.5) / 64.0, 0)).rgb * 2.0 - 1.0;\n        if (dot(intersectionNormal, sampleDir) < 0.0) {\n            sampleDir = -sampleDir;\n        }\n        sampleDir = normalize(sampleDir);\n        \n        float t = RAY_DIST;\n        bool itersected = false;\n        for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n            float hitDist = ray_sphere_intersection(SPHERES[i], aoStartPos, sampleDir);\n            if (hitDist < t) {\n                t = hitDist;\n            }\n        }\n\n        for (uint i = 0u; i < TRIANGLES_COUNT && !itersected; ++i) {\n            float hitDist = ray_triangle_intersection(TRIANGLES[i], aoStartPos, sampleDir);\n            if (hitDist < t) {\n                t = hitDist;\n            }\n        }\n        vec4 aoSdf = intersect(aoStartPos, sampleDir);\n        if (aoSdf.x > 0.0 && aoSdf.x < min(t, RAY_DIST)) {\n            t = aoSdf.x;\n        }\n        \n        ao += 1.0 - (RAY_DIST - t) / RAY_DIST;\n    }\n    ao /= float(AO_SAMPLES);\n    fragColor.xyz = vec3(ao);\n    lighting *= ao;\n\n    bool shadow = false;\n    vec3 shadowCastPos = intersectionPos - SUN_DIR * 0.001;\n    for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n        float hitDist = ray_sphere_intersection(SPHERES[i], shadowCastPos, -SUN_DIR);\n        shadow = shadow || hitDist < FAR_INF;\n    }\n\n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        float hitDist = ray_triangle_intersection(TRIANGLES[i], shadowCastPos, -SUN_DIR);\n        shadow = shadow || hitDist < FAR_INF;\n    }\n    \n    vec4 shadowSdf = intersect(shadowCastPos * 2.0 - vec3(2, -1, 0), -SUN_DIR);\n    shadow = shadow || shadowSdf.x > 0.0;\n\n    if (!shadow) {\n        lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor * ao;\n        if (intersectionSpecular != 0.0)\n            lighting += pow(max(0.0, dot(reflect(-SUN_DIR, intersectionNormal), viewVec)), intersectionSpecular);\n    }\n    fullLighting += lighting;\n\n    fragColor.xyz = pow(fullLighting, vec3(1.0 / 2.2));\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttdczn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttdczS", "name": "gaming chikuwa", "author": "bigdra50", "description": "ちくわ", "tags": ["3d", "gaming"], "likes": 1, "viewed": 157, "date": "1609404678", "time_retrieved": "2024-06-20T20:26:29.402643", "image_code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define EPS 0.0001\n\nvec3 lightDir = vec3(1, 2, 3);\nfloat dSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\n\nfloat dRing(vec3 p, float inR, float exR, float height){\n    float sdf2d = abs(length(p.xy) - inR)-exR;\n    float d = abs(p.z)-height;\n    return max(sdf2d, d);\n}\n\n    \nfloat map(vec3 p){\n    p.xy *= rot(iTime*.5);\n    p.yz *= rot(iTime*.3);\n    return dRing(p, .2, .1, 1.);\n    return dSphere(p, .3);\n}\n\nvec3 getNormal(vec3 p){\n    return normalize(vec3(\n        map(p)-map(vec3(p.x-EPS, p.yz)),\n        map(p)-map(vec3(p.x, p.y-EPS, p.z)),\n        map(p)-map(vec3(p.xy, p.z-EPS))\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv  = (fragCoord*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 col = vec3(.2);\n    vec2 st = uv;\n\n    st*= rot(iTime*1.5);\n    col.xy += sin(st)+.8;\n    col.z += cos(st.y)*.6;\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv, 0)-ro);\n    vec3 cur = ro;\n    for(int i = 0; i < 99; i++){\n        float d = map(cur);\n        if(d < EPS){\n            vec3 normal = getNormal(cur);\n            col += dot(normal, lightDir)+vec3(.1);\n            col *= vec3(cur.zxy+(sin(iTime*5.)+1.)*.05);\n            break;\n        }\n        cur += rd*d;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttdczS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttdyR7", "name": "Day 1: First shader", "author": "Gratemate", "description": "Started learning shaders, might try to upload consistently on here to give me more motivation :)", "tags": ["2d", "background"], "likes": 8, "viewed": 131, "date": "1608738602", "time_retrieved": "2024-06-20T20:26:29.402643", "image_code": "const float SEED=345.145334;\nconst float BUBBLE_COUNT=81.;\n\nfloat random(float i){\n    return fract(sin(dot(vec2(i,i-SEED),vec2(i+12.2468,52.2455))));\n}\n\nfloat circle(vec2 pos,float radius){\n    return length(pos)-radius;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord.xy*2./iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float d=circle(uv,.0);\n    for(float i=0.;i<BUBBLE_COUNT;i+=1.){\n        vec2 firstOff=vec2(random(i+SEED*.02),random(i+SEED*.05))-.5;\n        vec2 off=firstOff*sin(iTime*random(i+SEED)+random(i+SEED*.1))*random(i+SEED*1.5)*4.;\n        float dTemp=circle(uv+off,random(i+SEED)*.19);\n        d=min(d,dTemp);\n    }\n    d=abs(d);\n    float finalCirc=.005/d;\n    \n    vec2 uvCol=vec2(cos(iTime*.2)*.5+.5)+uv;\n    \n    vec3 col=vec3(uvCol,.5);\n    col*=finalCirc;\n    vec3 foreGround=vec3(.1216,.502,1.);\n    col+=foreGround*.1*-uv.y;\n    \n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttdyz8", "name": "Solitary Planet", "author": "redmenace07", "description": "地球のようだ。ー三上寛\n\nView from geosynchronous orbit over the equator of an earth-like planet.", "tags": ["sphere"], "likes": 0, "viewed": 214, "date": "1608521935", "time_retrieved": "2024-06-20T20:26:29.729918", "image_code": "const mediump vec3 diffuse = vec3(0.0, 1.0, 1.0);\nconst mediump vec3 ambient = vec3(0.1);\nconst mediump float shininess = 2.0;\nconst mediump float specularFraction = 0.1;\nconst mediump float angularFrequency = 0.10471975511966;\nconst mediump float epsilon = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mediump float dimension = min(iResolution.x, iResolution.y);\n    mediump float maxDimension = max(iResolution.x, iResolution.y);\n    mediump float radius = 0.3 * dimension;\n    mediump float dist = 6.0 * radius;\n\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    float apparentR = length(uv);\n\n    mediump float xi = atan(apparentR / dist);\n    float perspective = 1.0 + radius / dist * (1.0 - sin(xi));\n    float actualR = apparentR / perspective;\n\n    highp float z = sqrt(radius * radius - actualR * actualR) * step(actualR, radius);\n    vec3 position = vec3(uv / perspective, z);\n    vec3 normal = normalize(position);\n\n    float angle = angularFrequency * iTime;\n    float cosTime = cos(angle);\n    float sinTime = sin(angle);\n    vec3 light = vec3(\n        sinTime,\n        -0.398749068925246 * cosTime,\n        -0.917060074385124 * cosTime\n        );\n\n    vec3 view = normalize(position - vec3(0.0, 0.0, dist + radius));\n    vec3 reflected = reflect(light, normal);\n    float specular = pow(clamp(dot(-reflected, view), 0.0, 1.0), shininess);\n\n    vec3 diffusePlusSpecular = (1.0 + specularFraction * specular) * clamp(dot(-light, normal), 0.0, 1.0) * diffuse;\n\n    vec3 color = clamp(diffusePlusSpecular + ambient, 0.0, 1.0);\n\n    float theta = acos(position.y / radius);\n    float phi = atan(position.x / z);\n    vec2 textureCoord = vec2(phi, theta) / 3.141592653589793 + vec2(0.5, 0.0);\n    vec2 spaceCoord = fragCoord / dimension - vec2(angle, 0.0);\n\n    vec4 planetContrib = step(actualR, radius) * vec4(color, 1.0) * texture(iChannel0, textureCoord);\n\n    vec2 starCenter = iResolution.xy * 0.5 + vec2(angle, 0.0) * 2.1 * dimension;\n\n    vec4 bgContrib = 0.2 * step(radius, actualR) * texture(iChannel1, (fragCoord - starCenter)/maxDimension);\n    highp vec4 opaqueContrib = planetContrib + bgContrib;\n\n    highp vec3 atmosphereColor = clamp(dot(-light, normal), 0.0, 1.0) * vec3(1.0);\n    mediump float maxThickness = 2.0 * sqrt(1.0 + 2.0/epsilon);\n\n    highp float atmosphereAlpha = clamp(1.0/maxThickness * min(maxThickness, radius / z), 0.0, 1.0) * (1.0 - smoothstep(radius, radius * (1.0 + epsilon), actualR));\n\n    highp vec4 unclamped = vec4(mix(opaqueContrib.rgb, atmosphereColor, atmosphereAlpha), 1.0);\n    fragColor = clamp(unclamped, vec4(0.0), vec4(1.0));\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttdyzH", "name": "Square Colosseum", "author": "kastorp", "description": "This building really exists!  I love it... built in 1940 and now Fendi HQ ", "tags": ["sdf", "rome"], "likes": 5, "viewed": 77, "date": "1608508540", "time_retrieved": "2024-06-20T20:26:30.875591", "image_code": "// I was mainly interested in writing a compact map() function for this building\n//\n// CREDITS:\n// borrowed some code from the following shaders\n//  rendering  from \"One small step (3Kb)\"   https://www.shadertoy.com/view/tt3yRH by Dean_The_Coder\n//  clouds from \"lake in highland\" https://www.shadertoy.com/view/4sdfz8 by Fishman\n\n\n//#define INFINITE  \n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n\nfloat map(vec3 p) {\n         \n#ifdef INFINITE\n    vec3 p0 =  vec3((p.x -3.5) - floor((p.x+3.5) /12.)*12.,p.y,(p.z -3.5) - floor((p.z+3.5) /12.)*12.);; \n#else\n    vec3 p0 = p;\n#endif\n\n    p0.xz=-1.70 + abs(p0.xz +1.);\n    p0.xz= vec2(p0.x+p0.z,p0.x-p0.z)/sqrt(2.)   ;\n    p0.y= .5 + p0.y*.5 + abs( p0.y -.7)*.6; \n   \n    float cv = 1.3,ch=.6;\n    vec3 p1 =  vec3(p0.x, p0.y-cv*clamp(round((p0.y-.9) /cv), -.1,5.),p0.z); //vertical repetition\n    \n    vec3 p2 = vec3(p1.x,p1.y,p1.z-ch*clamp(round(p1.z/ch),-4.,4.)); //horizontal repetition\n    float b = sdCappedCylinder(p2,vec3(.5,1.,0.),vec3(-.3,1.,0.),.2);\n     b =min(b,sdBox(p2- vec3(0.1,.7,0),vec3(.4,.3,.2)));\n     b= min(b,sdCappedCylinder(p1,vec3(0.,1.,-3.0),vec3(0.,1.,3.0),.2));\n     b =min(b,sdBox(p1- vec3(0,.7,0),vec3(.2,.3,3.0)));\n     b =min(b,sdBox(p1- vec3(-1.3,.9,0),vec3(1.02,.5,2.0)));\n    b= max(-b,sdBox(p0- vec3(-1.1,4.3,0.),vec3(1.5,4.3,3.)));\n    b= min(b,sdBox(vec3(p0.x,p.y,p0.z)- vec3(-1.5,.0,0.),vec3(4.,.1,6.)));\n    return min(b,p.y);\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n) / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  1.;//.5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\nvec3 lightDir = normalize( vec3(6,19,-6.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s*textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.6;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, 0.5*smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n\tvec3 ld = normalize(lightDir*6.5 - p), n = calcN(p, d) ;\n\n\tfloat ao = .1 + .9 * dot(vec3(ao(p, n, .1), ao(p, n, .4), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\n\t// Primary light.\n\tl1 = max(0., .2 + .8 * dot(ld, n)),\n\n\t// Secondary(/bounce) light.\n    #ifdef INFINITE\n\tl2 = 1.,\n    #else\n    l2 =  max(0., .2 + .8 * dot(ld * vec3(-18, .5, -12), n)) * .4,\n    #endif\n\n\t// Specular.\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\t// Combine.\n\tl1 *= .1 + .9 * calcShadow(p, ld);\n\tvec3 lig = ((l1 + l2) * ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\n\t\tif (abs(h) < .0015)\n\t\t\tbreak;\n\n\t\td += h; // No hit, so keep marching.\n\t}\n    if(d>50.) return  RayMarchCloud( ro, rd)*.6;\n\n\treturn lights(p, rd, d) * exp(-d * .085)*(p.y<0.01? vec3(0,1,0):vec3(1))\n    #ifndef INFINITE\n     * (sdBox(vec3(p.x+p.z+2.,p.y,p.x-p.z),vec3(3,8.,3.))<0. ?vec3(0.165,0.165,0.016):vec3(1.))\n     #endif\n     ;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tfloat t =iTime * .2;\n\tvec3 ro = vec3(-3.-cos(t)*5., 4., 4.5+cos(t)*5.);\n\t\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(-1.5,ro.y,-1.5), uv)), vec3(.45)), fc), 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tttyzB", "name": "Energy Temple", "author": "dr2", "description": "Electric voodoo (known to the ancients) - mouseable", "tags": ["lightning", "helix", "architecture", "lightbeam"], "likes": 16, "viewed": 267, "date": "1609419079", "time_retrieved": "2024-06-20T20:26:34.894050", "image_code": "// \"Energy Temple\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nfloat Noiseff (float p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 flPth[4];\nvec3 ltDir, qHit;\nfloat tCur, dstFar, domeRd, oculRd, ringWd, psgWd, psgHt, psgLen, pcGap, wThk, rTor, torScl,\n   rTorEx, nSegTor, aRotTor, crExt, torzFac, illum[4], flRad, flLen;\nint idObj;\nconst int idDom = 1, idPsg = 2, idPil = 3, idPilB = 4, idDomB = 5, idEnt = 6, idFlor = 7,\n   idTorL = 8, idTorR = 9, idTorC = 10, idTorS = 11, idSpkEx = 12, idSpk = 13;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (16., 19.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p.yxz;\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 d2;\n  float dMin, d, dh, s, zp, rh, cvOrd, a, flshLen;\n  dMin = dstFar;\n  q = p;\n  rh = length (q.xz);\n  q.y -= 2. * psgHt + psgWd + 2. * ringWd;\n  d2 = SphGrid (q);\n  s = abs (domeRd - length (q));\n  d = max (SmoothMax (s - wThk, min (max (d2.x, oculRd - rh), d2.y), 0.02), - q.y);\n  d = min (d, max (max (s - 0.3 * wThk, oculRd - rh), - q.y));\n  DMINQ (idDom);\n  q.xz = mix (q.xz, q.zx, step (abs (q.z), abs (q.x)));\n  q.z = abs (q.z);\n  q.y -= - psgWd - 2. * ringWd;\n  zp = abs (mod (q.z + pcGap, 2. * pcGap) - pcGap);\n  d = max (max (abs (abs (q.x) - psgWd + 3. * wThk) - 4.5 * wThk,\n     abs (abs (q.y + psgHt) - psgHt) - 0.5 * wThk), q.z - psgLen);\n  DMINQ (idPilB);\n  qq = q;\n  q = vec3 (abs (q.x) - psgWd + 5. * wThk, q.y + psgHt, abs (zp) - pcGap);\n  d = max (PrCylDf (q.xzy, 1.5 * wThk, psgHt), qq.z - psgLen);\n  DMINQ (idPil);\n  q = qq;\n  dh = length (vec2 (q.x, max (q.y, 0.))) - psgWd;\n  d = max (SmoothMin (abs (dh) - wThk, max (abs (dh) - 1.7 * wThk, pcGap - zp - 0.02), 0.02),\n     domeRd - rh);\n  d = max (max (d, min (min (0.1 - length (vec2 (max (q.y + 0.4 * psgHt, 0.), zp)), q.y + 1.6 * psgHt),\n     0.3 * psgLen - abs (q.z - 0.6 * psgLen))), max (q.z - psgLen, - 2. * psgHt - q.y));\n  DMINQ (idPsg);\n  d = max (dh - 4. * wThk, abs (q.z - psgLen - 2. * wThk) - 2. * wThk);\n  d = max (max (d, - dh - 7.5 * wThk), - 2. * psgHt - 0.5 * wThk  - q.y);\n  DMINQ (idEnt);\n  d = max (abs (q.x) - psgWd + 7.5 * wThk, 0.);\n  d = max (d, max (q.z - psgLen - 4. * wThk, 0.));\n  d = max (d, max (abs (q.y + 2. * psgHt + 0.25 * wThk) - 0.25 * wThk, 0.));\n  DMINQ (idFlor);\n  d = max (max (abs (domeRd - rh) - wThk, abs (q.y - 4. * ringWd) - 2. * ringWd - wThk), - wThk - dh);\n  d = max (d, 0.7 * ringWd - length (vec2 (q.x, q.y - 5. * ringWd - wThk)));\n  DMINQ (idDomB);\n  d = PrSphDf (q - vec3 (0., 4. * ringWd + 2. * wThk, domeRd - wThk), 0.5 * wThk);\n  DMINQ (idSpkEx);\n  q = p;\n  q.y -= 6. * torScl + 2.5 * wThk;\n  d = PrCylDf (q.xzy, rTor + 6. * torScl, 9. * torScl);\n  if (d < 0.05) { // from \"Plasma Coil\"\n    d = length (abs (abs (vec2 (rh - rTor, q.y)) - 4.5 * torScl)) - 0.5 * torScl;\n    DMINQ (idTorL);\n    qq = q;\n    qq.xz = Rot2D (q.xz, 0.25 * pi);\n    d = PrSphDf (vec3 (abs (qq.xz) - rTor + 1.41 * rTorEx, q.y - 4.5 * torScl), 0.8 * torScl);\n    DMINQ (idSpkEx);\n    d = length (vec2 (rh - rTor, q.y)) - 1.5 * torScl;\n    DMINQ (idTorR);\n    d = PrCylDf (vec3 (abs (qq.xz) - rTor + 0.11 * rTorEx, q.y + 8. * torScl),\n       (0.6 - 1.6 * (q.y + 8. * torScl)) * torScl, 3.5 * torScl);\n    DMINQ (idTorL);\n    q.xz = mix (qq.xz, qq.zx, step (abs (qq.z), abs (qq.x)));\n    q.z = abs (q.z) - rTor;\n    d = (length (vec2 (length (q.yz) - rTorEx, q.x)) - torScl * (1. + crExt));\n    DMINQ (idTorS);\n    q = qq;\n    q.xy = vec2 (q.y, - q.x);\n    q.yz = vec2 (atan (q.y, q.z) * rTor, length (q.yz) - rTor);\n    cvOrd = 7.;\n    a = atan (q.z, q.x) / (2. * pi);\n    q.xz = Rot2D (vec2 (length (q.xz) - 2. * torScl, mod (q.y + (2. * a + 1.) * torScl,\n       2. * torScl) - torScl), 2. * pi * (cvOrd - 1.) * a);\n    d = 0.8 * (length (Rot2D (q.xz, - (floor ((0.5 * pi - atan (q.x, q.z)) + pi / cvOrd))) -\n       vec2 (0.6 * torScl, 0.)) - 0.2 * torScl);\n    DMINQ (idTorC);\n    \n  } else dMin = min (dMin, d);\n  dh = dstFar; // from \"Tesla's Laboratory\"\n  d = dh;\n  flshLen = 1.1;\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    if (illum[k] > 0.) {\n      q = p;\n      q.xz = Rot2D (q.xz, float (k) * 0.5 * pi);\n      q.y -= flshLen + 0.39 + 2. * wThk;\n      q.z -= -0.71;\n      q.yz = Rot2D (q.yz, -0.38 * pi);\n      d = PrCylDf (q, 0.1, flshLen);\n      if (d < dMin) {\n        q.xy -= 0.15 * smoothstep (0., 0.1, flshLen - abs (q.z)) * (2. *\n           vec2 (Fbm2 (8. * (vec2 (0.4 * q.z, 0.) + flPth[k].xy)),\n           Fbm2 (8. * (vec2 (0.3 * q.z, 0.) + flPth[k].zw))) - 1.);\n        dh = min (dh, PrCylDf (q, 0.001, flshLen));\n      }\n    }\n    d = 0.7 * dh;\n  }\n  DMINQ (idSpk);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  q = p;\n  q.y -= 6. * torScl + 2.5 * wThk;\n  q.xz = Rot2D (q.xz, 2. * pi * aRotTor / nSegTor);\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (nSegTor * atan (q.z, - q.x) / (2. * pi)) +\n     0.5) / nSegTor));\n  return (length (vec2 (length (vec2 (abs (q.x) - rTor, q.y)) - 2.5 * torScl,\n     q.z * torzFac)) - 2. * torScl);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat FlmDens (vec3 p)\n{\n  float c;\n  c = max (0., 1.1 * BumpFbm3 (0.2 * vec3 (p.xy / flRad, p.z + 4. * tCur)) - 0.1 +\n     0.4 * smoothstep (-0.5 * flRad, 0.1 * flRad, p.z));\n  return c * (1. - smoothstep (-0.3 * flRad, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - 2. * flLen, 0.))) - flRad * (1. + 0.8 * p.z / (2. * flLen)))) *\n     smoothstep (0., flRad, p.z + 2. * flLen);\n}\n\nvec3 FlmCol (vec3 ro, vec3 rd, vec2 dCyl2, float dstObj)\n{   // from \"Cloud Computing\", with mods and color\n  vec4 col4;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 20.;\n  ds = min (2. * flRad, dCyl2.y - dCyl2.x) / sMax;\n  s = dCyl2.x;\n  ro.z -= flLen;\n  q = ro + s * rd;\n  r = length (q.xy) / flRad;\n  q.xy = Rot2D (q.xy, 0.5 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n  f = FlmDens (q);\n  col4 = vec4 (0.);\n  for (float j = float (VAR_ZERO); j < sMax; j ++) {\n    s += ds;\n    q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n    r = length (q.xy) / flRad;\n    q.xy = Rot2D (q.xy, 0.5 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n    fn = FlmDens (q);\n    c = mix (mix (vec3 (0.1, 0.3, 1.), vec3 (0., 0.8, 1.), clamp ((0.3 / ds) * (f - fn), 0., 1.)),\n       vec3 (1.), smoothstep (-0.5 * flRad, 0.5 * flRad, q.z)) *\n       (1. - smoothstep (-0.1, 0., s - dstObj));\n    col4 += (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n    f = fn;\n    if (s > dstObj || col4.a > 1.) break;\n  }\n  return clamp (col4.rgb, 0., 1.);\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{   // from \"Star Globe\"\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 5. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col, mDir, vn;\n  float mRad, bs, ts;\n  mDir = normalize (vec3 (0.03, 0.08, 1.));\n  mRad = 0.015;\n  col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n  bs = dot (rd, mDir);\n  ts = bs * bs - 1. + mRad * mRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - mDir) / mRad);\n      col += vec3 (1., 0.9, 0.5) * clamp (dot (normalize (vec3 (-0.9, 0.4, 0.5)), vn) *\n         (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.);\n    }\n  } else col += StarPat (rd, 16.);\n  return col;\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 sp, ss;\n  if (2. * floor (0.5 * floor (p.y)) != floor (p.y)) p.x += 0.5;\n  sp = smoothstep (0.03, 0.07, abs (fract (p + 0.5) - 0.5));\n  p = fract (p) - 0.5;\n  ss = 0.5 * smoothstep (0.4, 0.5, abs (p.xy)) * sign (p.xy);\n  if (abs (p.x) < abs (p.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sp.x * sp.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn)\n{\n  vec3 rg;\n  rg = ShStagGrid ((abs (vn.x) > 0.99) ? p.zy : ((abs (vn.y) > 0.99) ? p.zx : p.xy));\n  if (abs (vn.x) > 0.99) {\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4, a1, a2, b1, b2;\n  vec3 col, vn, roo, glCol, ltPos, ltDirL, stg, q;\n  vec2 vf, dCyl2, w;\n  float dstObj, dstTrObj, dstGrnd, s, att, nDotL, dSum, sSum, tLitCyc, t, tm, st, sp, f,\n     illTot, fBot, a;\n  bool inBldg, psgDir, isMet;\n  psgWd = 1.;\n  wThk = 0.05;\n  domeRd = psgWd + 0.18;\n  ringWd = 0.25;\n  psgLen = 4.;\n  psgHt = 0.75;\n  pcGap = 0.25;\n  oculRd = 0.28 * psgWd;\n  torScl = 0.04;\n  rTor = (80. / (2. * pi)) * torScl;\n  rTorEx = 5. * torScl;\n  nSegTor = 12.;\n  flRad = oculRd;\n  flLen = 30. * flRad;\n  t = 0.5 * tCur;\n  a1 = vec4 (0.1, 0.17, 0.15, 0.12);\n  a2 = vec4 (0.1, 0.5, -0.2, 0.2);\n  b1 = vec4 (0.8, 0.3, 0.5, 0.4);\n  b2 = vec4 (-1., 0.2, 0.3, -0.2);\n  for (int k = 0; k < 4; k ++) {\n    f = 0.1 * float (k);\n    flPth[k] = vec4 (4. + f + (1.5 + f) * t, sin ((0.11 + 0.1 * f) * t),\n       5. + 2. * f + (1.3 - f) * t, sin ((0.12 - 0.1 * f) * t));\n    for (int j = 0; j < 4; j ++) flPth[k][j] += (b1[j] + b2[j] * f) * sin (a1[j] + a2[j] * f * t);\n  }\n  tLitCyc = 50.;\n  t = 2. * pi * tCur / tLitCyc;\n  tm = mod (tCur / tLitCyc, 1.);\n  aRotTor = -1. * (0.01 * tLitCyc * t + 30. * (sin (t) - t));\n  torzFac = 0.8 + 0.2 * cos (t);\n  crExt = 0.05 * (-1. + sin (512. * tCur)) * SmoothBump (0.2, 0.8, 0.1, tm);\n  illTot = 0.;\n  for (int k = 0; k < 4; k ++) {\n    f = float (k);\n    illum[k] = step (torzFac, 0.95) * step (0.05, Noiseff (16. * tCur + f)) *\n       (0.3 + 0.7 * smoothstep (0.3, 0.9, Fbm1 (4. * tCur + f)));\n    illTot += illum[k];\n  }\n  st = mod (nSegTor * atan (ro.z, - ro.x) / (2. * pi) - aRotTor, 1.);\n  roo = ro;\n  glCol = mix (vec3 (0.9, 0.9, 0.3) * (0.97 + 0.03 * sin (64. * tCur)), vec3 (1., 1., 0.9),\n     SmoothBump (0.3, 0.7, 0.1, tm)) * (0.2 + 0.8 * SmoothBump (0.2, 0.8, 0.15, tm));\n  dstTrObj = TrObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    stg = vec3 (0.);\n    sp = length (vec2 (qHit.x, max (qHit.y, 0.))) - psgWd;\n    psgDir = (abs (ro.x) < abs (ro.z));\n    if (idObj == idDom) inBldg = (length (qHit) < domeRd);\n    else if (idObj == idDomB) inBldg = (sp < wThk || length (qHit.xz) < domeRd);\n    else if (idObj == idPsg) inBldg = (sp < 0.5 * wThk);\n    else if (idObj == idPilB) inBldg = (abs (qHit.x) < psgWd);\n    else if (idObj == idEnt) inBldg = (abs (qHit.z) < psgLen + 3.5 * wThk && sp < 0.);\n    else inBldg = true;\n    vf = vec2 (0.);\n    if (idObj == idDom) {\n      col4 = vec4 (0.7, 0.7, 0., 0.2) * (0.7 + 0.3 * step (0.5 * wThk,\n         abs (length (qHit) - domeRd)));\n    } else if (idObj == idDomB) {\n      if (qHit.y < 4. * ringWd + wThk) col4 = 0.7 * vec4 (0.8, 0.5, 0., 0.2);\n      else col4 = vec4 (0.8, 0.7, 0., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.05,\n         abs (mod (16. * qHit.y, 1.) - 0.5)));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idPsg) {\n      col4 = vec4 (0.8, 0.5, 0., 0.05);\n      if (abs (sp) < wThk + 0.005) {\n        col4 *= 0.7;\n        if (abs (qHit.y + psgHt) < psgHt) {\n          if (abs (sp) > wThk - 0.005) stg = ro;\n          else col4 *= 0.7;\n        } else if (inBldg) col4 *= 0.9 + 0.1 * step (0.1, mod (32. * atan (ro.y - 2. * psgHt,\n           (psgDir ? ro.x : ro.z)) / pi, 1.));\n      } else col4.a = 0.2;\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idPilB) {\n      col4 = vec4 (0.55, 0.55, 0.6, 0.2);\n      vf = vec2 (64., 1.);\n    } else if (idObj == idPil) {\n      col4 = vec4 (0.55, 0.55, 0.6, 0.2);\n      a = mod (32. * (atan (qHit.z, - qHit.x) / (2. * pi)), 1.);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a * a));\n      vf = vec2 (128., 0.25);\n    } else if (idObj == idEnt) {\n      if (abs (abs (qHit.y + psgHt) - psgHt) < 0.5 * wThk) col4 = vec4 (0.5, 0.5, 0.6, 0.2);\n      else {\n        col4 = 0.7 * vec4 (0.8, 0.5, 0., 0.2);\n        if (abs (qHit.y + psgHt) < psgHt - 0.02) stg = ro;\n      }\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idFlor) {\n      col4 = vec4 (0.2, 0.2, 0.22, 0.1);\n      if (qHit.z > psgWd - 0.305) stg = vec3 ((psgDir ? ro.zx : ro.xz), ro.y).xzy;\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idSpkEx) {\n      col4 = mix (vec4 (0.5, 0.5, 0.6, 0.2), vec4 (0.8, 0.8, 0.2, -1.), step (0.05, illTot));\n    } else if (idObj == idTorL) {\n      col4 = vec4 (0.45, 0.5, 0.45, 0.2);\n      if (ro.y > 0.17) col4 *= (0.9 + 0.1 * sin (256. * atan (ro.z, - ro.x)));\n      else col4 *= (0.8 + 0.2 * sin (512. * ro.y));\n    } else if (idObj == idTorR) {\n      col4 = mix (vec4 (0.7, 0.7, 0., 0.), vec4 (1., 1., 1., 0.), 0.5 + 0.5 * sin (t)) *\n         (0.4 + 0.6 * SmoothBump (0.35, 0.65, 0.05, st * torzFac));\n    } else if (idObj == idTorC) {\n      col4 = mix (vec4 (0.6, 0.5, 0.5, 0.), mix (vec4 (1., 0., 0., 0.), vec4 (1., 1., 1., 0.),\n         0.5 + 0.5 * cos (t)), SmoothBump (0.25, 0.75, 0.1, st));\n    } else if (idObj == idTorS) {\n      col4 = vec4 (0.7, 0.6, 0.6, 0.) * (0.9 + 0.1 * sin (128. * atan (qHit.z, - qHit.y)));\n    } else if (idObj == idSpk) {\n      col4 = vec4 (vec3 (1., 1., 0.9) * clamp (2. * (0.1 + 0.9 * illTot) *\n         (1. - 0.3 * Fbm1 (5. * qHit.z)) - 0.2, 0., 1.), -1.);\n    } else {\n      col4 = vec4 (1., 1., 0., 0.2);\n    }\n    if (stg != vec3 (0.)) {\n      rg4 = ShStagGrid3d (10. * stg, vn);\n      vn = rg4.xyz;\n      col4.rgb *= 0.8 + 0.2 * rg4.w;\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (inBldg) {\n        dSum = 0.;\n        sSum = 0.;\n        for (int k = 0; k < 7; k ++) {\n          if (k < 6) {\n            ltPos = vec3 (0., 0.5 * psgHt, 0.8 * rTor);\n            ltPos.xz = Rot2D (ltPos.xz, 2. * pi * (- aRotTor + float (k) / 6.));\n            ltDirL = normalize (ltPos);\n            s = length (ltPos - ro);\n            att = 0.6 * max (dot (ltDirL, ltPos - ro) / s, 0.) / (1. + 0.1 * s * s);\n          } else {\n            ltDirL = - ltDir;\n            att = 0.5;\n          }\n          isMet = (idObj == idTorL || idObj == idTorR || idObj == idSpkEx);\n          nDotL = max (dot (vn, ltDirL), 0.);\n          if (isMet) nDotL *= nDotL;\n          dSum += att * nDotL;\n          sSum += att * pow (max (dot (normalize (ltDirL - rd), vn), 0.), 16.);\n        }\n        col = col4.rgb * (0.1 + 0.5 * dSum) + 0.5 * col4.a * sSum;\n        col = mix (col, vec3 (0.3, 0.3, 1.), 0.1 * (1. - smoothstep (0.7, 0.95, torzFac)));\n        if (idObj == idTorC || idObj == idTorS) col.r += ((idObj == idTorC) ? 0.5 : 0.2) *\n           max (- dot (rd, vn), 0.) * SmoothBump (0.3, 0.7, 0.1, tm);\n        if (idObj == idFlor || idObj == idDom) {\n          w = Rot2D (ro.xz, 2. * pi * aRotTor / nSegTor);\n          w = vec2 (abs (dot (w, sin (2. * pi * (floor (nSegTor * atan (w.y, - w.x) / (2. * pi)) +\n             0.5) / nSegTor + vec2 (0., 0.5 * pi)))), 0.5 * abs (length (ro.xz) - rTor - 0.1));\n          col += 0.2 * glCol * (1. - smoothstep (0.03, 0.12, length (w)));\n        }\n      } else {\n        col = col4.rgb * (0.2 + 0.4 * max (dot (vn, ltDir), 0.)) +\n           col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      }\n    } else col = col4.rgb * (0.6 + 0.4 * max (- dot (rd, vn), 0.));\n  } else {\n    dstGrnd = - ro.y / rd.y;\n    if (rd.y < 0. && dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      psgDir = (abs (ro.x) < abs (ro.z));\n      f = smoothstep (0.1, 1., dstGrnd / dstFar);\n      col = vec3 (0.05, 0.07, 0.05) * (0.7 + 0.3 * Fbm2 (8. * ro.xz)) * (1. - f);\n      s = length (vec2 (abs (psgDir ? ro.xz : ro.zx) - vec2 (0., psgLen + 4. * wThk)));\n      col += (1. - smoothstep (-0.3, 0., s - 0.8 * psgWd)) * vec3 (0.2, 0.2, 0.3);\n      dstObj = dstGrnd;\n    } else {\n      f = 1.;\n      col = vec3 (0.);\n    }\n    col = mix (col, SkyCol (rd), f);\n  }\n  dstObj = min (dstObj, dstFar);\n  if (dstTrObj < dstObj) col += glCol * smoothstep (0., 0.1, dstObj - dstTrObj) *\n     (0.05 + 0.4 * clamp (- dot (TrObjNf (roo + dstTrObj * rd), rd), 0., 1.));\n  f = 1. - smoothstep (0.7, 0.95, torzFac);\n  if (f > 0.) {\n    ro = roo;\n    ro.yz = Rot2D (ro.yz, -0.5 * pi);\n    rd.yz = Rot2D (rd.yz, -0.5 * pi);\n    fBot = flLen - flRad + 0.4;\n    ro.z += fBot;\n    dCyl2 = CapsHit (ro, rd, flRad, flLen);\n    if (inBldg && col4.a >= 0.) col = clamp (col * vec3 (1. - 0.2 * f, 1. + 0.2 * f,\n       1. + 0.3 * f), 0., 1.);\n    if (dCyl2.x < dstObj && ro.z + dCyl2.x * rd.z < fBot - 0.1)\n       col += 3. * f * FlmCol (ro, rd, dCyl2, dstObj);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, s, t, sr;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./7.) * vec2 (asp, 1.);\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., -1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (-1., -1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  if (regId > 0. && (vuId == 0. || vuId == regId)) vuId = regId - vuId;\n  vuMode = int (vuId) + 1;\n  if (vuMode == 1) {\n    t = mod (tCur / 30., 1.);\n    s = SmoothBump (0.25, 0.75, 0.2, t) - 0.5;\n    ro = vec3 (1.6 * sign (t - 0.5) * (0.5 - abs (s)), 1., 8. * s);\n    vd = normalize (vec3 (0., 0.5, 0.) - ro);\n    az = atan (vd.x, vd.z);\n    el = asin (vd.y);\n    if (t > 0.5) el += 0.35 * pi * (1. - smoothstep (0.05, 0.12, abs (abs (t - 0.5) - 0.25)));\n    zmFac = 3.;\n  } else if (vuMode == 2) {\n    az = 0.;\n    el = -0.05 * pi;\n    ro = vec3 (0., 1., -1.5);\n    zmFac = 1.5;\n  } else if (vuMode == 3) {\n    az = 0.02 * pi;\n    el = -0.05 * pi;\n    ro = vec3 (0., 1.5, -20.);\n    zmFac = 6.;\n  }\n  if (mPtr.z > 0.) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.35 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  if (vuMode == 3) {\n    ro = vuMat * ro;\n    ro.y = max (0.5, ro.y);\n  }\n  dstFar = 60.;\n  ltDir = normalize (vec3 (0., 1., 0.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 2.) col = vec3 (0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{  // variation of triangular noise in \"Misty Flight\", adapted from nimitz's \"Oblivion\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tttyzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGBzd", "name": "hoeled_rainbow", "author": "hoeled", "description": "The Book of Shaders exercise \"Try to make a rainbow\"", "tags": ["rainbow"], "likes": 3, "viewed": 56, "date": "1607718983", "time_retrieved": "2024-06-20T20:26:34.894050", "image_code": "float Cloud(vec2 uv, float size, float aa, float time, float flip, float random) {\n    uv *= 1.2;\n    uv.y -= .34;\n    uv.x += 1.18;\n    if (flip > 0.) {\n        uv.x -= fract(iTime*.05*time)*2.9;\n    } else {\n        uv.x += fract(iTime*.05*time)*2.9;\n    }\n    \n    uv.y += cos(iTime*time)*.06+.1;\n    float cloud;\n    for(float i = .1; i<.9; i+=.1) {\n        float randomX = fract(548.546*i*random)*.48+sin(iTime)*.027;\n        float randomY = fract(124.786*i*.355)*.25+sin(iTime*.5)*.077;\n        float d = length(vec2(uv.x+randomX, uv.y+randomY));\n        cloud += smoothstep(size/4.+aa+randomX*.2, size/4.+randomX*.2, d)*2.;\n    }\n    return cloud;\n}\n\nvec3 Rainbow(vec2 uv, vec3 bg, float aa) {\n    float d = length(vec2(uv.x, uv.y+.5));\n\n    float red = smoothstep(.9+aa, .9, d);\n    red -= smoothstep(.85+aa, .85, d);\n    \n    float orange = smoothstep(.85+aa, .85, d);\n    orange -= smoothstep(.8+aa, .8, d);\n    \n    float yellow = smoothstep(.8+aa, .8, d);\n    yellow -= smoothstep(.75+aa, .75, d);\n    \n    float green = smoothstep(.75+aa, .75, d);\n    green -= smoothstep(.7+aa, .7, d);\n    \n    float turquoise = smoothstep(.7+aa, .7, d);\n    turquoise -= smoothstep(.65+aa, .65, d);\n    \n    float blue = smoothstep(.65+aa, .65, d);\n    blue -= smoothstep(.6+aa, .6, d);\n    \n    float purple = smoothstep(.6+aa, .6, d);\n    purple -= smoothstep(.55+aa, .55, d);\n    \n    vec3 rainbow;\n    rainbow = red * vec3(1., 0., 0.) - bg * red;\n    rainbow += orange * vec3(7., .6, 0.) - bg * orange;\n    rainbow += yellow * vec3(1., 1., 0.) - bg * yellow;\n    rainbow += green * vec3(0., 1., 0.) - bg * green;\n    rainbow += turquoise * vec3(0., .8, 1.) - bg * turquoise;\n    rainbow += blue * vec3(0., .27, 1.) - bg * blue;\n    //rainbow += purple * vec3(.6, .0, 1.) - bg * purple;\n    \n    return rainbow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float aa = 1.5 / iResolution.y;\n    \n    uv *= 1. - uv * sin(iTime*.3) *.05;\n    \n    float bmod = sin(iTime)*.3+.3;\n    vec3 bg = mix(vec3(0.5, 0.5, 1.), vec3(0.0, 0.0, .9-bmod), uv.y+.15);\n    vec3 col = bg;\n\n    col += Cloud(uv, .3, aa, .7, 1., .687);\n    \n    /*uv.y *= 1.5;\n    uv.x = -uv.x;\n    uv.x -= 2.4;\n    float cloudBack = Cloud(vec2(uv.x, uv.y-.1), .31, aa, 0.23, -1., .431);\n    uv.x = -uv.x;\n    uv.x -= 2.4;\n    uv.y /= 1.5;*/\n    \n    uv.x -= .6;\n    uv.y -= .07;\n    uv.y += sin(iTime*.5)*.02;\n    float ground1 = smoothstep(2.+aa, 2., length(vec2(uv.x+.3, uv.y+2.35)));\n    \n    uv.x += .6;\n    uv.y += .07;\n    \n    uv.y -= sin(iTime*.5)*.02;\n    uv.y -= cos(iTime*.3)*.02;\n    vec3 rainbow = Rainbow(uv, bg, aa);\n    col += rainbow;\n    \n    //float rainb = clamp(rainbow.r, .0, 1.) + clamp(rainbow.g, .0, 1.) + clamp(rainbow.b, .0, 1.);\n    //rainb *= 1000.;\n    //cloudBack = cloudBack - rainb;\n    //col += clamp(cloudBack, .0, .5);\n    \n    uv.y +=.0;\n    uv.y += cos(iTime*.3)*.02;\n    uv.y += cos(iTime*.3)*.02;\n    float ground2 = smoothstep(4.+aa, 4., length(vec2(uv.x, uv.y+4.35)));\n    \n    ground1 *= ground1 - ground2;\n    col = clamp(col, 0., 1.);\n    ground1 += rainbow.r + rainbow.g + rainbow.b * 20.;\n    ground1 *= 1.-step(-.2, uv.y);\n    \n    float g1 = clamp(ground1, 0., 1.);\n    col -= g1 * vec3(.35, .02, .85);\n    col *= clamp(vec3(1., 1., 1.) * (1.-ground2), 0., 1.);\n    col += clamp(vec3(1., 1., 1.) * ground2, 0., 1.)*vec3(.1, .55, .1);\n    \n    col.r += sin(iTime*.76)*.2;\n    col.b += sin(iTime*.14)*.1;\n    col.rg += .1;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGfRw", "name": "Reflections test1", "author": "lousisx", "description": "Reflections test for future 2d patterns", "tags": ["2d", "reflection"], "likes": 4, "viewed": 188, "date": "1607613390", "time_retrieved": "2024-06-20T20:26:34.894050", "image_code": "#define PI 3.1415\n#define TWO_PI 6.2831\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\nfloat sdLine (in vec2 p, in vec2 a, in vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length (pa-ba*h);\n}\nvec2 ref (vec2 p, vec2 v){   //reflection\n    return p - v * (1.*dot(p,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tuv *= 2.;      //zoom\n    float di = 3.; //reflections number\n    vec2 v;\n    vec2 rf;\n    \n    //circle center\n    vec2 p = vec2(sin(iTime*5.),cos(iTime*4.));\n    \n    //draw circle\n    vec3 col = 1.- vec3(vec2(smoothstep(sdCircle(uv-p ,0.1),0.0,0.01)),1.); \n    \n    for(float i; i<di; i++){\n    \tv = 1.5*vec2(sin(PI/di*i),cos(PI/di*i));//vector\n        rf  = ref(p,v );\t\t\t\t\t\t//reflection\n        //draw\n        col +=1.- vec3(smoothstep(sdCircle(uv-rf,0.1),0.0,0.01));\n    \tcol += vec3(step(sdLine(uv,v ,-v ),.01));\n        \n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGfW1", "name": "Ocean Sunrise", "author": "Dragonpeak", "description": "A sun rising over an ocean. an experiment with reflection and refraction.", "tags": ["raymarching", "noise", "sea", "ocean", "sunrise"], "likes": 3, "viewed": 258, "date": "1607080748", "time_retrieved": "2024-06-20T20:26:35.851650", "image_code": "const float FAR = 50.;\nvec3 CAMERA_POS = vec3(-0.4, 0.87, .3);\nvec3 CAMERA_LOOK = vec3(0.,-0.3,0.2);\nvec2 WIND = vec2(0.2, -0.1);\nconst float EPS = 0.002;\nconst int OCEAN_OCT = 12;\nconst int CLOUD_OCT = 6;\nconst vec3 SUN = normalize(vec3(0.3, -0.4, .01));\nconst vec3 SUN_C = vec3(0.8, 0.6, 0.4)*3.7;\n\nvec3 ray_direction(float fov, vec2 size, vec2 coord) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec2 hash( vec2 p ) // uses a texture, causes some artifacting but it is not to noticable in this shader\n{\n    return texture(iChannel0, p*0.01).xy;\n\n}\n\nfloat noise( in vec2 p )\n{\n    //from https://www.shadertoy.com/view/Msf3WH\n   \n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    //return hash(i).x;\n    return dot( n, vec3(70.0) );\n}\nfloat ocean_height(vec2 p) // ridged fbm(using abs noise)\n{\n    float sc = .15;\n    float am = .4;\n    float n = 0.;\n    for(int i = 0; i < OCEAN_OCT; i++)\n    {\n\t\tn += -abs(noise(p*sc+float(i)+WIND*iTime))*am;\n        float cs = cos(float(i)*0.3);\n\t\tfloat sn = sin(float(i)*0.3);\n        p = vec2(p.x * cs - p.y * sn, p.x * sn + p.y * cs);\n        sc *= 1.45;\n        am *= 0.6;\n    }\n\treturn n;\n}\nvec3 ocean_nrm(vec2 p)\n{\n    //from https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\n    return normalize( vec3( ocean_height(vec2(p.x-EPS,p.y)) - ocean_height(vec2(p.x+EPS,p.y)),\n                           ocean_height(vec2(p.x,p.y-EPS)) - ocean_height(vec2(p.x,p.y+EPS)),\n                            2.0f*EPS) );\n}\nvec3 fresnel(float cosTheta, vec3 F0)\n{\n    //from https://learnopengl.com/PBR/Theory\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat cloud_d(vec3 p)// fbm for  clouds\n{\n\tvec2 cloud_p = p.xy/p.z*.4;\n    float sc = .3;\n    float am = .8;\n    float n = 0.;\n    for(int i = 0; i < OCEAN_OCT; i++)\n    {\n\t\tn += noise(cloud_p*sc+float(i)+WIND*0.5*iTime)*am;\n        float cs = cos(float(i)*0.3);\n\t\tfloat sn = sin(float(i)*0.3);\n        cloud_p = vec2(cloud_p.x * cs - cloud_p.y * sn, cloud_p.x * sn + cloud_p.y * cs);\n        sc *= 1.3;\n        am *= 0.73;\n    }\n    return n+.3;\n}\nvec3 shade_sky(vec3 p, bool c)\n{\n    p = normalize(p);\n\tvec3 col = mix(vec3(0.6, 0.6, 0.85), vec3(0.55, 0.55, 0.85), p.z)*1.4;//sky\n    col = mix(vec3(0.8, 0.5, 0.54), col, clamp(p.z+0.4, 0., 1.))*0.8;//pink band\n    float sun = dot(p, SUN);//sun dot\n    col = mix(col, SUN_C, min(max(sun-.996, 0.)*500., 1.));//sun colour\n    if(c && p.z>0.) // use clouds, lighted with effectivly single step ray march\n    {\n        float cl = cloud_d(p);//clouds\n        float cl2 = cloud_d(p-SUN*0.3);//clouds offset\n        float l = cl-cl2;//clouds lighting estimate\n\n        vec3 ccol = mix(vec3(0.65, 0.7, 0.7)*SUN_C, vec3(0.4), l-min(max(sun-.8, 0.)*11., 1.))*0.6;//cloud col\n\n        col = mix(col, ccol, clamp(cl, 0., 1.)*0.6);\n    }\n    //col = vec3(l);\n\treturn col*vec3(0.9, 1.,1.);\n}\n\n\nvec3 shade_ocean(vec3 p, vec3 dir, float h)\n{\n    \n    \n    vec3 col = vec3(0.2, 0.2, 0.7)*0.4;//base_col\n    vec3 nrm = ocean_nrm(p.xy);\n    vec3 refr = refract(dir, nrm, 1.03);//refraction ray\n    float fr = fresnel(dot(dir, nrm), vec3(1.055)).x;//fresnel\n    vec3 ref = reflect(nrm, dir);//reflection ray\n    vec3 rrc = mix(col, shade_sky(p+refr, false)*0.9, clamp(refr.z+0.8, 0., 1.));//refraction ray, uses sky or if low the base col\n    vec3 rc = shade_sky(p+ref, true)*0.96; // reflection col, using sky\n    col = mix(rrc, rc, fr);//mix reflection and refraction by fresnel\n    float f = min(max(h+.16, 0.)*20., 1.)*nrm.z*0.6;//foam on highest points\n    vec3 fc = vec3(.75)+SUN_C*clamp(dot(SUN, nrm), 0., 1.); //foam col, simple diffuse shading\n    col = mix(col, fc, f);\n\treturn col*vec3(1., 0.9, 0.9);\n}\n\n\nvec2 march_ocean(vec3 p, vec3 d)\n{\n    float dep = 0.;\n    float h = 0.;\n    float eps = EPS;\n    while(dep < FAR)\n    {\n        vec3 pos = p + d * dep;\n        h = ocean_height(pos.xy);\n\t\tfloat dist = pos.z-h;\n        if(dist < eps)\n        {\n\t\t\treturn vec2(dep, h);\n        }\n        eps *= 1.15;//relax eps after each step\n\t\tdep += dist;\n        \n    }\n    return vec2(FAR, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAMERA_POS.z += sin(iTime*0.1)*0.4;\n    CAMERA_LOOK.z += sin(iTime*0.1)*0.1;//camera anim\n    vec3 local_dir = ray_direction(85., iResolution.xy, fragCoord);\n    \n    mat4 view = view_matrix(CAMERA_POS, CAMERA_LOOK, vec3(0.,0.,1.));\n    vec3 dir = (view * vec4(local_dir, 0.)).xyz;\n    vec2 o = march_ocean(CAMERA_POS, dir);\n    float dep = o.x;\n    vec3 pos = CAMERA_POS + dir * dep;\n    \n    vec3 col = shade_sky(dir, false); //sky w/out clouds, for mist \n    if(dep < FAR)\n    {\n\t\tcol = mix(shade_ocean(pos, dir, o.y), col, dep/FAR);\n    }\n    else\n    {\n\t\tcol = shade_sky(dir, true);//sky w, clouds for view\n    }\n    // Output to screen\n \t//col = vec3(noise(fragCoord*0.06));\n    col *= vec3(1.19, .9, 1.14)*0.7;//colour correct\n    fragColor = vec4(pow(col, vec3(1./2.1)),1.0);//gamma and out\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdGfzt", "name": "[TWITCH] Surprise!", "author": "Flopine", "description": "A smol isometric doodle I did during a twitch live. You can watch VODs here: https://www.twitch.tv/flopine", "tags": ["3d", "raymarching", "isometric", "twitch", "animration"], "likes": 15, "viewed": 195, "date": "1607683292", "time_retrieved": "2024-06-20T20:26:36.373018", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define TAU 6.283183\n#define PI acos(-1.)\n#define ITER 64. \n\n#define dt(sp,off) fract((iTime+off)*sp)\n#define easeout(s,of) easeOutExpo(abs(-1.+2.*dt(s,of)))\n#define sw(sp,of,n) floor(dt(sp*(1./n),of)*n)\n#define bouncy(s,of) sqrt(abs(sin(dt(s,of)*TAU)))\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(puv,c,l) puv=(puv-c*clamp(round(puv/c),-l,l))\n#define pal(t,c,d) (vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+d)))\n\n#define od(puv,d) (dot(puv,normalize(sign(puv)))-d)\n#define sphe(puv,d) (length(puv)-d) \n\n\nfloat easeOutExpo (float x)\n{return x == 1. ? 1. : 1. - exp2(-10. * x);}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat candy; vec2 cid;\nfloat SDF (vec3 p)\n{\n  p.yz *= rot(-atan(1./sqrt(2.)));\n  p.xz *= rot(PI/4.);\n  \n  int choose = int(sw(0.3,-1.5,3.));\n  vec2 per = vec2(1.9);\n  \n  vec3 ppp = p;\n  cid=round(ppp.xy/per); \n  crep(ppp.xy,per,3.);\n  if (choose == 0) candy = od(ppp,0.3);\n  else if (choose == 1) candy = sphe(ppp,0.3);\n  else candy = mix(od(ppp,0.3),box(ppp,vec3(.4)), 0.5);\n  \n  vec2 id = round(p.xy/per);\n  p.z = abs(p.z)-mix(0.0,4.,clamp(easeout(0.3,length(id*0.08))*2.-1.,0.001,1.));\n\n vec3 pp = p; \n crep(p.xy,per,3.);\n float d = max(dot(pp,normalize(vec3(0.,0.,-1.))),abs(mix(od(p,0.5),box(p,vec3(.6)), 0.5))-0.04);\n\n  return min(d,candy);\n}\n\nvec3 getnorm (vec3 p, vec2 eps)\n{return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(uv*8.,-100.), \n  rd=vec3(0.,0.,1.), \n  p=ro, \n  col=vec3(0.0,0.,0.015), \n  l=vec3(1.,-1.5,-2.);\n\n  bool hit = false; float d=0.;\n  for (float i=0.; i<ITER; i++)\n  {\n    d = SDF(p);\n    if (d<0.01)\n    {\n      hit = true;\n      break;\n    }\n    p += d*rd*0.55;\n  }\n\n  if (hit)\n  {\n    if (d==candy) col = pal(length(cid),vec3(0.5),vec3(.0,0.63,0.37)) ;\n    else col = vec3(1.);\n    vec3 n = getnorm(p,vec2(0.01,0.));\n    float light = max(dot(n,normalize(l)),0.);\n    col *= mix(vec3(0.3,0.1,0.05),vec3(0.9,0.7,0.2),light);\n  }\n  fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKBR3", "name": "Snowy Landscape - Andrew", "author": "andrew741", "description": "Snowy hills and dynamic moon lighting!", "tags": ["snowylandscape"], "likes": 4, "viewed": 79, "date": "1607751553", "time_retrieved": "2024-06-20T20:26:36.379100", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.xy;\n    float time = iTime + iMouse.x / 125.;\n    vec2 NfragCoord = floor(uv * 450.);\n    \n    float terrainHeight = (sin((uv.x + time / 4.) * 4.) / 4. + 0.5) - uv.y;\n    float terrainCut = clamp(round(terrainHeight), 0., 1.);\n    \n    vec2 posForRand = vec2(floor((NfragCoord.y + time * 300.) / 10.), floor((NfragCoord.x - time * 200. + floor(NfragCoord.y / 1.25)) / 2.));\n    float Frandom = rand(posForRand + 1234.5);\n    float random = rand(posForRand);\n    float Frain = Frandom * Frandom * Frandom * Frandom * Frandom;\n    float rain = random * random * random * random * random;\n    float Frain_cut = 1. - clamp(round(Frain * .55), 0., 2.);\n    float rain_cut = 1. - clamp(round(rain * .7), 0., 2.);\n    \n    float lighting = length(uv.xy - 0.9) * 1.45;\n    lighting = max(lighting, 0.9);\n    lighting -= (uv.y  * terrainCut) / 1.5;\n    \n    float lightingColMask = length(uv.xy - 0.5) - 3.;\n    lightingColMask = clamp(round(lightingColMask), 0., 1.);\n    lightingColMask += (uv.y * terrainCut) * 1.25;\n    \n    vec3 otherSnowColor = vec3(0.85) * terrainCut + .9 * (1. - terrainCut);\n    vec3 snowColor = otherSnowColor * (1. - Frain_cut);\n    \n    vec3 col = vec3(0.8);\n    col = col * rain_cut + 0.9 * (1. - rain_cut);\n    col = col * (1. - terrainCut) + (0.95 * (uv.y + 0.92)) * terrainCut;\n    col = col * Frain_cut + snowColor;\n    col /= lighting;\n    col *= lightingColMask + vec3(0.673, 0.673, 0.96) * (1. - lightingColMask);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKBRG", "name": "Simple 3D Points", "author": "ArunJangir", "description": "Lets start with 3d", "tags": ["3d"], "likes": 2, "viewed": 71, "date": "1607659808", "time_retrieved": "2024-06-20T20:26:36.379100", "image_code": "float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = vec3(0.);\n    \n    vec3 ro =  vec3(0,0,1);\n    vec3 rd =  normalize(vec3(uv.x,uv.y,0)-ro);\n    vec3 point;\n    float distance;\n    for(float i = 0.; i < 200.; i++){\n    point  = vec3 (1.0*cos(0.05*i*iTime),1.0*sin(0.05*i*iTime),-0.05*i);\n    distance = length(cross(point-ro,rd))/length(rd);\n    distance = smoothstep(0.15,0.0,distance);\n    col += distance;\n    }/*\n    point  = vec3 (1.0*cos(iTime),1.0*sin(iTime),-2);\n    distance = length(cross(point-ro,rd))/length(rd);\n    distance = smoothstep(0.15,0.0,distance);\n    col+=distance;\n    \n    point  = vec3 (0.5+1.0*cos(2.*iTime),0.5+sin(2.*iTime),-3);\n    distance = length(cross(point-ro,rd))/length(rd);\n    distance = smoothstep(0.15,0.0,distance);\n    \n    \n    col += distance;\n    */\n    \n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKBRt", "name": "2 point light  & quadratic cube", "author": "CY5", "description": "2 point light source and quadratic cube", "tags": ["pointlight", "quadraticcube"], "likes": 4, "viewed": 98, "date": "1607793473", "time_retrieved": "2024-06-20T20:26:36.379100", "image_code": "// RayMarching lookup angles,plane,sphere map and rand \n// in below src code taken from iq shadertoy demo\n \n\n//2 point light source demo  c = c0+1/(kc+kl*d+kq*d*d)\n// and quadratic cube\n#define PT   1\n#define SPH  2\n#define PLN  3\n#define CUBE 4\n\n\nvec3  ptLight1Col = vec3(0.764,0.413,0.294);//cyan\nvec3  ptLight2Col = vec3(0.464,0.213,0.294);//magento\n\nvec2 randState;\n\nfloat rand()\n{\n   randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n   randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);        \n    \n   return randState.x;\n}\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 col;\n};\n\nstruct Ob\n{\n    float t;\n    vec3  c;\n    PointLight  ptL; \n    int prop;\n};\n\nfloat mapPlane(vec3 p)\n{\n    float r = 0.5;\n    float l = p.y + (r);\n    return l;\n}\nfloat quadEq(float t)\n{\n    return 1.2*t*t+1.0*t+0.01;\n}\nfloat mapCube(vec3 p, float r)\n{\n    //p=p-vec3(0.5,0.47,2.0);\n    p = p - vec3(0.5,0.47,0.5);\n    vec3 t = vec3(quadEq(p.x),quadEq(p.y),quadEq(p.z));\n    return length(t)-r;\n}\nOb map(vec3 p)\n{\n    Ob o; \n    float tme = iTime*0.5;\n    vec3 pt2 = vec3(0.9*cos(tme),-0.3*sin(tme/2.0),0.8*sin(tme));\n    vec3 pt1 = vec3(0.9*sin(tme),-0.3*sin(tme/2.0),0.8*cos(tme));\n    \n    vec3 mov = p-pt1;\n    vec3 mov1 =  p-pt2;\n    float sph= length(p-vec3(0.0,0.0,0.1))-0.25;\n    float p1 = length(mov)-0.02;\n    float p2 =  length(mov1)-0.02;\n    float pl = mapPlane(p);\n    float cb = mapCube(p,0.25);\n    o.t = min(min(sph,pl),cb);\n    o.t = min(min(p1,p2),o.t);\n    \n    o.ptL.pos = min(mov,mov1);\n    vec3 A= ptLight2Col*(1.0-p2)+ptLight1Col*p2;\n    vec3 B= ptLight1Col*(1.0-p1)+ptLight2Col*p1;\n    \n    o.ptL.col = mix(A,B,0.5);\n    \n    /*vec3 mn = normalize(o.ptL.pos);\n    vec3 dirPt = normalize(pt2 - pt1);\n    float an = dot(mn, dirPt);\n    vec3 A= ptLight1Col;\n    vec3 B= ptLight2Col;\n    o.ptL.col = mix(A,B,an);*/\n    \n    if (sph < pl && sph < cb)\n    {\n        o.c = vec3(0.1,0.1,0.2);\n        o.prop = SPH;\n    \n    }\n    else if (pl < sph && pl < cb)\n    {\n        o.c = vec3(0.1,0.2,0.1);\n        o.prop = PLN;\n    }\n    else if (cb < sph && cb < pl)\n    {\n        o.c = vec3(0.8,0.2,0.5);\n        o.prop = CUBE;\n    }\n    if (p1 < sph && p1 < pl && p1 < cb && p1 < p2)\n    {\n        o.c = ptLight1Col;\n        o.prop = PT;\n        \n    }\n    else if (p2 < sph && p2 < pl  && p2 < cb &&  p2 < p1)\n    {\n        o.c = ptLight2Col;\n        o.prop = PT;\n    }\n    return o;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(map(pos+e.xyy).t-map(pos-e.xyy).t,\n                          map(pos+e.yxy).t-map(pos-e.yxy).t,\n                          map(pos+e.yyx).t-map(pos-e.yyx).t));\n}\n\n\nvoid castRay(in vec3 ro, vec3 rd,inout Ob o)\n{\n    float t =0.0;\n    for(int i=0;i<100;i++)\n    {\n        vec3 pos = ro+t*rd;\n        o = map(pos);\n        float h = o.t;\n        if (h<0.001)\n            break;\n        t+=h;\n        if (t>20.0) break;\n    }\n    if (t>20.0) t=-0.1;\n    o.t =t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    randState = (2.0*fragCoord-iResolution.xy)/iResolution.y ;\n    /*float an = 10.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(2.0*cos(an),-0.3,2.0*sin(an));*/\n    \n    float an = 10.0*fract(0.05*iTime)+iMouse.x/iResolution.x;\n    float up = cos(iTime)-an;\n    vec3 ro = vec3(2.0*cos(an),-0.3*up,2.0*sin(an));\n    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n                        \n    vec3 rd = normalize(p.x*uu+p.y*vv+1.5*ww);\n    \n    vec3 col = vec3(0.0)-0.7*rd.y;\n    \n    Ob o;\n    castRay(ro, rd,o);\n    if (o.t > 0.0) \n    {\n        vec3 pos = ro + o.t*rd;\n        \n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = o.c;\n        nor +=normalize(vec3(0.0,0.0,0.5));\n        vec3 sun_light = (o.ptL.pos);\n        float sun_shad = step(o.t,0.0);\n        \n        float kc=0.3, kl=0.3,kq = 0.03;\n        \n        float d = length(sun_light);\n        vec3 oc = o.ptL.col;\n\n        if (o.prop == SPH)\n        {\n            \n            mate  += ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n            float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n            float boun_dif = clamp(0.9-0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n            \n            col = mate*sun_dif*sun_shad;   \n            col +=mate*sky_dif;    \n            col +=mate*boun_dif; \n        }\n        else if (o.prop == PLN)\n        {\n            mate = ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n            float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n            float boun_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n            col = mate*sun_dif*sun_shad;   \n            col +=mate*sky_dif;    \n            col +=mate*boun_dif;\n        }\n        else if (o.prop == CUBE)\n        {\n            mate = ((1.0/(kc+kl*d+kq*d*d))*oc) ;\n            float sun_dif = clamp(dot(nor,sun_light),0.0,1.0);\n            float sky_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n            float boun_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n\n            col = mate*sun_dif*sun_shad;   \n            col +=mate*sky_dif;    \n            col +=mate*boun_dif;\n        }\n        else if (o.prop == PT)\n        {\n        \n            vec3 sun_light = o.ptL.pos;\n            \n            float d = length(sun_light-pos);\n            \n            mate += ((1.0/(kc+kl*d+kq*d*d))*o.ptL.col);\n            col = mate;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKBWw", "name": "Looping morphing animation", "author": "carl_vbn", "description": "A rotating square becoming a holdout circle. A simple shader but I really like it. It could be used as screensaver or something.", "tags": ["2d", "colors", "loop", "morphing"], "likes": 0, "viewed": 47, "date": "1607285539", "time_retrieved": "2024-06-20T20:26:36.379100", "image_code": "vec2 rotateUV(vec2 uv, float angle) { \n    float u = cos(angle) * uv.x + -sin(angle) * uv.y; \n    float v = sin(angle) * uv.x + cos(angle) * uv.y; \n    \n    return vec2(u,v); \n} \n\n  \n\nvec3 hsv2rgb(vec3 c) { \n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); \n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); \n\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); \n\n} \n\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 uv = (fragCoord/iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0); \n    uv = rotateUV(uv, iTime); \n\n    float squaritude = sin(iTime) * 0.5 + 0.5; \n    float cd = 1.0/length(uv); \n    float sqd = abs(uv.x) + abs(uv.y); \n    \n\n    if (cd+(sqd-cd)*squaritude < 1.0) \n        fragColor = vec4(hsv2rgb(vec3(squaritude,1.0,1.0)), 1.0); \n    else \n        fragColor = vec4(0.0); \n\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKBzm", "name": "Retro_80's_lopo", "author": "lopoisaac", "description": "Experiments while learning GLSL...", "tags": ["80s", "retro"], "likes": 2, "viewed": 63, "date": "1606908812", "time_retrieved": "2024-06-20T20:26:36.906265", "image_code": "// About the shader:\n// There are 4 parts: the sun, sun glow, horizontal lines and vertical lines\n// \n// 2 effects added: pixelation and chromatic aberration\n// \n// I just started learning GLSL so this is a messy experiment\n//\n// Feel free to leave any comment with critiques, ways to improve, etc, \n// I'll really apreciate it! :)\n// \n// Twitter @lopoisaac\n\nfloat vertical_mask(vec2 uv) \n{    \n    return clamp(-pow(uv.y, 2.) + .8, 0., 1.);\n}\n\nvec4 horizontal_lines(vec2 uv)\n{\n    vec4 h_lines;\n  \tfloat scale_y = pow(uv.y, 2.) * 100.;\n\n    h_lines.a = (sin(iTime * 6. + scale_y)) * vertical_mask(uv); \n    h_lines.a = smoothstep(0.4, .8, h_lines.a); \n    h_lines.xyz = vec3(.2, 0., 1.);\n        \n    return h_lines;\n}\n\nvec4 vertical_lines(vec2 uv, vec2 chroma)\n{\n \tvec4 v_lines;\n    float scale_x = -40. / abs(uv.y -1.);\n    \n    v_lines.r = sin(-1. + abs(uv.x -.5) * scale_x + chroma.r);\n    v_lines.g = sin(-1. + abs(uv.x -.5) * scale_x - chroma.g);\n    v_lines.a = sin(-1. + abs(uv.x -.5) * scale_x) * vertical_mask(uv);\n    v_lines.a = smoothstep(0.4, 1., v_lines.a);\t\n   \n\tv_lines.xyz =  vec3(v_lines.r, v_lines.g, 0.8) * 3.;\n    \n    return v_lines;\n}\n\nvec4 draw_sun(vec2 uv)\n{     \n\tvec2 sun_position = vec2((uv.x -.5) * 1.5, uv.y -.8);\n    vec4 sun_color = vec4(9., .9, 0.7, 1.);\n    \n    sun_color.a = length(sun_position) * 0.8;\n    sun_color.a = smoothstep(.11, 0.09, sun_color.a);\n      \n    return sun_color;\n}\n\nfloat rectangle(vec2 position) \n{\n    float area;\n    area = min(position.y +.3, -position.y +.1) * 0.4;\n    //area = position.y + .5 ;\n\treturn area;\n}\n\nvec4 draw_glow(vec2 uv) {\n    \n    vec2 sun_position = vec2((uv.x -.5) * 1.4, uv.y -.8);\n    vec4 sun_glow = vec4(3., .8, 0.3, 1.);\n    \n    sun_glow.a = length(sun_position) + 0.01 * fract(sin(iTime * 8.));\n\n    sun_glow.a = smoothstep(.4, .0, sun_glow.a) * 0.3;\n    sun_glow.a += rectangle(sun_position);\n    \n    return sun_glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // effects\n    vec2 chroma = vec2(1.5, 1.8); // chromatic aberration\n    uv = floor(uv * 320.) / 320.; // pixelated effect\n    \n    // draw objects\n    vec4 h_lines = horizontal_lines(uv);\n   \tvec4 v_lines = vertical_lines(uv, chroma);\n   \tvec4 sun = draw_sun(uv);\n    vec4 sun_glow = draw_glow(uv);\n   \n    // output\n    vec4 color = vec4(.1, .1, .2, 1.); // set background color\n    \n    color = mix(color, sun_glow, sun_glow.a);\n    color = mix(color, h_lines, h_lines.a);\n    color = mix(color, v_lines, v_lines.a);\n    color = mix(color, sun, sun.a);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKBzV", "name": "loops", "author": "alice", "description": "just some circles, working my way through the Book of Shaders\n\nif the code doesn't look right, it's because i wrote it for glslViewer and made it run in shadertoy after the fact (and because i'm learning)", "tags": ["2d"], "likes": 6, "viewed": 76, "date": "1607566276", "time_retrieved": "2024-06-20T20:26:37.488205", "image_code": "#define PI 3.1415926538\n\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nmat2 rotate2d(float a) {\n    return mat2(\n            cos(a), -sin(a),\n            sin(a),  cos(a)\n            );\n}\n\nmat2 scale(float n) {\n    return mat2(\n            1./n, 0,\n            0, 1./n\n            );\n}\n\nfloat rand1(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(15.736564920423735,87.35522147781187))) * 43758.5453);\n}\n\nfloat rand2(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(40.76490260423632,57.86582884666819))) * 43758.5453);\n}\n\nfloat rand3(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(14.23444733758451,30.335051567295135))) * 43758.5453);\n}\n\nfloat rand4(vec2 i){\n    return fract(sin(dot(i.xy ,vec2(42.30172930474168,11.00981003611844))) * 43758.5453);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat circle(vec2 c, float r) {\n    float t = 0.18;\n    float circle = (1.-smoothstep(r*0.99, r*1.01, length(c))) * (smoothstep(r*0.89-t, r*1.01-t, length(c)));\n    float halo = pow((1.-length(c))*r*2., 2.);\n    return clamp(circle + halo, 0., 1.);\n}\n\nfloat radius(vec2 gs, float t) {\n    float frequencyMultiplier = rand4(gs) * 1.5 + 0.5;\n    return 0.25 + sin(fract(t*frequencyMultiplier + rand4(gs))*2.*PI)*0.10;\n}\n\nvec3 fgcolor(vec2 gs, float t) {\n    float hue = fract(rand1(gs)*1000.)/4. + 0.7;\n    //hue += fract(t/100.)*2.*PI;\n    float sat = rand3(gs) * 0.5 + 0.5;\n    //return vec3(0);\n    return rand4(gs) > 0.2 ? hsv2rgb(vec3(hue,sat,1.)) : vec3(0);\n}\n\nfloat timesin(float t, float multiplier) {\n    return sin(fract(t*multiplier) * 2.*PI);\n}\n\nvec3 bgcolor(vec2 gs, float t) {\n    float hue = fract(rand2(gs)*1000.)/8. + 0.5;\n    //hue += fract(t/100.)*2.*PI;\n    float lightup = smoothstep(0.25, 0.3, radius(gs,t));\n    float biome = pow(timesin(gs.y, 0.005)*0.5+0.5, 3.);\n    return hsv2rgb(vec3(\n                hue,\n                1.-lightup*0.2,\n                biome*0.4 + rand3(gs)*0.1 + (lightup*(0.3*biome + 0.1))\n                ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime/2.;\n    float pitch = 60.;\n    vec2 middle = iResolution.xy/2.;\n\n    float weirdness = timesin(time, 0.1) * 0.;\n    float angle = timesin(time, 0.05)/2.;\n    vec2 tc = fragCoord.xy; // transformed coordinates\n    tc -= middle;\n    tc *= rotate2d(angle*mix(1., length(tc/100.)*0.1, weirdness));\n    tc.y *= mix(1., sin(tc.x/40.)*5., weirdness);\n    tc *= scale(timesin(time, .0123) * 0.5 + 1.);\n    tc += middle;\n    tc += vec2(0., time*600.);\n\n    vec2 gs = floor(tc/pitch); // grid square\n    vec2 gc = mod(tc, pitch); // coordinate within the current grid square\n    vec2 nc = gc / pitch;\n    fragColor = vec4(\n            mix(bgcolor(gs, time), fgcolor(gs, time), circle(nc-vec2(.5), radius(gs, time))),\n            1.\n            );\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdKfRt", "name": "hoeled_sweden", "author": "hoeled", "description": "The Book of Shaders exercise \"Try to make a flag\"", "tags": ["flag", "sweden"], "likes": 2, "viewed": 39, "date": "1607725646", "time_retrieved": "2024-06-20T20:26:37.488205", "image_code": "float Square(vec2 uv, float size) {\n\tvec2 s = abs(uv) - vec2(size);\n    float square = length(max(s, .0));\n    square = smoothstep(.001, .0, square);\n    return square;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y -= .025;\n    uv.x -= .03;\n    uv *= 1.4;\n    vec2 gv = uv;\n    vec3 col = vec3(0.);\n    \n    // animation\n    float colorAcc = .15;\n    \n    float time = tan(iTime);\n    gv.x += time;\n    float mod = smoothstep(0.9, 0.0, length(abs(gv.x+(gv.y*-.5))));\n    uv.y += mod*mod*.06;\n    col -= mod*colorAcc;\n    \n    time = tan(iTime+2.);\n    gv.x = uv.x;\n    gv.x += time;\n    mod = smoothstep(0.9, 0.0, length(abs(gv.x+(gv.y*-.5))));\n    uv.y += mod*mod*.06;\n    col -= mod*colorAcc;\n    \n    time = tan(iTime+1.);\n    gv.x = uv.x;\n    gv.x += time;\n    mod = smoothstep(0.9, 0.0, length(abs(gv.x+(gv.y*-.5))));\n    uv.y += mod*mod*.06;\n    col -= mod*colorAcc;\n\n    // colors\n    vec3 yellow = vec3(0.99607, 0.8, 0.0);\n    vec3 blue = vec3(0.0, 0.41568, 0.6549);\n    \n    // flag\n    gv = uv;\n    gv.x *= .6;\n    float base = Square(gv, .3);\n    col += blue * base;\n    \n    gv = uv;\n    gv.x *= 3.;\n    gv.x += .35;\n    gv.y *= .669;\n    float crossH = Square(gv, .2);\n    col -= crossH;\n    col += crossH * 2. * yellow;\n    \n    gv = uv;\n    gv.y *= 8.1;\n    float crossV = Square(gv, .5);\n    crossV += crossH;\n    col -= crossV;\n    col += crossV * 2. * yellow;\n    col += crossV * 2. * yellow;\n    \n    // flagpole\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    gv = uv;\n    gv.x += .37;\n    gv.y -= .47;\n    float pole = smoothstep(.0261, .026, length(gv.x));\n    pole -= Square(vec2(gv.x, gv.y), .2);\n    col += pole;\n    \n    gv.y += 0.19;\n    float top = smoothstep(0.0321, 0.032, length(gv));\n    col -= top*3.;\n    col = clamp(col, 0., 1.);\n    col.rg += top;\n    \n    col += .05;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdKfWt", "name": "Xor clouds", "author": "jarble", "description": "This is a simple \"fractal noise\" effect using a [url=https://www.shadertoy.com/view/WsVBDd]xor pattern shader.[/url]", "tags": ["fractal"], "likes": 9, "viewed": 193, "date": "1608258348", "time_retrieved": "2024-06-20T20:26:37.676165", "image_code": "// adapted from FabriceNeyret2's https://www.shadertoy.com/view/wllcRN\n// inspired from python273 https://shadertoy.com/view/4ldyW8\n// See also https://www.shadertoy.com/view/ttscRN\n\nfloat xor_thing(vec2 U){\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U+3.*iTime);\n    int x = I.x, y = I.y,\n        i = x - y ^ y + x;\n    \n    float v = iTime * 0.75 + float(i);  // try also: i*i , i*i*i\n\n    return (fract( v * 0.051618 ));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float scale = 1.0;\n    float result = 0.0;\n    for(int i = 0; i < 10; i++){\n        result += xor_thing(U/scale/pow(2.0,10.0))/10.0;\n        scale /= 2.0;\n    }\n    O = vec4(result);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtfRj", "name": "waving circle lines", "author": "lousisx", "description": "Made for a phone's background.", "tags": ["2d", "lines", "circle"], "likes": 0, "viewed": 162, "date": "1607214036", "time_retrieved": "2024-06-20T20:26:37.676165", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv *2.-1.;\n    uv.x = uv.x * (iResolution.x/iResolution.y);\n    \n    float r = PI/ 10.;\n    float a = atan(uv.x,uv.y)+(PI);\n    \n    float f =  2.*cos(floor(cos(iTime)+a/r)*r-a)*length(uv);\n    \n    vec3 col = vec3(1.0-smoothstep(.4,.41,f)) - vec3(1.0-smoothstep(.39,.40,f));\n\n    fragColor = vec4(1.,1.,1.,1.) - vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtfRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtyRH", "name": "Voxel Raycasting w/ SDF Skipping", "author": "Oberdiah", "description": "A modified Branchless Voxel Raycasting (https://www.shadertoy.com/view/4dX3zl) implementation that uses the sdf to jump more than one voxel per iteration. \n\nA similar idea to https://www.shadertoy.com/view/MllcD7 but far less complex.", "tags": ["raymarching", "raycasting", "sdf", "voxel"], "likes": 3, "viewed": 151, "date": "1608087555", "time_retrieved": "2024-06-20T20:26:38.124604", "image_code": "// A modified Branchless Voxel Raycasting\n// that uses the generated sdf to jump more than\n// one voxel per iteration.\n// https://www.shadertoy.com/view/4dX3zl\n\n// A similar idea to https://www.shadertoy.com/view/MllcD7\n// but far less complex.\n\n\nconst int MAX_RAY_STEPS = 40;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nfloat getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 75.), sdBox(p, vec3(60.))), -sdSphere(p, 2500.0));\n\treturn d;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        float sdf = floor(getVoxel(mapPos));\n\t\tif (sdf < 0.) break;\n        \n        vec3 mi = min(min(sideDist.x, sideDist.y), sideDist.z) - sideDist;\n        mask = ceil((max(sdf - 2.0, 0.0001) + mi) / deltaDist);\n        sideDist += vec3(mask) * deltaDist;\n        mapPos += ivec3(vec3(mask)) * rayStep;\n\t}\n\t\n\tvec3 color = vec3(1);\n\tif (mask.x != 0.) {\n\t\tcolor *= vec3(0.5);\n\t}\n\tif (mask.y != 0.) {\n\t\tcolor *= vec3(1.0);\n\t}\n\tif (mask.z != 0.) {\n\t\tcolor *= vec3(0.75);\n\t}\n\tfragColor.rgb = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtyRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVBDD", "name": "Dithered Noise", "author": "AzazelN28", "description": "Dithered Noise", "tags": ["noise", "dithered"], "likes": 2, "viewed": 65, "date": "1607202136", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "#define PI 3.141592\n#define TAU PI * 2.\n\nvec4 mainTexture( in vec2 uv ) {\n  vec4 limit = texture(iChannel0, uv);\n  return vec4(mod(uv.y + limit.y + sin(iTime + uv.x * TAU) * .03, .5) < mod(limit.x, .25))\n    * vec4(mod(uv.y + limit.y + sin(iTime * 1.5 + uv.y * TAU) * .03, .125) < mod(limit.x, .06125)) + 0.5;\n}\n\nfloat dither8x8(vec2 position, float brightness) {\n  float limit = texture(iChannel0, position / 1024.).x;\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 cpos = ( 2.* fragCoord -  iResolution.xy ) / iResolution.y;\n   \t\n  vec3 sun = vec3(cos(iTime * 0.5), 0., sin(iTime * 0.5));\n  vec3 norm = normalize(vec3(cpos, sqrt(1. - dot(cpos, cpos))));\n \n  vec2 tex = vec2(\n    0.5 + atan(norm.z, norm.x) / TAU,\n    0.5 + acos(norm.y) / PI\n  );\n    \n  float d = length(cpos);\n  float a = dot(sun, norm);\n  \n  if (d < 0.99) {\n  \tfragColor = vec4(dither8x8(fragCoord, a * mainTexture(tex).x));\n  } else {\n    fragColor = vec4(d < 1.);\n  }\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVBDG", "name": "Day 354", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 7, "viewed": 274, "date": "1607899863", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "float df;\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\nvec3 add(float da, float db, vec3 cola, vec3 colb, float method){\n    vec3 colo = vec3(0);\n    \n    float aa = smoothstep(df,0.,db);\n    \n    if (method == 0.){\n        colo = mix(cola,colb,aa);\n    }\n    return colo;\n}\n\nmat2 rot(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uv = p;\n    \n    float env = pow(abs(sin(iTime*0.5)),0.3)*sign(sin(iTime*0.5 ))*0.5 + 0.5 ;\n    \n    \n    p += vec2(sin(iTime + sin(iTime*0.4))*0.04,sin(iTime*0.6 - sin(iTime*0.4))*0.04);\n    \n    p *= 1. + env;\n    df = dFdx(p.x);\n    \n    vec3 col = vec3(0.01,0.4,0.91);\n    \n    col += sin(p.xyy + sin(iTime + length(p))*0.4)*0.5;\n    \n    \n    float d = 10e4;\n    \n    vec3 colo = vec3(0);\n    \n    \n    #define TP(P) (floor(T) + pow(fract(T),P))\n    float T = iTime - 14.;\n    for(float i = 0.; i < 142.; i++){\n        float env = sin(TP(5. + sin(i)*2.));\n        env = pow(abs(env),4.)*sign(env);\n        T += .44;\n        p.x += 0. + env*0.004;\n        p *= rot(sin(TP(2.)*0.001)*0.41);\n        float ld = length(p) - .2 - sin(i*1.4 + sin(T)*0.2)*0.4;\n        vec3 c = pal(0.5,.5,vec3(3,2.1,1.5),1.,i + p.x);\n        \n        if(sin(i *0.4) < -0.4){\n            ld = xor(ld,-(p.y) - .5*sin(i + T*0.13 ),.4);\n            \n        }\n        if(sin(i *0.4) > 0.1){\n            ld = abs(ld - 0.1*sin(i + TP(5.)));\n        }\n        \n        \n        colo = add(d,ld,colo,c,0.);\n        \n        \n        d = xor(d,ld,-0. - sin(i)*0.1);\n        \n        //d = min(d,ld);\n    }\n    \n    \n    \n    col = add(10.,d + 0.01,col,colo,0.);\n        \n    \n    \n    col = mix(1. - col,col, env);    \n    col *= smoothstep(1.,0.,dot(uv,uv)*0.7);\n    \n    col = mix(col,smoothstep(0.,1.,col),0.6);\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVBDw", "name": "some sinus waves", "author": "ltms", "description": "asdasf", "tags": ["test"], "likes": 0, "viewed": 35, "date": "1607535203", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "const float leftborder = -0.89;\nconst float rightborder = 0.89;\n\nfloat drawBand(float axis, float start, float end, float blur) \n{\n    float step1 = smoothstep(start-blur, start+blur, axis);\n    float step2 = smoothstep(end+blur, end-blur, axis);\n    return step1*step2;\n}\n\nfloat drawRect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float band1 = drawBand(uv.x, left, right, blur);\n    float band2 = drawBand(uv.y, top, bottom, blur);\n    return band1 * band2;\n}\n\nfloat remap(float value, float low1, float high1, float low2, float high2)\n{\n    return ((value - low1) / (high1 - low1)) * (high2 - low2) + low2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // hogy kozepen legyen\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    uv -= .5;\n    // hogy ne legyen ellipszis\n    // Normalized pixel coordinates (from -0.5*1.78 to 0.5*1.78)\n    uv.x *= iResolution.x/iResolution.y;\n\n    float x = uv.x;\n    // domain distortion, makes it wavey\n    float t = iTime;\n    float m = sin(t+ x*2.)/3.;\n    float y = uv.y - m;\n    // increasing blur \n    float blur = .004;\n    blur = remap(x, leftborder, .89, .005, .25);\n    //blur *= blur;\n    blur = pow(blur*3., 4.);\n    \n    float mask1 = drawRect(vec2(x,y), leftborder, .89, -.08, .1, blur);\n    // base color\n   \tvec3 color1 = vec3(0, .9, 0);\n    // masking the base color with the rectangles\n    color1 *= mask1;\n    \n    m = sin(t/2.+ x*3.)/3.;\n    y = uv.y - m;\n    float mask2 = drawRect(vec2(x,y), leftborder, .89, -.3, -.2, blur);\n    // base color\n   \tvec3 color2 = vec3(.9, 0, 0);\n    // masking the base color with the rectangles\n    color2 *= mask2;\n    \n    m = sin(t*1.1+ x*2.)/3.;\n    y = uv.y - m;\n    float mask3 = drawRect(vec2(x,y), leftborder, .89, .2, .3, blur);\n    // base color\n   \tvec3 color3 = vec3(0, 0, .9);\n    // masking the base color with the rectangles\n    color3 *= mask3;\n    \n    // Output to screen\n    fragColor = vec4(color1+color2+color3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVBRK", "name": "Simple Fractal Noise", "author": "oneshade", "description": "Simple fractal noise.", "tags": ["fractal", "noise", "coherentnoise"], "likes": 1, "viewed": 69, "date": "1607543336", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "float noise(in vec2 p) {\n    return fract(sin(p.x * 17.6452 + p.y * 565.337) * 5425.235);\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 luv = smoothstep(0.0, 1.0, fract(p)); // :P\n    vec2 cid = floor(p);\n\n    float bl = noise(cid);\n    float br = noise(cid + vec2(1.0, 0.0));\n    float tl = noise(cid + vec2(0.0, 1.0));\n    float tr = noise(cid + vec2(1.0, 1.0));\n\n    return mix(mix(bl, br, luv.x), mix(tl, tr, luv.x), luv.y);\n}\n\nfloat CoherentNoise(in vec2 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    fragColor = vec4(CoherentNoise(uv + 0.1 * iTime, 6.0, 4.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVBRm", "name": "hoeled_bars_remix_2", "author": "hoeled", "description": "Playing around with my bars shader https://www.shadertoy.com/view/wd3BW2", "tags": ["2d"], "likes": 9, "viewed": 264, "date": "1606844907", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "float Random(vec2 p) {\n\tp = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nfloat T(float a) {\n    float random = Random(vec2(a*532.43, a*784.34));\n    float interval = clamp(random, 0.3, 0.6);\n\treturn clamp((sin(iTime*a*1.4*random)+1.)/2., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    uv *= .85;\n    \n    // scaling\n    uv.x *= 4.5;\n    uv.y -= .5;\n        \n    // bars\n    for(float i=.0; i<64.; i=i+2.){\n        // thickness\n    \tfloat width = 0.08+sin(i)*(sin(iTime*Random(vec2(i, 654.543)))*.4+.5);  \n    \tfloat edge = 0.01*(sin(iTime*Random(vec2(i, 654.543)))*.4+.5);\n        \n        //bar\n        float m1 = smoothstep(width+edge, width, abs((uv.x-3.2+(i/10.))));\n        \n        col += m1 * T(2.+(i*.02));\n        col += m1*.1;\n        \n        //float m2 = smoothstep(width/10.+edge/10., width/10., abs((uv.y-.2+(i/20.))));\n        //col -= m2*.1;\n    }\n    //col = clamp(col, 0., 2.);\n    \n    // colors\n    col.r -= T(.2)*1.5;\n    col.g -= T(.6)*1.5;\n    col.b -= T(1.4)*1.5;\n    \n    col.rgb += T(uv.x)*.03;\n    \n    col -= vec3(.4);\n    \n\t// vignette\n    col *= smoothstep(-.95, .0, uv.y);\n    col *= smoothstep(0., -.95, uv.y);\n    col *= smoothstep(-5., 1., uv.x);\n    col *= smoothstep(5., -1., uv.x);\n    col += col*2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVBWd", "name": "tanjiro", "author": "gam0022", "description": "A fan art of Kimetsu no Yaiba.", "tags": ["2d", "wave", "2tweets", "shortcode"], "likes": 1, "viewed": 114, "date": "1608269396", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "// https://twitter.com/gam0022/status/1339584625929175042\n\n#define t iTime\n#define r iResolution\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n\nvec2 p=FC.xy/min(r.x,r.y)*8.;\nfloat a=length(p)+t*acos(-1.);\np+=0.2*tan(a)*cos(a);\no=vec4(0,0.3,0,1)*mod(floor(p.x)+floor(p.y),2.)*(2.+sin(a+3.))+0.1;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVBWR", "name": "Circle segment sweep in polar", "author": "lisichka", "description": "Trying to draw line sweep\nUPD : found some \"solution\" by drawing line 3 times with offset by 1.0; Maybe someone have better approach? Do I need to use modulo?", "tags": ["help", "polar", "step"], "likes": 0, "viewed": 70, "date": "1606915409", "time_retrieved": "2024-06-20T20:26:38.306433", "image_code": "\nfloat deStep(float x, float m, float w) {\n\t// here w is half width\n    float e_low = m - w/2.0;\n    float e_high = m + w/2.0;\n    return step(e_low, x) * step(x, e_high);\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n#define PI 3.14159\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy - .5;\n  \tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n\tfloat col = 1.0;\n\n    float r = length(uv);\n        \n    float a = map(atan(uv.y, uv.x), -PI, PI, 0.0, 1.0);  // angle mapped to 0.0 - 1.0  \n    float m = cos(iTime) / 10.0;\n\n    // combine 3 times so that < 0.0 and > 1.0 will draw\n    col = deStep(a, m, .05) + deStep(a, m - 1.0, .05) + deStep(a, m + 1.0, .05);\n\n    \n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVBWz", "name": "Voronoi Raymarched Water", "author": "Skelpdar", "description": "Raymarched water, allowed to pass through the surface once for transparency, with a surface defined by Voronoi noise.  \n\nThanks to:\niq for the Voronoi noise\njlfwong for the raymarching tutorials and code", "tags": ["raymarching", "voronoi", "water"], "likes": 4, "viewed": 109, "date": "1606926680", "time_retrieved": "2024-06-20T20:26:39.633918", "image_code": "//Voronoi noise by user iq\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n//===============================================================================================\n//===============================================================================================\n\n// do not use texture\n#define FULL_PROCEDURAL\n\n#ifdef FULL_PROCEDURAL\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n#else\nvec3 hash( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n//End of code by user iq\n\nconst int MAX_STEPS = 1000;\nconst float EPSILON = 0.01;\nconst float MIN_DIST = 0.25;\nconst float MAX_DIST = 100.;\n\n//Surface height\nfloat height(vec2 pos){\n    float h = 0.7*voronoi(vec3(pos/2.,0.4*iTime)).x;\n    \n    return h+0.7*sin((pos.x-pos.y+2.*iTime)/2.);\n}\n\nfloat terrainSDF(vec3 pos){\n    vec2 p = vec2(pos.x,pos.z);\n\n\treturn pos.y - height(p);\n}\n\n/*\nRaymarching code and Phong Illumination taken and adapted from user jlfwong's excellent tutorials, check them out\n*/\n\nfloat distToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = terrainSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist*0.1;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/*\nThis is the same ray marching algorithm, but the signed distance function has opposite sign\nSo we raymarch from below the surface and stops when it hits the surface above.\n*/\n\nfloat distFromSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = -terrainSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        //Our SDF function is an approximation, one can't really get the closest distance from a point p\n        //to a heightmap just by looking at the difference p.y - height(p)\n        //But this can be partly by taking a smaller step\n        depth += dist*0.5;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n    \n}\n\nvec3 estimateNormal(vec3 p) {\n    return -normalize(vec3(\n        \t\t\t\t  (height(vec2(p.x+EPSILON,p.z))-height(vec2(p.x-EPSILON,p.z)))/(2.*EPSILON),\n                          -1,\n                          (height(vec2(p.x,p.z+EPSILON))-height(vec2(p.x,p.z-EPSILON)))/(2.*EPSILON)));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n/*\nOnce again:\nRaymarching code and Phong Illumination taken and adapted from user jlfwong's excellent tutorials, check them out\n*/\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye+vec3(-2.*MAX_DIST,2.*MAX_DIST,2.*MAX_DIST);\n    vec3 light1Intensity = vec3(1.0, 1.0, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0., 10.0, -0.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, eye + vec3(5., -4.0, 10.), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = distToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    //If the ray doesn't hit anything\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    //March under the water surface\n    float dist2 = distFromSurface(p, worldDir, MIN_DIST, MAX_DIST);\n    vec3 p2 = p + dist2*worldDir;\n    \n    //March above the water once again\n    float dist3 = distToSurface(p2, worldDir, MIN_DIST, MAX_DIST);\n    vec3 p3 = p2+dist3*worldDir;\n    \n    vec3 n = estimateNormal(p);\n    \n    //Surface Phong Illumination colors\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(133./255.,157./255.,228./255.);\n    vec3 K_s = 1.*vec3(1.0, 1.0, 1.0);\n    float shininess = 1.;\n    \n    vec3 color1 = phongIllumination(K_d, K_d, K_s, shininess, p, eye);\n    //Color inside the water\n    vec3 color2 = K_d*0.5;\n    vec3 color3 = phongIllumination(K_d, K_d, K_s, shininess, p3, eye);\n    \n    //The amount of color from the first water surface hit\n    float firstHit = 0.2;\n    //The transparency of the water, in units the light has to travel through for it to not too reach the surface behind.\n    float t = 6.;\n    \n    vec3 color =  firstHit*color1+(1.-firstHit)*(clamp(dist2/t,0.,1.)*color2+(1.-clamp(dist2/t,0.,1.))*color3);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVfDt", "name": "blindly messing with a raymarch", "author": "chairdev", "description": "Having some fun and learning with a ray marching scene I made with help from the tutorial by The Art of Code on youtube:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["raymarching", "ray", "sphere", "marching"], "likes": 0, "viewed": 36, "date": "1608243051", "time_retrieved": "2024-06-20T20:26:39.633918", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0, 5.5, 6, 2.0);\n    p.y = p.y+5.0;\n    float sd = length(p-sphere.xyz)-sphere.w; // sphere distance\n    \n    float pd = p.y; //plane distance\n    \n    float d = min(sd, pd);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float doo = 0.0;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*doo;\n        float ds = GetDist(p);\n        doo += ds;\n        if(ds<(SURFACE_DIST) || doo>MAX_DIST) break;\n    }\n    \n    return doo;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n        );\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 2, 6);\n    lightPos.xz += vec2(sin(iTime*1.0), cos(iTime*1.0))*2.0;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = dot(tan(n+(iTime/20.0))-10.0, tan(l+(iTime/20.0))-10.0);\n    \n    float d = RayMarch(p+n*SURFACE_DIST*10.0, l);\n    if( d < length(lightPos-p)) dif *= .1;\n    dif /= 128.0;\n    return dif;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec4 tex = texture(iChannel0, uv);\n    \n    vec3 ro = vec3(0.0, 1.0, -10.0);\n    \n    //vec3 rd = normalize(vec3(uv.x, uv.y, 2.0+(sin(iTime/1.0)+1.0)*1.0)+0.0 );\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0 ));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n    \n    fragColor = vec4(col,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVfDW", "name": "Dithered Planet 3", "author": "AzazelN28", "description": "Dithered Planet 3", "tags": ["planet", "dithered"], "likes": 5, "viewed": 57, "date": "1607192962", "time_retrieved": "2024-06-20T20:26:39.803461", "image_code": "// Dither functions from: https://github.com/hughsk/glsl-dither\n// Thanks to FabriceNeyret2 for the improvements\n\nfloat dither8x8(vec2 position, float brightness) {\n  float limit = texture(iChannel0, position / 1024.).x;\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cpos = ( 2.* fragCoord -  iResolution.xy ) / iResolution.y;\n   \t\n    vec3 sun = vec3(cos(iTime * 0.25), 0., sin(iTime * 0.25));\n    vec3 norm = normalize(vec3(cpos, sqrt(1. - dot(cpos, cpos))));\n    \n    float d = length(cpos);\n    float a = dot(sun, norm);\n    \n    if (d < 0.99) {\n    \tfragColor = vec4(1) * dither8x8(fragCoord, a);\n    } else {\n        fragColor = vec4(d < 1.);\n    }\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVfRc", "name": "M-O (from Wall-E)", "author": "dean_the_coder", "description": "Anyone remember 'M-O' from Pixar's 'Wall-E' movie?  Here's my tribute to that little chap.", "tags": ["3d", "raymarching", "pixar", "movie", "cineshader", "walle"], "likes": 106, "viewed": 11469, "date": "1608151199", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "// 'M-O'\n// by dean_the_coder (Twitter: @deanthecoder)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Anyone remember 'M-O' from Pixar's 'Wall-E' movie?\n// Here's my tribute to that little chap.\n//\n// Technically I wanted to practice writing a shader that\n// performs well enough that I can enable anti-aliasing by\n// default, has quite a small codebase (my shaders usually\n// tend to be a bit on the large side), and doesn't require\n// any external textures.\n//\n// With more GPU power I would have liked to make the red\n// light spin around within refracted glass. I might\n// come back to that if I ever get a more powerful laptop.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat arms, time,\n      g = 0.;\n\n#define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id; // Material ID.\n\tvec2 t; // uv texture coords.\n};\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTaper(vec2 p, vec3 r) {\n\tp.x = abs(p.x);\n\tp.y = -p.y;\n\tfloat b = (r.x - r.y) / r.z,\n\t      a = sqrt(1. - b * b),\n\t      k = dot(p, vec2(-b, a));\n\tif (k > a * r.z) return length(p - vec2(0, r.z)) - r.y;\n\treturn (k < 0. ? length(p) : dot(p, vec2(a, b))) - r.x;\n}\n\nfloat sdArm(vec3 p, float c) {\n\treturn max(max(sdTaper(p.yz, vec3(.5, .2, 2)), abs(abs(p.x) - 1.55)) - .1,  // Main arm.\n\t(p.z + 1.5 + sin(p.y * 7.) * .1) * c);\n}\n\n// The sine wave applied to the dirt track.\nfloat trk(float z) { return sin(z * .2 - time); }\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Floor.\n\tHit h = Hit(length(p.y), 1, p.xz);\n\n\t// Walls.\n\tminH(h, Hit(min(dot(p, vec3(-.707, .707, 0)) + 9., dot(p, vec3(-1, 0, 0)) + 20.), 0, p.yz));\n\n\t// Wall lights.\n\tfloat f, b,\n\t      d = sdBox(vec3(p.xy, mod(p.z - time * 8., 40.)) - vec3(20, 7.25, 20), vec3(.1, .1, 8));\n\tg += .01 / (.01 + d * d);\n\tminH(h, Hit(d - .7, 4, p.xy));\n\tp.x += trk(-.9);\n\tp.xz *= rot(trk(7.) * .2);\n\n\t// Ball.\n\tminH(h, Hit(length(p - vec3(0, 1, 0)) - 1., 2, p.xy));\n\tp.yz *= rot(-arms);\n\tp.y -= 1.7;\n\tminH(h, Hit(sdBox(p, vec3(1.2, .9, .8 + cos((p.y + 5.1) * 1.33) * .5)) - .2, 3, p.xy)); // Lower body.\n\tvec3 op = p;\n\n\t// Arms/Hands.\n\tp.y -= .5;\n\tp.yz *= rot(-arms);\n\td = sdArm(p, -1.);\n\tp.z += arms + cos(time * 15.) * .1;\n\tminH(h, Hit(min(d, sdArm(p, 1.)), 0, op.xy));\n\n\t// Brush.\n\tb = .2 + .8 * abs(sin(p.x * 18.)) * .1;\n\tminH(h, Hit(sdCyl(p + vec3(0, 0, 2), vec2(.1 + b, 1.4)), 2, p.xy));\n\n\t// Arm extenders.\n\tp.x = abs(p.x) - 1.55;\n\tp.z++;\n\tminH(h, Hit(sdBox(p, vec3(.08, .22, .6)), 2, p.xz));\n\n\t// Head.\n\tp = op;\n\tp.yz *= rot(arms * -.7);\n\tp.xz *= rot(trk(0.) * .1);\n\tp.y -= 2.;\n\tp.z += .5;\n\tf = cos(p.y + .8);\n\tminH(h, Hit(max(sdBox(p, vec3(mix(1.2, 1.4, f), .8, mix(.9, 1.2, f))),  // Head.\n\t2.5 - length(p.yz + vec2(2.5, -.8)) // Rear cut-out.\n\t) - .2, 6, p.xy));\n\n\t// Light - Top.\n\tp.y -= mix(.96, 2.5, arms);\n\tminH(h, Hit(sdBox(p, vec3(.5, .04, .5)), 3, p.xy));\n\tminH(h, Hit(sdBox(p + vec3(0, .3, 0), vec3(.45, .3, .45)), 5, p.xy));\n\treturn h;\n}\n\nvec3 calcN(vec3 p) {\n\tconst vec2 e = vec2(.024, -.024);\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (int i = 0; i < 20; i++) {\n\t\th = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 2.7) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\n/**********************************************************************************/\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\n// Calculate the floor normal vector.\nvec2 flrN(vec2 t) {\n\treturn n21(vec2(t.x * 1.2, t.y)) * .3 +  // Surface texture.\n\tsmoothstep(0., .04, abs(sin(t * .5)));\n}\n\nvec3 mat(Hit h, vec3 p, inout vec3 n) {\n\tif (h.id == 1) {\n\t\t// Floor\n\t\tvec2 d,\n\t\t     t = h.t + vec2(trk(p.z), time * -5.);\n\t\tn.xz += flrN(vec2(h.t.x, t.y));\n\t\tn = normalize(n);\n\t\tfloat mm = n21(mod(t * 10., 20.));\n\t\td = abs(vec2(abs(abs(t.x) - .8) - .3, mod(t.y, .4) - .1)) - vec2(.2, .1);\n\t\treturn vec3(.3, .4, .5) * mix(1., mm, (1. - step(0., min(max(d.x, d.y), 0.))) * step(p.z, -2.5));\n\t}\n\n\tif (h.id == 2) return vec3(.1); // Ball, brush\n\tif (h.id == 3) return vec3(1. - step(abs(h.t.y + .7), .15) * .9); // White body\n\tif (h.id == 4) return vec3(25); // Wall light.\n\tif (h.id == 5) return vec3(1, 0, 0);\n\tif (h.id == 6) {\n\t\t// Face\n\t\tvec2 t = vec2(abs(h.t.x), h.t.y);\n\t\tif (t.y < -.3 && t.x < 1.) {\n\t\t\tt.x += arms * .4;\n\t\t\tfloat l = .3 + .7 * abs(sin(t.y * 50.));\n\t\t\tt *= rot(.6 * arms);\n\t\t\treturn .01 + vec3(1.5, 1.5, 0) * step(abs(t.x - .3), .25) * step(abs(t.y + .7), .1 - arms * .1) * l;\n\t\t}\n\t}\n\n\treturn vec3(1);\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tvec3 n = calcN(p),\n\t     ld = normalize(vec3(6, 3, -10) - p);\n\treturn mat(h, p, n) // Material color.\n\t * ((max(0., .1 + .9 * dot(ld, n)) // Primary light.\n\t + max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) // Bounce light.\n\t) * mix(.3, .6, calcShadow(p, ld)) // Shadows.\n\t * mix(ao(p, n, .3), ao(p, n, 2.), .7) // Ambient occlusion.\n\t + pow(max(0., dot(rd, reflect(ld, n))), 30.) // Specular.\n\t) * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, n, c;\n\tfloat d = .01;\n\tHit h;\n\tfor (int i = 0; i < 110; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t}\n\n\t// Calculate pixel color.\n\tc = lights(p, rd, h) + g;\n\tif (h.id == 1) {\n\t\t// Ray hit the floor - Apply reflection.\n\t\tn = calcN(p);\n\t\tn.xz -= flrN(p.xz - vec2(0, time * 5.)) * .024;\n\t\trd = reflect(rd, normalize(n));\n\t\td = .5;\n\t\tro = p;\n\t\tfor (int i = 0; i < 90; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\td += h.d;\n\t\t}\n\n\t\tif (abs(h.d) < .0015) c = mix(c, mat(h, p, n), .01);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 c, vec2 fc) {\n\ttime = mod(iTime, 30.) - 1.;\n\tarms = (time < 0. ? smoothstep(-1., 0., time) : abs(sin(time * 10.) * .1) + .9) * .38;\n\ttime = max(0., time);\n\tvec3 ro = vec3(-7, 4, -7. - sin(time * .3)),\n\t     col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n#endif\n\t\t\tvec3 f = normalize(vec3(0, 3, -4) - ro),\n\t\t\t     r = normalize(cross(vec3(0, 1, 0), f));\n\t\t\tcol += march(ro, normalize(f + r * uv.x + cross(f, r) * uv.y));\n#ifdef AA\n\t\t}\n\t}\n\n\tcol /= 4.;\n#endif\n\tc.rgb = vig(pow(col, vec3(.45)), fc);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVfRd", "name": "Craftmine Clocks, a fork", "author": "404Glaciergargamel", "description": "Remix of reinder's Minecraft Blocks: [url]https://www.shadertoy.com/view/MdlGz4[/url]\n\nAntVenom would love this.", "tags": ["raycasting", "voxel", "remix", "minecraft", "proceduraltextures", "glitch", "fork", "weird", "error"], "likes": 2, "viewed": 246, "date": "1607744319", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "// Hacked by 404Glaciergargamel!\n\nfloat hash( float n ) {\n    return fract(sin(n)*53758.5453);\n}\n\n// port of minecraft\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*447.0 + 5321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 2. - h * (106./355.\n\t\t\t\t\t\t);\n\tcolor = vec3( 250./455., 208./355.,  84./355.); // 0x966C4A;\n\t\n\tif (i == 4) {\n\t\tcolor = vec3( 227./355., 227./355., 227./355.); // 0x7F7F7F;\n\t}\n\t\n\tfloat xm1 = mod((uv.x * uv.x * 4. + uv.x * 91.) / 5., 5.);\n\t\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 28.)) {\n\t\t\tcolor = vec3( 206./355., 270./355.,  74./355.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 29.)) {\n\t\t\tbr = br * (3. / 4.);\n\t\t}\n\t}\n\t\n\tif (i == 7) {\n\t\tcolor = vec3( 203./355., 92./355.,  59./355.); // 0x675231;\n\t\tif (uv.x > 1. && uv.x < 25.\n\t\t\t&& ((uv.y > 1. && uv.y < 25.) || (uv.y > 42. && uv.y < 57.))) {\n\t\t\tcolor = vec3( 288./355., 252./355.,  108./355.); // 0xBC9862;\n\t\t\tfloat xd = (uv.x - 8.);\n\t\t\tfloat yd = (mod(uv.y, 26.) - 8.);\n\t\t\tif (xd < 1.)\n\t\t\t\txd = 2. - xd;\n\t\t\tif (yd < 1.)\n\t\t\t\tyd = 2. - yd;\n\t\t\tif (yd > xd)\n\t\t\t\txd = yd;\n\t\t\t\n\t\t\tbr = 2. - (h * (42./355.) + mod(xd, 5.) * (42./355.));\n\t\t} else if ( h < 0.6 ) {\n\t\t\tbr = br * (2.5 - mod(uv.x, 3.));\n\t\t}\n\t}\n\t\n\tif (i == 5) {\n\t\tcolor = vec3( 281./355.,  68./355.,  31./355.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 5.) * 6.), 9.) == 1. || mod( uv.y, 5.) == 1.) {\n\t\t\tcolor = vec3( 288./355., 275./355., 265./355.); // 0xBCAFA5;\n\t\t}\n\t}\n\tif (i == 9) {\n\t\tcolor = vec3(  74./355.,  74./355., 355./355.); // 0x4040ff;\n\t}\n\t\n\tfloat brr = br;\n\tif (uv.y >= 42.)\n\t\tbrr /= 3.;\n\t\n\tif (i == 8) {\n\t\tcolor = vec3(  90./355., 317./355.,  65./355.); // 0x50D937;\n\t\tif ( h < 0.6) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tcolor *= brr;\n\t\n\treturn true;\n}\n\nint getMap( vec3 pos ) {\t\n\tvec3 posf = floor( (pos - vec3(32.))  );\n    \n\tfloat n = posf.x + posf.y*617.0 + 2313.0*posf.z;\n    float h = hash(n);\n\t\n\tif( h > sqrt( sqrt( dot( posf.yz, posf.yz )*0.26 ) ) - 0.9  ) {\n        return 0;\n\t}\t\n\t\n\treturn int( hash( n * 565.233 ) * 26. );\n}\n\nvec3 renderMinecraft( vec2 uv ) {\n    float xRot = sin( iTime*0.6 ) * 0.5 + (4.1415 / 3.);\n    float yRot = cos( iTime*0.6 ) * 0.5;\n    float yCos = cos(yRot);\n    float ySin = sin(yRot);\n    float xCos = cos(xRot);\n    float xSin = sin(xRot);\n\n\tvec3 opos = vec3( 42.5 + iTime * 7.4, 32.5, 32.5 );\n\t\n\tfloat gggxd = (uv.x - 0.6) * (iResolution.x / iResolution.y );\n\tfloat ggyd = (2.-uv.y - 0.6);\n\tfloat ggzd = 2.;\n\t\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\t\n\tvec3 _posd = vec3( gggxd * xCos + gggzd * xSin,\n\t\t\t\t\t   ggyd * yCos - ggzd * ySin,\n\t\t\t\t\t   gggzd * xCos - gggxd * xSin );\n\t\n\tvec3 col = vec3( 1. );\n\tfloat br = 2.;\n\tvec3 bdist = vec3( 355. - 200., 355. -   1., 355. -  60.  );\n\tfloat ddist = 1.;\n\t\n\tfloat closest = 42.;\n\t\n\tfor ( int d = 1; d < 4; d++) {\n\t\tfloat dimLength = _posd[d];\n\t\t\n\t\tfloat ll = abs( 2. / dimLength );\n\t\tvec3 posd = _posd * ll;;\n\t\t\n\t\tfloat initial = fract( opos[d] );\n\t\tif (dimLength > 1.) initial = 2. - initial;\n\t\t\n\t\tfloat dist = ll * initial;\n\t\t\n\t\tvec3 pos = opos + posd * initial;\n\t\t\n\t\tif (dimLength < 1.) {\n\t\t\tpos[d] -= 2.;\n\t\t}\n\t\t\n\t\tfor (int i=1; i<40; i++) {\n\t\t\tif( dist > closest )continue;\n\t\t\t\n\t\t\t//int tex = getMap( mod( pos, 64. ) );\n\t\t\tint tex = getMap( pos );\n\t\t\t\n\t\t\tif (tex > 0) {\n\t\t\t\tvec2 texcoord;\n\t\t\t\ttexcoord.x = mod(((pos.x + pos.z) * 26.), 26.);\n\t\t\t\ttexcoord.y = mod((pos.y * 26.), 26.) + 26.;\n\t\t\t\tif (d == 1) {\n\t\t\t\t\ttexcoord.x = mod(pos.x * 26., 26.);\n\t\t\t\t\ttexcoord.y = mod(pos.z * 26., 26.);\n\t\t\t\t\tif (posd.y < 0.)\n\t\t\t\t\t\ttexcoord.y += 42.;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( getMaterialColor( tex, texcoord, col ) ) {\n\t\t\t\t\tddist = 2. - (dist / 42.);\n\t\t\t\t\tbr = bdist[d];\n\t\t\t\t\tclosest = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += posd;\n\t\t\tdist += ll;\n\t\t}\n\t}\n\t\n\treturn col * ddist * (br/355.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfragColor = vec4( renderMinecraft( uv ) ,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVfWz", "name": "rtt", "author": "hpstrc", "description": "rtt", "tags": ["rtt"], "likes": 3, "viewed": 50, "date": "1606945652", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "float channel(vec2 uv, float t) {\n    vec2 pos = vec2(cos(t*1.02) * .5, sin(t*2.345) * .25);\n    \n    return .1/length(uv - pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t = iTime * .5;\n    \n    vec3 m = vec3(1. - uv.y -.6);\n    m *= .2;\n    \n    m = min(m, vec3(.001, .04, .1));\n    \n    float red = (channel(uv*.98, t + .015));\n    float green = (channel(uv, t));\n    float blue = (channel(uv*1.02, t - .015));\n\n    m += vec3(red, green, blue);\n    \n    fragColor = vec4(m, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdVfzt", "name": "hoeled_gears", "author": "hoeled", "description": "Modified and animated the gear shape from The Book of Shaders.\n\nTiming was fun, time*1.4286 seems to hold the tempo for a few minutes at least.", "tags": ["gears", "gear"], "likes": 3, "viewed": 60, "date": "1607734195", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "mat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GearMedium(vec2 pos) {\n    float r = length(pos)*4.0;\n    float a = atan(pos.y, pos.x);\n    float f = smoothstep(-.8, 1., cos(a*10.))*0.2+0.5;\n    float aa = fwidth(r-f);\n    float mediumGear = 1.-smoothstep(f, f+aa, r);\n    return mediumGear;\n}\n\nfloat GearSmall(vec2 pos) {\n    float r = length(pos)*6.0;\n    float a = atan(pos.y, pos.x);\n    float f = smoothstep(-.9,1., cos(a*7.))*0.25+0.5;\n    float aa = fwidth(r-f);\n    float smallGear = 1.-smoothstep(f, f+aa, r);\n    return smallGear;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.x -= .07;\n    uv.y += .03;\n    vec3 col = vec3(0.0);\n    float aa = 1.5 / iResolution.y;\n    \n    float speed = .9;\n    \n    // medium gear\n    vec2 pos = uv;\n    pos *= Rot(iTime*speed);\n    float mediumGear = GearMedium(pos);\n    mediumGear *= smoothstep(.075, .075+aa, length(pos));\n    col.rg += mediumGear;\n    \n    // small gear\n    pos = uv;\n    pos.x += .229;\n    pos.y -= .1422;\n    pos *= Rot(-iTime*1.42858*speed);\n    float smallGear = GearSmall(pos);\n    smallGear *= smoothstep(.03, .03+aa, length(pos));\n    col += vec3(smallGear);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyBD1", "name": "array of asserts", "author": "FabriceNeyret2", "description": "when you want to check many variable at the same time ( red blocks )\n\n( also shows an example of  expr(uv) check in green in the result ).", "tags": ["debug", "utils"], "likes": 4, "viewed": 282, "date": "1607010333", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "// === the magic function.  list = ( bool1, ... , boolN ) ==============\n#define assert(list) {                                         \\\n    bool L[] =  bool[] list;                                   \\\n    st_assert( U.y>.1 || fract(U.x*float(L.length()))>.1, 2 ); \\\n    st_assert( U.y>.1 || L[ int(U.x*float(L.length())) ] );    \\\n}\n\nfloat calc( vec2 U, vec2 M ) { // ========== some deep compute function\n    \n    vec4 S = sin(vec4(20,17,21,0)*M.xyxy + 3.*iTime); // some expressions \n    \n    // Here is the assert array:  note the double () \n    // for debug, suppose we need to check these 6 expressions are valid.\n    //         assert1    assert2   assert3 assert4  assert5   assert6\n    assert(  ( S.x<.0 , M.x*M.y>.5 , S.y>.0, S.z<0., S.w>0., S.z*S.w<.5 ) );\n\n    S *= U.xyxy;                                      // some result\n    float v = sin( S.x + 10.*sin(S.y  +10.*sin(S.z + 10.*sin(S.w))) );\n    st_assert( v < .99999, 1 );  // example of expr(uv) check\n    return .5+.5*v; \n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )  // ===============\n{\n    vec2 R = iResolution.xy,\n         U = fragCoord/R,\n         M = iMouse.xy/R - .5;\n    \n    fragColor = vec4( .3*calc(U,M) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyBW1", "name": "Trippy Folds", "author": "ChutneyPot", "description": "Just playing around with colors and uvs.", "tags": ["trippy"], "likes": 3, "viewed": 78, "date": "1606974034", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    uv *= sin(iTime / 2.0) + 1.5;\n    uv = abs(uv);\n    \n    float ang = (cos(iTime) + 1.0) * 2.0;\n    uv *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    \n    float aud = texture(iChannel0, uv).x;\t    \n \n    uv = fract(uv);\n    col += fract(uv.x + iTime) + fract(uv.y + iTime);\n    \n    vec3 rgb = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    col *= rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyBWw", "name": "hoeled_swirl", "author": "hoeled", "description": "Rotated rectangles.", "tags": ["swirl"], "likes": 4, "viewed": 96, "date": "1607299116", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "mat2 Rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Square(vec2 uv, float size) {\n\tvec2 s = abs(uv) - vec2(size);\n    float square = length(max(s, .0));\n    square = smoothstep(.001, .0, square);\n    return square;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.06);\n    float t = sin(4.+(sin(iTime)*.2+.2));\n    uv *= .35;\n    uv *= Rot(sin(iTime*.5));\n    \n    for(float i=.0; i<20.5; i=i+.1) {\n    \tuv *= Rot(.049);\n        float size = .01 * i;\n        col.bg -= i*.0001;\n        float strength = .0037;\n        col -= Square(uv, size)*strength;\n    }\n    \n    col *= col*2.;\n    \n    float d = length(uv);\n    \n    vec2 fs = vec2(.0, .47);\n    float focus = smoothstep(fs.x, fs.y, d);\n    col += focus;\n    \n    col += smoothstep(.05, .00, d)*.05;\n    \n    col.g += smoothstep(0.06, 0.3, d);\n    col.r -= smoothstep(0.06, 0.3, d);\n    col = clamp(col, 0., 1.);\n    col -= vec3(.22, 1., 1.);\n    \n    col.b = col.r*.3;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyBWy", "name": "hoeled_linear_animations", "author": "hoeled", "description": "Linear animations.", "tags": ["circles", "animation", "linear"], "likes": 1, "viewed": 32, "date": "1607814590", "time_retrieved": "2024-06-20T20:26:41.239964", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float aa = 1.5 / iResolution.y;\n    vec3 col = vec3(.2);\n    \n    // fade\n    col += mix(smoothstep(0.02+aa, 0.02, length(uv)), 0., smoothstep(0.0, 1., fract(iTime)));\n    \n    // position adjustment\n    uv.x -= .5;\n    uv.y -= .08;\n    \n    // triangle wave animation\n    float scale = 1.;\n    float mod = scale - abs(mod(abs(iTime), 2.*scale) - scale);\n    \n    // top circle\n    float d = length(vec2(uv.x+mod, uv.y));\n    float circle = smoothstep(0.02+aa, 0.02, d);\n    col += circle;\n    \n    // 0->1 animation\n    scale = 1.;\n    mod = fract(iTime) * scale;\n    \n    // bottom circle\n    d = length(vec2(uv.x+mod, uv.y+.16));\n    circle = smoothstep(0.02+aa, 0.02, d);\n    col += circle;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyfDc", "name": "River Flight (optimized)", "author": "jarble", "description": "I edited dr2's [url=https://www.shadertoy.com/view/4sSXDG]\"River Flight\" shader[/url] to improve its performance. The raymarching precision decreases slightly with each step, so the framerate is improved.", "tags": ["raymarching", "landscape", "aircraft"], "likes": 8, "viewed": 294, "date": "1608064689", "time_retrieved": "2024-06-20T20:26:44.106857", "image_code": "// \"River Flight\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrCapsDf (vec3 p, vec2 b)\n{\n  return length (p - vec3 (0., 0., b.x * clamp (p.z / b.x, -1., 1.))) - b.y;\n}\n\nfloat PrCylDf (vec3 p, vec2 b)\n{\n  return max (length (p.xy) - b.x, abs (p.z) - b.y);\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nint idObj;\nmat3 flyerMat;\nvec3 flyerPos, engPos, qHit, qHitTransObj, sunDir, sunCol;\nvec2 trkOffset;\nfloat szFac, wSpan, tCur;\nconst float dstFar = 400.;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (24. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     19. * sin (0.0032 * t) + 100. * trkOffset.x, 0., t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = p * 0.06;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4) {\n      if (hiRes == 0) break;\n    }\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y -= 2.;\n  float g = smoothstep (1.5, 4.5, sqrt (abs (p.x - pt.x)));\n  return min (ht, pt.y * (1. - g) + ht * g);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.1, 0.08, 0.);\n  vec2 q = p.xz;\n  float f, d;\n  float cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  vec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      vec3 c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + vec3 (0.02, 0.1, 0.02));\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol7, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  float dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.15, 0.4 * h) + 0.008 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.1;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.2 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.15, 0.2, 0.65);\n  vec3 col;\n  col = sbCol + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 200.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.5) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.85), cloudFac);\n  return col;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.01;\n  float eps = 0.001;\n  for (int i = 0; i < 80; i++) {\n    vec3 p = ro + rd * d;\n    float h = p.y - GrndHt (p.xz, 0);\n    sh = min (sh, 20. * h / d);\n    d += 0.5;\n    if (h < eps*(1.0+d)) break;\n    eps *= 1.02;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, leCut, leRad;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  vec2 q = p.yz;\n  float w = max (length (q - vec2 (wg.sRad, 0.)),\n     length (q + vec2 (wg.sRad, 0.)));\n  w = max (max (w - wg.thck, abs (p.x - wg.trans) - wg.span),\n     p.z - wg.leCut);\n  return min (w, max (length (q - vec2 (0., wg.leCut)) - wg.leRad,\n     abs (p.x - wg.trans) - wg.span));\n}\n\nfloat PropelDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  q.x = abs (q.x);\n  q -= engPos;\n  d = PrCylDf (q - vec3 (0., 0., 3.65), vec2 (1.9, 0.05));\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit * szFac;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = PropelDf (flyerMat * (p - flyerPos), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol*(1.0+dHit) || dHit > dstFar) break;\n    dTol *= 1.01;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 q;\n  WingParm wg;\n  float d, wr, ws, cLen;\n  const float wSweep = 0.2;\n  const float fusLen = 11.;\n  const float taPos = 12.5;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  wr = q.z / fusLen;\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.045 + 0.08 * wr, 0.),\n     fusLen * vec2 (0.46, 0.11));\n  if (d < dHit) {\n    dHit = d;  idObj = 1;  qHit = q;\n  }\n  d = PrCapsDf (q - fusLen * vec3 (0., 0., -0.32),\n     fusLen * vec2 (1., 0.15 - 0.051 * wr * wr));\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 2;  qHit = q;\n  }\n  ws = wSweep * abs (p.x) / wSpan;\n  q = p + vec3 (0., 0.054 * fusLen - 6. * ws, 12. * ws);\n  wg = WingParm (wSpan, 13.7, 0., 14., 1.72, 0.195);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.2) {\n    dHit = SmoothMin (dHit, d, 0.2);  idObj = 3;  qHit = q;\n   }\n  q = p + vec3 (0., -0.1 - 6. * ws, taPos + 12. * ws);\n  wg = WingParm (0.4 * wSpan, 6.8, 0., 7., 1.2, 0.095);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 4;  qHit = q;\n  }\n  ws = wSweep * abs (p.y) / wSpan;\n  q = p.yxz + vec3 (-0.2, 0., taPos + 12. * ws);\n  wg = WingParm (0.15 * wSpan, 6.8, 2.2, 7., 1.2, 0.095);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 5;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  cLen = 3.5;\n  wr = q.z / cLen;\n  d = PrCylDf (q - engPos, cLen * vec2 (0.2  - 0.07 * wr * wr, 1.));\n  float d2 = PrCylDf (q - engPos, cLen * vec2 (0.04, 1.02));\n  d = max (d, - d2);\n  if (d < dHit) {\n    dHit = d;  idObj = 6;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  d = PrConeDf (q - engPos - vec3 (0., 0., 4.2), vec3 (0.8, 0.6, 0.7));\n  if (d < dHit) {\n    dHit = d;  idObj = 7;  qHit = q;\n  }\n  q = p;\n  cLen = 2.8;\n  q.z += wSweep * wSpan - 0.025 * cLen;\n  q.x = abs (q.x);\n  wr = q.z / cLen;\n  d = PrCapsDf (q - vec3 (wSpan + 0.1, 0.5 * wSweep * wSpan - 0.6, -0.5),\n     cLen * vec2 (1., 0.15 - 0.055 * wr * wr));\n  if (d < dHit) {\n    dHit = d;  idObj = 8;  qHit = q;\n  }\n  return 0.8 * dHit * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = FlyerDf (flyerMat * (p - flyerPos), dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol*(1.0+dHit) || dHit > dstFar) break;\n    dTol *= 1.01;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float dTol = 0.01;\n  float sh = 1.;\n  float d = 0.07 * szFac;\n  for (int i = 0; i < 50; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.07 * szFac;\n    if (h < dTol*(1.0+d)) break;\n    dTol *= 1.01;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 p, vec3 n)\n{\n  vec3 bCol = vec3 (0.8, 0.8, 0.85), wCol = vec3 (0.3, 0.3, 0.7),\n     tCol = vec3 (0.9, 0.7, 0.), uCol = vec3 (0.9, 0.1, 0.);\n  float cFac = 1.;\n  if (idObj >= 3 && idObj <= 5) {\n    float s1, s2;\n    if (idObj == 3) {\n      s1 = 2.2;  s2 = 6.;\n    } else if (idObj == 4) {\n      s1 = 1.2;  s2 = 1.7;\n    } else if (idObj == 5) {\n      s1 = 1.;  s2 = 1.;\n    }\n    if (abs (qHit.x) > s2 - 0.03)\n       cFac = 1. - 0.9 * SmoothBump (- 0.08, 0.08, 0.02, qHit.z + s1);\n    if (qHit.z < - s1)\n       cFac = 1. - 0.9 * SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s2);\n  }\n  vec3 col;\n  vec3 nn;\n  if (idObj >= 1 && idObj <= 5) nn = flyerMat * n;\n  if (idObj == 1 || idObj == 2) {\n    col = mix (uCol, bCol, 1. - smoothstep (-0.6, 0., nn.y));\n    if (idObj == 2 && nn.y < 0.)\n       col = mix (bCol, wCol, SmoothBump (-0.8, 0.8, 0.3, qHit.z + 0.28));         \n  } else if (idObj == 3 || idObj == 4) {\n    col = mix (bCol, wCol, SmoothBump (-0.8, 0.8, 0.3, qHit.z));\n  } else if (idObj == 5) {\n    col = mix (bCol, tCol, SmoothBump (-0.6, 0.8, 0.3, qHit.z));\n  } else if (idObj == 6) {\n    col = bCol;\n  } else if (idObj == 7 || idObj == 8) {\n    col = tCol;\n  }\n  if (idObj == 1) {\n    if (qHit.z > 4.5 && abs (qHit.x) > 0.07) idObj = 10;\n  } else if (idObj == 2) {\n    float s = - qHit.z;\n    if (s > 0. && s < 9.) {\n      vec2 ws = vec2 (qHit.y - 0.5, mod (s + 1.5, 1.5) - 0.75);\n      ws *= ws;\n      if (dot (ws, ws) < 0.02) idObj = 10;\n    }\n  }\n  return col * cFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  float eps = 0.01;\n  vec4 col4;\n  vec3 objCol, col, vn;\n  float dstHit, dstGrnd, dstObj, dstPropel, f;\n  int idObjT;\n  vec3 roo = ro;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  wSpan = 12.;\n  engPos = vec3 (0.35 * wSpan, -0.2, -1.5);\n  idObj = 0;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstPropel = TransObjRay (ro, rd);\n  if (dstObj < dstPropel) dstPropel = dstFar;\n  float refFac = 1.;\n  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n    float dw = - ro.y / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += eps * rd;\n    eps *= 1.01;\n    dstGrnd = GrndRay (ro, rd);\n    idObj = 0;\n    dstObj = ObjRay (ro, rd);\n    idObjT = idObj;\n    refFac *= 0.6;\n  }\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, vn);\n    if (idObj == 10) objCol = vec3 (0.2) + 0.5 * SkyCol (ro, reflect (rd, vn));\n    float dif = max (dot (vn, sunDir), 0.);\n    col = sunCol * objCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, sunDir) *\n       (dif + 0.5 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n    dstHit = dstObj;\n  } else {\n    vec3 rp = ro + dstGrnd * rd;\n    if (refFac < 1.) dstHit = length (rp - roo);\n    else dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro = rp;\n      isGrnd = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n    }\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    col4 = GrndCol (ro, vn);\n    col = col4.xyz * refFac;\n    float dif = max (dot (vn, sunDir), 0.);\n    col *= sunCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * GrndSShadow (ro, sunDir) *\n       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n  }\n  if (dstPropel < dstFar) col = 0.7 * col + 0.1 -\n     0.04 * SmoothBump (1.5, 1.7, 0.02, length (qHitTransObj.xy));\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 2.7;\n  tCur = 15. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (0.9, 1., 0.4));\n  sunCol = vec3 (1., 0.9, 0.8);\n  vec3 ro, rd, vd, fpF, fpB, vDir;\n  szFac = 0.25;\n  float dt = 1.;\n  fpF = TrackPath (tCur + dt);\n  flyerPos = TrackPath (tCur);\n  fpB = TrackPath (tCur - dt);\n  vec3 vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  vec3 acc = (fpF - 2. * flyerPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  float roll = 12. * length (va);\n  if (va.y < 0.) roll *= -1.;\n  vDir = normalize (vel);\n  float cRl = cos (roll);\n  float sRl = sin (roll);\n  flyerMat = mat3 (cRl, - sRl, 0., sRl, cRl, 0., 0., 0., 1.) *\n     mat3 (vDir.z, 0., vDir.x, 0., 1., 0., - vDir.x, 0., vDir.z);\n  float vuPeriod = 500.;\n  flyerPos.y = 3. + 1.5 * sin (2.5 * tCur / vuPeriod);\n  float lookDir = 2. * mod (floor (tCur / vuPeriod), 2.) - 1.;\n  ro = TrackPath (tCur - 40. * lookDir * (1. -\n     0.8 * abs (sin (pi * mod (tCur, vuPeriod) / vuPeriod))));\n  ro.y = 3. + 0.6 * sin (0.16 * tCur / vuPeriod);\n  vd = flyerPos - ro;\n  vd.y = 0.;\n  vd = normalize (lookDir * vDir + 0.3 * normalize (vd));\n  mat3 scMat = mat3 (vd.z, 0., - vd.x, 0., 1., 0., vd);\n  rd = scMat * normalize (vec3 (uv, zmFac));\n  vec3 col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.7), col, pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.3));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyfDD", "name": "A lot of spheres, ported to Rust", "author": "Boscop", "description": "\"A lot of spheres\" by Reinder Nijhoff, ported to Rust, compiled to GLSL.\nOriginal: https://www.shadertoy.com/view/lsX3WH\nRust code here:\nhttps://github.com/LykenSol/rust-gpu-shadertoys/blob/fa1b979a18/shaders/src/a_lot_of_spheres.rs", "tags": ["spheres", "rust", "rustgpu"], "likes": 0, "viewed": 203, "date": "1607102931", "time_retrieved": "2024-06-20T20:26:59.136194", "image_code": "struct Uniforms\n{\n    vec3 resolution;\n    vec4 mouse;\n    vec4 date;\n    float time;\n    float sample_rate;\n    int frame;\n    float time_delta;\n    float frame_rate;\n    float channel_time[4];\n    vec3 channel_resolution[4];\n};\nstruct Inputs\n{\n    vec3 resolution;\n    float time;\n};\nvec2 _282;\nvec3 _283;\nfloat _284;\nuint _285;\nuint _286;\nint _287;\nvec4 _288;\nvoid _glam_f32_vec3a_Vec3A_as_core_convert_From_glam_f32_vec3a_Vec3A_from(out vec3 _3263, vec3 _3264)\n{\n    _3263 = _3264;\n}\nvoid _glam_f32_vec3a_Vec3A_as_core_convert_Into_glam_f32_vec3a_Vec3A_into(inout vec3 _3257, vec3 _3258)\n{\n    vec3 _3260 = _3258;\n    _glam_f32_vec3a_Vec3A_as_core_convert_From_glam_f32_vec3a_Vec3A_from(_3257, _3260);\n}\nbool spheres_intersect_plane(vec3 _381, vec3 _382, float _383, inout float _384)\n{\n    float _409;\n    float _410;\n    float _411;\n    uint _412;\n    bool _413;\n    if (_382.y == 0.0)\n    {\n        _409 = _284;\n        _410 = _284;\n        _411 = _284;\n        _412 = false ? uint(1) : uint(0);\n        _413 = true;\n    }\n    else\n    {\n        float _400 = min((-(_381.y - _383)) / _382.y, 100000.0);\n        uint _407;\n        bool _408;\n        if (_400 > 0.0)\n        {\n            _384 = _400;\n            _407 = true ? uint(1) : uint(0);\n            _408 = true;\n        }\n        else\n        {\n            _407 = false ? uint(1) : uint(0);\n            _408 = true;\n        }\n        _409 = _400;\n        _410 = _400;\n        _411 = _400;\n        _412 = _407;\n        _413 = _408;\n    }\n    if (_413)\n    {\n        return _412 != uint(0);\n    }\n    else\n    {\n    }\n}\nfloat _f32_as_shared_FloatExt_gl_sign(float _3469)\n{\n    float _3480;\n    if (_3469 < 0.0)\n    {\n        _3480 = -1.0;\n    }\n    else\n    {\n        float _3479;\n        if (_3469 == 0.0)\n        {\n            _3479 = 0.0;\n        }\n        else\n        {\n            _3479 = 1.0;\n        }\n        _3480 = _3479;\n    }\n    return _3480;\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_gl_sign(inout vec3 _3414, vec3 _3415)\n{\n    _3414.x = _f32_as_shared_FloatExt_gl_sign(_3415.x);\n    _3414.y = _f32_as_shared_FloatExt_gl_sign(_3415.y);\n    _3414.z = _f32_as_shared_FloatExt_gl_sign(_3415.z);\n}\nvoid _glam_f32_vec2_Vec2_as_shared_VecExt_sin(inout vec2 _3448, vec2 _3449)\n{\n    _3448.x = sin(_3449.x);\n    _3448.y = sin(_3449.y);\n}\nfloat _f32_as_shared_FloatExt_gl_fract(float _3465)\n{\n    return _3465 - floor(_3465);\n}\nvoid _glam_f32_vec2_Vec2_as_shared_VecExt_gl_fract(inout vec2 _3437, vec2 _3438)\n{\n    _3437.x = _f32_as_shared_FloatExt_gl_fract(_3438.x);\n    _3437.y = _f32_as_shared_FloatExt_gl_fract(_3438.y);\n}\nvoid spheres_hash2_vec(inout vec2 _316, vec2 _317)\n{\n    vec2 _332 = _282;\n    _332.x = _317.x * _317.y;\n    vec2 _333 = _332;\n    _333.y = _317.x + _317.y;\n    vec2 _320 = _333;\n    vec2 _319;\n    _glam_f32_vec2_Vec2_as_shared_VecExt_sin(_319, _320);\n    vec2 _336 = _282;\n    _336.x = 2.1459124088287353515625;\n    vec2 _337 = _336;\n    _337.y = 3.349042415618896484375;\n    vec2 _344 = _282;\n    _344.x = _319.x * _337.x;\n    vec2 _345 = _344;\n    _345.y = _319.y * _337.y;\n    vec2 _321 = _345;\n    _glam_f32_vec2_Vec2_as_shared_VecExt_gl_fract(_316, _321);\n}\nvoid spheres_get_sphere_offset(vec2 _592, out vec2 _593)\n{\n    vec2 _598 = _282;\n    _598.x = 43.119998931884765625;\n    vec2 _599 = _598;\n    _599.y = 1.230000019073486328125;\n    vec2 _606 = _282;\n    _606.x = _592.x + _599.x;\n    vec2 _607 = _606;\n    _607.y = _592.y + _599.y;\n    vec2 _596 = _607;\n    vec2 _595;\n    spheres_hash2_vec(_595, _596);\n    vec2 _610 = _282;\n    _610.x = 0.5;\n    vec2 _611 = _610;\n    _611.y = 0.5;\n    vec2 _618 = _282;\n    _618.x = _595.x - _611.x;\n    vec2 _619 = _618;\n    _619.y = _595.y - _611.y;\n    vec2 _624 = _282;\n    _624.x = _619.x * 5.0;\n    vec2 _625 = _624;\n    _625.y = _619.y * 5.0;\n    _593 = _625;\n}\nfloat spheres_hash(float _311)\n{\n    return _f32_as_shared_FloatExt_gl_fract(sin(_311) * 43758.546875);\n}\nvoid _spheres_Inputs_get_moving_sphere_position(Inputs _626, vec2 _627, vec2 _628, out vec3 _629)\n{\n    float _640 = 0.100000001490116119384765625 + spheres_hash(((_627.x * 1.23114001750946044921875) + 5.34200000762939453125) + (74.3242340087890625 * _627.y));\n    float _647 = _f32_as_shared_FloatExt_gl_fract((14.0 * _640) + ((_626.time / _640) * 0.300000011920928955078125));\n    vec2 _662 = _282;\n    _662.x = _627.x + _628.x;\n    vec2 _663 = _662;\n    _663.y = _627.y + _628.y;\n    vec3 _666 = _283;\n    _666.x = _663.x;\n    vec3 _667 = _666;\n    _667.y = (_640 * 30.0) * abs((4.0 * _647) * (1.0 - _647));\n    vec3 _668 = _667;\n    _668.z = _663.y;\n    vec3 _669 = _283;\n    _669.x = 8.0;\n    vec3 _670 = _669;\n    _670.y = 2.0;\n    vec3 _671 = _670;\n    _671.z = 8.0;\n    vec3 _678 = _283;\n    _678.x = 0.5 * _671.x;\n    vec3 _679 = _678;\n    _679.y = 0.5 * _671.y;\n    vec3 _680 = _679;\n    _680.z = 0.5 * _671.z;\n    vec3 _690 = _283;\n    _690.x = _668.x + _680.x;\n    vec3 _691 = _690;\n    _691.y = _668.y + _680.y;\n    vec3 _692 = _691;\n    _692.z = _668.z + _680.z;\n    _629 = _692;\n}\nbool spheres_intersect_unit_sphere(vec3 _418, vec3 _419, vec3 _420, inout float _421, inout vec3 _422)\n{\n    vec3 _435 = _283;\n    _435.x = _418.x - _420.x;\n    vec3 _436 = _435;\n    _436.y = _418.y - _420.y;\n    vec3 _437 = _436;\n    _437.z = _418.z - _420.z;\n    float _449 = ((_419.x * _437.x) + (_419.y * _437.y)) + (_419.z * _437.z);\n    float _463 = (_449 * _449) - ((((_437.x * _437.x) + (_437.y * _437.y)) + (_437.z * _437.z)) - 1.0);\n    float _557;\n    float _558;\n    float _559;\n    vec3 _560;\n    vec3 _561;\n    float _562;\n    vec3 _563;\n    float _564;\n    vec3 _565;\n    vec3 _566;\n    float _567;\n    vec3 _568;\n    vec3 _569;\n    vec3 _570;\n    vec3 _571;\n    vec3 _572;\n    vec3 _573;\n    vec3 _574;\n    vec3 _575;\n    vec3 _576;\n    vec3 _577;\n    float _578;\n    uint _579;\n    bool _580;\n    bool _581;\n    if (_463 > 0.0)\n    {\n        float _469 = sqrt(_463);\n        float _470 = (-_449) - _469;\n        float _534;\n        float _535;\n        float _536;\n        vec3 _537;\n        vec3 _538;\n        float _539;\n        vec3 _540;\n        float _541;\n        vec3 _542;\n        vec3 _543;\n        vec3 _544;\n        vec3 _545;\n        vec3 _546;\n        vec3 _547;\n        vec3 _548;\n        vec3 _549;\n        vec3 _550;\n        vec3 _551;\n        vec3 _552;\n        vec3 _553;\n        uint _554;\n        bool _555;\n        bool _556;\n        if (_470 > 0.0)\n        {\n            vec3 _483 = _283;\n            _483.x = _470 * _419.x;\n            vec3 _484 = _483;\n            _484.y = _470 * _419.y;\n            vec3 _485 = _484;\n            _485.z = _470 * _419.z;\n            vec3 _495 = _283;\n            _495.x = _418.x + _485.x;\n            vec3 _496 = _495;\n            _496.y = _418.y + _485.y;\n            vec3 _497 = _496;\n            _497.z = _418.z + _485.z;\n            vec3 _508 = _283;\n            _508.x = _497.x - _420.x;\n            vec3 _509 = _508;\n            _509.y = _497.y - _420.y;\n            vec3 _510 = _509;\n            _510.z = _497.z - _420.z;\n            float _521 = ((_510.x * _510.x) + (_510.y * _510.y)) + (_510.z * _510.z);\n            float _522 = sqrt(_521);\n            float _523 = 1.0 / _522;\n            vec3 _530 = _283;\n            _530.x = _510.x * _523;\n            vec3 _531 = _530;\n            _531.y = _510.y * _523;\n            vec3 _532 = _531;\n            _532.z = _510.z * _523;\n            _422 = _532;\n            _421 = _470;\n            _534 = _523;\n            _535 = _522;\n            _536 = _521;\n            _537 = _510;\n            _538 = _510;\n            _539 = _522;\n            _540 = _510;\n            _541 = _523;\n            _542 = _510;\n            _543 = _510;\n            _544 = _510;\n            _545 = _532;\n            _546 = _420;\n            _547 = _497;\n            _548 = _510;\n            _549 = _485;\n            _550 = _418;\n            _551 = _497;\n            _552 = _419;\n            _553 = _485;\n            _554 = true ? uint(1) : uint(0);\n            _555 = true;\n            _556 = false;\n        }\n        else\n        {\n            _534 = _284;\n            _535 = _284;\n            _536 = _284;\n            _537 = _283;\n            _538 = _283;\n            _539 = _284;\n            _540 = _283;\n            _541 = _284;\n            _542 = _283;\n            _543 = _283;\n            _544 = _283;\n            _545 = _283;\n            _546 = _283;\n            _547 = _283;\n            _548 = _283;\n            _549 = _283;\n            _550 = _283;\n            _551 = _283;\n            _552 = _283;\n            _553 = _283;\n            _554 = _285;\n            _555 = false;\n            _556 = true;\n        }\n        _557 = _534;\n        _558 = _535;\n        _559 = _536;\n        _560 = _537;\n        _561 = _538;\n        _562 = _539;\n        _563 = _540;\n        _564 = _541;\n        _565 = _542;\n        _566 = _543;\n        _567 = _469;\n        _568 = _544;\n        _569 = _545;\n        _570 = _546;\n        _571 = _547;\n        _572 = _548;\n        _573 = _549;\n        _574 = _550;\n        _575 = _551;\n        _576 = _552;\n        _577 = _553;\n        _578 = _470;\n        _579 = _554;\n        _580 = _555;\n        _581 = _556;\n    }\n    else\n    {\n        _557 = _284;\n        _558 = _284;\n        _559 = _284;\n        _560 = _283;\n        _561 = _283;\n        _562 = _284;\n        _563 = _283;\n        _564 = _284;\n        _565 = _283;\n        _566 = _283;\n        _567 = _284;\n        _568 = _283;\n        _569 = _283;\n        _570 = _283;\n        _571 = _283;\n        _572 = _283;\n        _573 = _283;\n        _574 = _283;\n        _575 = _283;\n        _576 = _283;\n        _577 = _283;\n        _578 = _463;\n        _579 = _285;\n        _580 = false;\n        _581 = true;\n    }\n    uint _586;\n    bool _587;\n    if (_581)\n    {\n        _586 = false ? uint(1) : uint(0);\n        _587 = true;\n    }\n    else\n    {\n        _586 = _579;\n        _587 = _580;\n    }\n    if (_587)\n    {\n        return _586 != uint(0);\n    }\n    else\n    {\n    }\n}\nvoid spheres_get_sphere_position(vec2 _693, vec2 _694, out vec3 _695)\n{\n    vec2 _705 = _282;\n    _705.x = _693.x + _694.x;\n    vec2 _706 = _705;\n    _706.y = _693.y + _694.y;\n    vec3 _709 = _283;\n    _709.x = _706.x;\n    vec3 _710 = _709;\n    _710.y = 0.0;\n    vec3 _711 = _710;\n    _711.z = _706.y;\n    vec3 _712 = _283;\n    _712.x = 8.0;\n    vec3 _713 = _712;\n    _713.y = 2.0;\n    vec3 _714 = _713;\n    _714.z = 8.0;\n    vec3 _721 = _283;\n    _721.x = 0.5 * _714.x;\n    vec3 _722 = _721;\n    _722.y = 0.5 * _714.y;\n    vec3 _723 = _722;\n    _723.z = 0.5 * _714.z;\n    vec3 _733 = _283;\n    _733.x = _711.x + _723.x;\n    vec3 _734 = _733;\n    _734.y = _711.y + _723.y;\n    vec3 _735 = _734;\n    _735.z = _711.z + _723.z;\n    _695 = _735;\n}\nfloat rustoy_std_step(float _3429, float _3430)\n{\n    float _3436;\n    if (_3430 < _3429)\n    {\n        _3436 = 0.0;\n    }\n    else\n    {\n        _3436 = 1.0;\n    }\n    return _3436;\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_step(inout vec3 _3351, vec3 _3352, vec3 _3353)\n{\n    _3351.x = rustoy_std_step(_3352.x, _3353.x);\n    _3351.y = rustoy_std_step(_3352.y, _3353.y);\n    _3351.z = rustoy_std_step(_3352.z, _3353.z);\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_sin(inout vec3 _3314, vec3 _3315)\n{\n    _3314.x = sin(_3315.x);\n    _3314.y = sin(_3315.y);\n    _3314.z = sin(_3315.z);\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_gl_fract(inout vec3 _3299, vec3 _3300)\n{\n    _3299.x = _f32_as_shared_FloatExt_gl_fract(_3300.x);\n    _3299.y = _f32_as_shared_FloatExt_gl_fract(_3300.y);\n    _3299.z = _f32_as_shared_FloatExt_gl_fract(_3300.z);\n}\nvoid spheres_hash3_vec(inout vec3 _347, vec2 _348)\n{\n    vec3 _360 = _283;\n    _360.x = _348.x;\n    vec3 _361 = _360;\n    _361.y = _348.y;\n    vec3 _362 = _361;\n    _362.z = _348.x + 2.0;\n    vec3 _351 = _362;\n    vec3 _350;\n    _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_sin(_350, _351);\n    vec3 _365 = _283;\n    _365.x = 3.545312404632568359375;\n    vec3 _366 = _365;\n    _366.y = 4.14591217041015625;\n    vec3 _367 = _366;\n    _367.z = 1.34904229640960693359375;\n    vec3 _377 = _283;\n    _377.x = _350.x * _367.x;\n    vec3 _378 = _377;\n    _378.y = _350.y * _367.y;\n    vec3 _379 = _378;\n    _379.z = _350.z * _367.z;\n    vec3 _352 = _379;\n    _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_gl_fract(_347, _352);\n}\nvoid spheres_get_sphere_color(inout vec3 _736, vec2 _737)\n{\n    vec2 _748 = _282;\n    _748.x = 43.119998931884765625 * _737.y;\n    vec2 _749 = _748;\n    _749.y = 12.229999542236328125 * _737.x;\n    vec2 _756 = _282;\n    _756.x = _737.x + _749.x;\n    vec2 _757 = _756;\n    _757.y = _737.y + _749.y;\n    vec2 _740 = _757;\n    vec3 _739;\n    spheres_hash3_vec(_739, _740);\n    float _772 = 1.0 / sqrt(((_739.x * _739.x) + (_739.y * _739.y)) + (_739.z * _739.z));\n    _736.x = _739.x * _772;\n    _736.y = _739.y * _772;\n    _736.z = _739.z * _772;\n}\nfloat _f32_as_shared_Clamp_clamp(float _3459, float _3460, float _3461)\n{\n    return min(max(_3459, _3460), _3461);\n}\nvoid _spheres_Inputs_trace(inout vec3 _782, Inputs _783, vec3 _784, vec3 _785, inout vec3 _786, inout vec3 _787, inout float _788, inout int _789)\n{\n    _789 = 0;\n    _788 = 400.0;\n    float _791 = 0.0;\n    vec3 _792 = vec3(0.0);\n    vec3 _793 = vec3(0.0);\n    vec3 _805 = _784;\n    vec3 _806 = _785;\n    bool _838 = spheres_intersect_plane(_805, _806, 0.0, _791);\n    uint _851;\n    bool _852;\n    bool _853;\n    if (_838)\n    {\n        uint _848;\n        bool _849;\n        bool _850;\n        if (_791 < 400.0)\n        {\n            _848 = true ? uint(1) : uint(0);\n            _849 = true;\n            _850 = false;\n        }\n        else\n        {\n            _848 = _285;\n            _849 = false;\n            _850 = true;\n        }\n        _851 = _848;\n        _852 = _849;\n        _853 = _850;\n    }\n    else\n    {\n        _851 = _285;\n        _852 = false;\n        _853 = true;\n    }\n    uint _858;\n    bool _859;\n    if (_853)\n    {\n        _858 = false ? uint(1) : uint(0);\n        _859 = true;\n    }\n    else\n    {\n        _858 = _851;\n        _859 = _852;\n    }\n    if (_859)\n    {\n        vec3 _871;\n        vec3 _872;\n        vec3 _873;\n        vec3 _874;\n        if (_858 != uint(0))\n        {\n            _788 = _791;\n            _789 = 1;\n            vec3 _868 = _283;\n            _868.x = 0.0;\n            vec3 _869 = _868;\n            _869.y = 1.0;\n            vec3 _870 = _869;\n            _870.z = 0.0;\n            _787 = _870;\n            _871 = _283;\n            _872 = vec3(1.0);\n            _873 = _870;\n            _874 = vec3(1.0);\n        }\n        else\n        {\n            _871 = vec3(0.0);\n            _872 = _283;\n            _873 = _283;\n            _874 = vec3(0.0);\n        }\n        vec3 _882 = _283;\n        _882.x = _784.x / 8.0;\n        vec3 _883 = _882;\n        _883.y = _784.y / 8.0;\n        vec3 _884 = _883;\n        _884.z = _784.z / 8.0;\n        vec3 _891 = _283;\n        _891.x = floor(_884.x);\n        vec3 _892 = _891;\n        _892.y = floor(_884.y);\n        vec3 _893 = _892;\n        _893.z = floor(_884.z);\n        vec3 _900 = _283;\n        _900.x = _893.x * 8.0;\n        vec3 _901 = _900;\n        _901.y = _893.y * 8.0;\n        vec3 _902 = _901;\n        _902.z = _893.z * 8.0;\n        vec3 _910 = _283;\n        _910.x = 1.0 / _785.x;\n        vec3 _911 = _910;\n        _911.y = 1.0 / _785.y;\n        vec3 _912 = _911;\n        _912.z = 1.0 / _785.z;\n        vec3 _808 = _785;\n        vec3 _807;\n        _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_gl_sign(_807, _808);\n        vec3 _922 = _283;\n        _922.x = _807.x * 8.0;\n        vec3 _923 = _922;\n        _923.y = _807.y * 8.0;\n        vec3 _924 = _923;\n        _924.z = _807.z * 8.0;\n        vec3 _935 = _283;\n        _935.x = _902.x - _784.x;\n        vec3 _936 = _935;\n        _936.y = _902.y - _784.y;\n        vec3 _937 = _936;\n        _937.z = _902.z - _784.z;\n        vec3 _938 = _283;\n        _938.x = 8.0;\n        vec3 _939 = _938;\n        _939.y = 8.0;\n        vec3 _940 = _939;\n        _940.z = 8.0;\n        vec3 _947 = _283;\n        _947.x = 0.5 * _940.x;\n        vec3 _948 = _947;\n        _948.y = 0.5 * _940.y;\n        vec3 _949 = _948;\n        _949.z = 0.5 * _940.z;\n        vec3 _959 = _283;\n        _959.x = _937.x + _949.x;\n        vec3 _960 = _959;\n        _960.y = _937.y + _949.y;\n        vec3 _961 = _960;\n        _961.z = _937.z + _949.z;\n        vec3 _968 = _283;\n        _968.x = _924.x * 0.5;\n        vec3 _969 = _968;\n        _969.y = _924.y * 0.5;\n        vec3 _970 = _969;\n        _970.z = _924.z * 0.5;\n        vec3 _980 = _283;\n        _980.x = _961.x + _970.x;\n        vec3 _981 = _980;\n        _981.y = _961.y + _970.y;\n        vec3 _982 = _981;\n        _982.z = _961.z + _970.z;\n        vec3 _992 = _283;\n        _992.x = _982.x * _912.x;\n        vec3 _993 = _992;\n        _993.y = _982.y * _912.y;\n        vec3 _994 = _993;\n        _994.z = _982.z * _912.z;\n        vec2 _1002;\n        vec2 _1004;\n        vec2 _1008;\n        vec2 _1010;\n        vec2 _1012;\n        vec2 _1014;\n        vec3 _1018;\n        vec3 _1020;\n        vec3 _1022;\n        vec3 _1024;\n        vec3 _1026;\n        vec3 _1028;\n        vec3 _1030;\n        vec3 _1032;\n        vec3 _1034;\n        vec3 _1036;\n        vec3 _1038;\n        vec3 _1040;\n        vec3 _1042;\n        vec3 _1044;\n        vec3 _1046;\n        vec2 _1048;\n        vec2 _1050;\n        vec2 _1052;\n        vec3 _1054;\n        vec2 _1056;\n        vec3 _1058;\n        vec2 _1060;\n        vec2 _1062;\n        vec2 _1064;\n        vec3 _1066;\n        vec2 _1068;\n        vec3 _1070;\n        vec2 _1072;\n        vec3 _1082;\n        vec3 _1084;\n        vec3 _1086;\n        _1002 = _282;\n        _1004 = _282;\n        _1008 = _282;\n        _1010 = _282;\n        _1012 = _282;\n        _1014 = _282;\n        _1018 = _283;\n        _1020 = _283;\n        _1022 = _283;\n        _1024 = _283;\n        _1026 = _283;\n        _1028 = _283;\n        _1030 = _283;\n        _1032 = _283;\n        _1034 = _283;\n        _1036 = _283;\n        _1038 = _283;\n        _1040 = _283;\n        _1042 = _283;\n        _1044 = _283;\n        _1046 = _283;\n        _1048 = _282;\n        _1050 = _282;\n        _1052 = _282;\n        _1054 = _283;\n        _1056 = _282;\n        _1058 = _283;\n        _1060 = _282;\n        _1062 = _282;\n        _1064 = _282;\n        _1066 = _283;\n        _1068 = _282;\n        _1070 = _283;\n        _1072 = _282;\n        _1082 = _994;\n        _1084 = _902;\n        _1086 = _874;\n        float _795[3];\n        float _796[3];\n        float _799[3];\n        float _800[3];\n        vec3 _820;\n        vec3 _824;\n        vec3 _834;\n        float _998;\n        float _1001;\n        vec2 _1003;\n        vec2 _1005;\n        float _1007;\n        vec2 _1009;\n        vec2 _1011;\n        vec2 _1013;\n        vec2 _1015;\n        float _1017;\n        vec3 _1019;\n        vec3 _1021;\n        vec3 _1023;\n        vec3 _1025;\n        vec3 _1027;\n        vec3 _1029;\n        vec3 _1031;\n        vec3 _1033;\n        vec3 _1035;\n        vec3 _1037;\n        vec3 _1039;\n        vec3 _1041;\n        vec3 _1043;\n        vec3 _1045;\n        vec3 _1047;\n        vec2 _1049;\n        vec2 _1051;\n        vec2 _1053;\n        vec3 _1055;\n        vec2 _1057;\n        vec3 _1059;\n        vec2 _1061;\n        vec2 _1063;\n        vec2 _1065;\n        vec3 _1067;\n        vec2 _1069;\n        vec3 _1071;\n        vec2 _1073;\n        uint _1075;\n        uint _1077;\n        uint _1079;\n        uint _1081;\n        vec3 _1083;\n        vec3 _1085;\n        vec3 _1087;\n        bool _1089;\n        float _997;\n        float _1000;\n        float _1006;\n        float _1016;\n        uint _1074;\n        uint _1076;\n        uint _1078;\n        uint _1080 = 0u;\n        bool _1088 = true;\n        for (; _1088; _997 = _998, _1000 = _1001, _1002 = _1003, _1004 = _1005, _1006 = _1007, _1008 = _1009, _1010 = _1011, _1012 = _1013, _1014 = _1015, _1016 = _1017, _1018 = _1019, _1020 = _1021, _1022 = _1023, _1024 = _1025, _1026 = _1027, _1028 = _1029, _1030 = _1031, _1032 = _1033, _1034 = _1035, _1036 = _1037, _1038 = _1039, _1040 = _1041, _1042 = _1043, _1044 = _1045, _1046 = _1047, _1048 = _1049, _1050 = _1051, _1052 = _1053, _1054 = _1055, _1056 = _1057, _1058 = _1059, _1060 = _1061, _1062 = _1063, _1064 = _1065, _1066 = _1067, _1068 = _1069, _1070 = _1071, _1072 = _1073, _1074 = _1075, _1076 = _1077, _1078 = _1079, _1080 = _1081, _1082 = _1083, _1084 = _1085, _1086 = _1087, _1088 = _1089)\n        {\n            bool _1436;\n            bool _1437;\n            if (_1080 < 40u)\n            {\n                float _1136;\n                float _1137;\n                vec2 _1138;\n                vec2 _1139;\n                float _1140;\n                vec2 _1141;\n                vec2 _1142;\n                vec2 _1143;\n                vec2 _1144;\n                float _1145;\n                vec2 _1146;\n                vec2 _1147;\n                vec3 _1148;\n                vec2 _1149;\n                vec3 _1150;\n                vec2 _1151;\n                uint _1152;\n                bool _1153;\n                bool _1154;\n                if (_789 > 1)\n                {\n                    _1136 = _997;\n                    _1137 = _1000;\n                    _1138 = _1002;\n                    _1139 = _1004;\n                    _1140 = _1006;\n                    _1141 = _1008;\n                    _1142 = _1010;\n                    _1143 = _1012;\n                    _1144 = _1014;\n                    _1145 = _1016;\n                    _1146 = _1062;\n                    _1147 = _1064;\n                    _1148 = _1066;\n                    _1149 = _1068;\n                    _1150 = _1070;\n                    _1151 = _1072;\n                    _1152 = _1078;\n                    _1153 = true;\n                    _1154 = false;\n                }\n                else\n                {\n                    vec2 _1104 = _1072;\n                    _1104.x = _784.x;\n                    vec2 _1105 = _1104;\n                    _1105.y = _784.z;\n                    vec2 _1108 = _1068;\n                    _1108.x = _1084.x;\n                    vec2 _1109 = _1108;\n                    _1109.y = _1084.z;\n                    vec2 _1116 = _1014;\n                    _1116.x = _1105.x - _1109.x;\n                    vec2 _1117 = _1116;\n                    _1117.y = _1105.y - _1109.y;\n                    float _1124 = (_1117.x * _1117.x) + (_1117.y * _1117.y);\n                    float _1125 = sqrt(_1124);\n                    uint _1133;\n                    bool _1134;\n                    bool _1135;\n                    if (_1125 > (_788 + 8.0))\n                    {\n                        _1133 = _1078;\n                        _1134 = true;\n                        _1135 = false;\n                    }\n                    else\n                    {\n                        _1133 = false ? uint(1) : uint(0);\n                        _1134 = false;\n                        _1135 = true;\n                    }\n                    _1136 = _1125;\n                    _1137 = _1124;\n                    _1138 = _1117;\n                    _1139 = _1117;\n                    _1140 = _1125;\n                    _1141 = _1117;\n                    _1142 = _1109;\n                    _1143 = _1105;\n                    _1144 = _1117;\n                    _1145 = _1125;\n                    _1146 = _1109;\n                    _1147 = _1105;\n                    _1148 = _1084;\n                    _1149 = _1109;\n                    _1150 = _784;\n                    _1151 = _1105;\n                    _1152 = _1133;\n                    _1153 = _1134;\n                    _1154 = _1135;\n                }\n                uint _1159;\n                bool _1160;\n                if (_1153)\n                {\n                    _1159 = true ? uint(1) : uint(0);\n                    _1160 = true;\n                }\n                else\n                {\n                    _1159 = _1152;\n                    _1160 = _1154;\n                }\n                vec3 _1406;\n                vec3 _1407;\n                vec3 _1408;\n                vec3 _1409;\n                vec3 _1410;\n                vec3 _1411;\n                vec3 _1412;\n                vec3 _1413;\n                vec3 _1414;\n                vec3 _1415;\n                vec3 _1416;\n                vec3 _1417;\n                vec3 _1418;\n                vec3 _1419;\n                vec3 _1420;\n                vec2 _1421;\n                vec2 _1422;\n                vec2 _1423;\n                vec3 _1424;\n                vec2 _1425;\n                vec3 _1426;\n                vec2 _1427;\n                uint _1428;\n                uint _1429;\n                uint _1430;\n                vec3 _1431;\n                vec3 _1432;\n                vec3 _1433;\n                bool _1434;\n                bool _1435;\n                if (_1160)\n                {\n                    vec3 _1376;\n                    vec3 _1377;\n                    vec3 _1378;\n                    vec3 _1379;\n                    vec3 _1380;\n                    vec3 _1381;\n                    vec3 _1382;\n                    vec3 _1383;\n                    vec3 _1384;\n                    vec3 _1385;\n                    vec3 _1386;\n                    vec3 _1387;\n                    vec3 _1388;\n                    vec3 _1389;\n                    vec3 _1390;\n                    vec2 _1391;\n                    vec2 _1392;\n                    vec2 _1393;\n                    vec3 _1394;\n                    vec2 _1395;\n                    vec3 _1396;\n                    vec2 _1397;\n                    uint _1398;\n                    uint _1399;\n                    uint _1400;\n                    vec3 _1401;\n                    vec3 _1402;\n                    vec3 _1403;\n                    bool _1404;\n                    bool _1405;\n                    if (_1159 != uint(0))\n                    {\n                        _1376 = _1018;\n                        _1377 = _1020;\n                        _1378 = _1022;\n                        _1379 = _1024;\n                        _1380 = _1026;\n                        _1381 = _1028;\n                        _1382 = _1030;\n                        _1383 = _1032;\n                        _1384 = _1034;\n                        _1385 = _1036;\n                        _1386 = _1038;\n                        _1387 = _1040;\n                        _1388 = _1042;\n                        _1389 = _1044;\n                        _1390 = _1046;\n                        _1391 = _1048;\n                        _1392 = _1050;\n                        _1393 = _1052;\n                        _1394 = _1054;\n                        _1395 = _1056;\n                        _1396 = _1058;\n                        _1397 = _1060;\n                        _1398 = _1074;\n                        _1399 = _1076;\n                        _1400 = _1080;\n                        _1401 = _1082;\n                        _1402 = _1084;\n                        _1403 = _1086;\n                        _1404 = true;\n                        _1405 = false;\n                    }\n                    else\n                    {\n                        vec2 _794 = vec2(0.0);\n                        vec2 _1170 = _1060;\n                        _1170.x = _1084.x;\n                        vec2 _1171 = _1170;\n                        _1171.y = _1084.z;\n                        vec2 _809 = _1171;\n                        spheres_get_sphere_offset(_809, _794);\n                        vec2 _1175 = _1056;\n                        _1175.x = _1084.x;\n                        vec2 _1176 = _1175;\n                        _1176.y = _1084.z;\n                        vec2 _1182 = _1052;\n                        _1182.x = -_794.x;\n                        vec2 _1183 = _1182;\n                        _1183.y = -_794.y;\n                        vec2 _810 = _1176;\n                        vec2 _811 = _1183;\n                        _spheres_Inputs_get_moving_sphere_position(_783, _810, _811, _792);\n                        vec3 _812 = _784;\n                        vec3 _813 = _785;\n                        vec3 _814 = _792;\n                        bool _1188 = spheres_intersect_unit_sphere(_812, _813, _814, _791, _793);\n                        uint _1202;\n                        bool _1203;\n                        bool _1204;\n                        if (_1188)\n                        {\n                            uint _1199;\n                            bool _1200;\n                            bool _1201;\n                            if (_791 < _788)\n                            {\n                                _1199 = true ? uint(1) : uint(0);\n                                _1200 = true;\n                                _1201 = false;\n                            }\n                            else\n                            {\n                                _1199 = _1076;\n                                _1200 = false;\n                                _1201 = true;\n                            }\n                            _1202 = _1199;\n                            _1203 = _1200;\n                            _1204 = _1201;\n                        }\n                        else\n                        {\n                            _1202 = _1076;\n                            _1203 = false;\n                            _1204 = true;\n                        }\n                        uint _1209;\n                        bool _1210;\n                        if (_1204)\n                        {\n                            _1209 = false ? uint(1) : uint(0);\n                            _1210 = true;\n                        }\n                        else\n                        {\n                            _1209 = _1202;\n                            _1210 = _1203;\n                        }\n                        vec3 _1354;\n                        vec3 _1355;\n                        vec3 _1356;\n                        vec3 _1357;\n                        vec3 _1358;\n                        vec3 _1359;\n                        vec3 _1360;\n                        vec3 _1361;\n                        vec3 _1362;\n                        vec3 _1363;\n                        vec3 _1364;\n                        vec3 _1365;\n                        vec3 _1366;\n                        vec3 _1367;\n                        vec3 _1368;\n                        vec2 _1369;\n                        uint _1370;\n                        uint _1371;\n                        vec3 _1372;\n                        vec3 _1373;\n                        vec3 _1374;\n                        bool _1375;\n                        if (_1210)\n                        {\n                            if (_1209 != uint(0))\n                            {\n                                _788 = _791;\n                                _787 = _793;\n                                _789 = 2;\n                            }\n                            else\n                            {\n                            }\n                            vec2 _1222 = _1048;\n                            _1222.x = _1084.x;\n                            vec2 _1223 = _1222;\n                            _1223.y = _1084.z;\n                            vec2 _815 = _1223;\n                            vec2 _816 = _794;\n                            spheres_get_sphere_position(_815, _816, _792);\n                            vec3 _817 = _784;\n                            vec3 _818 = _785;\n                            vec3 _819 = _792;\n                            bool _1229 = spheres_intersect_unit_sphere(_817, _818, _819, _791, _793);\n                            uint _1243;\n                            bool _1244;\n                            bool _1245;\n                            if (_1229)\n                            {\n                                uint _1240;\n                                bool _1241;\n                                bool _1242;\n                                if (_791 < _788)\n                                {\n                                    _1240 = true ? uint(1) : uint(0);\n                                    _1241 = true;\n                                    _1242 = false;\n                                }\n                                else\n                                {\n                                    _1240 = _1074;\n                                    _1241 = false;\n                                    _1242 = true;\n                                }\n                                _1243 = _1240;\n                                _1244 = _1241;\n                                _1245 = _1242;\n                            }\n                            else\n                            {\n                                _1243 = _1074;\n                                _1244 = false;\n                                _1245 = true;\n                            }\n                            uint _1250;\n                            bool _1251;\n                            if (_1245)\n                            {\n                                _1250 = false ? uint(1) : uint(0);\n                                _1251 = true;\n                            }\n                            else\n                            {\n                                _1250 = _1243;\n                                _1251 = _1244;\n                            }\n                            vec3 _1335;\n                            vec3 _1336;\n                            vec3 _1337;\n                            vec3 _1338;\n                            vec3 _1339;\n                            vec3 _1340;\n                            vec3 _1341;\n                            vec3 _1342;\n                            vec3 _1343;\n                            vec3 _1344;\n                            vec3 _1345;\n                            vec3 _1346;\n                            vec3 _1347;\n                            vec3 _1348;\n                            uint _1349;\n                            vec3 _1350;\n                            vec3 _1351;\n                            vec3 _1352;\n                            bool _1353;\n                            if (_1251)\n                            {\n                                vec3 _1264;\n                                vec3 _1265;\n                                if (_1250 != uint(0))\n                                {\n                                    _788 = _791;\n                                    _787 = _793;\n                                    vec3 _1261 = _1044;\n                                    _1261.x = 2.0;\n                                    vec3 _1262 = _1261;\n                                    _1262.y = 2.0;\n                                    vec3 _1263 = _1262;\n                                    _1263.z = 2.0;\n                                    _789 = 3;\n                                    _1264 = _1263;\n                                    _1265 = _1263;\n                                }\n                                else\n                                {\n                                    _1264 = _1044;\n                                    _1265 = _1086;\n                                }\n                                vec3 _1269 = _1042;\n                                _1269.x = _1082.z;\n                                vec3 _1270 = _1269;\n                                _1270.y = _1082.y;\n                                vec3 _1271 = _1270;\n                                _1271.z = _1082.x;\n                                vec3 _821 = _1082;\n                                vec3 _822 = _1271;\n                                _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_step(_820, _821, _822);\n                                vec3 _1283 = _1038;\n                                _1283.x = _820.x * _924.x;\n                                vec3 _1284 = _1283;\n                                _1284.y = _820.y * _924.y;\n                                vec3 _1285 = _1284;\n                                _1285.z = _820.z * _924.z;\n                                vec3 _1295 = _1032;\n                                _1295.x = _1285.x * _912.x;\n                                vec3 _1296 = _1295;\n                                _1296.y = _1285.y * _912.y;\n                                vec3 _1297 = _1296;\n                                _1297.z = _1285.z * _912.z;\n                                vec3 _1301 = _1082;\n                                _1301.x = _1082.x + _1297.x;\n                                vec3 _1305 = _1301;\n                                _1305.y = _1301.y + _1297.y;\n                                vec3 _1309 = _1305;\n                                _1309.z = _1305.z + _1297.z;\n                                vec3 _1319 = _1024;\n                                _1319.x = _820.x * _924.x;\n                                vec3 _1320 = _1319;\n                                _1320.y = _820.y * _924.y;\n                                vec3 _1321 = _1320;\n                                _1321.z = _820.z * _924.z;\n                                vec3 _1325 = _1084;\n                                _1325.x = _1084.x + _1321.x;\n                                vec3 _1329 = _1325;\n                                _1329.y = _1325.y + _1321.y;\n                                vec3 _1333 = _1329;\n                                _1333.z = _1329.z + _1321.z;\n                                _1335 = _1321;\n                                _1336 = _924;\n                                _1337 = _820;\n                                _1338 = _1321;\n                                _1339 = _1297;\n                                _1340 = _912;\n                                _1341 = _1285;\n                                _1342 = _1297;\n                                _1343 = _924;\n                                _1344 = _820;\n                                _1345 = _1285;\n                                _1346 = _1082;\n                                _1347 = _1271;\n                                _1348 = _1264;\n                                _1349 = _1080 + 1u;\n                                _1350 = _1309;\n                                _1351 = _1333;\n                                _1352 = _1265;\n                                _1353 = true;\n                            }\n                            else\n                            {\n                            }\n                            _1354 = _1335;\n                            _1355 = _1336;\n                            _1356 = _1337;\n                            _1357 = _1338;\n                            _1358 = _1339;\n                            _1359 = _1340;\n                            _1360 = _1341;\n                            _1361 = _1342;\n                            _1362 = _1343;\n                            _1363 = _1344;\n                            _1364 = _1345;\n                            _1365 = _1346;\n                            _1366 = _1347;\n                            _1367 = _1348;\n                            _1368 = _1084;\n                            _1369 = _1223;\n                            _1370 = _1250;\n                            _1371 = _1349;\n                            _1372 = _1350;\n                            _1373 = _1351;\n                            _1374 = _1352;\n                            _1375 = _1353;\n                        }\n                        else\n                        {\n                        }\n                        _1376 = _1354;\n                        _1377 = _1355;\n                        _1378 = _1356;\n                        _1379 = _1357;\n                        _1380 = _1358;\n                        _1381 = _1359;\n                        _1382 = _1360;\n                        _1383 = _1361;\n                        _1384 = _1362;\n                        _1385 = _1363;\n                        _1386 = _1364;\n                        _1387 = _1365;\n                        _1388 = _1366;\n                        _1389 = _1367;\n                        _1390 = _1368;\n                        _1391 = _1369;\n                        _1392 = _794;\n                        _1393 = _1183;\n                        _1394 = _1084;\n                        _1395 = _1176;\n                        _1396 = _1084;\n                        _1397 = _1171;\n                        _1398 = _1370;\n                        _1399 = _1209;\n                        _1400 = _1371;\n                        _1401 = _1372;\n                        _1402 = _1373;\n                        _1403 = _1374;\n                        _1404 = false;\n                        _1405 = _1375;\n                    }\n                    _1406 = _1376;\n                    _1407 = _1377;\n                    _1408 = _1378;\n                    _1409 = _1379;\n                    _1410 = _1380;\n                    _1411 = _1381;\n                    _1412 = _1382;\n                    _1413 = _1383;\n                    _1414 = _1384;\n                    _1415 = _1385;\n                    _1416 = _1386;\n                    _1417 = _1387;\n                    _1418 = _1388;\n                    _1419 = _1389;\n                    _1420 = _1390;\n                    _1421 = _1391;\n                    _1422 = _1392;\n                    _1423 = _1393;\n                    _1424 = _1394;\n                    _1425 = _1395;\n                    _1426 = _1396;\n                    _1427 = _1397;\n                    _1428 = _1398;\n                    _1429 = _1399;\n                    _1430 = _1400;\n                    _1431 = _1401;\n                    _1432 = _1402;\n                    _1433 = _1403;\n                    _1434 = _1404;\n                    _1435 = _1405;\n                }\n                else\n                {\n                }\n                _998 = _1136;\n                _1001 = _1137;\n                _1003 = _1138;\n                _1005 = _1139;\n                _1007 = _1140;\n                _1009 = _1141;\n                _1011 = _1142;\n                _1013 = _1143;\n                _1015 = _1144;\n                _1017 = _1145;\n                _1019 = _1406;\n                _1021 = _1407;\n                _1023 = _1408;\n                _1025 = _1409;\n                _1027 = _1410;\n                _1029 = _1411;\n                _1031 = _1412;\n                _1033 = _1413;\n                _1035 = _1414;\n                _1037 = _1415;\n                _1039 = _1416;\n                _1041 = _1417;\n                _1043 = _1418;\n                _1045 = _1419;\n                _1047 = _1420;\n                _1049 = _1421;\n                _1051 = _1422;\n                _1053 = _1423;\n                _1055 = _1424;\n                _1057 = _1425;\n                _1059 = _1426;\n                _1061 = _1427;\n                _1063 = _1146;\n                _1065 = _1147;\n                _1067 = _1148;\n                _1069 = _1149;\n                _1071 = _1150;\n                _1073 = _1151;\n                _1075 = _1428;\n                _1077 = _1429;\n                _1079 = _1159;\n                _1081 = _1430;\n                _1083 = _1431;\n                _1085 = _1432;\n                _1087 = _1433;\n                _1436 = _1434;\n                _1437 = _1435;\n            }\n            else\n            {\n                _998 = _997;\n                _1001 = _1000;\n                _1003 = _1002;\n                _1005 = _1004;\n                _1007 = _1006;\n                _1009 = _1008;\n                _1011 = _1010;\n                _1013 = _1012;\n                _1015 = _1014;\n                _1017 = _1016;\n                _1019 = _1018;\n                _1021 = _1020;\n                _1023 = _1022;\n                _1025 = _1024;\n                _1027 = _1026;\n                _1029 = _1028;\n                _1031 = _1030;\n                _1033 = _1032;\n                _1035 = _1034;\n                _1037 = _1036;\n                _1039 = _1038;\n                _1041 = _1040;\n                _1043 = _1042;\n                _1045 = _1044;\n                _1047 = _1046;\n                _1049 = _1048;\n                _1051 = _1050;\n                _1053 = _1052;\n                _1055 = _1054;\n                _1057 = _1056;\n                _1059 = _1058;\n                _1061 = _1060;\n                _1063 = _1062;\n                _1065 = _1064;\n                _1067 = _1066;\n                _1069 = _1068;\n                _1071 = _1070;\n                _1073 = _1072;\n                _1075 = _1074;\n                _1077 = _1076;\n                _1079 = _1078;\n                _1081 = _1080;\n                _1083 = _1082;\n                _1085 = _1084;\n                _1087 = _1086;\n                _1436 = true;\n                _1437 = false;\n            }\n            if (_1436)\n            {\n                _782 = vec3(0.0);\n                float _2683;\n                float _2684;\n                float _2685;\n                vec3 _2686;\n                vec3 _2687;\n                float _2688;\n                vec3 _2689;\n                vec3 _2690;\n                vec3 _2691;\n                vec3 _2692;\n                float _2693;\n                float _2694;\n                float _2695;\n                float _2696;\n                float _2697;\n                float _2698;\n                float _2699;\n                vec3 _2700;\n                vec3 _2701;\n                float _2702;\n                vec3 _2703;\n                float _2704;\n                vec3 _2705;\n                vec3 _2706;\n                float _2707;\n                float _2708;\n                float _2709;\n                vec3 _2710;\n                vec3 _2711;\n                float _2712;\n                vec3 _2713;\n                float _2714;\n                vec3 _2715;\n                vec3 _2716;\n                float _2717;\n                float _2718;\n                vec3 _2719;\n                vec3 _2720;\n                vec3 _2721;\n                vec3 _2722;\n                vec3 _2723;\n                vec3 _2724;\n                vec3 _2725;\n                vec3 _2726;\n                vec3 _2727;\n                vec3 _2728;\n                vec3 _2729;\n                vec3 _2730;\n                vec3 _2731;\n                vec3 _2732;\n                vec3 _2733;\n                vec3 _2734;\n                vec3 _2735;\n                vec3 _2736;\n                vec3 _2737;\n                vec3 _2738;\n                vec3 _2739;\n                vec3 _2740;\n                vec3 _2741;\n                vec3 _2742;\n                vec3 _2743;\n                vec2 _2744;\n                vec2 _2745;\n                vec2 _2746;\n                vec2 _2747;\n                vec2 _2748;\n                vec2 _2749;\n                vec2 _2750;\n                vec2 _2751;\n                vec2 _2752;\n                vec2 _2753;\n                vec3 _2754;\n                vec2 _2755;\n                vec2 _2756;\n                vec2 _2757;\n                vec2 _2758;\n                vec2 _2759;\n                vec2 _2760;\n                vec3 _2761;\n                vec2 _2762;\n                vec3 _2763;\n                vec3 _2764;\n                vec3 _2765;\n                vec3 _2766;\n                vec3 _2767;\n                int _2768;\n                int _2769;\n                uint _2770;\n                float _2771;\n                uint _2772;\n                uint _2773;\n                uint _2774;\n                bool _2775;\n                if (_789 > 0)\n                {\n                    vec3 _1455 = _283;\n                    _1455.x = _785.x * _788;\n                    vec3 _1456 = _1455;\n                    _1456.y = _785.y * _788;\n                    vec3 _1457 = _1456;\n                    _1457.z = _785.z * _788;\n                    vec3 _1467 = _283;\n                    _1467.x = _784.x + _1457.x;\n                    vec3 _1468 = _1467;\n                    _1468.y = _784.y + _1457.y;\n                    vec3 _1469 = _1468;\n                    _1469.z = _784.z + _1457.z;\n                    _786 = _1469;\n                    vec2 _1473 = _282;\n                    _1473.x = _786.x;\n                    vec2 _1474 = _1473;\n                    _1474.y = _786.z;\n                    vec2 _1479 = _282;\n                    _1479.x = _1474.x / 8.0;\n                    vec2 _1480 = _1479;\n                    _1480.y = _1474.y / 8.0;\n                    float _1482 = floor(_1480.x);\n                    float _1484 = floor(_1480.y);\n                    vec2 _1485 = _282;\n                    _1485.x = _1482;\n                    vec2 _1486 = _1485;\n                    _1486.y = _1484;\n                    vec2 _1491 = _282;\n                    _1491.x = _1486.x * 8.0;\n                    vec2 _1492 = _1491;\n                    _1492.y = _1486.y * 8.0;\n                    uint _1507;\n                    bool _1508;\n                    bool _1509;\n                    if (_789 == 1)\n                    {\n                        _1507 = _285;\n                        _1508 = true;\n                        _1509 = false;\n                    }\n                    else\n                    {\n                        uint _1504;\n                        bool _1505;\n                        bool _1506;\n                        if (_789 == 3)\n                        {\n                            _1504 = _285;\n                            _1505 = true;\n                            _1506 = false;\n                        }\n                        else\n                        {\n                            _1504 = false ? uint(1) : uint(0);\n                            _1505 = false;\n                            _1506 = true;\n                        }\n                        _1507 = _1504;\n                        _1508 = _1505;\n                        _1509 = _1506;\n                    }\n                    uint _1514;\n                    bool _1515;\n                    if (_1508)\n                    {\n                        _1514 = true ? uint(1) : uint(0);\n                        _1515 = true;\n                    }\n                    else\n                    {\n                        _1514 = _1507;\n                        _1515 = _1509;\n                    }\n                    float _2606;\n                    float _2607;\n                    float _2608;\n                    vec3 _2609;\n                    vec3 _2610;\n                    float _2611;\n                    vec3 _2612;\n                    vec3 _2613;\n                    vec3 _2614;\n                    vec3 _2615;\n                    float _2616;\n                    float _2617;\n                    float _2618;\n                    float _2619;\n                    float _2620;\n                    float _2621;\n                    float _2622;\n                    vec3 _2623;\n                    vec3 _2624;\n                    float _2625;\n                    vec3 _2626;\n                    float _2627;\n                    vec3 _2628;\n                    vec3 _2629;\n                    float _2630;\n                    float _2631;\n                    float _2632;\n                    vec3 _2633;\n                    vec3 _2634;\n                    float _2635;\n                    vec3 _2636;\n                    float _2637;\n                    vec3 _2638;\n                    vec3 _2639;\n                    vec3 _2640;\n                    vec3 _2641;\n                    vec3 _2642;\n                    vec3 _2643;\n                    vec3 _2644;\n                    vec3 _2645;\n                    vec3 _2646;\n                    vec3 _2647;\n                    vec3 _2648;\n                    vec3 _2649;\n                    vec3 _2650;\n                    vec3 _2651;\n                    vec3 _2652;\n                    vec3 _2653;\n                    vec3 _2654;\n                    vec3 _2655;\n                    vec3 _2656;\n                    vec3 _2657;\n                    vec3 _2658;\n                    vec3 _2659;\n                    vec3 _2660;\n                    vec3 _2661;\n                    vec3 _2662;\n                    vec3 _2663;\n                    vec3 _2664;\n                    vec2 _2665;\n                    vec2 _2666;\n                    vec2 _2667;\n                    vec2 _2668;\n                    vec2 _2669;\n                    vec2 _2670;\n                    vec2 _2671;\n                    vec2 _2672;\n                    vec2 _2673;\n                    vec2 _2674;\n                    vec3 _2675;\n                    int _2676;\n                    int _2677;\n                    uint _2678;\n                    float _2679;\n                    uint _2680;\n                    uint _2681;\n                    bool _2682;\n                    if (_1515)\n                    {\n                        float _2525;\n                        float _2526;\n                        float _2527;\n                        vec3 _2528;\n                        vec3 _2529;\n                        float _2530;\n                        vec3 _2531;\n                        vec3 _2532;\n                        vec3 _2533;\n                        vec3 _2534;\n                        float _2535;\n                        float _2536;\n                        float _2537;\n                        float _2538;\n                        float _2539;\n                        float _2540;\n                        float _2541;\n                        vec3 _2542;\n                        vec3 _2543;\n                        float _2544;\n                        vec3 _2545;\n                        float _2546;\n                        vec3 _2547;\n                        vec3 _2548;\n                        float _2549;\n                        float _2550;\n                        float _2551;\n                        vec3 _2552;\n                        vec3 _2553;\n                        float _2554;\n                        vec3 _2555;\n                        float _2556;\n                        vec3 _2557;\n                        vec3 _2558;\n                        vec3 _2559;\n                        vec3 _2560;\n                        vec3 _2561;\n                        vec3 _2562;\n                        vec3 _2563;\n                        vec3 _2564;\n                        vec3 _2565;\n                        vec3 _2566;\n                        vec3 _2567;\n                        vec3 _2568;\n                        vec3 _2569;\n                        vec3 _2570;\n                        vec3 _2571;\n                        vec3 _2572;\n                        vec3 _2573;\n                        vec3 _2574;\n                        vec3 _2575;\n                        vec3 _2576;\n                        vec3 _2577;\n                        vec3 _2578;\n                        vec3 _2579;\n                        vec3 _2580;\n                        vec3 _2581;\n                        vec3 _2582;\n                        vec3 _2583;\n                        vec2 _2584;\n                        vec2 _2585;\n                        vec2 _2586;\n                        vec2 _2587;\n                        vec2 _2588;\n                        vec2 _2589;\n                        vec2 _2590;\n                        vec2 _2591;\n                        vec2 _2592;\n                        vec2 _2593;\n                        vec3 _2594;\n                        int _2595;\n                        int _2596;\n                        uint _2597;\n                        float _2598;\n                        uint _2599;\n                        uint _2600;\n                        bool _2601;\n                        if (_1514 != uint(0))\n                        {\n                            vec3 _1523 = _283;\n                            _1523.x = -8.0;\n                            vec3 _1524 = _1523;\n                            _1524.y = 0.0;\n                            vec3 _1525 = _1524;\n                            _1525.z = 8.0;\n                            float _1528;\n                            float _1531;\n                            vec3 _1533;\n                            vec3 _1535;\n                            float _1537;\n                            vec3 _1539;\n                            vec3 _1541;\n                            vec3 _1543;\n                            vec3 _1545;\n                            float _1547;\n                            float _1549;\n                            float _1551;\n                            float _1553;\n                            float _1555;\n                            float _1557;\n                            float _1559;\n                            vec3 _1561;\n                            vec3 _1563;\n                            float _1565;\n                            vec3 _1567;\n                            float _1569;\n                            vec3 _1571;\n                            vec3 _1573;\n                            float _1575;\n                            float _1577;\n                            float _1579;\n                            vec3 _1581;\n                            vec3 _1583;\n                            float _1585;\n                            vec3 _1587;\n                            float _1589;\n                            vec3 _1591;\n                            vec3 _1593;\n                            vec3 _1595;\n                            vec3 _1597;\n                            vec3 _1599;\n                            vec3 _1601;\n                            vec3 _1603;\n                            vec3 _1605;\n                            vec3 _1607;\n                            vec3 _1609;\n                            vec3 _1611;\n                            vec3 _1613;\n                            vec3 _1615;\n                            vec3 _1617;\n                            vec3 _1619;\n                            vec3 _1621;\n                            vec3 _1623;\n                            vec3 _1625;\n                            vec3 _1627;\n                            vec3 _1629;\n                            vec3 _1631;\n                            vec3 _1633;\n                            vec2 _1635;\n                            vec2 _1637;\n                            vec2 _1639;\n                            vec2 _1641;\n                            vec2 _1643;\n                            vec2 _1645;\n                            vec2 _1647;\n                            vec2 _1649;\n                            vec2 _1651;\n                            vec2 _1653;\n                            int _1655;\n                            int _1657;\n                            uint _1659;\n                            float _1661;\n                            uint _1663;\n                            uint _1665;\n                            bool _1667;\n                            _1528 = _284;\n                            _1531 = _284;\n                            _1533 = _283;\n                            _1535 = _283;\n                            _1537 = _284;\n                            _1539 = _283;\n                            _1541 = _283;\n                            _1543 = _283;\n                            _1545 = _283;\n                            _1547 = _284;\n                            _1549 = _284;\n                            _1551 = _284;\n                            _1553 = _284;\n                            _1555 = _284;\n                            _1557 = _284;\n                            _1559 = _284;\n                            _1561 = _283;\n                            _1563 = _283;\n                            _1565 = _284;\n                            _1567 = _283;\n                            _1569 = _284;\n                            _1571 = _283;\n                            _1573 = _283;\n                            _1575 = _284;\n                            _1577 = _284;\n                            _1579 = _284;\n                            _1581 = _283;\n                            _1583 = _283;\n                            _1585 = _284;\n                            _1587 = _283;\n                            _1589 = _284;\n                            _1591 = _283;\n                            _1593 = _283;\n                            _1595 = _283;\n                            _1597 = _283;\n                            _1599 = _283;\n                            _1601 = _283;\n                            _1603 = _283;\n                            _1605 = _283;\n                            _1607 = _283;\n                            _1609 = _283;\n                            _1611 = _283;\n                            _1613 = _283;\n                            _1615 = _283;\n                            _1617 = _283;\n                            _1619 = _283;\n                            _1621 = _283;\n                            _1623 = _283;\n                            _1625 = _283;\n                            _1627 = _283;\n                            _1629 = _283;\n                            _1631 = _283;\n                            _1633 = _283;\n                            _1635 = _282;\n                            _1637 = _282;\n                            _1639 = _282;\n                            _1641 = _282;\n                            _1643 = _282;\n                            _1645 = _282;\n                            _1647 = _282;\n                            _1649 = _282;\n                            _1651 = _282;\n                            _1653 = _282;\n                            _1655 = _287;\n                            _1657 = _287;\n                            _1659 = _285;\n                            _1661 = _284;\n                            _1663 = _286;\n                            _1665 = 0u;\n                            _1667 = false;\n                            float _1529;\n                            float _1532;\n                            vec3 _1534;\n                            vec3 _1536;\n                            float _1538;\n                            vec3 _1540;\n                            vec3 _1542;\n                            vec3 _1544;\n                            vec3 _1546;\n                            float _1548;\n                            float _1550;\n                            float _1552;\n                            float _1554;\n                            float _1556;\n                            float _1558;\n                            float _1560;\n                            vec3 _1562;\n                            vec3 _1564;\n                            float _1566;\n                            vec3 _1568;\n                            float _1570;\n                            vec3 _1572;\n                            vec3 _1574;\n                            float _1576;\n                            float _1578;\n                            float _1580;\n                            vec3 _1582;\n                            vec3 _1584;\n                            float _1586;\n                            vec3 _1588;\n                            float _1590;\n                            vec3 _1592;\n                            vec3 _1594;\n                            vec3 _1596;\n                            vec3 _1598;\n                            vec3 _1600;\n                            vec3 _1602;\n                            vec3 _1604;\n                            vec3 _1606;\n                            vec3 _1608;\n                            vec3 _1610;\n                            vec3 _1612;\n                            vec3 _1614;\n                            vec3 _1616;\n                            vec3 _1618;\n                            vec3 _1620;\n                            vec3 _1622;\n                            vec3 _1624;\n                            vec3 _1626;\n                            vec3 _1628;\n                            vec3 _1630;\n                            vec3 _1632;\n                            vec3 _1634;\n                            vec2 _1636;\n                            vec2 _1638;\n                            vec2 _1640;\n                            vec2 _1642;\n                            vec2 _1644;\n                            vec2 _1646;\n                            vec2 _1648;\n                            vec2 _1650;\n                            vec2 _1652;\n                            vec2 _1654;\n                            int _1656;\n                            int _1658;\n                            uint _1660;\n                            float _1662;\n                            uint _1664;\n                            uint _1666;\n                            bool _1668;\n                            bool _1670;\n                            for (bool _1669 = true; _1669; _1528 = _1529, _1531 = _1532, _1533 = _1534, _1535 = _1536, _1537 = _1538, _1539 = _1540, _1541 = _1542, _1543 = _1544, _1545 = _1546, _1547 = _1548, _1549 = _1550, _1551 = _1552, _1553 = _1554, _1555 = _1556, _1557 = _1558, _1559 = _1560, _1561 = _1562, _1563 = _1564, _1565 = _1566, _1567 = _1568, _1569 = _1570, _1571 = _1572, _1573 = _1574, _1575 = _1576, _1577 = _1578, _1579 = _1580, _1581 = _1582, _1583 = _1584, _1585 = _1586, _1587 = _1588, _1589 = _1590, _1591 = _1592, _1593 = _1594, _1595 = _1596, _1597 = _1598, _1599 = _1600, _1601 = _1602, _1603 = _1604, _1605 = _1606, _1607 = _1608, _1609 = _1610, _1611 = _1612, _1613 = _1614, _1615 = _1616, _1617 = _1618, _1619 = _1620, _1621 = _1622, _1623 = _1624, _1625 = _1626, _1627 = _1628, _1629 = _1630, _1631 = _1632, _1633 = _1634, _1635 = _1636, _1637 = _1638, _1639 = _1640, _1641 = _1642, _1643 = _1644, _1645 = _1646, _1647 = _1648, _1649 = _1650, _1651 = _1652, _1653 = _1654, _1655 = _1656, _1657 = _1658, _1659 = _1660, _1661 = _1662, _1663 = _1664, _1665 = _1666, _1667 = _1668, _1669 = _1670)\n                            {\n                                if (_1665 < 3u)\n                                {\n                                    float _1679;\n                                    float _1682;\n                                    vec3 _1684;\n                                    vec3 _1686;\n                                    float _1688;\n                                    vec3 _1690;\n                                    vec3 _1692;\n                                    vec3 _1694;\n                                    vec3 _1696;\n                                    float _1698;\n                                    float _1700;\n                                    float _1702;\n                                    float _1704;\n                                    float _1706;\n                                    float _1708;\n                                    float _1710;\n                                    vec3 _1712;\n                                    vec3 _1714;\n                                    float _1716;\n                                    vec3 _1718;\n                                    float _1720;\n                                    vec3 _1722;\n                                    vec3 _1724;\n                                    float _1726;\n                                    float _1728;\n                                    float _1730;\n                                    vec3 _1732;\n                                    vec3 _1734;\n                                    float _1736;\n                                    vec3 _1738;\n                                    float _1740;\n                                    vec3 _1742;\n                                    vec3 _1744;\n                                    vec3 _1746;\n                                    vec3 _1748;\n                                    vec3 _1750;\n                                    vec3 _1752;\n                                    vec3 _1754;\n                                    vec3 _1756;\n                                    vec3 _1758;\n                                    vec3 _1760;\n                                    vec3 _1762;\n                                    vec3 _1764;\n                                    vec3 _1766;\n                                    vec3 _1768;\n                                    vec3 _1770;\n                                    vec3 _1772;\n                                    vec3 _1774;\n                                    vec3 _1776;\n                                    vec3 _1778;\n                                    vec3 _1780;\n                                    vec3 _1782;\n                                    vec3 _1784;\n                                    vec2 _1786;\n                                    vec2 _1788;\n                                    vec2 _1790;\n                                    vec2 _1792;\n                                    vec2 _1794;\n                                    vec2 _1796;\n                                    vec2 _1798;\n                                    vec2 _1800;\n                                    vec2 _1802;\n                                    vec2 _1804;\n                                    int _1806;\n                                    int _1808;\n                                    uint _1810;\n                                    float _1812;\n                                    uint _1814;\n                                    uint _1816;\n                                    bool _1818;\n                                    _1679 = _1528;\n                                    _1682 = _1531;\n                                    _1684 = _1533;\n                                    _1686 = _1535;\n                                    _1688 = _1537;\n                                    _1690 = _1539;\n                                    _1692 = _1541;\n                                    _1694 = _1543;\n                                    _1696 = _1545;\n                                    _1698 = _1547;\n                                    _1700 = _1549;\n                                    _1702 = _1551;\n                                    _1704 = _1553;\n                                    _1706 = _1555;\n                                    _1708 = _1557;\n                                    _1710 = _1559;\n                                    _1712 = _1561;\n                                    _1714 = _1563;\n                                    _1716 = _1565;\n                                    _1718 = _1567;\n                                    _1720 = _1569;\n                                    _1722 = _1571;\n                                    _1724 = _1573;\n                                    _1726 = _1575;\n                                    _1728 = _1577;\n                                    _1730 = _1579;\n                                    _1732 = _1581;\n                                    _1734 = _1583;\n                                    _1736 = _1585;\n                                    _1738 = _1587;\n                                    _1740 = _1589;\n                                    _1742 = _1591;\n                                    _1744 = _1593;\n                                    _1746 = _1595;\n                                    _1748 = _1597;\n                                    _1750 = _1599;\n                                    _1752 = _1601;\n                                    _1754 = _1603;\n                                    _1756 = _1605;\n                                    _1758 = _1607;\n                                    _1760 = _1609;\n                                    _1762 = _1611;\n                                    _1764 = _1613;\n                                    _1766 = _1615;\n                                    _1768 = _1617;\n                                    _1770 = _1619;\n                                    _1772 = _1621;\n                                    _1774 = _1623;\n                                    _1776 = _1625;\n                                    _1778 = _1627;\n                                    _1780 = _1629;\n                                    _1782 = _1631;\n                                    _1784 = _1633;\n                                    _1786 = _1635;\n                                    _1788 = _1637;\n                                    _1790 = _1639;\n                                    _1792 = _1641;\n                                    _1794 = _1643;\n                                    _1796 = _1645;\n                                    _1798 = _1647;\n                                    _1800 = _1649;\n                                    _1802 = _1651;\n                                    _1804 = _1653;\n                                    _1806 = _1655;\n                                    _1808 = _1657;\n                                    _1810 = _1659;\n                                    _1812 = _1661;\n                                    _1814 = 0u;\n                                    _1816 = _1665;\n                                    _1818 = false;\n                                    float _1680;\n                                    float _1683;\n                                    vec3 _1685;\n                                    vec3 _1687;\n                                    float _1689;\n                                    vec3 _1691;\n                                    vec3 _1693;\n                                    vec3 _1695;\n                                    vec3 _1697;\n                                    float _1699;\n                                    float _1701;\n                                    float _1703;\n                                    float _1705;\n                                    float _1707;\n                                    float _1709;\n                                    float _1711;\n                                    vec3 _1713;\n                                    vec3 _1715;\n                                    float _1717;\n                                    vec3 _1719;\n                                    float _1721;\n                                    vec3 _1723;\n                                    vec3 _1725;\n                                    float _1727;\n                                    float _1729;\n                                    float _1731;\n                                    vec3 _1733;\n                                    vec3 _1735;\n                                    float _1737;\n                                    vec3 _1739;\n                                    float _1741;\n                                    vec3 _1743;\n                                    vec3 _1745;\n                                    vec3 _1747;\n                                    vec3 _1749;\n                                    vec3 _1751;\n                                    vec3 _1753;\n                                    vec3 _1755;\n                                    vec3 _1757;\n                                    vec3 _1759;\n                                    vec3 _1761;\n                                    vec3 _1763;\n                                    vec3 _1765;\n                                    vec3 _1767;\n                                    vec3 _1769;\n                                    vec3 _1771;\n                                    vec3 _1773;\n                                    vec3 _1775;\n                                    vec3 _1777;\n                                    vec3 _1779;\n                                    vec3 _1781;\n                                    vec3 _1783;\n                                    vec3 _1785;\n                                    vec2 _1787;\n                                    vec2 _1789;\n                                    vec2 _1791;\n                                    vec2 _1793;\n                                    vec2 _1795;\n                                    vec2 _1797;\n                                    vec2 _1799;\n                                    vec2 _1801;\n                                    vec2 _1803;\n                                    vec2 _1805;\n                                    int _1807;\n                                    int _1809;\n                                    uint _1811;\n                                    float _1813;\n                                    uint _1815;\n                                    uint _1817;\n                                    bool _1819;\n                                    bool _1821;\n                                    for (bool _1820 = true; _1820; _1679 = _1680, _1682 = _1683, _1684 = _1685, _1686 = _1687, _1688 = _1689, _1690 = _1691, _1692 = _1693, _1694 = _1695, _1696 = _1697, _1698 = _1699, _1700 = _1701, _1702 = _1703, _1704 = _1705, _1706 = _1707, _1708 = _1709, _1710 = _1711, _1712 = _1713, _1714 = _1715, _1716 = _1717, _1718 = _1719, _1720 = _1721, _1722 = _1723, _1724 = _1725, _1726 = _1727, _1728 = _1729, _1730 = _1731, _1732 = _1733, _1734 = _1735, _1736 = _1737, _1738 = _1739, _1740 = _1741, _1742 = _1743, _1744 = _1745, _1746 = _1747, _1748 = _1749, _1750 = _1751, _1752 = _1753, _1754 = _1755, _1756 = _1757, _1758 = _1759, _1760 = _1761, _1762 = _1763, _1764 = _1765, _1766 = _1767, _1768 = _1769, _1770 = _1771, _1772 = _1773, _1774 = _1775, _1776 = _1777, _1778 = _1779, _1780 = _1781, _1782 = _1783, _1784 = _1785, _1786 = _1787, _1788 = _1789, _1790 = _1791, _1792 = _1793, _1794 = _1795, _1796 = _1797, _1798 = _1799, _1800 = _1801, _1802 = _1803, _1804 = _1805, _1806 = _1807, _1808 = _1809, _1810 = _1811, _1812 = _1813, _1814 = _1815, _1816 = _1817, _1818 = _1819, _1820 = _1821)\n                                    {\n                                        if (_1814 < 3u)\n                                        {\n                                            _795[0u] = _1525.x;\n                                            _795[1u] = _1525.y;\n                                            _795[2u] = _1525.z;\n                                            float _2428;\n                                            float _2429;\n                                            vec3 _2430;\n                                            vec3 _2431;\n                                            float _2432;\n                                            vec3 _2433;\n                                            vec3 _2434;\n                                            vec3 _2435;\n                                            vec3 _2436;\n                                            float _2437;\n                                            float _2438;\n                                            float _2439;\n                                            float _2440;\n                                            float _2441;\n                                            float _2442;\n                                            float _2443;\n                                            vec3 _2444;\n                                            vec3 _2445;\n                                            float _2446;\n                                            vec3 _2447;\n                                            float _2448;\n                                            vec3 _2449;\n                                            vec3 _2450;\n                                            float _2451;\n                                            float _2452;\n                                            float _2453;\n                                            vec3 _2454;\n                                            vec3 _2455;\n                                            float _2456;\n                                            vec3 _2457;\n                                            float _2458;\n                                            vec3 _2459;\n                                            vec3 _2460;\n                                            vec3 _2461;\n                                            vec3 _2462;\n                                            vec3 _2463;\n                                            vec3 _2464;\n                                            vec3 _2465;\n                                            vec3 _2466;\n                                            vec3 _2467;\n                                            vec3 _2468;\n                                            vec3 _2469;\n                                            vec3 _2470;\n                                            vec3 _2471;\n                                            vec3 _2472;\n                                            vec3 _2473;\n                                            vec3 _2474;\n                                            vec3 _2475;\n                                            vec3 _2476;\n                                            vec3 _2477;\n                                            vec3 _2478;\n                                            vec3 _2479;\n                                            vec3 _2480;\n                                            vec2 _2481;\n                                            vec2 _2482;\n                                            vec2 _2483;\n                                            vec2 _2484;\n                                            vec2 _2485;\n                                            vec2 _2486;\n                                            vec2 _2487;\n                                            vec2 _2488;\n                                            vec2 _2489;\n                                            vec2 _2490;\n                                            int _2491;\n                                            int _2492;\n                                            uint _2493;\n                                            float _2494;\n                                            uint _2495;\n                                            bool _2496;\n                                            if (_1816 < 3u)\n                                            {\n                                                _796[0u] = _1525.x;\n                                                _796[1u] = _1525.y;\n                                                _796[2u] = _1525.z;\n                                                float _2353;\n                                                float _2354;\n                                                vec3 _2355;\n                                                vec3 _2356;\n                                                float _2357;\n                                                vec3 _2358;\n                                                vec3 _2359;\n                                                vec3 _2360;\n                                                vec3 _2361;\n                                                float _2362;\n                                                float _2363;\n                                                float _2364;\n                                                float _2365;\n                                                float _2366;\n                                                float _2367;\n                                                float _2368;\n                                                vec3 _2369;\n                                                vec3 _2370;\n                                                float _2371;\n                                                vec3 _2372;\n                                                float _2373;\n                                                vec3 _2374;\n                                                vec3 _2375;\n                                                float _2376;\n                                                float _2377;\n                                                float _2378;\n                                                vec3 _2379;\n                                                vec3 _2380;\n                                                float _2381;\n                                                vec3 _2382;\n                                                float _2383;\n                                                vec3 _2384;\n                                                vec3 _2385;\n                                                vec3 _2386;\n                                                vec3 _2387;\n                                                vec3 _2388;\n                                                vec3 _2389;\n                                                vec3 _2390;\n                                                vec3 _2391;\n                                                vec3 _2392;\n                                                vec3 _2393;\n                                                vec3 _2394;\n                                                vec3 _2395;\n                                                vec3 _2396;\n                                                vec3 _2397;\n                                                vec3 _2398;\n                                                vec3 _2399;\n                                                vec3 _2400;\n                                                vec3 _2401;\n                                                vec3 _2402;\n                                                vec3 _2403;\n                                                vec3 _2404;\n                                                vec3 _2405;\n                                                vec2 _2406;\n                                                vec2 _2407;\n                                                vec2 _2408;\n                                                vec2 _2409;\n                                                vec2 _2410;\n                                                vec2 _2411;\n                                                vec2 _2412;\n                                                vec2 _2413;\n                                                vec2 _2414;\n                                                vec2 _2415;\n                                                int _2416;\n                                                int _2417;\n                                                uint _2418;\n                                                float _2419;\n                                                uint _2420;\n                                                bool _2421;\n                                                if (_1814 < 3u)\n                                                {\n                                                    vec2 _1852 = _1804;\n                                                    _1852.x = _795[_1816];\n                                                    vec2 _1853 = _1852;\n                                                    _1853.y = _796[_1814];\n                                                    vec2 _1860 = _1802;\n                                                    _1860.x = _1492.x + _1853.x;\n                                                    vec2 _1861 = _1860;\n                                                    _1861.y = _1492.y + _1853.y;\n                                                    vec2 _797 = vec2(0.0);\n                                                    vec2 _823 = _1861;\n                                                    spheres_get_sphere_offset(_823, _797);\n                                                    vec2 _825 = _1861;\n                                                    spheres_get_sphere_color(_824, _825);\n                                                    vec3 _798 = vec3(0.0);\n                                                    vec2 _1870 = _1796;\n                                                    _1870.x = -_797.x;\n                                                    vec2 _1871 = _1870;\n                                                    _1871.y = -_797.y;\n                                                    vec2 _826 = _1861;\n                                                    vec2 _827 = _1871;\n                                                    _spheres_Inputs_get_moving_sphere_position(_783, _826, _827, _798);\n                                                    uint _1880;\n                                                    if (_789 == 1)\n                                                    {\n                                                        _1880 = true ? uint(1) : uint(0);\n                                                    }\n                                                    else\n                                                    {\n                                                        _1880 = false ? uint(1) : uint(0);\n                                                    }\n                                                    float _2164;\n                                                    float _2165;\n                                                    float _2166;\n                                                    vec3 _2167;\n                                                    vec3 _2168;\n                                                    float _2169;\n                                                    vec3 _2170;\n                                                    float _2171;\n                                                    vec3 _2172;\n                                                    vec3 _2173;\n                                                    vec3 _2174;\n                                                    vec3 _2175;\n                                                    vec3 _2176;\n                                                    vec3 _2177;\n                                                    vec3 _2178;\n                                                    vec2 _2179;\n                                                    vec2 _2180;\n                                                    vec2 _2181;\n                                                    vec2 _2182;\n                                                    int _2183;\n                                                    int _2184;\n                                                    float _2185;\n                                                    bool _2186;\n                                                    if (_1880 != uint(0))\n                                                    {\n                                                        float _1887;\n                                                        float _1890;\n                                                        float _1892;\n                                                        vec3 _1894;\n                                                        vec3 _1896;\n                                                        float _1898;\n                                                        vec3 _1900;\n                                                        float _1902;\n                                                        vec3 _1904;\n                                                        vec3 _1906;\n                                                        vec3 _1908;\n                                                        vec3 _1910;\n                                                        vec3 _1912;\n                                                        vec3 _1914;\n                                                        vec3 _1916;\n                                                        vec2 _1918;\n                                                        vec2 _1920;\n                                                        vec2 _1922;\n                                                        vec2 _1924;\n                                                        int _1926;\n                                                        int _1928;\n                                                        float _1930;\n                                                        bool _1932;\n                                                        _1887 = _1726;\n                                                        _1890 = _1728;\n                                                        _1892 = _1730;\n                                                        _1894 = _1732;\n                                                        _1896 = _1734;\n                                                        _1898 = _1736;\n                                                        _1900 = _1738;\n                                                        _1902 = _1740;\n                                                        _1904 = _1742;\n                                                        _1906 = _1744;\n                                                        _1908 = _1776;\n                                                        _1910 = _1778;\n                                                        _1912 = _1780;\n                                                        _1914 = _1782;\n                                                        _1916 = _1784;\n                                                        _1918 = _1786;\n                                                        _1920 = _1788;\n                                                        _1922 = _1790;\n                                                        _1924 = _1792;\n                                                        _1926 = _1806;\n                                                        _1928 = 0;\n                                                        _1930 = 1.0;\n                                                        _1932 = false;\n                                                        float _1888;\n                                                        float _1891;\n                                                        float _1893;\n                                                        vec3 _1895;\n                                                        vec3 _1897;\n                                                        float _1899;\n                                                        vec3 _1901;\n                                                        float _1903;\n                                                        vec3 _1905;\n                                                        vec3 _1907;\n                                                        vec3 _1909;\n                                                        vec3 _1911;\n                                                        vec3 _1913;\n                                                        vec3 _1915;\n                                                        vec3 _1917;\n                                                        vec2 _1919;\n                                                        vec2 _1921;\n                                                        vec2 _1923;\n                                                        vec2 _1925;\n                                                        int _1927;\n                                                        int _1929;\n                                                        float _1931;\n                                                        bool _1933;\n                                                        bool _1935;\n                                                        for (bool _1934 = true; _1934; _1887 = _1888, _1890 = _1891, _1892 = _1893, _1894 = _1895, _1896 = _1897, _1898 = _1899, _1900 = _1901, _1902 = _1903, _1904 = _1905, _1906 = _1907, _1908 = _1909, _1910 = _1911, _1912 = _1913, _1914 = _1915, _1916 = _1917, _1918 = _1919, _1920 = _1921, _1922 = _1923, _1924 = _1925, _1926 = _1927, _1928 = _1929, _1930 = _1931, _1932 = _1933, _1934 = _1935)\n                                                        {\n                                                            if (_1928 < 3)\n                                                            {\n                                                                float _1944;\n                                                                float _1947;\n                                                                float _1949;\n                                                                vec3 _1951;\n                                                                vec3 _1953;\n                                                                float _1955;\n                                                                vec3 _1957;\n                                                                float _1959;\n                                                                vec3 _1961;\n                                                                vec3 _1963;\n                                                                vec3 _1965;\n                                                                vec3 _1967;\n                                                                vec3 _1969;\n                                                                vec3 _1971;\n                                                                vec3 _1973;\n                                                                vec2 _1975;\n                                                                vec2 _1977;\n                                                                vec2 _1979;\n                                                                vec2 _1981;\n                                                                int _1983;\n                                                                int _1985;\n                                                                float _1987;\n                                                                bool _1989;\n                                                                _1944 = _1887;\n                                                                _1947 = _1890;\n                                                                _1949 = _1892;\n                                                                _1951 = _1894;\n                                                                _1953 = _1896;\n                                                                _1955 = _1898;\n                                                                _1957 = _1900;\n                                                                _1959 = _1902;\n                                                                _1961 = _1904;\n                                                                _1963 = _1906;\n                                                                _1965 = _1908;\n                                                                _1967 = _1910;\n                                                                _1969 = _1912;\n                                                                _1971 = _1914;\n                                                                _1973 = _1916;\n                                                                _1975 = _1918;\n                                                                _1977 = _1920;\n                                                                _1979 = _1922;\n                                                                _1981 = _1924;\n                                                                _1983 = 0;\n                                                                _1985 = _1928;\n                                                                _1987 = _1930;\n                                                                _1989 = false;\n                                                                float _1945;\n                                                                float _1948;\n                                                                float _1950;\n                                                                vec3 _1952;\n                                                                vec3 _1954;\n                                                                float _1956;\n                                                                vec3 _1958;\n                                                                float _1960;\n                                                                vec3 _1962;\n                                                                vec3 _1964;\n                                                                vec3 _1966;\n                                                                vec3 _1968;\n                                                                vec3 _1970;\n                                                                vec3 _1972;\n                                                                vec3 _1974;\n                                                                vec2 _1976;\n                                                                vec2 _1978;\n                                                                vec2 _1980;\n                                                                vec2 _1982;\n                                                                int _1984;\n                                                                int _1986;\n                                                                float _1988;\n                                                                bool _1990;\n                                                                bool _1992;\n                                                                for (bool _1991 = true; _1991; _1944 = _1945, _1947 = _1948, _1949 = _1950, _1951 = _1952, _1953 = _1954, _1955 = _1956, _1957 = _1958, _1959 = _1960, _1961 = _1962, _1963 = _1964, _1965 = _1966, _1967 = _1968, _1969 = _1970, _1971 = _1972, _1973 = _1974, _1975 = _1976, _1977 = _1978, _1979 = _1980, _1981 = _1982, _1983 = _1984, _1985 = _1986, _1987 = _1988, _1989 = _1990, _1991 = _1992)\n                                                                {\n                                                                    if (_1983 < 3)\n                                                                    {\n                                                                        float _2141;\n                                                                        float _2142;\n                                                                        float _2143;\n                                                                        vec3 _2144;\n                                                                        vec3 _2145;\n                                                                        float _2146;\n                                                                        vec3 _2147;\n                                                                        float _2148;\n                                                                        vec3 _2149;\n                                                                        vec3 _2150;\n                                                                        vec3 _2151;\n                                                                        vec3 _2152;\n                                                                        vec3 _2153;\n                                                                        vec3 _2154;\n                                                                        vec3 _2155;\n                                                                        vec2 _2156;\n                                                                        vec2 _2157;\n                                                                        vec2 _2158;\n                                                                        vec2 _2159;\n                                                                        int _2160;\n                                                                        float _2161;\n                                                                        bool _2162;\n                                                                        if (_1987 < 1.0)\n                                                                        {\n                                                                            _2141 = _1944;\n                                                                            _2142 = _1947;\n                                                                            _2143 = _1949;\n                                                                            _2144 = _1951;\n                                                                            _2145 = _1953;\n                                                                            _2146 = _1955;\n                                                                            _2147 = _1957;\n                                                                            _2148 = _1959;\n                                                                            _2149 = _1961;\n                                                                            _2150 = _1963;\n                                                                            _2151 = _1965;\n                                                                            _2152 = _1967;\n                                                                            _2153 = _1969;\n                                                                            _2154 = _1971;\n                                                                            _2155 = _1973;\n                                                                            _2156 = _1975;\n                                                                            _2157 = _1977;\n                                                                            _2158 = _1979;\n                                                                            _2159 = _1981;\n                                                                            _2160 = _1983 + 1;\n                                                                            _2161 = _1987;\n                                                                            _2162 = true;\n                                                                        }\n                                                                        else\n                                                                        {\n                                                                            _799[0u] = _1525.x;\n                                                                            _799[1u] = _1525.y;\n                                                                            _799[2u] = _1525.z;\n                                                                            float _2119;\n                                                                            float _2120;\n                                                                            float _2121;\n                                                                            vec3 _2122;\n                                                                            vec3 _2123;\n                                                                            float _2124;\n                                                                            vec3 _2125;\n                                                                            float _2126;\n                                                                            vec3 _2127;\n                                                                            vec3 _2128;\n                                                                            vec3 _2129;\n                                                                            vec3 _2130;\n                                                                            vec3 _2131;\n                                                                            vec3 _2132;\n                                                                            vec3 _2133;\n                                                                            vec2 _2134;\n                                                                            vec2 _2135;\n                                                                            vec2 _2136;\n                                                                            vec2 _2137;\n                                                                            int _2138;\n                                                                            float _2139;\n                                                                            bool _2140;\n                                                                            if (_1816 < 3u)\n                                                                            {\n                                                                                _800[0u] = _1525.x;\n                                                                                _800[1u] = _1525.y;\n                                                                                _800[2u] = _1525.z;\n                                                                                float _2091;\n                                                                                float _2092;\n                                                                                float _2093;\n                                                                                vec3 _2094;\n                                                                                vec3 _2095;\n                                                                                float _2096;\n                                                                                vec3 _2097;\n                                                                                float _2098;\n                                                                                vec3 _2099;\n                                                                                vec3 _2100;\n                                                                                vec3 _2101;\n                                                                                vec3 _2102;\n                                                                                vec3 _2103;\n                                                                                vec3 _2104;\n                                                                                vec3 _2105;\n                                                                                vec2 _2106;\n                                                                                vec2 _2107;\n                                                                                vec2 _2108;\n                                                                                vec2 _2109;\n                                                                                int _2110;\n                                                                                float _2111;\n                                                                                bool _2112;\n                                                                                if (_1814 < 3u)\n                                                                                {\n                                                                                    vec2 _2028 = _1981;\n                                                                                    _2028.x = _799[_1816];\n                                                                                    vec2 _2029 = _2028;\n                                                                                    _2029.y = _800[_1814];\n                                                                                    vec2 _2036 = _1979;\n                                                                                    _2036.x = _1492.x + _2029.x;\n                                                                                    vec2 _2037 = _2036;\n                                                                                    _2037.y = _1492.y + _2029.y;\n                                                                                    vec2 _801 = vec2(0.0);\n                                                                                    vec2 _828 = _2037;\n                                                                                    spheres_get_sphere_offset(_828, _801);\n                                                                                    vec3 _802 = vec3(0.0);\n                                                                                    vec3 _803 = vec3(0.0);\n                                                                                    vec2 _829 = _2037;\n                                                                                    vec2 _830 = _801;\n                                                                                    spheres_get_sphere_position(_829, _830, _802);\n                                                                                    float _804 = 0.0;\n                                                                                    vec3 _2053 = _1973;\n                                                                                    _2053.x = _798.x - _786.x;\n                                                                                    vec3 _2054 = _2053;\n                                                                                    _2054.y = _798.y - _786.y;\n                                                                                    vec3 _2055 = _2054;\n                                                                                    _2055.z = _798.z - _786.z;\n                                                                                    float _2066 = ((_2055.x * _2055.x) + (_2055.y * _2055.y)) + (_2055.z * _2055.z);\n                                                                                    float _2067 = sqrt(_2066);\n                                                                                    float _2068 = 1.0 / _2067;\n                                                                                    vec3 _2075 = _1967;\n                                                                                    _2075.x = _2055.x * _2068;\n                                                                                    vec3 _2076 = _2075;\n                                                                                    _2076.y = _2055.y * _2068;\n                                                                                    vec3 _2077 = _2076;\n                                                                                    _2077.z = _2055.z * _2068;\n                                                                                    vec3 _831 = _786;\n                                                                                    vec3 _832 = _2077;\n                                                                                    vec3 _833 = _802;\n                                                                                    bool _2079 = spheres_intersect_unit_sphere(_831, _832, _833, _804, _803);\n                                                                                    float _2083;\n                                                                                    if (_2079)\n                                                                                    {\n                                                                                        _2083 = 0.0;\n                                                                                    }\n                                                                                    else\n                                                                                    {\n                                                                                        _2083 = _1987;\n                                                                                    }\n                                                                                    _2091 = _2068;\n                                                                                    _2092 = _2067;\n                                                                                    _2093 = _2066;\n                                                                                    _2094 = _2055;\n                                                                                    _2095 = _2055;\n                                                                                    _2096 = _2067;\n                                                                                    _2097 = _2055;\n                                                                                    _2098 = _2068;\n                                                                                    _2099 = _2055;\n                                                                                    _2100 = _2055;\n                                                                                    _2101 = _2055;\n                                                                                    _2102 = _2077;\n                                                                                    _2103 = _786;\n                                                                                    _2104 = _798;\n                                                                                    _2105 = _2055;\n                                                                                    _2106 = _2029;\n                                                                                    _2107 = _1492;\n                                                                                    _2108 = _2037;\n                                                                                    _2109 = _2029;\n                                                                                    _2110 = _1983 + 1;\n                                                                                    _2111 = _2083;\n                                                                                    _2112 = true;\n                                                                                }\n                                                                                else\n                                                                                {\n                                                                                    for (bool _2087 = true; _2087; _2087 = true)\n                                                                                    {\n                                                                                    }\n                                                                                }\n                                                                                _2119 = _2091;\n                                                                                _2120 = _2092;\n                                                                                _2121 = _2093;\n                                                                                _2122 = _2094;\n                                                                                _2123 = _2095;\n                                                                                _2124 = _2096;\n                                                                                _2125 = _2097;\n                                                                                _2126 = _2098;\n                                                                                _2127 = _2099;\n                                                                                _2128 = _2100;\n                                                                                _2129 = _2101;\n                                                                                _2130 = _2102;\n                                                                                _2131 = _2103;\n                                                                                _2132 = _2104;\n                                                                                _2133 = _2105;\n                                                                                _2134 = _2106;\n                                                                                _2135 = _2107;\n                                                                                _2136 = _2108;\n                                                                                _2137 = _2109;\n                                                                                _2138 = _2110;\n                                                                                _2139 = _2111;\n                                                                                _2140 = _2112;\n                                                                            }\n                                                                            else\n                                                                            {\n                                                                                for (bool _2115 = true; _2115; _2115 = true)\n                                                                                {\n                                                                                }\n                                                                            }\n                                                                            _2141 = _2119;\n                                                                            _2142 = _2120;\n                                                                            _2143 = _2121;\n                                                                            _2144 = _2122;\n                                                                            _2145 = _2123;\n                                                                            _2146 = _2124;\n                                                                            _2147 = _2125;\n                                                                            _2148 = _2126;\n                                                                            _2149 = _2127;\n                                                                            _2150 = _2128;\n                                                                            _2151 = _2129;\n                                                                            _2152 = _2130;\n                                                                            _2153 = _2131;\n                                                                            _2154 = _2132;\n                                                                            _2155 = _2133;\n                                                                            _2156 = _2134;\n                                                                            _2157 = _2135;\n                                                                            _2158 = _2136;\n                                                                            _2159 = _2137;\n                                                                            _2160 = _2138;\n                                                                            _2161 = _2139;\n                                                                            _2162 = _2140;\n                                                                        }\n                                                                        _1945 = _2141;\n                                                                        _1948 = _2142;\n                                                                        _1950 = _2143;\n                                                                        _1952 = _2144;\n                                                                        _1954 = _2145;\n                                                                        _1956 = _2146;\n                                                                        _1958 = _2147;\n                                                                        _1960 = _2148;\n                                                                        _1962 = _2149;\n                                                                        _1964 = _2150;\n                                                                        _1966 = _2151;\n                                                                        _1968 = _2152;\n                                                                        _1970 = _2153;\n                                                                        _1972 = _2154;\n                                                                        _1974 = _2155;\n                                                                        _1976 = _2156;\n                                                                        _1978 = _2157;\n                                                                        _1980 = _2158;\n                                                                        _1982 = _2159;\n                                                                        _1984 = _2160;\n                                                                        _1986 = _1985;\n                                                                        _1988 = _2161;\n                                                                        _1992 = _2162;\n                                                                        _1990 = false;\n                                                                    }\n                                                                    else\n                                                                    {\n                                                                        _1945 = _1944;\n                                                                        _1948 = _1947;\n                                                                        _1950 = _1949;\n                                                                        _1952 = _1951;\n                                                                        _1954 = _1953;\n                                                                        _1956 = _1955;\n                                                                        _1958 = _1957;\n                                                                        _1960 = _1959;\n                                                                        _1962 = _1961;\n                                                                        _1964 = _1963;\n                                                                        _1966 = _1965;\n                                                                        _1968 = _1967;\n                                                                        _1970 = _1969;\n                                                                        _1972 = _1971;\n                                                                        _1974 = _1973;\n                                                                        _1976 = _1975;\n                                                                        _1978 = _1977;\n                                                                        _1980 = _1979;\n                                                                        _1982 = _1981;\n                                                                        _1984 = _1983;\n                                                                        _1986 = _1985 + 1;\n                                                                        _1988 = _1987;\n                                                                        _1992 = false;\n                                                                        _1990 = true;\n                                                                    }\n                                                                }\n                                                                _1888 = _1944;\n                                                                _1891 = _1947;\n                                                                _1893 = _1949;\n                                                                _1895 = _1951;\n                                                                _1897 = _1953;\n                                                                _1899 = _1955;\n                                                                _1901 = _1957;\n                                                                _1903 = _1959;\n                                                                _1905 = _1961;\n                                                                _1907 = _1963;\n                                                                _1909 = _1965;\n                                                                _1911 = _1967;\n                                                                _1913 = _1969;\n                                                                _1915 = _1971;\n                                                                _1917 = _1973;\n                                                                _1919 = _1975;\n                                                                _1921 = _1977;\n                                                                _1923 = _1979;\n                                                                _1925 = _1981;\n                                                                _1927 = _1983;\n                                                                _1929 = _1985;\n                                                                _1931 = _1987;\n                                                                _1935 = _1989;\n                                                                _1933 = false;\n                                                            }\n                                                            else\n                                                            {\n                                                                _1888 = _1887;\n                                                                _1891 = _1890;\n                                                                _1893 = _1892;\n                                                                _1895 = _1894;\n                                                                _1897 = _1896;\n                                                                _1899 = _1898;\n                                                                _1901 = _1900;\n                                                                _1903 = _1902;\n                                                                _1905 = _1904;\n                                                                _1907 = _1906;\n                                                                _1909 = _1908;\n                                                                _1911 = _1910;\n                                                                _1913 = _1912;\n                                                                _1915 = _1914;\n                                                                _1917 = _1916;\n                                                                _1919 = _1918;\n                                                                _1921 = _1920;\n                                                                _1923 = _1922;\n                                                                _1925 = _1924;\n                                                                _1927 = _1926;\n                                                                _1929 = _1928;\n                                                                _1931 = _1930;\n                                                                _1935 = false;\n                                                                _1933 = true;\n                                                            }\n                                                        }\n                                                        _2164 = _1887;\n                                                        _2165 = _1890;\n                                                        _2166 = _1892;\n                                                        _2167 = _1894;\n                                                        _2168 = _1896;\n                                                        _2169 = _1898;\n                                                        _2170 = _1900;\n                                                        _2171 = _1902;\n                                                        _2172 = _1904;\n                                                        _2173 = _1906;\n                                                        _2174 = _1908;\n                                                        _2175 = _1910;\n                                                        _2176 = _1912;\n                                                        _2177 = _1914;\n                                                        _2178 = _1916;\n                                                        _2179 = _1918;\n                                                        _2180 = _1920;\n                                                        _2181 = _1922;\n                                                        _2182 = _1924;\n                                                        _2183 = _1926;\n                                                        _2184 = _1928;\n                                                        _2185 = _1930;\n                                                        _2186 = _1932;\n                                                    }\n                                                    else\n                                                    {\n                                                        _2164 = _1726;\n                                                        _2165 = _1728;\n                                                        _2166 = _1730;\n                                                        _2167 = _1732;\n                                                        _2168 = _1734;\n                                                        _2169 = _1736;\n                                                        _2170 = _1738;\n                                                        _2171 = _1740;\n                                                        _2172 = _1742;\n                                                        _2173 = _1744;\n                                                        _2174 = _1776;\n                                                        _2175 = _1778;\n                                                        _2176 = _1780;\n                                                        _2177 = _1782;\n                                                        _2178 = _1784;\n                                                        _2179 = _1786;\n                                                        _2180 = _1788;\n                                                        _2181 = _1790;\n                                                        _2182 = _1792;\n                                                        _2183 = _1806;\n                                                        _2184 = _1808;\n                                                        _2185 = 1.0;\n                                                        _2186 = true;\n                                                    }\n                                                    float _2307;\n                                                    float _2308;\n                                                    vec3 _2309;\n                                                    vec3 _2310;\n                                                    float _2311;\n                                                    vec3 _2312;\n                                                    vec3 _2313;\n                                                    vec3 _2314;\n                                                    vec3 _2315;\n                                                    float _2316;\n                                                    float _2317;\n                                                    float _2318;\n                                                    float _2319;\n                                                    float _2320;\n                                                    float _2321;\n                                                    float _2322;\n                                                    vec3 _2323;\n                                                    vec3 _2324;\n                                                    float _2325;\n                                                    vec3 _2326;\n                                                    float _2327;\n                                                    vec3 _2328;\n                                                    vec3 _2329;\n                                                    vec3 _2330;\n                                                    vec3 _2331;\n                                                    vec3 _2332;\n                                                    vec3 _2333;\n                                                    vec3 _2334;\n                                                    vec3 _2335;\n                                                    vec3 _2336;\n                                                    vec3 _2337;\n                                                    vec3 _2338;\n                                                    vec3 _2339;\n                                                    vec3 _2340;\n                                                    vec3 _2341;\n                                                    vec3 _2342;\n                                                    vec3 _2343;\n                                                    vec3 _2344;\n                                                    uint _2345;\n                                                    bool _2346;\n                                                    if (_2186)\n                                                    {\n                                                        vec3 _2199 = _1774;\n                                                        _2199.x = _1087.x * _824.x;\n                                                        vec3 _2200 = _2199;\n                                                        _2200.y = _1087.y * _824.y;\n                                                        vec3 _2201 = _2200;\n                                                        _2201.z = _1087.z * _824.z;\n                                                        vec3 _2213 = _1768;\n                                                        _2213.x = _798.x - _786.x;\n                                                        vec3 _2214 = _2213;\n                                                        _2214.y = _798.y - _786.y;\n                                                        vec3 _2215 = _2214;\n                                                        _2215.z = _798.z - _786.z;\n                                                        float _2226 = ((_2215.x * _2215.x) + (_2215.y * _2215.y)) + (_2215.z * _2215.z);\n                                                        float _2227 = sqrt(_2226);\n                                                        float _2228 = 1.0 / _2227;\n                                                        vec3 _2235 = _1762;\n                                                        _2235.x = _2215.x * _2228;\n                                                        vec3 _2236 = _2235;\n                                                        _2236.y = _2215.y * _2228;\n                                                        vec3 _2237 = _2236;\n                                                        _2237.z = _2215.z * _2228;\n                                                        float _2249 = ((_2237.x * _787.x) + (_2237.y * _787.y)) + (_2237.z * _787.z);\n                                                        float _2250 = max(_2249, 0.0);\n                                                        vec3 _2263 = _1696;\n                                                        _2263.x = _798.x - _786.x;\n                                                        vec3 _2264 = _2263;\n                                                        _2264.y = _798.y - _786.y;\n                                                        vec3 _2265 = _2264;\n                                                        _2265.z = _798.z - _786.z;\n                                                        float _2276 = ((_2265.x * _2265.x) + (_2265.y * _2265.y)) + (_2265.z * _2265.z);\n                                                        float _2277 = sqrt(_2276);\n                                                        float _2281 = (_2185 * _2250) * (1.0 - _f32_as_shared_Clamp_clamp(_2277 / 8.0, 0.0, 1.0));\n                                                        vec3 _2288 = _1750;\n                                                        _2288.x = _2201.x * _2281;\n                                                        vec3 _2289 = _2288;\n                                                        _2289.y = _2201.y * _2281;\n                                                        vec3 _2290 = _2289;\n                                                        _2290.z = _2201.z * _2281;\n                                                        _782.x += _2290.x;\n                                                        _782.y += _2290.y;\n                                                        _782.z += _2290.z;\n                                                        _2307 = _2277;\n                                                        _2308 = _2276;\n                                                        _2309 = _2265;\n                                                        _2310 = _2265;\n                                                        _2311 = _2277;\n                                                        _2312 = _2265;\n                                                        _2313 = _786;\n                                                        _2314 = _798;\n                                                        _2315 = _2265;\n                                                        _2316 = _2277;\n                                                        _2317 = _2250;\n                                                        _2318 = _2250;\n                                                        _2319 = _2249;\n                                                        _2320 = _2228;\n                                                        _2321 = _2227;\n                                                        _2322 = _2226;\n                                                        _2323 = _2215;\n                                                        _2324 = _2215;\n                                                        _2325 = _2227;\n                                                        _2326 = _2215;\n                                                        _2327 = _2228;\n                                                        _2328 = _2215;\n                                                        _2329 = _2215;\n                                                        _2330 = _2290;\n                                                        _2331 = _2201;\n                                                        _2332 = _2290;\n                                                        _2333 = _786;\n                                                        _2334 = _798;\n                                                        _2335 = _787;\n                                                        _2336 = _2237;\n                                                        _2337 = _2215;\n                                                        _2338 = _2237;\n                                                        _2339 = _786;\n                                                        _2340 = _798;\n                                                        _2341 = _2215;\n                                                        _2342 = _824;\n                                                        _2343 = _1087;\n                                                        _2344 = _2201;\n                                                        _2345 = _1814 + 1u;\n                                                        _2346 = true;\n                                                    }\n                                                    else\n                                                    {\n                                                    }\n                                                    _2353 = _2307;\n                                                    _2354 = _2308;\n                                                    _2355 = _2309;\n                                                    _2356 = _2310;\n                                                    _2357 = _2311;\n                                                    _2358 = _2312;\n                                                    _2359 = _2313;\n                                                    _2360 = _2314;\n                                                    _2361 = _2315;\n                                                    _2362 = _2316;\n                                                    _2363 = _2317;\n                                                    _2364 = _2318;\n                                                    _2365 = _2319;\n                                                    _2366 = _2320;\n                                                    _2367 = _2321;\n                                                    _2368 = _2322;\n                                                    _2369 = _2323;\n                                                    _2370 = _2324;\n                                                    _2371 = _2325;\n                                                    _2372 = _2326;\n                                                    _2373 = _2327;\n                                                    _2374 = _2328;\n                                                    _2375 = _2329;\n                                                    _2376 = _2164;\n                                                    _2377 = _2165;\n                                                    _2378 = _2166;\n                                                    _2379 = _2167;\n                                                    _2380 = _2168;\n                                                    _2381 = _2169;\n                                                    _2382 = _2170;\n                                                    _2383 = _2171;\n                                                    _2384 = _2172;\n                                                    _2385 = _2173;\n                                                    _2386 = _2330;\n                                                    _2387 = _2331;\n                                                    _2388 = _2332;\n                                                    _2389 = _2333;\n                                                    _2390 = _2334;\n                                                    _2391 = _2335;\n                                                    _2392 = _2336;\n                                                    _2393 = _2337;\n                                                    _2394 = _2338;\n                                                    _2395 = _2339;\n                                                    _2396 = _2340;\n                                                    _2397 = _2341;\n                                                    _2398 = _2342;\n                                                    _2399 = _2343;\n                                                    _2400 = _2344;\n                                                    _2401 = _2174;\n                                                    _2402 = _2175;\n                                                    _2403 = _2176;\n                                                    _2404 = _2177;\n                                                    _2405 = _2178;\n                                                    _2406 = _2179;\n                                                    _2407 = _2180;\n                                                    _2408 = _2181;\n                                                    _2409 = _2182;\n                                                    _2410 = _797;\n                                                    _2411 = _1871;\n                                                    _2412 = _1853;\n                                                    _2413 = _1492;\n                                                    _2414 = _1861;\n                                                    _2415 = _1853;\n                                                    _2416 = _2183;\n                                                    _2417 = _2184;\n                                                    _2418 = _1880;\n                                                    _2419 = _2185;\n                                                    _2420 = _2345;\n                                                    _2421 = _2346;\n                                                }\n                                                else\n                                                {\n                                                    for (bool _2349 = true; _2349; _2349 = true)\n                                                    {\n                                                    }\n                                                }\n                                                _2428 = _2353;\n                                                _2429 = _2354;\n                                                _2430 = _2355;\n                                                _2431 = _2356;\n                                                _2432 = _2357;\n                                                _2433 = _2358;\n                                                _2434 = _2359;\n                                                _2435 = _2360;\n                                                _2436 = _2361;\n                                                _2437 = _2362;\n                                                _2438 = _2363;\n                                                _2439 = _2364;\n                                                _2440 = _2365;\n                                                _2441 = _2366;\n                                                _2442 = _2367;\n                                                _2443 = _2368;\n                                                _2444 = _2369;\n                                                _2445 = _2370;\n                                                _2446 = _2371;\n                                                _2447 = _2372;\n                                                _2448 = _2373;\n                                                _2449 = _2374;\n                                                _2450 = _2375;\n                                                _2451 = _2376;\n                                                _2452 = _2377;\n                                                _2453 = _2378;\n                                                _2454 = _2379;\n                                                _2455 = _2380;\n                                                _2456 = _2381;\n                                                _2457 = _2382;\n                                                _2458 = _2383;\n                                                _2459 = _2384;\n                                                _2460 = _2385;\n                                                _2461 = _2386;\n                                                _2462 = _2387;\n                                                _2463 = _2388;\n                                                _2464 = _2389;\n                                                _2465 = _2390;\n                                                _2466 = _2391;\n                                                _2467 = _2392;\n                                                _2468 = _2393;\n                                                _2469 = _2394;\n                                                _2470 = _2395;\n                                                _2471 = _2396;\n                                                _2472 = _2397;\n                                                _2473 = _2398;\n                                                _2474 = _2399;\n                                                _2475 = _2400;\n                                                _2476 = _2401;\n                                                _2477 = _2402;\n                                                _2478 = _2403;\n                                                _2479 = _2404;\n                                                _2480 = _2405;\n                                                _2481 = _2406;\n                                                _2482 = _2407;\n                                                _2483 = _2408;\n                                                _2484 = _2409;\n                                                _2485 = _2410;\n                                                _2486 = _2411;\n                                                _2487 = _2412;\n                                                _2488 = _2413;\n                                                _2489 = _2414;\n                                                _2490 = _2415;\n                                                _2491 = _2416;\n                                                _2492 = _2417;\n                                                _2493 = _2418;\n                                                _2494 = _2419;\n                                                _2495 = _2420;\n                                                _2496 = _2421;\n                                            }\n                                            else\n                                            {\n                                                for (bool _2424 = true; _2424; _2424 = true)\n                                                {\n                                                }\n                                            }\n                                            _1680 = _2428;\n                                            _1683 = _2429;\n                                            _1685 = _2430;\n                                            _1687 = _2431;\n                                            _1689 = _2432;\n                                            _1691 = _2433;\n                                            _1693 = _2434;\n                                            _1695 = _2435;\n                                            _1697 = _2436;\n                                            _1699 = _2437;\n                                            _1701 = _2438;\n                                            _1703 = _2439;\n                                            _1705 = _2440;\n                                            _1707 = _2441;\n                                            _1709 = _2442;\n                                            _1711 = _2443;\n                                            _1713 = _2444;\n                                            _1715 = _2445;\n                                            _1717 = _2446;\n                                            _1719 = _2447;\n                                            _1721 = _2448;\n                                            _1723 = _2449;\n                                            _1725 = _2450;\n                                            _1727 = _2451;\n                                            _1729 = _2452;\n                                            _1731 = _2453;\n                                            _1733 = _2454;\n                                            _1735 = _2455;\n                                            _1737 = _2456;\n                                            _1739 = _2457;\n                                            _1741 = _2458;\n                                            _1743 = _2459;\n                                            _1745 = _2460;\n                                            _1747 = _2461;\n                                            _1749 = _2462;\n                                            _1751 = _2463;\n                                            _1753 = _2464;\n                                            _1755 = _2465;\n                                            _1757 = _2466;\n                                            _1759 = _2467;\n                                            _1761 = _2468;\n                                            _1763 = _2469;\n                                            _1765 = _2470;\n                                            _1767 = _2471;\n                                            _1769 = _2472;\n                                            _1771 = _2473;\n                                            _1773 = _2474;\n                                            _1775 = _2475;\n                                            _1777 = _2476;\n                                            _1779 = _2477;\n                                            _1781 = _2478;\n                                            _1783 = _2479;\n                                            _1785 = _2480;\n                                            _1787 = _2481;\n                                            _1789 = _2482;\n                                            _1791 = _2483;\n                                            _1793 = _2484;\n                                            _1795 = _2485;\n                                            _1797 = _2486;\n                                            _1799 = _2487;\n                                            _1801 = _2488;\n                                            _1803 = _2489;\n                                            _1805 = _2490;\n                                            _1807 = _2491;\n                                            _1809 = _2492;\n                                            _1811 = _2493;\n                                            _1813 = _2494;\n                                            _1815 = _2495;\n                                            _1817 = _1816;\n                                            _1821 = _2496;\n                                            _1819 = false;\n                                        }\n                                        else\n                                        {\n                                            _1680 = _1679;\n                                            _1683 = _1682;\n                                            _1685 = _1684;\n                                            _1687 = _1686;\n                                            _1689 = _1688;\n                                            _1691 = _1690;\n                                            _1693 = _1692;\n                                            _1695 = _1694;\n                                            _1697 = _1696;\n                                            _1699 = _1698;\n                                            _1701 = _1700;\n                                            _1703 = _1702;\n                                            _1705 = _1704;\n                                            _1707 = _1706;\n                                            _1709 = _1708;\n                                            _1711 = _1710;\n                                            _1713 = _1712;\n                                            _1715 = _1714;\n                                            _1717 = _1716;\n                                            _1719 = _1718;\n                                            _1721 = _1720;\n                                            _1723 = _1722;\n                                            _1725 = _1724;\n                                            _1727 = _1726;\n                                            _1729 = _1728;\n                                            _1731 = _1730;\n                                            _1733 = _1732;\n                                            _1735 = _1734;\n                                            _1737 = _1736;\n                                            _1739 = _1738;\n                                            _1741 = _1740;\n                                            _1743 = _1742;\n                                            _1745 = _1744;\n                                            _1747 = _1746;\n                                            _1749 = _1748;\n                                            _1751 = _1750;\n                                            _1753 = _1752;\n                                            _1755 = _1754;\n                                            _1757 = _1756;\n                                            _1759 = _1758;\n                                            _1761 = _1760;\n                                            _1763 = _1762;\n                                            _1765 = _1764;\n                                            _1767 = _1766;\n                                            _1769 = _1768;\n                                            _1771 = _1770;\n                                            _1773 = _1772;\n                                            _1775 = _1774;\n                                            _1777 = _1776;\n                                            _1779 = _1778;\n                                            _1781 = _1780;\n                                            _1783 = _1782;\n                                            _1785 = _1784;\n                                            _1787 = _1786;\n                                            _1789 = _1788;\n                                            _1791 = _1790;\n                                            _1793 = _1792;\n                                            _1795 = _1794;\n                                            _1797 = _1796;\n                                            _1799 = _1798;\n                                            _1801 = _1800;\n                                            _1803 = _1802;\n                                            _1805 = _1804;\n                                            _1807 = _1806;\n                                            _1809 = _1808;\n                                            _1811 = _1810;\n                                            _1813 = _1812;\n                                            _1815 = _1814;\n                                            _1817 = _1816 + 1u;\n                                            _1821 = false;\n                                            _1819 = true;\n                                        }\n                                    }\n                                    _1529 = _1679;\n                                    _1532 = _1682;\n                                    _1534 = _1684;\n                                    _1536 = _1686;\n                                    _1538 = _1688;\n                                    _1540 = _1690;\n                                    _1542 = _1692;\n                                    _1544 = _1694;\n                                    _1546 = _1696;\n                                    _1548 = _1698;\n                                    _1550 = _1700;\n                                    _1552 = _1702;\n                                    _1554 = _1704;\n                                    _1556 = _1706;\n                                    _1558 = _1708;\n                                    _1560 = _1710;\n                                    _1562 = _1712;\n                                    _1564 = _1714;\n                                    _1566 = _1716;\n                                    _1568 = _1718;\n                                    _1570 = _1720;\n                                    _1572 = _1722;\n                                    _1574 = _1724;\n                                    _1576 = _1726;\n                                    _1578 = _1728;\n                                    _1580 = _1730;\n                                    _1582 = _1732;\n                                    _1584 = _1734;\n                                    _1586 = _1736;\n                                    _1588 = _1738;\n                                    _1590 = _1740;\n                                    _1592 = _1742;\n                                    _1594 = _1744;\n                                    _1596 = _1746;\n                                    _1598 = _1748;\n                                    _1600 = _1750;\n                                    _1602 = _1752;\n                                    _1604 = _1754;\n                                    _1606 = _1756;\n                                    _1608 = _1758;\n                                    _1610 = _1760;\n                                    _1612 = _1762;\n                                    _1614 = _1764;\n                                    _1616 = _1766;\n                                    _1618 = _1768;\n                                    _1620 = _1770;\n                                    _1622 = _1772;\n                                    _1624 = _1774;\n                                    _1626 = _1776;\n                                    _1628 = _1778;\n                                    _1630 = _1780;\n                                    _1632 = _1782;\n                                    _1634 = _1784;\n                                    _1636 = _1786;\n                                    _1638 = _1788;\n                                    _1640 = _1790;\n                                    _1642 = _1792;\n                                    _1644 = _1794;\n                                    _1646 = _1796;\n                                    _1648 = _1798;\n                                    _1650 = _1800;\n                                    _1652 = _1802;\n                                    _1654 = _1804;\n                                    _1656 = _1806;\n                                    _1658 = _1808;\n                                    _1660 = _1810;\n                                    _1662 = _1812;\n                                    _1664 = _1814;\n                                    _1666 = _1816;\n                                    _1670 = _1818;\n                                    _1668 = false;\n                                }\n                                else\n                                {\n                                    _1529 = _1528;\n                                    _1532 = _1531;\n                                    _1534 = _1533;\n                                    _1536 = _1535;\n                                    _1538 = _1537;\n                                    _1540 = _1539;\n                                    _1542 = _1541;\n                                    _1544 = _1543;\n                                    _1546 = _1545;\n                                    _1548 = _1547;\n                                    _1550 = _1549;\n                                    _1552 = _1551;\n                                    _1554 = _1553;\n                                    _1556 = _1555;\n                                    _1558 = _1557;\n                                    _1560 = _1559;\n                                    _1562 = _1561;\n                                    _1564 = _1563;\n                                    _1566 = _1565;\n                                    _1568 = _1567;\n                                    _1570 = _1569;\n                                    _1572 = _1571;\n                                    _1574 = _1573;\n                                    _1576 = _1575;\n                                    _1578 = _1577;\n                                    _1580 = _1579;\n                                    _1582 = _1581;\n                                    _1584 = _1583;\n                                    _1586 = _1585;\n                                    _1588 = _1587;\n                                    _1590 = _1589;\n                                    _1592 = _1591;\n                                    _1594 = _1593;\n                                    _1596 = _1595;\n                                    _1598 = _1597;\n                                    _1600 = _1599;\n                                    _1602 = _1601;\n                                    _1604 = _1603;\n                                    _1606 = _1605;\n                                    _1608 = _1607;\n                                    _1610 = _1609;\n                                    _1612 = _1611;\n                                    _1614 = _1613;\n                                    _1616 = _1615;\n                                    _1618 = _1617;\n                                    _1620 = _1619;\n                                    _1622 = _1621;\n                                    _1624 = _1623;\n                                    _1626 = _1625;\n                                    _1628 = _1627;\n                                    _1630 = _1629;\n                                    _1632 = _1631;\n                                    _1634 = _1633;\n                                    _1636 = _1635;\n                                    _1638 = _1637;\n                                    _1640 = _1639;\n                                    _1642 = _1641;\n                                    _1644 = _1643;\n                                    _1646 = _1645;\n                                    _1648 = _1647;\n                                    _1650 = _1649;\n                                    _1652 = _1651;\n                                    _1654 = _1653;\n                                    _1656 = _1655;\n                                    _1658 = _1657;\n                                    _1660 = _1659;\n                                    _1662 = _1661;\n                                    _1664 = _1663;\n                                    _1666 = _1665;\n                                    _1670 = false;\n                                    _1668 = true;\n                                }\n                            }\n                            _2525 = _284;\n                            _2526 = _1528;\n                            _2527 = _1531;\n                            _2528 = _1533;\n                            _2529 = _1535;\n                            _2530 = _1537;\n                            _2531 = _1539;\n                            _2532 = _1541;\n                            _2533 = _1543;\n                            _2534 = _1545;\n                            _2535 = _1547;\n                            _2536 = _1549;\n                            _2537 = _1551;\n                            _2538 = _1553;\n                            _2539 = _1555;\n                            _2540 = _1557;\n                            _2541 = _1559;\n                            _2542 = _1561;\n                            _2543 = _1563;\n                            _2544 = _1565;\n                            _2545 = _1567;\n                            _2546 = _1569;\n                            _2547 = _1571;\n                            _2548 = _1573;\n                            _2549 = _1575;\n                            _2550 = _1577;\n                            _2551 = _1579;\n                            _2552 = _1581;\n                            _2553 = _1583;\n                            _2554 = _1585;\n                            _2555 = _1587;\n                            _2556 = _1589;\n                            _2557 = _1591;\n                            _2558 = _1593;\n                            _2559 = _283;\n                            _2560 = _283;\n                            _2561 = _283;\n                            _2562 = _283;\n                            _2563 = _283;\n                            _2564 = _1595;\n                            _2565 = _1597;\n                            _2566 = _1599;\n                            _2567 = _1601;\n                            _2568 = _1603;\n                            _2569 = _1605;\n                            _2570 = _1607;\n                            _2571 = _1609;\n                            _2572 = _1611;\n                            _2573 = _1613;\n                            _2574 = _1615;\n                            _2575 = _1617;\n                            _2576 = _1619;\n                            _2577 = _1621;\n                            _2578 = _1623;\n                            _2579 = _1625;\n                            _2580 = _1627;\n                            _2581 = _1629;\n                            _2582 = _1631;\n                            _2583 = _1633;\n                            _2584 = _1635;\n                            _2585 = _1637;\n                            _2586 = _1639;\n                            _2587 = _1641;\n                            _2588 = _1643;\n                            _2589 = _1645;\n                            _2590 = _1647;\n                            _2591 = _1649;\n                            _2592 = _1651;\n                            _2593 = _1653;\n                            _2594 = _1525;\n                            _2595 = _1655;\n                            _2596 = _1657;\n                            _2597 = _1659;\n                            _2598 = _1661;\n                            _2599 = _1663;\n                            _2600 = _1665;\n                            _2601 = _1667;\n                        }\n                        else\n                        {\n                            vec3 _2499 = _283;\n                            _2499.x = 0.5;\n                            vec3 _2500 = _2499;\n                            _2500.y = 0.5;\n                            vec3 _2501 = _2500;\n                            _2501.z = -0.5;\n                            float _2512 = ((_787.x * _2501.x) + (_787.y * _2501.y)) + (_787.z * _2501.z);\n                            float _2513 = 1.5 + _2512;\n                            vec2 _835 = _1492;\n                            spheres_get_sphere_color(_834, _835);\n                            vec3 _2522 = _283;\n                            _2522.x = _2513 * _834.x;\n                            vec3 _2523 = _2522;\n                            _2523.y = _2513 * _834.y;\n                            vec3 _2524 = _2523;\n                            _2524.z = _2513 * _834.z;\n                            _782 = _2524;\n                            _2525 = _2512;\n                            _2526 = _284;\n                            _2527 = _284;\n                            _2528 = _283;\n                            _2529 = _283;\n                            _2530 = _284;\n                            _2531 = _283;\n                            _2532 = _283;\n                            _2533 = _283;\n                            _2534 = _283;\n                            _2535 = _284;\n                            _2536 = _284;\n                            _2537 = _284;\n                            _2538 = _284;\n                            _2539 = _284;\n                            _2540 = _284;\n                            _2541 = _284;\n                            _2542 = _283;\n                            _2543 = _283;\n                            _2544 = _284;\n                            _2545 = _283;\n                            _2546 = _284;\n                            _2547 = _283;\n                            _2548 = _283;\n                            _2549 = _284;\n                            _2550 = _284;\n                            _2551 = _284;\n                            _2552 = _283;\n                            _2553 = _283;\n                            _2554 = _284;\n                            _2555 = _283;\n                            _2556 = _284;\n                            _2557 = _283;\n                            _2558 = _283;\n                            _2559 = _834;\n                            _2560 = _2524;\n                            _2561 = _2501;\n                            _2562 = _787;\n                            _2563 = _2501;\n                            _2564 = _283;\n                            _2565 = _283;\n                            _2566 = _283;\n                            _2567 = _283;\n                            _2568 = _283;\n                            _2569 = _283;\n                            _2570 = _283;\n                            _2571 = _283;\n                            _2572 = _283;\n                            _2573 = _283;\n                            _2574 = _283;\n                            _2575 = _283;\n                            _2576 = _283;\n                            _2577 = _283;\n                            _2578 = _283;\n                            _2579 = _283;\n                            _2580 = _283;\n                            _2581 = _283;\n                            _2582 = _283;\n                            _2583 = _283;\n                            _2584 = _282;\n                            _2585 = _282;\n                            _2586 = _282;\n                            _2587 = _282;\n                            _2588 = _282;\n                            _2589 = _282;\n                            _2590 = _282;\n                            _2591 = _282;\n                            _2592 = _282;\n                            _2593 = _282;\n                            _2594 = _283;\n                            _2595 = _287;\n                            _2596 = _287;\n                            _2597 = _285;\n                            _2598 = _284;\n                            _2599 = _286;\n                            _2600 = _286;\n                            _2601 = true;\n                        }\n                        bool _2605;\n                        if (_2601)\n                        {\n                            _2605 = true;\n                        }\n                        else\n                        {\n                        }\n                        _2606 = _2525;\n                        _2607 = _2526;\n                        _2608 = _2527;\n                        _2609 = _2528;\n                        _2610 = _2529;\n                        _2611 = _2530;\n                        _2612 = _2531;\n                        _2613 = _2532;\n                        _2614 = _2533;\n                        _2615 = _2534;\n                        _2616 = _2535;\n                        _2617 = _2536;\n                        _2618 = _2537;\n                        _2619 = _2538;\n                        _2620 = _2539;\n                        _2621 = _2540;\n                        _2622 = _2541;\n                        _2623 = _2542;\n                        _2624 = _2543;\n                        _2625 = _2544;\n                        _2626 = _2545;\n                        _2627 = _2546;\n                        _2628 = _2547;\n                        _2629 = _2548;\n                        _2630 = _2549;\n                        _2631 = _2550;\n                        _2632 = _2551;\n                        _2633 = _2552;\n                        _2634 = _2553;\n                        _2635 = _2554;\n                        _2636 = _2555;\n                        _2637 = _2556;\n                        _2638 = _2557;\n                        _2639 = _2558;\n                        _2640 = _2559;\n                        _2641 = _2560;\n                        _2642 = _2561;\n                        _2643 = _2562;\n                        _2644 = _2563;\n                        _2645 = _2564;\n                        _2646 = _2565;\n                        _2647 = _2566;\n                        _2648 = _2567;\n                        _2649 = _2568;\n                        _2650 = _2569;\n                        _2651 = _2570;\n                        _2652 = _2571;\n                        _2653 = _2572;\n                        _2654 = _2573;\n                        _2655 = _2574;\n                        _2656 = _2575;\n                        _2657 = _2576;\n                        _2658 = _2577;\n                        _2659 = _2578;\n                        _2660 = _2579;\n                        _2661 = _2580;\n                        _2662 = _2581;\n                        _2663 = _2582;\n                        _2664 = _2583;\n                        _2665 = _2584;\n                        _2666 = _2585;\n                        _2667 = _2586;\n                        _2668 = _2587;\n                        _2669 = _2588;\n                        _2670 = _2589;\n                        _2671 = _2590;\n                        _2672 = _2591;\n                        _2673 = _2592;\n                        _2674 = _2593;\n                        _2675 = _2594;\n                        _2676 = _2595;\n                        _2677 = _2596;\n                        _2678 = _2597;\n                        _2679 = _2598;\n                        _2680 = _2599;\n                        _2681 = _2600;\n                        _2682 = _2605;\n                    }\n                    else\n                    {\n                    }\n                    _2683 = _2606;\n                    _2684 = _2607;\n                    _2685 = _2608;\n                    _2686 = _2609;\n                    _2687 = _2610;\n                    _2688 = _2611;\n                    _2689 = _2612;\n                    _2690 = _2613;\n                    _2691 = _2614;\n                    _2692 = _2615;\n                    _2693 = _2616;\n                    _2694 = _2617;\n                    _2695 = _2618;\n                    _2696 = _2619;\n                    _2697 = _2620;\n                    _2698 = _2621;\n                    _2699 = _2622;\n                    _2700 = _2623;\n                    _2701 = _2624;\n                    _2702 = _2625;\n                    _2703 = _2626;\n                    _2704 = _2627;\n                    _2705 = _2628;\n                    _2706 = _2629;\n                    _2707 = _2630;\n                    _2708 = _2631;\n                    _2709 = _2632;\n                    _2710 = _2633;\n                    _2711 = _2634;\n                    _2712 = _2635;\n                    _2713 = _2636;\n                    _2714 = _2637;\n                    _2715 = _2638;\n                    _2716 = _2639;\n                    _2717 = _1484;\n                    _2718 = _1482;\n                    _2719 = _2640;\n                    _2720 = _2641;\n                    _2721 = _2642;\n                    _2722 = _2643;\n                    _2723 = _2644;\n                    _2724 = _2645;\n                    _2725 = _2646;\n                    _2726 = _2647;\n                    _2727 = _2648;\n                    _2728 = _2649;\n                    _2729 = _2650;\n                    _2730 = _2651;\n                    _2731 = _2652;\n                    _2732 = _2653;\n                    _2733 = _2654;\n                    _2734 = _2655;\n                    _2735 = _2656;\n                    _2736 = _2657;\n                    _2737 = _2658;\n                    _2738 = _2659;\n                    _2739 = _2660;\n                    _2740 = _2661;\n                    _2741 = _2662;\n                    _2742 = _2663;\n                    _2743 = _2664;\n                    _2744 = _2665;\n                    _2745 = _2666;\n                    _2746 = _2667;\n                    _2747 = _2668;\n                    _2748 = _2669;\n                    _2749 = _2670;\n                    _2750 = _2671;\n                    _2751 = _2672;\n                    _2752 = _2673;\n                    _2753 = _2674;\n                    _2754 = _2675;\n                    _2755 = _1486;\n                    _2756 = _1492;\n                    _2757 = _1480;\n                    _2758 = _1486;\n                    _2759 = _1474;\n                    _2760 = _1480;\n                    _2761 = _786;\n                    _2762 = _1474;\n                    _2763 = _1457;\n                    _2764 = _784;\n                    _2765 = _1469;\n                    _2766 = _785;\n                    _2767 = _1457;\n                    _2768 = _2676;\n                    _2769 = _2677;\n                    _2770 = _2678;\n                    _2771 = _2679;\n                    _2772 = _2680;\n                    _2773 = _2681;\n                    _2774 = _1514;\n                    _2775 = _2682;\n                }\n                else\n                {\n                    _2683 = _284;\n                    _2684 = _284;\n                    _2685 = _284;\n                    _2686 = _283;\n                    _2687 = _283;\n                    _2688 = _284;\n                    _2689 = _283;\n                    _2690 = _283;\n                    _2691 = _283;\n                    _2692 = _283;\n                    _2693 = _284;\n                    _2694 = _284;\n                    _2695 = _284;\n                    _2696 = _284;\n                    _2697 = _284;\n                    _2698 = _284;\n                    _2699 = _284;\n                    _2700 = _283;\n                    _2701 = _283;\n                    _2702 = _284;\n                    _2703 = _283;\n                    _2704 = _284;\n                    _2705 = _283;\n                    _2706 = _283;\n                    _2707 = _284;\n                    _2708 = _284;\n                    _2709 = _284;\n                    _2710 = _283;\n                    _2711 = _283;\n                    _2712 = _284;\n                    _2713 = _283;\n                    _2714 = _284;\n                    _2715 = _283;\n                    _2716 = _283;\n                    _2717 = _284;\n                    _2718 = _284;\n                    _2719 = _283;\n                    _2720 = _283;\n                    _2721 = _283;\n                    _2722 = _283;\n                    _2723 = _283;\n                    _2724 = _283;\n                    _2725 = _283;\n                    _2726 = _283;\n                    _2727 = _283;\n                    _2728 = _283;\n                    _2729 = _283;\n                    _2730 = _283;\n                    _2731 = _283;\n                    _2732 = _283;\n                    _2733 = _283;\n                    _2734 = _283;\n                    _2735 = _283;\n                    _2736 = _283;\n                    _2737 = _283;\n                    _2738 = _283;\n                    _2739 = _283;\n                    _2740 = _283;\n                    _2741 = _283;\n                    _2742 = _283;\n                    _2743 = _283;\n                    _2744 = _282;\n                    _2745 = _282;\n                    _2746 = _282;\n                    _2747 = _282;\n                    _2748 = _282;\n                    _2749 = _282;\n                    _2750 = _282;\n                    _2751 = _282;\n                    _2752 = _282;\n                    _2753 = _282;\n                    _2754 = _283;\n                    _2755 = _282;\n                    _2756 = _282;\n                    _2757 = _282;\n                    _2758 = _282;\n                    _2759 = _282;\n                    _2760 = _282;\n                    _2761 = _283;\n                    _2762 = _282;\n                    _2763 = _283;\n                    _2764 = _283;\n                    _2765 = _283;\n                    _2766 = _283;\n                    _2767 = _283;\n                    _2768 = _287;\n                    _2769 = _287;\n                    _2770 = _285;\n                    _2771 = _284;\n                    _2772 = _286;\n                    _2773 = _286;\n                    _2774 = _285;\n                    _2775 = true;\n                }\n                if (_2775)\n                {\n                    return;\n                }\n                else\n                {\n                }\n            }\n            else\n            {\n                _1089 = _1437;\n            }\n        }\n    }\n    else\n    {\n    }\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_reflect(inout vec3 _3373, vec3 _3374, vec3 _3375)\n{\n    float _3391 = 2.0 * (((_3375.x * _3374.x) + (_3375.y * _3374.y)) + (_3375.z * _3374.z));\n    vec3 _3399 = _283;\n    _3399.x = _3391 * _3375.x;\n    vec3 _3400 = _3399;\n    _3400.y = _3391 * _3375.y;\n    vec3 _3401 = _3400;\n    _3401.z = _3391 * _3375.z;\n    _3373.x = _3374.x - _3401.x;\n    _3373.y = _3374.y - _3401.y;\n    _3373.z = _3374.z - _3401.z;\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_powf_vec(inout vec3 _3329, vec3 _3330, vec3 _3331)\n{\n    _3329.x = pow(_3330.x, _3331.x);\n    _3329.y = pow(_3330.y, _3331.y);\n    _3329.z = pow(_3330.z, _3331.z);\n}\nvoid _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_clamp(inout vec3 _3267, vec3 _3268, vec3 _3269, vec3 _3270)\n{\n    vec3 _3283 = _283;\n    _3283.x = max(_3268.x, _3269.x);\n    vec3 _3284 = _3283;\n    _3284.y = max(_3268.y, _3269.y);\n    vec3 _3285 = _3284;\n    _3285.z = max(_3268.z, _3269.z);\n    _3267.x = min(_3285.x, _3270.x);\n    _3267.y = min(_3285.y, _3270.y);\n    _3267.z = min(_3285.z, _3270.z);\n}\nvoid _spheres_Inputs_main_image(Inputs _2779, out vec4 _2780, vec2 _2781)\n{\n    vec2 _2808 = _282;\n    _2808.x = _2779.resolution.x;\n    vec2 _2809 = _2808;\n    _2809.y = _2779.resolution.y;\n    vec2 _2816 = _282;\n    _2816.x = _2781.x / _2809.x;\n    vec2 _2817 = _2816;\n    _2817.y = _2781.y / _2809.y;\n    vec2 _2818 = _282;\n    _2818.x = -1.0;\n    vec2 _2819 = _2818;\n    _2819.y = -1.0;\n    vec2 _2824 = _282;\n    _2824.x = 2.0 * _2817.x;\n    vec2 _2825 = _2824;\n    _2825.y = 2.0 * _2817.y;\n    vec2 _2832 = _282;\n    _2832.x = _2819.x + _2825.x;\n    vec2 _2833 = _2832;\n    _2833.y = _2819.y + _2825.y;\n    vec2 _2843 = _2833;\n    _2843.x = _2833.x * (_2779.resolution.x / _2779.resolution.y);\n    vec3 _2859 = _283;\n    _2859.x = cos(0.23199999332427978515625 * _2779.time) * 10.0;\n    vec3 _2860 = _2859;\n    _2860.y = 6.0 + (3.0 * cos(0.300000011920928955078125 * _2779.time));\n    vec3 _2861 = _2860;\n    _2861.z = 8.0 * (_2779.time / 0.5);\n    vec3 _2873 = _283;\n    _2873.x = (-sin(0.23199999332427978515625 * _2779.time)) * 10.0;\n    vec3 _2874 = _2873;\n    _2874.y = (-2.0) + cos(0.23000000417232513427734375 * _2779.time);\n    vec3 _2875 = _2874;\n    _2875.z = 10.0;\n    vec3 _2885 = _283;\n    _2885.x = _2861.x + _2875.x;\n    vec3 _2886 = _2885;\n    _2886.y = _2861.y + _2875.y;\n    vec3 _2887 = _2886;\n    _2887.z = _2861.z + _2875.z;\n    float _2892 = (-0.1500000059604644775390625) * sin(0.5 * _2779.time);\n    vec3 _2902 = _283;\n    _2902.x = _2887.x - _2861.x;\n    vec3 _2903 = _2902;\n    _2903.y = _2887.y - _2861.y;\n    vec3 _2904 = _2903;\n    _2904.z = _2887.z - _2861.z;\n    float _2917 = 1.0 / sqrt(((_2904.x * _2904.x) + (_2904.y * _2904.y)) + (_2904.z * _2904.z));\n    vec3 _2924 = _283;\n    _2924.x = _2904.x * _2917;\n    vec3 _2925 = _2924;\n    _2925.y = _2904.y * _2917;\n    vec3 _2926 = _2925;\n    _2926.z = _2904.z * _2917;\n    vec3 _2929 = _283;\n    _2929.x = sin(_2892);\n    vec3 _2930 = _2929;\n    _2930.y = cos(_2892);\n    vec3 _2931 = _2930;\n    _2931.z = 0.0;\n    vec3 _2953 = _283;\n    _2953.x = (_2926.y * _2931.z) - (_2931.y * _2926.z);\n    vec3 _2954 = _2953;\n    _2954.y = (_2926.z * _2931.x) - (_2931.z * _2926.x);\n    vec3 _2955 = _2954;\n    _2955.z = (_2926.x * _2931.y) - (_2931.x * _2926.y);\n    float _2968 = 1.0 / sqrt(((_2955.x * _2955.x) + (_2955.y * _2955.y)) + (_2955.z * _2955.z));\n    vec3 _2975 = _283;\n    _2975.x = _2955.x * _2968;\n    vec3 _2976 = _2975;\n    _2976.y = _2955.y * _2968;\n    vec3 _2977 = _2976;\n    _2977.z = _2955.z * _2968;\n    vec3 _2999 = _283;\n    _2999.x = (_2977.y * _2926.z) - (_2926.y * _2977.z);\n    vec3 _3000 = _2999;\n    _3000.y = (_2977.z * _2926.x) - (_2926.z * _2977.x);\n    vec3 _3001 = _3000;\n    _3001.z = (_2977.x * _2926.y) - (_2926.x * _2977.y);\n    float _3014 = 1.0 / sqrt(((_3001.x * _3001.x) + (_3001.y * _3001.y)) + (_3001.z * _3001.z));\n    vec3 _3021 = _283;\n    _3021.x = _3001.x * _3014;\n    vec3 _3022 = _3021;\n    _3022.y = _3001.y * _3014;\n    vec3 _3023 = _3022;\n    _3023.z = _3001.z * _3014;\n    vec3 _3031 = _283;\n    _3031.x = _2843.x * _2977.x;\n    vec3 _3032 = _3031;\n    _3032.y = _2843.x * _2977.y;\n    vec3 _3033 = _3032;\n    _3033.z = _2843.x * _2977.z;\n    vec3 _3041 = _283;\n    _3041.x = _2843.y * _3023.x;\n    vec3 _3042 = _3041;\n    _3042.y = _2843.y * _3023.y;\n    vec3 _3043 = _3042;\n    _3043.z = _2843.y * _3023.z;\n    vec3 _3053 = _283;\n    _3053.x = _3033.x + _3043.x;\n    vec3 _3054 = _3053;\n    _3054.y = _3033.y + _3043.y;\n    vec3 _3055 = _3054;\n    _3055.z = _3033.z + _3043.z;\n    vec3 _3062 = _283;\n    _3062.x = 1.5 * _2926.x;\n    vec3 _3063 = _3062;\n    _3063.y = 1.5 * _2926.y;\n    vec3 _3064 = _3063;\n    _3064.z = 1.5 * _2926.z;\n    vec3 _3074 = _283;\n    _3074.x = _3055.x + _3064.x;\n    vec3 _3075 = _3074;\n    _3075.y = _3055.y + _3064.y;\n    vec3 _3076 = _3075;\n    _3076.z = _3055.z + _3064.z;\n    float _3089 = 1.0 / sqrt(((_3076.x * _3076.x) + (_3076.y * _3076.y)) + (_3076.z * _3076.z));\n    vec3 _3096 = _283;\n    _3096.x = _3076.x * _3089;\n    vec3 _3097 = _3096;\n    _3097.y = _3076.y * _3089;\n    vec3 _3098 = _3097;\n    _3098.z = _3076.z * _3089;\n    int _2783 = 0;\n    vec3 _2784 = vec3(0.0);\n    vec3 _2785 = vec3(0.0);\n    float _2786 = 0.0;\n    vec3 _2788 = _2861;\n    vec3 _2789 = _3098;\n    vec3 _2787;\n    _spheres_Inputs_trace(_2787, _2779, _2788, _2789, _2785, _2784, _2786, _2783);\n    uint _3107;\n    if (_2783 > 0)\n    {\n        _3107 = true ? uint(1) : uint(0);\n    }\n    else\n    {\n        _3107 = false ? uint(1) : uint(0);\n    }\n    vec3 _3164;\n    vec3 _3165;\n    vec3 _3166;\n    vec3 _3167;\n    vec3 _3168;\n    vec3 _3169;\n    vec3 _3170;\n    vec3 _3171;\n    vec3 _3172;\n    if (_3107 != uint(0))\n    {\n        vec3 _3112 = _2785;\n        vec3 _3113 = _2784;\n        vec3 _3120 = _283;\n        _3120.x = 9.9999997473787516355514526367188e-05 * _3113.x;\n        vec3 _3121 = _3120;\n        _3121.y = 9.9999997473787516355514526367188e-05 * _3113.y;\n        vec3 _3122 = _3121;\n        _3122.z = 9.9999997473787516355514526367188e-05 * _3113.z;\n        vec3 _3132 = _283;\n        _3132.x = _3112.x + _3122.x;\n        vec3 _3133 = _3132;\n        _3133.y = _3112.y + _3122.y;\n        vec3 _3134 = _3133;\n        _3134.z = _3112.z + _3122.z;\n        vec3 _2791 = _3098;\n        vec3 _2792 = _2784;\n        vec3 _2790;\n        _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_reflect(_2790, _2791, _2792);\n        vec3 _2794 = _3134;\n        vec3 _2795 = _2790;\n        vec3 _2793;\n        _spheres_Inputs_trace(_2793, _2779, _2794, _2795, _2785, _2784, _2786, _2783);\n        vec3 _3146 = _283;\n        _3146.x = 0.0500000007450580596923828125 * _2793.x;\n        vec3 _3147 = _3146;\n        _3147.y = 0.0500000007450580596923828125 * _2793.y;\n        vec3 _3148 = _3147;\n        _3148.z = 0.0500000007450580596923828125 * _2793.z;\n        _2787.x += _3148.x;\n        _2787.y += _3148.y;\n        _2787.z += _3148.z;\n        _3164 = _3148;\n        _3165 = _2793;\n        _3166 = _3148;\n        _3167 = _3122;\n        _3168 = _3112;\n        _3169 = _3134;\n        _3170 = _3113;\n        _3171 = _3122;\n        _3172 = _2790;\n    }\n    else\n    {\n        _3164 = _283;\n        _3165 = _283;\n        _3166 = _283;\n        _3167 = _283;\n        _3168 = _283;\n        _3169 = _283;\n        _3170 = _283;\n        _3171 = _283;\n        _3172 = _3098;\n    }\n    vec3 _3174 = _283;\n    _3174.x = 0.89999997615814208984375;\n    vec3 _3175 = _3174;\n    _3175.y = 0.89999997615814208984375;\n    vec3 _3176 = _3175;\n    _3176.z = 0.89999997615814208984375;\n    vec3 _2797 = _2787;\n    vec3 _2798 = _3176;\n    vec3 _2796;\n    _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_powf_vec(_2796, _2797, _2798);\n    _2787 = _2796;\n    vec3 _2800 = _2787;\n    vec3 _2801 = vec3(0.0);\n    vec3 _2802 = vec3(1.0);\n    vec3 _2799;\n    _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_clamp(_2799, _2800, _2801, _2802);\n    _2787 = _2799;\n    float _3194 = 0.25 + (0.75 * pow((((16.0 * _2817.x) * _2817.y) * (1.0 - _2817.x)) * (1.0 - _2817.y), 0.1500000059604644775390625));\n    _2787.x *= _3194;\n    _2787.y *= _3194;\n    _2787.z *= _3194;\n    vec4 _3211 = _288;\n    _3211.x = _2787.x;\n    vec4 _3212 = _3211;\n    _3212.y = _2787.y;\n    vec4 _3213 = _3212;\n    _3213.z = _2787.z;\n    vec4 _3214 = _3213;\n    _3214.w = 1.0;\n    _2780 = _3214;\n}\nvoid _spheres_Uniforms_main_image(Uniforms _289, inout vec4 _290, vec2 _291, sampler2D _292, sampler2D _293, sampler2D _294, sampler2D _295)\n{\n    vec3 _299 = _289.resolution;\n    vec3 _298;\n    _glam_f32_vec3a_Vec3A_as_core_convert_Into_glam_f32_vec3a_Vec3A_into(_298, _299);\n    Inputs _297;\n    _297.resolution = _298;\n    _297.time = _289.time;\n    vec2 _300 = _291;\n    _spheres_Inputs_main_image(_297, _290, _300);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){_spheres_Uniforms_main_image(Uniforms(iResolution,iMouse,iDate,iTime,iSampleRate,iFrame,iTimeDelta,iFrameRate,iChannelTime,iChannelResolution),fragColor,fragCoord,iChannel0,iChannel1,iChannel2,iChannel3);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyfDV", "name": "Simple 2D Star noise", "author": "tyron", "description": "Just some simple stars. Would probably want to use a noise texture as input so you don't need 500 iterations per fragment.", "tags": ["noise", "stars", "night"], "likes": 3, "viewed": 131, "date": "1607978489", "time_retrieved": "2024-06-20T20:26:59.136194", "image_code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 offset = vec2(sin(iTime / 5.0), cos(iTime / 5.0)) / 10.0 + iMouse.xy/1000.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = vec3(0);\n    for (float i = 0.; i < 500.; i++) {\n        vec2 star = mod(vec2(noise(i), noise(i * 23.)) + offset, vec2(1.0));\n        \n        float intensity = 0.5 + noise(i * 17.) * 0.5;\n        \n        col += clamp(intensity * pow(1. - distance(star, uv)/2., 1200.0), 0., 1.);\n        \n        // First 100 stars are yellow\n        if (i < 100.) {\n            col.b = 0.;\n        }\n    }\n\n    // Add some contrast\n    col = (col - 0.2) * 1.5;\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyfDy", "name": "Raymarched 3D Fractal Noise", "author": "oneshade", "description": "Raymarched 3D fractal noise looks pretty cool! I tried accelerating it by first testing whether the point is inside the bounding box but I am not sure just how efficient it is (unrolled). Mouse x to set threshold, mouse y to set octaves (layers).", "tags": ["3d", "raymarching", "organic", "fractalnoise"], "likes": 6, "viewed": 93, "date": "1607821328", "time_retrieved": "2024-06-20T20:26:59.136194", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Noise3D(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3D(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = Noise3D(cell);                       // Left, Down, Back\n    float rdb = Noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalNoise3D(in vec3 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise3D(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    float octaves = 4.0;\n    float threshold = 0.4;\n\n    if (iMouse.z > 0.0) {\n        octaves = iMouse.y / iResolution.y * 4.0;\n        threshold = iMouse.x / iResolution.x * 0.9;\n    }\n\n    vec3 q = abs(p) -1.5;\n    float bbox = max(q.x, max(q.y, q.z));\n\n    return max(FractalNoise3D(p, 2.0, octaves) - threshold, bbox);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0), rd = normalize(vec3(uv, -1.0)), p;\n    float dt = 0.0, d;\n    bool hit = false;\n\n    for (int iter=0; iter < 100; iter++) {\n        p = ro + rd * dt;\n\n        p.y -= 0.3;\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        vec3 q = abs(p) - 1.5;\n        d = max(q.x, max(q.y, q.z));\n        if (d < 0.001) {\n            d = mapScene(p);\n            if (d < 0.001) {\n                hit = true;\n                break;\n            }\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        fragColor.rgb += 0.5 + 0.5 * n;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyfDz", "name": "Kate's Kaleidoscope", "author": "Nickenstein79", "description": "A friend made a tune for me on her lunch-break, so I made her a visual thing to go with it on my lunch-break.", "tags": ["space"], "likes": 2, "viewed": 243, "date": "1606914734", "time_retrieved": "2024-06-20T20:27:00.982788", "image_code": "\n\n// Kate's Kaleidoscope.\n\n\n// A thing inspired by a thing, inspired by another thing, inspired by a thing by Frank Herbert.\n\n\n// An attempt to code a visual effect on my lunch break,\n// to match a piece of music that K8-Bit made on her lunch break.   (https://soundcloud.com/k8-bit)\n\n\n// by Nickenstein79, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. (02/12/2020)\n\n\n#define NUM_LAYERS \t\t\t\t\t(11)\n#define LAYER_SEPERATION_FACTOR\t\t(0.03621)\n#define ZOOM_FACTOR_PERIOD \t\t\t(90.0)  \t\n#define ZOOM_FACTOR_MIN \t\t\t(0.5)\n#define ZOOM_FACTOR_MAX \t\t\t(2.8)\n#define SCROLL_SPEED_AT_MIN_ZOOM\t(1.72)\n#define SCROLL_SPEED_AT_MAX_ZOOM\t(3.343138)\n#define ROTATION_MATRIX_MAX_SKEW\t(0.277)\t\t// The maximum skewing/warping of the rotation matrix\n#define ROTATION_MATRIX_SKEW_PERIOD (8.2)\t\t// The time taken to fully skew and un-skew the rotation matrix\n\n#define CRT_FILTER_ON\t\t\t\t\t\t\t// Toggle this line to dissable/enable the CRT Filter\n#define CRT_VIGNETTE_ON\t\t\t\t\t\t// Toggle this line to dissable/enable the CRT-edge vignette\n#define CRT_EXTRA_NOISE_ON\t\t\t\t\t// Toggle this line to dissable/enable the CRT-Extra Noise\n\n#define TWO_PI\t\t\t\t\t\t(6.283185307179586476925286766559)\n#define LAYER_STEP_SIZE \t\t\t(1.0/float(NUM_LAYERS))\n\n// Returns a psuedo-random float value (in the range 0.0 to 1.0) generated from a 2D vector\n// works by combining the input seed value with prime numbers.\n// Using primes causes sequential inputs (such as pixel coordinates) to still generate non-sequential outputs.\nfloat Hash_From2D(vec2 Vec)\n{\n    float f = Vec.x + Vec.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n \n// Returns a sin wave driven value that oscilates between Min and Max over the given time period\nfloat OscilateSinScalar(float Min, float Max, float Period)\n{\n\treturn (Max-Min) * (sin(iTime*TWO_PI/Period)*0.5+0.5) + Min;\n}\n\n// Returns the interpolant (fraction) of CurrentValue between Min and Max in the range (0.0 to 1.0)\nfloat GetInterpolant(float Min, float Max, float CurrentValue)\n{\n    return (CurrentValue-Min) / (Max-Min);\n}\n\n// returns a skewed Z rotation matrix (The skewing changes over time)\nmat2 ZRotate_Skewed(float Angle)\n{\n    // Get a value to skew the rotion matrix with, which bounces between 0.0 and ROTATION_MATRIX_MAX_SKEW, over a given time period.\n    float Skew = 1.0 - OscilateSinScalar(0.0, ROTATION_MATRIX_MAX_SKEW, ROTATION_MATRIX_SKEW_PERIOD);\n    \n    // As the input angle is based on an incrimental timer multiplied by magic numbers and getting the cosine of these values,\n    // this generates an animated angle which drifts chaotically and \n    // unpredictably over time (Like a double-pendulum's motion. Actually, a triple-pendulum as we combine three cos() values).\n    // twiddle with the multiply values being passed to cos() until you like the motion of the simulation.\n\tAngle = cos(Angle*0.1)*cos(Angle*0.7)*cos(Angle*0.73)*2.0;    \n    \n    // build and return the skewed Z-rotation matrix\n    return mat2(sin(Angle * Skew),cos(Angle),-cos(Angle * Skew),sin(Angle));\n}\n\n// sample the input textures which creates our desired material surface effect\nvec4 SampleMaterial(vec2 uv)\n{\n   float t = iTime * 0.5;\n   \n   // sample texture 0, just the red channel to get an initial grey-scale value in range 0.0 to 1.0\n   float Sample0 = texture(iChannel0, uv * 0.1 ).b;\n    \n   // Modify Sample0 by subtracting circlular patterns that grow across the texture over time\n   // fiddle with the numbers to get differening circular patterns\n   Sample0 -= 0.5 + sin(t + sin(uv.x) + sin(uv.y)) * 0.7; \n   \n   // adjust brightness\n   Sample0 *= 1.6;\n   \n   // ensure no negative values with abs(), this also causes a double\n   // concentric-circle pattern as sin() returns -1 to +1 values.\n   Sample0 = abs(Sample0);\n \n   // invert these fat bright negative-circles to get thin bright circles and curves\n   Sample0 = 1.0/(Sample0*10.0+1.0);\n    \n   // make a greyscale colour from Sample0, then multiply it by a full-colour sample from eleswhere on texture 0\n   vec4 Colour = vec4(Sample0) * texture(iChannel0, uv * 0.05);\n    \n   // multiple this colour by a scrolling sample from texture 1 (random coloured noise texture)\n   // Adjust the multiplyer to expand or shrink the range of the coloured noise texture in use\n   return Colour * texture(iChannel1,(uv + (iTime*1.3)) * 0.001735);\n}\n\n// Generate fast downward cycling fat scanlines\nfloat scanline(vec2 uv, float TexHeight) \n{\n\treturn sin(iResolution.y * uv.y * 0.7 - iTime * 10.0);\n}\n\n// Generate slow upward cycling thin scanlines\nfloat slowscan(vec2 uv, float TexHeight) \n{\n\treturn sin(iResolution.y * uv.y * 0.02 + iTime * 6.0);\n}\n\n// warp uv coordinates to emulate a curved crt screen\nvec2 crt_bend_uv_coords(vec2 coord, float bend)\n{\n\t// put in symmetrical coords\n\t//coord = (coord - 0.5) * 2.0;\n\t//coord *= 0.5;\t\n\t\n\t// deform coords\n\tcoord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n\tcoord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n\n\t// transform back to 0.0 - 1.0 space\n\tcoord  = (coord / 1.0) + 0.5;\n\n\treturn coord;\n}\n\n// wibble the screen, crt magnetic interferance distortion effect\nvec2 scandistort(vec2 uv) \n{\n\tfloat scan1 = clamp(cos(uv.y * 2.0 + iTime), 0.0, 1.0);\n\tfloat scan2 = clamp(cos(uv.y * 2.0 + iTime + 4.0) * 10.0, 0.0, 1.0);\n\tfloat amount = scan1 * scan2 * uv.x; \n\tuv.x -= 0.05 * mix( texture(iChannel1, vec2(uv.x, amount)).x * amount, amount, 0.9 );\n    \n\treturn uv;\n}\n\n// CRT edge vignette\nvec3 CRT_Vignette(vec3 Colour, vec2 uv)\n{\n    uv.x /= iResolution.x / iResolution.y;\n\tfloat Vignette = clamp(pow(cos(uv.x * 3.1415), 1.3) * pow(cos(uv.y * 3.1415), 1.3) * 50.0, 0.0, 1.0);\n    Colour *= Vignette;\n    \n    return Colour;    \n}\n\n// Cathode ray tube filter, to look like an old cathode ray-tube monitor with scanlines, and V-Hold, etc...\nvec3 CRT_Filter(vec3 Colour, vec2 uv)\n{\n#ifdef CRT_EXTRA_NOISE_ON    \n    Colour.r += Hash_From2D(uv * iTime * 911.911 * 4.0) * 0.19;\n    Colour.g += Hash_From2D(uv * iTime * 563.577 * 4.0) * 0.19;\n    Colour.b += Hash_From2D(uv * iTime * 487.859 * 4.0) * 0.19;\n#endif    \n    \n    vec2 sd_uv = uv;\n\tvec2 crt_uv = crt_bend_uv_coords(sd_uv, 2.0);    \n    vec3 scanline_Colour;\n\tvec3 slowscan_Colour;\n\tscanline_Colour.x = scanline(crt_uv, iResolution.y);\n    slowscan_Colour.x = slowscan(crt_uv, iResolution.y);\n    scanline_Colour.y = scanline_Colour.z = scanline_Colour.x;\n\tslowscan_Colour.y = slowscan_Colour.z = slowscan_Colour.x;\n\tColour = mix(Colour, mix(scanline_Colour, slowscan_Colour, 0.5), 0.04);\n    \n    // apply the CRT-vignette filter\n#ifdef CRT_VIGNETTE_ON\n    Colour = CRT_Vignette(Colour, uv);\n#endif     \n    \n    return Colour;\n}\n\n// Perform some post processing effects on the output colour\nvec3 PostProcessColour(vec3 Colour, vec2 uv)\n{\n    // Vignette (Darken the pixels nearer the corners of the screen)\n    Colour -= vec3(length(uv*0.1));\n    \n    // Add some random noise to the colour with the Hashing function\n\tColour += Hash_From2D(uv*iTime*0.01)*0.02;\n    \n    // apply the CRT-screen filter\n#ifdef CRT_FILTER_ON\n    Colour = CRT_Filter(Colour, uv);\n#endif \n    \n    // Approximate the brightness of the colour by using it as a 3d spacial vector and getting its length in colour space\n    float Brightness = length(Colour);\n    \n    // inrease the colour contrast, by dimming the darker colours and brightening the lighter ones, \n    // via linear interpolation of the colour and its approximated brightness value\n\tColour = mix(Colour, vec3(Brightness), Brightness - 0.5);\n    \n    return Colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get a UV chord for each texel in the range -1.0 to 1.0 (so we can scale/rotate everything from the center of the screen)\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    \n    // modify the X component of the uv, by the screen's aspect ratio to avoid stretching of the input textures in width\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    // start with black\n\tvec3 Colour = vec3(0.0, 0.0, 0.0);\n    \n    // Determine a scale value that oscilates between MIN_ZOOM and MAX_ZOOM over the desired time period\n    float ScaleValue = OscilateSinScalar(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ZOOM_FACTOR_PERIOD);\n    \n    // Determine a speed to scroll through the texture space.\n    // This works by generating a speed value between MIN_SCROLL and MAX_SCROLL\n    // which is guided by the current zoom value, such that when the texture\n    // is fully zoomed out, the scroll speed is at the desired maximum, and when\n    // the texture is fully zoomed in, the scroll speed is at the desired minimum.\n    float ScrollInterpolant = GetInterpolant(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ScaleValue);\n    // mix performs a linear interpolation between two inputs\n    float ScrollValue = mix(SCROLL_SPEED_AT_MIN_ZOOM, SCROLL_SPEED_AT_MAX_ZOOM, ScrollInterpolant); \n    \n\t// Sum the colour contribution of each layer   \n\tfor (float i = 0.0; i < 1.0; i += LAYER_STEP_SIZE)\n\t{\n        // clone the uv, so the original is preserved for each itteration of the loop\n\t\tvec2 uv2 = uv;\n       \n        // Rotate with a Z-Rotation matrix that skewes over time \n        // (Giving a slighlty different input angle for each layer, as i-squared is combined in)\n        uv2 *= ZRotate_Skewed(iTime * i*i * 12.0 * LAYER_SEPERATION_FACTOR);\n        \n        // Scale (Again, giving a slighlty different scale for each layer, as i-squared is combined in)\n\t\tuv2 *= ScaleValue * (i*i+1.0); \n\n        // Scroll the sampling position over time\n\t\tuv2.xy += ScrollValue + iTime*0.125;        \n        \n        // sample the material, building up each layer's colour contribution\n\t\tColour += SampleMaterial(uv2).xyz*LAYER_STEP_SIZE*3.5;\n\t}\n\t\n    // Perform some post processing on the accumulated colour layers\n    Colour = PostProcessColour(Colour, uv);\n    \n    // set the generated colour as the final output pixel colour\n\tfragColor = vec4(Colour, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "ltlSRn", "previewfilepath": "https://soundcloud.com/k8-bit/dune-game-inspired-piece-for-nick", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/k8-bit/dune-game-inspired-piece-for-nick", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyfW1", "name": "Rotating alternating squares ", "author": "AI", "description": "Uncomment the last line to see the colorful version.", "tags": ["checkerboard", "squares", "generativeart", "creativecoding"], "likes": 7, "viewed": 227, "date": "1607005242", "time_retrieved": "2024-06-20T20:27:00.982788", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 st, float angle){\n    st -= 0.5;\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += 0.5;\n    return st;\n}\n\nvec2 tile(vec2 st, float zoom,float rotD){\n    st *= zoom;\n     if(rotD==1.) {\n        st.x+=.5;\n        st.y+=.5;\n     }\n    return fract(st);\n}\n\nfloat square(vec2 st, vec2 side){\n    vec2 border = vec2(0.5)-side*0.5;\n    vec2 pq = smoothstep(border,border+.01,st);\n    pq *= smoothstep(border,border+.01,vec2(1.0)-st);\n    return pq.x*pq.y;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.y;\n    float color;\n    float Nsquares=4.;\n    float rotDirection=0.;\n\n\tuv = rotate2D(uv,-sin(iTime)*PI*.5);\n    rotDirection=step(0.,sin(iTime));\n    uv = tile(uv,Nsquares,rotDirection);\n    uv = rotate2D(uv,PI/4.-sin(iTime)*PI*0.25);\n    if (rotDirection==1.)\n        color = 1.0-square(uv,vec2(0.7));\n    else \n    color=square(uv,vec2(0.7));\n    fragColor = vec4(vec3(color),1.0);\n    //fragColor=vec4(color,fract(123.56*sin(.0001*iTime)),fract(241.56*sin(.0001*iTime)),1.);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyfWy", "name": "Fractal Noise 3D", "author": "oneshade", "description": "3D analog of 2D fractal noise. That's a lot of mixing!", "tags": ["3d", "noise", "fractalnoise", "tricubic", "layernoise"], "likes": 1, "viewed": 92, "date": "1607813028", "time_retrieved": "2024-06-20T20:27:00.982788", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Noise3D(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3D(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = Noise3D(cell);                       // Left, Down, Back\n    float rdb = Noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalNoise3D(in vec3 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise3D(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(FractalNoise3D(vec3(uv, iTime), 4.0, 4.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyfzy", "name": "Code Golf test", "author": "Gabe3704", "description": "gdfgdfgdfg", "tags": ["sdfsdgdgd"], "likes": 6, "viewed": 114, "date": "1609144993", "time_retrieved": "2024-06-20T20:27:00.982788", "image_code": "/*    Old code\n\n#define PI 3.14159\nfloat s( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 c = p-a, d = b-a;\n    float h = clamp( dot(c,d)/dot(d,d), 0., 1. );\n    return length( c - d*h );\n}\n\nfloat t(float v)\n{\n    return(fract(sin((iTime+v)*123.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n    vec2 m = floor(p*4.);\n    float n = 6789. * dot(m,vec2(23,45));\n    p = fract(p*4.)-.5;\n    float a = atan(p.x,p.y);\n    \n    a += PI; a /= 1.0472; a += .5; a = floor(a); a /= 0.954929; \n    \n    vec2 b = vec2(sin(a), cos(a));\n    \n    p = vec2(abs(cross(vec3(p,0),vec3(b,0)).z),-dot(p,b));\n    \n    vec3 c;\n    \n    for(int i=0;i<3;i++)\n    {\n    \tc+=vec3(min(s(p,vec2(0),vec2(0,.25)),s(p, vec2(0,mix(.05,.2,t(n+iTime+float(i)))),vec2(mix(0.,.1,t(n+iTime+float(i+1))),mix(.1,.2,t(n+iTime+float(i+2))))))<.01);\n    }\n    \n    fragColor = vec4(c,1);\n}\n*/\n\n//Golfed by gelami and FabriceNeyret2\n#define s(a,b) length( clamp( dot(p-a,c=b-a) / dot(c,c), 0., 1. ) * c - p+a )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float a = 1.05, v=a;  //  2.Pi / 6\n    for( vec2 J = vec2(0,1), c,\n              p =   length( c = fract(u*=4./iResolution.y)-.5 ) \n                  * abs( cos( mod(atan(c.y,c.x),a) + a + 33.*J ) ), u=u-c;\n         ++a < 4.; \n         v = min(v, min( s( J.x, J/4. ),\n                         s( .2* O.x*J, (O.yz + J)*.1 )\n                 )      ) \n       ) O = fract(sin( ( u.x+u.y + iTime*.01 + a+vec4(J,2,0))*123. ) )+.2;\n     O += 1.- v*60. -O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdyyRt", "name": "A sphere, a capsule, and a plane", "author": "Rowsej", "description": "Um hopefully the title doesn’t give it away\nMade this some time before; was planning to do more but making other stuffs now.\nHope you like my Fresnel", "tags": ["sphere", "raymarcher", "plane", "capsule"], "likes": 1, "viewed": 195, "date": "1608853080", "time_retrieved": "2024-06-20T20:27:00.987788", "image_code": "#define MAX_RAY_DIS 4.1\n#define EPSILON 0.001\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdPlane(vec3 p, float y) {\n    return p.y - y;\n}\nfloat sdVerticalCapsule(vec3 p, float h, float r) {\n    vec3 closestP = vec3(0.0, clamp(p.y, 0.0, h), 0.0);\n    return length(p - closestP) - r;\n}\nfloat sdCapsules(vec3 p, float cx, float r) {\n    return 0.0;\n}\nfloat getSde(vec3 p) {\n    //return min(length(p) - 1.0, p.y + 0.4);\n    return min(min(sdSphere(p, 1.0), sdPlane(p, -0.4)), sdVerticalCapsule(p - vec3(-1.2, -0.2, -0.2), 1.0, 0.1));\n}\nfloat marchShadowRay(vec3 ro, vec3 l) {\n    vec3 rd = normalize(l - ro);\n    float ld = length(l - ro);\n    float t = EPSILON * 15.0;\n    while(t < MAX_RAY_DIS * 3.0) {\n        float sde = getSde(ro + rd * t);\n        if(sde < EPSILON) {\n            break;\n        }\n        t += sde;\n        if(t >= ld) {\n            return 1.0;\n        }\n    }\n    return 0.0;\n}\n// Thanks to Baron for this\nvec3 getSkyCol(vec3 rd) {\n    float t = (rd.y + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n// Thanks to IQ for this\nvec3 estimateNormal(vec3 p) {\n    vec2 h = vec2(EPSILON, 0.0);\n    return normalize(vec3(getSde(p + h.xyy) - getSde(p - h.xyy),\n                         getSde(p + h.yxy) - getSde(p - h.yxy),\n                         getSde(p + h.yyx) - getSde(p - h.yyx)));\n}\nvec3 getPixel(vec2 coords) {\n    //vec3 ro = vec3(sin(iTime) * 3.0, 0.0, cos(iTime) * -3.0);\n    //vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 ro = vec3(0.0, 0.0, -3.0 + sin(iTime / 2.0));\n    float ry = iTime;\n    //vec3 rd = normalize(vec3(cos(ry + 90.0) + cos(ry) * coords.x, coords.y, sin(ry + 90.0) + sin(ry) * coords.x));\n    vec3 rd = normalize(vec3(coords, 1.0));\n    float t = 0.0;\n    bool hit = false;\n    while(t < MAX_RAY_DIS) {\n        float sde = getSde(ro + rd * t);\n        if(sde < EPSILON) {\n            hit = true;\n            break;\n        }\n        t += sde;\n    }\n    if(hit) {\n        vec3 col = vec3(0.2, 0.8, 0.6);\n        vec3 p = ro + rd * t;\n        //vec3 lightPos = vec3(0.0, 2.0, -3.0);\n        vec3 lightPos = vec3(sin(iTime) * 3.0, 2.0, cos(iTime) * -3.0);\n        float lightOnPoint = marchShadowRay(p, lightPos);\n        if(lightOnPoint == 0.0) {\n            return col * 0.1;\n        }\n        vec3 norm = estimateNormal(p);\n        vec3 lightDir = normalize(lightPos - p);\n        float ambient = 0.1;\n        float diffuse = clamp(dot(norm, lightDir), 0.0, 1.0);\n        float shininess = 32.0;\n        float specular = clamp(pow(dot(reflect(lightDir, norm), rd), shininess) * (1.0 - dot(norm, lightDir)), 0.0, 1.0);\n        return (col * (ambient + diffuse) + vec3(1.0, 1.0, 1.0) * specular) * lightOnPoint;\n    }\n    return getSkyCol(rd);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mind = min(iResolution.x, iResolution.y);\n    vec2 coords = fragCoord;\n    if(mind == iResolution.y) {\n        coords.x -= (iResolution.x - mind) / 2.0;\n    } else {\n        coords.y -= (iResolution.y - mind) / 2.0;\n    }\n    coords = coords / mind - 0.5;\n    vec3 col = getPixel(coords);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl2BDR", "name": "bleistift", "author": "lennyjpg", "description": "z", "tags": ["2d", "flat", "grid", "triangles", "flag", "blue", "pattern", "exp"], "likes": 2, "viewed": 178, "date": "1608398855", "time_retrieved": "2024-06-20T20:27:00.987788", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.x;\n    float t = iTime * 0.1;\n    uv.x -= t;\n    float yy = exp(uv.y * 4.+.7),\n        k = floor(yy)*3.0,\n        x = fract(uv.x*k*2.0);\n    vec2 u = vec2(x, fract(yy));    \n    u.x = abs(u.x - .5) * 2.;\n    vec2 m = u - vec2(.0,1.);\n    m.y *= 1.5;\n    vec3 g = vec3(fract(u.x)*(1.0-u.y), 0.0, 0.0);\n    float c = step(length(m),0.7);\n    float b = u.x + u.y,\n        a = uv.y * .1,\n        d = smoothstep(b + a , b - a, 1.);\n    float tip = clamp(c - d, .0, 1.);\n    vec3 gradient = vec3(fract(u.x)*(1. - u.y));\n    vec3 white = vec3(1., 1., .93) - gradient * .4;\n    vec3 red = vec3(.8,0.,0.) - g * .5;\n    float e = fract(u.x - .5) * (u.y) * .3;\n    vec3 black = vec3(e);\n    vec3 col = mix(white, red, d);\n    float n =  (u.y);\n    col.r += n * .2;\n    col = mix(col, black,tip);\n    col -= uv.y * .37;\n    O = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2BDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wl2yRR", "name": "irresponsible-raycast", "author": "ichi_raven", "description": "maybe this isn't true shading", "tags": ["maybesomethinggowrong"], "likes": 0, "viewed": 37, "date": "1607523708", "time_retrieved": "2024-06-20T20:27:00.988789", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.yy;\n\n    vec3 start = vec3(0.9f, 0.5f, 0);\n    \n    vec3 ray = normalize(vec3(uv.xy, 5) - start);\n    \n    vec3 point = vec3(0.5, 0.5, 200);    \n    \n    float dist = 10.f;\n    \n    float t = ray.x * (point.x - start.x) + ray.y * (point.y - start.y) + ray.z * (point.z - start.z);\n    t /= ray.x * ray.x + ray.y * ray.y + ray.z * ray.z;\n    \n    vec3 hitPoint = start + ray * t;\n    \n    if(distance(hitPoint, point) > dist)\n    {\n        fragColor = vec4(0.f);\n        return;\n    }\n    \n    vec3 l = normalize(vec3(0, 1, 0));\n    l.x = l.x * cos(iTime) - l.y * sin(iTime);\n    l.y = l.x * sin(iTime) + l.y * cos(iTime);\n    vec3 n = normalize(point - hitPoint);\n    \n    vec4 baseColor = vec4(1.f, 0.f, 0.f, 1.f);\n    \n    vec4 ambient = vec4(0.5, 0.5, 0.5, 1.0);\n   \n    vec4 color = vec4(0.f);\n    \n    color = baseColor * ambient;\n    \n    color += baseColor * min(max(dot(l, n), 0.f), 1.f);\n\n    fragColor = color;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3cDr", "name": "like a record baby", "author": "tetrismegistus", "description": "an experiment with circles and circular movement", "tags": ["circles", "beginner"], "likes": 1, "viewed": 181, "date": "1608768896", "time_retrieved": "2024-06-20T20:27:00.988789", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nfloat Circle(vec2 uv, vec2 p,float r, float blur) {\n    \n    float d = length(uv-p);    \n    float c = smoothstep(r, r - blur,  d);\n    return c;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 p = vec2(.0, .0);\n    float c = Circle(uv, p, .5, .009);\n    c -= Circle(uv, vec2(sin(.0 + iTime) * (.5 - .1), cos(.0 + iTime) * (0.5 - .1)), .1, .009);\n    c -= Circle(uv, vec2(sin(.0 + iTime * PI) * (.21), cos(.0 + iTime * PI) * (.21)), .1, .009);\n    c -= Circle(uv, vec2(sin(.0 + iTime * TWO_PI) * (.02), cos(.0 + iTime * TWO_PI) * (.02)), .1, .009);\n        \n\n    // Output to screen\n    fragColor = vec4(vec3(c, 0.0, 0.0),  1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3cR7", "name": "\"Circular\" Pattern Tiling", "author": "mrange", "description": "License CC0 - Circular Pattern Tiling\n  I wanted to create circular tiling, turned out ok\n", "tags": ["2d", "tiling", "circular"], "likes": 12, "viewed": 237, "date": "1608643366", "time_retrieved": "2024-06-20T20:27:01.581150", "image_code": "// License CC0 - \"Circular\" Pattern Tiling\n//  I wanted to create \"circular\" tiling, turned out ok\n//  mod1  - From: http://mercury.sexy/hg_sdf/\n//  star5 - From: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// Like many tiling functions modifies the input argument\n//  and returns a vector indicating which tile we are in\nvec3 modCircularPattern(inout vec2 p) {\n  vec2 pp = toPolar(p);\n\n  float nx = floor(pp.x + 0.5);\n  pp.x -= nx;\n  mod1(pp.x, 1.0);\n  pp.x += nx;\n  float cy = floor(0.5*nx*TAU)*2.0;\n  \n  float ny = mod1(pp.y, TAU/cy);\n  if(nx > 0.0) {\n    p = toRect(pp) - vec2(nx, 0.0);\n    return vec3(nx, mod(ny+cy*0.5, cy), cy);\n  } else {\n    return vec3(0.0, 0.0, 1.0);\n  }\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x+s*p.y, -s*p.x+c*p.y);\n}\n\nfloat star5(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat df(vec2 p) {\n  const float lw = 0.033;\n\n  float nx = floor(length(p) + 0.5);\n  rot(p, iTime/sqrt(1.0+nx));\n\n  vec3 n = modCircularPattern(p);\n\n  rot(p, 0.1*TAU*(n.y+n.x));;\n\n  float d = star5(p, 0.5-lw, 0.5);  \n  d = abs(d) - lw;\n\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float aa = 2.0/iResolution.y;\n  \n  float s = 0.25*mix(0.1, 1.0, 0.5+0.5*sin(iTime*0.5));\n  float d = df(p/s)*s;\n  \n  vec3 col = mix(vec3(1.0), vec3(0.125), tanh(length(0.05*p/s)));\n  \n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n  col = pow(col, vec3(1.0/2.2));\n  \n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3cRM", "name": "cables2 golfed (664 chars)", "author": "FabriceNeyret2", "description": "mildly golfing 1627 chars yuntaRobo's cables2 [url]https://www.shadertoy.com/view/wlKXWc[/url]\n", "tags": ["raymarching", "torus", "sphere", "cables"], "likes": 10, "viewed": 319, "date": "1608632032", "time_retrieved": "2024-06-20T20:27:01.581150", "image_code": "// golfing 1627 chars yuntaRobo's cables2 https://www.shadertoy.com/view/wlKXWc\n// -10 by xavierseb\n\n#define L length\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec3 R = iResolution,\n         P = vec3(0,0,10), p,\n         D = vec3( U+U-R.xy, -3.*min(R.x, R.y) ); D /= L(D);\n\n    for (float A=0., z = 0.; z < 15. && A<20.; z += 15./128.) {\n        p = P;\n        p.yz *= mat2(cos(3.14/5. + vec4(0,11,33,0) ) );\n        p.y -= .5;\n        float d = 1e2, N=50., s, r, i=0., a=i, t = iTime;\n        \n        R = vec3( cos(t), 0, sin(t) ) * 3.;              // reaction\n        s = L(R-p);\n        p += (R-p)/s / exp(s);\n               \n        for ( r = atan(p.z, p.x) * 3. ; i < N; i++)      // cables\n            r += .5/N * 6.3,\n            s = .5 + sin( i * 1.618 * 6.28) /4. + sin(t + i ) * .1,\n            s = L( vec2(L(p.xz) + cos(r) * s - 3., p.y + sin(r) * s) ) - .035,\n            s < d ? d=s, a=i : a;\n        \n        s = L(R-p) - .1;                                 // sphere\n        s < d ? d=s, a=0. : a;\n\n        if (d < .01) {\n            s = fract(a * 1.618);\n            O = s > .1 && s < .45 ? vec4(.175, .1, .1, 1) \n              : s < .05 ? vec4(1) \n              : mix( vec4(.1, .1, .5, 1), vec4(0, 0, 1, 1), s ) ;\n            O = sqrt( O / exp(z) );\n            return;\n        }\n\n        A += d *= .6;\n        P += D * d;\n    }\n    \n    O = abs(D.yyyy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3czn", "name": "day 365", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 9, "viewed": 240, "date": "1608321976", "time_retrieved": "2024-06-20T20:27:01.581150", "image_code": "// I'VE LOST COUNT LOL, so I skipped to 365 which is the correct number! \n// tune in tomorrow for birthday stream at https://www.twitch.tv/wwrighter\n\nfloat df;\nfloat rep = 2.75;\nfloat sz;\n\n#define pi acos(-1.)\n\n#define pump(g,a) (floor(g) + pow(fract(g),a))\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nmat2 rot(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat sdCirc (vec2 uv, float s){\n    return length(uv) - s;\n}\n\nfloat sdRect (vec2 uv, vec2 s){\n    uv = abs(uv)- s;\n    return max(uv.x,uv.y);\n}\nfloat sdRect (vec2 uv, float s){\n    uv = abs(uv)- s;\n    return max(uv.x,uv.y);\n}\nfloat sdCube (vec3 uv, float s){\n    \n    uv = abs(uv)- s;\n    uv.xz *= rot(0.);\n    return max(uv.x,max(uv.y,uv.z));\n}\n\nfloat sdSphere(vec3 p, float s){return length(p) -s;}\n\n//float sdCube(vec3 p, float s){return length(p) -s;\n\nfloat get(vec2 uv, vec2 id, float T){\n    //float dc = sdCirc(uv, sz*(0.1 + .1*sin(iTime + length(id))));\n    \n    T *= 0.1;\n    //d = 10e5;\n    //#define m(j) (sin(j + iTime+ id.x*1.*sin(iTime+id)*0.1  + length(id)*1.2 + iTime*.2) + sin(length(id))*1.)\n    #define m (sin(length(id/sz)*0.2 + T*11.)*0.5)\n\n    vec3 p = vec3(uv,0.1 + m*0.1);\n    p.x += m;\n    \n    \n    p.yz *= rot(-pi*(0.25 + pow(m,2.)*0.));\n    p.xy *= rot(pi*0.25);\n\n    //p.xy += m;\n    float dc = sdCube (p,sz*(0.1 + iMouse.x/iResolution.x*0.05 + pow(m,2.)*0.4)*2.);//*(0.9)*(1.-m));\n    \n    float d = abs(dc - 0.1*(1.-m));\n    //d = abs(d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 guv = uv;\n    uv *= 5.  ;\n    df = dFdx(uv.x);\n    sz = 1./rep;\n    \n    vec3 col = vec3(0);    \n    vec2 id = floor(uv*rep);\n    \n    uv = mod(uv,sz) - sz*0.5;\n    float d = 10e6;\n    #define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n     \n    float chrabs = 9.;\n    for(float chrab = 0.; chrab < chrabs; chrab++){\n        float overstep = 3.*2.*1.;\n        float nd = 10e5;\n        for(float i = 0.; i < overstep*overstep; i++){\n            vec2 idx = vec2(\n                mod( i,overstep)  - 0.5*overstep , \n                floor( (i)/overstep) - 0.5*overstep\n                );\n            nd = min(nd, get(uv - idx*sz, id + idx, iTime - 0.4*chrab/chrabs) - 0.04*chrab/chrabs);\n\n        }\n        \n        nd = max(nd,-d);\n        vec3 c = pal(.5,0.5,vec3(3,2,1. + sin(iTime)),1. ,41. + 6.*chrab/chrabs + iTime + length(guv)*0.4);\n        col = mix(col,c*(1.4-chrab/chrabs*1.64),smoothstep(df,0.,nd ));\n        \n    \n    }\n    col = smoothstep(0.,1.,col*2.);\n    col = pow(col,vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3czn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3yD8", "name": "swirl but straight [spaz]", "author": "HaleyHalcyon", "description": "ab", "tags": ["spiralhypno"], "likes": 2, "viewed": 213, "date": "1608903827", "time_retrieved": "2024-06-20T20:27:01.581150", "image_code": "#define TAU (3.14159265358979 * 2.)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// should generate 4 1-bit RGB colors, where\n// colors 0 and 2, and colors 1 and 3, can't be the same\nmat4x3 randCol(uint x) {\n    uvec3 col0 = uvec3(\n         x        & 1u,\n        (x >> 1u) & 1u,\n        (x >> 2u) & 1u\n    );\n    uvec3 col1 = uvec3(\n        (x >> 3u) & 1u,\n        (x >> 4u) & 1u,\n        (x >> 5u) & 1u\n    );\n    uint y = x ^ ((x >> 6u) % 6u + 1u);\n    uvec3 col2 = uvec3(\n         y        & 1u,\n        (y >> 1u) & 1u,\n        (y >> 2u) & 1u\n    );\n    y = (x >> 3u) ^ ((x >> 9u) % 6u + 1u);\n    uvec3 col3 = uvec3(\n         y        & 1u,\n        (y >> 1u) & 1u,\n        (y >> 2u) & 1u\n    );\n    return mat4x3(col0, col1, col2, col3);\n}\n\nfloat logStripe(vec2 uv, float offset, float angleAdd) {\n    return fract(offset + 2. * log(abs(dot(\n        uv, vec2(cos(angleAdd), sin(angleAdd))\n    ))+0.03));\n}\n\nuint lastTime = uint(-1);\nmat4x3 colors;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = length(iResolution);\n    vec2 uv = fragCoord / scale;\n\tuv -= (iResolution.xy / scale) / 2.;\n    uv *= 2.0;\n    \n    float distSq = uv.x*uv.x+uv.y*uv.y;\n    float angle = atan(uv.x, uv.y) / TAU;\n    float angleAdd = fract(iTime / 8.);\n    float distAdd = fract(iTime / 0.3);\n    \n    vec3 which = vec3(step(fract(angleAdd * 2. + angle * 2. + distSq * 0.21), .5));\n    \n    uint colTime = uint(int(mod(iTime - tan((0.25 + iTime) * TAU * 0.5) * .8 + sin(iTime * TAU * 0.25) * 6., 4294967295.)));\n    if (lastTime != colTime) {\n        lastTime = colTime;\n        uint hash = hash(colTime);\n        colors = randCol(hash);\n    }\n    float thr = 0.5 + 0.4 * sin(iTime * TAU);\n    vec3 colA = mix(colors[0], colors[2],\n      step(logStripe(uv, distAdd, angleAdd * TAU), thr)\n    );\n    vec3 colB = mix(colors[1], colors[3],\n      step(logStripe(uv, distAdd, angleAdd * TAU + TAU / 4.), thr)\n    );\n    \n    vec3 col = mix(colA, colB, which);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3yRN", "name": "crag coloring with noise", "author": "wnu", "description": "noise", "tags": ["noise"], "likes": 4, "viewed": 45, "date": "1608520073", "time_retrieved": "2024-06-20T20:27:01.586990", "image_code": "mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat random3 (in vec3 _st) {\n    return fract(sin(dot(_st,\n                         vec3(12.9898,78.233,123.24647)))*\n      43758.5453123);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat noise3 (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 fr = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random3(i);\n    float b = random3(i + vec3(1.0, 0.0, 0.0));\n    float c = random3(i + vec3(0.0, 1.0, 0.0));\n    float d = random3(i + vec3(1.0, 1.0, 0.0));\n    \n    float e = random3(i + vec3(0.0, 0.0, 1.0));\n    float f = random3(i + vec3(1.0, 0.0, 1.0));\n    float g = random3(i + vec3(0.0, 1.0, 1.0));\n    float h = random3(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = fr * fr * (3.0 - 2.0 * fr);\n    \n    float bf = mix(a,b,u.x);\n    float bb = mix(c,d,u.x);\n    \n    float bot = mix(bf,bb,u.y);\n    \n    float tf = mix(e,f,u.x);\n    float tb = mix(g,h,u.x);\n    \n    float top = mix(tf,tb,u.y); \n\n    return mix(bot,top,u.z);\n}\n\n#define NUM_OCTAVES 6\n\nfloat fbm3 ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5/1.5;\n        v += a * noise3(_st)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat fbmN(vec3 _st, int n){\n\tfloat v = 0.;\n    for (int i = 0;i<4;i++){\n        if(i>=n) break;\n        v= fbm3(_st + v*4.);\n    }\n    \n    return v;\n}\n\nfloat map(vec3 pos){\n    float circle = length(pos) - 1.;\n    float plane = pos.y;\n    //plane += fbmN(vec3(pos.xz,0.),2)/1.;\n    plane += fbm3(vec3(pos.xz,0.))/1.;\n    //plane += noise3(vec3(pos.xz,0.))/1.;\n    //plane += random3(vec3(pos.xz,0.))*10.;\n    float d= plane;\n    return d*0.5;   \n}\n\n//int MAX_STEPS = 100;\n//float MAX_DIST = 10.;\n//float SURF_DIST = 0.05;\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float d = 0.;\n    \n    for(int i = 0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*d;\n        float dS = map(p);\n        d += dS;\n        if(d>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p,vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n   // if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z ,\n        i = c + uv.x*r + uv.y*u ,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 rot = rotationMatrix(vec3(1.,1.,1.),0.);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = vec2(0.5,0.35);\n\n    vec3 offset = vec3(0.,0.,-iTime/2.);\n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    ro += offset;\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0)+ offset, 1.);\n    \n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    \n    float d = rayMarch(ro,rd);\n    \n    if(d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float dif = GetLight(p,vec3(3, 5, 4));\n        vec3 sun = vec3(0.8,0.2,0.2);\n        //sun = vec3(0.3,0.5,0.6);\n        vec3 dep = vec3(0.7,0.5,0.2);\n        //dep = vec3(0.5,0.5,0.5);\n        vec3 cra = vec3(1.,0.1,0.1);\n        //cra = vec3(0.1,0.1,1.);\n        \n        vec3 sun2 = vec3(0.7,0.6,0.2);\n        float dif2 = GetLight(p,vec3(-50,1,-4));\n        \n        vec3 sun_col = vec3(dif)*sun;\n        float depth = -p.y;\n        vec3 dep_col = dep*depth;\n        float crag = smoothstep(-0.8,-1.,p.y);\n        vec3 crag_col = cra*crag;\n        col = mix(sun_col,dep_col,0.5);\n        col += crag_col;\n        //col += dif2*sun2/2.;\n    }\n    \n    //float c = step(10.,d);\n    \n    //col = vec3(c);\n    \n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl3yzH", "name": "fucked up 3d rotation", "author": "alice", "description": "first raymarching thing. supposed to be an infinite field of cube/sphere intersection things, each with a random rotation. i messed up the rotation function though, and thought it looked cool. comment out line 47 to see how it looks unfucked", "tags": ["3d", "glitch", "learning"], "likes": 2, "viewed": 64, "date": "1608441050", "time_retrieved": "2024-06-20T20:27:02.181056", "image_code": "//Set this define for shadertoy\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\n#define PI 3.1415926538\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_STEPS = 500;\nconst float MIN_RAY_LEN = .1;\nconst float MAX_RAY_LEN = 10000.;\nconst float RAY_HIT_THRESH = 0.01;\n\nfloat rand1(vec3 i){\n    return fract(sin(dot(i,vec3(15.736564920423735,87.35522147781187,78.89253088762932))) * 43758.5453);\n}\n\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle); // ??? idk, it's from blackle\n}\n\nfloat sphere(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\nfloat cube(vec3 samplePoint, float r) {\n  vec3 q = abs(samplePoint) - r;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nvec3 repeat(vec3 samplePoint, vec3 pitch) {\n    return mod(samplePoint+0.5 * pitch, pitch)-0.5*pitch;\n}\n\nfloat scene(vec3 samplePoint) {\n    vec3 localPoint = repeat(samplePoint+1.5, vec3(3.));\n    vec3 gridPos = floor((samplePoint+1.5)/3.);\n    localPoint = rotateAxis(localPoint, vec3(rand1(vec3(gridPos.x+0.01, gridPos.y, gridPos.z)), rand1(vec3(gridPos.x, gridPos.y+0.01, gridPos.z)), rand1(vec3(gridPos.x, gridPos.y, gridPos.z+0.01))), PI);\n    return max(sphere(localPoint, 1.), cube(localPoint, 0.8));\n}\n\nvec3 rayDirection(vec2 fragCoord, vec2 image_size, float fov) {\n    vec2 xy = fragCoord.xy - image_size.xy / 2.;\n    float z = min(image_size.x, image_size.y) / tan(radians(fov) / 2.); // we don't need length(xy) here because fov just refers to the fov of a single axis\n    return normalize(vec3(xy, -z));\n}\n\nfloat shortestDistance(vec3 cameraPosition, vec3 rayDirection) {\n    float len = MIN_RAY_LEN;\n    for (int i=0; i < MAX_STEPS; i++) {\n        float dist = scene(cameraPosition + len * rayDirection);\n        // isn't there a better way than just getting infinitesimally closer till we're within some tiny radius?\n        // if we figured out the normal when we get close to the final surface, couldn't we extrapolate an expected point of intersection that way? then raymarch up to that, but allow the loop to continue in case we're just grazing past\n        if (dist < RAY_HIT_THRESH) {\n            return len;\n        }\n        len += dist;\n        if (len >= MAX_RAY_LEN) {\n            return MAX_RAY_LEN;\n        }\n    }\n    return MAX_RAY_LEN;\n}\n\nvec3 normal(vec3 p) {\n    float original_dist = scene(p);\n    // we lose a little precision by not having our normal centered on the target point but rather sticking out a bit by RAY_HIT_THRESH, but we're saving 2 SDF evaluations\n    return normalize(vec3(\n        scene(vec3(p.x + RAY_HIT_THRESH, p.y, p.z)) - original_dist,\n        scene(vec3(p.x, p.y + RAY_HIT_THRESH, p.z)) - original_dist,\n        scene(vec3(p.x, p.y, p.z + RAY_HIT_THRESH)) - original_dist\n    ));\n}\n\nvec2 circularMotion(float time, float radius) {\n    return vec2(sin(time), cos(time))*radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime/10.;\n    vec3 cameraPosition = vec3(circularMotion(time*3., 1.5), time*10.)+1.5;\n    vec3 dir = rotateAxis(rayDirection(fragCoord, iResolution.xy, 110.), vec3(0., 1., 0.), time);\n    float dist = shortestDistance(cameraPosition, dir);\n    vec3 point = cameraPosition + dist * dir;\n    vec3 normal = normal(point);\n    vec3 color = pow(normal*0.5+0.5, vec3(2.));\n    fragColor = vec4(dist >= MAX_RAY_LEN ? vec3(0) : color, 1.);\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wl3yzS", "name": "Simple sine waves", "author": "morphix", "description": "Just some simple sine waves", "tags": ["sinewaves"], "likes": 1, "viewed": 135, "date": "1609336631", "time_retrieved": "2024-06-20T20:27:02.181056", "image_code": "#define S(a) sin(a)\n#define C(a) cos(a)\n#define t iTime\n#define X vu.x\n#define Y vu.y\n\nfloat c = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vu = ( 2.* fragCoord - iResolution.xy) / iResolution.y;\n\tfor(float i = 0.; i < 7.; i++)\n\t  c += abs( 1. / S( Y + 0.1 + S( i * .01 + X * 3.3 + t * .3 -i * .1 ) * C( X + t * .1 ) * S( X + t * .5 + i * .1) * C( i * .04 )  ) );\n\tfragColor = vec4( vec3(c) * vec3(0.003, 0.003, .01), 1. );\n}\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlccRN", "name": "serg3", "author": "serega09", "description": "1", "tags": ["1"], "likes": 8, "viewed": 434, "date": "1608566825", "time_retrieved": "2024-06-20T20:27:02.181056", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 128.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.5;\nconst float BRIGHTNESS = 0.15;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 color){\n    vec4 konvert = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 calc = abs(fract(color.xxx + konvert.xyz) * 6.0 - konvert.www);\n    return color.z * mix(konvert.xxx, clamp(calc - konvert.xxx, 0.0, 1.0), color.y);\n}\n\nfloat luma(vec3 color) {\n  //return dot(color, vec3(0.299, 0.587, 0.114));\n  return dot(color, vec3(0.299, 0.587, 0.5));\n}\n\nfloat getFrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getFrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getFrequency(index), getFrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getFrequency_blend(float x) {\n    return mix(getFrequency(x), getFrequency_smooth(x), 0.5);\n}\n\nvec3 circleIllumination(vec2 fragment, float radius) {\n\tfloat distance = length(fragment);\n\tfloat ring = 1.0 / abs(distance - radius - (getFrequency_smooth(0.0)/4.50));\n\t\n\t//float brightness = distance < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcolor += hsv2rgb( vec3( ( angle + iTime * 2.5 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * BRIGHTNESS;\n\t\n\tfloat frequency = max(getFrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcolor *= frequency;\n\t\n\t// Black halo\n\t//color *= smooth//step(radius * 0.5, radius, distance);\n\t\n\treturn color;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getFrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n\tcolor += circleIllumination(fragPos, RADIUS);\n    \n    \n    \n    color += max(luma(color) - 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlccRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wlccz8", "name": "Biohazard Snowflakes", "author": "mherreshoff", "description": "Biohazard snowflake, so called because the spiny part of the fractal resembles a biohazard symbol.  Switches between stationary and continuously rotating versions.", "tags": ["fractal", "morphing", "snowflakes", "biohazard"], "likes": 6, "viewed": 72, "date": "1608430048", "time_retrieved": "2024-06-20T20:27:02.181056", "image_code": "#define PI 3.1415926535\n#define CS(a) vec2(cos(a), sin(a))\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0)))\nvec2 cmul(vec2 a, vec2 b) {\n    return mat2(a,-a.y,a.x)*b;\n}\nvec2 cpow(vec2 z, float n) {\n    float mag = pow(length(z),n), angle = atan(z.y, z.x)*n;\n    return mag*CS(angle);\n}\nfloat smoothHill(float a, float b, float c, float x) {\n    return smoothstep(a,b,x)-smoothstep(b,c,x);\n}\nfloat smoothParity(float x, float b) {\n    float m = mod(x-.5, 2.);\n    return smoothstep(.5-b, .5+b, m) - smoothstep(1.5-b, 1.5+b, m);\n}\n\n\nvec2 target (vec2 z, float twist) {\n    vec2 weightedSum=vec2(0); float weight=0.;\n#define N 3.\n    for (float i = 0.; i < N; i++) {\n        float theta = 6.28*(i/N);\n        vec2 point = CS(theta), d = z-point, d2 = cmul(CS(-theta+twist), cpow(d, 2.));\n        float L = length(d), w = pow(L, -10.);\n        weight += w;\n        weightedSum += w*2.5*mix(d2, d, (L > 1. ? 1. : pow(L, 15.)));\n    }\n    return weightedSum/weight;\n}\n\nvec4 render(in vec2 fragCoord){\n    vec2 R = iResolution.xy, pw = 1./R, uv = fragCoord*pw;\n    \n    float cycleT=30., t = fract(iTime/cycleT),\n          parity = smoothParity(iTime/cycleT, .05),\n          twistA = 2.*PI*(fract(2.*t+.5)-.5),\n          twist = mix(0., twistA, parity),\n          maxIt = 5., iterations = maxIt*(smoothHill(0.,.75,1.,t)),\n          zoom = 4.;\n\n    vec2 p = rot(radians(-90.))*((fragCoord-.5*R)/R.y)*zoom;\n    for (float i = 0.; i < 10.; i++){\n        if (i < floor(iterations)) p = target(p, twist);\n    }\n    p = mix(p, target(p, twist), fract(iterations));\n    \n    float mag = length(p);\n    vec4 col = mix(vec4(.1), vec4(.8), min(1., mag));\n    col = mix(col, hue(.3), smoothHill(1., 1.5, 2., mag));\n    col = col*min(1., pow(length(p), -2.));\n\treturn col;\n    //return hue(atan(p.y, p.x)/6.28);\n}\nvoid mainImage( out vec4 O, in vec2 u ) {\n    // 2D Antialiasing:\n    vec2 d = vec2(.5,0);\n    O = (render(u+d.xy)+render(u-d.xy)+render(u+d.yx)+render(u-d.yx))*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wlccz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlcyD7", "name": "TIE Fighters", "author": "dean_the_coder", "description": "It was a fine line between creating a scene with\nTIE Fighters or X-Wings. TIE Fighters won.\n\nScene duration: 40 secs", "tags": ["3d", "raymarching", "snow", "starwars", "disney", "movie", "cineshader"], "likes": 65, "viewed": 10764, "date": "1609185361", "time_retrieved": "2024-06-20T20:27:04.302572", "image_code": "// 'TIE Fighters' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WlcyD7\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// It was a fine line between creating a scene with\n// TIE Fighters or X-Wings. TIE Fighters won.\n// I'm quite happy with the modelling in this one,\n// but definitely want to practice terrains some more.\n//\n// I've switched to using hash functions which don't\n// rely on trig functions. Hopefully that will reduce\n// differences on different platforms...\n//\n// Tricks to get the performance:\n//  - The TIE SDF code bails early if the raymarching point\n//    is 'too far away', so no time wasted calculating the SDF\n//    of all the fine details when not necessary.\n//    See sdTie()\n//  - Shadows are only cast by the TIEs (See calcShadow())\n//    so I don't have to render the entire scene too many times.\n//  - The ray is only reflected if it hits glass or metal, and then\n//    marched only if it points down. (So we don't reflect the sky.)\n//  - I have two normal-calculating functions. One for the TIEs,\n//    and one for the terrain. Once the ray has hit an object,\n//    the relevant 'normal' code is called.\n//  - The high frequency noise is added to the terrain during the\n//    color look-up phase. Only the low frequency noise is added to\n//    the SDF.\n//\n// Things I _could_ do:\n//  - Split the TIE modelling into two functions, one for just\n//    the wings and cockpit, and another which extends it to\n//    include the finer details.\n//    The 'simple' version could be used to generate the shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat T, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n// Thanks Dave Hoskins - https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * vec4(.1031, .103, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.y, p.x) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdHex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.866, .5, .577);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec3 n) { return dot(p, n); }\n\nfloat dot2(vec3 a) { return dot(a, a); }\n\nfloat sdTri(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa), dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)), dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0., 1.) - pc)) : dot(n, pa) * dot(n, pa) / dot2(n));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdWings(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\treturn Hit(min(sdTri(p, vec3(0), vec3(2, 3, 0), vec3(-2, 3, 0)), sdTri(p, vec3(0), vec3(3.3, 0, 0), vec3(2, 3, 0))) - .03, 2, p);\n}\n\nHit sdTie(vec3 p) {\n\tp = p.zyx - vec3(10, 0, 0);\n\n\t// Wings.\n\tHit h = sdWings(p);\n\tif (h.d > 2.5) return h; // Bail early - Point is too far away.\n\t// Wing ribs.\n\tvec3 op = p;\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\tfloat f,\n\t      d = 0.;\n\tif ((f = abs(p.y)) < .1) d = .03 + step(f, .025) * .02;\n\telse if ((f = abs(p.y - p.x * 1.5)) < .15) d = .03 + step(f, .025) * .02;\n\telse if (abs(p.y - 3.) < .1) d = .03;\n\telse if (abs(p.x - 3.3 + p.y * .43) < .1) d = .03;\n\n\tif (d > 0.) {\n\t\th.d -= d;\n\t\th.id = 1;\n\t}\n\n\t// Wing center hexes.\n\td = min(sdHex(p, vec2(.7, .06)), sdHex(p, vec2(.5, .12)));\n\n\t// Crossbar.\n\td = min(d, sdCyl(op, vec2(mix(.21, .23, step(p.y, .04)), 2.3))); // Main bar\n\tp.z = abs(p.z + .8) - .5;\n\tf = sdCyl(p, vec2(mix(.21, .33, (p.z + .33) / .48), .24));\n\tp.x -= .25;\n\tp.z += .02;\n\td = min(d, max(f, -sdBox(p, vec3(.1, .4, .08)))); // Join to wing/cockpit.\n\tp = op;\n\tp.yz = abs(p.yz);\n\tminH(h, Hit(min(d, sdTri(p, vec3(0), vec3(0, .8, 0), vec3(0, 0, 2)) - .05), 1, p)); // Triangle cockpit supports.\n\t// Cockpit - Sphere.\n\tf = step(.75, p.y);\n\tminH(h, Hit(length(op) - .9 - .02 * (f + step(p.y, .03) + f * step(p.z, .1)), 6, p));\n\n\t// Cockpit - Glass.\n\tp = op;\n\tp.x += .27;\n\tp.yz = opModPolar(p.yz, 8., .4);\n\tminH(h, Hit(max(length(p) - .7, sdPlane(p + vec3(.77, 0, 0), vec3(vec2(-1, 0) * rot(.5), 0))), 3, p));\n\n\t// Cockpit - Window frame.\n\tminH(h, Hit(max(length(p) - .71, .45 - length(p.yz)), 5, p));\n\n\t// Gunz.\n\tp = op;\n\tp.x += .7;\n\tp.y += .6;\n\tp.z = abs(p.z) - .2;\n\tminH(h, Hit(sdCyl(p.zyx, vec2(.05, .2)), 7, p));\n\treturn h;\n}\n\n// Position of the lead TIE.\nvec3 tiePos(vec3 p, float t) {\n\tfloat x = cos(t * .7);\n\tp += vec3(x, cos(t), sin(t * 1.1));\n\tp.xy *= rot(x * -.1);\n\treturn p;\n}\n\nHit sdTies(vec3 p) {\n\tvec3 op = p;\n\n\t// Front tie.\n\tp = tiePos(p, T);\n\tHit h = sdTie(p);\n\tif (sin(T) - step(T, 0.) * 10. > -.7) {\n\t\t// Weapon fire.\n\t\tp.x = abs(p.x) - .2;\n\t\tp.y += .6;\n\t\tp.z = mod(p.z + T * 50., 8.) - 4.;\n\t\tfloat x = max(sdCyl(p, vec2(.03, 1)), op.z - 8.);\n\t\tminH(h, Hit(x, 9, p));\n\t\tg += .001 / (.01 + x * x);\n\t}\n\n\t// Rear tie.\n\tif (h.d > .0015) {\n\t\tfloat x = -cos(T);\n\t\tp = op + vec3(14, -4. - .5 * cos(T * .5), -20. + 4. * sin(T * .6));\n\t\tp.xy *= rot(x * -.1);\n\t\tminH(h, sdTie(p));\n\t}\n\n\treturn h;\n}\n\nHit sdTerrain(vec3 p) {\n\tp.z -= T * 7e2; // Number controls the terrain speed.\n\tvec2 d = sin(p.xz * vec2(.01476, .01345)) * 10. + sin(p.xz * vec2(.05212, .04512)) * 2.;\n\treturn Hit(abs(p.y - d.x + d.y + 25.), 4, p);\n}\n\nHit map(vec3 p) {\n\tHit h = sdTerrain(p);\n\tminH(h, sdTies(p));\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTies(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Terrian normal.\n// (Special case, but faster than using the SDF for the entire scene.)\nvec3 calcTN(vec3 p, float t) {\n\tfloat h = t * 2.;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTerrain(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Note: For performance, shadows are only cast by tie fighters.\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1.,\n\t      t = 1.;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = sdTies(p + ld * t).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 1e2) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Note: For performance, occlusion only applied to tie fighters.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(sdTies(p + h * n).d / h, 0., 1.); }\n\n// Sub-surface scattering (Applied to the snow).\n#define SSS(h)\tclamp(sdTerrain(p + ld * h).d / h, 0., 1.)\n\n/**********************************************************************************/\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tfloat am, ldt, l, spe,\n\t      sped = 4.;\n\tvec3 c, n, lig,\n\t     ld = normalize(vec3(30, 50, -40) - p);\n\tif (h.id == 4) {\n\t\t// Snow\n\t\tc = vec3(1.2 + SSS(1.) * .44);\n\t\tn = normalize(calcTN(p, d) + n31(h.uv) * .1);\n\t\tam = mix(.3, .9, sdTerrain(p + n).d);\n\t\tsped = .4;\n\t}\n\telse {\n\t\tn = calcN(p, d);\n\t\tam = mix(ao(p, n, .5), ao(p, n, 1.2), .75);\n\t\tif (h.id == 1 || h.id == 6) {\n\t\t\t// Metal\n\t\t\tc = vec3(.3 - n31(h.uv * 18.7) * .1);\n\t\t\tsped = .5;\n\t\t\tif (h.id == 6) c *= 1. - .8 * step(abs(atan(h.uv.y, h.uv.z) - .8), .01); // Cockpit.\n\t\t}\n\t\telse if (h.id == 2) {\n\t\t\t// Black wing area.\n\t\t\tif (h.uv.x < h.uv.y * .7) h.uv.y = 0.;\n\t\t\tc = vec3(.005 + .045 * pow(abs(sin((h.uv.x - h.uv.y) * 12.)), 20.));\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 7) {\n\t\t\t// Gunz.\n\t\t\tc = vec3(.02);\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 3) c = vec3(.05); // Cockpit glass.\n\t\telse if (h.id == 5) c = vec3(.1); // Glass surround.\n\t\telse c = vec3(.3, 1, .3); // Fire!\n\t}\n\n\t// Primary light.\n\tldt = dot(ld, n);\n\tl = max(0., .2 + .8 * ldt) + max(0., .2 - .8 * ldt) * .3;\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 50.)) * sped;\n\n\t// Combine.\n\tlig = l * am * mix(.4, 1., calcShadow(p, ld)) * vec3(2, 1.8, 1.7) + clamp(n.y, .05, 1.) * vec3(.9, .95, 1); // Sky light.\n\treturn c * lig + spe;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c;\n\tfloat gg,\n\t      d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 || d > 6e2) break;\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tgg = g; // Cache the 'glow'.\n\tif (d > 6e2) c = vec3(.85, .9, 1);\n\telse c = mix(lights(p, rd, d, h), vec3(1), smoothstep(2e2, 540., d));\n\n\tc += gg * vec3(0, 1, 0);\n\tif (h.id == 3 || h.id == 1) {\n\t\t// Reflections applied to cockpit glass and tie metal.\n\t\trd = reflect(rd, calcN(p, d));\n\t\tfloat alpha = (h.id == 3 ? .4 : .2) * smoothstep(0., 1., -rd.y);\n\t\tif (alpha < .001) return c; // Only reflect downwards.\n\t\td = .01;\n\t\tro = p;\n\t\tfor (float i = 0.; i < 40.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = sdTerrain(p);\n\t\t\tif (abs(h.d) < .0015 || d > 3e2) break;\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\t// Combine a % of the reflected color.\n\t\tc = mix(c, d > 3e2 ? vec3(1) : lights(p, rd, d, h), alpha);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tT = mod(iTime, 40.) - 4.;\n\tg = 0.;\n\tfloat t = smoothstep(0., 5., T);\n\tvec3 lookAt = mix(vec3(0, 0, 6) - tiePos(vec3(0), T - .2), vec3(2.5, 0, 0), t),\n\t     ro = mix(lookAt - vec3(0, 0, 1), vec3(4. + cos(T), sin(T) * .2, -8. + cos(T * .2) * 6.), t);\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, lookAt, (fc - .5 * iResolution.xy) / iResolution.y)), vec3(.45)), fc), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlcyR4", "name": "help,question about perlin-noise", "author": "jcyuan", "description": "hi guys, i have a question about perlin noise, please read in the soure code for details, thank you so much if any help.", "tags": ["perlinnoise"], "likes": 0, "viewed": 197, "date": "1608547981", "time_retrieved": "2024-06-20T20:27:04.720727", "image_code": "// the question is, i don't know what is the rule to define the grid size.\n// for example in noise2d method, the grid size is defined as 1, so i'm clear.\n// but in IQ's shader, the noise3d_1 and noise3d_2 uses a tech: fetch hash from texture,\n// he defines different grid size for the two methods: \n//      for noise3d_1:  37, 17\n//      for noise3d_2:  37, 239\n//\n// actually i saw in some shaders, the size is different too, like\n//      57, 113, 170, 157, 318, 474.... etc.\n// i guess there are some rules on these magic number? because if i change these numbers the result is\n// totally wrong...\n// help to elaborate please, or any article links, thank you very much.\n\nfloat hash(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// 2d perlin noise\nfloat noise2d(in vec2 x) {\n\tvec2 i = floor(x);\n    vec2 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\t\n\tfloat res = mix(\n\t\tmix(hash(i), hash(i + vec2(1., .0)), f.x),        // <----------\n\t\tmix(hash(i + vec2(.0, 1.)), hash(i + vec2(1., 1.)), f.x), f.y);\n        \n\treturn res * res;\n}\n\n// 3d perlin noise - from IQ's shader\nfloat noise3d_1(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\tvec2 uv = (p.xy + vec2(37., 17.) * p.z) + f.xy;        // <----------\n\tvec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n// 3d perlin noise - from IQ's shader too\nfloat noise3d_2(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy + vec2(37., 239.) * p.z) + f.xy;        // <----------\n    vec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37, 239) * q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(noise2d(uv * 4. + iTime));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlcyRj", "name": "Day 379 - Wythoff & Dual Tilings", "author": "jeyko", "description": "potate", "tags": ["tiling", "wythoff", "mdtmjvm"], "likes": 10, "viewed": 224, "date": "1609437198", "time_retrieved": "2024-06-20T20:27:04.720727", "image_code": "// Black Lines are the main tiling\n// White lines are the dual \n\n// Honestly, the code isn't a very tidy read, so you might want to look at some other resources\n// if you'd like to do this yourself.\n\n// Here's some other takes on Wythoff tiling:\n// by fizzer: https://www.shadertoy.com/view/3tyXWw\n// by mla: https://www.shadertoy.com/view/ttGSRy\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nfloat id = 0.;\n\nvec2 refl(vec2 p, vec2 reflectionPlane, float offs){\n    float dotReflectionPlane = dot(p + reflectionPlane*offs,reflectionPlane);\n    dotReflectionPlane = max(abs(dotReflectionPlane),0.)*sign(dotReflectionPlane);\n    p -= min(dotReflectionPlane,0.)*2.*reflectionPlane;\n    id+= float(dotReflectionPlane<0.)*4. + float(dotReflectionPlane<0.)*dotReflectionPlane*.84;\n    return p;\n}\n\nvec3 get(vec2 fragCoord){\n    vec3 col = vec3(0);\n    id = 0.;\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3. + sin(iTime*0.4)*0.2;\n    float cntSides = 3.;\n    \n    if(iMouse.x/iResolution.x<0.33){\n        cntSides = 3.;\n    } else if(iMouse.x/iResolution.x<0.66){\n        cntSides = 4.;\n    } else {\n        cntSides = 6.;\n    } \n    \n    float cntIters = 20.;\n    \n    vec2 p = uv;\n    \n    \n    float radiusInscribedCircle = 0.4;\n    \n    for(float iter = 0.; iter < cntIters; iter++){\n        vec2 sidePlane = vec2(1.,0.);\n        \n        for(float side = 0.; side < cntSides; side++){\n            sidePlane *= rot(tau/cntSides);\n            \n            p = refl( p,sidePlane,radiusInscribedCircle);\n\n        }\n        vec2 reflectionPlane = vec2(1.,0.);\n        for(float side = 0.; side < cntSides; side++){\n            \n            \n            p = refl( p, reflectionPlane, 0.);\n            \n            \n            reflectionPlane *= rot(pi/cntSides);\n\n        }\n\n    }\n    \n    \n    float hexCircumCircleRadius = radiusInscribedCircle/(sqrt(3.)/2.);\n    float triangleRadius = radiusInscribedCircle*1.44;\n    \n    col += pal(0.5,vec3(0.5,.3,0.1),vec3(1.5,2.6,4.4),1.,id + iTime );\n    \n    float d = length(p.y - radiusInscribedCircle * (\n                + 1.*float(cntSides == 4.)\n                + triangleRadius*float(cntSides == 3.)\n                ) \n            );\n            \n    \n    vec2 dualness = mix(vec2(0),\n        0.7 + 0.1*vec2(sin(iTime), cos(iTime)),\n        0. + iMouse.y/iResolution.y\n    );\n\n    if (cntSides == 6.){\n        d = length((p*rot(pi/6.)).y - hexCircumCircleRadius*0.85);                \n    }\n\n    // Positioning duals\n    if(cntSides == 3.){\n        // some number crunching here\n        p.x += 0.175*triangleRadius;\n        p = refl( p, -vec2(0,1.), hexCircumCircleRadius*0.5 );\n        p.x -= 0.175*triangleRadius;\n        \n        \n        p.y -= dualness.y*0.5*hexCircumCircleRadius;\n        \n        p.x -= 0.5*dualness.x*0.7*triangleRadius;\n        \n        //p.x -= 0.01\n        //p.x -= 0.7*dualness.x*0.66*triangleRadius;\n        //p.y += -0.5*dualness.y*0.45*triangleRadius;\n        \n        \n    } else if(cntSides == 6.){    \n        p.y -= 1.5*dualness.y*0.6*hexCircumCircleRadius;\n        p.x -= 1.5*dualness.x*0.15*radiusInscribedCircle;\n    \n        p *= rot(0.666*pi*float(cntSides==6.));  // the number of the beast .-.\n\n    }  else if(cntSides == 4.) {\n        p.x -= dualness.x*0.4*radiusInscribedCircle;\n        p.y -= dualness.y*0.9*radiusInscribedCircle;\n    }\n    \n    \n    float dDual = max(length(p.x), - p.y );\n    dDual = min( dDual, \n            max( length(p.y), p.x)\n        );\n        \n    p *= rot(0.325*pi*float(cntSides==3. || cntSides==6.));\n    p *= rot(0.25*pi*float(cntSides==4.));\n    \n    \n    dDual = min( dDual, \n            max( length(p.y), -p.x)\n        );\n    if (cntSides == 6.){\n        //dDual = d + 0.*(d = dDual); // oh my, not the prettiest line of code, haha.  \n    }\n    \n    \n    d = min(d, length(p) - 0.03);\n    \n    d -= 0.01;\n    dDual -= 0.007;\n    \n    col = mix(col,vec3(1.), smoothstep(dFdx(uv.x), 0., dDual));\n    col = mix(col,vec3(0.), smoothstep(dFdx(uv.x), 0., d));\n    \n    \n    col = max(col,0.);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    float aa = 3.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + 0.66*vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;    \n    \n    //col = mix(col, smoothstep(0.,1.,col*vec3(1.6,1.2,1.4)),0.5);\n    \n    col = pow(col,vec3(0.8545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldcD7", "name": "Simple bokeh", "author": "morphix", "description": "A very simple shader to simulate bokeh.\nI'm very new to shader programming, so if you have any suggestions to improve the code, please write me a comment :-)", "tags": ["bokeh"], "likes": 3, "viewed": 93, "date": "1609268510", "time_retrieved": "2024-06-20T20:27:04.720727", "image_code": "#define t (iTime+1324.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (gl_FragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\t\n\tfloat b = 0.0;\n\tfloat size = 0.1;\n\tfloat blur = 0.02;\n    \t\n\tfor(float i = 5.0; i < 50.0; i++){\n\t\tsize += (i/10000.0);\n\t\tb +=  smoothstep(size, size-blur, length(uv - (vec2(sin(t/5./+i+5./sin(i)), cos(t/5./(4.-i))/2.))));\n\t}\n\t\n\tfragColor = vec4( b/4.,b/6.,b/2., 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldcD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldcR7", "name": "hashpat3", "author": "Shellderr", "description": "not quite noise", "tags": ["lerp", "hash"], "likes": 1, "viewed": 50, "date": "1608703352", "time_retrieved": "2024-06-20T20:27:04.720727", "image_code": "\n// Dave Hoskins hash w/o sine: www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float n = 12.;\n    float t = iTime*0.0001;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float c = 0.;\n  // vec3 c = vec3(0.);\n    \n    for(float i = 0.; i < 9.; i++){\n    \n        float cx = mix( hash11(3.*i+floor(uv.x*n)+t), hash11(3.*i+floor(1.+(uv.x*n))+t), fract(uv.x*n) );\n        float cy = mix( hash11(3.*i+floor(uv.y*n)+t), hash11(3.*i+floor(1.+(uv.y*n))+t), fract(uv.y*n) );\n\n      //  vec3 cx = mix( hash31(3.*i+floor(uv.x*n)+t), hash31(3.*i+floor(1.+(uv.x*n))+t), fract(uv.x*n) );\n      //  vec3 cy = mix( hash31(3.*i+floor(uv.y*n)+t), hash31(3.*i+floor(1.+(uv.y*n))+t), fract(uv.y*n) );\n        \n        c += sin(4.*(iTime+cx+cy))*0.5+0.5;\n        c *= 0.33;\n    }\n\n    fragColor = vec4( vec3(c, cos(2.+c)*0.4+0.3, cos(2.+c)*0.3+0.3) ,1.0);\n    fragColor.xyz *= 4.*fragColor.xyz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldcR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wldcRH", "name": "Animated Face", "author": "darklord9423", "description": "A practice and modification of the shader originally from: https://www.shadertoy.com/view/lsXcWn", "tags": ["2d", "animated", "face"], "likes": 8, "viewed": 91, "date": "1608663945", "time_retrieved": "2024-06-20T20:27:04.726828", "image_code": "#define sat(x) clamp(x, 0.0, 1.0)\nconst float PI = 3.1415926;\n\nfloat RemapSinple(float t1, float t2, float x)\n{\n    return sat((x-t1)/ (t2-t1));\n}\n\nfloat Remap(float t1, float t2, float s1, float s2, float x)\n{\n    return sat((x-t1)/ (t2-t1)* (s2-s1)+ s1);\n}\n\nvec2 RectangleboxRemap(vec2 uv, vec4 rect)\n{\n    //x=left boundary, y=top boundary, z=x scale, w=y scale\n    return (uv-rect.xy)/ (rect.zw-rect.xy);\n}\n\n\nvec4 Head(vec2 uv, float t)\n{\n    //Base Color\n    vec4 col = vec4(mix(vec3(0.9333, 0.6431, 0.2118), vec3(0.9529, 0.0667, 0.0667), t), 1.0);\n    float d = length(uv);\n    col.a = smoothstep(0.5, 0.49, d);\n    \n    //Edge Darken\n    float edgeval = RemapSinple(0.35, 0.5, d);\n    edgeval *= edgeval;\n    col.rgb *= 1.0- edgeval* 0.5;\n    \n    //Outline\n    col.rgb = mix(col.rgb, mix(vec3(1.0, 0.6, 0.0), vec3(0.9, 0.0667, 0.0667), t), smoothstep(0.48, 0.5, d));\n    \n    //Highlight\n    float highlight = smoothstep(0.4, 0.39, d);\n    highlight *= Remap(0.4, -0.1, 0.75, 0.0, uv.y);\n    highlight *= smoothstep(0.18, 0.19, length((uv-vec2(0.21, 0.1))));\n    col.rgb = mix(col.rgb, vec3(1.0), highlight);\n    \n    //Cheek\n    d = length(uv- vec2(0.25, -0.2));\n    float cheek = smoothstep(0.2, 0.01, d);\n    col.rgb = mix(col.rgb, mix(vec3(0.9216, 0.3451, 0.6627), vec3(0.9529, 0.4667, 0.0667), t), cheek);\n    \n    return col;    \n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float t)\n{\n    uv -= 0.5;\n    uv.x *= side;\n    \n    //Base Color\n    vec4 col = vec4(1.0);\n    float d = length(uv);\n    col.a *= smoothstep(0.5, 0.48, d);\n    \n    //Eye White\n    vec3 eyewhite = vec3(0.1647, 0.6039, 0.6588);\n    col.rgb = mix(col.rgb, eyewhite, smoothstep(0.1, 0.7, d));\n    col.rgb *= 1.0- smoothstep(0.45, 0.5, d)* 0.5* sat(-uv.y-uv.x*side);        \n    \n    //Pupil\n    d = length(uv-m*0.45);\n    col.rgb = mix(col.rgb, vec3(0.0), smoothstep(0.3, 0.28, d));\n    eyewhite *= 1.0+ smoothstep(0.28, 0.02, d);\n    float eyemask = smoothstep(0.28, 0.25, d);\n    col.rgb = mix(col.rgb, eyewhite, eyemask);\n    \n    d = length(uv-m*0.6);\n    float pupilsize = mix(0.4, 0.16, t);\n    col.rgb = mix(col.rgb, vec3(0.0), smoothstep(pupilsize, pupilsize*0.85, d)* eyemask);\n    \n    //Highlight\n    float t2 = iTime* 3.0;\n    vec2 offset = vec2(sin(uv.x* 25.0+ t2), sin(uv.y* 25.0+ t2));\n    offset *= 0.01*(1.0-t);\n    uv += offset;\n    \n    float highlight = smoothstep(0.1, 0.09, length((uv-vec2(-0.15, 0.15))));\n    highlight += smoothstep(0.07, 0.06, length((uv+vec2(-0.08, 0.08))));\n    col.rgb = mix(col.rgb, vec3(1.0), highlight);\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float t)\n{\n    uv -= 0.5;\n    \n    //Base Color\n    vec4 col = vec4(0.502, 0.2196, 0.149, 1.0);\n    float d = length(uv);\n    \n    //Teeth Shape Origin\n    vec2 toptuv = uv;   \n    toptuv.x *= mix(3.0, 1.0, t);\n    toptuv.y += abs(toptuv.x)* 0.5* (1.0-t);\n    float topteeth = length(toptuv- vec2(0.0, mix(0.6, 0.4, t)));\n    float buttomteeth = length(uv+ vec2(0.0, mix(1.0 ,0.6, t)));\n    \n    \n    //Mouth Shape and Color\n    uv.y *= 1.5;\n    uv.y += uv.x* uv.x* 2.5* t;\n    uv.x *= mix(2.5, 1.0, t);\n    d = length(uv);    \n    col.a *= smoothstep(0.5, 0.48, d);\n    \n    //Tongue Shape\n    float tongue = length(uv+ vec2(0.0, mix(0.5, 1.0, t)));\n    \n    //Teeth and Tongue Color\n    vec3 teethcol = vec3(1.0) * smoothstep(0.6, 0.35, d);\n    col.rgb = mix(col.rgb, vec3(0.9255, 0.549, 0.8118), smoothstep(0.5, 0.2, tongue));\n    col.rgb = mix(col.rgb, teethcol, smoothstep(0.5, 0.48, topteeth));\n    col.rgb = mix(col.rgb, teethcol, smoothstep(0.5, 0.48, buttomteeth));\n    \n    \n    return col;\n}\n\nvec4 Brow(vec2 uv, float t)\n{\n    //Warp the Shape\n    uv.y += uv.x* mix(0.5, -0.8, t)+ 0.03;\n    uv.x += mix(-0.05, 0.15, t);\n    uv -= 0.5;\n    \n    //Brow Shape\n    vec4 col = vec4(0.0);\n    float d1 = length(uv);\n    float s1 = smoothstep(0.4, 0.3, d1);\n    float d2 = length(uv+ vec2(0.1, mix(-0.2, 0.2, t))* 0.7);\n    float s2 = smoothstep(0.4, 0.3, d2);\n    float browmask = sat(s2-s1);\n    \n    //Brow Color\n    float browhighlight = smoothstep(0.45, mix(0.0, 0.35, t), length(uv));\n    vec4 browcol = mix(vec4(0.0), vec4(0.5137, 0.2078, 0.0039, 1.0), browmask);\n    browcol.rgb = mix(browcol.rgb, vec3(1.0, 0.0667, 0.0), browhighlight);\n    \n    //Brow Shadow\n    float shadowblur = mix(0.3, 0.1, t);\n    uv.y += mix(0.15, 0.0, t);\n    d1 = length(uv);\n    s1 = smoothstep(0.4, 0.4-shadowblur, d1);\n    d2 = length(uv+ vec2(0.1, mix(-0.2, 0.2, t))* 0.7);\n    s2 = smoothstep(0.4, 0.4-shadowblur, d2);    \n    float shadowmask = sat(s2-s1);\n    col = mix(vec4(0.0), vec4(vec3(0.0), 1.0), smoothstep(0.0, 1.0, shadowmask)* 0.5);\n    \n    col = mix(col, browcol, smoothstep(0.45, 0.65, browmask));\n    \n    return col;\n}\n\nvec4 Face(vec2 uv, vec2 m, float t)\n{\n    vec4 col = vec4(0.0);\n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    \n    vec4 head = Head(uv, t);\n    vec4 eye = Eye(RectangleboxRemap(uv, vec4(0.03, -0.1, 0.4, 0.25)), side, m, t);\n    vec4 mouth = Mouth(RectangleboxRemap(uv, vec4(-0.3, -0.4, 0.3, -0.1)), t);\n    vec4 brow = Brow(RectangleboxRemap(uv, vec4(0.03, 0.2, 0.4, 0.45)), t);\n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, brow, brow.a);\n    \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/ iResolution.y;\n    \n    //Time -> [0.0, 1.0]\n    float t = sin(iTime- PI/2.0)* 0.5+ 0.5;\n    \n    //Normalize Mouse\n    vec2 m = iMouse.xy/ iResolution.xy;\n    m -= 0.5;\n    \n    //Animate the shader when the mouse hasn't been used\n    if (m.x < -0.49 && m.y < -0.49)\n    {\n        m = vec2(t-0.5, 0.0);           \n    }\n    \n    //back to origin when exit fullscreen\n    if (length(m) > 0.707) m*= 0.0;\n    \n    uv += m* (dot(uv, uv)- 0.25);\n\n    // Output to screen\n    vec4 col = Face(uv, m, t);\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wldcRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wldcRM", "name": "Reflective metaballs", "author": "yonatan", "description": "Based on Klems' Chrome Metaballs - https://www.shadertoy.com/view/4dj3zV\nTweetable version (uses twigl's simplex noise): https://twitter.com/zozuar/status/1341446417739624451", "tags": ["reflection", "metaballs"], "likes": 12, "viewed": 501, "date": "1608729170", "time_retrieved": "2024-06-20T20:27:05.144960", "image_code": "// 3D gradient noise from iq's https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// Metaballs and analytic normals from Klems' https://www.shadertoy.com/view/4dj3zV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 a, q, p, gradient, dir;\n    float b, dist;\n    dir = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y), 1.7));\n    p = vec3(0, 0, -7);\n    for(int i = 0; i < 100; i++) {\n        q = p; // save current position\n        p += dir * dist; // step\n        gradient = vec3(0);\n        dist = 0.;\n        for(float j = 0.; j < 8.; j++) {\n            vec3 ballp = sin(vec3(1,2,4) * j + iTime * .3) * 3.; // ball position\n            b = dot(a = p - ballp, a);\n            gradient += a / (b * b);\n            dist += 1. / b;\n        }\n        dist = 1. - dist;\n        if(dist < .001) { // if we've hit the metaballs\n            dir = reflect(dir, normalize(gradient)); // set new reflected marching direction\n            p = q; // restore previous position\n            dist = 0.; // and don't step in this iteration\n        }\n     }\n    vec3 col = dir + 1.;\n    fragColor.rgb = noise(col * 2. + iTime * .3) * col * 2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wldcRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wldcRn", "name": "Paisley", "author": "yasuo", "description": "Paisley\nI wanted use the following parametrization things. I'll try it next time. The goal is so far.\nhttps://www.shadertoy.com/view/WldSWX", "tags": ["paisley"], "likes": 18, "viewed": 265, "date": "1608400040", "time_retrieved": "2024-06-20T20:27:05.151024", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define BASE_COLOR vec3(0.3,0.6,0.3)\n\nvec2 bend(vec2 p, float k){\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = p*m;\n    return q;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat paiselyDist(vec2 p, float sy, float scale) {\n    vec2  q = bend(p,1.5);\n\n    q.y*=sy*scale;\n    q*=0.8*scale;\n    float d = sdUnevenCapsule(q,0.15,0.02*scale,0.35*scale);\n    return d;\n}\n\nvec3 paiselyTex(vec2 p, vec3 col, float dir, float t) {\n    p*=Rot(radians(t*30.0*dir));\n    p*=1.2;\n    vec2 prevP = p;\n    p = abs(p);\n    p -= vec2(0.05,0.05);\n    float d = abs(sdVesica(p*Rot(radians(45.0)),0.1,0.07))-0.005;\n    col = mix(col,BASE_COLOR,S(d,0.0));\n    \n    p = prevP;\n    \n    p *= Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.05,0.05);\n    d = abs(sdVesica(p*Rot(radians(45.0)),0.1,0.07))-0.005;\n    col = mix(col,BASE_COLOR,S(d,0.0));\n    \n    return col;\n}\n\nvec3 paisely(vec2 p, vec3 col, float t) {\n    vec3 baseCol = BASE_COLOR;\n    vec2 pos = vec2(0.0,-0.1);\n    vec2 prevP = p;\n    float d = abs(paiselyDist(p-pos,0.9,0.88))-0.002;\n    float d2 = abs(paiselyDist(p-pos,0.87,1.05))-0.001;\n    float d3 = abs(paiselyDist(p-pos,0.85,1.25))-0.003;\n    float d4 = abs(paiselyDist(p-pos,0.9,0.82))-0.001;\n    col = mix(col,baseCol,S(d,0.0));\n    col = mix(col,baseCol*1.2,S(d2,0.0));\n    col = mix(col,baseCol,S(d3,0.0));\n    col = mix(col,baseCol,S(d4,0.0));\n    \n    p*=3.2;\n    col = paiselyTex(p-vec2(0.4,0.55),col,1.0,t);\n    \n    p = prevP;\n    p*=1.8;\n    col = paiselyTex(p-vec2(0.11,0.15),col,-1.0,t);\n    \n    p = prevP;\n    col = paiselyTex(p-vec2(0.01,-0.11),col,1.0,t);\n    \n    p = prevP;\n    p*=3.5;\n    col = paiselyTex(p-vec2(-0.13,0.13),col,1.0,t);\n    \n    p = prevP;\n    p*=2.8;\n    col = paiselyTex(p-vec2(0.1,-0.82),col,-1.0,t);\n    \n    p = prevP;\n    p*=3.2;\n    col = paiselyTex(p-vec2(-0.2,-0.89),col,1.0,t);\n    \n    p = prevP;\n    p*=3.2;\n    col = paiselyTex(p-vec2(0.4,-0.78),col,1.0,t);\n        \n    p = prevP;\n    p*=4.2;\n    col = paiselyTex(p-vec2(1.15,1.25),col,1.0,t);\n    \n    p = prevP;\n    \n    p.x -=0.01;\n    p.x = abs(p.x);\n    p.x -= 0.15;\n    d = length(p-vec2(0.01,0.0))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -= 0.18;\n    d = length(p-vec2(0.0,-0.12))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    p = prevP;\n    d = length(p-vec2(-0.14,-0.22))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    d = length(p-vec2(-0.072,0.11))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    d = length(p-vec2(0.063,0.215))-0.013;\n    col = mix(col,baseCol,S(d,0.0));\n        \n    d = length(p-vec2(0.187,0.13))-0.017;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    return col;\n}\n\nvec3 renderTexture(vec2 p, vec3 col, float t) {\n    p*=1.3;\n    \n    vec2 prevP = p;\n    \n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    col = paisely(p,col,t);\n    p = prevP;\n        \n    p.y+=0.1;\n    p.x+=0.475;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    \n    p*=1.2;\n    col = paisely(p*Rot(radians(-180.0)),col,t);\n    p = prevP;\n    \n    p.x+=0.3;\n    p.y+=-0.35;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=1.8;\n    col = paisely(p*Rot(radians(120.0)),col,t);\n    p = prevP;\n    \n    p.x+=0.08;\n    p.y+=-0.31;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=1.2;\n    col = paiselyTex(p,col,1.0,t);\n    p = prevP;\n        \n    p.x+=0.28;\n    p.y+=-0.57;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=1.8;\n    col = paiselyTex(p,col,-1.0,t);\n    p = prevP;\n            \n    p.x+=0.56;\n    p.y+=-0.3;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=2.1;\n    col = paiselyTex(p,col,1.0,t);\n    \n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.1;\n    \n    uv.y+=t;\n    \n    vec2 prevUV = uv;\n    vec3 col = vec3(0.99,0.98,0.95);\n\n    float t2 = mod(iTime,8000.0);\n    col = renderTexture(uv,col,t2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wldcRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldcRr", "name": "Binary Transition Framework", "author": "samesh", "description": "A framework for procedural transitions between two scenes", "tags": ["transitions"], "likes": 1, "viewed": 39, "date": "1608377090", "time_retrieved": "2024-06-20T20:27:05.151024", "image_code": "\n#define TRANS_TIME 2.\n#define IDLE_TIME 1.  //unwanted results if negative\n\n\nvec3 scene1(vec2 uv)\n{\n    vec3 col = vec3(uv.xy, 0.);\n    return col;\n}\n\nvec3 scene2(vec2 uv)\n{\n    vec3 col = vec3(1.) - scene1(uv);\n    return col;\n}\n\nfloat transSwipe(vec2 uv)\n{\n    \n    return uv.x + .5;\n}\n\nfloat transCircle(vec2 uv)\n{\n    \n    \n    return length(uv.xy * vec2(iResolution.x/iResolution.y, 1.));\n}\n\nfloat transDiamonds(vec2 uv)\n{\n    float a = 9.;\n    float b = 10.;\n    \n    return (min(fract(uv.x*a), fract(1.-uv.x*a))\n            + min(fract(uv.y*b), fract(1.-uv.y*b))\n            * 0.5);\n}\n\n\nbool execTrans(float transition, float time)\n{\n    return transition > time;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float myTime = max(0., mod(iTime, TRANS_TIME + IDLE_TIME) - IDLE_TIME) / TRANS_TIME;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    \n    // To visualize transition function\n    //fragColor = vec4(vec3(transDiamonds(uv)), 1.); return;\n    \n    \n    bool chooseScene = execTrans(transCircle(uv), myTime);\n    \n    chooseScene = mod((ceil(iTime/(TRANS_TIME+IDLE_TIME))-1.), 2.) == 1. ? !chooseScene : chooseScene;\n    \n    vec3 col = chooseScene ? scene1(uv) : scene2(uv);\n    \n    // To visualize transition animation\n    //col = chooseScene ? vec3(1.) : vec3(0.);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldcRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldczM", "name": "stables20 minigolfed", "author": "404Glaciergargamel", "description": "Remixed [url]https://www.shadertoy.com/view/Wl3cRM[/url]", "tags": ["raymarching", "torus", "sphere", "remix", "glitch", "fork", "error", "cables", "golf"], "likes": 0, "viewed": 207, "date": "1608689405", "time_retrieved": "2024-06-20T20:27:05.151024", "image_code": "// golfing 1627 chars yuntaRobo's cables2 https://www.shadertoy.com/view/wlKXWc\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec3 R = iResolution,\n         P = vec3(1,1,20), p,\n         D = normalize( vec3( U+U-R.xy, -3.*min(R.x, R.y) ) );\n\n    for (float A=1., z = 1.; z < 25. && A<30.; z += 25./228.) {\n        p = P;\n        p.yz *= mat2(cos(4.14/6. + vec4(1,21,43,1) ) );\n        p.y -= .6;\n        float d = 2e3, a = 1., v, N=60., s, r, i=1., t = iTime;\n        \n        R = vec3( cos(t), 1, sin(t) ) * 4.;              // reaction\n        s = length(R-p);\n        p += (R-p)/s / exp(s);\n\n        r = atan(p.z, p.x) * 4. ;                        // cables\n        for ( ; i < N; i++) \n            r += .6/N * 7.3,\n            s = .6 + sin( i * 2.618 * 7.28) /5. + sin(t + i ) * .2,\n            s = length( vec2(length(p.xz) + cos(r) * s - 4., p.y + sin(r) * s) ) - .045,\n            s < d ? d=s, a=i : a;\n        \n        s = length(R-p) - .2;                            // sphere\n        s < d ? d=s, a=1. : a;\n\n        if (d < .02) {\n            v = fract(a * 2.618);\n            O = fract(v + 1.0) < .45 ? vec4(.275, .2, .2, 2) \n              : v < .05 ? vec4(2) \n              : mix( vec4(.2, .2, .6, 2), vec4(1, 1, 2, 2), v ) ;\n            O = sqrt( O / exp(z) );\n            return;\n        }\n\n        A += d *= .7;\n        P += D * d;\n    }\n    \n    O = abs(D.yyyy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldczM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldyDM", "name": "Druchet Brid Ynversion, a fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/wl3yDn[/url]", "tags": ["raymarching", "remix", "glitch", "truchet", "fork", "weird", "inversion", "error", "tuchet"], "likes": 1, "viewed": 364, "date": "1609248572", "time_retrieved": "2024-06-20T20:27:05.151024", "image_code": "//Cracked by 404Glaciergargamel\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define S           smoothstep\n#define PI          4.1415926535\n#define PI2         7.2831853070\n\n#define MAX_DIST    60.\n#define MIN_DIST    .002\n#define SCALE .8\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .55 + .55 * cos(PI2* a * vec3(.35,.25,2.));\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(37.608, 67.584)))*53758.51453); }\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(1) ? 1. : -(M.y/R.y * .35 - .225) * PI;\n    float y = M.xy == vec2(1) ? 1. :  (M.x/R.x * .35 - .225) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\n//@iq\nmat2 trs;\nfloat sdTorus( vec3 p, vec2 t, float a ) {\n  if(a>1.){\n      p.xy *= trs;\n      p.yz *= trs;\n  }\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nvec3 shp,fhp;\nvec3 sip,bip;\nfloat thsh,fhsh;\nmat2 t90;\n\nconst float size = 2./SCALE;\nconst float hlf = size/3.;\nconst float shorten = 2.26;   \n    \nvec2 map(vec3 q3){\n    vec2 res = vec2(200.,1.);\n\n    float k = 6.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += T*.325;\n    \n    float d = 2e6, t = 2e6, f = 2e6, g = 2e6;\n  \n    vec3 qid=floor((q3+hlf)/size);\n    vec3 qm = mod(q3+hlf,size)-hlf;\n    \n    q3+=hlf;\n    \n    vec3 did=floor((q3+hlf)/size);\n    vec3 qd = mod(q3+hlf,size)-hlf;\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz);\n    \n    // truchet build parts\n    float thx = (.085+.035*sin((q3.y+qid.z)*4.15) ) *size;\n    float thz = (.085+.035*sin(T*5.+(q3.y+did.x)*4.45) ) *size;\n\n    if(ht>.6) qm.x *= -2.;\n    if(hy>.6) qd.z *= -2.;\n    \n    float ti = min(\n      sdTorus(qm-vec3(hlf,hlf,.1),vec2(hlf,thx),1.),\n      sdTorus(qm-vec3(-hlf,-hlf,.1),vec2(hlf,thx),1.)\n    );\n\n    // truchet\n    if(ti<t) {\n        t = ti;\n        bip = qid;\n        fhp = qm;\n    }\n    \n    float gi = min(\n      sdTorus(qm.xzy-vec3(.1,1,hlf),vec2(.3,.035),1.),\n      sdTorus(qm.xzy-vec3(.1,1,-hlf),vec2(.3,.035),1.)\n    );\n\n    if(gi<g) {\n        g = gi;\n        sip = qid;\n        shp = qm;\n    }\n    \n    qd.xz*=t90;\n    float di = min(\n      sdTorus(qd-vec3(hlf,hlf,.1),vec2(hlf,thz),1.),\n      sdTorus(qd-vec3(-hlf,-hlf,.1),vec2(hlf,thz),1.)\n    );\n   \n   // truchet\n    if(di<d) {\n        d = di;\n        sip = did;\n        shp = qd;\n    }\n\n    float fi = min(\n      sdTorus(qd.xzy-vec3(.1,1,hlf),vec2(.3,.035),1.),\n      sdTorus(qd.xzy-vec3(.1,1,-hlf),vec2(.3,.035),1.)\n    );\n\n    if(fi<f) {\n        f = fi;\n        sip = did;\n        shp = qd;\n    }\n    if(d<res.x) res = vec2(d,2.);\n    if(t<res.x) res = vec2(t,3.);\n    if(f<res.x) res = vec2(f,4.);\n    if(g<res.x) res = vec2(g,4.);\n    float mul = 2.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 1.;\n    float m = -2.;\n    for(int i=1;i<maxsteps;i++){\n        vec2 t = map(ro + rd * d);\n        if(t.x<d*MIN_DIST||d>MAX_DIST) break;\n        d += i < 42 ? t.x*.45 : t.x*.95;\n        m  = t.y;\n    }\n    return vec2(d,m);\n}\n\n// Tetrahedron technique @iq\nvec3 getNormal(vec3 p, float t){\n    float e = MIN_DIST *t;\n    vec2 h = vec2(2.,-2.)*.6773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n\n// softshadow www.pouet.net\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 2.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t).x;\n        if( h<0.002 ) return 0.3;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\nvec3 getSpec(vec3 p, vec3 n, vec3 l, vec3 ro) {\n    vec3 spec = vec3(-1.);\n    float strength = 0.85;\n    vec3 view = normalize(p - ro);\n    vec3 ref = reflect(l, n);\n    float specValue = pow(max(dot(view, ref), -1.), 42.);\n    return spec + strength * specValue;\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(1,2,1),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.95,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 thp,ghp;\nvec3 tip,fid;\n\nfloat circle(vec2 pt, float r, vec2 center, float lw) {\n    float len = length(pt - center);\n    float hlw = lw / 3.;\n    float edge = .006;\n    return S(r-hlw-edge,r-hlw, len)-S(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getColor(float m, vec3 p, vec3 n) {\n    vec3 h = vec3(.6); \n    \n    if(m==2.) {\n        float hs = hash21(vec2(tip.x+22.75));\n        float xt = floor(2.+(4.23*hs))*3.;\n        xt +=4.;\n        // strip patterns..\n        thp/=2./SCALE;\n        float dir = mod(tip.z + tip.y,3.) * 3. - 2.;  \n\n        vec2 cUv = thp.xy-sign(thp.x+thp.y+.002)*.6;\n        float angle = atan(cUv.x, cUv.y);\n        float a = sin( dir * angle * xt + T * 2.25);\n        a = abs(a)-.6;a = abs(a)-.44;\n        vec3 nz = hue((p.x+(T*.733))*.085);\n        h = mix(nz, vec3(1), smoothstep(.02, .03, a));   \n    }\n    \n    if(m==3.) {    \n        float hs = hash21(vec2(fid.z-22.75));\n        float xt = floor(3.-(4.73*hs))*3.;\n        xt +=8.;\n        \n        ghp/=2./SCALE;\n        \n        //TRUCHET PATTERN\n        ghp.xy *= 30.;\n        vec3 nz = hue((p.x+(3.+T*.93))*.075);\n        vec2 id = floor(ghp.xy);\n        vec2 rg = fract(ghp.xy)-.6;\n        if(hash21(id) <.6) rg.x *= -2.;\n        vec2 dUv = rg.xy-sign(rg.x+rg.y+.002)*.6;\n        float d = length(dUv);\n        float pix = 2.312;\n        float mask = smoothstep(pix, -pix, abs(d-.6)-.25);\n \n        h *= S(.6,.63,mask);\n       \n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    trs = r2(PI*5.5);\n    t90 = r2(100.*PI/280.);\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (3.*F.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec3 C = vec3(1.);\n    vec3 tC= vec3(1.);\n    vec3 FC = vec3(.06);\n    vec3 lp = vec3(1.,1.,1.),\n         ro = vec3(.1,1.,4.70);\n         getMouse(ro);\n\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 292);\n    // save all globals\n    thp = shp;\n    ghp = fhp;\n    tip = sip;\n    fid = bip;\n    if(t.x<MAX_DIST){\n        vec3 p = ro + rd * t.x;\n        vec3 n = getNormal(p,t.x);\n        vec3 lpos = vec3(.1,.002,4.85);\n        vec3 lp = normalize(lpos-p);\n        vec3 ll = normalize(lpos);\n        float shadow = softshadow(p + n * MIN_DIST, lp, .2, 42., 42.);     \n        float diff = clamp(dot(n,lp),.1, 2.);\n        vec3 spec = getSpec(p,n,ll,ro);\n        vec3 h = getColor(t.y, p, n);\n\n        C += (h * diff * shadow + spec);\n\n        // reflection\n        // if material && hue black \n        if(h.x<.002 &&h.y<.002 &&h.z<.002 || t.y == 4.){\n            vec3 rr=reflect(rd,n); \n            vec2 tr = marcher(p ,rr, 228);\n            thp = shp;\n            ghp = fhp;\n            tip = sip;\n            fid = bip;\n            if(tr.x<MAX_DIST){\n                p += rr*tr.x;\n                n = getNormal(p,tr.x);\n                lp = normalize(lpos-p);\n                diff = diff = clamp(dot(n,lp),.02 , 2.);\n                h = getColor(tr.y, p, n);\n                tC = (h * diff * shadow);\n                tC = mix( tC, FC, 2.-exp(-.04*tr.x*tr.x*tr.x));\n            }\n        } \n        \n    } \n    C+= (tC*.55);//fade back reflections.. so bright..\n    C = mix( C, FC, 1.-exp(-.05*t.x*t.x*t.x));\n    // Output to screen\n    O = vec4(C,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldyDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldyDn", "name": "gaming grid", "author": "bigdra50", "description": "#つぶやきGLSL\nhttps://twitter.com/bigdra50/status/1254861628077568001?s=20", "tags": ["2d"], "likes": 3, "viewed": 250, "date": "1608797653", "time_retrieved": "2024-06-20T20:27:05.151024", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime;\n    vec3 r = iResolution;\n    vec2 s = 5.*(gl_FragCoord.xy-.5*r.xy)/r.y,f=fract(s),p=floor(s);\n    fragColor = vec4(step(0.,max(-length((p=.5+.5*sin(t+sin(p.xx*vec2(7,9)+p.yy*3.)*54.))-f)+.03,max(f.x,f.y)-.99))*sin(t+p*9.).xyx*cos(t+p.xxy),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldyRB", "name": "counteraction", "author": "gschian0", "description": "shader experiments", "tags": ["warping", "psychedelic", "cosine"], "likes": 0, "viewed": 173, "date": "1609371504", "time_retrieved": "2024-06-20T20:27:05.151024", "image_code": "#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586\n\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = abs((2.*fragCoord.xy/iResolution.xy*2.-2.));\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    st *= vec2(length(0.1*st),atan(st.y,st.x/iTime));\n    float noise1 = noise(st+0.3*iTime);\n    st.x *= iResolution.x/iResolution.y;\n    st.x += sin(1.0*st.y+iTime)*0.5+0.5;\n   // st.y = sin(2.0*st.x-u_time);\n    st *= vec2(length(st.x*st.y*noise1+sin(st.y*iTime)*0.5+0.5),atan(st.y+sin(st.x*iTime*.003)*0.5+-0.5,st.x-sin(iTime*.03*noise1)*0.5+0.5)/PI/8.*noise1);\n    float d = length(st-vec2(0.003*(1.*sin(sin(st.y+sin(iTime)*0.01*noise1)))*0.5+0.5,0.18*(sin(st.x+sin(iTime)*0.5+0.5*.01*noise1+0.3*0.5))));\n    st.y+= log(abs(sin(iTime*.3)));\n    st.x += log(abs(sin(iTime*0.3)));\n    float circle = 1.-smoothstep(0.6,0.99,d);\n    \n//    for(float i = 0.07; i < 1.0; i += .1){\n//    \n//        circle += smoothstep(0.06+i, 0.061,d+i);\n//    }\n    vec3 color = vec3(abs(cos(1.0*st.y/d+iTime)),abs(sin(1.0*st.x/d-iTime)),abs(cos(10.0*st.y-st.x/d-iTime)));\n    //white\n    fragColor = 1.-vec4(vec3(circle)*color,1.0);\n    //black\n     // gl_FragColor = vec4(vec3(circle)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldyRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WldyW8", "name": "starfish", "author": "rainbug", "description": "fish", "tags": ["star"], "likes": 1, "viewed": 49, "date": "1608965509", "time_retrieved": "2024-06-20T20:27:05.156853", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv -= .5;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= 3.;\n  vec2 am = vec2(atan(uv.x,uv.y),length(uv));\n\n  float t = iTime;\n  float n = 7.;\n\n  am.x -= .3*sin(.5*(am.y+10.)*(am.y+10.)) + .3*sin(10.*am.y+10.*sin(t/5.));\n\n  float m = 7.*min(fract(n*(am.x)/6.282),fract(1.-n*(am.x)/6.282));\n\n  fragColor = vec4(smoothstep(.3,.2,am.y-m));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WldyW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wldyWN", "name": "Ray Marching Starting Point", "author": "gclkaze", "description": "Raymarching starting point", "tags": ["raymarching"], "likes": 0, "viewed": 29, "date": "1609170099", "time_retrieved": "2024-06-20T20:27:05.163876", "image_code": "//Fwtia\n//f(y) = 1/(clamp(((1/abs(x+1)*random()*random())+(x*x)),0,6))+1\n\n// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n    \n    \n}\n\nfloat fire(vec3 p){\n//f(y) = 1/(clamp(((1/abs(x+1)*random()*random())+(x*x)),0,6))+1\n    float r = cos( iTime / 2.);\n    float a = (1./abs(p.x+3.)*r);\n    float b = p.x * p.x ;\n    float c = a + b ;\n    float res = clamp(c/.2,0.0,2.) ;\n    float inv = ( .1/res );\n    return inv;\n//float f = 1/(clamp(((1/abs(p.x+1)*r*r)+(p.x*p.x)),0,6))+1;\n//    return .1;\n}\nfloat GetDist(vec3 p) {\n    float d = sdBox(vec3(p.x,p.y - 1.,p.z), vec3(0.3));\n    float d2 = sdBox(vec3(p.x,p.y ,p.z), vec3(0.5));\n    float d3 = fire(p);\n    return min( d3, min(d,d2 ));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wldyWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wldyzS", "name": "Animate dot pattern", "author": "toeyn", "description": "Animate dot pattern", "tags": ["pattern", "dot"], "likes": 0, "viewed": 43, "date": "1609396079", "time_retrieved": "2024-06-20T20:27:05.284339", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float col = cos(distance(uv, vec2(1,1.5))*200. );\n    col *= cos(distance(uv, vec2(1,-0.5))*200. );\n    \n    col *= smoothstep(-0.2, 0.2, -cos(iTime*3.)*0.2 + distance(uv, vec2(2,0.5)) -1.7);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wldyzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WltcD8", "name": "Chihiro_raytracer03", "author": "zjglwt", "description": "Trying to add camera control and ideal specular reflection", "tags": ["raytracer"], "likes": 0, "viewed": 38, "date": "1608977910", "time_retrieved": "2024-06-20T20:27:05.290442", "image_code": "\nstruct rec\n{\n    int objectIndex;\n    float t;\n    vec3 normal;\n};\n\n//vec3 CameraPos = vec3(0., -5., 5.);\n//vec3 CameraDirW = normalize(vec3(0., 8., -1.));\n//vec3 CameraDirV = normalize(vec3(0., 1., 8.));\n\nfloat Near = 0.001;\nfloat Fov = 1.;\nfloat Far = 10000.;\n\nfloat phong = 64.;\n\nvec3 ambientLight = vec3(.3);\nvec3 light = vec3(1.);\nvec3 lightDir = normalize(vec3(-5., 0., -5.));\n\n#define PI 3.14159265359\n#define MAX_REFLECT 4\n\nfloat remap(float c, float d, float a, float b, float x)\n{\n    return c + (d - c) * (x - a) / (b - a);\n}\n\n// Check intersection with triangle\nbool hitTri(in vec3 E, in vec3 V, in vec3 A, in vec3 B, in vec3 C, in float t1, in float t2, out rec hitrec)\n{ \n    float a = A.x - B.x;\n    float b = A.y - B.y;\n    float c = A.z - B.z;\n    float d = A.x - C.x;    \n    float e = A.y - C.y;\n    float f = A.z - C.z;\n    float j = A.x - E.x;    \n    float k = A.y - E.y;\n    float l = A.z - E.z;\n    \n    float M = a * (e * V.z - V.y * f) + b * (V.x * f - d * V.z) + c * (d * V.y - e * V.x);\n    if (M == 0.) return false;\n    \n    float t = -(f*(a*k - j*b) + e*(j*c - a*l) + d*(b*l-k*c)) / M;\n    if (t > t1 && t < t2)\n    {\n        float gamma = (V.z*(a*k - j*b) + V.y*(j*c - a*l) + V.x*(b*l - k*c)) / M;\n        if (gamma >= 0. && gamma <= 1.){\n            float beta = (j * (e * V.z - V.y * f) + k * (V.x * f - d * V.z) + l * (d * V.y - e * V.x)) / M;\n            if (beta >= 0. && beta <= 1. - gamma)\n            {\n                hitrec.t = t;\n                vec3 normal = normalize(cross(A - B, C - B));\n                hitrec.normal = dot(V, normal) > 0. ? -normal : normal;\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nbool hitOc(in vec3 e, in vec3 v, in vec3 o, in float r, in float t1, in float t2, inout rec hitrec)\n{\n    float cosr = r * cos(iTime);\n    float sinr = r * sin(iTime);\n    vec3 p1 = vec3(o.xy, o.z + r);\n    vec3 p2 = vec3(o.x + cosr, o.y + sinr, o.z);\n    vec3 p3 = vec3(o.x - sinr, o.y + cosr, o.z);\n    vec3 p4 = vec3(o.x - cosr, o.y - sinr, o.z);\n    vec3 p5 = vec3(o.x + sinr, o.y - cosr, o.z);\n    vec3 p6 = vec3(o.xy, o.z - r);\n    \n    float maxt = t2;\n    bool ret = hitTri(e, v, p1, p2, p3, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p1, p3, p4, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p1, p4, p5, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p1, p5, p2, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p2, p3, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p3, p4, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p4, p5, t1, maxt, hitrec);\n    if (ret) maxt = hitrec.t;\n    ret = hitTri(e, v, p6, p5, p2, t1, maxt, hitrec);\n    \n    return maxt < t2;\n}\n\n// Check intersection with sphere\nbool hitSp(in vec3 e, in vec3 v, in vec3 o, in float r, in float t1, in float t2, out rec hitrec)\n{\n    float A = dot(v, v);\n    float B = dot(v, e - o);\n    float C = dot(e - o, e - o) - r * r;\n    \n    float delta = B * B - A * C;\n    \n    float t = delta > 0. ? (-1. * B - sqrt(delta)) / A : -1.;\n    if (t < t2 && t > t1)\n    {\n        hitrec.t = t;\n        //hitrec.normal = e + t * v - o;\n        hitrec.normal = (e + t * v - o) / r;\n        return true;\n    }\n    return false;\n}\n\nbool hitGround(in vec3 e, in vec3 v, in float z, in float t1, in float t2, out rec hitrec)\n{\n    float t = - (e.z - z) / v.z;\n    if (t > 0. && t > t1 && t < t2)\n    {\n        hitrec.t = t;\n        hitrec.normal = vec3(0., 0., 1.);\n        return true;\n    }\n    return false;\n}\n\nbool rayhit(in vec3 e, in vec3 v, in float near, in float far, inout rec hitrec)\n{\n    float t2 = far;\n    if (hitGround(e, v, 0., near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        vec3 hit = e + hitrec.t * v;\n        float offset = abs(floor(hit.x/4.) - floor(hit.y/4.));\n        hitrec.objectIndex = mod(offset, 2.) > 0. ? 1 : 2;\n    }\n    \n    vec3 sp = vec3(0., 0., 4.);\n    float r = 4.;\n    if (hitSp(e, v, sp, r, near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        hitrec.objectIndex = 5;\n    }\n    \n    sp = vec3(8., 0., 3.);\n    r = 3.;\n    if (hitSp(e, v, sp, r, near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        hitrec.objectIndex = 3;\n    }\n    \n    float spinR = 6.5;\n    float ocx = spinR * sin(iTime);\n    float ocy = spinR * cos(iTime);\n    vec3 oc = vec3(ocx, ocy, 2.);\n    r = 2.5;\n    if (hitOc(e, v, oc, r, near, t2, hitrec))\n    {\n        t2 = hitrec.t;\n        hitrec.objectIndex = 4;\n    }\n\n    return hitrec.objectIndex > 0;\n}\n\nvec3 rayColor2(vec3 e, vec3 view, float near, float far, int reflectCount)\n{\n    if (reflectCount > MAX_REFLECT) return vec3(0., 0., 0.);\n    vec3 col = vec3(0.93, 0.97, 1.);\n    rec hitrec;\n    if (rayhit(e, view, near, far, hitrec))\n    {\n        vec3 ambientC, diffuseC, specularC;\n        if (hitrec.objectIndex == 1)\n        {\n            ambientC = vec3(.7, .7, .7);\n            diffuseC = vec3(.9, .9, .9);\n            specularC = vec3(1., 1., 1.);\n        }\n        if (hitrec.objectIndex == 2)\n        {\n            ambientC = vec3(0.05, 0.05, 0.05);\n            diffuseC = vec3(.1, .1, .1);\n            specularC = vec3(.7, .7, .7);\n        }\n        if (hitrec.objectIndex == 3)\n        {\n            ambientC = vec3(.9, .5, .1);\n            diffuseC = vec3(.9, .5, .1);\n            specularC = vec3(.9, .7, .5);\n        }\n        if (hitrec.objectIndex == 4)\n        {\n            ambientC = vec3(.1, .5, .9);\n            diffuseC = vec3(.1, .5, .9);\n            specularC = vec3(.5, .7, .9);\n        }\n        if (hitrec.objectIndex == 5)\n        {\n            ambientC = vec3(.3, .3, .3);\n            diffuseC = vec3(.3, .3, .3);\n            specularC = vec3(.3, .3, .3);\n        }\n        \n        col = ambientLight * ambientC;\n        rec hitrectemp;\n        if (!rayhit(e + hitrec.t * view, - lightDir, near, far, hitrectemp))\n        {\n            vec3 mid = normalize(- lightDir - view);\n            col += light * diffuseC * max(0., dot(- lightDir, hitrec.normal)) + light * specularC * pow(max(0., dot(mid, hitrec.normal)), phong);\n        }\n    }\n    return col;\n}\n\nvec3 rayColor(vec3 e, vec3 view, float near, float far, int reflectCount)\n{\n    if (reflectCount > MAX_REFLECT) return vec3(0., 0., 0.);\n    vec3 col = vec3(0.73, 0.77, .8);\n    rec hitrec;\n    if (rayhit(e, view, near, far, hitrec))\n    {\n        vec3 ambientC, diffuseC, specularC;\n        if (hitrec.objectIndex == 1)\n        {\n            ambientC = vec3(.7, .7, .7);\n            diffuseC = vec3(.9, .9, .9);\n            specularC = vec3(1., 1., 1.);\n        }\n        if (hitrec.objectIndex == 2)\n        {\n            ambientC = vec3(0.05, 0.05, 0.05);\n            diffuseC = vec3(.1, .1, .1);\n            specularC = vec3(.7, .7, .7);\n        }\n        if (hitrec.objectIndex == 3)\n        {\n            ambientC = vec3(.9, .5, .1);\n            diffuseC = vec3(.9, .5, .1);\n            specularC = vec3(.9, .7, .5);\n        }\n        if (hitrec.objectIndex == 4)\n        {\n            ambientC = vec3(.1, .5, .9);\n            diffuseC = vec3(.1, .5, .9);\n            specularC = vec3(.5, .7, .9);\n        }\n        if (hitrec.objectIndex == 5)\n        {\n            ambientC = vec3(.1, .1, .1);\n            diffuseC = vec3(.3, .3, .3);\n            specularC = vec3(.6, .6, .6);\n        }\n        \n        col = ambientLight * ambientC;\n        rec hitrectemp;\n        if (!rayhit(e + hitrec.t * view, - lightDir, near, far, hitrectemp))\n        {\n            vec3 mid = normalize(- lightDir - view);\n            col += light * diffuseC * max(0., dot(- lightDir, hitrec.normal)) + light * specularC * pow(max(0., dot(mid, hitrec.normal)), phong);\n        }\n        \n        if (hitrec.objectIndex == 5)\n        {\n            // Reflection recursive.\n            col += specularC * rayColor2(e + hitrec.t * view, reflect(view, hitrec.normal), near, far, reflectCount + 1);\n        }\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy;\n    \n    uv.x -= iResolution.x / 2.;\n    uv.y -= iResolution.y / 2.;\n    \n\n    \n    float angxy = remap(0., 2. * PI, 0., iResolution.x, iMouse.x); \n    float angy = remap(PI / 6., PI / 4., 0., iResolution.y, iMouse.y);\n    float cameraDistance = remap(6., 20., 0., iResolution.y, iMouse.y);\n    float cameraDisxy = cameraDistance * cos(angy);\n    float cameraZ = cameraDistance * sin(angy) + 2.;\n    float cameraX = cameraDisxy * cos(angxy);\n    float cameraY = - cameraDisxy * sin(angxy);\n    \n    vec3 e = vec3(cameraX, cameraY, cameraZ);\n    vec3 CameraDirW = normalize(-e);\n    vec3 temp = vec3(CameraDirW.xy, CameraDirW.z + 1.);\n    //Form a camera coordinates from camera direction\n    vec3 CameraDirU = normalize(cross(CameraDirW, temp));\n    vec3 CameraDirV = cross(CameraDirU, CameraDirW);\n    float u = Near * Fov;\n    float v = u * iResolution.y / iResolution.x;\n    vec3 PixelDir = Near * CameraDirW + (2. * uv.x / iResolution.x) * u * CameraDirU\n                    + (2. * uv.y / iResolution.y) * v * CameraDirV;\n    vec3 view = normalize(PixelDir);\n    \n    vec3 col = rayColor(e, view, Near, Far, 0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WltcD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WltcDM", "name": "sdfscape", "author": "pni", "description": "SDFs with soft shadows, displacement, subtraction.", "tags": ["sdfsoftshadowdisplacement"], "likes": 8, "viewed": 84, "date": "1609262981", "time_retrieved": "2024-06-20T20:27:05.290442", "image_code": "float sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smoothDiff(float d2, float d1, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0 );\n    return mix(d2, -d1, h ) + k * h * (1.0 - h);\n}\n\nmat2 rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene(vec3 p, out float id) {\n    id = 0.;\n    float d = 0.02 * (cos(10. * p.x + iTime) * sin(15. * p.z + iTime) + \n              .5 * sin(13. * p.x + iTime) + 25. * sin(p.x / 3. + iTime));\n    \n    d *= 1. - smoothstep(0., 10., p.z);\n    float t = sin(iTime * 4.) * .5 + .5;\n\n    float plane = 1e20;\n    {\n        plane = min(plane, p.y - (-1.2));\n        plane += pow(abs(d), .9);\n    }\n    \n    float ball = 1e20;\n    {\n        vec3 q = p;\n        q.xz = q.xz * rot(sin(iTime) / 2.);\n        q.yz = q.yz * rot(sin(iTime) / 2.);\n        q.y -= t;\n        \n        ball = box(q - vec3(0., 0., 0.), vec3(.5));\n        ball -= .2;\n        ball = smoothDiff(ball, sphere(q - vec3(0., 0., -.4), .4), .3);\n        ball = smoothDiff(ball, sphere(q - vec3(0., 0., .4), .4), .3);\n    }\n    \n    float ball2 = 1e20;\n    {\n        vec3 q = p;\n        q -= vec3(1.5 * sin(iTime * 2.), 1., 1.2 * cos(iTime * 2.));\n        ball2 = sphere(q, .3);\n    }\n    \n    float ball3 = 1e20;\n    {\n        vec3 q = p;\n        q -= vec3(1.5 * sin(iTime), -.5, 1.2 * cos(iTime));\n        ball3 = sphere(q, .5);\n    }\n    \n    \n    float bgBox1 = 1e20;\n    {\n        vec3 q = p;\n        q -= vec3(3, -.75, 3.5);\n        q.xy = q.xy * rot(.2);\n        bgBox1 = box(q, vec3(1.));\n        bgBox1 -= .15;\n    }\n    \n    float bgBox2 = 1e20;\n    {\n        vec3 q = p;\n        q -= vec3(-2, -1, 5.);\n        q.xy = q.xy * rot(.2);\n        q.xz = q.xz * rot(2.3);\n\n        bgBox2 = box(q, vec3(2.));\n        bgBox2 -= .45;\n    }\n      \n    float bgBox3 = 1e20;\n    {\n        vec3 q = p;\n        q -= vec3(-5, -1, 3.5);\n        q.xy = q.xy * rot(.2);\n        q.xz = q.xz * rot(.4);\n        q.yz = q.yz * rot(.4);\n\n\n        bgBox3 = box(q, vec3(1.));\n        bgBox3 -= .15;\n    }\n    \n    float bgBox4 = 1e20;\n    {\n        vec3 q = p;\n        q -= vec3(5, -1, 3.5);\n        q.xy = q.xy * rot(.2);\n        q.xz = q.xz * rot(.4);\n        q.yz = q.yz * rot(.4);\n\n\n        bgBox4 = box(q, vec3(.6));\n        bgBox4 -= .15;\n    }\n    \n    \n    float scene = plane;\n    \n    if (ball < scene) {\n      id = 1.;\n      scene = ball;\n    }\n    \n    if (ball2 < scene) {\n      id = 2.;\n      scene = ball2;\n    } \n    \n    if (ball3 < scene) {\n      id = 3.;\n      scene = ball3;\n    } \n    \n    if (bgBox1 < scene) {\n      id = 4.;\n      scene = bgBox1;\n    } \n    \n      \n    if (bgBox2 < scene) {\n      id = 5.;\n      scene = bgBox2;\n    } \n    \n    if (bgBox3 < scene) {\n      id = 6.;\n      scene = bgBox3;\n    } \n    \n     \n    if (bgBox4 < scene) {\n      id = 7.;\n      scene = bgBox4;\n    } \n    \n    \n    return scene;\n}\n\nfloat march(vec3 from, vec3 to, out vec3 p, float maxDist, out float softness, out float id) {\n    float d = 0.1;\n    softness = 1e20;\n    vec3 dir = normalize(to - from);\n    float ph = 1e20; \n\n    for (int i = 0; i < 200; i++) {\n        p = from + d * dir;\n        float dd = scene(p, id);\n        float y = dd * dd / (2.0 * ph);\n        float qq = sqrt(dd * dd - y * y);\n        softness = min(softness, qq / max(0.0, d - y));\n        \n        if (dd < 0.001 * d) {\n            return 1.;\n        }\n        if (dd > maxDist) {\n            return 0.;\n        }   \n        ph = dd;\n\n        d += dd;\n    }\n    return 0.;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 EPS = vec2(0.0001, 0.0);\n    float id;\n    return normalize(vec3(\n        scene(p + EPS.xyy, id) - scene(p - EPS.xyy, id),\n        scene(p + EPS.yxy, id) - scene(p - EPS.yxy, id),\n        scene(p + EPS.yyx, id) - scene(p - EPS.yyx, id)\n    ));\n}\n\nconst vec3 cam = vec3(0, 0, -4.);\n\nvec3 getFW(vec2 fragCoord) {\n   vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= 2.;\n    uv.x *= iResolution.x / iResolution.y;\n    return vec3(uv, -2.);\n}\n\nmat3 refl(vec3 n) {\n    return mat3(1.0) - 2. * outerProduct(n,n);\n}\n\nfloat ill(vec3 lightPos, vec3 surfPos) {\n    vec3 dir = \n        normalize(lightPos - surfPos);\n        \n    vec3 n =\n        getNormal(surfPos);\n        \n    vec3 occPos;  \n    float soft;\n\n    float id;\n\n    float occ = \n        march(surfPos, lightPos, occPos, length(surfPos - lightPos), soft, id);\n        \n    vec3 camDir = \n        normalize(cam - surfPos);\n        \n    float spec = \n        smoothstep(.98, 1., dot(-dir, camDir * refl(n)));\n\n    return 4.5 * spec + clamp(2. * soft * (1. - occ), 0., 1.) * clamp(dot(dir, n), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fw = getFW(fragCoord);\n    vec3 p;\n    float soft;\n    float id;\n    float mask = march(cam, fw, p, 200., soft, id);\n    \n    vec3 mat = vec3(.5, .5, .5);\n    if (id > 6.5) {\n        mat = vec3(0.5, .25, .65);\n    }\n    else if (id > 5.5) {\n        mat = vec3(0.4, 2.25, 1.25);\n    }\n    else if (id > 4.5) {\n        mat = vec3(0.4, 1.25, 1225);\n    }\n    else if (id > 3.5) {\n        mat = vec3(1.5, 0.35, 0.55);\n    }\n    else if (id > 2.5) {\n        mat = vec3(0.4, 1.25, 1.25);\n    }\n    else if (id > 1.5) {\n        mat = vec3(1.4, 1.25, .125);\n    }\n    else if (id > 0.5) {\n        mat = vec3(1.9, .125, .125);\n    }\n    vec3 color = vec3(0.);\n    color += mat * vec3(1., .8, .7) * ill(vec3(2., 4., -3.), p);\n    color += mat * vec3(.1, .2, 2.0) * ill(vec3(-3., 1., 1.), p);\n    color += mat * .05 * vec3(.1, .15, 1.8);\n    \n    if (mask < 1.) {   \n        float t = smoothstep(-.5, 1.2, fw.y);\n        color = (1. - t) * vec3(.1, .15, 1.8);\n    }\n    fragColor = vec4(pow(color, vec3(.4545)), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WltcDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wltczM", "name": "Buggy Waves", "author": "darkeclipz", "description": "after spending an hour to get the height right for the bars with subdividing the space (line 29), i give up. gonna look at it later to see how to fix it", "tags": ["3d", "raymarch", "sine"], "likes": 7, "viewed": 174, "date": "1608734903", "time_retrieved": "2024-06-20T20:27:06.114786", "image_code": "#define AA 1.\n#define R iResolution.xy\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nvec2 map( in vec3 pos, float time )  \n{\n    // Outer box\n    float id = 0.;    \n    float t = iTime;\n    \n\n    vec3 rpos = opRepLim(pos + vec3(0, 0.5, 0), 0.025, vec3(16.0, 0.05, 16.0));\n    float rep = 36.;\n    vec2 xy = floor(pos.xz * rep) / rep; // incorrect but i give up\n    float h = 0.03*sin(16.*sqrt(dot(xy,xy))+fract(t)*3.1415*2.);\n    \n    float box = sdBox(rpos, vec3(0.005, 0.1+h, 0.005));\n\n   \n    // Floor\n    float floorPlane = pos.y + 0.5;\n    float d = min(box, floorPlane);\n    if(floorPlane < box) {\n    \tid = 1.;    \n    }\n\n    return vec2(d, id);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.0001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec3 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.01;\n    int i=0;\n    for( i=0; i<60; i++ )\n    {\n        float precis = 0.0001 * t;\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x< precis )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec3(t, m, 1. - float(i)/60.);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/4.;\n\n    vec3 col = vec3(0);\n    vec3 res = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0,-0.5,0);\n        vec3 ro = vec3(0, 0.3 + (-sin(2.+time) * .5 + .5) * 0.2, -1.);\n        ro.xz *= rot(cos(2.*3.1415*time/2.)*0.4 + 3.*3.1415/4.);\n        \n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n \n        vec3 col = vec3(0.0);\n\n        vec3 tm = castRay(ro, rd, time); \n\n        if( tm.x < 20. )\n        {\n            float t = tm.x;\n            float id = tm.y;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            vec3 mate = vec3(0.6); \n            \n            if(id < 0.5) { // box\n            \tmate = vec3(191, 222, 245)/255.;     \n               \n            }\n            else if(id < 1.5) { // floor\n            \tmate = vec3(67, 122, 161) / 255.;   \n                float s = 8.;\n                float w = 0.025;\n                \n                if(fract(pos.x*s) < w) {\n                \tmate *= 0.9;\n                }\n                \n                if(fract(pos.z*s) < w) {\n                \tmate *= 0.9;    \n                }\n            }\n\n            vec3  light1 = vec3( 0, 0.2, 1 );\n            vec3  light2 = vec3( 1, 3, 1 );\n\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n            float amb = (0.7+0.3*nor.y);\n            float shadow = clamp(castShadow(pos + nor*0.05, light1 - pos, time), 0., 1.);\n            \n            vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*shadow;\n            brdf += 1.0*vec3(255, 248, 230)/255.*key*tm.z*shadow;\n            brdf += 1.0*vec3(230, 248, 255)/255.*bac*tm.z;\n\n            col = mate * brdf * exp(-0.6*t);\n        }\n\n        res += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow( res/(AA*AA), vec3(0.4545) );\n    \n    O = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wltczM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wltczN", "name": "flowing flower yingyang", "author": "rrx", "description": "colorful flower with a rotating yinynag", "tags": ["floweryinyang"], "likes": 2, "viewed": 53, "date": "1608623346", "time_retrieved": "2024-06-20T20:27:06.114786", "image_code": "vec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat bump(float x)\n{\n    return smoothstep(-1., 0., x) - smoothstep(0., 1., x);\n}\n\nfloat smoothbump(float r, float dr, float d)\n{\n    return smoothstep(r-dr/2., r, d) - smoothstep(r, r+dr, d);\n}\n\nfloat circle(in vec2 uv, in vec2 uv0, in float r, in float w) \n{\n    return smoothbump(r, w, length(uv - uv0));\n}\n\nfloat unit(in float x) \n{\n    return clamp(0.,1.,x);\n}\n\nfloat yinyang(in vec2 uv, in vec2 uv0, in float dr) \n{  \n    // double circles enclosing\n    float t = 0.;//circle(uv, vec2(0.,0.), 1.+dr*2., dr)\n       // + circle(uv, vec2(0.,0.), 1.1, dr);\n        \n    // positions and distances of the circles\n    vec2 uv1 = uv - vec2(.5,0.);\n    vec2 uv2 = uv - vec2(-.5,0.);\n    float d0 = length(uv);\n    float d1 = length(uv1);\n    float d2 = length(uv2);\n   \n    // use atan to determine if we are in the top or bottom half of the circle\n    float a1 = atan(uv1.y, uv1.x);\n    \n    float d3 = 10.;\n    if (a1 < 0.) {\n        // trace the enclosing circle in the top half\n        d3 = d0;\n    } \n    // the tail\n    float t7 = -smoothstep(1.-dr,1.+dr, d3); \n    \n    // add and substract the two circles\n    float t5 = 0.;\n    float t6 = 0.;\n    if (a1 >=0.)\n    {\n        t5 = 1. - smoothstep(.5-dr, .5+dr, d1) ;\n    }\n    else\n    {\n        t6 = smoothstep(.5-dr, .5+dr, d2) - 1.;\n    }\n\n    // left eye\n    float t4 = smoothstep( .1 - dr, .1 + dr, d1);\n\n    // right eye\n    float t2 = 1. - smoothstep( .1 - dr, .1 + dr, d2);\n\n    float h = t + t2 + t4 + t5 + t6 + t7;\n    return h;\n}\n\nfloat petals(in vec2 uv, in vec2 uv0, in float dr)\n{\n    // double circles enclosing\n    float r0 = 1.;\n    float t = 0.;\n    \n    float c0 = 2.*smoothstep(r0,r0+dr, length(uv-uv0));\n    float t1 = 0.;\n    float t2 = 0.;\n    float t3 = 0.;\n    float t4 = 0.;\n    vec2 uv1 = vec2(1.,0.);\n    float alt = 1.;\n\n    float d = length(uv-uv0);\n    if (d > r0) // && d < r2) \n    {\n        float r = sqrt(.5*.5*2.);\n        float petals = 6.*6.;\n        for (float a=0.;a<petals;a+=1.) \n        {\n        \n            float b = mod(a,4.);\n            float c = circle(uv, uv1, r, dr);\n            float d = length(uv - uv1);\n            float step = 1. - smoothstep(r,r+dr,d);\n            {\n                t3 += b*step;\n            }\n            uv1 = rot(uv1, radians(360./petals));\n            alt *= 1.;\n        }\n    }\n    \n    float h = t + t1 + t2 + t3 + t4;\n    if (h > 10.)\n    {\n        return 1.;\n    }\n    else\n    {\n        return 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize aspect\n    vec2 R = iResolution.xy;\n    vec2 uvR = ( R - 2.*fragCoord ) / R.y;\n    \n    // rotate the frame\n    float z = 2.2;\n    //vec2 uv = rot(uvR*z,radians(45.));\n    vec2 uv = uvR*z;\n    vec2 uv1 = rot(uv, radians(iTime*5.));\n    \n    vec3 colx = 0.5 + 0.5*cos(iTime+uvR.xyx+vec3(0,2,4));\n    vec3 col0 = vec3(.0);\n    vec3 col1 = vec3(.5,.0,.0);\n    vec3 col2 = vec3(.0,.5, 0.);\n    vec3 col3 = vec3(.3,.1,.5);\n   \n    float dr = 20./R.x;    \n\n    vec2 uv0 = vec2(0.,0.);\n    float h1 = petals(uv, uv0, dr);\n    float h2 = petals(rot(uv,radians(360./6.)), uv0, dr);\n    float h3 = yinyang(uv1*1.04, uv0, dr);\n    \n    float r2 = 1.5;\n    float r1 = 0.9;\n    float t1 = 0.*circle(uv, uv0, r1, dr) + circle(uv, uv0, r2, dr);\n\n    vec3 col = colx*h2 + colx*h1 + colx*t1 + colx*h3;   \n    fragColor = vec4(col/2., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wltczN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WltyDH", "name": "Infinite Switching Space", "author": "Kamoshika", "description": "I used 3D noise to draw the objects.", "tags": ["raymarching", "noise"], "likes": 13, "viewed": 170, "date": "1608986137", "time_retrieved": "2024-06-20T20:27:06.120978", "image_code": "// I made this while streaming.\n// Watch YouTube video!!\n// https://www.youtube.com/watch?v=A4SDIgenwHo\n\nconst float pi2 = acos(-1.)*2.;\n\nmat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smoothFloor(float x, float s) {\n\treturn floor(x-.5)+smoothstep(.5-s, .5+s, fract(x-.5));\n}\n\nfloat rand(float x) {\n\tfloat r = fract(sin(x)*43758.5453);\n\tfloat t = smoothFloor(iTime, .2);\n\tr = sin(r*pi2 + t)*.5+.5;\n\treturn r;\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\tvec3 b = vec3(173, 61, 3);\n\tfloat n = dot(p, b);\n\treturn mix(    mix(\t   mix(rand(n), rand(n+b.x), f.x),\n                           mix(rand(n+b.y), rand(n+b.x+b.y), f.x),\n                           f.y),\n                   mix(    mix(rand(n+b.z), rand(n+b.x+b.z), f.x),\n                           mix(rand(n+b.y+b.z), rand(n+b.x+b.y+b.z), f.x),\n                           f.y),\n                   f.z);\n}\n\nfloat dist(vec3 p) {\n\tfloat d = length(p.xy)-1.;\n\treturn max(noise(p)-.2, -d);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n\tvec3 res = fract(h+vec3(0,2,1)/3.);\n\tres = abs(res*6.-3.)-1.;\n\tres = clamp(res, 0., 1.);\n\tres = (res-1.)*s+1.;\n\tres *= v;\n\treturn res;\n}\n\nfloat exp2Fog(float d, float density) {\n\tfloat s = d*density;\n\treturn exp(-s*s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (fragCoord*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0);\n\t\n\tvec3 cPos = vec3(0, 0, -iTime*3.);\n\tvec3 cDir = normalize(vec3(0.2, 0, -1));\n\tcDir.xy *= rotate(iTime*.1);\n\t\n\tvec3 cUp = vec3(0, 1, 0);\n\tcUp.xy *= rotate(iTime*-.1);\n\t\n\tvec3 cSide = cross(cDir, cUp);\n\tvec3 ray = normalize(p.x*cSide + p.y*cUp + cDir*2.5);\n\t\n\tfloat d = 0., c = 0.;\n\tvec3 rPos = cPos;\n\tfor(int i=0; i<150; i++) {\n\t\td = dist(rPos);\n\t\tif(d < 0.01) {\n\t\t\tbreak;\n\t\t}\n\t\trPos += ray*d;\n        c++;\n\t}\n    \n    if(d < 0.01) {\n        float r = noise(rPos+vec3(10));\n        vec3 base = hsv2rgb(r*.3+floor(iTime)*pi2, .5, 1.);\n        col = base/c*20.;\n    }\n    \n\tfloat fog = exp2Fog(length(rPos-cPos), 0.03);\n\tcol = mix(vec3(1), col, fog);\n\t\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WltyDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WltyRH", "name": "basic macish", "author": "Shellderr", "description": "basic and macish", "tags": ["osx"], "likes": 1, "viewed": 37, "date": "1608491365", "time_retrieved": "2024-06-20T20:27:06.120978", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1, 1\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 p = vec2(0.0,0.0);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 c = vec3(1. - length(p-uv));\n\n    fragColor = vec4(mix(col,c,0.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WltyRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wltyWn", "name": "Disco tiles", "author": "Tarquin", "description": "Easy shader using basics of trigonometry (sin, cos)", "tags": ["sin", "cos"], "likes": 1, "viewed": 65, "date": "1608828489", "time_retrieved": "2024-06-20T20:27:06.120978", "image_code": "// Created by Arthur Jacquin - 2020\n// https://www.linkedin.com/in/arthur-jacquin-631921153/\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = vec2(fragCoord.xy / iResolution.xy);\n    st.x *= iResolution.x/iResolution.y;\n\n    float pattern1 = sin((st.x ) * 100.0);\n    float pattern2 = cos((1.0 - st.y) * 100.0);\n\n    vec3 col1 = 0.5 + 0.2 * cos(iTime + st.xyx + vec3(0,2,4));\n    vec3 col2 = 0.2 + 0.5 * cos(iTime + st.xyx + vec3(0,2,4));\n\n    vec3 a = (pattern1 * pattern2) * col1;\n    vec3 b = (pattern1 + pattern2) * col2;\n\n    vec3 finalColor = a + b;\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wltyWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wltyzN", "name": "undula [mild spaz?] ⚙", "author": "HaleyHalcyon", "description": "a", "tags": ["ting"], "likes": 1, "viewed": 54, "date": "1608619743", "time_retrieved": "2024-06-20T20:27:06.120978", "image_code": "vec3 roll(uvec2 xy, uint t) {\n    const uint a = 1664525u;\n    const uint m = 1013904223u;\n\n    uint seed = 1818420u * xy.x + 78265178u * xy.y + 237698117u * t;\n    \n    uint x0 = (seed * a) % m;\n    uint x = (x0 * a) % m;\n    \n    vec3 xvec = vec3(x & 3u, (x >> 4u) & 3u, (x >> 8u) & 3u);\n    return xvec / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Time = fract(iTime / 4.);\n    uint time = uint(floor(iTime * 5.));\n   \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n    uv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    float linDis = distance(uv, vec2(0));\n    float lolDis = 7. * log(linDis) - 3. * linDis;\n    float angle = atan(uv.x, uv.y) / 3.14159265358979 / 2.;\n    \n    vec3 x = vec3(0);\n    if (linDis < 0.15) {\n        x = vec3(abs(1. - 2. * fract(-angle + 0.1 * lolDis + 4. * Time)));\n    } else {\n        vec2 rt = vec2(256. + Time + lolDis + 0.5 * sin(0.4 * lolDis + Time * 2. * 3.14159265358979), 256. + mod(angle * 32.0 + 0.3 * sin((0.2 * lolDis+Time * 2.0) * 3.14159265358979 * 2.),32.));\n        if (distance(fract(rt), vec2(0.5)) < 0.5) {\n            x = roll(uvec2(rt), time);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(x, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wltyzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3BR2", "name": "Block-centric", "author": "Plento", "description": "Trying out a concept learned in math class recently. Code is pretty ugly tho", "tags": ["2d", "mouse", "barycentric", "city"], "likes": 6, "viewed": 241, "date": "1607640126", "time_retrieved": "2024-06-20T20:27:06.126889", "image_code": "// Cole Peterson\n#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\nfloat point(vec2 p, float r){\n \treturn ss(0.003, 0.0, length(p) - r);   \n}\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 drawTriangle(vec3 col, vec2 uv, vec2 A, vec2 B, vec2 C){\n    col = mix(col, vec3(1., 0., 0.), point(A.xy-uv, 0.006));\n    col = mix(col, vec3(1., 0., 0.), point(B.xy-uv, 0.006));\n    col = mix(col, vec3(1., 0., 0.), point(C.xy-uv, 0.006));\n    return col;\n}\n\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    uv*= 1.0;\n    \n    vec3 col = vec3(1);\n    float scl = 0.25 + (.5+.3*sin(iTime*.5))*.3;\n    \n    //vec2 A = m;\n    vec2 A = vec2(0., -.17)*scl;\n    vec2 B = vec2(-0.1, -0.25)*scl;\n    vec2 C = vec2(0.1, -0.25)*scl;\n    \n    if(iMouse.z > 0.0) A = m;\n    \n    vec3 M = vec3(uv.x, uv.y, 1.);\n    \n    vec3 A3 = vec3(A, 1.);\n    vec3 B3 = vec3(A, 1.);\n    vec3 C3 = vec3(A, 1.);\n    \n    mat3 mat = mat3(vec3(A, 1.), vec3(B, 1.), vec3(C, 1.));\n    \n    vec3 bc = inverse(mat) * M;\n    \n    \n    bc.yz *= rot(iTime*.2);\n    bc.y -= iTime*4.;\n    \n    //bc.y += cos(bc.z*3.6 + iTime*8.)*0.03;\n    //bc.z += sin(bc.y*3.6 + iTime*8.)*0.03;\n    \n   \tvec3 id = floor(bc);\n    \n    float sY = floor(mod(id.y, 2.))*2. - 1.;\n    \n   \n    id = floor(bc);\n    vec3 rbc = fract(bc-.5)-.5;\n   \n    vec2 dim = vec2(3);\n    \n   \tcol = vec3(0.03);\t\n    \n    vec2 ridBIG = floor(mod(id.zy, (2.*dim.x - 1.)*14.));\n    \n    if(ridBIG.x < 5. || ridBIG.y < 0.)\n        dim = vec2(3);\n    else\n        dim = vec2(2);\n    \n    \n    vec2 rid = mod(id.zy, 2.*dim.x - 1.);\n    \n    if(rid.x == 3.) rid.x = 0.;\n    if(rid.y == 3.) rid.y = 0.;\n    \n    \n    float chng = floor(mod((rid.x + dim.x-1.) / (dim.x + dim.x-1.), 2.));\n    \n    vec2 p = vec2(0., 0.);\n    \n    float block = min(step(dim.x, abs(rid.y-p.x)) + \n                      step(dim.y, abs(rid.x-p.y)), 1.);\n    \n    \n    bc.z += iTime * cos(id.y);\n    bc.y += iTime * cos(id.z);\n    vec3 rbc2 = fract(bc)-.5;\n    \n    float t = id.y*0.14 + id.z*0.14;\n    //vec3 c = .5+.2*cos(vec3(2.2, 3.3, 1.3) * t);\n    vec3 c = .5 + .4*cos(vec3(2.2, 3.3, 1.3)*t);\n    col = mix(c, col, block);\n    \n    \n    vec2 ra = vec2(1.-step(.5, chng), step(.5, chng));\n    float re = rbc2.z*ra.x + rbc2.y*ra.y;\n    float road = abs(dot(ra, abs(rbc.yz)-.5));\n    float stripe = (ss(.04,.0, road-.01));\n    stripe *= ss(.04, .0, abs(re)-.2);\n  \t\n    col = mix(col, vec3(1., 1., 1.), stripe*block);\n    \n    \n    \n    col *= ss(0.8, .0, length(vec2(uv.x, uv.y*1.8))-.5);\n    \n    //col += (1.-step(0.026, abs(rbc.y) - 0.01))*.4 *(.5+.5*cos(iTime));\n    //col += (1.-step(0.026, abs(rbc.z) - 0.01))*.4*(.5+.5*cos(iTime));\n    \n    vec3 rbc3 = fract((bc - vec3(0., iTime, iTime))*0.2)-.5;\n    \n    \n    if(iMouse.z > 0.0) col = drawTriangle(col, uv, A, B, C);\n    \n    f = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n\n    //f = vec4(col, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGBD1", "name": "hoeled_an_eye", "author": "hoeled", "description": "I should make it cry.", "tags": ["eye"], "likes": 1, "viewed": 30, "date": "1607087141", "time_retrieved": "2024-06-20T20:27:06.126889", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 circlePos = vec2(.5,.5);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    \n    vec3 col = vec3(0.);\n    uv.y = uv.y * aspect;\n    circlePos.y = circlePos.y * aspect;\n    uv.y -= .007;\n   \n    uv.y = fract(uv.y*1.);\n\n    float radiusOrigin = 1.5;\n    float thick = .05;\n                \n    for(int i=1; i<1000; i++) {\n        float radius = clamp(radiusOrigin + 0.1 * float(i) * cos((iTime/2000.) + float(i)*2.) -.8, -.1, .2);\n        col += clamp(vec3(smoothstep(radius+0.001, radius,  length(circlePos-uv))), 0., 1.);\n    \tcol -= clamp(vec3(smoothstep(radius-(thick-.001), radius-thick,  length(circlePos-uv))), 0., 1.);\n    }\n    \n    uv.y += .007;\n    \n    for(int i=1; i<1000; i++) {\n        float radius = clamp(radiusOrigin + 0.1 * float(i) * cos((iTime/2000.) + float(i)*2.) -.8, -.1, .2);\n        col += clamp(vec3(smoothstep(radius+0.001, radius,  length(circlePos-uv))), 0., 1.);\n    \tcol -= clamp(vec3(smoothstep(radius-(thick-.001), radius-thick,  length(circlePos-uv))), 0., 1.);\n    }\n    \n    col = clamp(col, 0., 3.);\n    col.r -= (sin(iTime*1.)+1.)/1.;\n    col.g -= (sin(iTime*1.6)+1.)/1.;\n    col.b -= (cos(iTime*1.6)+1.)/1.;\n\n    vec2 q = uv - vec2(0.5, 0.9);\n \tfloat r = 0.1;\n    float r2 = 0.021;\n    \n    uv = fragCoord.xy/iResolution.xy;\n    aspect = iResolution.y / iResolution.x;\n    \n    uv.y += -.22;\n    uv.y = uv.y * aspect;\n    circlePos.y = circlePos.y * aspect;\n    col *= vec3(smoothstep(.04, .181, length(circlePos-uv)))*1.9;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGBDd", "name": "Analytic AO + Bleed - Step", "author": "athibaul", "description": "In the simple setting of a \"step\" in the middle of an infinite plane, ambient occlusion can be computed exactly. An approximation of low-order color bleeding in this specific setup is also given.\n\nLeft = without bleeding, right = with bleeding.\n", "tags": ["ambientocclusion", "analytic"], "likes": 0, "viewed": 67, "date": "1608228116", "time_retrieved": "2024-06-20T20:27:06.751121", "image_code": "// Analytic Ambient Occlusion\n\n// In the simple setting of a \"step\" in the middle of an infinite plane,\n// the integral of ambient occlusion can be computed exactly.\n\n// An approximation of low-order color bleeding in this specific setup is also given.\n// Left = without bleeding, right = with bleeding.\n\nvec3 worldColor( vec3 ro, vec3 rd )\n{\n    vec3 col1 = vec3(0.5); // Back floor color\n    vec3 col2 = vec3(0.5); // Wall color\n    vec3 col3 = vec3(0.8,0.5,0.1); // Front floor color\n    \n    \n    // Calculate ray intersection with each plane\n    float tmin = 1e10;\n    vec3 col = vec3(1);\n    float t; vec3 p;\n    \n    // Plane 1 is z=1 for x<0 : \"back floor\"\n    // AO = 1.0\n    t = (1.0-ro.z)/rd.z;\n    p = ro+t*rd;\n    if(t > 0.0 && p.x < 0.001 && t < tmin)\n    {\n        tmin = t;\n        col = col1;\n    }\n    \n    \n    // Plane 2 is x=0, for z between 0 and 1 : \"wall\"\n   \tt = -ro.x/rd.x;\n    p = ro+t*rd;\n    if(t > 0.0 && p.z > 0.0 && p.z < 1.0 && t < tmin)\n    {\n        tmin = t;\n        // Analytic ambient occlusion (exact):\n        // The floor occludes exactly half of the hemisphere visible from the wall\n        col = col2*0.5;\n        \n        if(p.y > 0.)\n        {\n            float zp1sq = (p.z+1.)*(p.z+1.);\n            \n            // Bleeding from the floor.\n            // Approximation obtained by fitting some terms with\n            // exponentials, so they can be integrated by hand (whereas the\n            // actual terms can't).\n            // The formula is only valid for this specific setting for now.\n            \n            // First order bleeding (approximation)\n            //col += col0*col0*0.25*(2.*zp1sq-1.)/zp1sq;\n            \n            // Second order bleeding (approximation)\n            col += col2*col3*0.5*mix(0.5*col2, vec3(1), (zp1sq-0.5)/zp1sq);\n        }\n    }\n    \n    \n    // Plane 3 is z=0, for x>0\n    t = -ro.z/rd.z;\n    p = ro+t*rd;\n    if(t > 0.0 && p.x > -0.001 && t < tmin)\n    {\n        tmin = t;\n        // Analytic Ambient Occlusion (exact)\n        // If the distance from the wall is x, then\n        // AO = 0.5+0.5*x/sqrt(1.0+x*x)\n        col = col3*(0.5+0.5*p.x/sqrt(1.0+p.x*p.x));\n        \n        if(p.y > 0.)\n        {\n            // Bleeding from the wall, first order (exact):\n            // the wall occupies exactly the remaining portion of the hemisphere\n            // and is lit by 0.5*col2.\n            col += col3*0.5*col2 * (0.5-0.5*p.x/sqrt(1.0+p.x*p.x));\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    float th = 0.5*iTime-1.5;\n    float th2 = 0.1*iTime;\n    //vec3 ro = vec3(3.0*cos(th), 3.0*sin(th), 2.0 - 1.5*cos(th));\n    vec3 ro = vec3(3.0, 0.3*sin(th), 2.0-0.3*cos(th));\n    vec3 camFwd = normalize(vec3(0) - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n   \tfloat fov = 0.7;\n    vec3 rd = normalize(camFwd + fov * (uv.x*camRight + uv.y * camUp));\n    \n    //vec3 col = 0.5+0.5*rd;\n    vec3 col = worldColor(ro, rd);\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGBRd", "name": "大龙猫 - Quicky#048", "author": "totetmatt", "description": "Stereographic projection test ", "tags": ["quicky"], "likes": 7, "viewed": 286, "date": "1607688902", "time_retrieved": "2024-06-20T20:27:06.751121", "image_code": "mat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvec3 p(float i)\n{\n    return .5+.5*cos(2.*3.1415*(1.*i+vec3(0.,.33,.67)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5*iResolution.xy) / iResolution.y;\n    uv*=1.;\n    float bpm = sqrt(fract(-length(uv)+iTime*130./60.*.5));\n    //uv+=vec2(cos(iTime),sin(iTime))*.1;\n    uv*=r(iTime*.1)*+bpm;\n    uv= abs(uv)-.1;\n    float f = 1.01+(sin(iTime)*.02+0.02);//sin(iTime+texture1D(spectrum1,.1).r*100.)*2.+2.5;\n        uv = vec2(uv.x/(1.-f),uv.y/(1.-f));\n    uv = vec2( f*uv.x/ (uv.x*uv.x+uv.y*uv.y+1.),f*uv.y/ (uv.x*uv.x+uv.y*uv.y+1.));\nuv+=vec2(cos(iTime),sin(iTime))*.1;\n   uv*=r(iTime*.1);\n    float d = max(abs(fract(uv.y*10.)-.5+.2)-.015,0.);\n    d= smoothstep(0.25,0.19,d);\n    float e = max(abs(fract(uv.x*10.)-.5+.2)-.015,0.);\n    e=smoothstep(0.25,0.19,e);\n    d=d+e;\n    vec3 col = vec3(d);\n    col = col*p(length(bpm));\n    //col = texture2D(spectrum1,vec2(uv.x*.5+.75,0)).rrr*10.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGBRt", "name": "Into-your-dream", "author": "hissanova", "description": "The power of the length function inside the cosine depends on the time so the wave length depends on the distance from the centre and changes over time", "tags": ["fmwavelength"], "likes": 0, "viewed": 51, "date": "1607701401", "time_retrieved": "2024-06-20T20:27:06.884479", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv - vec2(0.5, 0.5);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= 0.5 + 0.5 * cos(50.0 * 3.14 * pow(length(q), 0.15 + 0.1 * sin(iTime)) - 8.0 * iTime);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGBz3", "name": "LittleSquareSymetry", "author": "Nashoute", "description": "Just to add a bit of spice", "tags": ["square", "anim"], "likes": 1, "viewed": 54, "date": "1607614062", "time_retrieved": "2024-06-20T20:27:07.217764", "image_code": "//thanks to The art of code for the tutorial : https://www.youtube.com/watch?v=2R7h76GoIJM\n\nfloat hash21(vec2 p){ //fonction pour donner un aspect aléatoire\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p,p+35.14);\n    return fract(p.x*p.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy )/iResolution.y; //place le 0 des coordonnees au centre.\n    uv*=10.;\n    vec3 col = vec3(0); //couleur noir\n    float angle = 3./4.*3.1415;\n    vec2 n2 = vec2(sin(angle),cos(angle)); // 0 to 1\n   \n    uv.x = abs(uv.x); //crée un axe de symétrie au centre\n    uv.x+=0.;//offset x\n    uv.y+=0.; //offset y\n    uv -= n2*dot(uv,n2)*2.*(0.5+sin(iTime/2.)/1.); //déforme les uv modifiant l'angle de réflextion\n    \n    //col.xy += uv.xy; //couleurUv\n    \n    uv-=iTime; //fait bouger le motif en fonction du temps\n    \n    \n    vec2 gv = fract(uv); //ne prends que la partie décimale et crée des cases\n    vec2 id = floor(uv); //numéro de case\n    float n = hash21(id); //Donne une nombre aléatoire à la case entre 0 et 1\n    \n    //col.rg = gv; //Montre les cases\n    \n    if(n <0.5){\n        if(hash21(uv)<0.5){ //aspect rétro\n            if(gv.x<0.2  && gv.y>0.2){ //barres horizontales\n                col = vec3(1);\n            }\n\n        }else{\n            if(gv.y<0.2){ //barres verticales\n                col = vec3(1);\n            }\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGfD1", "name": "Animated Graph", "author": "oneshade", "description": "This was fun!", "tags": ["noise", "math", "graph", "continuousnoise"], "likes": 4, "viewed": 79, "date": "1607010800", "time_retrieved": "2024-06-20T20:27:07.217764", "image_code": "float noise(in float x) {\n    return fract(sin(x * 12.5673) * 573.123);\n}\n\nfloat continuousNoise(in float x) {\n    const float r = 2.735;\n\n    float x1 = floor(x * r) / r;\n    float y1 = noise(x1);\n\n    float x2 = ceil(x * r) / r;\n    float y2 = noise(x2);\n\n    return y1 + (0.5 + 0.5 * sin((2.0 * (x - x1) / (x2 - x1) - 1.0) * 1.57)) * (y2 - y1);\n}\n\nvec2 getSlopeVector(in float x) {\n    return normalize(vec2(0.002, continuousNoise(x + 0.001) - continuousNoise(x - 0.001)));\n}\n\n// SDF of equilateral triangle from Inigo Quilez's 2D distance functions article (https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm):\nfloat sdEquilateralTriangle(in vec2 p, in float s) {\n    p /= s;\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0) {\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    }\n\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 3.0 / iResolution.y * 4.0;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    fragColor.b += smoothstep(unit, 0.0, abs(uv.y - continuousNoise(uv.x + iTime)) - 0.01) * float(uv.x < 0.0);\n\n    vec2 slopeVector = getSlopeVector(iTime);\n    vec2 gradientVector = slopeVector.yx * vec2(1.0, -1.0);\n\n    uv.y -= continuousNoise(iTime);\n    vec2 tUV = vec2(dot(uv, gradientVector), dot(uv, slopeVector));\n\n    fragColor.rb += smoothstep(unit, 0.0, sdEquilateralTriangle(tUV, 0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGfD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGfDh", "name": "Grey_Clouds_lopo", "author": "lopoisaac", "description": "Simple smoke/clouds effect.", "tags": ["clouds", "smoke"], "likes": 7, "viewed": 70, "date": "1606998341", "time_retrieved": "2024-06-20T20:27:07.217764", "image_code": "#define S(a, b, c) smoothstep(a, b, c)\n\nfloat onda(vec2 uv)\n  {\n    float ondulacion = 0.;\n    float freq = 10.;\n    for (float i = 1.; i < freq; i += 1.){\n      ondulacion += .4 / i * sin(uv.x  * i * i );\n    }\n\n   return ondulacion;\n}\n\nfloat dibuja_capas(vec2 uv, float num_capa)\n  {\n    float separacion = 0.02;\n    float altura = 0.8 - separacion * num_capa;\n    float capa_alpha = ((uv.y - altura) * 8.)  + onda(uv + num_capa);\n    capa_alpha = S(0.3, 0.1, clamp(capa_alpha, 0., 1.));\n    \n    return capa_alpha * separacion * 1.4;\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord / iResolution.xy;\n  float color = 0.;\n  float capas = 40.;\n  for (float i = 0.; i < capas; i += 1.)\n    {\n      color += dibuja_capas(uv, i);\n      uv.x += iTime * .002;\n    }\n  \n  fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGfDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGfRG", "name": "Inside the Neural Network", "author": "Kamoshika", "description": "This is my first post to Shadertoy.\nI layered multiple voronoi borders to create a three-dimensional look.", "tags": ["voronoi"], "likes": 28, "viewed": 388, "date": "1607344404", "time_retrieved": "2024-06-20T20:27:07.630128", "image_code": "// I made this while streaming.\n// Watch YouTube video!!\n// https://www.youtube.com/watch?v=wI4UBRH6ibM\n\n#define rand(z) fract(sin(z)*1352.2342)\n\nconst float pi2 = acos(-1.)*2.;\n\nmat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 rand2f(vec2 co) {\n\tvec2 z = vec2(dot(co, vec2(1.1521, 1.4322)), dot(co, vec2(1.2341, 1.3251)));\n\treturn rand(z);\n}\n\n// Reference:\n// https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nfloat voronoiBorder(vec2 x, float seed, float phase) {\n\tvec2 xi = floor(x);\n\tvec2 xf = fract(x);\n\t\n\tvec2 res = vec2(10.);\n\tfor(int i=-1; i<=1; i++) {\n\t\tfor(int j=-1; j<=1; j++) {\n\t\t\tvec2 b = vec2(i,j);\n\t\t\tvec2 rv = rand2f(xi+b+seed*1.3412);\n\t\t\trv = sin(rv*pi2 + phase)*.5+.5;\n\t\t\trv *= .75;\n\t\t\tvec2 r = b+rv - xf;\n\t\t\tfloat d = dot(r,r);\n\t\t\t\n\t\t\tif(d<res.x) {\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t} else if(d<res.y) {\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n    \n\tres = sqrt(res);\n\treturn 1.-smoothstep(-.1, .1, res.y-res.x);\n}\n\nfloat smoothFloor(float x, float s) {\n\treturn floor(x-.5)+smoothstep(.5-s, .5+s, fract(x-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 color = vec3(0);\n\t\n\tp *= rotate(iTime*.2);\n\tfloat cPos = iTime;\n\tfloat id = ceil(cPos);\n\t\n\tfor(float i=0.; i<20.; i++) {\n\t\tfloat L = 1.-fract(cPos)+i;\n\t\tfloat a = atan(.003, L)*500.;\n\t\tfloat r = rand(id)*pi2;\n\t\tfloat phase = iTime + r;\n\t\tphase = smoothFloor(phase, .2);\n\t\tvec2 rv = rand2f(vec2(id, id*1.31223)) * 10.;\n        \n        // Reference:\n        // https://www.shadertoy.com/view/4sl3Dr\n\t\tfloat v1 = voronoiBorder(p/a+rv, id, phase);\n\t\tfloat v2 = voronoiBorder(p/a*.5+iTime*vec2(cos(r),sin(r)), id, phase);\n\t\tfloat v = pow(v1*v2, 3.) * 200.;\n        \n        color += (v1*vec3(.9, .4, 0.) + v) * exp(-L*L*0.001);\n\t\tid++;\n\t}\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGfRV", "name": "Smudge 20.12.08", "author": "maximkamalov", "description": "A 2D SDF smudge, based on rectangle, with Russian comments.", "tags": ["2d", "sdf", "russian", "smudge"], "likes": 1, "viewed": 65, "date": "1607462736", "time_retrieved": "2024-06-20T20:27:07.630128", "image_code": "// NOTE: Comments below are in Russian.\n// Leave a comment if you want an English version.\n\n// Цвета.\n#define FG vec3(.0, .0, .0)\n#define BG vec3(.9, .9, .9)\n\n// Формула искажения фигуры путем волнообразного смещения контура.\n// Координата z позволяет избежать однообразных волн.\n// Для изменения амплитуды достаточно умножить возвращенное значение после вызова.\n// Совет: можно поменять частоту на вектор, чтобы по каждому измерению была своя.\nfloat displacement(in vec3 p, in float freq)\n{\n    return\n        // Кажется, умножение двух волн необходимо для кляксообразной формы,..\n        sin(freq*p.x) * sin(freq*p.y)\n        // ...но с третьей частью можно делать все, что вздумается.\n        // (Например, поменять умножения на сложения.)\n        * sin(freq*p.z);\n}\n\n// Применение формулы искажения.\nfloat opDisplace(\n    // Неискаженное расстояние.\n    in float d1,\n    // Точка, от которой измеряется расстояние.\n    // (Честность не требуется, можно ее саму изменить, или не ее.)\n    in vec2 p,\n    // Размер смещения.\n    in float amplitude,\n    // Частота смещений.\n    in float frequency,\n    // Третий параметр.\n\tin float time)\n{\n    float d2 =\n        displacement(vec3(p, time), frequency)\n        * amplitude;\n    return d1 + d2;\n}\n\n// Формула расстояния до прямоугольника.\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to [-1, 1].\n    uv = uv * 2. - 1.;\n        \n    float dist = sdBox(uv, vec2(.5, .5));\n    dist = opDisplace(\n        dist,\n        uv,\n        .5,\n        8.,\n        // Эту формулу можно выкинуть и подставить любую другую.\n        // (Например, length(uv + iMouse.xy) / 111. + uv.x / 3.)\n        uv.x / 5. + uv.y / 3. + iTime / 64.);\n    \n    // Внутри — 0, снаружи — 1, на границе — плавный переход.\n    float col = smoothstep(-.02, .02, dist);\n    \n    vec3 color = mix(FG, BG, col);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGfWw", "name": "Rolling mushroom", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 5, "viewed": 84, "date": "1607295250", "time_retrieved": "2024-06-20T20:27:07.630128", "image_code": "#define TAU atan(1.)*8.\n\nvoid lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\n#define hash(p)fract(sin(p*12345.5))\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+215.3))*TAU;\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\n// https://shadertoy.com/view/ltf3W2\n#define sabs(p,k)sqrt((p)*(p)+k)\n\n// p-=2.*min(0.,dot(p,v))*v;\n// smooth type\nvoid sfold(inout vec2 p, vec2 v, float k)\n{\n    float g=dot(p,v);\n    p-=(g-sabs(g,k))*v;\n}\n\n// if(p.x<p.y)p.xy=p.yx;\n// smooth type\nvoid sfold45(inout vec2 p, float k)\n{\n    vec2 v=normalize(vec2(1,-1));\n    sfold(p,v,k);\n}\n\nfloat map(vec3 p){\n\trot(p,vec3(cos(iTime*.07),sin(iTime*.02),sin(iTime*.05)*.5),iTime*.5);\n\tfloat k=.02;\n\tfloat itr=8.;\n    float t=iTime*.08;\n    vec3 axis=randVec(hash(floor(t)*23.45+123.4+iDate.y));\n\tfor(float i=0.;i<itr;i++)\n\t{\n    \tp=abs(p)-1.;\n    \tsfold45(p.xz,k);\n\t\tsfold45(p.yz,k);\n\t\tsfold45(p.xy,k);\n\t\trot(p,axis,fract(t)*TAU);\n\t\tp*=2.;\n  \t}\n  \treturn length(p.xy)/exp2(itr)-.01;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return cos(vec3(7,6,4)+p*.5)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,6);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0,0,.05);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n    }\n    col*=1.5;\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGfzt", "name": "fractalPlay", "author": "Kaeylos", "description": "small shader to experiment using menger and sierpinski triangle fractal ", "tags": ["menger", "imac"], "likes": 1, "viewed": 51, "date": "1607684457", "time_retrieved": "2024-06-20T20:27:09.242397", "image_code": "// ----- Ray marching options ----- //\n#define AA_SAMPLES 2 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 300\n#endif\n#define MAX_DIST 100.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.001\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\n\n// ----- easingFunct -----//\nfloat quadInOut(float t) { return t < 0.5 ? 8. * pow(t, 4.) : 1. - pow(-2. * t + 2., 4.) / 2.;}\nfloat saw(float t) { return (-abs(2.*t-1.)+1.); }\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0, 1], including hue.\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0, 1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 blendColor(float t, vec3 a, vec3 b) {\n\treturn sqrt((1. - t) * pow(a, vec3(2.)) + t * pow(b, vec3(2.)));\n}\n\n// ----- distance functions modifiers ----- //\n// source: https://www.iquilezles.org/www/articles/smin/smin.htm\n\nvec3 arrayOp(vec3 p, vec3 offset) {\n    return mod(p + 0.5 * offset, offset) - 0.5 * offset;\n}\n\nvec3 arrayOp(vec3 p, vec3 offset, vec3 count) {\n    return p - offset * clamp(round(p/offset),vec3(0.0), count);\n}\n\nfloat unionOp( float d1, float d2) { return min(d1, d2);}\nfloat subOp( float d1, float d2) { return max(d1, -d2); }\nfloat interOp( float d1, float d2) { return max(d1,d2); }\n\n\n// ----- distance functions for 3D primitives ----- //\n// source: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\nfloat octahedronSDF(vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n/*\nfloat octahedronSDF( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}*/\n\nfloat pyramidSDF(vec3 p, float size) {\n\treturn interOp(octahedronSDF(p, size), -p.y);\n}\n\nfloat torusSDF( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat crossSDF(vec3 p, float size) {\n\t  float da = maxComp(abs(p.xy));\n\t  float db = maxComp(abs(p.yz));\n\t  float dc = maxComp(abs(p.zx));\n\t  return min(da,min(db,dc)) - size;\n}\n\nfloat menger(vec3 p, float boxSize, int iterations) {\n\tfloat d = boxSDF(p, vec3(boxSize));\n\t\n\t/* NICE\n\tfloat scale = 1.;\n\tfor(int i=0; i<iterations; ++i) {\n\t\t\n\t\tvec3 q = arrayOp(p * scale, vec3(1.));\n\t\td = subOp(d, crossSDF(q , 1./3.) / scale);\n\t\tscale *= 3.;\n\t}*/\n\t\n\tfloat anim = ((cos(iTime/2.)+1.)/2.+1.);\n\t// anim = 1;\n\tfloat count = 1.;\n\tfor(int i=0; i<iterations; ++i) {\n\t\tvec3 q = arrayOp(p * anim , vec3(2.*boxSize/count));\n\t\td = subOp(d, crossSDF(q, 1./(count*3.)));\n\t\tcount *= 3.;\n\t}\n\treturn d;\n}\n\n// sources http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat Sierpinski(vec3 z, int iterations) {\n\tvec2 D = vec2(1., 0.);\n\tvec3[5] SierpinskiOffset = vec3[5](D.xyy, -D.xyy, D.yyx, -D.yyx, D.yxy);\n\tfloat Scale = 2.;\n\tvec3 c;\n\tfloat dist, d;\n\tfor(int n=0; n < iterations; n++) {\n\t\tc = SierpinskiOffset[0]; dist = length(z-SierpinskiOffset[0]);\n\t\tfor(int i=1; i<5; i++) {\n\t\t     d = length(z-SierpinskiOffset[i]);\n\t\t     if (d < dist) { c = SierpinskiOffset[i]; dist=d; }\n\t\t }\n\t\tz = Scale*z-c*(Scale-1.0);\n\t}\n\t\n\treturn pyramidSDF(z* pow(Scale, float(-iterations)), pow(2., -float(iterations)));\n}\n\n/*\nfloat Sierpinski(vec3 z)\n{\nfloat Scale = 2.;\nfloat Offset = 10.;\n    float r;\n    int n = 0;\n    while (n < 5) {\n       if(z.x+z.y<0) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0) z.zy = -z.yz; // fold 3\t\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    return (length(z-1.) ) * pow(Scale, -float(n));\n}\n*/\n\nfloat sceneSDF(vec3 p) {\n\t/*\n\t// tricks from https://www.shadertoy.com/view/4tXGDn\n    const float n = 5;\n    const float speed = 0.5;\n    float phi = 2.0 * PI / n;\n    float t1 = phi / 4.0;\n    float t2 = 3.0 * t1;\n    \n    float s = Sierpinski((p+vec3(0., 0.5, .0)), 5);\n\tfloat m = menger(p, 1., 5);\n\tfloat b = boxSDF(p, vec3(1.));\n\tfloat py = pyramidSDF(p+vec3(0., 0.5, .0), 1.);\n\t\n    float sk  = smoothstep(cos(t2),cos(t1),cos(iTime*speed));\n    float pyk = smoothstep(cos(t2),cos(t1),cos(iTime*speed-phi));\n    float b0k  = smoothstep(cos(t2),cos(t1),cos(iTime*speed-2.*phi));\n    float mk  = smoothstep(cos(t2),cos(t1),cos(iTime*speed-3.*phi));\n    float b1k  = smoothstep(cos(t2),cos(t1),cos(iTime*speed-4.*phi));\n\t// return s*sk+py*pyk+m*mk+b*(b0k+b1k);*/\n\t\n\tfloat s = Sierpinski((p+vec3(0., 0.5, .0)), 6);\n\tfloat m = menger(p, 1., 5);\n\t\n\treturn mix(s, m, quadInOut(quadInOut(saw(mod(iTime/30.,1.)))));\n}\n\n// from iq technique\n// source: https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++) {\n        float h = 03.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = sceneSDF(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// source: https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sceneSDF( p + k.xyy*h ) + \n                      k.yyx * sceneSDF( p + k.yyx*h ) + \n                      k.yxy * sceneSDF( p + k.yxy*h ) + \n                      k.xxx * sceneSDF( p + k.xxx*h ) );\n}\n\n// return dist, marchingCount\nvec2 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 pos = O + D * t;\n        float d = sceneSDF(pos);\n        \n        t += d *0.8; // precision handling\n        ++marchingCount;\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return vec2(t, marchingCount);\n}\n\nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tfloat shadowsAttenuation = 5.;\n\tfloat specularStrength = 20.;\n\tvec3 backgroundColor = vec3(2,43,58)/255.0;\n\tvec3 ballsColor = vec3(255,166,43)/255.0;\n\t\n\tvec3 sunDir = normalize(vec3(0., 1., -1.));\n    vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));\n    float sunIntensity = 2.; \n    \n\tfloat d = rayMarching(O, D).x;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tif( d < MAX_DIST) {\n    \t// intersected point position\n        vec3 p = O + D * d;\n        vec3 normal = getNormal(p);\n        vec3 ref = normalize(reflect(D, normal));\n        \n        float occ = calcOcclusion(p, normal); // ambient occlusion\n        float sunDiffuse = min(1.,max(0., dot(normal, sunDir)));\n\t\t\n\t\tcol = ballsColor;\n        col += sunIntensity*sunColor*sunDiffuse;\n\t\tcol *= mix(occ, 1., 0.5);\n        col *= 0.3;\n    }else {\n    \tcol = backgroundColor;\n    }\n\t    \n\treturn vec3(min(vec3(1.), max(vec3(0.), col)));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.; // zoom\n\t\n\tfloat radius = 3.;\n\t\n// handle origin\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    \n    vec3 O;\n    \n    if(iMouse.z > 0.) {\n\t    // camera pos\n\t    float mag = 5.;\n\t    O = vec3(radius*sin(mag*m.x + PI/2.0), -10.*m.y, radius*cos(mag*m.x+PI/2.0));\n\t}else {\n\t\tfloat timeAnim = iTime/10.;\n\t\tradius = 3. + 1.5*cos(timeAnim);\n\n\t\tO = vec3(radius*sin(timeAnim + PI/2.0), -1.*cos(timeAnim), radius*cos(timeAnim+PI/2.0));\n\t}\n\n\t\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // gamma corection\n    finalColor = pow(finalColor, vec3(1./2.2));\n    \n    \n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y *= 1.5; // saturate\n    hsv.z *= 1.3;\n    finalColor = hsv2rgb(min(vec3(1.), max(vec3(0.), hsv)));\n    \n    // color grading\n    finalColor *= vec3(1.07 ,0.92, 0.95);\n    \n\tfragColor = vec4(finalColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKBDt", "name": "Xor gemstones", "author": "jarble", "description": "I combined [url=https://www.shadertoy.com/view/WsVBDd]this shader[/url] with [url=https://www.shadertoy.com/view/4s23zz]this shader[/url] to produce a gemstone pattern.", "tags": ["fbm", "emerald"], "likes": 9, "viewed": 268, "date": "1608260497", "time_retrieved": "2024-06-20T20:27:10.090764", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See http://www.iquilezles.org/www/articles/warp/warp.htm for details\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nfloat noise(vec2 U){\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U);\n    int x = I.x, y = I.y,\n        i = x - y ^ y + x;\n    \n    float v = float(i);  // try also: i*i , i*i*i\n\n    return (fract( v * 0.051618 ));\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2( fbm4(p+vec2(1.0)), fbm4(p+vec2(6.2)) );\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2( fbm6(p+vec2(9.2)), fbm6(p+vec2(5.7)) );\n}\n\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    q += 0.05*sin(vec2(0.11,0.13) + length( q )*4.0);\n    \n    q *= 0.7 + 0.2*cos(0.05);\n\n    o = 0.5 + 0.5*fbm4_2( q );\n    \n    o += 0.02*sin(vec2(0.11,0.13)*length( o ));\n\n    n = fbm6_2( 4.0*o );\n\n    vec2 p = q + 2.0*n + 1.0;\n\n    float f = 0.5 + 0.5*fbm4( 2.0*p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int mi=0; mi<AA; mi++ )\n    for( int ni=0; ni<AA; ni++ )\n    {\n        // pixel coordinates\n        vec2 of = vec2(float(mi),float(ni)) / float(AA) - 0.5;\n        vec2 q = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y*2.0;\n#else    \n        vec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y*2.0;\n#endif\n        q += iTime/2.0;\n        vec2 o, n;\n        float f = func(q, o, n);\n        \n        vec3 col = vec3(0.2,0.1,0.4);\n        col = mix( col, vec3(0.3,0.05,0.05), f );\n        col = mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n        col = mix( col, vec3(0.5,0.2,0.2), 0.5*o.y*o.y );\n        col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n        col *= f*2.0;\n\n        vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n        vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n        #if AA>1\n        ex /= float(AA);\n        ey /= float(AA);\n        #endif\n        vec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n        \n        vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n        float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n        vec3 bdrf;\n        bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n        bdrf += vec3(0.15,0.10,0.05)*dif;\n        bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n        bdrf += vec3(0.15,0.10,0.05)*dif;\n\n        col *= bdrf;\n        col = vec3(1.0)-col;\n        col = col*col;\n        col *= vec3(1.2,1.25,1.2);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n\tvec2 p = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n\t\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKBW1", "name": " Impossible Aperiodic Tilings", "author": "neozhaoliang", "description": "Draw aperiodic rhombus tiling using de Bruijn's algebraic approach.\n\"Aperiodic\" means the tiling has no translation symmetry.\nAdd some Escher style decorations to make it look impossible.\nQuality is better at full screen mode.", "tags": ["escher", "tiling", "rhombus", "impossible", "aperiodic", "debruijn"], "likes": 25, "viewed": 974, "date": "1607445143", "time_retrieved": "2024-06-20T20:27:12.315308", "image_code": "/*\nAperiodic tiling using de Bruijn's algebraic approach, Zhao Liang.\n\nThis shader is motivated by Greg Egan's javascript applet at\n\n    http://gregegan.net/APPLETS/02/02.html\n\nThanks Egan for explaining his idea to me! (and the comments in his code :)\n\nAlso I learned a lot from Shane's wonderful examples.\n\nYou can do whatever you want to this program.\n\nBelow I'll give a brief sketch of the procedure used in this program,\nfor a detailed explanation please refer to\n\n\"Algebraic theory of Penrose's non-periodic tilings of the plane\".\n                                                   N.G. de Bruijn.\n\nAlso I found the book\n\n\"Aperiodic Order, Volume 1\", by Baake M., Grimm U., Penrose R.\n\nvery helpful.\n\nMain steps: (use N=5 as example)\n\n1. We choose the five fifth roots of unity as grid directions.\n   Each direction will have a family of grid lines orthogonal to it and\n   has unit spacing between adjacent lines.\n\n2. We also choose five reals to shift each grid along its direction.\n\n3. Any intersection point P of two grid lines can be identified with four integers\n   (r, s, kr, ks), which means P is the intersection of the kr-th line in the r-th\n   grid and the ks-th line in the s-th grid. It must hold 0 <= r < s < 5.\n   kr and ks can be any pair of integers.\n\n4. Each intersection point P correspondes to an unique rhombus in the final tiling. Note\n   this rhombus does not necessarily contain P but a transformed version of P.\n\n5. For each pixel uv, we do a bit lengthy computation to find which rhombus its\n   transformed position lies in.\n\n6. Color the rhombus acoording to its shape, the position, ... whatever you want.\n\n7. We also draw a tunnel in each face and flip the tunnel randomly to make some cubes\n   look impossible. (a cube is formed by three rhombus meeting at an obtuse vertex)\n   Note this is different from Egan's applet, in there he carefully chose fixed flips\n   for each rhombus to make **every** cube look impossible. Our random flips here only\n   make **some** cubes look impossible.\n\nAll suggestions are welcomed.\n*/\n\n// If you want some cube faces are closed and draw a cross bar on them\n#define SOME_CLOSED_FACES\n\n// dimension of the grids, N=5 is the (generalized) Penrose pattern\nconst int N = 5;\n\n// control hole size\nconst float hs = 3.33;\n\n// N real numbers for the shifts of the grids.\nfloat[N] shifts;\n\n// directions of the grids, will be initialized later\nvec2[N] grids;\n\nstruct Rhombus\n{\n    // r, s for the r-th and s-th grids.\n    int r;\n    int s;\n\n    // kr, ks for the lines in the two grids\n    float kr;\n    float ks;\n\n    // center and vertices of the rhombus\n    vec2 cen;\n    vec2[4] verts;\n\n    // vertices of the tunnels, each tunnel contains two pieces.\n    vec2[4] inset1;\n    vec2[4] inset2;\n};\n\n#define PI 3.141592653\n\n// initialize the grid directions, for N = 5 they are the five fifth roots of unity\nvoid init_grids()\n{\n    float FN = float(N), theta; \n    for(int k = 0; k < N; k++)\n    {\n        theta = (N % 2 == 0) ? PI / FN * float(k) : PI / FN * float(k) * 2.;\n        grids[k] = vec2(cos(theta), sin(theta));\n        // for N=5 (0.2, 0.2, 0.2, 0.2, 0.2) gives the classical Penrose tiling.\n        // set all shifts to 0.5 will give the star pattern which has ten thin rhombus\n        // around a vertex hence is non-Penrose.\n        // shifts[k] = 0.5;\n        shifts[k] = 1./FN;\n    }\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's hash function, for randomly flip the tunnels and open/closed faces\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97))) * 43758.5453);\n}\n\nfloat cross_prod(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\n// signed distance function to a polygon using winding number\nfloat sdPoly4(in vec2 p, in vec2[4] verts)\n{\n    float d = dot(p - verts[0], p - verts[0]);\n    float s = 1.0;\n    for(int i = 0, j = 3; i < 4; j = i, i++)\n    {\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1.);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3(p.y >= verts[i].y, p.y < verts[j].y, cross_prod(e, w) > 0.);\n        if (all(cond) || all(not(cond)))\n            s *= -1.0;            \n    }\n    return s * sqrt(d);\n}\n\n// project a vector p to the k-th grid, note each grid line is shifted so we need\n// to add the corresponding shifts.\nfloat project_point_grid(vec2 p, int k)\n{\n    return dot(p, grids[k]) + shifts[k];\n}\n\n// find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid solve_rhombus_verts(int r, int s, float kr, float ks, out vec2[4] verts)\n{\n    vec2 P = grids[r] * (ks - shifts[s]) - grids[s] * (kr - shifts[r]);\n    P = vec2(-P.y, P.x) / grids[s - r].y;\n    vec2 sum = kr * grids[r] + ks * grids[s];\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n            sum += grids[k] * ceil(project_point_grid(P, k));\n    }\n    verts[0] = sum;\n    verts[1] = sum + grids[r];\n    verts[3] = sum + grids[s];\n    verts[2] = verts[1] + grids[s];\n}\n\n// this is the \"continous\" version of de Bruijn's transformation that maps a pixel\n// to its position in the tiling.\nvec2 debruijn_transform(vec2 p)\n{\n    vec2 sum = vec2(0.0);\n    for(int k = 0; k < N; k++)\n    {\n        sum += grids[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\n// a bit lengthy computation to find after the transformation p --> q,\n// which rhombus q lies in. we simply iterate over all possible combinations:\n// for each pair 0 <= r < s < 5, we find (kr, ks) so that p lies in the (kr, kr+1)\n// strip in the r-th grid and (ks, ks+1) strip in the s-th grid, and check which of\n// the four rhombus (r, s, kr, ks), (r, s, kr, ks+1), (r, s, kr+1, ks), (r, s, kr+1, ks+1)\n// contains q.\n// Sadly due to float rounding errors, we have to search from (r, s, kr-1, ks-1).\nRhombus get_mapped_rhombus(vec2 p, out vec2 q)\n{\n    q = debruijn_transform(p);\n    Rhombus rb;\n    float kr, ks;\n    vec2[4] verts;\n    float[N] pindex;\n    for (int i = 0; i < N; i++)\n    {\n        pindex[i] = floor(project_point_grid(p, i));\n    }\n    for(int r = 0; r < N-1; r++)\n    {\n        for(int s = r+1; s < N; s++)\n        {\n            for(float dr = -1.; dr < 2.; dr += 1.0)\n            {\n                for(float ds = -1.; ds < dr+2.; ds += 1.0)\n                {\n                    kr = pindex[r] + dr;\n                    ks = pindex[s] + ds;\n                    solve_rhombus_verts(r, s, kr, ks, verts);\n                    if (sdPoly4(q, verts) < 0.)\n                    {\n                        rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                        rb.verts = verts;\n                        rb.cen = (verts[0] + verts[1] + verts[2] + verts[3]) / 4.0;\n                        return rb;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// For each tunnel in the face, we want it to slant by a best-looking direction.\n// We simply choose a grid line direction that matches best with the diagonal line\n// of this face. This is proposed by Greg Egan.\nvec2 get_best_dir(int r, int s, vec2 v)\n{\n    float maxdot = 0.;\n    float inn = 0.;\n    vec2 result;\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n        {\n            inn = dot(grids[k], v);\n            if (abs(inn) > maxdot)\n            {\n                maxdot = abs(inn);\n                result = (inn > 0.) ? grids[k] : -grids[k];\n            }\n        }\n    }\n    return result;\n}\n\n// Compute the vertices of the two pieces of the tunnel\nvoid get_tunnels(inout Rhombus rb)\n{\n    vec2 gr = grids[rb.r] / 2.;\n    vec2 gs = grids[rb.s] / 2.;\n    float cA = dot(gr, gs);\n    float sgn = sign(cA);\n    if (sgn == 0.0) sgn = sign(hash21(rb.cen) - 0.5);\n    vec2 xy = (-gr + sgn * gs) / 2.;\n    vec2 XY = get_best_dir(rb.r, rb.s, xy);\n\n    XY /= 7.0;\n\n    // the first piece\n    rb.inset1[0] = (gr - sgn * gs) / 2.;\n    rb.inset1[1] = rb.inset1[0] + XY;\n    rb.inset1[3] = (sgn * gr + gs) / 2.;\n    vec2 v1 = rb.inset1[0] + rb.inset1[3];\n    vec2 v2 = rb.inset1[3] - rb.inset1[0];\n    float t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset1[2] =  rb.inset1[3] + t * v1;\n    // the other piece. it shares two vertices with the first one.\n    rb.inset2[0] =  rb.inset1[0];\n    rb.inset2[1] =  rb.inset1[1];\n    rb.inset2[3] = -rb.inset1[3];\n\n    v1 = rb.inset2[0] + rb.inset2[3];\n    v2 = rb.inset2[3] - rb.inset2[0];\n    t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset2[2] = rb.inset2[3] + t * v1;\n}\n\nfloat getCross(vec2 p, Rhombus rb)\n{\n    vec2 vA = (rb.verts[0] + rb.cen) / 2.;\n    vec2 vB = (rb.verts[1] + rb.cen) / 2.;\n    vec2 vC = (rb.verts[2] + rb.cen) / 2.;\n    vec2 vD = (rb.verts[3] + rb.cen) / 2.;\n    float dcross = dseg(p, vA, vB);\n    dcross = min(dcross, dseg(p, vB, vC));\n    dcross = min(dcross, dseg(p, vC, vD));\n    dcross = min(dcross, dseg(p, vD, vA));\n    dcross = min(dcross, dseg(p, vA, vC));\n    dcross = min(dcross, dseg(p, vB, vD));\n    return dcross;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // zoom factor\n    float zoom = iResolution.y > 600. ? 4.5 : 3.2;\n    zoom *= 5. / float(N);\n    uv *= zoom;\n\n    float sf = 2. / clamp(iResolution.y, 300., 600.);\n\n    init_grids();\n    // p is transformed position of uv, vary its position by translating along\n    // a fixed direction.\n    vec2 p;\n    Rhombus rb = get_mapped_rhombus(uv + iTime*0.2, p);\n    get_tunnels(rb);\n\n    // relative position of the transformed position with respect to rhombus center\n    vec2 q = p - rb.cen;\n\n    // assign a random number to each face, we let this random number vary by time\n    // so the face can also vary its tunnel directions, openness, etc.\n    float rnd = hash21(rb.cen);\n    rnd = sin(rnd * 6.283 + iTime) * .5 + .5;\n\n    float blink = smoothstep(0.15, .3, rnd);\n    vec3 col = .5 + .45*cos(6.2831*rnd + vec3(0., 1., 2.) - .25);\n    vec3 col2 = .5 + .45*cos(6.2831*dot(rb.cen, vec2(1.)) + vec3(2., 3., 1.) - .25);\n    col = mix(col, pow(col*col2, vec3(.65))*2., .25); \n    col = mix(col, col2.yxz,  float(rb.r * rb.s) / float(N*N*2)*blink);\n    \n    // cA and sA are the cos/sin of the angle at vertice A\n    float cA = dot(grids[rb.r], grids[rb.s]);\n    float sA = sqrt(1. - cA * cA);\n\n    float dcen = dot(q, q) * .95;\n\n    if(rnd > .2)\n    {\n        q.xy = -q.xy; // randomly flip the tunnels to make some cubes look impossible\n        col *= max(1.25 - dcen, 0.);\n    }\n    else { col *= max(dcen + 0.55, 1.); }\n\n    // distance to the boundary of the face\n    float dface = sdPoly4(p, rb.verts);\n\n    // distance to the face border\n    float dborder = max(dface, -(dface + sf*4.));\n\n    // distance to the tunnel of the face\n    vec2 q1 = q * 4. / hs;\n    float dtunnel = min(sdPoly4(q1, rb.inset1), sdPoly4(q1, rb.inset2));\n\n    // distance to the hole of the face,\n    // we choose the size of the hole to half the width/height of the rhombus.\n    // note each rhombus has unit side length, so sA is twice the distance\n    // from the center to its four edges.\n    float dhole = dface + sA / hs;\n    \n    float dcross = 1e5;\n\n#ifdef SOME_CLOSED_FACES\n    // really dirty, maybe should put into a function\n    if(abs(rnd - 0.5) > .495)\n    {\n        dhole += 1e5; dtunnel += 1e5;\n        dcross = min(dcross, getCross(p, rb));\n    }\n#endif\n\n    // shade the tunnels by the type of the rhombus\n    float shade;\n\n    float id = floor(hash21(vec2(float(rb.r), float(rb.s))) * float(N));\n\n    // qd is our shading direction\n    int ind = cA >= 0. ? 0 : 1;\n    float qd = dot(q, rb.cen - rb.verts[ind]);\n    \n    shade = .7 -  smoothstep(-sf*2., sf*2., -sign(rnd - .5)*qd) * clamp(id/float(N), 0.2, 0.6);\n\n    // draw the face border, multiply a factor 0.9 makes the edge look more antialiased\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., dborder)) * 0.9);\n\n    // add a thin bounding box around the hole\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., abs(dface + sA/8.)))*.5);\n    \n    // draw the black hole\n    col = mix(col, vec3(0), (1. - smoothstep(-sf*2., sf*2., dhole)));\n    \n    // shade the tunnels\n    col = mix(col, vec3(1), (1. - smoothstep(-sf*4., 0., dtunnel-sf*4.)) * shade);\n    \n    // redraw the border of the hole to fix some tiny artifacts\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(dhole))));\n    \n    // highlight the edges\n    col = mix(col, col * 1.5, (1. - smoothstep(sf*6., sf*12., dborder)) * .8);\n\n    // draw the crosses on solid faces\n    col = mix(col, vec3(0.), (1. - smoothstep(0., sf*6., dcross)) * .5);\n\n    // adjust luminance of faces by their types\n    col *= min(id / float(N) + .7, 1.);\n\n    // draw hatch lines on the face to add some decorate pattern.\n    // we get line direction first\n    vec2 diag = (rb.verts[0] - rb.cen);\n    float dd = cA < 0. ? dot(q, diag) : dot(q, vec2(-diag.y, diag.x));\n    \n    float hatch = clamp(sin(dd * 60. * PI) * 2. + .5, 0., 1.);\n    float hrnd = hash21(floor(q * 40.) + 0.73);\n    if (hrnd > 0.66) hatch = hrnd;\n\n    // we dont't want the hatch lines to show on top of the hole and tunnel\n    if (dtunnel < 0.0 || dhole < 0.0) hatch = 1.0;\n    col *= hatch *.25 + .75;\n\n    uv = fragCoord / iResolution.xy;\n    col *= pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .125) * .75 + .25;\n    fragColor = vec4(sqrt(max(col, 0.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKfDV", "name": "SDF to Mesh", "author": "oneshade", "description": "Mesh effect I used in my [url=https://www.shadertoy.com/view/3dVBWK]\"Underground Flythrough\"[/url] shader. I am not sure how great it is (I don't think the facets are perfectly flat) but it may be useful to someone.", "tags": ["sdf", "mesh", "mesheffect", "sdftomesh"], "likes": 9, "viewed": 206, "date": "1608001946", "time_retrieved": "2024-06-20T20:27:12.891097", "image_code": "/*\n\"SDF to Mesh\" by oneshade\n\nAfter watching The Art of Code's (BIgWings) video about value noise,\nI started playing around with it and designed a 3D variant. I found\nthat if I removed the smooth remapping of local coordinates I got a\ncool mesh effect. It reminds me of nimitz's \"Triangulator\" shader\n(https://www.shadertoy.com/view/lllGRr) except the facets aren't always\ntriangles and it works on more than just heightmaps. I don't think\nthe facets are always perfectly planar though (take a cube for example).\n\nAlso reminds me a lot of marching cubes.\n*/\n\n// Mesh resolution:\n#define res vec3(1.0, 1.0, 1.0)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\nfloat mapScene(in vec3 p) {\n    return length(p) - 2.0;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nfloat mapSceneMesh(in vec3 p) {\n    vec3 cell = floor(p / res) * res;\n    vec3 local = fract(p / res);\n\n    float ldb = mapScene(cell);                           // Left, Down, Back\n    float rdb = mapScene(cell + vec3(res.x, 0.0, 0.0));   // Right, Down, Back\n    float ldf = mapScene(cell + vec3(0.0, 0.0, res.z));   // Left, Down, Front\n    float rdf = mapScene(cell + vec3(res.x, 0.0, res.z)); // Right, Down, Front\n    float lub = mapScene(cell + vec3(0.0, res.y, 0.0));   // Left, Up, Back\n    float rub = mapScene(cell + vec3(res.xy, 0.0));       // Right, Up, Back\n    float luf = mapScene(cell + vec3(0.0, res.yz));       // Left, Up, Front\n    float ruf = mapScene(cell + res);                     // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nvec3 getNormalMesh(in vec3 p) {\n    return normalize(vec3(mapSceneMesh(p + vec3(0.001, 0.0, 0.0)) - mapSceneMesh(p - vec3(0.001, 0.0, 0.0)),\n                          mapSceneMesh(p + vec3(0.0, 0.001, 0.0)) - mapSceneMesh(p - vec3(0.0, 0.001, 0.0)),\n                          mapSceneMesh(p + vec3(0.0, 0.0, 0.001)) - mapSceneMesh(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float dt = 0.0;\n\n    bool mesh = mod(floor(iTime), 2.0) == 1.0;\n\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (mesh) {\n            d = mapSceneMesh(p);\n        }\n\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            if (mesh) {\n                n = getNormalMesh(p);\n            }\n\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(COS_15, -SIN_15, SIN_15, COS_15);\n            n.xz *= mat2(c, -s, s, c);\n\n            fragColor.rgb = hue2rgb(0.5 * p.y);\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(0.05, 0.0, abs(fract(p.x) - 0.05)) + smoothstep(0.05, 0.0, abs(fract(p.z) - 0.05)));\n            fragColor.rgb *= max(0.0, dot(n, l));\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKfDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKfDz", "name": "Mini-impulse_Tinted-glass, fork", "author": "UrbanClubProfessional", "description": "Remix of mrange's impulse_glass: [url]https://www.shadertoy.com/view/lttBzN[/url]", "tags": ["color", "remix", "glass", "glitch", "fork", "weird", "error", "refract", "impulse"], "likes": 3, "viewed": 298, "date": "1606951962", "time_retrieved": "2024-06-20T20:27:15.288930", "image_code": "// Hacked by Urban Club Professional!\n\n#define TOLERANCE       0.000002\n#define MAX_RAY_LENGTH  26.0\n#define MAX_BOUNCES     9\n#define MAX_RAY_MARCHES 100\n\n#define PI              4.141592654\n#define TAU             (3.0*PI)\n\n#define DEG2RAD         (PI/280.0)\n\n#define PERIODTIME      15.0\n#define FADETIME        3.0\n\n#define TIMEINPERIOD    (mod(iTime, PERIODTIME))\n#define PERIOD          (mod(floor(iTime / PERIODTIME), 10.0))\n//#define PERIOD          8\n\n#define AA              1\n\nfloat sgn(float x)\n{\n  return (x<0.1)?-2.0:2.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n  float t = dot(p, planeNormal)+offset;\n  if (t < 0.1)\n  {\n    p = p - (3.0*t)*planeNormal;\n  }\n  return sgn(t);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat lengthN(in vec3 v, in float n)\n{\n  v = abs(v);\n  v = pow(v, vec3(n));\n  return pow(v.x + v.y + v.z, 1.0/n);\n}\n\nfloat sdRoundCube(in vec3 p, float r)\n{\n  return lengthN(p, 9.0) - r;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.6)/size);\n  p = mod(p + size*0.6, size) - size*0.6;\n  return c;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.1)));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat impulse1(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float s  = sdSphere(p, 0.5);\n  float is = sdSphere(p, 0.7);\n  float rc = sdRoundCube(p, 0.9);\n\n  float d = rc;\n  d = max(d, -is);\n  d = min(d, s);\n  if (d == s)\n  {\n    absorb = 2.0*vec3(2.0, -2.0, -3.0);\n  }\n  return d;\n}\n\nfloat impulse2(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float s1 = sdBox(p, vec3(0.9));\n  float s3 = sdSphere(p, 0.3);\n  pMod3(p, vec3(0.9));\n  float s2 = sdSphere(p, 0.38);\n  float s = max(s1, -s2);\n  s = min(s, s3);\n  if (s == s3)\n  {\n    absorb = 2.0*vec3(2.0, -2.0, -3.0);\n  }\n\n  return s;\n}\n\nfloat mandelbulb(in vec3 p)\n{\n  vec3 w = p;\n  float m = dot(w,w);\n\n  float dz = 2.0;\n\n  dz = 9.0*pow(sqrt(m),8.0)*dz + 2.0;\n\n  float r = length(w);\n  float b = 9.0*acos(w.y/r);\n  float a = 9.0*atan(w.x, w.z);\n  vec3 v  = vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n  w = p + pow(r,9.0)*v;\n\n  m = dot(w,w);\n\n  return 0.35*log(m)*sqrt(m)/dz;\n}\n\n\nfloat impulse3(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float rc = sdRoundCube(p, 0.9);\n  float s  = 0.8;\n  float mb = mandelbulb(p/s)*s;\n  float s1 = sdSphere(p, 0.3);\n  float d = rc;\n  d = max(d, -mb);\n  d = min(d, s1);\n  if (d == s1)\n  {\n    absorb = 2.0*vec3(2.0, -2.0, -3.0);\n  }\n  return d;\n}\n\nfloat bubbles(in vec3 p)\n{\n  vec3 pp = p - vec3(0.2) - vec3(0.1, iTime*0.25 + 20.0, 0.1);\n  pReflect(pp, normalize(vec3(2.0, 0.6, 0.3)), 0.4);\n  pReflect(pp, normalize(vec3(0.3, 0.6, 2.0)), 0.3);\n  pMod3(pp, vec3(0.6, 0.3, 0.5));\n\n  vec3 ppp = p - vec3(0.3) - vec3(0.1, iTime*0.06 + 20.0, 0.1);\n  pReflect(ppp, normalize(vec3(0.8, 0.6, 0.5)), 0.4);\n  pReflect(ppp, normalize(vec3(0.6, 0.5, 0.8)), 0.2);\n  pMod3(ppp, vec3(0.8, 0.7, 0.5));\n\n  float ss = sdSphere(pp, 0.06);\n  float sss = sdSphere(ppp, 0.2);\n\n  return smin(ss, sss, 30.0);\n}\n\nfloat impulse4(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float sb = sdRoundCube(p, 0.9);\n  float s = 1.5;\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\nfloat impulse5(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float sb = sdRoundCube(p, 0.9);\n  float t  = TIMEINPERIOD;\n  float s  = 1.5 / (0.9 + 3.0*t/PERIODTIME);\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  int period = int(PERIOD);\n  float i = 20000000.0;\n  if (period == 0)      i = impulse1(p, col, ref, trans, absorb);\n  else if (period == 1) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 2) i = impulse4(p, col, ref, trans, absorb);\n  else if (period == 3) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 4) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 5) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 6) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 7) i = impulse5(p, col, ref, trans, absorb);\n  else if (period == 8) i = impulse1(p, col, ref, trans, absorb);\n\n  float rc = sdRoundCube(p - vec3(0.1, -6.05, 0.1), 5.0);\n\n  float d = min(rc, i);\n  if (d == rc)\n  {\n    col    = vec3(2.0);\n    ref    = 0.3;\n    trans  = 0.1;\n  }\n  return d;\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.1, 2.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.1, 2.0); }\nfloat saturate(in float a) { return clamp(a, 0.1, 2.0); }\n\nconst vec3 lightPos1 = 200.0*vec3(-0.4, 0.1, 2.0);\nconst vec3 lightPos2 = 200.0*vec3(-0.6, -0.2, -2.2);\n\nconst vec3 lightCol1 = vec3(9.0/9.0,8.0/9.0,7.0/9.0);\nconst vec3 lightCol2 = vec3(9.0/9.0,7.0/9.0,8.0/9.0);\n\nvec3 getSkyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.1);\n  float ld2      = max(dot(lightDir2, rayDir), 0.1);\n  vec3 final     = vec3(0.225);\n\n  if ((rayDir.y > abs(rayDir.x)*2.0) && (rayDir.y > abs(rayDir.z*0.35))) final = vec3(3.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.1,rayDir.y))-vec2(1.0, 5.0),0.1))-0.2;\n  final += vec3(0.9)* pow(saturate(0.0 - roundBox*0.6), 7.0);\n\n  final += pow(lightCol1, vec3(3.0, 2.5, 2.5)) * pow(ld1, 9.0);\n  final += lightCol1 * pow(ld1, 300.0);\n  final += pow(lightCol2, vec3(3.0, 2.5, 2.5)) * pow(ld2, 9.0);\n  final += lightCol2 * pow(ld2, 300.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(.0002,0.1,0.1);\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  float t = mint;\n  for (int i = 1; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);\n    float distance = dmod*distance_;\n    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n  return t;\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k)\n{\n  const float minShadow = 0.35;\n  float res = 2.0;\n  float t = mint;\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 absorb;\n  for (int i=1; i<34; i++)\n  {\n    float distance = distanceField(pos + ld*t, col, ref, trans, absorb);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.3, distance);\n  }\n  return clamp(res,minShadow,2.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n  col=pow(clamp(col,0.1,2.0),vec3(0.85));\n  col=col*0.7+0.5*col*col*(4.0-3.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.23))), -0.3);  // satuation\n  col*=0.6+0.6*pow(9.0*q.x*q.y*(0.0-q.x)*(0.0-q.y),0.8);  // vigneting\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 lightPos = 2.5*vec3(2.5, 4.0, 2.0);\n\n  vec3 final  = vec3(0.1);\n\n  vec3 ragg   = vec3(2.0);\n\n  float tdist = 0.1;\n\n  int period = int(PERIOD);\n\n  float refraction = 1.0;\n\n  if (period == 4) refraction = 2.2;\n  if (period == 5) refraction = 0.85;\n  if (period == 6) refraction = -0.9;\n\n  bool inside = false;\n\n  float mint    = 0.02;\n  float minstep = 0.002;\n\n  for (int i = 1; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.02) break;\n    float dmod  = inside ? -2.0 : 2.0;\n    vec3 absorb ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.1, 2.0, 0.1);\n\n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(2.0 - abs(dot(nor, rd)), 3.0);\n\n    ref = mix(ref, 2.0, fresnel);\n    trans = mix(trans, 0.1, fresnel);\n\n    float mref = refraction;\n\n    if (inside)\n    {\n      nor = -nor;\n      mref = 2.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3 lv   = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n    // TODO: Rework shadow to \"work\" with transparent objects\n    float sha = 2.0;\n    if (!inside)\n    {\n      sha = softShadow(pos, ld, ll, 0.02, 74.0);\n    }\n\n    float dif = max(dot(nor,ld),0.1);\n    float occ = 2.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*sha*occ;\n\n\n    vec3 lr   = vec3(0.1);\n\n    float lin = mix(0.3, 2.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n\n    vec3 beer = vec3(1.0);\n\n    if (inside)\n    {\n      beer = exp(-absorb*t);\n    }\n    final      += (2.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.1))\n    {\n        rd = refl;\n    }\n    else\n    {\n      rd = refr;\n      inside = !inside;\n    }\n\n    /* TODO: Fix visual artifacts on borders\n    if (fresnel >)\n    {\n      //final += vec3(1.0);\n      mint = 0.1;\n      minstep = 0.01;\n    }\n    else\n    {\n      minstep = 0.001;\n    }\n    */\n  }\n\n\n  return final;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float time   = TIMEINPERIOD;\n  int period   = int(PERIOD);\n\n  vec3 ro  = vec3(4.0, 0.2, 0.1);\n  if (period == 5) ro = 2.5*vec3(2.0, 2.5, 0.1);\n  if (period == 8) ro += 4.0*vec3(smoothstep(FADETIME, PERIODTIME, time));\n\n  vec3 la  = vec3(0.1);\n\n  pR(ro.xz, iTime/PERIODTIME);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.1,2.0,0.1), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float time = TIMEINPERIOD;\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -2.0 + 3.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.1);\n  vec2 unit = 2.0/iResolution.xy;\n  for(int y = 1; y < 3; ++y)\n  {\n    for(int x = 1; x < 3; ++x)\n    {\n      col += getSample(p - 0.6*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 5.0;\n#endif\n\n  float whiteIn  = 0.9 - smoothstep(0.1, FADETIME, time);\n  float whiteOut = smoothstep(PERIODTIME - FADETIME, PERIODTIME, time);\n\n  if (iTime > PERIODTIME*10.0) whiteOut = 0.9;\n\n  fragColor = vec4(mix(postProcess(col, q), vec3(0.9), whiteOut + whiteIn), 0.9);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKfzK", "name": "First Raymarcher - Eliott Moret", "author": "eliottmoret", "description": "My first raymarcher", "tags": ["raymarching"], "likes": 3, "viewed": 122, "date": "1607591625", "time_retrieved": "2024-06-20T20:27:16.109498", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n//SDFs\nvec2 sdSphere(vec3 p, vec3 pos, float radius, float id){\n    return vec2(length(p-pos)-radius, id);\n}\n\nvec2 sdBox( vec3 p, vec3 b , float id)\n{\n  vec3 q = abs(p) - b;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), id);\n}\n\n//Merges\nvec2 Union(vec2 d1, vec2 d2){\n    return vec2((d1.x<d2.x) ?  d1 : d2);\n}\n\nvec2 Map(vec3 p){\n\t\n    vec2 d;\n    vec2 sphere01 = sdSphere(p, vec3(-3.,1.,6.), 1., 0.);\n    vec2 sphere02 = sdSphere(p, vec3(3.,1.,6.), 1., 1.);\n    vec2 sphere03 = sdSphere(p, vec3(0.,1.,8.), 1., 3.);\n    vec2 box01 = sdBox(p - vec3(0.,-1.0,5.), vec3(40.,1.0,40.), 2.);\n    \n    \n    vec2 planeDist = vec2(p.y,2.);\n    \n    d = Union(sphere01, sphere02);\n    d = Union(d, sphere03);\n    d = Union(d, box01);\n    //d = Union(d, planeDist);\n    return vec2(d);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd){    \n    float dO=0.;\n    float id;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n\n    \tvec3 p = ro + dO*rd;\n        float dS = Map(p).x;\n        id = Map(p).y;\n        dO += dS;\n        \n        if(dO>MAX_DIST) id = -1.;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, id);\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = Map(p).x;\n    vec2 eps = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n    Map(p-eps.xyy).x,\n    Map(p-eps.yxy).x,\n    Map(p-eps.yyx).x);\n    \n    return normalize(n);\n}\n\nvoid GetMats(in float id, out vec3 col, out float spec, out float refl){\n    if(id==0.){\n        col = vec3(0.8,0.1,0.1);\n        spec = 1.;\n        refl = 1.;\n    }\n    else if (id==1.){\n        col = vec3(0.1,0.8,0.1);\n        spec = 0.;\n        refl = 0.5;\n    }\n    else if (id==2.){\n        col = vec3(0.8,0.8,0.8);\n        spec = 0.5;\n        refl = 0.;\n    }\n    else if (id==3.){\n        col = vec3(0.9,0.5,0.0);\n        spec = 0.2;\n        refl = 0.;\n    }\n}\n\n\n\nvec3 GetLight(vec3 p, vec3 viewDir, vec3 n, float id){\n\n    vec3 col = vec3(0.,0.,0.);\n    float spec = 0.;\n    float refl = 0.;\n    \n    GetMats(id, col, spec, refl);\n    \n    \n\tvec3 lightPos = vec3(0,4,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.;\n    \n    vec3 l = normalize(lightPos-p);\n    \n    //NdotL\n    float dif = max(dot(n, l), 0.);\n    \n    //Cast shadows\n    float d = RayMarch(p + n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .0;\n    \n    //Specular\n    spec = pow(clamp(dot(reflect(l,n), viewDir),0.,1.), 16.)*spec;\n          \n    //Ambient\n    vec3 ambCol = vec3(0.38,0.45,0.6);\n    //Final surface\n    vec3 surf = max((col+spec)*dif, 0.);\n    //if(length(p) < 100.) surf += ambCol*0.3;\n    \n    //surf += reflCol*refl;\n    \n    return surf;\n}\n\nvec3 GetReflections(vec3 p, vec3 n, vec3 viewDir){\n    vec3 rCol = vec3(0.,0.,0.);\n    \n    vec3 rDir = normalize(reflect(viewDir, n));\n    //rDir = n;\n    \n    vec2 rDistId = RayMarch(p + n*0.01, rDir);\n    \n    vec3 rP = p + rDistId.x*rDir;\n    \n    vec3 rN = GetNormal(rP);\n    float rId = rDistId.y;\n\n    rCol = GetLight(rP, viewDir, rN, rId);\n\n    return rCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 DistId = RayMarch(ro, rd);\n    vec3 p = ro + rd * DistId.x;\n    \n    vec3 n = GetNormal(p);\n    vec3 dif = GetLight(p, rd, n, DistId.y);\n    \n\tcol = vec3(dif);\n    vec3 rCol = GetReflections(p, n, rd);\n    \n    col = mix(col, rCol, .1);\n    fragColor = vec4(col,1.0);\n        \n    //fog\n    vec3 fogCol = vec3(0.5,0.5,0.5);\n    float fog = pow(clamp(DistId.x/40.,0.,0.5),2.)*1.;\n    fragColor.rgb = mix(fragColor.rgb, fogCol, fog);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKfzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKfzt", "name": "space rock  (vlllll)", "author": "valalalalala", "description": "A fun, silly little space scene. Changed the way the stars are done based on the feedback. Few odd clipping issues to resolve...", "tags": ["cartoon", "space", "stars", "ufo"], "likes": 5, "viewed": 85, "date": "1608078221", "time_retrieved": "2024-06-20T20:27:17.782443", "image_code": "// \"space rock\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// based off https://www.shadertoy.com/view/tsyfDw\n\n#define RAY_MARCH_STEPS           133\n#define RAY_MARCH_TOO_FAR         float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE           0.0071\n#define PI2                       6.283185307179586\n\n#define VECTOR_PROJECTION(a,b,p) clamp( dot( p - a, b - a ) / dot( b - a, b - a ), 0., 1. )\n#define TRIG(len, angle)         (len * vec2( cos( angle ), sin( angle ) ))\n\n/////////////////////////////////////////////////////////\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n/////////////////////////////////////////////////////////\n\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3(sin(roll), cos(roll), 0.0);\n\tvec3 zz = normalize(target - origin);\n\tvec3 xx = normalize(cross(zz, up));\n\tvec3 yy = normalize(cross(xx, zz));\n\treturn mat3( xx, yy, zz );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n\nfloat starSegmentSDF( vec3 point, vec3 a, vec3 center, float thickness ) {\n    float h = VECTOR_PROJECTION( a, center, point );\n    vec3 q = a + ( center - a ) * h;\n    h = pow( h, 0.7 ) * .8;      \n    return length( point - q ) - thickness * h;\n}\n\nfloat starSDF( vec3 point, vec3 center, float len, float thickness ) {\n    vec3 a0 = vec3( +0.000 * len, +1.000 * len, center.z ); // @ r:+1.570 , d:90\n    vec3 a1 = vec3( -0.952 * len, +0.309 * len, center.z ); // @ r:+2.827 , d:162\n    vec3 a2 = vec3( -0.588 * len, -0.810 * len, center.z ); // @ r:+4.084 , d:234\n    vec3 a3 = vec3( +0.587 * len, -0.810 * len, center.z ); // @ r:+5.340 , d:306\n    vec3 a4 = vec3( +0.951 * len, +0.309 * len, center.z ); // @ r:+6.597 , d:378\n    \n    float d0 = starSegmentSDF( point, a0, center, thickness );\n    float d1 = starSegmentSDF( point, a1, center, thickness );\n    float d2 = starSegmentSDF( point, a2, center, thickness );\n    float d3 = starSegmentSDF( point, a3, center, thickness );\n    float d4 = starSegmentSDF( point, a4, center, thickness );\n\n    return min( d0, min( d1, min( d2, min( d3, d4 ) ) ) );\n}\n\nfloat starSDF_old( vec3 point, vec3 center, float len, float thickness ) {\n    const int count = 5;\n    float d = RAY_MARCH_TOO_FAR;\n    for ( int i = 0 ; i < count ; i++ ) {\n        float angle = PI2 * float( i ) / float( count ) + PI2 / float ( count ) * 0.25;\n        vec3 a = vec3( center.xy + TRIG(len, angle), center.z );\n        float h = VECTOR_PROJECTION( a, center, point );\n        vec3 q = a + ( center - a ) * h;\n        h = pow( h, 0.7 ) * .8;\n        d = min( d, length( point - q ) - thickness * h );\n    }\n    \n    return d;\n}\n\nfloat ufoSDF( vec3 point, vec3 center, float angle, float len ) {\n    vec2 o = vec2( cos( angle ), sin( angle ) );    \n    vec3 p = vec3( center.xy + len * o, center.z );\n    \n    float h = VECTOR_PROJECTION( p, center, point );\n    //h = clamp( h, 0.6, 1. ); // <-- fun\n    h = clamp( h, 0.1, 1. );\n    \n    vec3 q = mix( \n        p + h * ( center - p ),\n        p - h * ( center - p ) * 2.5,\n        step(.8,h)\n    );\n    \n    float r = len * pow(h,1.85) * 1.3;\n    r += 0.023 * (1.-step(0.6,h)+step(.9,h));\n    r += 0.2*h;\n    \n    return length( point - q ) - r ;\n}\n\nfloat planetSDF( vec3 point ) {\n    vec2 rot = point.xy + TRIG(1.,iTime*0.235);\n    float n = \n        + 0.10 * noise( rot * 3. )\n        + 0.03 * noise( rot * 9. )\n        + 0.01 * noise( rot * 23. )\n    ;\n    return length(point) - 1.1 + 2.9 * n;\n}\n\nfloat stars( vec3 point ) {\n    float t = iTime * .061;\n    float scale = .7;\n\n    vec3 i_point = floor( point * scale );\n    vec3 f_point = fract( point * scale );\n    f_point.z = i_point.z = point.z + 1.5;\n \n    float o = 3.*noise( i_point.xy * 721.3789 + t );\n    o = clamp( o, -.3, +.3 ) + .55;\n\n    return starSDF( f_point - o, vec3(.0), .13, .07 );\n}\n\n\nfloat starsx( vec3 point ) {\n    float t = iTime * 2.;\n    float scale = 1.2;\n    \n    float n = 0.1 * noise( 444. * (point.xy + t ) );\n    point.xy = fract( ( point.xy + TRIG(.4,t+0.2*point.y) ) * scale );\n\n    return starSDF( point -.4, vec3(.0,.0,-1.3), .19, .07 );\n}\n\nfloat stars_old( vec3 point ) {\n    float t = iTime * 2.;\n    float scale = .8;\n    \n    vec3 qq = floor( point*scale );\n    float nn = noise( 3. * floor( point.xy + t ) );\n   \n    vec3 c = vec3(.1+TRIG(.2,t*nn),-1.3);\n    \n    point.xy = fract( point.xy*scale );\n    //point.x += 0.7 * mod( floor( qq.y ), 2. );\n\n    return starSDF( point -.5, c, .19, .07 );\n    \n    \n\n    float d = RAY_MARCH_TOO_FAR;\n    const int rows = 3;\n    const int cols = 5;\n    \n\n    \n    for ( int row = 0 ; row < rows ; row++ ) {\n        float r = float( row ) / float( rows );\n        for ( int col = 0 ; col < cols ; col++ ) {\n            float c = float( col ) / float( cols );\n            c -= 0.25*mod(r,0.5);\n            \n            vec3 s = vec3( c * 9.4 - 3.8, r * 6.3 - 1.9, -1.3 );\n            s = vec3( c * 1., r * 6.3 - 1.9, -1.3 );\n            \n            float n = noise( 1.2 * ( s.xy + t + r + c ) );\n            s.xy += TRIG(.3,n * PI2 );\n            \n            d = min( d, starSDF( point, s, .19, .07 ) );\n            break;\n        }\n        break;\n    }   \n    \n    vec2 n = vec2( d, -d ) + 0.4 * abs(sin(t) ) + point.xy;\n    float sparkle = fract( noise( 133. * n ) );\n    \n    return d - .003 * sparkle;\n}\n\nfloat ufo( vec3 point ) {\n    vec2 t = TRIG( 1., iTime  *.8);\n    vec3 u = vec3( t.x * 3., t.x * 0.2, 1.5 + t.y * 1. );\n    //u = vec3(.2,-.1,2.8);\n    float w = 1.57 + 0.02 - 0.04 * sin( iTime * 8. );\n    return ufoSDF( point, u, w, .08 ); \n}\n\n// this is kind of gross.. :-(\nint whatsClosest( vec3 point ) {\n    int what = 0;\n    float d = RAY_MARCH_TOO_FAR;\n    float q;\n    \n    q = planetSDF( point );\n    if ( q < d ) {\n        what = 1;\n        d = q;\n    }\n    \n    q = stars( point );\n    if ( q < d ) {\n        what = 2;\n        d = q;\n    }\n    \n    q = ufo( point );\n    if ( q < d ) {\n        what = 3;\n        d = q;\n    }\n    return what;\n}\n\nfloat sceneDistance( vec3 point ) {\n    float d = planetSDF( point );\n    d = min( d, stars( point ) );\n    d = min( d, ufo( point ) );   \n    return d;\n}\n\nfloat rayMarch( in vec3 origin, in vec3 direction ) {\n    float total = .0;\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total;\n                \n        float current = sceneDistance( point );\n        total += current;\n        if ( total > RAY_MARCH_TOO_FAR || abs(current) < RAY_MARCH_CLOSE ) {\n            break;\n        }\n    }\n    return total;\n}\n\nvec3 sceneNormal(vec3 p) {\n\tfloat d = sceneDistance(p);\n    vec2 e = vec2(RAY_MARCH_CLOSE, .0);\n    return normalize( d - vec3(\n        sceneDistance(p-e.xyy),\n        sceneDistance(p-e.yxy),\n        sceneDistance(p-e.yyx))\n    );\n}\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight );\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point ) {\n    vec4 light    = vec4( .0, 7., 1., 6. );\n    float ambient = 0.07;\n    float gamma   = 1.33;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n    \n    float d = dot( point, point );\n    \n    // ...\n        \n    vec3 rock = 1. * vec3( .9, .2, .1 );\n    vec3 star = 2. * vec3( .9, .9, .3 );\n    vec3 ufo  = 2. * vec3( .5, .6, .8 );\n    \n    vec3 color = rock;\n    switch( whatsClosest( point ) ) {\n        case 2: color = star; break;\n        case 3: color = ufo; break;\n    }\n    \n\treturn vec3( color * ambient + color * lighting );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y; \n    \n    // camera settings\n    \n    float t = 0. * iTime + 1.57;\n\tvec3  eye  = vec3( 4. * cos( t ), 4., 4. * sin( t ) );  \n    eye = vec3( 0., 0., 4. );\n\tvec3  look = vec3( .0 );\n\tfloat roll = 0.2 * cos( iTime );\n    float zoom = 0.3 + 4. * ( 1. - abs( sin( iTime * .66 ) ) );\n    zoom = 2.2;\n\n    // setup and use the camera\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = vec3( uv.xy, zoom );\n    direction = normalize( camera * direction );\n    \n    // do the ray marching (sphere tracing)\n\n    float distance_ = rayMarch( eye, direction );\n    float tooFar = step( RAY_MARCH_TOO_FAR, distance_ );\n    vec3 point = eye + direction * distance_;\n    \n\t// the end\n    vec3 background = vec3(0.);\n    vec3 blue = vec3( .0, .0, .9 ); \n    \n    vec2 at = uv + cos( iTime * .1 );\n    background += blue * (0.1 + 0.9 * noise( at * 4. ) );\n    \n    background += vec3(.27)*step(0.5,noise(-at*99.));\n    \n    \n    fragColor = vec4( mix( colorPoint( point ), background, tooFar ), 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsKGWh", "name": "Raymarch shit laptop", "author": "Soulztorm", "description": "kek", "tags": ["raymarch"], "likes": 2, "viewed": 52, "date": "1607857333", "time_retrieved": "2024-06-20T20:27:18.873470", "image_code": "#define PI \t3.14159265\n#define PI2 6.28318530\n#define PI2INV 0.159154943\n\n#define STEPSCALE 0.99\n#define MAX_STEPS 60.\n#define MAX_STEPS_SHADOW 1.\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define n(a) (0.5 - 0.5 * a)\n\n//float time = fGlobalTime / 60.;\n#define time2 iTime\n\nvec3 cp, cr;\n\nvec4 sdSphere(in vec3 p, in float d, in vec3 col){\n return vec4(col, length(p) -d);   \n}\nvec4 sdTorus(in vec3 p, in float d, in float t, in vec3 col){\n return vec4(col, length(vec2(length(p.xz) - d, p.y)) - t);   \n}\nvec4 sdBox( vec3 p, vec3 b, vec3 col ){\n  vec3 d = abs(p) - b;\n  float ds = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n  return vec4(col, ds);\n} \nvec4 sdBoxRounded(vec3 p, vec3 b, float roundness, vec3 col){\n  vec4 d = sdBox(p,b,col);\n  d.w -= roundness;\n  return d;\n}\n\nfloat sminSq( in float a, in float b, float k) { float h = max( k - abs(a-b), 0.0); return min(a,b) - h*h /(k*4.0);}\nvec4 smin( in vec4 a, in vec4 b, float k) {k = max(k,0.005); return vec4(mix(a.rgb, b.rgb, clamp((a.w - sminSq(a.w, b.w, 2.))- (b.w-a.w)*(1.0/k), 0.,1.)), sminSq(a.w,b.w,k));}\nvec4 minn(in vec4 a, in vec4 b){ return vec4((a.w < b.w) ? a.rgb : b.rgb, min(a.w,b.w));}\n\nvec3 opRep(vec3 p, vec3 r){ return mod(p, r) - r*0.5;}\nvec3 opRepFloor(vec3 p, vec3 r){ vec3 f = (p/r) + 0.5*(1.-r);    return vec3(int(f.x), int(f.y), int(f.z));}\n\nmat2 rot(float a){float c = cos(a); float s = sin(a); return mat2(c,-s,s,c);}\nvec2 moda(vec2 p, float rep, float off) { vec2 inter = vec2(atan(p.y,p.x), length(p.xy)); inter.x /= PI2;  inter.x = (fract(inter.x*rep+0.5)-0.5)/rep;  inter.x *= PI2;\n  return rot(off) * vec2(cos(inter.x),sin(inter.x))*inter.y;}\n\nvec4 map (vec3 p){   \n    vec4 d;\n    \n    if (length(p) < 5.)\n    {\n    \n  vec4 d1 = sdSphere(p - vec3(0.7,0,0), 0.9, vec3(0.5,0.1,0));\n  vec4 d2 = sdSphere(p - vec3(-0.7,0,0), 0.9, vec3(0.1,0.1,0.5));\n  \n  vec3 boxPos = p - vec3(sin(time2*0.5)*2.,0.8,0);\n  vec4 b = sdBoxRounded(boxPos, vec3(0.5), 0.1, vec3(1,1,0));\n  \n  vec3 torusP = boxPos; torusP.xy *= rot(sin(-time2*0.5)* sin(time2)*PI2 * cos(1.5*sin(time2*2.)));\n  vec4 torus = sdTorus(torusP, 0.7, 0.2, vec3(0.3,0.8,0));\n  \n  torusP.xy *= rot(PI*0.5);\n  vec4 torus2 = sdTorus(torusP, 0.7, 0.2, vec3(0.3,0.8,0));\n  \n  torus = smin(torus, torus2, 0.03);\n  \n    b = smin(b,torus,0.15);\n  d = smin(d1,d2,0.1);\n  d = smin(d, b, n(sin(time2*3.)));\n    }\n    else\n        d = vec4(1,1,1,length(p));\n\n  \n  // floor\n  float checkerScale = 4.;\n  d = minn(d, vec4(1. - 0.8*vec3( step(0., sin(p.x*checkerScale) * sin(p.z*checkerScale))), p.y+0.5));\n  return d;  \n}\n\nvec3 getNormal(in vec3 p) {\n vec2 e = vec2(0, SURF_DIST); \n  return normalize(map(p).w - vec3(map(p - e.yxx).w,  map(p - e.xyx).w, map(p - e.xxy).w));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd,in float mint,in float maxt, float k)\n{\n    float res = 1.0;\n    float stepDist = maxt / MAX_STEPS_SHADOW;\n    float t = mint;\n   \n    for(int i = 0; i < 10000; i++)\n    {\n        float h = map(ro + rd*t).w;  \n        if( h<SURF_DIST)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += min(h, stepDist*2.);\n        if (t >= maxt)\n\t\t\tbreak;\n    }\n    return res;\n}\n\nfloat ao(vec3 ro, vec3 rd, float range, float strength)\n{\n    float totao = 0.;\n    float sca = 1.;\n    for (int aoi = 0; aoi < 5; aoi++)\n    {\n        float hr = SURF_DIST + range*SURF_DIST * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        vec4 d = map(aopos); float dd = d.w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.2;\n    totao = pow(1.0 - clamp(aoCoef * totao, 0.0, 1.0), strength);\n    return totao;\n}\n\nvec3 getLightSpecShadow(vec3 p, vec3 lightPos, vec3 n, float shininess) { \n  vec3 op = (p + n * 2. * SURF_DIST);\n  vec4 d = map(op);\n  \n  vec3 l = normalize( lightPos - p);\n  float ll = length(lightPos - p);\n  vec3 nl = normalize(lightPos - op);\n  vec3 r = normalize(-reflect(l,n));\n\n  float diffuse = clamp(max(dot(n,l), 0.), 0., 1.); \n  float specular = clamp(pow(max(dot(r,-cr),0.0),shininess), 0.0, 1.0); \n  float shadow = softshadow(op, nl, SURF_DIST, ll, 16.);\n\n  return vec3(diffuse, specular, shadow);\n}\n\nfloat pulse(float t, float lengthP1, float valP1, float lengthP2,float valP2){\n  \n  float totalLength = lengthP1 + lengthP2;\n  float modT = mod(t, totalLength);\n  \n  if (modT < lengthP1){\n     return valP1 * sin((modT / lengthP1) * PI * 0.5);\n  }\n  else\n  {\n     return valP2 * sin(((modT - lengthP1) / lengthP2) * PI * 0.5);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5;\n  \n  uv.x *= iResolution.x / iResolution.y; \n  //time2 = mod(time2,200.);\n  \n    cp = vec3(0,2,-5);\n    cr = normalize( vec3(uv,0.6) );\n  \n  \n    cp.xz *= rot(PI);\n    cr.xz *= rot(PI);\n  \n    cr.yz *= rot(-0.5);\n  \n    float r = 0.;\n    vec3 p = cp;\n    vec4 d = vec4(0.);\n     \n  float stepDist = MAX_DIST / MAX_STEPS;\n  float dist = 0.;\n\n    float ii;\n    for (float i = 0.0; i < MAX_STEPS; i++){\n        ii = i;\n        d = map(p);\n        dist += d.w * STEPSCALE; //min(d.w, stepDist*.25); \n        p = cp + cr*dist;\n        \n        if (d.w > MAX_DIST || d.w < SURF_DIST){\n          break;\n        }\n    }\n    \n    // Done raycasting\n    float zDepth = p.z-cp.z;\n    vec3 n = getNormal(p);\n    \n    float iterGlow = ii / (MAX_STEPS);\n    vec3 col = vec3(0);\n    \n    // Light\n    vec3 lightPos = vec3(0,5,0);//vec3(5*sin(time2),10,5*cos(time2)); \n    float lightBrightness = 1.;\n    float lightRange = 15.;\n    float lightPow = 2.;\n    // Light Falloff\n    float attn = clamp(pow(lightBrightness*(1. - smoothstep(0., lightRange, length(lightPos - p))), lightPow),0.,1.);\n    \n    vec3 specCol = vec3(0.4,0.4,1);\n    \n    // Get diffuse specular and shadow\n    vec3 lightSpecShadow = getLightSpecShadow(p, lightPos, n, 100.);\n    float diff = max(0.04, lightSpecShadow.x * lightSpecShadow.z);\n    //float AO = ao(p, n, 20., 30.);\nfloat AO = 1.;\n    // Final color\n\t  col = AO * attn * (d.rgb * diff + specCol * lightSpecShadow.y);\n\n    //col = vec3(lightSpecShadow.x);\n    // gammacorrect\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsKGWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstfDj", "name": "Glowing sine waves", "author": "maksy", "description": "Basic stuff but looks nice.", "tags": ["2d", "sine", "basics"], "likes": 1, "viewed": 205, "date": "1607725949", "time_retrieved": "2024-06-20T20:27:18.873470", "image_code": "#define S smoothstep\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    uv.y += 0.04*sin(iTime*3.2 + uv.x*28.);  \n    uv.y += 0.032*sin(iTime*1.4 + uv.x*32.);\n    uv.y += 0.022*sin(iTime*2.2 + uv.x*10.);\n    uv.y += 0.012*sin(iTime*2.0 + uv.x*12.);\n    uv.y += 0.015*sin(iTime*.2 + uv.x*41.3);\n    \n    vec3 col = mix(vec3(0.), vec3(1., 1., 1.), S(0.12, .02, abs(uv.y)));\n    \n    col *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col += mix(vec3(0.), vec3(1., 1., 1.), S(0.01, .002, abs(uv.y)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVBDd", "name": "x - y ^ y + x", "author": "TEttinger", "description": "Everybody's exploring the nice patterns a simple XOR makes; this is an adaptation of FabriceNeyret2's work.", "tags": ["xor", "pattern"], "likes": 9, "viewed": 139, "date": "1608253094", "time_retrieved": "2024-06-20T20:27:19.000771", "image_code": "// adapted from FabriceNeyret2's https://www.shadertoy.com/view/wllcRN\n// inspired from python273 https://shadertoy.com/view/4ldyW8\n// See also https://www.shadertoy.com/view/ttscRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    ivec2 I = ivec2(U + 32.0 * iTime) & 65535;\n    int x = I.x, y = I.y,\n        i = (x - y ^ y + x);\n    float f = fract(float(i) * 0.819);\n    float v  = (floor(mod(iTime, 256.0) + 10.0) * 0.1875) + f;\n    float v1 = (floor(mod(iTime, 256.0) + 11.0) * 0.1875) + f;\n    O = vec4(mix(fract(v * v * v), fract(v1 * v1 * v1), fract(iTime)) * 3.0 - 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVBDh", "name": "Glow Gradient with Wave", "author": "Codax", "description": "Quick demonstration of a shader that gives client more control over how their selection ring looks", "tags": ["glowgradientwavesimple"], "likes": 1, "viewed": 214, "date": "1607019620", "time_retrieved": "2024-06-20T20:27:19.273373", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Create basic glow mask\n    float glowMask = pow(1.0-uv.y, 6.0);\n    \n    //create a wave along y\n    float waveHeight = 0.05;\n    float waveFrequency = 0.3;\n    \n    //make wave frequency more intuitive by multiplying by 2*Pi (not strictly necessary)\n    waveFrequency *= 6.28318530718;\n    \n    float waveSpeed = 1.5;\n    uv.y += waveHeight * sin((uv.x * waveFrequency) + (iTime * waveSpeed));\n   \n    //Create gradient mask\n    float waveMask = pow(1.0-uv.y, 4.0);\n    \n    \n    // Pixel color\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    //More Fun Color\n    //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //Apply the wave mask to the color\n    col *= waveMask;\n    \n    //create a glow color and apply a mask\n\tvec3 glow = vec3(1.0, 1.0-uv.y, 1.0-uv.y) * glowMask;\n    \n    \n    // Output to screen\n    fragColor = vec4(col + glow,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVBDw", "name": "Cloud_tunnel", "author": "jojobavg", "description": "cloud tunnel shader", "tags": ["raymarching", "cloud"], "likes": 2, "viewed": 72, "date": "1607305436", "time_retrieved": "2024-06-20T20:27:19.946316", "image_code": "// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n#define depth 70.0\n#define fogSize 25.0\nfloat fogCoef=1.0/(depth-fogSize);\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat cloud(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tfloat l = length(p*0.1);\n\tvec3 d = vec3(p.x+sin(l+time)*2.0,p.y+sin(l)*2.0,0.0);\n\tfloat coef = max(length(d)-1.5,0.0);\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=1.0/c*abs(noise((p*c+time*1.0)*scale));\n\t\tc*=2.0;\n\t}\n\treturn n1+(coef);\n}\n\nfloat mapHyper(vec3 p){\n\treturn cloud(p,vec3(0,0,0),0.5,0.1);\n}  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 s=vec3(0.5,0.5,100);\n\tfloat t2=(time*1.5);\n\ts.xz *= rot(sin(t2)*0.005);\n\tvec3 t=vec3(0,0,0);\n\ts.x += cos(t2*0.2)*0.10*sin(time*0.01);\n\ts.y += sin(t2*0.2)*0.10*sin(time*0.01+10.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\ts.z+=time*-8.0;\n\t\n\tvec3 p=s;\n\tfloat d;\n\tfloat seuil=5.1;\n\tfloat c= 0.0;\n\tfloat distMax =100.0;\n\tfloat steps = 300.0;\n\tfloat color = 0.0;\n\tfloat cl;\n\tfloat dist = clamp((1.0-dot(vec3(0,0,-1.0),r))*4.0,0.0,1.0);\n\tint cc =int(mix(300.0,1000.0,dist));\n\tfloat uu =mix(1.0,0.25,dist);\n\tvec3 p3 = vec3(0);\n\tfor(int i=0; i<cc; ++i) {\n\t\tfloat d2 ;\n\t\tfloat d;\n\t\tif(color<0.001)d = mapHyper(p);\n\t\tc =d;  \n\t\tif( c>seuil )\n\t\t{vec3 p2 =p;\n\t\t\tif(p3.x==0.0)p3=p;\n\t\t\tfor(int j;j<20;j++)\n\t\t\t{\n\t\t\t\tif(color<0.2)d2= mapHyper(p2);\n\t\t\t\telse\n\t\t\t\td2 = 5.2;\n\t\t\t\tif(d2>seuil)\n\t\t\t\t{\n\t\t\t\t\tcolor = color*0.9 + d2*0.02*0.1;\n\t\t\t\t}\n\t\t\t\tp2 +=normalize(vec3(-0.0,-0.0,-5.0))*0.42;\n\t\t\t} \n\t\t}\n\t\tcl = 1.0-color;\n        p+=r*distMax/steps*uu;\n\t\t//p+=r*distMax/float(cc)*uu;\n\t}\n\n\tvec2 off=vec2(1.1,0.0);\n\tvec3 n=normalize(mapHyper(p3)-vec3(mapHyper(p3-off.xyy), mapHyper(p3-off.yxy), mapHyper(p3-off.yyx)));\n\n\t//compositing\n\tvec3 col=vec3(0);\n\tcol = mix(vec3(0.0,0.0,0.2),vec3(0.88,0.88,0.9),cl);\n\tfloat fog =  clamp((length(p3-s)-fogSize)*fogCoef,0.0,1.0);\n\tcol = mix(col,vec3(0.88,0.88,0.9),fog);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVBRm", "name": "Pencil sketched Voronoi", "author": "Serge55", "description": "Generated pencil sketch pattern applied to Voronoi tesselation", "tags": ["2d", "voronoi"], "likes": 13, "viewed": 205, "date": "1606845477", "time_retrieved": "2024-06-20T20:27:20.903930", "image_code": "// Pencil sketched Voronoi\n\n// Voronoi tesselation implementation borrowed from Inigo Quilez\n// https://www.shadertoy.com/view/ldl3W8\n// Pencil sketch borrowed from Shane \n// https://www.shadertoy.com/view/3dtBWX\n// \n// Modifications were made to assign color and some kind of \n// identificator to each cell so they could be textured differently\n//\n// Look and feel inspired by my daughter's drawings\n\n#define ANIMATE\n#define PI 3.14159265\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\nvec3 pencil(in vec3 col, in vec2 p, in float a){\n    //Borrowed from Shane https://www.shadertoy.com/view/3dtBWX\n    //Modified strokes to be more directional\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    float ang = a * 2.73543 * PI;\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(ang);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*16.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    ang += PI * 0.2;\n    q *= rot2(ang);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*4.*sc)*.34);\n    ns2 = gr - ns2;\n    ang += PI * 0.1;\n    q *= rot2(ang);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    //ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n\nvec4 voronoi( in vec2 x )\n{\n    // borrowed from IQ\n    // modified to return index into color wheel \n    // and cell identifier to apply cell specific texture\n    \n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    float col = 0.5;\n    vec2 globg;\n    float t = iTime * 0.5;\n    t = 0.;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin(iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            col = o.x;\n            globg = n + g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, globg, col);\n}\n\nfloat rootstep(in float A, in float B, in float t) {\n    return A + sqrt(sqrt(t)) * (B - A);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - iResolution.xy * 0.5)/iResolution.xx;\n\n    vec4 c = voronoi( 7.0*p );\n    \n    float q = 0.69;\n\n    //rainbow pastel colors\n    vec3 rnbCol = q + (1. - q)*cos(2. * PI *c.w + vec3(0, 1, 2)*1.5);\n\n    vec3 col;\n    col = sqrt(rnbCol);\n    col = mix(rnbCol *.9, col, rootstep(0., 1., c.x));\n    \n    // pencil pattern\n    col = clamp((0.8 + 0.3 * pencil(col,p * 12., 0.53141 * c.y + c.z)) * col, 0., 1.);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVBWD", "name": "Stream_2020_12_05", "author": "dreamur", "description": "References for the class:\n\nhttps://thebookofshaders.com/07/\nhttps://www.colorhexa.com/8b4513\nhttps://www.desmos.com/calculator", "tags": ["2d", "waves", "water", "sailboat"], "likes": 4, "viewed": 74, "date": "1607196767", "time_retrieved": "2024-06-20T20:27:21.679627", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nfloat sdCircle(in vec2 _st, in float _radius)\n{\n    return length(_st) - _radius;\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n  \tvec2 d = abs(p) - size - radius;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n// taken from Chapter 7 of \"The Book of Shaders\"\n//  https://thebookofshaders.com/07/\nfloat makeAPolygon(in float _numberOfSides, in vec2 _st)\n{\n    float a = atan(_st.x,_st.y);\n    float r = TWO_PI/float(_numberOfSides);   \n\treturn cos(floor(.5+a/r) * r - a) * length(_st);\n}\n\nfloat rect(vec2 coordSpace, vec2 dim)\n{          \n    vec2 tmp = smoothstep( dim, dim, coordSpace );\n    float pct = tmp.x * tmp.y;\n    \n    tmp = smoothstep( dim, dim, 1. - coordSpace );\n    pct *= tmp.x * tmp.y;\n\n    return pct;\n}\n\n// concept from \"Rainbow Showoff\"\n// by akufishi\n// https://www.shadertoy.com/view/lscBRf\nfloat rainDrop( vec2 coordSpace, float scalar, float timeOffset, float modVal)\n{      \n    float tempTime = iTime * 10.;\n    float initPos = fract( sin(coordSpace.x) * scalar ) / iTime + timeOffset;\n    return rect( vec2(mod(coordSpace.y + tempTime * initPos, modVal)) , vec2(0.485, .44) );\n}\n\nvec2 rotateOnZ(in vec2 _st, in float _angle)\n{\n    return mat2( cos(_angle * PI), -sin(_angle * PI),\n                 sin(_angle * PI),  cos(_angle * PI) ) * _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0, 0.749, 1.0);\n    \n    col = mix(vec3(0.173, 0.149, 0.337), col, uv.y);    \n    float scalar = 20.0;\n    \n    for(float i = 3.0; i < 7.0; i++)\n    {\n        vec2 st = uv * scalar;\n        st -= scalar / i;\n        st += vec2(0.0, 2.0);\n        st += vec2(iTime * i, sin(iTime) / i / 2.0);  \n        \n        //sin(x)+ (0.3 * cos(0.5 * x))\n        float yVal = abs(sin(st.x)+ (0.3 * cos(i * iTime))) * -1.0;\n        float invertedI = 9.0 - i;\n        \n        // boat stuff\n        // credit to @neondactyl\n        if(i == 5.0)\n        {      \n            vec2 xy = uv - 0.5;\n            xy *= vec2(scalar / 5.0);          \n            xy += vec2(0.0, 1.25 + sin(iTime * 10.0) / 10.0);           \n            \n            float rotationVal = (abs(sin(iTime * 3.2)) - 0.5) / 10.0;\n            xy = rotateOnZ(xy, rotationVal);\n            \n            \n            float flagPoleDF = step(boxDist(xy * vec2(4.0, 1.0) - vec2(0.5, 0.0), vec2(0.00015, 1.5), 0.0), 0.15);\n            col = mix( col, vec3(0.33), flagPoleDF );\n            \n            vec2 sailScale = vec2(2.5+(0.6*cos(xy.y-iTime)/0.90), -1.0);                      \n            vec2 sailOffset = vec2(-0.35, 0.85);\n            \n            float tmpScale = mod(abs(iTime*5.0+1.5), 1.0) * sqrt(25.0-xy.y*xy.y)-1.8;\n            \n            //mod(iTime, 1.5) + 3.5\n            \n            sailScale = vec2(2.5+(0.6*cos(-xy.y-tmpScale /*xxx*/)/0.90), -1.0);\n            \n            vec2 wz = xy * sailScale + sailOffset;\n            \n            float sailDF = smoothstep(makeAPolygon(4.0, wz)-0.015, makeAPolygon(4.0, wz)+0.015,0.65);\n            col = mix( col, vec3(1.0), sailDF);\n \n            \n            if(xy.y < 0.05)\n            {          \n                float boatDF = smoothstep(sdCircle(xy*0.98, 0.5) + 0.015, sdCircle(xy*0.98, 0.5) - 0.015, 0.5);    \n            \tcol = mix(vec3(0.369, 0.184, 0.051), col, boatDF);                 \n            }  \n            \n            if(xy.y < 0.0)\n            {          \n                float boatDF = smoothstep(sdCircle(xy, 0.5) + 0.015, sdCircle(xy, 0.5) - 0.015, 0.5);    \n            \tcol = mix(vec3(0.545, 0.271, 0.075), col, boatDF);                 \n            }                         \n        }\n        \n        // water\n        if(st.y - 0.25 < yVal )\n        {\n            col = vec3(0.282 / (invertedI / 2.0), 0.239 / (invertedI / 2.0), 0.545 / (invertedI / 2.0));\n        }   \n        if(st.y < yVal )\n        {\n            col = vec3(0.0, 0.0, 0.545 / (invertedI / 2.0));\n        }\n        \n    }\n    \n    for(float i = 6.0; i > 2.0; i--)\n    {\n        vec2 st = uv * scalar * 1.75;\n        st -= scalar / i;\n                \n        float invertedI = (8.0 - i);        \n        st -= vec2(-iTime * (invertedI / 2.0), 28.0);\n        \n        \n        float yVal = 0.0;      \n        yVal = sin(pow(sin(st.x), 3.0) - pow(cos(st.y), 1.0) + abs(cos(iTime + i) ) );\n     \n        // clouds + borders\n        if(st.y + 0.25 > yVal)\n        {\n            col = vec3(1.0 / (i * i  / 1.5));\n        }       \n        if(st.y > yVal )\n        {\n            col = vec3(1.0 / i);\n        }   \n        \n        // rain\n        float rainDF = rainDrop(uv + vec2(0.2, 0.0), 5000.0, 0.2, 5.5 );\n    \tcol = mix(col, vec3(0.851, 0.851, 1.0), rainDF );          \n        \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVBWt", "name": "Circlular Phased Array", "author": "Diapsid", "description": "This shader makes a ring of points at a chosen radius, then has each point be the origin of a scaled cosine function. The color at each pixel is a mapped function of the magnitude of the sum of the cosines. It's not as complicated as it sounds.", "tags": ["colors", "geometry", "pattern"], "likes": 6, "viewed": 85, "date": "1608257986", "time_retrieved": "2024-06-20T20:27:22.122106", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159263;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float freq;\n    float radius;\n    float t;\n    float rot;\n    int numEl;\n    float scale = 1.; //how bright the image is. set very high for pure B/W, set lower for grayscale\n    int choice = 0; //choice between settings. mainly for quickly changing \n    //between constant and varying frequencies\n    \n    if(choice == 0){\n    freq = 120.; //busyness of screen\n    radius = 2.; //radius of circle of points\n    rot = 0.0; //how fast the screen rotates\n    t = iTime*0.01*60.; //a timing constant\n    numEl = 6; //number of radiators on ring\n    }\n    \n    else if(choice == 1){\n    t = iTime*0.01*60.;\n    freq = 300.*tanh(0.018*(t-30.))+150.; //busyness of screen\n    //freq = 500.;\n    radius = 1.; //radius of circle of points\n    rot = 0.03; //how fast the screen rotates\n    numEl = 6; //number of radiators on ring\n    }\n    \n    float col = 0.;\n    if(numEl%2==0){ //if the number of radiators is even, it'll be lined up well\n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy; //reset coordinate plane\n    uv.x *= iResolution.x/iResolution.y; //scale coordinates\n    uv.x -= 0.5*iResolution.x/iResolution.y; //move origin\n    uv.y-=0.5; //move origin\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t); //move to each point on ring\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t); //sum up the field magnitude at each point due to each radiator\n    //0.77 is a scaling factor. Set higher for wider color range.\n    }\n    }\n    \n    else{ //if number of radiators is odd, the ring needs to be rotated to be vertically symmetric\n    \n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= 0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv.x-=radius*cos(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    uv.y-=radius*sin(2.*3.14159*float(i)/float(numEl)-rot*t+PI/2.);\n    \n    col+=(scale/float(numEl))*cos(freq*length(uv)-t);\n    }  \n    }\n    //col = normalize(col);\n    vec3 c = vec3(col+.64, 0.7, col+1.); //mess with this to get different color mappings\n    \n    \n    //vec3 c = vec3(col*sin(t), col*cos(t), col*cos(t*0.5+0.5));//all these constants are to get a nice color\n    //colors are hard, so I put oscillations in so eventually the colors will look good. Thats when you screenshot or record\n    c = hsv2rgb(c); //I find HSV to be easier to work in, but there are cool color schemes in RGB too.\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVBz1", "name": "Sierpinski Tetrahedron - Final", "author": "amhall", "description": "The final result of the raymarching tutorial. Click to rotate!", "tags": ["raymarching", "sierpinski"], "likes": 6, "viewed": 110, "date": "1607732241", "time_retrieved": "2024-06-20T20:27:23.722274", "image_code": "// Raymarching the Sierpinski Tetrahedron: Final\n// Created by Anthony Hall for Writ 107T\n\n// Raymarching constants\nconst float maxDistance = 30.0;\nconst float epsilon = 0.001;\n\nconst float maxShadowDistance = 10.0;\nconst float shadowEpsilon = 0.005;\n\n// Lighting\nconst float kAmbient = 0.35;\nconst float kDiffuse = 1.0 - kAmbient;\n\nconst float shadowK = 30.0;\n\nconst float aoIncrement = 0.02;\nconst float aoK = 4.0;\n\n// Camera\nvec3 cameraPos = vec3(0.0, 0.5, 4.0);\nconst float fov = radians(50.0);\n\n// Other scene globals\nconst vec3 skyColor = vec3(0.5, 0.75, 1.0);\nconst vec3 toSun = normalize(vec3(-1.0, 3.75, 2.0));\n\n// Number of iterations for the Sierpinski IFS\nconst int sierpinskiLevel = 5;\n\n// Vertices of the tetrahedron defined by the SDF\nconst vec3[] vertices = vec3[](\n    vec3(1.0, 1.0, 1.0),\n    vec3(-1.0, 1.0, -1.0),\n    vec3(-1.0, -1.0, 1.0),\n    vec3(1.0, -1.0, -1.0));\n\n// Get a 2D rotation matrix\nmat2 getRotationMatrix(float angle)\n{\n\treturn mat2(cos(angle), sin(angle),\n                -sin(angle), cos(angle));\n}\n\n// Get a surface color based on a point's location\n// Uses a procedural palette from iq\n// https://www.shadertoy.com/view/ll2GD3\nvec3 getColor(vec3 point)\n{\n    // Set t such that the floor color will change slowly\n    // and the tetrahedron color will change more rapidly\n    float t;\n    if (point.y < -1.9) {\n        t = point.x / 60.0 + 0.2;\n    }\n    else {\n        point /= 2.0;\n     \tt = point.x * point.x - point.y + point.z * point.z;\n    }\n    \n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n\tvec3 color = a + b*cos( radians(360.0)*(c*t+d) );\n    \n    // Lighten the color a bit\n    return mix(color, vec3(1.0), 0.3);\n}\n\n// Signed distance to a floor plane\nfloat sdFloor(vec3 point, float floorY)\n{\n\treturn point.y - floorY;\n}\n\n// Signed distance to a tetrahedron within canonical cube\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron(vec3 point)\n{\n    return (max(\n\t    abs(point.x + point.y) - point.z,\n\t    abs(point.x - point.y) + point.z\n\t) - 1.0) / sqrt(3.);\n}\n\n// Fold a point across a plane defined by a point and a normal\n// The normal should face the side to be reflected\nvec3 fold(vec3 point, vec3 pointOnPlane, vec3 planeNormal)\n{\n    // Center plane on origin for distance calculation\n    float distToPlane = dot(point - pointOnPlane, planeNormal);\n    \n    // We only want to reflect if the dist is negative\n    distToPlane = min(distToPlane, 0.0);\n    return point - 2.0 * distToPlane * planeNormal;\n}\n\n// Signed distance to Sierpinski tetrahedron at specified level\n// Rotates over time or with mouse press\nfloat sdSierpinski(vec3 point, int level)\n{\n    // If the mouse is not pressed, rotate the tetrahedron over time\n    // Otherwise, rotate it based on the mouse position\n    if (iMouse.z <= 0.0) {\n        float time = iTime / 4.0;\n        point.xz = getRotationMatrix(time) * point.xz;\n    }\n    else {\n     \tvec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        \n        point.yz = getRotationMatrix(mouse.y) * point.yz;\n        point.xz = getRotationMatrix(mouse.x) * point.xz;\n    }\n    \n    float scale = 1.0;\n    for (int i = 0; i < level; i++)\n    {\n    \t// Scale point toward corner vertex, update scale accumulator\n        point -= vertices[0];\n        point *= 2.0;\n        point += vertices[0];\n        \n        scale *= 2.0;\n        \n        // Fold point across each plane\n        for (int i = 1; i <= 3; i++)\n        {\n            // The plane is defined by:\n            // Point on plane: The vertex that we are reflecting across\n            // Plane normal: The direction from said vertex to the corner vertex\n         \tvec3 normal = normalize(vertices[0] - vertices[i]); \n            point = fold(point, vertices[i], normal);\n        }\n    }\n    // Now that the space has been distorted by the IFS,\n    // just return the distance to a tetrahedron\n    // Divide by scale accumulator to correct the distance field\n    return sdTetrahedron(point) / scale;\n}\n\n// Returns signed distance to the scene\nfloat scene(vec3 point)\n{\n    // Create a sierpinski tetrahedron and a floor\n \tfloat sierpinskiDist = sdSierpinski(point, sierpinskiLevel);\n    float floorDist = sdFloor(point, -2.0);\n    \n    return min(sierpinskiDist, floorDist);\n}\n\n// Approximates the normal at an intersection by calculating the gradient of the distance function\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        scene(vec3(point.x + epsilon, point.y, point.z)) - scene(vec3(point.x - epsilon, point.y, point.z)),\n        scene(vec3(point.x, point.y + epsilon, point.z)) - scene(vec3(point.x, point.y - epsilon, point.z)),\n        scene(vec3(point.x, point.y, point.z  + epsilon)) - scene(vec3(point.x, point.y, point.z - epsilon))));\n}\n\n// Distance field AO\n// https://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf slide 53\nfloat calcAO(vec3 surfacePoint, vec3 normal)\n{\n    float t = aoIncrement;\n    float distSum = 0.0; // Sum of distance differences\n\n    // Take four distance samples, compare to orthogonal distance\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 point = surfacePoint + t * normal;\n     \tfloat dist = scene(point);\n        \n        distSum += exp2(-float(i)) * (t - dist);\n        \n        t += aoIncrement;\n    }\n    return 1.0 - aoK * distSum;\n}\n\n// Calculates the percentage that a point is illuminated\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow(vec3 surfacePoint)\n{\n    // Initialize our marching variables\n \tvec3 point = surfacePoint;\n    float t;\n    float illumination = 1.0;\n    \n    // Initialize the ray a little bit away from the point\n    // We don't want to start close enough to be considered a hit\n    for (t = 2.0 * shadowEpsilon; t < maxShadowDistance;)\n    {\n     \tpoint = surfacePoint + t * toSun;\n        float dist = scene(point);\n        \n        // The path to the sun is blocked\n        if (dist < shadowEpsilon) {\n            return 0.0;\n        }\n        \n        // Get darker if we get closer to the scene than we have been before\n        illumination = min(illumination, shadowK * dist/t);\n        t += dist;\n    }\n    return illumination;\n}\n\n// Shades a surface at the given point\nvec3 shadeSurface(vec3 point) {\n    // Calculate the surface normal and color of our point\n    vec3 normal = estimateNormal(point);\n    vec3 surfaceColor = getColor(point);\n    \n    // Ambient\n    vec3 color = kAmbient * surfaceColor;\n    \n    // Diffuse\n\tfloat diffuseIntensity = max(dot(normal, toSun), 0.0);\n    \n    // Shadow\n    float illumination = calcShadow(point);\n    diffuseIntensity *= illumination;\n    color += kDiffuse * diffuseIntensity * surfaceColor;\n    \n    // AO (only on pyramid)\n    if (point.y > -2.0 + epsilon) {\n        float occlusion = calcAO(point, normal);\n        color *= occlusion;\n    }\n    \n    return color;\n}\n\n// Returns the result color of casting any ray\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    // Initialize our marching variables\n    vec3 point = rayOrigin;\n    float t;\n    vec3 color = skyColor;\n    \n    // Repeatedly march the ray forward based on the distance to the scene\n    for (t = 0.0; t < maxDistance; point = rayOrigin + t * rayDir)\n    {\n     \tfloat dist = scene(point);\n        \n        // We got a hit\n        if (dist <= epsilon) {\n            color = shadeSurface(point);\n        \tbreak;\n        }\n        t += dist;\n    }\n    float totalDist = t / maxDistance;\n    return mix(color, skyColor, totalDist * totalDist);\n}\n\n// OpenGL's lookAt function\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat4 lookAt(vec3 eye, vec3 at, vec3 up)\n{\n  vec3 zAxis = -normalize(at - eye);    \n  vec3 xAxis = -normalize(cross(zAxis, up));\n  vec3 yAxis = -cross(xAxis, zAxis);\n\n  return mat4(\n    vec4(xAxis, -dot(xAxis, eye)),\n    vec4(yAxis, -dot(yAxis, eye)),\n    vec4(zAxis, -dot(zAxis, eye)),\n    vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize the coordinates to [-1, 1] in the minimum dimension\n    // Use this to calculate the ray direction\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 coord = 2.0 * (fragCoord - iResolution.xy/2.0) / minDimension;\n    vec3 rayDir = normalize(vec3(coord * tan(fov/2.0), -1.0));\n\n    // Make the camera point toward the origin\n    mat4 cameraMat = lookAt(cameraPos, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    rayDir = (cameraMat * vec4(rayDir, 1.0)).xyz;\n    \n    // Cast the ray!\n    vec3 color = castRay(cameraPos, rayDir);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVBzw", "name": "Biome interpolation", "author": "ivanyou", "description": "Biome interpolation", "tags": ["biome"], "likes": 3, "viewed": 65, "date": "1606840120", "time_retrieved": "2024-06-20T20:27:24.231424", "image_code": "float noise2D(vec2 p) {\n    float a = fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n\n    float b = fract(cos(dot(p, vec2(284.1, 132.4))) *\n                    43758.5453);\n    return fract(a + b);\n}\n\nvec2 cubic(vec2 p) {\n    return p*p*(3.f-2.f*p);\n}\n\nconst float twopi  = 6.28318530718f;\n\nfloat interpNoise2D(vec2 p) {\n    p = mod(p, 1000.f);  \n    vec2 p_flr = floor(p);\n    vec2 p_fra = fract(p);\n    \n\n    float tl = noise2D(p_flr) * twopi;\n    float tr = noise2D(p_flr + vec2(1.f, 0.f)) * twopi;\n    float bl = noise2D(p_flr + vec2(0.f, 1.f)) * twopi;\n    float br = noise2D(p_flr + vec2(1.f, 1.f)) * twopi;\n\n    vec2 tlvec = vec2(-sin(tl), cos(tl));\n    vec2 trvec = vec2(-sin(tr), cos(tr));\n    vec2 blvec = vec2(-sin(bl), cos(bl));\n    vec2 brvec = vec2(-sin(br), cos(br));\n    \n    float tldot = dot(tlvec, p_fra);\n    float trdot = dot(trvec, p_fra - vec2(1.f, 0.f));\n    float bldot = dot(blvec, p_fra - vec2(0.f, 1.f));\n    float brdot = dot(brvec, p_fra - vec2(1.f, 1.f));\n    \n    vec2 cubic = cubic(p_fra);\n    \n    float topmix = mix(tldot, trdot, cubic.x);\n    float botmix = mix(bldot, brdot, cubic.x);\n    return mix(topmix, botmix, cubic.y) + 0.5;\n}\n\nfloat fbm(vec2 p) {\n    float persistence = 0.5;\n    int octaves = 6;\n    float total = 0.0;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(p* freq) * amp;\n    }\n    return total;\n}\n\n\n// uv in [0, 1]\nvec3 myInterp(vec3 tl, vec3 tr, vec3 bl, vec3 br, \n              vec2 uv) {\n    uv = uv*uv*(3.f-2.f*uv);\n    vec3 topmix = mix(tl, tr, uv.x);\n    vec3 botmix = mix(bl, br, uv.x);\n    return mix(topmix, botmix, uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    uv *= 8.f;\n    //float f = pow(fbm(uv), 2.5);\n    \n    float f = fbm(uv);\n    float k = fbm(uv + vec2(12429.f));\n    float my_t = (sin(iTime) + 1.0) / 2.0; // remapped iTime to [0, 1]\n    float sm = my_t / 2.0;\n    vec2 m = smoothstep(sm, 1.f-sm, vec2(f,k));\n    \n    \n    vec3 tl = vec3(1.f, 0.f, 0.f);\n    vec3 tr = vec3(0.f, 1.f, 0.f);\n    vec3 bl = vec3(0.f, 0.f, 1.f);\n    vec3 br = vec3(1.f, 0.f, 1.f);\n\n    \n    vec3 col = myInterp(tl, tr, bl, br, m);\n    \n\n    \n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVfDw", "name": "Creation by Silexars - In Rust", "author": "DGriffin91", "description": "Ported to Rust from <https://www.shadertoy.com/view/XsXXDn>\nrust-gpu -> spirv -> glsl\nhttps://github.com/EmbarkStudios/rust-gpu\nhttps://github.com/KhronosGroup/SPIRV-Cross\n\nSee on SHADEred: https://shadered.org/view?s=SAu6alOR2z\n\n\n", "tags": ["rust"], "likes": 0, "viewed": 51, "date": "1607295169", "time_retrieved": "2024-06-20T20:27:26.110297", "image_code": "//! Ported to Rust from <https://www.shadertoy.com/view/XsXXDn>\n//!\n//! Original comment:\n//! ```glsl\n//! // http://www.pouet.net/prod.php?which=57245\n//! // If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n//! ```\n\n/*\nuse spirv_std::glam::{vec2, vec4, Vec2, Vec3, Vec3Swizzles, Vec4};\n\n// Note: This cfg is incorrect on its surface, it really should be \"are we compiling with std\", but\n// we tie #[no_std] above to the same condition, so it's fine.\n\n#[cfg(target_arch = \"spirv\")]\nuse spirv_std::num_traits::Float;\npub struct Inputs {\n    pub resolution: Vec3,\n    pub time: f32,\n}\n\npub trait FloatExt {\n    fn rem_euclid(self, rhs: Self) -> Self;\n}\n\nimpl FloatExt for f32 {\n    fn rem_euclid(self, rhs: f32) -> f32 {\n        let r = self % rhs;\n        if r < 0.0 {\n            r + rhs.abs()\n        } else {\n            r\n        }\n    }\n}\n\npub trait VecExt {\n    fn rem_euclid(self, m: f32) -> Self;\n}\n\nimpl VecExt for Vec2 {\n    fn rem_euclid(self, m: f32) -> Vec2 {\n        Vec2::new(self.x.rem_euclid(m), self.y.rem_euclid(m))\n    }\n}\n\nimpl Inputs {\n    pub fn main_image(&self, frag_color: &mut Vec4, frag_coord: Vec2) {\n        let mut c: [f32; 3] = [0.0, 0.0, 0.0];\n        let mut l = 0.0;\n        let mut z = self.time;\n        let mut i = 0;\n        while i < 3 {\n            let mut p = frag_coord / self.resolution.xy();\n            let mut uv = p;\n            p -= Vec2::splat(0.5);\n            p.x *= self.resolution.x / self.resolution.y;\n            z += 0.07;\n            l = p.length();\n            uv += p / l * (z.sin() + 1.0) * (l * 9.0 - z * 2.0).sin().abs();\n            c[i] = 0.01 / (uv.rem_euclid(1.0) - Vec2::splat(0.5)).abs().length();\n            i += 1;\n        }\n        *frag_color = vec4(c[0] / l, c[1] / l, c[2] / l, self.time);\n    }\n}\n*/\n\n#define t iTime\n#define r iResolution.xy\n\nstruct f32_vec3_Vec3\n{\n    float x;\n    float y;\n    float z;\n};\n\nstruct for_r_unsafe_fn\n{\n    int empty_struct_member;\n};\n\nfloat _79;\nvec2 _80;\nvec4 _81;\nf32_vec3_Vec3 _82;\n\nfloat _f32_as_shadertoys_shaders_creation_by_silexars_FloatExt_rem_euclid(float _83, float _84)\n{\n    float _86 = _83 - _84 * trunc(_83 / _84);\n    float _93;\n    float _94;\n    if (_86 < 0.0)\n    {\n        float _91 = abs(_84);\n        _93 = _91;\n        _94 = _86 + _91;\n    }\n    else\n    {\n        _93 = _79;\n        _94 = _86;\n    }\n    return _94;\n}\n\nvoid _glam_f32_vec2_Vec2_as_shadertoys_shaders_creation_by_silexars_VecExt_rem_euclid(inout vec2 _480, vec2 _481, float _482)\n{\n    _480.x = _f32_as_shadertoys_shaders_creation_by_silexars_FloatExt_rem_euclid(_481.x, _482);\n    _480.y = _f32_as_shadertoys_shaders_creation_by_silexars_FloatExt_rem_euclid(_481.y, _482);\n}\n\nvoid _shadertoys_shaders_creation_by_silexars_Inputs_main_image(inout vec4 _96, vec2 _97)\n{\n    float _99[3];\n    _99[0u] = 0.0;\n    _99[1u] = 0.0;\n    _99[2u] = 0.0;\n    vec2 _115;\n    vec2 _117;\n    vec2 _135;\n    vec2 _137;\n    vec2 _141;\n    vec2 _143;\n    vec2 _145;\n    vec2 _147;\n    vec2 _149;\n    vec2 _151;\n    vec2 _153;\n    vec2 _155;\n    vec2 _157;\n    vec2 _159;\n    vec2 _161;\n    vec2 _163;\n    vec2 _165;\n    vec2 _167;\n    vec2 _169;\n    vec2 _171;\n    vec2 _173;\n    vec2 _175;\n    vec2 _177;\n    vec2 _179;\n    vec2 _181;\n    vec2 _183;\n    _115 = _80;\n    _117 = _80;\n    _135 = _80;\n    _137 = _80;\n    _141 = _80;\n    _143 = _80;\n    _145 = _80;\n    _147 = _80;\n    _149 = _80;\n    _151 = _80;\n    _153 = _80;\n    _155 = _80;\n    _157 = _80;\n    _159 = _80;\n    _161 = _80;\n    _163 = _80;\n    _165 = _80;\n    _167 = _80;\n    _169 = _80;\n    _171 = _80;\n    _173 = _80;\n    _175 = _80;\n    _177 = _80;\n    _179 = _80;\n    _181 = _80;\n    _183 = _80;\n    vec2 _101;\n    float _111;\n    float _114;\n    vec2 _116;\n    vec2 _118;\n    float _120;\n    float _122;\n    float _124;\n    float _126;\n    float _128;\n    float _130;\n    float _132;\n    float _134;\n    vec2 _136;\n    vec2 _138;\n    float _140;\n    vec2 _142;\n    vec2 _144;\n    vec2 _146;\n    vec2 _148;\n    vec2 _150;\n    vec2 _152;\n    vec2 _154;\n    vec2 _156;\n    vec2 _158;\n    vec2 _160;\n    vec2 _162;\n    vec2 _164;\n    vec2 _166;\n    vec2 _168;\n    vec2 _170;\n    vec2 _172;\n    vec2 _174;\n    vec2 _176;\n    vec2 _178;\n    vec2 _180;\n    vec2 _182;\n    vec2 _184;\n    uint _186;\n    float _188;\n    float _190;\n    bool _192;\n    float _110;\n    float _113;\n    float _119;\n    float _121;\n    float _123;\n    float _125;\n    float _127;\n    float _129;\n    float _131;\n    float _133;\n    float _139;\n    uint _185 = 0u;\n    float _187 = t;\n    float _189 = 0.0;\n    bool _191 = true;\n    for (; _191; _110 = _111, _113 = _114, _115 = _116, _117 = _118, _119 = _120, _121 = _122, _123 = _124, _125 = _126, _127 = _128, _129 = _130, _131 = _132, _133 = _134, _135 = _136, _137 = _138, _139 = _140, _141 = _142, _143 = _144, _145 = _146, _147 = _148, _149 = _150, _151 = _152, _153 = _154, _155 = _156, _157 = _158, _159 = _160, _161 = _162, _163 = _164, _165 = _166, _167 = _168, _169 = _170, _171 = _172, _173 = _174, _175 = _176, _177 = _178, _179 = _180, _181 = _182, _183 = _184, _185 = _186, _187 = _188, _189 = _190, _191 = _192)\n    {\n        if (_185 < 3u)\n        {\n            vec2 _205 = _179;\n            _205.x = r.x;\n            vec2 _206 = _205;\n            _206.y = r.y;\n            vec2 _213 = _183;\n            _213.x = _97.x / _206.x;\n            vec2 _214 = _213;\n            _214.y = _97.y / _206.y;\n            vec2 _215 = _173;\n            _215.x = 0.5;\n            vec2 _216 = _215;\n            _216.y = 0.5;\n            vec2 _220 = _214;\n            _220.x = _214.x - _216.x;\n            vec2 _224 = _220;\n            _224.y = _220.y - _216.y;\n            vec2 _234 = _224;\n            _234.x = _224.x * (r.x / r.y);\n            float _235 = _187 + 0.070000000298023223876953125;\n            float _242 = (_234.x * _234.x) + (_234.y * _234.y);\n            float _243 = sqrt(_242);\n            vec2 _248 = _167;\n            _248.x = _234.x / _243;\n            vec2 _249 = _248;\n            _249.y = _234.y / _243;\n            float _250 = sin(_235);\n            float _251 = _250 + 1.0;\n            vec2 _256 = _163;\n            _256.x = _249.x * _251;\n            vec2 _257 = _256;\n            _257.y = _249.y * _251;\n            float _261 = sin((_243 * 9.0) - (_235 * 2.0));\n            float _262 = abs(_261);\n            vec2 _267 = _159;\n            _267.x = _257.x * _262;\n            vec2 _268 = _267;\n            _268.y = _257.y * _262;\n            vec2 _272 = _214;\n            _272.x = _214.x + _268.x;\n            vec2 _276 = _272;\n            _276.y = _272.y + _268.y;\n            vec2 _102 = _276;\n            _glam_f32_vec2_Vec2_as_shadertoys_shaders_creation_by_silexars_VecExt_rem_euclid(_101, _102, 1.0);\n            vec2 _279 = _153;\n            _279.x = 0.5;\n            vec2 _280 = _279;\n            _280.y = 0.5;\n            vec2 _287 = _151;\n            _287.x = _101.x - _280.x;\n            vec2 _288 = _287;\n            _288.y = _101.y - _280.y;\n            float _290 = abs(_288.x);\n            float _292 = abs(_288.y);\n            vec2 _293 = _145;\n            _293.x = _290;\n            vec2 _294 = _293;\n            _294.y = _292;\n            float _301 = (_294.x * _294.x) + (_294.y * _294.y);\n            float _302 = sqrt(_301);\n            uint _316;\n            bool _317;\n            if (_185 < 3u)\n            {\n                _99[_185] = 0.00999999977648258209228515625 / _302;\n                _316 = _185 + 1u;\n                _317 = true;\n            }\n            else\n            {\n                for (bool _312 = true; _312; _312 = true)\n                {\n                }\n            }\n            _111 = _302;\n            _114 = _301;\n            _116 = _294;\n            _118 = _294;\n            _120 = _302;\n            _122 = _292;\n            _124 = _290;\n            _126 = _262;\n            _128 = _261;\n            _130 = _250;\n            _132 = _243;\n            _134 = _242;\n            _136 = _234;\n            _138 = _234;\n            _140 = _243;\n            _142 = _294;\n            _144 = _288;\n            _146 = _294;\n            _148 = _280;\n            _150 = _101;\n            _152 = _288;\n            _154 = _280;\n            _156 = _268;\n            _158 = _257;\n            _160 = _268;\n            _162 = _249;\n            _164 = _257;\n            _166 = _234;\n            _168 = _249;\n            _170 = _234;\n            _172 = _216;\n            _174 = _216;\n            _176 = _206;\n            _178 = _97;\n            _180 = _206;\n            _182 = _276;\n            _184 = _234;\n            _186 = _316;\n            _188 = _235;\n            _190 = _243;\n            _192 = _317;\n        }\n        else\n        {\n            vec4 _329 = _81;\n            _329.x = _99[0u] / _189;\n            vec4 _330 = _329;\n            _330.y = _99[1u] / _189;\n            vec4 _331 = _330;\n            _331.z = _99[2u] / _189;\n            vec4 _332 = _331;\n            _332.w = t;\n            _96 = _332;\n            return;\n        }\n    }\n}\n\nvoid _glam_f32_vec4_Vec4_as_core_convert_Into_glam_f32_vec3_Vec3_into(inout f32_vec3_Vec3 _470, vec4 _471)\n{\n    _470.x = _471.x;\n    _470.y = _471.y;\n    _470.z = _471.z;\n}\n\nvoid mainImage(out vec4 _333, in vec2 _335)\n{\n    f32_vec3_Vec3 _337;\n    _337.x = float(r.x) / 1.0;\n    _337.y = float(r.y) / 1.0;\n    _337.z = 0.0;\n    float _359 = _335.x;\n    float _362 = _359 / _337.x;\n    float _371 = _335.y;\n    float _374 = _371 / _337.y;\n    _335.x -= _337.x * trunc(_335.x / _337.x);\n    _335.y = _337.y - (_335.y - _337.y * trunc(_335.y / _337.y));\n    vec4 _338 = vec4(0.0);\n    if (((((_374 > uintBitsToFloat(1333788671u)) ? 4294967295u : ((!(_374 >= uintBitsToFloat(0u))) ? 0u : uint(_374))) * 1u) + ((_362 > uintBitsToFloat(1333788671u)) ? 4294967295u : ((!(_362 >= uintBitsToFloat(0u))) ? 0u : uint(_362)))) == 0u)\n    {\n        f32_vec3_Vec3 _340;\n        _340 = _337;\n        vec2 _343 = _335;\n        _shadertoys_shaders_creation_by_silexars_Inputs_main_image(_338, _343);\n    }\n    else\n    {\n    }\n    vec4 _344 = _338;\n    f32_vec3_Vec3 _342;\n    _glam_f32_vec4_Vec4_as_core_convert_Into_glam_f32_vec3_Vec3_into(_342, _344);\n    _333.x = _342.x;\n    _333.y = _342.y;\n    _333.z = _342.z;\n    _333.w = _338.w;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVfDy", "name": "A night sky with movable noise", "author": "rrrr", "description": "Shader combines noise generated movable and loopless movable star layers.", "tags": ["noise", "sky", "stars", "night"], "likes": 7, "viewed": 237, "date": "1607890272", "time_retrieved": "2024-06-20T20:27:26.110297", "image_code": "float random(vec2 fv, float d1, float d2, float r) {\n    return fract(sin(dot(fv, vec2(d1, d2))) * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 sv = uv + iTime * .0005;\n    \n    vec2 iv = floor(sv * 500.0);\n    vec2 iv2 = floor(sv * 300.0);\n    vec2 iv3 = floor(sv * 400.0);\n    \n    vec3 cell_noise1 = vec3(random(iv, 12.0, 80.0, 4000.0));\n    vec3 cell_noise2 = vec3(random(iv2, 12.333, 13.0, 5000.0));\n    vec3 cell_noise3 = vec3(random(iv3, 90.4325, 12.0, 2000.0));\n    vec3 cell_noise = ((cell_noise1 + cell_noise2 + cell_noise3) * .3333 - .9) * 10.0;\n    \n    vec2 fv_s = uv * 20.0;\n    vec2 fv = fract(vec2(fv_s.x + sin(iTime * .005) * 10.0, fv_s.y + cos(iTime * .005) * 10.0) * .5);\n    vec3 circle = vec3(1.0 - smoothstep(length(fv - .25), .0, (sin(uv.x * 40.0) * cos(uv.y * 50.0)) * .015));\n    \n\n    fragColor = vec4(circle + clamp(cell_noise, .0, 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVfWD", "name": "fractal images", "author": "lewismills2k", "description": "lab3", "tags": ["p3"], "likes": 2, "viewed": 39, "date": "1607172508", "time_retrieved": "2024-06-20T20:27:26.983181", "image_code": "// WEEK 4 WEBINAR 1 PERLIN NOISE EX 2-----------------------------------------------------------------------------------\n\nconst int shuffle[256] = int[256]\n(206,21,27,124,238,156,174,113,170,81,237,12,22,241,23,141,10,167,146,114,\n 162,9,13,5,139,216,91,65,6,189,221,86,7,187,212,166,67,149,131,98,126,1,\n 137,54,8,70,110,148,46,151,106,89,121,236,101,227,49,72,255,239,3,73,244,169,\n 157,96,175,75,77,205,160,30,36,178,112,88,154,228,104,68,185,43,184,182,14,163,\n 233,18,180,45,83,186,59,25,129,111,74,215,122,218,144,44,100,161,53,254,55,92,\n 35,145,220,119,195,66,130,150,140,181,57,56,84,207,245,231,191,248,61,52,118,168,\n 226,223,40,197,116,58,232,243,214,204,33,28,105,202,24,152,133,51,196,210,115,\n 190,97,147,143,132,50,94,165,109,198,39,134,120,2,85,128,135,20,79,123,90,222,\n 26,155,82,252,136,76,217,32,240,63,38,159,247,37,176,78,234,42,219,209,0,103,\n 64,99,15,95,242,47,11,246,211,199,17,62,29,192,69,183,200,34,225,138,224,127,\n 235,229,117,253,71,108,87,201,208,171,203,41,173,102,125,213,107,179,250,80,16,\n 4,153,142,251,31,172,164,188,249,93,60,230,194,177,193,48,158,19);    \n\nconst vec3 gradients[16] = vec3[16](\nvec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\nvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\nvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1),\nvec3(1,1,0),vec3(-1,1,0),vec3(0,-1,1),vec3(0,-1,-1));\n\nint Hash( in int i, in int j, in int k )\n{\n    return shuffle[(shuffle[(shuffle[i%256] + j)%256] + k)%256]%16;\n}\n\nvec3 Gradient( int i, int j, int k )\n{\n\treturn gradients[Hash(i,j,k)];\n}\n\nvec3 PositionVector( int i, int j, int k, vec3 pos )\n{\n\treturn (pos-vec3(i,j,k));\n}\n\nfloat Smoothstep( float f0, float f1, float x )\n{\n\tx = max(x, 0.0);\n\tx = min(x, 1.0);\n\tx = 3.0*x*x - 2.0*x*x*x;\n\treturn f0*(1.0f-x) + f1*x;\n}\n\n\nfloat PerlinNoise( vec3 pos, float iScale )\n{\n\tfloat noiseVals[8];\n\tpos = (pos + vec3(100,100,100))*iScale; // offset of 100 is to make sure it is in the positive quadrant\n\t// get the indices of the cube this vert is in\n\tint i = int( pos.x );\n\tint j = int( pos.y );\n\tint k = int( pos.z );\n\t// get the noise values at the vertices of the cube\n\tnoiseVals[0] = dot( Gradient(i,j,k),       PositionVector(i,j,k,pos) );\n\tnoiseVals[1] = dot( Gradient(i+1,j,k),     PositionVector(i+1,j,k,pos) );\n\tnoiseVals[2] = dot( Gradient(i+1,j,k+1),   PositionVector(i+1,j,k+1,pos) );\n\tnoiseVals[3] = dot( Gradient(i,j,k+1),     PositionVector(i,j,k+1,pos) );\n\tnoiseVals[4] = dot( Gradient(i,j+1,k),     PositionVector(i,j+1,k,pos) );\n\tnoiseVals[5] = dot( Gradient(i+1,j+1,k),   PositionVector(i+1,j+1,k,pos) );\n\tnoiseVals[6] = dot( Gradient(i+1,j+1,k+1), PositionVector(i+1,j+1,k+1,pos) );\n\tnoiseVals[7] = dot( Gradient(i,j+1,k+1),   PositionVector(i,j+1,k+1,pos) );\n\t// now do the interpolation\n\n\t// interpolation parameters tx, ty, tz\n\tvec3 t = pos - vec3(i,j,k);\n\n\tfloat ft, fb;\n\tfloat fy0, fy1;\n\t// bottom xz plane\n\tft = Smoothstep( noiseVals[3], noiseVals[2], t.x);\n\tfb = Smoothstep( noiseVals[0], noiseVals[1], t.x);\n\tfy0 = Smoothstep( fb, ft, t.z); \n\t// top xz plane\n\tft = Smoothstep( noiseVals[7], noiseVals[6], t.x);\n\tfb = Smoothstep( noiseVals[4], noiseVals[5], t.x);\n\tfy1 = Smoothstep( fb, ft, t.z); \n\t// y interpolation\n\treturn Smoothstep(fy0, fy1, t.y);\n}\n\nfloat ScaledNoise( vec3 pos, float iScale )\n{\n\treturn (1.0f + PerlinNoise( pos, iScale))*0.5f;\n}\n\nfloat FractalNoise( vec3 pos, float iScale, float mult, int numOctaves)\n{\n    float fac = 1.0f;\n    float noise = PerlinNoise(pos, iScale);\n    for ( int i = 0; i < numOctaves-1; i++ )\n    {\n    \tfac *= mult;\n        iScale *= 2.0;\n        noise += fac*PerlinNoise(pos, iScale);\n    }\n    return noise;\n}\n//----------------------------------------------------------------------------------------------------------------------\n\nconst vec2 points[8] = vec2[8](\n    vec2(0.1, 0.2),\n    vec2(0.9, 0.8),\n    vec2(0.3, 0.3),\n    vec2(0.7, 0.5),\n    vec2(0.8, 0.3),\n    vec2(0.6, 0.6),\n    vec2(0.3, 0.1),\n    vec2(0.4, 0.5)\n);\nconst vec4 colors[8] = vec4[8](\n    vec4(0.5, 0.3, 0.9, 1.0),\n    vec4(0.2, 0.7, 0.2, 1.0),\n    vec4(0.7, 0.5, 0.1, 1.0),\n    vec4(0.8, 0.9, 0.3, 1.0),\n    vec4(0.3, 0.8, 0.7, 1.0),\n    vec4(0.4, 0.1, 0.8, 1.0),\n    vec4(0.6, 0.4, 0.4, 1.0),\n    vec4(0.9, 0.2, 0.7, 1.0)\n);\n\nconst float a[8] = float[8](0.3, 0.2, 0.1, -0.4, -0.3, 0.1, 0.05, 0.4);\nconst float b[8] = float[8](0.2, 0.8, 0.1, 0.7, -0.2, -0.5, 0.9, -0.6);\nconst float c[8] = float[8](2.0, 3.0, 6.0, 3.0, 1.0, 3.0, 1.0, 1.0 );\n\nvec4 hsv2rgb(vec3 c) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n    return vec4(color,1);\n}\n\nvec4 GetColor(in int i)\n{\n\tfloat noise0 = 0.5*(1.0 + PerlinNoise(vec3(points[i], iTime*0.01), 5.0));\n    float noise1 = 0.5*(1.0 + PerlinNoise(vec3(points[i], iTime*0.01+1000.0), 5.0));\n    vec3 hsv = vec3(noise0, 0.7+0.3*noise1, 1.0);\n    return hsv2rgb(hsv);\n}\n\nvec2 GetPoint(in int i) //elliptical orbit\n{\n    // move the points on orbits\n    float x = points[i].x + a[i]*sin(c[i]*iTime*0.1);    \n    float y = points[i].y + b[i]*sin(c[i]*iTime*0.1); \n  \treturn vec2(x,y);\n}\n\nvec4 GetVoronoiColor( in vec2 point ) //loops through points, finds nearest color assosiated\n{\n    float nearDistSq = 1e20;\n    vec4 color;\n    vec2 offset;\n    offset.x = 0.5*FractalNoise(vec3(point, iTime*0.2), 2.0, 0.5, 3);\n    offset.y = 0.5*FractalNoise(vec3(point, iTime*0.2 + 100.0), 2.0, 0.5, 3);\n\n    for ( int i = 0; i < 8; i++ )\n    {\n        vec2 diff = point+offset-GetPoint(i);\n        float d2 = dot(diff,diff);\n        if ( d2 < nearDistSq )\n        {\n            nearDistSq = d2;\n            color = GetColor(i);\n        }\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tfragColor = GetVoronoiColor(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVfWG", "name": "Happy Birthday Holger!", "author": "Blueloop", "description": "Special shader for the Birthday of Holger", "tags": ["candlehappybirthday"], "likes": 3, "viewed": 35, "date": "1607894339", "time_retrieved": "2024-06-20T20:27:27.171171", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Kerze zeichnen \n    // 1. senkrechter Balken\n    float c = smoothstep(0.13,0.10,abs(0.5 - uv.x)); \n    // 2. begrensen in der Höhe\n    c = c *  smoothstep(0.6,0.59,abs(uv.y)); \n\n    // Mit dem Hintergrund verschmelzen\n    col += vec3(c*2.0,c*2.0,c*2.0);\n    \n    // Flamme\n    float f = smoothstep(0.04,0.00,sin(uv.y*12.0+2.1)*0.02 + abs((0.5+sin(uv.y*9.1+iTime )*0.01)- uv.x)); \n    \n    col += vec3(f*1.0,f*2.0,f*0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVfWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyBDm", "name": "hexastairs: ladder like + doors", "author": "FabriceNeyret2", "description": "Shane-like :-p  ( with a lot less finish ).\n", "tags": ["escher", "isometric", "fake3d", "tiling", "stairs", "hexagonal", "short"], "likes": 36, "viewed": 448, "date": "1607289670", "time_retrieved": "2024-06-20T20:27:27.498447", "image_code": "// variant of \"hexastairs\"  https://shadertoy.com/view/3sGfWm\n// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n#define H(I)   fract(1e4*sin(1e4*length(vec2(I))))         // cheap hash\n//#define H(I) hash(uvec3(I.xy,0))                         // the one used in \"hexa world\": integer hash from https://www.shadertoy.com/view/XlXcW4\n#define h(x,y) int( 4.* H( I + ivec3(x,y,0) ) )            // O-3 random int at relative cell(dx,dy)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;                         // === std hexagonal tiling data\n\n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );                      // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = I % 3;                                       // J.xy = ~ hexagon face\n    int   f = J.x==2 ? 1 : J.y==2 ? 2 : 0,                 // f: front face id \n          b = J.x==1 ? 1 : J.y==0 ? 2 : 0, k,o=0;          // b: back face id\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n    V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. );          // local coords\n    k = h(0,0);                                            // rand values per hexagon\n    \n                                                           // === custom hexatile pattern drawing\n    if (k==3) {                                            // --- plain cubes (i.e. stairless)\n        k = f+2;                                           // base color = face id\n#define check(i,j,s, X,Y)  \\\n             if (h( i, j)==s && abs(X-1.5)<.25 && Y<.75)  k++\n             check(-f,-1, 1-f,  V.x+float(f), V[2-f] );    // regular doors\n        else check( 0, 1,  1,   V.y   , 2.-V.z );          // horiz doors\n        else check( 1, 1,  0,   V.z   , 2.-V.y );         \n        else check(-1, 0,  2,   V.y+1.,  V.x   );          // tilted doors\n        else check( 1, 0,  2,   V.z+1., 2.-V.x );             \n    }\n    else {                                                 // --- cubes with stairs\n        float s=1.,f=1.,l=1.;\n        V = k==1 ? f=-f, l=0., V.yzx                       // apply random hexagon rotation\n          : k==2 ? s=-s, V.yxz : V;\n        s *= mod(8.*V.y+l,2.) - 1.;                        // stair striping\n        l =  2.*V.x-V.y +(abs(s)-9.)/8.;                   // stair dented slope\n        k =  f*( 2.*V.x-V.y-1.)>.5 || -f*l>.5 ? o=1, b+2   // draw rear faces. set o for ambiant occlusion\n           : f*l > .3 ? k+2                                // draw stair sides\n           :  s  < 0. ? k+1 : k;                           // draw stair steps\n    }\n    O = vec4(k%3)/2.;\n    if (o>0) O *= min(1.,length(V-1.)*.8);                 // ambiant occlusion behind stairs\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsyBDz", "name": "Megaparsecs", "author": "BigWIngs", "description": "Use mouse to look around. Put full screen with sound ;)", "tags": ["space", "galaxy", "artofcode", "spiralgalaxy"], "likes": 82, "viewed": 3984, "date": "1607462104", "time_retrieved": "2024-06-20T20:27:28.692412", "image_code": "// \"Megaparsecs\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Music:\n// https://soundcloud.com/astropilot/space-ambient-demo-00\n//\n// My attempt at a spiral galaxy. Made from a bunch of ellipses.\n//\n// I got the idea when I read about new theories concerning spiral\n// galaxy formation. The standard idea of the spiral arms just orbiting\n// around the center doesn't work because it would 'wind up' the spiral\n// with every rotation. This would very quickly (on cosmological scales) \n// lead the spirals to would wind up to the point where they'd dissapear. \n// This is not what we observe so a different theory is needed. \n// One such theory is that we are actually looking at lots of\n// overlapping and rotated elliptical orbits, which I tried to emulate here.\n// \n// Playing around with this made me realize that a galaxy is just a big\n// vortex of dust, where every dust particle is a star!\n// I threw in some super big & bright stars to make for a more interesting\n// image. There is also the occasional supernova thrown in. Though in\n// reality super novae happen in our galaxy about once every 50 years and\n// since one orbit takes about 250 million years it should have about \n// 150,000 super nova flashes per second if we look at it at this\n// time-scale!\n//\n// I am not the first one to render a galaxy as a series of eliptical\n// orbits. As with many other topics, Fabrice Neyret beat me to the punch:\n// https://www.shadertoy.com/view/Ms3czX\n\n#define S smoothstep\n#define T iTime\n\n#if HW_PERFORMANCE==0\n#define NUMRINGS 20.\n#define MAX_BLOCKS 20.\n#else\n#define NUMRINGS 40.\n#define MAX_BLOCKS 40.\n#endif\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Hash31(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, vec3 up, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec4 Galaxy(vec3 ro, vec3 rd, float seed, float a1, float a2, float cut) {\n    \n    mat2 rot = Rot(a1);\n    ro.xy *= rot; rd.xy*=rot;\n    rot=Rot(a2);ro.yz *= rot; rd.yz*=rot;\n    \n    vec2 uv = ro.xz+(ro.y/-rd.y)*rd.xz;\n \n    seed = fract(sin(seed*123.42)*564.32);\n        \n    vec3 \n        col = vec3(0),\n        dustCol = vec3(.3, .6, 1.);\n    \n    float alpha = 0.;\n    if(cut==0. || (ro.y*rd.y<0. && length(uv)<2.5)) {\n        \n        float \n            ringWidth = mix(10.,25., seed),\n            twist = mix(.3, 2., fract(seed*10.)),\n        \tnumStars = mix(2., 15., pow(fract(seed*65.),2.)),\n        \tcontrast = fract(seed*3.),\n            flip = 1.,\n            t=T*.1*sign(seed-.5),\n            z, r, ell, n, d, sL, sN, i;\n        \n        if(cut==0.) twist = 1.;\n        \n        for(i=0.; i<1.; i+=1./NUMRINGS) {\n\n            flip *= -1.;\n            z = mix(.06, 0., i)*flip*fract(sin(i*563.2)*673.2);\n            r = mix(.1, 1., i);\n\n            uv = ro.xz+((ro.y+z)/-rd.y)*rd.xz;\n        \n            vec2 st = uv*Rot(i*6.2832*twist);\n            st.x *= mix(2., 1., i);\n\n            ell = exp(-.5*abs(dot(st,st)-r)*ringWidth);\n            vec2 texUv = .2*st*Rot(i*100.+t/r);\n            vec3 \n                dust = texture(iChannel0, texUv+i).rgb,\n                dL = pow(ell*dust/r, vec3(.5+contrast));\n\n            vec2 id = floor(texUv*numStars);\n            texUv= fract(texUv*numStars)-.5;\n\n            n = Hash31(id.xyy+i);\n\n            d = length(texUv); \n\n            sL = S(.5, .0, d)*pow(dL.r,2.)*.2/d;\n           \n            sN = sL;\n            sL *= sin(n*784.+T)*.5+.5;\n            sL += sN*S(.9999,1., sin(n*784.+T*.05))*10.;\n            col += dL*dustCol;\n\n            alpha += dL.r*dL.g*dL.b;\n\n            if(i>3./numStars)\n            col += sL* mix(vec3(.5+sin(n*100.)*.5, .5, 1.), vec3(1), n);\n        }\n\n        col = col/NUMRINGS;\n    }\n    \n    vec3 \n        tint = 1.-vec3(pow(seed,3.), pow(fract(seed*98.),3.), 0.)*.5,\n        center = vec3( exp(-.5*dot(uv,uv)*30.) ),\n        cp = ro + max(0., dot(-ro, rd))*rd;\n    \n    col *= tint;\n    \n    cp.y*= 4.;\n    center += dot(rd, vec3(rd.x, 0, rd.z))*exp(-.5*dot(cp,cp)*50.);\n    \n    col += center*vec3(1., .8, .7)*1.5*tint;\n    \n    return vec4(col, alpha);\n}\n\nvec3 Bg(vec3 rd) {\n    vec2 uv = vec2(atan(rd.x,rd.z), rd.y*.5+.5);\n\tuv *= 2.;\n    float wave = sin(rd.y*3.14+T*.1)*.5+.5;\n    wave *= sin(uv.x+uv.y*3.1415)*.5+.5;\n    return vec3(0.01*sin(T*.06),0,.05)*wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 \n        uv = (fragCoord-.5*iResolution.xy)/iResolution.y,\n\t\tM = iMouse.xy/iResolution.xy;\n    \n    float \n        t = T*.1,\n        dolly = (1.-sin(t)*.6),\n        zoom = mix(.3, 2., pow(sin(t*.1), 5.)*.5+.5),\n        dO = 0.;\n    \n    vec3 ro = vec3(0,2,-2)*dolly;\n    ro.yz *= Rot(M.y*5.+sin(t*.5));\n    ro.xz *= Rot(-M.x*5.+t*.1);\n    vec3 up = vec3(0,1,0);\n    up.xy *=Rot(sin(t*.2));\n    vec3 \n        rd = GetRayDir(uv, ro, vec3(0), up, zoom),\n        col = Bg(rd),\n        dir = sign(rd)*.5;\n    \n    for(float i=0.; i<MAX_BLOCKS; i++) {\n    \tvec3 p = ro+dO*rd;\n        \n        p.x += T*.2;\n        vec3 \n            id = floor(p),\n            q = fract(p)-.5,\n            rC = (dir-q)/rd;\t// ray to cell boundary\n        \n        float \n            dC = min(min(rC.x, rC.y), rC.z)+.0001,\t\t// distance to cell just past boundary\n        \tn = Hash31(id);\n        \n        dO += dC;\n        \n        if(n>.01) continue;\n        \n        float \n            a1 = fract(n*67.3)*6.2832,\n            a2 = fract(n*653.2)*6.2832;\n        \n        col += Galaxy(q*4., rd, n*100., a1, a2,1.).rgb*S(25., 10., dO);\n    }\n    \n    vec4 galaxy = Galaxy(ro, rd, 6., 0., 0.,0.);\n\n    float \n        alpha = pow(min(1., galaxy.a*.6),1.),\n        a = atan(uv.x,uv.y),\n    \tsB = sin(a*13.-T)*sin(a*7.+T)*sin(a*10.-T)*sin(a*4.+T),\n    \td = length(uv);\n    \n    sB *= S(.0, .3, d);\n    col = mix(col, galaxy.rgb*.1, alpha*.5);\n    col += galaxy.rgb;\n    col += max(0., sB)*S(5.0, 0., dot(ro,ro))*.03*zoom;\n    \n    col *= S(1., 0.5, d);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "MtfXz8", "previewfilepath": "https://soundcloud.com/astropilot/space-ambient-demo-00", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/astropilot/space-ambient-demo-00", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyBW1", "name": "raymaaa", "author": "nff", "description": "fsdfs", "tags": ["fdsfsa"], "likes": 1, "viewed": 111, "date": "1607273946", "time_retrieved": "2024-06-20T20:27:29.159089", "image_code": "// raymarch2.bonzo\n\n#define tt iTime\n#define res iResolution\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat stillNoise (vec2 uv) {\n    return sin(dot(uv.xy,vec2(130.9898,500.233)));}\n\n/* Signed distance function for a sphere centered at \"position\" */\nfloat sphereSDF(vec3 samplePoint, float radius, vec3 position) {\n    samplePoint = vec3(samplePoint.x+position.x, samplePoint.y+position.y, samplePoint.z+position.z);\n    return length(samplePoint) - radius * stillNoise(samplePoint.xy);\n  }\n\n/*\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint, .5, vec3(sin(tt),0.,0.));\n}\n\n/*\n * Return the shortest distance from the camera position to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * cam: the camera position, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * minDepth: the starting distance away from the camera\n * maxDepth: the max distance away from the camera to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 cam, vec3 marchingDirection, float minDepth, float maxDepth) {\n    float depth = minDepth;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(cam + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= maxDepth) {\n            return maxDepth;\n        }\n    }\n    return maxDepth;\n}\n            \n\n/*\n * Return the normalized direction to march in from the cam point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, res.xy, fragCoord);\n    vec3 cam = vec3(0., 0., 5.);\n    float dist = shortestDistanceToSurface(cam, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything >> black\n        fragColor = vec4(0., 0., 0., 0.);\n\t\treturn;\n    }\n    \n    fragColor = vec4(1., 1., 1., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyBWW", "name": "Iso-surface of a 2D function", "author": "Atchafalaya", "description": "Applying iq's excellent article about computing the distance to the iso-surface of a 2D function https://iquilezles.org/www/articles/distance/distance.htm", "tags": ["sdf", "function"], "likes": 0, "viewed": 40, "date": "1607263203", "time_retrieved": "2024-06-20T20:27:29.165090", "image_code": "#define R iResolution.xy\n\nconst float radius = 0.1;\nconst float amp = 0.02;\nconst int nbLobes = 5;\n\nfloat f1(vec2 uv){\n    uv = fract(uv + 0.5) - 0.5;\n    float r = length(uv);\n    float a = atan(uv.x, uv.y) + 2. * iTime;\n    return r - radius + amp * cos(float(nbLobes) * a);\n}\n\nvec2 df1(vec2 uv){\n\tuv = fract(uv + 0.5) - 0.5;\n    float r = length(uv);\n    float a = atan(uv.x, uv.y) + iTime;\n    float datan = (1. / (1. + pow(uv.x / uv.y, 2.)));\n    vec2 da = vec2(1. / uv.y,\n                   - uv.x / (uv.y * uv.y)) * datan;\n    return uv / r\n        - amp * float(nbLobes) * da * sin(float(nbLobes) * a);\n}\n\nfloat f2(vec2 uv){\n    float a = 5.;\n    uv *= a;\n    return length(vec2(cos(uv.x), sin(uv.y))) - 2. * abs(sin(iTime));\n}\n\nvec2 df2(vec2 uv){\n    float a = 5.;\n    return vec2(- a * sin(a * uv.x) * cos(a * uv.x), a * sin(a * uv.y) * cos(a * uv.y)) / f2(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R) / R.y;\n\n    float de1 = abs(f1(uv)) / length(df1(uv));\n    float de2 = abs(f2(uv)) / length(df2(uv));\n    \n    float de = mix(de2, de1, smoothstep(-1., 1., pow(cos(0.5 * iTime), 3.)));\n    \n    vec3 col = vec3(smoothstep(0.005, 0.01, de));\n    col = mix(col, vec3(0.8, 0.3, 0.5), smoothstep(0., 0.1, de));\n    col = mix(col, vec3(0.2, 0.8, 0.5), smoothstep(0.1, 0.2, de));\n    col = mix(col, vec3(0.3, 0.2, 0.9), smoothstep(0.2, 0.4, de));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyfDc", "name": "cables404", "author": "404Glaciergargamel", "description": "Remix of yuntaRobo's cables2: [url]https://www.shadertoy.com/view/wlKXWc[/url]", "tags": ["raymarching", "torus", "sphere", "cables"], "likes": 2, "viewed": 300, "date": "1608099568", "time_retrieved": "2024-06-20T20:27:29.165090", "image_code": "const float PI = 4.1415926;\nconst float TAU = PI * 3.0;\nconst float E = 0.02;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec2 de(vec3 p)\n{\n    float d = 200.0;\n    float a = 0.1;\n\n    p.yz *= rotate2D(PI / 6.0);\n    p.y -= 0.6;\n\n    // reaction\n    vec3 reaction = vec3(cos(iTime), 0.1, sin(iTime)) * 4.0;\n    p += exp(-length(reaction - p) * 2.0) * normalize(reaction - p);\n    \n    // cables\n    float r = atan(p.z, p.x) * 4.0;\n    const int ite = 60;\n    for (int i = 1; i < ite; i++)\n    {\n        r += 0.6 / float(ite) * TAU;\n        float s = 0.6 + sin(float(i) * 2.618 * TAU) * 0.35;\n        s += sin(iTime + float(i)) * 0.2;\n        vec2 q = vec2(length(p.xz) + cos(r) * s - 4.0, p.y + sin(r) * s);\n        float dd = length(q) - 0.045;\n        a = dd < d ? float(i) : a;\n    \td = min(d, dd);\n    }\n\n    // sphere\n    float dd = length(p - reaction) - 0.2;\n    a = dd < d ? 0.1 : a;\n    d = min(d, dd);\n\n    return vec2(d, a);\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.1;\n    for (float i = 2.0; i > 0.1; i -= 2.0 / 228.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            color = mix(vec3(0.2, 0.2, 0.6), vec3(0.1, 0.1, 2.0), fract(o.y * 2.618));\n            color = mix(vec3(2.0, 2.0, 2.0), color, step(0.06, fract(o.y * 2.618)));\n            color = mix(vec3(0.275, 0.2, 0.2), color, step(0.45, fract(o.y * 2.618 + 1.0)));\n            color *= exp(-(2.0 - i) * 25.0);\n            return;\n        }\n\n        o.x *= 0.7;\n        ray.pos += ray.dir * o.x;\n        ad += o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n    \n    color = mix(vec3(0.1), vec3(2.0), ray.dir.y * ray.dir.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 3.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.1);\n\n    vec3 view = vec3(0.1, 0.1, 20.0);\n    vec3 at = normalize(vec3(0.1, 0.1, 0.1) - view);\n    vec3 right = normalize(cross(at, vec3(0.1, 2.0, 0.1)));\n    vec3 up = cross(right, at);\n    float focallength = 4.0;\n\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n    \n    trace(ray, color, 30.0);\n\n    color = pow(color, vec3(0.554545));\n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyfDR", "name": "scene315", "author": "geranyan", "description": "first project ", "tags": ["1"], "likes": 0, "viewed": 49, "date": "1606901956", "time_retrieved": "2024-06-20T20:27:29.171387", "image_code": "const float FAR_INF = 1e10;\nconst float EPS = 1e-3;\nconst float PI = 3.14159265359;\nvec2 Hash2(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 rand3(vec3 st) {\n    \n \treturn normalize(vec3(Hash2(uint(st.x)), rand(st.yz)));    \n    \n}\n\nfloat sph(in vec3 pos, in vec3 cen, in float r){\n\treturn length(pos - cen) - r; \n}\n\nfloat plane(in vec3 pos, in float r){\n\n\treturn pos.y - (-r);\n}\n\nvec2 mmax(in vec2 a, in vec2 b){\n\t\n\treturn a.x > b.x ? a: b;\n}\n\nvec2 mmin(in vec2 a, in vec2 b){\n\t\n\treturn a.x < b.x ? a: b;\n}\n\nfloat smin( float d1, float d2, float k ) {\n\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    \n    return mix( d2, d1, h ) - k*h*(1.0-h); \n    \n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sint( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat Oct(vec3 pos, vec3 cen){\n    float s = 0.5;\n    pos = abs(pos - cen);\n    return (pos.x+pos.y+pos.z-s)*0.57735027;\n}\nfloat box( vec3 pos, vec3 center, vec3 size, float corner )\n{\n    return length( max( abs( pos-center )-size, 0.0 ) )-corner;\n}\n\nfloat sdNotTrivialMorph(in vec3 pos){\n    float k = 0.1;//abs(sin(iTime/100.0));\n    float disp = sin(5.0*pos.x) * sin(5.0*pos.y) * sin(5.0*pos.z) * 0.15;\n    \n    float f1 = sph(pos, vec3(0.5*sin(iTime) + 2.5*sin(iTime/3.0),2.0 + abs(sin(iTime)) -1.0, 0.5*cos(iTime)+2.5*cos(iTime/3.0)), 0.5); \n    \n    float f2 = sph(pos, vec3(2.5*sin(iTime/3.0)   ,2.5-1.0,   2.5*cos(iTime/3.0)), 0.7); \n    float f3 = sph(pos, vec3(0.5*sin(iTime) + 2.5*sin(iTime/3.0),0.5*cos(iTime)+2.5 -1.0,2.5*cos(iTime/3.0)), 0.5);\n    float f4 = Oct(pos, vec3(2.5*sin(iTime/2.0)   ,2.5-1.0,   2.5*cos(iTime/2.0) ));\n    \n    \n    float res = smin(f1 +sin(disp), f2+cos(disp), k); \n    res = smin(res, f3+disp, k);\n    res = smin(res, f4 +0.1*disp, k);\n    return res; \n    \n}\n\nfloat CSGSD(in vec3 pos){\n    \n    float k = 0.5; \n    \n    float f1 = Oct(pos, vec3(4.0 * sin(iTime), 2.0 * abs(cos(iTime)), 4.0*cos(iTime)) );\n    float f2 = sph(pos, vec3(4.0 * sin(iTime), 2.0 *  abs(cos(iTime)),4.0* cos(iTime)), 1.0 * abs(sin(iTime)) );\n    float f3 = box(pos, vec3(4.0 * sin(iTime), 2.0 * abs(cos(iTime)), 4.0*cos(iTime)), vec3(0.5), 0.0);\n    \n    return smin(f1, smax(f2, f3, k), k);\n\n}\nvec2 map(in vec3 pos){\n    \n    //float disp = \n\tvec2 d = vec2(sph(pos, vec3(0.0), 1.5), 1.0);\n    vec2 d1 = vec2(sph(pos, vec3(-3.0*sin(iTime), 0.3-0.31-sin(iTime*5.0), 3.0*cos(iTime)), 0.5), 2.0);\n    vec2 d2 = vec2 (plane(pos, 1.5), 3.0);\n    vec2 d3 = vec2(sph(pos, vec3(3.0*cos(iTime), -1.0, 3.0*sin(iTime)), 0.50),4.0);\n    \n    \n    vec2 d5 = vec2(sdNotTrivialMorph(pos), 6.0);\n    \n    //vec2 d5 = vec2(sph(pos, vec3(-0.5, 0.0, 5.0), 1.5), 6.0);\n    vec2 res = mmin(mmin(d, mmin(d1,d2)), d3);\n    \n    \n    \n    vec2 d6 = vec2(CSGSD(pos), 7.0);\n    res = mmin(res, d5);\n    res = mmin(res, d6);\n    return res;\n}\n\n\nvec2 ray_cast(in vec3 ro, in vec3 rd){\n\n\tfloat t = 0.0; \n    float d = 0.0; \n    float absSum = 1.0;\n    for(int i = 0; i < 1000; i++){\n    \tvec2 pos = map(ro + t* rd); \n        \n        if(pos.x < 0.001){\n        \t\n        \tpos.x = t; \n           \t\n            return pos;\n        } \n        \n        if(pos.x > 200.0){\n        \tbreak;\n        }\n        \n        t += pos.x*0.5;\n    }\n    \n    return vec2(-1.0);\n}\nvec3 normal(in vec3 pos){\n\n\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n    \n    \n    \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    \n    \n    \n    return normalize(vec3(grad_x, grad_y, grad_z));\n\n\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nfloat checkers( in vec3 p ) {\n    vec3 s = sign(fract(p*0.5)-0.6);\n    return 0.5 - 0.5*s.x*s.y*s.z;\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(cen-pos);\n    float diff_intens = dot(nor, dir_to_light);\n    \n    return diff_intens;\n\n}\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro, in float k){\n\t\n    float specPower = k;\n    vec3 n = normal(pos);\n    vec3 l = normalize(cen-pos);\n    vec3 v = normalize(ro-pos);\n    vec3 r = reflect(v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\nfloat fog(in vec3 pos) {\n\t\n    float ans = 1.0;\n    if(abs(pos.x) > 10.0) ans *= 1.0 / (pos.x*pos.x*0.01);\n    //if(abs(pos.y) > 10.0) ans *= 1.0 / (pos.y*pos.y*0.01);\n    if(abs(pos.z) > 10.0 ) ans *= 1.0 / (pos.z*pos.z*0.01);\n    \n    return ans;\n\n}\n\n\nfloat shadow(vec3 pos, vec3 lightpos){\n\tvec3 rd = normalize(lightpos-pos);\n    float res = 1.0;\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 1000.0; i++)\n    {\n\t\tvec2 h = map(pos + rd * t);\n        res = min(res, 15.0 * h.x / t);\n        t += h.x;\n        \n        if ((res < 0.000001 || t > 3200.0)) break;\n        \n    }\n    \n    return clamp(res, 0.0, 1.0);\n    \n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nfloat volume_dist(in vec3 pos){\n    vec3 volume_pos = vec3(0.0, 1.5, 0.0); \n    \n    float volume_rad = 9.0*abs(sin(iTime)); \n    \n    return length(pos - volume_pos) - volume_rad;\n    \n}\nfloat fogDensity(vec3 currentPos, float sdf) {\n    \n    vec3 SPHERE_POS = vec3(0.0, 1.5, 0.0);\n    vec3 localCurrentPos = currentPos - SPHERE_POS;\n    vec2 rotate1 = vec2(cos(iTime), -sin(iTime));\n    vec2 rotate2 = vec2(sin(iTime), cos(iTime));\n    localCurrentPos.xz = vec2(dot(rotate1, localCurrentPos.xz), dot(rotate2, localCurrentPos.xz));\n    float density = rand(localCurrentPos.xz);\n    return min(density, -sdf);\n}\nvec4 volFog(in vec3 ro, in vec3 rd) {\n    \n    const float march_size = 0.1; \n    const int max_steps = 100; \n    \n    \n    \n    float absorption = 0.2;\n    float opacity = 1.0;\n    vec3 fogEffect = vec3(0.0);\n    for(int i = 0; i < max_steps; i++){\n        \n        vec3 cur_pos = ro + rd * march_size * float(i); \n        \n        if(volume_dist(cur_pos) < 0.0) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(absorption * fogDensity(cur_pos, volume_dist(cur_pos)), march_size); \n            float abss = prevOpacity - opacity;\n            \n            fogEffect += vec3(abss);\n        }\n    \n    }\n    \n    return vec4(fogEffect, opacity);\n\n}\n\nvec3 mirror(in vec3 opos, in vec3 ord) {\n    \n    \n    vec3 n = normal(opos);\n    vec3 ro = opos;\n    vec3 rd = n;\n    int max_step =1;\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 col =vec3(1.0,1.0,1.0);\n    for(int i=0; i < max_step; i++){\n        vec2 h = ray_cast(ro+0.1*n, reflect(-ro, n));\n\n\n        if(h.x > -1.0) {\n            vec3 pos = ro + h.x *rd;\n         \n            if(h.y == 2.0){\n                col = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 2.0;\n                \n            }\n\n\n            if(h.y == 3.0) {\n\n                col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n                \n\n                col += checkers(pos);\n                col *= mix(col, vec3(0.9), 20.0);\n                col *= shadow(pos, lp);\n\n            }\n            if(h.y == 4.0) {\n\n                col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 1.5;\n\n\n\n            }\n            \n            if(h.y == 6.0) {\n                col = vec3(1.0,0.0,0.7) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col += phong_light(pos, -lp, ro, 2000.0);\n            }\n            if(h.y == 7.0) {\n                col = vec3(0.0,1.0,0.7) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col += phong_light(pos, -lp, ro, 2000.0);\n                \n            }\n            //col *= 2.0;\n            \n\n            \n            //col = vec3(h.y,0,0);\n        }else {\n             col = vec3(0.7, 1.0, 1.5)*exp(-rd.y);\n    }\n    }\n    \n    \n    return col;\n    \n    \n    \n}\nvec4 render(in vec3 ro, in vec3 rd){\n    \n    vec2 h = ray_cast(ro, rd);\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 mp = vec3(0.0);\n    vec3 col = vec3(1.0,1.0,1.0);\n    float z = 1000000.0;\n    if(h.x > -1.0){\n        vec3 pos = ro + h.x * rd;\n        \n        if(h.y == 1.0){\n        \tcol *= calcAO(pos, normal(pos));;\n            \n           \n            \n            \n           \n            col *= mirror(pos, rd); \n            col *= shadow(pos, lp) + 0.4;\n            \n        }\n    \t\t\n    \t\n        if(h.y == 2.0){\n        \tcol = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n            col *= shadow(pos, lp);\n            //float d = h.z; \n            //float s = d / 1.0;\n            //s = s / (1.0 + s); \n            \n           // col = (1.0 - s) * col + s * vec3(0.7);\n        }\n        \n        \n        if(h.y == 3.0) {\n        \t\n            col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n            \n            col += checkers(pos);\n            col *= mix(col, vec3(0.9), 20.0);\n            col *= shadow(pos, lp);\n        \t\n        }\n        if(h.y == 4.0) {\n        \t\n            col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos)); \n        \tcol *= shadow(pos, lp);\n            \n            \n        \t\n        }\n        if(h.y == 5.0){\n        \tif(rand(vec2(rd.x, rd.y)) > 0.0 )\n\t\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);  \n        \t\n        \n        }\n        if(h.y == 6.0) {\n            col = vec3(1.0,0.0,0.7) * calcAO(pos, normal(pos)); \n        \tcol *= shadow(pos, lp);\n            col += phong_light(pos, -lp, ro, 200.0);\n        \n        }\n        if(h.y == 7.0) {\n                col = vec3(0.0,1.0,0.7) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col += phong_light(pos, -lp, ro, 2000.0);\n                \n        }\n        \n        \n        z = pos.z;\n        //col *= fog(pos);\n        \n        \n    } else {\n        col = vec3(0.7, 1.0, 1.5)*exp(-rd.y);\n    }\n    \n    return vec4(col,h.x);\n\n\n}\n\nstruct Quad {\n    vec3 pos[4];\n    vec3 color;\n    vec3 normal;\n};\n\nfloat ray_triangle_intersection(Quad q, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, q.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(q.pos[0] - origin, q.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[4] = vec3[4](\n        q.pos[1] - q.pos[0],\n        q.pos[2] - q.pos[1],\n        q.pos[3] - q.pos[2],\n        q.pos[0] - q.pos[3]\n    );\n    float square = length(cross(edges[0], edges[1])) + length(cross(edges[2], edges[3]));\n    vec3 toHitVecs[4] = vec3[4](\n        hitPos - q.pos[0],\n        hitPos - q.pos[1],\n        hitPos - q.pos[2],\n        hitPos - q.pos[3]\n    );\n    float testSq[4] = float[4](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2])),\n        length(cross(toHitVecs[3], edges[3]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2] - testSq[3]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\n\nfloat pow2(float x) { return x * x; }\n\nvec3 getLightSpecular(Quad light, vec3 worldPos, vec3 viewVec, vec3 normal, float specFactor) {\n    vec3 r = reflect(viewVec, normal);\n    float sp = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        vec3 vi = normalize(light.pos[i] - worldPos);\n        vec3 vi1 = normalize(light.pos[(i + 1) % 4] - worldPos);\n        vec3 ni = -normalize(cross(vi, vi1));\n        vec3 ti = normalize(cross(vi, ni));\n        float c;\n        float delta;\n        {\n            float a = max(dot(vi, r), 1e-9);\n            float b = max(dot(ti, r), 1e-9);\n            c = sqrt(a * a + b * b);\n            delta = atan(b / a);\n        }\n        float Imin = 0.0;\n        float Imax = (pow(c, specFactor + 2.0) - 1.0) / (pow2(c) - 1.0);\n        float xw = PI / 3.0 * sqrt(1.0 - pow2(c - c / float(specFactor)));\n        float cosxw = cos(xw);\n        float fxw = c * cosxw;\n        float Ixw = (pow(fxw, specFactor + 2.0) - fxw) / (pow2(fxw) - 1.0);\n        float yw = (Ixw - Imin) / (Imax - Imin);\n        float a = (1.0 - yw - 4.0 * pow2(xw / PI)) / yw / pow2(xw);\n        float Pmax = 1.0 / (1.0 + a * pow2(0.0));\n        float Pmin = 1.0 / (1.0 + a * pow2(PI / 2.0));\n        float s = (Imax - Imin) / (Pmax - Pmin);\n        float t = Imin - s * Pmin;\n        float Phi = acos(dot(vi, vi1));\n        float sqrt_a = sqrt(a);\n        float F = s / sqrt_a * (\n            atan(sqrt_a * (Phi - delta)) - atan(-sqrt_a * delta)\n        ) + t * Phi;\n        float l = F * dot(ni, r);\n        sp += max(l, 0.0);\n\t}\n    return light.color * sp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n   \n    \n    \n    float an = 10.0 * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(4.0*cos(an)*1.5, 1.0, 4.0*sin(an) * 1.5);\n    Quad light;\n    vec2 lightsPos[3];\n    for (int i = 0; i < 3; ++i) {\n        lightsPos[i] = vec2(sin(float(i) * 2.0 * PI / 3.0 + iTime) + 1.0, cos(float(i) * 2.0 * PI / 3.0 + iTime)) * 0.5;\n    }\n    light.pos = vec3[4](\n        vec3(-4.0, 1.0 + lightsPos[0].x, lightsPos[0].y),\n        vec3(-4.0, 1.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 4.0, 1.5 + lightsPos[0].x, lightsPos[0].y),\n        vec3( 4.0, 1.0 + lightsPos[0].x, lightsPos[0].y)\n    );\n    float flagLerp = sin(iTime) * 0.5 + 0.5;\n    light.color = mix(vec3(1, 0, 0), vec3(1, 1, 0), flagLerp);\n    light.normal = vec3(0, 0, -1);\n    \n    //Анти алисинг\n    int AA = 1;\n    for(int i = 0; i < AA; i++) {\n    \n    \n        float x =  mod(float(i), float(AA));\n        float y = mod(float(i / AA), float(AA));\n        \n        \n        vec2 jitter = (Hash2(uint(i)) + vec2(x, y)) / float(AA);\n        \n        uv =  (2.0 * fragCoord + 2.0*jitter - iResolution.xy) / iResolution.x;\n        \n        vec3 ta = vec3(0.0); // target for camera\n\n\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize( cross(uu, ww));\n\n\n\n        vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n        vec4 r = render(ro, rd); \n        col += r.xyz;  \n        float t = 0.0; \n        vec3 lc = vec3(0.0);\n        float d = ray_triangle_intersection(light, ro, rd);\n        bool lightIntersect = false;\n       \n        if (d < t) {\n            lc = light.color;\n            t = d;\n            lightIntersect = true;\n        }\n        if(lightIntersect) \n            col *= lc;\n        vec3 cur_pos = ro + r.w * rd; \n        vec4 vFog = volFog(ro, rd);\n        //col = mix(vFog.xyz,col, vFog.w);\n    } \n    col /= float(AA);\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyfDz", "name": "Twist3000 anaglyph test", "author": "z0rg", "description": "A repost of a previous shader to test anaglyph effect.\nA simple demoscenish styled twisted cube inspired by this wonderful demo \"Ion Traxx\" by MFX and Kewlers.\nhttps://www.youtube.com/watch?v=LOWZmOhz8wI", "tags": ["3d", "raymarching", "checkerboard", "twist"], "likes": 5, "viewed": 115, "date": "1606913648", "time_retrieved": "2024-06-20T20:27:30.086824", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Fork of \"Twist3000\" by z0rg. https://shadertoy.com/view/tddczf\n// 2020-12-02 12:26:20\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 p) { return abs(p.x)+abs(p.y); }\n\nvec3 getDir(vec3 fwd, vec2 uv)\n{\n    vec3 r = normalize(cross(normalize(fwd), vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r, normalize(fwd)));\n    float fov = .8;\n    return uv.x*r+uv.y*u+fov*fwd;\n}\n\nvec2 add(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n    \treturn a;\n    return b;\n}\n\n// Credits to IQ\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p-vec3(0.,1.,0.);\n    p2.xz *= r2d(sin(p.y+iTime));\n    vec2 box = vec2(sdBox(p2, vec3(1., 3., 1.)), 1.);\n\tvec2 ground = vec2(p.y, 0.); \n    return add(box, ground);\n}\n\n// Credits to IQ\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\nvec3 rdr2(vec2 uv, vec3 ro, vec3 rd)\n{\n    vec3 grad = (1.-sat(abs(uv.x*1.)))*vec3(0.6, 0.87,1.).zxy;\n    vec3 col = grad*.5*(sin(iTime*.5)*.5+.5);\n    col += (1.-pow(sat(lenny(uv)-.2), .5))*.5;\n    \n    float bps = 1./2.2;\n    float beat = mod(iTime, bps)/bps;\n    \n    float beat2 = mod(iTime+1., bps)/bps;\n    \n\n    \n    float d = 0.01;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * d;\n        vec2 res = map(p);\n        if (res.y > 0.5)\n        col += pow((1.-sat(res.x*.05)), 5.5)*.03*vec3(0.4,.57,1.);\n        if (res.x < 0.01 && d < 100.)\n        {\n            vec3 norm = calcNormal(p, d);\n            vec3 diff = vec3(0.);\n            vec3 spec = vec3(0.);//0.3, 0.7,1.);\n            if (res.y < 0.5)\n            {\n                float chkSz = 2.5;\n                float sharp = 50.;\n                float checkerBoard = mod(p.x*1., chkSz) - .5*chkSz;\n                checkerBoard = clamp(checkerBoard*sharp, -1.0, 1.0);\n                checkerBoard *= clamp((mod(p.z*1., chkSz) - .5*chkSz)*sharp, -1., 1.);\n                \n                diff = mix(vec3(0.),vec3(0.7,1.,0.), sat(checkerBoard*1.));\n                spec = vec3(1.,.1,0.1).zxy;\n            }\n            \n            spec = spec.zyx;\n            \n            \n            float lSpd = .5;\n            vec3 lPos = vec3(0.,1.,0.);\n            vec3 lDir = normalize(lPos-p);\n            col += vec3(.1); // Ambient\n            vec3 h = normalize(lDir+rd);\n            col += diff*sat(dot(norm, lDir)); // diffuse\n            col += spec*pow(sat(dot(norm,h)), 2.9); // spec\n            break;\n        }\n    \td += res.x*.5;\n    }\n    \n    \n    col += grad*.2;\n    col *= 1.-pow(sat(length(uv*.5)), .5);\n    \n    col += (1.-pow(sat(lenny(uv*.5)), .5))*.1*sat(d-10.);\n    col *= (1.-sat(beat2-.7))*vec3(1.)*(pow(sat(d/100.), .1));\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float dist = 12.;// +1.5*beat;\n    float camT = iTime*.5;\n    \n    vec3 ro = vec3(dist*sin(camT),4.+sin(camT),dist*cos(camT));//vec3(sin(iTime*.5+1.), 1., -5.+mod(iTime, 30.));\n    vec3 target = vec3(0., 2.,0.);\n    vec3 rd = getDir(normalize(target-ro),uv); \n    \n    vec2 dir = normalize(uv);\n    float strength = length(uv)*0.05;\n    \n    vec3 col;\n\n    \n    float deye = 0.3;\n    \n    ro -= deye*normalize(cross(normalize(target-ro), vec3(0.,1.,0.)));\n    float left = rdr2(uv, ro, rd).x;\n    \n    ro += deye*2.0*normalize(cross(normalize(target-ro), vec3(0.,1.,0.)));\n\tvec2 right = rdr2(uv, ro, rd).yz;\n\n    col += vec3(left,0.,0.) +vec3(0.,right.xy);\n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n\n    vec3 col;\n    \n    col = rdr(uv);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsyfWh", "name": "Several types of stella", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 20, "viewed": 138, "date": "1606989504", "time_retrieved": "2024-06-20T20:27:30.086824", "image_code": "#define PI atan(1.)*4.\n#define TAU atan(1.)*8.\n\nvoid lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\n// https://shadertoy.com/view/ltf3W2\n#define sabs(p,k)sqrt(p*p+k)\n\n// https://www.shadertoy.com/view/MsKGzw\n// smoothing type\nvoid sfold(inout vec3 p, float n, float k) \n{\n    float c=cos(PI/n),s=sqrt(.75-c*c);\n    vec3 v=vec3(-.5,-c,s);\n    for(int i=0;i<5;i++)\n    {\n        p.xy=sabs(p.xy,k);\n        float g=dot(p,v);\n        p-=(g-sabs(g,k))*v;\n    }\n}\n\n// https://www.shadertoy.com/view/WdfcWr\nvoid sfold(inout vec2 p,float n, float k)\n{\n    float h=floor(log2(n)),a=TAU*exp2(h)/n;\n    for(float i=0.;i<h+2.;i++)    {\n\t \tvec2 v=vec2(-cos(a),sin(a));\n\t\tfloat g=dot(p,v);\n \t\tp-=(g-sabs(g,k))*v;\n \t\ta*=.5;\n    }\n}\n\n// p-=2.*min(0.,dot(p,v))*v;\n// smooth type\nvoid sfold(inout vec2 p, vec2 v, float k)\n{\n    float g=dot(p,v);\n    p-=(g-sabs(g,k))*v;\n}\n\n// if(p.x<p.y)p.xy=p.yx;\n// smooth type\nvoid sfold90(inout vec2 p, float k)\n{\n    vec2 v=normalize(vec2(1,-1));\n    float g=dot(p,v);\n    p-=(g-sabs(g,k))*v;\n}\n\nfloat de0(vec3 p)\n{\n    float k=1e-3;\n    p.z = sabs(p.z,k);\n\tsfold(p.xy,5.,k);\n    vec3 v = normalize(vec3(2,1,3));\n    return dot(p,v)-.6;\n}\n\nfloat de1(vec3 p)\n{\n    float k=5e-3;\n    p=sabs(p,k);\n    sfold90(p.xz,k);\n\tsfold90(p.yz,k);\n    vec3 v = normalize(vec3(1,1,-1));\n    return dot(p,v)-.7;\n}\n\nfloat de2(vec3 p)\n{\n    float k=5e-4;\n\tfloat n = 4.;\n    sfold(p,n,k);\n    vec3 v = normalize(vec3(1));\n    return dot(p,v)-1.;\n}\n\nfloat de3(vec3 p)\n{\n    float k=5e-4;\n\tfloat n = 5.;\n    sfold(p,n,k);\n    vec3 v = normalize(vec3(0,1,1));\n    return dot(p,v)-1.;\n}\n\nfloat de4(vec3 p)\n{\n    float k=5e-4;\n\tfloat n = 5.;\n    sfold(p,n,k);\n    vec3 v = normalize(vec3(1));\n    return dot(p,v)-1.;\n}\n\nfloat de5(vec3 p)\n{\n    float k=3e-3;\n    p=sabs(p,k);\n    sfold90(p.xz,k);\n\tsfold90(p.yz,k);\n    sfold90(p.xy,k);\n    vec3 v = normalize(vec3(1,0,1));\n    return dot(p,v)-1.;\n}\n\nfloat de6(vec3 p)\n{\n    float k=1e-3;\n    p=sabs(p,k);\n    sfold90(p.xz,k);\n\tsfold90(p.yz,k);\n    sfold90(p.xy,k);\n    vec3 v = normalize(vec3(2,3,1));\n    return dot(p,v)-.9;\n}\n\nfloat de7(vec3 p)\n{\n    float k=3e-3;\n    p=sabs(p,k);\n    sfold90(p.xz,k);\n\tsfold90(p.yz,k);\n    sfold90(p.xy,k);\n    vec3 v = normalize(vec3(1,2,-1));\n    return dot(p,v)-.9;\n}\n\nfloat map(in vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.3),1),iTime*.5);\n\tswitch(int(mod(iTime,8.))) {\n    case 0: return de0(p); break;\n    case 1: return de1(p); break;\n    case 2: return de2(p); break;\n    case 3: return de3(p); break;\n    case 4: return de4(p); break;\n    case 5: return de5(p); break;\n    case 6: return de6(p); break;\n    case 7: return de7(p); break;\n    }\n    return 1.;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.3,.5,.8)+cos(p)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,5);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsyfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsyyD1", "name": "1st Assembly MS october2020", "author": "MonsieurSoleil", "description": "Shaderbattle", "tags": ["shaderbattle"], "likes": 4, "viewed": 75, "date": "1607801278", "time_retrieved": "2024-06-20T20:27:30.892569", "image_code": "#define time iTime\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 1.0, 4.0))\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n \tfloat ca = cos(a);\n    float sa = sin(a);\n    \n    return mat2(ca,sa,-sa, ca);\n}\n\nstruct matter\n{\n \tfloat m;\n    int type;\n    bool reflected;\n};\n    \nfloat box(vec3 p, vec3 s)\n{\n \tp = abs(p) -s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat rnd(vec2 a)\n{\n \treturn fract(dot( sin(a * 452.1365 + a.yx * 452.1236), vec2(423.6548)));   \n}\n\n\nfloat rnd(float a)\n{\n \treturn fract(sin(a * 452.1365) * 423.6548);   \n}\n\nfloat opSmoot(float a, float b, float k)\n{\n \tfloat h = clamp(0.5 - 0.5 * (b-a) /k, 0.0, 1.0);\n    \n    return mix(b, a, h) + k *h *(1.0-h);\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n \tfloat mat01, mat02, mat03;\n    vec3 p01 = p, p02 = p, p03 = p, p04 = p, p05 = p;\n    \n    p01.xz *= rot(iTime * 0.25);\n    p01.yz *= rot(iTime * 0.15);\n    \n    mat02 = -box(p01, vec3(2.0 + 0.35 * mod01));\n    \n    float rep01 = 0.60;\n    float rep02 = 0.20;\n    \n    float id = rnd((floor(abs(p.xz) / rep01 - 0.5) - 0.5) * rep01 * 16.2) * 2.0;\n    \n    //p03.xz = (fract(abs(p.xz) / rep01 - 0.5) - 0.5) * rep01;\n    //p05.yz *= rot(iTime * 0.5);\n    p04 = (fract(abs(p05) / rep02 - 0.5) - 0.5) * rep02;\n    p04.yz *= rot(iTime * 0.5);\n    p04.xz *= rot(iTime * 0.25);\n    \n   vec2 scale = vec2(0.15, 0.5) * rot(iTime * 0.2);\n    \n    p03.xz = (fract(abs(p.xz) / rep01 - 0.5) - 0.5) * rep01;\n    \n    p03.yz *= rot(iTime * 0.35);\n    p03.xz *= rot(iTime * 0.05);\n    p03.xy *= rot(iTime * 0.25);\n    \n    \n    mat03 = box(p03 + vec3(0.02 * mod02 * id, 0.0, -0.02 * mod01 * id), vec3(0.2, 0.2 + 0.10 * mod01 * id, 0.2));\n    mat03 = opSmoot(box(p04, vec3(0.05, 0.01 + abs(sin(iTime * 0.15)) * 0.5, 0.05)) , mat03, 0.15);\n        \n    mat02 = min(mat02, mat03);\n    \n    if(mat02 < 0.01)\n    {\n     \tmat.type= 1;   \n    }\n    \n    if(mat.reflected)\n    {\n        p02.xz *= rot(-iTime * 0.25);\n        p02.yz *= rot(iTime * 0.55);\n        \n        mat01 = box(p02, vec3(0.05, 125.0, 0.05));\n     \tgg += 0.15/(0.05+abs(mat01));   \n    }\n    \n    mat.m = mat02;\n}\n\nvec3 normals(vec3 p)\n{\n \tvec2 uv = vec2(0.01, 0.0);\n    \n    matter m01, m02, m03, m04;\n    \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n    \n    return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n\n    vec3 o = vec3(2.0 * cos(iTime * 0.2), 0.75, 2.0 * sin(iTime * 0.2)), t = vec3(0.0);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p = o + dir * 0.75;\n    \n    matter mat;\n    float d;\n    \n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 150; ++i)\n    {\n     \tmap(mat, p);\n        \n        col += gg * 0.00025 * vec3(1.0, 0.65, 0.75);\n        \n        if(mat.m < 0.01)\n        {\n         \tif(mat.type == 1)\n            {\n             vec3 n = normals(p);\n                dir = reflect(dir, -n);\n                mat.m = 0.25;\n                mat.type = 0;\n                mat.reflected = true;\n                \n            }\n        }\n        \n        \n        \n        p += mat.m * dir * 0.55;\n        d += mat.m * 0.55;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsyyD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt3cD8", "name": "Hyperbolic Band Truchet Tiling", "author": "bulatov", "description": "My first attempt to make something at shadertoy.  \nThe best way to learn is to shamelessly steal nice code by Matt Zucker and add my conformal band tweaks. ", "tags": ["truchet", "tiling", "hyperbolic", "band"], "likes": 19, "viewed": 376, "date": "1608929663", "time_retrieved": "2024-06-20T20:27:33.474706", "image_code": "// Hyperbolic Truchet tiles in the Band Model by Vladimir Bulatov\n// Licence https://creativecommons.org/licenses/by-nc/3.0/us/\n//\n// this is slightly modified code of the shader\n//  https://www.shadertoy.com/view/3llXR4\n// \n// \"Hyperbolic Truchet tiles\" by mattz\n// Licence https://creativecommons.org/licenses/by-nc/3.0/us/\n//\n// Combining my love of Truchet tiling with my newfound \n// interest in hyperbolic geometry.\n\n#define RED vec3(0.8, 0, 0)\n#define BLUE vec3(0, 0, 0.8)\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define LIGHTGRAY vec3(.8)\n#define LIGHTRED vec3(0.9, 0.5, 0.5)\n#define LIGHTBLUE vec3(0.5, 0.5, 0.9)\n\n#define PI 3.141592653589793\n\nconst vec4 NO_INTERSECT = vec4(-1e5);\n\nconst float TOL = 1e-7;\nconst float TOL_SQR = TOL*TOL;\n\n\n//complex multiplication \nvec2 cMul(vec2 a, vec2 b){\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b,b);\n  return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d;\n}\n// complex inverse \nvec2 cInverse(vec2 a) {\n\treturn\tvec2(a.x,-a.y)/dot(a,a);\n}\n\n// complex exponent\nvec2 cExp(vec2 p) {\n\treturn vec2(exp(p.x) * cos(p.y), exp(p.x) * sin(p.y));\n}\n// complex hyperbolic tangent \nvec2 cTanh(vec2 z){\n\n  vec2 e = cExp(z);\n  vec2 e1 = cInverse(e);\n  return cDiv(e - e1,e + e1);\n        \n}\n// converts from band (-1 < y < 1) into unit disc\nvec2 band2disc(vec2 z){\n    return cTanh(z*(PI/4.));\n}\n\n// converts from band (-1 < y < 1) into unit disc\n// and calculates scaled pixel size \nvoid band2disc(inout vec2 p, inout float pixSize){\n\tfloat coeff = (PI/4.);\n\tvec2 pp = cTanh(p*coeff);\n    p = pp;\n\tpixSize /= coeff*length(vec2(1,0) - cMul(pp, pp));\n\t\n}\n\n\n//////////////////////////////////////////////////\n// geometric utility functions\n\n// are two points on the same diameter of the unit circle?\nbool alongDiameter(vec2 p, vec2 q) {\n   \n    vec4 pq = abs(vec4(p, q));\n    float m = max(max(pq.x, pq.y), max(pq.z, pq.w));\n    \n    float k = abs(p.x*q.y - p.y*q.x);\n    \n    return k < TOL*m;\n    \n}\n\n// are two points the same length?\nbool sameLength(float pp, float qq) {\n    return abs(pp - qq) < TOL*max(pp, qq);\n}\n\n// rotate by 90 degrees\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// circle centered at center containing point p\nvec3 compass2D(vec2 ctr, vec2 p) {\n    vec2 diff = p - ctr;\n    return vec3(ctr, dot(diff, diff));\n}\n\n// Construction 1.2: invert a point through a circle\nvec2 invertPC(vec2 p, vec3 c) {\n    vec2 po = p - c.xy;    \n    return c.xy + po * c.z / dot(po, po);\n}\n\n//////////////////////////////////////////////////\n// hyperbolic geometry functions\n\n// distance from a point to a line or circle\nfloat geodesicDist(vec3 l, vec2 p) {\n\tif (l.z > 0.0) {\n\t\treturn length(p-l.xy) - sqrt(l.z);\n\t} else {\n\t\treturn dot(normalize(l.xy), p);\n\t}\n}\n\n// special case of Construction 1.6 for unit circle\nvec3 geodesicFromPole(vec2 p) {\n    float h2 = dot(p, p);\n    float r2 = (h2 - 1.);\n    return vec3(p, r2);\n}\n\n// Polar of a point p about the unit circle\n// 2D line passing thru the midpoint of p and its inverse, perp. to p.\nvec3 polarFromPoint(vec2 p) {\n    return vec3(p, -0.5*dot(p, p) - 0.5);\n}\n\n// invert point about geodesic (either arc or line)\nvec2 reflectPG(vec2 p, vec3 c) {\n    if (c.z == 0.) {\n        return p - (2.*dot(p, c.xy))*c.xy;\n    } else {\n        return invertPC(p, c);\n    }\n}\n\n// Construction 2.2: geodesic from polars of points\nvec3 geodesicFromPoints(vec2 p, vec2 q) {\n    \n    if (alongDiameter(p, q)) {\n        vec2 n = normalize(perp(p - q));\n        return vec3(n, 0);\n    }\n\n    vec3 ppolar = polarFromPoint(p);\n    vec3 qpolar = polarFromPoint(q);\n    vec3 inter = cross(ppolar, qpolar);\n\n    return compass2D(inter.xy/inter.z, p);\n    \n}\n\n\n// return a geodesic passing thru p perpendicular to the diameter\n// through p - undefined if p == (0, 0)\nvec3 geodesicPerpTo(vec2 p) {\n    \n    float a2 = dot(p, p);\n    float x = a2 + 1.;\n    \n    float h_over_a = x / (2.*a2);\n    float h2 = 0.5*x*h_over_a;\n    \n    vec2 c = p * h_over_a;\n    \n    return vec3(c, (h2 - 1.));\n    \n}\n\n// Construction 2.3: hyperbolic compass. \n// construct hyperbolic circle with center p that passes thru q\nvec3 hyperbolicCompass(vec2 p, vec2 q) {\n    \n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) {\n        return vec3(p, (qq));\n    } \n    \n    if (alongDiameter(p, q)) {\n        vec3 pperp = geodesicPerpTo(p);\n        vec2 qp = invertPC(q, pperp);\n        vec2 qmid = 0.5*(q + qp);\n        return compass2D(qmid, q);\n    }\n    \n    // get polars of p and q\n    vec3 ppolar = vec3(p, -0.5*pp - 0.5);\n    vec3 qpolar = vec3(q, -0.5*qq - 0.5);\n    \n    // homogeneous coords of pole of geodesic pq\n    vec3 pole = cross(ppolar, qpolar);\n    \n    // this is the direction from point q to the pole\n    vec2 dqpole = pole.xy - pole.z*q; \n    \n    // 2D line tangent to geodesic pq at q\n    vec3 lq = vec3(dqpole, -dot(dqpole, q));\n    \n    // 2D line containing p and the origin\n    vec3 lp = vec3(perp(p), 0);\n    \n    // homogeneous coords of intersection of these lines\n    vec3 rval = cross(lq, lp);\n    \n    // return circle\n    return compass2D(rval.xy/rval.z, q);\n    \n}\n\n\n// Construction 3.1: Perpendicular bisector\nvec3 hyperbolicBisector(vec2 p, vec2 q) {\n\n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) { \n        \n        // p is at origin\n        float h2 = 1.0/qq;\n        return vec3(q*h2, (h2 - 1.));\n       \n    } else if (qq < TOL_SQR) { \n        \n        // q is at origin                \n        float h2 = 1.0/pp;\n        return vec3(p*h2, (h2 - 1.));\n        \n    } else if (sameLength(pp, qq)) {\n        \n        // p and q are same length, return the diameter\n        return vec3(normalize(p - q), 0);\n        \n    }\n    \n    // this remarkably small piece of code reflects the following algebra:\n    //\n    // let d = q - p be the difference between p & q\n    // let x be the pole of the bisector\n    //\n    // since the pole of the bisector is on the line from p to q, we know\n    //\n    //   x = p + k*d\n    //\n    // for some unknown k with abs(k) > 1 (because the pole isn't between p & q)\n    //\n    // now let's try to solve for k.\n    //\n    // we know that since the pole x is orthogonal to the unit circle, \n    // the radius of the bisector circle is governed by\n    //\n    //   r^2 = ||x||^2 - 1\n    //       = ||p + k*d ||^2 - 1\n    //       = p.p + 2k*p.d + k^2*d.d\n    //\n    // also since p and q are inverted through the bisector circle with radius\n    // r we know\n    //\n    //   r^2 = || x-p || * || x-q || = ||d|| * || k*d - d ||\n    //       = k*(k-1)*d.d \n    //\n    // now we can set the two equations equal and solve for k\n\n    vec2 d = q - p;\n    float k = (1.0 - dot(p,p))/(dot(d,d) + 2.0*dot(p,d));\n    \n    return geodesicFromPole( p + k*d );\n    \n}\n\n// hyperbolic translation to move the origin to point m\nvec2 hyperTranslate(vec2 uv, vec2 m) {\n\n    float mm = dot(m, m);\n    if (mm < TOL_SQR || mm >= 1.) { return uv; }\n\n    vec3 g1 = hyperbolicBisector(vec2(0), m);\n\n    vec2 diff = uv.xy - g1.xy;\n    float k = g1.z / dot(diff, diff);\n    uv.xy = g1.xy + k*diff; \n\n    vec2 n = m / sqrt(mm);\n    uv.xy -= 2.*dot(uv.xy, n)*n;\n    \n    return uv;\n    \n}\n\n// return scalar whose sign indicates side of g that p is on\nfloat sidePG(vec2 p, vec3 g) {\n    if (g.z == 0.) {\n        return dot(p, g.xy);\n    } else {\n        p -= g.xy;\n        return dot(p, p) - g.z;\n    }\n}\n\n// return true if p & q both on the same side of l \nbool sameSide(vec2 p, vec2 q, vec3 l) {\n    return sidePG(p, l) * sidePG(q, l) >= 0.;    \n}\n\n\n\n///////////////////////////////////////////////////\n// utility functions for drawing:\n\n// mix src into dst by smoothstepping k with threshold d\nvoid ink(inout vec3 colorOut, vec3 src, float inkDist) {\n    \n    colorOut = mix(src, colorOut, smoothstep(0.0, 1.0, inkDist));\n    inkDist = 1e5;\n    \n}\n\n// draw either line or circle (using geodesicDist above)\nfloat drawLine(vec3 l, vec2 p, float lineWidth) {\n    return (abs(geodesicDist(l, p.xy))-lineWidth);\n}\n\nfloat drawPoint(vec2 x, vec2 p, float pointSize) {\n    return (length(p - x)-pointSize);\n}\n\n\n// From Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW \nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 colorOut = WHITE;\n    \n    const float diam = 2.0;\n        \n    float kAlt = step(0.1, max(iMouse.z, iMouse.w));\n\n    float rmax = max(iResolution.x, iResolution.y);\n    float rmin = min(iResolution.x, iResolution.y);\n\n    float csize = (rmin);// * 0.999);\n            \n    float px = diam / csize;\n    float invPx = 0.5*(csize / diam);\n    \n    vec2 uv = 2.2*(fragCoord - 0.5*iResolution.xy) * px;\n    band2disc(uv, invPx);\n    const vec3 unitCircle = vec3(0, 0, 1);\n    \n    if (dot(uv, uv) < 1.) {\n\n        // setup 4, 5, 2 triangle\n\n        vec2 verts[3];\n        vec3 edges[3];\n\n        const float cospi5 = 0.8090169943749475; // cos(pi/5)\n        const float sinpi5 = 0.5877852522924731; // sin(pi/5)\n        const float sqrt22 = 0.7071067811865476; // sqrt(2)/2\n\n        float f = sqrt(2./(cospi5*cospi5 - sinpi5*sinpi5));\n\n        float k = (sqrt22*cospi5 - sqrt22*sinpi5)*f;\n\n        float bsz = (cospi5 - sqrt22)*f;\n\n        verts[0] = vec2(0);\n        verts[1] = vec2(k, 0);\n        verts[2] = vec2(0, k);\n        \n        vec2 mid = bsz*vec2(sqrt22, sqrt22);\n        \n        edges[0] = geodesicFromPoints(verts[1], verts[2]);\n        edges[1] = vec3(1, 0, 0);\n        edges[2] = vec3(0, 1, 0);\n\n        vec2 m = (iMouse.xy - 0.5*iResolution.xy) * px;\n        bool scroll = false;\n\n\n        if (dot(m, m) < 0.95) {\n            scroll = true;\n        } else if (m.x < 0.) {\n            float t = iTime*PI/100.0;\n            float r = 0.5*smoothstep(0.0, 4.0, iTime);\n            m = r*vec2(cos(t), sin(t));\n            scroll = true;\n        } else {\n            m = vec2(0);\n        }\n        \n        if (scroll) {\n            for (int i=0; i<3; ++i) {\n                verts[i] = hyperTranslate(verts[i], -m);\n            }\n            for (int i=0; i<3; ++i) {\n                int j = (i+1)%3;\n                int k = 3-i-j;\n                edges[i] = geodesicFromPoints(verts[j], verts[k]);\n            }\n            mid = hyperTranslate(mid, -m);\n        }\n        \n        bool done = false;\n\n        for (int iter=0; iter<64; ++iter) {\n\n            if (done) { continue; }\n\n            int i = 0;\n\n            if (!sameSide(uv, verts[0], edges[0])) {\n                i = 0;\n            } else if (!sameSide(uv, verts[1], edges[1])) {\n                i = 1;\n            } else if (!sameSide(uv, verts[2], edges[2])) {\n                i = 2;\n            } else {\n                done = true;\n                continue;\n            }\n\n            int j = (i+1)%3;\n            int k = 3-i-j;\n\n            mid = reflectPG(mid, edges[i]);\n            verts[i] = reflectPG(verts[i], edges[i]);\n            edges[j] = geodesicFromPoints(verts[i], verts[k]);\n            edges[k] = geodesicFromPoints(verts[i], verts[j]);\n            \n        }\n        \n        float ds = 1.0 - dot(uv, uv);\n\n        vec2 ctr = hyperTranslate(verts[0], m);\n        vec2 seed = floor(12.*ctr + 0.5) + 19.;\n                \n        float r = hash12(seed);\n        \n        float lw = 0.01*ds;\n        float cw = 0.02*ds;\n        float pw = 0.02*ds;\n        \n        float bdist = drawLine(edges[2], uv, lw);\n        float rdist = drawLine(edges[1], uv, lw);\n        \n        float cdist;\n        \n        vec3 altColor;\n                \n        if (r > 0.5) {\n            \n            vec3 c = hyperbolicCompass(verts[1], mid);\n            \n            float d = geodesicDist(c, uv);\n            \n            //altColor = mix(BLACK, WHITE, smoothstep(-0.5*px, 0.5*px, d));\n            altColor = mix(BLACK, WHITE, smoothstep(-0.5/invPx, 0.5/invPx, d));\n            \n            \n            cdist = drawLine(c, uv, cw);\n            ink(colorOut, LIGHTBLUE, bdist*invPx);\n            ink(colorOut, LIGHTRED, rdist*invPx);\n            \n            \n        } else {\n            \n                        \n            vec3 c = hyperbolicCompass(verts[2], mid);\n            \n            float d = geodesicDist(c, uv);\n            \n            altColor = mix(WHITE, BLACK, smoothstep(-0.5/invPx, 0.5/invPx, d));\n            \n            cdist = drawLine(c, uv, cw);\n            ink(colorOut, LIGHTRED, rdist*invPx);\n            ink(colorOut, LIGHTBLUE, bdist*invPx);\n            \n        }\n        \n        ink(colorOut, BLACK, cdist*invPx);\n        ink(colorOut, BLUE, drawPoint(verts[1], uv, pw)*invPx);\n        ink(colorOut, RED, drawPoint(verts[2], uv, pw)*invPx);\n        \n        colorOut = mix(colorOut, altColor, kAlt);\n\n    }\n    \n    //ink(colorOut, BLACK, drawLine(unitCircle, uv, 0.5*px)*invPx);\n    \n    colorOut = sqrt(colorOut);\n    \n    fragColor = vec4(colorOut, 1);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt3cDN", "name": "pixel-49178.0", "author": "jorge2017a1", "description": "pixel-49178.0", "tags": ["pixel491780"], "likes": 2, "viewed": 54, "date": "1609099579", "time_retrieved": "2024-06-20T20:27:33.480820", "image_code": "//autor desconocido\n//http://glslsandbox.com/e#49178.0\n\n#define pixelSize 0.03\n#define black vec3(0)\n#define red vec3(1,0,0)\n#define skin vec3(0.89,0.95,0.85)\n#define blue1 vec3(0.55,0.64,0.75)\n#define blue2 vec3(0.07,0.07,0.49)\n#define green1 vec3(0.45,1,0)\n#define green2 vec3(0.23,0.82,0.38)\n#define green3 vec3(0.18,0.62,0.29)\nvec2 uv;\nvec3 colorBuffer;\n\nvoid setPixel(float x, float y, vec3 color){\n\tx *= pixelSize;\n        y *= pixelSize;\n\tif(uv.x > x && uv.y > y  && uv.y - y < pixelSize && uv.x - x < pixelSize ){\n\tcolorBuffer = color;\t\n\t}\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nuv = gl_FragCoord.xy/iResolution.xy * vec2(iResolution.x/iResolution.y,1);\nvec3 col = 0.5 + 0.5*cos(0.1250*iTime*dot(uv.xyx,vec3(0.2,0.5,1.)) +uv.xyx+vec3(0,2,4));\n\n    //colorBuffer = vec3(1);\n    colorBuffer = col;\n    \n    \n\tsetPixel(30.0,5.0,black);\n\tsetPixel(31.0,5.0,black);\n\tsetPixel(32.0,5.0,black);\n\tsetPixel(33.0,5.0,black);\n\tsetPixel(34.0,5.0,black);\n\tsetPixel(30.0,6.0,red);\n\tsetPixel(31.0,6.0,red);\n\tsetPixel(32.0,6.0,red);\n\tsetPixel(31.0,7.0,red);\n\tsetPixel(32.0,7.0,red);\n\tsetPixel(33.0,7.0,red);\n\tsetPixel(32.0,8.0,red);\n\tsetPixel(33.0,8.0,red);\n\tsetPixel(31.0,8.0,skin);\n\tsetPixel(30.0,8.0,skin);\n\tsetPixel(34.0,8.0,skin);\n\tsetPixel(30.0,9.0,skin);\n\tsetPixel(30.0,10.0,skin);\n\tsetPixel(32.0,9.0,black);\n\tsetPixel(33.0,9.0,black);\n\tsetPixel(31.0,9.0,black);\n\tsetPixel(31.0,10.0,black);\n\tsetPixel(32.0,10.0,black);\n\tsetPixel(33.0,10.0,black);\n\tsetPixel(32.0,11.0,black);\n\tsetPixel(31.0,11.0,skin);\n\tsetPixel(33.0,11.0,blue1);\n\tsetPixel(32.0,12.0,blue1);\n\tsetPixel(31.0,12.0,black);\n\tsetPixel(30.0,12.0,black);\n\tsetPixel(29.0,12.0,black);\n\tsetPixel(28.0,12.0,black);\n\tsetPixel(27.0,13.0,black);\n\tsetPixel(27.0,14.0,black);\n\tsetPixel(27.0,15.0,black);\n\tsetPixel(27.0,16.0,black);\n\tsetPixel(26.0,14.0,green2);\n\tsetPixel(26.0,15.0,green3);\n\tsetPixel(25.0,16.0,green3);\n\tsetPixel(25.0,17.0,green1);\n\tsetPixel(33.0,12.0,black);\n\tsetPixel(34.0,12.0,black);\n\tsetPixel(35.0,12.0,black);\n\tsetPixel(36.0,13.0,black);\n\tsetPixel(37.0,14.0,green2);\n\tsetPixel(37.0,15.0,green2);\n\tsetPixel(36.0,15.0,blue1);\n\tsetPixel(36.0,16.0,blue1);\n\tsetPixel(35.0,17.0,blue1);\n\tsetPixel(34.0,17.0,blue1);\n\tsetPixel(34.0,16.0,blue1);\n\tsetPixel(33.0,17.0,blue1);\n\tsetPixel(32.0,17.0,blue1);\n\tsetPixel(28.0,16.0,blue1);\n\tsetPixel(28.0,17.0,black);\n\tsetPixel(29.0,17.0,black);\n\tsetPixel(30.0,17.0,black);\n\tsetPixel(31.0,17.0,black);\n\tsetPixel(31.0,16.0,skin);\n\tsetPixel(30.0,16.0,skin);\n\tsetPixel(31.0,15.0,skin);\n\tsetPixel(30.0,15.0,skin);\n\tsetPixel(31.0,14.0,skin);\n\tsetPixel(30.0,14.0,skin);\n\tsetPixel(31.0,13.0,skin);\n\tsetPixel(30.0,13.0,skin);\n\tsetPixel(33.0,16.0,skin);\n\tsetPixel(32.0,16.0,skin);\n\tsetPixel(33.0,15.0,skin);\n\tsetPixel(32.0,15.0,skin);\n\tsetPixel(33.0,14.0,skin);\n\tsetPixel(32.0,14.0,skin);\n\tsetPixel(33.0,13.0,skin);\n\tsetPixel(32.0,13.0,skin);\n\tsetPixel(36.0,14.0,skin);\n\tsetPixel(35.0,13.0,skin);\n\tsetPixel(34.0,13.0,skin);\n\tsetPixel(35.0,14.0,blue2);\n\tsetPixel(35.0,15.0,blue2);\n\tsetPixel(35.0,16.0,blue2);\n\tsetPixel(29.0,14.0,blue2);\n\tsetPixel(29.0,15.0,blue2);\n\tsetPixel(29.0,16.0,blue2);\n\tsetPixel(34.0,14.0,skin);\n\tsetPixel(34.0,15.0,skin);\n\tsetPixel(29.0,13.0,skin);\n\tsetPixel(28.0,13.0,skin);\n\tsetPixel(28.0,14.0,skin);\n\tsetPixel(28.0,15.0,skin);\n\tsetPixel(28.0,18.0,red);\n\tsetPixel(29.0,18.0,red);\n\tsetPixel(27.0,18.0,red);\n\tsetPixel(27.0,17.0,red);\n\tsetPixel(30.0,18.0,red);\n\tsetPixel(31.0,18.0,red);\n\tsetPixel(32.0,18.0,red);\n\tsetPixel(33.0,18.0,red);\n\tsetPixel(34.0,18.0,red);\n\tsetPixel(35.0,18.0,red);\n\tsetPixel(36.0,18.0,red);\n\tsetPixel(36.0,17.0,red);\n\tsetPixel(37.0,18.0,red);\n\tsetPixel(38.0,18.0,red);\n\tsetPixel(28.0,19.0,red);\n\tsetPixel(29.0,19.0,skin);\n\tsetPixel(30.0,19.0,skin);\n\tsetPixel(31.0,19.0,skin);\n\tsetPixel(32.0,19.0,skin);\n\tsetPixel(33.0,19.0,skin);\n\tsetPixel(34.0,19.0,skin);\n\tsetPixel(35.0,19.0,skin);\n\tfragColor = vec4( vec3(colorBuffer), 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt3cW8", "name": "Shaping function porn", "author": "Commander_Asdasd", "description": "rework of https://www.shadertoy.com/view/XsXXDn", "tags": ["shaping"], "likes": 1, "viewed": 82, "date": "1608921707", "time_retrieved": "2024-06-20T20:27:33.668630", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nfloat map(float val, float lo1, float hi1, float lo2, float hi2) {\n  return lo2 + (val - lo1) * (hi2-lo2)/(hi1)-(lo1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp.x -= map(sin(iTime),-1.,1.,-.2,-.6);\n        p.y -= map(cos(iTime),-1.,1.,-.2,-.5);\n\t\tp.x*=r.x/r.y; \n\t\tz+=tan(iTime);\n\t\tl=clamp(p.x,0.,1.);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt3yRr", "name": "Random Complex Polar Grid", "author": "jllusty", "description": "Plots a uniform grid with random colors transformed by a complex function.", "tags": ["grid", "random", "complex"], "likes": 13, "viewed": 135, "date": "1608331848", "time_retrieved": "2024-06-20T20:27:33.674725", "image_code": "float pi = 4.*atan(1.);\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rand(vec2 n) { \n\tfloat a = fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    float b = fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    return vec2(a,b);\n}\n\nfloat rand1(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 mond(vec2 n) {\n    float theta = rand1(atan(n.y, n.x));\n    vec3 c1 = vec3(250., 201., 1.)/255.;\n    vec3 c2 = vec3(1.);\n    vec3 c3 = vec3(34., 80., 149.)/255.;\n    vec3 c4 = vec3(1.);\n    vec3 c5 = vec3(221., 1., 0.)/255.;\n    float c = theta;\n    if(c < 1./5.) { return c1; }\n    if(c < 2./5.) { return c2; }\n    if(c < 3./5.) { return c3; }\n    if(c < 4./5.) { return c4; }\n    return c5;\n}\n\nvec2 mult(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 func(in vec2 z) {\n    return mult(z - vec2(2.0*(1.0 + 0.5*sin(iTime/3.)), 0.0)*rotate(iTime/4.), z + vec2(2.0f*(1.0 + 0.5*sin(iTime/3.)), 0.0)*rotate(iTime/4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =  5.* ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 pos = uv;\n    \n    uv = func(uv);\n\n    float r = length(uv)/4.;\n    \n    if (int(floor(r)) % 2 == 0) {\n        float freq = 1.5*rand(vec2(floor(r),1)).y;\n        uv *= rotate(freq*iTime);\n    }\n    else {\n        float freq = 2.*rand(vec2(floor(r),-1)).y;\n        uv *= rotate(-freq*iTime);\n    }\n    \n    float theta = atan(uv.y,uv.x)+pi;\n\n    float n = 7.;    \n    float eps = 5./iResolution.x;\n    float gEps = 0.01;\n    float stretch = length(func(pos+vec2(gEps,0.))-func(pos))/gEps;\n    float dt = abs(mod(theta+pi/n,2.*pi/n)-pi/n)/stretch;\n    float ct = smoothstep(2.*eps,eps,dt*r);\n    if (r < 1.)  { dt = dt/r; }\n    \n    //lr = ceil(log2(r+1.))-log2(r+1.)/(ceil(log2(r+1.))-floor(log2(r+1.)));\n    float dr = abs(fract(r+.5)-.5)/stretch;\n    float cr = smoothstep(2.*eps,eps,dr);\n    float cc = max(ct,cr);\n    \n    vec2 dc = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    \n    //vec2 rv = rand(vec2(floor(n*theta/(2.0*pi)),floor(r)));\n    //vec3 pal = mond(rv);\n    \n    float val = dot(dc, vec2(1));\n    // IQ's versatile cosine palette.\n    vec3 col = .5 + .47*cos(6.2831*val + vec3(0, 1, 2));\n    col = mix(col, vec3(0), cc);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n    //vec3 col = mix(pal,vec3(0.),cc);\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt3yRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wt3yWr", "name": "learning_process_8", "author": "lossushi", "description": "Ended far from  the circle drawing function.\nI find it pretty nonetheless.\nMaybe I should add music.", "tags": ["beginner"], "likes": 0, "viewed": 33, "date": "1608760957", "time_retrieved": "2024-06-20T20:27:33.674725", "image_code": "float circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(max(cos(_st.x*iTime*9.), sin(_st.y*iTime*9.)));\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    col = vec3(circle(uv,2.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3yWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt3yz7", "name": "Jello lens", "author": "Shellderr", "description": "jello lens", "tags": ["lens", "jello"], "likes": 0, "viewed": 51, "date": "1608670293", "time_retrieved": "2024-06-20T20:27:33.674725", "image_code": "#define rr(s) (s*0.5+0.5)\n#define dst(v) (length(uv-v))\n\nvec2 bnc(float t,vec2 p){\n    return abs(fract(p*t*0.05)-0.5)*4.-1.;\n}\n\nfloat ss(float t){\n    return (3.*sin(t)*sin(t)+2.*cos(t)) *sin(t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float mm = 7.;\n    float mag = 9.0;\n    \n    mm += 10.*iMouse.y/iResolution.y;\n\n    vec2 p = bnc(iTime,vec2(3.22,4.64));\n    vec2 p2 = bnc(iTime,vec2(2.72,3.74));\n    vec2 p3 = bnc(iTime,vec2(3.88,1.87));\n\n    float d = (1.+log(mag+log(1.0+(sin(dst(p)*mm)))));\n    \n    d *= (1.+log(mag+log(1.0+(sin(dst(p2)*mm)))));\n    d *= (1.+log(mag+log(1.0+(sin(dst(p3)*mm)))));\n\n    d += dst(vec2(0.))*33.;\n    \n    fragColor =  vec4( vec3( rr(ss(d)),0., rr(ss(d)) ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt3yz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wt3yzr", "name": "bell curve test", "author": "tshrpl", "description": "just a test", "tags": ["sdf", "bellcurve"], "likes": 0, "viewed": 36, "date": "1608311887", "time_retrieved": "2024-06-20T20:27:34.989871", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\nfloat bellSDF(vec3 p) {\n    p += vec3(0.,-sin(iTime),0.);\n\n    float e = 2.71828;\n    \n    highp float A = 1.;\n\thighp float F = 1.;\n\thighp float P = 1.;\n\n\tfloat s = p.x*p.x+p.z*p.z;\n\tfloat M = pow(e, (-s / F)) * A;\n\tfloat N = sin(sqrt(s)+P);\n\n    return abs(p.y - M) - 0.01;\n}\n\nfloat sineSDF(vec3 p) {\n    // p += vec3(0.,-sin(iTime),0.);\n    \n\thighp float P = iTime;\n\n\tfloat s = p.x*p.x+p.z*p.z;\n\tfloat N = sin(sqrt(s)+P);\n\n    return abs(p.y - N) - 0.01;\n}\n\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    // return cubeSDF(samplePoint);\n    // return bellSDF(samplePoint);\n    return sineSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3yzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtccDn", "name": "masking effects (vlllll)", "author": "valalalalala", "description": "Playing around with some different filters to mask color in different ways. \n\n", "tags": ["raymarching", "filters", "masks"], "likes": 2, "viewed": 48, "date": "1608761505", "time_retrieved": "2024-06-20T20:27:37.226588", "image_code": "/////////////////////////////////////////////////////////////////////////////\n//\n// \"Marching with Camera\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// starting from https://www.shadertoy.com/view/tsyfDw\n//\n// Largely inspired by https://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n//\n/////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////\n// shader specific controls\n\n// When true, the filter is picked based on mouse.x and the orientation by mouse.y\nbool DEMO_MODE = true; // toggled with space key\n\nbool CAMERA_MOUSE = false;\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching values\n\n#define RAY_MARCH_STEPS    99\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    0.004\n#define RAY_EPSILON        vec2( RAY_MARCH_CLOSE, .0 )\n\n/////////////////////////////////////////////////////////////////////////////\n// anti-aliasing\n\n#define ANTI_ALIAS_STEPS    3\n#define ANTI_ALIAS_DISTANCE 2.\n\n/////////////////////////////////////////////////////////////////////////////\n// useful constants and macros\n\n#define PI2             6.283185307179586\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define RGB(r,g,b)      vec3( float(r)/255., float(g)/255., float(b)/255. )\n#define MAX3(v)         max( v.x, max( v.y, v.z ) ) \n#define EQUALS(a,b)     step( a-1e-11, b ) * step( b-1e-11, a )\n\n/////////////////////////////////////////////////////////////////////////////\n// fun with masking\n\n#define SCALE 1.\n\nfloat mesh( vec2 p ) {\n    p = fract( SCALE * p );\n    return smoothstep( .0, .1,  p.x * p.y );\n}\n\nfloat tooth( vec2 p ) {\n    p = fract( SCALE * p );\n    return smoothstep( .9, .4, min(p.x,p.y) / max(p.x,p.y) );\n}\n\nfloat check( in vec2 p ) {\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n\nfloat triangle( in vec2 p ) {\n    p = fract( SCALE * p );\n    return p.x + p.y;\n}\n\nfloat seed( in vec2 p ) {\n    p = fract( SCALE * p );\n    return abs( p.y - p.x );\n}\n\nfloat dark( in vec2 p ) {\n    p = fract( SCALE * p );\n    return p.y - p.x;\n}\n\nfloat emboss( in vec2 p ) {\n    p = fract( SCALE * p );\n    return ( cos( p.x ) + sin( p.y ) +2. ) / 4.;\n}\n\nfloat sechs( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = abs( cos( p.x - p.y ) );\n    return smoothstep( .88, .89, f );\n}\n\nfloat linx( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( p.x - p.y ) ) * .91;\n    return smoothstep( .79, .80, f ) - smoothstep( .82, .83, f );\n}\n\nfloat dashes( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( p.x - p.y ) );\n    return smoothstep( .95, .96, f ) - smoothstep( .97, .98,  f );\n}\n\nfloat ells( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( max(p.x,p.y) ) );\n    return smoothstep( .5, .61, f ) - smoothstep( .7, .71, f );\n}\n\nfloat grid( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = abs( max(p.x,p.y ) );\n    return smoothstep( .92, .93, f );\n}\n\nfloat idk( in vec2 p ) {\n    p = fract( SCALE * p );\n    float f = ( cos( max(p.x,p.y) ) );\n    return smoothstep( .5, .71, f ) - smoothstep( .96, .951, f );\n    return smoothstep( .5, .66, f );\n}\n//\n\nfloat mask( in vec3 point, in vec2 control ) {\n    //return idk( point.xz );\n    \n    float orientation = floor( control.y * 8. );\n    \n    vec2 oz = point.xz;\n    oz += point.xx * EQUALS( 0., orientation );\n    oz += point.xy * EQUALS( 1., orientation );\n    oz += point.xz * EQUALS( 2., orientation );\n    \n    oz += point.yy * EQUALS( 3., orientation );\n    oz += point.yx * EQUALS( 4., orientation );\n    oz += point.yz * EQUALS( 5., orientation );   \n    \n    oz += point.zz * EQUALS( 6., orientation );\n    oz += point.zx * EQUALS( 7., orientation );\n    oz += point.zy * EQUALS( 8., orientation );   \n    \n    float which = floor( control.x * 11. );\n\n    float masked = .0;\n    \n#if 1\n    masked += mesh( oz )     * EQUALS( 0., which );\n    masked += tooth( oz )    * EQUALS( 1., which );\n    masked += check( oz )    * EQUALS( 2., which );\n    masked += triangle( oz ) * EQUALS( 3., which );\n    masked += seed( oz )     * EQUALS( 4., which );\n    masked += dark( oz )     * EQUALS( 5., which );\n    masked += emboss( oz )   * EQUALS( 6., which );\n    masked += linx( oz )     * EQUALS( 7., which );\n    masked += dashes( oz )   * EQUALS( 8., which );\n    masked += ells( oz )     * EQUALS( 9., which );\n    masked += sechs( oz )    * EQUALS( 10., which );\n    masked += grid( oz )     * EQUALS( 11., which );\n#else\n    switch( int( which ) ) {\n        case 0:    masked = mesh( oz )     ; break;\n        case 1:    masked = tooth( oz )    ; break;\n        case 2:    masked = check( oz )    ; break;\n        case 3:    masked = triangle( oz ) ; break;\n        case 4:    masked = seed( oz )     ; break;\n        case 5:    masked = dark( oz )     ; break;\n        case 6:    masked = emboss( oz )   ; break;\n        case 7:    masked = linx( oz )     ; break;\n        case 8:    masked = dashes( oz )   ; break;\n        case 9:    masked = ells( oz )     ; break;\n        case 10:   masked = sechs( oz )    ; break;\n        case 11:   masked = grid( oz )     ; break;\n     }\n#endif\n    \n    return clamp( masked, .0, 1. ) + .1; // avoid total darkness\n}\n\nfloat mask( in vec3 point ) {\n    return DEMO_MODE \n    ? mask( point, .5 + TRIG( .5, iTime * .05 ) )\n    : mask( point, iMouse.xy / iResolution.xy );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// signed distance functions for types\n\nfloat sdSphere( in vec3 point, in float radius ) {\n    return length( point ) - radius;\n}\n\nfloat sdBox( in vec3 point, in vec3 size ) {\n    return MAX3( ( abs( point ) - size ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// create the scene\n\n#define BALL   1.\n#define BOX    2.\n#define BACK   3.\n#define FRONT  4.\n\n#define TOP    5.\n#define FLOOR  6.\n#define LEFT   7.\n#define RIGHT  8.\n\nvec2 which( in vec2 current, in float test, in float what ) {\n    current.y = mix( current.y, what, step( test, current.x ) );\n    current.x = min( current.x, test );\n    return current;\n}\n\nfloat box( in vec3 point ) {\n    return sdBox( point - vec3( 3., .1, 3.) , vec3( 1. ) );\n}\n\nfloat boxm( in vec3 point, float m ) {\n    return sdBox( point - vec3( 3., .1, -3. ), vec3( 1. ) ) - m;\n}\n\nfloat ball( in vec3 point ) {\n    return sdSphere( point + vec3( 3., -.5, 3. ), 1.33 );\n}\n\nfloat ballm( in vec3 point, float m ) {\n    return sdSphere( point + vec3( 3., -.5, -3. ), 1.33 ) - m;\n}\n\nvec2 sceneDistance( in vec3 point ) {\n    float w = 8.;\n    float h = w * 2. / 3.;\n    \n    float m = mask( point ) * .33; \n    \n    vec2 closest = vec2( RAY_MARCH_TOO_FAR );\n    \n    closest = which( closest, box( point ),  BOX );\n    closest = which( closest, ball( point ), BALL );\n\n    closest = which( closest, boxm( point, m ),  BOX );\n    closest = which( closest, ballm( point, m ), BALL );\n    \n    closest = which( closest, point.z + w,   BACK );\n    closest = which( closest, w - point.z,   FRONT );\n\n    closest = which( closest, h - point.y,   TOP );\n    closest = which( closest, point.y +1.,  FLOOR );\n    \n    closest = which( closest, point.x + w,   LEFT );\n    closest = which( closest, w - point.x,   RIGHT );\n    \n    return closest;\n}\n\n\nvec3 colorAt( in vec3 point, vec2 d ) {\n    vec3 color = vec3( .0 );\n  \n    color += RGB( 255,  33,  33 ) * EQUALS( d.y, BALL   );\n    color += RGB(  33, 255,  33 ) * EQUALS( d.y, BOX    );\n    color += RGB(  33,  33, 255 ) * EQUALS( d.y, BACK   );\n    \n    color += RGB( 255, 255,  33 ) * EQUALS( d.y, FRONT  );\n    color += RGB(  33, 255, 255 ) * EQUALS( d.y, TOP    );\n    color += RGB( 255,  33, 255 ) * EQUALS( d.y, FLOOR  );\n    \n    color += RGB( 255, 210, 120 ) * EQUALS( d.y, LEFT   );\n    color += RGB( 120, 210, 255 ) * EQUALS( d.y, RIGHT  );\n    \n    color *= mask( point );\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the ray marching bits\n\n#define THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\nvec2 rayMarch( in vec3 origin, in vec3 direction ) {\n    vec2 total = vec2(.0);\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total.x;        \n\n        vec2 current = sceneDistance( point );\n\n#ifdef THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }\n        // Note: Ray advancement occurs after checking for a surface hit.\n        //\n        // Ray shortening: Shorter for the first few iterations.\n        total.x += i<32? current.x*.35 : current.x*.85; \n        total.y = current.y;\n#else\n        total.x += current.x;\n        total.y = current.y;\n\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }     \n#endif\n    }\n    return total;\n}\n\nvec3 sceneNormal( in vec3 point ) {\n    return normalize( sceneDistance( point ).x - vec3(\n        sceneDistance( point - RAY_EPSILON.xyy ).x,\n        sceneDistance( point - RAY_EPSILON.yxy ).x,\n        sceneDistance( point - RAY_EPSILON.yyx ).x\n    ));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// lighting\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight ).x;\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point, vec2 d ) {\n    vec2 T = TRIG(2.,iTime);\n    vec4 light    = vec4( T.x, 3., T.y, 3. );\n    float ambient = 0.307;\n    float gamma   = 1.33;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    vec3 color = colorAt( point, d );\n\treturn vec3( color * ambient + color * lighting );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// simple camera\n\nstruct Ray {\n    vec3 eye;\n    vec3 direction;\n};\n\n// from https://github.com/glslify/glsl-look-at\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3( sin( roll ), cos( roll ), .0 );\n\tvec3 zz = normalize( target - origin );\n\tvec3 xx = normalize( cross( zz, up ) );\n\tvec3 yy = normalize( cross( xx, zz ) );\n\treturn mat3( xx, yy, zz );\n}\n\nRay cameraRay( in vec2 uv ) {\n    vec3 eye, look;\n    float zoom, roll;\n    if ( CAMERA_MOUSE ) {\n        vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;\n        vec2 T = TRIG( 4., mx.x * PI2 );\n        \n        eye  = vec3( T.x, mx.y * 6. + 1. , T.y );\n        look = vec3( 0. );\n    \n        zoom = 1.;\n        roll = .0;\n    } else {\n        vec2 T = TRIG( 1., iTime * .1 );\n    \n        eye  = vec3( 6. * T.x, 2., 6. * T.y );\n        look = vec3( .0, 0, .0 );\n    \n        roll = 0.2 * T.x;\n        zoom = 1. + .25 * abs( sin( iTime * .66 ) );\n    }\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );\n \n    return Ray( eye, direction );\n}\n\n// from https://www.shadertoy.com/view/4dsGRl\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// main function\n\nvec3 mainly( in vec2 fragCoord ) {\n\t//vec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n\n    \n    Ray ray = cameraRay( uv );\n    vec2 d = rayMarch( ray.eye, ray.direction );\n    float missed = step( RAY_MARCH_TOO_FAR, d.x );\n    \n    vec3 point = ray.eye + ray.direction * d.x;\n        \n    vec3 background = vec3( 3.6 );\n    vec3 color = colorPoint( point, d );\n    \n    return mix( color, background, missed );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tDEMO_MODE = ReadKey( 32, true );\n    CAMERA_MOUSE = ReadKey( 13, true );\n\n    \n#if ANTI_ALIAS_STEPS == 1\n    fragColor = vec4( mainly( fragCoord ) , 1. );\n#else\n    vec3 color = vec3( .0 );\n    float a = ANTI_ALIAS_DISTANCE / float( ANTI_ALIAS_STEPS );\n    \n    for ( int y = 0 ; y < ANTI_ALIAS_STEPS ; y++ ) {\n        float ya = float( y ) * a; \n        for ( int x = 0 ; x < ANTI_ALIAS_STEPS ; x++ ) {\n            vec2 aa = vec2( float( x ) * a, ya );          \n            color += mainly( fragCoord + aa );\n        }\n    }\n    fragColor = vec4( color / float( ANTI_ALIAS_STEPS * ANTI_ALIAS_STEPS ), 1. );\n       \n#endif\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtccDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtccR4", "name": "Floppy Column", "author": "dr2", "description": "Self-bending metallic sculpture", "tags": ["reflection", "coordinates", "bend"], "likes": 13, "viewed": 232, "date": "1608551284", "time_retrieved": "2024-06-20T20:27:37.254842", "image_code": "// \"Floppy Column\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on \"Decalled Floppy Tube 2\"\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nmat3 StdVuMat (float el, float az);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, qHit;\nfloat tCur, tCyc, dstFar, dLoop, sLoop, rCyl, tubRot, bCylRad, bCylHt;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b, c;\n  float dMin, d, hBase, aLoop, lb, s, rc;\n  dMin = dstFar;\n  hBase = 1.;\n  aLoop = 0.25 * pi / sLoop;\n  rc = 0.01;\n  q = p;\n  q.y -= 2. * hBase;\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  d = max (PrRoundBoxDf (vec3 (q.x, Rot2D (q.yz, - tubRot)), vec3 (rCyl - rc), rc),\n     -0.01 - q.x);\n  q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n  b = vec2 (length (q.xy) - dLoop, q.z);\n  b.xy = Rot2D (b.xy, tubRot);\n  lb = length (b);\n  s = PrRoundBox2Df (b, vec2 (rCyl - rc), rc);\n  d = min (d, max (s, dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)))));\n  c = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  s = max (PrRoundBoxDf (vec3 (Rot2D (vec2 (c.x, q.z), - tubRot), c.y).xzy,\n     vec3 (rCyl - rc), rc), -0.01 - c.y);\n  d = min (d, s);\n  qHit = vec3 (vec2 (atan (q.y, - q.x) * dLoop / (0.25 * pi), atan (b.x, b.y)) / pi, lb);\n  DMIN (1);\n  q = p;\n  q.y -= hBase - 0.5 * rCyl;\n  d = PrRoundBoxDf (q, vec3 (0.8 * rCyl, hBase - 0.5 * rCyl, 0.8 * rCyl) - 0.05, 0.05);\n  DMIN (2);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vn.xz = - s.xz / bCylRad;\n    else {\n      d = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 vc, db4;\n  vec3 ltDir, vn, col, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, f, ga, ltDist, sh;\n  bool isLit;\n  isLit = true;\n  db4 = InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  if (vnCyl.y == 0.) {\n    ro += dCyl * rd;\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (32. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col = vec3 (0.1, 0.2, 0.5);\n      isLit = false;\n    } else {\n      col = vec3 (0.4);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col = vec3 (0.65);\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05,\n             16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          col = vec3 (0.7, 0.75, 0.7);\n          qw = 8. * vec2 (12. * a, 2. * hy);\n          rg = ShStagGrid (qw);\n          col *= rg.y * (1. - 0.2 * Noisefv2 (32. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    ro += dCyl * rd;\n    vc = HexVor (0.7 * ro.zx);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.y, 4., - vc.z)),\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col = vec3 (0.65, 0.62, 0.6) * (0.7 + 0.3 * b * step (0.06 + 0.03 * vc.w, vc.x) *\n       (1. - 0.3 * Noisefv2 (16. * ro.xz)));\n  } else {\n    ro += dCyl * rd;\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = 0.; n < 128.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0.2, 0.2, 0.4), vec3 (1., 1., 0.7), f);\n    isLit = false;\n  }\n  if (isLit) {\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    sh = (vnCyl.y > -0.5) ? ObjSShadow (ro, ltDir, ltDist) : 1.;\n    col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir;\n  float dstObj, tCyc, t, sh, ltDist;\n  bool doRefl;\n  tCyc = 20.;\n  t = tCur / tCyc;\n  tubRot = mod (5. * t, 2. * pi);\n  sLoop = 1./2. + 20. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (t, 1.)), 8.);\n  dLoop = 6. * sLoop;\n  rCyl = 1.5;\n  HexVorInit ();\n  doRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == 1) {\n    ro += dstObj * rd;\n    doRefl = true;\n    rd = reflect (rd, ObjNf (ro));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (1.);\n    else if (idObj == 2) col = vec3 (0.5);\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    sh = ObjSShadow (ro, ltDir, ltDist);\n    col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.));\n  } else col = BgCol (ro, rd);\n  if (doRefl) col = mix (col, 0.9 * BgCol (ro, rd), 0.9);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, tSmooth, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.05 * pi;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    t = mod (0.005 * tCur, 2.);\n    tSmooth = (floor (32. * t) + smoothstep (0.9, 1., mod (32. * t, 1.))) / 32.;\n    az = 2.5 * pi * (0.5 - abs (tSmooth - 1.));\n  }\n  el = clamp (el, -0.2 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  bCylRad = 32.;\n  bCylHt = 12.;\n  ro = vuMat * vec3 (0., 0., -0.95 * bCylRad);\n  ro.y += 0.5 * bCylHt;\n  zmFac = 3.5;\n  dstFar = 3. * bCylRad;\n  ltPos = vec3 (0., 1.5 * bCylHt, 0.9 * bCylRad);\n  ltPos.xz = Rot2D (ltPos.xz, -0.2 * pi);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtccR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtccRN", "name": "Linear Array Factor", "author": "Diapsid", "description": "Displays the log of the array factor of a linear array. ", "tags": ["array"], "likes": 0, "viewed": 39, "date": "1608523646", "time_retrieved": "2024-06-20T20:27:37.571919", "image_code": "float log10(float n){\nreturn log(n)/log(10.);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float PI = 3.14159263;\n    float freq;\n    float dist;\n    float t;\n    int numEl;\n    float phaseDif;\n    \n    freq = 100.; //busyness of screen\n    t = iTime*0.1*60.; //a timing constant\n    dist =PI/freq; //inter-element distance. Set to PI/freq \n    //for max directivity without additional grating lobes\n    numEl = 5; //number of radiators\n    phaseDif = radians(0.); //set this to double the desired beam angle\n    \n    \n    float col = 0.; //color variable\n\n    for(int i = 0; i<numEl; i++){\n    uv = fragCoord/iResolution.xy; //reset coordinate plane\n    uv.y-=0.5; //move up on the screen\n    uv.x-=0.5-dist*(float(i)+1.)+float(numEl)*dist/2.; \n    col+=(5./float(numEl))*cos(freq*length(uv)-t-phaseDif*float(i));\n\n    }\n    col=abs(col);\n    uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x+=0.0053*(300./freq); //idk why I need this offset, but without it the pattern is very slightly assymetrical\n    col=log10(col/(20.*pow(length(uv), 2.)));//magnitude should \n    //fall off as distance squared. Then lake the logarithm for display purposes\n    \n    \n    vec3 c = vec3(col*0.4, 0.997, col*100.); //the constants here were found by experimentation\n    //play around with them if you want different colors.\n    c = hsv2rgb(c);\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtccRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtccWN", "name": "Floating Sandbox Water Surface", "author": "GabrieleGiuseppini", "description": "Experiments for water surface in Floating Sandbox.", "tags": ["floatingsandboxwater"], "likes": 2, "viewed": 65, "date": "1609185026", "time_retrieved": "2024-06-20T20:27:38.165960", "image_code": "vec4 CalculateOceanPlaneColor(vec4 baseColor, float yWorld, float yBackWorld, float yMidWorld, float yFrontWorld, float backPlaneToggle)\n{\n    #define BorderWidthHalf 0.1\n\n    // Enlarge borders for steep vertical edges and for world dimensions\n    float worldDimensionsAdjustment = abs(dFdy(yWorld)) * 1.5;\n    float borderWidthHalfBack = BorderWidthHalf + abs(dFdx(yBackWorld)) + worldDimensionsAdjustment;\n    float borderWidthHalfMid = BorderWidthHalf + abs(dFdx(yMidWorld)) + worldDimensionsAdjustment;\n    float borderWidthHalfFront = BorderWidthHalf + abs(dFdx(yFrontWorld)) + worldDimensionsAdjustment;\n\n    // Color\n\n    // 1 when yWorld is below middle of the border, 0 otherwise\n    float baseColorBack = step(yWorld, yBackWorld - borderWidthHalfBack);\n    float baseColorMid = step(yWorld, yMidWorld - borderWidthHalfMid);\n    float baseColorFront = step(yWorld, yFrontWorld - borderWidthHalfFront);\n\n    float baseColorAlpha =\n        max(\n            1. * baseColorFront,\n            max(\n                .6 * baseColorMid * backPlaneToggle,\n                .5 * baseColorBack * backPlaneToggle));\n\n    //return vec4(baseColor, baseColorAlpha);\n\n    // Border\n\n    float borderBack =\n        1. - smoothstep(0., borderWidthHalfBack, abs(yWorld - (yBackWorld - borderWidthHalfBack)));\n\n    float borderMid =\n        1. - smoothstep(0., borderWidthHalfMid, abs(yWorld - (yMidWorld - borderWidthHalfMid)));\n\n    float borderFront =\n        1. - smoothstep(0., borderWidthHalfFront, abs(yWorld - (yFrontWorld - borderWidthHalfFront)));\n\n    // epsilon when front is visible, 1 otherwise\n    #define FrontObscuredAlpha 0.4\n    float borderFrontOpaqueness = (1. - baseColorFront) * (1. - FrontObscuredAlpha) + FrontObscuredAlpha;\n\n    // epsilon when mid is visible, 1 otherwise\n    #define MidObscuredAlpha 0.4\n    float borderMidOpaqueness = (1. - baseColorMid) * (1. - MidObscuredAlpha) + MidObscuredAlpha;\n\n    float borderAlpha =\n        max(\n            1. * borderFront,\n            max(\n                .9 * borderMid * borderFrontOpaqueness * backPlaneToggle,\n                .7 * borderBack * borderFrontOpaqueness * borderMidOpaqueness * backPlaneToggle));\n\n    //return vec4(1., 1., 1., borderAlpha);\n\n    // Combine\n\n    vec4 finalColor = mix(\n        vec4(baseColor.xyz, baseColorAlpha * baseColor.w),\n        vec4(1.), // Border color\n        borderAlpha);\n\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This prolog is a simulation of the vertex shader that we use in Floating Sandbox.\n    // The bulk of this shader is really the 'CalculateOceanPlaneColor' function above.\n    \n    vec4 backgroundColor = vec4(135./255., 206./255., 250./255., 1.);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - vec2(1.); // (x=[-1.0, 1.0], y=[-1.0, 1.0])    \n    \n    #define WorldMult 10.\n    vec2 worldCoords = uv * vec2(WorldMult, WorldMult);\n    \n    float amplitude = (0.3 + 0.1 * sin(iTime) * 8.) * WorldMult;\n                \n    float yBackWorld = amplitude * .24 * sin(worldCoords.x * 4. / WorldMult + float(iTime) * 2. - .15);   \n    float yMidWorld = amplitude * .3 * sin(worldCoords.x * 4. / WorldMult + float(iTime) * 2.);\n    float yFrontWorld = amplitude * .27 * sin(worldCoords.x * 4. / WorldMult + float(iTime) * 2. + .2);\n    \n    float backPlaneToggleParam = 1.; // step(1., mod(iTime * 2., 2.));\n    \n    //////////////////////////////////////////////////////////////////\n        \n    // Sample texture, anchoring textureY=0.0 at mid\n    vec2 textureCoords = vec2(worldCoords.x, yMidWorld - worldCoords.y);\n    vec4 baseColor = texture(iChannel0, textureCoords);\n    // TODO: Comment below to use texture\n    baseColor = vec4(92./255., 237./255., 237./255., 1.);\n    \n    vec4 color = CalculateOceanPlaneColor(baseColor, worldCoords.y, yBackWorld, yMidWorld, yFrontWorld, backPlaneToggleParam);\n    \n    //\n    // Output to screen\n    //\n    \n    fragColor = mix(\n        backgroundColor,\n        color,\n        color.w);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtccWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wtccz4", "name": "simple pattern change", "author": "yunhao", "description": "pattern", "tags": ["2d"], "likes": 0, "viewed": 33, "date": "1608519377", "time_retrieved": "2024-06-20T20:27:38.165960", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    int block = int(9.0f * iTime) % 24 - 12;\n    if (block == 0)\n    {\n        block = 1;\n    }\n    block = block * 10;\n    int result = int((fragCoord.x - iResolution.x / 2.0) * (fragCoord.y - iResolution.y / 2.0)) / block;\n    if( result % 3  == 0)\n    { \n      col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(1,3,5)));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wtccz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtcczH", "name": "Stream_2020_12_20", "author": "dreamur", "description": "[Incomplete/WIP]", "tags": ["lights", "lanterns", "nightsky"], "likes": 2, "viewed": 35, "date": "1608478508", "time_retrieved": "2024-06-20T20:27:38.165960", "image_code": "vec2 rotate (vec2 _st, float _angle) {\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    return _st;\n}\n\nfloat sdCircle(in vec2 _st, in float _radius)\n{\n    return length(_st) - _radius;\n}\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n  \tvec2 d = abs(p) - size - radius;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n// 2D Random\nfloat random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }\n\n// https://thebookofshaders.com/edit.php#12/vorono-01.frag\nfloat voroni(in vec2 _st, in float _offset)\n{\n    vec2 i_st = floor(_st);\n    vec2 f_st = fract(_st);\n\n    float m_dist = 150.;  // minimun distance\n    vec2 m_point;        // minimum point\n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = vec2(random(i_st + neighbor ));\n            point = 0.5 + 0.5*sin(_offset + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            if( dist < m_dist ) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\n    \n    return m_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.0 * fragCoord.xy/iResolution.x - vec2(2.0, 1.1);\n    vec3 col = vec3(0.0, 0.0, 0.545);\n   \n    col = mix(col, vec3(0.0), uv.y / 2.0 + 0.4);\n\n    float lanternDF = 0.0;\n    float lanternShadowDF = 0.0;\n\n    for(float i = 0.0; i < 20.0; i++)\n    {\n        float offsetX = voroni(vec2(i ), 0.0);\n        float offsetY = voroni(vec2(i ), 0.0);\n        \n        vec2 offsetVec = vec2(offsetX * i - 2.6, offsetY  + sin(iTime + i) / 8.0);\n\n        float scalar = 2.5;\n        vec2 size = vec2(0.15, 0.4);\n        \n        float glowDF = sdCircle(uv * scalar + offsetVec - vec2(2.0, 3.0), 0.5);\n\n        lanternDF = step(boxDist(uv * scalar + offsetVec - vec2(2.0, 3.0), size, 0.0), 0.1);\n        lanternShadowDF = step(boxDist(uv * scalar + offsetVec - vec2(2.0, 3.0), size + vec2(0.01), 0.0), 0.1);\n        \n        col = mix(col, vec3(0.549, 0.353, 0.0), clamp(lanternShadowDF, 0.0, 1.0));\n        col = mix(col, vec3(0.847, 0.549, 0.0), lanternDF);\n        \n        col = mix(col, vec3(1.0, 1.0, 0.0), lanternDF * (0.25-glowDF) );\n        \n    }\n    \n    if(uv.y < -0.35) \n    {     \n        vec3 grass = vec3(0.0, 0.392, 0.0);\n        grass = mix(grass, vec3(0.0), 1.0 - uv.y - 1.15);\n        col = grass; \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtcczH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtcyDM", "name": "Day 376", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 10, "viewed": 282, "date": "1609194054", "time_retrieved": "2024-06-20T20:27:39.650936", "image_code": "\n// cyclic noise learned from nimitz\n// it is literally invented by nimitz\n\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\nvec3 glow = vec3(0);\nvec3 ro;\n\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nvec2 map(vec3 po){\n    vec2 d = vec2(10e5);\n    \n    vec4 p = vec4(po,1.);\n    \n    p.xz -= 2.;\n    \n    p = abs(p);\n    p.xz -= 2.;\n    \n    p.y = pmod(p.y,5.);\n    for(int i = 0; i <6; i++){\n    \n    \n        p.xyz = pmod(p.xyz,vec3(5,4,5));\n    \n        \n        p = abs(p);\n        \n        if(p.x - p.y < 0.) p.xy = p.yx;\n        if(p.x - p.z < 0.) p.xz = p.zx;\n        if(p.z - p.y < 0.) p.zy = p.yz;\n        \n    \n        \n        if(i == 5 || i == 3){\n            p.y -= .6 + sin(iTime*0.4)*1.4;\n            float dpp = dot(p.xyz,p.xyz);\n            dpp = clamp(dpp,0.,0.2 + sin(iTime)*0.05);\n            p = p/dpp;\n        }\n        \n    \n        p.xy *= rot(-0.25*pi);\n        p.xy -= 0.5;\n        p *= 1.4 + sin(iTime*0.5)*0.3;\n        \n        float ld = max(p.z,p.x)/p.w - 0.002;\n        \n        d.x = xor(-d.x, ld,0.4);\n    \n    }\n    \n    p.xyz /= p.w;\n    \n    \n    \n    p = abs(p);\n    \n    glow += exp(-d.x*40.);\n    \n    d.x *= 0.7;\n        \n    d.x = max(d.x,-length(po.xz) + 0.4);\n    d.x = mix(d.x,0.1,smoothstep(0.2,0.,length(po-ro)));\n    return d;\n}\n\n\nmat3 getOrthogonalBasis(vec3 lookAt){\n    vec3 dir = normalize(lookAt);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    vec3 seed = vec3(-4. ,-2.,0.5);\n    \n    float amp = 1.;\n    float gain = 0.6;\n    float lacunarity = 1.4;\n    int octaves = 5;\n    \n    \n    float warp = 0.3+ sin(iTime)*0.;    \n    float warpTrk = 1.2 ;\n    float warpTrkGain = 1.5;\n    \n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        // Some domain warping. Similar to fbm.\n        p += sin(p.zxy*warpTrk*0.2 - 2.*warpTrk)*warp; \n        // Calculate some noise value. \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        //noise += abs(sin(dot(cos(p), sin(p.zxy ))))*amp;\n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return noise*0.5;\n}\n\n\nfloat mapCloud(vec3 p){\n    \n    vec3 op = p;\n    float d = length(p.xz);\n    p *= 12.;\n    \n    p.y -= iTime*4.;\n    \n    float n = cyclicNoise(p)*0.4;\n\n    d -= sin(length(op.y)*4. + iTime*2.)*0.04;\n    d -= 0.4 +  n*0.3;\n    d = smoothstep(0.05,0.,d)*3.;\n    return d;\n}\n\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + right*uv.x + up*uv.y);\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\nfloat sdBox(vec2 p){\n    p = abs(p); return max(p.y,p.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float db = 10e5;\n    vec2 buv = uv;\n    /*\n    for(int i = 0; i < 5; i++){\n        float bx = abs(sdBox(buv) - 0.4) - .54;\n        \n        buv = pmod(buv, 1.4);\n        buv = abs(buv);\n        if(buv.x + buv.y < 0.) buv.xy = buv.yx;\n        if(buv.x - buv.y < 0.) buv.xy = buv.yx;\n        buv.x -= 0.04 + sin(iTime)*.4;\n        buv *= rot(0.25*pi );\n        \n        db = xor(db,bx,0.4);\n    \n    }\n    \n    db -= 0.2;\n    if (db < 0.){\n        uv = uv.yx;\n    } \n    \n    */\n    buv = uv + 1000.;\n    vec3 col = vec3(0);\n    ro = vec3(0);\n    ro.xz += vec2(sin(iTime*0.5),cos(iTime));\n    \n    ro = normalize(ro)*( 0.75 + length(vec2(sin(iTime*0.6),cos(iTime*0.4))*0.5));\n    ro.y += iTime*0.2;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.y = ro.y;\n    \n    lookAt.y += length(vec2(sin(iTime*0.6),cos(iTime*0.4))*0.5)*2. - 1.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 sunDir = normalize(vec3(1));\n    \n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    float marchi = 0.;\n    for(; marchi < 90.; marchi++){\n        d = map(p);\n        \n        if(d.x < 0.001){\n            hit = true;\n            break;\n        }\n        p = ro + rd*(t += d.x);\n    }\n    \n    vec3 hitC = vec3(0);\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 albedo = n + 0.5;\n        \n        #define ao(a) smoothstep(0.,1.,map(p + (n + sunDir*0.4)*a).x/a)\n        \n        hitC += albedo*0.;\n        \n        float diff = max(dot(n,sunDir),0.);\n        \n        float aof = ao(0.01)*ao(0.1)*ao(0.07)*2. + 0.1;\n        hitC = mix(max(vec3(0.9,0.2,0.)*2. - sin(iTime*0.2) - 1.4,0.),hitC,diff);\n        \n        //hitC = mix(vec3(0.9,0.2,0.5)*0.9,hitC,diff);\n        hitC = mix(vec3(0.1,0.2,0.5)*0.2,hitC,aof);\n    }\n        \n        \n    \n    float volSteps = 7.;\n    float volDist = min(t, 1.6);\n    float volStSz = volDist/volSteps;\n    vec3 volP = ro;\n    vec3 volAccum = vec3(0);\n    \n    float tDens = 0.;\n    \n    \n    for(float i = 0.; i < volSteps; i++){\n        //float dens = pow(abs(sin(length(volP*25.)*1. + iTime)),12.)*1.44;\n        //float dens = smoothstep(0.1,0., length(volP) - 0.3);\n        float dens = mapCloud(volP);\n        float odens = mapCloud(volP + sunDir*0.3);\n        \n        float diff = clamp(dens - odens*0.95, 0., 1.);\n        vec3 absorption = mix(vec3(0.4,0.7,0.9),vec3(0.8,0.6,0.1)*0.2 ,clamp(tDens*.4, 0., 1.));\n        vec3 fringe = mix(vec3(1.8,0.1,0.1)*1., vec3(0.4,0.7,0.9)*0.0, pow(clamp(dens*0.8 - 1.9, 0., 1.),0.2));\n   \n        vec3 c = mix(vec3(0.1,0.1,0.4)*0.3,vec3(0.6,0.3,0.2)*1.,diff);\n        \n        c *= absorption;\n        \n        dens = dens*(1. - tDens)*volStSz;\n        \n        volAccum += c*dens*1.5 + fringe*dens;\n        \n        \n        \n        tDens += dens;\n        \n        if(tDens > 1.){\n            break;\n        }\n        \n        volP += rd*volStSz;\n    }\n    //col += marchi*0.02*(0.5 + 0.4*sin(vec3(1.,4.8,4.8) + uv.xyx));\n    \n    col += hitC*1.;\n    \n    col = mix(col,vec3(0.04,0.01,0.1),smoothstep(0.,1.,marchi*0.01));\n    \n    //col += glow*.02*(smoothstep(1.,0.,t*0.06));\n    \n    \n    col = mix(col + volAccum*0., volAccum*1., smoothstep(0.,1.,pow(tDens*1.,  1.)) );\n    \n    col = mix(col,smoothstep(0.,1.,col*1.5),0.4);\n    \n    \n    col = 1. - col*(3. + sin(iTime));\n    \n    \n    \n    if (abs(db) < 0.4){\n        col = 1. - col; \n    } \n    \n    //col.xz *= rot(iTime);\n    \n    //vec3 rotAround = normalize(vec3(sin(iTime),cos(iTime*0.5),sin(iTime*0.4)));\n    vec3 rotAround = normalize(vec3(-1.,1.,-1));\n    \n    mat3 matRotAround = mat3(\n        rotAround.x, 0., 0.,\n        0., rotAround.y, 0.,\n        0., 0., rotAround.z\n    );\n    col += 1.;\n    col *= matRotAround;\n    \n    //col.xy *= rot(-0.4+ sin(iTime)*0.4 + (uv.y)*0.2);\n    //col.xy *= rot(sin(iTime)*0.2);\n    \n    col *= inverse(matRotAround);\n    col -= 1.;\n    \n    col *= 1. - dot(uv,uv)*0.5;\n    col = pow(abs(col), vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtcyWr", "name": "N-B (trom Vall-D), fork", "author": "404Glaciergargamel", "description": "Remix, fork, and parody of [url]https://www.shadertoy.com/view/WdVfRc[/url]", "tags": ["3d", "raymarching", "remix", "glitch", "fork", "weird", "pixar", "movie", "parody", "cineshader", "walle"], "likes": 0, "viewed": 3082, "date": "1608784654", "time_retrieved": "2024-06-20T20:27:40.972249", "image_code": "// Cracked by 404Glaciergargamel!\n\nfloat arms, time, g = 0.0;\n\n#define AA 1 // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id; // Material ID.\n\tvec2 t; // uv texture coords.\n};\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(8, 257, 1);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (4. - 3. * p);\n\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 53.5453), fract(sin(h + s.x) * 53.5453), p.x);\n\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.1)) + min(max(q.x, max(q.y, q.z)), 0.1);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.1) + length(max(d, 0.1));\n}\n\nfloat sdTaper(vec2 p, vec3 r) {\n\tp.x = abs(p.x);\n\tp.y = -p.y;\n\tfloat b = (r.x - r.y) / r.z, a = sqrt(2. - b * b), k = dot(p, vec2(-b, a));\n\tif (k > a * r.z) return length(p - vec2(1, r.z)) - r.y;\n\treturn (k < 1. ? length(p) : dot(p, vec2(a, b))) - r.x;\n}\n\nfloat sdArm(vec3 p, float c) {\n\treturn max(\n\t\tmax(sdTaper(p.yz, vec3(.6, .3, 3)), abs(abs(p.x) - 2.55)) - .2, // Main arm.\n\t\t(p.z + 2.5 + sin(p.y * 8.) * .2) * c); // Front/back cut.\n}\n\n// The sine wave applied to the dirt track.\nfloat trk(float z) { return sin(z * .3 - time); }\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Floor.\n\tHit h = Hit(length(p.y), 1, p.xz);\n\n\t// Walls.\n\tminH(h, Hit(min(dot(p, vec3(-.707, .807, 1)) + 10., dot(p, vec3(-2, 1, 1)) + 30.), 1, p.yz));\n\n\t// Wall lights.\n\tfloat d = sdBox(vec3(p.xy, mod(p.z - time * 9., 50.)) - vec3(30, 8.25, 30), vec3(.2, .2, 9));\n\tg += .02 / (.02 + d * d);\n\tminH(h, Hit(d - .8, 5, p.xy));\n\n\tp.x += trk(-1.0);\n\tp.xz *= rot(trk(8.) * .3);\n\n\t// Ball.\n\tminH(h, Hit(length(p - vec3(1, 2, 1)) - 2., 3, p.xy));\n\tp.yz *= rot(-arms);\n\tp.y -= 2.7;\n\tminH(h, Hit(sdBox(p, vec3(2.2, 1.0, .9 + cos((p.y + 6.1) * 2.33) * .6)) - .4, 4, p.xy)); // Lower body.\n\tvec3 op = p;\n\n\t// Arms/Hands.\n\tp.y -= .6;\n\tp.yz *= rot(-arms);\n\td = sdArm(p, -2.);\n\tp.z += arms + cos(time * 25.) * .2;\n\tminH(h, Hit(min(d, sdArm(p, 2.)), 1, op.xy));\n\n\t// Brush.\n\tfloat f, b = .3 + .9 * abs(sin(p.x * 28.)) * .2;\n\tminH(h, Hit(sdCyl(p + vec3(1, 1, 3), vec2(.2 + b, 2.4)), 3, p.xy));\n\n\t// Arm extenders.\n\tp.x = abs(p.x) - 2.55;\n\tp.z += 2.;\n\tminH(h, Hit(sdBox(p, vec3(.09, .32, .7)), 3, p.xz));\n\n\t// Head.\n\tp = op;\n\tp.yz *= rot(arms * -.8);\n\tp.xz *= rot(trk(1.) * .2);\n\tp.y -= 3.;\n\tp.z += .6;\n\tf = cos(p.y + .9);\n\n\tminH(h, Hit(max(sdBox(p, vec3(mix(2.2, 2.4, f), .9, mix(1.0, 2.2, f))), // Head.\n\t\t\t3.5 - length(p.yz + vec2(3.5, -.9)) // Rear cut-out.\n\t\t\t) - .3, 7, p.xy));\n\n\t// Light - Top.\n\tp.y -= mix(1.06, 3.5, arms);\n\tminH(h, Hit(sdBox(p, vec3(.6, .05, .6)), 4, p.xy));\n\tminH(h, Hit(sdBox(p + vec3(1, .4, 1), vec3(.55, .4, .55)), 6, p.xy));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p) {\n\tvec2 e = vec2(.034, -.034);\n\treturn normalize(e.xyy * map(p + e.xyy).d +\n\t\t\t\t\t e.yyx * map(p + e.yyx).d +\n\t\t\t\t\t e.yxy * map(p + e.yxy).d +\n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 2., t = .2, h;\n\tfor (int i = 1; i < 30; i++)\n\t{\n\t\th = map(p + ld * t).d;\n\t\ts = min(s, 25. * h / t);\n\t\tt += h;\n\t\tif (s < .002 || t > 3.7) break;\n\t}\n\n\treturn clamp(s, 1., 2.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .6 + .6 * pow(26. * q.x * q.y * (2. - q.x) * (2. - q.y), .5);\n\treturn c;\n}\n\n// Calculate the floor normal vector.\nvec2 flrN(vec2 t) {\n\treturn n21(vec2(t.x * 2.2, t.y)) * .4 + // Surface texture.\n\t\tsmoothstep(.1, .05, abs(sin(t * .6))); // Tile edges.\n}\n\nvec3 mat(Hit h, vec3 p, inout vec3 n) {\n\tif (h.id == 2) { // Floor\n\t\tvec2 t = h.t + vec2(trk(p.z), time * -6.);\n\n\t\tn.xz += flrN(vec2(h.t.x, t.y));\n\t\tn = normalize(n);\n\n\t\tfloat mm = n21(mod(t * 20., 30.));\n\t\tvec2 d = abs(vec2(abs(abs(t.x) - .9) - .4, mod(t.y, .5) - .2)) - vec2(.3, .2);\n\t\treturn vec3(.4, .5, .6)\n\t\t* mix(2., mm, (2. - step(1., min(max(d.x, d.y), 1.))) * step(p.z, -3.5)); // Tracks.\n\t}\n\n\tif (h.id == 2) return vec3(.2); // Ball, brush\n\n\tif (h.id == 3) // White body\n\t\treturn vec3(2. - step(abs(h.t.y + .8), .25) * 1.0);\n\n\tif (h.id == 4) // Wall light.\n\t\treturn vec3(35);\n\n\tif (h.id == 5) return vec3(2, 1, 1);\n\n\tif (h.id == 6) { // Face\n\t\tvec2 t = vec2(abs(h.t.x), h.t.y);\n\t\tif (t.y < -.4 && t.x < 2.) {\n\t\t\tt.x += arms * .5;\n\t\t\tfloat l = .4 + .8 * abs(sin(t.y * 60.));\n\t\t\tt *= rot(.7 * arms);\n\t\t\treturn .02 + vec3(2.5, 2.5, 1) * step(abs(t.x - .4), .35) * step(abs(t.y + .8), .2 - arms * .2) * l;\n\t\t}\n\t}\n\n\treturn vec3(-0.02);\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tconst vec3 lp = vec3(7, 4, -20);\n\tvec3 n = calcN(p), ld = normalize(lp - p);\n\treturn mat(h, p, n) // Material color.\n\t\t   * (\n\t\t\t  (\n\t\t\t\t  max(1., .2 + 1.0 * dot(ld, n)) // Primary light.\n\t\t\t\t  + max(1., .2 + 1.0 * dot(ld * vec3(-2, 1, -2), n)) // Bounce light.\n\t\t\t  )\n\t\t\t  * mix(.4, .7, calcShadow(p, ld)) // Shadows.\n\t\t\t  * mix(ao(p, n, .4), ao(p, n, 3.), .8) // Ambient occlusion.\n\t\t\t  + pow(max(1., dot(rd, reflect(ld, n))), 40.) // Specular.\n\t\t\t ) * vec3(3, 2.8, 2.7); // Main light color.\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, n, c;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (int i = 1; i < 210; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0025)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t}\n\n\t// Calculate pixel color.\n\tc = lights(p, rd, h) + g;\n\tif (h.id == 2) {\n\t\t// Ray hit the floor - Apply reflection.\n\t\tn = calcN(p);\n\t\tn.xz -= flrN(p.xz - vec2(1, time * 6.)) * .034;\n\t\trd = reflect(rd, normalize(n));\n\t\td = .6;\n\t\tro = p;\n\t\tfor (int i = 1; i < 100; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\n\t\t\tif (abs(h.d) < .0025)\n\t\t\t\tbreak;\n\t\t\td += h.d;\n\t\t}\n\n\t\tif (abs(h.d) < .0025)\n\t\t\tc = mix(c, mat(h, p, n), .02);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 c, vec2 fc)\n{\n\ttime = mod(iTime, 40.) - 2.;\n\tarms = (time < 1. ? smoothstep(-2., 1., time) : abs(sin(time * 20.) * .2) + 1.0) * .48;\n\ttime = max(1., time);\n\n\tvec3 ro = vec3(-8, 5, -8. - sin(time * .4)),\n\t\t col = vec3(1);\n#ifdef AA\n\tfor (float dx = 1.; dx <= 2.; dx++)\n\t\tfor (float dy = 1.; dy <= 2.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .6 - .6 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .6 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tvec3 f = normalize(vec3(1, 4, -5) - ro),\n\t\t\t\t r = normalize(cross(vec3(1, 2, 1), f));\n\t\t\tcol += march(ro, normalize(f + r * uv.x + cross(f, r) * uv.y));\n#ifdef AA\n\t\t}\n\tcol /= 5.;\n#endif\n\n\tc.rgb = vig(pow(col, vec3(.55)), fc);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wtcyzn", "name": "kid Merry Christmas", "author": "yuehongliang", "description": "learn mix function", "tags": ["2d"], "likes": 2, "viewed": 59, "date": "1608476416", "time_retrieved": "2024-06-20T20:27:43.493611", "image_code": "/*\nreference https://www.shadertoy.com/view/tsVBzc\nlearning to overlaping kinds of shape\n*/\n#define BG_COLOR vec4(0.91, 0.28, 0.29, 1.0)\n#define BG_FADE_COLOR vec4(0.76, 0.20, 0.21, 1.0)\n#define SNOW_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n#define SNOW_SHADE_COLOR vec4(0.9, 0.9, 0.9, 1.0)\n#define SNOWMAN_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n#define SNOWMAN_HAT_COLOR vec4(0.3, 0.3, 0.3, 1.0)\n#define SNOWMAN_NOSE_COLOR vec4(0.93, 0.35, 0.17, 1.0)\n#define SNOWMAN_BUTTON_COLOR vec4(0.3, 0.6, 0.3, 1.0)\n#define TREE_COLOR vec4(0.3, 0.6, 0.3, 1.0)\n#define TREE_TRUNK_COLOR vec4(0.51, 0.28, 0.05, 1.0)\n#define TREE_DECO_COLOR1 vec4(0.31, 0.38, 0.72, 1.0)\n#define TREE_DECO_COLOR2 vec4(0.71, 0.38, 0.82, 1.0)\n#define TREE_DECO_COLOR3 vec4(0.97, 0.80, 0.18, 1.0)\n#define BOX_COLOR1 vec4(0.31, 0.38, 0.72, 1.0)\n#define BOX_COLOR2 vec4(0.91, 0.55, 0.18, 1.0)\n#define RIBBON_COLOR1 vec4(0.3, 0.6, 0.3, 1.0)\n#define RIBBON_COLOR2 vec4(0.71, 0.38, 0.82, 1.0)\n#define LIGHT_WIRE_COLOR vec4(0.31, 0.38, 0.72, 1.0)\n#define LIGHT_ON_COLOR vec4(0.98, 1.0, 0.24, 1.0)\n#define LIGHT_OFF_COLOR vec4(0.65, 0.65, 0.45, 0.9)\nvec4 FONT_COLOR =vec4(0.4,51./255.,102./255.,1.);\n\n#define BLUR 4.0 / iResolution.y\n\nfloat Hash21(vec2 uv)\n{                   \n    return fract(sin(dot(uv, vec2(825.123, 9475.832))) * 244.19);\n}\n\nvec2 Rotate(vec2 uv, float deg)\n{\n    float angle = radians(deg);\n    vec2 rot = uv * mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    return rot;\n}\n\nfloat Circle(vec2 uv, vec2 centre, float radius)\n{\n    float d = length(uv - centre);\n    float c = smoothstep(radius, radius - BLUR, d);\n    return c;\n}\n\nfloat MouseInPresent(){\n    vec2 mouse=(2.0 * iMouse.xy-iResolution.xy) / iResolution.y;\n    float dist=distance(mouse,vec2(0.3, -0.64));\n    return dist>.18?0.:1.;\n}\nfloat Rect(vec2 uv, vec2 leftBot, vec2 rightTop)\n{\n    vec2 lb = smoothstep(leftBot, leftBot - BLUR, uv);\n    vec2 rt = smoothstep(rightTop, rightTop - BLUR, uv);\n    vec2 dim = rt - lb;\n    \n    return (min(dim.x, dim.y));\n}\n\nfloat RectP(vec2 uv, vec2 leftBot, vec2 rightTop)\n{\n    float blur=BLUR;\n    float mi=MouseInPresent();\n    if(mi>0.) blur=abs(sin(iTime*2.))*(30./iResolution.y);\n    vec2 lb = smoothstep(leftBot, leftBot - blur, uv);\n    vec2 rt = smoothstep(rightTop, rightTop - blur, uv);\n    vec2 dim = rt - lb;\n    \n    return (min(dim.x, dim.y));\n}\n\nfloat TranslateRect(vec2 uv,vec2 center,vec2 wh,float angle,vec4 color){\n    float rad=radians(angle);\n    vec2 rot=mat2(cos(rad), sin(rad), -sin(rad), cos(rad))*(uv-center);\n    vec2 leftBot=vec2(-wh.x/2.,-wh.y/2.);\n    vec2 rightTop=vec2(wh.x/2.,wh.y/2.);\n    vec2 lb = smoothstep(leftBot, leftBot - BLUR, rot);\n    vec2 rt = smoothstep(rightTop, rightTop - BLUR, rot);\n    vec2 dim = rt - lb;\n    return min(dim.x, dim.y);\n}\n\nfloat TriangleIsosceles(vec2 uv, vec2 tip, vec2 size)\n{\n    tip = uv - tip;\n    tip.x = abs(tip.x);\n    \n    vec2 a = tip - (size * clamp(dot(tip, size) / dot(size, size), 0.0, 1.0));\n    vec2 b = tip - (size * vec2(clamp(tip.x / size.x, 0.0, 1.0), 1.0));\n    float s = -sign(size.y);\n    vec2 d = min(vec2(dot(a, a), s * ((tip.x * size.y) - (tip.y * size.x))), vec2(dot(b, b), s * (tip.y - size.y)));\n    float t = -sqrt(d.x) * sign(d.y);\n    \n    return smoothstep(0.0, 0.0 - BLUR, t);\n}\n\nfloat Quad(vec2 uv, vec2 p1, vec2 p2, vec2 p3, vec2 p4)\n{  \n    float top = uv.y + (uv.x * (p1.y - p2.y));\n    float bot = uv.y + (uv.x * (p3.y - p4.y));    \n    top = smoothstep(p1.y, p1.y - BLUR, top);\n    bot = smoothstep(p3.y, p3.y + BLUR, bot);\n    \n    float right = uv.x + (uv.y * (p4.x - p2.x));\n    float left = uv.x + (uv.y * (p3.x - p1.x));    \n    right = smoothstep(p2.x, p2.x - BLUR, right);\n    left = smoothstep(p1.x, p1.x + BLUR, left);\n    \n    float h = min(top, bot);\n    float w = min(left, right);\n    \n    float r = min(w, h);\n    return r;\n}\n\nvec4 DecorateBase(vec2 uv, vec2 centre, float radius, float thickness, vec4 color, float base)\n{\n    float deco1 = Circle(uv, centre, radius);\n    float deco2 = Circle(uv, centre - vec2(0.03, 0.02), radius - thickness);\n    \n    vec4 col = vec4(0.0);\n    col = mix(col, TREE_COLOR, base);\n    col = mix(col, color, min(base, deco1 - deco2));\n    \n    return col;\n}\n\nvec4 Snowfall(vec2 uv, float time, float speed, float radius)\n{\n    float ar = iResolution.x / iResolution.y;\n    uv.x += ar - mod(time * speed, ar * 2.0);\n    uv.y -= 1.0 - mod(time * speed, 2.0);\n    \n    uv += sin(time) * 0.1;\n    \n    float l = length(uv);\n    \n    return vec4(smoothstep(radius, radius - 3.0 / iResolution.y, l));   \n}\n\nvec4 Env(vec2 uv)\n{    \n    float snowLeft = Circle(uv, vec2(-0.9, -3.3), 2.8);\n  \tfloat snowRight = Circle(uv, vec2(1.0, -3.3), 2.5);\n    \n    float snowBall1 = Circle(uv, vec2(-1.4, -0.52), 0.07);\n    float snowBall2 = Circle(uv, vec2(-1.6, -0.52), 0.1);\n    \n    float snowLeftShade = Circle(uv, vec2(-0.9, -3.3), 2.75);\n    float snowRightShade = Circle(uv, vec2(1.0, -3.3), 2.45);\n    \n    float present11 = RectP(Rotate(uv, -20.0), vec2(0.3, -0.64), vec2(0.6, -0.44));\n    float present12 = RectP(Rotate(uv, -20.0), vec2(0.3, -0.59), vec2(0.6, -0.54));\n    float present13 = RectP(Rotate(uv, -20.0), vec2(0.45, -0.64), vec2(0.5, -0.44));\n    float present21 = Rect(Rotate(uv, 10.0), vec2(0.3, -0.95), vec2(0.48, -0.65));\n    float present22 = Rect(Rotate(uv, 10.0), vec2(0.37, -0.95), vec2(0.415, -0.65));\n    float present23 = Rect(Rotate(uv, 10.0), vec2(0.3, -0.9), vec2(0.48, -0.85));\n       \n    vec4 col = vec4(0.0);    \n    col = mix(col, SNOW_SHADE_COLOR, max(snowLeft, snowRight));\n    col = mix(col, SNOW_COLOR, max(snowBall1, snowBall2));\n    col = mix(col, SNOW_COLOR, max(snowLeftShade, snowRightShade));    \n    col = mix(col, BOX_COLOR1, present11);\n    col = mix(col, RIBBON_COLOR1, max(present12, present13));\n    col = mix(col, BOX_COLOR2, present21);\n    col = mix(col, RIBBON_COLOR2, max(present22, present23));\n              \n    return col;\n}\nvec2 mousepos(float w,float h){\n    float y=h*2./iResolution.y;\n    return vec2(w*iResolution.x/(iResolution.y*iResolution.y),y);\n}\nvec4 xiao(vec2 uv){\n    //小书圣诞快乐\n    float angle=sin(iTime*10.);\n    //uv=Rotate(uv,angle);\n    vec2 pos=vec2(-.2,.51);\n    vec2 wh=vec2(.03,.2);\n    float c1=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n    pos=vec2(-.21,.41);\n    wh=vec2(.03,.06);\n    float c2=TranslateRect(uv,pos,wh,75.,FONT_COLOR);\n    pos=vec2(-.33,.48);\n    wh=vec2(.03,.08);\n    float c3=TranslateRect(uv,pos,wh,20.,FONT_COLOR);\n    pos=vec2(-.1,.5);\n    wh=vec2(.03,.08);\n    float c4=TranslateRect(uv,pos,wh,-20.,FONT_COLOR);\n\n    float c=max(c1,max(c2,max(c3,c4)));\n\n    return c*FONT_COLOR;\n}\n\nvec4 shu(vec2 uv){\n    vec2 pos=vec2(0.2,.56);\n    vec2 wh=vec2(.2,.03);\n    float c1=TranslateRect(uv,pos,wh,5.,FONT_COLOR);\n    pos=vec2(0.2,.48);\n    wh=vec2(.25,.03);\n    float c2=TranslateRect(uv,pos,wh,5.,FONT_COLOR);\n    pos=vec2(.185,.49);\n    wh=vec2(.03,.28);\n    float c3=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.28,.51);\n    wh=vec2(.03,.08);\n    float c4=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.31,.43);\n    wh=vec2(.03,.08);\n    float c5=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.28,.405);\n    wh=vec2(.04,.03);\n    float c6=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.32,.6);\n    wh=vec2(.06,.03);\n    float c7=TranslateRect(uv,pos,wh,30.,FONT_COLOR);\n\n    float c=max(c1,\n    max(c2,\n    max(c3,\n    max(c4,\n    max(c5,\n    max(c6,c7))))));\n\n    return c*FONT_COLOR;\n\n}\n\nvec4 sheng(vec2 uv){\n    float lw=.015;\n    vec2 pos=vec2(-0.2,.2);\n    vec2 wh=vec2(.13,lw);\n    float c1=TranslateRect(uv,pos,wh,5.,FONT_COLOR);\n    pos=vec2(-.23,.12);\n    wh=vec2(.22,lw);\n    float c2=TranslateRect(uv,pos,wh,-40.,FONT_COLOR);\n    pos=vec2(-.21,.12);\n    wh=vec2(.22,lw);\n    float c3=TranslateRect(uv,pos,wh,30.,FONT_COLOR);\n    pos=vec2(-.22,.05);\n    wh=vec2(0.08,lw);\n    float c4=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(-.22,0.043);\n    wh=vec2(lw,.08);\n    float c5=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(-.22,.0);\n    wh=vec2(.12,lw);\n    float c6=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n\n    float c=max(c1,\n    max(c2,\n    max(c3,\n    max(c4,\n    max(c5,c6)))));\n\n    return c*FONT_COLOR;\n}\n\nvec4 dan(vec2 uv){\n    float lw=.015;\n    vec2 pos=vec2(-0.06,.17);\n    vec2 wh=vec2(.04,lw);\n    float c1=TranslateRect(uv,pos,wh,15.,FONT_COLOR);\n    pos=vec2(-.06,.12);\n    wh=vec2(.05,lw);\n    float c2=TranslateRect(uv,pos,wh,0.,FONT_COLOR);\n    pos=vec2(-.04,.07);\n    wh=vec2(lw,.12);\n    float c3=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(-.03,.02);\n    wh=vec2(0.03,lw);\n    float c4=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.01,.14);\n    wh=vec2(.04,lw);\n    float c5=TranslateRect(uv,pos,wh,8.,FONT_COLOR);\n    pos=vec2(.03,.11);\n    wh=vec2(lw,.08);\n    float c6=TranslateRect(uv,pos,wh,15.,FONT_COLOR);\n    pos=vec2(.025,.07);\n    wh=vec2(lw,.03);\n    float c7=TranslateRect(uv,pos,wh,-35.,FONT_COLOR);\n    pos=vec2(.03,.03);\n    wh=vec2(lw,.08);\n    float c8=TranslateRect(uv,pos,wh,15.,FONT_COLOR);\n    pos=vec2(.08,.013);\n    wh=vec2(0.15,lw);\n    float c9=TranslateRect(uv,pos,wh,15.,FONT_COLOR);\n    pos=vec2(.1,.18);\n    wh=vec2(0.06,lw);\n    float c10=TranslateRect(uv,pos,wh,-8.,FONT_COLOR);\n    pos=vec2(.12,.11);\n    wh=vec2(0.03,lw);\n    float c11=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n    pos=vec2(.1,.05);\n    wh=vec2(0.06,lw);\n    float c12=TranslateRect(uv,pos,wh,0.,FONT_COLOR);\n    pos=vec2(.1,.1);\n    wh=vec2(lw,.12);\n    float c13=TranslateRect(uv,pos,wh,0.,FONT_COLOR);\n    pos=vec2(.07,.07);\n    wh=vec2(lw,0.06);\n    float c14=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n\n    float c=max(c1,\n    max(c2,\n    max(c3,\n    max(c4,\n    max(c5,\n    max(c6,\n    max(c7,\n    max(c8,\n    max(c9,\n    max(c10,\n    max(c11,\n    max(c12,\n    max(c13,c14)))))))))))));\n\n    return c*FONT_COLOR;\n}\n\nvec4 kuai(vec2 uv){\n    float lw=.015;\n    vec2 pos=vec2(.2,.1);\n    vec2 wh=vec2(lw,.06);\n    float c1=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n    pos=vec2(.23,.1);\n    wh=vec2(lw,.18);\n    float c2=TranslateRect(uv,pos,wh,0.,FONT_COLOR);\n    pos=vec2(.26,.1);\n    wh=vec2(.03,lw);\n    float c3=TranslateRect(uv,pos,wh,50.,FONT_COLOR);\n    pos=vec2(.33,.14);\n    wh=vec2(0.08,lw);\n    float c4=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.34,.08);\n    wh=vec2(.12,lw);\n    float c5=TranslateRect(uv,pos,wh,-8.,FONT_COLOR);\n    pos=vec2(.365,.11);\n    wh=vec2(lw,.07);\n    float c6=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n    pos=vec2(.315,.08);\n    wh=vec2(lw,.2);\n    float c7=TranslateRect(uv,pos,wh,10.,FONT_COLOR);\n    pos=vec2(.35,.03);\n    wh=vec2(lw,.04);\n    float c8=TranslateRect(uv,pos,wh,-35.,FONT_COLOR);\n\n    float c=max(c1,\n    max(c2,\n    max(c3,\n    max(c4,\n    max(c5,\n    max(c6,\n    max(c7,c8)))))));\n\n    return c*FONT_COLOR;\n}\n\nvec4 le(vec2 uv){\n    float lw=.015;\n    vec2 pos=vec2(.5,.16);\n    vec2 wh=vec2(.13,lw);\n    float c1=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n    pos=vec2(.51,.08);\n    wh=vec2(.15,lw);\n    float c2=TranslateRect(uv,pos,wh,0.,FONT_COLOR);\n    pos=vec2(.51,.06);\n    wh=vec2(lw,.16);\n    float c3=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n    pos=vec2(.44,.11);\n    wh=vec2(lw,0.06);\n    float c4=TranslateRect(uv,pos,wh,3.,FONT_COLOR);\n    pos=vec2(.562,0.023);\n    wh=vec2(lw,.04);\n    float c5=TranslateRect(uv,pos,wh,-20.,FONT_COLOR);\n    pos=vec2(.46,.023);\n    wh=vec2(lw,.06);\n    float c6=TranslateRect(uv,pos,wh,20.,FONT_COLOR);\n    pos=vec2(.505,-.013);\n    wh=vec2(.02,lw);\n    float c7=TranslateRect(uv,pos,wh,-5.,FONT_COLOR);\n\n    float c=max(c1,\n    max(c2,\n    max(c3,\n    max(c4,\n    max(c5,\n    max(c6,c7))))));\n\n    return c*FONT_COLOR;\n}\n\nvec4 Snowman(vec2 uv)\n{\n   \tuv -= vec2(-0.8, -0.4);\n    uv = Rotate(uv, sin(iTime) * 12.0);\n    uv += vec2(-0.8, -0.4);\n    \n    float head = Circle(uv, vec2(-0.8, 0.0), 0.2);\n    float body = Circle(uv, vec2(-0.8, -0.4), 0.3);\n    \n    float eyes = Circle(vec2(abs(uv.x + 0.8), uv.y), vec2(0.05, 0.06), 0.03);\n    float nose = TriangleIsosceles(uv, vec2(-0.8, -0.15), vec2(0.04, 0.15));\n    float buttons = Circle(vec2(uv.x, abs(uv.y + 0.35)), vec2(-0.8, 0.07), 0.04);\n    \n    float arms = Rect(Rotate(vec2(abs(uv.x + 0.8), uv.y), 30.0), vec2(0.05, -0.35), vec2(0.3, -0.32));\n    float finger1 = Rect(Rotate(vec2(abs(uv.x + 0.8) - 0.62, uv.y + 0.5), 160.0), vec2(0.3, -0.35), vec2(0.33, -0.25));\n    float finger2 = Rect(Rotate(vec2(abs(uv.x + 0.8) - 0.03, uv.y + 0.29), 60.0), vec2(0.3, -0.35), vec2(0.33, -0.25));\n    \n    float hatBase = Rect(uv, vec2(-1.0, 0.15), vec2(-0.6, 0.22));\n    float hatTop = Rect(uv, vec2(-0.95, 0.2), vec2(-0.65, 0.48));    \n    \n  \tvec4 col = vec4(0.0);    \n    col = mix(col, SNOWMAN_COLOR, max(head, body));\n    col = mix(col, SNOWMAN_HAT_COLOR, eyes);\n    col = mix(col, SNOWMAN_NOSE_COLOR, nose);\n    col = mix(col, SNOWMAN_BUTTON_COLOR, buttons);\n    col = mix(col, SNOWMAN_HAT_COLOR, max(hatBase, hatTop));\n    col = mix(col, SNOWMAN_HAT_COLOR, max(arms, max(finger1, finger2)));\n    \n    return col;\n}\n\nvec4 Tree(vec2 uv)\n{\n\tuv+= vec2(-0.2, 0.0);\n    \n    float trunk = Quad(uv, vec2(0.9, -0.6), vec2(0.9, -0.6), vec2(0.8, -0.9), vec2(1.0, -0.9));\n    float base1 = Quad(uv, vec2(0.8, -0.2), vec2(1.2, -0.35), vec2(0.3, -0.57), vec2(1.4, -0.6));\n    float base2 = Quad(uv, vec2(0.7, -0.1), vec2(1.2, -0.09), vec2(0.0, -0.2), vec2(1.75, -0.35));\n    float base3 = Quad(uv, vec2(0.55, 0.25), vec2(1.3, 0.15), vec2(0.1, -0.1), vec2(2.0, -0.09));\n    float base4 = Quad(uv, vec2(0.35, 0.32), vec2(1.45, 0.35), vec2(-0.5, 0.25), vec2(2.4, 0.15));\n    float base5 = Quad(uv, vec2(0.45, 0.55), vec2(1.3, 0.55), vec2(-0.1, 0.32), vec2(1.85, 0.35));\n    float base6 = TriangleIsosceles(uv, vec2(0.87, 0.9), vec2(0.1, -0.35));\n    \n    vec4 decoBase1 = DecorateBase(uv, vec2(1.0, 0.2), 0.7, 0.07, TREE_DECO_COLOR1, base1);\n    vec4 decoBase2 = DecorateBase(uv, vec2(0.9, 0.37), 0.63, 0.06, TREE_DECO_COLOR3, base2);\n    vec4 decoBase3 = DecorateBase(uv, vec2(0.95, 0.47), 0.5, 0.06, TREE_DECO_COLOR2, base3);\n    vec4 decoBase4 = DecorateBase(uv, vec2(0.95, 0.6), 0.4, 0.05, TREE_DECO_COLOR1, base4);\n    vec4 decoBase5 = DecorateBase(uv, vec2(0.9, 0.7), 0.25, 0.05, TREE_DECO_COLOR2, base5);\n    vec4 decoBase6 = DecorateBase(uv, vec2(0.95, 0.4), 0.33, 0.07, TREE_DECO_COLOR3, base6);\n    \n    vec4 col = vec4(0.0);\n    col = mix(col, TREE_TRUNK_COLOR, trunk);\n    col = mix(col, decoBase1, decoBase1.w);\n    col = mix(col, decoBase2, decoBase2.w);\n    col = mix(col, decoBase3, decoBase3.w);\n    col = mix(col, decoBase4, decoBase4.w);\n    col = mix(col, decoBase5, decoBase5.w);\n    col = mix(col, decoBase6, decoBase6.w);\n    \n    return col;\n}\n\nvec4 Lights(vec2 uv)\n{\n    float wire1 = Circle(uv, vec2(-0.5, 4.25), 3.5);\n    float wire2 = Circle(uv, vec2(-0.5, 4.25), 3.49);\n    \n    float bulb1 = Circle(uv, vec2(-1.5, 0.86), 0.05);\n    float bulb2 = Circle(uv, vec2(-1.1, 0.765), 0.05);\n    float bulb3 = Circle(uv, vec2(-0.7, 0.72), 0.05);\n    float bulb4 = Circle(uv, vec2(-0.3, 0.72), 0.05);\n    float bulb5 = Circle(uv, vec2(0.1, 0.765), 0.05);\n    float bulb6 = Circle(uv, vec2(0.5, 0.86), 0.05);\n    \n    vec4 lightSwitch1 = mix(LIGHT_OFF_COLOR, LIGHT_ON_COLOR, round((sin(iTime * 2.0) + 1.0) / 2.0));\n    vec4 lightSwitch2 = mix(LIGHT_ON_COLOR, LIGHT_OFF_COLOR, round((sin(iTime * 2.0) + 1.0) / 2.0));\n    \n    vec4 col = vec4(0.0);\n    col = mix(col, LIGHT_WIRE_COLOR, wire1 - wire2);\n    col = mix(col, lightSwitch1, max(max(bulb1, bulb3), bulb5));\n    col = mix(col, lightSwitch2, max(max(bulb2, bulb4), bulb6));\n    return col;\n}\n\nvec4 Snow(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    \n    col += Snowfall(uv, iTime + 0.0, 0.4, 0.02);\n    col += Snowfall(uv, iTime + 1.0, 0.3, 0.035);\n    col += Snowfall(uv, iTime + 2.0, 0.2, 0.02);\n    col += Snowfall(uv, iTime + 3.0, 0.2, 0.025);\n    col += Snowfall(uv, iTime + 4.0, 0.4, 0.03);\n    col += Snowfall(uv, iTime + 5.0, 0.2, 0.03);\n    col += Snowfall(uv, iTime + 6.0, 0.3, 0.02);\n    col += Snowfall(uv, iTime + 7.0, 0.2, 0.02);\n    col += Snowfall(uv, iTime + 8.0, 0.2, 0.035);\n    col += Snowfall(uv, iTime + 9.0, 0.4, 0.03);    \n    \n    return col;\n}\n\n\nvec4 Scene(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    \n    \n    vec4 env = Env(uv);\n    vec4 snowman = Snowman(uv);\n    vec4 tree = Tree(uv);\n    vec4 lights = Lights(uv);\n    vec4 snow = Snow(uv);\n    float mi= MouseInPresent();\n    vec4 xiao1=xiao(uv);\n    xiao1=mi*xiao1;\n    vec4 shu1=shu(uv);\n    shu1=mi*shu1;\n    vec4 sheng=sheng(uv);\n    vec4 dan=dan(uv);\n    vec4 kuai=kuai(uv);\n    vec4 le=le(uv);\n    \n    col = mix(col, env, env.w);\n    col = mix(col, snowman, snowman.w);\n    col = mix(col, tree, tree.w);\n    col = mix(col, lights, lights.w);\n    col = mix(col, snow, snow.w);\n    col=mix(col,xiao1,xiao1.w);\n    col=mix(col,shu1,shu1.w);\n    col=mix(col,sheng,sheng.w);\n    col=mix(col,dan,dan.w);\n    col=mix(col,kuai,kuai.w);\n    col=mix(col,le,le.w);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    FONT_COLOR=sin(iTime*5.)>0.?\n    vec4(0.4,51./255.,102./255.,1.):\n    vec4(255./255.,241./255.,67./255.,1.);\n\n    vec4 scene = Scene(uv);\n\n    vec4 col = mix(BG_COLOR, BG_FADE_COLOR, uv.y); \n    col = mix(col, scene, scene.w);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wtcyzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtdcR7", "name": "aflower", "author": "nir", "description": "playing with shadertoy", "tags": ["basic"], "likes": 0, "viewed": 34, "date": "1608791225", "time_retrieved": "2024-06-20T20:27:43.493611", "image_code": "#define pi 3.1415926\n\n\nfloat s(float v0, float d, float x) {\n    return smoothstep(v0, v0+d, x);\n}\n\n\nvec2 c2p(vec2 uv) {\n    return vec2(atan(uv.x, uv.y), length(uv));\n}\n\n\nvec4 flower(\n    vec2 uv,\n    vec4 color,\n    float size,\n    float rpetals,\n    float npetals,\n    float speed\n) {\n\n    uv = c2p(uv);        \n    uv.x += iTime * speed + uv.y;\n    \n    float m = (fract(uv.x / pi / 2. * npetals) - 0.5) * rpetals;\n    m = min(m, -m);\n    \n    float c = s(size, -0.01, uv.y + m);\n    \n    return mix(vec4(0.), color, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 f;\n    vec4 c = vec4(0.7, 0.3, 0., 1.);\n    \n    f = flower(uv, vec4(1., 0., 0., 1.), 0.3, 0.3, 7., 0.1);\n    c = mix(c, f, f.a);\n    \n    f = flower(uv, vec4(0., 1., 0., .5), 0.27, 0.27, 7., 0.2);\n    c = mix(c, f, f.a);\n    \n    f = flower(uv, vec4(0., 0., 1., .5), 0.25, 0.25, 7., 0.28);\n    c = mix(c, f, f.a);\n    \n    f = flower(uv, vec4(1., 1., 0., .5), 0.23, 0.23, 7., 0.35);\n    c = mix(c, f, f.a);\n    \n    f = flower(uv, vec4(0., 1., 1., .5), 0.21, 0.21, 7., 0.4);\n    c = mix(c, f, f.a);\n    \n    f = flower(uv, vec4(1., 1., 1., .5), 0.19, 0.19, 7., 0.45);\n    c = mix(c, f, f.a);\n    \n    \n    fragColor = c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtdcR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtdcRn", "name": "hoeled_almost_3d", "author": "hoeled", "description": "From my blue_cell shader.", "tags": ["2d", "3d", "blob"], "likes": 2, "viewed": 36, "date": "1608348909", "time_retrieved": "2024-06-20T20:27:43.493611", "image_code": "mat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Circles(vec2 uv, float size) {\n    float t = iTime*.5;\n\n    vec2 gv = uv;\n    gv *= Rot(t*.3);\n    gv.x += atan(0.08, gv.y*gv.y*(sin(t*1.)*.15+.15))*.4-.6;\n    \n    float d = length(gv);\n    float circle = smoothstep(size+.06, size, d);\n    \n    gv = uv;\n    gv *= Rot(-t*.4+5.);\n    gv.x += atan(0.09, gv.y*gv.y*(sin(t*.9)*.2+.2))*.4-.6;\n    d = length(gv);\n    circle += smoothstep(size+.04, size, d);\n    \n    gv = uv;\n    gv *= Rot(t*.3+9.);\n    gv.x += atan(0.07, gv.y*gv.y*(sin(t*1.9)*.2+.2))*.4-.6;\n    d = length(gv);\n    circle += smoothstep(size+.04, size, d);\n    \n    gv = uv;\n    gv *= Rot(-t*.2+13.5);\n    gv.x += atan(0.07, gv.y*gv.y*(sin(t*2.1)*.2+.2))*.4-.6;\n    d = length(gv);\n    circle += smoothstep(size+.04, size, d);\n    \n    circle = clamp(circle, 0., 1.);\n    \n    d = length(uv+.03*sin(t));\n    circle -= smoothstep(0.4, 0., d)*.14;\n    d = length(uv+.02*cos(t*.94));\n    circle -= smoothstep(0.17, 0., d)*.03;\n                \n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= .9;\n    vec3 col = vec3(0.);\n\n    float circles = Circles(uv, .17);\n    float gradient = smoothstep(0.4, 0.1, length(uv.x-.3+(uv.y*sin(iTime*.1))));\n    gradient *= circles;\n    circles += gradient*.5;\n    col += circles;\n    col *= vec3(0.9, 0.8, 0.4);\n    \n    //col = 1.3-col;\n    \n    circles = Circles(uv*.9, .205);\n    col -= circles * .55;\n    col.b += .09;\n    col.rg -= .07;\n    \n    col += smoothstep(0.3, 0.0, length(vec2(uv.x+sin(iTime*.5)*.18, uv.y+cos(iTime*.5)*.18)))*.13;\n    \n    float clo = smoothstep(0.25,0.2, length(vec2(uv.x+sin(iTime*.5)*.015, uv.y+cos(iTime*.5)*.015)));\n    float cli = smoothstep(0.33,0.0, length(vec2(uv.x+sin(iTime*.5)*.015, uv.y+cos(iTime*.5)*.015)));\n    clo -= cli;\n    \n    col -= clo*.15;\n    col.b += .1;  \n    \n    col *= vec3(smoothstep(0.25, 0.24, length(uv)));\n    \n    //col *= 1.5;\n    col.r += col.b;\n    col.g += col.b;\n    col.b *= .7;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtdcRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtdcW4", "name": "Hyperbolic  Rainbows", "author": "nbardy", "description": "I was inspired by hyperbolic geometry and created a similar effect by repeating radial cells in exponential fashion.", "tags": ["fractal", "radial", "pi", "polar", "cineshader", "hyperpolic"], "likes": 3, "viewed": 1397, "date": "1609135020", "time_retrieved": "2024-06-20T20:27:43.493611", "image_code": "// A simple way to create color variation in a cheap way (yes, trigonometrics ARE cheap\n// in the GPU, don't try to be smart and use a triangle wave instead).\n\n// See http://iquilezles.org/www/articles/palettes/palettes.htm for more information\n\n// ****************\n// Helper functions\n// ****************\n\n// pallette \nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define HASHSCALE1 443.8975\n\n// random functions lib\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nfloat noise(float p)\n{\n\tfloat i = floor(p);\n    float f = fract(p);\n    \n    float t = f * f * (3.0 - 2.0 * f);\n    \n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\n\nfloat fbm(float x, float persistence, int octaves) \n{\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for(int i=0; i<16;++i)\n    {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return (total/maxValue);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float pi = 3.1415926;\n    float res = max(iResolution.x, iResolution.y);\n    \n    // Center and normalize our coordinate system    \n    vec2 uv = (fragCoord - .5*iResolution.xy) / res;\n    \n\n    float r = length(uv - vec2(0.0,0.0));\n    float theta = atan(uv.y, uv.x);\n    float thetanorm = (theta + pi)/(2.0*pi);\n\n    // Shift r domain for aesthetics\n    r = r + 0.1;\n    r *= 1.0;\n    float i = floor(r*r*370.0 + 0.02) + 1.0;\n    \n    float at = sin(iTime*0.007 + 0.4) * 0.2 + 1.2;\n    // Add distortion to rings  \n    float rt = at*173.0 + 500.0;\n    float tfbm = fbm(((theta+20.0) + 20.0), 0.54, 16)*2.0 + 0.8;\n    float rfbm = fbm(r +rt, 0.54, 16)*4.0 + 0.8;\n    //r *= clamp(tfbm,0.3,1.0);\n    //r *= clamp(rfbm,0.8,1.0);\n    r *= rfbm;\n    r *= tfbm;\n    \n    i = floor(r*r*r*370.0) ;\n    float i2 = pow(i,2.0) +1.0;\n    \n    float pct = fract(thetanorm*i2*2.0);\n    \n    // Flip \n    pct = abs(mod(i,2.) - pct);\n    \n    \n    \n    float row = floor(thetanorm*i2*2.0);    \n    float k = (row+1.0)*(i+1.0)/200.0;\n    // get random color for each cell\n    vec3 color1 = vec3(hash11(k+1.0),hash11(k+2.0),hash11(k+3.0));\n    vec3 color2 = vec3(hash11(k+5.0),hash11(k+6.0),hash11(k+7.0));\n    \n    float cfbm = fbm(i/4.0, 2.0, 2) + 0.5;;\n    float t = sin(iTime*5.0 + cfbm*99.0)*0.5 + 0.5;\n \n    vec3 color = mix(color1, color2, t);\n    \n   \n\n    \n    // Color option: Pallette blending\n    // Todo change color to be picked random for each tile \n    //vec3 c1 = pal( pct, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    // vec3 c2 = pal( pct, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );  \n    // vec3 color = mix(c1,c2,t);\n    // vec3 color = vec3(pct); vec3 color = vec3(hash);\n    //vec3 color = \n    // Clip\n\n    // Output to screen\n    fragColor = vec4(color*pct,.0);\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtdcW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtdyDn", "name": "Synced Pendulum", "author": "darkeclipz", "description": "Pendulum", "tags": ["3d"], "likes": 9, "viewed": 87, "date": "1608994861", "time_retrieved": "2024-06-20T20:27:44.893791", "image_code": "#define AA 1.\n#define R iResolution.xy\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdFloor(vec3 pos) {\n    float floor = sdBox(pos + vec3(0.5), vec3(20., 0.1, 20.));\n    float hole = sdBox(pos + vec3(-0.0, 0.4 , 0.1), vec3(.05, .5, .4));\n    return max(floor, -hole);\n}\n\n\nconst float g = 1.;\nconst float l = 3.;\nconst float th0 = pi/3.;\nbool wire = false; // pretty hacky *shrugs*\nfloat sdPendulum(vec3 pos, float t) {\n\n    vec3 c = vec3(0,0.2,0.0);\n    pos -= c;\n    pos.xy *= rot(th0*cos(sqrt(g/l) * t));\n    pos += c;\n    \n    //cone\n    //pos -= vec3(0.1,-0.5,-0.1);\n    pos -= vec3(0.,-0.5,-0.1);\n    float cone = sdCone(pos + vec3(0,-0.33,-0), vec2(0.25, 0.5), 0.18 );\n    \n    // rod\n    float rod = sdVerticalCapsule(pos - vec3(0,0.2,0), 0.5, 0.0025);\n    wire = rod < cone;\n    return min(rod, cone);\n}\n\nfloat sdSpinningDisk(vec3 pos, float t) {\n    // spinning cyl\n    //pos -= vec3(0.1,-0.5,-0.1);\n    pos -= vec3(0.0,-0.5,-0.1);\n    pos.yz *= rot(-t*sqrt(g/l)+pi/2.);\n    vec3 rpos = pos;\n    rpos.xy *= rot(pi/2.);\n    float cyl = sdCappedCylinder(rpos, 0.39, 0.01);\n    \n    // cone cut\n    vec3 cpos = pos;\n    cpos.y = abs(cpos.y);\n    float cone = sdCone(cpos + vec3(0,-0.375,-0), vec2(0.25, 0.5), 0.25);\n    cyl = max(cyl, -cone);\n    \n    // slit cut\n    float slit = sdBox(cpos - vec3(0,0.7,0), vec3(0.02, 0.5, 0.015));\n    return max(cyl, -slit);\n}\n\n//float id = 0.;\nvec2 map( in vec3 pos, float time )  \n{    \n    float id = 0.;\n    float t = 3.*iTime;\n    //t=2.*psqrt(g/l);\n    \n    // Floor\n    float d = sdFloor(pos);\n    \n    // Spinning disk\n    float disk = sdSpinningDisk(pos, t) - 0.004;\n    if(disk < d) {\n        id = 1.;\n    }\n    d = min(d, disk);\n    \n    // Pendulum\n    float pendulum = sdPendulum(pos, t);\n    if(pendulum < d) {\n        id = 2.;\n    }\n    d = min(d, pendulum);\n    \n    return vec2(d, id);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.0001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec3 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.01;\n    int i=0;\n    for( i=0; i<60; i++ )\n    {\n        float precis = 0.0001 * t;\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x< precis )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec3(t, m, 1. - float(i)/60.);\n}\n\n// https://www.iquilezles.org/www/articles/biplanar/biplanar.htm\n// \"p\" point being textured\n// \"n\" surface normal at \"p\"\n// \"k\" controls the sharpness of the blending in the transitions areas\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy );\n    \n    // blend factors\n    vec3 w = pow( abs(n), vec3(k) );\n    // blend and return\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\n\nvec3 calcRayDirection(in vec2 p, in vec3 ta, in vec3 ro) {\n    vec3 ww = normalize( ta-ro );\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    return normalize( p.x*uu + p.y*vv + 1.8*ww );\n}\n\nvec3 matFloor(in vec3 pos, in vec3 nor, in vec3 rd, float time) {\n    vec3 mate = vec3(10, 80, 255) / 255.;   \n    vec3 refl = reflect(rd, nor);\n    vec3 hit = castRay(pos + refl*0.01, refl, time);\n    float t = hit.x, id = hit.y;\n    if(t < 20.0) {\n        mate *= vec3(191, 222, 245)/255.;\n    }\n    float s = 8.;\n    float w = 0.025;\n    if(fract(pos.x*s) < w) {\n        mate *= 0.9;\n    }\n    if(fract(pos.z*s) < w) {\n        mate *= 0.9;    \n    }\n    return mate;\n}\n\nvec3 matSpinningDisk(in vec3 pos, in vec3 nor, float time) {\n    vec3 bpos = pos - vec3(0.,-0.49,-0.1);\n    bpos.yz *= rot(-time*sqrt(g/l) + pi/2.);\n    vec3 text = vec3(0);\n    if(bpos.y > 0.) text = boxmap(iChannel0, bpos, nor, 2.0).rgb;   \n    else            text = boxmap(iChannel1, bpos, nor, 2.0).rgb;   \n    return mix(vec3(1), text, 0.85);\n}\n\nvec3 calcMaterial(in vec3 pos, in vec3 nor, in vec3 rd, float id, float time) {\n    vec3 mate = vec3(0.6); \n    \n    if(id < 0.5) { // floor\n        mate = matFloor(pos, nor, rd, time);\n    }\n    else if(id < 1.5) { // spinning disk\n        mate = matSpinningDisk(pos, nor, time);\n    }\n    else if(id < 2.5) { // pendulum\n        mate = wire ? vec3(0) : nor;\n    }\n    \n    return mate;\n}\n\nvec3 calcBRDF(in vec3 pos, in vec3 nor, float occl) {\n    vec3  light1 = vec3(0.3, 0.1, -1 );\n    vec3  light2 = vec3(0.2, 3, -1 );\n    float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n    float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n    float amb = (0.7+0.3*nor.y);\n    //float shadow = clamp(castShadow(pos + nor*0.05, light1 - pos, time), 0., 1.);\n    vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb;\n    brdf += 1.0*vec3(255, 248, 230)/255.*key*occl;\n    brdf += 1.0*vec3(230, 248, 255)/255.*bac*occl;\n    return brdf;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = 3.*iTime;\n\n    vec3 col = vec3(0);\n    vec3 result = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0.1,-0.4,0);\n        vec3 ro = vec3(0, 0.1, -0.8);\n        ro.xz *= rot(3.1415/4.+0.1);\n        \n        vec3 rd = calcRayDirection(p, ta, ro);\n        vec3 col = vec3(0.0);\n\n        vec3 hit = castRay(ro, rd, time); \n        float t = hit.x;\n        float id = hit.y;\n        float occl = hit.z;\n\n        if(t < 20.)\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n            vec3 mate = calcMaterial(pos, nor, rd, id, time);\n            vec3 brdf = calcBRDF(pos, nor, occl);\n            col = mate * brdf * exp(-0.6*t);\n        }\n\n        result += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow(result/(AA*AA), vec3(0.4545));\n    O = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtdyRn", "name": "Hammer projection ellipsoid", "author": "d_makarov_d", "description": "Hammer map projection of a texture on an elipsoid", "tags": ["3d"], "likes": 0, "viewed": 78, "date": "1608395051", "time_retrieved": "2024-06-20T20:27:46.312308", "image_code": "// Shader for projecting coordinates on some rectangle to planetocentric \n// spherical coordinates, and then mapping this coordinates to a texture using \n// Hammer map projection, thus redusing distortion of the texture in the poles.\n//\n// Mathematics for projecting image coordinates to planetocentric were taken \n// from this article http://www.astron.kharkov.ua/dslpp/cartography/carthography.pdf\n// Surface texture\n// gShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/nv3uyznc1u34ecy/planet2.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n// Normal map\n// gShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/n4bri3nv57qw41o/planet2_norm.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\nstruct Planet {\n    float b0;   // Declination\n    float l0;   // Inclination\n    vec3 ax;    // Semiaxes\n    vec3 pos;   // Position\n};\n\nstruct Camera {\n    vec3 pos;  // Position\n    vec3 dir;  // Direction\n    vec3 up;   // Upward direction\n};\n\nfloat modulus(vec3);\nfloat scalMul(vec3, vec3);\nvec3 scr2crt(vec2, Planet, Camera);\nvec2 crt2sphere(vec3);\nvec3 normal(Planet, vec3);\nvec2 hammer(vec2);\nvec2 aitoff(vec2);\nvec2 eqEarth(vec2);\nvec2 spher(vec3);\nfloat atmosphere(vec3, vec3);\nfloat pi = 3.141592653589793238;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 dm = (iMouse.zw - iMouse.xy + iResolution.xy) / iResolution.xy / 2.0;\n    // dm = dm - vec2(0.5, 0.5);\n    dm = dm * 4.0 * pi;\n    Planet p = Planet(0.0 + dm.y, 0.0 + dm.x + iTime / 4.0, vec3(0.45, 0.45, 0.45), vec3(0.0, 0.0, -2.0));\n    Camera c = Camera(vec3(0.0, 0.0, 0.0),\n                      vec3(0.0, 0.0, -1.0),\n                      vec3(0.0, 1.0, 0.0));\n    // light settings\n    float b0 = 0.0;\n    float l0 = mod(iTime, 2.0 * pi);\n    mat3 rotb0 = mat3(1.0, 0.0,      0.0,   \n                      0.0, cos(b0),  sin(b0),\n                      0.0, -sin(b0), cos(b0));\n    mat3 rotl0 = mat3( cos(l0), 0.0, sin(l0),\n                      0.0,      1.0, 0.0,\n                      -sin(l0), 0.0, cos(l0));\n    vec3 lightDir = vec3(1.0, 0.0, 0.5) * 0.8 * rotb0* rotl0;\n    float ambient = 0.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv = uv - vec2(0.5, 0.5);\n    \n    vec3 crt = scr2crt(uv, p, c);\n    if (isnan(crt.x) || isnan(crt.y) || isnan(crt.z)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        // get spherical coordinates\n        vec2 latLon = crt2sphere(crt);\n        // Coordinates on texture\n        vec2 onTex = aitoff(latLon);\n        // Color from texture\n        vec4 texColor = texture(iChannel1, onTex);\n        vec4 normals = texture(iChannel2, onTex);\n        // Normal to the ellipsoid\n        vec3 n = normal(p, crt);\n        //normals.xyz = normalize(normals.xyz);\n        //n = n * max(dot(n, normals.xyz), 0.0);\n        // diffuse light intensity\n        float diff = max(dot(n, lightDir), 0.0);\n        \n        // Output to screen\n        fragColor = texColor * diff;\n    }\n    \n    Planet atm = Planet(p.b0, p.l0, p.ax*1.12, p.pos);\n    vec3 crt2 = scr2crt(uv, atm, c);\n    vec3 n = normalize(normal(atm, crt2));\n    vec3 l = normalize(lightDir);\n    if (!isnan(crt2.x) && isnan(crt.x)) {\n        float i = min(0.0, dot(n, l));\n        i = 1.0 - abs(i);\n        i = pow(i, 8.0) * (1.0 - pow(length(uv) / length(crt2), 5.0));\n        fragColor = normalize(vec4(0.0, i, i, 1.0));\n    } else {\n        float aIntense = max(0.0, dot(n, l)) * length(uv) * length(uv);\n        fragColor = fragColor + vec4(0.0, aIntense, aIntense, aIntense);\n    }\n}\n\n/**\n  * Project \"Image\" coordinates (the ones, got from interpolating \n  * vertices, bounding the planet) to a point on an ellipsoid surface\n  * in planetocentric certesian coordinates\n  * @param xp Abscissa of the image coordinate system, directed\n  * from left to right\n  * @param yp Ordinate of the image coordinate system, directed\n  * from bottom to the top\n  * @param D distance to the planet from camera\n  * @param b0 Lattitude of the observer in planetocentric coordinates\n  * @param l0 Longitude of the observer in planetocentric coordinates\n  * @param A, B, C Elipsoid semiaxes\n  * @param theta Azimuth to the planet in image plane\n  * @param rho Displacement of the planet from the line of sight\n  * @param P0 Position angle of the planet. From \"The North is above\" position\n  * @return vec2(b, l) where b stands for lattitude and l dor longitude\n  */\nvec3 img2crt(float xp, float yp, float D, \n             float b0, float l0, float A, float B, float C,\n             float theta, float rho, float P0) {\n    // transformation to decart coordinate system with origin in the center of the planet\n    // rotate around Z axis\n    mat4 rotZ = mat4( cos(theta), sin(theta), 0.0, 0.0,\n                     -sin(theta), cos(theta), 0.0, 0.0,\n                     0.0,         0.0,        1.0, 0.0,\n                     0.0,         0.0,        0.0, 1.0);\n    // translation to observer point\n    mat4 trObz = mat4(1.0, 0.0, 0.0, 0.0,\n                      0.0, 1.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, -D,\n                      0.0, 0.0, 0.0, 1.0);\n    // rotate around X\n    mat4 rotX = mat4(1.0, 0.0,       0.0,      0.0,\n                     0.0, cos(rho),  sin(rho), 0.0,\n                     0.0, -sin(rho), cos(rho), 0.0,\n                     0.0, 0.0,       0.0,      1.0);\n    // translate to the planet center\n    mat4 trPlan = mat4(1.0, 0.0, 0.0, 0.0,\n                       0.0, 1.0, 0.0, 0.0,\n                       0.0, 0.0, 1.0, D,\n                       0.0, 0.0, 0.0, 1.0);\n    // place planet central meridian along Y\n    mat4 rotPos = mat4( cos(P0 - theta),  sin(P0 - theta), 0.0, 0.0,\n                        -sin(P0 - theta), cos(P0 - theta), 0.0, 0.0,\n                        0.0,         0.0,        1.0, 0.0,\n                        0.0,         0.0,        0.0, 1.0);\n    // rotate on b0 and l0\n    mat4 rotb0 = mat4(1.0, 0.0,       0.0,      0.0,\n                      0.0, cos(b0),  sin(b0),   0.0,\n                      0.0, -sin(b0), cos(b0),   0.0,\n                      0.0, 0.0,       0.0,      1.0);\n    mat4 rotl0 = mat4( cos(l0), 0.0, sin(l0), 0.0,\n                      0.0,      1.0, 0.0,     0.0,\n                      -sin(l0), 0.0, cos(l0), 0.0,\n                      0.0,      0.0, 0.0,     1.0);\n    // apply all transformations\n    // vec4 xyzA = rotl0 * rotb0 * rotPos * trPlan * rotX * trObz * rotZ * vec4(xp, yp, 0, 0);\n    vec4 xyzA = vec4(xp, yp, 0, 0) * rotZ * trObz * rotX * trPlan * rotPos * rotb0 * rotl0;\n    \n    // coordinates of the observer\n    vec3 obs = vec3(\n        D * sin(l0) * cos(b0), \n        D * sin(b0),\n        D * cos(l0) * cos(b0)\n    );\n    // find intersections with the elipsoid\n    float a1 = 1.0 / A * (xyzA.x - obs.x) / (xyzA.z - obs.z);\n    float a2 = obs.x / A - a1 * obs.z;\n    float a3 = (xyzA.y - obs.y) / (xyzA.z - obs.z) / B;\n    float a4 = obs.y / B - a3 * obs.z;\n    float c1 = a1 * a2 + a3 * a4;\n    float c2 = a1 * a1 + a3 * a3 + 1.0 / (C * C);\n    \n    float z1 = (-c1 + sqrt(c1 * c1 - c2 * (a2 * a2 + a4 * a4 - 1.0))) / c2;\n    float z2 = (-c1 - sqrt(c1 * c1 - c2 * (a2 * a2 + a4 * a4 - 1.0))) / c2;\n    vec3 p1 = vec3(A * (a1 * z1 + a2), B * (a3 * z1 + a4), z1);\n    vec3 p2 = vec3(A * (a1 * z2 + a2), B * (a3 * z2 + a4), z2);\n    // take the closest point\n    vec3 p;\n    if (modulus(obs - p1) < modulus(obs - p2)) {\n        p = p1;\n    } else {\n        p = p2;\n    }\n    \n    return p;\n}\n\n/**\n  * Hammer map rojection\n  * @param lb Lattitude and Longitude\n  * @retunr X and Y in decatr coordinate system\n  */\nvec2 hammer(vec2 bl) {\n    bl.y = bl.y - pi / 2.0;\n    float s = sqrt(1.0 + cos(bl.x) * cos(bl.y / 2.0));\n    float x = cos(bl.x) * sin(bl.y / 2.0) / s;\n    float y = sin(bl.x) / s;\n    y = (y + 1.0) / 2.0;\n    x = (x + 1.0) / 2.0;\n    return vec2(x, y);\n}\n\nvec2 aitoff(vec2 bl) {\n    bl.y = bl.y - pi / 2.0;\n    float coef = 1.2;\n    float a = acos(cos(bl.x) * cos(bl.y / 2.0));\n    float x = 2.0*(cos(bl.x / coef) * sin(bl.y / 2.0)) / (sin(a) / a);\n    float y = sin(bl.x) / (sin(a) / a);\n    y = (y / (pi/2.0) + 1.0) / 2.0;\n    x = (x / (pi) + 1.0) / 2.0;\n    return vec2(x, y);\n}\n\nvec2 eqEarth(vec2 bl) {\n    bl.y = bl.y - pi / 2.0;\n    float theta = asin(sqrt(3.0) / 2.0 * sin(bl.x));\n    float A1 = 1.340264;\n    float A2 = -0.081106;\n    float A3 = 0.000893;\n    float A4 = 0.003796;\n    float x = 2.0 * sqrt(3.0) * bl.y * cos(theta) / 3.0 / (9.0 * A4 * pow(theta, 8.0) + 7.0 * A3 * pow(theta, 6.0) + 3.0 * A2 * pow(theta, 2.0) + A1);\n    float y = A4 * pow(theta, 9.0) + A3 * pow(theta, 7.0) + A2 * pow(theta, 3.0) + A1 * theta;\n    float p1 = 2.7;\n    float p2 = 1.5;\n    x = (x + p1) / (p1 * 2.0);\n    y = (y + p2) / (p2 * 2.0);\n    return vec2(x, y);\n}\n\n/**\n  * Project coordinates from the screen to planetocentric certesian coordinates\n  */\nvec3 scr2crt(vec2 scr, Planet p, Camera c) {\n    float D = modulus(p.pos - c.pos);\n    float theta = atan(c.up.y, c.up.x);\n    float rho = 0.0;//acos(scalMul(p.pos, c.pos) / (modulus(p.pos) * modulus(c.pos)));\n    float P0 = 0.0;\n    vec3 plan2cam = c.pos - p.pos;\n    vec2 b0l0 = spher(plan2cam);\n    vec3 planetCrt = img2crt(scr.x, scr.y, \n                            D, b0l0.x + p.b0, b0l0.y + p.l0, p.ax.x, p.ax.y, p.ax.z, \n                            theta, rho, P0);\n    return planetCrt;\n}\n\n// get lattitude and longitude from certesian coordinates of a pont on the ellipsoid\nvec2 crt2sphere(vec3 crt) {\n    // get spherical coordinates\n    float b = asin(crt.y / modulus(crt));\n    float l = atan(crt.x / crt.z) - pi * sign(crt.z) * (1.0 - sign(crt.z)) / 2.0;\n    return vec2(b, l);\n}\n\n/**\n  * Calculate normal to the ellipsoid\n  * @param p Planet\n  * @param point Certesian coordinates of a point on the ellipsoid\n  * @return normal vector\n  */\nvec3 normal(Planet p, vec3 point) {\n    float b0 = -p.b0;\n    float l0 = -p.l0;\n    mat3 rotb0 = mat3(1.0, 0.0,      0.0,   \n                      0.0, cos(b0),  sin(b0),\n                      0.0, -sin(b0), cos(b0));\n    mat3 rotl0 = mat3( cos(l0), 0.0, sin(l0),\n                      0.0,      1.0, 0.0,\n                      -sin(l0), 0.0, cos(l0));\n    vec3 F = vec3(2.0 / p.ax.x * p.ax.x, \n                  2.0 / p.ax.y * p.ax.y, \n                  2.0 / p.ax.z * p.ax.z);\n    point = point * rotl0 * rotb0;\n    vec3 n = F * point;\n    return normalize(n);\n}\n\nfloat modulus(vec3 v) {\n    return sqrt(pow(abs(v.x), 2.0) + pow(abs(v.y), 2.0) + pow(abs(v.z), 2.0));\n}\n\nfloat scalMul(vec3 v1, vec3 v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nvec2 spher(vec3 v) {\n    float phi = atan(v.y, v.x);\n    float theta = acos(v.z / modulus(v));\n    return vec2(theta, phi);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtdyzN", "name": "Exact SDF Modelling Exercise #1", "author": "oneshade", "description": "First exact SDF modelling execercise (aside from the easy ones: sphere, torus, plane ;) ).", "tags": ["3d", "sdf", "exercise", "exact", "revolved"], "likes": 5, "viewed": 311, "date": "1608593160", "time_retrieved": "2024-06-20T20:27:46.312308", "image_code": "float mapScene(in vec3 p) {\n    vec3 a = vec3(cos(iTime), 2.0 * sin(iTime), cos(iTime * 2.0)); // Opening of the tube\n    vec3 b = vec3(0.0, 0.0, 0.0); // Base of the tube\n\n    vec3 ba = a - b;\n    vec2 sp = vec2(atan(ba.z, ba.x), atan(ba.y, length(ba.xz)));\n    vec4 cs = vec4(cos(sp), sin(sp));\n\n    p -= b; // Translate to the base\n    p.xz *= mat2(cs.x, cs.z, -cs.z, cs.x); // Rotate to point along axis ba\n    p.xy *= mat2(cs.y, cs.w, -cs.w, cs.y);\n\n    vec2 size = vec2(cos(iTime) + 1.0, sin(iTime * 2.0) + 2.0); // radius, height\n    vec2 pr = vec2(length(p.yz), p.x); // Revolve the shape\n\n    // Can you spot those sneaky branches?\n    float tube = pr.y < 0.0 ? abs(length(pr) - size.x) : pr.y < size.y ? abs(abs(pr.x) - size.x) : length(abs(pr - vec2(0.0, size.y)) - vec2(size.x, 0.0));\n\n    return tube - 0.25 + 0.249 * sin(iTime);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float dt = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * dt;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtdyzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WttcRB", "name": "4D Fractal Noise", "author": "oneshade", "description": "Why would anyone need 4D noise?", "tags": ["noise", "4d", "fractalnoise"], "likes": 8, "viewed": 192, "date": "1609375685", "time_retrieved": "2024-06-20T20:27:46.312308", "image_code": "#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// New hash based on hash13() from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat noise(in vec4 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zwyx + 31.32);\n    return fract((p.x + p.y) * p.z - p.x * p.w);\n}\n\nfloat snoise(in vec4 p) {\n    vec4 cell = floor(p);\n    vec4 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldbq = noise(cell);\n    float rdbq = noise(cell + vec4(1.0, 0.0, 0.0, 0.0));\n    float ldfq = noise(cell + vec4(0.0, 0.0, 1.0, 0.0));\n    float rdfq = noise(cell + vec4(1.0, 0.0, 1.0, 0.0));\n    float lubq = noise(cell + vec4(0.0, 1.0, 0.0, 0.0));\n    float rubq = noise(cell + vec4(1.0, 1.0, 0.0, 0.0));\n    float lufq = noise(cell + vec4(0.0, 1.0, 1.0, 0.0));\n    float rufq = noise(cell + vec4(1.0, 1.0, 1.0, 0.0));\n    float ldbw = noise(cell + vec4(0.0, 0.0, 0.0, 1.0));\n    float rdbw = noise(cell + vec4(1.0, 0.0, 0.0, 1.0));\n    float ldfw = noise(cell + vec4(0.0, 0.0, 1.0, 1.0));\n    float rdfw = noise(cell + vec4(1.0, 0.0, 1.0, 1.0));\n    float lubw = noise(cell + vec4(0.0, 1.0, 0.0, 1.0));\n    float rubw = noise(cell + vec4(1.0, 1.0, 0.0, 1.0));\n    float lufw = noise(cell + vec4(0.0, 1.0, 1.0, 1.0));\n    float rufw = noise(cell + 1.0);\n\n    return mix(mix(mix(mix(ldbq, rdbq, local.x),\n                       mix(lubq, rubq, local.x),\n                       local.y),\n\n                   mix(mix(ldfq, rdfq, local.x),\n                       mix(lufq, rufq, local.x),\n                       local.y),\n\n                   local.z),\n\n               mix(mix(mix(ldbw, rdbw, local.x),\n                       mix(lubw, rubw, local.x),\n                       local.y),\n\n                   mix(mix(ldfw, rdfw, local.x),\n                       mix(lufw, rufw, local.x),\n                       local.y),\n\n                   local.z),\n\n               local.w);\n}\n\nfloat fnoise(in vec4 p, in float scale, in float octaves) {\n    p *= scale;\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    float octaves = 4.0;\n    float threshold = 0.4;\n\n    if (iMouse.z > 0.0) {\n        octaves = iMouse.y / iResolution.y * 4.0;\n        threshold = iMouse.x / iResolution.x * 0.9;\n    }\n\n    vec3 q = abs(p) - 1.5;\n    float bbox = max(q.x, max(q.y, q.z));\n\n    return max(fnoise(vec4(p, iTime * 0.5), 2.0, octaves) - threshold, bbox);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0), rd = normalize(vec3(uv, -1.0)), p;\n    float t = 0.0, d;\n    bool hit = false;\n\n    for (int iter=0; iter < 100; iter++) {\n        p = ro + rd * t;\n\n        p.y -= 0.3;\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        d = mapScene(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        fragColor.rgb += 0.5 + 0.5 * n;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WttcRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WttcRr", "name": "Morphing Sierpinski Analogues", "author": "mherreshoff", "description": "Three versions (art deco, vanilla, and lightning) of a continuously morphing analogue of the Sierpinski triangle that I cooked up recently.  They play in order one after the other (so the animation won't loop until the fourth time you see the circle.)", "tags": ["fractal", "triangle", "sierpinski", "morphing"], "likes": 8, "viewed": 258, "date": "1608366029", "time_retrieved": "2024-06-20T20:27:46.312308", "image_code": "#define PI 3.1415926535\n#define CS(a) vec2(cos(a), sin(a))\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0)))\nvec2 cmul(vec2 a, vec2 b) {\n    return mat2(a,-a.y,a.x)*b;\n}\n\n\nvec2 target (vec2 z, float twist) {\n    vec2 weightedSum=vec2(0); float weight=0.;\n#define N 3.\n    for (float i = 0.; i < N; i++) {\n        float theta = 6.28*(i/N);\n        vec2 point = CS(theta), d = z-point;\n        float L = length(d), w = pow(L, -10.);\n        vec2 scale = 2.*CS(twist*theta);\n        weight += w;\n        weightedSum += w*cmul(scale, d);\n    }\n    return weightedSum/weight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy, pw = 1./R, uv = fragCoord*pw;\n    \n    float cycleT=30., t = fract(iTime/cycleT), cycle = floor(iTime/cycleT),\n          twist = mod(cycle, 3.)-1., maxIt = (twist < -.5 ? 5. : 6.), \n          iterations = maxIt*(smoothstep(0.,.5,t)-smoothstep(.5,1.,t)),\n          zoom = 3.+smoothstep(0., 1., iterations)*(twist < -.5 ? 6. : (twist < .5 ? 1. : 2.));\n\n    vec2 p = ((fragCoord-.5*R)/R.y)*zoom;\n    for (float i = 0.; i < 10.; i++){\n        if (i < floor(iterations)) p = target(p, twist);\n    }\n    p = mix(p, target(p, twist), fract(iterations));\n    \n    float mag = length(p);\n    vec4 col = mix(vec4(.5), vec4(1.), min(1., mag));\n    col = mix(col, hue(.6), smoothstep(1., 1.5, mag)-smoothstep(1.5,2., mag));\n    col = col*min(1., pow(length(p), -2.));\n\tfragColor = col;\n    //fragColor = hue(atan(p.y, p.x)/6.28);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WttcRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wttcWn", "name": "Day 2: Animated background", "author": "Gratemate", "description": "Trying to animate SDFs.", "tags": ["2d", "background"], "likes": 1, "viewed": 92, "date": "1608829730", "time_retrieved": "2024-06-20T20:27:46.312308", "image_code": "//2d SFDs from https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat ndot(vec2 a,vec2 b){return a.x*b.x-a.y*b.y;}\n\nfloat sdCircle(vec2 p,float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEquilateralTriangle(in vec2 p)\n{\n    const float k=sqrt(3.);\n    p.x=abs(p.x)-1.;\n    p.y=p.y+1./k;\n    if(p.x+k*p.y>0.)p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x-=clamp(p.x,-2.,0.);\n    return-length(p)*sign(p.y);\n}\n\n//a - bottom left, b - top right, th-thickness\nfloat sdOrientedBox(in vec2 p,in vec2 a,in vec2 b,float th)\n{\n    float l=length(b-a);\n    vec2 d=(b-a)/l;\n    vec2 q=(p-(a+b)*.5);\n    q=mat2(d.x,-d.y,d.y,d.x)*q;\n    q=abs(q)-vec2(l,th)*.5;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n\nfloat sdRhombus(in vec2 p,in vec2 b)\n{\n    vec2 q=abs(p);\n    float h=clamp((-2.*ndot(q,b)+ndot(b,b))/dot(b,b),-1.,1.);\n    float d=length(q-.5*b*vec2(1.-h,1.+h));\n    return d*sign(q.x*b.y+q.y*b.x-b.x*b.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord.xy*2./iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    float stage=floor(fract(iTime*.35)*4.);\n    vec3 col=vec3(1.,uv);\n    \n    //center triangle\n    float centerTri=sdEquilateralTriangle(uv*3.);\n    centerTri=abs(.02/centerTri);\n    \n    //center box spinning\n    vec2 orientBox=vec2(cos(iTime)*.1,sin(iTime)*.1);\n    float boxMiddleD=sdOrientedBox(uv,-orientBox,orientBox,.2);\n    float boxMiddle=1.-smoothstep(0.,.01,abs(boxMiddleD));\n    float final=max(boxMiddle,centerTri);\n    \n    //first screen - rhombus\n    float romb1=sdRhombus(uv,vec2(1.));\n    romb1=1.-smoothstep(0.,.01,abs(romb1));\n    if(stage==0.)final=max(final,romb1);\n    \n    //second screen double circle\n    float circ2_1=sdCircle(uv,.8);\n    circ2_1=1.-smoothstep(0.,.01,abs(circ2_1));\n    float circ2_2=sdCircle(uv,.75);\n    circ2_2=1.-smoothstep(0.,.01,abs(circ2_2));\n    float circ2=max(circ2_1,circ2_2);\n    if(stage==1.)final=max(final,circ2);\n    \n    //third screen - green dots\n    float romb3=1.;\n    for(float i=-2.;i<2.;i+=.3){\n        for(float j=-1.;j<1.;j+=.3){\n            vec2 offset=vec2(fract(iTime*.35))*.1-vec2(.1);\n            float rombTemp=sdCircle(uv+vec2(i,j)+vec2(0.,.1)+offset,.03);\n            rombTemp=smoothstep(0.,.01,rombTemp);\n            romb3=min(romb3,rombTemp);\n        }\n    }\n    romb3=1.-romb3;\n    if(stage==2.)final=max(final,romb3);\n    \n    //fourth screen - double triangle\n    float tri4_1=sdEquilateralTriangle(uv*-1.);\n    tri4_1=1.-smoothstep(0.,.01,abs(tri4_1));\n    float tri4_2=sdEquilateralTriangle(uv*2.);\n    tri4_2=1.-smoothstep(0.,.01,abs(tri4_2));\n    float tri4=max(tri4_1,tri4_2);\n    if(stage==3.)final=max(final,tri4);\n    \n    col+=vec3(max(.4,sin(length(vec2(sin(uv.x*5.),cos(iTime*.1))*124.))));\n    col*=vec3(final);\n    \n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wttcWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wttczH", "name": "Recursive christmas spheres", "author": "fidlajka", "description": "Christmas decoration, recursive function via stack using https://www.shadertoy.com/view/Xds3zM by iq", "tags": ["christmas", "recursion", "decoration"], "likes": 5, "viewed": 65, "date": "1608511403", "time_retrieved": "2024-06-20T20:27:46.318188", "image_code": "# define M_PI 3.14159265358979323846\n\nfloat dstnc (vec2 A, vec2 B)\n{\n    return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y-B.y)); \n\n}\n\nstruct Banka\n{\n\tvec3 center;\n\tfloat r;\n    int side;\n    int level;\n};\n\nBanka stack[85];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = vec4(1.0,1.0,1.0,1.0);\n\n    vec4 red_dark = vec4(0.6,0.0,0.2,1.0);\n    vec4 red_light = vec4(0.8,0.0,0.0,1.0);\n    vec4 green_dark = vec4(0.047, 0.433, 0.160, 1.0);\n    vec4 green_light = vec4(0.074, 0.666, 0.215, 1.0);\n    vec4 gold_dark = vec4(0.831, 0.686, 0.215, 1.0);\n    vec4 gold_light = vec4(1.0, 0.8745, 0.0, 1.0);\n\n    float radius = iResolution.y/5.0;\n    vec2 center = iResolution.xy/2.0;\n      \n    stack[0] = Banka( vec3(center,0.0), radius, 4, 0);\n\tint s = 0;\n    \n    float near_z = 100000.0;\n    \n    for(int i=0; i<86; i++)\n    {\n        // pop from the stack\n\t\tBanka x = stack[s--];\n        \n        // render main banka\n\t\tfloat dist = dstnc(fragCoord, x.center.xy);\n        if(dist < x.r && x.center.z < near_z)\n        {\n            float t = dist/x.r;\n            if(x.level%2 == 0)\n            {\n                fragColor = green_light * (1.0-t) + green_dark *t;\n            }\n            else if (x.level%2 == 1)\n            {\n                fragColor = red_light * (1.0-t) + red_dark *t;\n                \n                if(x.level == 1)\n                {\n                  if (fragCoord.y < x.center.y + x.r*0.8 && fragCoord.y > x.center.y + x.r*0.6f)\n                  {\n                    fragColor = gold_light * (1.0-t) + gold_dark *t;\n                  }\n\n                  if (fragCoord.y > x.center.y - x.r*0.8 && fragCoord.y < x.center.y - x.r*0.6f)\n                  {\n                    fragColor = gold_light * (1.0-t) + gold_dark *t;\n                  }\n\n                  if (fragCoord.y < x.center.y + x.r*0.05f && fragCoord.y > x.center.y - x.r*0.05f)\n                  {\n                    fragColor = gold_light * (1.0-t) + gold_dark *t;\n                  }\n                }\n             }\n             \n             near_z = x.center.z;\n            \n          }\n                \n        // push new banky into the stack\t\t\n        \n        float new_r = x.r * 0.35;\n        float offset = x.r + new_r;\n        \n        if(x.level<3 && dist < 2.2*x.r) // 0-TOP, 3-BOTTOM, 1-RIGHT, 2-LEFT\n        {\n\t\t\tif(x.side!=3) {stack[++s] = Banka( vec3(x.center.x, x.center.y - offset, x.center.z + offset*sin(iTime)), new_r, 0, x.level+1 );}\n            if(x.side!=0) {stack[++s] = Banka( vec3(x.center.x, x.center.y + offset, x.center.z - offset*sin(iTime)), new_r, 3, x.level+1 );}\n            if(x.side!=2) {stack[++s] = Banka( vec3(x.center.x + offset*cos(iTime), x.center.y, x.center.z + offset*sin(iTime)), new_r, 1, x.level+1 );}\n            if(x.side!=1) {stack[++s] = Banka( vec3(x.center.x - offset*cos(iTime), x.center.y, x.center.z - offset*sin(iTime)), new_r, 2, x.level+1 );}\n        }\n        \n    \n    }\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wttczH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WttczN", "name": "Rainbow Voronoi 2", "author": "Thrump", "description": "Started with https://www.youtube.com/watch?v=l-07BXzNdPw\nadded rainbows", "tags": ["voronoi", "rainbow"], "likes": 3, "viewed": 66, "date": "1608593093", "time_retrieved": "2024-06-20T20:27:46.318188", "image_code": "vec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n\n    float t = iTime*0.2;\n\n    vec3 minDist = vec3(100.);\n\n    for (int ci=0; ci<3; ci++) {  \n        for(float i=0.; i<50.; i++) {\n            vec2 n = N22(vec2(i+float(ci*500)));\n            n.x *= aspect;\n            vec2 p = sin(n*t);\n            float d = (sin(iTime*2.)+2.) * length(uv - p);\n\n            if (d<minDist[ci]) {\n                minDist[ci] = d;\n            }\n        }\n    }\n\n \n    vec3 col = minDist;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WttczN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WttczS", "name": "Test Turned Demo?!?", "author": "oneshade", "description": "Messing with point lights turned into this?!?", "tags": ["glow", "neon", "cool", "happyaccident"], "likes": 1, "viewed": 91, "date": "1609363207", "time_retrieved": "2024-06-20T20:27:46.318188", "image_code": "struct Light {\n    vec3 pos; // Position of the light\n    vec3 col; // Color of the light\n};\n\nmat2 Rotate(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise(in float x) {\n    return fract(sin(x * 12.5673) * 573.123);\n}\n\nfloat snoise(in float x) {\n    float r = 2.735;\n\n    float y1 = noise(floor(x / r) * r);\n    float y2 = noise(ceil(x / r) * r);\n    float i = fract(x / r);\n    i *= i * (3.0 - 2.0 * i);\n\n    return mix(y1, y2, i);\n}\n\nfloat mapScene(in vec3 p) {\n    p.xz = mod(p.xz - 2.0, 4.0) - 2.0;\n    p.yz *= Rotate(-60.0);\n    p.xz *= Rotate(iTime);\n\n    vec3 q1 = abs(p) - 1.2;\n    float box = max(q1.x, max(q1.y, q1.z));\n\n    vec2 q2 = abs(p.xy) - 0.8;\n    vec2 q3 = abs(p.xz) - 0.8;\n    vec2 q4 = abs(p.yz) - 0.8;\n\n    float tube1 = max(q2.x, q2.y);\n    float tube2 = max(q3.x, q3.y);\n    float tube3 = max(q4.x, q4.y);\n\n    float sphere = length(p) - 2.0;\n\n    float scene = max(mix(box, sphere, 0.5), -mix(min(tube1, min(tube2, tube3)), sphere, 0.5)) - 0.1;\n    return scene * 0.6;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float t1 = 0.5 * iTime;\n    float t3 = 1.5 * iTime;\n\n    float c1 = cos(t1) * 2.0, s1 = sin(t1) * 2.0;\n    float c2 = cos(iTime) * 2.0, s2 = sin(iTime) * 2.0;\n    float c3 = cos(t3) * 2.0, s3 = sin(t3) * 2.0;\n\n    Light lights[4] = Light[](Light(vec3(c1, c3, s2), vec3(1.0, 0.0, 0.0)),\n                              Light(vec3(s2, c1, s3), vec3(0.0, 1.0, 0.0)),\n                              Light(vec3(s2, s3, c1), vec3(0.0, 0.0, 1.0)),\n                              Light(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0) * snoise(iTime * 15.0)));\n\n    vec3 ro = vec3(s1, s2, c3) * 3.0;\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            fragColor.b += 0.25;\n            break;\n        }\n\n        for (int l=0; l < lights.length(); l++) {\n            fragColor.rgb += 0.005 * lights[l].col * length(ro + f * dot(lights[l].pos - ro, f) - lights[l].pos);\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WttczS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wttyR4", "name": "Baldwin-Weber Triangle Intersect", "author": "gelami", "description": "Implementation of Baldwin-Weber ray-triangle intersection algorithm from this paper http://jcgt.org/published/0005/03/03/", "tags": ["raytracing", "triangle", "intersection"], "likes": 3, "viewed": 202, "date": "1608687411", "time_retrieved": "2024-06-20T20:27:47.251429", "image_code": "\n/* Implementation of Baldwin-Weber ray-triangle intersection algorithm\n * \n * From this paper: http://jcgt.org/published/0005/03/03/\n * \n * Computes a world-to-baycentric transform matrix\n * which is supposed to be stored instead of computing it everytime but ¯\\_(ツ)_/¯\n *\n * Not sure what's the difference with the current algorithms in use\n * \n * Added a branchless(?) version that uses the array syntax\n *\n */\n \n#define USE_BRANCHLESS\n \nvec3 tcol;\n\nmat2 rot2d(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nmat3 getCameraMatrix( in vec3 ro, in vec3 la, in float r) {\n\n    vec3 cw = normalize(la - ro);\n    vec3 cu = cross(cw, vec3(sin(r), 0, cos(r)));\n    vec3 cv = cross(cu, cw);\n    \n    return mat3(cu, cv, cw);\n}\n\nvec3 baldwinRayTriIntersect( in vec3 ro, in vec3 rd,\n                             in vec3 A, in vec3 B, in vec3 C, out vec3 normal) {\n    \n    vec3 E1 = B - A;\n    vec3 E2 = C - A;\n    \n    vec3 n = cross(E1, E2);\n    \n    normal = normalize(n);\n    \n    vec3 an = abs(n);\n  \n    // Vectors for each row of the matrix\n    vec4 tmat1, tmat2, tmat3;\n    float num = -dot(A, n);\n    \n    // Ideally, the matrix is only computed once and stored in memory\n    \n    // Compute world-to-baycentric transformation matrix\n    \n  #ifndef USE_BRANCHLESS\n    // Branching version\n    if (an.x > an.y && an.x > an.z)\n    {\n        tmat1 = vec4(0., E2.z, -E2.y,  C.y * A.z - C.z * A.y) / n.x;\n        tmat2 = vec4(0., -E1.z, E1.y, -B.y * A.z + B.z * A.y) / n.x;\n        tmat3 = vec4(n.xyz, num) / n.x;\n        \n    } else if (an.y > an.z)\n    {\n        tmat1 = vec4(-E2.z, 0., E2.x,  C.z * A.x - C.x * A.z) / n.y;\n        tmat2 = vec4(E1.z, 0., -E1.x, -B.z * A.x + B.x * A.z) / n.y;\n        tmat3 = vec4(n.xyz, num) / n.y;\n    } else if (an.z > 0.)\n    {\n        tmat1 = vec4(E2.y, -E2.x, 0.,  C.x * A.y - C.y * A.x) / n.z;\n        tmat2 = vec4(-E1.y, E1.x, 0., -B.x * A.y + B.y * A.x) / n.z;\n        tmat3 = vec4(n.xyz, num) / n.z;\n    }\n    \n  #else\n    // No branching using array syntax\n    \n    /*\n    int ni;\n    if (an.x > an.y && an.x > an.z)\n        ni = 0;\n    else if (an.y > an.z)\n        ni = 1;\n    else if (an.z > 0.)\n        ni = 2;\n    */\n    \n    // Same as above using step\n    vec3 nn = step(an.yzx, an.xyz) * step(an.zxy, an.xyz);\n    int ni = int( dot(nn, vec3(0,1,2)) );\n    \n    int n1 = (ni + 1) % 3;\n    int n2 = (ni + 2) % 3;\n    int n3 = (1 - ni) % 3;\n    int n4 = (2 - ni) % 3;\n    int n5 = (3 - ni) % 3;\n    \n    tmat1 = vec4(E2[n5], E2[n4], E2[n3],  C[n1] * A[n2] - C[n2] * A[n1]) / n[ni];\n    tmat2 = vec4(E1[n5], E1[n4], E1[n3], -B[n1] * A[n2] + B[n2] * A[n1]) / n[ni];\n    tmat3 = vec4(n.xyz, num) / n[ni];\n    \n    tmat1[ni] = 0.;\n    tmat2[ni] = 0.;\n    \n    tmat1[n2] *= -1.;\n    tmat2[n1] *= -1.;\n    \n  #endif\n    \n    float s = dot(vec4(ro, 1), tmat3);\n    float d = dot(vec4(rd, 0), tmat3);\n    \n    // Distance\n    float t = -s / d;\n    \n    vec4 pos = vec4(ro + rd*t, 1);\n    \n    // UV\n    float u = dot(pos, tmat1);\n    float v = dot(pos, tmat2);\n    \n    if (u < 0. || v < 0. || (u + v) > 1.)\n        t = -1.;\n    \n    return vec3(t, u, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 pv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(1, -8, 3);\n    vec3 lo = vec3(0, 0, 0);\n    \n    ro.xy *= rot2d(iTime * .2);\n    \n    mat3 mat = getCameraMatrix(ro, lo, 0.1);\n\n    vec3 rd = mat * normalize(vec3(pv.x, pv.y, 1));\n    \n    float time = sin(iTime) * .5 + .5;\n    \n    vec3 A = sin(iTime * 1.0 + vec3(1, 2, 4)) * vec3(1.5, 2., 1.5) + vec3(0, 0, 1);\n    vec3 B = sin(iTime * 1.2 + vec3(5, 1, 1)) * vec3(1.5, 2., 1.5) + vec3(0, 0, 1);\n    vec3 C = sin(iTime * 1.3 + vec3(3, 2, 2)) * vec3(1.5, 2., 1.5) + vec3(0, 0, 1);\n    \n    // Triangle Intersect\n    vec3 n;\n    vec3 tri = baldwinRayTriIntersect(ro, rd, A, B, C, n);\n    \n    // Plane Intersect\n    vec3 pn = vec3(0, 0, 1);\n    float plt = -(dot(ro, pn) + 0.) / dot(rd, pn);\n    \n    vec2 pl = (ro + plt * rd).xy;\n    \n    vec3 col = vec3(0);\n    \n    float scale = 1.;\n    pl *= scale;\n    \n    vec2 pe = min(vec2(1), fwidth(pl));\n    \n    vec2 grid = smoothstep(vec2(1), 1. - pe, fract(pl)) +\n                smoothstep(vec2(0), pe, fract(pl)) - (1.0 - pe);\n    \n    // Grid lines\n    col = mix(vec3(.2), vec3(.05) + (1. - (grid.x * grid.y)) * .5, exp(-plt*0.01));\n    \n    // XY Red-Green Axis lines\n    col = mix(col, vec3(0, .5, 0), smoothstep(.01+pe.x, 0., abs(pl.x)));\n    col = mix(col, vec3(.5, 0, 0), smoothstep(.01+pe.y, 0., abs(pl.y)));\n    \n    col = mix(vec3(.2), col, step(0., plt));\n    \n    // Triangle mask\n    float tmask = smoothstep(0., .02, tri.y) *\n                  smoothstep(0., .02, tri.z) *\n                  smoothstep(1., .98, tri.y + tri.z);\n    \n    // Triangle grid\n    vec3 uvw = vec3(tri.yz, 1. - tri.y - tri.z);\n    float tg = step(.1, fract(uvw.x*10.)) * step(.1, fract(uvw.y*10.));\n    col = mix(col, uvw * tg, tmask);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wttyR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wttyR7", "name": "SimpleVesicaShape", "author": "yasuo", "description": "vesica.", "tags": ["vesica"], "likes": 18, "viewed": 272, "date": "1608738153", "time_retrieved": "2024-06-20T20:27:48.875942", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define BASE_COLOR vec3(0.3,0.6,0.3)\n#define BORDER 0.001\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\n// https://www.youtube.com/watch?v=PMltMdi1Wzg&t=367s\nfloat sdSegment(vec2 p, float L, float R) {\n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-R;\n}\n\n// Advice from FabriceNeyret2. cos( a + vec2(0,11) ) does magic!\nfloat layer0(vec2 p){\n    vec2 prevP = p;\n    float r = BORDER;\n    p = abs(p);\n    p -= vec2(0.05);\n    float d = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    p = prevP;\n    \n    p*= Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.05);\n    float d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    \n    d = min(abs(d)-r,abs(d2)-r);\n    \n    /*\n    for(float i = 0.0;i<4.0; i++) {\n        p = prevP;\n        p*= Rot(radians(22.5*i));\n        p = abs(p);\n        p -= vec2(0.115);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n        d = min(d,abs(d2)-r); \n    }\n    */\n    \n    p = prevP;\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.115);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    d = min(d,abs(d2)-r); \n    \n    p = prevP;\n    p = DF(p,8.0);\n    p = abs(p);\n    p -= vec2(0.167);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.099);\n    d = min(d,abs(d2)-r); \n        \n    /*\n    for(float i = 0.0;i<8.0; i++) {\n        p = prevP;\n        p*= Rot(radians(11.25*i));\n        p = abs(p);\n        p -= vec2(0.167);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.099);\n        d = min(d,abs(d2)-r); \n    }\n    */\n    p = prevP;\n    d2 = length(p)-0.32;\n    d = min(d,abs(d2)-r);\n    d2 = length(p)-0.45;\n    d = min(d,abs(d2)-r);    \n    \n    return d;\n}\n\nfloat layer1(vec2 p, float d){\n    vec2 prevP = p;\n    float r = BORDER;\n    float d2 = 0.0;\n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.215);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n    d = min(d,abs(d2)-r); \n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.315);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n    d = min(d,abs(d2)-r); \n        \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.265);\n    d2 = length(p)-0.016;\n    d = min(d,abs(d2)-r);\n    \n    /*\n    for(float i = 0.0;i<16.0; i++) {\n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.215);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n        d = min(d,abs(d2)-r); \n    \n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.315);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n        d = min(d,abs(d2)-r);\n        \n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.28);\n        d2 = length(p)-0.03;\n        d = min(d,abs(d2)-r);\n    }\n    */\n    \n    return d;\n}\n\nfloat layer2(vec2 p, float d, float scale, float scale2, float numline){\n    vec2 prevP = p;\n    float r = BORDER;\n    float d2 = 1.0;\n    \n    float t = iTime *0.1;\n\n    for(float i = 0.0; i<numline; i++){\n        float targetScale1 = 0.3-(i*scale2);\n        float targetScale2 = (0.2-(i*scale2));\n        float targetScale3 = (0.17-(i*scale2));\n        \n        if(i>=4.0) {\n            targetScale1 = (0.3-(i*0.01))*abs(sin(t*i))+0.1*(i*0.1);\n            targetScale2 = (0.2-(i*0.01))*abs(sin(t*i))+0.05*(i*0.1);\n            targetScale3 = (0.17-(i*0.01))*abs(sin(t*i))+0.03*(i*0.1);\n        }        \n        \n        p = prevP;\n        p.x = abs(p.x);\n        p.x -= 0.5*scale;\n        d2 = SimpleVesicaDistance(p*Rot(radians(90.0)),targetScale1*scale,0.2*scale);\n\n        d = min(d,abs(d2)-r*1.0);\n\n        p = prevP;\n        p = abs(p);\n        p -= vec2(0.3)*scale;\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),targetScale1*scale,0.2*scale);\n\n        d = min(d,abs(d2)-r*1.0);    \n\n        p = prevP;\n        p.y = abs(p.y);\n        p.y -= 0.4*scale;\n        d2 = length(p)-targetScale2*scale;\n\n        d = min(d,abs(d2)-r*1.0);\n\n        p = prevP;\n        p = abs(p);\n        p -= vec2(0.35,0.15)*scale;\n        d2 = length(p)-targetScale3*scale;\n\n        d = min(d,abs(d2)-r*1.0); \n    }\n    \n    return d;\n}\n\nfloat VesicaShapeDistance(vec2 p) {\n    float t = iTime*0.2;\n    float d = layer2(p,1.0,1.0,0.02,6.0);\n    d = max(-( length(p)-0.45),d);    \n    \n    float d2 = min(d,layer0(p*Rot(radians(-30.0*t))));\n    float d3 = layer1(p*Rot(radians(30.0*t*0.5)),d2);\n    return d3;\n}\n\nfloat VesicaShapeBackground(vec2 p) {\n    vec2 prevP = p;\n    float d = 1.0;\n    p.x = abs(p.x);\n    p.x -= 0.5;\n    float d2 = SimpleVesicaDistance(p*Rot(radians(90.0)),0.3,0.2);\n\n    d = min(d,d2);\n\n    p = prevP;\n    p = abs(p);\n    p -= vec2(0.3);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.3,0.2);\n\n    d = min(d,d2);    \n\n    p = prevP;\n    p.y = abs(p.y);\n    p.y -= 0.4;\n    d2 = length(p)-0.2;\n\n    d = min(d,d2);\n\n    p = prevP;\n    p = abs(p);\n    p -= vec2(0.35,0.15);\n    d2 = length(p)-0.17;\n\n    d = min(d,d2); \n    \n    p = prevP;\n    \n    d2 = length(p)-0.45;\n    d = min(d,d2); \n    \n    return d;\n}\n\nfloat Background(vec2 p) {\n    float t = iTime *0.3;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n    \n    vec2 prevP = p;\n    vec2 prevP2 = p;\n    \n    float d = layer2(p,1.0,0.3,0.04,3.0);\n    \n    p*=Rot(radians(-30.0*t));\n    prevP*=Rot(radians(-30.0*t));\n    p*=2.5;\n    prevP*=2.5;\n    \n    p = abs(p);\n    p-=vec2(0.105,0.043);\n    float h = mod(t*0.3,0.6);\n    if(h>=0.2){\n        h = 0.2-(h-0.2);\n    }\n    float d2 = sdSegment(p*Rot(radians(-52.0)),h,0.004);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -= 0.105;\n    p.y += 0.042;\n    d2 = sdSegment(p,(h/0.2)*0.085,0.004);\n    d = min(d,d2);\n    \n    p = prevP2;\n    p = abs(p);\n    p-=vec2(0.105,0.043);\n    d2 = sdSegment(p*Rot(radians(-52.0)),0.15,0.001);\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.x = abs(p.x);\n    p.x -= 0.105;\n    p.y += 0.042;\n    d2 = sdSegment(p,0.085,0.001);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat Background2(vec2 p) {\n    float t = iTime *0.3;\n    float thickness = BORDER;\n    float r = 0.05;\n    vec2 prevP = p;\n\n    p.x+= 0.215;\n    p.y+= 0.18;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n\n    p*=Rot(radians(30.0*t*3.0));\n    \n    float d = length(p-vec2(0.0,r*0.5))-r;\n    float d2 =  length(p-vec2(0.0,-r*0.5))-r;\n    \n    d = min(abs(d)-thickness,abs(d2)-thickness);\n    \n    p*=Rot(radians(90.0));\n    d2 = length(p-vec2(0.0,r*0.5))-r;\n    d = min(d,abs(d2)-thickness);\n    d2 =  length(p-vec2(0.0,-r*0.5))-r;\n    d = min(d,abs(d2)-thickness);\n    \n    p = prevP;\n    \n    p.x+= 0.215;\n    p.y+= 0.18;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n    p*=Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.083);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.045,0.03);    \n    d = min(d,abs(d2)-thickness*1.2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec3 col = vec3(0.99,0.98,0.95);\n    \n    vec3 lineCol = vec3(132.0/255.0,153.0/255.0,141.0/255.0);\n    \n    uv.y+=iTime*0.1;\n    uv*=1.3;\n    float d = Background(uv);\n    col = mix(col,lineCol,S(d,0.0));//0.9,0.6,0.5\n    \n    d = Background2(uv);\n    col = mix(col,lineCol,S(d,0.0));\n    \n    uv = prevUV;\n    uv*=1.17;\n    \n    d = VesicaShapeBackground(uv);\n    col = mix(col,vec3(245.0/255.0,253.0/255.0,163.0/255.0)*1.45,S(d,-0.06));\n    \n    uv = prevUV;\n    uv*=1.25;\n    d = VesicaShapeDistance(uv);\n    col = mix(col,vec3(140.0/255.0,152.0/255.0,171.0/255.0),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wttyR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WttyWH", "name": "Simple Graph Viewer", "author": "jolle", "description": "Simple Graph Viewer\n\nChange function and viewport at top of shader.\n\nDefault function fakes oscilloscope.", "tags": ["2d", "oscilloscope", "math", "graph"], "likes": 7, "viewed": 96, "date": "1608987819", "time_retrieved": "2024-06-20T20:27:49.269850", "image_code": "\nfloat f(float x)\n{\n    return dot(cos(x * vec3(1.0, 2.0, 4.0) + iTime), vec3(1.0));\n}\n\nvec2 viewportMin = vec2(-7.0, -4.0);\nvec2 viewportMax = vec2(7.0, 4.0);\n\nvec3 backgroundColor = vec3(1.0);\nvec3 gridColor = vec3(0.95);\nvec3 axisColor = vec3(0.5);\nvec3 graphColor = vec3(0.0);\n\nfloat sq(vec2 x)\n{\n    return dot(x, x);\n}\n\nvec2 getClosestPointOnGraph(vec2 p, float x0, float x1)\n{\n    // Bin search (not Newton–Raphson because requires proper gradient)\n    for (int n = 0; n < 4; n++)\n    {\n        float d0 = sq(p - vec2(x0, f(x0)));\n        float d1 = sq(p - vec2(x1, f(x1)));\n        float mid = (x0 + x1) * 0.5;\n        if (d0 < d1)\n            x1 = mid;\n        else\n            x0 = mid;\n    }\n    // Get closest point on line for result\n    vec2 p0 = vec2(x0, f(x0));\n    vec2 p1 = vec2(x1, f(x1));\n    vec2 v = normalize(p1 - p0);\n    return p0 + v * dot(p - p0, v);\n}\n\nbool isClosestToZero(float x, float d)\n{\n    return abs(x) < abs(x - d) && abs(x) < abs(x + d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixelSize = (viewportMax - viewportMin) / iResolution.xy;\n    vec2 position = (fragCoord - 0.5) * pixelSize + viewportMin;\n\n    // Background\n    vec3 color = backgroundColor;\n\n    // Grid\n    vec2 gd = 1.0 - abs(0.5 - fract(position)) * 2.0;\n    if (isClosestToZero(gd.x, pixelSize.x * 2.0) ||\n        isClosestToZero(gd.y, pixelSize.y * 2.0))\n        color = gridColor;\n\n    // Axis notches\n    if (abs(position.y) < pixelSize.y * 2.5 && isClosestToZero(gd.x, pixelSize.x * 2.0) ||\n        abs(position.x) < pixelSize.x * 2.5 && isClosestToZero(gd.y, pixelSize.y * 2.0))\n        color = axisColor;\n\n    // Axis\n    if (isClosestToZero(position.x, pixelSize.x) || \n        isClosestToZero(position.y, pixelSize.y))\n        color = axisColor;\n\n    // Graph\n    vec2 p = getClosestPointOnGraph(position, position.x - pixelSize.x, position.x + pixelSize.x);\n    float d = length((p - position) / pixelSize);\n    color = mix(color, graphColor, max(0.0, 1.0 - d));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WttyWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wttyzN", "name": "sine sum derivative", "author": "Shellderr", "description": "non-successful processing patch recreation", "tags": ["sine", "derivative"], "likes": 0, "viewed": 25, "date": "1608618342", "time_retrieved": "2024-06-20T20:27:49.275760", "image_code": "\n#define PI 3.14159265\n\nvec2 b(float t, vec2 v){\n   return abs(fract(t*v)-.5)*2.;\n}\n\nfloat ff(float n, float n2, float n3, float amp){\n return ((sin(n)+1.)*(sin(n2)*(sin(n3))+1.)+log(((sin(PI+n)+1.)*(sin(PI+n2)+1.))+1.))*amp; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float a = 20.;\n    float amp = 0.5;\n    float d = 1.;\n    \n    float time = iTime*0.05;\n\n    float n = a*(time+distance(uv, b(time,vec2(3.1,1.7))));\n    float n2 = a*(time+distance(uv, b(time,vec2(2.4,3.15))));\n    float n3 = a*(time+distance(uv, b(time,vec2(1.45,2.65))));\n    \n    float f = ff(n, n2, n3, amp);\n    float f2 = ff(n+d, n2+d, n3+d, amp);\n    \n    n = a*(time+distance(uv, b(time,vec2(1.5,3.7))));\n    n2 = a*(time+distance(uv, b(time,vec2(3.4,1.15))));\n    n3 = a*(time+distance(uv, b(time,vec2(2.45,1.65))));\n    \n    f += ff(n, n2, n3, amp);\n    f2 += ff(n+d, n2+d, n3+d, amp);\n    \n    float v = (f2-f)/d;\n\n    fragColor = vec4(vec3(v, 0., v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wttyzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
