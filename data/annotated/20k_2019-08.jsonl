{"id": "3l2SRh", "name": "Transmissions", "author": "Nocks_on", "description": "This is my first shader program as an art.\nI really enjoy it!", "tags": ["raymarching"], "likes": 5, "viewed": 140, "published": "Public", "date": "1565025549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define eps 0.0001\n\nfloat sdBox(vec3 pos, vec3 size) {\n  vec3 d = abs(pos) - size;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdCircle(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat distFunc(vec3 pos) {\n  float T = 5.0;\n  float interval = 1.0;\n  float cube_size = 0.18;\n  float frame = 0.025;\n  float sphere_size = 0.1;\n  vec3 fold = pos;\n  float ret, d;\n  \n  //frame cube\n  fold = mod(fold, interval) - interval/2.0;\n  d = sdBox(fold, vec3(cube_size-0.01));\n  ret = d;\n  d = sdBox(fold, vec3(cube_size, cube_size-frame, cube_size-frame));\n  ret = max(ret, -d);\n  d = sdBox(fold, vec3(cube_size-frame, cube_size, cube_size-frame));\n  ret = max(ret, -d);\n  d = sdBox(fold, vec3(cube_size-frame, cube_size-frame, cube_size));\n  ret = max(ret, -d);\n  \n  //sphere\n  float t = mod(iTime + floor(pos.y/interval) + 0.5*floor(pos.z/interval), T) - T/2.0;\n  fold = pos;\n  fold.y = mod(fold.y, interval);\n  fold.z = mod(fold.z, interval) - interval/2.0;\n  d = sdCircle(fold - vec3(interval/2.0, interval/2.0, 0.0)  - vec3(sign(t)*pow(t, 3.), 0.0, 0.0), sphere_size);\n  ret = min(ret, d);\n  \n  return ret;\n}\n\nvec3 getNormal(vec3 pos) {\n  return normalize(vec3(\n      distFunc(vec3(pos.x+eps, pos.y, pos.z)) - distFunc(pos),\n      distFunc(vec3(pos.x, pos.y+eps, pos.z)) - distFunc(pos),\n      distFunc(vec3(pos.x, pos.y, pos.z+eps)) - distFunc(pos)\n    ));\n}\n\nmat2 rotateMat(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec3 transform(vec3 v) {\n  vec3 ret = v;\n  ret.xz *= rotateMat(PI/2.0);\n  ret.yz *= rotateMat(iTime/5.0);\n  return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float d, b;\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  vec3 transformed, normal;\n  \n  vec3 cameraPos = vec3(0.0, 0.0, 1.0);\n  vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n  \n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec3 cur = transform(cameraPos) + vec3(0.0, 0.0, iTime/2.0);\n  vec3 ray = normalize(transform(vec3(uv, 0.0) - cameraPos));\n  \n  for (float i = 0.; i < 64.; i+=1.0) {        \n    d = distFunc(cur);\n    if (d < eps) {\n      normal = getNormal(cur);\n      b = pow(1.0 - i/70.0, 2.0);\n      vec3 m = abs(mod(cur, 5.0) - 2.5)/2.0;\n      col = clamp(b, 0., 0.95)*m;\n      break;\n    }\n    cur += d * ray;\n  }\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2SRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 74, 74, 170], [172, 172, 205, 205, 231], [233, 233, 259, 259, 1153], [1155, 1155, 1181, 1181, 1404], [1406, 1406, 1435, 1435, 1501], [1503, 1503, 1527, 1527, 1624], [1626, 1626, 1683, 1683, 2352]]}
{"id": "3l2SzR", "name": "Vignette function", "author": "ttyy", "description": "vignette", "tags": ["vignette"], "likes": 2, "viewed": 120, "published": "Public", "date": "1564799526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VIGNETTE 0.3\n#define ASPECT 1.\n// gamma only affects vignette\n#define GAMMA 1.8\n\n\nvec3 vignette( in vec3 col, in vec2 uv, in float aspect, in float amt, in float gamma )\n{\n    uv = uv * 2. - 1.;\t// [0:1] -> [-1:1]\n    uv.y *= aspect;\t\t// apply aspect correction (if not 1.)\n    float rf = sqrt(dot(uv, uv)) * amt;\n    float rf2_1 = rf * rf + 1.0;\n    float v = 1.0 / (rf2_1 * rf2_1);\n    col *= pow(v, gamma);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = mix(vec3(1.), texture(iChannel0, uv).rgb, 1.-(cos(iTime * (3.1415/8.)) * .5 + .5));\n\n    col = vignette(col, uv, ASPECT, VIGNETTE, GAMMA);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2SzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 90, 179, 179, 435], [437, 437, 494, 544, 805]]}
{"id": "3l2XRG", "name": "rain bow test", "author": "raineye", "description": "rain bow test", "tags": ["rainbowtest"], "likes": 0, "viewed": 83, "published": "Public", "date": "1566266248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = 2. * uv - 1.;\n    st.y = st.y + 0.4;\n    float angle = atan(st.y, st.x);\n    float cosv = cos(angle + PI);\n    vec3 col = vec3(0.);\n    float r =  smoothstep(-0.2, 0., length(st) - 1.2) - smoothstep(0., 0.2, length(st) - 1.2) ;\n    \n     float r1 = length(st);\n\n      col = hsb2rgb(vec3(r1 * -3.5 + 0.55, 1., 0.9)) * step(0., angle);\n\n    \n\n   // Output to screen\n    fragColor = vec4(col ,1.0) * r * abs(sin(iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2XRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 45, 45, 277], [280, 280, 337, 387, 861]]}
{"id": "3l2XRW", "name": "Cauliflower Cheese", "author": "mewo2", "description": "Let's play with fractal raymarching!", "tags": ["raymarch", "sdf"], "likes": 6, "viewed": 141, "published": "Public", "date": "1565221939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat hash(float x) {\n    return mod(x*324327. * sin(x*423254.), 1.0);\n}\n\nfloat smax(float x, float y) {\n    return log(exp(x*10.) + exp(y*10.))/10.;\n}\n\nfloat smin(float x, float y) {\n    return -smax(-x, -y);\n}\n\nfloat box(vec3 p, vec3 s) {\n\tvec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nvec3 eyepos() {\n    return vec3(4. * cos(iTime * .3), 5. * sin(iTime * .26), 3. * sin(iTime * .11));\n}\n\nfloat sdf(vec3 p) {\n    float eyeball = length(p - eyepos()) - .1;\n    float d0 = 1.;\n    float s = 1.;\n    float m = 1.35 + .2 * sin(iTime * 0.29);\n    for (int i = 0; i < 6; i++) {\n        p.xy = rot(iTime * .23) * p.xy;\n        p.y = -abs(p.y);\n        p += vec3(.3, 1.+sin(iTime * 0.27), cos(iTime * .29));\n        p.yz = rot(iTime * .07) * p.yz;\n        p.x = -abs(p.x - .4) + .9;\n        p *= m;\n        s *= m;\n        float d = min(box(p, vec3(0.5)), box(p - vec3(0.5), vec3(0.5)));\n        d0 = smin(d/s, d0);\n    }\n    return smax(d0, -eyeball);\n}\n\nvec3 normal(vec3 p) {\n\tfloat h = 0.001;\n    vec3 a1 = vec3(1., 1., 1.);\n    vec3 a2 = vec3(1., -1., -1.);\n    vec3 a3 = vec3(-1., 1., -1.);\n    vec3 a4 = vec3(-1., -1., 1.);\n    return normalize(a1 * sdf(p + h * a1) + a2 * sdf(p + h * a2) + a3 * sdf(p + h * a3) + a4 * sdf(p + h * a4));\n}\n\nvec3 sky(vec3 r) {\n    return vec3(.5, .2, .2) + r.y * vec3(-.5 * r.y, -.1 * r.y, .1);\n}\nvec3 march(vec3 start, vec3 r) {\n            vec3 c = vec3(1.);\n\tfloat t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 p = start + t * r;\n        float d = min(sdf(p), .5);\n        c -= vec3(.01);\n\n        if (d < 0.001) {\n            vec3 n = normal(p);\n\t\t\tfloat ao = exp(sdf(p + n/5.) + sdf(p + n/4.)+ sdf(p + n/3.));\n            return mix( c * (vec3(.5 + .2 * dot(n, normalize(eyepos() - p)),.6,.9 + .5 * n.y) + .0 * n) * ao , sky(r),t/(vec3(5., 3., 1.)+t));\n        }\n        t += d;\n    }\n    return sky(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    vec3 eye = eyepos();\n    vec3 look = vec3(0.);\n    vec3 fwd = normalize(look - eye);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = normalize(cross(fwd, up));\n    up = normalize(cross(right, fwd));\n    vec3 r = normalize(uv.x * right + uv.y * up + fwd);\n    float vignette = 1. - length(uv)/3.;\n    vec3 c = march(eye, r) * vignette;\n    float w = (c.r + c.g + c.b) / 3.+ .1 * hash(uv.x+hash(uv.y)+hash(iTime*.1));\n    fragColor = vec4(c * w / (.1 + w), 1.0) * vignette;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2XRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 118, 118, 169], [171, 171, 201, 201, 248], [250, 250, 280, 280, 308], [310, 310, 337, 337, 429], [431, 431, 446, 446, 533], [535, 535, 554, 554, 1092], [1094, 1094, 1115, 1115, 1382], [1384, 1384, 1402, 1402, 1472], [1473, 1473, 1505, 1505, 1997], [1999, 1999, 2056, 2056, 2599]]}
{"id": "3l2XRz", "name": "playing with geomtry", "author": "xigh", "description": "Playing with circle, ", "tags": ["2d", "circle"], "likes": 2, "viewed": 66, "published": "Public", "date": "1564828601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p,float a) \n{\n\treturn cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nconst float pi = 3.1415;\nconst float tau = pi * 2.0;\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand2(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(float(r)/256.0, float(g)/256.0, float(b)/256.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    vec3 col1 = 2.0*rgb(52, 20, 5);\n    vec3 col2 = 2.0*rgb(3, 3, 50);\n    // vec3 col3 = 2.0*rgb(1, 1, 24);\n\n    uv = rotate(uv, -iTime*.3);\n    \n    float radius = .5;\n    float size = 0.06;\n    \n    float angle = atan(uv.y, uv.x);\n    \n    // angle += rand2(uv);\n    float disp = sin(angle*sin(iTime/3.0)*16.0+3.0*pi/2.0);\n    float disp2 = sin(angle*sin(iTime/10.0)*15.0+3.0*pi/2.0);\n    float disp3 = sin(iTime+angle*5.0+2.0*pi/2.0);\n    \n    // col2 *= disp; // debug\n\n    float dist = length(uv) + disp / 48.0;\n    \n    float sigma = abs(dist-radius) + smoothstep(size+.47, size+0.99, dist*1.1) * 1.2 * disp2 * disp3;\n    \n    float tor = smoothstep(size, size+0.01, sigma);\n    vec3 col = mix(col2, col1, tor);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2XRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 72], [128, 197, 218, 218, 287], [289, 289, 320, 320, 387], [389, 389, 445, 445, 1306]]}
{"id": "3l2XWV", "name": "Swirl Segments", "author": "Passion", "description": "Having a little fun...", "tags": ["2d", "rings", "segments"], "likes": 19, "viewed": 236, "published": "Public", "date": "1567144720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Timothy Michael Walsh */\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n        vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec3 effect(vec2 uv, float zoomSpeed, float ringCount, float size, float rotationSpeed){\n    float spacing = 1.3;\n    vec2 id = floor(uv/spacing-.5); //*spacing;\n    float rrr = random(id.yy);\n    rrr *= rrr<.5 ? 1. : -1.;\n    uv.x+=rrr*iTime*1.5;\n    \n    id = floor(uv/spacing-.5);\n    uv = (fract(uv/spacing-.5)-.5)*spacing;\n    \n    float r = random(id);\n    float rr = random(id);\n\n    uv*=r2(rr*rotationSpeed*iTime+(sin(iTime*r)*3.*r));\n    float s = length(uv)-size; //*(sin(iTime*zoomSpeed)*.5);\n    \n    float f = smoothstep(s-.005, s, .2935);\n    f -= smoothstep(s,s + 0.005, .27);\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(r+rr+iTime+uv.xyx+vec3(r*f,3.-rr+r,r+1.)-iTime*2.);\n\n    float a = atan(uv.x,uv.y);\n    //f = f * step(a, sin(iTime-a*18.0)+cos(3.*iTime+a*18.0));\n    f = f * smoothstep(f,  cos(a*(ringCount+(sin(iTime*2.*r)*8.*rotationSpeed*r))*sin(r+iTime)+cos(-iTime*11.75*rotationSpeed*rr)) +1., .02);   //+cos(iTime-s*10.)\n   \n    return col*f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=2.25;\n    uv*=r2(sin(iTime/2.));\n    uv *= 1.0 + dot(uv,uv)*.5;\n    uv.x+=sin(iTime/5.)*13.;\n    uv.y+=sin(iTime/5.5)*11.;\n    \n    vec3 col = effect(uv, 4., 11., .125, .75);\n    col += effect(uv, 2.5, 8., .2, 1.);\n    col += effect(uv, 1.5, 6., .25, 0.5);\n    col += effect(uv, 0.5, 7., .34, 0.35);\n    col += effect(uv, 0.25, 5., .081, 0.865);\n    col += effect(uv, 0.25, 5., .03, 01.1865);\n    \n    \n    //f = f * step(f,sin(a*12.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2XWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 45, 45, 121], [123, 123, 147, 147, 228], [230, 230, 318, 318, 1217], [1219, 1219, 1276, 1326, 1888]]}
{"id": "3l2XzW", "name": "Hmm?", "author": "warlokkz", "description": "hmm", "tags": ["blackandwhite"], "likes": 2, "viewed": 69, "published": "Public", "date": "1565239822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    vec2 uv;\n    vec2 p;\n    vec2 r = iResolution.xy;\n    \n    for (int i = 0; i < 3; i++) {\n        uv = fragCoord/r;\n        p = uv;\n\n        uv -= 0.5;\n        \n        p.y -= 5. * sin(iTime * 0.15);\n        p.x -= 5. * cos(iTime * 0.15);\n        \n        uv.y += sin(iTime) * 0.15;\n        uv.x += cos(iTime) * 0.15;\n        \n        col[i] += p.x / (uv.x * 0.01);\n        col[i] += p.y / (uv.y * 0.01);\n        \n        col[i] += cos(p.x / uv.x) / 0.001;\n        col[i] += sin(p.y / uv.y) / 0.001;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2XzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 638]]}
{"id": "3lBSDW", "name": "Visualiser Experiments", "author": "bombshell93", "description": "babies first visualiser, thought I'd give it a go", "tags": ["visualizer", "dancing"], "likes": 1, "viewed": 308, "published": "Public", "date": "1565826830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\ttoggle whether within screen or square region\n#define CLAMP_RANGE 0\n\n//\tsample scale modifier\n#define SAMPLE_SCALE 1.\n\n//\tshape of the visualizer\n//\t\t0 - line\n//\t\t1 - waveform\n#define VISUALIZER_SHAPE 0\n\nvoid mainImage( out vec4 t_out_colour, in vec2 t_coord )\n{\n    // normalize\n    vec2 uv = (t_coord - iResolution.xy * .5) / (iResolution.y * .5);\n    \n    // output colour, is purty\n    vec3 c = vec3(sin(uv.x + iTime) * .5 + .5, cos(uv.y + iTime * .5) * .5 + .5, sin(iTime * .33));\n    c = max(c, vec3(.2, .2, .2));\n    \n#if CLAMP_RANGE\n    // coord within box\n    float cd = texture(iChannel0, vec2((uv.x / SAMPLE_SCALE) * .5 + .5, 0.)).r;\n    \n    // clamp range\n    cd *= step(abs(uv.x), 1.);\n#else\n    // coord within screen\n    float cd = texture(iChannel0, vec2(((t_coord.x / SAMPLE_SCALE) / iResolution.x), 0.)).r;\n#endif\n    \n    // scale amplitude\n    cd *= .4;\n    \n#if VISUALIZER_SHAPE == 1\n    // distance from coord\n    float d = distance(abs(uv.y), cd * cd * 8. + 4. / iResolution.y);\n    \n    // colour mod\n    c*= smoothstep(abs(uv.y), abs(uv.y) + 4. / iResolution.y, d);\n#else \n    // colour mod\n    c*= smoothstep(0., distance(uv.y, cd), 1. / iResolution.y);\n#endif\n\n    // output\n    t_out_colour = vec4(c, 1.);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 208, 266, 283, 1240]]}
{"id": "3lBSRc", "name": "A E S T H E T I C", "author": "clevijoki", "description": "Going off on a ray traced reflection tangent while following the iq shader deconstruction video.", "tags": ["raymarching", "sdf", "reflections"], "likes": 7, "viewed": 181, "published": "Public", "date": "1566760704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float MAT_SKY = 1.0;\nconst float MAT_FLOOR = 2.0;\nconst float MAT_WHITE = 3.0;\nconst float MAT_RED = 4.0;\nconst float MAT_GREEN = 5.0;\nconst float MAT_BLUE = 6.0;\nconst float MAT_COLUMN = 7.0;\n\nvec2 PixelCoords(in vec2 fragCoord) {\n    \n    return (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n}\n\nfloat Noise( in vec2 f ) {\n    \n    vec2 p = floor(f);\n    f = fract(f);\n    f = f*f*(3.0-2.0*f);\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\n    return res;\n}\n\n\nvec3 CreateRayDir(in vec3 ray_origin, in vec3 look_at, in vec2 pixel) {\n    \n    vec3 z = normalize(look_at - ray_origin);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    return normalize(pixel.x*x + pixel.y*y + 1.5*z);\n}\n\nvec3 ApplyGamma(in vec3 col) {\n\treturn pow(col, vec3(0.4545));\n}\n\nvec2 MapSphere(in vec3 sample_pos, in vec3 pos, in float radius, in float material, in vec2 res) {\n\n    float d = length(sample_pos - pos)-radius;\n    if (d < res.x)\n        return vec2(d, material);\n    \n    return res;\n}\n\nvec2 MapColumn(in vec3 sample_pos, in vec3 pos, in float radius, in float height, in float material, in vec2 res) {\n    \n    float col_y = clamp(sample_pos.y, pos.y, pos.y+height);\n        \n    float spiral_speed = 60.0;\n\n    float d = length((sample_pos - vec3(pos.x, col_y, pos.z))*vec3(1.0,10.0,1.0))-radius;\n    \n    if (d < res.x)\n        return vec2(d, material);\n    \n    return res;\n}\n\nvec2 MapScene(in vec3 pos) {\n    \n    const float DEG_TO_RAD = 3.14159/180.0;\n    const vec3 ORBIT_A = normalize(vec3(sin(DEG_TO_RAD*  0.0), 2.5, cos(DEG_TO_RAD*  0.0)));\n    const vec3 ORBIT_B = normalize(vec3(sin(DEG_TO_RAD*120.0), 2.5, cos(DEG_TO_RAD*120.0)));\n    const vec3 ORBIT_C = normalize(vec3(sin(DEG_TO_RAD*240.0), 2.5, cos(DEG_TO_RAD*240.0)));\n    \n\tconst float ORBIT_DIST = 0.52;\n    const float ORBIT_SPEED = 0.6;\n    \n    float time_a = (iTime + 3.14159*1.0) * ORBIT_SPEED;\n    float time_b = (iTime + 3.14159*2.0) * ORBIT_SPEED;\n    float time_c = (iTime + 3.14159*3.0) * ORBIT_SPEED;\n    \n    float plane_d = pos.y + 0.25;\n//    float tile_d = 0.2*clamp(sin(pos.x*10.0)*sin(pos.z*10.0)*3.0+0.05, 0.01, 0.2);    \n//    plane_d -= max(0.0, tile_d) * 0.1;\n    vec2 res = vec2(plane_d, MAT_FLOOR);\n    \n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1 + sin(iTime)*0.05, 0.0),\n        0.25,\n        MAT_WHITE,\n        res);\n    \n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1, 0.0) + \n        \tORBIT_A.yzx * ORBIT_DIST * sin(time_a) +\n        \tORBIT_A.zxy * ORBIT_DIST * cos(time_a),\n        0.1,\n        MAT_RED,\n        res);\n\n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1, 0.0) +\n        \tORBIT_B.yzx * ORBIT_DIST * sin(time_b) +\n        \tORBIT_B.zxy * ORBIT_DIST * cos(time_b),\n        0.1,\n        MAT_GREEN,\n        res);\n        \n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1, 0.0) +\n        \tORBIT_C.yzx * ORBIT_DIST * sin(time_c) +\n        \tORBIT_C.zxy * ORBIT_DIST * cos(time_c),\n        0.1,\n        MAT_BLUE,\n        res);\n    \n    res = MapColumn(\n        vec3(mod(pos.x*0.5, 1.0)-0.5, pos.y, mod(pos.z, 1.0)-0.5),\n        vec3(\n            0.0,\n            -0.4,\n            0.0\n        ),\n        0.04,\n        1.0,\n        MAT_COLUMN,\n        res);    \n       \n    return res;\n}\n\nvec3 CalcNormal(in vec3 pos) {\n\t\n    vec2 e = vec2(0.0001, 0.0);\n    \n    return normalize(\n        vec3(\n\t        MapScene(pos+e.xyy).x-MapScene(pos-e.xyy).x,\n   \t    \tMapScene(pos+e.yxy).x-MapScene(pos-e.yxy).x,\n    \t    MapScene(pos+e.yyx).x-MapScene(pos-e.yyx).x\n    \t)\n   \t);\n}\n\nvec2 CastRay(in vec3 ray_origin, vec3 ray_dir) {\n\n    vec2 res = vec2(0.0, -1.0);\n    float t = 0.0;\n    \n    for (int i = 0; i < 400; ++i) {\n        \n        vec3 pos = ray_origin + t * ray_dir;\n        \n        vec2 h = MapScene(pos);\n        \n        if (h.x < 0.001)\n            return vec2(t, h.y);\n        \n        t += h.x;\n        \n        if (t>20.0)\n            return vec2(-1.0, MAT_SKY);\n    }\n        \n    return vec2(t, MAT_SKY);\n}\n\nfloat CalcCloud(in vec3 ray_origin, vec3 ray_dir) {\n    if (ray_dir.y < 0.01)\n        return 0.0;\n    \n    vec3 cloud_pos = ray_origin + ray_dir * ((10.0-ray_origin.y)/ray_dir.y);\n    cloud_pos.xz += vec2(iTime*2.0);\n    float cloud_color = 0.0;\n\n    cloud_color += Noise((cloud_pos.xz+vec2(iTime*2.0))*0.1) * 0.2;\n    cloud_color += mix(-1.0, 1.0, Noise((cloud_pos.xz+vec2(iTime*3.3)-ray_dir.xz*2.0)*0.2)) * 0.1;\n    cloud_color += mix(-1.0, 1.0, Noise((cloud_pos.xz+vec2(iTime*3.0)+ray_dir.xz*3.0)*0.4)) * 0.05;\n    cloud_color += mix(-1.0, 1.0, Noise((cloud_pos.xz+vec2(iTime*2.5)+ray_dir.xz*4.0)*0.6)) * 0.025;\n\n    return smoothstep(max(0.0, cloud_color), 0.0, 0.1);\n}\n\nfloat CastSoftShadow(in vec3 ray_origin, vec3 ray_dir) {\n    \n    float res = max(0.1, 1.0-CalcCloud(ray_origin, ray_dir)*1.2);\n    \n    float t = 0.02;\n    float tmax = 12.0;\n    \n    for (int i = 0; i < 25; ++i) {\n        \n        vec3 pos = ray_origin + t * ray_dir;\n        \n        float h = MapScene(pos).x;\n        res = min(res, max(0.0, 16.0 * h/t));\n        t += clamp(h, 0.05, 0.4);\n        \n        if (res < 0.005 || t>tmax)\n            break;\n    }\n\n    return res;\n}\n\nfloat RaymarchPixel(in vec3 ray_origin, in vec3 ray_dir, out vec3 hit_pos, out vec3 color, out vec3 normal) {\n\n    vec3 fog_color = vec3(1.0);\n\n    vec2 hit = CastRay(ray_origin, ray_dir);\n    \n    if (hit.x > 0.0) {\n        \n        hit_pos = ray_origin + hit.x * ray_dir;\n        normal = CalcNormal(hit_pos);\n                \n        vec3 sun_dir = normalize(vec3(0.8,0.4,0.2));\n        float sun_dif = clamp(dot(normal, sun_dir), 0.0, 1.0);\n        float sun_sha = CastSoftShadow(hit_pos + normal*0.001, sun_dir);\n        float sky_dif = 0.5 + 0.5 * normal.y;\n        float bounce_dif = 0.4 + normal.y * -0.5;\n        \n        vec3 light = vec3(0.0);\n        \n        light += vec3(10.0, 6.0, 3.0) * sun_dif*sun_sha;\n        light += vec3(0.5, 0.8, 0.9) * sky_dif;\n        light += vec3(0.7, 0.3, 0.2) * bounce_dif;\n        \n        vec3 material = vec3(0.2);\n        float reflection = 0.45;\n        \n        if (hit.y == MAT_FLOOR) {\n\t        material = vec3(0.2*clamp(sin(hit_pos.x*10.0)*sin(hit_pos.z*10.0)*1.0+0.05, 0.01, 0.2));\n            reflection = 0.05;\n        }\n        else if (hit.y == MAT_COLUMN) {\n            material = vec3(0.25);\n            reflection = 0.0;\n        }\n        else if (hit.y == MAT_WHITE) {\n            material = vec3(0.18);\n        }\n        else if (hit.y == MAT_RED) {\n            material = vec3(0.2, 0.01, 0.04);\n        }\n        else if (hit.y == MAT_GREEN) {\n            material = vec3(0.01, 0.2, 0.04);\n        }\n        else if (hit.y == MAT_BLUE) {\n            material = vec3(0.01, 0.04, 0.2);\n        }\n        \n        color = material * light;\n        // distance fog\n        color = mix(color, fog_color, clamp(hit.x*hit.x*0.01, 0.0, 1.0));\n        \n        return reflection;\n        \n    } else {\n        \n        color = vec3(0.4, 0.75, 1.0) - 0.7*ray_dir.y;\n\n        color += CalcCloud(ray_origin, ray_dir);\n        \n        color = mix(color, fog_color, clamp(exp(-8.0*ray_dir.y), 0.0, 1.0));\n\n        hit_pos = normal = vec3(0.0);\n        \n        return 0.0;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = PixelCoords(fragCoord);\n    \n    float an = 10.*iMouse.x/iResolution.x;\n    an += iTime * -0.09;\n    \n    vec3 ray_origin = vec3(sin(an), 0.1, cos(an));\n    vec3 look_at = vec3(0.0, 0.1, 0.0);\n\n    vec3 ray_dir = CreateRayDir(ray_origin, look_at, p);\n    \n    vec3 color = vec3(1.0);\n    float hit_strength = 1.0;\n    \n    for (int n = 0; n < 3; ++n) {\n        vec3 hit_pos, hit_color, hit_normal;\n        \n        float reflect_amount = RaymarchPixel(\n            ray_origin,\n            ray_dir,\n            hit_pos,\n            hit_color,\n            hit_normal\n        );\n\n        color = mix(color, hit_color, hit_strength);\n        hit_strength *= reflect_amount;\n\n        if (hit_strength > 0.001) {\n            ray_origin = hit_pos + hit_normal * 0.001;\n\t        ray_dir = reflect(ray_dir, hit_normal);            \n        }\n        else {\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(ApplyGamma(color),1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 238, 238, 306], [308, 308, 334, 334, 485], [488, 488, 559, 559, 758], [760, 760, 790, 790, 824], [826, 826, 924, 924, 1048], [1050, 1050, 1165, 1165, 1442], [1444, 1444, 1472, 1472, 3288], [3290, 3290, 3320, 3320, 3572], [3574, 3574, 3622, 3622, 4019], [4021, 4021, 4072, 4072, 4694], [4696, 4696, 4752, 4752, 5177], [5179, 5179, 5288, 5288, 7212], [7214, 7214, 7269, 7324, 8292]]}
{"id": "3lBSRm", "name": "Cupcakes", "author": "dr2", "description": "More tasty desserts", "tags": ["raymarch", "repetition", "chocolate", "food", "dessert"], "likes": 4, "viewed": 283, "published": "Public API", "date": "1565335314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Cupcakes\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 ltDir, flPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize, twDir, cCol;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a, rad, ht, s;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p.y -= 1.;\n    r = length (p.xz);\n    a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n    rad = 1.;\n    ht = 0.5;\n    q = p;\n    q.y -= - ht;\n    s = rad * (1. + 0.2 * q.y / ht + 0.03 * sin (32. * 2. * pi * a));\n    d = PrCylAnDf (q.xzy, s, 0.01, ht);\n    DMIN (1);\n    q.y -= ht + 0.05 - 0.15 * r * r;\n    d = PrCylDf (q.xzy, s, 0.05);\n    DMIN (2);\n    rad = 0.3;\n    ht = 1.;\n    q = p;\n    q.y -= ht;\n    d = SmoothMin (PrCylDf (q.xzy, rad * (1. + 0.2 * sin (2. * pi * (2. * q.y / ht +\n       twDir * a))) * (1. - 0.95 * q.y / ht), ht), d, 0.05);\n    DMIN (3);\n    dMin *= 0.5;\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 fRand;\n  float emFrac;\n  emFrac = 0.1;\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  isOcc = (fRand.y >= emFrac);\n  if (isOcc) {\n    fRand.y = (fRand.y - emFrac) / (1. - emFrac);\n    twDir = (fRand.y < 0.5) ? -1. : 1.;\n    cCol = fRand.x;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, sh, s;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (1., 1., 0.9, 0.);\n      vf = vec2 (64., 0.5);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.4, 0.2, 0., 0.2);\n      vf = vec2 (16., 0.1);\n    } else if (idObj == 3) {\n      if (cCol < 0.8) {\n        cCol /= 0.8;\n        col4 = vec4 (HsvToRgb (vec3 (floor (8. * cCol) / 8., 0.3, 1.)), 0.1);\n      } else {\n        col4 = vec4 (vec3 ((cCol > 0.9) ? 0.1 : 1.2), 0.2);\n      }\n      vf = vec2 (32., 0.5);\n    }\n    vn = VaryNf (vf.x * ro, vn, vf.y);\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = vec4 (mix (vec3 (0.7, 0.7, 0.65), vec3 (0.8, 0.8, 0.85),\n       smoothstep (0.45, 0.55, Fbm2 (2. * ro.xz))), 0.3);\n    if (dstObj < dstFar) {\n      gId = PixToHex (ro.xz / hgSize);\n      SetGrObjConf ();\n      if (isOcc) col4.rgb *= 0.7 + 0.3 * smoothstep (0.8, 1.,\n         length (ro.xz - HexToPix (gId * hgSize)));\n    }\n  } else {\n    col = vec3 (0.6, 0.6, 0.6);\n  }\n  if (dstObj < dstFar) {\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return t * vec3 (0.1, 0., sqrt (0.99)) + vec3 (2. * cos (0.1 * t), 0., 0.);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\n#define AA  1 \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 2.;\n  VuPM (0.9 * tCur);\n  az = 0.;\n  el = -0.08 * pi;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  flPos.y += 8.;\n  ro = flPos;\n  zmFac = 6. + 2. * sin (0.02 * 2. * pi * tCur);\n  dstFar = 50.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    rd = rd * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBSRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 675, 697, 697, 1421], [1423, 1423, 1445, 1445, 1706], [1708, 1708, 1741, 1741, 2844], [2846, 2846, 2867, 2867, 3057], [3059, 3059, 3096, 3096, 3522], [3524, 3524, 3559, 3559, 4948], [4950, 4950, 4976, 4976, 5056], [5058, 5058, 5079, 5079, 5677], [5695, 5695, 5751, 5751, 6920], [6922, 6922, 6964, 6964, 7015], [7017, 7017, 7070, 7070, 7131], [7133, 7133, 7157, 7157, 7387], [7389, 7389, 7413, 7413, 7473], [7475, 7475, 7497, 7497, 7535], [7537, 7537, 7582, 7582, 7685], [7687, 7687, 7717, 7717, 7830], [7832, 7832, 7856, 7856, 7973], [8007, 8007, 8031, 8031, 8161], [8163, 8163, 8188, 8188, 8374], [8376, 8376, 8397, 8397, 8552], [8554, 8554, 8583, 8583, 8795], [8797, 8797, 8836, 8836, 9016]]}
{"id": "3lBSzy", "name": "Raytracer testing", "author": "vizaxo", "description": "Simple raytracer", "tags": ["raytracer"], "likes": 0, "viewed": 45, "published": "Public", "date": "1566232675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Converts a color from linear light gamma to sRGB gamma\n// from https://gamedev.stackexchange.com/a/148088\nvec4 fromLinear(vec4 linearRGB)\n{\n    bvec4 cutoff = lessThan(linearRGB, vec4(0.0031308));\n    vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = linearRGB * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n// Converts a color from sRGB gamma to linear light gamma\nvec4 toLinear(vec4 sRGB)\n{\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nstruct material {\n    vec4 color;\n    bool light;\n    float reflectivity;\n};\n    \nconst float tau = 6.28318;\n    \nmaterial blue = material(vec4(.1, .2, .9, 1.), false, .2);\nmaterial mirror = material(vec4(1., 1., 1., 1.), false, 1.);\nmaterial redLight = material(vec4(4., .0, 0., 1.), true, 0.1);\nmaterial ground = material(vec4(.4, .3, .1, 1.), false, 0.0);\n                         \nstruct hit {\n    float dist;\n    material mat;\n    vec3 hitNorm;\n};\n\nconst float epsilon = 0.001;\n\nfloat minNZ(float a, float b) {\n    if (a < 0.)\n        return b;\n    if (b < 0.)\n        return a;\n    return min(a, b);\n}\n\nhit minHit(hit a, hit b) {\n    if (a.dist < 0.)\n        return b;\n    if (b.dist < 0.)\n        return a;\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\nhit intersectPlane(vec3 rd, vec3 ro, vec3 n, float d, material mat) {\n    float denom = dot(n, rd);\n    if (denom == 0.) return hit(-1., mat, n);\n    float t = -((dot(n, ro) + d) / denom);\n    return hit(t > epsilon ? t : -1., mat, n);   \n}\n\nhit intersectSphere(vec3 rd, vec3 roWorld, vec3 centre, float radius, material mat) {\n    vec3 ro = roWorld - centre;\n    float b = 2. * dot(rd, ro);\n    float c = dot(ro, ro) - (radius * radius);\n    \n    float root = sqrt(b*b - 4.*c);\n    \n    float t1 = (-b + root) / 2.;\n    float t2 = (-b - root) / 2.;\n    float t = minNZ(t1, t2);\n    vec3 hitNorm = normalize(ro + rd*t);\n\treturn hit(t > epsilon ? t : -1., mat, hitNorm);\n}\n\nhit intersect(vec3 rd, vec3 ro) {\n    material whiteLight = material(vec4(vec3((sin(iTime*2.)+1.) * 2. + 0.2), 1.), true, 0.);\n    \n    return minHit(minHit(\n        minHit(minHit(intersectPlane(rd, ro, normalize(vec3(0, 1, 0)), 0., ground),\n               intersectSphere(rd, ro, vec3(3, 1, 10), 3., whiteLight)),\n               intersectSphere(rd, ro, vec3(7.*sin(iTime) + 3., .5, 7.*cos(iTime) + 10.), 2., blue)),\n               intersectSphere(rd, ro, vec3(-10., 4, 10.), 4., redLight)),\n               intersectSphere(rd, ro, vec3(-7.*sin(iTime) + 3., .5, -7.*cos(iTime) + 10.), 2., mirror));\n\n\n}\n\n\nvec3 ray(int n, vec3 ro, vec3 rd) {\n    if (n <= 0)\n        return vec3(0);\n}\n\n//from https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat getRand( float f ) {\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n        \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\n\nvec3 sampleSphere(float seed) {\n    float u1 = getRand(seed);\n    float u2 = getRand(seed+1.);\n    float r = sqrt(1. - u1*u1);\n    float phi = tau * u2;\n    return vec3(cos(phi) * r, sin(phi) * r, 2. * u1);\n}\n\nvec3 sampleHemisphere(vec3 normal, float seed) {\n    vec3 v = sampleSphere(seed*2.);\n    if (dot(normal, v) < 0.)\n        return -v;\n    else\n        return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - .5) * vec2(1, iResolution.y / iResolution.x);\n\n    vec3 camPos = vec3(0, 3, -10);\n    vec3 lookAt = vec3(0, 2.9, -9);\n\n    \n    vec3 skyCol = vec3(.05, .05, .06);\n    vec3 col = vec3(0.);\n    int maxBounces = 3;\n    int rpp = 500;\n    for(int rays = 0; rays<rpp; rays++) {\n        vec3 filmPos = lookAt + vec3(uv, 0) + 0.005*vec3(getRand(float(rays)));\n    \tvec3 rd = normalize(filmPos - camPos);\n    \tvec3 ro = filmPos;\n\n        vec3 rayCol = vec3(1. / float(rpp));\n        int bounces = 0;\n        for(; bounces<maxBounces; bounces++) {\n            hit h = intersect(rd, ro);\n            if (h.dist > epsilon) {\n                vec3 hitPos = ro + h.dist*rd;\n                vec3 perfectReflect = reflect(rd, h.hitNorm);\n                float seed = getRand(getRand(fragCoord.x * iResolution.x + fragCoord.y) + float(rays)) + float(bounces);\n                vec3 randReflect = sampleHemisphere(h.hitNorm, seed);\n                rd = normalize(mix(randReflect, perfectReflect, h.mat.reflectivity));\n                ro = hitPos;\n                rayCol *= h.mat.color.rgb;\n                if (h.mat.light) {\n                    break;\n                }\n            } else {\n                rayCol *= skyCol;\n                break;\n            }\n        }\n        if (bounces == maxBounces)\n            rayCol = vec3(0);\n    \n        col += rayCol;\n    }\n\n    fragColor = fromLinear(vec4(col,1.0));\n    //fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 110, 143, 143, 359], [360, 418, 444, 444, 639], [1125, 1125, 1156, 1156, 1248], [1250, 1250, 1276, 1276, 1426], [1428, 1428, 1497, 1497, 1668], [1670, 1670, 1755, 1755, 2099], [2101, 2101, 2134, 2134, 2702], [2705, 2705, 2740, 2740, 2782], [2784, 2875, 2896, 2896, 3027], [3028, 3028, 3054, 3054, 3294], [3297, 3297, 3328, 3328, 3505], [3507, 3507, 3555, 3555, 3668], [3671, 3671, 3728, 3728, 5234]]}
{"id": "3lBXDD", "name": "Wave and sun", "author": "GreenChicken", "description": "Tryed Distance to nearest surface (src : fabrice Castel) and hur shift for rainbow (src : reedwirrax)", "tags": ["raymarch", "rainbow", "repeat"], "likes": 2, "viewed": 337, "published": "Public API", "date": "1565853258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// COLORS\n// src : nvidia\nfloat saturate(float x)\n{\n    return max(0.0, min(1.0, x));\n}\n\n\nvec3 saturate(vec3 v)\n{\n    return vec3(\n        max(0.0, min(1.0, v.x)),\n        max(0.0, min(1.0, v.y)),\n        max(0.0, min(1.0, v.z))\n        );\n}\n\n// src reefwirrax\nvec3 Hue(float h)\n{\n    float r = abs(h*6.0-3.0)-1.0;\n    float g = 2.0 - abs(h*6.0-2.0);\n    float b = 2.0 - abs(h*6.0-4.0);\n    return saturate(vec3(r,g,b));\n}\n\nvec3 HSVtoRGB(vec3 hsv)\n{\n    return vec3(((Hue(hsv.x) - 1.0) * hsv.y + 1.0) * hsv.z);\n}\n\n// world\n// src : Fabrice Castel\nfloat DistanceToNearestSurface(vec3 p)\n{\n    float t;\n    p.y += sin(p.z * 0.25 + iTime * 5. + sin(p.x + iTime * 10.));\n    \n    vec3 q = vec3(mod(p.x, 3.0) - 1.5, p.y, mod(p.z, 3.0) - 1.5);\n    float s = 1.0;\n    vec3 d = abs(q) - vec3(s);\n    \n    t = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    \n    return t;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t;\n    float anim = fract(iTime);\n    \n    for(int i=0; i<128 ; i++)\n    {\n        float res = 0.0;\n        vec3 march = rayOrigin + rayDir * t;\n        res = DistanceToNearestSurface(march);\n        \n        if(res < (0.0001*t))\n        {\n            return t;\n        }\n        t += res;\n    }\n    \n    return -1.0;\n}\n\nvec2 NormalizeScreen(vec2 st)\n{\n    vec2 uv = (2.0 * st/iResolution.xy - 1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nvec3 render(vec2 uv, vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col;\n    float t = castRay(rayOrigin, rayDir);\n    float ao = pow(1.-t * 0.005, 1.);\n    vec3 rainbow = vec3(HSVtoRGB(vec3(fract(ao+iTime*.5), 1.0, 1.0)));\n    \n    if(t == -1.0)\n    {\n        vec2 st = uv;\n        float angle = fract(atan(st.x, st.y)*5.);\n        float sun = smoothstep(.3, .31, length(st));\n        sun += step(.8, fract(st.y*10.-.3));\n        \n        float at = angle+iTime;\n        vec3 yolo = rainbow * (smoothstep(.1, .3, fract(at))-smoothstep(.3, .5, fract(at)));\n        \n        col = mix(\n            vec3(max(mix(vec3(.0), yolo, smoothstep(.29, .30, length(st))), mix(rainbow, vec3(.0), sun))), // \n            vec3(.0),\n            vec3(step(0.03, rayDir.y))\n            );\n    }\n    else\n    {\n        col = rainbow;\n    }\n    \n    return col;\n}\n\nvec3 CameraViewDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 viewDir;\n    vec3 forward = normalize(camTarget - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    float fPersp = 4.0;\n    \n    viewDir = normalize(uv.x * right + uv.y * up + fPersp * forward);\n    \n    return viewDir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(.5);\n    float offsetTime = iTime+1000.;\n    vec3 camPos = vec3(sin(offsetTime)*5., -5., offsetTime);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    \n    vec2 uv = NormalizeScreen(fragCoord);\n    vec3 viewDir = CameraViewDir(uv, camPos, camTarget);\n    \n    col = vec3(length(uv)-.5);\n    \n    col = render(uv, camPos, viewDir);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 51, 51, 87], [90, 90, 113, 113, 241], [243, 261, 280, 280, 422], [424, 424, 449, 449, 512], [514, 547, 587, 587, 878], [880, 880, 924, 924, 1254], [1256, 1256, 1287, 1287, 1392], [1394, 1394, 1445, 1445, 2231], [2233, 2233, 2291, 2291, 2598], [2600, 2600, 2655, 2655, 3042]]}
{"id": "3lBXDw", "name": "LiveCodingPractice003(45min)", "author": "Hirai_worthless", "description": "bubble", "tags": ["raymarching"], "likes": 3, "viewed": 104, "published": "Public", "date": "1565993780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nfloat rand(float p){\n\treturn sin(p) * 3. + cos(p) / 2. + sin(p/2.) * 2.;\n}\nvec2 pmod(vec2 p, float c){\n    p *= genRot(PI/c);\n    float r = length(p);\n\tfloat at = atan(p.y/p.x);\n    at = mod(at , PI * 2./c);\n    p = vec2(cos(at) * r,sin(at) * r);\n    p *= genRot(-PI/c);\n    return p;\n}\nfloat map(vec3 p){\n    float rc = 0.25 + abs(floor(rand(p.x + iTime/4.) * 5.) + floor(rand(p.y + iTime/4.) * 5.) + floor(rand(p.z + iTime/4.) * 5.)) * 0.015;\n    float sp = length(p - vec3(0.,0.,iTime)) - rc * 2.;\n    p.z = (fract(p.z/2. + 0.5)-0.5 ) * 2.;\n        p.xy = pmod(p.xy,4.);\n        p.x -= 4.;\n    p.xy = pmod(p.xy,8.);\n    float r = 0.25 + abs(floor(rand(p.x + iTime) * 5.) + floor(rand(p.y + iTime) * 5.) + floor(rand(p.z + iTime) * 5.)) * 0.015;\n\tfloat sps = length(p - vec3(3.,0.,0.)) - r;\n    return min(sp,sps);\n}\n\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n\tvec4 res;\n    float t = 0.;\n    for(int i = 0; i < 64; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 n = getNormal(o + r * t);\n    return vec4(n,t);\n\n}\nvec3 cam(){\n\tvec3 c = vec3(2. * sin(iTime),2. * -cos(iTime),-2.5 + iTime);\n    return c;\n}\nvec3 ray(vec2 uv,float z) {\n\tvec3 r = normalize(vec3(uv,z));\n    r.yz *= genRot(-PI/4.);\n    r.xz *= genRot(-PI/4.);\n    r.xy *= genRot(iTime);\n    return r;\n}\nvec3 getCol(vec3 o,vec3 r,vec4 data){\n\tfloat t = data.w;\n    vec3 n = data.xyz;\n    vec3 bc = vec3(1. - dot(n,r));\n    vec3 p = o + r * t;\n    vec3 ccol;\n    float at = atan(p.y / p.x) * 2.;\n    ccol.x = sin(at + iTime + p.z) / 2. + 0.5;\n    ccol.y = sin(at + iTime + p.z + PI * 2. /3.) / 2. + 0.5;\n    ccol.z = sin(at + iTime + p.z + PI * 4. / 3.) / 2. + 0.5;\n    bc *= ccol;\n    float fog = 1./(1. + t * t * 0.015);\n    vec3 col = mix(bc,vec3(0.),1. - fog);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    vec3 o = cam();\n    vec3 r = ray(uv,1.5 * sin(iTime));\n    vec4 data = trace(o,r);\n    vec3 col = getCol(o,r,data);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 90], [91, 91, 111, 111, 165], [166, 166, 193, 193, 377], [378, 378, 396, 396, 909], [911, 911, 934, 934, 1011], [1013, 1013, 1039, 1039, 1240], [1241, 1241, 1252, 1252, 1331], [1332, 1332, 1359, 1359, 1491], [1492, 1492, 1529, 1529, 1969], [1970, 1970, 2027, 2077, 2296]]}
{"id": "3lBXRw", "name": "Juggle", "author": "mewo2", "description": "Cubes in a cave", "tags": ["fractal", "raymarch", "sdf"], "likes": 7, "viewed": 421, "published": "Public", "date": "1565307692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\nfloat hash(float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5 + 0.5*(b - a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 uni(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nvec3 eye() {\n    vec3 p = vec3(-.2,.3,2.5);\n    p.yz = rot(.05 * cos(iTime/17.)) * p.yz;\n    p.xy = rot(.1 * sin(iTime/8.)) * p.xy;\n    return p;\n}\n\nvec3 look() {\n    return vec3(.2 * cos(iTime/3.9)+.5,.2 * sin(iTime/2.7) -.4,.1 * sin(iTime/11.2));\n}\n\nfloat sph(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat box(vec3 p, vec3 c, vec3 r) {\n    vec3 d = abs(p - c) - r;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat menger(vec3 p) {\n   float d = -1000.;\n\n   float s = 1.0;\n   for( int m=0; m<3; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n\n   return d;\n}\n        \nfloat torus(vec3 p, vec3 c, float r1, float r2) {\n    vec3 v = p - c;\n    return length(vec2(length(v.xy) - r1, v.z)) - r2;\n}\nvec2 sdf(vec3 p) {\n    float ships = 1000.;\n    for (int i = 0; i < 3; i++) {\n        float angle = 2.*float(i)*PI/3. + iTime/1.3;\n        vec3 q = p - vec3(.2*cos(angle), .2*sin(angle), 1.5);\n        q.yz = rot(iTime + angle) * q.yz;\n        q.xy = rot(iTime/3.2) * q.xy;\n        float shipsize = .1;\n        float ship = max(box(q, vec3(0., 0., 0.), vec3(shipsize )), menger(q/shipsize)*shipsize);\n        ships = min(ships, ship);\n    }\n    float z = p.z - iTime;\n\tp.x += cos(z)* .2;\n   \tfloat d =  1. - length(p.xy);\n    p.xy = rot(z + sin(z) + iTime/5. + sin(iTime/4.)/6.) * p.xy;\n    float s = 1.;\n    z /= 2.;\n    for (int i = 0; i < 7; i++) {\n        p *= 1.9;\n        s *= 1.9;\n        z *= 2.57;\n        d += (sin(z/4.1) + cos(z/.4)) * sin(p.x+cos(p.y)) * .3/s;\n    }\n    return uni(vec2(d, 0.), vec2(ships, 1.));\n}\n\nvec3 march(vec3 start, vec3 ray) {\n    float t = 0.0;\n    vec3 c = vec3(1., 0.5, 0.);\n    for (int i = 0; i < 99; i++) {\n        vec3 p = start + t * ray;\n        vec2 d = sdf(p);\n        if (d.y == 0.) {\n            c += vec3(0.05, d.x/20., d.x*sqrt(sqrt(t))/10.);\n        } else {\n            c += vec3(.0, .03, 0.05);\n        }\n        t += d.x * .6;\n        if (d.x/t < 0.001) {\n            if (d.y == 1.) c -= vec3(1., 0., 0.);\n            return c;\n        }\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.)/iResolution.y;\n\t\n    vec3 e = eye();\n    vec3 l = look();\n    vec3 fwd = normalize(l - e);\n    vec3 right = normalize(cross(fwd, vec3(0.,1.,0.)));\n    vec3 up = cross(right, fwd);\n    \n    vec3 ray = normalize(uv.x * right + uv.y * up + fwd);\n    \n    float vignette = 1. - length(uv);\n    float noise = hash(uv.x + hash(uv.y + hash(iTime)));\n    vec3 c = vignette * march(e, ray) + noise * .05;\n\tfloat w = c.r + c.g + c.b;\n    \n    // Output to screen\n    fragColor = vec4(c * (w/(5. + w)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 152], [154, 154, 173, 173, 239], [240, 240, 279, 279, 376], [378, 378, 404, 404, 449], [451, 451, 463, 463, 598], [600, 600, 613, 613, 701], [703, 703, 739, 739, 771], [773, 773, 808, 808, 906], [908, 908, 930, 930, 1273], [1283, 1283, 1332, 1332, 1408], [1409, 1409, 1427, 1427, 2234], [2236, 2236, 2270, 2270, 2722], [2724, 2724, 2781, 2781, 3328]]}
{"id": "3lBXWc", "name": "equilateral triangle grid noise", "author": "lomateron", "description": ".", "tags": ["noise", "grid", "triangle", "equilateral"], "likes": 4, "viewed": 352, "published": "Public API", "date": "1567246949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hex(vec2 u)\n{\n    vec3 a = u*mat3x2(0.           ,1. ,\n                       .86602540378, .5,\n                       .86602540378,-.5);\n    return max(1.-dot(abs(a),vec3(.57735026919)),0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 8.*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y+iTime;\n    \n    vec2 s = vec2(2.,1.73205080757);\n    vec2 a0 = (u+s*vec2(.0 ,.0))/s;\n    vec2 a1 = (u+s*vec2(.5 ,.0))/s;\n    vec2 a2 = (u+s*vec2(.25,.5))/s;\n    vec2 a3 = (u+s*vec2(.75,.5))/s;\n    vec2 a0f = fract(a0)*s-s*.5;\n    vec2 a1f = fract(a1)*s-s*.5;\n    vec2 a2f = fract(a2)*s-s*.5;\n    vec2 a3f = fract(a3)*s-s*.5;\n    float a0n = fract(sin(dot(floor(a0)+.0,vec2(37.341,97.784)))*47925.950837);\n    float a1n = fract(sin(dot(floor(a1)+.1,vec2(37.341,97.784)))*47925.950837);\n    float a2n = fract(sin(dot(floor(a2)+.2,vec2(37.341,97.784)))*47925.950837);\n    float a3n = fract(sin(dot(floor(a3)+.3,vec2(37.341,97.784)))*47925.950837);\n    fragColor = vec4(hex(a0f)*a0n+\n                     hex(a1f)*a1n+\n                     hex(a2f)*a2n+\n                     hex(a3f)*a3n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 199], [200, 200, 257, 257, 1109]]}
{"id": "3lfSWn", "name": "raymarched mandelbulb test", "author": "dagbrynildsentholander", "description": "bandelbulb test", "tags": ["mandelbulb"], "likes": 1, "viewed": 284, "published": "Public API", "date": "1565558239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lightDir = vec3(1,.5,.2);\nvec3 lightColor = vec3(1., .9, .9)*1.5;\nvec3 ambientLight = vec3(0.1);\n\nfloat mandelbulb(vec3 pos) \n{\n    int Iterations = 16;\n    float Bailout = 20.;\n    float Power = 4.;\n\tvec3 z = pos;\n\tfloat dr = 2.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>Bailout) \n            break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos*2.+(sin(iTime/10.)/10.+0.04);\n\t\t\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat map(vec3 p)\n{\n    return mandelbulb(p);\n\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.001;\n    vec3 x = vec3 (delta, 0.00, 0.00);\n\tvec3 y = vec3 (0.00, delta, 0.00);\n\tvec3 z = vec3 (0.00, 0.00, delta);\n    \n    float val = map(p);\n    vec3 grad = vec3(val - map(p - x), val - map(p - y), val - map(p - z));\n    return normalize(grad);\n}\n\nvec3 fog(vec3 rgb, vec3 cp, vec3 p, vec3 rd)\n{\n    vec3 fogCol = vec3(1.-lightColor)*.2;\n    fogCol += lightColor*clamp(rd.y, -.1, .1)/5.;\n    fogCol += lightColor*clamp(dot(normalize(rd), normalize(lightDir)), -1.0, 1.0)/10.;\n    return mix(rgb, fogCol, clamp(distance(cp, p)/10., 0., 1.));\n}\n\nvec4 march(vec3 p, vec3 rd, float stepcount)\n{\n    float t = 0.;\n    \n    for(float i = 0.; i < stepcount; i++)\n    {\n        float dist = map(p+rd*t);\n        if(dist < .003)\n            return vec4((p+rd*t).xyz, i);\n        else\n            t+=dist;\n    }\n    \n     return vec4((p+rd*t).xyz, stepcount);\n}\n\nvec3 lighting(vec3 p, vec3 n)\n{\n    float shadow = clamp(distance(march(p+n*.01, lightDir, 128.).xyz, p)/5., 0., 1.);\n    return  max(dot(normalize(lightDir), n), 0.0) * lightColor * (shadow) +ambientLight;\n}\n\nvec3 shade(vec4 p)\n{\n    vec3 n = normal(p.xyz);\n    vec3 baseCol = abs(p.xyz)*n;\n    vec3 color=baseCol*lighting(p.xyz,n);\n    color = mix(color, ambientLight*.5, clamp(p.w/128., 0.0, 1.0));\n\n    return color;\n}\n\nconst int KEY_UP = 38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    \n\tvec3 rrot = vec3(iMouse.y/iResolution.y*360.+180., -iMouse.x/iResolution.x*360.+180., 0);\n    vec3 rp = vec3(sin(radians(rrot.y)), sin(radians(rrot.x)), cos(radians(rrot.y)))*4.0;\n    \t\n    vec3 lookdir = normalize(-rp);\n    vec3 lookDirLeft = cross(lookdir, vec3(0, 1., 0));\n    vec3 lookDirUp = cross(lookDirLeft, lookdir);\n    vec3 rd = normalize(lookdir+lookDirLeft*uv.x+lookDirUp*uv.y);\n\n    vec4 marchResult = march(rp, rd, 256.);\n    vec3 col = fog(vec3(1.), rp, rp+rd*100., rd);\n    \n    if(marchResult.w<256.)\n    {    \n        col = shade(marchResult.xyzw); \n    }\n    else\n        col = fog(col, rp, marchResult.xyz, rd);\t\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 132, 132, 786], [789, 789, 808, 808, 837], [839, 839, 860, 860, 1128], [1130, 1130, 1176, 1176, 1423], [1425, 1425, 1471, 1471, 1732], [1734, 1734, 1765, 1765, 1942], [1944, 1944, 1964, 1964, 2156], [2182, 2182, 2239, 2294, 3051]]}
{"id": "3ljSDV", "name": "Reflective Polyhedra", "author": "dr2", "description": "Partially reflective varying polyhedra (mouseable)", "tags": ["optics", "fresnel", "reflect", "polyhedron"], "likes": 15, "viewed": 349, "published": "Public API", "date": "1567149819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Reflective Polyhedra\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Partially reflective varying polyhedra (mouseable).\n\n// Polyhedra based on knighty's \"Polyhedron again\" (https://www.shadertoy.com/view/XlX3zB)\n\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, vc, pMid, vp[3];\nfloat tCur, dstFar;\nint idObj, pType;\nbool showFace;\nconst int idFace = 1, idEdge = 2, idSph = 3;\nconst float pi = 3.14159, phi = 1.618034;\n\nvoid PInit ()\n{\n  vec3 c;\n  float cp, sp, t;\n  t = 0.02 * tCur;\n  pType = int (mod (t, 3.)) + 3;\n  c = 0.5 * (1. + sin (vec3 (1., 2., 4.) * 4. * pi * t));\n  cp = cos (pi / float (pType));\n  sp = sqrt (0.75 - cp * cp);\n  vc = vec3 (-0.5, - cp, sp);\n  vp[0] = vec3 (0., 0., 1.);\n  vp[1] = vec3 (sp, 0., 0.5);\n  vp[2] = vec3 (0., sp, cp);\n  pMid = (length (c) > 0.) ? normalize ((c.x * vp[0] + c.y * vp[1] + c.z * vp[2])) : vec3 (0.);\n  vp[1] = normalize (vp[1]);\n  vp[2] = normalize (vp[2]);\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, dv;\n  float dMin, d;\n  dMin = dstFar;\n  if (! showFace) {\n    d = PrSphDf (p, 0.25);\n    DMIN (idSph);\n  }\n  for (int k = 0; k < 5; k ++) {\n    p.xy = abs (p.xy);\n    p -= 2. * min (0., dot (p, vc)) * vc;\n    if (k == pType - 1) break;\n  }\n  q = p - pMid;\n  if (showFace) {\n    dv = vec3 (dot (q, vp[0]), dot (q, vp[1]), dot (q, vp[2]));\n    d = Maxv3 (dv);\n    DMIN (idFace);\n  }\n  dv = vec3 (length (q - min (0., q.x) * vec3 (1., 0., 0.)), \n     length (q - min (0., q.y) * vec3 (0., 1., 0.)),\n     length (q - min (0., dot (q, vc)) * vc));\n  d = Minv3 (dv) - 0.01;\n  DMIN (idEdge);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, aMin, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n      aMin = a;\n    }\n  }\n  return vec4 (aMin, vfMin);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 c;\n  vec2 f;\n  f = mod (64. * vec2 (atan (rd.z, - rd.x), asin (rd.y)) / pi, 1.);\n  c = 0.5 * mix (vec3 (0.2, 0.3, 0.6), vec3 (0.7, 0.7, 0.4),\n     max (SmoothBump (0.47, 0.53, 0.01, f.x), SmoothBump (0.47, 0.53, 0.01, f.y))) *\n     (0.7 + 0.3 * rd.y);\n  c = max (c, 0.5 * vec3 (1., 1., 0.) * (1. - smoothstep (0.01, 0.015,\n     length (SphFib (rd, 2048.).yzw - rd))));\n  return c;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, nDotL;\n  showFace = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    vn = ObjNf (ro + dstObj * rd);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == idEdge) {\n      nDotL *= nDotL;\n      nDotL *= nDotL;\n      col = vec3 (0.5, 0.3, 0.1);\n    } else if (idObj == idSph) {\n      col = vec3 (0.5, 0.7, 0.7);\n    }\n    col = col * (0.2 + 0.8 * nDotL) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = BgCol (rd);\n  showFace = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    vn = ObjNf (ro + dstObj * rd);\n    if (idObj == idFace) {\n      col = mix (col * vec3 (0.5, 1., 0.5), BgCol (reflect (rd, vn)),\n         1. - pow (max (- dot (rd, vn), 0.), 5.));\n    } else if (idObj == idEdge) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      nDotL *= nDotL;\n      col = vec3 (0.5, 0.3, 0.1) * (0.2 + 0.8 * nDotL * nDotL) +\n         0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n  } else col = BgCol (rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -8.);\n  zmFac = 6.5;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  PInit ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljSDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[184, 611, 626, 626, 1102], [1163, 1163, 1185, 1185, 1797], [1799, 1799, 1832, 1832, 2007], [2009, 2009, 2030, 2030, 2227], [2229, 2229, 2260, 2317, 3151], [3153, 3153, 3175, 3175, 3565], [3567, 3567, 3602, 3602, 4669], [4686, 4686, 4742, 4742, 5963], [5965, 5965, 5998, 5998, 6025], [6027, 6027, 6084, 6084, 6167], [6169, 6169, 6191, 6191, 6229], [6231, 6231, 6253, 6253, 6291], [6293, 6293, 6323, 6323, 6436]]}
{"id": "3ljSRh", "name": "the army of sponge", "author": "poipoi34", "description": "blah", "tags": ["curvemarch"], "likes": 4, "viewed": 96, "published": "Public", "date": "1565024696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dBox(vec3 p,vec3 size)\n{\n    return length(max(vec3(0.,0.,0.),abs(p)-size/2.));\n}\nfloat dSphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\nfloat dScene(vec3 p)\n{\n    p = mod(p+10.,20.)-10.;\n    return dBox(p,vec3(2.,1.,1.)*2.0)/2.;\n}\nvec3 crossProduct (vec3 p1,vec3 p2)\n{\n    return vec3(p1.y*p2.z-p1.z*p2.y,p1.z*p2.x-p1.x*p2.z,p1.x*p2.y-p1.y*p2.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n\n    vec3 ro = vec3(0.+sin(iTime)*1.,3.+sin(iTime)*0.,-10.+iTime*20.+sin(iTime)*0.);\n    vec3 rd = normalize(vec3(uv,1.0));\n    vec3 rdNx = normalize(vec3(1.,1.,(-rd.x-rd.y)/rd.z));\n    vec3 rdNy = normalize (crossProduct(rd,rdNx));\n    vec3 rp = ro;\n    float k = 0.;\n    int it = 0;\n    \n    float d = dScene(ro);\n    while (d>0.01 && it <100)\n    {\n        k += d;\n        rp = ro + k*rd + cos(k*0.5)*rdNx + cos(k*0.5)*rdNy;\n        d = dScene(rp);\n        it++;\n    }\n    \n    vec3 col = fract(rp);\n    \n\tif (it==100)\n        col = vec3(0.6,0.7,0.8);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 87], [88, 88, 119, 119, 145], [146, 146, 168, 168, 240], [241, 241, 278, 278, 358], [361, 361, 418, 469, 1132]]}
{"id": "3ljXRc", "name": "RepeatedRaymarching", "author": "Fogrex", "description": "raymarching test", "tags": ["raymarching"], "likes": 1, "viewed": 79, "published": "Public", "date": "1566642501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int STEP = 64;\nfloat NEAR = 2.0;\n\n\n//transform function(inverse)\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 move)\n{\n    return transform(pos, move, vec3(0.0,0.0,0.0));\n}\n\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    return transform(pos, vec3(0.0,0.0,0.0), rot);\n}\n\n// distance functions\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// mixing shapes\nfloat nsUnion(float d1, float d2) {return min(d1, d2);}\n\nfloat nsSubtraction(float d1, float d2) {return max(-d1, d2);}\nfloat nsIntersection(float d1, float d2) {return max(d1, d2);}\nfloat sUnion(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\nfloat sSubtraction(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\nfloat sIntersection(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n\n//mapping\nfloat map(vec3 pos)\n{\n    vec3 m = vec3(10.0, 10.0, 10.0);\n    pos = mod(pos, m) - m/2.0;\n    float s1 = sphere(pos, 1.2);\n    float b1 = box(pos, vec3(1.0,1.0,1.0));\n    float bss = nsSubtraction(s1,b1);\n    float r = 0.3;\n    float k = 2.0;\n    float d = 1.5;\n    vec3 rot = vec3(iTime*0.57, iTime*0.73, iTime*1.12);\n    for(float i=-1.0;i<=1.0;i+=2.0)\n    {\n        for(float j=-1.0;j<=1.0;j+=2.0)\n        {\n            for(float l=-1.0;l<=1.0;l+=2.0)\n            {\n                bss = sUnion(bss, sphere(translate(rotate(pos, rot),vec3(d*i,d*j,d*l)),r),k);\n            }\n        }\n    }\n    return bss;\n    \n}\n\n// calculating normal\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    float center = map(pos);\n    vec3 grad = vec3(map(pos+vec3(d,0.0,0.0))-center, map(pos+vec3(0.0,d,0.0))-center, map(pos+vec3(0.0,0.0,d))-center);\n    return normalize(grad / d);\n}\n\n// lambert model\nvec4 lambert(vec3 pos, vec3 lightDir)\n{\n    vec3 n = calcNorm(pos);\n    float b = max(0.0, dot(n, -normalize(lightDir)))*0.9+0.1;\n    return vec4(b, b, b, 1.0);\n}\n\nvec4 visualizeNormal(vec3 pos)\n{\n    return vec4(calcNorm(pos),1.0);\n}\n\n// raymarching\nvec4 raymarch(vec2 fc)\n{\n    fc = (fc * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(fc, NEAR) + vec3(0.0,0.0,-5.0);\n    \n    // camera moving\n    float theta = iTime*0.2;\n    ray = transform(ray, vec3(0.0,0.0,0.0), vec3(0.0, -theta, 0.0));\n    pos = transform(pos, vec3(0.0,0.0,0.0), vec3(0.0, -theta, 0.0));\n    \n    float d = 0.0;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d < 0.0001){\n            //return lambert(pos, vec3(1.0,1.0,0.0));\n            return visualizeNormal(pos);\n        }\n        pos = pos + ray * d;\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = raymarch( fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 65, 112, 112, 1062], [1064, 1064, 1101, 1101, 1155], [1157, 1157, 1190, 1190, 1243], [1245, 1267, 1298, 1298, 1326], [1328, 1328, 1360, 1360, 1455], [1457, 1474, 1509, 1509, 1529], [1531, 1531, 1572, 1572, 1593], [1594, 1594, 1636, 1636, 1656], [1657, 1657, 1699, 1699, 1794], [1795, 1795, 1843, 1843, 1939], [1940, 1940, 1989, 1989, 2084], [2087, 2097, 2118, 2118, 2712], [2714, 2736, 2761, 2761, 2967], [2969, 2986, 3025, 3025, 3148], [3150, 3150, 3182, 3182, 3220], [3222, 3237, 3261, 3261, 3910], [3912, 3912, 3969, 3969, 4010]]}
{"id": "3ljXzd", "name": "RefectRepeatedObjects", "author": "Fogrex", "description": "refrecting objects", "tags": ["raymarching"], "likes": 1, "viewed": 49, "published": "Public", "date": "1566827190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n\nconst int STEP = 128;\nconst float REFLECT_LIMIT = 2.0;\nconst float NEAR = 2.0;\nconst float REPEAT_UNIT = 500.0;\nconst vec3 LIGHT_DIR = vec3(0.5,-0.5,0.0);\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 origin;\n    vec4 color;\n    bool frag;\n};\n\n\n//transform function(inverse)\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 move)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m * p).xyz;\n}\n\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n// distance functions\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cylinder(vec3 pos, float r)\n{\n    return length(pos.xz) - r;\n}\n\nfloat plane(vec3 pos, float h)\n{\n    return pos.y - h;\n}\n\n// mixing shapes\nfloat nsUnion(float d1, float d2) {return min(d1, d2);}\n\nfloat nsSubtraction(float d1, float d2) {return max(-d1, d2);}\nfloat nsIntersection(float d1, float d2) {return max(d1, d2);}\nfloat sUnion(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\nfloat sSubtraction(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\nfloat sIntersection(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n\n//mapping\nfloat map(vec3 pos)\n{\n    vec3 m = vec3(8.0);\n    vec3 p = mod(pos, m) - m/2.0;\n    float s1 = sphere(p, 1.2);\n    float b1 = box(p, vec3(1.0,1.0,1.0));\n    float bss = nsSubtraction(s1,b1);\n    float r = 0.3;\n    float k = 2.0;\n    float d = 1.5;\n    vec3 rot = vec3(iTime*0.57, iTime*0.73, iTime*1.12)*0.3;\n    bss = sUnion(bss, sphere(translate(rotate(p, rot),vec3(d,d,d)),r),k);\n    bss = sUnion(bss, sphere(translate(rotate(p, rot),vec3(d,-d,-d)),r),k);\n    bss = sUnion(bss, sphere(translate(rotate(p, rot),vec3(-d,d,-d)),r),k);\n    bss = sUnion(bss, sphere(translate(rotate(p, rot),vec3(-d,-d,d)),r),k);\n    \n    bss = sUnion(bss, plane(pos, -10.0), k);\n    \n    return bss;\n    \n}\n\n// calculating normal\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    float center = map(pos);\n    vec3 grad = vec3(map(pos+vec3(d,0.0,0.0))-center, map(pos+vec3(0.0,d,0.0))-center, map(pos+vec3(0.0,0.0,d))-center);\n    return normalize(grad / d);\n}\n\n// lambert model\nvec4 lambert(vec3 pos)\n{\n    vec3 n = calcNorm(pos);\n    float b = max(0.0, dot(n, -LIGHT_DIR))*0.9+0.1;\n    return vec4(b, b, b, 1.0);\n}\n\nvec4 visualizeNormal(vec3 pos)\n{\n    return vec4(calcNorm(pos),1.0)*0.8 + vec4(1.0,1.0,1.0,1.0)*0.2;\n}\n\n// raymarching\nRay raymarch(Ray r, float refTime)\n{\n    vec3 pos = r.origin;\n    vec3 dir = r.direction;\n    \n    float d = 0.0;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d < 0.00001)\n        {\n            if(refTime == REFLECT_LIMIT - 1.0)\n            {\n                r.frag = true;\n            }else{\n                vec3 n = calcNorm(pos);\n                r.direction = dir - 2.0 * dot(dir, n) * n;\n                r.origin = pos + r.direction * 0.001;\n            }\n            //r.color += vec4(lambert(pos).xyz * pow(0.5, refTime+1.0),0.0);\n            r.color += vec4(visualizeNormal(pos).xyz * pow(0.5, refTime+1.0),0.0);\n            return r;\n        }\n        pos = pos + dir * d;\n    }\n    r.frag = true;\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fc = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(fc, NEAR);\n    \n    //camera rotating\n    float rx = (iMouse.x/iResolution.x*2.0 - 1.0) * PI;\n    float ry = (iMouse.y/iResolution.y*2.0 - 1.0) * PI * 0.5;\n    pos = rotate(pos, vec3(ry,-rx,0.0));\n    ray = rotate(ray, vec3(ry,-rx,0.0));\n    \n    // camera moving\n    pos = translate(pos, vec3(0.0,0.0,5.0));\n    \n    Ray r;\n    r.direction = ray;\n    r.origin = pos;\n    r.color = vec4(0.0,0.0,0.0,1.0);\n    r.frag = false;\n    \n    \n    for(float i=0.0;i<REFLECT_LIMIT;i++)\n    {\n        r = raymarch(r,i);\n        if(r.frag) break;\n    }\n    fragColor = r.color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 324, 371, 371, 1321], [1323, 1323, 1360, 1360, 1620], [1622, 1622, 1655, 1655, 2416], [2418, 2440, 2471, 2471, 2499], [2501, 2501, 2533, 2533, 2628], [2630, 2630, 2665, 2665, 2698], [2700, 2700, 2732, 2732, 2756], [2758, 2775, 2810, 2810, 2830], [2832, 2832, 2873, 2873, 2894], [2895, 2895, 2937, 2937, 2957], [2958, 2958, 3000, 3000, 3095], [3096, 3096, 3144, 3144, 3240], [3241, 3241, 3290, 3290, 3385], [3388, 3398, 3419, 3419, 4086], [4088, 4110, 4135, 4135, 4341], [4343, 4360, 4384, 4384, 4497], [4499, 4499, 4531, 4531, 4601], [4603, 4618, 4654, 4654, 5366], [5368, 5368, 5425, 5425, 6138]]}
{"id": "3lSSDG", "name": "Procedural Creatures 3d", "author": "thiagoborn", "description": "Trying to make my 2d creature generator 3d ( https://www.shadertoy.com/view/tlBSzd ) \nbut my video card is not allowing me to continue :p so here it is in an unfinished state :p", "tags": ["procedural", "sdf", "creature"], "likes": 3, "viewed": 386, "published": "Public API", "date": "1566874108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO\n// fresnel\n// clouds\n// occlusion\n// reflections \n\nstruct hit {\n    float d;\n    int m;\n};\nfloat sdSphere(vec3 pos,float radius){\n    return length(pos)-radius;\n}\nfloat terrain(vec2 pos){\n   return sin(pos.x*1.4)*0.1+sin(pos.x*0.93)*.3 +\n    sin(pos.y*2.3)*0.1+sin(pos.y*1.45)*0.2;\n}\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat srand(float n) {\n    return rand(n)*2.-1.;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nmat4 translate(float x, float y, float z){\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(x,   y,   z,   1.0)\n    );\n}\n\nmat4 RotateX(float phi){\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(phi),-sin(phi),0.),\n        vec4(0.,sin(phi),cos(phi),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 RotateY(float theta){\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 RotateZ(float psi){\n    return mat4(\n        vec4(cos(psi),-sin(psi),0.,0),\n        vec4(sin(psi),cos(psi),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n\nhit map(vec3 pos){\n    hit h;\n    h.m = 1;\n    \n    float d = 10000000.;\n    float i = float(int(iTime/10.)+124);\n    i = rand(i);\n   \n\n    for(int b=0;b<3;b++){\n         mat4 m = mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.)\n    );\n        //m = translate(.0,-1.,.0)*m;\n\t    for(int x=0;x<15;x++){\n            vec3 rot = vec3(\n             srand(i++)*3.1415,\n             srand(i++)*3.1415,\n             srand(i++)*3.1415);\n            float s = (.5+.5*rand(i++))*.14;\n           \n            /*\n            a += smoothstep(-.4,.4,sin(iTime*1.5))* srand(i++)*.2;\n            a += sin(iTime*3.0)* srand(i++)*.05;\n            a += sin(iTime*1.0)* srand(i++)*.04;\n            a += smoothstep(.5,1.,sin(iTime*6.))* srand(i++)*.01;\n            */\n            m = RotateY(rot.y)*m;\n            m = RotateZ(rot.z)*m;\n            m = RotateX(rot.x)*m;\n            m = translate(.0,-s,.0)*m;\n            //m = m*RotateX(1.5);\n\t\t\t\n            float bs = 0.04+rand(i++)*0.02;\n            float ls = 0.02+rand(i++)*0.03;\n            float ma = rand(i++);\n            \n             for(int k=0;k<2;k++){\n                 vec3 pp = k==0?pos:pos*vec3(-1.,1.,1.);\n                vec4 p2 = m*vec4(pp,1.);\n                 \n                //vec4 p2 = vec4(pos,1.);\n                d = smoothMerge(d,sdCappedCylinder(p2.xyz,ls,s),.08);\n               // d = min(d,sdCappedCylinder(p2.xyz,ls,s));\n                  mat4 m2 = translate(.0,-s,.0)*m;\n                 p2 = m2*vec4(pp,1.);\n                d = smoothMerge(d,sdSphere(p2.xyz,bs),.08);\n             }\n             m = translate(.0,-s,.0)*m;\n            \n        }\n    }\n    h.d=d;\n    \n     float f = pos.y+0.0;\n    if(f<h.d){\n       // h.d=f;\n//        h.m=2;\n    }\n    return h;\n}\n    \nhit castRay(vec3 ro ,vec3 rd ){\n   \tint s = 0;\n    float d = 0.0;\n    while(s < 30 && d < 10.0){\n        vec3 p = ro + rd * d;\n        hit h = map(p);\n        float od = abs(h.d);\n        if(od<0.004){\n            h.d = d;\n          \treturn h;\n        }\n        d+=od;\n        s++;\n    }\n    hit h;\n    h.d = d;\n    return h;\n}\nvec3 pixel(vec2 uv){\n    float an = iTime*.5 + .3 + iMouse.x/iResolution.x*3.1415*2.;\n    vec3 ro = vec3(2.*sin(an),0.4,2.*cos(an));\n    //vec3 ta = vec3(iTime,.0,.0);   \n    //vec3 ro = vec3(0.,0.,2.);\n    vec3 ta = vec3(0.,.0,.0);   \n    \n    vec3 fo = normalize(ta-ro);\n    vec3 ri = normalize(cross(fo,vec3(0.0,1.0,0.0)));\n    vec3 up = normalize(cross(ri,fo));\n    \n    vec3 rd = normalize(uv.x*ri + uv.y*up + 1.5*fo);\n    vec3 alb = vec3(.0);\n    hit h = castRay(ro,rd);\n    if(h.m==0) return vec3(0.);\n    return vec3(1./h.d); // dist\n   \n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    //if(iMouse.z<=.0)return;\n    \n    float pix = 1./iResolution.y;\n    vec2 uv = ((i)*2.0-iResolution.xy)/iResolution.y;\n\n    vec2 e = vec2(pix/2.+pix*.2,0.);\n    \n    vec3 c = pixel(uv+e.xy);   \n   // c+=pixel(uv-e.xy);\n   // c+=pixel(uv-e.yx);\n   // c+=pixel(uv-e.yx);\n    //c/=4.0;\n\to = vec4(c,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 99, 137, 137, 170], [171, 171, 195, 195, 291], [292, 292, 331, 331, 418], [419, 419, 467, 467, 568], [570, 570, 591, 591, 635], [637, 637, 659, 659, 687], [688, 688, 740, 740, 847], [850, 850, 892, 892, 1053], [1055, 1055, 1079, 1079, 1231], [1233, 1233, 1259, 1259, 1419], [1421, 1421, 1445, 1445, 1597], [1599, 1599, 1617, 1617, 3391], [3397, 3397, 3428, 3428, 3724], [3725, 3725, 3745, 3745, 4272], [4276, 4276, 4317, 4347, 4625]]}
{"id": "3lSSDR", "name": "breakegg_03rotate_rect", "author": "breakegg", "description": "rotate", "tags": ["rotate"], "likes": 1, "viewed": 77, "published": "Public", "date": "1565518203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(float left,float right, float top, float bottom, vec2 uv){\n    float blur=1./iResolution.y;\n    float c = 1.;\n    c = smoothstep(left-blur,left+blur,uv.x);\n    c *= smoothstep(right+blur,right-blur,uv.x);\n    c *= smoothstep(top-blur,top+blur,uv.y);\n    c *= smoothstep(bottom+blur,bottom-blur,uv.y);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float ang = iTime/2.;\n\t// uv=vec2(cos(ang)*uv.x+(-sin(ang)*uv.y),sin(ang)*uv.x+(cos(ang)*uv.y));\n    // 旋转矩阵\n\tmat2x2 rot = mat2x2(vec2(cos(ang),-sin(ang)),vec2(sin(ang),cos(ang)));\n    uv *= rot;\n    \n    float m = rect(-0.1,0.1,-0.1,0.1,uv);\n    vec3 col = vec3(1.,1.,1.)*m;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 327], [328, 328, 385, 385, 791]]}
{"id": "3lSSzm", "name": "Stars on paper", "author": "Hirai_worthless", "description": "writing with glsl", "tags": ["shader", "writing"], "likes": 1, "viewed": 59, "published": "Public", "date": "1565341841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(float t){\n\treturn 0.5 + 0.5 * (sin(t * 4.) + cos(t * 2.) + sin(t / 2.)) / 3.;\n}\nmat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nvec2 path(float t){\n\tfloat x = (2./3. * cos(t * 40.) + 1./3. * cos(t * 40. * 1.5)) * (0.75 + noise(t) * 0.75)/2.;\n    float y = (2./3. * sin(t * 40.) - 1./3. * sin(t * 40. * 1.5)) * (0.75 + noise(t) * 0.75)/2.;\n    return vec2(x,y);\n}\nfloat dist(vec2 p,float t){\n    p *= 1. * (1.5 + 0.75 * sin(iTime/2.));\n    p *= genRot(sin(iTime/2.) *3. * 3.1415 / 5.);\n    p.y += floor((p.x +  0.75) / 1.5) * 0.75;\n    p += 0.75;\n    p = fract(p / 1.5) * 1.5;\n    p -= 0.75;\n    \n\tfloat result = 1000000.;\n    for(float i = 0.0;i < 1.5; i += 0.0005){\n    \tfloat c = length(p - path(t - i)) - 0.0015 * (2.0 - i) / 2.;\n        result = min(result,c);\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //uv -= vec2(cos(iTime/4.),sin(iTime/4.)) * 2.;\n\tvec3 col = mix(vec3(0.),vec3(1.0),dist(uv,iTime) * 256.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [92, 92, 115, 115, 169], [170, 170, 189, 189, 404], [405, 405, 432, 432, 833], [834, 834, 891, 941, 1197]]}
{"id": "3lSXDG", "name": "Bezier operation", "author": "gaz", "description": "Bezier operation. 2D & 3D", "tags": ["bezier"], "likes": 8, "viewed": 330, "published": "Public", "date": "1566996852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat roundBox(vec2 p, vec2 size, float r){\n   return length(p-clamp(p,-size,size))-r;\n}\n\nfloat roundBox(vec3 p, vec3 size, float r){\n   return length(p-clamp(p,-size,size))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat lengthN(vec2 v, float n){\nvec2 tmp = pow(abs(v), vec2(n));\nreturn pow(tmp.x+tmp.y, 1.0/n);\n} \n\n// https://www.shadertoy.com/view/lssBDM\nvec2 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0)\n    { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec2(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec3 opBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{   \n    b = mix(b + vec2(1e-4), b, abs(sign(b * 2.0 - a - c)));\n    vec2 A = b - a, B = a - b * 2.0 + c, C = A * 2.0, D = a - p;\n    vec3 k = vec3(3.*dot(A,B),2.*dot(A,A)+dot(D,B),dot(D,A)) / dot(B,B);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 dp1 = D + (C + B*t.x)*t.x;\n    vec2 dp2 = D + (C + B*t.y)*t.y;\n    float d1 = dot(dp1, dp1);\n    float d2 = dot(dp2, dp2);\n    vec2 h = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n    vec2 g = normalize(2.*B*h.y + C);\n    p -= mix(mix(a, b, h.y), mix(b, c, h.y), h.y);\n    float y = g.x*p.y-g.y*p.x;\n    float x = sqrt(max(0.0,h.x-y*y))*sign(h.y-0.5);\n    return vec3(x,y,h.y);\n}\n\nvec4 opBezier(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 w = normalize(cross(a-b, b-c));\n\tvec3 v = normalize(cross(w, a-b));\n\tvec3 u = cross(w,v);\n    mat3 m = mat3(u,v,w);\n    a *= m, b *= m, c *= m, p *= m;\n    vec3 bz = opBezier(p.xy,a.xy,b.xy,c.xy);\n    return vec4(p.z,bz.yxz);\n}\n\nfloat map(in vec3 p)\n{   \n    p.xz*=rot(iTime*0.5);\n\tvec3 a=vec3(-2,0,0);\n    vec3 b=vec3(0,2.0+sin(iTime*1.5)*0.8,0);\n    vec3 c=vec3(2,1,sin(iTime*0.8)*2.0);\n\tvec4 bz=opBezier(p,a,b,c);\n    float de;\n    switch(int(mod(iTime*0.3,4.0)))\n    {\n\t\tcase 0:\n        \tde = roundBox(bz.xyz,vec3(0.5,0.5*bz.w+0.2,0.0),0.1);\n        \tbreak;\n        case 1:\n        \tde = sdTorus(bz.xyz,vec2(1.0,0.3));\n        \tbreak;\n        case 2:\n        \tfloat d2=abs(lengthN(bz.xy,3.0)-(.5+sin(bz.w*100.0)*0.02))-.05;\n\t\t\tde = length(max(vec2(d2,abs(bz.z)),0.0))-0.02;\n        \tbreak;\n        default:\n        \tde = length(bz.xyz)-0.5;\n        \tbreak;\n    }\n    return de;\n}\n\nvec3 calcNormal(in vec3 pos){\n  vec2 e = vec2(1.0, -1.0) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tvec3 col=vec3(0.0);\n    vec3 bz =opBezier(uv*2.0,vec2(-2,0),vec2(0,1),vec2(2,-1));    \n    col = mix(col, vec3(0.5, 0.7, 1.0), smoothstep(0.08, 0.0, roundBox(bz.xy,vec2(0.1),0.01)));\n    vec3 ro = vec3(0, 1, 5);\n    vec3 rd = normalize(vec3(uv, -2.0));\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 100; i++)\n  \t{\n    \tt += d = map(ro + rd * t);\n    \tif(d < 0.001) break;\n  \t}\n  \tif(d < 0.001)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 n = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        vec3 bg = col;\n        col = vec3(1.0, 0.8,0.2);\n        float dif = clamp(dot(n, li), 0.3, 1.0);\n        float amb = max(0.5 + 0.5 * n.y, 0.0);\n        float spc = pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 50.0);\n        col *= dif * amb ;\n        col += spc;\n        col = clamp(col,0.0,1.0);\n        col = mix(bg, col, exp(-exp2(length(p - ro))*0.002));\n  \t\tcol = pow(col, vec3(0.6));        \n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 94, 94, 139], [141, 141, 184, 184, 229], [231, 231, 264, 264, 329], [331, 331, 362, 362, 429], [432, 473, 517, 517, 1027], [1029, 1029, 1076, 1076, 1728], [1730, 1730, 1777, 1777, 2011], [2013, 2013, 2035, 2035, 2667], [2669, 2669, 2698, 2698, 2855], [2857, 2857, 2914, 2914, 3910]]}
{"id": "3lsXDl", "name": "Mostly Grey", "author": "peet", "description": "Just a little optical illusion test. 6 RGB spheres mixing.\nUsing IQ's colourspace conversion functions to saturate/desaturate some pixels", "tags": ["raymarching", "optical", "illusion", "grey"], "likes": 4, "viewed": 129, "published": "Public", "date": "1564650111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///////////////////////////////////////////////////////////////////////////////////\n// Trying out some raymarching, and combining it with Schlicks Approximation //////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_EPSILON 0.01\n#define MARCH_ITERATIONS 40\n\n#define SMOOTH_DIST 0.5\n#define MAT_CHANGE 0.1\n\n#define TOO_FAR 10000.0\n\n#define REFLECT_ITERATIONS 2\n#define EPSILON 0.0001\n#define MSAA 3.0\n\n#define NUM_SPHERES 6\n\n#define HURRY_UP 1.5\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material mat;\n};\n    \nstruct Light {\n    vec3 dir;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\n    \n///////////////////////////////////////////////////////////////////////////////////\n        \nSphere g_spheres[NUM_SPHERES];\n\nLight g_light = Light(normalize(vec3(1.0, -1.0, 1.0)), vec3(150.0, 100.0, 50.0));\n\n///////////////////////////////////////////////////////////////////////////////////\n\nconst float eps = 0.0000001;\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + eps)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              // H\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + eps),  // S\n                 (minc+maxc)*0.5 );                           // L\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF's & other spatial query functions\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphereSDF(Sphere sphere, vec3 p) \n{\n    return length(sphere.pos - p) - sphere.radius;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    float mindist = TOO_FAR;\n    for (int i=0; i<NUM_SPHERES; i++)\n    {\n        float dist = sphereSDF(g_spheres[i], p);\n        dist = opSmoothUnion(mindist, dist, SMOOTH_DIST);\n        if (dist < mindist)\n        {\n        \tmindist = dist;    \n        }\n    }\n      \n\treturn mindist;\n}\n\nMaterial materialAt(vec3 p)\n{\n    float mindist = TOO_FAR;\n    float weight = 1.0f;\n    Material mat = Material(vec3(0.0), 0.0, 0.0);\n    \n    for (int i=0; i<NUM_SPHERES; i++)\n    {\n        float dist = sphereSDF(g_spheres[i], p);\n        if (dist < SMOOTH_DIST)\n        {\n            float scale = (SMOOTH_DIST-dist)/SMOOTH_DIST;\n       \n        \tmat.colour += g_spheres[i].mat.colour * scale;                    \n        \tmat.diffuse += g_spheres[i].mat.diffuse * scale;                    \n        \tmat.specular += g_spheres[i].mat.specular * scale;                    \n            mindist = dist;\n        }\n    }\n        \n    if (mindist<SMOOTH_DIST)\n        return mat;\n    else\n\t\treturn g_NoMaterial;\n}\n\nResult resultSDF(vec3 p)\n{\n    Result result;\n\tresult.normal.x = sceneSDF(p + vec3(EPSILON, 0.0, 0.0)) - sceneSDF(p);\n\tresult.normal.y = sceneSDF(p + vec3(0.0, EPSILON, 0.0)) - sceneSDF(p);\n\tresult.normal.z = sceneSDF(p + vec3(0.0, 0.0, EPSILON)) - sceneSDF(p);\n    result.normal = normalize(result.normal);\n    result.mat = materialAt(p);\n    result.pos = p;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch query, returning intersection point, normal, surface colour\n\nResult raymarch_query(Ray ray)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), g_NoMaterial);\n\tfor (int i=0; i<MARCH_ITERATIONS; i++)\n    {\n    \tfloat signeddist = sceneSDF(ray.pos);\n        \n        ray.pos += signeddist*ray.dir*1.4;       \n    }\n    result = resultSDF(ray.pos);\n    return result;\n}\n\nvec3 raymarch(Ray inputray)\n{\n    const float exposure = 1e-2;\n    const float gamma = 2.2;\n    const float intensity = 100.0;\n    const vec3 ambient = vec3(0.1, 0.1, 0.1) *1.0* intensity / gamma;\n\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    vec3 mask = vec3(1.0, 1.0, 1.0);\n    vec3 fresnel = vec3(1.0, 1.0, 1.0);\n    \n    Ray ray=inputray;\n        \n    for (int i=0; i<REFLECT_ITERATIONS; i++)\n    {\n        Result result = raymarch_query(ray);\n\n        if (result.mat.diffuse==0.0)\n        {\n            vec3 spotlight = vec3(1e4) * pow(clamp(dot(ray.dir, -g_light.dir),0.0,1.0), 250.0);\n\n            colour += mask * (ambient + spotlight); \n            break;\n        }\n        else\n        {              \n            vec3 r0 = result.mat.colour.rgb * result.mat.specular;\n            float hv = clamp(dot(result.normal, -ray.dir), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;            \n                        \n            colour += clamp(dot(result.normal, -g_light.dir), 0.0, 1.0) * g_light.colour\n                * result.mat.colour.rgb * result.mat.diffuse\n                * (1.0 - fresnel) * mask / fresnel;\n                        \n            Ray reflectray;\n            reflectray.pos = result.pos + result.normal*MARCH_EPSILON*2.0f;\n            reflectray.dir = reflect(ray.dir, result.normal);\n            ray = reflectray;\n        }\n    }\n        \n    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// initialise all the primitives\n\nvoid setupscene()\n{   \n    // scene definition    \n    for (int i=0; i<NUM_SPHERES; i++)\n    {\n        vec3 origin;\n        origin.x = 2.0 - perlin(HURRY_UP*iTime*0.212, float(i) + 1.0)*4.0;\n        origin.y = 2.0 - perlin(HURRY_UP*iTime*0.341, float(i) + 2.0)*4.0;\n        origin.z = 4.0 + perlin(HURRY_UP*iTime*0.193, float(i) + 3.0)*2.0;\n        float radius = 1.0;\n        \n        g_spheres[i].pos = origin;\n        g_spheres[i].radius = radius;\n        g_spheres[i].mat = Material(vec3(1.0), 1.0, 0.1);        \n    }    \n    \n    g_spheres[0].mat.colour = vec3(1.0, 0.0, 0.0);\n    g_spheres[1].mat.colour = vec3(0.0, 1.0, 0.0);\n    g_spheres[2].mat.colour = vec3(0.0, 0.0, 1.0);\n    g_spheres[3].mat.colour = vec3(1.0, 0.0, 0.0);\n    g_spheres[4].mat.colour = vec3(0.0, 1.0, 0.0);\n    g_spheres[5].mat.colour = vec3(0.0, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n\tsetupscene();\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA*MSAA);\n    \n    for (float x=0.0; x<MSAA; x++)\n    {\n        for (float y=0.0; y<MSAA; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA))*x;\n            uv.y += (1.0/(iResolution.y*MSAA))*y;\n            \n            Ray ray;\n            ray.pos = vec3(0.0, 0.0, 0.0);\n            ray.dir = uv.xyx;\n            ray.dir.z = 1.0;\n            ray.dir = normalize(ray.dir);\n\n            fragColor.xyz += raymarch(ray)*factor;\n        }        \n    }\n    \n    float amount = 0.5 + sin(iTime)*0.5;\n    \n    if ((floor(mod(fragCoord.y, 8.0)) != 0.0) && (floor(mod(fragCoord.x, 8.0)) != 0.0) && amount>0.1)\n    {\n        fragColor.xyz = rgb2hsv(fragColor.xyz);\n        fragColor.y=0.0;\n        fragColor.xyz = hsv2rgb(fragColor.xyz);\n    }\n    else\n    {\n        fragColor.xyz = rgb2hsv(fragColor.xyz);\n        fragColor.y=1.0;\n        fragColor.xyz = hsv2rgb(fragColor.xyz);        \n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1269, 1383, 1410, 1410, 1539], [1541, 1541, 1568, 1568, 1710], [1712, 1712, 1738, 1738, 2053], [2055, 2055, 2081, 2081, 2533], [2535, 2620, 2682, 2682, 2820], [2822, 2822, 2842, 2842, 2912], [2914, 2914, 2946, 2946, 3089], [3091, 3217, 3270, 3270, 3370], [3372, 3372, 3413, 3413, 3466], [3468, 3468, 3492, 3492, 3781], [3783, 3783, 3812, 3812, 4492], [4494, 4494, 4520, 4520, 4874], [4876, 5033, 5065, 5065, 5357], [5359, 5359, 5388, 5388, 6874], [6876, 6994, 7013, 7044, 7833], [7835, 7970, 8027, 8027, 9140]]}
{"id": "3lSXDV", "name": "Learning Raymarching 002", "author": "raphaelameaume", "description": "raymarching, learning", "tags": [], "likes": 3, "viewed": 357, "published": "Public", "date": "1567071126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubstraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// rotation matrix\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\n\n\nfloat map(in vec3 pos)\n{\t\n    vec3 spherePos = vec3(0.5 * cos(iTime), 0.5 * sin(iTime), 0.);\n    float sphere = sdSphere(pos - spherePos, 0.45);\n    \n    \n    float box = sdBox(pos, vec3(0.2, 0.2, 0.2));\n                      \n    //float d = opSmoothUnion(sphere, box, 0.3);\n    \n    vec3 caps = vec3(pos.x - 0.4, pos.y, pos.z - 0.4);\n    \n    float scale = 0.4 + (sin(iTime) + 1.) * 0.25;\n    scale = 1.0;\n    \n    caps = caps / scale;\n   \n    \n    \n    vec3 c = vec3(4., 1., 1.); \n    caps = mod(caps,c)-0.5*c;\n    //caps.y -= iTime;\n    \n    \n    float d = sdVerticalCapsule(caps, 1., 0.05) * scale;\n    \n    \n    vec3 boxes = vec3(pos.x - 0.4, pos.y - 0.4 + iTime, pos.z - 0.4);\n    boxes = mod(boxes,c)-0.5*c;\n    \n  \tfloat d2 = sdBox(boxes, vec3(0.1));\n    \n    d = opSmoothUnion(d, d2, 0.1);\n  \n    \n    \n    float ground = pos.y - (-0.25);\n                      \n    \n    \n    return min(d, d);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float limit = 30.0;\n    \n    for (int i=0; i <100; i++)\n    {\n    \tvec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if(h<0.001) break;\n        \n        \n        t += h;\n        \n        if (t > limit) break;\n    }\n    \n    if (t>limit) t = -1.0;\n    \n    return t;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = cross(cu, cw);\n    \n    return mat3(cu, cv, cw);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2.0 * fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    \n    float an = 10.57 * iMouse.x / iResolution.x;\n    vec3 ta =  vec3(0.0, 0.0, 2.0 - iTime);\n    vec3 ro = ta + vec3(1.3 * cos(an), 0., 1.3 * sin(an));\n    \n    \n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    vec3 rd = ca * normalize(vec3(p, -2) - vec3(0., 0.0, 0.));\n\tvec3 col = vec3(0.6, 0.7, 0.9) - 0.5;\n    \n    vec3 fogColor = vec3(0.0, 0.0, 0.);\n    col = fogColor;\n    \n    float t = castRay(ro, rd);\n    \n    \n    if (t > 0.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        vec3 sunDir = normalize(vec3(0.8, 0.2, 0.2));\n        float sunDif = clamp(dot(nor, sunDir), 0.0, 1.0);\n        float skyDif = clamp(0.5 + 0.5 *dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float sunShadow = step(castRay(pos + nor*0.001, sunDir), 0.0);\n        sunShadow = 1.0;\n        float bounceDif = clamp(0.5 + 0.5 *dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        // main light\n        col = mate * vec3(7.0, 5.0, 3.0) * sunDif*sunShadow;\n        // sky light\n        col += mate * vec3(0.5, 0.8, 0.9) * skyDif;\n\t\t// bounce light\n        //col += mate * vec3(0.7, 0.3, 0.2) * bounceDif;\n        \n   \t    float fogNear = 9.0;\n        float fogFar = 20.0;\n    \n\t    float fogAmount = clamp(smoothstep(fogNear, fogFar, t * 2.0), 0., 1.) * 1.;\n    \n    \tcol = mix(col, fogColor, fogAmount);\n        \n    }\n    \n\n    \n    col = pow(col, vec3(0.4545));\n                        \n                    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 181], [183, 183, 218, 218, 242], [244, 244, 297, 297, 360], [362, 362, 414, 414, 513], [515, 515, 574, 574, 674], [676, 676, 735, 735, 834], [836, 855, 891, 891, 1295], [1299, 1299, 1323, 1323, 2204], [2206, 2206, 2236, 2236, 2440], [2442, 2442, 2478, 2478, 2795], [2797, 2797, 2847, 2847, 3029], [3032, 3032, 3089, 3140, 4755]]}
{"id": "3lSXRt", "name": "TornadeLattice", "author": "Fogrex", "description": "lattice tornade", "tags": ["raymarching"], "likes": 2, "viewed": 97, "published": "Public", "date": "1566691720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n\nint STEP = 64;\nfloat NEAR = 2.0;\nfloat REPEAT_UNIT = 500.0;\n\n\n//transform function(inverse)\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 move)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m * p).xyz;\n}\n\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n// distance functions\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cylinder(vec3 pos, float r)\n{\n    return length(pos.xz) - r;\n}\n\n// mixing shapes\nfloat nsUnion(float d1, float d2) {return min(d1, d2);}\n\nfloat nsSubtraction(float d1, float d2) {return max(-d1, d2);}\nfloat nsIntersection(float d1, float d2) {return max(d1, d2);}\nfloat sUnion(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\nfloat sSubtraction(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\nfloat sIntersection(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n\n//mapping\nfloat map(vec3 pos)\n{\n    pos = rotate(pos, vec3(0.0,0.0,pos.z / REPEAT_UNIT * PI2));\n    \n    vec3 m = vec3(REPEAT_UNIT / 40.0,REPEAT_UNIT / 40.0,REPEAT_UNIT / 40.0);\n    pos = mod(pos,m) - m * 0.5;\n    float c1 = cylinder(pos, 1.0);\n    float c2 = cylinder(rotate(pos, vec3(PI/2.0,0.0,0.0)),1.0);\n    float c3 = cylinder(rotate(pos, vec3(0.0,0.0,PI/2.0)),1.0);\n    float s1 = sphere(pos,2.0);\n    float r = nsUnion(c2,c3);\n    r = nsUnion(c1, r);\n    r += sin(pos.x*3.0)*sin(pos.y*3.0)*sin(pos.z*3.0)*0.25;\n    \n    r = nsUnion(s1, r);\n    return r;\n    \n}\n\n// calculating normal\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    float center = map(pos);\n    vec3 grad = vec3(map(pos+vec3(d,0.0,0.0))-center, map(pos+vec3(0.0,d,0.0))-center, map(pos+vec3(0.0,0.0,d))-center);\n    return normalize(grad / d);\n}\n\n// lambert model\nvec4 lambert(vec3 pos, vec3 lightDir)\n{\n    vec3 n = calcNorm(pos);\n    float b = max(0.0, dot(n, -normalize(lightDir)))*0.9+0.1;\n    return vec4(b, b, b, 1.0);\n}\n\nvec4 visualizeNormal(vec3 pos)\n{\n    return vec4(calcNorm(pos),1.0)*0.8 + vec4(1.0,1.0,1.0,1.0)*0.2;\n}\n\n// raymarching\nvec4 raymarch(vec2 fc)\n{\n    fc = (fc * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(fc, NEAR);\n    \n    //camera rotating\n    float rx = iMouse.x/iResolution.x*2.0 - 1.0;\n    float ry = iMouse.y/iResolution.y*2.0 - 1.0;\n    pos = rotate(pos, vec3(ry,-rx,0.0));\n    ray = rotate(ray, vec3(ry,-rx,0.0));\n    \n    // camera moving\n    pos = translate(pos, vec3(0.0,0.0,mod(-iTime*20.0, REPEAT_UNIT)));\n    \n    \n    float d = 0.0;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d < 0.0001){\n            return lambert(pos, vec3(1.0,-1.0,0.0));\n            //return visualizeNormal(pos);\n        }\n        pos = pos + ray * d;\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = raymarch( fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 144, 191, 191, 1141], [1143, 1143, 1180, 1180, 1440], [1442, 1442, 1475, 1475, 2236], [2238, 2260, 2291, 2291, 2319], [2321, 2321, 2353, 2353, 2448], [2450, 2450, 2485, 2485, 2518], [2520, 2537, 2572, 2572, 2592], [2594, 2594, 2635, 2635, 2656], [2657, 2657, 2699, 2699, 2719], [2720, 2720, 2762, 2762, 2857], [2858, 2858, 2906, 2906, 3002], [3003, 3003, 3052, 3052, 3147], [3150, 3160, 3181, 3181, 3718], [3720, 3742, 3767, 3767, 3973], [3975, 3992, 4031, 4031, 4154], [4156, 4156, 4188, 4188, 4258], [4260, 4275, 4299, 4299, 5044], [5046, 5046, 5103, 5103, 5144]]}
{"id": "3lSXW1", "name": "EmissionPractice001", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 2, "viewed": 112, "published": "Public", "date": "1565692670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n\n//tracing result structure\nstruct TraceData {\n\tvec3 normal;\n    float t;\n    float nearestT;\n    float nearestD;\n    int uniqueID;\n    \n};\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n    float fs = 8.;\n    p = (fract(p / fs + 0.5) - 0.5)*fs;\n    p.xz *= genRot(iTime);\n    p.xy *= genRot(PI/8.);\n    return min(sphere(p,vec3(-0.25),1.2),sphere(p,vec3(0.25),1.2));\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(4.,4.,-5. + iTime * 2.);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.xz *= genRot(PI/8.);\n    ray.yz *= genRot(PI/8.);\n    ray.xy *= genRot(iTime/8.);\n    return ray;\n}\n\n//Tracing Ray\n\nTraceData trace (vec3 o, vec3 r){\n    TraceData data;\n\tfloat t = 0.0;\n    float nearestT = 10000000.0;\n    float nearestD = 10000000.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n        nearestT = d < nearestD ? t : nearestT;\n        nearestD = min(nearestD,d);\n        \n    }\n    data.nearestD = nearestD;\n    data.nearestT = nearestT;\n    data.normal = getNormal(p);\n    data.t = t;\n    return data;\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,TraceData data){\n    float t = data.t;\n    float nT = data.nearestT;\n    float nD = data.nearestD;\n    float fog = 1.0 / (1.0 + t * t * 0.005);\n    float a = dot(data.normal,r);\n    vec3 p = o + r * t;\n    vec3 fc = vec3(0.05);\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    vec3 nP = o + r * data.nearestT;\n    fc = mix(vec3(0.05),fc,fog);\n    fc = clamp(fc,0.,1.);\n    float at = atan(r.y/r.x)/PI + 0.5;\n    vec3 ccol = vec3(sin(at * PI), 1. - sin(at * PI),sin(p.z) + 0.1);\n    ccol = mix(ccol,vec3(0.0),sin(nP.z * 2. + iTime * 2.)/2. + 0.5);\n    fc += ccol / (1. + max(nT * nT * 0.0001, nD *nD * 10.0));\n    //fc = vec3(fog);\n    return fc;\n}\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    TraceData data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 237, 260, 260, 332], [334, 334, 355, 355, 467], [469, 469, 510, 510, 584], [586, 586, 612, 612, 795], [798, 812, 848, 848, 877], [879, 879, 917, 917, 946], [948, 948, 981, 981, 1128], [1130, 1130, 1173, 1173, 1329], [1332, 1349, 1367, 1367, 1550], [1552, 1570, 1594, 1594, 1846], [1848, 1868, 1889, 1889, 1929], [1931, 1945, 1972, 1972, 2115], [2117, 2132, 2165, 2165, 2636], [2638, 2653, 2697, 2697, 3321], [3322, 3333, 3390, 3407, 3764]]}
{"id": "3lSXWK", "name": "Church", "author": "icaroleles1", "description": "A small Church", "tags": ["raymarchingchurch"], "likes": 2, "viewed": 188, "published": "Public", "date": "1567106849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 100.\n\n\n\nstruct material{\n    \n    vec3 diffuse;\n };\n\n//transformations\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nstruct mat{\n    \n    \n vec3 diffuseColor;\n vec3 specularColor;\n float spec;\n    \n    \n};\n\nfloat addCapsule(vec3 p,vec3 a, vec3 b,float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab,ap)/(dot(ab,ab));\n                          \n    t = clamp(t,.0,1.);\n                          \n                          \n    vec3 c = a + t*ab;\n    float d = length(p-c) - r;\n                          \n     return d;                    \n    \n}\n\nfloat addTorus(vec3 p,vec2 r){\n    \n float x = length(p.xz)-r.x;\n    return length(vec2(x,p.y))-r.y;\n    \n    \n}\n\nfloat addCube(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n    \n    \n    \n}\n\nfloat addSphere(vec3 p, float r){\n    \n  vec3 sphere = vec3(0.0,0 ,.0);\n\n  //float sphereDistance = length(p - sphere.xyz)-sphere.w;\n  float sphereDistance = length(p - sphere.xyz)-r;   \n    \n    return sphereDistance;\n}\n\n//camera\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec2 opUnion(vec2 r1, vec2 r2){\n    return r1.x < r2.x ? r1 : r2;\n}\nvec2 getDistance(vec3 p){\n    \n   vec2 res;\n   vec3 cubeP =p-vec3(1.0,1.4,4);\n   cubeP.xz *=Rot(160.);\n   float cube = addCube(cubeP,vec3(2.1,1.3,.8));\n   \n   vec3 window1P = cubeP - vec3(-3.,.3,0.3);\n   float window1  = addSphere(window1P,.6);\n   res = opUnion(vec2(cube,1.0),vec2(window1,2.0));\n    \n   vec3 window2P = cubeP -  vec3(3.,.3,0.3);\n   float window2  = addSphere(window2P,.6);\n   res = opUnion(res,vec2(window2,2.0));\n\n   vec3 col1P  = cubeP -vec3(-3.,-.0,0.);\n   float col1 = addCube(col1P,vec3(.8,1.3,.8));\n   res = opUnion(res,vec2(col1,3.0));     \n\n   vec3 col2P = cubeP - vec3(3,0.,0.0);\n   float col2 = addCube(col2P,vec3(.8,1.3,.8));\n   res = opUnion(res,vec2(col2,3.0)); \n       \n \tvec3 tri1P = cubeP - vec3(-3,1.8,0.0);\n\tfloat tri1 = sdTriPrism(tri1P,vec2(.9,.9)); \n    res = opUnion(res,vec2(tri1,4.0));\n    \n    vec3 tri2P = cubeP - vec3(3.1,1.8,0.0);\n\tfloat tri2 = sdTriPrism(tri2P,vec2(.9,.9));\n    res = opUnion(res,vec2(tri2,4.0));\n    \n    vec3 tri3P = cubeP - vec3(0.0,2.0,0.0);\n\tfloat tri3 = sdTriPrism(tri3P,vec2(1.4,1.1));  \n    res = opUnion(res,vec2(tri3,4.0));\n    \n    vec3 cross1P = cubeP - vec3(3.1,3.,.0);\n    cross1P.xy *=Rot(55.);\n\tfloat cross1 =addCube(cross1P,vec3(1.2,.09,.09));\n    res = opUnion(res,vec2(cross1,5.0));\n    \n    vec3 cross11P = cubeP -vec3(3.1,3.4,.0);\n    cross11P.xy *=Rot(0.);\n\tfloat cross11 =addCube(cross11P,vec3(1.2,.09,.09));\n    res = opUnion(res,vec2(cross11,6.0));\n\n    \n    vec3 cross2P = cubeP - vec3(-3.1,3.,.0);\n    cross2P.xy *=Rot(55.);\n    float  cross2 =addCube(cross2P,vec3(1.2,.09,.09));\n\tres = opUnion(res,vec2(cross2,6.0));\n\n    vec3 cross22P = cubeP - vec3(-3.1,3.4,.0);\n    cross22P.xy *=Rot(0.);\n    float  cross22 =addCube(cross22P,vec3(1.2,.09,.09));\n   \tres = opUnion(res,vec2(cross22,6.0));\n\n    vec3 doorP = cubeP + vec3(0.0,0.6,-.9);\n    float door = addCube(doorP,vec3(.6,.6,.09));\n\tres = opUnion(res,vec2(door,7.0));\n\n  \tres = opUnion(res,vec2(p.y,-1.0));\n    \n    \n   \n     res = opUnion(res,vec2(p.y+1.,-2.0));\n\n    \n    return res;\n   \n   \n}\n\nfloat getDistToSphere(vec3 p){\n   float sphere = addSphere(p-vec3(.3,.0,2),1.0);\n\n    return sphere;\n}\n\n\n\n\nvec2 rayMarch(vec3 ro,vec3 rd){\n    float dO = 0.;\n    \n    vec2 d;\n\n    for(int i=0;i<100;i++){\n        \n     vec3 p = ro + rd*dO;\n        \n        d = getDistance(p);\n        \n\n        dO+=d.x;\n        if(d.x >100.0|| d.x<.01)\n            break;\n\n    }\n    \n        float id=d.y;\n        float dist = dO;\n    \n    return vec2(dist,id);\n    \n    \n}\n\n\n\nvec3 getNormal(vec3 p){\n    \n    vec2 d = getDistance(p);\n    \n    vec2 e= vec2(.01,.0);\n    \n    vec3 normal = d.x -vec3(getDistance(p-e.xyy).x,\n                          getDistance(p-e.yxy).x,\n                          getDistance(p-e.yyx).x);\n    \n      \n    return normalize(normal);\n}    \n\n\nvec3 getLight(vec3 p,vec3 ro,vec3 uv,float geometry){\n \n    \n \tvec3 lightPos = vec3(4, 5, 1.3);\n    lightPos.xz -= vec2(sin(iTime)*6., cos(iTime)*6.);\n    vec3 lightDir = normalize(lightPos-p);\n    vec3 normal = getNormal(p);\n    \n    \n    float dist = distance(lightPos,p);\n    float diff = clamp(dot(normal, lightDir), 0., 1.);\n    float d = rayMarch(p+normal*0.02*2., lightDir).x;\n    if(d<length(lightPos-p)) diff *= .1;\n    \n    \n    \n    vec3 viewDir = normalize(uv-ro);\n    vec3 reflectDir = reflect(-lightDir,normal);\n    vec3 ambient = vec3(.2,.2,.4);\n\n    mat material;\n    \n    //floor\n    if(geometry==-1.0){\n        \n        \n        material.diffuseColor = vec3(1.,1.3,1.3);\n        material.specularColor = vec3(.7,.7,.7);\n        material.spec = 64.0;\n        \n }\n    //mainWall\n      if(geometry==1.0){\n        \n        \n        material.diffuseColor = vec3(1.0,1.,.1);\n        material.specularColor = vec3(1.0);\n        material.spec = 2.0;\n        \n    }\n    \n    //window\n    else if(geometry == 2.0){\n        \n        material.diffuseColor = vec3(.1,1.,.1);\n        material.specularColor = vec3(.0,1.,.0);\n        material.spec = 256.0;\n\n        \n        \n    }\n    //columns\n      else if(geometry == 3.0){\n       \n        material.diffuseColor = vec3(.0,.0,.6);\n        material.specularColor = vec3(.8);\n        material.spec = 256.;\n        \n        \n    }\n    //roof\n      else if(geometry ==4.0 ){\n        material.diffuseColor = vec3(1.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n        \n        \n        \n    }\n    //cross\n      else if(geometry ==5.0 ){\n        \n        material.diffuseColor = vec3(.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 2.;\n        \n        \n    }\n     else if(geometry ==6.0 ){\n        \n        material.diffuseColor = vec3(.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 4.;\n        \n        \n    }\n     else if(geometry ==7.0 ){\n        \n        material.diffuseColor = vec3(.1,.3,.3);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n        \n        \n    }\n    else{\n        \n         material.diffuseColor = vec3(.8,.8,.8);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n    }\n   float spec = pow(max(dot(viewDir,reflectDir),0.0),material.spec);\n\n\n    material.diffuseColor*=diff * 1./(dist*.063);\n    material.specularColor*=spec*1./(dist*.063);\n    return material.diffuseColor + material.specularColor + ambient ;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n\tuv.x *=iResolution.x/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 position =  vec3(1.0,1.4,4);\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 3.9, -13);\n    vec3 dir = position-ro;\n \n\tro.xz = vec2(sin(iTime),cos(iTime)-13.);\n   // ro.yz *= Rot(-m.y+.4);\n    //ro.xz *= Rot(.2-m.x*6.2831);\n   // ro.xz = vec2(0. + sin(iTime),-6. + cos(iTime));\n    float geometry  ;\n    vec3 rd = vec3(uv.x,uv.y,1.);\n   \t\n    \n    \n   vec2 x = rayMarch(ro,rd);\n  \n    geometry = x.y;\n   vec3  outPut = ro +rd*x.x; \n   \n   vec3 result = getLight(outPut,ro,vec3(uv,1.0),geometry);\n    \n    \n    const float gamma = 2.2;\n    /*vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;\n  \n    // Exposure tone mapping\n    vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n    // Gamma correction \n    mapped = pow(mapped, vec3(1.0 / gamma));\n  \n    FragColor = vec4(mapped, 1.0);*/\n    \n    vec3 colx = result;\n    vec3 mapped = vec3(1.0) - exp(-colx * .2);\n    mapped = pow(mapped, vec3(1.0 / gamma));\n\n    fragColor = vec4(mapped,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 88, 107, 107, 183], [185, 185, 221, 221, 308], [311, 311, 352, 352, 443], [536, 536, 584, 584, 889], [891, 891, 921, 921, 1003], [1005, 1005, 1035, 1035, 1089], [1091, 1091, 1124, 1124, 1311], [1313, 1322, 1364, 1364, 1559], [1561, 1561, 1592, 1592, 1628], [1629, 1629, 1654, 1654, 3669], [3671, 3671, 3701, 3701, 3773], [3778, 3778, 3809, 3809, 4127], [4131, 4131, 4154, 4154, 4421], [4428, 4428, 4481, 4481, 6967], [6969, 6969, 7026, 7026, 8109]]}
{"id": "3lSXz1", "name": "Smooth Newton Fractal", "author": "cppio", "description": "The newton fractal, drawn smoothly, for the polynomial z^3-1.", "tags": ["2d", "fractal", "newton", "smooth"], "likes": 4, "viewed": 472, "published": "Public API", "date": "1564969029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define THRESHOLD 0.000001\n#define MAX_ITERATIONS 100\n#define ANTI_ALIASING 2\n\nvec2 f(vec2 z) {\n    float magnitude = dot(z, z);\n    return (2.0 * z + vec2(z.x * z.x - z.y * z.y, -2.0 * z.x * z.y) / (magnitude * magnitude)) / 3.0;\n}\n\nvec2 roots[] = vec2[](\n    vec2(1.0, 0.0),\n    vec2(-0.5, 0.5 * sqrt(3.0)),\n    vec2(-0.5, -0.5 * sqrt(3.0))\n);\n\nvec3 palette[] = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0)\n);\n\nvec3 drawFractal(vec2 z) {\n    for (int iterations = 0; iterations < MAX_ITERATIONS; ++iterations) {\n    \tz = f(z);\n        \n        for (int root = 0; root < roots.length(); ++root) {\n            vec2 difference = z - roots[root];\n            float distance = dot(difference, difference);\n            if (distance < THRESHOLD) {\n    \t\t\treturn palette[root] * (0.75 + 0.25 * cos(0.25 * (float(iterations) - log2(log(distance) / log(THRESHOLD)))));\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = exp(-5.0 * (0.9 - cos(iTime / 5.0)));\n    vec2 center = vec2(0.14918, 0.09001);\n    \n    vec3 color = vec3(0);\n    \n    for (int x = 0; x < ANTI_ALIASING; ++x) {\n        for (int y = 0; y < ANTI_ALIASING; ++y) {\n            color += drawFractal(center + zoom * ((2.0 * (fragCoord + vec2(x, y) / float(ANTI_ALIASING)) - iResolution.xy) / iResolution.y - center));\n        }\n    }\n    \n    fragColor = vec4(color / float(ANTI_ALIASING * ANTI_ALIASING), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 95, 95, 232], [450, 450, 476, 476, 929], [931, 931, 986, 986, 1462]]}
{"id": "3lSXzR", "name": "One to Many", "author": "mosaic", "description": "50 circles, moving fast", "tags": ["2d"], "likes": 1, "viewed": 67, "published": "Public", "date": "1564721621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord/2.0  - 0.1 * iResolution.xy) / iResolution.y+0.35;\n \n    //background gradient colour\n    float pct = 1.8-st.y*1.6;\n     \n    //the loop repeats 50 times, so there are 50 circles drawn in total\n    for(int i=0; i<50;i++){\n        //change i to float so I can multiply by it\n        float i_float = float(i);\n        //here the circle function is called. The location (position) of each circle is \n        //adjusted by the sin of the time value.\n        //The 50 circles are in different positions because the incremented i_float \n        //value is used:\n        \n        vec2 position = st+(0.2*sin(3.-i_float*st.yx*((sin(iTime/3.)+1.))));\n        pct += circle(position,0.001)*st.y*1.5;\n    }\n \n\tpct=pct-1.;\n\n    // Output to screen, adjust colour\n    fragColor = vec4(pct+.1,pct+.1,pct,1.0)*vec4(0.9,0.,0.,0.)+vec4(0.,0.0,0.3,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 218], [220, 220, 277, 277, 1139]]}
{"id": "3lXGDf", "name": "flying flag", "author": "bhuwan0000", "description": "flying flag ", "tags": ["flag"], "likes": 3, "viewed": 347, "published": "Public API", "date": "1564720983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, float left, float right, float up, float down, float blur)\n{\n    float l1 = smoothstep(uv.x, uv.x-blur, left);\n    float r1 = smoothstep(uv.x, uv.x+blur, right);\n    float u1 = smoothstep(uv.y, uv.y+blur, up);\n    float d1 = smoothstep(uv.y, uv.y-blur, down);\n    float result = l1*r1*u1*d1;\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    float x = uv.x;\n    float y = uv.y;\n    float m = 0.2*sin(19.0*iTime + x*22.0);\n  \n    y = y-(m*(uv.x-0.3)/2.0);\n\n    float col = rect(vec2(x,y), -0.3, 0.3, 0.1+uv.x, -0.2, 0.01);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 80, 80, 332], [333, 333, 390, 440, 740]]}
{"id": "3t2SDh", "name": "Hello Green Chicken", "author": "GreenChicken", "description": "Raymarching training with my Green Chicken !\n\nI followed the awesome page https://github.com/ajweeks/RaymarchingWorkshop by ajweeks.\nsdf functions and boolean stuffs src iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["raymarching", "sdf", "chicken"], "likes": 2, "viewed": 97, "published": "Public", "date": "1565767786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// SOME SDF FUNCTIONS\n//\n\nfloat spiralSDF(vec2 uv, float t)\n{\n    float r = dot(uv,uv);\n    float a = atan(uv.y, uv.x);\n    return abs(sin(fract(log(r)*t+a*0.159)));\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//\n// RAYMARCH SCENE\n//\n\nfloat sceneSDF(vec3 pos)\n{\n    float a, b, c;\n    float result = 0.0;\n    vec3 aPos = pos;\n    vec3 bPos = pos;\n    vec3 cPos;\n    \n    a = sdSphere(aPos, 1.0);\n    aPos.y -= 1.5;\n    a = opSmoothUnion(a, sdSphere(aPos, 1.0), .5);\n    \n    bPos.y -= 1.5;\n    bPos.x += .25;\n    bPos.z += .75;\n    b = sdSphere(bPos, .5);\n    bPos.x -= .5;\n    b = max(b, sdSphere(bPos, .5));\n    bPos = pos + vec3(0.5, -1.75, 0.75);\n    b = min(b, sdSphere(bPos, .25));\n    bPos = pos + vec3(-0.5, -1.75, 0.75);\n    b = min(b, sdSphere(bPos, .25));\n    \n    cPos = pos + vec3(0.0, -2.7, 0.0);\n    c = sdSphere(cPos, .5);\n    cPos = pos + vec3(0.0, -2.3, 0.7);\n    c = opSmoothUnion(c, sdSphere(cPos, .4),.25);\n    cPos = pos + vec3(0.0, -2.3, -0.7);\n    c = opSmoothUnion(c, sdSphere(cPos, .4),.25);\n    \n    result = min(min(a, b), c);\n    \n    \n    return result;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n    \n    for(int i=0; i<64 ; i++)\n    {\n        float res = sceneSDF(rayOrigin + rayDir * t);\n        if(res < (0.0001*t))\n        {\n            return t;\n        }\n        t += res;\n    }\n    \n    return -1.0;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = castRay(rayOrigin, rayDir);\n    vec3 col;\n    if(t == -1.0)\n    {\n        col = vec3(1., .1, .2) * -rayDir.y + .2;\n    }\n    else\n    {\n        float ao = pow(1.0-t*.1, 8.0) * 256.0;\n        col = vec3(.1, 1., .2) * ao;\n    }\n    \n    return col;\n}\n\nvec3 CameraViewDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 viewDir;\n    vec3 forward = normalize(camTarget - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n    float fPersp = 2.0;\n    \n    viewDir = normalize(uv.x * right + uv.y * up + fPersp * forward);\n    return viewDir;\n}\n\nvec2 NormalizeScreen(vec2 st)\n{\n    vec2 uv = (2.0 * st/iResolution.xy - 1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(.0);\n    vec3 camPos = vec3(sin(iTime), .25 + sin(iTime)*.25, cos(iTime)) * 6.0;\n    vec3 camTarget = vec3(0.0, 1., .0);\n    \n    vec2 uv = NormalizeScreen(fragCoord);\n    vec3 viewDir = CameraViewDir(uv, camPos, camTarget);\n    \n    col.xy = uv;\n    \n    col = render(camPos, viewDir);\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2SDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 64, 64, 170], [172, 172, 230, 230, 331], [333, 333, 385, 385, 484], [486, 486, 521, 521, 545], [548, 573, 599, 599, 1423], [1425, 1425, 1469, 1469, 1701], [1703, 1703, 1745, 1745, 2008], [2010, 2010, 2068, 2068, 2370], [2372, 2372, 2403, 2403, 2508], [2510, 2510, 2565, 2565, 2910]]}
{"id": "3t2SDW", "name": "rayMarching #5", "author": "dnkorbut", "description": "infinite figure", "tags": ["raymarching", "infinite"], "likes": 0, "viewed": 59, "published": "Public", "date": "1565901470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH 640\n#define MAX_DST 100.\n#define MIN_DST .01\n#define AMBIENT_DST .05\n\n#define OBJ_DELTA .004\n#define OBJ_PLANE .5\n#define OBJ_SPHERE .51\n#define OBJ_INFIG .52\n\n#define OBJECTS 9\n\nmat4 obj[OBJECTS];\n\n// globals\nvec3 p;\nint o;\nfloat deltaDst;\n\nvec3 getNor(int o, vec3 p) {\n    if(obj[o][3][3] < OBJ_SPHERE - OBJ_DELTA) {\n        return obj[o][2].xyz;\n    }else if(obj[o][3][3] < OBJ_INFIG - OBJ_DELTA) {\n    \treturn normalize(p - obj[o][0].xyz);\n    }else{\n        return normalize(p - obj[o][0].xyz);\n    }\n}\n\nfloat getDistance(vec3 p) {\n    float min = 255.;\n    float res;\n    for(int c = 0; c < OBJECTS; c++) {\n        \n        if(obj[c][3][3] < OBJ_SPHERE - OBJ_DELTA) {\n            res = abs(p.y - obj[c][0][1]); // plane\n        }else if(obj[c][3][3] < OBJ_INFIG - OBJ_DELTA) {\n            res = length(p - obj[c][0].xyz) - obj[c][0].w; // sphere\n        }else{\n         \tres = length(cos(p) * 1.6 + sin(obj[c][0].xyz) * 1.99) - obj[c][0].w; // infinite figure\n        }\n        \n        if(min > res) {\n            deltaDst = min - res;\n            min = res;\n            o = c;\n        }\n        \n    }\n    return min;\n}\n\nfloat rayMarch(vec3 start, vec3 dir) {\n    float ret = 0.;\n    int i;\n    float dst;\n    \n    for(i = 0; i < MAX_MARCH; i++) {\n        p = start + dir * ret;\n        dst = getDistance(p);\n        ret += dst;\n        if(ret > MAX_DST || dst < MIN_DST) {\n           break; \n        }\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // light\n    vec3 light = vec3(sin(iTime) * 10., 6., cos(iTime) * 10. + 10.);\n    vec3 light2 = vec3(sin(iTime + 3.14) * 10., 6., cos(iTime + 3.14) * 10. + 10.);\n    \n    // camera\n    vec3 cam = vec3(0., 1., 0.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // objects\n    obj[0][0] = vec4(0., -5.2, 0., 0.); // infinite plane at zero Y\n    obj[0][1] = vec4(.5, .5, .5, 1.);\n    obj[0][2] = vec4(0., 1., 0., 0.);\n    obj[0][3][3] = OBJ_PLANE;\n    \n    obj[1][0] = vec4(0., 1., 6., 1.); // red sph\n    obj[1][1] = vec4(1., 0., 0., 1.);\n    obj[1][3][3] = OBJ_SPHERE;\n    \n    obj[2][0] = vec4(1.5, 0.8, 6., 0.8); // blue sph\n    obj[2][1] = vec4(0., 0., 1., 1.);\n    obj[2][3][3] = OBJ_SPHERE;\n    \n    obj[3][0] = vec4(-1.5, 0.8, 6., 0.8); // green sph\n    obj[3][1] = vec4(0., 1., 0., 1.);\n    obj[3][3][3] = OBJ_SPHERE;\n    \n    obj[4][0] = vec4(0., .4, 2., .4); // yellow sph\n    obj[4][1] = vec4(1., 1., 0., 1.);\n    obj[4][3][3] = OBJ_SPHERE;\n    \n    obj[5][0] = vec4(1.5, 0.6, 3., 0.6); // magenta sph\n    obj[5][1] = vec4(1., 0., 1., 1.);\n    obj[5][3][3] = OBJ_SPHERE;\n    \n    obj[6][0] = vec4(-1.5, 0.6, 3., 0.6); // cyan sph\n    obj[6][1] = vec4(0., 1., 1., 1.);\n    obj[6][3][3] = OBJ_SPHERE;\n    \n    obj[7][0] = vec4(0., 17., 0., 0.); // infinite plane at 7 Y\n    obj[7][1] = vec4(.5, 1., .5, 1.);\n    obj[7][2] = vec4(0., -1., 0., 0.);\n    obj[7][3][3] = OBJ_PLANE;\n    \n    obj[8][0] = vec4(sin(iTime), 0.6, 3., 0.6); // infinite figure\n    obj[8][1] = vec4(1., .5, 0., 1.);\n    obj[8][3][3] = OBJ_INFIG;\n    \n    for(int i = 0; i < OBJECTS; i++) {\n        //obj[i][0].x *= cos(iTime);\n        //obj[i][0].z *= sin(iTime);\n    }\n    \n    float dst = rayMarch(cam, dir);\n    \n    dir = normalize(light - p);\n    vec3 nor = getNor(o, p);\n    \n    vec3 dir2 = normalize(light2 - p);\n    \n    float colMul = clamp(dot(dir, nor), 0.4, 0.5);\n    float colMul2 = clamp(dot(dir2, nor), 0.4, 0.5);\n    float ambient = 1.;\n    \n    if(deltaDst < AMBIENT_DST) {\n        ambient = clamp(deltaDst / AMBIENT_DST, 0.8, 1.);\n    }\n    \n    vec4 c = obj[o][1];\n    vec3 collisionP = p;\n    int collisionO = o;\n    \n    float shadow = rayMarch(collisionP + (nor * MIN_DST * 2.), dir);\n    \n    if(shadow < length(light - collisionP)) {\n        colMul *= .9;\n    }\n    \n    \n    shadow = rayMarch(collisionP + (nor * MIN_DST * 2.), dir2);\n    \n    if(shadow < length(light2 - collisionP)) {\n        colMul2 *= .9;\n    }\n    \n    nor = normalize(reflect(collisionP - cam, nor));\n    if(rayMarch(collisionP + (nor * MIN_DST * 2.), nor) < 10.) {\n    \tc = (obj[o][1] * .2) + obj[collisionO][1];\n    }\n    \n    vec4 c2 = c;\n    c2.rgb *= colMul2;\n    c.rgb *= colMul;\n    \n    fragColor = (c + c2) * ambient;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2SDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 260, 288, 288, 525], [527, 527, 554, 554, 1145], [1147, 1147, 1185, 1185, 1452], [1454, 1454, 1509, 1560, 4347]]}
{"id": "3t2SzW", "name": "Diving", "author": "iq", "description": "A simple stylized 2D diver", "tags": ["2d", "sdf", "diver"], "likes": 31, "viewed": 863, "published": "Public API", "date": "1565292601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat sdStick( in vec2 p, in vec2 a, in vec2 b, in float ra, in float rb )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - (ra+(rb-ra)*h*h*(3.0-2.0*h));\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\nfloat sdBox( vec2 p, in vec2 c, vec2 b )\n{\n    vec2 d = abs(p-c) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//------------------------------------------------------------\n\nvoid legAnim( out vec2 ankle, out vec2 knee, out vec2 toes, in vec2 heap, in float t )\n{\n    float an1 =     - 0.3 + 0.3*cos(t-0.0);\n    float an2 = an1 + 0.6 + 0.6*sin(t-0.1);\n    float an3 = an2 - 0.4 - 0.6*cos(t-0.5);\n\n    knee  = heap  + 0.32*vec2(cos(an1),sin(an1)); \n    ankle = knee  + 0.30*vec2(cos(an2),sin(an2)); \n    toes  = ankle + 0.27*vec2(cos(an3),sin(an3)); \n}\n\nvec3 diver( in vec3 col, in vec2 p, in float px, float t)\n{\n    float vt = t - 0.5*cos(t);\n\n    //========================================\n    // animate\n    //========================================\n\n    // dive\n    {\n    //p += vec2(0.5,0.1)*vec2(cos(vt),sin(vt)) - vec2(-0.3,0.3);\n    p += vec2(-0.5,0.1)*vec2(cos(vt),sin(vt)) - vec2(0.0,0.3);\n    }\n    \n    // jump\n    {\n    float s = 1.6*exp(-10.0*t);\n    float an = s -0.25;\n    float co = cos(an), si = sin(an); \n    p = vec2(0.4,1.5) + mat2(co,-si,si,co)*(p-vec2(0.4,1.5));\n    }\n\n    // body\n    vec2 head = vec2(0.00, 0.10);\n    vec2 heap = vec2(0.56, 0.00);\n    vec2 shou = vec2(0.18,-0.02);\n    vec2 kneeL, ankleL, toesL;\n    vec2 kneeR, ankleR, toesR;\n    legAnim( ankleL, kneeL, toesL, heap, 10.0*vt );\n    legAnim( ankleR, kneeR, toesR, heap, 10.0*vt+3.14 );\n\n#if 0\n    vec2 elbowL = vec2( 0.05,-0.25);\n    vec2 handL  = vec2(-0.16,-0.30);\n    vec2 elbowR = vec2( 0.25,-0.25);\n    vec2 handR  = vec2( 0.14,-0.40);\n#else\n    vec2 elbowL = vec2( 0.40,-0.12);\n    vec2 handL  = vec2( 0.68,-0.18);\n    vec2 elbowR = vec2( 0.40,-0.11);\n    vec2 handR  = vec2( 0.68,-0.14);\n#endif    \n\n    \n    //========================================\n    // draw\n    //========================================\n    \n    vec2 q = p; // unbent coords\n    \n    // bend coords\n    {\n    float an = 0.25*(p.x - 0.5);\n    float co = cos(an), si = sin(an); \n    p = mat2(co,-si,si,co)*p;\n    }\n    \n    //-------------------\n    \n    {\n    // arm R\n    float d  = sdStick( p, shou,   elbowR, 0.06, 0.04 );\n    d = min(d, sdStick( p, elbowR, handR,  0.04, 0.02 ) );\n    // leg R\n    d = min(d, sdStick( p, heap, kneeR, 0.09, 0.07 ) );\n    d = min(d, sdStick( p, kneeR, ankleR, 0.07, 0.04 ) );\n    d = min(d, sdStick( p, ankleR, toesR, 0.04, 0.06 ) );\n    \n    col = mix( col, vec3(0.01,0.03,0.06), 1.0-smoothstep(-px,px,d) );\n    }\n    \n    //-------------------\n    {\n    // head\n    float d  = sdCircle( p, head, 0.11 );\n    // tank\n    d = min(d, sdBox(    q, vec2(0.48,0.18), vec2( 0.24,0.08) ) );\n    d = min(d, sdCircle( q, vec2(0.24,0.18), 0.08 ) );\n    // body\n    d = min(d, sdStick( p, vec2(0.2,0.0), vec2(0.56,0.0), 0.11, 0.091 ) );\n    // leg L\n    d = min(d, sdStick( p, heap,   kneeL,  0.09, 0.07 ) );\n    d = min(d, sdStick( p, kneeL,  ankleL, 0.07, 0.04 ) );\n    d = min(d, sdStick( p, ankleL, toesL,  0.04, 0.06 ) );\n    // arm L\n    d = min(d, sdStick( p, shou,   elbowL, 0.06, 0.04 ) );\n    d = min(d, sdStick( p, elbowL, handL,  0.04, 0.02 ) );\n \n    col = mix( col, vec3(0.005,0.015,0.03), 1.0-smoothstep(-px,px,d) );\n    }\n    \n    // bubbles\n    for( int i=0; i<10; i++ )\n    {\n        vec2 p0 = head + vec2(-0.15,0.0);\n        vec2 p1 = head + vec2( 0.4 + 0.20*sin(21.39*float(i)),0.7);\n        float h = fract( 0.85 + 0.5*(t+ 0.5*float(i)*0.12331) );\n        vec2 c = mix( p0, p1, h );\n        float d = sdCircle( p, c, 0.04*sqrt(h) );\n        \n        col += (1.0-0.8*sqrt(abs(d)/0.04)) * 0.35 * 4.0*h*(1.0-h)*(1.0-smoothstep(-px,px,d));\n    }\n    \n    return col;\n}\n\nvec3 seafloor( in vec3 col, in vec2 p, in float px, in float t )\n{\n    for( int i=0; i<4; i++ )\n    {\n        float h = float(i)/3.0;\n        float of = -0.4 - 0.4*h + (0.5+0.5*h)*0.1*sin((4.0-h*2.0)*p.x + 30.0*h - 2.5*t*(1.0+2.0*h));\n        float dof = 3.0 + 5.0*abs(float(i-2));\n        col = mix( col, vec3(0.05,0.3,0.5)*(1.0-0.9*h), 1.0-smoothstep(-px*dof, px*dof, p.y-of) );\n    }\n    return col;\n}\n\nvec3 background( in vec2 p )\n{\n    return vec3(0.05,0.3,0.5)*0.9 + p.y*0.11;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    float ani = iTime*0.2;\n\n    // draw\n    vec3 col = background( p );\n         col = seafloor( col, p, px, ani );\n         col = diver( col, p, px, ani );\n\n    // vignetting\n\tcol *= 1.0 - 0.1*dot(p,p);\n    \n    // gamma\n    col = sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2SzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 126, 202, 202, 353], [355, 355, 407, 407, 435], [437, 437, 479, 479, 563], [565, 629, 717, 717, 1005], [1007, 1007, 1066, 1066, 4038], [4040, 4040, 4106, 4106, 4444], [4446, 4446, 4476, 4476, 4524], [4526, 4526, 4583, 4583, 4963]]}
{"id": "3t2Szz", "name": "worley noise speckles", "author": "julapy", "description": "worley noise speckles", "tags": ["noise", "worley"], "likes": 5, "viewed": 127, "published": "Public", "date": "1564837633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on - https://www.shadertoy.com/view/MtXSzH\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,126.7235))) * 43758.5453);\n}\n\nfloat worley3D(vec3 p)\n{\t\t\t\t\t \t\t\t\t\t \n\tfloat r = 3.0;\n    vec3 f = floor(p);\n    vec3 x = fract(p);\n\tfor(int i = -1; i<=1; i++)\n\t{\n\t\tfor(int j = -1; j<=1; j++)\n\t\t{\n\t\t\tfor(int k = -1; k<=1; k++)\n\t\t\t{\n                vec3 q = vec3(float(i),float(j),float(k));\n    \t\t\tvec3 v = q + vec3(noise3D((q+f)*1.11), noise3D((q+f)*1.14), noise3D((q+f)*1.17)) - x;\n    \t\t\tfloat d = dot(v, v);\n\t\t\t\tr = min(r, d);\n\t\t\t}\n\t\t}\n\t}\n    return sqrt(r);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*2.0-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    p *= 50.0;\n    p.y -= iTime;\n   \t\n    float f = worley3D(vec3(p,iTime * 0.5));\n    \n    vec3 col = vec3(1.0-smoothstep(0.3, 0.6, f));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2Szz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 76, 76, 150], [152, 152, 176, 176, 582], [585, 585, 642, 642, 915]]}
{"id": "3t2XRG", "name": "Square Kaleidoscope", "author": "domorin", "description": "square kaleidoscope", "tags": ["kaleidoscope", "square"], "likes": 4, "viewed": 172, "published": "Public", "date": "1566265474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float in_square(vec2 uv, float square_size)\n{\n    // Changing this value causes some funky shit\n    float a = iTime + length(uv) * 3.141592653589 * sin(iTime * 0.12316);\n    float s = sin(a);\n    float c = cos(a);\n    \n    uv *= mat2(c, -s, s, c);\n    \n    return float(uv.x > -square_size && uv.x < square_size && uv.y > -square_size && uv.y < square_size);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec3 color = vec3(0.0,0.0,1);\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    uv *= 6.0;\n    \n    float a = iTime * 0.4 + length(uv) * 0.005 * sin(iTime * 0.25);\n    float s = sin(a);\n    float c = cos(a);\n    \n    uv *= mat2(c, -s, s, c);\n    \n    vec2 guv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float square_size = 1.00 + (sin(iTime * 0.623) + 1.0) * 0.5 * length(uv) * 0.125;    \n    \n    \n    \n    float square = 0.0;\n    for(float col = -1.0; col < 2.0; col += 1.0)\n    {\n        for(float row = -1.0; row < 2.0; row += 1.0)\n        {            \n            square += in_square(vec2(guv.x + col, guv.y + row), square_size);\n        }\n        \n    }    \n    vec3 col = 0.5 + sin(iTime + vec3(square * 0.25, square * 2.354126, square * 13.42)) * 0.5;\n    \n  \n   \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2XRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 95, 360], [363, 363, 420, 420, 1374]]}
{"id": "3t2XRm", "name": "Bones of the Jellyfish", "author": "Hirai_worthless", "description": "raymarching,pmod,etc...", "tags": ["raymarching"], "likes": 6, "viewed": 145, "published": "Public", "date": "1565422544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n    //p.xy *= genRot(PI / 12.);\n        p.xy += 5.;\n    p.xy = fract(p.xy / 10.) * 10.;\n    p.xy -= 5.;\n    \n    p = pmod(p,12.);\n    p.y -= .0;\n    p.xy *= genRot(-PI / 12.);\n    p.z += 2.;\n    p.z = fract(p.z / 4.) * 4.;\n    p.z -= 2.;\n    \n    float theta = 0.;\n    float a = 0.2;\n\tfloat begin = sin(iTime * 2. * (0.2 + rand(0.)) + 0.) * a;\n    float prev = 0.;\n    float curr = 0.;\n    float r = 1.5 + 0.2 * cos(iTime);\n    \n    float res = sphere(p,vec3(0.,0.,begin),0.15);\n    for(int i = 1; i < 5; i++){\n        res = min(res,\n                 line(p,\n                     vec3(prev,\n                          0.,\n                          sin(iTime * 2. * (0.2 + rand(prev)) + prev) * a),\n                      vec3(float(i),\n                          0.,\n                          sin(iTime * 2. * (0.2 + rand(float(i))) + float(i)) * a),\n                      0.025\n                     ));\n    \tres = min(res,sphere(p,vec3(float(i),\n                              0.,\n                              sin(iTime * 2. * (0.2 + rand(float(i))) + float(i)) * a)\n                             ,0.15));\n        prev = float(i);\n    }\n    return res;\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(-2.0 * sin(-iTime* PI / 8.),-2.0 * cos(-iTime* PI / 8.),-5. + iTime*0.75 );\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.yz *= genRot(-PI/8.);\n    ray.xz *= genRot(-PI/8.);\n    ray.xy *= genRot(iTime * PI / 8.);\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.75;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.025);\n    float a = dot(data.xyz,r);\n    vec3 fc = mix(vec3(0.95),vec3(1. + a),fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2XRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 354, 354, 537], [540, 554, 590, 590, 619], [621, 621, 659, 659, 688], [690, 690, 723, 723, 870], [872, 872, 915, 915, 1071], [1074, 1091, 1109, 1141, 2261], [2263, 2281, 2305, 2305, 2557], [2559, 2579, 2600, 2600, 2691], [2693, 2707, 2734, 2734, 2886], [2888, 2903, 2931, 2931, 3131], [3133, 3148, 3180, 3180, 3403], [3405, 3416, 3473, 3490, 3840]]}
{"id": "3t2XWR", "name": "draw-math-cloud", "author": "lilieming", "description": "math cloud", "tags": ["mathcloud"], "likes": 2, "viewed": 75, "published": "Public", "date": "1565590584", "time_retrieved": "2021-10-01T00:00:00", "image_code": " vec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\n   vec4 mod289(vec4 x) { \n    return x - floor(x * (1. / 289.)) * 289.;\n}\n vec4 permute(vec4 x) { return mod289(((x*34.)+1.)*x); }\n vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - .85373472095314 * r; }\n  vec3 fade(vec3 t) { return t*t*t*(t*(t*6.-15.)+10.); }\nfloat noise(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.)),\n       f0 = fract(P), f1 = f0 - vec3(1.), f = fade(f0);\n     vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy),\n          iz0 = i0.zzzz, iz1 = i1.zzzz,\n        ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1),\n          gx0 = ixy0 * (1. / 7.), gy0 = fract(floor(gx0) * (1. / 7.)) - .5,\n          gx1 = ixy1 * (1. / 7.), gy1 = fract(floor(gx1) * (1. / 7.)) - .5;\n     gx0 = fract(gx0); gx1 = fract(gx1);\n     vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.)),\n          gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.));\n     gx0 -= sz0 * (step(0., gx0) - .5); gy0 -= sz0 * (step(0., gy0) - .5);\n     gx1 -= sz1 * (step(0., gx1) - .5); gy1 -= sz1 * (step(0., gy1) - .5);\n     vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n          g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n          g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n          g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n     vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3))),\n          norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n     g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n     g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n     vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n                       dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n                   vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n                        dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n     return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n  }\n  float turbulence(vec3 P) {             // Turbulence is a fractal sum of abs(noise).\n     float f = 0., s = 1.;              // The domain is rotated after every iteration\n     for (int i = 0 ; i < 9 ; i++) {      //    to avoid any visible grid artifacts.\n        f += abs(noise(s * P)) / s;\n        s *= 2.;\n        P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);\n      }\n      return f;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\n   float c = 0.;\n\n    // BUILD A FRACTAL TEXTURE USING\n    // NOISE THAT ANIMATES THROUGH Z\n\n    float x = uv.x+ iTime*.2;\n    float y = uv.y;\n    for (int n = 1 ; n <= 5 ; n++) {\n       float z = float(n);\n       vec3 p = vec3(x, y, z + 0.05 * iTime);\n       float frequency = pow(2., z);\n       c +=(noise(frequency*p)/frequency);\n    }\n\n    // CLOUDS SHOT WITH COLOR\n\n    vec3 sky   = vec3(.1, .3, .9);\n    vec3 white = vec3(1.,1.,1.);\n    vec3 pink  = vec3(1.,.5,.5);\n    vec3 cloud = mix(pink,white*.0,c);\n    c = clamp(c + y, 0.0, 1.0);\n    vec3 color = mix(sky, cloud, c);\n    // Output to screen\n    fragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2XWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 66], [70, 70, 91, 91, 140], [142, 142, 164, 164, 197], [199, 199, 227, 227, 276], [279, 279, 298, 298, 333], [334, 334, 355, 355, 2194], [2197, 2197, 2223, 2281, 2611], [2614, 2614, 2671, 2721, 3411]]}
{"id": "3t2Xzy", "name": "Belt Trick", "author": "_polymath", "description": "based on https://en.wikipedia.org/wiki/File:Belt_Trick.ogv", "tags": ["raymarcher"], "likes": 9, "viewed": 417, "published": "Public API", "date": "1566304770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITERS 300.0\n#define LENFACTOR .25\n#define NDELTA 0.001\n\n// #define GRIDCOLS\n#define LIGHTING\n// #define NORMALS\n#define COLOURS\n//#define SPINCAM\n#define SPINSPEED 0.3\n//#define SPINUP\n//#define DRAW_AXIS\n\n#define NDELTAX vec3(NDELTA, 0., 0.)\n#define NDELTAY vec3(0., NDELTA, 0.)\n#define NDELTAZ vec3(0., 0., NDELTA)\n\nfloat box(vec3 p, vec3 centre, vec3 dims) {\n    vec3 d = abs(p - centre) - dims;\n    return max(d.x, max(d.y, d.z));\n}\n\nconst vec3 rDir = normalize(vec3(-3.0, 4.0, -2.0)), rCol = vec3(1.0, 0.6, 0.4),\n    bDir = normalize(vec3(2.0, 3.0, -4.0)), bCol = vec3(0.3, 0.7, 1.0),\n    gDir = normalize(vec3(4.0, -3.0, 0.0)), gCol = vec3(0.7, 1.0, 0.8);\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    // axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, // 0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, // 0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);          // 0.0,\n               // 0.0,                                0.0,                                0.0,                                1.0);\n}\n\nconst float pi = 3.1415926536;\n\nmat2 rot(float t) {\n\tfloat s = sin(t), c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\nvec3 axis() {\n    return vec3(\n        cos(iTime * SPINSPEED),\n        0.,\n        sin(iTime * SPINSPEED));\n}\n\nvec3 rotSpace(vec3 p) {\n    // rotate space!!!\n    float angle = pi * pow(smoothstep(100., 2., dot(p, p)), 5.);\n    #ifdef SPINUP\n    \tangle *= smoothstep(10.0, 15.0, iTime);\n    #endif\n    if (angle <= 0.) return p;\n    return p * rotationMatrix(axis(), angle);\n}\n\nfloat scene(vec3 p) {\n    p = rotSpace(p);\n    \n    float l = iTime * 0.2 - .2;\n    l = max(0., min(pow(l, 6.), 1000.));\n    float d = min(box(p, vec3(0.), vec3(0.7, 0.1, l)),\n              min(box(p, vec3(0.), vec3(0.1, l, 0.7)),\n              min(box(p, vec3(0.), vec3(l, 0.7, 0.1)),\n                  box(p, vec3(0.), vec3(1.))\n              )));\n    #ifdef DRAW_AXIS\n    \tvec3 a = axis();\n    \td = min(d, length(cross(p, a)) - 0.1);\n    #endif\n    return d;\n}\n    \nvec3 sceneNormal(vec3 p) {\n    return normalize(vec3(\n        scene(p + NDELTAX) - scene(p - NDELTAX),\n        scene(p + NDELTAY) - scene(p - NDELTAY),\n        scene(p + NDELTAZ) - scene(p - NDELTAZ)\n\t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.));\n    ray.yz *= rot(-0.12);\n    ray.xz *= rot(-0.7853981634);\n    vec3 cam = vec3(10., 2., -10.);\n    #ifdef SPINCAM\n    \tcam.xz *= rot(pi * 0.75 - iTime * SPINSPEED);\n    \tray.xz *= rot(pi * 0.75 - iTime * SPINSPEED);\n    #endif\n    \n    vec3 pos = cam;\n    float i = 0.;\n    for (; i < MAXITERS; ++i) {\n        float dist = scene(pos);\n        if (dist < 0.001) break;\n        pos += ray * dist * LENFACTOR;\n    }\n\n    #ifdef GRIDCOLS\n    \tfragColor = vec4(fract(pos), 1.);\n    #endif\n    \n    #ifdef NORMALS\n    \tfragColor = vec4(sceneNormal(pos) * 0.5 + 0.5, 1.);\n    #endif\n    \n    #ifdef LIGHTING\n        vec3 col = vec3(1.);\n        #ifdef COLOURS\n            vec3 p2 = rotSpace(pos);\n            if (abs(p2.x) > 1.001) col = vec3(1., .757, .224);\n            else if (abs(p2.y) > 1.001) col = vec3(0., .576, .5255);\n            else if (abs(p2.z) > 1.001) col = vec3(.2902, .204, .365);\n        #endif\n    \tfragColor = vec4(col * (\n            rCol * abs(dot(rDir, sceneNormal(pos))) +\n            gCol * pow(dot(gDir, sceneNormal(pos)), 5.) +\n            bCol * abs(dot(bDir, sceneNormal(pos)))\n        ), 1.0) * (1.0 - pow(i / 300., 2.));\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2Xzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 329, 372, 372, 447], [674, 748, 793, 824, 1433], [1467, 1467, 1486, 1486, 1549], [1551, 1551, 1564, 1564, 1660], [1662, 1662, 1685, 1708, 1926], [1928, 1928, 1949, 1949, 2391], [2397, 2397, 2423, 2423, 2603], [2606, 2606, 2663, 2663, 3927]]}
{"id": "3tBSDR", "name": "Anisotropic & Diffract Color", "author": "bearworks", "description": "Based on https://www.shadertoy.com/view/4sSSW3 and GPU Gems Chapter 8. Simulating Diffraction", "tags": ["anisotropic", "diffract", "tangentspace"], "likes": 7, "viewed": 162, "published": "Public", "date": "1565772704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Based on Cheap orthonormal basis by nimitz\n//and GPU Gems Chapter 8. Simulating Diffraction\n\n//#define HANDLE_SINGULARITY\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n#define Diffract 1\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\nvec3 blend3 (vec3 x)\n{\n    vec3 y = 1. - x * x;\n    y = max(y, vec3 (0., 0., 0.));\n    return (y);\n}\n\nvec3 colormap(float u)\n{\n   if (u < 0.) u = -u;\n\n   vec3 cdiff = vec3(0., 0., 0.);\n   for (float n = 1.; n < 8.; n+=1.)\n   {\n     float y = 2. * u / n - 1.;\n     cdiff += blend3(vec3(0.85 * (y - 0.75), 2.6 * (y - 0.5),\n                                0.95 * (y - 0.25)));\n   }\n    \n    return cdiff;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5* cos(time), 0.2, -0.2 * sin(time)) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 r = vec3(0);vec3 f = vec3(0);\n        basis(nor,f,r);\n        \n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        #if Diffract\n        float e1 = dot(normalize(rd + ligt), f) / dot(reflect(rd,nor), ligt);\n        float spe1 = exp(-e1*e1);\n        float e = dot(normalize(rd + ligt), f);\n        float spe = e;\n        col = col*brdf + col*(colormap(spe) + spe1*vec3(1.5,0.4,1.3)) + fre*col;\n        #else\n        float spe = pow(clamp(dot(normalize(rd + ligt), f) / dot(reflect(rd,nor), ligt), 0., 1.),10.);\n        col = col*brdf + col*spe + fre*col;\n        #endif\n    }\n    \n    \n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 195, 216, 216, 268], [270, 270, 289, 289, 359], [361, 361, 398, 398, 627], [629, 629, 659, 659, 821], [823, 935, 982, 982, 1421], [1423, 1423, 1445, 1445, 1523], [1525, 1525, 1549, 1549, 1826], [1829, 1829, 1886, 1886, 3590]]}
{"id": "3tBSR3", "name": "Small Mandelbrot Set", "author": "danilolc", "description": "Just a simple mandelbrot set.", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 244, "published": "Public API", "date": "1566500682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float MAX = 20.0;\n\nvec2 po(vec2 z) {\n    return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n}\n\nvec4 mende( vec2 pos ) {\n    MAX = 13.0 * iTime;\n    \n    vec2 z = pos;\n    \n    float i = 0.0;\n    \n    for(i = 0.0; i < MAX; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n        z += pos;\n        if (length(z) > 2.0) break;\n    }\n    \n    float t = cos(iTime);\n    i /= MAX;\n    return vec4(i, log(length(z)), i / length(z), 1.0);\n    \n}\n\nvec2 trata (vec2 idiota) {\n    idiota /= iResolution.xy;\n    idiota =  idiota * 2.0 - 1.0;\n    idiota.x *= iResolution.x / iResolution.y;\n    return idiota;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = trata(fragCoord);\n\t//vec2 mouse = trata(iMouse.xy);\n    \n    //vec2 zoom = vec2(-0.749755,0.1006);\n    vec2 zoom = vec2(-0.745816,0.1050918);\n    \n    uv /= exp(iTime-1.0);\n    //uv += trata(iMouse.xy * uv.x);\n    uv += zoom;\n    \n    // Output to screen\n    fragColor = mende(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 36, 36, 95], [97, 97, 121, 121, 456], [458, 458, 484, 484, 616], [618, 618, 675, 725, 1023]]}
{"id": "3tBXDR", "name": "Hole and Protrusions", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 3, "viewed": 363, "published": "Public", "date": "1565511287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n    float inner = length(p.xy) - 1.0 - 0.15 * sin(p.z);\n    float at = atan(p.y/p.x);\n    inner -= 0.1 *cos(at * 2.0 + p.z * PI);\n    vec3 q = p;\n    q.xy *= genRot(PI/8. + p.z);\n    q = pmod(q,8.);\n    q.xy *= genRot(-PI/8.);\n    q.z = (fract(q.z / 1.0 + 0.5)-0.5) * 1.0 ;\n    float pole = max(length(q.yz) - 0.05 * (1./1. + pow(q.x,4.) * 4.),-q.x + 0.6);\n    return min(-inner,pole);\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(0.,0.,-2.0 + iTime * 2.0);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.xz *= genRot(PI / 12.);\n    ray.yz *= genRot(PI / 12.);\n    ray.xy *= genRot(iTime);\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 256; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    float a = dot(data.xyz,r);\n    vec3 p = o + r * t;\n    vec3 fc = min(fract(p.x),fract(p.z))<0.03 ? vec3(0.95) : vec3(0.05);\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    fc = mix(vec3(0.95),fc,fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 369, 369, 443], [445, 445, 471, 471, 654], [657, 671, 707, 707, 736], [738, 738, 776, 776, 805], [807, 807, 840, 840, 987], [989, 989, 1032, 1032, 1188], [1191, 1208, 1226, 1226, 1614], [1616, 1634, 1658, 1658, 1910], [1912, 1932, 1953, 1953, 1995], [1997, 2011, 2038, 2038, 2184], [2186, 2201, 2229, 2229, 2429], [2431, 2446, 2485, 2485, 2827], [2829, 2840, 2897, 2914, 3266]]}
{"id": "3tBXW1", "name": "大龙猫 - Quicky#006", "author": "totetmatt", "description": "Neon light remembers me of Macau Night", "tags": ["neon", "quickly"], "likes": 3, "viewed": 646, "published": "Public API", "date": "1565695267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define clock time/5.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n    \n    uv.x += tan(abs(uv.x)*5.);\n    \n    float d = fract(10.*uv.x+clock);\n    d = smoothstep(0.2,0.10,d);\n    \n    float p = tan(uv.x+time);\n    vec3 col = mix(vec3(0.1,0.1,0.1),vec3(p*0.1+step(.1,abs(cos(clock*2.))*uv.x),p*0.9,0.1+step(1.,sin(clock)*sin(clock)*abs(uv.x))),d);\n   \n    fragColor = vec4(\n        col,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 501]]}
{"id": "3tBXWc", "name": "ShaderDojo 036", "author": "antonOTI", "description": "Playing with my shader from yesterday", "tags": ["raymarching", "volume", "experiment", "training"], "likes": 4, "viewed": 268, "published": "Public API", "date": "1567245720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define RID(p, r) (floor((p + r/2.) / r))\n#define REP(p, r) (mod(p + r/2., r) - r /2.)\n\n//from https://www.shadertoy.com/view/XlfGzr\nfloat random(float p) {\n  \treturn fract(sin(p)*1e5);\n}\n\nfloat hash21(vec2 p) {\n  \treturn random(p.x + p.y*1e5);\n}\n\n// hash and noise from shane's : https://www.shadertoy.com/view/ldscWH\nvec3 hash33(vec3 p) { \n\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    \n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n  \n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); \n}\n\n// from iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a)\n{\n    float ca = cos(a); float sa = sin(a);\n    return mat2(ca,-sa,sa,ca);\n}\n\nfloat overCurve(float t)\n{\n    return sin(t * PI * .5);\n}\n\nfloat underCurve(float t)\n{\n    return 1. - cos(t * PI * .5);\n}\n\nfloat map(vec3 p)\n{\n    vec3 cp = p;\n    //p.xz *= rot(iTime * .25);\n    \n    float volNoise = tetraNoise(p * .1125 - vec3(0.,0.,-iTime * 2.5));\n    volNoise = overCurve(volNoise);\n    volNoise = volNoise * volNoise  * 4.;\n    float dist =3.95 - volNoise;\n    \n    float repSize = 10.;\n    vec2 rid = RID(p.xy, repSize);\n    p.xy = REP(p.xy, repSize);\n    \n    float cellNoise = hash21(rid);\n    \n    float cylRadius = overCurve(sin(iTime * 2. + p.z * .1 + cellNoise * 10.) * .5 + .5) * 3.;\n    float cyl = cylRadius - length(p.xy + vec2(cellNoise * 2.));\n    cyl = clamp(cyl,0.,1.);\n    dist *= cyl;\n    p = cp;\n    dist *= clamp(length(p.xy) - repSize*.5,0.,1.);\n    //p = abs(p);\n\t//float cu = max(p.x, max(p.y, p.z));\n\t//    dist = min(dist, 3. - cu);\n    \n    return dist;\n}\n\nfloat volRay(in vec3 ro, in vec3 rd, float maxDist)\n{\n\tfloat nbSample = 60.;\n    float acc = 0.;\n    \n    for(float i = 1.; i > 0.; i -= 1. / nbSample)\n    {\n        vec3 p = ro + rd * maxDist * i;\n        acc += max(0., map(p)) / nbSample;\n        if(acc >= 1.)\n        {\n          //  break;\n        }\n    }\n    \n    return clamp(acc, 0. ,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\n    vec3 ro = vec3(0.,0.,-10.);\n    vec3 cp = ro;\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float vol = volRay(ro, rd, 100.);\n\tvol *= 2.;\n    vol *= vol;\n    vec3 noColor = vec3(0.,0.,0.);\n    vec3 fullColor = vec3(.6,.4,.37) * 2.;\n    \n    vec3 col = mix(noColor, fullColor, vol);\n\n    // Output to screen\n    fragColor = vec4(col, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 153, 176, 176, 207], [209, 209, 231, 231, 266], [268, 339, 360, 360, 472], [474, 474, 503, 503, 1014], [1016, 1027, 1070, 1070, 1170], [1172, 1172, 1191, 1191, 1266], [1268, 1268, 1294, 1294, 1325], [1327, 1327, 1354, 1354, 1390], [1392, 1392, 1411, 1411, 2171], [2173, 2173, 2226, 2226, 2520], [2522, 2522, 2579, 2629, 3039]]}
{"id": "3tBXWz", "name": "Skewed", "author": "104", "description": "What even is this?", "tags": ["2d", "glitch"], "likes": 3, "viewed": 99, "published": "Public", "date": "1565532937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy,\n    u=C/R*2.;\n    u.x *= R.x / R.y;\n    float t = iTime*.4;\n    for (float i = 1.; i <= 6.; ++ i ){\n        vec4 c = hash42(floor(u));\n        u +=u+t+u.yx*(c.xy-.5);// skew + scale\n        o = i<2.? c+.5 : c.w>.5? o: o * c / (i-1.);// selectively accept color\n    }\n    C=fract(C/3.);\n    o = mix(step(.1,o),o,C.y)*C.y*2.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 169], [171, 171, 208, 208, 563]]}
{"id": "3tjGzd", "name": "Inside the Helix", "author": "holtsetio", "description": "Recursive Helix made out of torii", "tags": ["tunnel", "raymarcher", "helix"], "likes": 19, "viewed": 224, "published": "Public", "date": "1566674522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Parameters\n#define outerT 3.5\n#define FUZZ 0.50\n#define PHASELENGTH 30.0\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define EPSILON 0.0005\n#define KEPLER_MAXITER 2\n#define MAXSTEPS 150\n#define MAXDIST 95.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n\n\nvec3 glow = vec3(0);\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 buildtransform(vec3 point, float off, vec3 trans, bool isNeg) {\n    vec3 zaxis = normalize(point);\n    vec3 xaxis = normalize(vec3(zaxis.z, 0.0, -zaxis.x));\n    if (!isNeg && zaxis.x < 0.0) {\n        xaxis *= -1.0;\n    }\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0,\n                xaxis.y, yaxis.y, zaxis.y, 0,\n                xaxis.z, yaxis.z, zaxis.z, 0,\n                dot(xaxis,trans),dot(yaxis,trans),dot(zaxis,trans)+off,1);\n}\n\n   \nfloat solveKeplerHalley(float e,float M) {\n    float E =clamp(M+PI,0.00,PI);\n    int i=0;\n    while(i<KEPLER_MAXITER) {\n        float esinE = e*sin(E);\n        float k0mM = (E-esinE)-M;\n        float k1 = (1.0-e*cos(E));\n        E -= (2.0*k0mM*k1)/(2.0*k1*k1-k0mM*(esinE));\n        i++;\n    }\n    return E;\n}\n\nfloat solveKepler(float e, float M) {\n    //http://www.jgiesen.de/kepler/kepler.html\n    if (e >= 1.0) {\n        return solveKeplerHalley(e,M);\n    }\n    float E = (e < 0.8 ? M : PI);\n    float F = E - e*sin(M)-M;\n    int i = 0;\n    while (i < KEPLER_MAXITER) {\n    \tE -= F/(1.0 - e*cos(E));\n        F = E - e*sin(E) - M;\n        i++;\n    }\n\treturn E;\n}\n\nstruct HelixHit {\n\tvec4 p;\n    float strand;\n    float theta;\n};\n\n// Computes the closest point to p on a Helix (R,T) with n strands.\n// The returned struct contains the closest point, the strand and the point Theta on the helix.\nHelixHit ClosestPointHelixStep(vec4 p, float R, float T, float n_helices, float stepsize,float offset) {\n    // Nievergelt 2009\n    // doi: 10.1016/j.nima.2008.10.006\n    \n    //Helix: H(Theta) = [R*cos(Theta), R*sin(Theta), T*Theta]\n    //Point: D = (u, v, w) = [r * cos(delta), r * sin(delta), w]\n    HelixHit res;\n    float delta = atan(p.y, p.x);\n    float r = length(p.yx);\n    float kt = ((p.z/T)-delta)/TWOPI;\n    float inv_n_helices = 1.0/n_helices;\n    float n = floor((fract(kt) + 0.5*inv_n_helices)/inv_n_helices -0.5);\n    float s_offset = -(n+0.5)*inv_n_helices*TWOPI;\n    float dktp = delta + round(kt-(n+0.5)*inv_n_helices) * TWOPI; \n    float M = PI + (p.z/T) + s_offset - dktp;\n    float e = (r*R)/(T*T);\n    float E = solveKepler(e,M);\n    float Theta = E - PI + dktp;\n    Theta = round((Theta-s_offset+offset)/stepsize)*stepsize+s_offset-offset;\n    \n    res.theta = (Theta-s_offset);\n    res.strand=n;\n    res.p = vec4(R*cos(Theta), R*sin(Theta), res.theta*T,1.0);\n    res.theta += s_offset;\n    \n    \n    return res;\n}\n\nstruct TorusHit {\n  \tvec4 p;\n  \tfloat angle;\n};\n\nTorusHit sdTorus(vec4 pos, float r1)\n{\n  \tTorusHit hit;\n  \thit.angle = atan(pos.y,pos.x);\n  \thit.p = vec4(normalize(pos.xy)*r1,0,1);\n    return hit;\n}\n\nstruct Result {\n\tfloat dist;\n    vec4 n;\n};\nResult ED(vec4 p) {\n    float T = outerT;\n    HelixHit hit = ClosestPointHelixStep(p,4.0,T,3.0,PI/6.5,PHASE*TWOPI);\n\n    Result res;\n    \n    vec3 lookDir = (vec3(hit.p.y,-hit.p.x,-T));\n    mat4 transform = buildtransform(lookDir.xyz,0.0,-hit.p.xyz,true);\n    TorusHit hit2 = sdTorus(transform*p,1.7);\n    \n    vec3 lookDir2 = (vec3(hit2.p.y,-hit2.p.x,0));\n    transform = buildtransform(lookDir2.xyz,-hit2.angle*1.7,-hit2.p.xyz,false) * transform;\n    float T2 = 0.34;\n    HelixHit hit3 = ClosestPointHelixStep(transform*p,0.6,T2,2.0,PI/10.0,0.0);\n    \n    glow += normalize(vec3(0.8 + 0.4*sin(2.0*PHASE*TWOPI+0.75*PI),1.0,0.6+0.4*sin(PHASE*TWOPI))) * pow(max(0.0,(1.0-1.0*length(hit3.p - transform*p))),2.0) * 0.031;\n    \n    vec3 lookDir3 = (vec3(hit3.p.y,-hit3.p.x,-T2));\n    transform = buildtransform(lookDir3.xyz,0.0,-hit3.p.xyz,true) * transform;\n    TorusHit hit4 = sdTorus(transform*p,0.15+0.05*hit3.strand*0.0+0.05*sin(15.0*PHASE*PI*2.0+hit3.theta*2.0+1.0*hit3.strand*3.14159));\n    \n    \n    mat4 inv = inverse(transform);\n    res.dist = distance(p,inv*hit4.p)-0.043*2.00;\n    res.n = inv*normalize(transform*p-hit4.p);\n\treturn res;\n}\n\nvec3 raymarch(vec4 orig, vec4 dir) {\n    float dist = 0.0;\n    float minDist = 1e9;\n    int steps = 0;\n    vec4 pos = orig;\n    Result res;\n    res.dist = 1e9;\n    \n    while (dist < MAXDIST && steps < MAXSTEPS && res.dist >= EPSILON) {\n    \tres = ED(pos);\n        minDist = min(minDist,res.dist);\n        \n        dist += FUZZ*res.dist;\n        \n        pos = orig + dist*dir;\n    \tsteps++;\n    }\n    glow = pow(glow,vec3(1.2));\n    return pow(1.0-glow,vec3(1.0+4.0*dist/MAXDIST));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x * PI * 0.5;\n    \n    vec4 raydir = normalize(vec4(sin(uv.x),1.0,-sin(uv.y),0.0));\n    vec4 rayorig = vec4(0.0,0.0,2.0*PHASE*TWOPI*outerT,1);\n    \n    vec2 rot = (iMouse.xy / iResolution.xy - 0.5) * 2.0 * PI;\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n    \trot = vec2(0,0);\n    rot += vec2(0.0,-0.5)*PI;\n    \n    mat4 m = rotationY(-rot.x) * rotationX(rot.y);\n    raydir = m * raydir;\n\n    fragColor = vec4(raymarch(rayorig, raydir),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 283, 317, 317, 456], [458, 458, 492, 492, 628], [630, 630, 664, 664, 797], [799, 799, 867, 867, 1277], [1283, 1283, 1325, 1325, 1591], [1593, 1593, 1630, 1677, 1946], [2014, 2178, 2282, 2476, 3217], [3268, 3268, 3306, 3306, 3418], [3464, 3464, 3483, 3483, 4610], [4612, 4612, 4648, 4648, 5096], [5098, 5098, 5155, 5155, 5653]]}
{"id": "3tjSDG", "name": "Color from Trig", "author": "gressettd", "description": "Experimenting with an idea that pattern functions return \"color control\" info, different perspectives on the same pattern. This drives the color mapping functions. This should increase the complexity / richness of even simple patterns, in this case trig.", "tags": ["wave", "color"], "likes": 2, "viewed": 58, "published": "Public", "date": "1566950371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float scale = 1.0;\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\nvec4 ComputeWaveGradientPattern(\n\tvec2 p,\n\tint hv,\n\tfloat bias, float scale, float freq, float phase)\n{\n\tfloat ts = (float(hv) * p.x) + (1.0 - float(hv) * p.y);\n\tfloat tc = (float(hv) * p.y) + (1.0 - float(hv) * p.x);\n\tfloat svalue = bias + (scale * sin(6.28 * (freq * ts + phase)));\n\tfloat cvalue = bias + (scale * cos(6.28 * (freq * tc + phase)));\n\tfloat angle = atan(p.y, p.x);\n\tfloat angleBand = (0.5 * cos(10.0 * 6.28 * angle)) + 1.0;\n\treturn vec4(svalue,cvalue,angle,angleBand);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= float(iResolution.x) / float(iResolution.y);\n    \n    uv *= 1.0 / scale;\n\n    float maxRes = max(float(iResolution.x), float(iResolution.y));\n    \n    float tm = iTime *0.31;\n    \n    \n    \n    vec4 bias = vec4(0.350,0.906,0.689,1.0);\n    vec4 scale = vec4(0.772,0.114,0.263,1.0);\n    vec4 freq = vec4(0.077,0.368,1.016,1.0);\n    vec4 phase = vec4(3.859,3.252,5.857,1.0);\n    \n    vec4 pattern = ComputeWaveGradientPattern(uv + (iTime), \n                                              0,\n                                              (bias.x *tm),\n                                              (scale.x * tm),\n                                              freq.x,\n                                              phase.x);\n        \n    \n    \n    vec4 baseColor = ComputeWaveGradientRGB((pattern.x * tm),bias,scale, freq, phase);\n\tvec4 accent0 = ComputeWaveGradientRGB((pattern.y * tm),bias,scale, freq, phase);\n    vec4 accent1 = ComputeWaveGradientRGB(fract(pattern.z*tm),bias,scale, freq, phase);\n    vec4 accent2 = ComputeWaveGradientRGB(fract(pattern.w*tm),bias,scale, freq, phase);\n    \n    \n    vec4 finalColor = (baseColor + accent0 + accent1 + accent2) / 4.0;\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjSDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 110, 110, 214], [217, 217, 320, 320, 703], [708, 708, 765, 815, 2061]]}
{"id": "3tjSDW", "name": "rayMarching learn #4", "author": "dnkorbut", "description": "continue learning raymarching", "tags": ["raymarching", "raymarch", "infinite"], "likes": 1, "viewed": 56, "published": "Public", "date": "1565900000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH 640\n#define MAX_DST 100.\n#define MIN_DST .01\n#define AMBIENT_DST .05\n\n#define OBJ_PLANE .5\n#define OBJ_SPHERE .51\n#define OBJ_INFIG .52\n\n#define OBJECTS 9\n\nmat4 obj[OBJECTS];\n\n// globals\nvec3 p;\nint o;\nfloat deltaDst;\n\nvec3 getNor(int o, vec3 p) {\n    if(obj[o][3][3] < OBJ_SPHERE) {\n        return obj[o][2].xyz;\n    }else if(obj[o][3][3] < OBJ_INFIG) {\n    \treturn normalize(p - obj[o][0].xyz);\n    }else{\n        return normalize(p - obj[o][0].xyz);\n    }\n}\n\nfloat getDistance(vec3 p) {\n    float min = 255.;\n    float res;\n    for(int c = 0; c < OBJECTS; c++) {\n        \n        if(obj[c][3][3] < OBJ_SPHERE) {\n            res = abs(p.y - obj[c][0][1]); // plane\n        }else if(obj[o][3][3] < OBJ_INFIG) {\n            res = length(p - obj[c][0].xyz) - obj[c][0].w; // sphere\n        }else{\n         \tres = length(sin(p) - obj[c][0].xyz) - obj[c][0].w; // infinite figere\n        }\n        \n        if(min > res) {\n            deltaDst = min - res;\n            min = res;\n            o = c;\n        }\n        \n    }\n    return min;\n}\n\nfloat rayMarch(vec3 start, vec3 dir) {\n    float ret = 0.;\n    int i;\n    float dst;\n    \n    for(i = 0; i < MAX_MARCH; i++) {\n        p = start + dir * ret;\n        dst = getDistance(p);\n        ret += dst;\n        if(ret > MAX_DST || dst < MIN_DST) {\n           break; \n        }\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // light\n    vec3 light = vec3(sin(iTime) * 10., 6., cos(iTime) * 10. + 10.);\n    vec3 light2 = vec3(sin(iTime + 3.14) * 10., 6., cos(iTime + 3.14) * 10. + 10.);\n    \n    // camera\n    vec3 cam = vec3(0., 1., 0.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // objects\n    obj[0][0] = vec4(0., .2, 0., 0.); // infinite plane at zero Y\n    obj[0][1] = vec4(.5, .5, .5, 1.);\n    obj[0][2] = vec4(0., 1., 0., 0.);\n    obj[0][3][3] = OBJ_PLANE;\n    \n    obj[1][0] = vec4(0., 1., 6., 1.); // red sph\n    obj[1][1] = vec4(1., 0., 0., 1.);\n    obj[1][3][3] = OBJ_SPHERE;\n    \n    obj[2][0] = vec4(1.5, 0.8, 6., 0.8); // blue sph\n    obj[2][1] = vec4(0., 0., 1., 1.);\n    obj[2][3][3] = OBJ_SPHERE;\n    \n    obj[3][0] = vec4(-1.5, 0.8, 6., 0.8); // green sph\n    obj[3][1] = vec4(0., 1., 0., 1.);\n    obj[3][3][3] = OBJ_SPHERE;\n    \n    obj[4][0] = vec4(0., .4, 2., .4); // yellow sph\n    obj[4][1] = vec4(1., 1., 0., 1.);\n    obj[4][3][3] = OBJ_SPHERE;\n    \n    obj[5][0] = vec4(1.5, 0.6, 3., 0.6); // magenta sph\n    obj[5][1] = vec4(1., 0., 1., 1.);\n    obj[5][3][3] = OBJ_SPHERE;\n    \n    obj[6][0] = vec4(-1.5, 0.6, 3., 0.6); // cyan sph\n    obj[6][1] = vec4(0., 1., 1., 1.);\n    obj[6][3][3] = OBJ_SPHERE;\n    \n    obj[7][0] = vec4(0., 7., 0., 0.); // infinite plane at 7 Y\n    obj[7][1] = vec4(.5, 1., .5, 1.);\n    obj[7][2] = vec4(0., -1., 0., 0.);\n    obj[7][3][3] = OBJ_PLANE;\n    \n    obj[8][0] = vec4(-1.5, 0.6, 3., 0.6); // infinite figure\n    obj[8][1] = vec4(1., 5., 0., 1.);\n    obj[8][3][3] = OBJ_INFIG;\n    \n    for(int i = 0; i < OBJECTS; i++) {\n        //obj[i][0].x *= cos(iTime);\n        //obj[i][0].z *= sin(iTime);\n    }\n    \n    float dst = rayMarch(cam, dir);\n    \n    dir = normalize(light - p);\n    vec3 nor = getNor(o, p);\n    \n    vec3 dir2 = normalize(light2 - p);\n    \n    float colMul = clamp(dot(dir, nor), 0.3, 0.5);\n    float colMul2 = clamp(dot(dir2, nor), 0.3, 0.5);\n    float ambient = 1.;\n    \n    if(deltaDst < AMBIENT_DST) {\n        ambient = clamp(deltaDst / AMBIENT_DST, 0.8, 1.);\n    }\n    \n    vec4 c = obj[o][1];\n    vec3 collisionP = p;\n    int collisionO = o;\n    \n    float shadow = rayMarch(collisionP + (nor * MIN_DST * 2.), dir);\n    \n    if(shadow < length(light - collisionP)) {\n        colMul *= .9;\n    }\n    \n    \n    shadow = rayMarch(collisionP + (nor * MIN_DST * 2.), dir2);\n    \n    if(shadow < length(light2 - collisionP)) {\n        colMul2 *= .9;\n    }\n    \n    nor = normalize(reflect(collisionP - cam, nor));\n    if(rayMarch(collisionP + (nor * MIN_DST * 2.), nor) < 10.) {\n    \tc = (obj[o][1] * .2) + obj[collisionO][1];\n    }\n    \n    vec4 c2 = c;\n    c2.rgb *= colMul2;\n    c.rgb *= colMul;\n    \n    fragColor = (c + c2) * ambient;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 237, 265, 265, 478], [480, 480, 507, 507, 1056], [1058, 1058, 1096, 1096, 1363], [1365, 1365, 1420, 1471, 4249]]}
{"id": "3tjSDz", "name": "kojdj_RaymarchingTest1", "author": "kojdj0811", "description": "Raymarching Test", "tags": ["raymarching"], "likes": 1, "viewed": 71, "published": "Public", "date": "1565626020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define SETP_MAX 32\n\n#define NEAR 0.02\n#define FAR 50.0\n\n#define OFFSET_TO_NORMAL 0.01\n\n\n\nvec3 Background (vec2 uv) {\n    uv.x -= iTime * 0.5 + sin(iTime * 0.2);\n    uv.y -= iTime * 0.1 + sin(iTime * 0.7);\n    \n\tfloat offsetR = sin(iTime * 2.0 + PI * 0.0);\n    float offsetG = sin(iTime * 2.0 + PI * 0.33333333) ;\n    float offsetB = sin(iTime * 2.0 + PI * 0.66666666) ;\n\n    vec3 col = vec3(abs(sin(uv.x * 50.0)) * offsetR,\n                    abs(sin(uv.x * 50.0 + PI * 0.33333333)) * offsetG,\n                    abs(sin(uv.x * 50.0 + PI * 0.66666666)) * offsetB) * 0.5 ;\n    \n    col += vec3(abs(sin(uv.y * 50.0)) ,\n                abs(sin(uv.y * 50.0 + PI * 0.33333333)),\n                abs(sin(uv.y * 50.0 + PI * 0.66666666))) * 0.5;\n    \n    return col;\n}\n\n\n\nfloat DstSphere (vec3 currentStep, vec3 origin, float radius) {\n\treturn length(origin - currentStep) - radius;\n}\n\n\n\n\nfloat World (vec3 currentStep) {\n    \n    float world = 0.0;\n\n    \n    \n    \n    float sphere0 = DstSphere (currentStep , vec3(0.6 + 1.2 * sin(iTime * 0.5), 0.0, 3.0), 0.8);\n    float sphere1 = DstSphere (currentStep , vec3(-0.6, 0.0, 3.0), 0.8);\n    \n    \n    \n    \n    \n    \n    world = min(sphere0, sphere1);\n\n    return world;\n}\n\n\n\nvec3 raymarching (vec3 dir) {\n\tfloat dist = 0.0;\n    int currentStepCount = 0;\n\n    while(true) {\n        float world = World(dir * dist);\n        dist += world;\n        \n        \n        if(world < NEAR || currentStepCount > SETP_MAX)\n            break;\n\n        if(dist >  FAR)\n            return vec3(0.0, 0.0, 0.0);\n        \n        currentStepCount++;\n    }\n    \n    return dir * dist;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    \n    vec3 cameraPos = vec3(0.0, 0.0, -2.5 + 0.2 * sin(iTime));\n    vec3 cameraDir = vec3(0.0, 0.0, 1.0);\n    vec3 screen = vec3(uv, 0.0);\n    vec3 dir = normalize(screen - cameraPos);\n\n    \n    vec3 world0 = raymarching(dir);\n    \n    \n    \n    dir = normalize(screen + vec3(OFFSET_TO_NORMAL, OFFSET_TO_NORMAL, 0.0) - cameraPos);\n    vec3 world1 = raymarching(dir);\n    \n    dir = normalize(screen + vec3(-OFFSET_TO_NORMAL, OFFSET_TO_NORMAL, 0.0) - cameraPos);\n    vec3 world2 = raymarching(dir);\n    \n    dir = normalize(screen + vec3(OFFSET_TO_NORMAL, -OFFSET_TO_NORMAL, 0.0) - cameraPos);\n    vec3 world3 = raymarching(dir);\n    \n    dir = normalize(screen + vec3(-OFFSET_TO_NORMAL, -OFFSET_TO_NORMAL, 0.0) - cameraPos);\n    vec3 world4 = raymarching(dir);\n\n    \n    \n    \n\n    /*\n\t(world1 - world0) + (world2 - world0) + (world3 - world0) + (world4 - world0)\n\t*/\n    \n    //vec3 worldNormal = (world1 + world2 + world3 + world4) * 0.25 ;\n    //worldNormal = normalize(worldNormal);\n    \n    vec3 normal1 = normalize(world1 - world0);\n    vec3 normal2 = normalize(world2 - world0);\n    vec3 normal3 = normalize(world3 - world0);\n    vec3 normal4 = normalize(world4 - world0);\n\tvec3 normal0 = normalize(normal1 + normal2 + normal3 + normal4);\n    \n    \n    vec3 light0_dir = normalize(vec3(-1.0, -1.0, 0.8));\n    vec3 light0_color = vec3(0.0, 2.0, 1.0);\n    \n    col = light0_color * dot(normal0, light0_dir);\n    col = clamp(col, 0.0, 1.0);\n    col = length(col) > 0.0 ? col : Background(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 133, 133, 779], [783, 783, 846, 846, 895], [900, 900, 932, 932, 1232], [1236, 1236, 1265, 1265, 1628], [1633, 1633, 1690, 1690, 3366]]}
{"id": "3tjXRw", "name": "Noisy Mandelbrot Zoom", "author": "jarble", "description": "This shader is based on https://www.shadertoy.com/view/lsX3W4", "tags": ["mandelbrot"], "likes": 4, "viewed": 294, "published": "Public API", "date": "1565390128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    float di =  1.0;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<300; i++ )\n    {\n        if( m2>1024.0 ) { di=0.0; break; }\n\n\t\t// Z' -> 2·Z·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c+hash12(dz)/5.0*sin(iTime)*zoo;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if( di>0.5 ) d=0.0;\n\t\n    // do some soft coloring based on distance\n\td = clamp( pow(4.0*d/zoo,0.2), 0.0, 1.0 );\n\n    vec3 col = vec3( d );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjXRw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[88, 151, 173, 173, 290], [292, 292, 349, 349, 1307]]}
{"id": "3tjXzm", "name": "THE HIVE 001", "author": "Hirai_worthless", "description": "the hive of monsters.", "tags": ["raymarching"], "likes": 4, "viewed": 132, "published": "Public", "date": "1565444459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n\tfloat h = -10. + cos(p.x/2.) * 0.5 + cos(p.z/2.) * 0.5;\n    h += sin(p.x /8.) * 3.;\n    h -= sin(p.z /8.) * 3.;\n\tvec3 r = p;\n    p.y = -abs(-p.y - (sin(p.x) + sin(p.z) + sin(iTime)) * 0.2)\n        + (sin(p.x) + sin(p.z) + sin(iTime)) * 0.2;\n    float ground = p.y - h;\n    vec3 q = p;\n    q.xz = fract((q.xz + 5.) /10.) * 10. - 5.;\n    r.xz = fract((r.xz + 8.) /16.) * 16. - 8.;\n    r.xz += vec2(3.);\n\tfloat towerA = length(r.xz) - (1.25 + 0.25 + sin(r.y));\n    float towerB = length(q.xz - 2.5) - 1. / (0.9 + max(p.y - h,0.0));\n    float terrain = min(ground,min(towerA,towerB));\n    float path = max(abs(p.x) - 0.75,-p.y - 0.5);\n    return max(terrain,-path);\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(0.,0.,-2.0 + iTime * 2.0);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 256; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.005);\n    float a = dot(data.xyz,r);\n    vec3 p = o + r * t;\n    vec3 fc = min(fract(p.x),fract(p.z))<0.03 ? vec3(0.95) : vec3(0.05);\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    fc = mix(vec3(0.95),fc,fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 369, 369, 443], [445, 445, 471, 471, 654], [657, 671, 707, 707, 736], [738, 738, 776, 776, 805], [807, 807, 840, 840, 987], [989, 989, 1032, 1032, 1188], [1191, 1208, 1226, 1226, 1891], [1893, 1911, 1935, 1935, 2187], [2189, 2209, 2230, 2230, 2272], [2274, 2288, 2315, 2315, 2368], [2370, 2385, 2413, 2413, 2613], [2615, 2630, 2669, 2669, 3012], [3014, 3025, 3082, 3099, 3451]]}
{"id": "3tSSDD", "name": "Lemon SDF", "author": "spac", "description": "for more information see: https://www.desmos.com/calculator/kbjqpiv0qq\nusing iq's raymarching implementation from https://www.shadertoy.com/view/tl23RK", "tags": ["3d", "sdf", "lemon"], "likes": 0, "viewed": 183, "published": "Public API", "date": "1565843320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define TAU 6.28318530718\n\n#define SDF_GRADIENT 1\n#define SDF_GRADIENT_PERIOD 0.075\n//\n// `Lemon` is defined as the self-intersecting region of a spindle torus\n//\n// `position` defines the centre of the lemon (point of symmetry)\n//\n// `vertical` defines the axis of rotation\n//\n// `radius` defines the minor radius of the torus\n// `focus` defines the major radius of the torus\n//\n// `vertical`, `radius`, and `focus` are multiplied by the scale of the lemon\n//\nstruct Lemon\n{\n    vec3 position;\n    vec3 vertical;\n    float radius;\n    float focus;\n};\n\nLemon lemon = Lemon(\n\tvec3(0.0, 0.0, 0.0),\n    normalize(vec3(0.0, 0.0, 1.0)),\n    1.15470053838,\n    0.57735026919\n);\n\n// `sagitta` defines the shape of the lemon and is between 0 (zero volume) and 1 (sphere)\nvoid makeLemon(in float sagitta, out float radius, out float focus)\n{\n    radius = (sagitta*sagitta + 1.0) / (2.0*sagitta);\n    focus  = radius - sagitta;\n}\n\nfloat sdLemonPerfect(vec3 p, Lemon lemon)\n{\n    vec3 s = p - lemon.position;\n    float t = dot(s, lemon.vertical) / dot(lemon.vertical, lemon.vertical);\n\n    vec3 x = t*lemon.vertical;\n    vec3 y = s - x;\n    float y2 = dot(y, y);\n    if (abs(t) >= 1.0) {\n        float l = lemon.focus*(abs(t) - 1.0);\n        if (y2 <= l*l) {\n            // corner case\n            return length(sign(t) * lemon.vertical - s);\n        }\n    }\n    // general case\n    return length(lemon.focus*-(y/sqrt(y2)) - s) - lemon.radius;\n}\n\nfloat sdLemon(vec3 p, Lemon lemon)\n{\n    vec3 s = p - lemon.position;\n    float t = dot(s, lemon.vertical) / dot(lemon.vertical, lemon.vertical);\n\n    vec3 y = s - t*lemon.vertical;\n\n    return length(lemon.focus*-normalize(y) - s) - lemon.radius;\n}\n\n// ===========================\n\nfloat intersectPlane(vec3 p, vec3 v, vec3 n, float k)\n{\n    return (k - dot(p, n)) / dot(v, n);\n}\n\nfloat map( in vec3 pos )\n{\n    float an = 2.5*(0.5+0.5*sin(iTime*1.1+3.0));\n    vec2 c = vec2(sin(an),cos(an));\n    //return sdCappedTorus(pos, c, 0.4, 0.1 );\n    return sdLemonPerfect(pos, lemon);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius, focus;\n    //makeLemon(0.6 + sin(0.5*iTime)*0.25, radius, focus);\n    //lemon.radius = radius;\n    //lemon.focus  = focus;\n    \n    // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = 5.0*normalize(vec3( 1.0*cos(an), 0.5, 1.0*sin(an) ));\n    vec3 ta = vec3(0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        \n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        } else {\n            \n        }\n        // gamma        \n        col = sqrt( col );\n      \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSSDD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1751, 1841, 1910, 1910, 1997], [1999, 1999, 2042, 2042, 2512], [2514, 2514, 2550, 2550, 2763], [2765, 2797, 2852, 2852, 2894], [2896, 2896, 2922, 2922, 3095], [3097, 3161, 3193, 3193, 3432], [3452, 3452, 3509, 3509, 5248]]}
{"id": "3tSSRh", "name": "Britney abstract", "author": "foran", "description": "Britney abstract", "tags": ["britneyabstract"], "likes": 1, "viewed": 65, "published": "Public", "date": "1564904213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Sidescroller WTF, by @rianflo\n//\n// @danbri added running man from http://glsl.heroku.com/e#10532.6 \n// which in turn took it from David Hoskins shadertoy, https://www.shadertoy.com/view/MdsGRS\n// dashxdr ripped out all but running man 20140519\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bb;\nconst float smokeIntensity=2.;\nconst float offset=.5;\nconst vec2 smokeDirection=vec2(.05,.75);//point2D\nconst vec4 smokeColor=vec4(.75,.75,.75,.75);//color\n\nfloat runnerHeight;\nfloat runCycle;\n\n\n//----------------------------------------------------------------------------\nvec2 Segment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n//----------------------------------------------------------------------------\nfloat Head( vec2 p, float s )\n{\n\tp *= vec2(1.4, 1.1);\n\treturn length(p)-s;\n}\n\n//----------------------------------------------------------------------------\nvec2 Rotate(vec2 pos, vec2 piv, float ang)\n{\n\tmat2 m = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n\tpos = (m * (pos-piv))+piv;\n\treturn pos;\n}\n\n//----------------------------------------------------------------------------\nfloat Smin( float a, float b )\n{\n    float k = 0.025;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\t\n//----------------------------------------------------------------------------\nvec2 Running( vec2 p)\n{\n\t// Oh the horror! - of magic numbers. ;)\n\tfloat material = 0.0;\n\tfloat d;\n\tfloat ang = -.4;\n\tmat2 leanM = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n\trunnerHeight = -.5 + .05*min(.7, cos(runCycle*2.0+.5));\n\n\tp += vec2(0.0, runnerHeight);\n\tp *= leanM;\n\tfloat headX = sin(runCycle*.55)*.035;\n\td = Head(p-vec2(.44+headX, -0.02-headX*.5), .08);\n\t\n\tfloat arm1 = sin(runCycle)*.6*(.2+1.0);\n\tfloat leg1 = sin(runCycle)*.7*(.05+.5);\n\t\n\t// Neck...\n\tvec2 h = Segment( vec2(0.4,-0.1-0.01-headX*.5), vec2(0.42+headX,-.04), p );\n\tfloat d2 = h.x - 0.03 + h.y*0.005;\n\td = Smin(d, d2 );\n\t// Body...\n\th = Segment( vec2(0.4,-0.17), vec2(0.4,-.37), p );\n\td2 = h.x - 0.065 + h.y*0.03;\n\td = Smin(d, d2 );\n\t\n\t// Upper arm...\n\tvec2 elbow = Rotate(vec2(0.4,-.3), vec2(.4,-0.14), arm1);\n\th = Segment(vec2(0.4,-0.14),  elbow, p );\n\td2 = h.x - 0.04 + h.y*0.01;\n\td = min(d, d2 );\n\t// Lower arm...\n\tvec2 wrist = Rotate(elbow+vec2(.13, -.02), elbow, arm1*1.5-.3);\n\th = Segment(elbow,  wrist, p );\n\td2 = h.x - 0.03 + h.y*0.01;\n\td = min(d, d2 );\n\t// Hand...\n\tvec2 hand = Rotate(wrist+vec2(.005, -0.0), wrist, arm1*1.5-.3);\n\th = Segment(wrist,  hand, p );\n\td2 = h.x - 0.03 + h.y*0.001;\n\td = min(d, d2 );\n\t\n\t// Upper leg...\n\tvec2 knee = Rotate(vec2(0.4,-.55), vec2(.4,-0.35), -leg1+.5);\n\th = Segment(vec2(0.4,-.35), knee, p );\n\td2 = h.x - 0.05 + h.y*0.015;\n\td = Smin(d, d2 );\n\t\n\t// Lower leg...\n\tvec2 rotFoot = Rotate(knee+vec2(.0, -.22), knee, -(-leg1*.3+1.6));\n\trotFoot = Rotate(rotFoot, knee, smoothstep(-.2, .2, -(leg1)*.15)*5.2-1.2);\n\th = Segment(knee, rotFoot , p );\n\td2 = h.x - 0.03+ h.y*0.008;\n\td = Smin(d, d2 );\n\t\n\t// Foot...\n\tvec2 toes = Rotate(rotFoot+vec2(.09, 0.0), rotFoot, smoothstep(-.1, .15, -leg1*.2)*2.4-1.7-leg1);\n\th = Segment(rotFoot, toes, p );\n\td2 = h.x - 0.018 + h.y*0.005;\n\td = Smin(d, d2 );\n\t\n\tif (d > 0.005)\n\t{\n\t\t// Do shadowed back limbs if others haven't been hit...\n\t\t// Upper arm 2...\n\t\telbow = Rotate(vec2(0.4,-.3), vec2(.4,-0.14), -arm1);\n\t\th = Segment(vec2(0.4,-0.14), elbow, p );\n\t\td2 = h.x - 0.04 + h.y*0.01;\n\t\td = min(d, d2 );\n\t\t// Lower arm 2...\n\t\twrist = Rotate(elbow+vec2(.13, -.01), elbow, -arm1*1.5+.1);\n\t\th = Segment(elbow,  wrist, p );\n\t\td2 = h.x - 0.03 + h.y*0.01;\n\t\td = min(d, d2 );\n\t\t// Hand...\n\t\tvec2 hand = Rotate(wrist+vec2(.005, -0.0), wrist, -arm1*1.5-.3);\n\t\th = Segment(wrist,  hand, p );\n\t\td2 = h.x - 0.03 + h.y*0.001;\n\t\td = min(d, d2 );\n\t\t// Upper leg...\n\t\tknee = Rotate(vec2(0.4,-.55), vec2(.4,-0.35), leg1+.5);\n\t\th = Segment(vec2(0.4,-.35), knee, p );\n\t\td2 = h.x - 0.05 + h.y*0.02;\n\t\td = min(d, d2 );\n\t\t// Lower leg...\n\t\trotFoot = Rotate(knee+vec2(.0, -.22), knee, -(leg1*.3+1.6));\n\t\trotFoot = Rotate(rotFoot, knee, smoothstep(-.2, .2, leg1*.15)*5.2-1.2);\n\t\th = Segment(knee, rotFoot, p );\n\t\td2 = h.x - 0.03+ h.y*0.008;\n\t\td = Smin(d, d2 );\n\t\n\t\t// Foot...\n\t\ttoes = Rotate(rotFoot+vec2(.09, 0.0), rotFoot, smoothstep(-.1, .15, leg1*.2)*2.4-1.7+leg1);\n\t\th = Segment(rotFoot, toes, p );\n\t\td2 = h.x - 0.018 + h.y*0.005;\n\t\td = Smin(d, d2 );\n\t\tmaterial = 2.0;\n\t}\n\n\treturn vec2(d, material);\n}\nfloat random(vec2 co){\n\treturn fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat noise(vec2 p){\n\t\n\treturn random(vec2(p.x+p.y*10000.,p.y+p.x*10000.));\n\t\n}\n\nvec2 sw(vec2 p){return vec2(floor(p.x),floor(p.y));}\nvec2 se(vec2 p){return vec2(ceil(p.x),floor(p.y));}\nvec2 nw(vec2 p){return vec2(floor(p.x),ceil(p.y));}\nvec2 ne(vec2 p){return vec2(ceil(p.x),ceil(p.y));}\n\nfloat smoothNoise(vec2 p){\n\t\n\tvec2 interp=smoothstep(0.,1.,fract(p));\n\tfloat s=mix(noise(sw(p)),noise(se(p)),interp.x);\n\tfloat n=mix(noise(nw(p)),noise(ne(p)),interp.x);\n\treturn mix(s,n,interp.y);\n\t\n}\n\nfloat fractalNoise(vec2 p){\n\t\n\tfloat n=0.;\n\tn+=smoothNoise(p);\n\tn+=smoothNoise(p*2.)/2.;\n\tn+=smoothNoise(p*4.)/4.;\n\tn+=smoothNoise(p*8.)/8.;\n\tn+=smoothNoise(p*16.)/16.;\n\tn/=1.+1./2.+1./4.+1./8.+1./16.;\n\treturn n;\n\t\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n\n{\n\t\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / min(iResolution.x, iResolution.y);\n\t\nvec2 sd=(smokeDirection-vec2(.5));\t\t\nvec2 nuv=vec2(p.x-sd.x*iTime/3.,p.y-sd.y*iTime/3.);\n\tvec3 col;\n\trunCycle = iTime*4.0;\n\tfloat x=fractalNoise(nuv*6.);\n\tvec4 inputPixel=texture(iChannel0,(fragCoord/iResolution.xy)*.93+.051);\n\n\tvec2 res = Running(p * .5);\n\tcol=vec3(smoothstep(0.0, .0005, res.x));\t\n\t\n\tvec4 final=mix(vec4(x*col,max(x,inputPixel.a)),inputPixel,pow(abs(p.y),pow(smokeColor.a*smokeIntensity*x,2.)));\n\t\n\tfragColor=vec4(final);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 592, 632, 632, 763], [765, 844, 875, 875, 920], [922, 1001, 1045, 1045, 1145], [1147, 1226, 1258, 1258, 1368], [1371, 1450, 1473, 1515, 4487], [4488, 4488, 4510, 4510, 4576], [4578, 4578, 4598, 4598, 4657], [4659, 4659, 4675, 4675, 4711], [4712, 4712, 4728, 4728, 4763], [4764, 4764, 4780, 4780, 4815], [4816, 4816, 4832, 4832, 4866], [4868, 4868, 4894, 4894, 5068], [5070, 5070, 5097, 5097, 5286], [5287, 5287, 5342, 5342, 5875]]}
{"id": "3tSSWV", "name": "Color from Triangle Grid", "author": "gressettd", "description": "Playing with patterns that produce several variables for multiple perspectives on the pattern to drive color control.", "tags": ["grid", "color", "triangular"], "likes": 4, "viewed": 97, "published": "Public", "date": "1567050078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\nfloat Random1DC(float seed)\n{\n\treturn fract(cos(seed)* (131072.0*2.718281828459));\n}\n\nfloat Random3D(vec3 p)\n{\n\tvec3 comparator = vec3(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y),\n\t\t12.987 * Random1DC(p.z));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nvec4 ComputeTriangleGridPattern(vec2 pos, float scale)\t\n{\n\tmat2 m = mat2(1.0, -1.0 / 1.73, 0.0, 2.0 / 1.73);\n\tvec2 u = scale * pos * m;\n\tvec3 g = vec3(u, 1.0 - u.x - u.y);\n\tvec3 id = floor(g);\n\tg = fract(g);\n\tif (length(g) > 1.0) g = 1.0 - g;\n\tvec2 g2 = abs(2.0*fract(g.xy) - 1.0);\n\tfloat centerDistance = length(g2);\n\n\tfloat nodeDistance = length(1.0 - g2);\n\n\tfloat id1 = Random3D(id);\n\treturn vec4(id1, max(g.x,g.y), nodeDistance,centerDistance);\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= float(iResolution.y) / float(iResolution.x);\n    \n    uv += vec2(cos(iTime*0.2) + iTime*0.1,iTime * 0.05);\n\n\n    vec4 cc = ComputeTriangleGridPattern(uv,5.0);\n    \n    vec4 bias = vec4(0.350,0.906,0.689,1.0);\n    vec4 scale = vec4(0.772,0.114,0.263,1.0);\n    vec4 freq = vec4(0.077,0.368,1.016,1.0);\n    vec4 phase = vec4(3.859,3.252,5.857,1.0);\n    \n    vec4 color;\n    if(cc.x < 0.25)\n\t\tcolor=ComputeWaveGradientRGB(1.0 + 0.5*cos(cc.y + cc.z + iTime), bias, scale, freq,phase);\n    else if(cc.x < 0.5)\n        color=ComputeWaveGradientRGB(tan(cc.w + iTime), bias, scale, freq, phase);\n    else if(cc.x < 0.75)\n        color = ComputeWaveGradientRGB(fract(cc.w/(cc.y+cc.z) + iTime), bias, scale, freq, phase);\n    else\n        color = ComputeWaveGradientRGB(tan(max(cc.w,cc.y) + iTime), bias, scale, freq, phase);\n    \n    \n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 64], [66, 66, 95, 95, 148], [150, 150, 179, 179, 234], [236, 236, 260, 260, 502], [504, 504, 561, 561, 954], [956, 956, 1040, 1040, 1144], [1146, 1146, 1203, 1253, 2193]]}
{"id": "3tSSzw", "name": " Rounded Box trace fork", "author": "ollj", "description": "more explicitly vectorized fork of \nhttps://www.shadertoy.com/view/WlSXRW\nIn search of some symmetry to utilize, i sure found parallel processing alternatives, but the resulting difference is very neglible.", "tags": ["3d", "intersection", "min", "roundedcube", "branchlessed", "cull"], "likes": 1, "viewed": 397, "published": "Public API", "date": "1565313785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//some code more explicitly vectorized by ollj, which adds extra substractions (done as vectors anyways) \n//and it adds some min() and mix(step)) to removes 3 sequential/culling if() conditions, that obviously can be done in parallel instead.\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray with a rounded cube, testing a single\n// corner (sphere) instead of 8, and only 3 edges (cylinders)\n// instead of 12. There might be a better (more compact and\n// efficient) way to do it, but this is where I landed. However\n// the code to compute the surface normal is particularly\n// elegant.\n\n// Other intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n    \n#define AA 2  // reduce this to 1 if you have a slow machine\n\n#define BoundOr(a,b,c) (abs(b-.5*a)*2. c a)\n#define BoundAnd(a,b,c) (a c abs(b-.5*a)*2. ) \n//(0.<a&&a<b) === boundAnd(a,b,<) === boundOr (a,b,>=) \n//(0.>a||a>b) === boundOr (a,b,>) === boundAnd(a,b,<=) \n//(0.<a&&a<b) === (0.<a&&a-b<0.) === (0.<a&&0<b-a) === (0.<max(a,b-a)) ???\n//(0.<a||a<b) === (0.<a||a-b<0.) === (0.<a||0<b-a) === (0.<min(a,b-a)) ???\n\n//original code by iq, vectorized by ollj, parent code is in: https://www.shadertoy.com/view/WlSXRW\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad){\n\t// bounding box\n    vec3 m=1./rd;//assert nonzero RayDirection, seems fair.\n    vec3 n=m*ro;\n    vec3 d=abs(m)*(size+rad);\n    vec3 p=-d-n;d=d-n;\n\tfloat t =max(max(p.x,p.y),p.z);\n\tfloat tF=min(min(d.x,d.y),d.z);\n    if (0.<min(tF,t-tF)) return -1.; \t//if( tN > tF || tF < 0.0) //ollj edit\n    //end of bounding box\n    // convert to first octant\n    //7 intersection cases (3planes+3roundedSides+1RoundedCorner) planes first:\n    p=ro+t*rd;//p and d change meaning (short scope vars)\n    d=sign(p);\n    ro*=d;\n    rd*=d;    \n    p *=d;p-=size;p=max(p,p.yzx);if(min(min(p.x,p.y),p.z)<0.)return t;//type bvec3 not needed, replaced if(any()) with min() by ollj\n    //planar intersections done, roundedCorners are trickier, 3 sides +1 corner.\n    p=ro-size;//p and d change meaning (short scope vars)\n    d=p*rd;\n\tp*=p;//some wars renamed or reapropriated (p&&d have had a short scope, now means something else)\n    t =1e20; \n    // some precomputation\n    //of the vec4 types below,\n    //.xyz tests 3 rounded sides intersections\n    //.w   tests rounded corner intersection\n    vec4 a=vec4(rd*rd,1);\n    a.xyz=a.yzx+a.zxy;\n    vec4 b=d.yzxx+d.zxyy+vec4(0,0,0,d.z);\n    vec4 c=p.yzxx+p.zxyy+vec4(0,0,0,p.z)-rad*rad;\n    vec4 h=b*b-a*c;//vectorization requires more precalculation (all cases are precalculated in vectors at once, instead of just one at a time, this needs more minimum memory)\n    h.xyz=(-b.xyz-sqrt(h.xyz))/a.xyz;\n    a.xyz=size.xyz-abs(ro+rd*h.xyz); //note that [a] is negated to simplify conditionals below.\n\tif(h.w>0.0)t=-b.w-sqrt(h.w);//rounded corner(s) must be done before 3 sides \n    //because of culling order, sides go over inside-intersections of spheres in corners.\n    a=min(a,h);  //this line simplifies conditionals a lot\n    if(a.x>0.)t=min(t,h.x);    //   t=mix(min(t,h.x),t,step(a.x,0.));\n    if(a.y>0.)t=min(t,h.y);\n    if(a.z>0.)t=min(t,h.z);    //these 3 if() lines CAN BE substituted by the 2 lines below.\n //vec3 r=mix(min(vec3(t),h.xyz),vec3(t),step(a.xyz,vec3(0)));//this line can likely be simplified\n    //a branchlessing mix(step()) is indeed likely slower\n    //,except it maybe faster where you can handle multiple domains at once, instead of a list of if():\n//t=min(min(t,r.x),min(r.y,r.z));    \n    //this should end in a min(min(),min()) and not be a list of 4 conditions\n    //i leave the benchmarking of this to others    \n    if( t>1e19 )t=-1.;//>zFar error case.  \n\treturn t;} //end of vectorization by ollj\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\n\n//======================================================\n\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nvec3 pconvert( in mat4 mat, in vec3 v ) { return (mat*vec4(v,1.0)).xyz; }\nvec3 nconvert( in mat4 mat, in vec3 v ) { return (mat*vec4(v,0.0)).xyz; }\n\n//======================================================\n\n\nstruct\n{\n   mat4  world_to_obj;\n   mat4  obj_to_world;\n   vec3  size;\n   float radius;\n}box;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (0.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    // rounded box\n    {\n    \n    // convert from ray to box space\n    vec3 rdd = nconvert(box.world_to_obj, rd );\n    vec3 roo = pconvert(box.world_to_obj, ro );\n    // intersect in box space\n    float t = roundedboxIntersect(roo,rdd,box.size,box.radius);\n    if( t>0.0 && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\n// texture sampling\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an = 0.15*(iTime-10.0);\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ro = ta + vec3( 2.0*cos(an), 0.2, 2.0*sin(an) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.6,8.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n\n    // rounded box animation\n    box.obj_to_world = translate( 0.0, 1.0, 0.0 ) * \n                       rotate( normalize(vec3(1.0,1.0,0.1)), iTime ); \n    box.world_to_obj = inverse( box.obj_to_world );\n    box.size = vec3(0.5,0.4,0.3);\n    box.radius = 0.2;\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n    \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 )\n        {\n            // shading\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor;\n            vec3 mate;\n            \n            if( tm.y<1.5 ) // floor\n            {\n                nor = vec3(0.0,1.0,0.0);\n                mate = 0.35*texture( iChannel0, 0.2*pos.xz ).xyz;\n            }\n            else // rounded cube\n            {\n                // convert position from world to box space\n                vec3 bpos = pconvert(box.world_to_obj,pos);\n                // compute normal in box space\n                vec3 bnor = roundedboxNormal(bpos,box.size,box.radius);\n                // convert normal from box to world space\n                nor = nconvert(box.obj_to_world,bnor);\n                \n                mate = 0.35*boxmap( iChannel0, bpos, bnor, 8.0 ).xyz;\n            }\n            \n            // lighting\n            vec3 lig = normalize(vec3(0.8,0.4,-0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = step( intersect( pos+0.01*nor, lig ).y, 0.0 );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 4.0*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 2.0*vec3(0.20,0.30,0.40)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n\t\t\tcol *= mate;            \n            col += 0.3*pow(spe,8.0)*dif*sha*(0.04+0.96*pow(clamp(dot(lig,hal),0.0,1.0),5.0));\n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n        \n        // vignetting        \n        col *= 1.0 - 0.1*dot(p,p);\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n\t// grading\n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSSzw.jpg", "access": "shaders20k", "license": "mit", "functions": [[2908, 3008, 3087, 3104, 5515], [5548, 5575, 5640, 5640, 5697], [5700, 5758, 5794, 5794, 6198], [6200, 6200, 6245, 6245, 6361], [6363, 6363, 6404, 6404, 6436], [6437, 6437, 6478, 6478, 6510], [6512, 6665, 6707, 6707, 7168], [7170, 7190, 7254, 7254, 7436], [7438, 7438, 7495, 7519, 10562]]}
{"id": "3tsXDs", "name": "fractal flame v2", "author": "jorge2017a1", "description": "fractal flame v2", "tags": ["fractalflamev2"], "likes": 2, "viewed": 182, "published": "Public", "date": "1564668862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Creado por Hirai_worthless en 2019-07-31\n//modificado por jorge flores p.\n\nmat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat PI = 3.14159265;\nvec3 path(float t){\n\tfloat x = clamp(sin(t) * pow(2.0,0.5),-1.0,1.0);\n    float y = clamp(cos(t) * pow(2.0,0.5),-1.0,1.0);\n    float z = 0.2;\n    return vec3(x,y,z);\n}\nfloat grid(vec3 p, float a){\n    //p.xz *= genRot(iTime);\n    //p = fract(p / a) * a;\n    p = fract(p ) ;\n    \n    \n    p -= vec3(a / 1.5);\n\t\n    \n    \n    float d1 = max(abs(p.x),abs(p.y)) - a/(15.0);\n\tfloat d2 = max(abs(p.y),abs(p.z)) - a/(15.0);\n\tfloat d3 = max(abs(p.z),abs(p.x)) - a/(15.0);\n    \n\treturn (min(min(d1,d2),d3));\n}\nfloat map(vec3 p){\n\tfloat k = grid(p,1.0);\n    \n    for(float i = 2.0; i < 6.0; i++  ){\n        k = max(k,-grid(p,1.0/i));\n    }\n    return k;\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.3,0.12,0.10);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.7;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float stime;\n    stime=iTime*0.1;\n    \n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.5));\n    \n    r.xz *= genRot(stime);\n    \n    \n    vec3 o = vec3(  1.2,  0.5 + stime * 1.0 , cos(stime * PI / 4.) * 1.2);\n   \n    vec4 data = trace(o,r);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    vec3 fc = mix(vec3(0.3 - data.x,0.6 -data.y,0.5-data.z),vec3(0.),1.0 - fog);\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 100, 100, 154], [178, 178, 197, 197, 345], [346, 346, 374, 431, 678], [679, 679, 697, 697, 823], [850, 850, 874, 874, 1126], [1128, 1128, 1156, 1156, 1357], [1360, 1360, 1417, 1467, 2055]]}
{"id": "3tSXRD", "name": "Walking Among Fallen Stars", "author": "mathmasterzach", "description": "Watch stars fall from the sky on your evening walk. Remember how small they are.", "tags": ["stars", "scene", "calm", "walk", "monochromatic"], "likes": 20, "viewed": 482, "published": "Public API", "date": "1565159367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A shader in two colors, black and white\n//A relaxing walk at night\n\n//comment this out to remove the head bobbing\n#define HEAD_BOB\n\nconst float SPEED=10.;\n\n//Hashes from David Hoskins at https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nfloat pointPointDist(vec3 p, vec3 q){\n\treturn length(p-q);\n}\nfloat pointRayDist(vec3 o, vec3 r, vec3 p){\n    vec3 a=o-p;\n    if(dot(r,-a)<0.){return -1.;}\n\treturn sqrt(dot(a,a)-dot(-a,r)*dot(-a,r));\n}\nfloat spherePointDistOnLine(vec3 o, vec3 r, vec3 s) {\n \tvec3  a = o - s.xyz;\n    float b = dot(a,r);\n    float c = dot(a,a)-1.;\n    float t = b*b - c;\n    if( t > 0.0) \n        t = -b - sqrt(t);\n    return t;\n}\nfloat sphereTime(float id){\n    return 40.*hash11(id)+10.+SPEED*iTime-id;\n}\n\nfloat sphereVertical(float id){\n    float st=sphereTime(id)/(.5*SPEED);\n    if(st<.5){return 2e20;}\n    float t =fract(st);float b=floor(st);\n    float ht=max(0.,((100./(10.*b+1.))-2.))*(.5+hash11(id+.1));\n\treturn max(-ht*(t-.5)*(t-.5)+.25*ht,0.);\n}\n\nfloat ripples(float id,float d){\n    float st=sphereTime(id)/(.5*SPEED);\n    float t =fract(st);float b=floor(st);\n    if(t>.5){return 0.;}\n    float ht=max(0.,((100./(10.*b+1.))-2.))*(.5+hash11(id+.1));\n    float dt=-ht*t+ht/2.;\n   \treturn step(.1,dt*2.*(-abs(abs(abs(4.*(d-(2.*t+1.))-2.5)-1.)-1.)+.5)/(4.*(d-(2.*t+1.))+1.));\n}\n\nvec3 spherePosition(float id){\n    vec2 tg=hash21(id)*vec2(70.,.5);\n\treturn vec3(tg.x-35.,sphereVertical(id),tg.y+id);\n}\n\nfloat trace(vec3 o,vec3 r,vec2 sky){\n    float sh=floor(o.z);\n    float fDist=-o.y/r.y;\n    vec3 gP=fDist*r+o;\n    bool hit=false;\n    float minHitDist=2e20;\n    float minGroundDist=2e20;\n    float minGroundID=-1.;\n    float minGroundDist1=2e20;\n    float minGroundID1=-1.;\n    float minGroundDist2=2e20;\n    float minGroundID2=-1.;\n    for(float i=0.;i<50.;i++){\n        vec3 sP=spherePosition(i+sh);\n        float hitD=spherePointDistOnLine(o,r,sP);\n        if(hitD>0.&&hitD<minHitDist){\n            hit=true;\n        \tminHitDist=hitD;\n        }\n        float d=pointPointDist(gP,sP);\n        float st=(sphereTime(i+sh)/(.5*SPEED));\n        if(st>.5&&st<7.5){\n            if(d<minGroundDist){\n                minGroundDist2=minGroundDist1;\n                minGroundID2=minGroundID1;\n                minGroundDist1=minGroundDist;\n                minGroundID1=minGroundID;\n                minGroundDist=d;\n                minGroundID=i+sh;\n            }else if(d<minGroundDist1){\n            \tminGroundDist2=minGroundDist1;\n                minGroundID2=minGroundID1;\n                minGroundDist1=d;\n                minGroundID1=i+sh;\n            }else if(d<minGroundDist2){\n            \tminGroundDist2=d;\n                minGroundID2=i+sh;\n            }\n        }\n    }\n    if(minHitDist>fDist&&r.y<0.){\n        return ripples(minGroundID ,length(spherePosition(minGroundID )-gP))\n              +ripples(minGroundID1,length(spherePosition(minGroundID1)-gP))\n              +ripples(minGroundID2,length(spherePosition(minGroundID2)-gP));\n    }else if(hit){\n\t\treturn 1.;\n    }else if(r.y>0.&&hash12(sky.xy-vec2(0.,iFrame))>.98){\n    \treturn 1.;\n    }else{\n    \treturn 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    #ifdef HEAD_BOB\n    \tvec3 o = vec3(.2*cos(5.*iTime),2.+.3*abs(sin(5.*iTime)),SPEED*iTime-4.);\n    #else\n    \tvec3 o = vec3(0.,2.,SPEED*iTime-4.);\n    #endif\n    vec3 r = normalize(vec3(uv,1.));\n    fragColor=vec4(trace(o,r,fragCoord));\n}", "image_inputs": [{"id": "XtXGzs", "previewfilepath": "https://soundcloud.com/fm-attack/images-of-you", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/fm-attack/images-of-you", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 227, 249, 249, 334], [335, 335, 356, 356, 473], [474, 474, 495, 495, 623], [626, 626, 663, 663, 686], [687, 687, 730, 730, 826], [827, 827, 880, 880, 1037], [1038, 1038, 1065, 1065, 1113], [1115, 1115, 1146, 1146, 1364], [1366, 1366, 1398, 1398, 1694], [1696, 1696, 1726, 1726, 1816], [1818, 1818, 1854, 1854, 3496], [3498, 3498, 3554, 3554, 3853]]}
{"id": "ll2BD1", "name": "#Evoke 2019 - Sine Wave 1D", "author": "VJSpackOMat", "description": "Hybridising sine wave example as example that escape time hybridisation works the same", "tags": ["sine"], "likes": 0, "viewed": 61, "published": "Public", "date": "1565946094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\nSine Wave 1D\n\nc.Kleinhuis evoke 2019 - talk 'hybrid fractals'\n\nControls:\n\n- use mouse x to scale view\n\nexample for hybridising a sine wave like it is done for ages in demo programming,\n\nsine parameters are stored as vector3 values with \nsine1/sine2/sine3 parameters stored in x/y/z of the parameter vector\n\nthe wavelengths control the scale of the wave\nthe frequencies controls the speed of the wave\nthe amplitude controls the amplitude of the wave\n*/\n\n\nvec3 wavelengths=vec3(100.,200.,300.);\nvec3 frequencies=vec3(1.,1.,1.);\nvec3 amplitudes=vec3(1.,1.,1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n     \n    uv=uv*2.0-1.0;\n\tvec4 color=vec4(1,1,1,1);\n    \n   float val = sin(iTime*frequencies.x+uv.x*mouse.x*wavelengths.x)*amplitudes.x;    \n    val += sin(iTime*frequencies.y+uv.x*mouse.x*wavelengths.y)*amplitudes.y;\n    val += sin(iTime*frequencies.z+uv.x*mouse.x*wavelengths.z)*amplitudes.z;\n    val/=3.;\n    fragColor = color*(val>uv.y?1.:0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2BD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 564, 621, 621, 1060]]}
{"id": "lsGyzh", "name": "Noise color texture", "author": "jakeactuallynext", "description": "A noise color texture", "tags": ["noisecolortexture"], "likes": 6, "viewed": 343, "published": "Public API", "date": "1565973318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\n\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy1 = fragCoord.xy / 500.0, xy2 = xy1, xy3 = xy1;\n    \n    xy1.x += iTime / 2.0;\n    xy2.x -= iTime / 2.0;\n    xy3.x -= iTime / 2.0;\n    xy3.y -= iTime / 2.0;\n    \n    float a1 = 0.75 - cnoise(xy1);\n    float a2 = 0.75 - cnoise(xy2);\n    float a3 = 0.75 - cnoise(xy3);\n    \n    fragColor = vec4(a1, a2, a3, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 74, 74, 110], [111, 111, 132, 132, 169], [171, 171, 192, 192, 1269], [1271, 1271, 1328, 1328, 1652]]}
{"id": "tl2SD1", "name": "Circles and crosses", "author": "zodiax", "description": "Simple fun with shapes", "tags": ["circle", "cross"], "likes": 2, "viewed": 76, "published": "Public", "date": "1565809003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    _angle *= 3.1415/180.;\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 box(vec2 uvNew, vec2 scale, float orientation, vec2 position)\n{\n    uvNew += vec2(-0.5-position.x,(-0.5-position.y)*iResolution.y/iResolution.x);\n    uvNew *= rotate2d(orientation);\n    float a = 1.-step(scale.x*0.2,abs(uvNew.x));\n    float b = 1.-step(scale.y*0.2,abs(uvNew.y));\n    vec4 col= vec4(vec3(a*b),1.0);\n\n\treturn col;\n}\n\nvec4 crossA(vec2 uvNew, float orientation, vec2 position, vec2 scale)\n{\n\tvec4 crossAComp = box(uvNew, scale, 0.+orientation, position) + box(uvNew, scale, 90.+orientation, position);\n    return clamp(crossAComp,0.,1.);\n}\n\nvec4 circle(vec2 uvNew, float radius, vec2 position)\n{\n    uvNew += vec2(-0.5,(-0.5)*iResolution.y/iResolution.x);\n    float c = pow(uvNew.x-position.x,2.)+pow(uvNew.y-position.y,2.);\n    c = 1. - step(0.01*radius,c);\n\treturn vec4(c);\n}\n\nvec2 grid(vec2 uvNew, float density)\n{\n    uvNew *= density;\n    return vec2(fract(uvNew));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.y *= iResolution.y/iResolution.x;\n    \n    //cross\n    float g = 15.;\n    //float timeFactor = 25.*sin(ceil(uv.x*g) * (iTime)) + 25.*cos(ceil(uv.y*g) * (iTime));\n    float timeFactor = 20.*iTime + ceil(uv.y*g);\n    vec2 cPos = vec2(sin(uv.y*g + iTime *.5)*.1,sin(uv.x*g + iTime*.5)*.1);\n    vec4 crossCol = vec4(1.0,0.5,.3,1.0) * 1.-clamp(vec4(ceil(uv.x*g)/10.) * vec4(ceil(uv.y*g)/10.),0.,9.)+.1;\n    \n    //circle\n    vec2 oPos1 = vec2(sin(iTime+uv.x*g)*0.3,cos(iTime+uv.x*g)*0.3+.2);\n    vec4 circleCol = vec4(1.0,0.0,.3,1.0) * clamp(vec4(ceil(uv.x*g)/10.) * vec4(ceil(uv.y*g)/10.),0.,9.)+.1;\n\n    //final\n    fragColor = circle(grid(uv,g),2.,oPos1)*circleCol;\n    fragColor += crossA(grid(uv,g),timeFactor, cPos, vec2(0.1,2.50))*crossCol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2SD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 141], [143, 143, 211, 211, 478], [480, 480, 551, 551, 700], [702, 702, 756, 756, 938], [940, 940, 978, 978, 1033], [1035, 1035, 1092, 1142, 1931]]}
{"id": "tl2SRD", "name": "MeltyMountains001", "author": "Hirai_worthless", "description": "help", "tags": ["raymarching"], "likes": 5, "viewed": 114, "published": "Public", "date": "1565282171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nfloat map(vec3 p){\n\tfloat time = iTime / 12.0;\n    float h =3. + (sin(p.x + time) + sin(p.z + time)) * 0.4;\n    h += 0.8 * (sin(time)*sin(p.x/4.)*cos(p.z/0.5));\n    h -= sin(time * 0.3) * sin(p.x / 2.);\n    h -= cos(time * 0.75) * cos(p.z / 2.);\n    h -= sin(time * 0.5) * sin(p.x + p.z);\n    h += 0.8 * (cos(time)*sin(p.z/4.)*cos(p.x));\n\treturn abs(p.y) - h;\n\t\n\n}\n\nfloat trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 64; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float PI = 3.14159265;\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv,1.0));\n    vec3 o = vec3(6.0 * sin(iTime / 2.),0,-2.0 - iTime * 2.0);\n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.005);\n    float a = fract(t * uv.y) > 0.1 ? 0. : 1.;\n    vec3 fc = vec3(mix(1.,a,fog));\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2SRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 77], [78, 78, 96, 96, 442], [444, 444, 473, 473, 620], [622, 622, 679, 729, 1176]]}
{"id": "tl2XD1", "name": "metal rain", "author": "foran", "description": "metal rain", "tags": ["metalrain"], "likes": 6, "viewed": 137, "published": "Public", "date": "1565811244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n  const int octaves = 4;\n  \n  float sinnoise(vec3 loc){\n\n      float t = iTime*0.2;\n      vec3 p = loc;\n\n      for (int i=0; i<octaves; i++){\n          p += cos( p.xxz * 3. + vec3(0., t, 1.6)) / 3.;\n          p += sin( p.yzz + t + vec3(t, 1.6, 0.)) / 2.;\n          // p += sin( p.zyx + t * 2. + vec3(0,1.6,t)) / 2.;\n          p *= 1.3;\n      }\n\n      p += fract(sin(p+vec3(13, 7, 3))*5e5)*.03-.015;\n\n       return dot(p, p);\n     // return length(p);\n\n  }\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n  //void main()\n   {\n    vec2 uv = .92*(fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float shade = sinnoise(vec3(uv * 5., 1.));\n    shade = sin(shade) * .53 + .46;\n\n    fragColor = vec4(vec3(shade),1.0);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2XD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 56, 56, 456], [457, 457, 530, 530, 755]]}
{"id": "tl2XDD", "name": "ACG", "author": "yasuo", "description": "ALL CONDITION GEAR", "tags": ["nike", "raymerching"], "likes": 2, "viewed": 243, "published": "Public API", "date": "1565964837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define PI 3.141592653589793\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\n// This formula is from:https://en.wikipedia.org/wiki/Triangle_wave\nfloat triangleWave(vec3 p) {\n    float val = 0.0;\n    float amp = 1.2;\n    float period =12.0;\n    val = (2.0 * amp /PI) * acos(sin(2.0 * (PI / period) *p.x));\n    val += (2.0 * amp /PI) * asin(cos(2.0 * (PI / period) *p.z));\n    return val;\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n    p.z += iTime*20.0;\n\tp.y+= triangleWave(p);\n    \n    vec4 f = vec4(vec3(1.2,1.0,0.3),p.y+5.0);\n    p = pref;\n    \n    float a1 = sdCappedCylinder((p+vec3(0.0,-0.9,0.0))*matRotateY(radians(90.0))*matRotateZ(radians(90.0)), 0.8,0.2);\n    float a2 = sdCappedCylinder((p+vec3(0.0,-0.9,0.0))*matRotateY(radians(90.0))*matRotateZ(radians(90.0)), 0.4,0.3);\n    float a3 = sdBox((p+vec3(-0.65,-1.0,0.0)),vec3(0.2,0.7,0.2));\n    float ad = min(max(-a2,a1),a3);\n    \n    float c1 = sdCappedCylinder((p+vec3(0.9,0.7,0.0))*matRotateY(radians(90.0))*matRotateZ(radians(90.0)), 0.8,0.2);\n    float c2 = sdCappedCylinder((p+vec3(0.9,0.7,0.0))*matRotateY(radians(90.0))*matRotateZ(radians(90.0)), 0.4,0.3);\n    float c3 = sdBox((p+vec3(0.2,0.7,0.0)),vec3(0.9,0.2,0.3));\n    float cd = max(-c3,max(-c2,c1));\n    \n\tfloat g1 = sdCappedCylinder((p+vec3(-0.9,0.7,0.0))*matRotateY(radians(90.0))*matRotateZ(radians(90.0)), 0.8,0.2);\n    float g2 = sdCappedCylinder((p+vec3(-0.9,0.7,0.0))*matRotateY(radians(90.0))*matRotateZ(radians(90.0)), 0.4,0.3);\n    float g3 = sdBox((p+vec3(-1.6, 0.25,0.0))*matRotateZ(radians(-45.0)),vec3(0.7,0.25,0.3));\n    float g4 = sdBox((p+vec3(-1.6, 0.7,0.0)),vec3(0.7,0.2,0.3));\n    float g5 = sdBox((p+vec3(-1.37, 0.8,0.0)),vec3(0.3,0.15,0.3));\n    float gd = min(max(-g4,max(-g3,max(-g2,g1))),g5);\n    \n    float chard = min(min(ad,cd),gd);\n    \n    float bg0 = sdTriPrism(p,vec2(3.2,0.1));\n    vec4 bg = vec4(vec3(1.2,0.5,0.6),max(-chard,bg0));\n    \n    return combine(bg,f);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 3.5*cos(0.1*time + 6.0), 0.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.0, -0.4, -0.7 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float zoom = 1.5;\n    vec3 rd = ca * normalize( vec3(p.xy,zoom) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 60.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.6,0.6,0.6)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    fragColor = vec4(dst, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2XDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 459, 490, 490, 586], [588, 588, 640, 640, 747], [749, 749, 785, 785, 872], [874, 874, 910, 910, 985], [987, 1055, 1083, 1083, 1298], [1300, 1300, 1317, 1317, 2853], [2855, 2855, 2878, 2878, 3155], [3157, 3157, 3191, 3191, 3501], [3503, 3534, 3574, 3574, 3870], [3872, 3872, 3924, 3924, 4113], [4115, 4115, 4171, 4171, 5880]]}
{"id": "tl2XDy", "name": "Color from Bricks", "author": "gressettd", "description": "Playing with patterns that produce several variables for multiple perspectives on the pattern to drive color control.", "tags": ["color", "brick"], "likes": 1, "viewed": 51, "published": "Public", "date": "1567030245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 ComputeRegularBrickTilePattern(vec2 pos, vec2 box, float gap, float brickLum, float gapLum)\n{\n\tfloat width = box.x;\n\tfloat height = box.y;\n\t\t\n\tfloat brickAndMortarWidth = width + gap;\n\tfloat brickAndMortarHeight = height + gap;\n\tfloat mwf = (gap * 0.5 / brickAndMortarWidth);\n\tfloat mhf = (gap * 0.5 / brickAndMortarHeight);\n\n\t\n\tfloat row = pos.y / height;\n\tfloat x = 0.0;\n\tfloat y = fract(row);\n\tif (fract(row * 0.5) > 0.5)\n\t{\n\t\tx = fract((pos.x + width / 2.0) / width);\n\t}\n\telse\n\t{\n\t\tx = fract(pos.x / width);\n\t}\n\n\tfloat horizontal = step(mwf, x) - step(1.0 - mwf, x);\n\tfloat vertical = step(mhf, y) - step(1.0 - mhf, y);\n\tfloat lum = mix(gapLum, brickLum, horizontal * vertical);\n\tvec4 retval = vec4(lum, x, y, floor(row));\n\treturn retval;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= float(iResolution.y) / float(iResolution.x);\n    \n    uv += vec2(0.0,iTime* 0.1);\n\n    vec4 cc = ComputeRegularBrickTilePattern(uv,\n                                             vec2(0.3,0.15),\n                                             0.01,\n                                             0.8,0.25);\n\tfloat lum = cc.x * (cc.y+cc.z);\n    vec3 color = vec3( 0.5*(sin(cc.w * 3.14)) + 1.0,\n                       0.5*(sin((cc.w + cc.y)*3.14)) + 1.0,\n                       0.5*(sin((cc.w + cc.z)*3.14)) + 1.0);\n    color = clamp(lum * color, 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2XDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 98, 98, 749], [752, 752, 809, 859, 1524]]}
{"id": "tl2XDz", "name": "My first shader - street road", "author": "saoricih", "description": "my first shader", "tags": ["road"], "likes": 2, "viewed": 82, "published": "Public", "date": "1566856205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//isso é equivalente ao fragment shader\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n\n    // Output to screen\n   fragColor = vec4(0.3,0.3,0.3,1);\n    \n    \n     if(uv.x>(cos(iTime+uv.y)+3.0)/10.0)\n    {\n        fragColor = vec4(1,.8,0,1)  ;\n    }\n    \n    \n    if(uv.x>(cos(iTime+uv.y)+3.5)/10.0)\n    {\n        fragColor = vec4(1,1,1,1)  ;\n    }\n    \n     \t\n    \n    \tif(uv.x>(cos(iTime+uv.y)+4.5)/10.0)\n    {\n        if(uv.x>(cos(iTime+uv.y)+5.0/10.0))\n       \n    \t\tif(mod(uv.y*10.0,2.0) >0.9){\n    \n       \t\t fragColor = vec4(0,0,0,1);\n               \n    }\n\n    \n    }\n    \n\n    \n        if(uv.x>(cos(iTime+uv.y)+4.7)/10.0)\n    {\n        fragColor = vec4(1,1,1,1)  ;\n    }\n    \n    \n    \n    \n    if(uv.x>(cos(iTime+uv.y)+5.5)/10.0)\n    {\n        fragColor = vec4(1,.8,0,1)  ;\n    }\n    \n       if(uv.x>(cos(iTime+uv.y)+6.0)/10.0)\n    {\n        fragColor = vec4(0.3,0.3,0.3,1)  ;\n    }\n    \n       \n  \n \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2XDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 42, 99, 149, 1021]]}
{"id": "tl2XRR", "name": "two waves", "author": "foran", "description": "two waves", "tags": ["twowaves"], "likes": 1, "viewed": 144, "published": "Public", "date": "1564854308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\n\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\tvec2 splines = vec2(pow(1.0-abs(position.y-cos(position.x*9.0+(iTime*0.912))/5.0-0.75),40.0),\n\t\t\t    pow(1.0-abs(position.y+cos(position.x*7.0+(iTime*0.934))/3.0-0.45),50.0));\n\t\n\tsplines += pow(splines.x+splines.y, 2.0);\n\t\n\tvec3 color = vec3(0.15 * splines.x * splines.y,\n\t\t\t  0.15 * splines.x * splines.y,\n\t\t\t  0.8 * splines.x * splines.y);\n\t\n\t\n\tfragColor = vec4( color.r,color.g,color.b, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2XRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 100, 100, 553]]}
{"id": "tlB3zK", "name": "simple 2D clouds", "author": "zxxuan1001", "description": "2d clouds", "tags": ["noise", "clouds"], "likes": 20, "viewed": 1322, "published": "Public API", "date": "1566451688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//noise function from iq: https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nconst mat2 m2 = mat2(1.6,  1.2, -1.2,  1.6);\n\nfloat fbm4(vec2 p) {\n    float amp = 0.5;\n    float h = 0.0;\n    for (int i = 0; i < 4; i++) {\n        float n = noise(p);\n        h += amp * n;\n        amp *= 0.5;\n        p = m2 * p ;\n    }\n    \n\treturn  0.5 + 0.5*h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 sky = vec3(0.5, 0.7, 0.8);\n    vec3 col = vec3(0.0);\n    \n    // speed\n    float v = 0.001;\n\n    // layer1\n    vec3 cloudCol = vec3(1.0);\n    uv += mo * 10.0;\n   \n    vec2 scale = uv * 2.0;\n    vec2 turbulence = 0.008 * vec2(noise(vec2(uv.x * 10.0, uv.y *10.0)), noise(vec2(uv.x * 10.0, uv.y * 10.0)));\n    scale += turbulence;\n\tfloat n1 = fbm4(vec2(scale.x - 20.0 * sin(iTime * v * 2.0), scale.y - 50.0 * sin(iTime * v)));\n    col = mix( sky, cloudCol, smoothstep(0.5, 0.8, n1));\n    \n    //layer2\n    scale = uv * 0.5;\n    turbulence = 0.05 * vec2(noise(vec2(uv.x * 2.0, uv.y * 2.1)), noise(vec2(uv.x * 1.5, uv.y * 1.2)));\n    scale += turbulence;\n    float n2 = fbm4(scale + 20.0 * sin(iTime * v ));\n    col =  mix( col, cloudCol, smoothstep(0.2, 0.9, n2));\n    col = min(col, vec3(1.0));\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlB3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 65, 87, 87, 202], [204, 204, 230, 230, 709], [757, 757, 777, 777, 977], [979, 979, 1036, 1086, 2088]]}
{"id": "tlBSDz", "name": "pattern-texture-0", "author": "lilieming", "description": "just coding", "tags": ["texturepatternmath"], "likes": 1, "viewed": 40, "published": "Public", "date": "1565578117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float x = 40. * uv.x;     \n    float y = 40. * uv.y;     \n    float s = sin(x + 2.*iTime) + sin(y);  //[-2 2]\n    float c = step(0., s); \n\n    vec3 color = vec3(c, c, c); \n                                \n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 511]]}
{"id": "tlBSRh", "name": "mandelbrother", "author": "foran", "description": "mandelbrother", "tags": ["mandelbrother"], "likes": 6, "viewed": 122, "published": "Public", "date": "1564989792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Simple Mandelbulb - by @SyntopiaDK\n// (The camera code and lightning was taken from an example by @mrdoob)\n\nfloat PI=3.14159265;\n#define Power 8.0\n#define Bailout 4.0\n\nvoid powN1(inout vec3 z, float r, inout float dr) {\n\t// extract polar coordinates\n\tfloat theta = acos(z.z/r);\n\tfloat phi = atan(z.y,z.x);\n\tfloat power = Power*cos(iTime*0.001+length(iMouse)*0.009);\n\tdr =  pow( r, power-1.0)*power*dr + 1.0 + pow((1.-cos(iTime*.3)*cos(iTime*.2)), -2.5);\n\t\n\t// scale and rotate the point\n\tfloat zr = pow( r,power);\n\ttheta = theta*power;\n\tphi = phi*power;\n\t\n\t// convert back to cartesian coordinates\n\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n}\n\n\n// Compute the distance from `pos` to the Mandelbox.\nfloat DE(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=1.0;\n\tr=length(z);\n\tfor(int i=0; (i < 5); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tif (r>Bailout) break;\n\t}\n\t\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 DEColor(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=1.0;\n\tr=length(z);\n\tfloat minR = 1000.0;\n\tfor(int i=0; (i < 2); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tminR = min(r,minR);\n\t\tif (r>Bailout) break;\n\t}\n\tfloat i = minR*minR*minR*minR*0.70;\n\treturn vec3(clamp(i,0.0,1.0));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n//void main(void)\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n\n  //Camera animation\n  vec3 vuv=vec3(0,1,0);//Change camere up vector here\n  vec3 vrp=vec3(0,0,0); //Change camere view here\n  float mx=iMouse.x*PI*0.009;\n  float my=iMouse.y*PI*0.009;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*2.0; //Trackball style camera pos\n  \n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  //Raymarching\n  const vec3 e=vec3(0.001,0,0);\n  const float maxd=5.0; //Max depth\n  float s=0.0;\n  vec3 c,p,n;\n\n  float f=0.010;\n  for(int i=0;i<512;i++){\n    f+=s;\n    p=prp+scp*f;\n    s=DE(p);\n     if (abs(s)<.000525||f>maxd) break;\n   \n  }\n  \n  if (f<maxd){\n    n=normalize(\n      vec3(s-DE(p-e.xyy),\n           s-DE(p-e.yxy),\n           s-DE(p-e.yyx)));\n    c = DEColor(p);\n    c.yz = mix(c.yz, n.yz, 0.3);\n    float b=dot(n,normalize(prp-p));  \n    fragColor = mix(vec4((b*c+pow(b,16.0))*(1.0-f*.01),1.0), vec4(c,1.0),0.58);\n  }\n  else fragColor=vec4(.9,.9,.9,1); //background color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 216, 267, 297, 715], [718, 771, 791, 791, 971], [973, 973, 997, 997, 1263], [1265, 1265, 1337, 1337, 2493]]}
{"id": "tlBSzd", "name": "Procedural Creatures", "author": "thiagoborn", "description": "Some strange simple procedural creatures and animations\nThere is a new one each 10 seconds ", "tags": ["procedural", "2d", "sdf", "animation", "creature"], "likes": 13, "viewed": 389, "published": "Public API", "date": "1566798650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat srand(float n) {\n    return rand(n)*2.-1.;\n}\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n#define PI (3.1415*2.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 _uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float d = 10000000.;\n    float i = float(int(iTime/10.)+1234);\n    i = rand(i);\n    for(int b=0;b<3;b++){\n\t    vec2 last = vec2(0.0);\n    \tfloat la = 0.0;\n        for(int x=0;x<10;x++){\n            float a = srand(i++)*2.1415;\n            float s = .5+.5*rand(i++);\n            s*=.2;\n            // move\n            a += smoothstep(-.5,.5,sin(iTime*1.5))* srand(i++)*.2;\n            // preparation\n            a += sin(iTime*3.0)* srand(i++)*.25;\n            // breathe\n            //a += sin(iTime*1.0)* srand(i++)*.04;\n            // pulse\n            //a += smoothstep(.5,1.,sin(iTime*6.))* srand(i++)*.01;\n            a += la;\n            vec2 opos = last + vec2(sin(a),cos(a))*s;\n            float bs = rand(i++);\n            float ls = rand(i++);\n            float ma = rand(i++);\n            for(int k=0;k<2;k++){\n                vec2 uv = k==1?_uv:_uv*vec2(-1.,1.);\n\n                float o1 = lineDist(uv,opos,last,.02+ls*.03);\n                float o2= length( uv - opos)- (.01+bs*.02);\n                float o = min(o1,o2);\n                //d = smoothMerge(d,o,.01 + ma * .05);        \n                d= min(d,o);\n            }        \n            la = a;\n            last = opos;        \n        }\n    }\n\n    \n    vec3 col = draw_distance(d,_uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 43, 43, 151], [152, 152, 177, 177, 210], [212, 212, 239, 239, 301], [303, 303, 340, 340, 773], [775, 775, 796, 796, 840], [842, 842, 864, 864, 892], [894, 894, 953, 953, 1141], [1142, 1142, 1190, 1190, 1291], [1316, 1316, 1373, 1373, 2758]]}
{"id": "tlBSzh", "name": "Octa", "author": "nounoursheureux", "description": "Hello", "tags": ["raymarching"], "likes": 7, "viewed": 104, "published": "Public", "date": "1565368684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_STEPS 200\n#define EPSILON 0.001\n#define GRAD_STEP 0.02\n#define SCALE(sdf, s, p, __VA_ARGS__) s * sdf(p/s, __VA_ARGS__)\n#define MAX_DIST 100.\n\n#define WATER_I 0\n#define OCTA_I 1\n// TODO: colors, lighting, clouds ? \n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    float d = length(vec3(q.x,q.y-s+k,q.z-k));\n    return d;\n}\n\n/* float sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n} */\n\nmat2 rotate2D(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdWater(vec3 p)\n{\n    p.z += 10.;\n    p.y += 5.;\n    float u = length(p.xz);\n    float c = sin(.5 * u - iTime);\n   \tp.y += c * 0.5 * u * exp(1. - sqrt(u)*0.9);\n    float d = abs(p.y)-0.5;\n    return d;\n}\n\n\nvec2 min2(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat rnd(float t)\n{\n    return fract(sin(t*794.535)*567.562);\n}\n\nfloat curve(float t, float d)\n{\n    float g = t/d;\n    return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0., 1., fract(g)), 10.));\n}\n\nvec2 sdCool(vec3 p)\n{\n    p.y -= 7.;\n    p.xz = rotate2D(iTime + curve(iTime, 0.4) * 1.5) * p.xz;\n    p.xy = rotate2D(iTime * 0.4 + curve(iTime, 0.6) * 1.5) * p.xy;\n    vec2 res = vec2(sdOctahedron(p, 5.), OCTA_I);\n    return res;\n}  \n\nvec2 sdScene(vec3 p)\n{\n    float t = mod(iTime, 0.8);\n    float fac = 1.0 + 5.0 * t * exp(1.0 - 10.0 * t);\n    float k = 4.0 * sin(2.0*iTime);\n    \n    vec2 res = vec2(sdWater(p), WATER_I);\n    \n    res = min2(res, sdCool(p));\n    \n    return res;\n}\n\nvec3 gradient(vec3 p)\n{\n    vec3 dx = vec3(GRAD_STEP, 0.0, 0.0);\n    vec3 dy = vec3(0.0, GRAD_STEP, 0.0);\n    vec3 dz = vec3(0.0, 0.0, GRAD_STEP);\n    \n    return vec3(sdScene(p + dx).x - sdScene(p - dx).x,\n                sdScene(p + dy).x - sdScene(p - dy).x,\n                sdScene(p + dz).x - sdScene(p - dz).x);\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(gradient(p));\n}\n\nfloat haloScale(float h)\n{\n\treturn 0.2 * pow(h, .4);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // coords from -1 to 1\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    uv.x /= aspect;\n    \n\tvec3 ro = vec3(0.0, 5., 20.0);\n    vec3 target = vec3(uv, 0.0);\n    vec3 rd = normalize(target - vec3(0., 0., 1.));\n    \n    vec3 bg = vec3(.5, .6, .7);\n    vec3 waterCol = vec3(.1, 0., .1);\n    \n    float t = 0.0;\n    float halo = 0.;\n    \n    vec3 c = vec3(1.);\n    \n    for (int i = 0; i < NUM_STEPS && t <= MAX_DIST; i++)\n    {\n        vec3 p = ro + t * rd;\n        vec2 res = sdScene(p);\n        float dst = res.x;\n        \n        halo += 0.2 / (0.2 + sdCool(p).x);\n\n        if (dst < EPSILON + rnd(sin(uv.x + iTime)*sin(uv.y + iTime))* 0.001) {\n            break;\n        }\n    \tt += dst;\n    }\n\t\n    if (halo == 0.) {\n        fragColor = vec4(0., 0., 1., 1.);\n        return;\n    }\n    // Output to screen\n    float noise = rnd(sin(uv.x + iTime) * sin(uv.y + iTime));\n    halo = haloScale(halo);\n    fragColor = vec4(c * (halo + noise * 0.02), 1.);\n    //fragColor = vec4(bg,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 227, 271, 271, 585], [587, 696, 720, 720, 772], [774, 774, 797, 797, 983], [986, 986, 1013, 1013, 1045], [1047, 1047, 1067, 1067, 1111], [1113, 1113, 1144, 1144, 1254], [1256, 1256, 1277, 1277, 1488], [1492, 1492, 1514, 1514, 1741], [1743, 1743, 1766, 1766, 2062], [2064, 2064, 2085, 2085, 2122], [2124, 2124, 2150, 2150, 2178], [2182, 2182, 2237, 2264, 3297]]}
{"id": "tlBSzR", "name": "Cookies", "author": "dr2", "description": "More yummies from the chocolate factory", "tags": ["raymarch", "repetition", "chocolate"], "likes": 8, "viewed": 362, "published": "Public API", "date": "1564750071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Cookies\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 ltDir, flPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize, bRad, nArm, armDir, armFrq;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, bLen, h, r;\n  d = dstFar;\n  if (isOcc) {\n    bLen = 0.5;\n    p.y -= 0.02;\n    p.xz -= HexToPix (gId * hgSize);\n    q = p;\n    r = length (q.xz);\n    q.xz = Rot2D (q.xz, armDir * (0.1 * pi * r * (1. + 0.1 * sin (2. * pi * armFrq * r))\n       - 0.03 * pi * q.y * (1. + sin (2. * pi * 1.5 * r))));\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (nArm * atan (q.z, - q.x) / (2. * pi) + 0.5) / nArm));\n    q.x += bLen;\n    h = 0.25 * (1. - q.x / bLen);\n    h = 0.3 * (1. - 3.2 * h * h);\n    q.y -= h + 0.05;\n    d = length (max (abs (q) - vec3 (bLen, h, 0.001 * (1. + 12. * q.x) * (4. - 20. * q.y)), 0.)) - 0.05;\n    q = p;\n    q.y -= 0.35;\n    d = SmoothMin (d, PrCylDf (q.xzy, 0.01, 0.35), 0.03);\n    q = p;\n    q.y -= -1.25;\n    d = 0.8 * SmoothMin (d, - SmoothMin (min (bRad - length (q), q.y - 1.25), 2.2 * bLen -\n       r, 0.05), 0.05);\n  }\n  return d;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 fRand;\n  float emFrac;\n  emFrac = 0.02;\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  isOcc = (fRand.y >= emFrac);\n  if (isOcc) {\n    nArm = 6. + floor (20. * fRand.x);\n    armDir = 2. * floor (mod (32. * fRand.x, 2.)) - 1.;\n    fRand.y = (fRand.y - emFrac) / (1. - emFrac);\n    armFrq = 2. + 6. * fRand.y;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.03, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, s;\n  bool needSh;\n  bRad = 1.75;\n  needSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    s = length (ro - vec3 (HexToPix (gId * hgSize), 0.02 - 1.25).xzy) - bRad - 0.003;\n    col4 = mix (mix (vec4 (0.7, 0.4, 0., 0.05), vec4 (0.3, 0.1, 0., 0.1),\n       step (0.6, Fbm2 (16. * ro.xz))), vec4 (1., 1., 1., 0.5), smoothstep (0., 0.02, s));\n    s = step (0., s);\n    vn = VaryNf ((8. + 56. * s) * ro, vn, 4. - 3. * s);\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 16.);\n    needSh = true;\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col = vec3 (0.6, 0.6, 0.7) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.3 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (dstObj < dstFar) {\n      gId = PixToHex (ro.xz / hgSize);\n      SetGrObjConf ();\n      s = length (ro.xz - HexToPix (gId * hgSize));\n      if (isOcc) col *= 0.7 + 0.3 * smoothstep (1., 1.2, s);\n      else if (s < 1.) col = mix (col, vec3 (0.7, 0.4, 0.),\n         step (1.2, Fbm2 (32. * ro.xz) + Fbm2 (32. * Rot2D (ro.xz, 0.22 * pi))) *\n         (1. - smoothstep (0.5, 1.5, s)));\n      needSh = true;\n    }\n  } else {\n    col = vec3 (0.6, 0.6, 0.6);\n  }\n  if (needSh) col *= ObjSShadow (ro, ltDir);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return t * vec3 (0.1, 0., sqrt (0.99)) + vec3 (2. * cos (0.1 * t), 0., 0.);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\n#define AA  1 \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 1.4;\n  VuPM (0.9 * tCur);\n  az = 0.;\n  el = -0.1 * pi;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  flPos.y += 10.;\n  ro = flPos;\n  zmFac = 8. + 4. * sin (0.02 * 2. * pi * tCur);\n  dstFar = 50.;\n  ltDir = normalize (vec3 (-1.3, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    rd = rd * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBSzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 542, 564, 564, 1435], [1437, 1437, 1459, 1459, 1788], [1790, 1790, 1823, 1823, 2926], [2928, 2928, 2949, 2949, 3139], [3141, 3141, 3178, 3178, 3603], [3605, 3605, 3640, 3640, 5101], [5103, 5103, 5129, 5129, 5209], [5211, 5211, 5232, 5232, 5830], [5848, 5848, 5904, 5904, 7095], [7097, 7097, 7139, 7139, 7190], [7192, 7192, 7216, 7216, 7446], [7448, 7448, 7472, 7472, 7532], [7534, 7534, 7556, 7556, 7594], [7596, 7596, 7641, 7641, 7744], [7746, 7746, 7776, 7776, 7889], [7923, 7923, 7947, 7947, 8077], [8079, 8079, 8104, 8104, 8290], [8292, 8292, 8313, 8313, 8468], [8470, 8470, 8499, 8499, 8711], [8713, 8713, 8752, 8752, 8932]]}
{"id": "tlBXD3", "name": "the clouds", "author": "foran", "description": "the clouds", "tags": ["theclouds"], "likes": 14, "viewed": 276, "published": "Public", "date": "1567276434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int octaves=12;\nconst float seed=43758.5453123;\nconst float seed2=73156.8473192;\nconst vec3 color1=vec3(.101961,.619608,.666667);//color\nconst vec3 color2=vec3(.666667,.666667,.498039);//color\nconst vec3 color3=vec3(0,0,.164706);//color\nconst vec3 color4=vec3(.666667,1.,1.);//color\n\nfloat rand(vec2 co){\n\t// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise2f( in vec2 p )\n{\n\tvec2 ip = vec2(floor(p));\n\tvec2 u = fract(p);\n\t// http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n\tu = u*u*(3.0-2.0*u);\n\t//u = u*u*u*((6.0*u-15.0)*u+10.0);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),  rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),   rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n\t//return 2.0* (res-0.5);\n}\n\n\nfloat fbm(vec2 c) {\n\tfloat f = 0.0;\n\tfloat w = 1.0;\n\tfor (int i = 0; i < 12; i++) {\n\t\tf+= w*noise2f(c);\n\t\tc*=2.0;\n\t\tw*=0.5;\n\t}\n\treturn f;\n}\n//--------------\nvec2 random2(vec2 st,float seed){\n\tst=vec2(dot(st,vec2(127.1,311.7)),\n\tdot(st,vec2(269.5,183.3)));\n\treturn-1.+2.*fract(sin(st)*seed);\n}\n\nfloat noise(vec2 st,float seed){\n\tvec2 i=floor(st);\n\tvec2 f=fract(st);\n\t\n\tvec2 u=f*f*(3.-2.*f);\n\t\n\treturn mix(mix(dot(random2(i+vec2(0.,0.),seed),f-vec2(0.,0.)),\n\tdot(random2(i+vec2(1.,0.),seed),f-vec2(1.,0.)),u.x),\n\tmix(dot(random2(i+vec2(0.,1.),seed),f-vec2(0.,1.)),\n\tdot(random2(i+vec2(1.,1.),seed),f-vec2(1.,1.)),u.x),u.y);\n}\nfloat fbm1(in vec2 _st){\n\tfloat v=0.;\n\tfloat a=.95;//                       резкость\n\tvec2 shift=vec2(100.);\n\t// Rotate to reduce axial bias\n\tmat2 rot=mat2(cos(.5),sin(.5),\n\t-sin(.5),cos(.50));\n\tfor(int i=0;i<octaves;++i){\n\t\tv+=a*noise(_st,seed);\n\t\t_st=rot*_st*2.+shift;\n\t\ta*=.45;\n\t}\n\treturn v+.5014;//                яркость\n}\n//-----------\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nfloat pattern(  vec2 p, out vec2 q, out vec2 r )//        туманные облака (не резко)\n{\n\t\n\tq.x = fbm1( p  +0.00*iTime*.5);\n\tq.y = fbm1( p + vec2(1.0));\n\t//r=cMul(q,q);\n\tr.x = fbm1( p +1.0*q + vec2(1.7,9.2)+0.15*iTime*.5 );\n\tr.y = fbm1( p+ 1.0*q + vec2(8.3,2.8)+0.126*iTime*.5);\n   //\tr = cMul(q,q);\n\treturn fbm1(p +1.0*r + 0.0* iTime*.5);\n}\n\n\nvec3 colour(vec2 c,vec2 q,vec2 r) {\n\tfloat f = pattern(c,q,r)*1.1;//                 яркость 1.1\n\tvec3 col = mix(color1,color2,clamp((f*f)*4.0,0.0,1.0));\n\tcol = color2;\n\tcol = mix(col,color3,clamp(length(q),0.0,1.0));\n\tcol = mix(col,color4,clamp(length(r.x),0.0,1.0));\n\treturn (f*f+0.452)*col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec2 q=vec2(0.,0.);\n  vec2 r=vec2(0.,0.);\n  vec3 col=colour(uv,q,r);\n  fragColor=vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 290, 310, 383, 452], [454, 454, 482, 482, 831], [834, 834, 853, 853, 973], [974, 991, 1024, 1024, 1126], [1128, 1128, 1160, 1160, 1457], [1458, 1458, 1482, 1482, 1800], [1801, 1815, 1842, 1842, 1899], [1901, 1901, 2008, 2008, 2261], [2264, 2264, 2299, 2299, 2566], [2568, 2568, 2621, 2621, 2778]]}
{"id": "tlBXRw", "name": "Noise Square Tunnel 2.5D", "author": "Yusef28", "description": "I was trying to make something else but this is cool too I guess", "tags": ["2d", "tunnel", "shadow", "square"], "likes": 20, "viewed": 277, "published": "Public", "date": "1565832211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    st/=2.;\n    st+=iTime/8.;\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value/2000.;\n}\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\nfloat shadowCircle(vec2 p, float r, float i)\n    {\n        p +=vec2(0.02, 0.02)*rot(iTime/100.);//light direction\n        \n        float a  =atan( p.y,p.x);\n        float shape = fbm(p);//sin(a*i+i/1.*iTime/10.+iTime)/10.;\n \tfloat ss = 0.07;\n    float k = 1.0-smoothstep(r-ss, r+ss, max(abs(p.x),abs(p.y))-0.2+shape);\n    return pow(k,1.1);\n}\n\nfloat rimCircle(vec2 p, float r, float i)\n{\n    float a  =atan( p.y,p.x);\n    float shape = fbm(p);//sin(a*i+i/1.*iTime/10.+iTime)/10.;\n \tfloat ss = 0.004;//0.0053\n    \n    float rim = 0.004;\n    float k = smoothstep(r-ss, r+ss, max(abs(p.x),abs(p.y))-0.2+shape);\n    float k2 = smoothstep(r-ss+rim, r+ss+rim, max(abs(p.x),abs(p.y))-0.2+shape);\n    k =k-k2;\n    return clamp(k/2., 0.0, 1.);\n}\n\nfloat Circle(vec2 p, float r, float i)\n{\n \tfloat ss = 0.009;\n    float a  =atan( p.y,p.x);\n    float shape = fbm(p);//sin(a*i+i/1.*iTime/10.+iTime)/10.;\n    \n    float k = smoothstep(r-ss, r+ss, max(abs(p.x),abs(p.y))-0.2+shape);   \n    return k+rimCircle(p,r-0.001, i);//shadowCircle(p,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n   uv/=1.5;\n    \n    ///uv.x+=0.5;\n    float t1 = vec3(texture(iChannel0,uv)).x;\n    float t2 = vec3(texture(iChannel1,uv)).x;\n    vec3 col = vec3(0.9);\n    vec3 col2 = vec3(0.);\n    // Time varying pixel color\n    float druck = 0.0;\n    //uv-=vec2(2.);\n    //col = mix(col, vec3(1.), rimCircle(uv, 0.8));\n\n    float num = 20.;\n    float minWidth = -0.2;\n    for(float i = 0.;i<num;i++){\n        uv/= .9+mod(fract(i +iTime/20.), 0.4);\n            \n        uv*=rot(i+iTime/30.*random(vec2(i*8.+1., i+1.))*2.);\n        t1 = vec3(texture(iChannel0,uv/2.)).x;\n        t2 = vec3(texture(iChannel1,uv/1.)).x;\n\n    \tcol *=shadowCircle(uv, minWidth+i/num, i);  \n        \n        //color wahle\n        col2 = vec3( 0.2+i/num, 0.2+i/num, 1.);\n        col2 = vec3( 0.2+i/num*1., 0.2+i/num/2., 0.3)+0.1;\n        //col2 = vec3( pow(i/num, 3.), pow(i/num, 2.),pow(i/num, 3.))+0.3;\n        col2 = vec3( pow(i/num, 4.), pow(i/num, 2.),pow(i/num, 1.5))+0.65;\n\n    col = mix(col, col2 -t1*step(1.,mod(i,2.))-t2*1.2*(1.0-step(1.,mod(i,2.))), Circle(uv, minWidth+i/num, i));\n\tcol = mix(col, col2, rimCircle(uv, minWidth+i/num, i)*i/num);\n    //uv+=vec2(0.4,0.2);\n        \n    }\ncol = sin(col+0.05);    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1.)),1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [137, 215, 241, 241, 621], [641, 641, 665, 665, 977], [978, 978, 997, 997, 1049], [1050, 1050, 1100, 1100, 1392], [1394, 1394, 1437, 1437, 1786], [1788, 1788, 1828, 1828, 2080], [2082, 2082, 2139, 2189, 3541]]}
{"id": "tlBXWK", "name": "Storming Cubes", "author": "leon", "description": "Having fun with motion blur\n", "tags": ["cube", "storm"], "likes": 29, "viewed": 694, "published": "Public API", "date": "1567089624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Storming Cubes\n// inspired by Inigo Quilez live stream shader deconstruction\n// Leon Denise (ponk) 2019.08.28\n// Licensed under hippie love conspiracy\n\n// Using code from\n// Inigo Quilez\n// Morgan McGuire\n\n// tweak zone\nconst float range = .4;\nconst float radius = .065;\nconst float blend = .7;\nconst float balance = 2.0;\nconst float falloff = 1.5;\nconst int count = 5;\n\n// increment it at your own GPU risk\nconst float motion_frames = 10.;\n\n// tool box\nconst float TAU = 6.283;\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nfloat sdBox (vec3 p, vec3 b) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\nfloat geometry (vec3 pos, float time) {\n    float a = 1.0;\n    float scene = 1.;\n    float t = time * .5;\n    float ft = smoothstep(0.,.9,pow(fract(t),.7));\n    t = floor(t)+ft;\n    float w = sin(ft*3.1415);\n    for (int i = count; i > 0; --i) {\n        pos.xy *= rot(cos(t)*balance/a+a*2.);\n        pos.zy *= rot(sin(t)*balance/a+a*2.);\n        pos = abs(pos)-(range+w*.2)*a;\n        \n        a /= falloff;\n    }\n    scene = sdBox(pos, vec3(radius*(1.1-w)));\n    return scene;\n}\n\nfloat raymarch ( vec3 eye, vec3 ray, float time, out float total ) {\n    total = 0.0;\n    const int count = 10;\n    for (int index = count; index > 0; --index) {\n        float dist = geometry(eye+ray*total,time);\n        total += dist;\n        if (dist < 0.001 * total)\n            return float(index)/float(count);\n    }\n    return 0.;\n}\n\nvec3 camera (vec3 eye) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if (iMouse.z > 0.5) {\n        eye.yz *= rot(mouse.y*3.1415);\n        eye.xz *= rot(mouse.x*3.1415);\n    } else {\n        eye = vec3(1,3.5,1.);\n    }\n    return eye;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = camera(vec3(0,0,3.5));\n    vec3 ray = look(eye, vec3(0), uv, 2.);\n    float total = 0.;\n    fragColor = vec4(0);\n    for (float index = motion_frames; index > 0.; --index) {\n        float dither = random(ray.xy+fract(iTime+index));\n        float time = iTime+(dither+index)/10./motion_frames;\n        fragColor += vec4(raymarch(eye, ray, time,total))/motion_frames;\n    }\n    fragColor = vec4(pow(fragColor.r, .3));\n    \n    // extra color\n    fragColor.rgb *= vec3(.8,.85,.8);\n    float d = smoothstep(4.,0.,total);\n    fragColor.rgb += vec3(0.9,.5,.4) * d;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXWK.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[445, 482, 504, 504, 592], [593, 593, 612, 612, 662], [663, 663, 708, 708, 782], [783, 783, 813, 813, 896], [897, 897, 956, 956, 1177], [1179, 1179, 1218, 1218, 1658], [1660, 1660, 1728, 1728, 1998], [2000, 2000, 2024, 2024, 2244], [2246, 2246, 2303, 2303, 2942]]}
{"id": "tlBXWy", "name": "Funky circle", "author": "zodiax", "description": "circle", "tags": ["circle"], "likes": 3, "viewed": 63, "published": "Public", "date": "1566930046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float drawCircle(vec2 uvN, float radius, float width)\n{\n\tfloat a = distance(vec2(0.),uvN);\n    a = step(a,radius) - step(a, radius - width);\n    return a;\n}\n\nfloat distort(float base, vec2 uvN)\n{\n    base *= sin(uvN.x/iResolution.x*sin(iTime/20.)*1000.);\n    return base;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy/2.)/iResolution.x*800.;\n    float cSize = distort(200., uv);\n\tvec3 col = vec3(drawCircle(uv, cSize, 125.))*fragCoord.x/iResolution.x;\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 156], [158, 158, 195, 195, 273], [275, 275, 332, 332, 546]]}
{"id": "tlBXzd", "name": "Waves - symplectic integrator", "author": "iq", "description": "This shader compares three different ways to integrate sin/cos in order to compute cos/sin without trigonometric functions.", "tags": ["2d", "wave", "cosine", "integrator"], "likes": 18, "viewed": 1199, "published": "Public API", "date": "1566785150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Symplectic Integrator, motivated by this tweet by MMalex\n// and Fabian Giesen's explanation:\n// https://twitter.com/mmalex/status/1165757266601099276\n//\n// The shader compares different ways to integrate sin/cos in\n// order to compute cos/sin without trigonometrics.\n//\n// Choose a METHOD for comparison\n//\n// 0 Red:    naive Euler way. Explodes quickly\n// 1 Yellow: normalizing the naive way. Stable, but drifts\n// 2 Blue:   symplectic integrator, pretty close to perfect\n// 3 Green:  rotation based, perfect\n//   Grey:   ground truth\n\n#define METHOD 2\n\n//---------------------------------------------\n\n\n\n// Ground truth cs for reference.\nvec2 waveExact( int x, const float w )\n{\n    return vec2(cos(w*float(x)),sin(w*float(x)));\n}\n\n\n// The naive method is to integrate each component\n// sequentially. It's equivalent to rotating the vector\n// cs by M = {1, -w, w, 1}, which is a poor approximation\n// to the rotation and more importantly has determinant\n// |M| = 1+w² > 1, which means it's going to explore rapidly.\nvec2 waveEulerNaive( int x, const float w )\n{\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs += w*vec2(-cs.y,cs.x);\n    }\n    return cs;\n}\n\n\n// The naive fix to the naive method is to renormalize\n// the vector cs after each tansformation. This doesn't\n// work neither in the long run, since it doesn't fix the\n// drifting. See yellow graph.\nvec2 waveEulerNormalized( int x, const float w )\n{\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs += w*vec2(-cs.y,cs.x);\n        cs = normalize( cs );\n    }\n    return cs;\n}\n\n// Symplectic integration - instead of updating the value\n// and its derivative at the same time (like in a normal\n// Euler integration), it updates the derivative and then\n// the value based on the updated derivative (Verlet style).\n// See https://en.wikipedia.org/wiki/Symplectic_integrator,\n// and make p=cos, q=sin, H=1, T(x)=x^2, V(x)=x^2, and use the\n// first order integrator.\n//\n// It is equivalent to transforming the vector cs each time\n// with M = {1, -w, w, 1-w²}, which has determinant |M|=1\n// (won't explode). Sometimes it will produce a vector a bit\n// longer than the true cs wave, and sometimes shoter, but\n// it oscillates regularly around the true length.\nvec2 waveSymplectic( int x, const float w )\n{\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs.x-=w*cs.y;\n        cs.y+=w*cs.x; \n    }\n    return cs;\n    \n    // measure deviation from unity length\n    // return vec2( (4.0/w)*(length(cs)-1.0), 0.0 );\n    \n    // measure deviation from true cs coordinates\n    // return vec2( (4.0/w)*length(cs-waveExact(x,w)), 0.0 );\n}\n\n// The most intuitive method is probably to rotate\n// cs by the right amount each time.\nvec2 waveRotations( int x, const float w )\n{\n    mat2 M = mat2(cos(w),-sin(w),sin(w),cos(w));\n    vec2 cs = vec2(1.0,0.0);\n    for( int i=0; i<x; i++ )\n    {\n        cs = M*cs;\n    }\n    return cs;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n    float px = 1.0/iResolution.y;\n \n    const float pi = 3.1415926536;\n    const float w = 10.0*(2.0*pi)/800.0;\n    const float a = 0.1;\n\n    int x = int(fragCoord.x + min(pow(mod(iTime,15.0)/15.0,2.0)*4000.0,3000.0));\n    \n\n    vec3 col = vec3(0.15);\n\n    // axis\n    {\n    float d = abs(p.y-0.5);\n    col = mix( col, vec3(0.5), 1.0-smoothstep(0.5*px,1.5*px,d) );\n    }\n\n    // 2PI periods\n    {\n    float d = abs(mod(float(x)*w+pi,2.0*pi)-pi);\n    col = mix( col, vec3(0.5), 1.0-smoothstep(0.5*px,1.5*px,d) );\n    }\n\n    // naive: red\n    #if METHOD==0\n    {\n\tvec2 cs = a*waveEulerNaive( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n\n\t// naive normalized: yellow\n    #if METHOD==1\n    {\n\tvec2 cs = a*waveEulerNormalized( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n    \n    // symplectic: blue\n    #if METHOD==2\n    {\n\tvec2 cs = a*waveSymplectic( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(0.1,0.4,1.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n\n    \n    // rotations: green\n    #if METHOD==3\n    {\n\tvec2 cs = a*waveRotations( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    col = mix( col, vec3(0.1,1.0,0.0), 1.0-smoothstep(1.0*px,4.0*px,d) );\n    }\n    #endif\n    \n    // exact : white\n    {\n\tvec2 cs = a*waveExact( x, w );\n    float d = abs( 0.5+cs.x - p.y ) / sqrt(1.0+cs.y*cs.y);\n    float e = smoothstep(-0.1,0.1,sin(iTime*3.1415927));\n    col = mix( col, vec3(1.0,1.0,1.0), e*(1.0-smoothstep(1.0*px,4.0*px,d)) );\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 643, 683, 683, 735], [738, 1022, 1067, 1067, 1188], [1191, 1391, 1441, 1441, 1592], [1594, 2271, 2316, 2316, 2666], [2668, 2756, 2800, 2800, 2955], [2958, 2958, 3015, 3015, 4825]]}
{"id": "tlBXzh", "name": "Voronoi Variation", "author": "Hirai_worthless", "description": "like cell", "tags": ["voronoi"], "likes": 5, "viewed": 67, "published": "Public", "date": "1565009391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat mDist(vec2 p,vec2 o){\n\treturn abs(p.x - o.x) + abs(p.y - o.y);\n}\nfloat dist(vec2 p,vec2 o){\n    return length(p - o);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat min1 = 100000.0;\n    float min2 = 100000.0;\n    for(float xi= -0.3; xi < 1.0; xi+= 0.2){\n        for(float yi = -0.3; yi < 1.0; yi += 0.2){\n            float x = xi + sin(iTime * rand(vec2(xi,yi))) * 0.1;\n            float y = yi + cos(iTime * rand(vec2(yi,xi))) * 0.1;\n        \tfloat a1 = dist(uv,vec2(x,y));\n            float a2 = mDist(uv,vec2(x,y));\n            float a = mix(a1,a2,smoothstep(0.0,1.0, sin(iTime * 2.)/2. + 1./2.) );\n            min2 = min1 > a ? min1 : min2;\n            min1 = min1 > a ? a : min1;\n        }\n    }\n    vec3 baseCol = mix(vec3(1.,0.,0.),vec3(0.,1.,1.),\n                      smoothstep(0.0,1.0, sin(iTime * 2.)/2. + 1./2.)\n                      );\n    vec3 col = min2 - min1 < 0.01 ? baseCol :\n    \t(min2 - min1) * 5.0 * baseCol;\n    \t \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [93, 93, 120, 120, 163], [164, 164, 190, 190, 218], [220, 220, 277, 277, 1131]]}
{"id": "tlBXzR", "name": "Cube cutter", "author": "run", "description": "Playing with an effect inspired by this reddit post: ", "tags": ["cutter"], "likes": 2, "viewed": 300, "published": "Public API", "date": "1564756747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\n//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\nconst int iterations = 200;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .03;\n\nconst float cam_dist = 5.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n   /*pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);*/\n    \n    vec4 dark = vec4(.7, .7 ,.7, 1.);\n    vec4 light = vec4(.2, .2 ,.2, 1.);\n    \n    float res = 0.4;\n    \n    float counter = 0.;\n    if (mod(pos.x, res) > res / 2.0) {\n    \tcounter += 1.;\n    }\n    if (mod(pos.y, res) > res / 2.0) {\n    \tcounter += 1.;\n    }\n    if (mod(pos.z, res) > res / 2.0) {\n    \tcounter += 1.;\n    }\n    \n    //vec4(counter / 2., 0., 0., 1.);//\n    return mod(counter, 2.0) < 1.0 ? dark : light;\n}\n\nvec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit)\n{\n   vec3 fog_color = sky_color(ray_dir, light_dir);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      //color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -.003 :\n      .5; //iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y*.5) * -.003 :\n      .6; //iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir));\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\nfloat fField(vec3 p)\n{\n   float box1 = fBox(p, vec3(1., 1., 1.));\n    \n   vec2 tp = vec2(p.x, p.y);\n   pR45(tp);\n   p.x = tp.x;\n   p.y = tp.y;\n    \n   vec2 tp2 = vec2(p.x, p.z);\n   pR45(tp2);\n   p.x = tp2.x;\n   p.z = tp2.y;\n    \n   p.z += 2. + 1.75 * cos(iTime * 3.1415 / 3.5);//mod(-iTime, 4.);\n   float box2 = fBox(p, vec3(4., 4., 2.));\n    \n   return max(box1, -box2);\n   //return pill;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 55], [58, 94, 122, 122, 203], [205, 241, 266, 266, 306], [533, 773, 795, 795, 993], [995, 995, 1037, 1037, 1311], [1313, 1377, 1410, 1410, 1433], [1435, 1435, 1486, 1883, 2313], [2315, 2315, 2361, 2361, 2553], [2555, 2555, 2641, 2673, 3160], [3162, 3162, 3230, 3230, 4336], [4338, 4338, 4390, 4390, 5297], [5299, 5469, 5491, 5491, 5860]]}
{"id": "tljSRd", "name": "MandelBruth", "author": "DanielPettersso", "description": "Just a simple mandelbrot", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 65, "published": "Public", "date": "1566890952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float maxIterations = 150.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = .9995 + sin(iTime * .2);\n    \n    uv *= 2. - t;\n    uv += vec2(-1.5 + t * 0.9, -1. + t * 0.789);\n    \n    float realComponentOfResult = uv.x;\n    float imaginaryComponentOfResult = uv.y;\n\tfloat tempRealComponent = 0.;\n\tfloat tempImaginaryComponent = 0.;\n    \n    fragColor =  texture(iChannel0, uv * 3.);\n   \t\n    for(float i = 0.; i < maxIterations; i++) {\n        \n         tempRealComponent = realComponentOfResult * realComponentOfResult\n                                 - imaginaryComponentOfResult * imaginaryComponentOfResult\n                                 + uv.x;\n         tempImaginaryComponent = 2. * realComponentOfResult * imaginaryComponentOfResult\n                                 + uv.y;\n         realComponentOfResult = tempRealComponent;\n         imaginaryComponentOfResult = tempImaginaryComponent;\n\n        if(realComponentOfResult * imaginaryComponentOfResult > 2.) {\n            float a = sqrt(i/maxIterations);\n            fragColor = vec4(a, 0., a, 1.0);\n            break;\n        }\n    }\n   \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 1177]]}
{"id": "tljSWG", "name": "pulsating ring", "author": "raistm", "description": "A simple pulsating ring", "tags": ["2d", "shape"], "likes": 1, "viewed": 70, "published": "Public", "date": "1566993355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1, based on the width)\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 mUv = iMouse.xy/iResolution.x;\n    float flash = (sin(iTime*9.0) + 1.0) / 2.0;\n    float colorFactor = mix(0.5, 1.0, flash);\n    \n    float thickness = 0.01;\n    float radius = 0.1;\n    float gradientThickness = 0.02;\n    \n    float dist = distance(uv, mUv);\n    float col1 = smoothstep(radius, radius + gradientThickness, dist);\n    float col2 = smoothstep(radius + gradientThickness + thickness, radius + (2.0f * gradientThickness) + thickness, dist);\n    float col = (col1 - col2) * colorFactor;\n\n    // Output to screen\n    fragColor = vec4(col, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 127, 743]]}
{"id": "tljSWz", "name": "Squares fall", "author": "avin", "description": "visual experiment", "tags": ["blur", "square"], "likes": 20, "viewed": 574, "published": "Public API", "date": "1565638423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLACK_COL vec3(16,22,26)/255.\n#define WHITE_COL vec3(235,241,245)/255.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 ouv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    float sf = .05 + abs(ouv.y);\n    \n    float m = 0.;\n    for(float n=-1.; n<=1.; n+=1.){\n        vec2 uv = ouv * vec2(1., 1. + .025*n) * (2. + sin(iTime*.25)*.2);\n        uv.y+=iTime*.1;\n\n        uv = uv * 15.;\n        vec2 gid = floor(uv);\n        vec2 guv = fract(uv) - .5;\n        \n        for(float y=-1.; y<=1.; y+=1.){\n            for(float x=-1.; x<=1.; x+=1.){\n                vec2 iuv = guv + vec2(x,y);    \n                vec2 iid = gid - vec2(x,y);  \n\n                float angle = rand1(iid.x*25. + iid.y * 41.)*10. +\n                    (iTime * (rand1(iid.x*10. + iid.y * 60.) + 1.5));\n\n                float ca = cos(angle);\n                float sa = sin(angle);\n                iuv *= mat2(ca, -sa, sa, ca);\n\n                float size = rand1(iid.x*50. + iid.y*25.)*.2+.5;\n                float weight = size*.02;                \n                \n                float swp = size - weight;                                                               \n                float m1 = smoothstep(abs(iuv.x), abs(iuv.x) + sf, swp) \n                    * smoothstep(abs(iuv.y), abs(iuv.y) + sf, swp);\n\n                swp = size + weight;                                \n                float m2 = smoothstep(abs(iuv.x), abs(iuv.x) + sf, swp) \n                    * smoothstep(abs(iuv.y), abs(iuv.y) + sf, swp);\n                \n                float rr = rand1(iid.x*128. + iid.y*213.);\n                m1 *= rr > .075 ? 1.0 : (1.-rr*5.);\n\n                m += clamp(m2 - m1, 0., 1.);\n            }\n        } \n    }         \n    \n     if(iMouse.z > 0.){\n      m = 1.-m;\t\n    }  \n        \n    vec3 col = mix(BLACK_COL, WHITE_COL, m);    \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 190, 190, 1948]]}
{"id": "tljSzK", "name": "Belt Trick But Square", "author": "_polymath", "description": "as https://www.shadertoy.com/view/3t2Xzy but needlessly square, honestly it looks like a 90s hannah barbera cartoon, i hate it", "tags": ["raymarched"], "likes": 2, "viewed": 373, "published": "Public API", "date": "1566473364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITERS 300.0\n#define LENFACTOR .15\n#define NDELTA 0.001\n#define NDELTAX vec3(NDELTA, 0., 0.)\n#define NDELTAY vec3(0., NDELTA, 0.)\n#define NDELTAZ vec3(0., 0., NDELTA)\nfloat box(vec3 p, vec3 centre, vec3 dims) {\n    vec3 d = abs(p - centre) - dims;\n    return max(d.x, max(d.y, d.z));\n}\nconst vec3 rDir = normalize(vec3(-3.0, 4.0, -2.0)), rCol = vec3(1.0, 0.6, 0.4),\n    bDir = normalize(vec3(2.0, 3.0, -4.0)), bCol = vec3(0.3, 0.7, 1.0),\n    gDir = normalize(vec3(4.0, -3.0, 0.0)), gCol = vec3(0.7, 1.0, 0.8);\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, // 0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, // 0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);          // 0.0,\n}\nconst float pi = 3.1415926536;\nmat2 rot(float t) {\n\tfloat s = sin(t), c = cos(t);\n    return mat2(c, s, -s, c);\n}\nvec3 rotSpace(vec3 p) {\n    vec3 ap = abs(p);\n    float angle = pi * smoothstep(5., 2., max(ap.x, max(ap.y, ap.z)));\n    if (angle <= 0.) return p;\n    vec3 axis = vec3(\n        cos(iTime * 0.3),\n        0.,\n        sin(iTime * 0.3));\n    return p * rotationMatrix(axis, angle);\n}\nfloat scene(vec3 p) {\n    p = rotSpace(p);\n    \n    float l = iTime * 0.2 - .2;\n    l = max(0., min(pow(l, 6.), 1000.));\n    return min(box(p, vec3(0.), vec3(0.7, 0.1, l)),\n           min(box(p, vec3(0.), vec3(0.1, l, 0.7)),\n           min(box(p, vec3(0.), vec3(l, 0.7, 0.1)),\n               box(p, vec3(0.), vec3(1.))\n           )));\n}\nvec3 sceneNormal(vec3 p) {\n    return normalize(vec3(\n        scene(p + NDELTAX) - scene(p - NDELTAX),\n        scene(p + NDELTAY) - scene(p - NDELTAY),\n        scene(p + NDELTAZ) - scene(p - NDELTAZ)\n\t));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.));\n    ray.yz *= rot(-0.12);\n    ray.xz *= rot(-0.7853981634);\n    vec3 cam = vec3(10., 2., -10.);\n    vec3 pos = cam;\n    float i = 0.;\n    for (; i < MAXITERS; ++i) {\n        float dist = scene(pos);\n        if (dist < 0.001) break;\n        pos += ray * dist * LENFACTOR;\n    }\n        vec3 col = vec3(1.);\n            vec3 p2 = rotSpace(pos);\n            if (abs(p2.x) > 1.001) col = vec3(1., .757, .224);\n            else if (abs(p2.y) > 1.001) col = vec3(0., .576, .5255);\n            else if (abs(p2.z) > 1.001) col = vec3(.2902, .204, .365);\n    \tfragColor = vec4(col * (\n            rCol * abs(dot(rDir, sceneNormal(pos))) +\n            gCol * pow(dot(gDir, sceneNormal(pos)), 5.) +\n            bCol * abs(dot(bDir, sceneNormal(pos)))\n        ), 1.0) * (1.0 - pow(i / 300., 2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 220, 220, 295], [520, 520, 565, 565, 1037], [1069, 1069, 1088, 1088, 1151], [1152, 1152, 1175, 1175, 1432], [1433, 1433, 1454, 1454, 1769], [1770, 1770, 1796, 1796, 1976], [1977, 1977, 2034, 2034, 2924]]}
{"id": "tljXDD", "name": "大龙猫 - Quicky#007.2", "author": "totetmatt", "description": "Happy bridge day", "tags": ["quicky"], "likes": 7, "viewed": 322, "published": "Public API", "date": "1565958927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define time iTime\nmat2 r(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec2 q(float a){ return -vec2(cos(a),sin(a))/(9.+sin(-time)*3.);}\nfloat o(vec2 uv) {\n    return  smoothstep(0.1,0.2,smoothstep(0.12,0.17,length((uv))) - smoothstep(0.1,0.3,length(uv)))  ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec2 uvv = uv;\n    float mo = 1.5;\n    uv*=10.;\n      \n    uv = mod((uv+vec2(cos(-time)+5.,sin(time)+2.))*r(time/10.),mo+abs(sin(length(uvv)-time)));\n   \n    uv-=(mo/4.)+abs(sin(length(uvv)-time));\n     uv*=r(1.*smoothstep(-.01,0.02,(length(uvv)-tan(-time)))*time+sin(abs(length(uvv))*5.));\n    uv *= 1.-length(uv/sqrt(abs(uv)));\n    uv*=2.;\n    \n    float d = smoothstep(\n    1.0,\n    2.5,\n      o(uv+q(time)) + o(uv+q(-time+PI/2.))+ o(uv+q(time+PI)) + o(uv+q(-time+(3.*PI/2.) ))\n    ) ;\n\n    vec3 col = mix(vec3(.1*d,.1,.1),vec3(0.5*d+(iChannel0,fract(cos(time)+uv*10.)).x/2.,0.6+(iChannel0,fract(sin(time)+uv*10.)).y/2.,.9+d/10.),vec3(d));\n    fragColor = vec4(\n        col,\n        1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 55, 55, 100], [101, 101, 117, 117, 166], [167, 167, 185, 185, 290], [291, 291, 348, 348, 1102]]}
{"id": "tljXRd", "name": "YUV Visualizer", "author": "MooseBoys", "description": "Visualize UV planes for time-varying Y.", "tags": ["yuv"], "likes": 0, "viewed": 126, "published": "Public API", "date": "1566850400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Y indicator params\n    const float bar_a = 0.01f;\n    float bar_b = 1.0f / iResolution.x;\n    vec2 c = fragCoord/iResolution.xy;\n    float y = 0.5f - 0.5f * cos(iTime);\n    if (c.x > bar_a && c.x < bar_a + bar_b || c.x <= bar_a && c.y > y) {\n        fragColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        return;\n    }\n    float u = c.x;\n    float v = c.y;\n    float r = 1.164f * (y - 16.0f / 255.0f) + 1.596f * (v - 128.0f / 255.0f);\n    float g = 1.164f * (y - 16.0f / 255.0f) - 0.813f * (v - 128.0f / 255.0f) - 0.391f * (u - 128.0f / 255.0f);\n    float b = 1.164f * (y - 16.0f / 255.0f) + 2.018f * (u - 128.0f / 255.0f);\n    fragColor = vec4(r, g, b, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 83, 722]]}
{"id": "tljXRh", "name": "AudioVisualizer002", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 1, "viewed": 143, "published": "Public", "date": "1565078356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nfloat gear(vec3 p, float inner_1,float inner_2,\n          float outer_1,float outer_2,\n           float width,float gearCount){\n\tfloat at = atan(p.z/p.x) / (2. * PI);\n    float inner = fract(at * 2. * gearCount) > 0.5 ? inner_1 : inner_2;\n    float outer = fract(at * 2. * gearCount) > 0.5 ? outer_1 : outer_2;\n    return max(max(length(p.xz) - outer,-length(p.xz) + inner),p.y + 0.75 - width);\n}\nfloat map(vec3 p){\n    p.xz = fract((p.xz + vec2(0.8)) / 1.6) * 1.6 - 0.8;\n    p.y = -abs(p.y);\n    p.xz *= genRot(-iTime);\n    float vol1 = 0.;\n    float vol2 = 0.;\n    float vol3 = 0.;\n    for(float i = 0.0; i < 1.0 / 3.0; i+= 0.05){\n    \tint tx = int(i*512.0);\n        \tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n        vol1 += fft;\n    }\n    for(float i = 1./3.; i < 2.0 / 3.0; i+= 0.05){\n    \tint tx = int(i*512.0);\n        \tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n        vol2 += fft;\n    }\n    for(float i = 2./3.; i < 3.0 / 3.0; i+= 0.05){\n    \tint tx = int(i*512.0);\n        \tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n        vol3 += fft;\n    }\n\tfloat gear1 = gear(p,0.7,0.6,0.9,0.8,vol1 * 0.1,6.);\n    float gear2 = gear(p,0.4,0.3,0.7,0.6,vol2 * 0.2,6.);\n\tfloat gear3 = gear(p,0.,0.,0.4,0.3,vol3 * 0.4,6.);\n    return min(gear1,min(gear2,gear3));\n\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.75;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,0.8)),\n    o = vec3(sin(iTime) * 2.,0.,iTime * 2.);\n    //r.yz *= genRot(PI/6.);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.025);\n    vec3 baseColor = r.y > 0. ? vec3(1.,0.,0.): vec3(0.,0.,1.);\n    vec3 fc = mix(vec3(0.,0.,0.),baseColor,smoothstep(-0.75,0.,dot(n,r)));\n    fc = mix(vec3(0.),fc,smoothstep(0.,1.,fog));\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 90], [91, 91, 218, 218, 487], [488, 488, 506, 506, 1394], [1421, 1421, 1445, 1445, 1697], [1699, 1699, 1727, 1727, 1927], [1930, 1930, 1979, 2029, 2567]]}
{"id": "tljXWG", "name": "cube anime v4", "author": "jorge2017a1", "description": "cube anime v4", "tags": ["cubeanimev4"], "likes": 3, "viewed": 91, "published": "Public", "date": "1566999644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Created by BaconPapa in 2019-05-14\n//modificado por jorge2017a1 --2019-08-28\n\n\n#define ZOOM 1.5\n#define MAX_STEPS 100\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 50.\nconst vec3 _lightPos = vec3(-2., 5., -1.);\nconst vec3 _lightPos2 = vec3(2., 5., 1.);\nconst vec3 _lightDir = vec3(0., -.5, 1.);\n\n//const vec3 _lightColor = vec3(.92, 0.85, 0.99);\n//const vec3 _lightColor = vec3(.92, 0.54, 0.79);\nconst vec3 _lightColor = vec3(.92, 0.8, 0.93);\n\n\nconst float _pointIntense = .3;\nconst float _parallelIntense = 0.4;\nconst float _shadowMin = .01;\nconst float _shadowMax = 50.;\nconst float _shadowIntense = 1.;\nconst float _sphereSmooth = .15;\nconst float _k = 15.;\n\nvec3 getRay(in vec3 ro, in vec3 lookAt, in vec2 uv) {\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    return normalize(uv.x * r + uv.y * u + f * ZOOM);\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat opSU ( float d1, float d2, float k ) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdf(in vec3 p) {\n    \n    //vec3 c1 = vec3(0., 1. + .25 * sin(4. * iTime) + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 c2 = vec3(0., .5 - .25 * sin(4. * iTime) + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 c3 = vec3(.25 * sin(2. * iTime), .75 + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 c4 = vec3(-.25 * sin(2. * iTime), .75 + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 b = vec3(0., .75 + 0.25 * sin(iTime * 4.), 0.);\n    \n    \n    vec3 c1 = vec3(-1.0,1.0,-1.0);\n    vec3 c2 = vec3(2.0,1.0,0.0);\n    vec3 c3 = vec3(-2.0,1,-1.0);\n    vec3 c4 = vec3(1.0,0.5,-2);\n    vec3 b = vec3(0., .75 + 0.25 * sin(iTime * 4.), 0.);\n    \n    \n    float r = .5;\n    float sphere1 = sdSphere(p, c1, r);\n    float sphere2 = sdSphere(p, c2, r);\n    float sphere3 = sdSphere(p, c3, r);\n    float sphere4 = sdSphere(p, c4, r);\n    float plane = sdPlane(p);\n    float box = sdBox(b - p, vec3(.5, .5, .5)); \n    \n    \n    /*\n\tfloat d = opSU(sphere1, sphere2, _sphereSmooth);\n    d = opSU(d, sphere3, _sphereSmooth);\n    d = opSU(d, sphere4, _sphereSmooth);\n    d = opSS(d, box, .1);\n    d = opSU(d, plane, .8);\n    */\n    \n    float d;\n    d = min(sphere1, sphere2);\n    d = min(d, sphere3);\n    d = min(d, sphere4);\n    d = min(d, box);\n    d = min(d, plane);\n    \n    \n    return d;\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd) {\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i ++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdf(p);\n        dO += dS;\n        if(dS < MIN_DISTANCE || dO > MAX_DISTANCE) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(in vec3 p) {\n    float d = sdf(p);\n    vec2 e = vec2(MIN_DISTANCE, 0);\n    return normalize(vec3(\n        sdf(p + e.xyy) - d,\n        sdf(p + e.yxy) - d,\n        sdf(p + e.yyx) - d\n        ));\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0;\n    for(float h = mint;h<maxt;){\n        vec3 p = ro + rd * h;\n        float s = sdf(p);\n        h += s;\n        if (s <= MIN_DISTANCE) {\n            return 0.0;\n        }\n        res = min(res, k * s / h);\n    }\n    return res;\n}\n\nvec3 getLight(in vec3 p) {\n    vec3 n = getNormal(p);\n    vec3 ld = normalize(_lightPos - p);\n    vec3 ld2 = normalize(_lightPos2 - p);\n    float lParallel = clamp(dot(n, -_lightDir), 0., 1.) * _parallelIntense;\n    float lPoint = clamp(dot(n, ld), 0., 1.) * _pointIntense;\n    float lPoint2 = clamp(dot(n, ld2), 0., 1.) * _pointIntense;\n    lParallel = lParallel * pow(shadow(p, -_lightDir, _shadowMin, _shadowMax, _k), _shadowIntense);\n    lPoint = lPoint * pow(shadow(p, ld, _shadowMin, _shadowMax, _k), _shadowIntense);\n    lPoint2 = lPoint2 * pow(shadow(p, ld2, _shadowMin, _shadowMax, _k), _shadowIntense);\n    \n    return (lPoint + lParallel + lPoint2) * _lightColor;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(5. * sin(iTime / 2.), 4. , 5. * cos(iTime / 2.));\n    vec3 lookAt = vec3(0., .5, 0.);\n    vec3 col = vec3(0., 0., 0.);\n    vec3 rd = getRay(ro, lookAt, uv);\n\tfloat d = rayMarching(ro, rd);\n    vec3 p = ro + d * rd;\n    // Output to screen\n    fragColor = vec4(getLight(p), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 667, 720, 720, 880], [882, 882, 908, 908, 926], [928, 928, 978, 978, 1010], [1012, 1012, 1043, 1043, 1139], [1141, 1141, 1185, 1185, 1281], [1283, 1283, 1326, 1326, 1427], [1429, 1429, 1451, 1840, 2686], [2688, 2688, 2731, 2731, 2950], [2952, 2952, 2979, 2979, 3161], [3163, 3163, 3243, 3243, 3495], [3497, 3497, 3523, 3523, 4178], [4180, 4180, 4237, 4287, 4674]]}
{"id": "tljXWK", "name": "LiveCodingPractice010(1hour)", "author": "Hirai_worthless", "description": "FiberSpace", "tags": ["raymarching"], "likes": 13, "viewed": 270, "published": "Public", "date": "1567170715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat PI = 3.14159265;\nmat2 genRot(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvec2 pmod(vec2 p,float count){\n\tp *= genRot(PI/count);\n\tfloat at = atan(p.y/p.x);\n\tfloat r = length(p);\n\tat = mod(at,2. * PI / count);\n\tp = vec2(r * cos(at),r * sin(at));\n\tp *= genRot(-PI/count);\n\treturn p;\n}\nfloat map(vec3 p){\n\tvec3 q = p;\n\tp.xy *= genRot(p.z/4.);\n\tp = (fract(p/1.5 + 0.5) - 0.5) * 1.5;\n\tp.xy = pmod(p.xy,8.);\n\tfloat string = length(p.xy - vec2(0.25 + 0.05 * sin(q.z + iTime * PI),0.)) - .01 + 0.005 * sin(q.z);\n\tfloat sphere = length(p - vec3(0.25 + 0.05 * sin(q.z + iTime * PI),0.,0.)) - .03;\n\tstring = min(string,sphere);\n\treturn string;\n}\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n\tvec3 y = dFdy(p);\n\treturn normalize(cross(x,y));\n}\nvec4 trace(vec3 o,vec3 r){\n\tfloat t = 0.;\n\tvec3 p;\n\tfor(int i = 0; i < 128; i++){\n\t\tp = o + r * t;\n\t\tfloat d = map(p);\n\t\tt += d * 0.75;\n\t}\n\tvec3 n = getNormal(p);\n\treturn vec4(n,t);\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-1.5);\n\tc += vec3(.5 * sin(iTime/2.),.5 * cos(iTime/2.),iTime * 2.);\n\treturn c;\n}\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n\tr.xz *= genRot(PI / 8.);\n\tr.xy *= genRot(-iTime/4.);\n\t//r.xz *= genRot(time/8.);\n\t//r.yz *= genRot(time/8.);\n\treturn r;\n}\n\nvec3 getColor(vec3 o, vec3 r, vec4 d){\n\tvec3 light = normalize(vec3(r.xy,0.));\n\tvec3 p = o + r * d.w;\n\tvec3 n = d.xyz;\n\tfloat a = dot(n,r);\n\tvec3 cc = (vec3(sin(p.x),sin(p.y),sin(p.z)) * 0.5 + 0.5);\n\tvec3 bc = vec3(1.-a);\n\tcc = fract(p.z / 1.5) < 0.9 && fract((p.z/2. - iTime * 4.) / 8.) < 0.95  ? vec3(0.) : cc;\n\tbc += cc * 2.;\n\tfloat t = d.w;\n\tfloat fog = 1./(1. + t * t * 0.05);\n\treturn mix(bc,vec3(0.),1. - fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 uv = ( fragCoord.xy * 2. - iResolution.xy) / iResolution.y ;\n\tvec3 c = cam();\n\tvec3 r = ray(uv,1.5);\n\tvec4 d = trace(c,r);\n\tvec3 color = getColor(c,r,d);\n\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 45, 45, 91], [92, 92, 122, 122, 300], [301, 301, 319, 319, 652], [653, 653, 676, 676, 747], [748, 748, 774, 774, 931], [933, 933, 944, 944, 1047], [1048, 1048, 1074, 1074, 1230], [1232, 1232, 1270, 1270, 1650], [1652, 1652, 1708, 1708, 1906]]}
{"id": "tljXWy", "name": "Endless living creature", "author": "leon", "description": "Weird endless living creature\n", "tags": ["creature"], "likes": 41, "viewed": 988, "published": "Public API", "date": "1567024220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Weird endless living creature\n// inspired by Inigo Quilez live stream shader deconstruction\n// Leon Denise (ponk) 2019.08.28\n// Licensed under hippie love conspiracy\n\n// Using code from\n// Inigo Quilez\n// Morgan McGuire\n\n// tweak zone\nconst int count = 15;\nconst float speed = 1.;\nconst float balance = 1.5;\nconst float range = 1.4;\nconst float radius = .6;\nconst float blend = .3;\nconst float falloff = 1.2;\n\n// increment it at your own GPU risk\nconst float motion_frames = 1.;\n\n// toolbox\nconst float PI = 3.1415;\n#define repeat(p,r) (mod(p,r)-r/2.)\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\nfloat geometry (vec3 pos, float time) {\n    float scene = 1., a = 1.;\n    float t = time * .5 + pos.x / 30.;\n    t = floor(t)+smoothstep(0.0,.9,pow(fract(t),2.));\n    pos.x = repeat(pos.x+iTime, 5.);\n    for (int i = count; i > 0; --i) {\n        pos.x = abs(pos.x)-range*a;\n        pos.xy *= rot(cos(t)*balance/a+a*2.);\n        pos.zy *= rot(sin(t)*balance/a+a*2.);\n        scene = smoothmin(scene, sdSphere(pos,(radius*a)), blend*a);\n        a /= falloff;\n    }\n    return scene;\n}\n\nfloat raymarch ( vec3 eye, vec3 ray, float time, out float total ) {\n    float dither = random(ray.xy+fract(time));\n    total = 0.0;\n    const int count = 20;\n    for (int index = count; index > 0; --index) {\n        float dist = geometry(eye+total*ray,time);\n        dist *= 0.9+0.1*dither;\n        total += dist;\n        if (dist < 0.001 * total) {\n            return float(index)/float(count);\n        }\n    }\n    return 0.;\n}\n\nvec3 camera (vec3 eye) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if (iMouse.z > 0.5) {\n        eye.yz *= rot(mouse.y*PI);\n        eye.xz *= rot(mouse.x*PI);\n    }\n    return eye;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = camera(vec3(0,0,4));\n    vec3 ray = look(eye, vec3(0), uv, 1.);\n    float total = 0.0;\n    fragColor = vec4(0);\n    for (float index = motion_frames; index > 0.; --index) {\n        float dither = random(ray.xy+fract(iTime+index));\n        float time = iTime*speed+(dither+index)/10./motion_frames;\n        fragColor += vec4(raymarch(eye, ray, time, total))/motion_frames;\n    }\n    \n    // extra color\n    fragColor.rgb *= vec3(.7,.8,.9);\n    float d = smoothstep(7.,0.,total);\n    fragColor.rgb += vec3(0.8,.6,.5) * d;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXWy.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[483, 555, 577, 577, 665], [666, 666, 685, 685, 735], [736, 736, 781, 781, 855], [856, 856, 890, 890, 912], [913, 913, 972, 972, 1193], [1195, 1195, 1234, 1234, 1677], [1679, 1679, 1747, 1747, 2108], [2110, 2110, 2134, 2134, 2303], [2305, 2305, 2361, 2361, 2961]]}
{"id": "tljXzD", "name": "大龙猫 - Tentapixel", "author": "totetmatt", "description": "One day I promise I'll improve the code quality\n\nTrack that helps to get inspired \nhttps://www.youtube.com/watch?v=v4WXGd1nCvM", "tags": ["pixel"], "likes": 1, "viewed": 253, "published": "Public API", "date": "1565293980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define  time iTime\n\nfloat f(float q,float factor) {\n    return abs(floor(factor*sin(q)/q)/factor);\n}\n\nfloat q(vec2 uv) {\n      float p = f(uv.x,6.+sin(time)*2.);\n      p += f(uv.y,6.+cos(time)*2.);\n      return p ;\n}\n\nmat2 r(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat g(vec2 uv,float off,float dir) {\n    uv *= r(length(uv)/(25.+sin(time+uv.y/5.)*2.));\n    uv *= r(off-dir*time/3.) ;\n    float p = q(uv);\n    return smoothstep(0.65,1.0,p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n    uv *= 40.;\n    float p = (g(uv,0.,1.) + g(uv,-PI/4.,-1.)) - sqrt(g(uv,0.,1.) * g(uv,-PI/4.,-1.)) ;\n    float k =  pow(length(uv),2.);\n\n    fragColor = vec4(\n        mix(vec3(0.),vec3(.9,.5,.1*k),p),\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 72, 72, 121], [123, 123, 141, 141, 237], [239, 239, 256, 256, 300], [302, 302, 340, 340, 481], [484, 484, 541, 541, 826]]}
{"id": "tljXzh", "name": "Basic Circle Glow", "author": "Ashutosh421", "description": "This is basic circle", "tags": ["circle"], "likes": 1, "viewed": 90, "published": "Public", "date": "1565095952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 position, vec2 pCord, float radius, float ar, vec4 color) {\n    vec2 aposition = vec2(position);\n    aposition.x *= ar;\n    \n\tfloat cDistance = distance(aposition, pCord);\n    return vec4(smoothstep(radius , radius - ((abs(sin(iTime * 0.5))/2.0) + 1.0)/30.0, cDistance)) * color;\n}\n\nvec2 circleFn(float ad, float offset) {\n\treturn vec2(sin(iTime + offset) / ad, cos(iTime + offset) / ad);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2( fragCoord.xy / iResolution.xy);\n    float ar = iResolution.x / iResolution.y;\n    vec2 mouse = vec2( iMouse.xy / iResolution.xy);\n    \n    uv.x *= ar;\n    \n    vec4 outColor = circle(vec2 (0.5,0.5), uv, 0.1, ar, vec4(1.0 , (abs(sin(iTime)/4.0)), 0.0, 1.0));\n    outColor += circle(vec2 (0.5, 0.5), uv, 0.05, ar, vec4(0.0 , 1.0, 0.0, 1.0));\n    outColor += circle(vec2 (0.5, 0.5), uv, 0.05, ar, vec4(1.0 , 0.0, 0.0, 1.0));\n    \n    \n    fragColor = outColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 298], [300, 300, 339, 339, 407], [410, 410, 467, 517, 997]]}
{"id": "tllSDs", "name": "Circular Weave", "author": "4rknova", "description": "A simple circular weave effect", "tags": ["2d", "circular", "weave"], "likes": 3, "viewed": 300, "published": "Public API", "date": "1565128373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI  3.14159265359\n\n#define BG_COLOR  vec3(0.0745, 0.0862, 0.1058)\n#define AMPLITUDE (0.1)\n#define PERIOD    (10.) \n#define PHASE     (iTime * 10.)\n#define DELTA     (PI)\n#define DECAY     (2.0)\n#define SCALE     (1.1)\n#define RING_MIN  (0.98)\n#define RING_MAX  (1.00)\n\nfloat ring(float r) \n{ \n    return step(r, RING_MAX) - step(r, RING_MIN); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Polar Coordinates\n    float r = SCALE * length(p);\n    float theta = atan(p.y, p.x);\n\n    // remap [0,1] to [0,1]->[1,0]\n    float decay     = pow(abs(theta/PI),DECAY);\n    float amplitude = AMPLITUDE * decay;\n    float period    = theta * PERIOD + PHASE;\n\n    float w0 = amplitude * cos(period)\n        , w1 = amplitude * cos(period + DELTA);\n \n    vec3 f = ring(r-w0) + ring(r-w1) + BG_COLOR;    \n    fragColor = vec4(vec3(f), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllSDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 398, 420, 420, 474], [476, 476, 533, 533, 1071]]}
{"id": "tlSSDV", "name": "Robotic Arm Hunting Lights", "author": "reinder", "description": "This shader is a proof of concept to find out if I could create a \"typical\" Shadertoy shader, i.e. a shader that renders a non-trivial animated 3D scene, by using a ray tracer instead of the commonly used raymarching techniques. ", "tags": ["raytracer", "ray", "tracer", "inverse", "kinematics", "inversekinematics"], "likes": 97, "viewed": 3735, "published": "Public API", "date": "1567106604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Robotic Arm. Created by Reinder Nijhoff 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tlSSDV\n//\n// This shader is a proof of concept to find out if I could \n// create a “typical” Shadertoy shader, i.e. a shader that renders \n// a non-trivial animated 3D scene, by using a ray tracer instead \n// of the commonly used raymarching techniques. \n//\n// Some first conclusions:\n// \n// - It is possible to visualize an animated 3D scene in a single \n//   shader using ray tracing.\n// - The compile-time of this shader is quite long.\n// - The ray tracer is not super fast, so it was not possible to cast\n//   enough rays per pixel to support global illumination or soft\n//   shadows. Here I miss the cheap AO and soft shadow algorithms that\n//   are available when raymarching an SDF.\n// - Modelling a 3D scene for a ray tracer in code is verbose. It was\n//   not possible to exploit the symmetries in the arm and the domain\n//   repetition of the sphere-grid that would have simplified the\n//   description of an SDF.\n// - I ran in GPU-dependent unpredictable precision problems. Hopefully,\n//   most problems are solved now. I’m not sure if they are inherent\n//   to ray tracing, but I didn’t have these kinds of problems using\n//   raymarching before.\n//\n\n#define AA 1 // Set AA to 1 if you have a slow GPU\n#define PATH_LENGTH 3\n#define MAX_DIST 60.\n#define MIN_DIST .001\n#define ZERO (min(iFrame,0))\n\n// Global variables\nfloat time;\nvec2[2] activeSpheres;\nvec2[3] joints;\nfloat joint0Rot;\nfloat jointYRot;\n\n//\n// Hash by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\n//\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//\n// Ray-primitive intersection routines: https://www.shadertoy.com/view/tl23Rm\n//\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Plane \nfloat iPlane( const in vec3 ro, const in vec3 rd, in vec2 distBound, inout vec3 normal,\n              const in vec3 planeNormal, const in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n// Sphere: https://www.shadertoy.com/view/4d2XWV\nfloat iSphere( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\n               const float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( const in vec3 oc, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\n                 const in vec3 ca, const float ra, const bool traceCaps ) {\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return MAX_DIST;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y >= 0. && y <= caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    } else if(!traceCaps) {\n        return MAX_DIST;\n    } else {\n        d = ((y < 0. ? 0. : caca) - caoc)/card;\n\n        if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n            normal = normalize(ca*sign(y)/caca);\n            return d;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cone: https://www.shadertoy.com/view/llcfRf\nfloat iCone( const in vec3 oa, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\n             const in vec3 pb, const in float ra, const in float rb ) {\n    vec3  ba = pb;\n    vec3  ob = oa - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps - only top cap needed for scene\n    if (m1 < 0. && dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {\n        float d = -m1/m3;\n        if (d >= distBound.x && d <= distBound.y) {\n            normal = -ba*inversesqrt(m0);\n            return d;\n        }\n    }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n\n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n\n    float h = k1*k1 - k2*k0;\n    if( h < 0. ) return MAX_DIST;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\n        return t;\n    } else {   \n        return MAX_DIST;\n    }\n}\n\n// Box: https://www.shadertoy.com/view/ld23DV\nfloat iBox( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal, \n            const in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) {\n        //\tnormal = sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n//\n// Ray tracer helper functions\n//\nvec3 FresnelSchlick(vec3 SpecularColor, vec3 E, vec3 H) {\n    return SpecularColor + (1. - SpecularColor) * pow(1.0 - max(0., dot(E, H)), 5.);\n}\n\nvec2 randomInUnitDisk(const vec2 seed) {\n    vec2 h = hash22(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Sphere functions\n//\nvec2 activeSphereGrid(float t) {\n  vec2 p = randomInUnitDisk(vec2(floor(t),.5));\n  return floor(p * 8.5 + 1.75*normalize(p));\n}\n\nvec3 sphereCenter(vec2 pos) {\n    vec3 c = vec3(pos.x, 0., pos.y)+vec3(.25,.25,.25);\n    c.xz += .5*hash22(pos);\n\treturn c;\n}\n\nvec3 sphereCol(in float t) {\n    return normalize(.5 + .5*cos(6.28318530718*(1.61803398875*floor(t)+vec3(0,.1,.2))));\n}\n\n//\n// Inverse Kinematics\n//\n// Very hacky, analytical,  inverse kinematics. I came up with the algorithm myself;\n// Íñigo Quílez can probably implement it without using trigonometry:\n// http://www.iquilezles.org/www/articles/noacos/noacos.htm\n//\nvoid initDynamics() {\n    time = iTime * .25;\n\n    activeSpheres[0] = activeSphereGrid(time);\n    activeSpheres[1] = activeSphereGrid(time+1.);\n\n    vec3 ta0 = sphereCenter(activeSpheres[0]);\n    vec3 ta1 = sphereCenter(activeSpheres[1]);\n\n    float taa0 = atan(-ta0.z, ta0.x);  \n    float taa1 = atan(-ta1.z, ta1.x);\n\n    if (abs(taa0-taa1) > 3.14159265359) {\n        taa1 += taa1 < taa0 ? 2. * 3.14159265359 : -2. * 3.14159265359;  \n    }\n    jointYRot = mix(taa0, taa1, clamp(fract(time)*2.-.5,0.,1.));    \n\n    float tal = mix(length(ta0), length(ta1), clamp(fract(time)*2.5-1.,0.,1.));\n\n    vec2 target = vec2(tal,.5-.5*smoothstep(.35,.4,abs(fract(time)-.5)));  \n\n    float c0 = length(target);\n    float b0 = min(11., 4. + 2. * c0 / 11.);\n\n    vec2 sd = normalize(target);\n    float t0 = asin(sd.y)+acos(-(b0*b0-25.-c0*c0)/(10.*c0));\n\n    joints[0] = vec2(5. * cos(t0), 5.* sin(t0));\n    joint0Rot = t0;\n\n    sd = normalize(target-joints[0]);  \n    float c1 = min(6., distance(joints[0], target));\n    const float b1 = 2.;  \n\n    float t1 = asin(sd.y) * sign(sd.x) + acos(-(b1*b1-16.-c1*c1)/(8.*c1));\n    t1 += sd.x < 0. ? 3.1415 : 0.;\n    joints[1] = joints[0] + 4. * vec2(cos(t1),sin(t1));\n    joints[2] = target;\n}\n\n//\n// Scene description\n//\nvec3 opU( const in vec3 d, const in float iResult, const in float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n      \nvec3 iPlaneInt(vec3 ro, vec3 rd, float d) {\n    d = -(ro.y - d) / rd.y;\n    return ro + d * rd;\n}\n\nvec3 traceSphereGrid( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal, const int maxsteps ) {  \n\tfloat m = 0.;\n    if (ro.y < .5 || rd.y < 0.) {\n        vec3 ros = ro.y < .5 ? ro : iPlaneInt(ro, rd, .5);\n        if (length(ros.xz) < 11.) {\n            vec3 roe = iPlaneInt(ro, rd,rd.y < 0. ?0.:.5);\n            vec3 pos = floor(ros);\n            vec3 rdi = 1./rd;\n            vec3 rda = abs(rdi);\n            vec3 rds = sign(rd);\n            vec3 dis = (pos-ros+ .5 + rds*.5) * rdi;\n            bool b_hit = false;\n\n            // traverse grid in 2D\n            vec2 mm = vec2(0);\n            for (int i = ZERO; i<maxsteps; i++) {\n                float l = length(pos.xz+.5);\n                if (pos.y > .5 || pos.y < -1.5 || l > 11.) {\n                    break;\n                }\n                else if ( l > 2. && pos.y > -.5 && pos.y < 1.5 ) {\n                    float d = iSphere(ro-sphereCenter(pos.xz), rd, dist, normal, .25);\n                    if (d < dist.y) {\n                        m = 2.;\n                        dist.y = d;\n                        break;\n                    }\n                }\t\n                vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n                dis += mm*rda;\n                pos += mm*rds;\n            }\n        }\n    }\n\treturn vec3(dist, m);\n}\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 worldhit( const in vec3 ro, const in vec3 rd, const in vec2 dist, out vec3 normal ) {\n    vec3 d = vec3(dist, 0.);\n    \n    d = traceSphereGrid(ro, rd, d.xy, normal, 10);\n    \n    d = opU(d, iPlane   (ro, rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    d = opU(d, iCone    (ro-vec3(0,.2,0), rd, d.xy, normal, vec3(0,.2,0), 1.5, 1.4), 4.);\n    d = opU(d, iCylinder(ro, rd, d.xy, normal, vec3(0,.2,0), 1.5, false), 4.);\n    \n    float dmax = d.y;\n    vec3 roa = rotateY(vec3(ro.x, ro.y-1., ro.z), jointYRot);    \n    vec3 rda = rotateY(rd, jointYRot); \n    \n    vec3 bb = vec3(.5*max(joints[1].x,joints[2].x), joints[0].y*.5, .0);\n    vec3 bbn;\n    \n    if (iBox(roa-bb, rda, vec2(0,100), bbn, bb+vec3(.75,.75,.8)) < 100.) {\n\t    vec3 dr = vec3(-sin(joint0Rot), cos(joint0Rot), 0);\n        vec2 j21 = joints[2]-joints[1];\n        \n        for (int axis=0; axis<=1; axis++) {\n            float a = axis == 0 ? -1. : 1.;\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.67), rda, d.xy, normal, vec3(0,0,-a*.2),.55, true), 3.);\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.58)-.4*dr, rda, d.xy, normal, vec3(joints[0],-a*.24)-.24*dr,.07, false), 4.);\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.58)+.4*dr, rda, d.xy, normal, vec3(joints[0],-a*.24)+.24*dr,.07, false), 4.);\n            d = opU(d, iCylinder(roa-vec3(joints[0],a*.45), rda, d.xy, normal, vec3(0,0,-a*.2),.35, true), 3.);\n            d = opU(d, iCylinder(roa-vec3(joints[1],a*.29), rda, d.xy, normal, vec3(0,0,-a*.08),.25, true), 3.);\n            d = opU(d, iCylinder(roa-vec3(joints[1],a*.24), rda, d.xy, normal, vec3(j21,a*.08),.03, false), 4.);\n        }\n\n        vec2 j10 = joints[1]-joints[0];\n        d = opU(d, iCylinder(roa-vec3(0,0,-.72), rda, d.xy, normal, vec3(0,0,1.44),.5, true), 5.);\n        d = opU(d, iBox     (roa+vec3(0,.5,0), rda, d.xy, normal, vec3(.5,.5,.47)), 5.);\n        d = opU(d, iCone    (roa-vec3(joints[0],0), rda, d.xy, normal, vec3(j10,0),.25, .15), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[0],-.5), rda, d.xy, normal, vec3(0,0,1.),.3, true), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[1],-.35), rda, d.xy, normal, vec3(0,0,.7),.2, true), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[2],-.4), rda, d.xy, normal, vec3(0,0,.8),.2, true), 3.);\n        d = opU(d, iSphere  (roa-vec3(joints[2],0), rda, d.xy, normal, .32), 5.);\n        d = opU(d, iCylinder(roa-vec3(joints[2],0), rda, d.xy, normal, vec3(0,-.5,0),.06, true), 3.);\n\n        if (d.y < dmax) {\n            normal = rotateY(normal, -jointYRot);\n        }\n    }    \n    return d;\n}\n\nfloat shadowhit( const vec3 ro, const vec3 rd, const float dist) {\n    vec3 normal;\n    float d = traceSphereGrid( ro, rd, vec2(.3, dist), normal, 4).y;\n    d = min(d, iCylinder(ro, rd, vec2(.3, dist), normal, vec3(0,.2,0), 1.5, false));\n    return d < dist-0.001 ? 0. : 1.;\n}\n\n//\n// Simple ray tracer\n//\nfloat getSphereLightIntensity(float num) {\n    return num > .5 ?\n        clamp(fract(time)*10.-1., 0., 1.) :\n\t\tmax(0., 1.-fract(time)*10.); \n}\n\nfloat getLightIntensity( const vec3 pos, const vec3 normal, const vec3 light, const float intensity) {\n    vec3 rd = pos - light;\n    float i = max(0., dot(normal, -normalize(rd)) / dot(rd,rd));\n    i = i > 0.0001 ? i * intensity * shadowhit(light, normalize(rd), length(rd)) : 0.;\n    return max(0., i-0.0001);              \n}\n\nvec3 getLighting( vec3 p, vec3 normal ) {\n    vec3 l = vec3(0.);\n    \n    float i = getSphereLightIntensity(0.);\n    if (i > 0.) {\n\t    l += sphereCol(time) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[0]), .375));\n    } else {    \n        i = getSphereLightIntensity(1.);\n        if (i > 0.) {\n            l += sphereCol(time+1.) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[1]), .25));\n        }\n    }\n    \n    vec3 robot = mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));\n    vec3 lp = rotateY(vec3(joints[2].x, joints[2].y+1.,0), -jointYRot);\n    i = getLightIntensity(p, normal, lp, .5);\n    i += getLightIntensity(p, normal, vec3(0,2,0), .25);\n    l += i * robot;\n    \n    return l;\n}\n\nvec3 getEmissive( in vec2 pos, in float mat ) {\n    if (mat > 2.5 ) {\n\t   return mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));\n    } else if (mat > 1.5 ) {\n        float li0 = getSphereLightIntensity(0.);\n        float li1 = getSphereLightIntensity(1.);\n        if (li0 > 0. && pos == activeSpheres[0]) {\n            return sphereCol(time) * li0 * 1.25;\n        } else if (li1 > 0. && pos == activeSpheres[1]) {\n            return sphereCol(time+1.) * li1;\n        } else {\n            return vec3(0);\n        }\n    } else {\n        return vec3(0);\n    }\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(1);\n    vec3 emitted = vec3(0);\n    vec3 normal;\n        \n    for (int i=ZERO; i<PATH_LENGTH; ++i) {\n    \tvec3 res = worldhit( ro, rd, vec2(MIN_DIST, MAX_DIST-1.), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n\n            if (res.z < 3.5) { \n               \tvec3 F = FresnelSchlick(vec3(0.4), normal, -rd);\n                emitted += (col * (getEmissive(floor(ro.xz), res.z) + .5 * getLighting(ro, normal))) * (1.-F);\n                col *= .5 * F;\n            } else {\n                col *= res.z < 4.5 ? vec3(.7,.75,.8) : vec3(.9,.6,.2);   \n            } \n            \n            rd = normalize(reflect(rd,normal));\n        } else {\n\t\t\treturn emitted;\n        }\n    }  \n    return emitted;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initDynamics();\n\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.4,-.1) : abs(iMouse.xy)/iResolution.xy - .5;\n\n    vec3 ro = vec3(10.5*cos(1.5+6.*mo.x), 6.+10.*mo.y, 8.5*sin(1.5+6.*mo.x));\n    vec3 ta = vec3(ro.x*ro.y*.02, .8, 0);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    \n    vec3 col = vec3(0);\n    \n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ ) {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n        col += pow(8. * render(ro, rd), vec3(1./2.2));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n    \n    col = clamp(col + ((hash22(fragCoord).x-.5)/64.), vec3(0), vec3(1));\n    \n\tfragColor = vec4(col , 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSSDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[1612, 1681, 1702, 1702, 1835], [1837, 1921, 1946, 1946, 1965], [1967, 1977, 2133, 2133, 2367], [2369, 2418, 2556, 2556, 2970], [2972, 3030, 3202, 3202, 4019], [4021, 4075, 4239, 4239, 5262], [5264, 5310, 5440, 5440, 6100], [6102, 6139, 6196, 6196, 6283], [6285, 6285, 6325, 6325, 6460], [6462, 6488, 6520, 6520, 6615], [6617, 6617, 6646, 6646, 6742], [6744, 6744, 6772, 6772, 6863], [6865, 7114, 7135, 7135, 8337], [8339, 8366, 8439, 8439, 8496], [8504, 8504, 8547, 8547, 8601], [8603, 8603, 8702, 8702, 9915], [9917, 9917, 9968, 9968, 10089], [10091, 10091, 10181, 10181, 12649], [12651, 12651, 12717, 12717, 12927], [12929, 12956, 12998, 12998, 13098], [13100, 13100, 13202, 13202, 13427], [13429, 13429, 13470, 13470, 14177], [14179, 14179, 14226, 14226, 14760], [14762, 14762, 14800, 14800, 15522], [15524, 15524, 15576, 15576, 15753], [15755, 15755, 15812, 15812, 16676]]}
{"id": "tlSXR3", "name": "Aurora Borealis? ", "author": "draco_nite", "description": "AURORA BOREALIS? AT THIS TIME OF YEAR, AT THIS TIME OF NIGHT, LOCALIZED ENTIRELY WITHIN THIS SHADER?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYes.", "tags": ["steamedhams"], "likes": 3, "viewed": 410, "published": "Public API", "date": "1566554261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// thank you https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    uv -= .5;\n    \n    vec3 col = vec3( (sin(uv.x + iTime)), sin(iTime * 5.), (sin(-uv.y - .6) + 1.) / 2.);\n    col = hsv2rgb(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 78, 78, 256], [258, 258, 315, 365, 628]]}
{"id": "tlSXRz", "name": "Colder Amoebas", "author": "Mipmap", "description": "Colder tweak of 'Cold Amoebas', based on 'Flow of cells' (https://www.shadertoy.com/view/WtSSRR)", "tags": ["2d", "animation", "curve", "organic", "cell", "art", "cold"], "likes": 4, "viewed": 375, "published": "Public API", "date": "1564763659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Colder tweak of 'Cold Amoebas', based on 'Flow of cells' (https://www.shadertoy.com/view/WtSSRR)\n#define FIELD 35.0\n#define HEIGHT 0.7\n#define ITERATION 2.\n#define TONE vec4(0.0,0.2,0.6,0)\n#define SPEED 0.6\n\nfloat eq(vec2 p,float t){\n\tfloat x = sin( p.y-t +cos(t+p.x*.2) ) * cos(p.x-t);\n\tx *= acos(x);\n\treturn - x * abs(x-0.0) * p.x/p.y;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n\tvec4 X=O;\n\tvec2  p = FIELD*(U / iResolution.xy  +.5);\n\tfloat t = iTime*SPEED,i,\n         hs = 20.*(HEIGHT+cos(t)*.1),\n\t      x = eq(p,t), y = p.y-x;\n    \n\tfor(float i=0.; i<ITERATION; ++i)\n\t\tp.x *= 2.,\n        X = x + vec4(0, eq(p,t+i+1.), eq(p,t+i+2.) ,0),\n        x = X.z += X.y,\n        O += TONE / abs(y-X-hs);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 211, 236, 236, 342], [344, 344, 382, 382, 700]]}
{"id": "tlsXz7", "name": "Coaster Party", "author": "104", "description": "curves\n& modulation\n& curves\n& modulation", "tags": ["2d", "festive"], "likes": 17, "viewed": 213, "published": "Public", "date": "1564669479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592654;\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec4 disco(vec2 uv) {\n    float v = abs(cos(uv.x * PI * 2.) + cos(uv.y *PI * 2.)) * .5;\n    uv.x -= .5;\n    vec3 cid2 = hash32(vec2(floor(uv.x - uv.y), floor(uv.x + uv.y))); // generate a color\n    return vec4(cid2, v);\n}\nmat2 rot2D(float r){\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nvec2 warp(vec2 uv, float f, out float sd) {\n    float d = length(mod(uv+1.,2.)-1.);\n    sd = d-1.;\n    return uv*f*(1.-d);\n}\n\nvec4 purty(vec2 V, float t, float f) {\n    float t2 = t*.2;\n    V *= rot2D(t2*.25);\n    V += vec2(sin(t2), cos(t2));\n\n    float sd;\n    vec2 uvP = warp(V, f, sd);\n\n    uvP += t*.2;\n\n    vec4 d = disco(uvP);\n    vec3 col = d.rgb * pow(d.a, .15);\n\n    col.rg *= rot2D(.1);\n    col.br *= rot2D(-.2);\n\n    float a = pow(smoothstep(0.,1.,-sd), .4);\n    return vec4(col, a);\n}\nvoid mainImage(out vec4 o, vec2 O)\n{\n    float t = iTime+1e3;\n    vec2 R = iResolution.xy\n        ,V=(O-.5*R)/R.y\n        ,N=O/R-.5\n        ,P=O-R*.5;\n    V *= 4.;\n    \n    vec4 p =purty(V, t, 4.);\n    V += 1.;\n    V = -V * 2.;\n    vec4 p2 = purty(V, t, 1.);\n    p2.rgb *= .15;\n    p2.rgb = mix(p2.rgb,vec3(p2.r+p2.g+p2.b)/3.,.9);//desaturate\n\n    o = mix(p2,p,smoothstep(0.,.05,iMouse.z > 0. ? 0. : p.a));//mix the lower layer where a = 0\n    \n    o=clamp(o,0.,1.);\n    o = pow(o,o-o+.5);\n    o *= 1.-dot(N,N*2.);\n    o *= 1.-step(.42,abs(N.y));\n    o.a= 1.;\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 51, 51, 187], [188, 188, 209, 209, 409], [410, 410, 430, 430, 496], [497, 497, 540, 540, 621], [623, 623, 661, 661, 993], [994, 994, 1030, 1030, 1555]]}
{"id": "tlSXzD", "name": "Ciel sacré", "author": "hamtarodeluxe", "description": "A simple 2D shader based on domain repetition in polar coordinates :-)\nOriginal art from a friend of mine : https://www.instagram.com/p/B03t1VhCrNY/\n", "tags": ["2d", "eye", "sky", "stars", "night", "polar"], "likes": 3, "viewed": 132, "published": "Public", "date": "1565398666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define SOFT 0.0035\n\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    float v = mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n              \t             dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n              \t        mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n              \t             dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n              \t   mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n              \t             dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n              \t        mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n              \t             dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n\treturn v;\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float v = mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn v;\n}\n\nfloat fbm (vec2 p)\n{\n\treturn noise(p)+0.5*noise(p*2.);\n}\n\nfloat fbm (vec3 p)\n{\n    float n =0.;\n    float s = 1.;\n    for (int i = 0; i<6; i++)\n    {\n\t \tn+= noise (p*s)/s;\n    \ts*=2.;\n\t}\n    return n;\n}\nfloat band(float x,float mid, float thickness)\n{\n\treturn smoothstep (mid-thickness,mid,x)-smoothstep(mid, mid+thickness,x);\n}\n\nfloat ring(float rMin, float rMax, float l, float soft)\n{\n    return  smoothstep (rMin-soft,rMin,l)-smoothstep(rMax, rMax+soft,l);    \n}\n\nfloat sat(float x){return clamp(x,0.,1.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec2 uvNorm = uv*2.;\n\n    uv *= 0.0035;\n    uv *= iResolution.xy;\n    vec2 oldUv = uv;\n    \n    uv += vec2(cos(0.5*iTime),sin(0.33*iTime))*0.045;\n\n    float pol = atan(uv.y,uv.x)+PI;\n    float rad = length(uv); \n    \n    float deform = 0.02 * noise(vec3(7.*oldUv, iTime));\n    \n    float rMin = 0.06 + deform +sin(iTime*0.5)*0.015;;\n    float rMax = 0.35 + deform;\n    float limit = 0.18 + deform ;\n    float bands = step(limit,rad);\n    float thickness = 0.0018*3.;   \n\tfloat sp = 0.25;\n    float nSlice = mix(7.,9.,bands);\n   \tfloat slice = 2.*PI / nSlice;\n    \n    pol+=iTime*mix(0.05,-0.05,bands);\n    \n    uv.x = cos(pol)*rad;\n    uv.y = sin(pol)*rad;\n    \n\t// Main shape   \n    float t1 =  1.-(smoothstep(rMin, rMin +0.5*(limit-rMin),rad)-smoothstep(rMin +0.5*(limit-rMin),limit,rad));\n    float t2 =  1.-(smoothstep(limit, limit +0.5*(rMax-limit),rad)-smoothstep(limit +0.5*(rMax-limit),rMax,rad));\n    float nMap = mix(t1,t2,step(limit,rad));\n    float reshape = 1.0;\n    float nStr = 0.03 / pow(rad,0.85);  \n    float nFq = 7.;\n    float offsetStr = 0.2;\n    \n    //(pass1)\n    float pol1 = pol;       \n    float rot = slice*3.5*bands;\n    float s = step(rad,limit);\n    pol1 += rot;    \n    float cellPol =-rot+(floor((pol+rot+0.5*slice)/(slice))+0.5)*(slice);\n    float cellId = floor((mod(pol1+0.5*slice,2.*PI)/slice));\n    float offset = hash(vec2(cellId,0.)).x*rad;\n    vec2 cp = normalize(vec2(cos(cellPol),sin(cellPol)));\n    pol1 = mod(pol1+0.5*slice,slice)-0.5*slice;   \n    float n = nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.));\n    float li1 = band(pol1+n+offsetStr*offset,0.,thickness/(rad));\n    n = mix(n, nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.+5000.)),nMap);\n    li1 = max(li1,band(pol1+n+offsetStr*offset,0.,thickness/(rad)));   \n    \n    //(pass2)\n    pol1 = pol;       \n    rot = slice*0.5+slice*3.5*bands;\n    s = step(rad,limit);\n    pol1 += rot;    \n    cellPol =-rot+(floor((pol+rot+0.5*slice)/(slice))+0.5)*(slice);\n    cellId = floor((mod(pol1+0.5*slice,2.*PI)/slice));\n    offset = hash(vec2(cellId,1.)).x*rad;\n    cp = normalize(vec2(cos(cellPol),sin(cellPol)));\n    pol1 = mod(pol1+0.5*slice,slice)-0.5*slice;   \n    n = nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.+2000.));\n    float li2 = band(pol1+n+offsetStr*offset,0.,thickness/(rad));\n    n = mix(n,nStr*4.*(fbm(uv*nFq-cp*iTime*sp+rad*2.+5000.)),nMap);\n    li2 = max(li2,band(pol1+n+offsetStr*offset,0.,thickness/(rad)));\n   \n    float li = max (li1,li2);\n    \n    float zoneMid = ring(0.,rMin,rad,SOFT);\n    float mid =  (fbm(vec3(oldUv*150.,iTime*0.5)))-0.2;\n\tfloat ring0 = ring(rMin,rMin+0.002,rad,SOFT);\n    float ringlim = ring(limit,limit+0.002,rad,SOFT);\n    float zone = ring(rMin,rMax,rad,SOFT);\n\t\n    li = max(max(li,ring0),ringlim);\n\tli = min (li,zone);\n    li = max(li,mid*zoneMid);\n    \n    zone = ring(0.,rMax,rad,SOFT+0.01);\n            \n    vec3 liCol = mix(vec3(0.4), 1.5*vec3(0.16,0.14,0.025) , ring(0.,limit-SOFT,rad,SOFT));\n    vec3 bgCol = mix(vec3(0.001,0.0045,0.1429),vec3(0.0087),zoneMid);\n    vec3 mainShape = mix(bgCol*zone,liCol,li);\n    \n    //Stars\n    pol = atan(oldUv.y,oldUv.x)+PI;\n    rad = length(oldUv);    \n    slice = 2.*PI/50.;\n    float radSlice = 40.*pow(rad,0.24);\n \t\n    //(pass1)\n    cellPol = floor(pol/slice);\n    float cellRad = floor(-0.25*iTime+radSlice);\n    vec2 cellSpace = vec2(fract(pol/slice), fract(-0.25*iTime+radSlice));\n    vec3 cellH = hash(vec3(cellRad,cellPol,50.))*0.5+0.5;\n       \n    float starRad = (cellH.y*0.032+0.02)/rad;\n    float starProb = cellH.x;\n    float starOs = cellH.z-0.5;\n    float starLum = cellH.z;\n    float stars = starProb>0.4 ? 0. : starLum*smoothstep(starRad+0.01,0.01,length(-starOs+cellSpace-0.5));\n    \n    //(pass2)\n    pol +=0.5*slice;\n    cellPol = floor(pol/slice);\n    cellRad = floor(-0.5*iTime+150.+radSlice);\n    cellSpace = vec2(fract(pol/slice), fract(-0.5*iTime+radSlice));\n    cellH = hash(vec3(cellRad,cellPol,50.))*0.5+0.5;\n       \n    starRad = (cellH.y*0.032+0.02)/rad;\n    starProb = cellH.x;\n    starOs = cellH.z-0.5;\n    starLum = cellH.z;\n    stars = max(stars, starProb>0.4 ? 0. : starLum*smoothstep(starRad+0.01,0.01,length(-starOs+cellSpace-0.5)));\n    stars = sat(stars);\n    \n    //Background\n    float bgNoise = fbm(vec3(2.*oldUv/pow(rad,0.35),iTime*0.175))*0.5+0.5;\n    bgNoise = sat (bgNoise);\n\tvec3 col = vec3(0);// \n    vec3 cbg1 = 0.25*vec3(0.00450,.0049,0.0138); vec3 cbg2 = vec3(0.0052,0.0055,0.03);\n    col = mix(cbg1,cbg2,bgNoise);\n    col = mix(col, 1.*vec3(0.003,0.003,0.035), smoothstep(0.5,0.71,bgNoise));\n    col = mix(col*0.75,col,  smoothstep(0.3,0.35,bgNoise));\n\tcol *=0.75;\n    stars += (0.2*sat(mid) *(smoothstep(0.5,0.7,bgNoise)-smoothstep(0.9,1.,bgNoise)));\n    col += mix (col, vec3(0.3),stars);\n    \n    col = mix (col, mainShape, zone);\n    \n    //shadow\n    pol = atan(uv.y,uv.x) + PI;\n    rad = length(uv); \n    \n    pol += noise(vec2(rad*50.,0.5*iTime));\n    pol = mod(pol, 2.*PI);   \n    float v = sat((1.-zone)*(1.-(rad-rMax )/ (0.05+sin(pol*2.)*0.025)));\n    col = mix(col, col*0.2, v);\n    \n    //vignette and noise\n    col = mix(col,col*0.5,hash(oldUv).x);\n    col *= 1./pow((pow(sqrt(dot(uvNorm,uvNorm)*.4),2.)+1.),2.5);\n    \n    //texture\n    float pap = 1.-length((fract(oldUv*70.+vec2(0.,noise(0.5*oldUv*100.+5000.)))-0.5)/0.7);\n\tpap = sat(pap+0.5);\n\tcol *= pap;\n    \n    //the end\n    col = pow(col,vec3(0.45));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 62, 62, 177], [179, 179, 200, 200, 369], [371, 371, 394, 394, 1247], [1249, 1249, 1272, 1272, 1693], [1695, 1695, 1715, 1715, 1751], [1753, 1753, 1773, 1773, 1897], [1898, 1898, 1946, 1946, 2023], [2025, 2025, 2082, 2082, 2161], [2163, 2163, 2182, 2182, 2206], [2208, 2208, 2265, 2265, 7703]]}
{"id": "tlXXzB", "name": "Spheres raytracing (tutorial)", "author": "Megus", "description": "A simple raytracing example with lighting (diffusion and specular) and shadows.", "tags": ["raytracing"], "likes": 3, "viewed": 526, "published": "Public API", "date": "1565716861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COUNT 5\n#define SIZE 4\n\n#define LIGHT_POWER 80.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\nvec4 spheres[] = vec4[COUNT * SIZE](\n    // Spheres: center and radius, color, movement speed, movement amplitude\n    // Light source\n    vec4(-7.5, 0., 31., 0.1), vec4(1., 1., 1., 1.),\n    vec4(2., 1., 0, 0), vec4(0, 2., 0, 0),\n    // 1\n    vec4(-4., 0., 39., 2), vec4(.2, .9, .2, 1.),\n    vec4(1., 1.1, 2., 0), vec4(2, 3, 5.1, 0),\n    // 2\n    vec4(3., 0., 42., 3.), vec4(.9, .4, .5, 1.),\n    vec4(1.3, 1.7, 1.5, 0), vec4(1, 4, 5.1, 0),\n    // 3\n    vec4(2, -1., 43., 1.5), vec4(.2, .3, 1., 1.),\n    vec4(2., 1., 2., 0), vec4(7, 1, 7, 0),\n    // \"Floor\"\n    vec4(0, -800006, 0, 800000), vec4(1.7, 1.0, .7, 1),\n    vec4(0, 0, 0, 0), vec4(0, 0, 0, 0)\n);\n\n// Calculate a moving sphere center\nvec3 sphereCenter(int sphere) {\n    vec4 sD = spheres[sphere * SIZE];\n    vec4 sS = spheres[sphere * SIZE + 2];\n    vec4 sA = spheres[sphere * SIZE + 3];\n    vec3 c = vec3(\n        sD.x + sin(iTime * sS.x) * sA.x,\n        sD.y + sin(iTime * sS.y) * sA.y,\n        sD.z + cos(iTime * sS.z) * sA.z);\n    return c;    \n}\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n    int sphere = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < COUNT; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        vec3 c = sphereCenter(i);\n        float r = spheres[i * SIZE].w;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                sphere = i;\n                d = sd;\n            }\n        }\n    }\n    return sphere;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int sphere = findIntersection(camO, camL, -1, d);\n    \n    if (sphere == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = spheres[1].xyz;\n\n    if (sphere == 0) {\n        // It's a light source, don't need to shade it\n        return lightColor;\n    }\n    \n    vec3 lightPoint = sphereCenter(0);\n    \n    // Sphere color\n    vec3 sColor = spheres[sphere * SIZE + 1].xyz;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sphereCenter(sphere));\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint);\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, sphere, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy != 0) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, 0);\n    vec3 camL = normalize(vec3(uv.x, uv.y, 7));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXXzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[758, 794, 825, 825, 1110], [1112, 1359, 1422, 1422, 2054], [2056, 2174, 2208, 2208, 3672], [3674, 3674, 3731, 3781, 4069]]}
{"id": "tsBSWK", "name": "Ray Marching Lightning", "author": "pavleeto", "description": "Add Light to the scene", "tags": ["raymarching"], "likes": 2, "viewed": 145, "published": "Public", "date": "1567099059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereDE(vec3 position, vec3 center, float radius)\n{\n    return max(0.0, length(position - center) - radius);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sceneDE(vec3 position)\n{\n    float answer = min(sphereDE(position, vec3(sin(iTime)*5.0, 0.0, 0.0), 2.0),\n                       sphereDE(position, vec3(-sin(iTime)*5.0, 0.0, 0.0), 2.0));\n    answer = min(answer, sphereDE(position, vec3(cos(iTime*2.0)*10.0, 0.0, -sin(iTime*2.0)*10.0), 1.0));\n    answer = min(answer, sdPlane(position, normalize(vec4(0.0, 1.0, 0.0, 2.0))));\n    return answer;\n}\n\nvec3 estimateNormal(vec3 p) {\n    const float EPSILON = 1e-4;\n    return normalize(vec3(\n        sceneDE(vec3(p.x + EPSILON, p.y, p.z)) - sceneDE(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDE(vec3(p.x, p.y + EPSILON, p.z)) - sceneDE(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDE(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDE(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 raymarching(vec3 eye, vec3 dir, vec3 inf)\n{\n    const float MAX_STEPS = 200.0;\n    const float MIN_DIST = 1e-5;\n    \n    float steps = 0.0;\n    float totalDist = 0.0;\n    while (steps++ < MAX_STEPS)\n    {\n        vec3 pos = eye + totalDist * dir;\n        float delta = sceneDE(pos);\n        totalDist += delta;\n        \n        if (delta < MIN_DIST) break;\n    }\n    \n    vec3 finalPos = eye + totalDist * dir;\n    // if finalPos > MIN_DIST, infinity\n    return finalPos + step(MIN_DIST, sceneDE(finalPos)) * inf;  \n}\n\nvec3 phongLightningModel(float coeffDiffuse,\n                         vec3 eye,\n                         vec3 pos,\n                         vec3 normalInPos,\n                         vec3 lightPos, \n                         vec3 lightColor)\n{\n    vec3 lightDir = normalize(lightPos - pos);\n   \tfloat angleLightDir = dot(normalInPos, lightDir);\n    \n    return lightColor * (coeffDiffuse * angleLightDir) * step(0.0, angleLightDir);\n}\n\nvec3 computeLightning(vec3 eye, vec3 pos)\n{\n    const vec3 light1Pos = vec3(0, 10, 0);\n    const vec3 light1Color = vec3(0.8, 0.8, 0.8);\n    const vec3 ambient = vec3(0.08, 0.08, 0.08);\n    vec3 normalInPos = estimateNormal(pos);\n    \n    return ambient + phongLightningModel(0.8,\n                                         eye,\n                                         pos,\n                                         normalInPos,\n                                         light1Pos,\n                                         light1Color);\n}\n\n\nvec4 rayDir(vec2 uv, float fov, float aspect)\n{\n    vec2 coeffs = ((uv - 0.5) * 2.0) * tan(fov/2.0);\n    coeffs.x *= aspect;\n    vec4 dir = vec4(coeffs, -1.0, 0.0);\n    \n    return normalize(dir);\n}\n\nmat4 lookAt(vec3 eye, vec3 on, vec3 up)\n{\n    vec3 f = normalize(on - eye);\n    vec3 r = cross(f, up);\n    vec3 u = cross(r, f);\n    \n    return mat4(\n        vec4(r, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat aspect = iResolution.x / iResolution.y;\n    \n    // rayDir\n    vec3 eye = vec3(cos(iTime/2.3)*20.0, 2.0, sin(iTime/2.3)*20.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    mat4 worldToCam = lookAt(eye, center, vec3(0.0, 1.0, 0.0));\n    vec3 dir = (worldToCam * rayDir(uv, radians(45.0f), aspect)).xyz;\n    \n    vec3 pos = raymarching(eye, dir, vec3(1e4, 1e4, 1e4));\n    vec3 color = computeLightning(eye, pos);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 117], [118, 118, 151, 177, 208], [210, 210, 240, 240, 610], [612, 612, 641, 641, 977], [979, 979, 1027, 1027, 1501], [1503, 1503, 1745, 1745, 1936], [1938, 1938, 1981, 1981, 2473], [2476, 2476, 2523, 2523, 2674], [2676, 2676, 2717, 2717, 2939], [2941, 2941, 2998, 3048, 3565]]}
{"id": "tt2SDm", "name": "big eyes", "author": "lucastakejame", "description": "i never know what to put here...", "tags": ["2d", "eyes"], "likes": 0, "viewed": 136, "published": "Public API", "date": "1566173087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIN(t) (.5*sin(t) + .5)\n#define ss(a,b,c) smoothstep(a,b,c)\n#define tt iTime\n\n\nfloat eye(vec2 uv, vec2 center, float rad, float falloff)\n{\n    return smoothstep(rad + falloff + .001, rad - falloff, length(uv-center));\n}\n\nvec3 eyeRGB(vec2 uv, vec2 center, float rad, float falloff, vec2 modul)\n{\n    float eyer = eye(uv, center, rad, falloff);\n    falloff = falloff*modul.x + modul.y;\n    float eyeg = eye(uv, center, rad, falloff);\n    falloff = falloff*modul.x + modul.y;\n    float eyeb = eye(uv, center, rad, falloff);\n    \n    // Time varying pixel color\n    return vec3(eyer, eyeg, eyeb);\n\n}\n\nfloat smile(vec2 uv, vec2 center, float amount)\n{\n \n    float rad = .4;\n    float falloff = .01;\n    float smile0 = eye(uv, center, rad, falloff);\n    float smile1 = eye(uv, center+vec2(0.,.1 *amount), rad, falloff);\n    \n    return smoothstep(0., 1., smile0 - smile1);\n}\n\nvec2 rot(vec2 uv, float ang)\n{\n    vec2 i = vec2(cos(ang), sin(ang));\n    return vec2(uv.x*i.x - uv.y*i.y, uv.x*i.y + uv.y*i.x);\n}\n\nfloat maskT(float t, vec2 inter, float falloff)\n{\n    float mid = (inter.x + inter.y)/2.;\n    float amp = abs(inter.x - mid);\n    return ss(amp+falloff, amp-falloff, abs(t - mid)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    // eyes\n    \n    float tm10 = mod(tt,10.);\n    float teyeslide = ss(2. + 8.*float(tm10>9.5),\n                   9. + .5*float(tm10>9.5),\n                   tm10);\n    \n    vec2 eyeloc = vec2(.4);\n    vec3 eye = eyeRGB(uv, eyeloc, .3, .1, vec2(1., 0.1));\n    //blinking\n    float t0 = maskT(mod(tt, 4.), vec2(0.4, .5), .01);\n    t0 = max(t0,maskT(mod(tt, 4.), vec2(0.2, .3), .01));\n    t0 = max(t0,maskT(mod(tt, 4.), vec2(2., 2.3), .1));\n    eye *= 1. - 200.*t0*abs(uv.y - .4);\n    \n    vec2 eyeloc2 = vec2(-.4, .4 + teyeslide*(-.04));\n    vec3 eye2 = eyeRGB(uv, eyeloc2 + vec2(0., -.3*teyeslide), .3, .1, vec2(1., 0.1));\n    \n    // eyebrow\n    eye *= ss(0.3,.0, dot(uv-eyeloc + vec2(0., -.3*teyeslide), vec2(1.,1.)));\n    eye2 *= ss(0.3,.0, dot(uv-eyeloc2, vec2(-1.,1.)));\n    \n    vec3 iris = eyeRGB(uv, vec2(.4), .1, .1, vec2(.2, 0.));\n    vec3 iris2 = eyeRGB(uv, vec2(-.4,.4 + teyeslide*(-.2)), .1, .1, vec2(.2, 0.));\n    \n    // Time varying pixel color\n    vec3 col = eye + eye2 - iris - iris2;\n    \n    float t1 = maskT(mod(tt, 3.), vec2(0.2, 1.2), .3);\n    t1 = max(t1, maskT(mod(tt, 5.), vec2(2., 2.7), .2));\n    float t2 = maskT(mod(tt, 2.), vec2(0.5, 0.7), .1);\n    float smil = smile(uv*vec2(1. + t2*.1,1.+ t1*.2), vec2(0.,-.2), .5);\n    smil *= ss(0.,.1, SIN(uv.x * 80.));\n    float smil2 = smile(rot(uv*1.8,.5), vec2( .7,.4), .2 + .05*sin(35.*tt));\n    float smil3 = smile(rot(uv*1.8,-.5), vec2(-.7,.4), .2);\n    \n    col += smil;\n    col += smil2;\n    col += smil3;\n    \n    col = max(col, .6*eyeRGB(uv, vec2(.0), .9, .05, vec2(1., 0.45)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2SDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 146, 146, 227], [229, 229, 302, 302, 603], [605, 605, 654, 654, 876], [878, 878, 908, 908, 1008], [1010, 1010, 1059, 1059, 1193], [1196, 1196, 1253, 1303, 2987]]}
{"id": "tt2SRd", "name": "Fire Kamehameha", "author": "TheRomanOne", "description": "Tried to make a 2D animation with 3D  SDFs.", "tags": ["torus", "fire", "rings", "sin", "animation", "kamehameha"], "likes": 4, "viewed": 109, "published": "Public", "date": "1566941885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\nI wanted to see if I could make a 2D \"kamehameha\" like\nblast with 3D SDFs\n\nI probably don't need ALL the code that's here\nfor a simple scene like this, but I enjoyed setting\nthis whole \"engine\" up and play around with it.\n\nFirst time I try this approach from scratch, I mostly\nwanted to see how much I understand..\n\n*/\n\n#define eps 0.001\n#define max_dist 1000.\n#define PI 3.141592654\n\n#define BACKGROUND 0.\n#define DOUBLE_RING 0.\n#define CRYSTAL 1.\n#define KAMEHAMEHA 2.\n\nfloat time;\n\n\nmat2x2 rot(float deg)\n{\n    float ang = deg * PI / 180.;\n    float s = sin(ang), c = cos(ang);\n    return mat2x2(c, s, -s, c);\n}\n\nfloat torus(vec3 p, vec3 pos, vec2 width, float radius)\n{\n    p += pos;\n    \n    vec2 q = vec2(length(p.xz)-width.x - radius,p.y);\n    return length(q)-width.y;\n}\n\nfloat doubleRing(vec3 p)\n{\n    float dtime = sqrt(sqrt(2.*time));\n    vec3 pivot = vec3(0, 0, 0.);\n    \n    //p-= pivot;\n    //p += pivot;\n    \n    float compl;\n    \n    compl= sin((dtime));\n    \n    // Bottom ring\n    vec3 pos1 = pivot;\n    float rad1 = .5 * compl;\n    vec2 w1 = vec2(.01) + .02 * vec2(0., sin(dtime*3.25));\n    float t1 = torus(p, pos1, w1, rad1);\n    \n    // Top ring\n    vec3 pos2 = pos1 + vec3(0, -.2, 0.);\n    float rad2 = .35 * compl;\n    vec2 w2 = vec2(.01) + .02 * vec2(0., sin(3.25*dtime));\n    float t2 = torus(p, pos2, w2, rad2);\n    //time = tt;\n    \n    return min(t1, t2);\n}\n\nfloat ball(vec3 p, vec3 pos, float rad)\n{\n    return length(p - pos) - rad;\n}\n\nfloat kamehameha(vec3 p, vec3 pos, vec3 c )\n{\n    p += pos;\n    float r = .1;\n    \n    p.y -= clamp( p.y, 0.,.3)+.07;\n    float l = length(p) - r - 1.1*sin(p.y * max(.0, .9 + .05*sin(time*50.)));\n    \n    return l+time/10.;\n    \n}\n\nvec2 blast(vec3 p)\n{\n    p.xz *= rot(55.);\n    p.yz *= rot(-55.);\n    float d = doubleRing(p);\n    float b = ball(p, vec3(0, -.1, 0), .04);\n    \n    float k = kamehameha(p, vec3(0, .2, 0), vec3(.1));\n    float obj = 0.;\n    \n    if(k < d)\n    {\n        d = k;\n        obj = KAMEHAMEHA;\n    }\n    \n    if(b < d)\n    {\n        d = b;\n        obj = CRYSTAL;\n    }\n    \n    return vec2(obj, d);\n}\n\nvec2 map(vec3 p)\n{    \n    return blast(p);\n}\n\nvec3 deriv(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(eps, 0, 0)).y - map(p - vec3(eps, 0, 0)).y,\n        map(p + vec3(0, eps, 0)).y - map(p - vec3(0, eps, 0)).y,\n        map(p + vec3(0, 0, eps)).y - map(p - vec3(0, 0, eps)).y\n        ));\n}\n\nvec3 lighting(vec3 newRay, vec3 light, vec2 data)\n{\n    vec3 col;\n    \n    if(data.x == KAMEHAMEHA)\n    {\n        vec3 kLight = vec3(0, 0, -5);\n        kLight.yz *= rot(-time*2500.);\n        kLight.xz *= rot(-time*1500.);\n        float dt = dot( deriv(newRay), kLight );\n        \n        if(dt > .5 * sin(newRay.x*10. + 10.*time))\n            col = vec3(1., .2, 0.);\n        else col = vec3(1., 0, 0);\n\n        vec3 kLight2 = vec3(0, 1, 0);\n        kLight2.yz *= rot(-time*2000.);        \n        \n        dt = dot( deriv(newRay), kLight2 );\n        \n        if(dt < .5 * sin(newRay.x*10. + 10.*time))\n            col *= vec3(1., .5, .9);\n        else if(dt < .7)\n            col = vec3(1., 1., 0);\n        \n            \n        \n        kLight = vec3(-5.*sin(time*100.), -sin(time), -7);\n        //kLight.yz *= rot(-time*2500.);\n        //kLight.xz *= rot(-time*1500.);\n        dt = dot( deriv(newRay), kLight )/5.;\n        \n        if(dt > .4 * cos(newRay.x*time))\n            col = vec3(1.);\n        \n        //col = vec3(dt);\n    }else\n    {\n        float dt = dot( deriv(newRay), light );\n\n        if(data.x == DOUBLE_RING)\n            col = vec3(240., 0., 56.)/255.;\n\n        else if(data.x == CRYSTAL)\n            col = vec3(0, 0, 1);\n\n        if(dt > .5 + .2 * sin(newRay.x*10. + 10.*time))\n            col = vec3(0.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 camPos = vec3(.2, 0., 0);\n    vec3 ro = camPos + vec3(0., 0, -1.);\n\n    vec3 ta = camPos + vec3(0., 0, 1);\n    \n    // Don't really need cam vectors since I'm not moving\n    // the camera around..\n    \n    /*vec3 fw = normalize(ta - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up = cross(fw, ri);*/\n    vec3 rd = /*mat3x3(ri, up, fw) **/ vec3(uv, 1);\n    \n    \n    // THIS line is what sets the pace of the animation\n    //time = mod(iTime, PI/2. - .1);\n    \n    if(iMouse.z> 0.)\n\t\ttime = mod(iMouse.x/iResolution.y, PI-.5);\n    else\n    //if(time > PI/2.-5.)\n        time = mod(iTime, PI-.5);\n    \n    float dist, t;\n    vec3 newRay;\n    vec2 data;\n    for(int i = 0; i < 256; i++)\n    {\n        newRay = ro + t * rd;\n        data = map(newRay);\n        dist = data.y;\n        if(dist < 0.01)\n            break;\n        else if(t > max_dist)\n        {\n            newRay = vec3(max_dist);\n            break;\n        }\n        t += dist *.7;\n    }\n    \n    // Time varying pixel color\n    \n    vec3 col = vec3(0);\n    if(dist < max_dist)\n    {\n        vec3 light = normalize(vec3(1, 1, -2));\n        col = lighting(newRay, light, data);\n        col *= lighting(newRay, vec3(0, sin(time*5.), -1. + sin(time)), data);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2SRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 491, 514, 514, 619], [621, 621, 678, 678, 783], [785, 785, 811, 811, 1391], [1393, 1393, 1434, 1434, 1470], [1472, 1472, 1517, 1517, 1702], [1704, 1704, 1724, 1724, 2096], [2098, 2098, 2116, 2116, 2143], [2145, 2145, 2165, 2165, 2400], [2402, 2402, 2453, 2453, 3752], [3754, 3754, 3811, 3861, 5262]]}
{"id": "tt2SWV", "name": "BV Noise", "author": "bela333", "description": "This is a cool looking noise", "tags": ["noise", "gradient", "hash", "purple"], "likes": 2, "viewed": 110, "published": "Public", "date": "1567189376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash function by David Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define CYCLE 1.\n#define RESOLUTION 128.\n#define THRESHOLD .5\n\nfloat ease(float t){\n\t//return t<.5 ? 2.*t*t : -1.+(4.-2.*t)*t;\n    return t<.5 ? 8.*t*t*t*t : 1.-8.*(--t)*t*t*t;\n    //return 1.-(--t)*t*t*t;\n    //return t;\n}\n\nfloat complicatedNoise(float t, vec2 uv){\n\tfloat f1 = float(hash12(uv+floor(t)*10.) < THRESHOLD);\n    float f2 = float(hash12(uv+floor(t+1.)*10.) < THRESHOLD);\n    float f3 = float(hash12(uv+floor(t+2.)*10.) < THRESHOLD);\n    return ((f1+f2)*.5+f3)*.5;\n}\n\nfloat getColor(vec2 uv){\n    float tP = iTime/CYCLE+hash12(uv*10.);\n    float tN = (iTime/CYCLE+1.)+hash12(uv*10.);\n    // Output to screen\n\tfloat prev = complicatedNoise(tP, uv);\n    float next = complicatedNoise(tN, uv);\n    return mix(prev, next, ease(fract(tP)));\n    //return vec4(prev);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= RESOLUTION;\n    float dist = 1./16.;\n    vec2 movement = vec2(iTime)*vec2(1., 1.)*.1;\n    //vec2 movement = vec2(0.);\n    float background = getColor(floor(uv+movement));\n    float foreground = getColor(floor(uv*dist+movement));\n\t\n    //vec4 fgColor = vec4(0.63, 0.13, 0.94, 1.0);\n    vec4 fgColor = vec4(.0);\n    vec4 bgColor = vec4(0.63, 0.13, 0.94, 1.0);\n    \n    fragColor = mix(fgColor, bgColor, background*foreground);\n    \n    //fragColor = foreground;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2SWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 95, 95, 212], [277, 277, 297, 340, 437], [439, 439, 480, 480, 693], [695, 695, 719, 719, 989], [991, 991, 1048, 1048, 1598]]}
{"id": "tt2SzG", "name": "Noise RayMarcher", "author": "Dude", "description": "RayMarch over Noise floor", "tags": ["noiseraymarch"], "likes": 1, "viewed": 121, "published": "Public", "date": "1566373582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXIMUM_STEPS 1290\n#define DISTANCE_THRESHOLD .01\n#define FAR_CLIP 90.0\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opDisplace( vec3 p, float noiseColor )\n{\n    vec4 plo = vec4(.0,.10,.0,.2);\n    float d1 = sdPlane(p, plo);\n    float d2 = noiseColor;\n    return d1+d2;\n}\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat nearestSurface(vec3 rp, float nclr) {\n    \n    float msd = 99999.;\n    msd = min(msd, opDisplace(rp, nclr));\n\n    return msd;\n}\n\n/* RAY MARCHING */\n\n//march a single ray\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        rp *= .5f;\n        float f = noise(vec2(rp.x, rp.z));\n\t\tvec2 uv = vec2(rp.x*0.5f, rp.z*0.5f);\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n        \n        float hills = 0.36;\n        \n        \n        f  = 0.5000*noise( uv ); uv = m*uv;\n        f += 0.2500*noise( uv ); uv = m*uv;\n        f += 0.1250*noise( uv ); uv = m*uv;\n        //f += 0.0625*noise( uv ); uv = m*uv;\n        f = 0.3 + hills*f;\n        \n        float ns = nearestSurface(rp, f);\n        d += ns;\n        \n        if (abs(ns) < DISTANCE_THRESHOLD) {\n            float clf = 1.-f * 3.;\n            \n            if(clf > 0.3f){\n            \tpc = vec4(clf, clf, clf, 1.)*2.7;\n            }else{\n            \tpc = vec4(clf*0.3, clf*0.4, clf*0.2, 1)*5.;\n            }\n            pc *= d*0.06;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            pc = vec4(0.1, 0.3, 0.9, 1.);\n            pc *= 1.-smoothstep(0.02, 0.33, rd.y) + 0.8;\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 1.5));\n    vec3 ro = vec3(0, 0, -1.+float(iFrame)/15.);\n\n    rY(ro, -cos(iTime) * .0006);\n    rY(rd, sin(iTime) * .02);\n    rX(rd, .5);\n    \n\tfragColor = marchRay(ro, rd);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2SzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 139, 139, 277], [279, 279, 305, 305, 703], [706, 706, 739, 765, 796], [798, 798, 844, 844, 958], [960, 977, 1009, 1009, 1129], [1131, 1131, 1163, 1163, 1284], [1286, 1286, 1318, 1318, 1438], [1440, 1440, 1483, 1483, 1573], [1595, 1616, 1649, 1649, 2817], [2819, 2819, 2874, 2874, 3214]]}
{"id": "tt2XDV", "name": "organic texture", "author": "Eseris", "description": "texture", "tags": ["fbm", "gradientnoise"], "likes": 16, "viewed": 590, "published": "Public API", "date": "1567266404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pow(x,n) pow(abs(x),n)\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// by iq - https://www.shadertoy.com/view/XdXGW8\nfloat noise(in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat heightmap(vec2 p) {\n    float h = 0.;\n    vec2 q = 4. * p + noise(-4. * p + iTime * vec2(-.07, .03));\n    vec2 r = 7. * p + vec2(37., 59.) + noise(5. * p + iTime * vec2(.08, .03));\n    vec2 s = 3. * p + noise(5. * p + iTime * vec2(.1, .05) + vec2(13., 37.));\n    float smoothAbs = .2;\n    h += 1. * noise(s);\n    h += .9 * pow(noise(q), 1. + smoothAbs);\n    h += .7 * pow(noise(r), 1. + smoothAbs);\n    \n    h = .65 * h + .33;\n    return h;\n}\n\nvec3 calcNormal(vec2 p) {\n    vec2 e = vec2(1e-3, 0);\n    return normalize(vec3(\n        heightmap(p - e.xy) - heightmap(p + e.xy),\n        heightmap(p - e.yx) - heightmap(p + e.yx),\n        -2. * e.x));\n}\n\nvec3 getColor(float x) {\n    vec3 a = vec3(.1, .0, .03);\n    vec3 b = vec3(1., .05, .07);\n    vec3 c = vec3(.9, .2, .3);\n    return mix(a, mix(b, c, smoothstep(.4, .9, x)), smoothstep(.0, .9, x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    float h = heightmap(uv);\n    vec3 v = vec3(h);\n    v.yz *= 3.;\n    vec3 nor = calcNormal(uv);\n    nor.xy *= .4;\n    nor = normalize(nor);\n\n    vec3 mat = getColor(h);\n    mat = clamp(mat, 0., 1.);\n    vec3 ld = normalize(vec3(1,-1.,1));\n    vec3 ha = normalize(ld - vec3(0.,0,-1));\n    \n    vec3 col = vec3(0);\n    col += mat * .8;\n    col += .2 * mat * pow(max(dot(normalize(nor + vec3(.0,0,0)), -ld), 0.), 3.);\n    col += .3 * h * pow(dot(normalize(nor + vec3(.0,0,0)), ha), 20.);\n    \n    //if(h > 1.) col = vec3(0,1,0);\n    //if(h < 0.) col = vec3(0,0,1);\n    \n\t//col = mix(col, getColor(fragCoord.x/iResolution.x), step(abs(uv.y), .1));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2XDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 93, 93, 231], [233, 282, 306, 306, 704], [707, 707, 732, 732, 1155], [1157, 1157, 1182, 1182, 1362], [1364, 1364, 1388, 1388, 1562], [1565, 1565, 1622, 1622, 2341]]}
{"id": "tt2XRw", "name": "alien flower blob", "author": "anclin", "description": "alien flower blob", "tags": ["alienflowerblob"], "likes": 3, "viewed": 71, "published": "Public", "date": "1565459228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define S01(t) sin(t) * .5 + .5\n#define C01(t) cos(t) * .5 + .5\n#define S(a,b,t)  mix(a, b, S01(t))\n#define C(a,b,t)  mix(a, b, C01(t))\n#define BPM 130.\n#define BPS BPM/60.\n\nfloat lineDF(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float t = dot(ap,ab)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec2 c = a + t*ab;\n    return length(p-c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float scale = 15.;\n    uv *= scale;\n    float t = iTime*BPS;\n    \n    //uv = abs(uv);\n    \n    float t2 = t / 32.;\n    uv += vec2(cos(t2*PI2)*1., sin(t2*PI2))*1. * sin(t2*PI2*3.)*2.;\n    \n    float c = 9999.;\n    vec2 prev = vec2(0);\n    \n    float a0 = atan(uv.x,uv.y)/PI2+.5;\n    float l0 = length(uv);\n    \n    float t1 = t / 8.;\n    float count = 20.;\n    float inc = PI2/count;\n    float lw = mix(.05,.15,sin(l0*.05*PI2*15.)*.5+.5) * (l0*.5);\n    for (float a = 0.; a < count+.5; a += inc){\n        float a1 = a+PI/2. + t1;\n        vec2 p = vec2(cos(a1),sin(a1)) * sin(a1*6.)*5.;\n        if(a > 0.){\n            c = min(c, lineDF(prev,p,uv) + lw);\n        }\n        c = min(c,length(p-uv)-.2);\n        prev = p;\n    }\n    \n    float w = (7./iResolution.y);\n    float l = .25;\n    c = smoothstep(l+w,l-w,c);\n    \n    c = pow(c,.125);\n    \n    \n    vec3 col = vec3(c);\n\n    // Output to screen\n    uv /= scale;\n    //col = mix(col, vec3(1,0,0), step(abs(uv.y),.5/iResolution.y)*.1); // hori\n    //col = mix(col, vec3(0,1,0), step(abs(uv.x),.5/iResolution.y)*.1); // vert\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2XRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 262, 262, 410], [413, 413, 470, 470, 1645]]}
{"id": "tt2XWh", "name": "Hello Voronoi 2", "author": "2YY", "description": "more typical voronoi looks", "tags": ["voronoi"], "likes": 2, "viewed": 70, "published": "Public", "date": "1565786436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * https://thebookofshaders.com/12/\n */\nvec2 random2(vec2 p) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Some variables\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    float gridLength = 3. + sin(iTime * .2) * 10. + 1.;\n    vec2 gridCoords = floor(uv * gridLength);\n    vec2 gridFrag = fract(uv * gridLength);\n\n    // Calc min distance to random point by grid\n    float minDist = 1.;\n    for(int x=-1; x<=1; x++) {\n        for(int y=-1; y<=1; y++) {\n        \tvec2 neighborGridCoords = vec2(float(x), float(y));\n            vec2 randomPoint = random2(neighborGridCoords + gridCoords);\n            randomPoint = sin(iTime * randomPoint) * 0.5 + .5;\n            minDist = min(minDist, length(neighborGridCoords + randomPoint - gridFrag));\n        }\n    }\n\n    // Apply Post Effect\n    vec3 color = vec3(minDist);\n    //color += step(.5, sin((20. * (uv.y * gridLength * 2.) + 10.) * color)) * (.2 + (sin(iTime * 2.) * .1 + .1));\n    color.r += uv.x * .1 + (sin(iTime) * .5 + .5) * .2;\n    color.g += uv.x * .1;\n    color.b += (1.-uv.y) * .1;\n    \n    // Apply Post Effect (Part 2)\n    color += step(.5, color) * uv.x * .1;\n    \n    // Apply Post Effect (Part 3);\n    color.r -= uv.x * .06;\n    color.g -= (1.0-uv.x) * .03;\n    color.b += (2.0-uv.y) * .1;\n\n    // Draw\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2XWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 66, 66, 156], [158, 158, 215, 237, 1454]]}
{"id": "tt2XWw", "name": "Happy dog", "author": "GreenChicken", "description": "A verry happy dog bouncing in the rainbow world.\nUsing sdf, booleans, palette colors and a lot of fun\nSome shadow for incredible beauty", "tags": ["raymarching", "sdf", "colors", "palette"], "likes": 2, "viewed": 356, "published": "Public API", "date": "1566150120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HAPPY DOG\n// by Green Chicken\n// -----------------\n// So much fun with sdf, boolean, palette color\n// first shadow. Hope to see what i'll do with color materials\n\n// iq\nfloat impulse(float k, float x)\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n// iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// iq\nfloat uSDF(float s1, float s2)\n{\n    return min(s1, s2);\n}\n\n// iq\nfloat dSDF(float s1, float s2)\n{\n    return max(s1, -s2);\n}\n\n// iq\nfloat suSDF( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n// iq\nfloat sdPlane(vec3 pos, float offset)\n{\n    return pos.y+offset;\n}\n\n// iq\nfloat sdSphere(vec3 pos, float r)\n{\n    \n    return length(pos)-r;\n}\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// iq ? yes\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 tp = pos;\n    float t = 10000.0;\n    \n    // body\n    float bodyY = -1.0;\n    bodyY += impulse(5.0, fract(iTime)) * .5;\n    tp = pos + vec3(0.0, bodyY, 0.0);\n    t = sdCapsule(tp, vec3(1., .0, .0), vec3(0.0), 1.0);\n    \n    // sexy legs\n    float legY = 1.0;\n    tp = pos + vec3(0.5, legY, 1.0);\n    t = suSDF(t, sdRoundCone(tp, .1, .5, 1.), .5);\n    tp = pos + vec3(-1.5, legY, 1.0);\n    t = suSDF(t, sdRoundCone(tp, .1, .5, 1.), .5);\n    tp = pos + vec3(0.5, legY, -1.0);\n    t = suSDF(t, sdRoundCone(tp, .1, .5, 1.), .5);\n    tp = pos + vec3(-1.5, legY, -1.0);\n    t = suSDF(t, sdRoundCone(tp, .1, .5, 1.), .5);\n    \n    // la tete de ta mere\n    tp = pos + vec3(1.5, bodyY+-.5, 0.0);\n    t = suSDF(t, sdSphere(tp, 1.5), .2);\n    tp = pos + vec3(1.5, bodyY+-2.0, 0.5);\n    t = suSDF(t, sdRoundCone(tp, .3, .1, 1.), .5);\n    tp = pos + vec3(1.5, bodyY+-2.0, -0.5);\n    t = suSDF(t, sdRoundCone(tp, .3, .1, 1.), .5);\n    tp = pos + vec3(2.5, bodyY+-.2, 0.0);\n    t = dSDF(t, sdSphere(tp, .6));\n    tp = pos + vec3(2.8, bodyY+-.5, 0.0);\n    t = uSDF(t, sdSphere(tp, .5));\n    // eyes\n    tp = pos + vec3(2.7, bodyY+-1.0, .5);\n    t = uSDF(t, sdSphere(tp, .25));\n    tp = pos + vec3(2.9, bodyY+-1.0, .5);\n    t = dSDF(t, sdSphere(tp, .1));\n    tp = pos + vec3(2.7, bodyY+-1.0, -.5);\n    t = uSDF(t, sdSphere(tp, .25));\n    tp = pos + vec3(2.9, bodyY+-1.0, -.5);\n    t = dSDF(t, sdSphere(tp, .1));\n    \n    // balls of steel\n    tp = pos + vec3(-2.0, bodyY+.5, 0.15);\n    t = uSDF(t, sdSphere(tp, .2));\n    tp = pos + vec3(-2.0, bodyY+.5, -0.15);\n    t = uSDF(t, sdSphere(tp, .2));\n    tp = pos + vec3(-2., bodyY+.5, 0.0);\n    t = uSDF(t, sdCapsule(tp, vec3(0.0, -.5, sin(iTime*10.)*.2), vec3(.0), .15));\n    \n    t = uSDF(t, sdPlane(pos, 1.0));\n    \n    return t;\n}\n\nfloat CastRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t;\n    \n    for(int i=0; i<128; i++)\n    {\n        float res = map(rayOrigin + rayDir * t);\n        \n        if(res < (0.0001*t))\n        {\n            return t;\n        }\n        \n        t += res;\n    }\n    \n    return -1.0;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(   e.xyy*map(  pos+e.xyy   )   +\n                        e.yyx*map(  pos+e.yyx   )   +\n                        e.yxy*map(  pos+e.yxy   )   +\n                        e.xxx*map(  pos+e.xxx   ));\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    float t = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n        vec3 pos=ro+rd*t;\n        vec3 N = calcNormal(pos);\n        vec3 L = vec3(-1.0, 1.0, 1.0);\n        \n        float light = clamp(dot(N, L), 0.0, 1.0);\n        vec3 spec = vec3(pow(clamp(dot(N, L), 0.0, 1.0),8.0));\n        float fog = 0.2 * t; // is it ?\n        \n        float shad = shadow(pos, L, 0.02, 2.5);\n        \n        col = palette(\n            light * fog, \n            vec3(.5),\n            vec3(.5),\n            vec3(.12),\n            vec3(.5, .2, .9));\n        \n        col = mix(col*.33, col, shad);\n    }\n    \n    return col;\n}\n\nvec3 CameraViewDir(vec2 uv, vec3 camPos, vec3 camTar)\n{\n    vec3 viewDir;\n    vec3 forward = normalize(camTar - camPos);\n    vec3 right = normalize(cross(vec3(.0, -1., .0), forward));\n    vec3 up = normalize(cross(right, forward));\n    float fPersp = 1.0;\n    \n    viewDir = normalize(uv.x * right + uv.y * up + fPersp * forward);\n    \n    return viewDir;\n}\n\nvec2 NormalizeScreen(vec2 st)\n{\n    vec2 uv = 2. * st/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(.0);\n    float time = iTime*.5;\n    vec3 camPos = vec3(sin(time), .2+sin(iTime)*.2, cos(time))*5.0;\n    vec3 camTarget = vec3(0.0, 0.5, 0.0);\n    vec2 uv = NormalizeScreen(fragCoord);\n    \n    vec3 viewDir = CameraViewDir(uv, camPos, camTarget);\n    \n    col = render(camPos, viewDir); \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2XWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 172, 205, 205, 251], [253, 259, 331, 331, 374], [376, 382, 414, 414, 440], [442, 448, 480, 480, 507], [509, 515, 559, 559, 658], [661, 667, 706, 706, 733], [735, 741, 776, 776, 809], [811, 817, 869, 869, 996], [998, 1010, 1074, 1074, 1352], [1354, 1354, 1375, 1375, 3149], [3151, 3151, 3195, 3195, 3434], [3436, 3436, 3466, 3466, 3730], [3732, 3732, 3796, 3796, 3955], [3957, 3957, 3988, 3988, 4676], [4678, 4678, 4733, 4733, 5035], [5037, 5037, 5068, 5068, 5170], [5172, 5172, 5227, 5227, 5573]]}
{"id": "ttBSDz", "name": "color-effect-0", "author": "lilieming", "description": "jsut coding", "tags": ["colormath"], "likes": 2, "viewed": 31, "published": "Public", "date": "1565577275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 color = vec3(0.5, 0.5, 0.5);\n\n\n    color.r = 0.5 + 0.5 * sin(20. * uv.x + 20.*iTime);\n \n\n    // Output to screen\n    fragColor = vec4(sqrt(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 407]]}
{"id": "ttBSRc", "name": "mandelbulb--derivate--mod2", "author": "jorge2017a1", "description": "solo cambios de color ", "tags": ["mandelbulbderivatemod2"], "likes": 26, "viewed": 521, "published": "Public", "date": "1566568389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n#define ZERO (min(iFrame,0))\n\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    return 0.35*log(m)*sqrt(m)/dz;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.02,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.01)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = intersect( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.5)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\t/*col = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        */\n        \n        col = mix( col, vec3(0.030,0.20,0.30), clamp(tra.y,0.01,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.040,0.10,0.02), clamp(pow(tra.w,6.0),0.01,1.0) );\n        \n        col *= 0.6;\n\t\t//col = vec3(0.1);\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.01,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.01,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.002*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient\n        \t lin += 4.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n        col += spe1*15.0;\n        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occ)*(0.03+0.97*pow(fac,5.0))*smoothstep(0.0,0.1,ref.y )*softshadow( pos+0.01*nor, ref, 2.0 );\n        //col = vec3(occ*occ);\n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    // camera\n\tfloat di = 1.4+0.1*cos(.29*time);\n\tvec3  ro = di * vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    // render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBSRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[349, 542, 595, 595, 802], [835, 835, 878, 878, 2154], [2156, 2156, 2229, 2229, 2787], [2789, 2789, 2845, 2845, 3119], [3121, 3121, 3178, 3178, 3409], [3515, 3515, 3554, 3568, 6076], [6082, 6082, 6139, 6139, 6900]]}
{"id": "ttBSRt", "name": "Planet_00", "author": "VB", "description": "Based on https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html \nand Kalil set: https://www.shadertoy.com/view/XlfGRj", "tags": ["kaliset", "scattering", "hdr", "atmosphere"], "likes": 6, "viewed": 701, "published": "Public API", "date": "1566771681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535f;\n\n// ------ EARTH\nconst float EARTH_R = 1.0f;\nconst float ATM_R = EARTH_R * 1.0157f; // Karman line: 1.57% of Earth's radius\nconst float H0 = (ATM_R - EARTH_R) * 0.25f;\nconst float SCATTERING = 2.f;\nconst float SUN_INTENSITY = 100.0f;\nconst float EARTH_AMBIENT = 0.01f;\nconst vec3 EARTH_COLOR = 0.04f * vec3(0.2f, 0.9f, 0.2f);\nconst float N_STEPS_1 = 32.f;\nconst float N_STEPS_2 = 8.f;\nconst vec3 Kr = vec3(0.18f, 0.49f, 0.66f); // http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n\n// ------ SUN\nvec3 sunDir()\n{\n\treturn normalize(vec3(0.f, 1.f, 6.f));\n}\n\n// ------ CAMERA\nconst float FOCAL = 2.0;\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n// theta [0, pi]\n// phi [0, 2pi]\nvec3 sph(float theta, float phi, float r)\n{\n    return r * vec3(\n        sin(phi)*cos(theta),\n        cos(phi),\n        sin(phi)*sin(theta)  \n    );\n}\n\nvoid getRay(in vec2 fragCoord, out vec3 ro, out vec3 rd, out float fade)\n{\n    // misc\n    float r = EARTH_R;\n    vec3 top = vec3(0, r * 1.0001f, 0);\n\n    // time / segment\n    const float SEGMENT_DURATION = 5.5;\n    float t = iTime;\n    float segment = trunc(t / SEGMENT_DURATION);\n    float segT = mod(t, SEGMENT_DURATION) / SEGMENT_DURATION;\n    \n    // fade\n    float fadePercent = 0.12;\n    fade = smoothstep(0.0, fadePercent, segT) * (1.0 - smoothstep(1.0 - fadePercent, 1.0, segT));\n    if (t/SEGMENT_DURATION<0.5)\n        fade = 1.0;\n    \n    //     \n    float s = (segment+10.0)/202.0;\n    float rand1 = clamp(texture(iChannel0, vec2(s, s)).x, 0.0, 1.0);\n    float rand2 = clamp(texture(iChannel0, vec2(s, rand1)).x, 0.0, 1.0);\n    float rand3 = clamp(texture(iChannel0, vec2(rand1+s, rand2)).x, 0.0, 1.0);\n    \n    // source\n    float thetaCoef = rand1;\n    float thetaSign = sign(rand2-0.5);\n    float theta = -PI*0.5 + thetaSign * mix(0.4, 1.1, thetaCoef);\n    float phi = PI*0.5 + PI*0.27 * mix(-1.0, 1.0, rand3); \n    \n    float maxH = mix(r*6.0, r*3.0, thetaCoef); \n    float h = mix(r*1.1, maxH, rand2);\n    \n    vec3 start = vec3(theta, phi, h);    \n    \n    vec3 end = start;\n    end.x += thetaSign * PI * 0.35 / (1.0+thetaCoef);\n    \n    float maxZChange = r*2.5;\n    float minZ = r * 1.0001f;\n    float tgtZ = max(start.z * 0.3, minZ);\n    float change = min(start.z - tgtZ, maxZChange);\n    end.z = start.z - change;\n    \n    vec3 cur = mix(start, end, segT);       \n    ro = sph(cur.x, cur.y, cur.z);\n    \n    // target\n    vec3 dirTop = normalize(top - ro);\n    vec3 dirSun = sunDir();\n    float coef = length(ro - top) / r;\n    vec3 dir = mix(dirSun, dirTop, 0.4);\n    vec3 tgt = ro + dir * r;\n    \n    // final ray\n    mat3 cam = setCamera(ro, tgt, 0.0);    \n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    rd = cam * normalize(vec3(p.xy, FOCAL));        \n}\n\n// --- KALI SET\nconst int KALI_N_ITERATIONS = 20;\nconst int KALI_N_LAYERS = 6;\n\nconst float KALI_C = 0.53;\nconst float KALI_EVOLVE_SPEED = 0.004;\nconst float KALI_POW = 11.0;\nconst float KALI_LUM = 28.0;\n\nconst vec3 KALI_ORIGIN = vec3(1.578, 9.3, 3.8);\nconst vec3 KALI_COLOR_TONE = vec3(1.8, 1.4, 0.9);\n\nvec3 kali(vec3 o, vec3 d)\n{\n\tfloat avg = 0.0; \n \tvec3 p = o + d + KALI_EVOLVE_SPEED * (iTime);\n\tvec3 p0 = p;\n\tfloat l0 = length(p);\n\tfor (int k = 0; k < KALI_N_LAYERS; k++)\n\t{\n\t\tp = p0 + float(k) * d;\n\t\tfor (int i = 0; i < KALI_N_ITERATIONS; i++)\n\t\t{\n\t\t\tp = abs(p) / dot(p,p) - KALI_C;\n\t\t\tfloat l1 = length(p);\n\t\t\tavg += abs(l1-l0);\n\t\t\tl0 = l1;\n\t\t}\n\t}\n\tfloat v = avg * (1.0 / float(KALI_N_LAYERS * KALI_N_ITERATIONS));    \n    v = smoothstep(0.0, 2.0, v);\n    \n    vec3 hdr = vec3(v);    \n    hdr = pow(hdr, vec3(KALI_POW) * KALI_COLOR_TONE);    \n    return hdr * KALI_LUM;\n}\n\n// ------ SDF TOOLS\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nvec4 intersectSphere_raymarch(vec3 o, vec3 l, float r)\n{\n\tint max_steps = 200;\n\tfloat max_delta = r * 1e3f;\n\tfloat min_delta = r / 1e5f;\n\tfloat end_delta = r / 1e4f;\n\n\tvec4 NO_HIT = vec4(0.0f, 0.0f, 0.0f, -1.0f);\n\tvec3 rd = l;\n\tvec3 p = o;\n\n\tint i;\n\tfor (i = 0; i < max_steps; i++)\n\t{\n\t\tfloat d = sdSphere(p, r);\n\t\tif (d > max_delta)\n\t\t\treturn NO_HIT;\n\t\tif (d < end_delta)\n\t\t\tbreak;\n\t\tp += rd * max(d, min_delta);\n\t}\n\n\tif (i == max_steps)\n\t\treturn NO_HIT;\n\telse\n\t\treturn vec4(p, 1.0f);\n}\n\n// ------ SPHERE RAY INTERSECTION(S)\n// intersection with a sphere centered at zero\n// o: ray origin\n// l: ray direction, must be normalized\n// r: sphere radius\n// result.x : 1st intersection distance\n// result.y : 2nd intersection distance\n// result.z : nb intersections\nvec3 intersectSphere(vec3 o, vec3 l, float r)\n{\n\tvec3 res = vec3(0.0f);\n\tfloat l_dot_o = dot(l, o);\n\tfloat lo = length(o);\n\tfloat n = l_dot_o*l_dot_o - lo*lo + r*r;\n\n\t// 2 potential intersections\n\tif (n > 0.0f)\n\t{\n\t\tfloat sqn = sqrt(n);\n\t\tvec2 v = vec2(-l_dot_o + sqn, -l_dot_o - sqn); // v.x >= v.y, because sqrt(n) >= 0\n\n\t\tif (v.x >= 0.0)\n\t\t{\n\t\t\tif (v.y >= 0.0)\n\t\t\t{\n\t\t\t\tres.z = 2.0f;\n\t\t\t\tres.x = v.y;\n\t\t\t\tres.y = v.x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres.z = 1.0f;\n\t\t\t\tres.x = v.x;\n\t\t\t}\n\t\t}\n\t}\n\t// 1 intersection, this means the ray grazes the sphere shell we consider we missed the in this case\n\t//else if (n == 0.0f)\n\t//{\n\t//\tres.z = 1.0f;\n\t//\tres.x = -l_dot_o;\n\t//}\n\treturn res;\n}\n\n// ------ ATMOSPHERE PATH\n// finds the two intersection points between ray and earth / atmosphere shells\nint getAtmPath(vec3 a, vec3 b, out vec3 oA, out vec3 oB, float rAtmo, float rPlanet)\n{\n\tvec3 v = b - a;\n\tfloat l = length(v);\n\tvec3 rd = normalize(v);\n\tvec3 itAtm = intersectSphere(a, rd, rAtmo);\n\tvec3 itEarth = intersectSphere(a, rd, rPlanet);\n\n\t// inside atmosphere\n\tif (length(a) <= ATM_R)\n\t{\n\t\toA = a;\n\t\toB = b;\n\t\tif ((itEarth.z > 0.0) && (itEarth.x <= l))\n\t\t\toB = a + rd * itEarth.x;\n\t\telse if ((itAtm.z > 0.0) && (itAtm.x <= l))\n\t\t\toB = a + rd * itAtm.x;\n\t}\n\t// outside atmosphere\n\telse\n\t{\n\t\tif (itAtm.z <= 0.0)\n\t\t\treturn 0;\n\t\toA = a + rd * itAtm.x;\n\t\toB = b;\n\t\tif (itEarth.z > 0.0 && itEarth.x <= l)\n\t\t\toB = a + rd * itEarth.x;\n\t\telse if ((itAtm.z > 0.0) && (itAtm.x <= l))\n\t\t\toB = a + rd * itAtm.y;\n\t}\n\treturn 1;\n}\n\n// ------ PHASE FUNCTION\nfloat phaseFunction(float cos_theta, float g)\n{\n\tfloat a = (3.0f * (1.0f - g*g)) / (2.0f * (2.0f + g*g));\n\tfloat b = (1.0f + cos_theta*cos_theta) / pow(1.0f + g*g - 2.0f * g * cos_theta, 3.0f / 2.0f);\n\treturn a * b;\n}\n\n// ------ OPTICAL DEPTH (light scattered along AB)\nfloat exp_h_h0(vec3 p)\n{\n\tfloat h = length(p) - EARTH_R;\n//\tASSERT(h >= -0.001f);\n\tfloat res = exp(-h / H0);\n\treturn res;\n}\n\nfloat opticalDepth(vec3 pA, vec3 pB)\n{\n\t// integrate optical depth between a & b, using trapezoidal method\n\tfloat nSteps = N_STEPS_2;\n\tfloat res = 0.0f;\n\tvec3 dV = (pB - pA) / nSteps;\n\tfloat dL = length(dV);\n\tfor (float i = 1.0f; i <= nSteps; i++)\n\t{\n\t\tvec3 p1 = pA + dV * (i - 1.0f);\n\t\tvec3 p2 = pA + dV * (i);\n\t\tres += dL * 0.5f * (exp_h_h0(p1) + exp_h_h0(p2));\n\t}\n\treturn res;\n}\n\n// ------ ATMOSPHERE\n\nvec3 outScattering(vec3 pA, vec3 pB, vec3 LColor, vec3 absorption)\n{\n\t// light scattered away along AB\n\treturn (4.0f * PI) * SCATTERING * absorption * opticalDepth(pA, pB);\n}\n\nvec3 inScatteringInner(vec3 p, vec3 sd, vec3 LColor, vec3 absorption, vec3 ro)\n{\n\tvec3 n = normalize(p);\n\n\t// no scattering when in shadow\n\tfloat dotnsd = dot(n, sd);\n\tif (dotnsd < 0.f)\n\t\treturn vec3(0.0);\n\n\t// move the start point a bit inside the atmosphere\n\t// this is to avoid points on atm. boundary for which getAB may return 0\n\tvec3 pStart;\n\tpStart = p - n * 0.0000001f;\n\n\t// ---- p to cam\n\tvec3 cpA, cpB;\n\tint nIt2 = getAtmPath(pStart, ro, cpA, cpB, ATM_R, EARTH_R);\n\tvec3 osCam = vec3(0.0);\n\tif (nIt2 > 0)\n\t\tosCam = outScattering(cpA, cpB, LColor, absorption);\n\n\t// ---- p to sun\n\tvec3 spA, spB;\n\tint nIt = getAtmPath(pStart, pStart + sd * EARTH_R * 1e2f, spA, spB, ATM_R, EARTH_R);\n\tvec3 osSun = vec3(0.0);\n\tif (nIt > 0)\n\t\tosSun = outScattering(spA, spB, LColor, absorption);\n\n\treturn vec3(exp_h_h0(pStart)) *exp(-osSun - osCam);\n}\n\nvec3 inScattering(vec3 ro, vec3 pA, vec3 pB, vec3 LColor, vec3 absorption, float g)\n{\n\tvec3 sd = sunDir();\n\n\t// phase function\n\tvec3 toCam = normalize(pA - pB);\n\tfloat cos_theta = dot(sd, toCam);\n\tfloat phase = phaseFunction(cos_theta, g);\n\n\t// integrate in-scattering between pA and pB\n\tfloat nSteps = N_STEPS_1;\n\tvec3 dV = (pB - pA) / nSteps;\n\tfloat dL = length(dV);\n\tvec3 res = vec3(0.0);\n\tvec3 v1 = inScatteringInner(pA, sd, LColor, absorption, ro);\n\tfor (float i = 1.0; i <= nSteps; i++)\n\t{\n\t\tvec3 v2 = inScatteringInner(pA + dV * i, sd, LColor, absorption, ro);\n\t\tres += dL * 0.5f * (v1 + v2);\n\t\tv1 = v2;\n\t}\n\n\t// final formula\n\treturn SUN_INTENSITY * LColor * phase * absorption * res;\n}\n\nvec4 earthRay(vec3 ro, vec3 rd)\n{\n\tvec4 res = intersectSphere_raymarch(ro, rd, EARTH_R);\n\tif (res.w <= 0.0)\n\t\treturn vec4(0.0);\n\n\t// diffuse\n\tvec3 p = vec3(res.x, res.y, res.z);\n\tvec3 n = normalize(p);\n\tfloat diff = SUN_INTENSITY * max(dot(n, sunDir()), 0.0f);\n\n\t// gi\n\tfloat amb = SUN_INTENSITY * EARTH_AMBIENT;\n\n\treturn vec4(EARTH_COLOR * (diff + amb), 1.0);\n}\n\nvec4 atmRay(vec3 ro, vec3 rd)\n{\n\tvec3 atmCol = vec3(0.f);\n\n\t// optional fake sun using phase\n\tvec4 res = intersectSphere_raymarch(ro, rd, EARTH_R);\n\tif (res.w <= 0.0f)\n\t{\n\t\tvec3 toCam = -rd; // normalize(pA - pB);\n\t\tfloat cos_theta = dot(sunDir(), toCam);\n\t\tfloat phase = phaseFunction(cos_theta, -0.99f);\n\t\tatmCol += vec3(1.5, 1.3, 0.9) * vec3(0.01f) * phase;\n\t}\n\n\t//\n\tvec3 pA, pB;\n\tint foundPath = getAtmPath(ro, ro + rd * EARTH_R * 1e2f, pA, pB, ATM_R, EARTH_R);\n\tif (foundPath == 0)\n\t\treturn vec4(atmCol, 0.0);\n\n\t//\n\tvec3 SUN_COLOR = vec3(1.0);\n\n\t// rayleigh\n\tvec3 rayleigh = inScattering(ro, pA, pB, SUN_COLOR, Kr, 0.0f);\n\tatmCol += rayleigh;\n\n\t//\n\treturn vec4(atmCol, 1.0);\n}\n\n// ------ POST PROCESSING\nconst float EXPOSURE = 0.95f;\nconst vec3 CONTRAST = vec3(2.1);\n\nvec3 postProcess(vec3 hdr)\n{\n    vec3 ldr = hdr * EXPOSURE;\n    ldr = ldr / (vec3(1.0) + ldr);\n\tvec3 gamma = pow(ldr, CONTRAST / vec3(2.2));\n    return gamma;\n}\n\n// --- MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get ray\n    float fade;\n\tvec3 ro,rd;\n    getRay(fragCoord, ro, rd, fade);\n        \n    // earth + atmosphere rays\n\tvec4 earth = earthRay(ro, rd);\n\tvec4 atm = atmRay(ro, rd);\n\n   \t// compute kali\n\tvec3 kaliC = vec3(0);\n    \n    if (earth.w < 0.01) \n        kaliC = kali(KALI_ORIGIN, rd);\n\n    vec3 hdr = mix(kaliC.rgb, earth.rgb, earth.w) + atm.rgb;\n    \n    //\n\tfragColor.rgb = fade * postProcess(hdr);\n}\n\n/*\nvec4 kali(vec2 p)\n{\n    vec4 kali = texture(iChannel0, p);\n    kali = pow(kali, vec4(2.2)) * 32.0;\n    return vec4(kali.rgb * 1.1, 1.0);\n}\n\nvoid mainImage(OUT(vec4, fragColor), IN(vec2, fragCoord)) \n{\n    // get ray\n\tvec3 ro, rd;\n\tgetRay(vec2(fragCoord.x, fragCoord.y), ro, rd);\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    \n    // earth + atmosphere rays\n\tvec4 earth = earthRay(ro, rd);\n\tvec4 atm = atmRay(ro, rd);\n\n    float atmIntensity = 0.0;\n        \n    // combine with starfield\n \tvec3 c = earth.rgb + atm.rgb;\n    if (earth.w < 0.001)\n    {\n        atmIntensity = (atm.r + atm.g + atm.b) / 3.0;\n        float m = smoothstep(0.5, 0.6, atmIntensity);        \n       \tc += kali(p).rgb * vec3(1.0-m);\n    }\n\n  \tc += kali(p).rgb;\n\n\tc *= EXPOSURE;\n\tc = c / (vec3(1.0f) + c);\n\n\tc = pow(c, vec3(CONTRAST / 2.2f));\n\n   // c = vec3(atmIntensity);\n    \n\tfragColor = vec4(c, 1.f);\n}\n\n*/", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 555, 570, 570, 612], [614, 657, 707, 707, 880], [883, 916, 959, 959, 1066], [1068, 1068, 1142, 1154, 2967], [2969, 3273, 3300, 3300, 3848], [3850, 3870, 3903, 3903, 3928], [3930, 3930, 3986, 3986, 4417], [4419, 4691, 4738, 4738, 5366], [5368, 5473, 5559, 5559, 6195], [6197, 6222, 6269, 6269, 6439], [6441, 6492, 6516, 6516, 6615], [6617, 6617, 6655, 6723, 6998], [7000, 7022, 7090, 7124, 7196], [7198, 7198, 7278, 7278, 8039], [8041, 8041, 8126, 8126, 8734], [8736, 8736, 8769, 8769, 9098], [9100, 9100, 9131, 9131, 9781], [9783, 9873, 9901, 9901, 10033], [10035, 10047, 10104, 10119, 10516]]}
{"id": "ttBXRG", "name": "Smooth Staircase", "author": "iq", "description": "Using gain() to create a smooth staircase and reverse smooth staircase", "tags": ["2d", "graph"], "likes": 12, "viewed": 537, "published": "Public API", "date": "1566245949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Staircase function y=f(x)\n//\n// k>1 : flat horizontals\n// k<1 : flat verticals\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // coordinates    \n    float dx = 3.0/iResolution.y;\n    vec2  p = fragCoord.xy*dx;\n    \n    // animate staircase curve\n    float k = pow( 2.0, 4.0*sin(3.1415927*iTime));\n    \n    // background\n    vec3 col = vec3( 0.2 + 0.02*mod(floor(p.x)+floor(p.y),2.0) );\n\n    // draw curve y=f(x)\n    float y = staircase( p.x, k );\n    col = mix( col, vec3(1.0,0.8,0.3), 1.0-smoothstep(0.0, 2.0*dx, abs(p.y-y) ) );\n    \n    // draw curve x=f^-1(x)\n    float x = staircase( p.y, 1.0/k );\n    col = mix( col, vec3(1.0,0.8,0.3), 1.0-smoothstep(0.0, 2.0*dx, abs(p.x-x) ) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBXRG.jpg", "access": "shaders20k", "license": "mit", "functions": [[1080, 1264, 1307, 1307, 1457], [1459, 1459, 1516, 1540, 2121]]}
{"id": "ttBXRh", "name": "Shapes and materials sdf", "author": "tmulgrew", "description": "More signed distance field practice", "tags": ["3d", "raymarching", "sdf"], "likes": 5, "viewed": 527, "published": "Public API", "date": "1565088361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A little SDF ray-marching \"framework\".\n// Much of the techniques are copied from IQ's demos and articles.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst float tmin = 0.01;\t\t\t\t\t\t\t\t// Ray minimum distance\nconst float tmax = 500.0;\t\t\t\t\t\t\t\t\nconst int raySteps = 256;\t\t\t\t\t\t\t\t// Max iterations when resolving a ray\nconst int shadowSteps = 50;\t\t\t\t\t\t\t\t// Max iterations when resolving a shadow ray\nconst float limit = 0.0005;\t\t\t\t\t\t\t\t// Convergence to surface limit when ray tracing\nconst float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-0.5, -1.0, 0.6));\t// Light direction\nconst float ambient = 0.2;\t\t\t\t\t\t\t\t// Ambient light\nconst vec3 fog = vec3(0.5,0.7,0.9);\t\t\t\t\t\t// Fog colour\nconst int bounces = 3;\t\t\t\t\t\t\t\t\t// Max reflection bounces (actually bounces + 1, as includes initial ray)\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Data structures\n\nstruct lightingParams {\n \tfloat diffuse;\n    float specular;\n    float shiny;\n};\n\nstruct material {\n    vec3 col;\t\t\t\t\t\t\t\t\t\t\t// Surface colour\n    lightingParams lighting;\n    float reflective;\t\t\t\t\t\t\t\t\t// Reflectiveness. 0 = not reflective. 1 = completely reflective (e.g. mirror).\n};\n    \nstruct rayInfo {\n    vec3 origin;\n    vec3 dir;\n};\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Functions (implemented at the bottom)\n    \n// Get camera ray for specified pixel\nrayInfo getRay(in vec2 fragCoord);\n\n// Get VR ray\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir);\n\n// Get sample point.\n// Format is vec4:\n//\tx,y\t\t= Material parameter (e.g. uv)\n//\tz\t\t= Distance to nearest surface\n//\tw\t\t= Material index (will be passed to getMaterial())\nvec4 map(in vec3 p);\n\n// Get material properties by index\nmaterial getMaterial(float index, vec2 uv);\n\n// Get colour for ray that misses\nvec3 getRayMissCol(in rayInfo ray);\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Trig\n\nconst float PI = 3.14159265;\n\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotatez(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 euler) {\n \treturn rotatey(rotatex(rotatez(p, euler.z), euler.x), euler.y);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Helper functions\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\n// Pinched from: http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Combining shapes\n//\n// Sample format is vec3:\n//\tx,y\t\t= Material parameter (e.g. texture coordinates)\n//\tz\t\t= Distance\n\n// Union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2) { \n    return p1.z < p2.z ? p1 : p2;\n}\n\n// Smoothed union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z < p2.z ? p1.xy : p2.xy, sminCubic(p1.z, p2.z, k));\n}\n\n// Subtract shape p2 from p1\nvec3 carve(in vec3 p1, in vec3 p2) { \n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\n// Intersection of two shapes\nvec3 intersect(in vec3 p1, in vec3 p2) { \n    return p1.z > p2.z ? p1 : p2;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shape primitives\n\nvec3 sphere(in vec3 p, in vec3 center, float rad) { \n    p -= center;\n    return vec3(atan(p.x, p.y) * rad, atan(length(p.xy), p.z) * rad, length(p) - rad); \n}\nvec3 box(in vec3 p, in vec3 center, in vec3 size) {\n    p -= center;\n    vec3 x = vec3(p.yz, abs(p.x) - size.x);\n    vec3 y = vec3(p.xz, abs(p.y) - size.y);\n    vec3 z = vec3(p.xy, abs(p.z) - size.z);\n    return intersect(x, intersect(y, z));\n}\nvec3 cube(in vec3 p, in vec3 center, float size) \t{ return box(p, center, vec3(size)); }\nvec3 planeLeft(in vec3 p, float x)\t\t\t\t\t{ return vec3(p.yz, x-p.x); }\nvec3 planeRight(in vec3 p, float x)\t\t\t\t\t{ return vec3(p.yz, p.x-x); }\nvec3 planeBottom(in vec3 p, float y)\t\t\t\t{ return vec3(p.xz, y-p.y); }\nvec3 planeTop(in vec3 p, float y) \t\t\t\t\t{ return vec3(p.xz, p.y-y); }\nvec3 planeFront(in vec3 p, float z)\t\t\t\t\t{ return vec3(p.xy, z-p.z); }\nvec3 planeBack(in vec3 p, float z)\t\t\t\t\t{ return vec3(p.xy, p.z-z); }\nvec3 cylinder(in vec3 p, in vec3 center, float radius, float height) { \n    p -= center;\n    vec3 tube = vec3(atan(p.x, p.z) * radius, p.y, length(p.xz) - radius);\n    vec3 top = planeTop(p, height);\n    vec3 bottom = planeBottom(p, -height);\n    return intersect(tube, intersect(top, bottom));\n}\nvec3 torus(in vec3 p, in vec3 center, float radius, float thickness) { \n    p -= center;\n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\nvec3 plane(in vec3 p, in vec3 center, in vec3 n) { \n    return vec3(0, 0, dot(p - center, n)); \n}\nvec3 pyramid(in vec3 p, in vec3 center, float width, float height) {\n    vec3 top = center + vec3(0, height, 0);\n    vec3 r = planeBottom(p, center.y);\n    r = intersect(r, plane(p, top, normalize(vec3( height,width, 0))));\n    r = intersect(r, plane(p, top, normalize(vec3(-height,width, 0))));\n    r = intersect(r, plane(p, top, normalize(vec3( 0,width, height))));\n    r = intersect(r, plane(p, top, normalize(vec3( 0,width,-height))));\n    return r;\n}\n\n// Creating and combining full sample including material index\nvec4 makes(in vec3 d, float material) {\n    // Like a distance sample, but with w = material index.\n    // Specifically:\n    //\tx,y\t= material parameter (e.g. texture coord)\n    //\tz\t= distance\n    //\tw\t= material index\n \treturn vec4(d, material);   \n}\n\nvec4 merges(in vec4 result, in vec3 d, float material) {\n \treturn d.z < result.z ? makes(d, material) : result;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Rendering\n\n// Calculate ray direction for a given pixel\nvec3 screenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), 1);\n}\n\n// Simple lighting\nfloat shading(in vec3 e, in vec3 n, in lightingParams p) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * p.diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), p.shiny) * p.specular;\n\n    return max(d + s, 0.0);\n}\n\n// Calculate normal at a point\nvec3 normal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).z;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).z - d,\n        map(p + vec3(0,s,0)).z - d,\n        map(p + vec3(0,0,s)).z - d);\n    \n    return normalize(r);\n}\n\n// Cast regular ray\nvec4 raycast(in vec3 from, in vec3 dir) {\n    \n    float t = tmin;\n    vec4 d;\n    for (int i = 0; i < raySteps && t < tmax; i++) {\n        vec3 p = from + dir * t;\n        d = map(p);\n        if (abs(d.z) <= limit * t) {\n            d.z = t;\n            return d;\n        }\n        t += d.z;\n    }    \n    \n    // Avoid flicker when polygons are edgewise to the camera.\n    // In this case the ray cannot quite find the surface and runs out of steps.\n    // Just return the last sample point.\n    if (t < tmax) {\n        d.z = t;\n        return d;\n    }\n    \n    return vec4(0,0,-1.0,0);    \n}\n\n// Cast shadow ray\nfloat shadow(in vec3 from, in vec3 dir, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < shadowSteps && t < tmax; i++) {\n     \tvec3 p = from + dir * t;\n        float d = map(p).z;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\nvec3 drawPixel(in rayInfo ray) {\n    ray.dir = normalize(ray.dir);\n\n    // Sum up reflection bounces    \n    vec3 sumCol = vec3(0);\n    float alpha = 1.0;\n    for (int bounce = 0; bounce < bounces && alpha > 0.0002; bounce++) {\n    \n\t    // Ray cast\n\t    vec4 r = raycast(ray.origin, ray.dir);\n    \n        // Distance is returned in r.z\n\t    // Miss?\n\t    if (r.z == -1.0)\n\t    {\n            vec3 missCol = getRayMissCol(ray);\n            sumCol += missCol * alpha;\n\t        break;\n\t    }\n        \n\t    // Position and normal\n\t    vec3 p = ray.origin + r.z * ray.dir;\n\t    vec3 n = normal(p, r.z);\n\n        // Get material info\n        material mat = getMaterial(r.w, r.xy);        \n        \n        // Cancel reflection if on last bounce\n        if (bounce == bounces - 1)\n            mat.reflective = 0.0001;\n    \n        // Apply lighting\n        float i = shading(ray.dir, n, mat.lighting);\n        if (i > 0.0) \n            i *= shadow(p, -light, 16.0);    \n        i = clamp(i + ambient, 0.0, 1.0);\n        mat.col *= i;\n\n        // Apply fog\n        float f = clamp(r.z * r.z / 50000.0, 0.0, 1.0);\n        sumCol += fog * f * alpha;\n        alpha *= (1.0 - f);\n\t    \n        // Add to sum of colours\n        mat.col *= (1.0 - mat.reflective);\n        sumCol += mat.col * alpha;\n        alpha *= mat.reflective;\n        \n        // Calculate reflection vector\n        ray.origin = p;\n        ray.dir = normalize(reflect(ray.dir, n));\n    }    \n    \n    return sumCol;\n}\n\n// Main entrypoints\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rayInfo ray = getRay(fragCoord);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) \n{\n \trayInfo ray = getVRRay(fragCoord, fragRayOri, fragRayDir);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\nrayInfo getRay(in vec2 fragCoord) {\n    rayInfo ray;\n    \n    vec3 ang = vec3(0.65, iTime * 0.05, 0);\n    ray.origin = vec3(0,-2,0) + rotate(vec3(0, 0, -30), ang);\n    ray.dir = rotate(screenRay(fragCoord), ang);\n    return ray;\n}\n\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n \trayInfo ray;\n    ray.origin = fragRayOri * 50.0 + vec3(0,40,10);\n    ray.dir = fragRayDir;\n    return ray;\n}\n\nvec3 getRayMissCol(in rayInfo ray) {\n    vec3 skycol = fog;\n    if (ray.dir.y > 0.1) {\n        vec2 t = ray.dir.xz / ray.dir.y;\n        float cloud = texture(iChannel3, t * 0.1 + iTime * vec2(0.01, 0.007)).x \n            + texture(iChannel3, t * 0.3 + iTime * vec2(0.005, -0.003)).x * 0.3\n            + texture(iChannel3, t * 1.0 + iTime * vec2(-0.004, -0.006)).x * 0.1;\n        cloud = clamp(cloud - 0.6, 0.0, 1.0);\n        skycol += vec3(cloud);            \n    }\n    \n    return skycol;\n}\n\n// Material types.\n// Returned by map(). Then passed into getMaterial() to get colour, lighting etc.\nconst float redMat \t\t= 1.0;\nconst float blueMat \t= 2.0;\nconst float mirrorMat \t= 3.0;\nconst float marbleMat \t= 4.0;\nconst float woodMat \t= 5.0;\nconst float checkerMat \t= 6.0;\nconst float metalMat \t= 7.0;\n\n// Lookup material colour etc\nmaterial getMaterial(float matType, vec2 uv) {\n\n    // Set defaults\n    material mat;\n    mat.lighting.diffuse = 0.6;\n    mat.lighting.specular = 0.8;\n    mat.lighting.shiny = 32.0;\n    mat.reflective = 0.0001;\n    \n    if (matType == redMat) {        \n        mat.col = vec3(0.8, 0.3, 0.2);\n        mat.reflective = 0.05;\n        mat.lighting.specular = 2.5;\n    }\n    else if (matType == blueMat) {        \n        mat.col = vec3(0.3, 0.5, 0.9);\n    }        \n    else if (matType == marbleMat) {\n        mat.reflective = 0.15;\n        mat.col = texture(iChannel0, uv * 0.05).xyz;\n    }\n    else if (matType == mirrorMat) {\n        mat.reflective = 0.6;\n        mat.col = vec3(0.7);\n    }\n    else if (matType == woodMat) {\n        mat.col = texture(iChannel1, uv * 0.05).xyz;  \n    }\n    else if (floor(matType) == checkerMat) {\n        float p = (matType - checkerMat) * PI * 2.0;\n        mat.col = vec3(sin(p), sin(p + 2.0), sin(p + 4.0)) * 0.4 + vec3(0.6);\n        if (checkerboard(uv * PI / 2.0))\n            mat.col = mix(mat.col, vec3(1), 0.4);\n    }\n    else if (matType == metalMat) {\n        mat.reflective = 0.15;\n        mat.col = texture(iChannel2, uv * 0.05).xyz * 2.0;              \n    }\n    \n    return mat;\n}\n\nvec3 coffeeCup(in vec3 p, in vec3 center) {\n    \n    // Create a vec3 distance sample by combining distance samples for primative shapes.    \n\tp -= center;\n    \n    float d = length(p - vec3(0, 2.75, 0.6));\n    if (d > 5.5) \n        return vec3(0,0,d - 5.0);    \n    \n    // Component primatives\n    vec3 base = sphere(p, vec3(0, 2, 0), 3.0);\n    base = intersect(base, planeBottom(p, 0.0));        \n    vec3 body = cylinder(p, vec3(0, 3, 0), 3.0, 2.0);    \n    vec3 hole = cylinder(p, vec3(0, 4, 0), 2.8, 3.0);    \n    vec3 rim = torus(p, vec3(0, 5, 0), 2.9, 0.1);    \n    vec3 handle = torus(p.zxy, vec3(3, 0, 2.85), 1.5, 0.3);\n    \n    // Combine together\n    return combine(carve(combine(combine(base, body), handle, 0.5), hole), rim);\n}\n\nvec4 map(in vec3 p) {\n\n    // Combine shapes with materials\n    vec4 r = makes(torus(p, vec3(16, 1.0, 0), 5.0, 1.0), checkerMat + 0.55);\n    r = merges(r, cube(p, vec3(-18, 3.0, 3), 3.0), woodMat);\n    r = merges(r, cylinder(p, vec3(-3, 4, 10), 2.0, 4.0), checkerMat + 0.0);\n    r = merges(r, sphere(p, vec3(sin(iTime * 0.3 * 2.0) * 15.0, 4, cos(iTime * 0.3) * 20.0), 4.0), mirrorMat);\n    r = merges(r, pyramid(p, vec3(-18, 0, -4), 4.0, 6.0), redMat);    \n    vec3 cupp = rotatey(p - vec3(0, 0, -10), -PI*0.5);\n    r = merges(r, coffeeCup(cupp, vec3(0)), metalMat);\n    r = merges(r, planeTop(p, 0.0), marbleMat);\n    \n    return r;\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2149, 2322, 2356, 2356, 2467], [2469, 2469, 2503, 2503, 2614], [2616, 2616, 2650, 2650, 2761], [2763, 2763, 2802, 2802, 2873], [2875, 3030, 3060, 3060, 3206], [3208, 3274, 3320, 3320, 3406], [3665, 3688, 3726, 3726, 3763], [3765, 3797, 3844, 3844, 3918], [3920, 3949, 3985, 3985, 4039], [4041, 4071, 4111, 4111, 4148], [4150, 4305, 4356, 4356, 4464], [4465, 4465, 4516, 4516, 4709], [4710, 4710, 4761, 4761, 4798], [4799, 4799, 4839, 4839, 4867], [4868, 4868, 4909, 4909, 4937], [4938, 4938, 4979, 4979, 5007], [5008, 5008, 5048, 5048, 5076], [5077, 5077, 5118, 5118, 5146], [5147, 5147, 5187, 5187, 5215], [5216, 5216, 5286, 5286, 5512], [5513, 5513, 5583, 5583, 5779], [5780, 5780, 5830, 5830, 5877], [5878, 5878, 5946, 5946, 6333], [6335, 6398, 6437, 6617, 6650], [6652, 6652, 6708, 6708, 6765], [6915, 6960, 6987, 6987, 7074], [7076, 7095, 7153, 7178, 7373], [7375, 7406, 7439, 7569, 7874], [7876, 7896, 7937, 7937, 8490], [8492, 8511, 8561, 8561, 8843], [8845, 8845, 8877, 8877, 10321], [10323, 10344, 10401, 10401, 10501], [10503, 10503, 10596, 10596, 10720], [10722, 10857, 10892, 10892, 11087], [11089, 11089, 11166, 11166, 11277], [11279, 11279, 11315, 11315, 11770], [12078, 12108, 12154, 12175, 13336], [13338, 13338, 13381, 13479, 14079], [14081, 14081, 14102, 14140, 14716]]}
{"id": "ttBXWm", "name": "Countdown Timer 60 sec", "author": "Yusef28", "description": "As title suggests", "tags": ["2d", "circles", "time", "shadow", "timer"], "likes": 12, "viewed": 196, "published": "Public", "date": "1566207260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.45262)))*43256.53);\n}\nmat2 rot(float a)\n{\n \treturn mat2 (cos(a), -sin(a), sin(a), cos(a));   \n}\n//unused\nfloat square(vec2 p, float ss, float b)\n{\n\tp = abs(p);\n\tfloat sq = max(p.x, p.y)-b; \n    return sq;\n}\n \nfloat S(vec2 p, float r)\n{    \nfloat ss = 0.05;\n    //shift so it's not directly under\n    vec2 shift = vec2(0.03)*rot(iTime/2.);\n    float c = length(p+shift);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}    \n//rim lighting circle\nfloat R(vec2 p, float r)\n{    \nfloat ss = 0.002;\n    //shift so it appears to be boucing off one side\n    vec2 shift = vec2(0.003)*rot(iTime/2.);   \n    float c = length(p-shift);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n} \n//used for the black inner circle\nfloat R2(vec2 p, float r)\n{    \nfloat ss = 0.005; \n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}   \n//circle used for both gold and red\nfloat circle(vec2 p, float r)\n{\n\tfloat ss = 0.002;\n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    \nfloat ss = 0.001;\n    float c = length(p);\n    return abs(sin(c*340.))*(1.0-smoothstep(r-ss, r+ss,c));\n}\n//unused\nfloat H(vec2 p, float r)\n{    \nfloat ss = 0.1;\n    float c = length(p);\n    return 1.0-c;//1.0-smoothstep(r-ss, r+ss, c);\n}\n\n//unused\nfloat Nring(vec2 p, float r, float i)\n{\n    \n return circle(p, r)-circle(p, r-0.005);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st2 = uv;\n    uv = uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n\n    uv*=1.5;\n    vec2 noMoveuv = uv;\n\n    //background color\n    vec3 col = vec3(0.9, 0.9, 0.8);\n    //init x shift\n    float x = 0.;\n    //init y shift\n    float y = 0.;\n    //init radius\n    float r = 0.5;\n    float n = 60.;\n    //num of circles (number of times through the loop)\n    float num = mod(n-ceil(iTime), n);//rnd(vec2(floor(iTime)))*100.+10.;\n    //some movement\n    //uv.y+=sin(iTime)/50.;\n    //gold\n    vec3 gold  = vec3(215., 154., 15.)/255.;\n    //shading texture for the gold\n    float tx = vec3(texture(iChannel0, uv*rot(iTime/8.)/2.)).x+0.7;\n        \n    //texture for the red\n    float tx1 = vec3(texture(iChannel1, uv/2.)).x+0.3;\n\n    //background texture\n    float tx2 = vec3(texture(iChannel2, noMoveuv/2.)).x+0.3;\n\t//using background texture\n    col-=tx2/9.;    \n    //how spread out the circles are\n    float th = 2.+1.*abs(sin(iTime));\n        \n    // Time varying ring color\n    vec3 ringcolor = vec3(abs(sin(iTime/12.+0.9))+0.1, abs(cos(iTime/2.+0.5)), abs(fract(iTime/3.)-0.5)+0.2);//vec3(0.42, 0., 0.);\n    //a for loop\n    for(float i = 0.0 ; i<num ; i++){\n        //circle shifed based on random offet based on index of for loop\n        x = rnd(vec2(i, i+4904.));\n        y = rnd(vec2(i, i+234.));\n        //radius changed based on for loop index\n        \n        r = rnd(vec2(i, i+10.))/2.;\n    \tuv = uv*rot(iTime/32.);\n        //shift and separationg for each circle\n        vec2 st=uv+(vec2(x, y)*th-th/2.);\n    \t\n        tx1 = vec3(texture(iChannel1, st/2.)).x+0.3;\n    \t//shadow circle\n        col = mix(col, vec3(0.0), S(st, r));\n       //rim lighting circle\n        col = mix(col, gold+0.4, R(st, r+0.005));\n\t\t//gold outer circle\n    \tcol = mix(col, gold*tx, circle(st, r));\n      \t//sin gradient on outer circle\n        col-=SIN(st, r)/4.;\n        //another ring around the inner circle\n        col = mix(col, vec3(0.1)*tx1, R2(st,\n                                                      //radius made smaller by random offse based on for loop index\n                                                      r-0.08*rnd(vec2(i))));\n        \n        //colored inner circle                                   \n    \tcol = mix(col, ringcolor*tx1-vec3(.4, 0., 0.0)*(sin(i)+1.)/4., circle(st,\n                                                      //radius made smaller by random offse based on for loop index\n                                                      r-0.1*rnd(vec2(i))));\n    \t//unused\n        //some shading circle                                   \n    \t//some ring thing\n        //col = mix(col, vec3(0.2)*tx, Nring(uv+vec2(y, x)*th-th/2., rnd(vec2(i))/2., i/4.));\n        //col -= clamp(\n          //  pow(H(uv+(vec2(x, y)*th-th/2.),r-0.1*rnd(vec2(i)))/1.3, 7.)  , 0., 1.);\n\n    }\n    //vignette\n    st2 *=  1.0 - st2.yx;\n    float vig = st2.x*st2.y*15.;\n    vig = pow(vig, 0.15);\n    //output\n    \n   // col = vec3(fbm(uv));// vec3(SINcircle(uv, 0.5));\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 86], [87, 87, 106, 106, 160], [161, 170, 211, 211, 271], [274, 274, 300, 300, 478], [483, 505, 531, 531, 728], [730, 764, 791, 791, 883], [887, 923, 954, 954, 1042], [1044, 1067, 1095, 1095, 1205], [1206, 1215, 1241, 1241, 1338], [1340, 1349, 1388, 1388, 1439], [1441, 1441, 1498, 1548, 4605]]}
{"id": "ttBXzV", "name": "My test spiral hallucinogen", "author": "dimonoid", "description": "Test", "tags": ["test"], "likes": 1, "viewed": 57, "published": "Public", "date": "1566418710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/300.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 a;\n    float pi=3.14159;\n    float r=sqrt(pow(uv.x-0.5,2.0)+pow(uv.y-0.5,2.0));\n    float o=acos((uv.x-0.5)/r);\n    o=o/(2.0*pi);\n    if (uv.y<0.5)\n        o=(1.0-o);\n    float o1=o-iTime*0.5;\n    float o2=o+iTime*0.5;\n    \n    o1=mod(o1,1.0);\n    o2=mod(o2,1.0);\n    \n    a.r=r*2.0/sqrt(2.0);\n    a.b=1.0-a.r;\n    //\n    \n    a.b=mod(a.b-o1,0.1)*10.0;\n    a.r=mod(a.r-o2,0.1)*10.0;\n    //\n    fragColor = vec4(a.b,a.r,a.b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 570]]}
{"id": "ttjSR3", "name": "Phase ripple", "author": "tdhooper", "description": "Fooling around with x-ray rendering again", "tags": ["glow", "xray"], "likes": 48, "viewed": 877, "published": "Public API", "date": "1566647160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from https://www.shadertoy.com/view/WdB3Dw\n\n#define PI 3.14159265359\n#define fTime mod(iTime / 4., 1.)\n\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat map(vec3 p) {\n    return length(p) - .5;\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nconst float ITER = 400.;\nconst float FUDGE_FACTORR = .25;\nconst float INTERSECTION_PRECISION = .0001;\nconst float MAX_DIST = 4.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 pos;\n    float rayLength = 0.;\n\tfloat dist = 0.;\n\n\tvec3 origin = vec3(0,.0,2.9);\n    \n    vec2 rot = vec2(.525,-.41);\n\tvec2 im = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    if (im.x > -1. && im.y > -1.) {\n       rot += im;\n    }\n    pR(origin.zy, rot.y*1.5);\n    pR(origin.zx, rot.x*1.5);\n    \n    mat3 camMat = calcLookAtMatrix(origin, vec3(0), vec3(0,1,0));\n    vec3 rd = normalize(camMat * vec3(p, 4.));\n\n    vec3 color = vec3(10,0,12)*.0007;\n    vec3 c;    \n\n    for (float i = 0.; i < ITER; i++) {\n\n        // Step a little slower so we can accumilate glow\n        rayLength += max(INTERSECTION_PRECISION, abs(dist) * FUDGE_FACTORR);\n        pos = origin + rd * rayLength;\n\n        // warp space\n        float w = smoothstep(0., .2, fTime) - pow(smoothstep(.2, 1., fTime), 1.);\n        float q = smoothstep(0., .2, fTime) * .5 + smoothstep(.2, 1., fTime) * .5;\n        pos += sin((pos) * mix(10., 100., fTime)) * mix(.0, .05, w);\n        \n        dist = map(pos);\n\n        // Add a lot of light when we're really close to the surface\n        c = vec3(max(0., .001 - abs(dist)) * .5);\n        c *= vec3(1.4,2.1,1.7); // blue green tint\n\n        // Accumilate some purple glow for every step\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\n        c *= smoothstep(20., 7., length(pos));\n\n        // Fade out further away from the surface\n        c *= smoothstep(.01, .0, dist) * .5;\n        \n        // Vary colour as we move through space\n        c *= spectrum(length(sin(pos - vec3(.45,0,0))) * 10. - .6 - fTime*5.);\n\n        color += c;\n        \n        if (rayLength > MAX_DIST) {\n            break;\n        }\n    }\n\n    // Tonemapping and gamma\n    color = pow(color, vec3(1. / 1.8)) * 2.;\n    color = pow(color, vec3(2.)) * 3.;\n    color = pow(color, vec3(1. / 2.2));\n\n\n    fragColor = vec4(color,1);\n}", "image_inputs": [{"id": "4dX3Rr", "previewfilepath": "/media/ap//media/previz/cubemap00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 157, 225, 225, 268], [269, 269, 293, 293, 391], [393, 403, 435, 435, 480], [482, 482, 501, 501, 530], [532, 532, 582, 582, 725], [857, 857, 914, 914, 2813]]}
{"id": "ttjSRc", "name": "noisy convolutions", "author": "hexjay", "description": "Yet another raymarching experiment based on Inigo Quilez's code.", "tags": ["noise", "raymarch", "abstract"], "likes": 2, "viewed": 104, "published": "Public", "date": "1566665430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\tYet another raymarching experiment based on IQ and @paulofalcao's code.\n*/\n\nconst int ITER = 20;\nconst float PI = 3.14159265;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.9 );\n\n\nvec2 r2(vec2 v, float a) \n{\n\tmat2 m = mat2 (\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t\t);\n\treturn m*v;\n}\n\nfloat ss(float mi,float ma,float a)\n{ // sineSignal (min,max,alpha)\n\treturn (sin(a)+1.)*(ma-mi)*0.5+mi;\n}\n\n\n//   /\n//---  Noise\n//   \\\n\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec2 p )\n{\n\tp*=3.;\n\tfloat f = 0.0;\n    f += 0.25000*noise( p ); p = m2*p*0.02;\n    f += 0.12500*noise( p ); p = m2*p*0.13;\n    f += 0.06250*noise( p ); p = m2*p*0.01;\n    f += 0.03125*noise( p ); p = m2*p*0.04;\n    f += 0.01500*noise( p );\n    return f/0.38375;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//    /\n// ---  Field\n//    \\\n\nfloat distanceField(in vec3 p) \n{\n  \tfloat s = 8.; // spacing\n  \tfloat d = cos(p.x*0.05);\n  \tfloat rs = 0.25 * iTime+ d; // rotating speed\n  \tvec2 pos; // yz\n  \n  \tfloat a = rs+d;  \n  \tpos = s*vec2( sin(a) , cos(a));\n\n  \tfloat r = 2.5;\n  \tfloat res;\n\t\n  \t// a simple cylinder would go like this :  length(p.yz+pos)-r  \n  \t// here is 4 cylinders with displacements :\n\n  \tfloat ssf =  ss(0.,1.,p.y*2.) * sin(p.x+iTime);\n  \tfloat w = fbm(p)*2.;\n\n  \tres = \n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\n  \ta = rs+PI*1.0+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res2 =\n\t  \t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\t\n\ta = rs+PI*0.50+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res3 =\n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\t\n  \ta = rs+PI*1.50+d;\n  \tpos = s*vec2(sin(a),cos(a));\n  \tfloat res4 =\n\t\t( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;\n\n  \tres = min(res,res4);\n  \tres = min(res,res3);\n  \tres = min(res,res2);\n  \treturn res;\n}\n\nvec3 getColor(in vec3 p)\n{\n\tvec3 res = vec3(1.,0.2,0.) * 2.;\n  \tfloat m = mod(sin(p.x),2.);\n  \tfloat n = fbm(p);\n  \tfloat g = fbm(vec3(p.x*iTime*2000.,1.,1.))*2.;\n  \tres = res*n*m*(g*2.+1.);\n  \treturn res;\n}\n\n//    /\n// ---  Main\n//\t  \\\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec3 bgColor = vec3 (0.1,0.0,0.0);\n\n  \tvec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  \tvec3 finalColor = vec3 (0.0);  \n  \n  \t//Camera animation\n  \tvec3 vuv=vec3(0,1,0);//Change camere up vector here\n  \tfloat s0 = ss(-15.,+15.,iTime*0.1);\n\t\n  \tvec3 prp=vec3(s0,0.,ss(3.,13.,iTime*0.13)); //Change camera path position here\n  \tvec3 vrp=vec3(sin(iTime*0.002)*2.,cos(iTime)*2.,0); //Change camere view here\n\n  \t//Camera setup\n  \tvec3 vpn=normalize(vrp-prp);\n  \tvec3 u=normalize(cross(vuv,vpn));\n  \tvec3 v=cross(vpn,u);\n  \tvec3 vcv=(prp+vpn);\n  \tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t//Raymarching\n  \tconst vec3 e=vec3(0.1,0,0);\n  \tconst float maxd=30.0; //Max depth\n\n  \tfloat s= 0.1;\n  \tvec3 c,p,n;\n\n  \tfloat f=1.0;\n  \tfor(int i=0;i<  ITER ; i++)\n    {\n    \tif (abs(s)<.01||f>maxd) break;\n    \tf+=s;\n    \tp=prp+scp*f;\n    \ts=distanceField(p);\n  \t}\n\n  \tif (f<maxd)\n    {\n    \tc=getColor(p);\t// cylinder color\n    \tn=normalize(\n      \tvec3(s-distanceField(p-e.xyy),\n        \ts-distanceField(p-e.yxy),\n        \ts-distanceField(p-e.yyx)));\n    \tfloat b=dot(n,normalize(prp-p));\n\n    \tvec3 finalColor = vec3( b*c+pow(b,8.0))*(1.0-f*.02) ;  //simple phong LightPosition=CameraPosition\n\n\t\tfinalColor*=0.44;\n    \tfragColor = vec4( finalColor, 1.);\n  \t} else \n    { // background color\n    \tbgColor = \n\t  \tvec3(0.7,0.2,0.1);\n\t  \tfloat n = fbm(p);\n      \tbgColor = vec3(n)*bgColor*f/60.;\n\t  \tfragColor=vec4(bgColor,1.);\n  \t}\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 286, 313, 313, 386], [388, 388, 425, 455, 493], [496, 525, 551, 551, 695], [697, 697, 723, 723, 928], [930, 930, 951, 951, 1204], [1206, 1206, 1227, 1227, 1409], [1411, 1442, 1475, 1475, 2471], [2473, 2473, 2499, 2499, 2680], [2682, 2711, 2766, 2766, 4253]]}
{"id": "ttjSRG", "name": "Belt Trick Warps a Cube", "author": "_polymath", "description": "https://www.shadertoy.com/view/3t2Xzy but more so", "tags": ["raymarched"], "likes": 2, "viewed": 259, "published": "Public API", "date": "1566305855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITERS 1000\n#define LENFACTOR .2\n#define NDELTA 0.001\n\n// #define GRIDCOLS\n// #define LIGHTING\n#define NORMALS\n\n#define NDELTAX vec3(NDELTA, 0., 0.)\n#define NDELTAY vec3(0., NDELTA, 0.)\n#define NDELTAZ vec3(0., 0., NDELTA)\n\nfloat box(vec3 p, vec3 centre, vec3 dims) {\n    vec3 d = abs(p - centre) - dims;\n    return max(d.x, max(d.y, d.z));\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    // axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, // 0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, // 0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);          // 0.0,\n               // 0.0,                                0.0,                                0.0,                                1.0);\n}\n\nconst float pi = 3.1415926536;\n\nmat2 rot(float t) {\n\tfloat s = sin(t), c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\nfloat scene(vec3 p) {\n    \n    // rotate space!!!\n    vec3 axis = vec3(\n    \tcos(iTime * 0.3),\n    \t0.,\n    \tsin(iTime * 0.3));\n    float angle = pi * pow(smoothstep(100., 2., dot(p, p)), 5.);\n    p *= rotationMatrix(axis, angle);\n    \n    return //min(box(p, vec3(0.), vec3(0.7, 0.1, 1000.)),\n           //min(box(p, vec3(0.), vec3(0.1, 10., 0.7)),\n           //min(box(p, vec3(0.), vec3(1000., 0.7, 0.1)),\n               box(p, vec3(0.), vec3(\n                   4. + 3. * cos(iTime * 0.4)\n               ));\n           //)));\n}\n    \nvec3 sceneNormal(vec3 p) {\n    return normalize(vec3(\n        scene(p + NDELTAX) - scene(p - NDELTAX),\n        scene(p + NDELTAY) - scene(p - NDELTAY),\n        scene(p + NDELTAZ) - scene(p - NDELTAZ)\n\t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.));\n    ray.yz *= rot(-0.1);\n    ray.xz *= rot(-0.7853981634);\n    vec3 cam = vec3(20., 2., -20.);\n    \n    vec3 pos = cam;\n    for (int i = 0; i < MAXITERS; ++i) {\n        float dist = scene(pos);\n        pos += ray * dist * LENFACTOR;\n    }\n\n    #ifdef GRIDCOLS\n    \tfragColor = vec4(fract(pos), 1.);\n    #endif\n    \n    #ifdef NORMALS\n    \tfragColor = vec4(sceneNormal(pos) * 0.5 + 0.5, 1.);\n    #endif\n    \n    #ifdef LIGHTING\n    \tvec3 light = vec3(cos(iTime) * 15., 2., sin(iTime) * 5. + 10.);\n    \tvec3 toLight = light - pos;\n    \tfloat brightness = 5.;\n    \t// I've not checked but I'm guessing inverse-square-law here:\n    \tbrightness /= pow(length(toLight), 0.5);\n    \tfragColor = vec4(vec3(dot(sceneNormal(pos), normalize(toLight))) * brightness, 1.);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 234, 277, 277, 352], [354, 428, 473, 504, 1113], [1147, 1147, 1166, 1166, 1229], [1231, 1231, 1252, 1280, 1761], [1767, 1767, 1793, 1793, 1973], [1976, 1976, 2033, 2033, 2908]]}
{"id": "ttjSRR", "name": "Math functions test PS #00", "author": "stoleckipawel", "description": "atan length", "tags": ["atanlength"], "likes": 1, "viewed": 268, "published": "Public API", "date": "1564844368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat atan_test( vec2 uv)\n{\n    float col = fract(((atan(uv.x, uv.y)+ PI) / (2.0 * PI) + (iTime * 0.1)));\n\treturn col;\n    \n}\n\t\nfloat length_test( vec2 uv)\n{\n   float lengthtestt = length(uv) - sin(iTime) * 0.25;\n   return lengthtestt;\n\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n    \n   \n    //float col = atan_test(uv);\n\tfloat col = length_test(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 53, 53, 151], [154, 154, 183, 183, 264], [267, 267, 324, 324, 514]]}
{"id": "ttjSRy", "name": "Resonating color space", "author": "TheRomanOne", "description": "A small test", "tags": ["grid", "color", "pattern"], "likes": 1, "viewed": 127, "published": "Public", "date": "1566342910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 70.\n#define EPS 0.01\n\n// Number of spheres is 2*a²\n#define a 7.\n\n// Comment out to disable rotation\n#define rotate_space\n\n// Coment to switch to lighter color pallete\n#define DARK_MODE\n\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(center - p) - radius;\n}\n\nmat2x2 rot(float ang)\n{\n    ang *= 3.141592654 / 180.;\n \treturn mat2x2(cos(ang), sin(ang), -sin(ang), cos(ang));   \n}\n\nvec4 map(vec3 p)\n{\n    float d = MAX_DIST;\n    float qq = 4., pp = 3.;\n    vec3 col;\n    for(float j = -a/2.; j < a/2.; j++)\n        for(float k = -a; k < a; k++)\n        {            \n            vec3 point = vec3(qq*(j), cos(iTime/2.)*sin(j*cos(iTime)-k*sin(iTime)), (pp*(k+a)));\n        #ifdef rotate_space\n            point.z -= a*pp;\n            point.xz *= rot(iTime * 5.);\n            point.z += a*pp;\n        #endif\n            //vec3 point = vec3(qq*(j-b), 1.+.8*cos(iTime/2.)*sin(j*cos(iTime)-k*sin(iTime)), (pp*k-b));\n            float newD = sphere(p, point , .25+sin(iTime*2.+j+k)*.17);\n            if(newD < d)\n            {\n                d = newD;\n                col = vec3(k, j, j*k);\n            }\n        }\n        \n    return vec4(col+2.5, d);//min(p.y + 1., d);\n}\n\nvec3 deriv(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(EPS, 0, 0)).w - map(p - vec3(EPS, 0, 0)).w,\n        map(p + vec3(0, EPS, 0)).w - map(p - vec3(0, EPS, 0)).w,\n        map(p + vec3(0, 0, EPS)).w - map(p - vec3(0, 0, EPS)).w\n        ));\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    \n    vec4 d=vec4(0.);\n    float dv;\n    for(int i = 0; i < 250; i++)\n    {\n        vec3 newRay = ro + dv * rd;\n        d = map(newRay);\n        if(d.w < EPS || dv > MAX_DIST)\n            break;\n        dv += d.w * .7;\n    }\n    \n    return vec4(d.xyz, dv);\n}\n\nfloat directLight(vec3 p)\n{\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(-1.5, 10, -5);\n    \n    //ro.xz *= rot(iTime * 30./* + iMouse.x/2.*/);\n    //ro.yz *= rot(-iMouse.y/2.);\n    \n    vec3 lookat = vec3(-1.5, 0, 7);\n\n    vec3 fw = normalize(lookat - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up  = cross(fw, ri);\n    \n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv*1.57, 1);\n    \n    vec4 d = march(ro, rd);\n    \n    //vec3 light = normalize(vec3(3, 3, -3));\n    vec3 light = normalize(vec3(3.*sin(iTime*3.), abs(sin(iTime)), -3.*cos(iTime*3.)));\n    vec3 col = vec3(0);\n    if(d.w < MAX_DIST)\n    {\n        vec3 n = deriv(ro + rd * d.w);\n        vec3 basecolor = d.xyz*vec3(.7, 0.3, .5)*1.2;\n        basecolor.zy = (rot(iTime*15.) * basecolor.xy);\n        #ifndef DARK_MODE\n        basecolor.zy = abs(basecolor.zy);\n        #endif\n        basecolor.zx = (rot(iTime*30.) * basecolor.yx);\n        #ifndef DARK_MODE\n        basecolor.zx = abs(basecolor.zx);\n        #endif\n        col = basecolor*max(vec3(.3), dot(n, light));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 205, 254, 254, 296], [298, 298, 321, 321, 415], [417, 417, 435, 435, 1203], [1205, 1205, 1225, 1225, 1460], [1462, 1462, 1492, 1492, 1755], [1757, 1757, 1784, 1784, 1801], [1803, 1803, 1860, 1910, 3055]]}
{"id": "ttjXD1", "name": "karhusel", "author": "foran", "description": "karhusel", "tags": ["karhusel"], "likes": 5, "viewed": 104, "published": "Public", "date": "1565809323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "  float sigmoid(float x) {\n    return x + ( .51 + abs(x));\n  }\n  \n  vec2 sigmoidDistort(in vec2 uv, inout vec2 polar, inout float distortion) {\n    polar = vec2( atan(uv.y, uv.x), length(uv) );\n    float a = sin(polar.y * .8);\n    distortion = sigmoid(a * -.2);\n    polar.x += sigmoid(a * .2) * 1.;\n    polar.y += sigmoid(a * -.5) * 3.;\n    return vec2( cos(polar.x) * polar.y, sin(polar.x) * polar.y );\n  }\n  vec3 rgb2hsv(vec3 c)\n{\n  vec4 K=vec4(0.,-1./3.,2./3.,-1.);\n  vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));\n  vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n  \n  float d=q.x-min(q.w,q.y);\n  float e=1.e-10;\n  return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K=vec4(1.,2./3.,1./3.,3.);\n  vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);\n  return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);\n}\n void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n  vec2 aspect=vec2(iResolution.x/iResolution.y,.7);\n  vec2 sPos=((fragCoord.xy/iResolution.xy)/.7+.001)*aspect;\n  vec4 b=texture(iChannel0,sPos).rgba;\n\n //---------------\n    vec2 subuv;\n    \n    uv *= 16.;\n    \n    vec2 polar = vec2(0.);\n    float distortion = 0.;\n    uv = sigmoidDistort(uv, polar, distortion);\n    \n    float t = iTime * .1;\n    uv *= mat2(\n      sin(t), -cos(t),\n      cos(t), sin(t)         \n    );\n    uv.x += iTime;\n    uv += .5;\n    \n    vec2 grid = floor(uv);\n    vec2 subgrid = fract(uv) - .5;\n    \n    float c = mod(grid.x + grid.y, 2.);\n     c = smoothstep(.44, .4, length(subgrid));\n    vec3 colour = vec3(c);\n    uv += distortion * .3;\n    grid = floor(uv);\n    subgrid = fract(uv) - .5;\n    colour.b = mod(grid.x + grid.y, 2.);\n     colour.g = smoothstep(.44, .4, length(subgrid));\n    uv += distortion * .3;\n    grid = floor(uv);\n    subgrid = fract(uv) - .5;\n    colour.b = mod(grid.x + grid.y, 2.);\n     colour.b = smoothstep(.44, .4, length(subgrid));\n uv+=distortion*.3;\n grid=floor(uv);\n subgrid=fract(uv)-.5;\n colour.r=mod(grid.x+grid.y,2.);\n colour.g=smoothstep(.44,.4,length(subgrid));\n                                  //colour=rgb2hsv(colour);\n                                  //colour=hsv2rgb(colour);\n                                  //colour=rgb2hsv(colour);\n                                  //colour=hsv2rgb(colour);\n  vec4 final=mix(vec4(colour.rgb,max(colour.xy,b.a)),b,.0712);\n fragColor=vec4(final);\n  }", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 26, 26, 62], [68, 68, 143, 143, 407], [410, 410, 432, 432, 699], [700, 700, 722, 722, 851], [853, 853, 907, 907, 2452]]}
{"id": "ttjXDK", "name": "Pixelated rainbow clouds", "author": "jarble", "description": "This is based on my \"pixelated ocean current\" shader.", "tags": ["hash"], "likes": 5, "viewed": 409, "published": "Public API", "date": "1567179476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this function is from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord/pow(2.0,mag)));\n}\n\nvec3 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.0,mag),0)*iTime,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color1 = vec3(0,0,0);\n    float maximum = 5.0;\n    for(float i = 0.0; i < maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+2.0);\n    }\n    fragColor = vec4(color1/maximum,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjXDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 83, 83, 219], [222, 222, 261, 261, 310], [312, 312, 355, 355, 416], [418, 418, 475, 475, 668]]}
{"id": "ttjXDR", "name": "breaking light ", "author": "lucastakejame", "description": "trying to make light dispersion gradients", "tags": ["2d", "lightdispersion"], "likes": 0, "viewed": 81, "published": "Public", "date": "1565737837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIN(t) (.5*sin(t) + .5)\n#define COS(t) (.5*cos(t) + .5)\n#define ss(a,b,c) smoothstep(a,b,c)\n#define PI 3.1415\n#define TAU 2.*PI\n\nvec2 muv;\n\nvec2 rot(vec2 uv, float r)\n{\n    vec2 rot = vec2(cos(r), sin(r));\n    \n    return vec2(uv.x*rot.x - uv.y*rot.y, uv.x*rot.y + uv.y*rot.x);\n}\n\nfloat points(vec2 uv, int count, float delta)\n{\n    float r = 0.;\n    \n    vec2 puv = vec2(length(uv), atan(uv.y, uv.x));\n    \n    puv.x = SIN(puv.x * 3.);\n    \n    for(int i = 0; i < count; i++)\n    {\n        \n        vec2 pos = rot(vec2(1.,0.), TAU*float(i)/float(count) );\n        \n        float dist =  .8;// + .6*sin(iTime);\n        // uv distortion proportional to its length and offset\n        float uvDist;\n        uvDist = iTime*.5;\n        uvDist += (sin(puv.x*10.))*pow( puv.x, 2.);\n        //deuvDist += puv.y;\n        vec2 uv0;\n        uv0 = rot(uv, uvDist);\n        \n        uv0 = puv.x*vec2(cos(puv.y+uvDist), sin(puv.y+uvDist));\n        \n        // brutal distortion\n        uv0 *= mix(vec2(1.), (1. - dist*pos), SIN(iTime));\n        //delta *= 1.*sin(4.*puv.y);\n        r += 1.-smoothstep(.0, .42, length(uv0 - delta*pos));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord- iResolution.xy)/iResolution.y;\n    muv = (2.*iMouse.xy- iResolution.xy)/iResolution.y;\n\n    //uv = abs(uv);\n     \n    float bd = .3 + .3*SIN(iTime*.3);\n    float gd = bd + 0.125 + .0*COS(3.*iTime);\n    float rd = bd + 0.25 + .00*SIN(4.*iTime);\n    \n    float dist = .2;\n    \n    float r;\n    float g;\n    float b;\n    \n    int count = 7;\n    r = points(uv, count, rd);\n    g = points(uv, count, gd);\n    b = points(uv, count, bd);\n    \n    //r = 0.;\n    //g = 0.;\n    //b = 0.;\n    \n    // balls\n    vec3 col = vec3(r,g,b);\n\n    float ang = .5*atan(uv.y, uv.x)/PI;\n    float m0 = (1. + .4*sin(ang*PI*28.)*sin(ang*PI*12.))*sin(iTime*5.);\n    \n    // concentric circles\n    col  = mix(col, vec3(SIN(10.*length(uv) + iTime*10.),\n                SIN(10.*length(uv) + iTime*10. + m0),\n                SIN(10.*length(uv) + iTime*10. + 2.*m0)),\n               1.5*sin(iTime));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 176, 176, 287], [289, 289, 336, 336, 1151], [1153, 1153, 1210, 1260, 2221]]}
{"id": "ttSSWm", "name": "LiveCodingPractice004(1h)", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 4, "viewed": 127, "published": "Public", "date": "1566058619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec2 pmod(vec2 p,float c){\n    p *= genRot(PI/c);\n\tfloat at = atan(p.y/p.x);\n    at = mod(at,PI * 2./c);\n    float r = length(p);\n    p = vec2(r * cos(at),r * sin(at));\n    p *= genRot(-PI/c);\n    return p;\n    \n}\nfloat map(vec3 p){\n    vec3 q = (fract(p/4. + 0.5)-0.5) * 4.;\n    vec3 s = p;\n    s.z = (fract(s.z/4. + 0.5)-0.5) * 4.;\n    p.x = p.x * sign(p.y);\n    p.y = -abs(-p.y);\n    float h =  - 2.5;\n    float a = 1.;\n    float T = 1.0;\n    for(int i = 0; i < 8; i++){\n    \th += a * sin((p.x - iTime/4.)/T) * sin((p.z + iTime/4.)/T);\n        a *= 0.5;\n        T *= 2.0;\n    }\n    h = floor(h * 10.)/10.;\n\tfloat terrain = p.y - h;\n    q.y += iTime * sign(p.x - 2.);\n    float r = floor((0.4 + 0.2 * cos(q.y * PI))* 15.0) / 15.0;\n    s.x -= iTime * sign(s.y);\n    s.y = abs(s.y);\n    float r2 = floor((0.4 + 0.2 * cos(s.x * PI)) * 15.) / 15.;\n    float tower = length(s.yz - vec2(1.25 , 2.)) - r2;\n    tower = min(tower,length(q.xz) - r);\n    \n    return min(terrain,tower);\n}\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n\tvec4 d;\n    float t = 0.;\n    for(int i = 0; i < 96; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 p = o + r * t;\n    vec3 n = getNormal(p);\n    return vec4(n,t);\n}\nvec3 cam (){\n vec3 c = vec3(2.,0.,-2.5 + iTime * 3.);\n    return c;\n}\nvec3 ray (vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    r.xz *= genRot(PI/8.);\n    r.yz *= genRot(PI/16.);\n    r.xy *= genRot(iTime/4.);\n    return r;\n}\nvec3 getCol (vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n    vec3 p = o + r * t;\n    vec3 n = d.xyz;\n    vec3 ccol;\n    float at = atan(r.y/r.x) * 2.;\n    ccol.x = sin(at + iTime);\n    ccol.y = sin(at + iTime + PI * 2./3.);\n    ccol.z = sin(at + iTime + PI * 4. /3.);\n    ccol =  ccol / 2. + 0.5;\n    vec3 bc = vec3(pow(1. - dot(r,n),2.));\n    bc = min(fract(p.x + iTime * sign(p.x - 2.)),fract(p.z + iTime)) < 0.1 ? vec3(1.) : bc ;\n    bc *= ccol;\n    float fog = 1./(1. + t * t * 0.01);\n    bc = mix(bc,vec3(1.),1. - fog);\n    return bc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    vec3 o = cam();\n    vec3 r = ray(uv,1. + 0.75 * sin(iTime *1.5));\n    vec4 data = trace(o,r);\n    vec3 c = getCol(o,r,data);\n    fragColor = vec4(c,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 90], [91, 91, 117, 117, 304], [305, 305, 323, 323, 1070], [1071, 1071, 1094, 1094, 1171], [1173, 1173, 1199, 1199, 1413], [1414, 1414, 1426, 1426, 1483], [1484, 1484, 1511, 1511, 1645], [1646, 1646, 1681, 1681, 2182], [2184, 2184, 2241, 2291, 2527]]}
{"id": "ttSSWy", "name": "Shifting Squares", "author": "sfaer", "description": "Is this white squares rotating on black foreground, or black squares rotating on white foreground ?", "tags": ["2d", "illusion"], "likes": 6, "viewed": 114, "published": "Public", "date": "1566921883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265\n\nvec2 rotate2D( in vec2 uv, in float alpha )\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    uv =  mat2(c, -s, s, c) * (uv - 0.5) + 0.5;\n    return uv;\n}\n\nvec2 tile(in vec2 uv, in float zoom)\n{\n    return fract(uv * zoom);\n}\n\nfloat box( in vec2 uv, in vec2 size, in float smoothEdges )\n{\n  size = 0.5 - size * 0.5;\n  vec2 aa = vec2( smoothEdges*0.5 );\n  vec2 st = smoothstep( size, size+aa, uv)\n          * smoothstep( size, size+aa, 1.0 - uv);    \n  return st.x * st.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n         uv.y *= iResolution.y * invRes.x;\n    \n    float dx = iMouse.x * invRes.x;\n    float dy = iMouse.y * invRes.y;\n    \n    float shiftAngle = PI * 0.25;\n    float speed = mix( 1.0, 3.5, dy);\n    float angle = mod( speed * iTime, PI) + shiftAngle;\n    float doShift = step(angle, PI-shiftAngle);\n    float scale = mix(4.0, 32.0, dx);\n    vec2 shiftOffset = vec2(-0.5, 0.5) / scale;\n    \n    //angle *= sign(doShift-0.5);\n    \n    uv += doShift * shiftOffset;\n    uv = tile(uv, scale);\n    uv = rotate2D(uv, angle);\n\n    float ic = abs(box(uv, vec2(0.71), 0.012) - doShift);\n    fragColor = vec4(vec3(0.15+0.77*ic), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 69, 69, 186], [188, 188, 226, 226, 257], [259, 259, 320, 320, 505], [507, 507, 564, 564, 1266]]}
{"id": "ttSSzK", "name": "My test spiral 1.0", "author": "dimonoid", "description": "Test", "tags": ["test"], "likes": 0, "viewed": 72, "published": "Public", "date": "1566396980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/300.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 a;\n    float pi=3.14159;\n    float r=sqrt(pow(uv.x-0.5,2.0)+pow(uv.y-0.5,2.0));\n    float o=acos((uv.x-0.5)/r);\n    o=o/(2.0*pi);\n    if (uv.y<0.5)\n        o=(1.0-o);\n    o=o-iTime;\n    o=mod(o,1.0);\n    a.r=r*2.0/sqrt(2.0);\n    //if (a.r>=0.999)//test\n    //    a.r=0.0;\n    a.g=o;\n    a.b=1.0-a.r;\n    \n    fragColor = vec4(a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 90, 475]]}
{"id": "ttSXDR", "name": "Skewed#2", "author": "104", "description": "Some kind of desert fabric?", "tags": ["2d", "glitch"], "likes": 5, "viewed": 103, "published": "Public", "date": "1566820447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec2 z = vec2(4);\nconst float complexity =4.;\nconst float density = .4; // 0-1\n\nconst float PI = atan(1.)*4.;\n\nvec4 hash42(vec2 p)\n{\n    p+=1e2;\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n#define q(x,p) (floor((x)/(p))*(p))\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = C/R.xy;\n    vec2 N = uv;\n    float t = iTime*.1+1e2;\n    uv.x *= R.x/R.y;\n\n    uv *= rot2D(PI/4.);\n    uv *= z;\n    \n    vec4 c = hash42(floor(uv));\n    float s = sign(c.z-.5);\n    s = 1.;\n    float d = 1.;\n    \n    for (float i = 1.;i <= complexity; ++ i) {\n        vec4 c = hash42(floor(uv));\n        vec2 p = fract(uv)*2.-1.;\n        uv +=s*(t+uv.yx*c.xy);\n        \n        if (i < 2.) {\n            o = c;\n        }\n        else if (c.w > density)\n            o *= c*p.x;\n        uv *= 2.;\n    }\n    o=pow(o,o-o+.3);\n    N-=.5;\n    o*=1.-dot(N,N);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 118, 139, 139, 299], [338, 338, 358, 358, 410], [412, 412, 449, 449, 1046]]}
{"id": "ttSXRG", "name": "Peachy Goo", "author": "PixelFiddler", "description": "Raymarching noise inside a sphere to create a peachy goo ball. Experimental stuff.", "tags": ["noise", "raymarch", "sphere"], "likes": 32, "viewed": 419, "published": "Public", "date": "1566319926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Carl-Mikael Lagnecrantz 2019\n// Much of this code was derived from shaders by Inigo Quilez (iq)\n\n// Raymarches noise inside a sphere to create a peachy goo ball\n\nvec3 intersectSphere( in vec3 rayPos, in vec3 rayDir, in vec3 spherePos, in float radius )\n{\n\tvec3 v = rayPos - spherePos;\n\tfloat b = dot(v, rayDir);\n\tfloat c = dot(v, v) - radius * radius;\n\tfloat discr = b * b - c;\n    \n    // A negative discriminant corresponds to ray missing sphere \n    if (discr < 0.0) return vec3(0.0,0.0,discr);\n    \n    // Ray intersects sphere. Compute and return distances of both intersections, front and back of sphere\n    discr = sqrt(discr);\n\treturn vec3(-b - discr, -b + discr, discr);\n}\n\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nfloat noise(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 w = fract(x);\n\tvec3 u = w * w*(3.0 - 2.0*w);\n\tvec3 du = 6.0*w*(1.0 - w);\n\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\n\tfloat a = hash(n + 0.0);\n\tfloat b = hash(n + 1.0);\n\tfloat c = hash(n + 157.0);\n\tfloat d = hash(n + 158.0);\n\tfloat e = hash(n + 113.0);\n\tfloat f = hash(n + 114.0);\n\tfloat g = hash(n + 270.0);\n\tfloat h = hash(n + 271.0);\n\n\tfloat k0 = a;\n\tfloat k1 = b - a;\n\tfloat k2 = c - a;\n\tfloat k3 = e - a;\n\tfloat k4 = a - b - c + d;\n\tfloat k5 = a - c - e + g;\n\tfloat k6 = a - b - e + f;\n\tfloat k7 = - a + b + c - d + e - f - g + h;\n\n    return k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x*u.y + k5 * u.y*u.z + k6 * u.z*u.x + k7 * u.x*u.y*u.z;\n}\n\nfloat fractalNoise(in vec3 x)\n{\n\tconst float scale = 3.0;\n    \n\tfloat a = 0.0;\n\tfloat b = 0.5;\n\tfloat f = 1.0;\n\n    float centerAspect = x.x*x.x + x.y*x.y + x.z*x.z;\n    float centerFade = (1.0 - centerAspect) * (1.0 - centerAspect);\n    \n    // Run iterations of noise\n\tfor (int i = 0; i<5; i++)\n\t{\n\t\tvec3 pp = f * x*scale;\n\t\tpp.x += sin(iTime * 0.1 * (float(i) + 1.0));\n\t\tpp.y += cos(iTime * 0.3 * (float(i) + 1.0));\n\t\tpp.z += sin(iTime * 0.6 * (float(i) + 1.0));\n\t\tfloat n = noise(pp);\n\t\ta += b * n;           // accumulate values\t\t\n\t\tb *= 0.52;             // amplitude decrease\n\t\tf *= -1.3 - 2.2 * centerFade; // frequency increase\n\t}\n    \n    // Fade outer rim of sphere to nothing so that no part of the mesh will intersect the sphere hull\n\tcenterAspect = 1.0 - pow(centerAspect, 40.0);\n    \n    a = 1.0 - pow(1.0 - a, 1.3);\n    \n    // Add small surface bumbs\n    float smallBumps = noise(x * 130.0 + iTime * 4.0);\n    a += smallBumps * 0.06 * (1.0 - centerAspect);\n    \n\treturn a * centerAspect;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(fractalNoise(pos + eps.xyy) - fractalNoise(pos - eps.xyy),\n\t\tfractalNoise(pos + eps.yxy) - fractalNoise(pos - eps.yxy),\n\t\tfractalNoise(pos + eps.yyx) - fractalNoise(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\nvec3 background(vec2 uv)\n{\n    vec2 uvScreen = (uv + 1.0) * 0.5; // Convert from -1...1 to 0...1\n    vec3 back = vec3(0.5, 0.6, 0.6);\n    back += (vec3(0.6, 0.8, 0.95) - back) * uvScreen.y;\n    back += vec3(1.0 - pow(1.0 - length(uv), 2.0)) * 0.2;\n    back += (1.0 - clamp(length(uv), 0.0, 1.0)) * 0.3;\n    \n    return back;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, vec2 tminmax, vec2 uv)\n{\n    // Raymarch\n\tconst int numIter = 96;\n\tfloat depth = tminmax.x;\n\tint hasSetDepth = 0;\n    float accum = 0.0;\n\tfor (int i = 0; i<numIter; i++)\n\t{\n        float loopVal = float(i) / float(numIter);\n        loopVal *= loopVal * loopVal * loopVal; // Move in smaller steps in the beginning to counter banding\n        float t = tminmax.x + (tminmax.y - tminmax.x) * loopVal;\n        \n\t\tvec3 pos = ro + t * rd;\n        \n        // Get noise value\n\t\tfloat noiseVal = fractalNoise(pos);\n        \n        // If the noise value is above 0.55 it counts as a surface hit\n\t\tif (noiseVal > 0.55 && hasSetDepth == 0)\n\t\t{\n\t\t\tdepth = t;\n\t\t\thasSetDepth = 1;\n\t\t}\n        accum += noiseVal * 2.0; // Accumulate raymarching noise values\n\t}\n\tif (hasSetDepth == 0) return background(uv); // There was no hit\n    \n    \n\tvec3 sectPos = ro + rd * depth; // Intersection pos\n    vec3 norm = calcNormal(sectPos); // Normal\n    \n    // Distance from sphere center values\n    float centerAspect = length(sectPos);\n    float centerAspectSquared = centerAspect * centerAspect;\n\n    // Lighting\n    vec3 lightDir = vec3(0.0, -1.0, 0.0); // Top light\n\tvec3 diffuse = clamp((dot(norm, lightDir)),0.0, 1.0) * vec3(0.4, 0.8, 0.9);\n    diffuse *= diffuse * 1.5;\n    vec3 lightDir2 = normalize(vec3(1.0, 0.0, 1.0)); // Back light\n    vec3 diffuse2 = clamp((dot(norm, lightDir2)),0.0, 1.0) * vec3(0.2, 0.8, 0.9);\n    diffuse2 *= centerAspectSquared * centerAspect;\n    diffuse += diffuse2 * 2.5;\n    \n    // Specular\n\tvec3 camToPos = normalize(sectPos - ro);\n\tvec3 h = normalize(lightDir + camToPos);\n\tfloat nDotH = clamp((dot(norm, h)), 0.0, 1.0);\n\tfloat specular = pow(nDotH, 40.0); // Power controls glossiness\n\tdiffuse += specular * 0.5;\n    \n    // Accumulated raymarch values simulates some smoke\n    accum /= float(numIter);\n    vec3 back = background(uv);\n    vec3 smoke = back + (vec3(accum) - back) * accum * (1.0 - pow(centerAspect, 30.0));\n    \n    // Calculate inner glow\n    float innerGlow = 1.0 - clamp((centerAspect / 0.75), 0.0, 1.0);\n    \n    centerAspect *= centerAspectSquared;\n    centerAspectSquared = centerAspect * centerAspect;\n    \n    // Color adjustments\n\tvec3 finalCol = diffuse * vec3(0.36, 0.28, 0.28);\n\tfinalCol += vec3(1.0, 0.4, 0.2) * centerAspect;\n\tfinalCol += vec3(1.0, 0.8, 0.6) * centerAspectSquared * 0.5;\n    \n    // Darken towards middle\n    finalCol *= 0.3 + 0.7 * centerAspect;\n    \n    // Inner glow\n    finalCol += vec3(1.0, 0.35, 0.25) * innerGlow * 1.5;\n    finalCol += vec3(1.0, 0.6, 0.25) * innerGlow * (1.0 - centerAspect) * (1.0 - centerAspect);\n    \n    // Smoke added from raymarch\n    float camDot = 1.0 - pow(clamp(dot(rd, norm), 0.0, 1.0), 3.0); // Fresnel\n    float smokeBlend = 0.7 * camDot * centerAspectSquared;\n    finalCol += (smoke - finalCol) * smokeBlend;\n    \n    // Fade outer rim of sphere to background slightly\n    float rimBlend = pow(length(uv), 6.0);\n    finalCol += (back - finalCol) * rimBlend;\n\n    // Some contrast\n    finalCol = (finalCol - 0.8) * 1.2 + 0.8;\n    \n\treturn clamp(finalCol, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera coordinates (from -1 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    // Setup camera\n    vec3 ro = vec3(0.0, 1.6, 1.6 );\n\tvec3 ta = vec3(0.0);\n\t\n    // Camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0, 1.0, 0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( uv.x*cu + uv.y*cv + 1.7*cw );\n    \n    // Intersect sphere\n    vec3 sect = intersectSphere(ro, rd, vec3(0.0, 0.0, 0.0), 1.0);\n    \n    // Raymarch\n    vec3 col;\n\tif (sect.z < 0.0) col = background(uv);\n    else col = raymarch(ro, rd, sect.xy, uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 176, 268, 268, 695], [697, 697, 718, 718, 754], [756, 756, 780, 780, 1455], [1457, 1457, 1488, 1488, 2463], [2465, 2465, 2492, 2492, 2748], [2750, 2750, 2776, 2776, 3076], [3078, 3078, 3134, 3150, 6177], [6179, 6179, 6236, 6277, 6884]]}
{"id": "ttSXzW", "name": "Hammersley Points", "author": "NadirRoGue", "description": "Test Hammersley points on the sphere", "tags": ["raymarch"], "likes": 4, "viewed": 113, "published": "Public", "date": "1565183764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MARCH_SAMPLES 150\n#define SPHERE_RADIUS 5.0\n#define EPSILON 0.001\n#define ANGLE_STEP 0.5\n\nconst vec3 lightDir = vec3(-1.0, 1.0, 0.0);\nfloat angle = 0.0;\nmat3 rotation;\n\nfloat radicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(uint i, uint N) \n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\nconst float PI = 3.14159265358979;\n\nvec3 hemisphereSample_uniform(float u, float v) \n{\n    float phi = v * 2.0 * PI;\n    float cosTheta = 1.0 - u;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    //return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    float theta = u * 2.0 * PI;\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta) / 2.0);\n}\n\nbool inSphere(in vec3 pos)\n{\n    return length(pos) <= SPHERE_RADIUS;\n}\n\nvec3 correctSpherePos(in vec3 pos)\n{\n \treturn normalize(pos) * (SPHERE_RADIUS + EPSILON);\n}\n\nbool raymarch(in vec3 startPos, in vec3 dir, out vec3 hitPos)\n{\n    float dist = length(startPos) + SPHERE_RADIUS;\n    float stepValue = dist / float(MARCH_SAMPLES);\n    \n    angle += ANGLE_STEP * iTime;\n    float cos0 = cos(angle);\n    float sin0 = sin(angle);\n    \n    vec3 c0 = vec3(cos0, 0, -sin0);\n    vec3 c1 = vec3(0, 1, 0);\n    vec3 c2 = vec3(sin0, 0, cos0);\n    rotation[0] = c0;\n    rotation[1] = c1;\n    rotation[2] = c2;\n    \n    rotation = inverse(rotation);\n        \n\tfor(int i = 0; i < MARCH_SAMPLES; i++)\n    {\n        vec3 pos = startPos + dir * stepValue * float(i);\n        if(inSphere(pos))\n        {\n            hitPos = correctSpherePos(pos);\n         \treturn true;   \n        }\n    }\n    \n    return false;\n}\n\n\nvec3 shadeSample(in vec3 pos)\n{\n    bool closeEnough = false;\n    vec3 tempPos = rotation * pos;\n    for(int i = 0; i < 200 && !closeEnough; i++)\n    {\n   \t\tvec2 uv = hammersley2d(uint(i), 200u);\n        vec3 testPos = normalize(hemisphereSample_uniform(uv.x, uv.y)) * SPHERE_RADIUS;\n        if(length(testPos - tempPos) < 0.08)\n        {\n         \tcloseEnough = true;   \n        }\n    }\n    \n    vec3 color = closeEnough? vec3(1,0,0) : vec3(1,1,0);\n    \n    vec3 normal = normalize(pos);\n    float d = dot(normalize(lightDir), normal);\n    d = clamp(d, 0.0, 1.0);\n    \n    return color * d + color * 0.25; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(45.0));\n    vec3 worldDir = normalize(vec3(xy, -z));\n    \n    const vec3 camPos = vec3(0.0, 0.0, 15.0);\n    \n    vec3 hitPos;\n    if(raymarch(camPos, worldDir, hitPos))\n    {\n    \tfragColor = vec4(shadeSample(hitPos), 1.0);\n    }\n    else\n    {\n    \t// Output to screen\n    \tfragColor = vec4(0,0,0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 216, 216, 620], [622, 622, 658, 658, 719], [757, 757, 807, 807, 1112], [1114, 1114, 1142, 1142, 1185], [1187, 1187, 1223, 1223, 1278], [1280, 1280, 1343, 1343, 2011], [2014, 2014, 2045, 2045, 2623], [2625, 2625, 2682, 2682, 3084]]}
{"id": "WdfGDX", "name": "#EVOKE 2019 Sound Hybrid Mandel", "author": "VJSpackOMat", "description": "use mouse up/down to zoom\n\nhybrid example using the sound channel as offets in the hybrid alternation loop\n\nsound by teo and chromag\n https://soundcloud.com/rocknrolla42/chromag-and-teo-zuckerfrei\n\n", "tags": ["fractalhybrid"], "likes": 6, "viewed": 927, "published": "Public API", "date": "1565967761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hybrid Mandelbrot Example by c.Kleinhuis for evoke 2019 talk\n//\n// Color Setup by by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// this is work in progres for upcoming talk about hybridisation\n\n// Disclaimer\n// \n// This is a hybrid alternate example, from a starting to an ending iteratoin\n// the input of the sound channel is used as an offset inside the iteration loop\n//\n// since the alternation starts only from a certain start to a certain end iteration\n// the initial mandelbrot shape is preserved\n//\n// the mapping of each input frequency results in slight variations\n// \n// example coordinates are entered uncomment them to use them, but make sure commenting all afterwards as well\n// \n// \n\nconst float PI=3.14159265359;\nconst int maxIter=1215;\nconst float maxIterFloat=float(maxIter);\n\nconst int startIteration=20;\nconst int endIteration=120;\n\n// cost intensive rotate, use it for rotating view for the downside bulbs\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m*v;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n     \n    // default\n    vec2 click=vec2(.25,.15);\n    // right above tip (uncomment only this to zoom this area)\n    // click=vec2(.25,.15);\n    // left bulb (uncomment only this to zoom this area)\n    // click=vec2(-1.35,.0);\n    // top small bulb (uncomment only this to zoom this area)\n    click=vec2(-0.1,0.8);\n    // top small left bulb (uncomment only this to zoom this area)\n    //  click=vec2(-0.5,0.6);\n    // top small right bulb (uncomment only this to zoom this area)\n    // click=vec2(0.3,0.5);\n    // bottom small right bulb (uncomment only this to zoom this area)\n    // click=vec2(0.25,-0.55);\n    // bottom small left bulb (uncomment only this to zoom this area)\n    // click=vec2(-0.5,-0.6);\n    \n    \n    vec2 mouse=(-iMouse.xy/iResolution.xy)*2.0f-1.0f;\n    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y; \n        p=rotate(p,0.);\n        float time = iTime; \n    \ttime=1.;\n        float zoo = 0.82 + 0.28*cos(.07*time);\n        zoo=iMouse.x<0.0001f?0.15:iMouse.y/iResolution.y;   \n        vec2 c =  click+p.xy*zoo;// '+ xy*zoo;\n\n        const float B = 256.0;\n        float l = 0.0;\n\t    vec2 z  = vec2(0.0);\n    \n        for( int i=0; i<maxIter; i++ )\n        {\n\n            \n\n            // z = z*z + c\t\t\n    \t\tz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\n            \n            if(i>startIteration && i<endIteration){\n               /*\n\t\t\t\tlets sample from the input fourier values (todo: get sampling rate/subdivision right)\n\t\t\t\t\n\t\t\t\t*/  \n                float iPos= float(i-startIteration)/float(endIteration-startIteration); \n\t\t\t\tcol.x=sin(iPos*PI*100.+iTime )*.1;\n             \tcol.y=cos(iPos*PI*10.+iTime )*.1;\n                \n                /*\n\n\t\t\t\t\tsince sample rate is 1-dimensional, but we have a 2dimensional complex value,\n\t\t\t\t\tlets use a timed arrrow rotating as direction ...\n\t\t\t\t*/\n                float value=texture(iChannel0,vec2(float(i)/float(maxIter))).r;\n                \n                \n                // this just offsets from audio per iteration - rather linear\n                 z.x+= value*value*.15  ;\n                 z.y-=  value*value*.15   ;\n                \n                // use this to make rotational direction \n                 //z.x+= col.x*value*value*.15  ;\n                 //z.y-= col.x*value*value*.15   ;\n            }\n                if( dot(z,z)>(B*B) ) break;\n\n    \t\tl += 1.0;\n        }\n\n    \t// ------------------------------------------------------\n        // smooth interation count\n    \t//float sl = l - log(log(length(z))/log(B))/log(2.0);\n         \n\n        col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));\n \n\n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGDX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[923, 997, 1027, 1027, 1109], [1112, 1112, 1169, 1169, 3858]]}
{"id": "wdjSzc", "name": "Ray Marching Torus with glow", "author": "pavleeto", "description": "Torus", "tags": ["raymarching"], "likes": 3, "viewed": 313, "published": "Public", "date": "1567100672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 eye = vec3(0.0, 0.0, 10.0);\nvec3 front = vec3(0.0, 0.0, -1.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nfloat fov = radians(45.0);\n\nfloat minDist = 1e-3;\nint maxSteps = 0xFF;\n\n\nfloat distEstimate(vec3 p)\n{\n    vec2 t = vec2(0.5, 0.10);\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nvec3 getRay(vec2 uv, float aspect)\n{\n    uv.y = (1.0 - uv.y);\n    vec3 right = cross(up, front);\n    vec2 coeffs = tan(-fov/2.0 + uv * fov);\n    coeffs.y *= aspect;\n    \n    return normalize(front + right*coeffs.x + up*coeffs.y);\n}\n\nvec3 rayMarch(vec2 uv, float aspect)\n{\n    vec3 dir = getRay(uv, aspect);\n    \n    int steps = 0;\n    float total = 0.0;\n    float glowDist = 1e9;\n    while (steps++ < maxSteps)\n    {\n        vec3 pos = eye + total * dir;\n        float dist = distEstimate(pos);\n        glowDist = min(glowDist, dist);\n        total += dist;\n        if (dist < minDist) break;\n    }\n    if (distEstimate(eye + total * dir) < minDist)\n    {\n        \n        float col = (1.0 - float(steps)/float(maxSteps));\n        return vec3(col, 0.0, 0.0);\n    }\n    else\n    {\n        return vec3(max((0.05 - glowDist)*20.0, 0.0));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    eye.y = sin(iTime/5.0);\n    eye.x = cos(iTime/5.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;    \n    \n    // Output to screen\n    fragColor = vec4(rayMarch(uv, aspect), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 200, 200, 298], [300, 300, 336, 336, 531], [533, 533, 571, 571, 1142], [1145, 1145, 1202, 1202, 1487]]}
{"id": "wl2SD1", "name": "RayMarching learn #3", "author": "dnkorbut", "description": "learning lighting", "tags": ["raymarching", "lighting"], "likes": 1, "viewed": 79, "published": "Public", "date": "1565809159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH 640\n#define MAX_DST 100.\n#define MIN_DST .01\n#define AMBIENT_DST .1\n\n#define OBJ_PLANE .5\n#define OBJ_SPHERE .51\n\n#define OBJECTS 8\n\nmat4 obj[OBJECTS];\n\n// globals\nvec3 p;\nint o;\nfloat deltaDst;\n\nvec3 getNor(int o, vec3 p) {\n    if(obj[o][3][3] < OBJ_SPHERE) {\n        return obj[o][2].xyz;\n    }else{\n    \treturn normalize(p - obj[o][0].xyz);\n    }\n}\n\nfloat getDistance(vec3 p) {\n    float min = 255.;\n    float res;\n    for(int c = 0; c < OBJECTS; c++) {\n        \n        if(obj[c][3][3] < OBJ_SPHERE) {\n            res = abs(p.y - obj[c][0][1]); // plane\n        }else{\n            res = length(p - obj[c][0].xyz) - obj[c][0].w; // sphere\n        }\n        \n        if(min > res) {\n            deltaDst = min - res;\n            min = res;\n            o = c;\n        }\n        \n    }\n    return min;\n}\n\nfloat rayMarch(vec3 start, vec3 dir) {\n    float ret = 0.;\n    int i;\n    float dst;\n    \n    for(i = 0; i < MAX_MARCH; i++) {\n        p = start + dir * ret;\n        dst = getDistance(p);\n        ret += dst;\n        if(ret > MAX_DST || dst < MIN_DST) {\n           break; \n        }\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // light\n    vec3 light = vec3(sin(iTime) * 10., 6., cos(iTime) * 10. + 10.);\n    vec3 light2 = vec3(sin(iTime + 3.14) * 10., 6., cos(iTime + 3.14) * 10. + 10.);\n    \n    // camera\n    vec3 cam = vec3(0., 1., 0.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // objects\n    obj[0][0] = vec4(0., .2, 0., 0.); // infinite plane at zero Y\n    obj[0][1] = vec4(.5, .5, .5, 1.);\n    obj[0][2] = vec4(0., 1., 0., 0.);\n    obj[0][3][3] = OBJ_PLANE;\n    \n    obj[1][0] = vec4(0., 1., 6., 1.); // red sph\n    obj[1][1] = vec4(1., 0., 0., 1.);\n    obj[1][3][3] = OBJ_SPHERE;\n    \n    obj[2][0] = vec4(1.5, 0.8, 6., 0.8); // blue sph\n    obj[2][1] = vec4(0., 0., 1., 1.);\n    obj[2][3][3] = OBJ_SPHERE;\n    \n    obj[3][0] = vec4(-1.5, 0.8, 6., 0.8); // green sph\n    obj[3][1] = vec4(0., 1., 0., 1.);\n    obj[3][3][3] = OBJ_SPHERE;\n    \n    obj[4][0] = vec4(0., .4, 2., .4); // yellow sph\n    obj[4][1] = vec4(1., 1., 0., 1.);\n    obj[4][3][3] = OBJ_SPHERE;\n    \n    obj[5][0] = vec4(1.5, 0.6, 3., 0.6); // magenta sph\n    obj[5][1] = vec4(1., 0., 1., 1.);\n    obj[5][3][3] = OBJ_SPHERE;\n    \n    obj[6][0] = vec4(-1.5, 0.6, 3., 0.6); // cyan sph\n    obj[6][1] = vec4(0., 1., 1., 1.);\n    obj[6][3][3] = OBJ_SPHERE;\n    \n    obj[7][0] = vec4(0., 7., 0., 0.); // infinite plane at 7 Y\n    obj[7][1] = vec4(.5, 1., .5, 1.);\n    obj[7][2] = vec4(0., -1., 0., 0.);\n    obj[7][3][3] = OBJ_PLANE;\n    \n    for(int i = 0; i < OBJECTS; i++) {\n        //obj[i][0].x *= cos(iTime);\n        //obj[i][0].z *= sin(iTime);\n    }\n    \n    float dst = rayMarch(cam, dir);\n    \n    dir = normalize(light - p);\n    vec3 nor = getNor(o, p);\n    \n    vec3 dir2 = normalize(light2 - p);\n    \n    float colMul = clamp(dot(dir, nor), 0.3, 0.5);\n    float colMul2 = clamp(dot(dir2, nor), 0.3, 0.5);\n    float ambient = 1.;\n    \n    if(deltaDst < AMBIENT_DST) {\n        ambient = deltaDst / AMBIENT_DST;\n    }\n    \n    vec4 c = obj[o][1];\n    vec3 collisionP = p;\n    int collisionO = o;\n    \n    float shadow = rayMarch(p + (nor * MIN_DST * 2.), dir);\n    \n    if(shadow < length(light - p)) {\n        colMul *= .9;\n    }\n    \n    \n    shadow = rayMarch(p + (nor * MIN_DST * 2.), dir2);\n    \n    if(shadow < length(light2 - p)) {\n        colMul *= .9;\n    }\n    \n    nor = normalize(reflect(collisionP - cam, nor));\n    if(rayMarch(collisionP + (nor * MIN_DST * 2.), nor) < 10.) {\n    \tc = obj[o][1] + (obj[collisionO][1] * .5);\n    }\n    \n    vec4 c2 = c;\n    c2.rgb *= colMul2;\n    c.rgb *= colMul;\n    \n    fragColor = (c + c2) * ambient;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2SD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 214, 242, 242, 369], [371, 371, 398, 398, 821], [823, 823, 861, 861, 1128], [1130, 1130, 1185, 1236, 3827]]}
{"id": "wl2SRm", "name": "Menger Street", "author": "Hirai_worthless", "description": "aaa", "tags": ["raymarching"], "likes": 6, "viewed": 463, "published": "Public", "date": "1565479015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\nfloat menger(vec3 p,vec3 o,float l){\n    p = p - o;\n    float result = max(abs(p.x),max(abs(p.y),abs(p.z)))- l/2.0;\n    for(int i = 0; i < 4; i++){\n        p *= 3.;\n    \tfloat a = max(abs(p.x),abs(p.y)) - l/2.;\n        float b = max(abs(p.y),abs(p.z)) - l/2.;\n    \tfloat c = max(abs(p.z),abs(p.x)) - l/2.;\n        float hole = min(a,min(b,c));\n        result = max(result,-hole);\n        p = fract(p/l) * l;\n        p -= l;\n        \n\n    }\n\treturn result;\n}\nfloat map(vec3 p){\n\tfloat h = -3. + cos(p.x/2.) * 0.5 + cos(p.z/2.) * 0.5;\n    h += sin(p.x /8.) * 3.;\n    h -= sin(p.z /8.) * 3.;\n    float ground = p.y - h;\n    vec3 q = p;\n    float towerHeight = q.y - floor(h) - 10.;\n    q.x = fract(q.x /8. + 0.5) * 8. - 4.;\n    q.z = fract(q.z /6. + 0.5) * 6. - 3.;\n    q.y = fract(q.y /3.0 + 0.5) * 3.0 - 1.5;\n    float me = menger(q,vec3(0.),3.0);\n    me = max(me,towerHeight);\n    return min(ground,me);\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n    float time = iTime * 4.0;\n\treturn vec3(4.,1.-sin(-5./8. + time/8.) * 3.,-5.0 + time);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.xy *= genRot(PI / 8.);\n    ray.xz *= genRot(PI / 8.);\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 256; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.005);\n    float a = dot(data.xyz,r);\n    vec3 p = o + r * t;\n    vec3 fc = min(fract(p.x),fract(p.z))<0.03 || abs(p.x - 4.) < 1. || fract(p.z / 6. - 0.4) < 0.2 ? vec3(0.95) : vec3(0.05);\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    fc = mix(vec3(0.95),fc,fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2SRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 369, 369, 443], [445, 445, 471, 471, 654], [657, 671, 707, 707, 736], [738, 738, 776, 776, 805], [807, 807, 840, 840, 987], [989, 989, 1032, 1032, 1188], [1191, 1207, 1243, 1243, 1664], [1665, 1665, 1683, 1683, 2112], [2114, 2132, 2156, 2156, 2408], [2410, 2430, 2451, 2451, 2543], [2545, 2559, 2586, 2586, 2701], [2703, 2718, 2746, 2746, 2946], [2948, 2963, 3002, 3002, 3398], [3400, 3411, 3468, 3485, 3837]]}
{"id": "wl2SWG", "name": "152ch - Shifting Squares", "author": "iapafoto", "description": "Code golfed version of sfaer shader Shifting Squares -  https://www.shadertoy.com/view/ttSSWy  \n", "tags": ["square", "2tweet", "golf"], "likes": 5, "viewed": 163, "published": "Public", "date": "1566997256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code golfed [sfaer] Shifting Squares - https://www.shadertoy.com/view/ttSSWy\n// ----------------------------\n//  sfaer\n//  FabriceNeyret2\n//  Xor\n//  iapafoto\n//\n// ----------------------------\n//    variant 159ch!!! (other approch, black white, no antialising)\n// ----------------------------\n//  Xor\n//  FabriceNeyret2\n//  iapafoto\n// ----------------------------\n\n// iapafoto -5ch => 147ch (remove S var)\n// does not works on Linux :/\n/*\nvoid mainImage(out vec4 o, vec2 i)\n{\n    o = cos(iTime + vec4(3,14,36,3));\n    o += dot(abs((mod(12.*i / iResolution.y + (i=sign(o.xx*o.y)),4.)-2.) * mat2(o))-1., i) /.1 - o;\n}\n*/\n\n// Xor -8ch \nvoid mainImage(out vec4 o, vec2 i)\n{\n    o = cos(iTime + vec4(3,14,36,3));\n    vec2 S = sign(o.xx*o.y);\n    o += dot(abs((mod( 12.*i / iResolution.y + S,4.)-2.) * mat2(o))-1.,S ) /.1 - o;\n}\n/*\n\n// 160ch (xor + Fabrice + iapafoto)\n// => black background\n\nvoid mainImage(out vec4 f, vec2 l)\n{\n    f = cos(iTime + vec4(3,14,36,3));\n    vec2 G = sign(f.xx*f.y),\n         o = abs((mod(G + 12.*\n         l / iResolution.y,4.)-2.) * mat2(f));\n         f = (G*(--o+o.x)).yyyy/.1;\n} /*\n\n/*\n// Xor -4ch black magic \nvoid mainImage(out vec4 f, vec2 l) {\n    vec2 G = step(.7, f = cos(mod(iTime,3.14) + vec4(7,18,-4,7))).yy-.5,\n         o = (mod(G + 6.*\n         l / iResolution.y,2.)-1.) * mat2(f)/.1;\n         f = max((max(o*o,o.x*o.x)-50.)*G,.25).yyyy;\n} /*\n\n//----------------------\n// FabriceNeyret2 174ch version\n//    -1: 8.56 => 8.6\n//    -2: o = step(8.6, G =  ).ww\n//----------------------\n\nvoid mainImage(out vec4 f, vec2 U) {\n    vec2 G = step(8.6, f = mod(iTime,3.14) + vec4(7,18,-4,7)).ww,\n         o = 7.*(mod(G + 6.*U/iResolution.y,2.)-1.) * mat2(cos(f)),\n  \t     l = clamp(25.-o*o,0.,1.);\n         f = .15 + abs(l.x*l-G).yyyy; }\n\n\n// https://twigl.app\n// vec2 G=step(8.6,o=mod(t,3.14)+vec4(7,18,-4,7)).ww,A=7.*(mod(G+6.*FC.xy/r.y,2.)-1.)*mat2(cos(o)),l=clamp(25.-A*A,0.,1.);o=abs(l.x*l-G).yyyy;\n\n\n//  G += cos(f.x*f-o).y - G (170ch light gray variant)\n//  G.wx = abs(f.x*f-o)  (168 ch red variant)\n\n//----------------------\n// FabriceNeyret2 177ch version\n//    -4: o = step(2.36,G.ww)\n//    -3: G = mod(iTime,3.14) + vec4(7,18,-4,7);  (.79 => .8)\n//----------------------\n\n#define mainImage(G, U)\\\n         G = mod(iTime,3.14) + vec4(7,18,-4,7); \\\n    vec2 o = step(8.56,G.ww),                    \\\n         l = 7.*(mod(o + 6.*U/iResolution.y,2.)-1.) * mat2(cos(G)), \\\n  \t     f = clamp(25.-l*l,0.,1.);               \\\n    G = .15 + abs(f.x*f-o).yyyy/*\n\n//----------------------\n// Xor 184ch version\n//   -3: by using mod and remove multiplications)\n//----------------------\n\n#define mainImage(G, U)\\\n         G = mod(iTime,3.14) + .79 - vec4(0,33,11,0); \\\n    vec2 o = U-U + step(G.w,2.36), \\\n         l = 7.*(mod(o + 6.*U/iResolution.y,2.)-1.) * mat2(cos(G)), \\\n  \t     f = clamp(25.-l*l,0.,1.); \\\n    G += .15 + abs(f.x*f-o).y - G/*\n\n\n//----------------------\n// iapafoto 187ch version \n//----------------------\n\n#define mainImage(G, U)\\\n         G = mod(iTime,3.14) + .79 - vec4(0,33,11,0); \\\n    vec2 o = U-U + step(G.w,2.36), \\\n         l = 14.*( fract(.5*o + 3.*U/iResolution.y)-.5 ) * mat2(cos(G)), \\\n  \t     f = clamp(25.-l*l,0.,1.); \\\n    G += .15 + abs(f.x*f-o).y - G/*\n        \n\n\n// ********************************************************************************** //\n//              =============================================\n//                         xavierseb  Variant\n//              =============================================\n// ********************************************************************************** //\n\n     \n//----------------------\n// FabriceNeyret2 159ch version \n// -2: replace c by t: mat2(t=cos(t),b,-b,t) )\n// -1: line * 2. the replace ?1:0 by step(.7,b)\n//----------------------\n\n#define mainImage(O,u)                                        \\\n    float t = mod(iTime,3.14),b = sin(t);                     \\\n    O += dot(step(.71, abs( ( mod(12.*u/iResolution.x-step(.7,b), 2. ) -1. ) \\\n                            * mat2(t=cos(t),b,-b,t) ) ), u ); \\\n    b < .7 ? O = 1. - O :O\n\n//----------------------\n// xavierseb 162ch version \n//----------------------\n\n#define mainImage(O,u)                 \\\n    float t = mod(iTime,3.14),b = sin(t), c = cos(t);          \\\n    O += dot(step(.355, abs( ( fract(4.*u/iResolution.x-(b>.7?.5:1.) ) -.5 ) \\\n                            * mat2(c,b,-b,c) ) ),u); \\\n    b<.7? O = 1. - O :O/*\n\n         \n\n// ********************************************************************************** //     \n//              =============================================\n//                     Variant - no adapted to screen resize\n//              =============================================\n// ********************************************************************************** //\n\n// 145ch \n#define mainImage(O,u)                                        \\\n    float t = mod(iTime,3.14),b = sin(t);                     \\\n    O += dot(step(.71, abs( ( mod(u/70.-step(.7,b), 2. ) -1. ) \\\n                            * mat2(t=cos(t),b,-b,t) ) ), u ); \\\n    b < .7 ? O = 1. - O : O\n\n// 155ch (gray whith antialisasing)\n#define mainImage(G, U)                                             \\\n    vec2 o = step(8.6, G = mod(iTime,3.14) + vec4(7,18,-4,7)).ww,   \\\n         l = 7.*(mod(o + U/60.,2.)-1.) * mat2(cos(G)), \\\n  \t     f = clamp(25.-l*l,0.,1.);                                  \\\n    G.wy = cos(f.x*f-o)/*\n\n*/\n             \n             ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2SWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 638, 674, 674, 827]]}
{"id": "wl2SWy", "name": "Eclipse 2D", "author": "Amaranth", "description": "eclipse simulation", "tags": ["2d", "eclipse"], "likes": 9, "viewed": 99, "published": "Public", "date": "1567020401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DAY_COLOR vec3(0.2, 0.3, 0.5)\n#define NIGHT_COLOR vec3(0.1,0.1,0.1)\n#define SUN_COLOR vec3(1.2, 1.1, 0.9)\n#define MOON_COLOR vec3(0.0, 0.0, 0.0)\n\n#define SUN_RADIUS 0.1\n#define MOON_RADIUS 0.09\n\nvec3 skyColor(float distMoonSun)\n{\n\treturn mix(NIGHT_COLOR, DAY_COLOR, smoothstep(0.0, 1.0, distMoonSun / 0.22));\n}\n\nfloat rand(float seed)\n{\n    float val = 0.0;\n    \n    for (int i = 0; i < 5; i++)\n    {\n        val += 0.240 * float(i) * sin(seed * 0.68171 * float(i));\n    }\n    return val;\n}\n\nvec3 baseColor(float distMoonSun, float distFromSun, float distFromMoon, vec2 fragCoord)\n{\n\tvec3 col = vec3(0);\n    if (distFromMoon < MOON_RADIUS)\n    {\n        col = MOON_COLOR;\n    }\n    else if (distFromSun < SUN_RADIUS)\n    {\n        col = SUN_COLOR;\n    }\n    else\n    {\n        col = skyColor(distMoonSun);;\n\t\t\n\t\tvec2 star = fragCoord;\n\t\tif (rand(star.y * star.x) >= 2.12 && rand(star.y + star.x) >= 0.8)\n\t\t{\n\t\t\tvec3 starCol = mix(vec3(2.0,2.0,2.0), DAY_COLOR, smoothstep(0.0,1.0, distMoonSun / 0.14));\n\t\t\tcol = max(col, starCol);\n\t\t}\n    }\n\treturn col;\n}\n\nvec3 rayColor(vec2 vecMoonSun, vec2 vecFromSun, float distMoonSun, float distFromSun)\n{\n\tvec3 skyCol = skyColor(distMoonSun);\n\t\n    vec2 unit = vecFromSun / distFromSun; // unit vec\n    vec2 norm = vec2(-unit.y, unit.x);\n\t\n\tvec3 col = vec3(0);\n\t// ray traverses moon\n    if ((abs(dot(norm, vecMoonSun)) < MOON_RADIUS && dot(vecFromSun, vecMoonSun) > 0.0) || distMoonSun < MOON_RADIUS)\n    {\n        float proj = dot(unit, vecMoonSun);\n        float delta = sqrt(MOON_RADIUS * MOON_RADIUS - distMoonSun * distMoonSun + proj * proj);\n\t\tvec2 root = clamp(vec2(proj - delta, proj + delta), vec2(0.0), vec2(distFromSun));\n        float radius = min(SUN_RADIUS, distFromSun);\n        col = (clamp(root.x, 0.0, radius) + max(radius - root.y,0.0)) * SUN_COLOR +            \n            ((distFromSun - clamp(root.y, radius, distFromSun)) + max(root.x - radius,0.0)) * skyCol +\n            (root.y - root.x) * MOON_COLOR;\n    }\n    else\n    {        \n    \tcol = max(distFromSun - SUN_RADIUS, 0.0) * skyCol + min(distFromSun, SUN_RADIUS) * SUN_COLOR;\n    }\n\tcol /= distFromSun;\n\t\n\t// apply attenuation based on squared distance\n\tcol *= 1.0 / (40.0 * max(0.01, distFromSun * distFromSun));\n\t\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalize and center fragment coordinates\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 sun = vec2(0.118);\n    vec2 moon = sun - cos(iTime * 0.6) * vec2(0.11, 0.07);\n    // mouse debug mode\n    //moon = iMouse.xy / iResolution.xy - 0.5;\n    vec2 pos = fragCoord / iResolution.xy - 0.5;\n    \n    sun.x *= aspect;\n    moon.x *= aspect;\n    pos.x *= aspect;    \n    \n    vec2 vecMoonSun = moon - sun;\n\tvec2 vecFromSun = pos - sun;\n\tvec2 vecFromMoon = pos - moon;\n\t\t\n\tfloat distMoonSun = length(vecMoonSun);\n\tfloat distFromSun = length(vecFromSun);\n\tfloat distFromMoon = length(vecFromMoon);\n\t\n    vec3 rayCol = rayColor(vecMoonSun, vecFromSun, distMoonSun, distFromSun);\n    vec3 baseCol = baseColor(distMoonSun, distFromSun, distFromMoon, fragCoord);\n    \n    fragColor = vec4(baseCol + rayCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2SWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 237, 237, 318], [320, 320, 344, 344, 498], [500, 500, 590, 590, 1062], [1064, 1064, 1151, 1151, 2259], [2261, 2261, 2316, 2365, 3142]]}
{"id": "wl2Szd", "name": "[twitch] Misty Grid", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/MistyGrid.glsl", "tags": ["3d", "raymarching", "translucency", "xray", "mist"], "likes": 65, "viewed": 1605, "published": "Public", "date": "1566855122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat time;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nvec3 fr(vec3 p, float t) {\n\n  //float s = 1.0 - exp(-fract(time*1.0))*0.8;\n  float s = 0.7 - smoothstep(0.0,1.0,abs(fract(time*0.1)-0.5)*2.0)*0.3;\n  for(int i=0; i<5; ++i) {\n    \n    float t2=t+float(i);\n    p.xy *= rot(t2);\n    p.yz *= rot(t2*.7);\n    \n    float dist = 10.0;\n    p=(fract(p/dist-.5)-.5)*dist;\n    p=abs(p);\n    p-=s;\n    \n  }\n  \n  return p;\n}\n\nfloat at = 0.;\nfloat at2 = 0.;\nfloat at3 = 0.;\nfloat map(vec3 p) {\n  \n  \n  vec3 bp=p;\n  \n  p.xy *= rot((p.z*0.023+time*0.1)*0.3);\n  p.yz *= rot((p.x*0.087)*0.4);\n  \n  float t=time*0.5;\n  vec3 p2 = fr(p, t * 0.2);\n  vec3 p3 = fr(p+vec3(5,0,0), t * 0.23);\n  \n  float d1 = box(p2, vec3(1,1.3,4));\n  float d2 = box(p3, vec3(3,0.7,0.4));\n  \n  float d = max(abs(d1), abs(d2))-0.2;\n  float dist = 1.;\n  vec3 p4=(fract(p2/dist-.5)-.5)*dist;\n  float d3 = box(p4, vec3(0.4));\n  //d = max(d, -d3);\n  d = d - d3*0.4;\n  \n  //d = max(d, length(bp)-15);\n  \n  \n  //float f=p.z + time*4;\n  //p.x += sin(f*0.05)*6;\n  //p.y += sin(f*0.12)*4;\n  //d = max(d, -length(p.xy)+10);\n  \n  at += 0.13/(0.13+abs(d));\n  \n  float d5 = box(bp, vec3(4));\n  \n  float dist2 = 8.;\n  vec3 p5=bp;\n  p5.z = abs(p5.z)-13.;\n  p5.x=(fract(p5.x/dist2-.5)-.5)*dist2;\n  float d6 = length(p5.xz)-1.;\n  \n  at2 += 0.2/(0.15+abs(d5));\n  at3 += 0.2/(0.5+abs(d6));\n  \n  return d;\n}\n\nvoid cam(inout vec3 p) {\n  \n  float t=time*0.1;\n  p.yz *= rot(t);\n  p.zx *= rot(t*1.2);\n}\n\nfloat rnd(vec2 uv) {  \n  return fract(dot(sin(uv*752.322+uv.yx*653.842),vec2(254.652)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n  time = iTime * 1.0 + 137.0;\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float factor = 0.9 + 0.1*rnd(uv);\n  //factor = 1;\n\n  vec3 s=vec3(0,0,-15);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  int i=0;\n  \n  for(i=0; i<80; ++i) {\n    float d=abs(map(p));\n    d = abs(max(d, -length(p-s)+6.));\n    d *= factor;\n    if(d<0.001) {\n      d = 0.1;\n      //break;\n    }\n    p+=r*d;\n  }\n  \n  vec3 col=vec3(0);\n  //col += pow(1-i/101.0,8);\n  \n  vec3 sky = mix(vec3(1,0.5,0.3), vec3(0.2,1.5,0.7), pow(abs(r.z),8.));\n  sky = mix(sky, vec3(0.4,0.5,1.7), pow(abs(r.y),8.));\n  \n  //col += at*0.002 * sky;\n  col += pow(at2*0.008, 1.) * sky;\n  col += pow(at3*0.072, 2.) * sky * vec3(0.7,0.3,1.0) * 2.;\n  \n  col *= 1.2-length(uv);\n  \n  col = 1.0-exp(-col*15.0);\n  col = pow(col, vec3(1.2));\n  col *= 1.2;\n  //col += 0.2*sky;\n  \n  //col = vec3(rnd(uv));\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2Szd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 34, 34, 105], [107, 107, 134, 134, 183], [185, 185, 211, 259, 545], [594, 594, 613, 613, 1477], [1479, 1479, 1503, 1503, 1568], [1570, 1570, 1590, 1590, 1660], [1662, 1662, 1719, 1719, 2730]]}
{"id": "wl2SzR", "name": "Caustic Amoebas", "author": "Mipmap", "description": "Another riff on 'Flow of cells', with more of a caustics effect.", "tags": ["2d", "animation", "curve", "organic", "cell", "art", "caustic"], "likes": 15, "viewed": 774, "published": "Public API", "date": "1564860912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweak #2 of sben's 'Flow of cells' (https://www.shadertoy.com/view/MlsGWX)\n#define FIELD 10.0\n#define HEIGHT 0.7\n#define ITERATION 2.0\n#define TONE vec4(.2,.4,.8,0)\n#define SPEED 0.5\n\nfloat eq(vec2 p,float t){\n\tfloat x = sin( p.y-t +cos(t+p.x*.8) ) * cos(p.x-t);\n\tx *= acos(x);\n\treturn - x * abs(x-.05) * p.x/p.y*4.9;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec4 X=O;\n\tvec2  p = FIELD*(U / iResolution.xy  +.9);\n\tfloat t = iTime*SPEED,\n          hs = FIELD*(HEIGHT+cos(t)*1.9),\n\t      x = eq(p,t), \n          y = p.y-x*0.1;\n    \n\tfor(float i=0.; i<ITERATION; ++i)\n\t\tp.x *= 1.5,\n        X = x + vec4(0, eq(p,t+i+1.), eq(p,t+i+2.) ,0),\n        x = X.z += X.y,\n        O += TONE / abs(y-X-hs);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2SzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 187, 212, 212, 322], [324, 324, 362, 362, 701]]}
{"id": "wl2XRD", "name": "Tapioca_Wave", "author": "Hirai_worthless", "description": "wave", "tags": ["practice"], "likes": 4, "viewed": 131, "published": "Public", "date": "1565286656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\nfloat dist_1(vec2 p){\n    float wave0 = p.y + 0.8 - 0.15 * cos(p.x * 5.0) * cos(iTime * 2.0);\n\tfloat wave1 = p.y + 0.3 - 0.15 * cos(p.x * 5.0) * cos(iTime * 2.0);\n    float wave2 = p.y - 0.3 - 0.15 * cos(p.x * 5.0) * cos(iTime * 2.0);\n    float wave3 = p.y - 0.8 - 0.15 * cos(p.x * 5.0) * cos(iTime * 2.0);\n    return min(min(wave0,-wave3),max(-wave1,wave2));\n    \n}\nfloat dist_2(vec2 p){\n    float result = 100000.0;\n    for(float xi = -3.0; xi < 3.0; xi += 0.1){\n        for(float yi = -3.0; yi < 3.0; yi += 0.1){\n            vec2 tmp = vec2(xi+fract(cos(yi * 3.0)*iTime / 4.),yi);\n        \tfloat r = 0.04 - max(dist_1(tmp),0.00);\n            result = min(result,circle(p,tmp,r));\n        }\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = dist_2(uv) > 0. ? vec3(252,193,121)/255. : vec3(159,101,101)/255.;\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2XRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 65], [66, 66, 87, 87, 432], [433, 433, 454, 454, 785], [786, 786, 843, 843, 1046]]}
{"id": "wl2XRK", "name": "KIFS experiments", "author": "rodgzilla", "description": "Experiment with kaleidoscopic iterated function system.", "tags": ["raymarching", "kifs"], "likes": 6, "viewed": 173, "published": "Public", "date": "1566470703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nfloat PI = acos(-1.);\n\nvec3 palette(float x) {\n  float wave = sin(3. * time) * 0.5 + 0.5;\n  vec3 p = vec3(1, 1, 1);\n  vec3 q = vec3(.3, .6, 1);\n  vec3 r = vec3(.3, .6, .3);\n  vec3 s = vec3(.9, .5, .3);\n  \n  return p + q * sin(2. * PI * (x * r + s));\n}\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n\n  return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n  float t = tf * time;\n\n  for (float i = 0.; i < 6.; i++) {\n    p.xy *= rot2d(t + i);\n    p.xz *= rot2d(t * 0.6 - i);\n    p = abs(p);\n    p -= s;\n    s *= 0.8 + .1 * sin(2.8 * time);\n  }\n\n  return p;\n}\n\nfloat map(vec3 p) {\n  float d = 10000.;\n\n\t\n  p.xy *= rot2d(sin(.3 * time) * p.z / 40.);\n  vec3 rep = vec3(20);\n  p = mod(p, rep) - 0.5 * rep;\n\n  vec3 pc = kifs(p, 1., .3);\n  vec3 pe = kifs(p, 1.05, .1);\n\n  d = min(d, length(pc) - 1.);\n  d = max(d, -(length(pe) - .8));\n\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, -20);\n    vec3 rd = normalize(vec3(uv, 1));\n\n    float d = 0.;\n    int i;\n    for (i = 0; i < 100; i++) {\n      vec3 p = ro + d * rd;\n      float ds = map(p);\n\n      if (ds < 0.01 || ds > 100.) {\n        break;\n      }\n\n      d += ds / 2.;\n    }\n    vec3 p = ro + d * rd;\n    vec2 e = vec2(0.01, 0);\n    vec3 n = normalize(map(p) - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx)));\n    vec3 l = vec3(0, 0, -50);\n    float dif = dot(n, normalize(l - p));\n\n    vec3 col = vec3(dif * palette(p.z / 50.));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2XRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 270], [272, 272, 293, 293, 356], [358, 358, 396, 396, 598], [600, 600, 619, 619, 883], [885, 885, 942, 942, 1648]]}
{"id": "Wl2XRz", "name": "rounded pentagone", "author": "xigh", "description": "2d experiments... should be self explained...", "tags": ["2d", "circle", "rounded", "pentagone"], "likes": 2, "viewed": 53, "published": "Public", "date": "1564829016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p,float a) \n{\n\treturn cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nconst float pi = 3.1415;\nconst float tau = pi * 2.0;\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand2(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(float(r)/256.0, float(g)/256.0, float(b)/256.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    vec3 col1 = 2.0*rgb(52, 20, 5);\n    vec3 col2 = 2.0*rgb(3, 3, 50);\n    // vec3 col3 = 2.0*rgb(1, 1, 24);\n    \n    float speed = 0.6;\n\n    uv = rotate(uv, iTime*speed);\n    \n    float radius = .5;\n    float size = 0.06;\n    \n    float angle = atan(uv.y, uv.x);\n    \n    uint count = 5u;\n    \n    float disp = sin(angle*float(count));\n    \n    float dist = length(uv) + disp / 48.0;\n    \n    float sigma = abs(dist-radius);\n    \n    float tor = smoothstep(size, size+0.01, sigma);\n    vec3 col = mix(col2, col1, tor);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2XRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 72], [128, 197, 218, 218, 287], [289, 289, 320, 320, 387], [389, 389, 445, 445, 1107]]}
{"id": "Wl2XWG", "name": "Colors from Grid", "author": "gressettd", "description": "Playing with the idea of pattern functions providing \"color control\", eg different perspectives on the same pattern, to drive color mapping. In this case, the simplest pattern of all, the grid.", "tags": ["grid"], "likes": 1, "viewed": 55, "published": "Public", "date": "1566949752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float gridSize = 3.0;\nconst float penSize = 15.0;\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\nvec4 ComputeGridPattern(\n\tvec2 p,\n\tfloat pen, \n\tfloat scale,\n\tfloat maxRes\n\t)\n{\n\tp *= scale;\n\tpen *= scale / maxRes;\n\tvec2 cell = floor(p);\n\tvec2 cellCoords = p - cell;\n\n\tvec2 d = abs(cellCoords) - vec2(1, 1);\n\tfloat edgeDistance = length(max(d, vec2(0, 0))) + min(max(d.x, d.y), 0.0);\n\tfloat annularDistance = abs(edgeDistance) - pen / 2.0;\n\t\n\tfloat intensity = 1.0 - step(0.0, annularDistance);\n\treturn vec4(intensity, annularDistance, cellCoords.x, cellCoords.y);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= float(iResolution.x) / float(iResolution.y);\n\n    float maxRes = max(float(iResolution.x), float(iResolution.y));\n    \n    float tm = iTime * 0.5;\n    \n    \n    vec4 pattern = ComputeGridPattern(uv + (iTime * 0.01), penSize, gridSize + (4.0 * (sin(iTime * .30)+1.0)), maxRes);\n        \n    vec4 bias = vec4(0.350,0.906,0.689,1.0);\n    vec4 scale = vec4(0.772,0.114,0.263,1.0);\n    vec4 freq = vec4(0.077,0.368,1.016,1.0);\n    vec4 phase = vec4(3.859,3.252,5.857,1.0);\n    \n    \n    vec4 baseColor = ComputeWaveGradientRGB(sin(pattern.x + tm),bias,scale, freq, phase);\n\tvec4 accent0 = ComputeWaveGradientRGB(cos(pattern.y + tm),bias,scale, freq, phase);\n    vec4 accent1 = ComputeWaveGradientRGB(fract(pattern.z*tm * tan(tm)),bias,scale, freq, phase);\n    vec4 accent2 = ComputeWaveGradientRGB(fract(pattern.w*tm* sin(tm)),bias,scale, freq, phase);\n    \n    \n    vec4 finalColor = (baseColor * accent0 * accent1 * accent2);\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2XWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 141, 141, 245], [248, 248, 327, 327, 717], [722, 722, 779, 829, 1834]]}
{"id": "Wl2XWR", "name": "cloud-math", "author": "lilieming", "description": "just coding", "tags": ["cloudmathdraw"], "likes": 4, "viewed": 155, "published": "Public", "date": "1565590803", "time_retrieved": "2021-10-01T00:00:00", "image_code": " vec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\n   vec4 mod289(vec4 x) { \n    return x - floor(x * (1. / 289.)) * 289.;\n}\n vec4 permute(vec4 x) { \n     return mod289(((x*34.)+1.)*x); \n }\n vec4 taylorInvSqrt(vec4 r) { \n     return 1.79284291400159 - .85373472095314 * r;\n }\n  vec3 fade(vec3 t) {\n      return t*t*t*(t*(t*6.-15.)+10.);\n  }\nfloat noise(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.)),\n       f0 = fract(P), f1 = f0 - vec3(1.), f = fade(f0);\n     vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy),\n          iz0 = i0.zzzz, iz1 = i1.zzzz,\n        ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1),\n          gx0 = ixy0 * (1. / 7.), gy0 = fract(floor(gx0) * (1. / 7.)) - .5,\n          gx1 = ixy1 * (1. / 7.), gy1 = fract(floor(gx1) * (1. / 7.)) - .5;\n     gx0 = fract(gx0); gx1 = fract(gx1);\n     vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.)),\n          gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.));\n     gx0 -= sz0 * (step(0., gx0) - .5); gy0 -= sz0 * (step(0., gy0) - .5);\n     gx1 -= sz1 * (step(0., gx1) - .5); gy1 -= sz1 * (step(0., gy1) - .5);\n     vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n          g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n          g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n          g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n     vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3))),\n          norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n     g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n     g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n     vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n                       dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n                   vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n                        dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n     return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n  }\n  float turbulence(vec3 P) {             // Turbulence is a fractal sum of abs(noise).\n     float f = 0., s = 1.;              // The domain is rotated after every iteration\n     for (int i = 0 ; i < 9 ; i++) {      //    to avoid any visible grid artifacts.\n        f += abs(noise(s * P)) / s;\n        s *= 2.;\n        P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);\n      }\n      return f;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) and center pos\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\n   float c = 0.;\n\n    // BUILD A FRACTAL TEXTURE USING\n    // NOISE THAT ANIMATES THROUGH Z\n\n    float x = uv.x+ iTime*.2;\n    float y = uv.y;\n    for (int n = 1 ; n <= 5 ; n++) {\n       float z = float(n);\n       vec3 p = vec3(x, y, z + 0.05 * iTime);\n       float frequency = pow(2., z);\n       c +=(noise(frequency*p)/frequency);\n    }\n\n    // CLOUDS SHOT WITH COLOR\n\n    vec3 sky   = vec3(.1, .3, .9);\n    vec3 white = vec3(1.,1.,1.);\n    vec3 pink  = vec3(1.,.5,.5);\n    vec3 cloud = mix(pink,white,c);\n    c = clamp(c + y, 0.0, 1.0);\n    vec3 color = mix(sky, cloud, c);\n    c = clamp(c - y, 0.0, 1.0);\n    vec3 color1 = mix(sky, cloud, c);\n    color = color + color1;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2XWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 66], [70, 70, 91, 91, 140], [142, 142, 164, 164, 205], [207, 207, 235, 235, 291], [294, 294, 313, 313, 356], [357, 357, 378, 378, 2217], [2220, 2220, 2246, 2304, 2634], [2637, 2637, 2694, 2759, 3549]]}
{"id": "wl2XzD", "name": "SquareDot001", "author": "Hirai_worthless", "description": "dist in dist.", "tags": ["practice"], "likes": 2, "viewed": 52, "published": "Public", "date": "1565295215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\nfloat square(vec2 p,vec2 o,float r){\n\treturn abs(p.x-o.x) + abs(p.y - o.y) - r;\n}\nfloat dist_1(vec2 p){\n\tfloat time = fract(iTime/8.) * 8.;\n    float line1 = abs(p.x) - 0.1;\n    float line2 = abs(p.x - 1.0) - 0.05;\n    float line3 = abs(p.x + 1.0) - 0.05;\n    float wall1 = p.x + 1.75 - abs(0.5 - fract(p.y * 2.0)) * 0.5;\n    float wall2 = p.x - 1.75 + abs(0.5 - fract(p.y * 2.0)) * 0.5;\n    float c1 = circle(p,vec2(0.,time - 2.0),0.75);\n    float c2 = circle(p,vec2(1.,time-4.),0.5);\n    float c3 = circle(p,vec2(-1.,time-4.),0.5);\n    float c4 = circle(p,vec2(0,time -6.),0.75);\n    return min(min(wall1,-wall2),\n               min(min(line1,min(line2,line3)),\n            min(min(c1,c2),min(c3,c4))));\n    \n}\nfloat dist_2(vec2 p){\n    float result = 100000.0;\n    for(float xi = -3.0; xi < 3.0; xi += 0.1){\n        for(float yi = -3.0; yi < 3.0; yi += 0.1){\n            vec2 tmp = vec2(xi+fract(iTime / 4.),yi);\n        \tfloat r = 0.05 - max(dist_1(tmp),0.00);\n            result = min(result,square(p,tmp,r));\n        }\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = dist_2(uv) > 0. ? vec3(255,69,84)/255. : vec3(0,195,227)/255.;\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2XzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 65], [66, 66, 102, 102, 147], [148, 148, 169, 169, 778], [779, 779, 800, 800, 1117], [1118, 1118, 1175, 1175, 1374]]}
{"id": "Wl2XzR", "name": "Spheres and box raymarch test", "author": "tmulgrew", "description": "Thought I'd have a go at ray-marching a signed distance field.\nVery much based on iq's work and tutorials.", "tags": ["3d", "raymarching", "sdf"], "likes": 2, "viewed": 394, "published": "Public API", "date": "1564807387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-0.5, -0.7, -0.2));\nconst int stepCount = 256;\nconst float tmin = 0.01;\nconst float tmax = 200.0;\nconst float pi = 3.14159265;\n\n\nfloat mapsphere(in vec3 p, in vec3 center, float rad) {\n\treturn length(p - center) - rad;   \n}\n\nfloat mapbox(in vec3 p, in vec3 center, in vec3 size) {    \n    vec3 a = abs(p - center) - vec3(size);\n    return max(a.x, max(a.y, a.z));\n}\n\nfloat mapcube(in vec3 p, in vec3 center, float size) {\n \treturn mapbox(p, center, vec3(size));   \n}\n\nfloat mapplane(in vec3 p, in vec3 center, in vec3 n) {\n\treturn dot(p - center, n);\n}\n\nvec3 rotx(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 roteuler(in vec3 p, in vec3 euler) {\n \treturn roty(rotx(rotz(p, euler.z), euler.y), euler.z);   \n}\n\nvec4 minp(in vec4 a, in vec4 b) {\n\treturn a.w < b.w ? a : b;   \n}\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\nvec4 map(in vec3 p) { \n    vec4 sphere = vec4(0, 0, 0, 1000);\n    for (int i = 0; i < 10; i++) {\n        float a = float(i) * 2.0*pi / 10.0;\n        float a2 = a + iTime * 0.4;\n        vec3 center = vec3(sin(a2), 0.0, cos(a2)) * 5.0 + vec3(0, 2.0 + sin(float(i)), -10);\n        vec3 col = vec3(sin(a), sin(a + 2.2), sin(a + 4.4)) * 0.75 + vec3(0.5);\n     \tsphere = minp(sphere, vec4(col, mapsphere(p, center, 1.0)));\n    }\n    \n    const vec3 boxCol = vec3(0.6);    \n    vec3 ccenter = vec3(0, 4.0 + sin(iTime) * 1.0,-10);\n    vec3 boxp = ccenter + roteuler(p - ccenter, vec3(iTime * 0.2, iTime * 0.7, iTime * 1.1) * 0.3);\n    vec4 box = vec4(boxCol, mapbox(boxp, ccenter, vec3(3, 2, 0.75)));\n    box.w = max(box.w, 1.0 - length(boxp.xy - ccenter.xy));\n    box.w = max(box.w, 0.5 - length(boxp.yz - ccenter.yz));\n    box.w = max(box.w, 0.5 - length(boxp.xz - ccenter.xz));\n\n    const vec3 planeCol1 = vec3(0, 0.5, 0.75);\n    const vec3 planeCol2 = vec3(0.7, 0.8, 1);\n    vec4 plane = vec4(\n        checkerboard(p.xz * 0.5) ? planeCol1 : planeCol2, \n        p.y - -2.0);\n    \n    return minp(sphere, minp(box, plane));\n}\n\nvec3 getNormal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).w;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).w - d,\n        map(p + vec3(0,s,0)).w - d,\n        map(p + vec3(0,0,s)).w - d);\n    \n    return normalize(r);\n}\n\nvec3 getScreenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), -1);\n}\n\nvec4 march(in vec3 from, in vec3 delta) {\n    float t = tmin;    \n    for (int i = 0; i < stepCount && t < tmax; i++) {\n     \tvec3 p = from + delta * t;\n        vec4 d = map(p);\n        if (abs(d.w) <= 0.0005 * t)\n            return vec4(d.xyz, t);\n        t += d.w;\n    }\n    \n    return vec4(vec3(0),-1);    \n}\n\nfloat shadow(in vec3 from, in vec3 delta, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < stepCount && t < tmax; i++) {\n     \tvec3 p = from + delta * t;\n        float d = map(p).w;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\n// Crude lighting equation\nfloat lighting(in vec3 e, in vec3 n, float diffuse, float specular, float shiny) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), shiny) * specular;\n\n    return max(d + s, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 fogCol = vec3(0.0, 0.0, 0.2);\n    const float r = 0.6;\n\n    float ang = iTime * 0.03;\n    vec3 from = vec3(0, 3, -10) + roty(vec3(0, 0, 12), ang);\n    vec3 dir = normalize(roty(rotx(getScreenRay(fragCoord), 0.1), ang));\n    \n    vec3 sumCol = vec3(0);\n    float sumf = 1.0;\n    for (int bounce = 0; bounce < 4; bounce++) {    \n        vec4 d = march(from, dir);\n\n        if (d.w < 0.0)\n            break;\n        \n\t\t// Position and normal\n        vec3 p = from + dir * d.w;\n        vec3 n = getNormal(p, d.w);\n\n        // Lighting\n        float l = lighting(dir, n, 1.5, 2.0, 10.0);\n        if (l > 0.0) {\n            // Shadow ray\n            float s = shadow(p, -light, 16.0);\n            l *= s;\n        }\n\n        vec3 col = d.xyz * min(l + 0.2, 1.0);\n        col *= r;\n\n        // Fog\n        float fog = clamp(d.w * d.w / 1200.0, 0.0, 1.0);\n        col = mix(col, fogCol, fog);\n        \n        // Add to sum\n        sumCol += col*sumf;\n        \n        // Calculate reflection vector\n        from = p;\n        dir = normalize(reflect(dir, n));\n  \n        sumf *= (1.0 - r) * (1.0 - fog);\n    }\n    \n    sumCol += fogCol * sumf;\n    \n    fragColor = vec4(sumCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2XzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 248, 303, 303, 342], [344, 344, 399, 399, 484], [486, 486, 540, 540, 585], [587, 587, 641, 641, 671], [673, 673, 704, 704, 815], [817, 817, 848, 848, 959], [961, 961, 992, 992, 1103], [1105, 1105, 1146, 1146, 1208], [1210, 1210, 1243, 1243, 1275], [1277, 1277, 1307, 1307, 1453], [1455, 1455, 1476, 1476, 2574], [2576, 2576, 2612, 2742, 3047], [3049, 3049, 3079, 3079, 3167], [3169, 3169, 3210, 3210, 3481], [3483, 3483, 3535, 3535, 3817], [3819, 3846, 3928, 3953, 4142], [4144, 4144, 4200, 4200, 5392]]}
{"id": "Wl2XzW", "name": "3D fbm test", "author": "uqone", "description": "Just experimenting.", "tags": ["3d", "noise", "fbm", "random"], "likes": 3, "viewed": 738, "published": "Public API", "date": "1565239852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 vec3(.1031)\n\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE1);\n\tp3 += dot(p3, p3.yxz+19.19);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\treturn mix(\tmix(mix( hash(p+vec3(0,0,0)), \n\t\t\t\t\t\thash(p+vec3(1,0,0)),f.x),\n\t\t\t\t\tmix( hash(p+vec3(0,1,0)), \n\t\t\t\t\t\thash(p+vec3(1,1,0)),f.x),f.y),\n\t\t\t\tmix(mix( hash(p+vec3(0,0,1)), \n\t\t\t\t\t\thash(p+vec3(1,0,1)),f.x),\n\t\t\t\t\tmix( hash(p+vec3(0,1,1)), \n\t\t\t\t\t\thash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\nvec3 fbm(in vec3 q)\n{\n\tvec3 f  = 0.5000*noise( q ); q = m3*q*2.01;\n\tf += 0.2500*noise( q ); q = m3*q*2.02;\n\tf += 0.1250*noise( q ); q = m3*q*2.03;\n\tf += 0.0625*noise( q ); q = m3*q*2.04;\n#if 1\n\tf += 0.03125*noise( q ); q = m3*q*2.05; \n\tf += 0.015625*noise( q ); q = m3*q*2.06; \n\tf += 0.0078125*noise( q ); q = m3*q*2.07; \n\tf += 0.00390625*noise( q ); q = m3*q*2.08;  \n#endif\n\treturn vec3(f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = fbm(float(iTime) + 1000.0 + vec3(fragCoord.x, fragCoord.y, (fragCoord.x + fragCoord.y) * 0.5) * 0.01);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2XzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 52, 52, 155], [157, 157, 182, 182, 534], [632, 632, 653, 653, 1025], [1027, 1027, 1084, 1134, 1351]]}
{"id": "WlBSRR", "name": "Polar Fold Test", "author": "gaz", "description": "Polar fold. used smooth minmum.", "tags": ["fold"], "likes": 3, "viewed": 114, "published": "Public", "date": "1564735360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\tPI * 2.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec2 polarFold(vec2 p,float n)\n{\n    float h=floor(log2(n));\n    float a =PI2*exp2(h)/n;\n    for(int i=0;i<int(h)+2;i++)\n    {\n        vec2 v = vec2(-cos(a),sin(a));  \n        p-=2.0*min(0.0,dot(p,v))*v;\n        a*=0.5;\n    }\n    return p;\n}\n\nvec2 polarSmoothFold(vec2 p,float n)\n{\n    float h=floor(log2(n));\n    float a =PI2*exp2(h)/n;\n    for(int i=0; i<int(h)+2; i++)\n    {\n        vec2 v = vec2(-cos(a),sin(a));  \n \t\tp-=2.0*smin(0.0,dot(p,v),0.05)*v;\n        a*=0.5;\n    }\n    return p;\n}\n\nfloat map(vec3 p)\n{\n    p.xy *= rot(iTime*0.5);\n    p.yz *= rot(iTime*0.3);\n\n    p.xy=polarSmoothFold(p.xy,16.);\n    p.y -= 1.2;\n    return length(p)-0.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec2 q = polarFold(uv,6.);\n    q.y-=iTime*0.8;\n    q.y=mod(q.y,0.4)-0.05;\n    vec3 col = vec3(0.2,0.5,0.1);\n    col = mix(col, vec3(0,0.15,0),step(0.0, q.x * q.y)); \n    col = mix(col, vec3(1,0.5,0)*0.7*dot(uv,uv), smoothstep(0.02, 0.0, abs(q.y)));\n    col = mix(col, vec3(0,0.6,1)*0.8*length(uv), smoothstep(0.02, 0.0, abs(q.x)));\n    \n \tvec3 ro = vec3(0,0,3);\n    vec3 rd = normalize(vec3(uv,-2));\n    float d, t = 0.0;\n    for(float i = 1.0;i > 0.0;i -= 1.0/30.0)\n    {\n     \tt += d = map(ro+t*rd);\n        if(d < 0.001)\n        {\n            col += i*i;\n            break;\n        }\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 138, 138, 245], [247, 247, 279, 279, 488], [490, 490, 528, 528, 740], [742, 742, 761, 761, 898], [900, 900, 957, 957, 1655]]}
{"id": "WlBSzd", "name": "Export Normal", "author": "SwordWu", "description": "This is a error result, but it still can use for some test", "tags": ["normalmap"], "likes": 3, "viewed": 696, "published": "Public API", "date": "1566722510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Center = vec2(0.5,0.5);\n\nfloat Rad = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    vec4 FinalColor = vec4( 0.5, 0.5, 1.0, 1.0 );\n      \n    float Distance = sqrt((uv.x - Center.x)*(uv.x - Center.x) +\n                            (uv.y - Center.y)*(uv.y - Center.y)); \n\n    FinalColor.xy = (uv - Center)/ Distance *2.0 *3.14159265 * Rad ;\n\n    FinalColor.xy = cos(FinalColor.xy + iTime);\n\n    FinalColor.xy = FinalColor.xy*0.5 + 0.5;\n  \n\n    // Output to screen\n    fragColor = FinalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 155, 609]]}
{"id": "WlBSzG", "name": "Basic Path Tracer", "author": "baldand", "description": "Pan with mouse\nIncrease the sample count if you have a better GPU\nBased on http://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n\n", "tags": ["3d", "pathtracer"], "likes": 13, "viewed": 1003, "published": "Public", "date": "1566240381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nSimple path tracer\n\nBased on http://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n\nbaldand/2019\n*/\n\n// Some settings you can tweak\n\n//#define SAMPLES 50 // Bigger GPUs\n#define SAMPLES 3 // Smaller GPUs, noisier\n\n#define APERTURE 0.08 // A little out of focus in background\n//#define APERTURE 0.0 // All in focus\n\nconst float M_PI = 3.141592653589793;\n\nstruct random_state {\n    uint z0;\n    uint z1;\n    uint z2;\n    uint z3;\n};\n\n    \nuint tst(in uint z, int S1, int S2, int S3, uint M) {\n    uint b = (((z << S1) ^ z) >> S2);\n    return (((z & M) << S3) ^ b);\n}\n\nuint lcg(in uint z, uint A, uint C) {\n    return (A*z+C);\n}\n\nvoid update_random(inout random_state rs) {\n    rs.z0 = tst(rs.z0, 13, 19, 12, 4294967294u);\n    rs.z1 = tst(rs.z1,  2, 25, 4,  4294967288u);\n    rs.z2 = tst(rs.z2, 3, 11, 17, 4294967280u);\n    rs.z3 = lcg(rs.z3, 1664525u, 1013904223u);\n    uint zt = rs.z3;\n    rs.z3 ^= rs.z2;\n    rs.z2 ^= rs.z1;\n    rs.z1 ^= rs.z0;\n    rs.z0 ^= zt;\n}\n\nvoid init_random(vec2 fragCoord, float time, inout random_state rs) {\n    rs.z0 = floatBitsToUint(fragCoord.y*0.1234567);\n    rs.z1 = floatBitsToUint(fragCoord.x*0.1234567);\n    rs.z2 = floatBitsToUint(time*0.1234567);\n    rs.z3 = floatBitsToUint(0.1234567);\n    // Mix up a bit\n    update_random(rs);\n    update_random(rs);\n    update_random(rs);\n    update_random(rs);\n}\n\nfloat random0(in random_state rs) {\n    return fract(0.00002328 * float(rs.z0));\n}\nfloat random1(in random_state rs) {\n    return fract(0.00002328 * float(rs.z1));\n}\nfloat random2(in random_state rs) {\n    return fract(0.00002328 * float(rs.z2));\n}\n\nvec3 random_in_unit_disk(inout random_state rs) {\n    update_random(rs);\n    vec3 r,p;\n    r.x = random0(rs);\n    r.y = random1(rs);\n    r.z = 0.0;\n    p =2.0 * r - vec3(1.0,1.0,0.0);\n    while (dot(p,p)>1.0) p *= 0.7;\n    return p;\n}\n\nconst uint Lambertian = 0u;\nconst uint Metal = 1u;\nconst uint Dielectric = 2u;\nconst uint DiffuseLight = 3u;\n\nstruct sphere {\n    vec3 center;\n    float radius2;\n    float radiusi;\n    uint mat_type;\n    vec3 albedo;\n    vec3 albedo2;\n    float fuzz;\n    float ref_idx;\n};\n    \nconst sphere world[] = sphere[]( \n    sphere(vec3(0.0,-1001.0,0.0), 1000.0*1000.0, 1.0/1000.0, Metal, vec3(0.2,0.2,0.2),vec3(0.2,0.4,0.2),0.05,0.0),\n    sphere(vec3(0.0,-0.5,0.0), 0.5*0.5, 1.0/0.5, Dielectric, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.0,1.7),\n    sphere(vec3(0.0,-0.5,0.0), 0.4*0.4, -1.0/0.4, Dielectric, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.0,1.7),\n\n    sphere(vec3(2.0,0.0,0), 1.0*1.0, 1.0/1.0, Lambertian, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),0.0,0.0),\n    sphere(vec3(-2.0,0.0,0), 1.0*1.0, 1.0/1.0, Metal, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.1,0.0),\n    sphere(vec3(0.0,0.0,2.0), 1.0*1.0, 1.0/1.0, Dielectric, vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),0.0,1.5),\n    sphere(vec3(0.0,0.0,-2.0), 1.0*1.0, 1.0/1.0, Metal, vec3(1.0,0.25,0.25),vec3(1.0,0.25,0.25),0.01,0.0),\n\n    sphere(vec3(4.0,-0.5,2.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),0.0,0.0),\n    sphere(vec3(2.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.0,1.0,0.0),vec3(0.0,1.0,0.0),0.0,0.0),\n    sphere(vec3(4.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,-2.0), 0.5*0.5, 1.0/0.5, Metal, vec3(1.0,1.0,0.0),vec3(1.0,1.0,0.0),0.0,0.0),\n    sphere(vec3(-2.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.0,1.0,1.0),vec3(0.0,1.0,1.0),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(1.0,0.0,1.0),vec3(1.0,0.0,1.0),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,2.0), 0.5*0.5, 1.0/0.5, Metal, vec3(1.0,0.5,0.5),vec3(1.0,0.5,0.5),0.0,0.0),\n    sphere(vec3(-2.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.5,1.0,0.5),vec3(0.5,1.0,0.5),0.0,0.0),\n    sphere(vec3(-4.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.5,0.5,1.0),vec3(0.5,0.5,1.0),0.0,0.0),\n    sphere(vec3(4.0,-0.5,-2.0), 0.5*0.5, 1.0/0.5, Metal, vec3(1.0,1.0,0.5),vec3(1.0,1.0,0.5),0.0,0.0),\n    sphere(vec3(2.0,-0.5,4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(0.5,1.0,1.0),vec3(0.5,1.0,1.0),0.0,0.0),\n    sphere(vec3(4.0,-0.5,-4.0), 0.5*0.5, 1.0/0.5, Lambertian, vec3(1.0,0.5,1.0),vec3(1.0,0.5,1.0),0.0,0.0)\n\n);\n\nvoid get_sphere_uv(vec3 p, inout float u, inout float v) {\n    u = p.x;\n    v = p.z;\n}\n  \nstruct hit_record {\n    float t;\n    vec3 p;\n    vec3 normal;\n    vec3 objcent;\n    float u;\n    float v;\n    int objidx;\n};\n\n\nbool sphere_hit(int i, vec3 ro, vec3 rd, float a, float ooa, float t_min, float t_max, inout hit_record rec) {\n    vec3 cen = world[i].center;\n    if (i==6) cen.y = 1.5*abs(sin(iTime*3.5));\n    vec3 oc = ro - cen; \n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - world[i].radius2;\n    float disc = b*b - a*c;\n    if (disc > 0.0) {\n        float sqdisc = sqrt(disc);\n        float temp = (-b -sqdisc)*ooa;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = ro + rd*temp;\n            rec.objcent = cen;\n            rec.normal = (rec.p - rec.objcent) * world[i].radiusi;\n            rec.objidx = i;\n            get_sphere_uv(rec.p, rec.u, rec.v);\n            return true;\n        }\n        temp = (-b +sqdisc)*ooa;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = ro + rd*temp;\n            rec.objcent = cen;\n            rec.normal = (rec.p - rec.objcent) * world[i].radiusi;\n            rec.objidx = i;\n            get_sphere_uv(rec.p, rec.u, rec.v);\n            return true;\n        }\n    }\n    return false;\n}\n   \n\nvec3 emitted(hit_record rec) {\n    if (world[rec.objidx].mat_type == DiffuseLight) {\n        return world[rec.objidx].albedo;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nbool list_hit(vec3 ro, vec3 rd, float t_min, float t_max, inout hit_record rec) {\n    bool hit_anything = false;\n    rec.t = t_max;\n    float a = dot(rd, rd);\n    float ooa = 1.0/a;\n    for (int i = 0; i < world.length(); i++) {\n        if (sphere_hit(i, ro, rd, a, ooa, t_min, rec.t, rec)) {\n            hit_anything = true;\n        }\n    }\n    return hit_anything;\n}\n\nvec3 shade(hit_record rec) {\n    bool wu = fract(rec.u*0.5)>0.5;\n    bool wv = fract(rec.v*0.5)>0.5;\n    if (wu^^wv) {\n        return world[rec.objidx].albedo;\n    } else {\n        return world[rec.objidx].albedo2;\n    }\n}\n\nvec3 random_in_unit_sphere(vec3 r) {\n    vec3 p;\n    p = 2.0 * r - vec3(1.0);\n    while (dot(p,p) > 1.0) p *= 0.7;\n    return p;\n}\n\n\nbool refract2(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float disc = 1.0 - ni_over_nt * ni_over_nt * (1.0-dt*dt);\n    if (disc > 0.0) {\n        refracted = ni_over_nt * (uv - n*dt) - n*sqrt(disc);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfloat schlick(float csn, float idx) {\n    float r0 = (1.0-idx) / (1.0+idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow(1.0-csn,5.0);\n}\n\nbool scatter(hit_record rec, vec3 ro, vec3 rd, inout vec3 attenuation, inout vec3 scro, inout vec3 scrd, inout random_state rs) {\n   vec3 r;\n   update_random(rs);\n   r.x = random0(rs);\n   r.y = random1(rs);\n   r.z = random2(rs);\n   vec3 reflected = reflect(normalize(rd), rec.normal);\n   attenuation = shade(rec);\n   uint mt = world[rec.objidx].mat_type;\n   if (mt == Lambertian) {\n       vec3 target = normalize(rec.normal + random_in_unit_sphere(r));\n       scro = rec.p;\n       scrd = target;\n       return true;\n   } else if (mt == Metal) {\n       vec3 rius = random_in_unit_sphere(r);\n       scro = rec.p;\n       float fuzz = world[rec.objidx].fuzz;\n       scrd = ((1.0-fuzz)*reflected + fuzz*rius) + fuzz*(rec.normal + rius);\n       return dot(scrd,rec.normal) > 0.0; \n   } else if (mt == Dielectric) {\n       vec3 outward_normal;\n       float ni_over_nt;\n       vec3 refracted;\n       float reflect_prob = 1.0;\n       float csn;\n       float il = 1.0/length(rd);\n       float drdnor = dot(rd, rec.normal);\n       float idx = world[rec.objidx].ref_idx;\n       if (drdnor > 0.0) {\n           outward_normal = -rec.normal;\n           ni_over_nt = idx;\n           csn = ni_over_nt * drdnor * il;\n       } else {\n           outward_normal = rec.normal;\n           ni_over_nt = 1.0/idx;\n           csn = -drdnor * il;\n       }\n       if (refract2(rd, outward_normal, ni_over_nt, refracted)) {\n           reflect_prob = schlick(csn, idx);\n       }\n       if (r.x < reflect_prob) {\n           scro = rec.p;\n           scrd = reflected;\n       } else {\n           scro = rec.p;\n           scrd = refracted;\n       }\n       return true;\n   } else if (mt == DiffuseLight) {\n       return false;\n   }\n}\n\nvec3 color(vec3 ro, vec3 rd, inout random_state rs) {   \n    vec3 emit_accum = vec3(0.0);\n    vec3 attenuation_accum = vec3(1.0);\n    vec3 albedo = vec3(0.0);\n    int depth = 0;\n    bool done = false;\n    while (!done) {\n        hit_record rec;\n        if (list_hit(ro, rd, 0.001, 1E9, rec)) {\n            vec3 scro, scrd;\n            vec3 attenuation;\n            vec3 emitcol = emitted(rec);\n            emit_accum += emitcol * attenuation_accum;\n            if (depth < 50 && scatter(rec, ro, rd, attenuation, scro, scrd, rs)) {\n                attenuation_accum *= attenuation;\n                ro = scro;\n                rd = scrd;\n                depth += 1;\n            } else {\n                done = true;\n            }\n        } else {\n            vec3 unit_direction = normalize(rd);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            albedo = ((1.0-t)*vec3(1.0) + t*vec3(0.25,0.5,1.0));\n            emit_accum += attenuation_accum * albedo * 0.7;\n            done = true;\n        }    \n    }\n    \n    return emit_accum; //vec3(random0(rs), random1(rs), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize pseudo random number gen \n    random_state rs;\n    float time = iTime + 25.0*iMouse.x/iResolution.x;\n    init_random(fragCoord, time+iMouse.y, rs);\n    \n    vec3 col = vec3(0.0);\n    \n    // Sample\n    int ns = SAMPLES;\n    for (int s=0; s<ns; s++) {\n        //world[6].center.y = 1.0+sin(time);\n        // Camera init\n        float orbit_radius = 6.0;\n        vec3 look_from = vec3(orbit_radius * sin(0.1*time), 1.5+cos(time*0.1)+5.0*iMouse.y/iResolution.y, orbit_radius*cos(0.1*time));\n        vec3 look_at = vec3(0.0);\n        float focus_dist = length(look_from - look_at) - 2.0;\n        float aspect = iResolution.x/iResolution.y;\n        vec3 vup = vec3(0.0,1.0,0.0);\n        float aperture = APERTURE; \n        float lens_radius = aperture * 0.5;\n        float vfov = 35.0;\n        float theta = vfov*M_PI/180.0;\n        float half_height = tan(theta*0.5);\n        float half_width = aspect * half_height;\n        vec3 origin = look_from;\n        vec3 w = normalize(look_from - look_at);\n        vec3 u = normalize(cross(vup, w));\n        vec3 v = cross(w, u);\n        vec3 lower_left_corner = origin - half_width * focus_dist * u - half_height*focus_dist*v - focus_dist*w;\n        vec3 horizontal = 2.0 * half_width * focus_dist* u;\n        vec3 vertical = 2.0 * half_height * focus_dist *v;\n        \n        // Generate a ray\n        vec2 st = vec2(fragCoord.x/iResolution.x + 1.0*random0(rs)/iResolution.x,\n                      fragCoord.y/iResolution.y + 1.0*random1(rs)/iResolution.y);\n        vec3 rd = lens_radius * random_in_unit_disk(rs);\n        vec3 offset = u*rd.x + v*rd.y;\n        vec3 ro = origin + offset;\n        rd = lower_left_corner + st.x*horizontal + st.y*vertical - origin - offset;\n        \n        // Sample from the scene along that ray\n        col += color(ro, rd, rs);\n        \n        time += 1.0/(30.0*float(ns)); // Motion blur        \n    }\n    col *= (1.0/float(ns));\n    col = pow(col, vec3(1.0/2.4)); // Gamma\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBSzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 467, 520, 520, 594], [596, 596, 633, 633, 655], [657, 657, 700, 700, 993], [995, 995, 1064, 1064, 1367], [1369, 1369, 1404, 1404, 1451], [1452, 1452, 1487, 1487, 1534], [1535, 1535, 1570, 1570, 1617], [1619, 1619, 1668, 1668, 1853], [4201, 4201, 4259, 4259, 4287], [4418, 4418, 4528, 4528, 5514], [5520, 5520, 5550, 5550, 5692], [5694, 5694, 5775, 5775, 6062], [6064, 6064, 6092, 6092, 6286], [6288, 6288, 6324, 6324, 6418], [6421, 6421, 6492, 6492, 6756], [6758, 6758, 6795, 6795, 6894], [6896, 6896, 7025, 7025, 8593], [8595, 8595, 8648, 8648, 9681], [9683, 9683, 9740, 9784, 11773]]}
{"id": "wlBSzR", "name": "Circle Daze", "author": "Tiz", "description": "Circle Daze", "tags": ["circle", "daze"], "likes": 1, "viewed": 46, "published": "Public", "date": "1564750259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 backgroundColor = vec4(0,0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuint radius = uint(50000.0 + 25000.0*sin(iTime)); //pixels \n    \n\tvec4 circleColor = vec4(sin(iTime)*0.5 + sin(iTime/10.0)*0.5,cos(iTime),1,0);\n    uvec2 coord = uvec2(fragCoord * 1000.0);\n    uvec2 center = uvec2(iResolution.xy/2.0 * 1000.0); \n    uvec2 diff = coord - center;\n    if(diff.x * diff.x + diff.y*diff.y < radius * radius)\n        fragColor = circleColor;\n    else\n        fragColor = backgroundColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 96, 96, 514]]}
{"id": "wlBXD3", "name": "Circles mosaic", "author": "avin", "description": "visual experiment", "tags": ["circles"], "likes": 2, "viewed": 269, "published": "Public API", "date": "1567277223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\nvec2 rand( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;        \n        \n    uv *= 7.5;\n    \n    vec2 iuv = floor(uv);\n    vec2 guv = fract(uv);\n\n    float mDist = 2.1;\n        \n    for (float y= -1.; y <= 1.; y++) {\n        for (float x= -1.; x <= 1.; x++) {            \n            vec2 neighbor = vec2(x, y);            \n            vec2 point = rand(iuv + neighbor);\t\t\t\n            point = 0.5 + 0.5*sin(iTime*.5 + 6.2831*point);\t\t\n            vec2 diff = neighbor + point - guv;            \n            float dist = length(diff) * (1.0 + rand(iuv + neighbor + 100.).x*.25);\n            \n            mDist = min(mDist, dist)*.85;\n        }\n    }        \n    \n    mDist *= 7.5;\n    \n    float v = fract(floor(mDist*10.)/10.);\n    \n    vec2 vr = rand(iuv);\n    vec3 col = vec3(hue(vr.x + vr.y*20.).rgb) * (v > .5 ? .9 : .25);    \n\n    fragColor = vec4(col,1.0);    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBXD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 102, 102, 195], [197, 197, 254, 254, 1132]]}
{"id": "WlBXDD", "name": "Kinetic facade", "author": "Artleet", "description": "Playing around with Perlin noise and hue shift", "tags": ["perlin", "hueshift"], "likes": 7, "viewed": 243, "published": "Public", "date": "1565924277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 h(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nfloat n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy+iTime*.1,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+6.)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\n\nvoid mainImage(out vec4 o, in vec2 p){\n    vec2 u=p/iResolution.y,i=floor(u*=10.);\n    u-=i+.5;    \n    vec3 a=vec3(n(i*.05),n(i*.1),n(i*.15)),b=a*6.,r=u.x*sin(b)+u.y*cos(b);\n\to=vec4(h(step(r,vec3(a.y*.5)),a.z*20.),1.);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 116], [118, 118, 134, 134, 454], [456, 456, 494, 494, 681]]}
{"id": "wlBXDG", "name": "Test random", "author": "zodiax", "description": "random", "tags": ["random"], "likes": 2, "viewed": 188, "published": "Public", "date": "1566920597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 str(vec2 x)\n{\n\tfloat a = distance(vec2(0.5), x);\n    float c = sqrt(a);\n    vec2 f = (vec2(c,c))/1.0;\n    vec2 g = clamp(smoothstep(0.65, 0.0, f),0.,1.);\n    return g;\n}\n\nfloat rand(vec2 cor){\n    return fract(sin(dot(cor.xy ,vec2(sin(iTime*cor.x/50.),.2))));\n}\n\nvec3 ab(vec2 uvN, vec3 c)\n{\n    for(int i=1; i<10; i++)\n    {\n        float x = rand(uvN+sin(uvN.x*iTime*3.));\n        float y = rand(uvN+cos(uvN.x*iTime*2.));\n        float z = rand(uvN+tan(uvN.x*iTime));\n        vec3 k = vec3(x,y,z);\n        c *= k;\n    }\n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n\tvec3 col = vec3(1,1,1);\n\n    col = ab(str(uv),col)*str(uv).x;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 174], [176, 176, 197, 197, 266], [268, 268, 295, 295, 546], [548, 548, 605, 605, 744]]}
{"id": "WlBXDR", "name": "Rocky sea", "author": "jblanper", "description": "Experimenting with noise functions and ray marching.", "tags": ["3d", "raymarching", "noise", "fbm"], "likes": 3, "viewed": 99, "published": "Public", "date": "1565514517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tt;\n\n// random / noise functions\n// htimeps://thebookofshaders.com/13/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (in float n) {\n  //htimeps://thebookofshaders.com/11/\n  return fract(sin(n)*1e4);\n}\n\nfloat noise (float x) {\n  // htimeps://thebookofshaders.com/11/\n  float i = floor(x);\n  float f = fract(x);\n  return mix(random(i), random(i+1.), smoothstep(0., 1., f));\n}\n\n// Based on Morgan McGuire @morgan3d\n// htimeps://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n// 3d functions\nvec2 map (vec3 p) {\n  float c = p.y;\n  c += fbm(p.xz) * fbm(vec2(fbm(p.zx + iTime), noise(vec2(iTime))));\n  c += noise(p.xx + length(iTime)) * .8;\n  vec2 t = vec2(c * .5, 1.);\n\n  return t;\n}\n\nvec2 trace (vec3 ro, vec3 rd) {\n  const float MAX_DEPTH = 50.;\n  vec2 h, t = vec2(.1);\n\n  for (int i = 0; i < 150; i++) {\n    h = map(ro + rd * t.x);\n    if (h.x < .0001 || t.x > MAX_DEPTH) break;\n    t.x += h.x; t.y = h.y;\n  }\n  if (t.x > MAX_DEPTH) t.x = 0.;\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy).x,\n    map(p - e.yxy).x,\n    map(p - e.yyx).x));\n}\n\nfloat getShadow(vec3 p, vec3 lightDir) {\n    float shadow = 1.0;\n    float t = 0.1;\n    for (int i = 0; i < 32; ++i)\n    {\n        vec3 ray = p + lightDir * t;\n        float d = map(ray).x;\n        shadow = min(shadow, d / t);\n        t += clamp(d, 0.0, 0.6);\n    }\n    return clamp(shadow * 2.0, 0.0, 1.0);\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // htimeps://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  float shadow = getShadow(p, light);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.) * shadow;\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.) * (shadow + .5);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDirection (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // htimeps://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  tt = iTime * .3;\n\n  // camera\n  vec3 ro = vec3(0., 1., 2.);\n  vec3 rd = getRayDirection(uv, ro, vec3(0.), 2.);\n\n  // color, fog and light direction\n  vec3 ld = normalize(vec3(0., 25., -35.));\n  // vec3 ld = vec3(0., 2., 5.);\n  vec3 fogColor = vec3(.8, .4, .2);\n  vec3 fog = fogColor * (.5 + (length(uv) - .3));\n  vec3 color = fog;\n\n  // scene\n  vec2 sc = trace(ro, rd);\n  float t = sc.x;\n\n  if (t > 0.) {\n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 albido = vec3(.8, .3, .2);\n\n    color = getLight(ld, p, rd, 1.5, Material(.2, .7, 1.2)) * vec3(.2, .4, .8);\n    color = mix(color, albido, .2);\n\n    color = mix(color, fog, 1. - exp(-.00002*t*t*t)); //gradient\n  }\n\n  fragColor = vec4(pow(color, vec3(.45)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[11, 77, 104, 104, 211], [213, 213, 240, 279, 309], [311, 311, 334, 374, 482], [484, 564, 590, 590, 970], [990, 990, 1014, 1036, 1290], [1292, 1308, 1327, 1327, 1498], [1500, 1500, 1531, 1531, 1774], [1776, 1776, 1801, 1801, 1949], [1951, 1951, 1991, 1991, 2260], [2336, 2336, 2426, 2471, 3018], [3020, 3020, 3093, 3144, 3436], [3438, 3438, 3495, 3495, 4331]]}
{"id": "wlBXDz", "name": "draw-math-3", "author": "lilieming", "description": "just coding", "tags": ["drawmath"], "likes": 2, "viewed": 54, "published": "Public", "date": "1565580695", "time_retrieved": "2021-10-01T00:00:00", "image_code": " float disk(float x, float y, float r) {\n    return 1. - step(r * r, x * x + y * y);\n }\n\n void mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n     \n     vec2 uv = fragCoord/iResolution.xy - 0.5;\n    // CREATE SIX ANIMATING DISKS.\n\n    float c = 0.0;\n    for (int i = 0 ; i < 6 ; i++) {\n       float t = float(i);\n       float x = uv.x - 0.5 * sin(2.0 * iTime + t);\n       float y = uv.y + 0.8*sin(iTime) * sin(2.7 * iTime + t);\n       c = c + disk(x, y, 0.1);\n    }\n\n    vec3 color = vec3(c, c, c); \n    // Output to screen\n    fragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 87], [90, 90, 146, 146, 569]]}
{"id": "WlBXW1", "name": "Rose Window", "author": "QuantumYeti", "description": "Attempt at rose windows. Decided to animate it some :D\nNot sure if I can get rid of the aliasing...", "tags": ["radial", "rainbow", "rose", "window", "gothic", "stainedglass"], "likes": 3, "viewed": 365, "published": "Public API", "date": "1565721406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Scale = 0.2;\nconst float NumSegments = 12.0;\t// Odd numbers can get clipped... :\"(\nconst float PI = 3.1415926535897932384626433832795028841971693993751058209749445923078164062;\n\nfloat Effect1(vec2 coords, float numSegments, float r, float cutoffMax, float cutoffMin, float thickness)\n{\n    float s = abs(sin(r * numSegments * 0.5));\n    float dist = length(coords);\n    \n    if (dist <= cutoffMax && dist >= cutoffMin)\n    {\n        if (s < (dist * (dist * 0.5)) * thickness)\n        {\n            return 1.0;\n        }\n    }\n    return 0.0;\n    \n    //return smoothstep(0.12f, 0.08f, abs(s));\n}\n\nfloat Effect2(vec2 coords, float numSegments, float r, float cutoffMax, float cutoffMin, float thickness)\n{\n    float dist = length(coords);\n    float s = abs(sin(r * numSegments * 0.5));\n    \n    if (dist <= cutoffMax && dist >= cutoffMin)\n    {\n        if (s < sin(dist) * thickness) \n        {\n            return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nfloat Effect3(vec2 coords, float numSegments, float r, float cutoffMax, float cutoffMin, float thickness)\n{\n    float dist = length(coords);\n    float s = abs(sin(r * numSegments * 0.5));\n    \n    if (dist <= cutoffMax && dist >= cutoffMin)\n    {\n        if (s < tan(tan(dist)) * thickness) \n        {\n            return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nfloat Effect4(vec2 coords, float radius, float cutoffMax, float cutoffMin)\n{\n    float dist = length(coords);\n    if (dist <= cutoffMax && dist >= cutoffMin)\n    {\n        if (dist < radius)\n        {\n            return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nfloat b2f(int b)\n{\n    return float(b) / 255.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = sin(iTime * 0.01);\n    float t2 = sin(iTime * 0.04);\n    float t4 = sin(iTime * 0.08);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectMax = max(iResolution.x, iResolution.y);\n    float aspectMin = min(iResolution.x, iResolution.y);\n    vec2 coords = (uv - 0.5) * vec2(aspectMax / aspectMin, 1.0) / (Scale + sin(t) * 0.2);\n    float r = atan(coords.y, coords.x) + 1.54;\n    vec4 color1 = vec4(0, 0, 0, 1);\n    vec4 color2 = vec4(b2f(247), b2f(2), 0, 1);\n    vec4 color3 = vec4(b2f(250), b2f(150), b2f(2), 1);\n    vec4 color4 = vec4(b2f(252), b2f(227), 0, 1);\n    vec4 color5 = vec4(b2f(185), b2f(246), b2f(5), 1);\n    vec4 color6 = vec4(b2f(1), b2f(223), b2f(2), 1);\n    vec4 color7 = vec4(b2f(0), b2f(216), b2f(255), 1);\n    //vec4 color7 = vec4(b2f(98), b2f(228), b2f(228), 1);\n    vec4 color8 = vec4(b2f(6), b2f(138), b2f(220), 1);\n    vec4 color9 = vec4(0, b2f(24), b2f(209), 1);\n    \n    vec4 final = vec4(b2f(66), b2f(55), b2f(98), 1);\n    \n    //Effect(vec2 coords, float numSegments, float r, float cutoffMax, float cutoffMin, float thickness)\n    vec4 l1 = color1 * Effect1(coords, NumSegments, r + t, 1.825, 0.0, mix(0.1, -0.1, t4));\n    vec4 l2 = color1 * Effect1(coords, NumSegments * 8.0, r - t, 3.4, 2.89, 0.025);\n    vec4 l3 = color1 * Effect3(coords * 4.0, NumSegments, r + t, 8.0, 0.0, mix(0.6, -0.6, t4));\n    vec4 l4 = color1 * Effect3(coords * 4.0, NumSegments * 3.0, r + t * 2.0, 18.0, 8.0, mix(2.8, -2.8, t2));\n    vec4 l5 = color1 * Effect1(coords, NumSegments * 0.5, r - t, 2.1, 1.8, mix(0.1, -0.1, sin(t2)));\n    vec4 l6 = color1 * Effect1(coords, NumSegments * 0.5, r + PI / 8.0 + t, 2.9, 2.1, mix(0.18, -0.18, t2));\n    vec4 c1 = color2 * Effect4(coords, 0.34, 20.0, 0.0);\n    vec4 c2 = color3 * Effect4(coords, 0.445, 20.0, 0.0);\n    vec4 c3 = color4 * Effect4(coords, 1.035, 20.0, 0.0);\n    vec4 c4 = color5 * Effect4(coords, 1.819, 20.0, 0.0);\n    vec4 c5 = color6 * Effect4(coords, 2.105, 20.0, 0.0);\n    vec4 c6 = color7 * Effect4(coords, 2.605, 20.0, 0.0);\n    vec4 c7 = color8 * Effect4(coords, 2.8, 50.0, 0.0);\n    vec4 c8 = color9 * Effect4(coords, 3.44, 20.0, 0.0);\n    vec4 c9 = vec4(0, 0, 0, 1) * (1.0 - Effect4(coords, 3.65, 20.0, 0.0));\n    \n    final = final * (1.0 - c9.a) + c9;\t\t// C9\n    final = final * (1.0 - c8.a) + c8;\t\t// C8\n    final = final * (1.0 - c7.a) + c7;\t\t// C7\n    final = final * (1.0 - c6.a) + c6;\t\t// C6\n    final = final * (1.0 - c5.a) + c5;\t\t// C5\n    final = final * (1.0 - c4.a) + c4;\t\t// C4\n    final = final * (1.0 - c3.a) + c3;\t\t// C3\n    final = final * (1.0 - c2.a) + c2;\t\t// C2\n    final = final * (1.0 - c1.a) + c1;\t\t// C1\n    final = final * (1.0 - l6.a) + l6;\t\t// L6\n    final = final * (1.0 - l5.a) + l5;\t\t// L5\n    final = final * (1.0 - l4.a) + l4;\t\t// L4\n    final = final * (1.0 - l3.a) + l3;\t\t// L3\n    final = final * (1.0 - l2.a) + l2;\t\t// L2\n    final = final * (1.0 - l1.a) + l1;\t\t// L1 (outline)\n    \n    float dist = length(coords);\n    vec4 vignette = vec4(1, 1, 1, 1) * clamp(1.4 - dist * 0.3, 0.0, 1.0);\n    \n    fragColor = final * vignette;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 190, 297, 297, 607], [609, 609, 716, 716, 963], [965, 965, 1072, 1072, 1324], [1326, 1326, 1402, 1402, 1584], [1586, 1586, 1604, 1604, 1635], [1637, 1637, 1692, 1692, 4755]]}
{"id": "wlBXWD", "name": "Hinge", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 7, "viewed": 160, "published": "Public", "date": "1565874717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 A,B,C;\n\nvec2 rotate(vec2 p, float theta)\n{\n    return p * cos(theta) + vec2(-p.y, p.x) * sin(theta);\n}\n\nfloat deRoundBox(vec3 p, vec3 s, float r)\n{\n   return length(p-clamp(p,-s,s))-r;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 solve(inout vec3 p, vec3 forward, float l1, float l2)\n{\n    float len = min(length(p), l1+l2);\n    float y=(len+(l1*l1-l2*l2)/len)/2.0, x=sqrt(l1*l1-y*y);\n    p = normalize(p*vec3(1,1,-1))*len;\n    return normalize(cross(p,cross(p,forward)))*x+p/len*y;\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float t){\n  return mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nvec3 bezierHinge(vec3 a, vec3 b, vec3 c, float t)\n{\n  float k=0.7;\n  return mix(\n      mix(a,b,t*(1.0+k)),\n      mix(b,c,t*(1.0+k)-k),\n      clamp(t*(1.0+k*4.0)-k*2.0,0.0,1.0));\n}\n\nvec3 func(float t)\n{\n    return mix(bezier(A,B,C,t), bezierHinge(A,B,C,t),step(0.0,sin(iTime*0.3)));\n\t//return bezier(A,B,C,t);\n\t//return bezierHinge(A,B,C,t);\n}\n\nfloat closest(vec3 p)\n{\n    float ITR =25.0, pitch = 1.0, t = 0.5, de = 1e9;   \n    for(int j=0;j<2;j++)\n    {\n        float t0 = t-pitch*0.5;\n        pitch /= ITR;\n        for(float i=0.0; i<=ITR; i++) \n        {\n            t0 += pitch;\n            float de0=distance(p,func(t0));\n            if (de0<de)\n            {\n                de = de0;\n                t=t0;\n            }       \n        }\n    }\n    return t;\n}\n\nfloat de01(vec3 p)\n{\n    float l1=1.0,l2=1.0;\n\tA=vec3(0,0,0);\n    C= vec3(0,1.0,sin(iTime)*1.2);\n    vec3 forward = vec3(0,0,1);\n    B = solve(C,forward,l1,l2);\n    float t = closest(p);\n    vec3 u = normalize(cross(A-B,C-B));\n    vec3 w = normalize(func(t+0.01) -func(t-0.01));\n    vec3 v = cross(u,w);\n    p -= func(t);  \n    p = vec3(dot(p,u), dot(p,v),dot(p,w));\n    \n    return mix(sdTorus(p, vec2(0.2,0.1)),deRoundBox(p,vec3(0.1),0.05),step(0.0,sin(iTime*0.5)));\n    //return sdTorus(p, vec2(0.2,0.1));\n    //return deRoundBox(p,vec3(0.1),0.05);\n    //return length(p)-0.15;\n}\n\n\nfloat map(vec3 p)\n{\n    p.xz = rotate(p.xz,iTime*0.3);\n    return de01(p);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1,-1)*0.01;\n    return normalize(\n        e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+ \n        e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n \tvec3 col = vec3(0.2);\n    col *= max(2.4 - length(uv), 0.0);\n    vec3 ro = vec3(0, 0.8, 3);\n    vec3 rd = normalize(vec3(uv, -2.0));\n    float ITR=80.0, t=0.0, d, a=1.0, maxd=10.0, st=1.0/ITR;\n    for(float i = 0.0; i < ITR; i++)\n    {\n        t += d = map(ro+rd*t);\n        if(d<0.001 || t>maxd) break;\n        a -= st;\n    }\n    if(d<0.001)\n    {\n        vec3 p = ro+t*rd;\n        vec3 li = normalize(vec3(1));\n        vec3 nor = calcNormal(p);\n\t    col = vec3(0.2, 0.8, 0.5);\n        col *= a*a*a; \n\t    col *= clamp(dot(nor,li),0.4,1.0);\n        col *= max(0.5+0.5*nor.y,0.0);\n        col += pow(clamp(dot(reflect(rd, nor),li),0.0,1.0),80.0);\n        col = pow(col,vec3(0.6));\n    }\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 47, 47, 107], [109, 109, 152, 152, 191], [193, 193, 224, 224, 289], [291, 291, 351, 351, 550], [552, 552, 597, 597, 638], [640, 640, 691, 691, 819], [821, 821, 841, 841, 982], [984, 984, 1007, 1007, 1405], [1407, 1407, 1427, 1427, 1989], [1992, 1992, 2011, 2011, 2068], [2070, 2070, 2095, 2095, 2245], [2247, 2247, 2304, 2304, 3083]]}
{"id": "wlBXWK", "name": "Atmospheric scattering explained", "author": "skythedragon", "description": "A simple explanation of how atmospheric scattering works, based on the scratchapixel implementation\nDrag the mouse to change the time of day!\n\nThe development repo of this shader: https://github.com/Dimev/atmosphere-shader\n", "tags": ["raymarching", "tutorial", "sky", "scattering", "atmosphere", "rayleigh", "explanation", "mie", "absorption", "ozone"], "likes": 54, "viewed": 6264, "published": "Public API", "date": "1567099330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMIT License\n\nCopyright (c) 2019 - 2021 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nUpdate 1 (25-9-2019): added 2 lines to prevent mie from shining through objects inside the atmosphere\nUpdate 2 (2-10-2019): made use of HW_PERFORMANCE to improve performance on mobile (reduces number of samples), also added a sun\nUpdate 3 (5-10-2019): added a license\nUpdate 4 (28-11-2019): atmosphere now correctly blocks light from the scene passing through, and added an ambient scattering term\nUpdate 5 (28-11-2019): mouse drag now changes the time of day\nUpdate 6 (28-11-2019): atmosphere now doesn't use the ray sphere intersect function, meaning it's only one function\nUpdate 7 (22-12-2019): Compacted the mie and rayleigh parts into a single vec2 + added a basic skylight\nUpdate 8 (15-5-2020): Added ozone absorption (Can also be used as absorption in general)\nUpdate 9 (6-5-2021): Changed the ozone distribution from 1 / cosh(x) to 1 / (x^2 + 1), and removed the clamp, better integration is planned\nUpdate 10 (6-5-2021): Changed the integrator to be a bit better, but it might have broken it a bit as well (and it's not 100% done yet) \nUpdate 11 (18-5-2021): Changed the integrator again, to fix it, because apparently it got worse since last update\nUpdate 12 (19-5-2021): Found a slight issue at certain view angles backwards, fixed with a simple max\nUpdate 13 (Planned): Change the integration again, according to seb hillaire: transmittance + total instead of optical depth and total\n                     See Enscape clouds, this hopefully improves the quality\n\nScattering works by calculating how much light is scattered to the camera on a certain path/\nThis implementation does that by taking a number of samples across that path to check the amount of light that reaches the path\nand it calculates the color of this light from the effects of scattering.\n\nThere are two types of scattering, rayleigh and mie\nrayleigh is caused by small particles (molecules) and scatters certain colors better than others (causing a blue sky on earth)\nmie is caused by bigger particles (like water droplets), and scatters all colors equally, but only in a certain direction. \nMie scattering causes the red sky during the sunset, because it scatters the remaining red light\n\nTo know where the ray starts and ends, we need to calculate where the ray enters and exits the atmosphere\nWe do this using a ray-sphere intersect\n\nThe scattering code is based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\nwith some modifications to allow moving the planet, as well as objects inside the atmosphere, correct light absorbsion\nfrom objects in the scene and an ambient scattering term tp light up the dark side a bit if needed\n            \nthe camera also moves up and down, and the sun rotates around the planet as well\n\nNote: \tBecause rayleigh is a long word to type, I use ray instead on most variable names\n\t\tthe same goes for position (which becomes pos), direction (which becomes dir) and optical (becomes opt)\n*/\n\n// first, lets define some constants to use (planet radius, position, and scattering coefficients)\n#define PLANET_POS vec3(0.0) /* the position of the planet */\n#define PLANET_RADIUS 6371e3 /* radius of the planet */\n#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */\n// scattering coeffs\n#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */\n#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */\n#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */\n#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */\n#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */\n// and the heights (how far to go up before the scattering has no effect)\n#define HEIGHT_RAY 8e3 /* rayleigh height */\n#define HEIGHT_MIE 1.2e3 /* and mie */\n#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */\n#define ABSORPTION_FALLOFF 4e3 /* how much the absorption decreases the further away it gets from the maximum height */\n// and the steps (more looks better, but is slower)\n// the primary step has the most effect on looks\n#if HW_PERFORMANCE==0\n// edit these if you are on mobile\n#define PRIMARY_STEPS 12 \n#define LIGHT_STEPS 4\n# else\n// and these on desktop\n#define PRIMARY_STEPS 32 /* primary steps, affects quality the most */\n#define LIGHT_STEPS 8 /* light steps, how much steps in the light direction are taken */\n#endif\n\n// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space\n#define CAMERA_MODE 2\n\n/*\nNext we'll define the main scattering function.\nThis traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.\nFor every sample, we'll also trace a ray in the direction of the light, \nbecause the color that reaches the sample also changes due to scattering\n*/\nvec3 calculate_scattering(\n\tvec3 start, \t\t\t\t// the start of the ray (the camera position)\n    vec3 dir, \t\t\t\t\t// the direction of the ray (the camera vector)\n    float max_dist, \t\t\t// the maximum distance the ray can travel (because something is in the way, like an object)\n    vec3 scene_color,\t\t\t// the color of the scene\n    vec3 light_dir, \t\t\t// the direction of the light\n    vec3 light_intensity,\t\t// how bright the light is, affects the brightness of the atmosphere\n    vec3 planet_position, \t\t// the position of the planet\n    float planet_radius, \t\t// the radius of the planet\n    float atmo_radius, \t\t\t// the radius of the atmosphere\n    vec3 beta_ray, \t\t\t\t// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\n    vec3 beta_mie, \t\t\t\t// the amount mie scattering scatters colors\n    vec3 beta_absorption,   \t// how much air is absorbed\n    vec3 beta_ambient,\t\t\t// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter\n    float g, \t\t\t\t\t// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\n    float height_ray, \t\t\t// how high do you have to go before there is no rayleigh scattering?\n    float height_mie, \t\t\t// the same, but for mie\n    float height_absorption,\t// the height at which the most absorption happens\n    float absorption_falloff,\t// how fast the absorption falls off from the absorption height\n    int steps_i, \t\t\t\t// the amount of steps along the 'primary' ray, more looks better but slower\n    int steps_l \t\t\t\t// the amount of steps along the light ray, more looks better but slower\n) {\n    // add an offset to the camera position, so that the atmosphere is in the correct position\n    start -= planet_position;\n    // calculate the start and end position of the ray, as a distance along the ray\n    // we do this with a ray sphere intersect\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (atmo_radius * atmo_radius);\n    float d = (b * b) - 4.0 * a * c;\n    \n    // stop early if there is no intersect\n    if (d < 0.0) return scene_color;\n    \n    // calculate the ray length\n    vec2 ray_length = vec2(\n        max((-b - sqrt(d)) / (2.0 * a), 0.0),\n        min((-b + sqrt(d)) / (2.0 * a), max_dist)\n    );\n    \n    // if the ray did not hit the atmosphere, return a black color\n    if (ray_length.x > ray_length.y) return scene_color;\n    // prevent the mie glow from appearing if there's an object in front of the camera\n    bool allow_mie = max_dist > ray_length.y;\n    // make sure the ray is no longer than allowed\n    ray_length.y = min(ray_length.y, max_dist);\n    ray_length.x = max(ray_length.x, 0.0);\n    // get the step size of the ray\n    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);\n    \n    // next, set how far we are along the ray, so we can calculate the position of the sample\n    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere\n    // if it's inside, it should start at the position of the camera\n    // the min statement makes sure of that\n    float ray_pos_i = ray_length.x + step_size_i * 0.5;\n    \n    // these are the values we use to gather all the scattered light\n    vec3 total_ray = vec3(0.0); // for rayleigh\n    vec3 total_mie = vec3(0.0); // for mie\n    \n    // initialize the optical depth. This is used to calculate how much air was in the ray\n    vec3 opt_i = vec3(0.0);\n    \n    // we define the density early, as this helps doing integration\n    // usually we would do riemans summing, which is just the squares under the integral area\n    // this is a bit innefficient, and we can make it better by also taking the extra triangle at the top of the square into account\n    // the starting value is a bit inaccurate, but it should make it better overall\n    vec3 prev_density = vec3(0.0);\n    \n    // also init the scale height, avoids some vec2's later on\n    vec2 scale_height = vec2(height_ray, height_mie);\n    \n    // Calculate the Rayleigh and Mie phases.\n    // This is the color that will be scattered for this ray\n    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them\n    float mu = dot(dir, light_dir);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n    \n    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it\n    for (int i = 0; i < steps_i; ++i) {\n        \n        // calculate where we are along this ray\n        vec3 pos_i = start + dir * ray_pos_i;\n        \n        // and how high we are above the surface\n        float height_i = length(pos_i) - planet_radius;\n        \n        // now calculate the density of the particles (both for rayleigh and mie)\n        vec3 density = vec3(exp(-height_i / scale_height), 0.0);\n        \n        // and the absorption density. this is for ozone, which scales together with the rayleigh, \n        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height\n        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side\n        float denom = (height_absorption - height_i) / absorption_falloff;\n        density.z = (1.0 / (denom * denom + 1.0)) * density.x;\n        \n        // multiply it by the step size here\n        // we are going to use the density later on as well\n        density *= step_size_i;\n        \n        // Add these densities to the optical depth, so that we know how many particles are on this ray.\n        // max here is needed to prevent opt_i from potentially becoming negative\n        opt_i += max(density + (prev_density - density) * 0.5, 0.0);\n        \n        // and update the previous density\n        prev_density = density;\n\n        // Calculate the step size of the light ray.\n        // again with a ray sphere intersect\n        // a, b, c and d are already defined\n        a = dot(light_dir, light_dir);\n        b = 2.0 * dot(light_dir, pos_i);\n        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);\n        d = (b * b) - 4.0 * a * c;\n\n        // no early stopping, this one should always be inside the atmosphere\n        // calculate the ray length\n        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));\n\n        // and the position along this ray\n        // this time we are sure the ray is in the atmosphere, so set it to 0\n        float ray_pos_l = step_size_l * 0.5;\n\n        // and the optical depth of this ray\n        vec3 opt_l = vec3(0.0);\n        \n        // again, use the prev density for better integration\n        vec3 prev_density_l = vec3(0.0);\n        \n        // now sample the light ray\n        // this is similar to what we did before\n        for (int l = 0; l < steps_l; ++l) {\n\n            // calculate where we are along this ray\n            vec3 pos_l = pos_i + light_dir * ray_pos_l;\n\n            // the heigth of the position\n            float height_l = length(pos_l) - planet_radius;\n\n            // calculate the particle density, and add it\n            // this is a bit verbose\n            // first, set the density for ray and mie\n            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);\n            \n            // then, the absorption\n            float denom = (height_absorption - height_l) / absorption_falloff;\n            density_l.z = (1.0 / (denom * denom + 1.0)) * density_l.x;\n            \n            // multiply the density by the step size\n            density_l *= step_size_l;\n            \n            // and add it to the total optical depth\n            opt_l += max(density_l + (prev_density_l - density_l) * 0.5, 0.0);\n            \n            // and update the previous density\n            prev_density_l = density_l;\n\n            // and increment where we are along the light ray.\n            ray_pos_l += step_size_l;\n            \n        }\n        \n        // Now we need to calculate the attenuation\n        // this is essentially how much light reaches the current sample point due to scattering\n        vec3 attn = exp(-beta_ray * (opt_i.x + opt_l.x) - beta_mie * (opt_i.y + opt_l.y) - beta_absorption * (opt_i.z + opt_l.z));\n\n        // accumulate the scattered light (how much will be scattered towards the camera)\n        total_ray += density.x * attn;\n        total_mie += density.y * attn;\n\n        // and increment the position on this ray\n        ray_pos_i += step_size_i;\n    \t\n    }\n    \n    // calculate how much light can pass through the atmosphere\n    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));\n    \n\t// calculate and return the final color\n    return (\n        \tphase_ray * beta_ray * total_ray // rayleigh color\n       \t\t+ phase_mie * beta_mie * total_mie // mie\n            + opt_i.x * beta_ambient // and ambient\n    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly\n}\n\n/*\nA ray-sphere intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray sphere intersect built in\n*/\n\nvec2 ray_sphere_intersect(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {\n\n    // slightly bend the surface normal towards the light direction\n    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));\n    \n    // and sample the atmosphere\n    return calculate_scattering(\n    \tsample_pos,\t\t\t\t\t\t// the position of the camera\n        surface_normal, \t\t\t\t// the camera vector (ray direction of this pixel)\n        3.0 * ATMOS_RADIUS, \t\t\t// max dist, since nothing will stop the ray here, just use some arbitrary value\n        background_col,\t\t\t\t\t// scene color, just the background color here\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height\n        LIGHT_STEPS, \t\t\t\t\t// steps in the ray direction\n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n}\n\n/*\nThe following function returns the scene color and depth \n(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)\n\nin this case, the function renders a green sphere on the place where the planet should be\ncolor is in .xyz, distance in .w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {\n    \n    // the color to use, w is the scene depth\n    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);\n    \n    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white\n    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);\n    \n    // get where the ray intersects the planet\n    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); \n    \n    // if the ray hit the planet, set the max distance to that ray\n    if (0.0 < planet_intersect.y) {\n    \tcolor.w = max(planet_intersect.x, 0.0);\n        \n        // sample position, where the pixel is\n        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;\n        \n        // and the surface normal\n        vec3 surface_normal = normalize(sample_pos);\n        \n        // get the color of the sphere\n        color.xyz = vec3(0.0, 0.25, 0.05); \n        \n        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law\n        vec3 N = surface_normal;\n        vec3 V = -dir;\n        vec3 L = light_dir;\n        float dotNV = max(1e-6, dot(N, V));\n        float dotNL = max(1e-6, dot(N, L));\n        float shadow = dotNL / (dotNL + dotNV);\n        \n        // apply the shadow\n        color.xyz *= shadow;\n        \n        // apply skylight\n        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);\n    }\n    \n\treturn color;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 uv    = coord.xy / resolution.xy - vec2(0.5);\n         uv.x *= resolution.x / resolution.y;\n\n    return normalize(vec3(uv.x, uv.y, -1.0));\n}\n\n/*\nFinally, draw the atmosphere to screen\n\nwe first get the camera vector and position, as well as the light dir\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the camera vector\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord);\n    \n    // get the camera position, switch based on the defines\n#if CAMERA_MODE==0\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);\n#endif\n#if CAMERA_MODE==1\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS , ATMOS_RADIUS);\n#endif\n#if CAMERA_MODE==2\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS + (-cos(iTime / 2.0) * (ATMOS_RADIUS - PLANET_RADIUS - 1.0)), 0.0);\n#endif\n#if CAMERA_MODE==3\n    float offset = (1.0 - cos(iTime / 2.0)) * ATMOS_RADIUS;\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 1.0, offset);\n#endif\n    // get the light direction\n    // also base this on the mouse position, that way the time of day can be changed with the mouse\n    vec3 light_dir = iMouse.y == 0.0 ? \n        normalize(vec3(0.0, cos(-iTime/8.0), sin(-iTime/8.0))) : \n    \tnormalize(vec3(0.0, cos(iMouse.y * -5.0 / iResolution.y), sin(iMouse.y * -5.0 / iResolution.y)));\n    \n    // get the scene color and depth, color is in xyz, depth in w\n    // replace this with something better if you are using this shader for something else\n    vec4 scene = render_scene(camera_position, camera_vector, light_dir);\n    \n    // the color of this pixel\n    vec3 col = vec3(0.0);//scene.xyz;\n    \n    // get the atmosphere color\n    col += calculate_scattering(\n    \tcamera_position,\t\t\t\t// the position of the camera\n        camera_vector, \t\t\t\t\t// the camera vector (ray direction of this pixel)\n        scene.w, \t\t\t\t\t\t// max dist, essentially the scene depth\n        scene.xyz,\t\t\t\t\t\t// scene color, the color of the current pixel being rendered\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height \n        PRIMARY_STEPS, \t\t\t\t\t// steps in the ray direction \n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n        \n    // apply exposure, removing this makes the brighter colors look ugly\n    // you can play around with removing this\n    col = 1.0 - exp(-col);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBXWK.jpg", "access": "shaders20k", "license": "mit", "functions": [[5752, 6075, 7734, 7829, 15295], [15297, 15488, 15650, 15787, 16066], [16068, 16254, 16344, 16413, 17996], [17998, 18385, 18440, 18491, 19945], [19947, 20147, 20200, 20200, 20347], [20349, 20465, 20520, 20554, 23518]]}
{"id": "wlBXz1", "name": "waterfall", "author": "foran", "description": "waterfall", "tags": ["waterfall"], "likes": 2, "viewed": 405, "published": "Public", "date": "1565023338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n \n \n// these seem popular nowdays let's try it with a twist --jz\n \n// how many curly fries do we need?\n#define MAX_ITER 12\n void mainImage(out vec4 fragColor,in vec2 fragCoord)\n//void main( void )\n {\n \n\t//vec2 p = vv_FragNormCoord;\n\tvec2 p=(2.4*fragCoord.xy-iResolution.xy)/iResolution.xy;\n\tvec2 i = p;\n \n\tfloat c = 0.0;\n \n\tfloat d = length(i);\n\tfloat r = atan(i.x, i.y);\n\tfor (int n = 0; n < MAX_ITER; n++) {\n\t\ti = i + vec2( \n\t\t\t\t1.0/float((n+1) * MAX_ITER/(n+1)) * d * sin(r * i.y * (pow(float(n), 2.0 - abs(sin(iTime * 0.022))) * float(MAX_ITER)/float(n+1)) + iTime * 1.49),\n\t\t\t\t1.0/float((n+1) * MAX_ITER/(n+1)) * d * cos(r * i.x * (pow(float(n), 2.0 - abs(cos(iTime * 0.021))) * float(MAX_ITER)/float(n+1)) + iTime * 1.51)\n\t\t\t);\n\t\t\n\t\td = length(i);\n\t        r = atan(i.x, i.y);\n\t}\n\t\n\tc = (1.50-d);\n\tc = pow(c, .52);\n\tfragColor = vec4( vec3( c*abs(sin(i.x + 1.0)), c*abs(sin(i.y + 4.0)), c*abs(sin(i.x+i.y + 4.0))) * vec3(.6501,1.15,1.5), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 170, 245, 277, 997]]}
{"id": "WlBXzy", "name": "3D blocks ", "author": "ParaBellum", "description": "Testing raycasting in 2D grid", "tags": ["3d", "raycasting", "light"], "likes": 14, "viewed": 361, "published": "Public", "date": "1566238604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AREA 60\n\nfloat r1D(float r)\n{\n    return fract(sin(r*12.43)*519803.43);\n}\n\nfloat rand(vec2 p)\n{\n  return fract(sin(dot(p,vec2(12.43,98.21)))*519803.43);\n}\n\nfloat map(vec2 v, float s, vec2 z)\n{\n    if (z.x >= 0. && z.y >= 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(floor(v));\n    }\n    if (z.x < 0. && z.y >= 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(vec2(ceil(v.x-1.), floor(v.y)));\n    }\n    if (z.x < 0. && z.y < 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(ceil(v-1.));\n    }\n    if (z.x >= 0. && z.y < 0.)\n    {\n        v*=z;\n        v*=s;\n\t\treturn rand(vec2(floor(v.x), ceil(v.y-1.)));\n    }\n}\n\nfloat grid2D(vec3 ro, vec3 rd, vec2 st)\n{\n    vec3 p;\n    vec3 u=ro;\n    \n    int j = 1;\n    for (int i=0;i<AREA;i+=0)\n    {\n        if (j > AREA)\n            break;\n        float h=0.;\n        if (rd.x != 0.)\n        {\n            p.x=floor(u.x)+1.;\n            h=(p.x-u.x)/rd.x;\n            p.y=h*rd.y+u.y;\n        }\n        else\tp.y=floor(u.y)+1.;\n        if (p.y>=floor(u.y)+1.)\n        {\n            p.y=floor(u.y)+1.;\n            h=(p.y-u.y)/rd.y;\n            p.x=h*rd.x+u.x;\n        }\n        else{j++;}\n        \n        float g=(p.x-u.x)/rd.x;\n        p.z=g*rd.z+u.z;\n        float t=map(u.xy,1.,sign(st))*abs(sin(iTime)*rand(floor(u.xy))+1.);\n        if (u.z<t)\n        {\n            return length(u-ro);\n            break;\n        }\n        if (p.z<t)\n        {\n            float z = p.z-t;\n            h=z/rd.z;\n            float x = h*rd.x;\n            h=x/rd.x;\n            float y = h*rd.y;\n            u = p-vec3(x,y,z);\n            return length(u-ro);\n        }\n        u=p;\n    }\n    return 0.;\n}\n\nvec3 normal(vec3 p, vec2 st)\n{\n    float d = length(p);\n    vec2 e = vec2(.01, 0.);\n   \tvec3 n = vec3(map(p.xy-e.xy,1.,sign(st))-map(p.xy+e.xy,1.,sign(st)),\n                  map(p.xy-e.yx,1.,sign(st))-map(p.xy+e.yx,1.,sign(st)),\n                  e.x);\n    return normalize(n);\n}\n\n#define B vec3(.6,.1,1.)\n#define G vec3(.6,1.,.1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 st=uv;\n    vec3 ro=vec3(0.,0.,10.);\n   \tvec3 rd=normalize(vec3(abs(st),-1.));\n    \n    vec3 col=vec3(0.);\n    \n    float d = grid2D(ro, rd, st);\n    vec3 p = ro+rd*d;\n    vec3 n = normal(p,st);\n    vec3 l = vec3(cos(iTime),sin(iTime),.25)*10.;\n    vec3 ld = normalize(l-p);\n    float diff = max(dot(ld,n),0.);\n    col += diff*p.z+(p.z+.1)*.1;\n    fragColor = vec4(sqrt(col*mix(B,G,p.z*1.5)), 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 37, 37, 81], [83, 83, 103, 103, 162], [164, 164, 200, 200, 632], [634, 634, 675, 675, 1648], [1650, 1650, 1680, 1680, 1930], [1983, 1983, 2040, 2040, 2538]]}
{"id": "wlfSDs", "name": "VenusianStorm", "author": "Taron", "description": "Making a simple noise with a few layers and a bit of swirling...hmm...greenish...gotta be on Venus. (?)\nOh, ya, have fun with the mouse... gooey somehow.", "tags": ["noise", "swirl", "fog", "turbulence", "smoke", "vortex", "dust"], "likes": 12, "viewed": 309, "published": "Public", "date": "1564627549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 p)\n{\n    p = floor(p);\n    p = fract(p*vec3(283.343, 251.691, 634.127));\n    p += dot(p, p+23.453);\n    return fract(p.x*p.y);\n}\nfloat noiseblend(vec3 p)\n{\n    vec2 off = vec2(1.,0.);\n    return mix(\tmix(\tmix(noise(p), noise(p+off.xyy),fract(p.x)),\n           \t\t\t\tmix(noise(p+off.yxy), noise(p+off.xxy),fract(p.x)),fract(p.y)),\n               \tmix(\tmix(noise(p+off.yyx), noise(p+off.xyx),fract(p.x)),\n           \t\t\t\tmix(noise(p+off.yxx), noise(p+off.xxx),fract(p.x)),fract(p.y))\n               ,fract(p.z));\n    \n}\nfloat turb(vec3 p)\n{\n    p *=4.;\n    vec3 dp = vec3(p.xy,p.z+iTime*.25);\n    float inc = 0.75;\n    float div = 1.75;\n    vec3 octs = dp*2.13;\n    float n = noiseblend(dp);\n    for(float i=0.; i<5.; i++)\n    {\n        float ns = noiseblend(octs);\n        n += inc*ns;\n\t\t\n        octs *=2.+(vec3(ns,noiseblend(octs+vec3(n,0.,0.1)),0.));\n        inc *=.5*n;\n        div +=inc;\n    }\n    float v = n/div;\n    v *= 1.-max(0.,1.2-length(vec3(.5,0.,6.)-p));\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = 1.+(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    uv *=1.+.2*length(uv);\n    float uvlen = 1.-length(uv);\n    float tt = .5*iTime+(0.3-.3*uvlen*uvlen);\n    vec2 rot = vec2(sin(tt),cos(tt));\n    uv = vec2(uv.x*rot.x+uv.y*rot.y, uv.x*rot.y-uv.y*rot.x);\n    mouse = vec2(mouse.x*rot.x+mouse.y*rot.y, mouse.x*rot.y-mouse.y*rot.x);\n    vec3 ro = vec3(mouse,-1.);\n    vec3 rd = normalize(vec3(uv,5.)-ro);\n    \n    \n    \n    vec3 col = vec3(0);\n    rd.z+=tt*.01;\n    float nv = turb(rd);\n    for(float i=0.; i<1.; i+=.2)\n    {\n        nv *=.5;\n        nv = turb(vec3(rd.xy,rd.z+i));\n    \tcol += (1.5-i)*vec3(nv,nv*nv*(3.-2.*nv), nv*nv);\n    }\n    col /=5.;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 145], [146, 146, 172, 172, 531], [532, 532, 552, 552, 998], [1000, 1000, 1057, 1108, 1876]]}
{"id": "wljSDD", "name": "raymarchingpractice001(1h)", "author": "Hirai_worthless", "description": "1hour", "tags": ["raymarching"], "likes": 2, "viewed": 89, "published": "Public", "date": "1565956413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nvec2 path(float t){\n\tfloat x = sin(t) + cos(t / 2.) + sin(t / 4.);\n    float y = sin(t) + sin(t/2.) + cos(t/4.);\n    return vec2(x,y)/4.;\n}\nmat2 genRot(float val){\n    return mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nvec3 modCell(vec3 p,vec3 c){\n\tp.x = (fract(p.x / c.x + 0.5) - 0.5) * c.x;\n    p.y = (fract(p.y / c.y + 0.5) - 0.5) * c.y;\n    p.z = (fract(p.z / c.z + 0.5) - 0.5) * c.z;\n    return p;\n}\n\nvec2 pmod(vec2 p,float c){\n    p.xy *= genRot(PI/c);\n\tfloat at = atan(p.y/p.x);\n    float r = length(p);\n    at = mod(at,PI * 2. / c);\n    vec2 re = vec2(cos(at) * r,sin(at) * r);\n    re.xy *= genRot(-PI/c);\n    return re;\n}\nfloat roomsize = 7.5;\nvec2 map(vec3 p){\n    p.xy += path(p.z);\n    //p = modCell(p,vec3(roomsize));\n    p = modCell(p,vec3(vec2(roomsize),2.0));\n    p.xy *= genRot(iTime);\n    p.xy = pmod(p.xy,12.);\n\tvec2 sp = vec2(length(p - vec3(3.0,0.,0.)) - 0.5,1.0);\n    vec3 q = p;\n    q.xz -= vec2(3.0,0.);\n    q.xy *= genRot(iTime);\n    float cyl = length(q.xz) - 0.25;\n    cyl = max(cyl,-length(p.xy) + 1.);\n    cyl = max(cyl,length(p.xy) - 3.00);\n    cyl = min(cyl,length(p.xy - vec2(3.,0.)) - 0.1);\n    return vec2(cyl,0.0);\n}\nvec2 trace(vec3 r,vec3 o){\n    float t = 0.0;\n    float id = -1.0;\n    for(int i = 0; i < 128; i++){\n    \tvec3 p = o + r * t;\n        vec2 d = map(p);\n        t += d.x * 0.5;\n        id = d.y;\n    }\n    return vec2(t,id);\n}\n\nvec3 ray (vec2 uv,float z){\n vec3 r = normalize(vec3(uv,z));\n    r.xz *= genRot(-PI/6.);\n    r.yz *= genRot(-PI / 8.);\n    r.xy *= genRot(iTime /1.);\n    return r;\n}\nvec3 cam (float t){\n\tvec3 c = vec3(roomsize/2.,roomsize/2.,-6.5 + iTime * 8.0);\n    return c;\n}\n\nvec3 getColor(vec3 r, vec3 o, vec2 data){\n    float t = data.x;\n    vec3 p = o + r * t;\n    vec3 col1 = vec3(sin(p.x) * 0.5 + 0.75,sin(p.y) * 0.5 + 0.75,sin(p.z) * 0.5 + 0.75);\n    vec3 col2 = vec3(cos(p.x) * 0.5 + 0.75,cos(p.y) * 0.5 + 0.75,cos(p.z) * 0.5 + 0.75);\n\tfloat fog = 1./(1. + t * t * 0.01);\n    float a = sin(p.z - iTime * 4.) * 0.5 + 0.5;\n    col1 = mix(col1,col2,a);\n    col1 = mix(col1,vec3(sin(iTime) * 0.5 + 0.5),1. - fog);\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    vec3 o = cam(iTime);\n    vec3 r = ray(uv,1.5);\n    vec2 data = trace(r,o);\n    \n    // Time varying pixel color\n    vec3 col =getColor(r,o,data);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 162], [163, 163, 186, 186, 243], [244, 244, 272, 272, 429], [431, 431, 457, 457, 655], [678, 678, 695, 695, 1176], [1177, 1177, 1203, 1203, 1400], [1402, 1402, 1429, 1429, 1567], [1568, 1568, 1587, 1587, 1663], [1665, 1665, 1706, 1706, 2124], [2126, 2126, 2183, 2233, 2507]]}
{"id": "wljSDh", "name": "Cartoon Landscape", "author": "ikuto", "description": "2d cartoon green ecology flat landscape.", "tags": ["2d", "perlinnoise", "cartoon", "water", "tree", "toon", "hill", "sailingboat", "solarpanel"], "likes": 8, "viewed": 589, "published": "Public API", "date": "1566135204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define ALPHA(d) 1. - clamp(d*200., 0., 1.)\n\nfloat hash(float p) { vec3 p3 = fract(vec3(p) * 0.1031); p3 += dot(p3, p3.yzx + 19.19); return fract((p3.x + p3.y) * p3.z); }\n\nvec2 rotate(vec2 v, float a) { return cos(a)*v + sin(a)*vec2(v.y,-v.x); }\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p) { return (int(1e4*hash) & 1) == 0 ? p : -p; }\n\nfloat perlinNoise1D(float p) {\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence)  {\n    float total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n    for(int i = 0; i < octaves; ++i) {\n        total += perlinNoise1D(pos * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total / maxValue;\n}\n\n//2d distance functions from http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2 ) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdCircle(vec2 p, float r) { return length(p) - r; }\n\nfloat sdBox(vec2 p, vec2 b) { vec2 d = abs(p)-b; return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0); }\n\nvec4 mixLayer(vec4 layer1, vec4 layer2) { return mix(layer1, layer2, layer2.a); }\n\nvec4 sky(vec2 uv) { \n    vec3 col = vec3(.3,.5,.8)-uv.y*.3;\n    col = mix(col, vec3(1.-uv.y,.6,.0), pow(1. - clamp(uv.y-.2,0.,1.), 2.));\n    return vec4(col, 1.); \n}\n\nvec4 sun(vec2 uv) {\n    vec2 d = uv - vec2(1.1, .8);\n    float t = pow(1./(1.+length(d)), 4.);\n\tvec3 col =  3. * vec3(.8, .7, .5) * t; //sun disk\n    float a = atan(d.y/d.x)+iTime;\n    col = mix(vec3(1.,1.,.5)*t*step(mod(a, PI/8.),PI/16.), col, t); //sun rays\n    return vec4(col, t);\n}\n\nvec4 hill(vec2 pos, vec2 size, vec3 col, bool snow) {\n\tfloat d = (pos.y - size.y*cos(pos.x*1./size.x));\n    if (abs(pos.x) > .5*PI*size.x || pos.y < 0.) return vec4(0.);\n    if (snow && pos.y > .7*size.y + .1*fbm(pos.x*8., 1, .5)) col = vec3(.95);\n    return vec4(col, ALPHA(d));\n}\n\nvec4 windmill(vec2 pos, float scale) {\n    pos/=scale;\n\tfloat d = sdBox(pos, vec2(.003, .15));\n    pos -= vec2(0.,.15);\n    d = min(d, sdCircle(pos, .01));\n#define WING d = min(d, sdTriangle(pos, vec2(0.), vec2(.1,-.09), vec2(.02,-.04)));\n    pos = rotate(pos, iTime); WING;\n    pos = rotate(pos, PI*2./3.); WING;\n    pos = rotate(pos, PI*2./3.); WING;\n    return vec4(vec3(1.), ALPHA(d));\n}\n\nvec4 grid(vec2 pos, vec3 v[4], vec3 col) {\n    for (int i = 0; i < 4; ++i) {\n        v[i].yz = rotate(v[i].yz, PI/4.);\n        v[i].xz = rotate(v[i].xz, .5*sin(iTime));\n        v[i]*=clamp(v[i].z+1., .2, 2.);\n    }\n    float d = sdTriangle(pos, v[0].xy, v[1].xy, v[2].xy);\n    d = min(d, sdTriangle(pos, v[0].xy, v[2].xy, v[3].xy));\n\treturn vec4(col, ALPHA(d));\n}\n\nvec4 solarPanel(vec2 pos, float scale) {\n \tpos/=scale;\n\tvec4 col = vec4(vec3(.8), ALPHA(sdBox(pos, vec2(.003, .1))));\n    pos -= vec2(0.,.1);\n    float w = .24, h = .12, dx = w / 4., dy = h / 2., k=1.;\n    for (float x = -w/2.; x < w/2.; x += dx) {\n        for (float y = -h/2.; y < h/2.; y += dy, k=-k) {\n            vec3 gridCol = k > 0. ? vec3(0.,.2,.6) : vec3(0.,.3,.5);\n        \tcol = mixLayer(col, grid(pos, vec3[](vec3(x,y,0.),vec3(x+dx,y,0.),vec3(x+dx,y+dy,0.),vec3(x,y+dy,0.)), gridCol));\n        }\n\t}\n    return col;\n}\n\nvec4 opU(vec4 c1, vec4 c2) {return c1.w < c2.w ? c1 : c2; } \n\nvec4 tree(vec2 pos, float scale) {\n \tpos/=scale;\n    vec4 col = vec4(vec3(.5), ALPHA(sdBox(pos, vec2(.008, .08))));\n    pos.x += .1*sin(2.*iTime) * pos.y;\n    col = mixLayer(col, vec4(vec3(.2, .32, .1), ALPHA(sdTriangle(pos, vec2(-.1, -.03), vec2(.1, -.03), vec2(0., .05)))));\n    col = mixLayer(col, vec4(vec3(.2, .36, .1), ALPHA(sdTriangle(pos, vec2(-.07, .02), vec2(.07, .02), vec2(0., .08)))));\n    col = mixLayer(col, vec4(vec3(.2, .34, .1), ALPHA(sdTriangle(pos, vec2(-.045, .06), vec2(.045, .06), vec2(0., .14)))));\n    return col;\n}\n\nvec4 mountain(vec2 uv) {\n\tvec4 col = mixLayer(vec4(0.), windmill(uv-vec2(.5, .2), .3));\n    col = mixLayer(col, hill(uv-vec2(-1.5, -.4), vec2(.2, .7), vec3(.2, .32, .1), true));\n    col = mixLayer(col, hill(uv-vec2(1.5, -.4), vec2(.3, 1.2), vec3(.62, .67, .68), true));\n    col = mixLayer(col, hill(uv-vec2(-.5, -.4), vec2(.5, .55), vec3(.0, .7, .2), false));\n    col = mixLayer(col, hill(uv-vec2(.5, -.4), vec2(.5, .6), vec3(.0, .7, .2), false));\n    col = mixLayer(col, hill(uv-vec2(-1., -.4), vec2(.4, .35), vec3(.2, .85, .4), false));\n\tcol = mixLayer(col, windmill(uv-vec2(-.5, .1), .45));\n\tcol = mixLayer(col, windmill(uv-vec2(1., -.05), .6));\n    col = mixLayer(col, hill(uv-vec2(1., -.4), vec2(.4, .3), vec3(.2, .85, .4), false));\n    col = mixLayer(col, hill(uv-vec2(.0, -.4), vec2(.5, .5), vec3(.2, .85, .4), false));\n    col = mixLayer(col, windmill(uv-vec2(.2, .1), .8));\n    col = mixLayer(col, windmill(uv-vec2(-.3, -.2), 1.));\n\tcol = mixLayer(col, windmill(uv-vec2(-1., .05), .7));\n   \tcol = mixLayer(col, solarPanel(uv-vec2(.3, -.2), 1.));\n    col = mixLayer(col, solarPanel(uv-vec2(-.8, -.1), .8));\n    col = mixLayer(col, tree(uv-vec2(1.2, -.2), 1.));\n    col = mixLayer(col, tree(uv-vec2(-1.1, -.1), .9));\n    col = mixLayer(col, tree(uv-vec2(-.1, -.15), .9));\n    col = mixLayer(col, tree(uv-vec2(0., .12), .6));\n    col = mixLayer(col, tree(uv-vec2(.1, .0), .6));\n    col = mixLayer(col, tree(uv-vec2(-.1, .1), .6));    \n    return col;  \n}\n\nvec4 building(vec2 uv) {\n    float d = uv.y - (.8*hash(floor(uv.x*8.))+.2);\n    vec3 col = vec3(.15, .35, .5);\n    return vec4(col, ALPHA(d));   \n}\n\nvec4 wave(vec2 uv, float height, float amplitude) {\n    float noise = amplitude * (fbm(uv.x*4., 4, .1) + fbm(uv.x*4. + iTime, 4, .1));\n    float d = uv.y - (noise + height);\n    return vec4(vec3(.0, .15, .4), 1.-clamp(d*30., 0., 1.));\n}\n\nvec4 water(vec2 uv) {\n\tvec4 col;\n    float height = -.4, amplitude = .005;\n    for (int i = 0; i < 5; ++i, uv.x+=10., height-=.13, amplitude+=.003)\n    \tcol = mixLayer(col, wave(uv, height, amplitude));\n    return col;\n}\n\nvec4 sailingBoat(vec2 uv) {\n    vec4 col = vec4(vec3(1.), ALPHA(sdBox(uv-vec2(0.,.13), vec2(.001, .1))));\n    vec2 p[4] = vec2[](vec2(-.1, .0), vec2(.1, .0), vec2(.15, .07), vec2(-.13,.05));\n    col = mixLayer(col, vec4(vec3(1.,.8,.0), ALPHA(sdTriangle(uv, p[0], p[1], p[3]))));\n    col = mixLayer(col, vec4(vec3(1.,.8,.0), ALPHA(sdTriangle(uv, p[1], p[2], p[3]))));\n    col = mixLayer(col, vec4(vec3(1.), ALPHA(sdTriangle(uv, vec2(.01,.23), vec2(.01,.08), vec2(.1,.08)))));\n    col = mixLayer(col, vec4(vec3(1.), ALPHA(sdTriangle(uv, vec2(-.01,.21), vec2(-.01,.08), vec2(-.08,.08)))));\n    return col;\n}\n\nvec4 render(vec2 uv) {\n\tvec4 col = sky(uv);\n    col = mixLayer(col, sun(uv));\n    col = mixLayer(col, building(uv));\n    col = mixLayer(col, mountain(uv));\n    col = mixLayer(col, water(uv));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    if (uv.y >= -.4) \n        fragColor = render(uv);\n    else //reflections\n        fragColor = mix(render(uv), render(vec2(uv.x, max(-.4, -uv.y*2.-1.2 + .04*fbm(uv.x*4.+iTime,4,.1)))), .1);\n        float w = iResolution.x / iResolution.y + .2;\n    \n    uv -= vec2(2.*w*fract(.05*iTime+.5)-w,-.7);\n    uv = rotate(uv, sin(5.*iTime) * .02);\n    fragColor = mixLayer(fragColor, sailingBoat(uv));\n    //reflection of the sailing boat\n    fragColor = mixLayer(fragColor, .3*sailingBoat(vec2(uv.x, -uv.y*2.-.05 + .04*fbm(uv.x*4.+iTime,4,.1))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 87, 87, 191], [193, 193, 223, 223, 266], [268, 268, 289, 289, 324], [326, 326, 359, 359, 403], [405, 405, 435, 435, 563], [565, 565, 620, 620, 916], [918, 1022, 1076, 1076, 1641], [1643, 1643, 1676, 1676, 1700], [1702, 1702, 1731, 1731, 1807], [1809, 1809, 1850, 1850, 1890], [1892, 1892, 1911, 1911, 2057], [2059, 2059, 2078, 2078, 2345], [2347, 2347, 2400, 2400, 2628], [2630, 2630, 2668, 2668, 3021], [3023, 3023, 3065, 3065, 3386], [3388, 3388, 3428, 3428, 3916], [3918, 3918, 3946, 3946, 3977], [3980, 3980, 4014, 4014, 4520], [4522, 4522, 4546, 4546, 5982], [5984, 5984, 6008, 6008, 6131], [6133, 6133, 6184, 6184, 6369], [6371, 6371, 6392, 6392, 6591], [6593, 6593, 6620, 6620, 7197], [7199, 7199, 7221, 7221, 7408], [7410, 7410, 7467, 7467, 8071]]}
{"id": "wljSWh", "name": "Hello Voronoi", "author": "2YY", "description": "My first voronoi playing.", "tags": ["voronoi"], "likes": 2, "viewed": 123, "published": "Public", "date": "1565784007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * https://thebookofshaders.com/12/\n */\nvec2 random2(vec2 p) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Some variables\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    float gridLength = 3. + sin(iTime * .2) * 1. + 1.;\n    vec2 gridCoords = floor(uv * gridLength);\n    vec2 gridFrag = fract(uv * gridLength);\n\n    // Calc min distance to random point by grid\n    float minDist = 1.;\n    for(int x=-1; x<=1; x++) {\n        for(int y=-1; y<=1; y++) {\n        \tvec2 neighborGridCoords = vec2(float(x), float(y));\n            vec2 randomPoint = random2(neighborGridCoords + gridCoords);\n            randomPoint = sin(iTime * randomPoint) * 0.5 + .5;\n            minDist = min(minDist, length(neighborGridCoords + randomPoint - gridFrag));\n        }\n    }\n\n    // Apply Post Effect\n    vec3 color = vec3(minDist);\n    color += step(.5, sin((20. * (uv.y * gridLength * 2.) + 10.) * color)) * (.2 + (sin(iTime * 2.) * .1 + .1));\n    color.r += uv.x * .1 + (sin(iTime) * .5 + .5) * .2;\n    color.g += uv.x * .1;\n    color.b += (1.-uv.y) * .1;\n    \n    // Apply Post Effect (Part 2)\n    color += step(.5, color) * uv.x * .1;\n    \n    // Apply Post Effect (Part 3);\n    color.r -= uv.x * .06;\n    color.g -= (1.0-uv.x) * .03;\n    color.b += (2.0-uv.y) * .1;\n\n    // Draw\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 66, 66, 156], [158, 158, 215, 237, 1451]]}
{"id": "wljSWw", "name": "Rusting metal", "author": "hexjay", "description": "metal is degrading over time", "tags": ["noise", "raymarch"], "likes": 5, "viewed": 183, "published": "Public", "date": "1566140446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\tToying with code from :\n\t@paulofalcao -> https://www.shadertoy.com/view/ldfGzr\n\tIQ raymarch reference and noise -> https://www.shadertoy.com/view/Xds3zN \n\tShane's texture bump mapping -> https://www.shadertoy.com/view/MlXSWX\n*/\n\nconst int ITER = 50;\nconst float PI = 3.14159265;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.9 );\n\nmat3 rotate3(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat ss(float mi,float ma,float a)\n{ // sineSignal (min,max,alpha)\n\treturn (sin(a)+1.)*(ma-mi)*0.5+mi;\n}\n\n\n//   /\n//---  Noise\n//   \\\n\n\nfloat noise( in vec2 x )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec2 p )\n{\n\tp*=3.;\n\tfloat f = 0.0;\n    f += 0.25000*noise( p ); p = m2*p*0.02;\n    f += 0.12500*noise( p ); p = m2*p*0.13;\n    f += 0.06250*noise( p ); p = m2*p*0.01;\n    f += 0.03125*noise( p ); p = m2*p*0.04;\n    f += 0.01500*noise( p );\n    return f/0.38375;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n//    /\n//----  Objects / Primitives\n//    \\\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n#if 0\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n#else\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n//    /\n//----  Operators\n//    \\\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p, float freq, float phase )\n{\n    float  c = cos(freq*p.y+phase);\n    float  s = sin(freq*p.y+phase);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\n//    /\n// ---  Field\n//    \\\n\nmat3 rotation;\n\nfloat distanceField(in vec3 p) \n{\n    vec2 res,res0,res1,res2;\n\tres = vec2(9999999.,0.);\n\n    float fbmp=fbm(p);\n        \n  \tp = opRep(p, vec3(10,10.,10.) );\n    \n    res1 = vec2(sdCapsule(p, vec3(0.,0.,-5.), vec3(0.,0.,5.),4.2 ), 000002.);\n    res = opU(res,res1);\n    res1 = vec2(sdCapsule(p, vec3(0.,-5.,0.), vec3(0.,5.,0.),4.2 ), 009900.);\n    res = opU(res,res1);\n    res1 = vec2(sdCapsule(p, vec3(-5.,0.,0.), vec3(5.,0.,0.),4.2 ), 999900.);\n    res2 = opU(res,res1);\n    \n    res1 = vec2( sdBox(p,vec3(5.,5.,5.)),990000);\n    res.x = opS(res1.x,res2.x);\n    \n    return res.x+fbmp*ss(0.,0.8,iTime/2.35);\n}\n\n//    /\n// ---  Texturing\n//    \\\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// from Shane : https://www.shadertoy.com/view/MlXSWX\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n//    /\n// ---  Main\n//\t  \\\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec3 bgColor = vec3 (0.1,0.0,0.0);\n\n  \tvec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  \tvec3 finalColor = vec3 (0.0);  \n  \n  \t//Camera animation\n  \tvec3 vuv=vec3(0,0,1);//Change camere up vector here\n  \t\n    vec3 prp=vec3(\n        \tss(-5.4,15.6,iTime/2.),\n        \tss(-2.,2.,iTime),\n        \t4. ); //Change camera path position here\n  \t\n        \t//2.5 , 2., 2.5 );\n        \t\n    vec3 vrp=vec3(\n        2.5,\n        2.5,\n        //ss(0.,8.,iTime) ); //Change camere view here\n        2.5);\n\n  \t//Camera setup\n  \tvec3 vpn=normalize(vrp-prp);\n  \tvec3 u=normalize(cross(vuv,vpn)*rotate3(vec3(ss(-0.3,0.3,iTime*0.63),0.,0.) ));\n  \tvec3 v=cross(vpn,u);\n  \tvec3 vcv=(prp+vpn);\n  \tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t//Raymarching\n  \tconst vec3 e=vec3(0.2,0,0);\n  \tconst float maxd=50.0; //Max depth\n\n  \tfloat s= 0.1;\n  \tvec3 c,p,n;\n\n  \tfloat f=1.0;\n  \tfor(int i=0;i<  ITER ; i++)\n    {\n    \tif (abs(s)<.01||f>maxd) break;\n    \tf+=s;\n    \tp=prp+scp*f;\n    \ts=distanceField(p);\n  \t}\n\n  \tif (f<maxd)\n    {\n    \t\n    \tn=normalize(\n      \tvec3(s-distanceField(p-e.xyy),\n        \ts-distanceField(p-e.yxy),\n        \ts-distanceField(p-e.yyx)));\n    \t\n        float texScale = 0.5;\n        n = doBumpMap(iChannel1, p*texScale, n,  0.40);\n        \n        float b=dot(n,normalize(prp-p));\n\t\t\n        c=tex3D(iChannel1, p*texScale, n)*4.;\n    \t\n        vec3 lightPos = vec3( 2.5,2.5,sin(iTime*1.1)*4. );\n        vec3 lightDir = normalize(lightPos-p);\n        float lightDistance = distance(lightPos,p);\n        \n        float b2=dot(lightDir,n);\n        \n        vec3 c1 = vec3( b*c+pow(b,8.) ) ;\n        vec3 c2 = vec3( c*(b2 + pow(b2, 8.) + 0.35)*1.5/(1.+lightDistance*.1+lightDistance*lightDistance*.005));  // Shane suggestion\n        \n        \n        finalColor = mix(c1,c2,.6);\n\t\tfinalColor*=0.44;\n    \n    \t// vignetting from : https://www.shadertoy.com/view/4lSXDm\n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tvec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    \tfloat Falloff = 0.35;\n        float rf = sqrt(dot(coord, coord)) * Falloff;\n\t    float rf2_1 = rf * rf + 1.0;\n\t    float e = 1.0 / (rf2_1 * rf2_1);\n    \n\t    vec4 src = vec4(finalColor,1.);\n\t\tfragColor = vec4(src.rgb * e, 1.0);    \n    \t//fragColor = vec4( finalColor, 1.);\n  \t} else \n    { // background color\n    \tbgColor = \n\t  \t\tvec3(0.1,0.1,0.1)*0.4;\n\t  \tfragColor=vec4(bgColor,1.);\n  \t}\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 438, 465, 465, 754], [756, 756, 793, 823, 861], [864, 893, 919, 919, 1063], [1065, 1065, 1091, 1091, 1296], [1298, 1298, 1319, 1319, 1572], [1574, 1574, 1595, 1595, 1777], [1779, 1825, 1850, 1850, 1865], [1867, 1867, 1902, 1902, 1928], [1930, 1930, 1961, 1961, 2048], [2050, 2050, 2095, 2095, 2135], [2137, 2137, 2170, 2170, 2223], [2225, 2225, 2261, 2261, 2503], [2505, 2505, 2557, 2557, 2671], [2673, 2673, 2709, 2709, 2957], [2959, 2959, 2995, 2995, 3094], [3096, 3096, 3134, 3134, 3375], [3377, 3377, 3402, 3402, 3439], [3441, 3441, 3466, 3466, 3524], [3526, 3526, 3551, 3551, 3616], [3618, 3618, 3653, 3653, 3720], [3722, 3722, 3757, 3757, 3824], [3826, 3826, 3863, 3863, 3914], [3917, 3952, 3985, 3985, 4011], [4013, 4013, 4043, 4043, 4076], [4078, 4078, 4111, 4111, 4136], [4138, 4138, 4171, 4171, 4196], [4198, 4198, 4228, 4228, 4257], [4259, 4259, 4308, 4308, 4442], [4445, 4492, 4525, 4525, 5103], [5105, 5140, 5162, 5162, 5206], [5208, 5208, 5258, 5258, 5454], [5456, 5510, 5583, 5583, 6047], [6049, 6078, 6133, 6133, 8577]]}
{"id": "wljSWz", "name": "#Evoke 2019 - Sine Wave 2D", "author": "VJSpackOMat", "description": "This example uses Mouse-Click and Mouse-X/Y for frequencies, lower left is 0/0\n\nIt demonstrates a 1 dimensional sine-line that is controlled by 2 frequencies, by introducing a second wave more interesting patterns occur,\nfor the fun of it 3 params\n\n\n", "tags": ["sine"], "likes": 1, "viewed": 136, "published": "Public", "date": "1565947138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\nSine Wave 2D\n\nc.Kleinhuis evoke 2019 - talk 'hybrid fractals'\n\nControls:\n\n- use mouse x/yo change frequencies of 2 waves\n \nhere a second dimension is added to create a place on the plane\n\n2 hybrid sine waves form the position of each dot\n\nthis is the way how common demo programming sprite/endless bobs/dotflag\neffects created their output and serves as example how hybridisation has\nbeen always used in computer/demo scene programming\n\n*/\n#define NUM_POINTS 1000000.0f\n#define POINT_SIZE 0.005f\n\nvec2 increment1=vec2(1.7f,1.1f);\nvec2 increment2=vec2(1.7f,1.2f);\nvec2 increment3=vec2(1.4f,1.1f);\nvec2 amplitude=vec2(1,1); \n\nfloat sineDist(vec2 p){\n    \t\n  float time=iTime*100.0f;\nvec2 frequency1=iMouse.xy/iResolution.xy;\nvec2 frequency2=iMouse.zw/iResolution.xy;\nvec2 frequency3=vec2(1.,2.);\n    float mini=NUM_POINTS;\n    for(float i=0.;i<800.f;i++){\n           // current point\n           vec2 curr=vec2(         \n               // x\n               sin(radians(time*frequency1.x+i*frequency1.x*increment1.x))*amplitude.x/6.0+amplitude.x/6.0+ \n               sin(radians(time*frequency2.x+i*frequency2.x*increment2.x))*amplitude.x/6.0+amplitude.x/6.0+                  \n               sin(radians(time*frequency3.x+i*frequency3.x*increment3.x))*amplitude.x/6.0+amplitude.x/6.0,                   \n               // y\n               sin(radians(time*frequency1.y+i*frequency1.y*increment1.y))*amplitude.y/6.0+amplitude.y/6.0+\n               sin(radians(time*frequency2.y+i*frequency2.y*increment2.y))*amplitude.y/6.0+amplitude.x/6.0+ \n               sin(radians(time*frequency3.y+i*frequency3.y*increment3.y))*amplitude.y/6.0+amplitude.y/6.0\n        );\n        \n        if(length(p-curr)<POINT_SIZE){\n        \tmini=min(mini,length(p-curr));\n        }\n        \n    }\n    \n    return 1.-mini;\n\n    \n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col =       vec3(0.,0.,0.);\n\n    col.r=sineDist(uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 629, 652, 652, 1805], [1809, 1809, 1866, 1916, 2110]]}
{"id": "WljSzh", "name": "Pmod Practice 001", "author": "Hirai_worthless", "description": "aaa", "tags": ["raymarching"], "likes": 3, "viewed": 93, "published": "Public", "date": "1565033730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\nvec3 cellMod(vec3 p,vec3 c){\n    p.z = mod(p.z + c.z / 2.,c.z) - c.z/2.;\n\tp.x = mod(p.x + c.x / 2.,c.x) - c.x/2.;\n    p.y = mod(p.y + c.y / 2.,c.y) - c.y/2.;\n    return p;\n}\n\nfloat cube(vec3 p, vec3 o){\n\treturn max(\n    \tabs(p.x - o.x),\n        max(abs(p.y - o.y),\n            abs(p.z - o.z))\n    );\n}\n\nfloat map(vec3 p){\n    p.xy *= genRot(iTime);\n\tp = cellMod(p,vec3(2.0,2.0,0.5));\n    p.xy *= genRot(PI / 12.);\n\tp = pmod(p,12.);\n    p.xy *= genRot(-PI / 12.);\n\n    float cu = cube(p,vec3(1.,0.,0.)) - 0.2;\n    float sp = length(p - vec3(1.,0.,0.)) - 0.1;\n    sp = min(sp,length(p.xz - vec2(1.,0.)) - 0.05);\n    return mix(cu,sp,smoothstep(0.4,0.6,abs(fract(iTime/2.) - 0.5) * 2.0));\n\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 96; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3(0,0,-1.5 + iTime * 2.);\n    r.yz *= genRot(iTime * PI / 8.);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    float tmp = sqrt(dot(n,r));\nvec3 fc = t > 10000.0 ? vec3(0.8) : mix((vec3(data.z) + 1.0)/1.5\n                                            ,vec3(0.0), - pow(dot(n,r),1.0));\n\tfc = mix(fc,vec3(1.),1. - fog);\n    //fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 90], [91, 91, 117, 117, 300], [301, 301, 329, 329, 474], [476, 476, 503, 503, 602], [604, 604, 622, 622, 989], [1016, 1016, 1040, 1040, 1292], [1294, 1294, 1322, 1322, 1520], [1523, 1523, 1572, 1622, 2182]]}
{"id": "wljSzK", "name": "Sinephony", "author": "TheRomanOne", "description": "playing around with trigo functions and \"scan lines\"", "tags": ["sin"], "likes": 9, "viewed": 674, "published": "Public", "date": "1566671336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 250.\n#define EPS 0.01\n\n// Uncomment to switch to dark color pallete\n//#define DARK_MODE\n\nvec3 spCenter;\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(center - p) - radius;\n}\n\nmat2x2 rot(float ang)\n{\n    ang *= 3.141592654 / 180.;\n \treturn mat2x2(cos(ang), sin(ang), -sin(ang), cos(ang));   \n}\n\nfloat terrain(vec3 p)\n{\n    float d = 0.;\n    d += 3.*sin(iTime+p.z/10.)*cos(iTime+p.x/10.);\n    d += (sin(iTime+p.z/5642.38453)*cos(iTime+p.x/345.153));\n    d += 2.*sin(p.x*p.z/2500.+iTime);\n    return d;\n}\n\nvec4 map(vec3 p)\n{\n    float h = terrain(p);\n \th *= terrain(p+cos(iTime+p.z*p.x/50.))/2.;\n    float d = p.y + h;\n    vec3 col = vec3(0);\n    float ringSize1 = 20. + iMouse.y/20. + 7.*sin(p.x/7.+iTime);\n    float ringSize2 = 20. + 10.*sin(p.z/25.+1.325*iTime);\n    \n    float ringSize3 = 55. + iMouse.y/20. + 10.*sin(p.x/50.+iTime);\n    float ringSize4 = 20. + 10.*cos(p.x/15.+2.325*iTime);\n    \n    float spRotRad = 20.;\n    spCenter = vec3(spRotRad * cos(iTime), 10., 50. + spRotRad * sin(iTime));\n    \n    float sp = sphere(p, spCenter, 3./* + sin(length(p))*/);\n    \n    if(sp < d)\n    {\n        d = sp;\n        col = vec3(.7, .5, .5);\n    }else\n    {\n        if(length(p) > ringSize1 && length(p) < ringSize1 + ringSize2)\n        {\n            col = normalize(vec3(p.x, p.z, .5));\n\t\t\t\n            col.zy = (rot(iTime*15.) * col.xy);\n            #ifndef DARK_MODE\n            col.zy = abs(col.zy);\n            #endif\n            col.zx = (rot(iTime*30.) * col.yx);\n            #ifndef DARK_MODE\n            col.zx = abs(col.zx);\n            #endif\n            col += .2;\n        }\n        if (length(p) > ringSize3 && length(p) < ringSize3 + ringSize4)\n        {\n            col += normalize(vec3(p.x, .5, p.z));\n\n                col.xy = (rot(iTime*15.) * col.xy);\n                #ifndef DARK_MODE\n                col.zy = abs(col.zx);\n                #endif\n                col.zy = (rot(iTime*30.) * col.yx);\n                #ifndef DARK_MODE\n                col.zx = abs(col.zx);\n                #endif\n            col += .2;\n        }\n    }\n    \n\n    return vec4(col, d);\n}\n\nvec3 deriv(vec3 p)\n{\n    return normalize(vec3(\n        map(p + vec3(EPS, 0, 0)).w - map(p - vec3(EPS, 0, 0)).w,\n        map(p + vec3(0, EPS, 0)).w - map(p - vec3(0, EPS, 0)).w,\n        map(p + vec3(0, 0, EPS)).w - map(p - vec3(0, 0, EPS)).w\n        ));\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    \n    vec4 d=vec4(0.);\n    float dv;\n    for(int i = 0; i < 250; i++)\n    {\n        vec3 newRay = ro + dv * rd;\n        d = map(newRay);\n        if(d.w < EPS || dv > MAX_DIST)\n            break;\n        dv += d.w * .3;\n    }\n    \n    return vec4(d.xyz, dv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 30, -1);\n        \n    vec3 lookat = vec3(0, 0, 45);\n\n    vec3 fw = normalize(lookat - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up  = cross(fw, ri);\n    \n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv, 1);\n    \n    vec4 d = march(ro, rd);\n    \n    vec3 light = vec3(1);\n    light.xz *= rot(iMouse.x/2. + 200.);\n    vec3 col = vec3(0);\n    if(d.w < MAX_DIST)\n    {\n        vec3 hitPoint = ro + rd * d.w;\n        vec3 n = deriv(hitPoint);\n        vec3 basecolor = d.xyz*vec3(.7, 0.3, .5)*1.2;\n        \n        float ds = march(hitPoint + n *.1, light).w;\n        float l = .3;\n        if(ds>=MAX_DIST)\n            l = max(.3, dot(n, 1.3*normalize(light)));\n        col = basecolor * l;\n    }\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 122, 171, 171, 213], [215, 215, 238, 238, 332], [334, 334, 357, 357, 541], [543, 543, 561, 561, 2125], [2127, 2127, 2147, 2147, 2382], [2384, 2384, 2414, 2414, 2677], [2679, 2679, 2736, 2786, 3668]]}
{"id": "WljXDR", "name": "Glitch#01", "author": "104", "description": "Evolving scenes", "tags": ["2d", "glitch"], "likes": 5, "viewed": 128, "published": "Public", "date": "1565618174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float z = 1.;\nconst float complexity = 13.;\nconst float speed = .5;// scene changing speed\nconst float density = .8; // 0-1\n\nconst float PI = atan(1.)*4.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n#define q(x,p) (floor((x)/(p))*(p))\n\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = C/R.xy;\n    vec2 N = uv;\n    uv.x *= R.x/R.y;\n    uv *= z;\n    float t = iTime+1e4;\n    uv += floor(t*speed)*z*1.618;// scene switcher\n    o = vec4(1);\n\n    for (float i = 1.;i <= complexity; ++ i) {\n        vec4 h = hash42(floor(uv+i));\n        vec2 p = fract(uv+i)-.5;\n        p *= rot2D(h.x*PI*2.);\n        uv += p * h.z;\n        h = hash42(floor(uv));\n        h += length(fract(p+q(iTime,.1)*.1)); // animate\n        h = fract(h);\n        if (i < 2. || h.w > density) {\n            o *= h;\n        }\n    }\n    o=pow(o,o-o+.5);\n  \to=step(.5,o) * mod(C.y,3.)/2.;\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 163, 184, 184, 332], [334, 334, 354, 354, 406], [445, 445, 482, 482, 1092]]}
{"id": "WljXDW", "name": "HEART TUNNEL SLOWED DOWN", "author": "dynamitedjs", "description": "KLEMS Heart Tunnel slowed down https://www.shadertoy.com/view/4dVBRc", "tags": ["heartrainbowtunnel"], "likes": 6, "viewed": 177, "published": "Public", "date": "1565904219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rot(float t) {\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat heart(vec2 p) {\n    p.y -= 1.6;\n    float t = atan(p.y, p.x);\n    float s = sin(t);\n    float r = 2.0-2.0*s+s*(sqrt(abs(cos(t)))/(s+1.4));\n    return r+2.0;\n}\n\nvec3 hue( in float c ) {\n    return cos(0.9*PI*c + 2.0*PI/3.0*vec3(3,2,1))*0.5+0.5;\n}\n\nfloat map(vec3 p) {\n    p.y = -p.y;\n    p.y += p.z*p.z*0.05;\n    float r = heart(p.xy);\n    return length(p.xy)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord - iResolution.xy*0.5;\n    uv /= iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 0.7));\n    dir.yz *= rot(-0.4);\n    \n    float tot = 0.0;\n    for (int i = 0; i < 100 ; i++) {\n        vec3 p = tot*dir;\n        tot += map(p)*0.9;\n    }\n\n\tvec3 c = hue(tot*0.3-iTime);\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 97], [99, 99, 120, 120, 263], [265, 265, 289, 289, 350], [352, 352, 371, 371, 468], [470, 470, 527, 527, 852]]}
{"id": "wljXRW", "name": "SinCosLine", "author": "gcj2450", "description": "move able sin cos line", "tags": ["sin", "cos"], "likes": 2, "viewed": 90, "published": "Public", "date": "1565265527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tfloat x=uv.x;\n    float y = abs(cos(x*3.5)*sin(x*12.0*iTime));\n    \n    y=plot(uv,y);\n\n    // Output to screen\n    fragColor = vec4(y,y,y,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 181, 231, 460]]}
{"id": "wljXWh", "name": "raymarching learn #2", "author": "dnkorbut", "description": "just trying to get some results", "tags": ["raymarching", "tutorial", "learn"], "likes": 1, "viewed": 55, "published": "Public", "date": "1565785181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH 640\n#define MAX_DST 100.\n#define MIN_DST .001\n#define AMBIENT_DST .1\n\n#define OBJ_PLANE .5\n#define OBJ_SPHERE .51\n\n#define OBJECTS 8\n\nmat4 obj[OBJECTS];\n\n// globals\nvec3 p;\nint o;\nfloat deltaDst;\n\nvec3 getNor(int o, vec3 p) {\n    if(obj[o][3][3] < OBJ_SPHERE) {\n        return obj[o][2].xyz;\n    }else{\n    \treturn normalize(p - obj[o][0].xyz);\n    }\n}\n\nfloat getDistance(vec3 p) {\n    float min = 255.;\n    float res;\n    for(int c = 0; c < OBJECTS; c++) {\n        \n        if(obj[c][3][3] < OBJ_SPHERE) {\n            res = abs(p.y - obj[c][0][1]); // plane\n        }else{\n            res = length(p - obj[c][0].xyz) - obj[c][0].w; // sphere\n        }\n        \n        if(min > res) {\n            deltaDst = min - res;\n            min = res;\n            o = c;\n        }\n        \n    }\n    return min;\n}\n\nfloat rayMarch(vec3 start, vec3 dir) {\n    float ret = 0.;\n    int i;\n    float dst;\n    \n    for(i = 0; i < MAX_MARCH; i++) {\n        p = start + dir * ret;\n        dst = getDistance(p);\n        ret += dst;\n        if(ret > MAX_DST || dst < MIN_DST) {\n           break; \n        }\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // light\n    vec3 light = vec3(sin(iTime) * 10., 6., cos(iTime) * 10. + 10.);\n    \n    // camera\n    vec3 cam = vec3(0., 1., 0.);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // objects\n    obj[0][0] = vec4(0., .2, 0., 0.); // infinite plane at zero Y\n    obj[0][1] = vec4(.5, .5, .5, 1.);\n    obj[0][2] = vec4(0., 1., 0., 0.);\n    obj[0][3][3] = OBJ_PLANE;\n    \n    obj[1][0] = vec4(0., 1., 6., 1.); // red sph\n    obj[1][1] = vec4(1., 0., 0., 1.);\n    obj[1][3][3] = OBJ_SPHERE;\n    \n    obj[2][0] = vec4(1.5, 0.8, 6., 0.8); // blue sph\n    obj[2][1] = vec4(0., 0., 1., 1.);\n    obj[2][3][3] = OBJ_SPHERE;\n    \n    obj[3][0] = vec4(-1.5, 0.8, 6., 0.8); // green sph\n    obj[3][1] = vec4(0., 1., 0., 1.);\n    obj[3][3][3] = OBJ_SPHERE;\n    \n    obj[4][0] = vec4(0., .4, 2., .4); // yellow sph\n    obj[4][1] = vec4(1., 1., 0., 1.);\n    obj[4][3][3] = OBJ_SPHERE;\n    \n    obj[5][0] = vec4(1.5, 0.6, 3., 0.6); // magenta sph\n    obj[5][1] = vec4(1., 0., 1., 1.);\n    obj[5][3][3] = OBJ_SPHERE;\n    \n    obj[6][0] = vec4(-1.5, 0.6, 3., 0.6); // cyan sph\n    obj[6][1] = vec4(0., 1., 1., 1.);\n    obj[6][3][3] = OBJ_SPHERE;\n    \n    obj[7][0] = vec4(0., 7., 0., 0.); // infinite plane at 7 Y\n    obj[7][1] = vec4(.5, 1., .5, 1.);\n    obj[7][2] = vec4(0., -1., 0., 0.);\n    obj[7][3][3] = OBJ_PLANE;\n    \n    for(int i = 0; i < OBJECTS; i++) {\n        //obj[i][0].x *= cos(iTime);\n        //obj[i][0].z *= sin(iTime);\n    }\n    \n    float dst = rayMarch(cam, dir);\n    \n    dir = normalize(light - p);\n    vec3 nor = getNor(o, p);\n    \n    float colMul = dot(dir, nor);\n    float ambient = 1.;\n    \n    if(deltaDst < AMBIENT_DST) {\n        ambient = deltaDst / AMBIENT_DST;\n    }\n    \n    vec4 c = obj[o][1];\n    vec3 collisionP = p;\n    int collisionO = o;\n    \n    float shadow = rayMarch(p + (nor * MIN_DST * 2.), dir);\n    \n    if(shadow < length(light - p)) {\n        colMul *= .2;\n    }\n    \n    nor = normalize(reflect(collisionP - cam, nor));\n    if(rayMarch(collisionP + (nor * MIN_DST * 2.), nor) < 10.) {\n    \tc = obj[o][1] + (obj[collisionO][1] * .5);\n    }\n    \n    c.rgb *= colMul;\n    \n    fragColor = c * ambient;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 215, 243, 243, 370], [372, 372, 399, 399, 822], [824, 824, 862, 862, 1129], [1131, 1131, 1186, 1237, 3447]]}
{"id": "wljXWV", "name": "trippy08", "author": "Del", "description": "trippy", "tags": ["sin", "cos", "trippy"], "likes": 19, "viewed": 499, "published": "Public API", "date": "1567190127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// trippy\n\nmat2 rot(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 fx(float time, vec2 uv)\n{\n    //float time = iTime;\n\tvec2 f = vec2(0.3);\n\tvec3 c = vec3(1.2,1.0,1.0);\n\tfloat light = 0.1;\n\t\n\tfor (float x = 1.1; x < 10.0; x += 1.0)\n\t{\n\t\tuv *= rot(x*200.0+sin(time*0.08));\n\t\t\n\t\tf = vec2(cos(cos(time*0.6+x + uv.x * x) - uv.y * dot(vec2(x + uv.y), vec2(sin(x), cos(x)))));\n\t\tlight += (0.04 / distance(uv, f)) - (0.01 * distance(vec2((cos(time*0.3 + uv.y))), vec2(uv)));\n\t\t\n\t\tc.y += sin(x+time+abs(uv.y))*0.3;\n\t\tif (c.y<0.8)\n\t\t\tc.y = 0.8;\n\t\tlight-=x*0.001 + c.y*0.001;\n\t\t\n\t}\n\tc *= light;\n\tc.x += (sin(time*2.4)*0.1);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ccc = fx(iTime*0.76,uv);\n    uv.y = dot(uv,uv);\n    uv.x = dot(uv,uv*2.0)*0.25;\n    fragColor = vec4(ccc*fx(iTime,uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 11, 30, 30, 97], [98, 98, 128, 154, 665], [667, 667, 724, 724, 928]]}
{"id": "wljXzh", "name": "190806_gummycube", "author": "omeometo", "description": "something\n\nreplacing abs functions appearing in fold operations by \"soft\" abs x->sqrt(x*x+a) gives a kind of smoothing effect.", "tags": ["ifs", "shape"], "likes": 22, "viewed": 294, "published": "Public", "date": "1565096422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float t){\n\treturn mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat dist(in vec3 pos){\n    vec3 p=pos;\n    vec3 a=0.14*vec3(cos(iTime));\n    float c=0.2*pow(0.01, smoothstep(0.6, -0.6, cos(iTime*0.7)));\n        \n    for(int k=0;k<10;k++){\n        p=sqrt(p*p+c)-0.5;\n\t\tp.xy*=rot(a.z);\n        p.yz*=rot(a.x);\n        p.zx*=rot(a.y);\n    }\n    return length(p)-0.45;\n}\n\nvoid getColor(out vec4 fragColor, in vec3 pos, in vec3 ray){\n    vec3 bg=vec3(0.0, 0.0, 0.05);\n    vec3 solid=vec3(1.0, 0.5, 0.55);\n\tfragColor=vec4(bg, 1.0);\n    float t=0.;\n    float dprev=1.0;\n    for(int i=0;i<200;i++){\n\t\tfloat d=dist(pos);\n        pos += d*ray;\n        t += d;\n        if(t>1e3)return;\n        if(d<1e-3){\n\t\t\tfloat u=1.0-d/dprev;\n            u+=0.5;\n            fragColor=vec4(solid*u, 1.0);\n            return;\n        }\n        dprev=d;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\t\n    vec3 pos = vec3(40.0*cos(iTime*1.1), 15.0, 40.0*sin(iTime*1.1));\n    vec3 eye = -normalize(pos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    up-=dot(up, eye)*eye;\n    up=normalize(up);\n    vec3 right = cross(eye, up);\n    float angle=0.3;\n    vec3 ray = eye + (uv.x*right+uv.y*up) * angle;\n    ray = normalize(ray);\n    \n    getColor(fragColor, pos, ray);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 93, 93, 373], [375, 375, 435, 435, 842], [844, 844, 901, 901, 1324]]}
{"id": "WljXzy", "name": "HMNKD", "author": "antonOTI", "description": "A small fan art for a game that was just announced.\n\nIt's a bit heavy on branching.", "tags": ["raymarching", "hex", "fanart"], "likes": 12, "viewed": 478, "published": "Public API", "date": "1567014102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader by Anton.\n\n//#define SHADOW\n//#define CLOUDS\n\n#define PI 3.14159\n#define HPI 1.570796\n#define REP(p, r) (mod(p + r/2.,r) - r/ 2.)\n\n// smin by iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// hash and noise from shane's : https://www.shadertoy.com/view/ldscWH\nvec3 hash33(vec3 p) { \n\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    \n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n  \n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    \n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); \n}\n\n\nmat2 mrn = mat2(0.8, -0.6, 0.6,0.8);\nfloat animatedNoise(vec2 p)\n{\n    p*= .25;\n    float t = iTime * .04;\n\tfloat h =0.;\n    float amp = 1.;\n    float freq = 1.;\n    for(float i = 1.; i < 4.; ++i)\n    {\n    \tamp *= .9; \n        freq *= 2.5;\n        h += sin(p.x * freq * .5) * amp;\n        p*= mrn;\n     \tp += t * (i-1.);\n        h+= sin(p.y * freq * .45) * amp;\n    }\n    \n    return h;\n}\n\n// Hexagonal Prism - exact by iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec4 hexCoord(vec2 uv)\n{\n    vec2 r = vec2(1.,1.73);\n    vec2 h = r * .5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    \n    vec2 gv;\n    if(length(a) < length(b))\n    {\n        gv = a;\n    }\n    else\n    {\n        gv = b;\n    }\n    \n    vec2 id = uv - gv;\n    \n    return vec4(gv, id);\n}\n\nfloat getTileType(vec2 p)\n{\n    float id = floor(tetraNoise(p.xyy) * 4.);\n\n    id = min(id, 2.);\n    return id;\n}\n\nfloat sqLength(vec2 v)\n{\n    return dot(v,v);\n}\n\nfloat upCurve(float t)\n{\n    return sin(t * HPI);\n}\n\nfloat underCurve(float t)\n{\n    return 1. - upCurve(1. - t);\n}\n\nconst vec4 idDelta = vec4(1.,0.,-1.,0.);\nconst vec4 idDeltb = vec4(.5,.866,-.5,-.866);\n\nconst vec4 tileDelta = vec4(.5, 0., -.5, 0.);\nconst vec4 tileDeltb = vec4(.25,.433,-.25,-.433) ;\n\n#define FLOAT_EQ(a ,b) (abs(a-b) < .1)\n\n#define BPM (90. / 60.)\nfloat bpmTime(float t)\n{\n    float ft = fract(t);\n    return floor(t) + ft * ft;\n}\n\nconst float gridScale = 10.;\n\nint idMat = 0;\nvec2 mat = vec2(0.,0.);\nfloat morph;\n\nfloat travellingSpeed = ( BPM * 7.);\n\nfloat map(vec3 p)\n{\n    float basePlan = p.y + 1.;\n    float timeTraveling = iTime * travellingSpeed;\n    p.z += timeTraveling;\n    \n    \n    vec4 hg = hexCoord(p.xz / gridScale);\n    float tideTime = timeTraveling / gridScale + hash11(hg.z) * 2.35;\n    //tideTime = floor(tideTime);\n    float stepLength = 1. / .557 * .5;\n    //tideTime = bpmTime(tideTime / stepLength) * stepLength;\n    float ti = hg.w  - (tideTime) - .5;\n    float tide = max(0., ti) * 10.;\n    \n    morph = 1. - clamp(ti, 0., 1.);\n    \n    p.y /= upCurve(morph);\n    \n    \n    float baseHeight = p.y;\n    float hexHeight = smoothstep(hg.y - .0001, -.005, .005);\n    \n    float id = getTileType(hg.zw);\n    bool id_tl = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.zy));\n    bool id_tr = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.xy));\n    bool id_ml = FLOAT_EQ( id, getTileType(hg.zw + idDelta.zw));\n    bool id_mr = FLOAT_EQ( id, getTileType(hg.zw + idDelta.xy));\n    bool id_bl = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.zw));\n    bool id_br = FLOAT_EQ( id, getTileType(hg.zw + idDeltb.xw));\n    \n    bool c_up = id_tl && id_tr;\n    bool c_tr = id_tr && id_mr;\n    bool c_br = id_mr && id_br;\n    bool c_do = id_br && id_bl;\n    bool c_bl = id_bl && id_ml;\n    bool c_tl = id_ml && id_tl;\n    \n    float innerRadius = 60.;\n    float innerSmoothFactor = 10.;\n    \n    float elevation = sqLength(hg.xy) * innerRadius;\n    \n    // top left\n    if(id_tl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.xw) * innerRadius, innerSmoothFactor);\n    }\n    //top right\n    if(id_tr)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.zw) * innerRadius, innerSmoothFactor);\n    }\n    //middle_left\n    if(id_ml)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDelta.xy) * innerRadius, innerSmoothFactor);\n    }\n    //middle right\n    if(id_mr)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDelta.zw) * innerRadius, innerSmoothFactor);\n    }\n    //bottom left\n    if(id_bl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.xy) * innerRadius, innerSmoothFactor);\n    }\n    //bottom right\n    if(id_br)\n    {\n        elevation = smin(elevation, sqLength(hg.xy + tileDeltb.zy) * innerRadius, innerSmoothFactor);\n    }\n\n    // up\n    if(c_up)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDelta.yx) * innerRadius, innerSmoothFactor);\n    }\n    // corner top right\n    if(c_tr)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.yx) * innerRadius, innerSmoothFactor);\n    }\n    // corner bottom right\n    if(c_br)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.yz) * innerRadius, innerSmoothFactor);\n    }\n    // corner bottom\n    if(c_do)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDelta.yz) * innerRadius, innerSmoothFactor);\n    }\n    // corner bottom left\n    if(c_bl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.wz) * innerRadius, innerSmoothFactor);\n    }\n    // corner top left\n    if(c_tl)\n    {\n        elevation = smin(elevation, sqLength(hg.xy - tileDeltb.wx) * innerRadius, innerSmoothFactor);\n    }\n    \n    if(c_up && c_tr && c_br && c_do && c_bl && c_tl)\n    {\n        elevation -= pow((1.-sqLength(hg.xy * 1.8)) * 2.8,2.);\n    }\n    \n    idMat = 0;\n    if( FLOAT_EQ( id, 2.))\n    {\n        float max_depth = .3;\n        \n        \n        elevation = smin(elevation - 2.9, .0, 1.8);\n        elevation = -smin(-elevation, max_depth, .4);\n    \tidMat = 2;\n        mat.y = elevation;\n        \n        float wave = animatedNoise(p.xz);\n        wave = pow(wave, 2.) * .025;\n        elevation += wave * step(elevation, -.15);\n        p.y -= elevation;\n    }\n    \n    else if( FLOAT_EQ( id, 1.))\n    {\n        elevation = 2.- (elevation);\n        elevation = elevation * 5.;\n    \televation += tetraNoise(p.xzz * 5. / gridScale ) * 7.-3.5;\n        elevation = -smin(0.,-elevation, 15.);\n        \n        p.y -=  elevation *.15;\n        \n        idMat = 1;\n        mat.y = elevation;\n    }\n    \n    float dist = sdHexPrism(vec3(hg.yx * 10.5 , p.y*2. + 3.), vec2(5.)) -.25;\n    \n    if(basePlan < .01)\n    {\n        idMat = 3;\n    \tmat.xy = hg.xy;\n    }\n    \n    dist = min(dist, basePlan);\n    \n    return dist; \n}\n\nvec3 normal(vec3 p, float cd)\n{\n    vec2 e = vec2(0.,.1);\n    return normalize(vec3(\n    \tcd - map(p + e.yxx),\n    \tcd - map(p + e.xyx),\n    \tcd - map(p + e.xxy)\n    ));\n}\n\nvoid ray(in vec3 ro, in vec3 rd, out vec3 cp, out float st, out float cd, out float dist)\n{\n    dist = 0.;\n    for(; st < 1.; st += 1. /128.)\n    {\n        cp = ro + rd * dist; \n        cd = map(cp);\n        if(cd < .01)\n        {\n            break;\n        }\n        \n        dist += cd * st;\n    }\n}\n\nvec3 lookAt(vec3 target, vec3 cp, vec2 uv)\n{\n    vec3 fd = normalize(target - cp);\n    vec3 up = cross(fd, vec3(1.,0.,0.));\n    vec3 ri = cross(up, fd);\n    return normalize(fd + up * uv.y + ri * uv.x);\n}\n\n#define MOUSE (iMouse.x / iResolution.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - vec2(iResolution * .5))/iResolution.y;\n\t\n    vec3 tar = vec3(100.,0.,0.);\n    vec3 ro = tar + vec3(0.,12.,-20.);\n   \tvec3 rd = lookAt(tar, ro, uv);\n   \tvec3 cp;\n    float st, cd, dist;\n    \n    ray(ro, rd, cp, st, cd, dist);\n    int selectedMat = idMat;\n    vec2 material = mat;\n    float mo = morph;\n\n    vec3 backCol = vec3(.3,.3,.7);\n    vec3 col;\n    if(cd < .01)\n    {\n        vec3 norm = normal(cp, cd);\n        vec3 ld = normalize(vec3(-14.,-6.,2.));\n        float li = clamp(dot(ld, norm),0.,1.);\n\t\t\n        vec3 plainColor = vec3(.075,.09,.001);\n        vec3 rockColor = vec3(.04,.02,.035);\n        vec3 snowColor = vec3(.6);\n        vec3 waterColor =vec3(.003,.0046,.094);\n        \n        vec3 tileColor = plainColor;\n        \n        if(selectedMat == 1)\n        {\n            vec3 bottomColor = tileColor;\n            \n            float elevation = clamp(material.y / 40., 0. ,1.) ;\n            //elevation\n            \n            float rockFactor = smoothstep(-.025,.025, elevation - .015);\n            tileColor = mix(tileColor,rockColor, rockFactor);\n            \n            elevation += norm.y*.25 ;\n\t\t\tfloat snowFactor = smoothstep(-.1, .1, elevation-.125);\n            snowFactor -= .35 - abs(norm.y) * .2;\n            \n            snowFactor = clamp(snowFactor, 0., 1.) * .5;\n            tileColor += vec3(.5,.5,.45) * snowFactor;\n        }\n        else if(selectedMat == 2)\n        {\n            float depth = clamp(-material.y* 50., .0, 1.);\n            tileColor = mix(tileColor, waterColor, depth);\n        }\n        \n#ifdef SHADOW\n        vec3 ncp;\n        cd = st = 0.;\n        float ndist;\n\t\tray(cp - ld * .05, - ld, ncp, cd,st, ndist);        \n        if(cd < 1.)\n        {\n        \ttileColor *= .7;\n        }\n        else\n        {\n      \t\ttileColor +=  vec3(.810,.800,.620) * li * .125;\n        }\n\n#else\n\t\ttileColor +=  vec3(.810,.800,.620) * li * .125;\n#endif\n        \n        col = mix(backCol, tileColor, underCurve(mo));\n        \n    }\n    else\n    {\n        col = backCol;\n    }\n    \n    if(selectedMat == 3)\n    {\n        float grid = hexDist(material.xy * 2.);\n        grid = 1. - smoothstep(-.05,.02,grid - .94);\n        col = mix(backCol * 1.5, backCol*1.2, grid);\n    }\n    \n#ifdef CLOUDS\n    // 2D cloud experiment\n\tvec2 shiftedPosition = cp.xz + vec2(0.,iTime * travellingSpeed);\n    col -= upCurve((animatedNoise(shiftedPosition * .25) + 1.) * .02);\n#endif\n    \n    // fog\n\tcol = mix(backCol, col, exp(min(-dist * .05 +2.5,0.)));\n    \n    // color grading\n    col = col*vec3(1.15,1.29,.9) * 1.3;\n\n    \n    // compress        \n    // col = 1.35*col/(1.0+col);\n        \n    \n    // gama correction\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 154, 197, 197, 297], [299, 345, 368, 368, 453], [455, 526, 547, 547, 659], [661, 661, 690, 690, 1201], [1241, 1241, 1270, 1270, 1593], [1595, 1628, 1664, 1664, 1947], [1949, 1949, 1972, 1972, 2079], [2080, 2080, 2104, 2104, 2388], [2390, 2390, 2417, 2417, 2503], [2505, 2505, 2529, 2529, 2552], [2554, 2554, 2578, 2578, 2605], [2607, 2607, 2634, 2634, 2669], [2921, 2921, 2945, 2945, 3003], [3126, 3126, 3145, 3145, 7393], [7395, 7395, 7426, 7426, 7566], [7568, 7568, 7659, 7659, 7869], [7871, 7871, 7915, 7915, 8075], [8119, 8119, 8176, 8176, 10914]]}
{"id": "wllXWf", "name": "Barrel lens distortion PS#01", "author": "stoleckipawel", "description": "Lens distortion practise.\n", "tags": ["lensdistortion"], "likes": 2, "viewed": 185, "published": "Public", "date": "1564844363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PIXELSIZE 15.0\n#define GRIDSIZE 5.0\n\nvec3 gridColor = vec3(0.0, 0.0, 0.0);\nvec3 color = vec3 ( 0.4, 0.4, 0.4);\nfloat barrelContrast = 1.0;\n\nvoid MakeGrid (vec2 uv)\n{\n    vec2 moduloXY = mod(uv.xy, PIXELSIZE);\n\n    //grid mask\n    if(moduloXY.x <GRIDSIZE || moduloXY.y<GRIDSIZE)\n    {\n    color.x= gridColor.x;\n    color.y= gridColor.y;\n    color.z= gridColor.z;\n    }\n}\n\nvec2 BarrelDistortion (vec2 uv)\n{\n    //angle \n    float theta = atan(uv.y, uv.x);\n    //ammount\n    float anim_effect_1 = ((sin (iTime + 0.3))*0.005);\n    float radius = length(uv) + anim_effect_1;\n    //contrast\n    radius = pow(radius, barrelContrast);\n    \n    uv.x = radius * cos(theta);\n    uv.y = radius * sin(theta);\n    color.r = 0.5 * (uv.y +1.0);\n    color.b = radius;\n    return 0.5 * (uv + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n \t\n    //animation\n    barrelContrast += (((sin(iTime) + cos(cos(iTime)))/2.0)-0.5);\n    //screen coord\n    vec2 normalizedUV = (fragCoord.xy/(iResolution.xy/2.0)) -1.0;\n    vec2 distortedUV = BarrelDistortion(normalizedUV)* iResolution.xy;\n    MakeGrid(distortedUV.xy);\n    \n   \n    fragColor = vec4( color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 173, 173, 377], [379, 379, 412, 425, 789], [791, 791, 847, 866, 1164]]}
{"id": "WlSSRc", "name": "Locus Rings", "author": "BLA_P", "description": "Coloured rings from a sinusoidal locus.", "tags": ["red", "locus"], "likes": 1, "viewed": 72, "published": "Public", "date": "1566519553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    float scale = 5.0; // How much of the xy plane you see; window goes from '-scale' to 'scale' on the x and y axes\n    float speed = 1.0; // Determines the speed of the animation\n    float rings = 3.0; // Roughly Determines the number of rings on screen\n    float radius = 4.0;// Determines the radius on which the foci orbit\n    \n    float time = iTime*speed;// adjust time based on speed\n    \n    vec2 uv = scale*2.0*fragCoord/iResolution.xy - scale; // scale coordinates\n    \n    // Focus F1 and Focus F2 orbit on a circle at different speeds in different directions\n    vec2 F1 = vec2 (radius*cos(-7.0*time*0.029),radius*sin(-7.0*time*0.029)); // Determine foci position on a circle\n    vec2 F2 = vec2 (radius*cos(5.0*time*0.029),radius*sin(5.0*time*0.029));\n    // F1 moves at speed -7, F2 moves at speed 5\n    \n    float D1 = length(F1 - uv); // Get distances to foci\n    float D2 = length(F2 - uv);\n    \n    // Q is set to the sum of the sines of the distance of point uv to the foci\n    // This creates the ring effect\n    float Q = sin(rings*D1) + sin(rings*D2); // Compute locus\n    \n    // This sets the boundary between black and red, using 'Q<sin(time)' causes black and red to pulse in and out,\n    //   using 'Q<1' generates rings, 'Q<0' generates a checkerboard. Setting Q< values between 2 and -2 generates  \n    //   interesting patterns.\n    if (Q < sin(time)) {\n        // Q*0.25+o.5 generates the light borders in the red regions\n        fragColor = vec4(1.0,Q*0.25+0.5,Q*0.25+0.5,1.0);\n    }\n    else{\n        fragColor = vec4(0,0,0,0); // Black regions\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1647]]}
{"id": "wlSSRD", "name": "fractans", "author": "foran", "description": "fractans", "tags": ["fractans"], "likes": 8, "viewed": 174, "published": "Public", "date": "1565190098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float h=0.5;\nconst float j=0.5;\nconst float F=5.0;\nconst float G=5.0;\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n\n{\n\tfloat f = F;\n\tfloat g = G;\n\t\n\tvec2 res = iResolution.xy;\n\tvec2 mou = vec2(0., 0.);\n\t\n\tmou.x = sin((iTime*0.2) * .3) * sin((iTime*0.2) * .15) * 2. + sin((iTime*0.2) * .3);\n\tmou.y = (1.0-sin((iTime*0.2) * .3 * 2.) )* sin((iTime*0.2) * .15) + cos((iTime*0.2) * .3);\n\tmou *= res;\n\n\tvec2 z = ( (-res+2.0 * fragCoord.xy) / res.y);\n\tvec2 p = ( (-res+2.0 + mou) / res.y) * j ;\n\t\n\tfor( int i = 0; i < 30; i++) {\n\t\t\n\t\tfloat d = dot(z, z) + 0.0 * dot(p*0.1,z*0.1);\n\t\tz = (vec2( z.x, -z.y ) / d) + p * (h)/(j); \n\t\tz.x = 1.0- abs(z.x);\n\t\tf = max( d-f, tan(dot(z-p,z-p) ));\n\t\tg = min( g*d, sin(dot(z+p,z+p))+1.0);\n\t}\n\t\n\tf = abs(-log(f) / 3.5);\n\tg = abs(+log(g) / 3.5 );\n\t\n\tvec3 col =  vec3(g*j, g*f, f*j);\n\tfragColor = vec4( min( col, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 178, 178, 914]]}
{"id": "wlSSWK", "name": "Asteroid Drifter", "author": "Terah", "description": "Asteroid Drifter", "tags": ["raymarching"], "likes": 1, "viewed": 85, "published": "Public", "date": "1567078527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.1)*1.7;\n  off.y += sin(p.z*0.05)*2.3;\n  return off;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p)-r;\n}\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  \treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0) - 0.05; \n}\n\nfloat N(float t) {\n \treturn fract(2375.*sin(7523.*t));   \n}\n\nfloat NP(float t) {\n \treturn N(t)*6.28;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 r = vec3(9.0);\n    vec3 p1 = mod(p, r) - 0.5*r;\n    vec3 p2 = p-p1;\n    \n    float t1 = 0.5*iTime;\n\n    //p1.xz *= rot(2.3*p2.x + t1);\n    p1.xy *= rot(3.7*p2.y + t1);\n    //p1.xz *= rot(5.1*p2.z + t1);\n    p1.xz *= rot(NP(p2.x) + t1);\n    //p1.yx *= rot(NP(p2.y) + t1);\n    p1.xz *= rot(NP(p2.z) + t1);\n    float b = box(p1, vec3(1));\n    \n    float s = sph(p1 - vec3(0,0,0), 1.2);  \n\n    return max(s, b);\n}\n\nvec3 norm(vec3 p) {\n\tvec2 o=vec2(0.002, 0.0);\n    return normalize(vec3(\n        map(p+o.xyy)-map(p-o.xyy),\n        map(p+o.yxy)-map(p-o.yxy),\n        map(p+o.yyx)-map(p-o.yyx)\n    ));\n}\n\nvec3 march(vec3 s, vec3 r) {\n      \n    float d=0.0;\n    int i=0;\n    vec3 p=s;\n    \n    for (; i<100; ++i) {             \n        d = map(p);   \n        if (abs(d)<0.001) {\n            break;\n        }       \n        p+=d*r;\n    }        \n    \n    vec3 col = vec3(0);\n    float li = 2.0;\n    \n    vec3 n = norm(p);\n    vec3 l = normalize(vec3(1,1,-1));\n    float lb = max(0.0,dot(n,l));\n    col += lb * vec3(0.8,0.9,0.6) * li;\n    \n    vec3 h = normalize(l + -r);\n    float sa = max(dot(h, n), 0.0);\n    float sp = pow(sa, 5.0);\n    if (lb>0.0) {\n        col += sp * vec3(0.5,0.5,0.5);\n    }\n\n    float fog = 1.0-float(i)/100.0;\n\tcol = mix(vec3(0.05, 0.05, 0.05), col, fog);\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  \tuv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 ro = vec3(14, 0, iTime*20.0);\n    ro += 1.2*tunnel(ro);\n    vec3 rd = normalize(vec3(uv, 0.3+(sin(0.53*iTime + 60.0)*0.3)));\n\n    \n    vec3 col = march(ro, rd);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 115], [117, 117, 136, 136, 205], [207, 207, 235, 235, 261], [264, 264, 291, 291, 389], [391, 391, 409, 409, 450], [452, 452, 471, 471, 493], [495, 495, 514, 514, 938], [940, 940, 959, 959, 1126], [1128, 1128, 1156, 1156, 1831], [1835, 1835, 1892, 1892, 2242]]}
{"id": "WlSSWV", "name": "One Way Trip", "author": "PVM", "description": "\"One Way Trip\" by PVM\nRanked 2nd in the 4 kbytes compo at Evoke 2019, Germany.\nCode: Kali, Music: Uctumi\nYou can download Windows 4kbyte executable from: http://pungas.space/releases/pvm-owtr.zip \n+PVM Info: http://pungas.space", "tags": ["intro", "4k", "demoscene"], "likes": 131, "viewed": 8047, "published": "Public", "date": "1567051363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -------------------------------------------------------------------------------------------\n\n// \"ONE WAY TRIP\" by PVM\n\n// Shadertoy version of our 4k intro entry for Evoke 2019\n\n// Code: Kali\n// Music: Uctumi\n\n// NOTE: Rewind the shader after it starts to correct audio sync\n\n// -------------------------------------------------------------------------------------------\n\n// Original code without optimizations for the 4k intro and including PVM logo\n\n// global variables\nfloat det=.005, fin=0., time; // raymarching threshold, aux variable\nconst float maxdist=60.; // max distance for raymarching\nvec3 ldir=vec3(0.,1.,4.); // light direction (without normalization)\nvec3 fcol; // global for coloring\nvec3 suncol=vec3(2.,1.,.6); // sun color\n\n// 2D rotation functions\nmat2 rot2D(float a) {\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n// A version with degrees used when designing the logo\nmat2 rot2Ddeg(float a) {\n\ta=radians(a);\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\n// -------------------------------------------------------------------------------------------\n\n// PVM LOGO\n\n\n// 2D rectangle with a tilt distortion value\nfloat rect(vec2 p, vec2 b, float inc) {\n    p.x+=p.y*inc;\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// 2D triangle function by iq (I think)\nfloat tri(vec2 p, vec2 q, float ang) {\n    p*=rot2Ddeg(ang);\n    p.x = abs(p.x);\n    \n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n// Here the logo is constructed from distoted rectangles and triangles\nvec4 logo(vec2 uv) {\n    uv*=1.2;\n    uv.x*=1.15;\n    uv.y-=.6;\n    uv.x-=1.3;\n    float d=rect(uv,vec2(.045,.25),-.5);\n\tuv.x+=.25;\n    uv.y+=.01;\n    d=min(d,rect(uv,vec2(.045,.24),.5));\n\tuv.x+=.265;\n    uv.y-=.04;\n    d=min(d,rect(uv,vec2(.045,.2),-.55));\n\tuv.x-=.73;\n    uv.y-=.06;\n    d=min(d,rect(uv,vec2(.045,.16),.4));\n\tuv.x-=.105;\n    uv.y+=.074;\n    d=min(d,rect(uv,vec2(.045,.085),-.45));\n\tuv.x-=.105;\n    uv.y+=.045;\n    d=min(d,rect(uv,vec2(.045,.13),.45));\n\tuv.x-=.25;\n    uv.y+=.1;\n    d=min(d,rect(uv,vec2(.18,.03),.0));\t\n\tuv.x+=1.32;\n    uv.y-=.18;\n    d=min(d,rect(uv+vec2(0.0,.03),vec2(.35,.03),.0));\t\n    uv.x-=.5165;\n    uv.y+=.4;\n    d=min(d,tri(uv,vec2(.09,.185),0.));\n    uv.x-=.492;\n    uv.y-=.56;\n    d=min(d,tri(uv,vec2(.063,.14),180.));\n    uv.x+=.225;\n    uv.y-=.17;\n    d=min(d,tri(uv,vec2(.063,.145),180.));\n    uv.x-=.142;\n    uv.y+=.555;\n    d=min(d,tri(uv,vec2(.063,.145),0.));\n    uv.x+=.985;\n    uv.y+=.075;\n    vec2 uvd=uv-vec2(uv.y,0.);\n    d=min(d,tri(uvd-vec2(0.003,0.022),vec2(.04,.05),0.));\n    uv.x-=.16\t;\n    uv.y-=.63;\n    uvd=uv+vec2(uv.y*.4,0.);\n    d=min(d,tri(uvd+vec2(.03,0.),vec2(.07,.23),-145.));    \n   \tuvd=uv+vec2(.465,.33);\n    uvd*=rot2Ddeg(27.);\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\n   \tuvd=uv+vec2(-1.43,.534);\n    uvd*=rot2Ddeg(206.);\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\n    float s=pow(abs(d)+.9,10.);\n\tuvd=uv+vec2(-.28,.36);\n    uvd*=rot2Ddeg(50.);\n    d=max(d,-rect(uvd,vec2(.1,.025),.0));\n    // logo coloring, RGBA \n    float o=1.-smoothstep(0.,.01,d);\n    float l=1.-smoothstep(0.,.05,d);\n    vec3 col=mix(vec3(2.,.15,.1),vec3(1.,2.,.5),min(1.,abs(uv.y+.4)));\n    return vec4(col*o+.1,l);\n}\n\n\n// -------------------------------------------------------------------------------------------\n\n// FRACTAL \n\n// A bunch of sin and cos that defines the curves of the fractal path\n// it returns the displacement at a given point. freq was used to explore diferent scales \nvec3 pitpath(float ti) { \n\tfloat freq=.5;\n    ti*=freq;\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\n\tvec3  p=vec3(x,y,ti/freq);\n\treturn p;\n}\n\n// Distance Estimation function\n\nfloat de(vec3 pos) {\n    float x=1.-smoothstep(5.,8.,abs(pos.x)); // aux variable used for washing the colors away from the path in the fractal\n\tpos.y+=.9; // offset y position for the fractal object\n\tpos.xy-=pitpath(pos.z).xy; // distortion of coordinates based on the path function\n    mat2 rot=rot2D(.5); // rotation matrix used in the fractal iteration loop\n    float organic=smoothstep(.5,1.,-sin(pos.z*.005)); // used for the \"organic\" part of the fractal\n    mat2 rot2=rot2D(organic*.4); // rotation matrix used in the fractal iteration loop, it mutates the fractal to kinda \"organic\" shapes\n    float fold=2.6+sin(pos.z*.01)+organic*1.5; // fold is a parameter for one of the operations inside the fractal loop\n    pos.x+=pow(organic,.2)*fold*.75; // x offset for the organic part\n    pos.y+=organic*.3; // y offset for the organic part\n\tpos.z=abs(5.-mod(pos.z,10.)); // tiling for repeating the fractal along the z axis\n    pos.x=abs(10.-mod(pos.x+10.,20.)); // tiling for reapeating along x axis\n\tpos.x-=fold; // x offset to center the fractal\n    vec4 p=vec4(pos,1.); // w value will be used for calculating the derivative\n    vec3 m=vec3(1000.); // for orbit trap coloring\n    int it=int(8.+fin*2.); // gives more iterations to the fractal at the end\n    // Amazing Surface fractal formula by Kali\n    // Derived from Mandelbox by tglad\n    for (int i=0; i<it; i++) {\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,2.))*2.0-p.xz; // fold transform on xz plane\n\t\tp.xyz-=vec3(.5,.8,1.); // translation transform\n        p=p*(2.-organic*.2)/clamp(dot(p.xyz,p.xyz),.25,1.)-vec4(2.,.5,-1.,0.)*x; // scale + spheric fold + translation transform\n\t\t// rotation transforms\n        p.xy*=rot;\n        p.xz*=rot2; // rotations on xz and yz give the \"organic\" feel for the \"alien reefs\" part\n        p.yz*=rot2; \n        m=min(m,abs(p.xyz)); // saves the minimum value of the position during the iteration, used for \"orbit traps\" coloring\n    }\n    // fractal coloring (fcol global variable)\n    fcol=vec3(1.,.3,.0)*m*x; \n    fcol=max(fcol,length(p)*.0015*vec3(1.,.9,.8)*(1.-fin))*(1.+organic*.5);\n    return (max(p.x,p.y)/p.w-.025*(1.-fin))*.85; // returns the distance estimation to the fractal's surface, with some adjustment towards the end\n}\n\n\n// -------------------------------------------------------------------------------------------\n\n// RAYMARCHING\n\n// Returns the perpendicular vector to the surface at a given point\nvec3 normal(vec3 p) {\n    vec3 d=vec3(0.,det*2.,0.);\n\treturn normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));\n}\n\n\n// Ambient occlusion and soft shadows, classic iq's methods\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat td=0., ao=0.;\n    for(int i=0; i<6; i++) {\n\t\ttd+=.05;\n\t\tfloat d=de(p-n*td);\n        ao+=max(0.,(td-d)/td);\n    }\n\treturn clamp(1.-ao*.1,0.,1.);\n}\n\n\nfloat shadow(vec3 p) {\n\tfloat sh=1.,td=.1;\n    for (int i=0; i<50; i++) {\n\t\tp+=ldir*td;\n        float d=de(p);\n\t\ttd+=d;\n        sh=min(sh,10.*d/td);\n        if (sh<.05) break;\n    }\n    return clamp(sh,0.,1.);\n}\n\n// Lighting\n\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {\n\tfloat sha=shadow(p); \n    float aoc=ao(p,n);\n    float amb=.25*aoc; // ambient light with ambient occlusion\n    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow\n    vec3 ref=reflect(dir,n); // reflection vector\n    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    \n    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color\n}\n\n// Raymarching\n\nvec4 march(vec3 from, vec3 dir, vec3 camdir) {\n    // variable declarations\n\tvec3 p=from, col=vec3(0.1), backcol=col;\n    float totdist=0., d=0.,sdet, glow=0., lhit=1.;\n\t// the detail value is smaller towards the end as we are closer to the fractal boundary\n   \tdet*=1.-fin*.7;\n    // raymarching loop to obtain an occlusion value of the sun at the camera direction\n    // used for the lens flare\n    for (int i=0; i<70; i++) {\n    \tp+=d*ldir; // advance ray from camera pos to light dir\n        d=de(p)*2.; // distance estimation, doubled to gain performance as we don't need too much accuracy for this\n        lhit=min(lhit,d); // occlusion value based on how close the ray pass from the surfaces and very small if it hits \n        if (d<det) { // ray hits the surface, bye\n            break;\n        }\n    }\n    // main raymarching loop\n    for (int i=0; i<150; i++) {\n    \tp=from+totdist*dir; // advance ray\n        d=de(p); // distance estimation to fractal surface\n        sdet=det*(1.+totdist*.1); // makes the detail level lower for far hits \n        if (d<sdet||totdist>maxdist) break; // ray hits the surface or it reached the max distance defined\n    \ttotdist+=d; // distance accumulator  \n        glow++; // step counting used for glow\n    }\n    float sun=max(0.,dot(dir,ldir)); // the dot product of the cam direction and the light direction using for drawing the sun\n    if (d<.2) { // ray most likely hit a surface\n    \tp-=(sdet-d)*dir; // backstep to correct the ray position\n        vec3 c=fcol; // saves the color set by the de function to not get altered by the normal calculation\n        vec3 n=normal(p); // calculates the normal at the ray hit point\n        col=shade(p,dir,n,c); // sets the color and lighting\n    } else { // ray missed any surface, this is the background\n        totdist=maxdist; \n    \tp=from+dir*maxdist; // moves the ray to the max distance defined\n        // Kaliset fractal for stars and cosmic dust near the sun. \n        vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\n        for (int i = 0; i < 10; i++) st = abs(st) / dot(st,st) - .8;\n        backcol+=length(st)*.015*(1.-pow(sun,3.))*(.5+abs(st.grb)*.5);\n        sun-=length(st)*.0017;\n        sun=max(0.,sun);\n\t\tbackcol+=pow(sun,100.)*.5; // adds sun light to the background\n    }\n    backcol+=pow(sun,20.)*suncol*.8; // sun light\n    float normdist=totdist/maxdist; // distance of the ray normalized from 0 to 1\n    col=mix(col,backcol,pow(normdist,1.5)); // mix the surface with the background in the far distance (fog)\n    col=max(col,col*vec3(sqrt(glow))*.13); // adds a little bit of glow\n\t// lens flare\n    vec2 pflare=dir.xy-ldir.xy;\n    float flare=max(0.,1.0-length(pflare))-pow(abs(1.-mod(camdir.x-atan(pflare.y,pflare.x)*5./3.14,2.)),.6);\n\tfloat cflare=pow(max(0.,dot(camdir,ldir)),20.)*lhit;\n    col+=pow(max(0.,flare),3.)*cflare*suncol;\n\tcol+=pow(sun,30.)*cflare;\n    // \"only glow\" part (at sec. 10)\n    col.rgb=mix(col.rgb,glow*suncol*.01+backcol,1.-smoothstep(0.,.8,abs(time-10.5)));\n    return vec4(col,normdist); // returns the resulting color and a normalized depth in alpha\n}\t//(depth was going to be used for a postprocessing shader) \n\n\n// -------------------------------------------------------------------------------------------\n\n// Camera and main function\n\n// I learnt this function from eiffie,\n// it takes a direction, a reference up vec3\n// and returns the rotation matrix to orient a vector\nmat3 lookat(vec3 dir, vec3 up){\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\n// the path of the camera at a given point of time\nvec3 campath(float ti) {\n    float start=pow(max(0.,1.-ti*.02),3.); // interpolation curve for the starting camera\n\tvec3 p=pitpath(ti); // path displacement of the fractal \n    p*=1.-start; // the camera gradually ends following the fractal when, that happens when start=0\n    p+=vec3(start*30.,start*25.,0.); // position offset for starting camera curve   \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 dir=normalize(vec3(uv,1.)); // ray direction  \n\ttime=mod(iTime,162.); // time loop\n    fin=smoothstep(145.,147.5,time); // aux variable used for the end sequence\n    // camera accelerations and slow downs\n    float acel1=smoothstep(11.,12.,time)*7.31;\n    float acel2=smoothstep(99.,100.,time)*4.;\n    float desacel1=smoothstep(77.,78.,time)*5.;\n    float desacel2=fin*9.5;\n\tfloat tt=time;\n\t// freeze BW frame\n    if (abs(tt-25.5)<.5) tt=25.;\n    float acel=acel1+acel2-desacel1-desacel2;\n\t// time variable\n    float t=tt*(3.6+acel)-acel1*11.-acel2*99.+desacel1*77.+desacel2*147.5;\n    t+=smoothstep(125.,145.,time)*243.;\n    vec3 from=campath(t); // camera position\n    from.y-=desacel2*.035; // camera offset on 2nd slow down\n\tvec3 fw=normalize(campath(t+3.)-from); // camera forward direction\n    from.x-=fw.x*.1; // camera x offset based on the forward direction\n    dir=dir*lookat(fw*vec3(1.,-1.,1.),vec3(fw.x*.2,1.,0.)); // re-orientation of the ray dir with the camera fwd dir\n\tldir=normalize(ldir); // light dir normalization \n\tvec4 col=march(from, dir, fw); // get color from raymarching and background\n    col.rgb=mix(vec3(length(col.rgb)*.6),col.rgb,.85-step(abs(tt-25.),.1)); // BW freeze frame sequence coloring\n\tcol.rgb*=1.-smoothstep(25.,26.,time)+step(25.1,tt); // BW freeze frame sequence fading\n    col.rgb*=1.+step(abs(tt-25.),.1);\n    // PVM Logo color mixing\n    vec4 pvm=logo(uv*1.5+vec2(.9,.5))*smoothstep(1.,3.,time+uv.x*2.)*(1.-smoothstep(7.5,8.,time+uv.x*2.));\n    col.rgb=mix(col.rgb,pvm.rgb,pvm.a);\n    // fade in from black\n    col.rgb*=smoothstep(0.,4.,time);\n    // fade out to black\n    col.rgb*=1.-smoothstep(160.,162.,time);\n    fragColor = col;\n}", "image_inputs": [{"id": "4lXGWS", "previewfilepath": "https://soundcloud.com/pablo-andrioli/uctumi-alien-reefs-wip", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pablo-andrioli/uctumi-alien-reefs-wip", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[746, 771, 792, 792, 858], [860, 915, 939, 939, 1023], [1136, 1181, 1220, 1220, 1322], [1324, 1364, 1402, 1402, 1738], [1741, 1812, 1832, 1832, 3558], [3670, 3831, 3855, 3855, 4062], [4064, 4097, 4117, 4117, 6339], [6454, 6522, 6543, 6543, 6645], [6648, 6709, 6735, 6735, 6888], [6891, 6891, 6913, 6913, 7102], [7104, 7117, 7165, 7165, 7549], [7551, 7567, 7613, 7642, 10663], [10851, 10989, 11020, 11020, 11129], [11132, 11183, 11207, 11207, 11556], [11558, 11558, 11615, 11615, 13386]]}
{"id": "WlSSWW", "name": "Blob-test", "author": "Buddhi", "description": "My first shader in ShaderToy", "tags": ["blob"], "likes": 14, "viewed": 259, "published": "Public", "date": "1565816154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k/4.0;\n}\n\nfloat dist(vec3 point)\n{\n    float d = point.y + 1.0;\n    for(float i = 1.0; i < 50.0; i++)\n    {\n        vec3 pos = vec3(sin(i*1.43+iTime*0.12), cos(i*1.13+iTime*0.345), sin(i*3.23+iTime*0.243));\n        \n\n        float sphere = (length(point - pos) - 0.001*i);\n        d = smin(sphere, d, 0.8);\n        \n    }\n    return d;\n}\n\nvec3 normal(vec3 point)\n{\n    vec3 delta = vec3(0.001, 0.0, 0.0);\n    float center = dist(point);\n    return(normalize(vec3(\n        center - dist(point - delta.xyz),\n        center - dist(point - delta.yxy),\n        center - dist(point - delta.yyx)\n        )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 camera = vec3(3.0 * sin(time), 1.5, 3.0 * cos(time));\n    vec3 target = vec3(0.1, 0.2, 0.5);\n    vec3 light = normalize(vec3(-4.0, 3.0, -4.0));   \n    \n    vec3 ww = normalize(target - camera);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    \n    vec3 dir = normalize(uv.x*uu + uv.y*vv + 1.8*ww);\n    \n    float scan = 0.0;\n    vec3 point;\n    int i;\n    for(i = 0; i < 100; i++)\n    {\n        point = camera + scan * dir;\n        float d = dist(point);\n        scan += d;\n        if(scan > 40.0) break;\n        if(scan < 0.01) break;\n    }\n    \n    vec3 mat = vec3(0.2, 0.4, 0.8);\n    \n    if (scan <= 20.0)\n    {\n        vec3 n = normal(point);\n        float shade = dot(n, light);\n        \n       \tvec3 halfv = normalize(light - dir);\n\t\tfloat spec = pow(max(dot(n, halfv), 0.0), 10.0);\n        \n        col = mat * shade + spec;\n    }\n    else\n    {\n        col = 0.5*vec3(1.0 - uv.y, 1.0 - 0.5*uv.y, 1.0);\n    }\n    \n    //glow\n    col += vec3(float(i)*0.007, float(i)*0.003, 0); \n    \n    //dark\n    col /= scan *0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 77, 77, 155], [157, 157, 181, 181, 484], [486, 486, 511, 511, 750], [752, 752, 809, 809, 2166]]}
{"id": "wlSSWy", "name": "Cookie Waves", "author": "dr2", "description": "What's a cookie wave?", "tags": ["raymarch", "shadow", "repetition", "hexagon"], "likes": 4, "viewed": 291, "published": "Public API", "date": "1566922265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Cookie Waves\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1 \n\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 ltDir, flPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize, wavHt, bRad, nArm, armDir, armFrq, cCol;\nint idObj;\nbool isOcc;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, bLen, h, r;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId * hgSize);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  d = max (abs (q.x) - 0.85 * hgSize, q.y - wavHt + 0.05 * dot (q.xz, q.xz));\n  DMIN (1);\n  if (isOcc) {\n    bLen = 0.5;\n    p.y -= wavHt - 0.03;\n    q = p;\n    r = length (q.xz);\n    q.xz = Rot2D (q.xz, armDir * (0.1 * pi * r * (1. + 0.1 * sin (2. * pi * armFrq * r))\n       - 0.03 * pi * q.y * (1. + sin (2. * pi * 1.5 * r))));\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (nArm * atan (q.z, - q.x) / (2. * pi) + 0.5) / nArm));\n    q.x += bLen;\n    h = 0.25 * (1. - q.x / bLen);\n    h = 0.3 * (1. - 3.2 * h * h);\n    q.y -= h + 0.05;\n    d = length (max (abs (q) - vec3 (bLen, h, 0.001 * (1. + 12. * q.x) * (4. - 20. * q.y)), 0.)) - 0.05;\n    q = p;\n    q.y -= 0.35;\n    d = SmoothMin (d, PrCylDf (q.xzy, 0.01, 0.35), 0.03);\n    q = p;\n    q.y -= -1.25;\n    d = 0.8 * SmoothMin (d, - SmoothMin (min (bRad - length (q), q.y - 1.25), 2.2 * bLen -\n       r, 0.05), 0.05);\n    DMIN (2);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  float emFrac;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.3 * sin (0.2 * 2. * pi * p)) +\n    0.1 * tCur, 1.) - 0.5;\n  wavHt = 0.6 * dot (exp (-100. * u * u), vec2 (1.));\n  emFrac = 0.05;\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  isOcc = (fRand.y >= emFrac);\n  if (isOcc) {\n    nArm = 5. + floor (12. * fRand.x);\n    armDir = 2. * floor (mod (32. * fRand.x, 2.)) - 1.;\n    fRand.y = (fRand.y - emFrac) / (1. - emFrac);\n    armFrq = 2. + 6. * fRand.y;\n    cCol = fRand.x + fRand.y;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.05;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 4; j ++) {\n    d = 0.01 + float (j) / 20.;\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  return 0.5 + 0.5 * clamp (1. - 2. * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vno, q;\n  float dstObj, sh, ao, s;\n  bRad = 1.75;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vno = vn;\n    if (idObj == 1) {\n      q = ro;\n      q.xz -= HexToPix (gId * hgSize);\n      if (vn.y > 0.01) {\n        col4 = vec4 (mix (vec3 (0.97, 1., 0.97), vec3 (0.9, 0.9, 0.95),\n           smoothstep (0.4, 0.6, Fbm2 (ro.xz))), 0.3);\n      } else {\n        q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n        col4 = vec4 (0.95, 0.95, 1., 0.3) * (0.8 + 0.2 * cos (9. * 2. * pi * q.z / hgSize));\n      }\n    } else if (idObj == 2) {\n      q = ro;\n      q.y -= wavHt;\n      s = length (q - vec3 (HexToPix (gId * hgSize), -1.25).xzy) - bRad + 0.01;\n      col4 = mix (mix (vec4 (1., 1., 1., 0.2), vec4 (0.3, 0.1, 0., 0.1),\n         step (0.7, Fbm2 (16. * ro.xz))), vec4 (HsvToRgb (vec3 (floor (8. * mod (cCol, 1.)) / 8.,\n         0.5, 1.)), 0.2), smoothstep (0., 0.02, s));\n      s = step (0., s);\n      vn = VaryNf ((8. + 56. * s) * q, vn, 4. - 3. * s);\n    }\n    ao = ObjAO (ro, vno);\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (sh > 0.5) col *= ao;\n  } else col = vec3 (0.6, 0.6, 0.6);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return t * vec3 (0.1, 0., sqrt (0.99)) + vec3 (2. * cos (0.1 * t), 0., 0.);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 1.6;\n  VuPM (1. * tCur);\n  az = 0.;\n  el = -0.1 * pi;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  flPos.y += 10.;\n  ro = flPos;\n  zmFac = 6. + 3. * sin (0.02 * 2. * pi * tCur);\n  dstFar = 100.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    rd = rd * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSSWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 670, 692, 692, 1784], [1786, 1786, 1808, 1808, 2371], [2373, 2373, 2406, 2406, 3497], [3499, 3499, 3520, 3520, 3715], [3717, 3717, 3754, 3754, 4164], [4166, 4166, 4198, 4198, 4559], [4561, 4561, 4596, 4596, 5993], [5995, 5995, 6021, 6021, 6101], [6103, 6103, 6124, 6124, 6722], [6724, 6724, 6780, 6780, 7950], [7952, 7952, 7994, 7994, 8045], [8047, 8047, 8071, 8071, 8301], [8303, 8303, 8327, 8327, 8387], [8389, 8389, 8411, 8411, 8449], [8451, 8451, 8496, 8496, 8599], [8601, 8601, 8631, 8631, 8744], [8746, 8746, 8770, 8770, 8887], [8921, 8921, 8945, 8945, 9075], [9077, 9077, 9102, 9102, 9288], [9290, 9290, 9311, 9311, 9466], [9468, 9468, 9497, 9497, 9709], [9711, 9711, 9750, 9750, 9935]]}
{"id": "wlSSzc", "name": "Intro to cone tracing pt.1", "author": "edapx", "description": "This is my attempt to understand better the cone tracing, with comments and link to other shadertoy examples. Comments and fixes are always appreciated ;)", "tags": ["antialias", "conetracing"], "likes": 3, "viewed": 222, "published": "Public", "date": "1566576484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 64;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.00;\nconst float PI = 3.14159265359;\n\nvec3 toGamma( vec3 col ){\n\treturn pow( col, vec3(1.0/2.2));\n}\n\nfloat clampeddot(vec3 a, vec3 b){\n    return max(0.,dot(a, b));\n}\n\nvec3 lightDirection = vec3(1.0, 1.0, 1.0);\n\nvec2 rotate(vec2 pos, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n} \n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(vec3 pos){\n    pos.xy = rotate(pos.xy, sin(iTime) * PI/2. * 0.03);\n    float offset = 0.5;\n    //float sph = sphere(pos, 1.5);\n    // just a sphere\n    //return sph;\n\n    // domain repetition, more edges, antialias more visible\n    pos = opRep(pos, vec3(offset, offset, offset));\n\n    // test boxes\n    return sdBox(pos, vec3(0.1, 0.1, 0.1));\n\n    // test spheres\n    //return sphere(pos, .2);\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    return clampeddot(normal, lightDirection);\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return pow(clampeddot(h, normal), specularityCoef);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getColor(vec3 eye, vec3 dir,float dist){\n    float ambient = 0.2;\n    vec3 red = vec3(1.0, 0.353, 0.208);\n    vec3 collision = (eye += (dist*0.995) * dir );\n    vec3 normal = computeNormal(collision);\n    float diffLight = diffuse(normal) * ambient + ambient;\n    float specLight = specular(normal, dir);\n\n    return (diffLight + specLight ) * red;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(3.5, 3.0, -1.0);\n    vec3 ta = vec3( -0.5, -0.9, 0.5 );\n    mat3 camera = setCamera( eye, ta, 1.0 );\n    float fov = 2.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n\n    // bg color\n    vec3 finalColor = vec3(0.086, 0.19, 0.8);\n    // t is the position of the center of the sphere along the ray.\n    float t = NEAR_CLIP;\n    float dist = EPSILON;\n    float zoom = 1.5;\n\n    // this is the radius of the sphere that models the cone.\n    // formula from https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer\n    float vfov = 0.9; //vfov is the vertical camera field-of-view (in radians)\n    float radius = (2.0*tan(vfov/2.0)) /(iResolution.y*zoom);\n\n    // it can also be simplyfied using a constant, like in via https://www.shadertoy.com/view/MsBGWm\n    // float radius = .7071/(u_resolution.y*zoom);\n\n    // color accumulation variable. This is used to accumulate the colors sampled for all\n    // the intersection between the cone and the scene, and to accumulate the coverage\n    // on the alfa channel\n    vec4 acc = vec4(0, 0, 0, 1);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float rad = t*radius;\n\n        // move the center of the sphere along the ray\n        dist = map(eye + t * dir);\n\n\n        // if the distance from the scene is smaller than the radius,\n        // it means that there is an intersection between the cone and the scene.\n        // we accumulate and blend the colors sampled for those intersections into the acc variable.\n        if (dist < rad) {\n            // how much of the surface of the projected pixel is covering the scene?\n            // this is what the coverage value stands for.\n\n            // This is the easiest coverage calculation that I have found:\n            // float alpha = smoothstep(rad, -rad, dist);\n            // https://www.shadertoy.com/view/4scBW8\n            float alpha = smoothstep(rad, -rad, dist);\n\n            // Another one is to get an estimation of the coverage of the surface by using it's distance\n            // over the projected aperture of the cone. \n            // coverage = dist / rad;\n            // of course the blending algorithm have to be adapted. see https://www.shadertoy.com/view/MsBGWm\n\n            // then sample the color at the given distance.\n            // I know, I could save the allocation of this variable, but, for the sake of clarity ...\n            vec3 sampleCol = getColor(eye, dir, t);\n\n            // the new color is calculated multiplying\n            // the previous alpha for the new color times the new alpha\n            acc.rgb += acc.a * (alpha*sampleCol.rgb);\n            // here we save the new alpha\n            acc.a *= (1.0 - alpha);\n\n            // when acc.a is really small, it means that we hit the object, brake the loop\n            if (acc.a < EPSILON ) break;   \n        }\n\n\n        // move the center of the sphere forward along the ray. The smaller\n        // the steps the higher the precision and the slower the computation.\n        t += max(abs(dist*0.85), 0.001); //https://www.shadertoy.com/view/4dlyWB\n        // t += max( dist, rad*.5 ); // https://www.shadertoy.com/view/MsBGWm\n\n        // brake if we are going too far away\n        if (t > FAR_CLIP) break;\n    }\n\n    finalColor = mix(acc.rgb, finalColor, acc.a);\n    fragColor = vec4(clamp(toGamma(finalColor),0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 183, 183, 219], [221, 221, 254, 254, 286], [332, 332, 367, 367, 457], [460, 460, 490, 490, 581], [583, 583, 620, 620, 655], [657, 657, 686, 686, 715], [717, 717, 737, 737, 1122], [1124, 1124, 1153, 1153, 1367], [1369, 1369, 1396, 1396, 1445], [1447, 1447, 1485, 1485, 1614], [1616, 1616, 1667, 1667, 1856], [1858, 1858, 1903, 1903, 2213], [2216, 2216, 2273, 2273, 5777]]}
{"id": "WlSSzR", "name": "Raymarched Mandelbrot", "author": "snerp", "description": "added a 3rd dimension to the complex multiply, like a quaternion with a value chopped off.", "tags": ["raymarching", "fractal", "mandelbrot"], "likes": 2, "viewed": 298, "published": "Public API", "date": "1564715650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 complexMult(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec3 complexMult3(vec3 a, vec3 b) {\n\treturn vec3(a.x*b.x - a.y*b.y - a.z*b.z, a.x*b.y + a.y*b.x, a.x*b.z + a.z*b.x);\n}\n\nfloat testMandelbrotDist(vec3 coord3d) {\n    // turn this up to reduce visual noise\n    const int iterations = 92;\n\tvec3 testPoint = vec3(0,0,0);\n    vec3 distTest = vec3(0,0,0);\n\tfor (int i = 0; i < iterations; i++){\n        distTest = 2.0*complexMult3(testPoint, distTest) + vec3(1,0,0);\n\t\ttestPoint = complexMult3(testPoint,testPoint) + coord3d;\n        float ndot = dot(testPoint,testPoint);\n\t\tif (ndot > 1024.0) {\n            return 0.5 * sqrt(ndot/dot(distTest,distTest))*log(ndot);\n\t\t}\n\t}\n\treturn -0.1;\n}\n\nmat3 rotmat(vec3 axis, float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv) {\n    uv = (0.1 + 0.6*abs(sin(iTime*0.1)))*(uv * 2.0 - 1.0) * vec2(1.0, iResolution.y / iResolution.x);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0));\n    vec2 coord = vec2(6.0 * iMouse.x/ iResolution.x, 3.0 * (0.5+ iMouse.y/iResolution.y));\n    if (iResolution.x < 500.0) {\n        coord = vec2(-4.33,-3.0);\n    }\n\treturn rotmat(\n        vec3(0.0, 1.0, 0.0),\n        coord.x\n    ) * rotmat(\n        vec3(1.0, 0.0, 0.0), \n        coord.y \n    ) * proj;\n}\nconst float minDist = 0.5;\nconst float maxDist = 4.5;\nfloat rayMarchMandelbrot(vec3 eye, vec3 ray) {\n    float iterDval = 0.01;\n    float distance = minDist;\n    const int limit = int(maxDist/0.01);\n    for (int i = 0; i < limit; i++) {\n     \tfloat testval =  testMandelbrotDist(eye + ray*distance);\n        if (iterDval < 0.001 || abs(testval) < 0.000001) {\n         \treturn distance;   \n        }\n        if (testval > 0.0) {\n         \tdistance = distance + iterDval;   \n        } else {\n            iterDval = iterDval * 0.5;\n            distance = distance - iterDval;\n        }\n    }\n    return distance;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    const float es = 0.02;\n    return normalize(vec3(\n        testMandelbrotDist(vec3(p.x + es, p.y, p.z)) - testMandelbrotDist(vec3(p.x - es, p.y, p.z)),\n        testMandelbrotDist(vec3(p.x, p.y + es, p.z)) - testMandelbrotDist(vec3(p.x, p.y - es, p.z)),\n        testMandelbrotDist(vec3(p.x, p.y, p.z  + es)) - testMandelbrotDist(vec3(p.x, p.y, p.z - es))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 fragment = fragCoord/iResolution.xy;\n    vec3 ray = getRay(fragment);\n\tvec3 camPos = getRay(vec2(0.5,0.5)) * -3.0;\n    float dist = rayMarchMandelbrot(camPos, ray);\n    if (dist > minDist && dist < maxDist){\n        vec3 lightpos = vec3(-.5,-1,.5);\n        vec3 lightCol = vec3(.98,.4,.5);\n        vec3 normal = estimateNormal(camPos + ray * dist);\n        float intensity = dot(lightpos, normal);        \n    \tfragColor = vec4(lightCol * intensity, 1.0);\n    } else {\n        fragColor = vec4(vec3(0.3*(dist)), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 88], [90, 90, 125, 125, 208], [210, 210, 250, 293, 721], [723, 723, 760, 760, 1149], [1151, 1151, 1173, 1173, 1626], [1681, 1681, 1727, 1727, 2238], [2241, 2241, 2270, 2270, 2637], [2639, 2639, 2694, 2694, 3229]]}
{"id": "wlsXD2", "name": "Keep up little square", "author": "104", "description": "I think we're lost", "tags": ["legday"], "likes": 18, "viewed": 158, "published": "Public", "date": "1565100915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float xscale = .25;\nconst float yscale = .2;\nconst float xspeed = 1.0;\nconst float timeMult = .17;\nconst float sluggishness = 10.;\nconst float camShakiness = 0.05;\nconst float camZoom = 0.1;\n\n//---------------------------------------------\n\nconst float PI = atan(1.)*4.;\nconst float PI2 = PI*2.;\n\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\nfloat sdSquare(vec2 p, vec2 pos, vec2 origin, float a, float s) {\n\tvec2 d = abs(((p-pos) * mat2(cos(a), sin(a), -sin(a), cos(a))) - origin) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// returns { x:orig, y:height, z:position 0-1 within this cell }\nvec3 cell(float x) {\n    float pos = fract(x/xscale);\n    float orig = (x/xscale-pos)*xscale;\n    float h = hash32(vec2(orig)).r;\n    return vec3(orig, h * yscale, pos);\n}\n\nvoid scene(out vec4 o, vec2 N, vec2 uv, float t, float xpos, float xcam) {\n    vec3 sqCellPrev = cell(xpos-xscale);\n    \n    // ground\n    vec3 bigCellThis = cell(uv.x);\n    vec3 bigCellNext = cell(uv.x + xscale);\n    float bigHeightThis = mix(bigCellThis.y, bigCellNext.y, bigCellThis.z);// terrain height\n    float sd = uv.y - bigHeightThis;\n\n    // walking square; interpolate between positions\n    float sdsq = 1e7;\n    vec3 sqCellThis = cell(xpos);\n    vec3 sqCellNext = cell(xpos+xscale);\n    float aThis = atan(sqCellPrev.y - sqCellThis.y, sqCellPrev.x - sqCellThis.x);\n    float aNext = atan(sqCellThis.y - sqCellNext.y, sqCellThis.x - sqCellNext.x) - PI*.5;\n    if(aNext > aThis+PI) aNext -= PI2;\n    if(aNext < aThis-PI) aNext += PI2;\n\n    float szThis = distance(sqCellPrev.xy, sqCellThis.xy);\n    float szNext = distance(sqCellThis.xy, sqCellNext.xy);\n\n    float asq = mix(aThis, aNext, pow(sqCellNext.z, sluggishness));\n    float sz = mix(szThis, szNext, pow(sqCellNext.z, sluggishness));\n    sdsq = sdSquare(uv,\n                                  vec2(sqCellThis.x, sqCellThis.y),\n                                  vec2(-sz*.5,sz*.5), asq+PI, sz*.5);\n\n    // parallax bg\n    o=vec4(0);\n    vec2 uvtemp =uv;\n    for (float i = 1.; i <= 9.; ++i) {\n        uvtemp.x -= xpos;\n        uvtemp*=vec2(2.,1.8);\n        //uvtemp *= 2.;\n        uvtemp.y -= .3;\n        uvtemp.x += xpos + 1e3;\n        vec3 cellThis = cell(uvtemp.x);\n        vec3 cellNext = cell(uvtemp.x + xscale);\n        float heightThis = mix(cellThis.y, cellNext.y, cellThis.z);\n        float sd = uvtemp.y - heightThis;\n        o.rgb = max(o.rgb, dtoa(sd,1e4)*.2/i);\n        \n        float amt = 25.+heightThis*500.;\n        //amt = 1000./((uvtemp.y)*100.);\n      \to.rgb = max(o.rgb, dtoa(abs(sd)+.01,amt)*.4/i);\n    }\n    o +=vec4(.8-uv.y*1.1);\n    o.g *= o.r;\n    o.r *=.6;\n    o.b += N.y;\n\n    // square\n    float alphasq = dtoa(sdsq, 1000.);\n    o.rgb = mix(o.rgb, vec3(.9,.1,.1), alphasq);\n    \n    // ground\n    float alphagr = dtoa(sd, 300.);\n    o.rgb = mix(o.rgb, vec3(1), alphagr);\n    \n    // snow\n    float amt = 25.+bigHeightThis*500.;\n    alphagr = dtoa(abs(sd+.01), amt);\n    o.rgb = mix(o.rgb, vec3(.8,.9,1), alphagr);\n}\n\nvoid mainImage( out vec4 o, vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec2 N = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    float t = iTime*timeMult;\n    float xpos = t*xspeed;\n    float xcam = sin(t)*sin(t*9.)*camShakiness;// shaky cam\n    uv *=.7+sin(t*2.)*camZoom;//zoomy cam\n    uv.x += xpos + xcam;\n\tuv.y += .3;\n\n    // calc scene twice & motion blur\n    vec3 sqCellPrev = cell(xpos-xscale);\n    float bounce = abs(sin(sqCellPrev.z*26.))*pow(1.-sqCellPrev.z, 7.) * .03;\n    uv.y += bounce;\n    scene(o, N, uv, t, xpos, xcam);\n    uv.y -= bounce;\n    vec4 o2;\n    scene(o2, N, uv, t, xpos, xcam);\n    o = mix(o2, o, .5);\n    \n    o.b *= .9;\n    o.rgb += (hash32(fragCoord+iTime)-.5)*.08;\n    o *= 1.1-dot(N,N);\n    o=clamp(o,0.,1.);\n    o.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 303, 324, 324, 460], [462, 462, 496, 496, 543], [544, 544, 609, 609, 745], [747, 812, 832, 832, 983], [985, 985, 1059, 1059, 3195], [3197, 3197, 3243, 3243, 3979]]}
{"id": "wlSXDw", "name": "Mandelbulb World v5", "author": "96logda", "description": "This is the fifth version in my Mandelbulb World serie.", "tags": ["procedural", "mandelbulb", "shadow", "menger", "vegetation", "mengersponge"], "likes": 5, "viewed": 163, "published": "Public", "date": "1566053564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Copyright (c) 2019-08-17 - 2019-08-18 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define PI\t\t\t\t\t3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n#define dot2(x) \t\t\tdot(x, x)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t500\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n   \treturn p.y - height;\n}\n\n//https://www.shadertoy.com/view/ltfSWn\nfloat mandelbulb(vec3 p)\n{\n    vec3 w = p;\n    float m = dot2(w);\n    float dz = 1.0;\n    for(int i = 0; i < 3; ++i)\n    {\n\t\tdz = 8.0 * pow(sqrt(m), 7.0) * dz + 1.0;\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n\n        m = dot(w,w);\n\t\tif (m > 255.0)\n\t\t{\n            break;\n\t\t}\n    }\t\n    return 0.1 * log(m) * sqrt(m) / dz;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\t\n    float ground = sdPlane(p, 1.8);\n    \n    p.xz = mod(p.xz + 5.0, 2.0) -1.0;\n    p.y = mod(p.y + 1.0, 2.0) - 1.0;\n\t\n    float d = mandelbulb(p - vec3(0.0, 0.5, 0.0));\n    vec4 res = vec4(d, 1.0, 0.0, 2.0);\n\t\n    //......................................................................\n    //  https://www.iquilezles.org/www/articles/menger/menger.htm\n    //......................................................................\n    float s = 1.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    { \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 3.0) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    //......................................................................\n    \n    return opU(res, vec4(ground, 1.0, 0.0, 1.0));\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; i++ )\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.0001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).y;\n        res = min(res, k * h / t);\n        if(res < 0.0001)\n\t\t{\n\t    \tbreak;\n    \t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 GetMaterialColor(in vec3 p, float materialID)\n{\n    if (materialID < 1.5)\n    {\n         vec2 uv = p.xz;\n         vec3 texRGB = texture(iChannel0, uv, 0.0).rgb;\n         return texRGB * 0.2 + vec3(0.0, 0.015, 0.0);\n    }\n    else if (materialID < 2.5)\n    {\n         vec2 uv = p.xy;\n         vec3 texRGB = texture(iChannel1, uv, 0.0).rgb;\n         return texRGB * 0.5;\n    }\n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {\n        const vec3 light1 = vec3(0.0, 0.0, -0.2);\n        \n        vec3 pos = ro + res.x * rd;\n        \n        vec3 normal = calcNormal(pos);\n        vec3 reflection = reflect(rd, normal);\n        \n        float occ = res.y;\n        float shadow1 = softshadow(pos + 0.01 * normal, light1);\n        \n        vec3 baseColor = GetMaterialColor(pos, res.w);\n        vec3 ambient = vec3(0.2) * baseColor;      \n\n        vec3 diffuse = baseColor * shadow1 * occ;\n        color = diffuse + (ambient * occ);\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\t \n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(15.0, 2.9, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro); \n    ww.xz = rotate2D(ww.xz, iMouse.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    rd.xz = rotate2D(rd.xz, PI * 2.55);\n\n    ro.z -= iTime * 0.1; //Camera movement\n\t\n    vec3 color = vec3(0.2);\n    color -= vec3(0.3, 0.3, 0.9);\n \tcolor += render(ro + vec3(0.0, -1.0, 0.0), rd);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 363, 399, 399, 512], [514, 514, 551, 551, 578], [580, 620, 646, 646, 1087], [1089, 1089, 1117, 1117, 1156], [1158, 1158, 1179, 1179, 2204], [2206, 2206, 2246, 2246, 2623], [2625, 2625, 2667, 2667, 2989], [2991, 2991, 3021, 3021, 3264], [3266, 3266, 3320, 3320, 3622], [3624, 3624, 3676, 3676, 4027], [4029, 4029, 4066, 4066, 4700], [4702, 4702, 4758, 4758, 5476]]}
{"id": "wlSXDz", "name": "draw-math-2", "author": "lilieming", "description": "draw math", "tags": ["drawmath"], "likes": 1, "viewed": 40, "published": "Public", "date": "1565580080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n float disk(float x, float y, float r) {\n    return 1. - step(r * r, x * x + y * y);\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n\n    float x = uv.x + 0.1 * sin(2.0 * iTime);\n    float y = uv.y + 0.1 * sin(2.1 * iTime);\n    float r = 0.2    + 0.1 * sin(2.2 * iTime);\n\n    float c = disk(x, y, r);  \n   \tfloat c1 = disk(x+.2, y+.5, r); \n\n    vec3 color = vec3(c, c, 0.); \n                                   \n\tcolor += vec3(c1, c1, 0.);\n    \n\n    // Output to screen\n    fragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 41, 41, 88], [90, 90, 147, 197, 620]]}
{"id": "WlSXRG", "name": "draw-math-4", "author": "lilieming", "description": "draw-math", "tags": ["justcoding"], "likes": 1, "viewed": 73, "published": "Public", "date": "1566197433", "time_retrieved": "2021-10-01T00:00:00", "image_code": " vec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\n   vec4 mod289(vec4 x) { \n    return x - floor(x * (1. / 289.)) * 289.;\n}\n vec4 permute(vec4 x) { \n     return mod289(((x*34.)+1.)*x); \n }\n vec4 taylorInvSqrt(vec4 r) { \n     return 1.79284291400159 - .85373472095314 * r;\n }\n  vec3 fade(vec3 t) {\n      return t*t*t*(t*(t*6.-15.)+10.);\n  }\nfloat noise(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.)),\n       f0 = fract(P), f1 = f0 - vec3(1.), f = fade(f0);\n     vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy),\n          iz0 = i0.zzzz, iz1 = i1.zzzz,\n        ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1),\n          gx0 = ixy0 * (1. / 7.), gy0 = fract(floor(gx0) * (1. / 7.)) - .5,\n          gx1 = ixy1 * (1. / 7.), gy1 = fract(floor(gx1) * (1. / 7.)) - .5;\n     gx0 = fract(gx0); gx1 = fract(gx1);\n     vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.)),\n          gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.));\n     gx0 -= sz0 * (step(0., gx0) - .5); gy0 -= sz0 * (step(0., gy0) - .5);\n     gx1 -= sz1 * (step(0., gx1) - .5); gy1 -= sz1 * (step(0., gy1) - .5);\n     vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n          g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n          g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n          g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n     vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3))),\n          norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n     g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n     g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n     vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n                       dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n                   vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n                        dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n     return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n  }\n  float turbulence(vec3 P) {             // Turbulence is a fractal sum of abs(noise).\n     float f = 0., s = 1.;              // The domain is rotated after every iteration\n     for (int i = 0 ; i < 9 ; i++) {      //    to avoid any visible grid artifacts.\n        f += abs(noise(s * P)) / s;\n        s *= 2.;\n        P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);\n      }\n      return f;\n  }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    \n   \tfloat c = noise(vec3(uv.x, uv.y+sin(iTime), 5.*sin(iTime*.5)))*255.;\n    fragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 66], [70, 70, 91, 91, 140], [142, 142, 164, 164, 205], [207, 207, 235, 235, 291], [294, 294, 313, 313, 356], [357, 357, 378, 378, 2217], [2220, 2220, 2246, 2304, 2634], [2639, 2639, 2696, 2746, 2901]]}
{"id": "WlSXRh", "name": "math-draw-001", "author": "lilieming", "description": "Art of code", "tags": ["mathdraw"], "likes": 3, "viewed": 67, "published": "Public", "date": "1564917264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n  \tuv = vec2(st.x/ 6.2831 +  iTime * 0.1, st.y - 0.1* cos(iTime));\n                   \n    float x = uv.x*8.;\n    float m = min(fract(x), fract(1.0 - x));\n    float c = smoothstep(0., 0.1, m*0.5 + 0.2-uv.y);\n\n  \n    // Output to screen\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 444]]}
{"id": "WlSXRW", "name": "Rounded Box - intersection", "author": "iq", "description": "The intersection of a ray with a rounded box, testing a single corner (sphere) instead of 8, and only 3 edges (cylinders) instead of 12. It only works if the corner spheres don't overlap!", "tags": ["3d", "intersection", "roundedcube"], "likes": 23, "viewed": 2876, "published": "Public API", "date": "1565294624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray with a rounded box, testing a single\n// corner (sphere) instead of 8, and only 3 edges (cylinders)\n// instead of 12. There might be a more compact and efficient\n// way to do it, but this is where I landed. However the code\n// to compute the surface normal is particularly elegant.\n//\n// It only works if the corner spheres don't overlap, ie, if\n// the raius is smaller than half the size of the base box.\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n\n#define AA 2  // reduce this to 1 if you have a slow machine\n\n// intersect a ray with a rounded box\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n\n    // some precomputation\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n\tvec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    t = 1e20;        \n\n    // corner\n    {\n    float b = od.x + od.y + od.z;\n\tfloat c = oo.x + oo.y + oo.z - ra2;\n\tfloat h = b*b - c;\n\tif( h>0.0 ) t = -b-sqrt(h);\n    }\n\n    // edge X\n    {\n\tfloat a = dd.y + dd.z;\n\tfloat b = od.y + od.z;\n\tfloat c = oo.y + oo.z - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n    }\n\t}\n    // edge Y\n    {\n\tfloat a = dd.z + dd.x;\n\tfloat b = od.z + od.x;\n\tfloat c = oo.z + oo.x - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n    }\n\t}\n    // edge Z\n    {\n\tfloat a = dd.x + dd.y;\n\tfloat b = od.x + od.y;\n\tfloat c = oo.x + oo.y - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n    }\n\t}\n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\n\n//======================================================\n\n// rotation matrix\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\n// transform points and vectors\nvec3 ptransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,1.0)).xyz; }\nvec3 ntransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,0.0)).xyz; }\n\n//======================================================\n\nmat4  box_world_to_obj;\nmat4  box_obj_to_world;\nvec3  box_size;\nfloat box_radius;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (-1.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    // rounded box\n    {\n    // convert ray from world to box space\n    vec3 rdd = ntransform(box_world_to_obj, rd );\n    vec3 roo = ptransform(box_world_to_obj, ro );\n    // intersect in box space\n    float t = roundedboxIntersect(roo,rdd,box_size,box_radius);\n    if( t>0.0 && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // rounded box animation\n    box_obj_to_world = \n                       rotate( normalize(vec3(1.0,1.0,0.1)), iTime ); \n    box_world_to_obj = inverse( box_obj_to_world );\n    box_size = vec3(0.5,0.4,0.3);\n    box_radius = 0.2;\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n    \n\t    vec3 ro = vec3(0.0, 0.0, 2.0 );\n\t    vec3 rd = normalize( vec3(p,-1.5) );\n        \n        // sky\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // raymarch geometry\n        vec2 tm = intersect( ro, rd );\n        if( tm.y>0.0 )\n        {\n            // shading\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n\n            const vec3 lig = normalize(vec3(0.8,0.4,-0.6));\n            \n            if( tm.y<1.5 ) // floor\n            {\n                vec3 nor = vec3(0.0,1.0,0.0);\n                float sha = step( intersect( pos+0.01*nor, lig ).y, 0.0 );\n                col = mix( col*3.0*(vec3(0.2,0.3,0.4)+vec3(0.8,0.7,0.6)*sha), \n                       col, 1.0-exp(-0.02*t) );\n            }\n            else // rounded box\n            {\n                // convert position from world to box space\n                vec3 bpos = ptransform(box_world_to_obj,pos);\n                // compute normal in box space\n                vec3 bnor = roundedboxNormal(bpos,box_size,box_radius);\n                // convert normal from box to world space\n                vec3 nor = ntransform(box_obj_to_world,bnor);\n                \n                vec3 lig = normalize(vec3(0.7,0.6,0.3));\n                vec3 hal = normalize(-rd+lig);\n                float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n                float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n\n                const float fr = 3.14159*7.5;\n\n                col = vec3(0.5);\n\n                col += 0.4*smoothstep(-0.01,0.01,cos(bpos.x*fr*0.5)*cos(bpos.y*fr*0.5)*cos(bpos.z*fr*0.5)); \n                col *= 1.0*smoothstep(-1.0,-0.98,cos(bpos.x*fr))\n                          *smoothstep(-1.0,-0.98,cos(bpos.y*fr))\n                          *smoothstep(-1.0,-0.98,cos(bpos.z*fr));\n\n                col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n\n                col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;            }\n        }\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma\n    tot = pow( tot, vec3(0.45) );\n    \n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n   \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXRW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1730, 1836, 1917, 1934, 3486], [3488, 3515, 3580, 3580, 3637], [3698, 3717, 3753, 3753, 4157], [4159, 4191, 4234, 4234, 4266], [4267, 4267, 4310, 4310, 4342], [4344, 4485, 4527, 4527, 4994], [4996, 4996, 5053, 5082, 7939]]}
{"id": "WlSXRy", "name": "DANIEL ARSHAM CASSETTE TAPE", "author": "yasuo", "description": "The Lost Tapes 2\nhttps://www.instagram.com/p/B0Rsw2CACAf/", "tags": ["raymerching", "cassettetape"], "likes": 9, "viewed": 386, "published": "Public API", "date": "1566224540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define PI 3.141592653589793\n\n// noise and fbm function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))-r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdTapeGear( vec3 p, vec2 h )\n{\n    float r = (length(p)-0.23);\n    float w = 0.05;\n    float h2 = 0.1;\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float len = 0.38;\n\tfloat resd = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    float res2d = max(-r,resd);\n    float b = sdBox(p*matRotateY(radians(-10.0)),vec3(w,h2,len),0.0);\n    float b2 = sdBox(p*matRotateY(radians(25.0)),vec3(len,h2,w),0.0);\n    float b3 = sdBox(p*matRotateY(radians(-50.0)),vec3(len,h2,w),0.0);\n    \n    \n    float res3d = max(-b,res2d);\n    float res4d = max(-r,min(min(b,b2),b3));\n  \treturn min(res3d,res4d);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n\n    float b0 = sdBox((p+vec3(0.0, 0.0,0.0)),vec3(2.0,1.2,0.2),0.1);\n    float b1 = sdBox((p+vec3(0.0, -0.2,0.32)),vec3(1.8,0.7,0.03),0.1);\n    \n    p.x = abs(p.x);\n    p.x -= 2.0;\n    float b2 = sdTriPrism((p+vec3(0.0, 0.95,0.0))*matRotateZ(radians(-50.0)),vec2(1.0,0.6));\n    p = pref;\n    float b3 = sdBox((p+vec3(0.0, 0.92,0.0)),vec3(1.6,0.35,0.35),0.0);\n    float b4 = sdBox((p+vec3(0.0, -0.2,-0.4)),vec3(1.8,0.7,0.03),0.1);\n    \n    p.x = abs(p.x);\n    p.x -= 1.1;\n    float hole0 = sdCappedCylinder((p+vec3(0.0, 1.1,0.0))*matRotateX(radians(90.0)),0.08,1.0);\n    p = pref;\n    \n    p.x = abs(p.x);\n    p.x -= 0.7;\n    float hole1 = sdCappedCylinder((p+vec3(0.0, 0.95,0.0))*matRotateX(radians(90.0)),0.08,1.0);\n    p = pref;\n    \n    float holes = min(hole0,hole1);\n    \n    float centerRectHole =  sdBox((p+vec3(0.0, -0.15,0.0)),vec3(0.4,0.2,0.3),0.05);\n    \n    p.x = abs(p.x);\n    p.x -= 0.8;\n    float centerHoles = sdCappedCylinder((p+vec3(0.0, -0.15,0.0))*matRotateX(radians(90.0)),0.27,1.0);\n    p = pref;\n    \n   \tp.x = abs(p.x);\n    p.x -= 0.8;\n    float tapeCircles = sdCappedCylinder((p+vec3(0.0, -0.15,0.0))*matRotateX(radians(90.0)),0.65,0.07);\n    p = pref;\n    \n    float tape = max(-centerHoles,tapeCircles);\n    \n    p.x = abs(p.x);\n    p.x -= 0.8;\n    float tapeGear = sdTapeGear((p+vec3(0.0, -0.15,0.0))*matRotateX(radians(90.0))*matRotateY(radians(90.0)*iTime*0.5), vec2(0.1,0.1));\n    p = pref;\n    \n    p.x += fbm(p*1.8)*1.2;\n    p.y += fbm(p*1.2)*1.3;\n    p.z += fbm(p*2.0)*1.1;\n   \tfloat fragileParts0 = (sdBox(p+vec3(1.8,0.8,-0.2),vec3(0.1,0.2,0.5),0.0)-1.0);\n    p = pref;\n    \n    p.x += fbm(p*1.8)*1.2;\n    p.y += fbm(p*1.2)*1.3;\n    p.z += fbm(p*2.0)*1.1;\n   \tfloat fragileParts1 = (sdBox(p+vec3(-3.2,-1.7,-0.2),vec3(0.3,0.6,0.5),0.0)-1.0);\n    p = pref;\n    \n    float f = p.y+1.3;\n    \n    float resB = max(-centerHoles,max(-centerRectHole, max(-holes,min(max(-b4,max(-b1,b0)),max(-b2,b3)))));\n    vec4 res = vec4(vec3(1.0,1.0,1.0),min(f,max(-fragileParts1,max(-fragileParts0,min(min(resB,tape),tapeGear)))));\n    \n    return res;\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 3.5*cos(0.1*time + 6.0), 0.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.0, -0.4, -0.7 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float zoom = 1.5;\n    vec3 rd = ca * normalize( vec3(p.xy,zoom) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 60.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.6, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.6,0.6,0.6)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    fragColor = vec4(dst, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 744, 770, 770, 1175], [1177, 1177, 1198, 1198, 1339], [1341, 1341, 1381, 1381, 1479], [1481, 1481, 1533, 1533, 1640], [1642, 1642, 1678, 1678, 1765], [1767, 1767, 1803, 1803, 2361], [2363, 2363, 2399, 2399, 2474], [2476, 2476, 2493, 2493, 4606], [4608, 4608, 4631, 4631, 4908], [4910, 4910, 4944, 4944, 5254], [5256, 5287, 5327, 5327, 5623], [5625, 5625, 5677, 5677, 5866], [5868, 5868, 5924, 5924, 7633]]}
{"id": "WlSXRz", "name": "Simple RayTracing", "author": "Nocks_on", "description": "test of raytracing\n", "tags": ["raytracing"], "likes": 2, "viewed": 70, "published": "Public", "date": "1564731087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INF 10000.\n#define PI 3.141592\n\nvec3 cameraPos = vec3(0., 0., 10.);\nvec3 lightDir = normalize(vec3(1., 1., 1.));\nfloat eps = 0.001;\n\nvec3[2] sphere_center = vec3[](\n\tvec3(-0.5, 0., 0.),\n    vec3(0.5, 0., 0.)\n);\nfloat[2] sphere_radius = float[](\n    0.5,\n    0.5\n);\nvec3[1] box_center = vec3[](\n\tvec3(0., 0., 0.)\n);\nvec3[1] box_size = vec3[](\n\tvec3(0.5, 0.5, 0.5)\n);\n\nmat3 rotateMatX(float angle) {\n\treturn mat3(\n        1, 0, 0, \n        0, cos(angle), -sin(angle),\n        0, sin(angle), cos(angle)\n    );\n}\n\nmat3 rotateMatY(float angle) {\n\treturn mat3(\n        cos(angle), 0, -sin(angle),\n        0, 1, 0,\n        sin(angle), 0, cos(angle)\n    );\n}\n\nmat3 rotateMatZ(float angle) {\n\treturn mat3(\n        cos(angle), -sin(angle), 0,\n        sin(angle), cos(angle), 0,\n        0, 0, 1\n    );\n}\n\n\nfloat distSphere(vec3 r, vec3 center, float radius) {\n\treturn length(r-center) - radius;\n}\n\nfloat distBox(vec3 r, vec3 center, vec3 size) {\n\treturn length(max(abs(r - center) - size, 0.0));\n}\n\nfloat distFunc(vec3 r) {\n    float min_dist = INF;\n    for (int i = 0; i < 1; i++) {\n    \tfloat dist = distBox(r, box_center[i], box_size[i]);\n        if (dist < min_dist) {\n        \tmin_dist = dist;\n        }\n    }\n    return min_dist;\n}\n\nvec3 normalFunc(vec3 r) { //get Normal vector\n\treturn normalize(vec3(\n    \tdistFunc(r) - distFunc(vec3(r.x+eps, r.y, r.z)),\n        distFunc(r) - distFunc(vec3(r.x, r.y+eps, r.z)),\n        distFunc(r) - distFunc(vec3(r.x+eps, r.y, r.z+eps))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    vec3 col;\n    \n    vec3 ray = normalize(vec3(uv, 0.) - cameraPos);\n    vec3 cur = cameraPos;\n    \n    float t = iTime;\n    float angle1 = t*2.*PI/5.0;\n    float angle2 = t*2.*PI/7.5;\n    lightDir = normalize(vec3(sin(angle1), 0.5*sin(angle2), cos(angle1)));\n    \n    for (int i = 0; i < 16; i++) {\n        vec3 transformed = rotateMatZ(angle2) * rotateMatY(angle2) * rotateMatX(angle2) * cur;\n    \tfloat dist = distFunc(transformed);\n        if (dist < eps) {\n        \tvec3 normal = normalFunc(transformed);\n            float diff = dot(normal, lightDir);\n            col = vec3(clamp(diff, 0.05, 0.95));\n            break;\n        }\n        cur += ray * dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 375, 405, 405, 516], [518, 518, 548, 548, 658], [660, 660, 690, 690, 800], [803, 803, 856, 856, 893], [895, 895, 942, 942, 994], [996, 996, 1020, 1020, 1234], [1236, 1236, 1261, 1281, 1486], [1488, 1488, 1545, 1595, 2418]]}
{"id": "wlSXW3", "name": "Point Cube ray f + plane test", "author": "MODer", "description": "да, тупо для тестов ага", "tags": ["dbdbdrb"], "likes": 3, "viewed": 249, "published": "Public API", "date": "1567258714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tex iChannel0\n#define pixe iResolution.xy\n#define t iTime\nvec3 m(vec3 p, float r){return vec3(p.x,cos(r)*p.y+sin(r)*p.z,cos(r)*p.z-sin(r)*p.y);}\nvec3 mx(vec3 p, float x){return m(p.xzy, x).xzy;}\nvec3 my(vec3 p, float y){return m(p.yxz, y).yxz;}\nvec3 mz(vec3 p, float z){return m(p.zyx, z).zyx;}\nvec3 mxyz(vec3 p, vec3 r){return mx(my(mz(p,r.z),r.y),r.x);}\n\nfloat rep(float f){if(f > 0.){if(f < 1.){return 1.;}}return 0.;}\nfloat point(vec2 uv, vec2 p, float s){return smoothstep(s, s-0.001, distance(uv,p)*4.);}\nfloat ray(vec2 uv, vec3 pos, vec3 r, vec3 f, float s){\n    pos += mxyz(f,r);\n    pos.z += 1.;\n    pos.xy /= pos.z;\n    pos.z = 1./pos.z;\n    pos.z *= 0.06125*s;\n    return point(uv, pos.xy,pos.z);}\nfloat cub(vec3 pos, vec2 uv, vec3 r, float s){\n    float col;\n    vec3 f;\n    for(int d = 0; d < 2; d ++){\n        for(int g = 0; g < 4; g ++){\n            f = my(vec3(0.5,0.25,0)*s, float(g)*3.14/2. );\n            f = mz(f, float(d)*3.14 );\n            col += ray(uv, pos, r, f, s);\n        }\n    }\n    return col;\n}\n\nvec3 plane(vec3 cor, vec3 r, vec2 fog){\n    #define add vec2(0.5);\n    cor.z = 0.;\n    \n    \n    \n    cor.xy -=add;\n    cor /= 0.5;\n    \n    cor.xy /= mxyz(vec3(1,1,0), vec3(r.xy,0)).xy;\n    cor.z   = mxyz(cor,         vec3(r.xy,0)).z ;\n    cor     =   mz(cor,                 -r.z)   ;\n    /*\n    ///////MATH_PROECTED__FOOOR\n    cor.xy +=add;\n    cor.xyz = mxyz(cor-vec3(0,0,1), vec3(fog.xy, 0) );\n    cor.xy -=add;\n    cor.xy /= cor.z;\n    */\n    cor.xy /= cor.z-1.;\n    \n    cor.xy +=add;\n    return cor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    float col;\n    vec3 pos;\n    vec3 r;\n    vec3 f;\n    float s;\n    vec2 fog;\n    \n    \n    \n    fog = ( (fragCoord.xy-vec2(pixe.x/2.,0) )/pixe.y-vec2(0,0.5) ).yx/180.*3.14/4.;\n    \n    fog.x *= 45.;\n    fog.y *= 45.;\n    \n    \n    \n    {\n    s = 1.;\n    uv = fragCoord.xy/iResolution.y; \n    uv.x -= iResolution.x/iResolution.y/4.;\n    uv -= 0.5;\n    r.y += iTime*2.5;\n    //r.z += iTime*1.425;  \n    //pos.x += sin(iTime);\n    \n    col += cub(pos,uv, r, s);\n    col += cub(mxyz(pos+vec3(0,0.5,0), r),uv, r, s*0.5);\n    col += cub(mxyz(pos+vec3(0.5,0,0), r+vec3(0,0.5,0)*3.14/2.),uv, r, s*0.25);\n    }//point V.\n    \n    {\n    //uv = fragCoord.xy/iResolution.xy;\n    uv *= 0.5;\n    uv.xy += 0.5;\n    pos.z = 1.;\n    r.y = iTime*2.5;\n    pos = plane(vec3(uv,0)+pos, r, fog);\n    col += texture(iChannel0, pos.xy).x*rep(pos.x)*rep(pos.y);\n    }\n    \n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 90, 90, 152], [153, 153, 178, 178, 202], [203, 203, 228, 228, 252], [253, 253, 278, 278, 302], [303, 303, 329, 329, 363], [365, 365, 384, 384, 429], [430, 430, 468, 468, 518], [519, 519, 573, 573, 716], [717, 717, 763, 763, 1034], [1036, 1036, 1075, 1075, 1545], [1547, 1547, 1604, 1604, 2502]]}
{"id": "wlSXWc", "name": "Inverted entanglement", "author": "avin", "description": "visual experiment", "tags": ["noise", "simplex", "visual"], "likes": 8, "viewed": 413, "published": "Public API", "date": "1567283095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;       \n    \n    float cc = 1.;\n    for(float i = 1.; i<2.0; i+=0.1){\n        vec2 iuv = uv*i*.5;\n        float s = simplex_noise(vec3(iuv*10.*i, iTime*.25 + i*10.));        \n        s += iTime*.25 + i;  \n        s = fract(s);\n        cc = min(cc, (s > .0  && s < i*.05) ? 1. - i*.945 : 1.0);                \n    }    \n    \n    fragColor = vec4(fract(cc));    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 62, 62, 214], [216, 216, 245, 245, 909], [911, 911, 968, 968, 1395]]}
{"id": "wlSXWD", "name": "Hello Random", "author": "2YY", "description": "My first random value playing.", "tags": ["random"], "likes": 2, "viewed": 258, "published": "Public", "date": "1565872200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n */\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/**\n * https://qiita.com/7CIT/items/5113587c82fc544c0a58\n */\nfloat heart(vec2 p){\n return pow(p.x*p.x+p.y*p.y-1.,3.)-p.x*p.x*p.y*p.y*p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n\n    float gridLength;\n    vec2 gridCoord;\n    if(uv.x > 1.) {\n        gridLength = 1. + iTime * .2;\n    \tgridCoord = floor(uv * gridLength + iTime * 2. * sin(iTime));\n    } else {\n        gridLength = 100. - (tan(iTime *3.));\n    \tgridCoord = floor(uv * gridLength - iTime * 1. + tan(iTime * 8.));\n    }\n    \n    vec2 gridFrag = fract(uv * gridLength);\n\n    vec3 color = vec3(random(gridCoord));\n    \n    if(fract(gridCoord.y / 2.) == 0.) {\n    \tif(color.x > .4 && gridFrag.x > color.x / 4.) {\n            color = vec3(.0);\n        }\n    } else {\n    \tif(color.x > .4 && gridFrag.y > color.x / 4.) {\n            color = vec3(.0);\n        }\n    }\n    \n    color.r = .0;\n    color.g = .0;\n    \n    if(color.b > .5 + (.2 * .5 + .9) * 1. * ((1. - abs(uv.x * 2. - 1.)) / ((sin((iTime - 3.5) / 2.) * .5 + .5) * 10.))) {\n    \tcolor.r += (4. * .3 + .8) * 1. * (1. - uv.y);\n    }\n    \n    color.r += fract(uv.x) * .2;\n    \n    // heart\n    float l = 1.-step(0.,heart(vec2(uv.x - .5, uv.y - .25) * (5. - (tan(iTime * 3.) * .5 + .5))));\n    //color *= vec3(l) * sin(iTime) - .3;\n    color *= vec3(l) - .3;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSXWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 109, 109, 181], [183, 244, 264, 264, 322], [324, 324, 381, 381, 1596]]}
{"id": "WlSXWK", "name": "Kaleido noise", "author": "josplode", "description": "idk", "tags": ["idk"], "likes": 1, "viewed": 250, "published": "Public API", "date": "1567039025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    p.x = sin(p.x);\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat n(vec2 p, float s) {\n    float o = s / iResolution.x;\n    return (noise(p + vec2(o, 0.)) + noise(p + vec2(0., o)) + noise(p + vec2(-o, 0.)) + noise(p + vec2(0., -o))) / 4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = (fragCoord.xy / iResolution.xy - vec2(0.5)) * 0.25;\n    float l = length(c);\n    float s = pow(0.5, 1. / iTime) * 0.5;\n    float t = atan(c.y, c.x);\n    vec2 p = vec2(t, pow(2., l * 10.) / s + iTime);\n    float e = 1. - smoothstep(s - .01, s, l);\n    \n    fragColor = vec4(n(p * 8., l * 100000.) * e);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [89, 89, 109, 109, 338], [340, 340, 366, 366, 520], [522, 522, 579, 579, 896]]}
{"id": "WlSXWw", "name": "LiveCodingPractice002(45min)", "author": "Hirai_worthless", "description": "ray.z magic", "tags": ["raymarching"], "likes": 2, "viewed": 124, "published": "Public", "date": "1565974986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\nvec3 modc(vec3 p,vec3 b){\n\tp = (fract(p / b + 0.5)-0.5) * b;\n    return p;\n}\nvec2 pmod(vec2 p,float c){\n\tp *= genRot(PI/c);\n    float at = atan(p.y/p.x);\n    at = mod(at,PI * 2./c);\n    float r = length(p);\n    p = vec2(cos(at) * r,sin(at) * r);\n    p *= genRot(-PI/c);\n    return p;\n}\n\nfloat map(vec3 p){\n    p.xy *= genRot(-iTime);\n    p = modc(p,vec3(4.));\n    p.xy *= genRot(iTime * 2.);\n    p.xy = pmod(p.xy,8.);\n\tfloat sp = length(p - vec3(1.0,0.,0.)) - 0.5;\n    float pil = length(p.xy - vec2(2.0,0.)) - 0.1; \n    return min(sp,pil);\n}\n\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 128; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n    }\n    vec3 n = getNormal(o + r * t);\n    vec4 result = vec4(n,t);\n    return result;\n\n}\n\nvec3 ray(vec2 uv,float a){\n\tvec3 r = normalize(vec3(uv,a));\n    return r;\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-2.5 + iTime);\n    return c;\n}\n\nvec3 getColor(vec3 o,vec3 r,vec4 data){\n\tfloat t = data.w;\n    vec3 n = data.xyz;\n    float fog = 1./(1. + t * t * 0.025);\n    vec3 bc = vec3(1. - dot(r,n));\n    float at = atan(r.y/r.x) * 2.;\n    vec3 colA;\n    colA.r = cos(at +iTime);\n\tcolA.g = cos(at +iTime + PI * 2. / 3.);\n    colA.b = cos(at +iTime + PI * 4. / 3.);\n\tbc *= colA * 0.5 + 0.5;\n    return mix(bc,vec3(0.),1. - fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.x;\n    vec3 o = cam();\n    vec3 r = ray(uv,sin(iTime/2.) * 1.5);\n    vec4 data = trace(o,r);\n    vec3 col = getColor(o,r,data);\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 100], [101, 101, 126, 126, 177], [178, 178, 204, 204, 386], [388, 388, 406, 406, 643], [645, 645, 668, 668, 745], [747, 747, 773, 773, 989], [991, 991, 1017, 1017, 1066], [1068, 1068, 1079, 1079, 1131], [1133, 1133, 1172, 1172, 1519], [1521, 1521, 1578, 1578, 1800]]}
{"id": "Wt2SRm", "name": "Fluffy Forest", "author": "toomuchvoltage", "description": "Since everyone is into SDFs, I thought I'd try something different: defining worlds using density fields only. This is very useful if you have fluff/fur/etc. Vanilla sphere marching doesn't lend itself well to such things though this naturally costs more.", "tags": ["scattering", "trace", "fields", "density", "scalar", "extinction"], "likes": 13, "viewed": 426, "published": "Public API", "date": "1565686765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/***********************************************************\n\n   A world entirely made out of a density field!\n   The whole thing is one giant fluffy scattering cloud-type thing! :)\n\n   Trees are fractal trees made with splitting stem cells...\n\n   The grass is something I invented called melon grass!\n   It's four ellipsoids each contributing a thin slice to make a grass patch.\n   Three versions of the patch are repeated indefinitely across the plains.\n   Each patch orientates at its origin against the sinusoidal height field.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n#define CORE_RADIUS 0.1\n#define FLUFF_RADIUS 1.2\n#define FLUFF_POWER 0.1 * min (1.0 - max (sin(iTime), 0.0), 0.9)\n#define DRAW_DISTANCE 15.0\n\n// Blue noise...\nfloat _2dNoise (vec2 forPos)\n{\n\tfloat noiseVal = texture (iChannel0, forPos).r;\n    return 0.9 + noiseVal * 0.1;\n}\n\n/******************* FRACTAL TREES USING SPLITTING STEMS **********************/\nfloat circle(vec2 uv, vec2 center, float rad, float fluffRad)\n{\n    vec2 diffVec = uv - center;\n    float distSq = dot(diffVec, diffVec);\n    float rSq = rad * rad;\n    float rTSq = rad + fluffRad;\n    rTSq *= rTSq;\n    if ( distSq < rSq )\n        return 1.0;\n    else if ( distSq < rTSq )\n        return clamp (1.0 - pow((distSq - rSq)/(fluffRad * fluffRad), FLUFF_POWER), 0.0, 1.0);\n    else\n        return 0.0;\n}\n\nfloat splitCell(vec2 uv, float inpTime, float spread)\n{\n    if ( inpTime < 0.0 || inpTime > M_PI ) return 0.0;\n    float timeProg = clamp(inpTime, 0.0, M_PI * 0.5);\n    float timeProg2 = clamp(inpTime - M_PI * 0.5, 0.0, M_PI * 0.5);\n    float sinTimeProg = sin(timeProg);\n    float sinTimeProg2 = sin(timeProg2);\n    float res1 = max(circle(uv, vec2 (sinTimeProg2, sinTimeProg) * spread, CORE_RADIUS, FLUFF_RADIUS), circle (uv, vec2 (sinTimeProg2, -sinTimeProg) * spread, CORE_RADIUS, FLUFF_RADIUS));\n    float res2 = max(circle(uv, vec2 (-sinTimeProg2, sinTimeProg) * spread, CORE_RADIUS, FLUFF_RADIUS), circle (uv, vec2 (-sinTimeProg2, -sinTimeProg) * spread, CORE_RADIUS, FLUFF_RADIUS));\n    return max (res1, res2);\n}\n\nfloat splitCell2(vec2 uv, float inpTime, float spread)\n{\n    if ( inpTime < M_PI )\n        return splitCell (uv, inpTime, spread);\n    else if ( inpTime < M_PI * 2.0 )\n    {\n        float res1 = splitCell (uv + vec2 ( spread,  spread), inpTime - M_PI, spread * 0.5);\n        float res2 = splitCell (uv + vec2 ( spread, -spread), inpTime - M_PI, spread * 0.5);\n        float res3 = splitCell (uv + vec2 (-spread,  spread), inpTime - M_PI, spread * 0.5);\n        float res4 = splitCell (uv + vec2 (-spread, -spread), inpTime - M_PI, spread * 0.5);\n        return max (max (res1, res2), max (res3, res4));\n    }\n    else if ( inpTime < M_PI * 3.0 )\n    {\n        float curMaxRes = 0.0;\n        for (int i = 0; i != 4; i++)\n        {\n            vec2 subOffset = vec2 (spread);\n            if ( i == 1 ) subOffset *= vec2 (1.0, -1.0);\n            else if ( i == 2 ) subOffset *= vec2 (-1.0, 1.0);\n            else if ( i == 3 ) subOffset *= vec2 (-1.0, -1.0);\n            float res1 = splitCell (uv + vec2 ( spread,  spread) + subOffset * 0.5, inpTime - M_PI * 2.0, spread * 0.25);\n            float res2 = splitCell (uv + vec2 ( spread, -spread) + subOffset * 0.5, inpTime - M_PI * 2.0, spread * 0.25);\n            float res3 = splitCell (uv + vec2 (-spread,  spread) + subOffset * 0.5, inpTime - M_PI * 2.0, spread * 0.25);\n            float res4 = splitCell (uv + vec2 (-spread, -spread) + subOffset * 0.5, inpTime - M_PI * 2.0, spread * 0.25);\n\t        curMaxRes = max (max (max (res1, res2), max (res3, res4)), curMaxRes);\n        }\n        return curMaxRes;\n    }\n    else\n        return 0.0;\n}\n\nfloat fractalTree (vec3 inpCoord)\n{\n    if ( inpCoord.y > M_PI * 3.0 ) return 0.0;\n    else if ( inpCoord.y > 0.0 && inpCoord.y < M_PI * 3.0 ) return splitCell2 (inpCoord.xz, inpCoord.y, 4.0);\n    else if ( inpCoord.y < 0.0) return circle (inpCoord.xz, vec2 (0.0), CORE_RADIUS, FLUFF_RADIUS);\n}\n/******************************************************************************/\n\n// 2D rotate\nmat2 rot2D (float ang)\n{\n    return mat2 (cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\n/******************* THE FLOOR HEIGHT FIELD **********************/\nfloat floorEq (vec2 inpCoord)\n{\n    return (sin(inpCoord.x) + 1.0) * 0.5 + (sin(inpCoord.y) + 1.0) * 0.5;\n}\n/*****************************************************************/\n\n/********************* MELON GRASS!!! **********************/\n// I call this melon grass... :)\n// It's grass made from 4 stripes on 4 melon-like shapes next to each other\nfloat melonGrass (vec3 inpCoord)\n{\n    inpCoord.y /= 3.0;\n    if ( inpCoord.y < -2.0 || inpCoord.y > -1.0 ) return 0.0;\n\tvec3 coordFract = fract (inpCoord) * 2.4 - 1.2;\n\n    // Orientate the grass patch against the height field...\n    vec3 centerOnFloor = floor (inpCoord) + 0.5;\n    vec3 tanVec = vec3 (0.02, floorEq(centerOnFloor.xz + vec2 (0.01, 0.0)) - floorEq(centerOnFloor.xz - vec2 (0.01, 0.0)), 0.0);\n    vec3 biTanVec = vec3 (0.0, floorEq(centerOnFloor.xz + vec2 (0.0, 0.01)) - floorEq(centerOnFloor.xz - vec2 (0.0, 0.01)), 0.02);\n    vec3 norm = normalize (cross (tanVec, biTanVec));\n    if ( norm.y < 0.0 ) norm = -norm;\n    biTanVec = normalize (cross (norm, tanVec));\n    tanVec = cross (biTanVec, norm);\n    mat3 grassPatchSpace;\n    grassPatchSpace[0] = tanVec;\n    grassPatchSpace[1] = norm;\n    grassPatchSpace[2] = biTanVec;\n    \n    // Bring sample point into local grass patch space...\n    coordFract = inverse (grassPatchSpace) * coordFract;\n\n    if ( coordFract.y < 0.0 ) return 0.0; // Cut below the melon\n    \n    vec3 toMelon1 = coordFract - vec3 ( 1.0, 0.0,  0.0);\n    vec3 toMelon2 = coordFract - vec3 (-1.0, 0.0,  0.0);\n    vec3 toMelon3 = coordFract - vec3 ( 0.0, 0.0,  1.0);\n    vec3 toMelon4 = coordFract - vec3 ( 0.0, 0.0, -1.0);\n\n    float result1 = 0.0, result2 = 0.0, result3 = 0.0, result4 = 0.0;\n    if ( normalize (toMelon1.xz).x < -0.99 ) result1 = 1.0 - pow((min (abs(dot (toMelon1,toMelon1) - 1.0), 3.0) / 3.0), FLUFF_POWER * 0.1);\n    if ( normalize (toMelon2.xz).x >  0.99 ) result2 = 1.0 - pow((min (abs(dot (toMelon2,toMelon2) - 1.0), 3.0) / 3.0), FLUFF_POWER * 0.1);\n    if ( normalize (toMelon3.xz).y < -0.99 ) result3 = 1.0 - pow((min (abs(dot (toMelon3,toMelon3) - 1.0), 3.0) / 3.0), FLUFF_POWER * 0.1);\n    if ( normalize (toMelon4.xz).y >  0.99 ) result4 = 1.0 - pow((min (abs(dot (toMelon4,toMelon4) - 1.0), 3.0) / 3.0), FLUFF_POWER * 0.1);\n    return max (max (result1, result2), max (result3, result4));\n}\n/***********************************************************/\n\n/*************** THE ENTIRE WORLD COMBINED ***************/\nfloat worldDensity (vec3 inpCoord)\n{\n    if ( inpCoord.y < -6.0 + floorEq (inpCoord.xz) ) return 1.0;\n    \n    mat2 rot1 = rot2D (M_PI *  0.2);\n    mat2 rot2 = rot2D (M_PI * -0.1);\n    mat2 rot3 = rot2D (M_PI *  0.35);\n\n    vec3 treeCoord = inpCoord;\n    treeCoord.xz = rot1 * (fract (inpCoord.xz / 5.0) * 20.0 - 10.0);\n    float worldDensity = 0.0;\n    worldDensity = max (fractalTree (treeCoord), worldDensity);\n    \n    vec3 grassCoord1 = inpCoord, grassCoord2 = inpCoord, grassCoord3 = inpCoord;\n    grassCoord1.xz = rot2 * inpCoord.xz + vec2 ( 0.2, 0.3);\n    grassCoord2.xz = rot1 * inpCoord.xz + vec2 (-0.1, 0.45);\n    grassCoord3.xz = rot3 * inpCoord.xz + vec2 (0.35, 0.12);\n    \n    worldDensity = max (melonGrass (grassCoord1), worldDensity);\n    worldDensity = max (melonGrass (grassCoord2), worldDensity);\n    worldDensity = max (melonGrass (grassCoord3), worldDensity);\n    return worldDensity;\n}\n/*********************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    \n    vec3 curEye = vec3 (0.0, 1.0, -5.0) + vec3 (iTime, 0.0, iTime);\n    vec3 sampleDir = normalize (vec3 (uv, 1.0)) * 0.01 * _2dNoise (uv);\n    vec3 samplePt = curEye + sampleDir;\n    float scat = 1.0;\n    float finalColor = 0.0;\n\n    for (;;)\n    {\n        float fader = max (DRAW_DISTANCE - length (samplePt - curEye), 0.0)/ DRAW_DISTANCE;\n        float densityEval = worldDensity (samplePt);\n        if ( densityEval > 0.001 )\n        {\n\t        finalColor += scat * densityEval * fader;\n            scat *= exp (-densityEval);\n        }\n        if ( scat < 0.1 ) break;\n        if ( fader == 0.0 ) break;\n        samplePt += sampleDir;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3 (finalColor),1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2SRm.jpg", "access": "shaders20k", "license": "mit", "functions": [[2147, 2164, 2194, 2194, 2278], [2280, 2361, 2424, 2424, 2776], [2778, 2778, 2833, 2833, 3499], [3501, 3501, 3557, 3557, 5097], [5099, 5099, 5134, 5134, 5393], [5476, 5489, 5513, 5513, 5574], [5576, 5644, 5675, 5675, 5751], [5821, 5992, 6026, 6026, 7951], [8015, 8075, 8111, 8111, 8983], [8984, 9045, 9102, 9102, 9877]]}
{"id": "Wt2SRw", "name": "CircleWaver001", "author": "Hirai_worthless", "description": "w", "tags": ["raymarching"], "likes": 2, "viewed": 69, "published": "Public", "date": "1565389031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n    p.xy *= genRot(floor(p.z/4. + .5) * -PI / 16.);\n    p = pmod(p,8.);\n    p.x -= 4.;\n    p.y -= 1.;\n    p.xy *= genRot(-PI / 8.);\n    p.z += 2.;\n    p.z = fract(p.z / 4.) * 4.;\n    p.z -= 2.;\n    p.xy += 3.;\n    p.xy = fract(p.xy / 6.) * 6.;\n    p.xy -= 3.;\n    float theta = 0.;\n    float a = 0.2;\n\tfloat begin = sin(iTime * 2. * (0.2 + rand(theta)) + theta) * a;\n    float prev = begin;\n    float curr = 0.;\n    float r = 1.5 + 0.2 * cos(iTime);\n    \n    float res = sphere(p,vec3(r * sin(theta),begin,r * cos(theta)),0.15);\n    for(int i = 1; i < 12; i ++){\n    \ttheta += PI / 6.0;\n        curr = sin(iTime * 2. * (0.2 + rand(theta)) + theta) * a;\n        res = min(res,sphere(p,vec3(r * sin(theta),curr,r * cos(theta)),0.15));\n        res = min(res,line(p,\n                          vec3(r * sin(theta),curr,r * cos(theta)),\n                          vec3(r * sin(theta - PI / 6.0),prev,r * cos(theta - PI / 6.0)),\n                          0.015));\n        prev = curr;\n    }\n    theta += PI / 6.0;\n    curr = sin(iTime * 2. * (0.2 + rand(0.)) + 0.) * a;\n    res = min(res,line(p,\n                      vec3(r * sin(theta),curr,r * cos(theta)),\n                      vec3(r * sin(theta - PI / 6.0),prev,r * cos(theta - PI / 6.0)),\n                      0.025));\n    return res;\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(0,0,-5.5 + iTime);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.xy *= genRot(iTime * PI / 8.);\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.75;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.025);\n    float a = dot(data.xyz,r);\n    vec3 fc = mix(vec3(0.95),vec3(1. + a),fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2SRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 354, 354, 537], [540, 554, 590, 590, 619], [621, 621, 659, 659, 688], [690, 690, 723, 723, 870], [872, 872, 915, 915, 1071], [1074, 1091, 1109, 1109, 2396], [2398, 2416, 2440, 2440, 2692], [2694, 2714, 2735, 2735, 2769], [2771, 2785, 2812, 2812, 2904], [2906, 2921, 2949, 2949, 3149], [3151, 3166, 3198, 3198, 3421], [3423, 3434, 3491, 3508, 3858]]}
{"id": "Wt2SWh", "name": "warlokkz - sunset/sunrise", "author": "warlokkz", "description": "first sunset/sunrise", "tags": ["pixelspirit"], "likes": 1, "viewed": 59, "published": "Public", "date": "1565756706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat plot(vec2 uv, float pct) {\n\treturn smoothstep(pct - 0.01, pct, uv.y) -\n           smoothstep(pct, pct + 0.01, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 yellow = vec3(0.149,0.141,0.912);\n\tvec3 blue = vec3(1.000,0.833,0.224);\n    \n    float curve = sin(uv.x + iTime);\n    vec3 pct = vec3(curve);\n        \n    vec3 col = mix(yellow, blue, pct);\n    \n    // plot our curve\n    // col = mix(col, vec3(0.), plot(uv, curve));\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2SWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 67, 67, 159], [161, 161, 218, 218, 581]]}
{"id": "wt2SWK", "name": "LiveCodingPractice009(40min)", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 5, "viewed": 100, "published": "Public", "date": "1567163775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\n\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\n\nfloat stime(){\n\tfloat a = floor(iTime);\n\tfloat b = smoothstep(0.,1.,fract(iTime));\n\treturn a + b;\n}\n\nfloat map(vec3 p){\n\t//p = (fract(p / 2. + 0.5) - 0.5) * 2.;\n\tp.xz *= genRot(stime() * PI/1.5);\n\tp.xy *= genRot(stime() * PI/1.5);\n\tp = (fract(p / 2. + 0.5) - 0.5) * 2.;\n\tvec3 q = abs(p);\n\tfloat c = max(q.x,max(q.y,q.z)) - 0.5;\n\tfor(int i = 0; i < 3; i ++){\n\t\tq.xz *= genRot(stime() * PI / 6.);\n\t\tp.yz *= genRot(stime() * PI / 3.);\n\t\tp.xy *= genRot(stime() * PI /4.);\n\t\tq *= 3.0;\n\t\tfloat pole = abs(q.x) - 0.5;\n\t\tpole = min(pole,abs(q.y) - 0.5);\n\t\tpole = min(pole,abs(q.z) - 0.5);\n\t\tc = max(c, -pole);\n\t\tq -= 1.;\n\t\tq = abs(q);\n\t}\n\treturn c;\n}\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n\tvec3 y = dFdy(p);\n\treturn normalize(cross(x,y));\n}\nvec4 trace(vec3 o,vec3 r){\n\tvec4 d;\n\tfloat t = 0.;\n\tfor(int i = 0; i < 256; i++){\n\t\tvec3 p = o + r * t;\n\t\tfloat d = map(p);\n\t\tt += d * 0.1;\n\t}\n\tvec3 p = o + r * t;\n\tvec3 n = getNormal(p);\n\treturn vec4(n,t);\n}\n\nvec3 getColor(vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n\tvec3 n = d.xyz;\n\tfloat a = dot(r,n);\n\tvec3 bc = vec3(1. + a);\n\tvec3 cc;\n\tvec3 p = o + r * t;\n\tcc = sin(p) * 0.5 + 0.5;\n\tbc *= cc;\n\tfloat fog = 1./(1. + t * t * 0.1);\n\treturn vec3(bc * fog);\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-1.5);\n\treturn c;\n}\n\nvec3 ray (vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n\treturn r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = (fragCoord.xy * 2.- iResolution.xy) / iResolution.y;\n\tvec3 o = cam();\n\tvec3 r = ray(uv,1.5);\n\tvec4 d = trace(o,r);\n\tvec3 color = getColor(o,r,d);\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2SWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 45, 45, 91], [93, 93, 107, 107, 192], [194, 194, 212, 253, 735], [736, 736, 759, 759, 830], [831, 831, 857, 857, 1039], [1041, 1041, 1077, 1077, 1286], [1288, 1288, 1299, 1299, 1340], [1342, 1342, 1369, 1369, 1415], [1416, 1416, 1473, 1473, 1667]]}
{"id": "wt2SWR", "name": "oil U-piter", "author": "foran", "description": "oil U-piter", "tags": ["oilupiter"], "likes": 4, "viewed": 157, "published": "Public", "date": "1565627448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    const int octaves = 3;\n    const float seed = 43758.5453123;\n    const float seed2 = 73156.8473192;\n  //-------------\n  \nvec3 hsv2rgb(vec3 c){\n  vec4 K=vec4(1.,2./3.,1./3.,3.);\n  vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);\n  return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);\n}\n/*\nvec3 rgb2hsv(vec3 c){\n  vec4 K=vec4(0.,-1./3.,2./3.,-1.);\n  vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));\n  vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n  float d=q.x-min(q.w,q.y);\n  float e=1.e-10;\n  return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\n*/\n  //----------\n    vec2 random2(vec2 st, float seed){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*seed);\n    }\n  \n    // Value Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/lsf3WH\n    float noise(vec2 st, float seed) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        vec2 u = f*f*(3.0-2.0*f);\n\n        return mix( mix( dot( random2(i + vec2(0.0,0.0), seed ), f - vec2(0.0,0.0) ), \n                         dot( random2(i + vec2(1.0,0.0), seed ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0), seed ), f - vec2(0.0,1.0) ), \n                         dot( random2(i + vec2(1.0,1.0), seed ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n  \n    float fbm1(in vec2 _st, float seed) {\n      float v = 0.0;\n      float a = 0.5;\n      vec2 shift = vec2(100.0);\n      // Rotate to reduce axial bias\n      mat2 rot = mat2(cos(0.5), sin(0.5),\n                      -sin(0.5), cos(0.50));\n      for (int i = 0; i < octaves; ++i) {\n          v += a * noise(_st, seed);\n          _st = rot * _st * 2.0 + shift;\n          a *= 0.4;\n      }\n      return v;\n    }\n  \n    float pattern(vec2 uv, float seed, float time, inout vec2 q, inout vec2 r) {\n\n      q = vec2( fbm1( uv + vec2(0.0,0.0), seed ),\n                     fbm1( uv + vec2(5.2,1.3), seed ) );\n\n      r = vec2( fbm1( uv + 4.0*q + vec2(1.7 - time / 2.,9.2), seed ),\n                     fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8), seed ) );\n\n      vec2 s = vec2( fbm1( uv + 4.0*r + vec2(21.7 - time / 2.,90.2), seed ),\n                     fbm1( uv + 4.0*r + vec2(80.3 - time / 2.,20.8), seed ) );\n\n      vec2 t = vec2( fbm1( uv + 4.0*s + vec2(121.7 - time / 2.,90.2), seed ),\n                     fbm1( uv + 4.0*s + vec2(180.3 - time / 2.,20.8), seed ) );\n\n      float rtn = fbm1( uv + 4.0*t, seed );\n\n     rtn = clamp(rtn, -0.9, .95); \n\n      return rtn;\n    }\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n    {\n      vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n      uv *= 1. + dot(uv, uv)*.3;\n      float time = iTime / 20.;\n      mat2 rot = mat2(cos(time), sin(time),\n                      -sin(time), cos(time));\n      uv = rot * uv;\n      uv *= 1.4 + sin(time) * .3;\n      uv.x -= time;\n      vec2 q = vec2(0.,0.);\n      vec2 r = vec2(0.,0.);\n      vec3 colour = vec3(pattern(uv, seed, time, q, r));\n      colour += vec3( (q.x + q.y), 1., r.x * r.y  );\n      colour += .15;\n       colour.r -= dot(q, r) * 1.;\n       colour.g += r.y;\n       colour = mix(colour, vec3(pattern(uv, seed2, time, q, r), dot(q, r) * 1., 0.), .005);\n       colour -= q.x * 1.5;\n       colour.g += dot(q, r) * 15.;\n       colour = hsv2rgb(colour);\n       fragColor = vec4(abs(colour), 1.);\n      \n     fragColor = vec4(colour + (abs(colour) * .5), 1.);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2SWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 125, 146, 146, 275], [276, 587, 621, 621, 767], [775, 865, 899, 899, 1361], [1369, 1369, 1406, 1406, 1774], [1782, 1782, 1858, 1858, 2536], [2537, 2537, 2595, 2595, 3443]]}
{"id": "wt2Szh", "name": "Ellipse Normals in relation", "author": "TimoKinnunen", "description": "Ellipse normals and tangents, ellipses and their opposites, are all connected by straight edges and parallel lines.", "tags": ["normal", "ellipse", "tangent"], "likes": 2, "viewed": 307, "published": "Public API", "date": "1565093577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ellipse Normals in relation\n// Timo Kinnunen 2019\n//\n// Exploring the relations between normal vectors 90 degrees apart on an ellipse and its opposite.\n//\n// Based on More Accurate Ellipse Normal @ https://www.shadertoy.com/view/3s23zz by scratch13764\n#define H .8\n#define W .5\n\nfloat ifLE(float a, float b, float eps) {\n    //if (a <= b) return 1.; else return 0.;\n    //return float(a <= b);\n    //return float(a - b <= .0);\n    //return float(b - a >= .0);\n    //return step(.0,b - a);\n    return smoothstep(.0,eps,b - a);\n}\nfloat Ellipse (vec2 p, float w, float h)\n{\n    //if (length(vec2(p.x/w,p.y/h)) <= .5) return 1.; else return 0.;\n    //return float(length(vec2(p.x/w,p.y/h)) <= .5);\n    //return float(length(vec2(p.x/w,p.y/h)) - .5 <= .0);\n    //return float(.5 - length(vec2(p.x/w,p.y/h)) >= .0);\n    //return step(.0,.5 - length(vec2(p.x/w,p.y/h)));\n    //return ifLE(length(vec2(p.x/w,p.y/h)),.5,.005);\n    float a = length(vec2(p.x/w,p.y/h));\n    float b = .5;\n    float eps = .005;\n    //return ifLE(a,b,eps);\n    eps *= 450./iResolution.y;\n    return ifLE(a,b+0.5*eps,eps);\n}\nfloat ifLE(float a, float b) {\n    //return ifLE(a,b,0.00000005*b);\n    //return ifLE(a,1.00000005*b,0.00000005*b);\n    //return ifLE(a,1.05*b,0.05*b);\n    //return ifLE(a,1.5*b,0.5*b);\n    //return ifLE(a,1.000000025*b,0.000000050*b);\n    //return ifLE(a,1.025*b,0.050*b);\n    //return ifLE(a,1.25*b,0.50*b);\n    float eps = 0.50*b;\n    eps *= 450./iResolution.y;\n    return ifLE(a,b+0.5*eps,eps);\n}\n\nvec2 EllipsePoint (float t, float w, float h) //Point on an ellipse at a certain angle, stretched circle\n{\n    return vec2(sin(t)*w / 2., cos(t)*h / 2.);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b ) //Line segment SDF made by Inigo Quilez (Thanks!)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\nfloat bump(float x) { return clamp(min(x,4.-x),0.,1.); }\nfloat act(float x, float which, float total) { return bump(mod(x-4.*which,4.*total)); }\nvoid mainImage( out vec4 u, in vec2 o )\n{\n    vec2 p = (o - .5*iResolution.xy)/iResolution.y;\n    vec4 col = vec4(.5);\n    \n    float pw = .2;\n    \n    col = mix (col, vec4(.8), Ellipse (p, W + pw, H + pw));\n    col = mix (col, vec4(.7), Ellipse (p, H, W) * .5);\n    col = mix (col, vec4(1.), Ellipse (p, W, H));\n    col = mix (col, vec4(.7), Ellipse (p, H, W) * .25);\n    \n    //Ellipse Normal Calculations and drawing\n    float t1 = (iTime / 15.) * radians(360.);\n    float t2 = t1 + radians(90.);\n    vec2 j = EllipsePoint (t1, W + pw, H + pw);\n    vec2 k = EllipsePoint (t1, H + pw, W + pw);\n    vec2 l = EllipsePoint (t2, W + pw, H + pw);\n    vec2 a = EllipsePoint (t1, W, H);\n    vec2 b = EllipsePoint (t1, H, W);\n    vec2 c = EllipsePoint (t2, W, H);\n    vec2 d = EllipsePoint (t2, H, W);\n    vec2 nk = normalize(k)*.1;\n    vec2 nl = normalize(l)*.1;\n    vec2 na = normalize(a)*.1;\n    vec2 nb = normalize(b)*.1;\n    vec2 nc = normalize(c)*.1;\n    vec2 nd = normalize(d)*.1;\n    \n    float total = 4.;\n    float ref = iTime/2.;\n    float act1 = 1.-act(ref,3.,total);\n    //float act2 = 1.-act(ref,2.,total);\n    float act3 = 1.-act(ref,1.,total);\n    float act4 = 5.*act(ref,2.,total);\n    \n    col = mix(col, vec4(1,1,0,0), ifLE( sdLine(p, a+(j-a-nl)*act1, a+(j-a+nl)*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,1,0), ifLE( sdLine(p, a+(j-a   )*act1, a+(j-a+nk)*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,1,0), ifLE( sdLine(p, a+(j-a   )*act1, a  ), .005)*.5*act1);//better incorrect normal\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, a*act3   , a+na*act1), .005)*.5*act1);//bad stretched circle normal\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, a-nb*act4, a+nb     ), .005)*.5     );//Correct normal - thanks IQ!\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, a-nc     , a+nc     ), .005)*.5     );\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, a-0.     , a+nd*act1), .005)*.5*act1);\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, b-na*act4, b+na     ), .005)*.5     );\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, b*act3   , b+nb*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, b-0.     , b+nc*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, b-nd     , b+nd     ), .005)*.5     );\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, c-na     , c+na     ), .005)*.5     );\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, c-0.     , c+nb*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, c*act3   , c+nc*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, c-nd*act4, c+nd     ), .005)*.5     );\n    col = mix(col, vec4(1,0,0,0), ifLE( sdLine(p, d-0.     , d+na*act1), .005)*.5*act1);\n    col = mix(col, vec4(0,0,0,0), ifLE( sdLine(p, d-nb     , d+nb     ), .005)*.5     );\n    col = mix(col, vec4(0,1,0,0), ifLE( sdLine(p, d-nc*act4, d+nc     ), .005)*.5     );\n    col = mix(col, vec4(0,0,1,0), ifLE( sdLine(p, d*act3   , d+nd*act1), .005)*.5*act1);\n\n    u = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2Szh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 282, 323, 491, 530], [531, 531, 573, 920, 1096], [1097, 1097, 1127, 1406, 1497], [1499, 1499, 1605, 1605, 1654], [1656, 1656, 1746, 1746, 1856], [1857, 1857, 1878, 1878, 1913], [1914, 1914, 1960, 1960, 2001], [2002, 2002, 2043, 2043, 5013]]}
{"id": "Wt2Szt", "name": "Skeleton Helix", "author": "holtsetio", "description": "Reiterating on the helix distance function. Completely unoptimized.", "tags": ["raymarching", "helix", "neon", "bones"], "likes": 11, "viewed": 148, "published": "Public", "date": "1566823996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Parameters\n#define outerT 2.9\n#define FUZZ 0.75\n#define PHASELENGTH 30.0\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define EPSILON 0.005\n#define KEPLER_MAXITER 2\n#define MAXSTEPS 150\n#define MAXDIST 95.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n\n\nvec3 glow = vec3(0);\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 buildtransform(vec3 point, float off, vec3 trans, bool isNeg) {\n    vec3 zaxis = normalize(point);\n    vec3 xaxis = normalize(vec3(zaxis.z, 0.0, -zaxis.x));\n    if (!isNeg && zaxis.x < 0.0) {\n        xaxis *= -1.0;\n    }\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat4(xaxis.x, yaxis.x, zaxis.x, 0,\n                xaxis.y, yaxis.y, zaxis.y, 0,\n                xaxis.z, yaxis.z, zaxis.z, 0,\n                dot(xaxis,trans),dot(yaxis,trans),dot(zaxis,trans)+off,1);\n}\n\n   \nfloat solveKeplerHalley(float e,float M) {\n    float E =clamp(M+PI,0.00,PI);\n    int i=0;\n    while(i<KEPLER_MAXITER) {\n        float esinE = e*sin(E);\n        float k0mM = (E-esinE)-M;\n        float k1 = (1.0-e*cos(E));\n        E -= (2.0*k0mM*k1)/(2.0*k1*k1-k0mM*(esinE));\n        i++;\n    }\n    return E;\n}\n\nfloat solveKepler(float e, float M) {\n    //http://www.jgiesen.de/kepler/kepler.html\n    if (e >= 1.0) {\n        return solveKeplerHalley(e,M);\n    }\n    float E = (e < 0.8 ? M : PI);\n    float F = E - e*sin(M)-M;\n    int i = 0;\n    while (i < KEPLER_MAXITER) {\n    \tE -= F/(1.0 - e*cos(E));\n        F = E - e*sin(E) - M;\n        i++;\n    }\n\treturn E;\n}\n\nstruct HelixHit {\n\tvec4 p;\n    float strand;\n    float theta;\n    vec4 stepped_p;\n    float stepped_theta;\n};\n\n// Computes the closest point to p on a Helix (R,T) with n strands.\n// The returned struct contains the closest point, the strand and the point Theta on the helix.\nHelixHit ClosestPointHelixStep(vec4 p, float R, float T, float n_helices, float stepsize,float offset,float offsetoffsetlol) {\n    // Nievergelt 2009\n    // doi: 10.1016/j.nima.2008.10.006\n    \n    //Helix: H(Theta) = [R*cos(Theta), R*sin(Theta), T*Theta]\n    //Point: D = (u, v, w) = [r * cos(delta), r * sin(delta), w]\n    HelixHit res;\n    float delta = atan(p.y, p.x);\n    float r = length(p.yx);\n    float kt = ((p.z/T)-delta)/TWOPI;\n    float inv_n_helices = 1.0/n_helices;\n    float n = floor((fract(kt) + 0.5*inv_n_helices)/inv_n_helices -0.5);\n    float s_offset = -(n+0.5)*inv_n_helices*TWOPI;\n    float dktp = delta + round(kt-(n+0.5)*inv_n_helices) * TWOPI; \n    float M = PI + (p.z/T) + s_offset - dktp;\n    float e = (r*R)/(T*T);\n    float E = solveKepler(e,M);\n    float Theta = E - PI + dktp;\n    \n    res.theta = (Theta-s_offset);\n    res.strand=n;\n    res.p = vec4(R*cos(Theta), R*sin(Theta), res.theta*T,1.0);\n        \n    offset *= sign(n-0.5);\n    offset += offsetoffsetlol;\n    Theta = round((Theta-s_offset+offset)/stepsize)*stepsize+s_offset-offset;\n    \n    res.stepped_theta = (Theta-s_offset);\n    res.strand=n;\n    res.stepped_p = vec4(R*cos(Theta), R*sin(Theta), res.stepped_theta*T,1.0);\n    res.stepped_theta += s_offset;\n    \n    \n    return res;\n}\n\nstruct TorusHit {\n  \tvec4 p;\n  \tfloat angle;\n};\n\nTorusHit sdTorus(vec4 pos, float r1)\n{\n  \tTorusHit hit;\n  \thit.angle = atan(pos.y,pos.x);\n  \thit.p = vec4(normalize(pos.xy)*r1,0,1);\n    return hit;\n}\n\nstruct Result {\n\tfloat dist;\n    vec4 n;\n};\n    \n    \n    float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nResult ED(vec4 p) {\n    vec3 col = pal( PHASE, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \n    p = rotationZ(-PHASE*TWOPI*1.0)*p;\n    float T = outerT;\n    HelixHit hit = ClosestPointHelixStep(p,4.0,T,2.0,PI/3.0,2.0*PHASE*TWOPI,-(PHASE*TWOPI)*0.5*2.0);\n    \n    float dh = distance(p,hit.p)-0.25;\n    vec3 nh = normalize(p-hit.p).xyz;\n    \n    //vec3 col = pal( PHASE, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //glow += normalize(col) * pow(max(0.0,(1.0-1.0*dh)),3.0) * 0.05;\n\n    Result res;\n    \n    vec3 lookDir = (vec3(hit.stepped_p.y,-hit.stepped_p.x,-T));\n    mat4 transform = buildtransform(lookDir.xyz,0.0,-hit.stepped_p.xyz,true);\n    TorusHit hit2 = sdTorus(transform*p,1.7);\n    \n    /*mat4 invt = inverse(transform);\n    float dt = distance(p,invt*hit2.p)-0.1;\n    vec3 nt = (invt*normalize(transform*p-hit2.p)).xyz;\n    vec3 colt = pal( mod(PHASE+0.5,1.0), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if (dt < dh) {\n      \tdh = dt;\n      \tnh = nt;\n        //col = pal( mod(PHASE+0.5,1.0), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }*/\n    \n    vec3 lookDir2 = (vec3(hit2.p.y,-hit2.p.x,0));\n    transform = buildtransform(lookDir2.xyz,-hit2.angle*1.7,-hit2.p.xyz,false) * transform;\n    float T2 = 1.7/5.0;\n    HelixHit hit3 = ClosestPointHelixStep(transform*p,0.6,T2,2.0,PI/1.5,-PHASE*TWOPI*5.0,0.0);\n    \n    \n    \n    //glow += normalize(vec3(0.8 + 0.4*sin(2.0*PHASE*TWOPI+0.75*PI),1.0,0.6+0.4*sin(PHASE*TWOPI))) * pow(max(0.0,(1.0-1.0*length(hit3.p - transform*p))),2.0) * 0.031;\n    //glow += normalize(vec3(1.0,1.0,1.0)) * pow(max(0.0,(1.0-0.5*length(hit3.p - transform*p))),1.0) * 0.021;\n    \n    \n    mat4 inv0 = inverse(transform);\n    float d0 = distance(p,inv0*hit3.p)-0.043*2.00;\n    vec4 n0 = inv0*normalize(transform*p-hit3.p);\n    \n    vec3 lookDir3 = (vec3(hit3.stepped_p.y,-hit3.stepped_p.x,-T2));\n    transform = buildtransform(lookDir3.xyz,0.0,-hit3.stepped_p.xyz,true) * transform;\n    TorusHit hit4 = sdTorus(transform*p,0.15+0.05*hit3.strand*0.0+0.05*sin(15.0*PHASE*PI*2.0+hit3.stepped_theta*2.0+1.0*hit3.strand*3.14159));\n    \n    \n    mat4 inv = inverse(transform);\n    res.dist = distance(p,inv*hit4.p)-0.043*1.00;\n    res.n = inv*normalize(transform*p-hit4.p);\n    \n    res.dist = opSmoothUnion(d0,res.dist,0.35);\n    \n    glow += normalize(vec3(1.0,1.0,1.0)) * pow(max(0.0,(1.0-1.0*res.dist)),2.0) * 0.021;\n    \n    res.dist = min(dh,res.dist);\n\n    /*if (d0 < res.dist) {\n    \tres.dist = d0; \n       \tres.n = n0;\n    }*/\n    \n    \n    \n    float glowmult = 1.0;\n    \n    if (res.dist < EPSILON) {\n      if (dh > res.dist) {\n        glowmult = max(0.0,-dot(n0.xyz,nh)) * pow(max(0.0,(1.0-0.3*dh)),2.0) *40.0;\n      } else {\n      \tglowmult = 20.0;  \n      }\n    } else {\n        glowmult = pow(max(0.0,(1.0-0.5*dh)),1.0) * 1.0;\n    }\n    glow += normalize(col)  * 0.01 * glowmult;\n    \n\treturn res;\n}\n\nvec3 raymarch(vec4 orig, vec4 dir) {\n    float dist = 0.0;\n    float minDist = 1e9;\n    int steps = 0;\n    vec4 pos = orig;\n    Result res;\n    res.dist = 1e9;\n    \n    while (dist < MAXDIST && steps < MAXSTEPS && res.dist >= EPSILON) {\n    \tres = ED(pos);\n        minDist = min(minDist,res.dist);\n        \n        dist += FUZZ*res.dist;\n        \n        pos = orig + dist*dir;\n    \tsteps++;\n    }\n    glow = pow(glow,vec3(1.2));\n    return 1.0-glow;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.x * PI * 0.5;\n    \n    vec4 raydir = normalize(vec4(sin(uv.x),1.0,-sin(uv.y),0.0));\n    vec4 rayorig = vec4(15.0,0.0,0.0,1);\n    \n    vec2 rot = (iMouse.xy / iResolution.xy - 0.5) * 2.0 * PI;\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0)\n    \trot = vec2(0,0);\n    rot += vec2(-0.5,-0.5)*PI;\n    \n    mat4 m = rotationY(-rot.x) * rotationX(rot.y) * rotationY(0.5);\n    raydir = m * raydir;\n\n    fragColor = vec4(raymarch(rayorig, raydir),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2Szt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 323, 391, 391, 434], [438, 438, 472, 472, 611], [613, 613, 647, 647, 783], [785, 785, 819, 819, 952], [954, 954, 1022, 1022, 1432], [1438, 1438, 1480, 1480, 1746], [1748, 1748, 1785, 1832, 2101], [2214, 2378, 2504, 2698, 3658], [3709, 3709, 3747, 3747, 3859], [3919, 3919, 3971, 3971, 4070], [4072, 4072, 4091, 4091, 7065], [7067, 7067, 7103, 7103, 7524], [7526, 7526, 7583, 7583, 8081]]}
{"id": "wt2SzW", "name": "flexflex", "author": "lennyjpg", "description": "asdaSD", "tags": ["asdad"], "likes": 3, "viewed": 242, "published": "Public API", "date": "1565271490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv-=iTime * .01 -.5;\n    uv*=10.;\n    float s = random(floor(uv)*1.);    \n    float a = 10.*random(floor(uv)) + sin(iTime * 9.);\n    vec2 u = fract(uv)-.5 + vec2(sin(a),cos(a))*.2;\n    float d = length(u);\n    float k = smoothstep(d,d+.05,s*.3);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2SzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 190, 190, 506]]}
{"id": "Wt2XDm", "name": "Soup balloon surface", "author": "Artleet", "description": "Soup balloon surface test", "tags": ["noise", "perlin", "hueshift"], "likes": 12, "viewed": 320, "published": "Public", "date": "1566543067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Thanks to @FabriceNeyret2 for some thoughtful comments.\nfloat n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy+iTime*.1,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+6.)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\nvoid mainImage(out vec4 o, in vec2 p){\n    float s;\n\tvec2 u=p/iResolution.y;\n    vec3 a=vec3(s=n(u*2.),n(u*6.+8.),n(u*3.+4.))*.6+.6,\n    m=vec3(cos(s*=26.),s=sin(s)*.5774,-s);\n    o.rgb=a*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);    \n}\n/*using @FabriceNeyret2 hints:*/\n/*unfortunately doesn't work on Safari and Edge\n#define mainImage(o,p)\\\n    float s;\\\n\tvec2 u=p/iResolution.y;\\\n    vec3 a=vec3(s=n(u*2.),n(u*6.+8.),n(u*3.+4.))*.6+.6,\\\n\texchange .5774 to .6 will reduce precision... and size of the code :)\n    m=vec3(cos(s*=26.),s=sin(s)*.6,-s);\\ \n    o.rgb=a*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2XDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 74, 74, 394], [395, 395, 433, 433, 622]]}
{"id": "Wt2XR3", "name": "Let there be space", "author": "TheRomanOne", "description": "playing around with sin waves and dot products", "tags": ["sin", "dot"], "likes": 2, "viewed": 79, "published": "Public", "date": "1566635475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 2048.\n#define EPS 0.01\n#define PI 3.141592654\n\nfloat time;\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(center - p) - radius;\n}\n\nmat2x2 rot(float ang)\n{\n    ang *= PI / 180.;\n \treturn mat2x2(cos(ang), sin(ang), -sin(ang), cos(ang));   \n}\n\nfloat terrain(vec3 p)\n{\n    p.z += time;\n    float d = 0.;\n    d += 3.*sin(time+p.z/10.)*cos(time+p.x/10.);\n    d += 7.*sin(p.x*p.z/5500.+time);\n    d += 5.*abs(cos(PI/2. + (p.x+time)/50.));\n    return d;\n}\n\nvec4 map(vec3 p)\n{\n    float h = terrain(p);\n \th *= terrain(p+cos(time+p.z*p.x/50.))/2.;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 rotCenter = vec3(0, 0, 55);\n    \n    float spRotRad = 50.;\n    vec3 spCenter = rotCenter + vec3(\n        10.*sin(5.1235*time) + 50.*sin(time)*cos(time),\n        spRotRad * abs(cos(time)),\n        10.*cos(5.1235*time)\n     );\n\n    float sp = sphere(p, spCenter, 7.5 + 7.5*cos(PI/2. + time));\n\n    \n    float d = p.y + h;\n    vec3 pp = normalize(p - spCenter);\n    \n    if(sp < d)\n    {\n        d = sp;\n        col = vec3(1, .5, .2);\n        col.xy = (rot(time*25.8520) * col.zy)*(h+3.);\n        col.zy = (rot(time*324.753) * col.xz);\n        col.zx = abs(col.zx);\n    }\n    \n    float an = dot(pp, vec3(0, -1, 0)) + .5*sin(time);\n    float rad = .4;\n    if(an > rad)\n    {\n        if(an < rad + .1)\n        {\n            if(an > rad + .09)\n                col = vec3(3.);\n            else col = vec3(0.);\n        }else\n        {\n            col = vec3(.5, 0, 0);\n            col.xy = (rot(time*15.) * col.xy)*(h+.7);\n            col.zy = (rot(time*30.) * col.yx);\n            col.zx = abs(col.zx);\n            col *= vec3(.7, 0.3, .5)*1.2;\n            col *= (an-rad)/rad;\n        }\n    }\n\n    return vec4(col, d);\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n    \n    vec4 d=vec4(0.);\n    float dv;\n    for(int i = 0; i < 250; i++)\n    {\n        vec3 newRay = ro + dv * rd;\n        d = map(newRay);\n        if(d.w < EPS || dv > MAX_DIST)\n            break;\n        dv += d.w * .3;\n    }\n    \n    return vec4(d.xyz, dv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime/3.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 175, -150. + 2.*iMouse.y);\n    /*if(iMouse.w == 1.)\n        ro.xz *= rot(iMouse.x);*/\n    ro.xz *= rot(iMouse.x + time*20.);\n    ro.yz *= rot(90.*sin(time/10.));\n    ro.y = abs(ro.y)+20.;\n    vec3 lookat = vec3(0, 0, 50);\n\n    vec3 fw = normalize(lookat - ro);\n    vec3 ri = normalize(vec3(fw.z, 0, -fw.x));\n    vec3 up  = cross(fw, ri);\n    \n    vec3 rd = mat3x3(ri, up, fw) * vec3(uv, 1);\n    \n    vec4 d = march(ro, rd);\n    \n    vec3 col;\n    if(d.w < MAX_DIST)\n        col = d.xyz * .3;\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2XR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 125, 125, 167], [169, 169, 192, 192, 277], [279, 279, 302, 302, 485], [487, 487, 505, 505, 1735], [1737, 1737, 1767, 1767, 2030], [2032, 2032, 2089, 2089, 2829]]}
{"id": "wt2XW1", "name": "Smooth blendy shape", "author": "cyaoeu", "description": "First shader on Shadertoy (modified from book of shaders example)", "tags": ["blending", "smoothstep", "shape"], "likes": 2, "viewed": 94, "published": "Public", "date": "1565804674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float size = 0.2*abs(sin(0.5*iTime));\n\tfloat size2 = 1.35*abs(sin(1.0*iTime))+size;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Each result will return 1.0 (white) or 0.0 (black).\n    vec2 bl = smoothstep(vec2(size), vec2(size2),st);   // Similar to ( X greater than 0.1 )\n    vec2 tr = smoothstep(vec2(size), vec2(size2), 1.0-st);\n    //float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )\n\n    // The multiplication of left*bottom will be similar to the logical AND.\n    color = vec3( bl.x * bl.y );\n    color *= tr.x * tr.y;\n    color.r = color.r*1000.0-1.0;\n    color.g = color.g*1000.0-1.0;\n    color.b = color.b*1000.0-1.0;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2XW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 153, 153, 873]]}
{"id": "Wt2Xzz", "name": "Bouncing ball", "author": "xigh", "description": "Simple ray marching test ...\n\nyes ...  I'm a big fan of Andromeda Nexus 7 :)", "tags": ["3d", "spheremarching", "bouncingball"], "likes": 2, "viewed": 107, "published": "Public", "date": "1564842658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 eps = vec2(1e-4, 0.);\n\nvec3 rotateZ(vec3 p, float a) \n{\n\treturn vec3(cos(a)*p.xy+sin(a)*vec2(p.y,-p.x), p.z);\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    vec2 u = cos(a)*p.xz+sin(a)*vec2(p.z,-p.x);\n\treturn vec3(u.x, p.y, u.y);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\t\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y, d.z)),0.)+length(max(d,0.));\n}\n\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nvec2 bounce;\n\nfloat map(vec3 p)\n{\n    p -= vec3(bounce, 0.);\n    p = rotateZ(p, iTime);\n    p = rotateY(p, iTime);\n    return \n        max(\n        \tmax(\n            \tmax(\n            \t\t-sdBox(p + vec3(0., -0.3, 0.), vec3(2.0, 0.15, 2.0)),\n        \t\t\t-sdBox(p + vec3(0., +0.3, 0.), vec3(2.0, 0.15, 2.0))\n        \t\t),\n        \t\tmax(\n            \t\t-sdBox(p + vec3(0., -0.9, 0.), vec3(2.0, 0.15, 2.0)),\n        \t\t\t-sdBox(p + vec3(0., +0.9, 0.), vec3(2.0, 0.15, 2.0))\n        \t\t)\n        \t),\n            max(\n        \t\t-sdSphere(p, vec3(0., 0., 0.), 1.4),\n            \tsdSphere(p, vec3(0., 0., 0.), 1.5)\n            )\n    \t);\n}\n\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        map(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n        map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\nconst vec3 light = vec3(1.0, 1.0, -2.0);\n#define rgb(r,g,b) vec3(r,g,b)/256.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*.5) / iResolution.x;\n\n\t// camera    \n    vec3 org = vec3(0., 0., -5.0);  \n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    vec3 col = rgb(55, 15, 18);\n    \n    bounce.x = abs(.5-fract(0.1*iTime))*5.-1.;\n    bounce.y = abs(.5-fract(0.3*iTime))*5.-1.;\n    \n    // sphere tracing\n    float d, r = 0.;\n    for (int i = 0; i < 200; i++) {\n        vec3 p = org + dir * d;\n        r = map(p);\n        if (d > 100.0)\n            break;\n        if (r < eps.x) {\n            vec3 n = normal(p);\n            vec3 pl = light-p;\n        \tfloat diffuse = max(0.0, dot(n, normalize(pl)));\n            // TODO: blinn-phong\n            col = vec3(.8, .6, .7) * diffuse + rgb(207, 163, 21);\n            break;\n        }\n        d += r;\n    }\n    \n    vec3 gamma = vec3(1.0/2.2);\n    fragColor = vec4(pow(col, gamma), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2Xzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 66, 66, 122], [124, 124, 156, 156, 235], [237, 237, 266, 266, 353], [355, 355, 396, 396, 428], [444, 444, 463, 463, 1053], [1055, 1055, 1076, 1076, 1218], [1298, 1298, 1354, 1354, 2195]]}
{"id": "WtBSD1", "name": "Vines at Night", "author": "dr2", "description": "Vine covered pillars (originated from \"Vinescape\")", "tags": ["raymarch", "lighting", "architecture", "plants"], "likes": 13, "viewed": 394, "published": "Public API", "date": "1565706930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Vines at Night\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0 \n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_GLOW 2\n\nvec3 glPos[N_GLOW], ltPos, ltAx;\nvec2 gId;\nfloat tCur, dstFar, hgSize, bRad, bDel, vLev;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, cRad, cLen, hp, br, tw, a, s, r;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId * hgSize);\n  cRad = 0.1;\n  cLen = 1.;\n  tw = 1.;\n  d = dMin;\n  vLev = 0.;\n  for (int k = 0; k < 6; k ++) {\n    tw = - tw;\n    s = float (k + 1) / 6.;\n    hp = tw * (16. - 10. * s) + bRad - 0.5;\n    br = 0.015 - 0.01 * s + 0.005 * (bRad - 0.75);\n    q = p;\n    q.y -= (bDel + 1.3 * s) * hp;\n    a = 2. * pi * q.y / hp;\n    q.xz = Rot2D (q.xz, (5. - 3. * bDel) * pi * (sign (bRad - 0.5) * a +\n       (0.01 * bDel + 0.3 * s) * sin (3. * a)));\n    q.x -= cRad + br;\n    r = length (q.xz) - br;\n    if (r < d) vLev = s;\n    d = SmoothMin (d, r, 0.005);\n  }\n  d = max (d, abs (p.y - cLen) - cLen);\n  DMIN (1);\n  q = p;\n  q.y -= cLen;\n  d = PrCylDf (q.xzy, cRad, cLen);\n  DMIN (2);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 6.));\n  q.y -= 2. * cLen + 0.065 - 0.1 * cos (pi * length (q.xz) / (0.5 * sqrt3 * hgSize));\n  d = PrRoundBox2Df (q.yz, vec2 (0.02, 0.008), 0.01);\n  DMIN (3);\n  q = p;\n  q.y = abs (q.y - cLen) - cLen + 0.03;\n  d = PrCylDf (q.xzy, cRad + 0.05, 0.03);\n  DMIN (3);\n  return 0.7 * dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 fRand;\n  fRand = Hashv2v2 (gId * vec2 (37.3, 43.1) + 27.1);\n  bRad = 0.5 + 0.5 * fRand.x;\n  bDel = fRand.y;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0. || p.y > 3.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 40; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col, mDir, vn;\n  float mRad, bs, ts;\n  mDir = normalize (vec3 (0.6, 0.03, 1.));\n  mRad = 0.025;\n  col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n  bs = dot (rd, mDir);\n  ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - mDir) / mRad);\n      col += vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, 0.4, 0.5), vn) *\n         (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.);\n    }\n  } else col += StarPat (rd, 6.);\n  return col;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 dirGlow;\n  float dstGlow, brGlow;\n  brGlow = 0.;\n  for (int k = 0; k < N_GLOW; k ++) {\n    dirGlow = glPos[k] - ro;\n    dstGlow = length (dirGlow);\n    dirGlow /= dstGlow;\n    if (dstGlow < dstObj) brGlow += 2. * pow (max (dot (rd, dirGlow), 0.), 1024.) / dstGlow;\n  }\n  return clamp (brGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltVec, ltDir, roo, col, vn, q, qh;\n  vec2 vf;\n  float dstObj, atten, a, s, r, sh;\n  bool isBg;\n  isBg = true;\n  vf = vec2 (0.);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    q = ro;\n    q.xz -= HexToPix (gId * hgSize);\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0.5, 0.7, 0.3, 0.3) * (0.4 + 0.6 * vLev);\n      vf = vec2 (32., 2. - vLev);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.6, 0.5, 0.4, 0.1);\n      a = mod (32. * (atan (q.z, - q.x) / (2. * pi)), 1.);\n      vn.xz = Rot2D (vn.xz, -0.3 * sin (pi * a * a));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.5, 0.4, 0.3, 0.1);\n      if (vn.y > 0.99 && length (q.xz) < 0.14) col4 *= 0.6;\n      vf = vec2 (32., 1.);\n    }\n    isBg = false;\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      qh = HexGrid (4. * sqrt3 * ro.xz);\n      r = length (qh.xy);\n      s = max (r - 0.5, 0.);\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 2. * s * s));\n      vn.zx = vn.z * vec2 (qh.x, - qh.y) / r;\n      s = smoothstep (0.03, 0.06, qh.z);\n      col4 = vec4 (0.5, 0.45, 0.45, 0.1) * (0.8 + 0.2 * s);\n      vf = vec2 (32., 1.5 * s);\n      isBg = false;\n    }\n  }\n  if (! isBg) {\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    ltVec = roo - ro;\n    s = length (ltVec);\n    ltDir = ltVec / s;\n    atten = 0.1 + 0.9 * smoothstep (0.8, 0.9, dot (ltAx, - ltDir)) / (1. + 0.05 * pow (s, 1.5));\n    ltVec += ltPos;\n    s = length (ltVec);\n    ltDir = ltVec / s;\n    sh = ObjSShadow (ro, ltDir, s);\n    col = atten * col4.rgb * (0.1 + 1.1 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n  dstObj = min (dstObj, dstFar);\n  if (dstObj / dstFar > 0.6) col = mix (col, SkyCol (rd), smoothstep (0.6, 1., dstObj / dstFar));\n  col = mix (col, vec3 (0.3, 0.8, 1.), GlowCol (roo, rd, dstObj));\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa, p1, p2, vd;\n  float el, az, zmFac, sr, vel, tCyc, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  hgSize = 1.;\n  vel = 0.4;\n  p1 = 0.5 * (TrackPath (vel * tCur + 0.2) + TrackPath (vel * tCur + 0.4));\n  p2 = 0.5 * (TrackPath (vel * tCur - 0.2) + TrackPath (vel * tCur - 0.4));\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2 * (2. * SmoothBump (0.25, 0.75, 0.15, mod (0.07 * vel * tCur, 1.)) - 1.);\n  ro.y = 0.7;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = 0.05 * pi * sin (0.07 * 2. * pi * tCur);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 2.5;\n  dstFar = 25.;\n  ltPos = 0.5 * vuMat * normalize (vec3 (cos (2. * pi * (0.022 * tCur)), 1., 0.));\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  for (int k = 0; k < N_GLOW; k ++) {\n    glPos[k] = vec3 (TrackPath (vel * tCur + 7. + 6. * float (k)),\n       0.8 + 0.3 * sin (2. * pi * (0.13 * tCur + float (k) / float (N_GLOW)))).xzy;\n    glPos[k].x *= 8.5;\n  }\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 807, 829, 829, 1982], [1984, 1984, 2006, 2006, 2123], [2125, 2125, 2158, 2158, 3273], [3275, 3275, 3296, 3296, 3491], [3493, 3493, 3544, 3544, 3984], [3986, 3986, 4021, 4021, 4474], [4476, 4476, 4499, 4499, 5044], [5046, 5046, 5094, 5094, 5405], [5407, 5407, 5442, 5442, 7461], [7463, 7463, 7489, 7489, 7881], [7883, 7883, 7939, 7939, 9730], [9732, 9732, 9774, 9774, 9825], [9827, 9827, 9874, 9874, 9921], [9923, 9923, 9947, 9947, 10177], [10179, 10179, 10203, 10203, 10263], [10265, 10265, 10288, 10288, 10421], [10423, 10423, 10445, 10445, 10483], [10485, 10485, 10507, 10507, 10545], [10547, 10547, 10592, 10592, 10695], [10697, 10697, 10754, 10754, 10837], [10839, 10839, 10869, 10869, 10982], [11016, 11016, 11040, 11040, 11170], [11172, 11172, 11196, 11196, 11416], [11418, 11418, 11443, 11443, 11629], [11631, 11631, 11656, 11656, 11881], [11883, 11883, 11904, 11904, 12059], [12061, 12061, 12090, 12090, 12302], [12304, 12304, 12343, 12343, 12523]]}
{"id": "WtBSDc", "name": "Fractal tri-grid noise ", "author": "CPU", "description": "Tried adding octaves to equilateral triangle grid noise here https://www.shadertoy.com/view/3lBXWc\nSmoothstep on RHS.", "tags": ["fractal", "noise", "grid", "tri"], "likes": 7, "viewed": 365, "published": "Public API", "date": "1567250952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hex(u) max( 0., 1.- dot( abs( vec3((u).y, (u)* mat2( .866, .5,.866,-.5) ) ),vec3(.577)) )\n\nfloat d,x;// = 0.;\n\nfloat el(vec2 u, int x, int y) {\n    vec2 s = vec2(2,1.73),\n         a = ( u + s*vec2(x,y)/4. ) / s;\n    return   hex( s* ( fract(a) -.5 ) )\n           * fract(sin(dot( ceil(a)+.1*d++ , vec2(37.341,97.784)))*47925.95);\n}\n\nfloat ns( vec2 u ){\n    d=0.;\n    float t=el(u, 0,0) +  el(u, 2,0) +  el(u, 1,2) +  el(u, 3,2) ;\n\tif(x>0.)t=t*t*(3.-2.*t);\n    return t;\n}\n\n\nvoid mainImage( out vec4 C, vec2 U ){\n    vec2 R = iResolution.xy,  u = 8.* ( 2.*U-R ) / R.y +iTime; x=U.x-.5*R.x;\n    int o=1+(iFrame>>6)%5;\n    float n=0., a=1., t=0.;\n    for(int i=0; i<o;i++){\n\t    n+=a*ns(u); t+=a; u*=2.; a*=.5; \n        }\n    C = vec4( n/t );\n\t}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 119, 151, 151, 339], [341, 341, 360, 360, 479], [482, 482, 519, 519, 750]]}
{"id": "wtBSDK", "name": "dog test", "author": "crossbow", "description": "an sss dog from a beginner", "tags": ["sdf"], "likes": 3, "viewed": 280, "published": "Public API", "date": "1567135982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//from iq\nfloat g_time;\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat sdf(vec3 p,float time){\n    float pi=3.1415926;\n   float d=1e4;\n   d=smin(length(p-vec3(-.75,0.,-.1))-.4,length(p-vec3(.75,0.,-.1))-.5,2.);\n    d=smin(d,length(p-vec3(0,0.4,-.1))-.9,1.6);\n    //NOSE\n    d=smin(d,length(p-vec3(0,0.4,1.0))-.5,.3);\n    d=smin(d,length(p-vec3(0,0.35,2.0))-.2,1.2);\n    //d=smin(d,length(p-vec3(0,0.35,3.0))-.2,1.2);\n    //DOG EARS\n    d=smin(d,length(p-vec3(.8,1.3,-0.5))-.3,0.4);\n    d=smin(d,length(p-vec3(1.0,1.6,-0.5))-.05,0.4);\n    d=smin(d,length(p-vec3(-.8,1.3,-0.5))-.3,0.4);\n    d=smin(d,length(p-vec3(-1.0,1.6,-0.5))-.05,0.4);\n    //neck\n    vec3 pneck=p;\n    pneck.yz*=rotmat(pi/8.0);\n    d=smin(d,distance(vec3(0.,clamp(pneck.y,-3.0,-1.1),0.),pneck.xyz)-0.95,.4);\n    //front chest\n    d=smin(d,length(p-vec3(.0,-3.0,-1.0))-1.2,0.4);\n    //front legs\n    d=smin(d,distance(vec3(0.55,clamp(p.y,-5.0,-3.1),-1.0),p.xyz)-0.4,.4);\n    d=smin(d,distance(vec3(-0.55,clamp(p.y,-5.0,-3.1),-1.0),p.xyz)-0.4,.4);\n    //belly\n    d=smin(d,distance(vec3(0.,-3.0,clamp(p.z,-3.5,-1.0)),p.xyz)-1.0,.4);\n    d=smin(d,length(p-vec3(0,-3.5,-2.7))-1.2,0.4);\n    //backleg\n    d=smin(d,length(p-vec3(.4,-3.3,-4.0))-.8,0.4);\n    d=smin(d,length(p-vec3(-.4,-3.3,-4.0))-.8,0.4);\n    d=smin(d,length(p-vec3(.6,-4.2,-4.2))-.6,0.7);\n    d=smin(d,length(p-vec3(-.6,-4.2,-4.2))-.6,0.7);\n    //leg\n    vec3 plleg=p;\n    plleg.yz*=rotmat(-pi/12.0);\n    d=smin(d,distance(vec3(0.55,clamp(plleg.y,-6.0,-5.0),-2.3),plleg.xyz)-0.35,.4);\n    d=smin(d,distance(vec3(-0.55,clamp(plleg.y,-6.0,-5.0),-2.3),plleg.xyz)-0.35,.4);\n    d=smin(d,distance(vec3(0.55,clamp(plleg.y,-5.0,-3.6),-5.6),plleg.xyz)-0.35,.4);\n    d=smin(d,distance(vec3(-0.55,clamp(plleg.y,-5.0,-3.6),-5.6),plleg.xyz)-0.35,.4);\n    //tail\n    vec3 plt1=p;\n    plt1.y+=3.3;\n    plt1.z+=2.3;\n    plt1.yz*=rotmat(sin(time*10.0)*pi/12.0);\n    plt1.y-=3.3;\n    plt1.z-=2.3;\n    vec3 plt2=p;\n    plt2.y+=3.3;\n    plt2.z+=5.3;\n    plt2.yz*=rotmat(sin(time*10.0)*pi/12.0);\n    plt2.y-=3.3;\n    plt2.z-=5.3;\n    d=smin(d,length(p-vec3(-.0,-3.3,-5.0))-.4,0.4);\n    d=smin(d,length(plt1-vec3(-.0,-3.3,-6.0))-1.1,0.4);\n    d=smin(d,length(plt2-vec3(-.0,-3.3,-7.5))-.1,1.6);\n    return d;\n}\nfloat raymarch(vec3 ro,vec3 rd,float begin,float end,float time){\n    float d= begin;\n    for (int i = 0; i < 255; i++) {\n        float dist = sdf(ro+rd*d,time);\n        if (dist < 0.001) {\n\t\t\treturn d;\n        }\n        d += dist;\n        if (d >= end) {\n            return end;\n        }\n    }\n    return end;\n}\nvec3 Ray( float zoom, in vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\nvec3 RY(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x * cos(angle) - pos.z * sin(angle),\n        pos.y,\n        pos.x * sin(angle) + pos.z * cos(angle)\n    );\n}\nfloat rand(float i){\n    return fract(sin(i*18.0)*12345.987);\n}\n//from iq\nfloat CalcAO(vec3 p, vec3 n)\n{\n   float r = 0.0;\n   float w = 1.0;\n   for (int i=1; i<=6; i++)\n   {\n      float d0 = float(i) * 0.2;\n      r += w * (d0 - sdf(p + n * d0,g_time));\n      w *= 0.4;\n   }\n   return 1.0 - clamp(r,0.0,1.0);\n}\n//from iq\nfloat CalcSSS(vec3 ro, vec3 rd,vec3 nor)\n{\n    vec4 kk;\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-sdf(ro-h*dir,g_time));\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n\nvec3 GetNormal(vec3 pos)\n{\n   vec3 n;\n   vec2 delta=vec2(0.001,0);\n   n.x = sdf( pos + delta.xyy,g_time ) - sdf( pos - delta.xyy,g_time );\n   n.y = sdf( pos + delta.yxy,g_time ) - sdf( pos - delta.yxy,g_time );\n   n.z = sdf( pos + delta.yyx ,g_time) - sdf( pos - delta.yyx ,g_time);\n   \n   return normalize(n);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat t=iTime;\n    g_time=iTime;\n\tvec3 rd=Ray(0.3,fragCoord);\n\trd=normalize(rd);\n    vec3 ro=vec3(0.0,0.0,-8.0);\n\tro=RY(ro,t/3.0);\n\trd=RY(rd,t/3.0);\n\tfloat dt=raymarch(ro,rd,0.0,100.0,t);\n\tif(dt>100.0-0.001){\n\t\tfragColor=vec4(0.0,0.0,0.0,0.0);\n\t\treturn;\n\t}\n    vec3 norm=GetNormal(ro+dt*rd);\n\tvec3 light = vec3(1) * max(0.0, dot(norm, vec3(0.2,0.1,0.02)));\n    \n   //light = (0.25 * light);\n   float sss=CalcSSS(ro+rd*dt, rd,norm);\n   float ao= CalcAO(ro+rd*dt, norm);\n   light = mix(light, vec3(0.8,0.6,0.6),sss);\n   light +=ao*0.25;\n    //light+=vec3(0.1,0.1,0.1);\n    \n    fragColor=vec4(clamp(light,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 65, 65, 158], [159, 159, 181, 181, 230], [231, 231, 260, 260, 2384], [2385, 2385, 2450, 2450, 2698], [2699, 2699, 2742, 2742, 2812], [2813, 2813, 2846, 2846, 2981], [2982, 2982, 3002, 3002, 3045], [3046, 3056, 3086, 3086, 3291], [3292, 3302, 3344, 3344, 3686], [3689, 3689, 3715, 3715, 4001], [4002, 4002, 4057, 4057, 4678]]}
{"id": "WtBSDV", "name": "Milk Metaballs", "author": "holtsetio", "description": "Quick sketch to demonstrate raymarching to a coworker", "tags": ["raymarching", "metaball"], "likes": 8, "viewed": 176, "published": "Public", "date": "1567068578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.0001\n#define MAXDIST 10.0\n#define SPHERENUM 20\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise(float p, float id) {\n\tfloat t = iTime*0.3 + p*id*33.1293;\n\tfloat s = floor(t);\n    float phase = t-s;\n    vec2 rs = vec2(23.1917,12.3777);\n    return mix(rand(rs*s),rand(rs*(s+1.0)),sin((phase-0.5)*3.14159)*0.5+0.5);\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat voxelRes = 0.01;\n\nfloat map(vec3 p) {\n    float d = 1e9,d0;\n    for (int i=0; i<SPHERENUM;i++) {\n        float r = noise(float(i),1.0)*0.7;\n        float x = noise(float(i),2.0)*2.0-1.0;\n        float y = noise(float(i),3.0)*2.0-1.0;\n        float z = noise(float(i),4.0)*2.0-1.0;  \n   \t\td0 = length(vec3(x,y,z)-p)-r;\n        d = opSmoothUnion(d,d0,0.5);\n    }\n\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 rd = normalize(vec3(uv,1.8));\n    vec3 p = vec3(0.0,0.0,-4.0);\n    float c = 0.0;\n    float d = 1.0, td = 0.0;\n    while (td <= MAXDIST && d > EPSILON*td) {\n      \td = map(p);\n        c += max(0.0,1.0-d) * 0.01;\n      \ttd += d;\n        p += rd*d;\n    }\n    fragColor = vec4(vec3(1.0-c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 85, 85, 157], [158, 158, 190, 190, 388], [389, 389, 441, 441, 540], [566, 566, 585, 585, 925], [926, 926, 983, 983, 1377]]}
{"id": "WtBSDz", "name": "浮遊球網", "author": "Hirai_worthless", "description": "q", "tags": ["raymarching"], "likes": 6, "viewed": 127, "published": "Public", "date": "1565533868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec2 pmod(vec2 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec2(l * cos(theta), l * sin(theta));\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 q){\n    q.xy *= genRot(PI/10.);\n    q.xy = pmod(q.xy,10.);\n    q.xy *= genRot(-PI/10.);\n    q.xy = (fract(q.xy /10.0 + 0.5) - 0.5) * 10.0;\n    q.z = (fract(q.z / 8.0 + 0.5) - 0.5) * 8.0;\n\t//q.xz *= genRot(iTime/2.);\n    float at = atan(q.y/q.x);\n    q.xy *= genRot(PI/10.);\n    q.xy = pmod(q.xy,10.);\n    q.xy *= genRot(-PI/10.);\n    q.xz *= genRot(PI/10.);\n    q.xz = pmod(q.xz,10.);\n    q.xz *= genRot(-PI/10.);\n    float h1 = 0.2 * cos(abs(at) + iTime);\n    float h2 = 0.3 * sin(abs(at) + iTime * 1.2);\n    float pole = sphere(q,vec3(2.,0.,h1),0.2);\n    pole = min(pole,\n              line(q,vec3(0.),vec3(2.,0.,h1),0.05));\n    pole = min(pole,sphere(q,vec3(3.,0.,h2),0.15));\n    pole = min(pole,\n              line(q,vec3(3.,0.,h2),vec3(2.,0.,h1),0.05));\n    return pole;\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(5. * cos(iTime/4.),5. * sin(iTime/4.),-6.0 + iTime);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.yz *= genRot(PI/4.);\n    ray.xy *= genRot(iTime/4.); \n    ray.xz *= genRot(PI/4.);\n\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 256; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.015);\n    float a = dot(data.xyz,r);\n    vec3 p = o + r * t;\n    vec3 fc = min(fract(p.x + p.y),fract(p.z + p.y))<0.03 ? vec3(0.95) : vec3(0.05);\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    fc = mix(vec3(0.95),fc,fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 369, 369, 443], [445, 445, 471, 471, 647], [650, 664, 700, 700, 729], [731, 731, 769, 769, 798], [800, 800, 833, 833, 980], [982, 982, 1025, 1025, 1181], [1184, 1201, 1219, 1219, 1993], [1995, 2013, 2037, 2037, 2289], [2291, 2311, 2332, 2332, 2400], [2402, 2416, 2443, 2443, 2588], [2590, 2605, 2633, 2633, 2833], [2835, 2850, 2889, 2889, 3244], [3246, 3257, 3314, 3331, 3683]]}
{"id": "wtBSRm", "name": "pusling spikes", "author": "anclin", "description": "pusling spikes", "tags": ["spikes", "pusling"], "likes": 7, "viewed": 102, "published": "Public", "date": "1565372992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI2 6.28318530718\n#define PI 3.14159265359\n#define e 2.71828182845904523536\n\nfloat lineDF(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float t = dot(ap,ab)/dot(ab,ab);\n    t = clamp(t,0.,1.);\n    vec2 c = a + t*ab;\n    return length(p-c);\n}\n\nfloat lineDFSqrd(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float t = dot(ap,ab)/dot(ab,ab);\n\tt = clamp(t,0.,1.);\n\tvec2 c = a + t*ab;\n    c = p-c;\n    return c.x*c.x+c.y*c.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*3.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float scale = 1.5;\n\tuv *= scale;\n\n    float t2 = t*2.;\n    float t3 = t*.1;\n    float c = 999999.;\n    float c2 = 999999.;\n    vec2 prev = vec2(0);\n    float skip = 23.;//floor(mod(t2,24.)/2.)*2.+3.;\n    float waves = floor(mod(t3,6.));\n    float f = pow(cos(t3*PI2-PI2)*.5+.5, 8.);\n\n    for (float a = 0.; a < PI2+.1; a += PI2/50.){\n        // lines\n        float a2 = a * skip + PI/2.;\n        vec2 p = vec2(cos(a2), sin(a2))*.5;\n        vec2 off = normalize(p) * mix(.0,.15,cos(a2*waves+t2)*.5+.5);\n        p += mix(off, vec2(0), f);;\n        if (a > 0.){        \n        \tfloat ci = lineDFSqrd(prev,p,uv);\n        \tc = min(c,ci);\n        }\n        prev = p;\n        \n        // circles\n        float a0 = a + PI/2.;\n        vec2 p0 = vec2(cos(a0), sin(a0))*.5;\n        vec2 off0 = normalize(p0) * mix(.0,.15,sin(a0*waves+t2)*.5+.5);\n        p0 += mix(off0, vec2(0), f);\n        float s = .005;\n        float c2i = length(p0-uv)-s;\n        c2 = min(c2,c2i);\n    }\n    \n    // combine\n    c = sqrt(c);\n    c = min(c,c2);\n    \n    // step\n    float w = 1.5*scale/iResolution.y;//*mix(1.,300.,sin(t)*.5+.5);\n    float lw = .001;\n    c = smoothstep(lw+w,lw-w, c);\n    \n    vec3 col = vec3(c);\n    col *= (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 122, 122, 270], [272, 272, 313, 313, 472], [474, 474, 531, 531, 1923]]}
{"id": "WtBSRy", "name": "Republic of Vietnam flag", "author": "nguyenvuong", "description": "Nice wave effect from lamogui: https://www.shadertoy.com/view/4l23DK", "tags": ["wave", "flag", "vietnam"], "likes": 0, "viewed": 77, "published": "Public", "date": "1566220019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat wave_amp=0.02;\nfloat wave_freq=3.0;\nfloat wave_speed=5.0;\n\n\nbool red_strip( vec2 uv )\n{\n    if (uv.y>-0.06 && uv.y<0.06)\n        return true;\n        \n    if (uv.y>-0.3 && uv.y<-0.18)\n        return true;\n        \n    if (uv.y>0.18 && uv.y<0.3)\n        return true;\n        \n    return false;\n}\n\nvec4 yellow_flag(vec2 uv)\n{\n    if (red_strip(uv))\n        return vec4(0.98, 0.24, 0.2, 1.0);\n\n    return vec4(1.0, 1.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = fragCoord.xy / iResolution.xy;\n    vec2 uv=v*2.-vec2(1.);\n    uv.x*=iResolution.x/iResolution.y;\n\n    float d=-uv.x+0.3*uv.y + texture(iChannel0,uv).x*0.03 - exp(-1.0+uv.x) +  exp(-uv.y);\n    float a=mod(wave_speed*iTime+d*wave_freq,4.0*3.14159265359);\n    uv.x += cos(a)*wave_amp;\n    uv.y += sin(a)*wave_amp;\n    vec4 color = yellow_flag(uv);\n    float shadow = .75 - 0.25*(sin(a-0.3));\n    fragColor = color * shadow;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 94, 94, 301], [303, 303, 330, 330, 436], [438, 438, 495, 495, 931]]}
{"id": "WtBSW3", "name": "Malachite 1", "author": "stseagle", "description": "One of the exercises from the Book of Shaders attempting to replicate a texture of Malachite", "tags": ["2d", "teal", "malachite"], "likes": 5, "viewed": 299, "published": "Public API", "date": "1567204679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From Inigo Quilez\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// https://www.shadertoy.com/view/XdXGW8 \nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat random(in float seed) {\n    return fract(sin(dot(vec2(seed),\n                         vec2(11.039234,66.74392)))*\n        5706.2373);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color = vec3(0.0078, 0.0588, 0.0588);\n\n    vec2 st = gl_FragCoord.xy/max(iResolution.x, iResolution.y);\n    vec2 mt = iMouse.xy/max(iResolution.x, iResolution.y);\n    vec2 pos = vec2(st * 11.);\n    float n = 11.9 + 1.8 * noise(pos);\n    float dis = distance(st,vec2(.65*n)) * distance(st,vec2(.046*n));\n    dis += distance(st, mt);\n\n    float steps = 18.;\n\n    float pct = floor(mod(dis *6. - iTime * 0.8, steps))*(1./(steps - .1));\n        pct = fract(pct*(random(pct) * 0.5 + 0.5));\n    vec3 malaColors[4];\n        malaColors[0] = vec3(0.0078, 0.1412, 0.102);\n        malaColors[1] = vec3(0.051, 0.3608, 0.2941);\n        malaColors[2] = vec3(0.2275, 0.8471, 0.7137);\n        malaColors[3] = vec3(0.1255, 0.6706, 0.5333);\n\n    float cutoff = 0.22;\n\n    if (pct < cutoff) {\n        color += mix(malaColors[0], malaColors[1], pct);\n    } else {\n        color = mix(malaColors[2], malaColors[3], (pct - cutoff) * (1. / cutoff));\n    }\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 79, 79, 217], [219, 261, 287, 287, 685], [687, 687, 716, 716, 828], [830, 830, 887, 887, 1861]]}
{"id": "WtBSWG", "name": "CircleRipple", "author": "huttarl", "description": "My daughter wanted the ripples to go out from the center. And the color to be blue. And ... it should come out from wherever your mouse is.\nView full screen.", "tags": ["wave"], "likes": 4, "viewed": 368, "published": "Public", "date": "1566871656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"CircleWave\" by RenoM. https://shadertoy.com/view/4dc3D8\n// 2019-08-27 00:50:56\n\n#define SCALE 40.\n#define SPEED 4.\n#define FREQUENCY -.2\n\nfloat d;\n// Circle\n// was: #define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\n#define C(p, o)  min(1., sqrt(10.*abs(length((p-.5)/(o + .001))-.4)))\n// Little dot\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = U - iMouse.xy + R*.5;\n    vec2 p = SCALE*(U+U/R)/R.y,\n         f = fract(p);\n    vec2 q = floor(p) + vec2(1., -1.) - SCALE*vec2(.9, .45);\n    float a = atan(q.y, q.x);\n    float t=(length(q) - a * .25 / FREQUENCY)*FREQUENCY\n           +iTime*SPEED;\n    vec2 o=vec2(cos(t),sin(t)); // was *.4+.5;\n    float col = C(f, o); // was: *D(f,o);\n    O.xyz = vec3(1.0 - col, 1.0 - col * .7, 0.5);\n}", "image_inputs": [{"id": "ltlGRs", "previewfilepath": "https://soundcloud.com/ryan-roberts/philip-glass-opening-from", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ryan-roberts/philip-glass-opening-from", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 366, 407, 407, 834]]}
{"id": "WtBSWw", "name": "Blue Tunnel", "author": "taso69", "description": "Blue Tunnel", "tags": ["3d", "reflection", "tunnel", "raymarch", "halftone"], "likes": 4, "viewed": 86, "published": "Public", "date": "1566049178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\nfloat speed = 5.0;\nvec3 light;\n\nmat2 rotate(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash21( vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n\nfloat sdSphere(vec3 pos, float r){\n    return length(pos) - r;\n}\n\nfloat sdCylinder( vec3 pos, vec3 c ){\n  return length(pos.xy-c.xy)-c.z;\n}\n\nfloat sdBox(vec3 pos, vec3 c){\n    vec3 d = abs(pos) - c ;\n    return length(max(d,0.0)) + min(max(max(d.x,d.y),d.z),0.0);\n}\n\nfloat sdBar(vec3 pos, vec3 c){\n    vec2 d = abs(pos.xy) - c.xy;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 matMin(vec2 a, vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n\nvec2 map(vec3 pos){\n    vec2 map = vec2(10000.0,-1.0); \n   \n    vec3  p = pos;\n    float outC = sdCylinder(p,vec3(0.0,0.0,4.0));\n    float inC = sdCylinder(p,vec3(0.0,0.0,3.9));\n    p.xy *= rotate(p.z);\n    float mask = sdBar(p,vec3(4.0,3.8,0.0));\n    float d = max(outC, -inC);\n    d = max(d,mask);\n    map = matMin(map,vec2(d,3.0)); \n\n    p = pos;\n    float pOutC = sdCylinder(p,vec3(0.0,0.0,2.0));\n    float pInC = sdCylinder(p,vec3(0.0,0.0,1.95));\n    float cycle = floor(hash21(vec2(floor(pos.z),-floor(pos.z)))*5.0);\n    p.xy *= rotate(cycle);\n    float t = clamp(mod(iTime,cycle) - (cycle-0.5), 0.0, 1.0)/0.5;\n    float rad =  mix(floor(iTime/cycle),floor(iTime/cycle+1.0),t)*PI/2.0;\n    rad = (mod(cycle,2.0)==0.0) ? rad : -rad;\n    p.xy *= rotate(rad);\n    float pMask = sdBar(p,vec3(0.5,3.0,0.0)); \n    pMask = min(pMask,sdBar(p,vec3(3.0,0.5,0.0)));\n    vec3 q = pos;\n    q.z = mod(q.z,2.0) - 1.0;\n    pMask = min(pMask,sdBox(q,vec3(4.0,4.0,0.5)));\n    float pC = max(pOutC,-pInC);\n    pC = max(pC,-pMask);\n    map = matMin(map,vec2(pC,2.0));\n\n    p = pos;\n    float outC2 = -sdCylinder(p,vec3(0.0,0.0,5.0));\n    map = matMin(map,vec2(outC2,4.0));\n    \n    p = mod(pos,2.0)-1.0;\n    float sp = sdSphere(p,0.2);\n    float box = sdBox(p,vec3(0.2));\n    map = matMin(map,vec2(mix(sp,box,sin(iTime)),1.0));\n    return map;\n}\n\n\nvec3 calcNorm(vec3 pos){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 trace(vec3 ro, vec3 rd,int N){\n    vec3 pos;\n    float dist = 0.0;\n    vec2 m;\n    for(int i = 0; i < N; i++){\n        pos = ro + dist*rd;\n        m = map(pos);\n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        dist += min(min((step(0.0,rd.x)-fract(pos.x))/rd.x, \n            (step(0.0,rd.z)-fract(pos.z))/rd.z)+0.01,m.x)*0.75;\n    }\n    return vec3(dist,m);\n}\n\n\nvec3 lighting(vec3 pos, vec3 N,float mat){\n    vec3 col = vec3(0.0);\n    vec3 L = normalize(light - pos);\n\n    float diffuse = clamp(dot(N,L),0.1,1.0);\n    if(mat == 1.0){\n        col += diffuse * vec3(0.01,0.4,0.6);\n    }else if(mat == 2.0){\n        col += diffuse * vec3(0.8);\n    }else if(mat == 3.0){\n        col += diffuse * vec3(0.4);\n    }else if(mat == 4.0){\n        col += diffuse * vec3(0.4,0.4,0.9)*0.8;\n    }\n    return col;\n}\n\nvec3 getCol(vec3 ro,vec3 rd,vec2 uv){\n    light = vec3(0.0,0.0,0.0-iTime*speed);\n    vec3 col = vec3(0.0);\n\n    vec3 pos;\n    vec2 m; \n    \n    vec3 t = trace(ro,rd,128);\n    pos = ro + t.x*rd;\n    if(abs(t.y) < 0.001){\n        vec3 N = calcNorm(pos);\n        vec3 L = normalize(light - pos);\n        col += lighting(pos,N,t.z);\n        float diff = clamp(dot(N,L),0.0,1.0);\n        float f = (sin(uv.x) * 0.5 + 0.5) + (sin(uv.y) * 0.5 + 0.5);//halftone\n        col +=  mix(0.0,f*0.05,diff);\n        \n        vec3 R = normalize(reflect(rd,N));\n        pos += N*0.001;\n        vec3 rT = trace(pos,R,32);\n        pos += rT.x*R; \n        if(abs(rT.y) < 0.001){\n            vec3 rN = calcNorm(pos);\n            col += lighting(pos,rN,rT.z);\n\n            vec3 rR = normalize(reflect(R,rN));\n            pos += rN*0.001;\n            vec3 rrT = trace(pos,rR,32);\n            pos += rrT.x*rR;\n            if(abs(rrT.x)<0.001){\n                vec3 rrN = calcNorm(pos);\n                col += lighting(pos,rrN,rrT.z);\n            }\n        }\n    }\n\n    col += vec3(0.01)*exp(0.15*t.x);\n    col += vec3(0.002,0.02,0.02)*exp(0.5*sin(iTime)*t.x);\n    return col;\n\n}\n\nmat3 cam(vec3 ro, vec3 ta){\n    vec3 cUp = vec3(0.0,1.0,0.0);\n    vec3 cDir = normalize(ta-ro);\n    vec3 cSide = normalize(cross(cDir,cUp));\n    cUp = normalize(cross(cDir,cSide));\n\n    return mat3(cSide,cUp,cDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = fragCoord.xy*2.0 - iResolution.xy;\n    p /= min(iResolution.x,iResolution.y);\n\n    float z = -iTime*speed; \n    vec3 ro = vec3(0.0,0.0,0.0+z);\n    vec3 ta = vec3(3.0*cos(iTime*1.2),-3.0*sin(iTime*0.8),6.0*cos(iTime*0.5)+z);\n    vec3  rd = normalize(vec3(p,1.0)) * cam(ro,ta);\n\n    vec2 uv = fragCoord;\n    vec3 col = getCol(ro,rd,uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 73, 73, 136], [138, 138, 161, 161, 231], [234, 234, 268, 268, 298], [300, 300, 337, 337, 373], [375, 375, 405, 405, 499], [501, 501, 531, 531, 621], [623, 623, 651, 651, 685], [688, 688, 707, 707, 2018], [2021, 2021, 2045, 2045, 2334], [2336, 2336, 2371, 2371, 2724], [2727, 2727, 2769, 2769, 3165], [3167, 3167, 3204, 3204, 4320], [4322, 4322, 4349, 4349, 4538], [4540, 4540, 4596, 4596, 4982]]}
{"id": "wtBSzc", "name": "Intro to cone tracing pt.2", "author": "edapx", "description": "This is the same as \"Intro to cone tracing pt.1\" https://www.shadertoy.com/view/wlSSzc , just with depth of field bounded to the mouse.", "tags": ["dof", "antialias", "conetracing"], "likes": 10, "viewed": 329, "published": "Public", "date": "1566577112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 64;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.00;\nconst float PI = 3.14159265359;\n\nvec3 toGamma( vec3 col ){\n\treturn pow( col, vec3(1.0/2.2));\n}\n\nfloat clampeddot(vec3 a, vec3 b){\n    return max(0.,dot(a, b));\n}\n\nvec3 lightDirection = vec3(1.0, 1.0, 1.0);\n\nvec2 rotate(vec2 pos, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n} \n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(vec3 pos){\n    pos.xy = rotate(pos.xy, sin(iTime) * PI/2. * 0.03);\n    float offset = 0.5;\n    //float sph = sphere(pos, 1.5);\n    // just a sphere\n    //return sph;\n\n    // domain repetition, more edges, antialias more visible\n    pos = opRep(pos, vec3(offset, offset, offset));\n\n    // test boxes\n    return sdBox(pos, vec3(0.1, 0.1, 0.1));\n\n    // test spheres\n    // /return sphere(pos, .2);\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    return clampeddot(normal, lightDirection);\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return pow(clampeddot(h, normal), specularityCoef);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getColor(vec3 eye, vec3 dir,float dist){\n    float ambient = 0.2;\n    vec3 red = vec3(1.0, 0.353, 0.208);\n    vec3 collision = (eye += (dist*0.995) * dir );\n    vec3 normal = computeNormal(collision);\n    float diffLight = diffuse(normal) * ambient + ambient;\n    float specLight = specular(normal, dir);\n\n    return (diffLight + specLight ) * red;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(3.5, 3.0, -1.0);\n    vec3 ta = vec3( -0.5, -0.9, 0.5 );\n    mat3 camera = setCamera( eye, ta, 1.0 );\n    float fov = 2.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n\n    // bg color\n    vec3 finalColor = vec3(0.086, 0.19, 0.8);\n    // t is the position of the center of the sphere along the ray.\n    float t = NEAR_CLIP;\n    float dist = EPSILON;\n    float zoom = 1.5;\n\n    // this is the radius of the sphere that models the cone.\n    // formula from https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer\n    float vfov = 0.9; //vfov is the vertical camera field-of-view (in radians)\n    float radius = (2.0*tan(vfov/2.0)) /(iResolution.y*zoom);\n    // it can also be simplyfied using a constant, like in via https://www.shadertoy.com/view/MsBGWm\n    // float radius = .7071/(u_resolution.y*zoom);\n    \n    \n    //Depth of Field\n    float aperture = .03 * iMouse.x/iResolution.x;\n\tfloat focus = 5.1 * iMouse.y/iResolution.y;\n\n    // color accumulation variable. This is used to accumulate the colors sampled for all\n    // the intersection between the cone and the scene, and to accumulate the coverage\n    // on the alfa channel\n    vec4 acc = vec4(0, 0, 0, 1);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float rad = t*radius + aperture*abs(t-focus);\n\n        // move the center of the sphere along the ray\n        dist = map(eye + t * dir);\n\n        // if the distance from the scene is smaller than the radius,\n        // it means that there is an intersection between the cone and the scene.\n        // we accumulate and blend the colors sampled for those intersections into the acc variable.\n        if (dist < rad) {\n            // how much of the surface of the projected pixel is covering the scene?\n            // this is what the coverage value stands for.\n\n            // This is the easiest coverage calculation that I have found:\n            // float alpha = smoothstep(rad, -rad, dist);\n            // https://www.shadertoy.com/view/4scBW8\n            float alpha = smoothstep(rad, -rad, dist);\n\n            // You can also estimate the coverage of the surface using it's distance\n            // over the projected aperture of the cone. \n            // coverage = dist / rad;\n            // of course the blending algorithm have to be adapted. see https://www.shadertoy.com/view/MsBGWm\n\n            // then sample the color at the given distance.\n            // I know, I could save the allocation of this variable, but, for the sake of clarity ...\n            vec3 sampleCol = getColor(eye, dir, t);\n\n            // the new color is calculated multiplying\n            // the previous alpha for the new color times the new alpha\n            acc.rgb += acc.a * (alpha*sampleCol.rgb);\n            // here we save the new alpha\n            acc.a *= (1.0 - alpha);\n\n            // when acc.a is really small, it means that we hit the object, brake the loop\n            if (acc.a < EPSILON ) break;   \n        }\n\n\n        // move the center of the sphere forward along the ray. The smaller\n        // the steps the higher the precision and the slower the computation.\n        t += max(abs(dist*0.85), 0.001); //https://www.shadertoy.com/view/4dlyWB\n        //t += max( dist, rad*.5 ); // https://www.shadertoy.com/view/MsBGWm\n\n        // brake if we are going too far away\n        if (t > FAR_CLIP) break;\n    }\n\n    finalColor = mix(acc.rgb, finalColor, acc.a);\n    fragColor = vec4(clamp(toGamma(finalColor),0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 183, 183, 219], [221, 221, 254, 254, 286], [332, 332, 367, 367, 457], [460, 460, 490, 490, 581], [583, 583, 620, 620, 655], [657, 657, 686, 686, 715], [717, 717, 737, 737, 1124], [1126, 1126, 1155, 1155, 1369], [1371, 1371, 1398, 1398, 1447], [1449, 1449, 1487, 1487, 1616], [1618, 1618, 1669, 1669, 1858], [1860, 1860, 1905, 1905, 2215], [2218, 2218, 2275, 2275, 5907]]}
{"id": "wtBXD1", "name": "mandelchot", "author": "pmabres", "description": "Basic mandelbrot", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 59, "published": "Public", "date": "1565821955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 200\nfloat mand(vec2 z, vec2 c) {\n    int iter = 0;\n    float sqrDist = 0.0;\n    for (;iter<STEPS;iter++) {\n        float rr = z.x*z.x;\n        float ii = z.y*z.y;\n        float tmpR = rr - ii + c.x;\n        float tmpI = z.x * z.y + z.y * z.x + c.y;\n        sqrDist = length(z);\n        if (sqrDist > 4.0) {\n            break;\n        }\n        z.x = tmpR;\n        z.y = tmpI;\n    }\n\treturn float(iter) - (log (log (sqrDist))) / log(2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x - 0.2;\n\tvec2 mandelCoords = uv.xy*(1.0/(iTime*iTime))-0.57;\n   \n    float mu = mand(mandelCoords, mandelCoords);\n    vec3 col = vec3( 1.0 - mu / float(STEPS));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 46, 46, 453], [455, 455, 512, 563, 794]]}
{"id": "wtBXDD", "name": "wicker bagel", "author": "avin", "description": "2d visual experiment", "tags": ["wicker"], "likes": 4, "viewed": 372, "published": "Public API", "date": "1565889228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define TAU 6.2831852\n\n#define SF 1./min(iResolution.x,iResolution.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float a = atan(uv.y, uv.x)/TAU;\n    \n    float l = length(uv);\n    float m = 0.;\n    for(float n=0.; n<6.; n+=1.){\n        float i = n*PI*.25;\n        float t = iTime*1. + i;\n        \n        float tt = 16.;\n        float f = t + a*PI*tt;\n        \n        float s = sin(f)*.5+.5;\n        float w = sin(PI*iTime + f + a*PI*4.)*.5+.5;\n        \n        float bs = w*.01;\n        \n    \tm = max(m, smoothstep(SF*2.+bs, bs, abs(l - (s*.25 + .225))) * (w*.5+.5) );\n    }\n    \n    \n    fragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 149, 149, 720]]}
{"id": "wtBXDm", "name": "LiveCodingPractice006(1h)", "author": "Hirai_worthless", "description": "1hour, sleepy", "tags": ["raymarching"], "likes": 5, "viewed": 89, "published": "Public", "date": "1566079563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec2 pmod(vec2 p,float c){\n\tp *= genRot(PI/c);\n    float at = atan(p.y/p.x);\n    at = mod(at,PI * 2./c);\n    float r = length(p);\n    p = vec2(r * cos(at),r * sin(at));\n    p *= genRot(-PI/c);\n    return p;\n}\nfloat map(vec3 p){\n    vec3 mc = vec3(3.5,3.5,1.5);\n        float r = 0.9 + 0.4 * sin(p.z);\n    p.xy *= genRot(p.z / 8. + sqrt(length(p.xy))/4. + iTime/32.);\n//    p = (fract(p /mc + 0.5)-0.5)*mc;\n    p.xy = pmod(p.xy,6.);\n    p.xy -= vec2(1.73,0.) * r;\n    \n    p.xy += vec2(1.73,0.) * r;\n    p = (fract(p /mc + 0.5)-0.5)*mc;\n\n\tfloat pil = length(p.xz - r * vec2(1.73,0.0)) - 0.1;\n\tpil = min(pil,length(vec2(p.x,abs(p.y)) - r * vec2(1.73,1.)) - 0.1);\n    vec3 q = p;\n    q.y = abs(q.y);\n    pil = min(pil,length(q - vec3(1.73,1.,0.) * r) - 0.25);\n    vec3 cp = abs(p - vec3(1.73,0.,0.) * r /2.);\n    cp.xy *= genRot(abs(sin(iTime)*1.25));\n    float cb = max(cp.x,max(cp.y,cp.z)) - 0.1;\n    pil = min(pil,cb);\n    return pil;\n}\nvec3 getNormal(vec3 p){\n\tvec3 x = dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\nvec4 trace(vec3 o,vec3 r){\n\tvec4 data;\n    float t = 0.;\n    for(int i = 0; i < 128; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 p = o + r  * t;\n    vec3 n = getNormal(p);\n    return vec4(n,t);\n}\t\nvec3 getCol(vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n    vec3 n = d.xyz;\n    vec3 p = o + r * t;\n    float fog = 1./(1. + t * t * 0.005);\n    vec3 col = vec3(pow(1. - dot(n,r) * 0.75,2.));\n    vec3 ccol ;\n    float at = atan(p.y/p.x) * 2. + p.z;\n    ccol.x = sin(at + iTime*2.);\n    ccol.y = sin(at + iTime*2. + PI * 2./3.);\n    ccol.z = sin(at + iTime*2. - PI * 2./3.);\n\tccol= ccol/1.8 + 0.5;\n    col *= ccol;\n    col = mix(col,vec3(0.),1. - fog);\n    return col;\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-2.5 + iTime * 3.);\n    return c;\n}\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    r.xz *= genRot(PI/8.);\n    r.yz *= genRot(PI/16.);\n    r.xy *= genRot(iTime/4.);\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    uv.y += sign(uv.x) * sign(sin(iTime)) * sqrt(abs(sin(iTime))) * 0.5;\n    uv.x += sign(uv.y) * sign(sin(iTime)) * sqrt(abs(sin(iTime))) * 0.5;\n\tvec3 o = cam();\n    vec3 r = ray(uv,1.2 + 0.5 * sin(iTime * PI / 4.));\n    vec4 d = trace(o,r);\n    vec3 c = getCol(o,r,d);\n    float vig = 1. - length(uv) * 0.05;\n\n    c *= vig;\n    // Time varying pixel color\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 90], [91, 91, 117, 117, 299], [300, 300, 318, 318, 1027], [1028, 1028, 1051, 1051, 1128], [1129, 1129, 1155, 1155, 1374], [1376, 1376, 1410, 1410, 1840], [1842, 1842, 1853, 1853, 1910], [1911, 1911, 1937, 1937, 2071], [2072, 2072, 2129, 2179, 2634]]}
{"id": "WtBXDR", "name": "群棲生塔", "author": "Hirai_worthless", "description": "Carnivorous", "tags": ["raymarching"], "likes": 4, "viewed": 85, "published": "Public", "date": "1565514078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\n\nfloat map(vec3 p){\n    p.xy = (fract(p.xy / 8. + 0.5) - 0.5) *8.;\n    vec3 q = p;\n    float inner = length(p.xy) - 1.0 - 0.15 * sin(p.z);\n    float at = atan(p.y/p.x);\n    inner -= 0.1 *cos(at * 2.0 + p.z * PI);\n    q.xy *= genRot(PI/16. + q.z/5.);\n    q = pmod(q,16.);\n    q.xy *= genRot(-PI/16.);\n    q.z = (fract(q.z / 2.0 + 0.5)-0.5) * 2.0 ;\n    float h1 = 0.4 * cos(abs(at) + iTime);\n    float h2 = 0.6 * sin(abs(at) + iTime * 1.2);\n    float pole = sphere(q,vec3(2.,0.,h1),0.2);\n    pole = min(pole,\n              line(q,vec3(0.),vec3(2.,0.,h1),0.05));\n    pole = min(pole,sphere(q,vec3(3.,0.,h2),0.15));\n    pole = min(pole,\n              line(q,vec3(3.,0.,h2),vec3(2.,0.,h1),0.05));\n    return min(inner,pole);\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n\treturn vec3(4. * cos(-iTime/4.),4. * sin(-iTime/4.),-2.0 + iTime);\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.xz *= genRot(PI / 4.);\n    ray.yz *= genRot(PI / 4.);\n    ray.xy *= genRot(-iTime/4.);\n    return ray;\n}\n\n//Tracing Ray\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 256; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.25;\n    }\n    return vec4(getNormal(p),t);\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,vec4 data){\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.015);\n    float a = dot(data.xyz,r);\n    vec3 p = o + r * t;\n    vec3 fc = min(fract(p.x + p.y),fract(p.z + p.y))<0.03 ? vec3(0.95) : vec3(0.05);\n    fc = mix(fc,vec3(1.),1. + a*1.5);\n    fc = mix(vec3(0.95),fc,fog);\n    fc = t < 1000. ? fc : vec3(0.95);\n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    vec4 data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 96, 119, 119, 191], [193, 193, 214, 214, 326], [328, 328, 369, 369, 443], [445, 445, 471, 471, 654], [657, 671, 707, 707, 736], [738, 738, 776, 776, 805], [807, 807, 840, 840, 987], [989, 989, 1032, 1032, 1188], [1191, 1208, 1226, 1226, 1928], [1930, 1948, 1972, 1972, 2224], [2226, 2246, 2267, 2267, 2337], [2339, 2353, 2380, 2380, 2528], [2530, 2545, 2573, 2573, 2773], [2775, 2790, 2829, 2829, 3184], [3186, 3197, 3254, 3271, 3623]]}
{"id": "wtBXR3", "name": "Mandelbrot Zoom Renderer", "author": "dkudriavtsev", "description": "Low precision shader adaptation of my C++ Mandelbrot set zoom animation renderer. To be worked on.", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 364, "published": "Public API", "date": "1566554590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Set parameters here\n\n#define MAX_ITER 1024.0\n#define COLOR_SCALE MAX_ITER\n\n#define AA true\n#define AA_8X true\n\n#define ALT_COLORS 1\n\n// Code\n\n#define ASPECT (iResolution.x / iResolution.y)\n\n#define Real float\n\nstruct Options {\n\tvec2 zoom_point;\n    int frame;\n    float zoom_factor;\n    int max_iter;\n};\n\n/*\n * Types used:\n * Bounds are a vec4(x1, y1, x2, y2)\n * Coordinates are a vec2(x, y)\n */\n\n// Map the current pixel and frame to a point,\n// zoomed to the given point by a given factor.\nvec2 frame_map(vec2 location, Options options) {    \n    vec4 bounds = vec4(vec2(-1.0, 1.0) * ASPECT, vec2(-1.0, 1.0)).xzyw;\n    vec2 zoomed_bounds = (bounds.zw - bounds.xy) \\\n        * pow(options.zoom_factor, Real(-options.frame));\n\n    vec4 px_bounds = vec4(\n        options.zoom_point.xy - zoomed_bounds.xy / 2.0,\n        options.zoom_point.xy + zoomed_bounds.xy / 2.0\n    );\n    \n    return px_bounds.xy + (px_bounds.zw - px_bounds.xy) * location / iResolution.xy;\n}\n\n        \nint iterations(in vec2 c, in int max_iter) {\n    vec2 z = vec2(0);\n    \n    for (int i = 0; i < max_iter; i++) {\n        if (distance(z.x, z.y) > 2.0) return i;\n        \n        z = vec2(\n            z.x*z.x - z.y*z.y + c.x,\n            z.y*z.x + z.x*z.y + c.y\n        );\n    }\n    \n\treturn -1;\n}\n\nvec3 color(vec2 fragCoord, Options options) {\n    vec2 c = frame_map(fragCoord, options);\n    \n    Real i = Real(iterations(c, options.max_iter));\n    vec3 col;\n    \n    if (i == -1.0) {\n    \tcol = vec3(0);\n    } else {\n#if ALT_COLORS\n        col = vec3(\n            sin((i / COLOR_SCALE)),\n            sin(i / (2.0 * COLOR_SCALE)) / 2.0,\n            sin((i / COLOR_SCALE))\n            //COLOR_SCALE - (i / COLOR_SCALE)\n        );\n#else\n        col = vec3(\n            (sin(1.0/log(i)) + sin((i / COLOR_SCALE))) / 2.0,\n            (0.5 * sin(1.0/log2(i)) + sin(i / (2.0 * COLOR_SCALE)) / 2.0) / 2.0,\n            (sin(1.0/log(i)) + sin((i / COLOR_SCALE))) / 2.0\n        );\n#endif\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Options options;\n   \toptions.frame = iFrame;\n    \n    /*\n    Real angle = 0.026;\n\n    Real r = (1.0 - cos(angle)) / 2.0;\n\toptions.zoom_point = vec2(\n\t\tr * cos(angle) + 0.25,\n\t\tReal y = r * sin(angle)\n\t);\n\t*/\n    \n    options.zoom_point = vec2(-0.74529, 0.113075);\n    \n    options.max_iter = int(pow(1.0, Real(options.frame)) * MAX_ITER);\n    options.zoom_factor = 1.01;\n    \n    vec3 col = vec3(0);\n    col += color(fragCoord + vec2(0.0, 0.0), options);\n    \n    if (AA) {\n        col += color(fragCoord + vec2(0.5, 0.0), options);\n        col += color(fragCoord + vec2(0.0, 0.5), options);\n        col += color(fragCoord + vec2(0.5, 0.5), options);\n        if (AA_8X) {\n            col += color(fragCoord + vec2(0.25, 0.25), options);\n            col += color(fragCoord + vec2(0.75, 0.25), options);\n            col += color(fragCoord + vec2(0.25, 0.75), options);\n            col += color(fragCoord + vec2(0.75, 0.75), options);\n            col /= 8.0;\n        } else {\n            col /= 4.0;\n        }\n    }\n\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 495, 543, 543, 966], [977, 977, 1021, 1021, 1273], [1275, 1275, 1320, 1320, 1978], [1980, 1980, 2035, 2035, 3119]]}
{"id": "wtBXRd", "name": "tela de lsd", "author": "lucastakejame", "description": "pra bruna fica feliz", "tags": ["2d", "lsd"], "likes": 3, "viewed": 95, "published": "Public", "date": "1566792228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define SIN(t) (.5*sin(t)+.5)\n#define COS(t) (.5*cos(t)+.5)\n#define ss(a,b,c) smoothstep(a,b,c)\n\n\nfloat spiral(vec2 puv, int iter, float thick)\n{\n    float sp = length( puv.x - puv.y);\n    float movableRef = puv.y;\n    \n    \n\t// after 2.*pi\n    for(int i = 0; i < iter; i++)\n    {\n        movableRef = movableRef + 2.*PI;\n    \tsp = min(sp, length(puv.x - movableRef ));    \n    }\n    \n    // before 0\n\tsp = min(sp, length(puv.x - puv.y + 2.*PI ));  \n\tsp = min(sp, length(puv.x - puv.y + 4.*PI ));  \n    \n    return ss(thick, 0., sp);\n}\n\nvec3 spiralRGB(vec2 puv, float thick, float offset)\n{\n    int iter = 15;\n    vec2 scale = vec2(30.,1.);\n    vec2 offs = vec2(offset,0.);\n\t\n    puv *= scale;\n    \n\tfloat r = spiral(puv, iter, thick);\n    puv = puv + offs;\n\tfloat g = spiral(puv, iter, thick);\n    puv = puv + offs;    \n\tfloat b = spiral(puv, iter, thick);\n    \n    return vec3(r,g,b);\n}\n\nfloat radials(vec2 puv, float segments, float intensity,\n              float width, float power)\n{\n    // last value in interval\n    float end = 2.*PI/segments;\n    // angle mod\n    float puvM = mod(puv.y, end);\n    //normalize\n    puvM /= end;\n    // inverse\n    float puvMInv = 1.-puvM; \n    puvM = \t  pow(puvM, power);\n    puvMInv = pow(puvMInv, power);\n    float res =  intensity*ss(1. - width/2., 1., puvM);\n    res = (res + intensity*ss(1. - width/2., 1.,puvMInv));\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.y;\n\n    if(true)\n    {\n    \tvec2 save = uv;\n        float grid = 7.;\n    \tuv.x += (.0851*length(save))*sin(uv.y*grid + iTime);\n    \tuv.y += (.0851*length(save))*sin(uv.x*grid + iTime);\n    }\n    \n    vec2 puv = vec2(length(uv), atan(uv.y, uv.x));\n    \n    puv.x += radials(puv, 14., -0.21 + .05*sin(puv.y*(12.) + iTime),\n                     1., .5);\n    \n    // Rotation\n    puv.y += mod(iTime, 2.*PI) - PI;\n    \n    vec3 col = spiralRGB(puv,\n                         4.5 - .9*COS(1.5*iTime),\n                         .2 + SIN(iTime*2.) + 0.5*SIN(puv.x*10.));\n\n    // DEBUG Radials\n    //col = vec3(radials(puv, 10., 0.1, .9, .6));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 163, 163, 553], [555, 555, 608, 608, 906], [908, 908, 1006, 1036, 1397], [1399, 1399, 1456, 1506, 2299]]}
{"id": "wtBXWV", "name": "Pixelated ocean current", "author": "jarble", "description": "This is based on a simple hash function.", "tags": ["hash"], "likes": 4, "viewed": 401, "published": "Public API", "date": "1567104245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this function is from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 magnify(vec2 fragCoord,float mag){\n\treturn hash22(floor(fragCoord/pow(2.0,mag)));\n}\n\nvec2 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.0,mag),0)*iTime,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 color1 = vec2(0,0);\n    float maximum = 5.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0);\n    }\n    color1 /= maximum;\n    fragColor = vec4(0.0,color1,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 83, 83, 217], [219, 219, 258, 258, 307], [309, 309, 352, 352, 413], [415, 415, 472, 472, 686]]}
{"id": "Wtf3zl", "name": "spiral friend", "author": "netgrind", "description": "just a fun little spiral friend", "tags": ["spiral", "hypno"], "likes": 5, "viewed": 349, "published": "Public", "date": "1565722416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    float d = length(uv)*20.;\n    float a = atan(uv.y, uv.x);\n    col.r = smoothstep(0.1, .2, abs(mod(d+iTime, 2.)-1.));\n\tcol.g = col.r*floor(mod(d*.5+.5+iTime*.5, 2.));\n    float f = smoothstep(-.1, .1,sin(a*3.+(sin(iTime*.5)*2.)*d-iTime));\n    col.rg = mix(col.rg, 1.-col.rg, f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtf3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 519]]}
{"id": "wtjSDW", "name": "SolidAngle - distance", "author": "iq", "description": "Exact distance to a solid angle or cone/sphere intersection. Beware doing the max() of a cone and a sphere won't produce an exact euclidean distance. Based on [url=https://www.shadertoy.com/view/3l23RK]sdPie()[/url]. ", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives", "solidangle", "solidangle"], "likes": 8, "viewed": 1122, "published": "Public API", "date": "1565939719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact distance to a cone that intersects a sphere, or a\n// \"solid angle\". Beware doing the max() of a cone and a \n// sphere won't produce an exact euclidean distance.\n// Based on sdPie(): https://www.shadertoy.com/view/3l23RK\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float l = length(q) - ra;\n\tfloat m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat map( in vec3 pos )\n{\n    pos.y += 0.4;\n    pos.xy = (mat2(4,3,-3,4)/5.0)*pos.xy;\n    \n    return sdSolidAngle(pos, vec2(3,4)/5.0, 0.7 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjSDW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1455, 1501, 1547, 1547, 1717], [1719, 1719, 1745, 1745, 1863], [1865, 1929, 1961, 1961, 2200], [2220, 2220, 2277, 2302, 3823]]}
{"id": "wtjSRh", "name": "warlokkz - fence", "author": "warlokkz", "description": "fence", "tags": ["fence"], "likes": 1, "viewed": 57, "published": "Public", "date": "1565074587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct)\n{\n    return smoothstep(pct - 0.02, pct, st.y) -\n           smoothstep(pct, pct + 0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \tfloat y = smoothstep(0.1, 0.9, abs(sin(uv.x + iTime)));\n    vec3 color = vec3(y);\n    float pct = plot(uv, y);\n    color = pct * vec3(0.0, 1.0, 0.0);\n \n    for (int i = 2; i < 15; i += 1) {\n      float iFloat = float(i) / 10.0;\n        \n      float stp = smoothstep(iFloat, 1.0 - iFloat, sin(uv.x + iTime));\n      float plotted = plot(uv, stp);\n      \n      vec3 col = i % 2 == 0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0); \n      color += plotted * col;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 127], [129, 129, 186, 236, 817]]}
{"id": "wtjSRV", "name": "Jake The Dog", "author": "sfaer", "description": "A 2D animation of Jake's face from Adventure Time :)\n\n(update :  just saw spolsh version which is super duper cool : https://www.shadertoy.com/view/ls2Bzy)", "tags": ["2d", "face"], "likes": 5, "viewed": 87, "published": "Public", "date": "1566493528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AspectRatio  (iResolution.y / iResolution.x);\n\n#define SSTEP(a, b, x) smoothstep((a)-(x), (a)+(x), b)\n\n\nfloat inCircle(in vec2 pt, in float r) {\n    pt.y *= AspectRatio;\n    float dp = dot(pt, pt);\n    return SSTEP(dp, r*r, 0.0015*r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Background color;\n    vec3 bgColor = vec3(1.0, 0.7, 0.0);\n    \n    vec3 col = bgColor;\n    \n    float t = 12.0f + iTime;\n\n\t// Time variation\n    float vt1 = sin(0.25*t)*sin(-0.4*t);\n    float vt2 = 0.5*(1.0 + sin((2.5-0.05*vt1)*t));\n    float vt3 = sin(0.5*t);\n    \n    // Eyes\n    float eyeSpace = 0.17;\n    float eyeLevel = 0.7;\n    vec2 leftEyePos = uv - vec2(0.5 - eyeSpace, eyeLevel);\n    vec2 rightEyePos = uv - vec2(0.5 + eyeSpace, eyeLevel);\n    \n    vec3 backEyeColor = vec3(0.15, 0.15, 0.1);    \n    float backEyeRadius = 0.1;\n    float inLeftEye = inCircle(leftEyePos, backEyeRadius);\n    float inRightEye = inCircle(rightEyePos, backEyeRadius);\n    \n    // back (black) eyes with contour\n    col = mix(col, backEyeColor, inLeftEye + inCircle(leftEyePos, 1.05*backEyeRadius));\n    col = mix(col, backEyeColor, inRightEye + inCircle(rightEyePos, 1.05*backEyeRadius));\n    \n    // front (white) eyes\n    vec3 frontEyeColor = vec3(0.9, 0.9, 0.95);\n    float frontEyeSpace = (0.3 + mix(0.0, 0.2, vt1)) * backEyeRadius;\n    float frontEyeRadius = backEyeRadius - frontEyeSpace;\n    col = mix(col, frontEyeColor, inLeftEye * inCircle(leftEyePos - frontEyeSpace * vec2( vt1, 0.4 + vt3), frontEyeRadius));\n    col = mix(col, frontEyeColor, inRightEye * inCircle(rightEyePos - frontEyeSpace * vec2( vt1, 0.4 + vt3), frontEyeRadius));\n    \n    // shiny corner eyes\n    frontEyeSpace *= 1.5;\n    frontEyeRadius = mix(0.075, 0.75, abs(vt1)) * (backEyeRadius - frontEyeRadius);\n    col = mix(col, frontEyeColor, inLeftEye * inCircle(leftEyePos + frontEyeSpace * vec2(0.75, 1.0), frontEyeRadius));\n    col = mix(col, frontEyeColor, inRightEye * inCircle(rightEyePos + frontEyeSpace* vec2(0.75, 1.0), frontEyeRadius));\n    \n    // mouth\n    {\n        vec2 mouthPos = uv - vec2(0.5, 0.23 + 0.0125*vt2);\n        \n        vec2 pt = 2.0*mouthPos;\n        pt.y -= abs(sin(pt.x * pt.x * 2.5));\n        float d = dot(pt, pt);\n        \n        // contour\n        float insideMouth = SSTEP(d, 0.1025, 0.005);\n        col = mix( col, vec3(0.0), insideMouth);\n        // inside\n        insideMouth = SSTEP(d, 0.1, 0.005);\n        vec3 mouthColor = vec3( 0.3, 0.0, 0.05);\n        col = mix( col, mouthColor, insideMouth);\n\n    \n        // teeth\n        pt = 50.0*(mouthPos - vec2(0.0, 0.11));\n        \n        float d1 = 2.25 * (2.0*(fract(0.25*pt.x + 0.5)-0.5));\n        float d2 = 1.0 - sqrt(1.0 - 0.4*d1*d1);\n        \n        // curve teeth\n        d = d2 + 3.0*(1.0 - sqrt( 1.0 - 0.025*pt.x*pt.x ));\n        \n        float isTeeth = insideMouth * SSTEP(d, pt.y, 0.15);\n        vec3 teethColor = vec3(0.9, 0.85, 0.8);\n        col = mix(col, teethColor, isTeeth);\n     \n        // tongue\n        pt = (15.0 + 0.5*vt2)*(mouthPos - vec2(0.0, -0.125));\n        d = -pt.x * sqrt( 1.5 - 2.0*pt.x*pt.x );\n        float isTongue = insideMouth * SSTEP(pt.y, d, 0.05);\n        vec3 tongueColor = vec3(0.95, 0.4, 0.5);\n        col = mix(col, tongueColor, isTongue);\n    }\n    \n    // doodly noodle\n    {\n        vec2 doodleCenter = 1.0*(uv - vec2(0.5, 0.2));\n\n        vec2 pt = 20.0*doodleCenter;\n        float ds = 9.50 * sin(pt.x) / pt.x;\n\n        // inside\n        float ds_top = inCircle(doodleCenter, 0.28);\n        float ds_btm = 1.0 + pt.y - ds;\n        ds = min(smoothstep( 0.0, 0.15, ds_btm), ds_top);\n        col = mix( col, bgColor, ds);\n\n        // contour\n        ds_top -= inCircle(doodleCenter, 0.2788);\n        ds_btm = smoothstep(0.0, 0.05, ds_btm) - smoothstep(0.05, 0.25, ds_btm);\n\n        ds *= ds_btm + ds_top;\n        col = mix( col, 0.15 * bgColor, ds);\n\t}   \n    \n    // Truffle\n    vec3 truffleColor = vec3(0.2, 0.2, 0.15);\n    vec2 trufflePos = uv - vec2(0.5, eyeLevel - 1.5*backEyeRadius);\n    float truffleRadius = pow(abs(1.2*trufflePos.y), 14.0*trufflePos.y*trufflePos.y) * 0.08;\n    col = mix(col, truffleColor, inCircle( trufflePos, truffleRadius ));\n\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 153, 153, 245], [247, 247, 304, 354, 4329]]}
{"id": "WtjSRz", "name": "eye tired", "author": "DBBH", "description": "uv", "tags": ["firstpublic"], "likes": 1, "viewed": 393, "published": "Public API", "date": "1564814967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size=4.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv=uv*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    float d= length(uv);\n    uv*=fract(d+iTime);//cos(d+iTime);\n    \n    // Time varying\n    vec2 v=uv*size;\n    uv=fract(uv*size); \n    \n\tfloat x=mod(v.x,2.);\n    x=x-1.;\n    x=sign(x);\n    x=smoothstep(0.,1.,x);\n    float y=mod(v.y,2.);\n    y=y-1.;\n    y=sign(y);\n    y=smoothstep(0.,1.,y);\n    float l =(x+y)==0.?1.:0.;\n    float l2=(x+y)>1.?1.:0.;\n    // Output to screen\n    fragColor = vec4(l+l2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 628]]}
{"id": "wtjSzD", "name": "TapiocaDrive", "author": "Hirai_worthless", "description": "test", "tags": ["practice"], "likes": 5, "viewed": 187, "published": "Public", "date": "1565287236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\nfloat dist_1(vec2 p){\n\tfloat baseCircle = length(p) - 0.5;\n    float waveCircle = fract(length(p) - iTime/1.5) - 0.2;\n    float wave0 = p.y + 0.8 - 0.10 * cos(p.x * 5.0) * sin(iTime * 2.0);\n    float wave3 = p.y - 0.8 - 0.10 * cos(p.x * 5.0) * sin(iTime * 2.0);\n    return min(min(baseCircle,waveCircle),min(wave0,-wave3));\n    \n}\nfloat dist_2(vec2 p){\n    float result = 100000.0;\n    for(float xi = -3.0; xi < 3.0; xi += 0.1){\n        for(float yi = -3.0; yi < 3.0; yi += 0.1){\n            vec2 tmp = vec2(xi+fract(cos(yi * 3.0)*iTime / 4.),yi);\n        \tfloat r = 0.04 - max(dist_1(tmp),0.00);\n            result = min(result,circle(p,tmp,r));\n        }\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = dist_2(uv) > 0. ? vec3(94,191,140)/255. : vec3(58,37,34)/255.;\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 65], [66, 66, 87, 87, 396], [397, 397, 418, 418, 749], [750, 750, 807, 807, 1006]]}
{"id": "wtjXDy", "name": "Learning Raymarching 001", "author": "raphaelameaume", "description": "raymarching, learning", "tags": [], "likes": 2, "viewed": 59, "published": "Public", "date": "1567028291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubstraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n\n\nfloat map(in vec3 pos)\n{\t\n    vec3 sphereSpacing = vec3(4.0, 1.0, 5.0);\n    vec3 spherePos = vec3(0.5 * cos(iTime), 0.5 * sin(iTime), 0.);\n    spherePos = vec3(0.,-2.0, mod(iTime, 10.) - 10.);\n    vec3 q = mod(pos - spherePos, sphereSpacing) - 0.5 * sphereSpacing;\n    float sphere = sdSphere(q, 0.25);\n    \n    \n    vec3 boxPos = vec3(0.0, 0.0, 0.0);\n    vec3 boxSpacing = sphereSpacing;\n    vec3 qBox = mod(pos - boxPos, boxSpacing) - 0.5 * boxSpacing;\n    \n    float box = sdBox(qBox, vec3(0.2, 0.2, 0.2));\n                      \n    float d = opSmoothUnion(sphere, box, 0.3);          \n    \n    \n    float ground = pos.y - (-0.25);\n                      \n    \n    \n    return min(d, ground);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float limit = 30.0;\n    \n    for (int i=0; i <100; i++)\n    {\n    \tvec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if(h<0.001) break;\n        \n        \n        t += h;\n        \n        if (t > limit) break;\n    }\n    \n    if (t>limit) t = -1.0;\n    \n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2.0 * fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    ro.y = 3.0 + sin(iTime) * 2.0;\n    //ro.z += iTime * 10.;\n    vec3 rd = normalize(vec3(p, -1.5));\n\tvec3 col = vec3(0.6, 0.7, 0.9) - 0.5 * rd.y;\n    \n    vec3 fogColor = vec3(0.7, 0.7, 0.8);\n    \n    col = mix(col, fogColor, exp(-10.0*rd.y));\n    \n    float t = castRay(ro, rd);\n    \n    \n    if (t > 0.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        vec3 sunDir = normalize(vec3(0.8, 0.2, 0.2));\n        float sunDif = clamp(dot(nor, sunDir), 0.0, 1.0);\n        float skyDif = clamp(0.5 + 0.5 *dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float sunShadow = step(castRay(pos + nor*0.001, sunDir), 0.0);\n        float bounceDif = clamp(0.5 + 0.5 *dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        // main light\n        col = mate * vec3(7.0, 5.0, 3.0) * sunDif*sunShadow;\n        // sky light\n        col += mate * vec3(0.5, 0.8, 0.9) * skyDif;\n\t\t// bounce light\n        col += mate * vec3(0.7, 0.3, 0.2) * bounceDif;\n        \n    }\n    \n    col = pow(col, vec3(0.4545));\n                        \n                    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 181], [183, 183, 218, 218, 242], [244, 244, 296, 296, 395], [397, 397, 456, 456, 556], [558, 558, 617, 617, 716], [721, 721, 745, 745, 1418], [1420, 1420, 1450, 1450, 1654], [1656, 1656, 1692, 1692, 2009], [2012, 2012, 2069, 2120, 3401]]}
{"id": "wtjXRz", "name": "Soft Shades", "author": "MadcoreTom", "description": "Using a log ramp for light makes it appear softer, with less definition on the bright side.\nClick around to change colours", "tags": ["sphere"], "likes": 1, "viewed": 81, "published": "Public", "date": "1564881982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Based on shader by zavie https://www.shadertoy.com/view/XsfXDr\n\tfloat ratio = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(ratio, 1.) * (2. * fragCoord.xy / iResolution.xy - 1.);\n    vec3 n = vec3(uv, sqrt(1. - clamp(dot(uv, uv), 0., 1.)));\n    \n    // the rest is my code\n    \n    // pick A colour\n    vec4 col = vec4(0.9,0.2,0.5,1.0);\n    \n    if(iMouse.x > 0.5 * iResolution.x){\n        col = vec4(0.5,0.9,0.2,1.0);\n    } else if(iMouse.x > 0.4 * iResolution.x){\n        col = vec4(0.2,0.5,0.9,1.0);\n    } else if(iMouse.x > 0.3 * iResolution.x){\n        col = vec4(0.9,0.5,0.2,1.0);\n    } else if(iMouse.x > 0.2 * iResolution.x){\n        col = vec4(0.7,0.6,0.5,1.0);\n    }\n\n    \n    // light it\n    vec3 light = vec3(sin(iTime)*2.0,0.6,1.0);\n    if(n.z != 0.0) {\n        float d = dot(light,n);\n        // log\n        col *= max(0.15,log(d+1.2)*0.8+0.7);\n        // linear\n        //col *= max(0.15,(d+1.2)*0.8+0.7);\n    } else {\n        // Background is black\n        col = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 127, 1104]]}
{"id": "wtjXWw", "name": "Bloody Labyrinth", "author": "96logda", "description": "I did something wrong with the shadows and got a bug looking like blood on the floor.", "tags": ["fractal", "cubes", "menger", "reflections", "blood", "mengersponge"], "likes": 5, "viewed": 168, "published": "Public", "date": "1566147411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Copyright (c) 2019-08-18 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define true\t\t\t\t1\n#define false\t\t\t\t0\n\n#define PI 3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t350\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n     return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n     return p.y - height;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\n    p.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n    p.y  = mod(p.y + 1.0, 2.0) - 1.0;\n    \n    float d = sdRoundBox(p, vec3(0.5), 1.0);\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n\t\n    //....................................................................\n    // Based on https://www.iquilezles.org/www/articles/menger/menger.htm\n    //....................................................................\n    float s = 8.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 8.0;\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    //....................................................................\n    \n    vec4 ground = vec4(sdPlane(p, -0.05), -0.5, 0.0, 1.0);\n    res = opU(ground, res);\n    \n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; ++i)\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n            break;\n\t\t}\n        t += clamp(h, 0.0, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {   \n        const vec3 light1 = vec3(0.5, 0.5, -0.5);\n        vec3 pos = ro + res.x * rd;\n        vec3 baseColor = vec3(0.0);\n        if (res.y == -0.5)\n\t\t{           \n            baseColor = vec3(0.0, 1.0, 1.0);\n\t\t}\n        else if (res.y > 0.0)\n        {\n            baseColor = mix(vec3(0.0, 0.4, 0.6), vec3(0.0, 0.0, 0.0), res.y);\n        }\n        \n        vec3 ambient = vec3(0.2) * baseColor;\n        \n        vec3 normal = calcNormal(pos);\n        vec3 reflection = reflect(rd, normal);\n\n        float occ = res.y;\n        float shadow1 = softshadow(pos + 0.001 * normal, light1);\n\n        vec3 diffuse = baseColor * shadow1 * occ;\n\n        color = diffuse + ambient;\t\t\n        color += 0.8 * smoothstep(0.0, 0.1, reflection.y) * softshadow(pos + 0.1 * normal, reflection);\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(8.75, 1.0, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro);\n    ww.xz = rotate2D(ww.xz, -mouseXY.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    ro.x -= iTime * 0.05; //Camera movement\n\n    vec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 355, 391, 391, 504], [506, 506, 549, 549, 597], [599, 599, 636, 636, 664], [666, 666, 694, 694, 733], [735, 735, 756, 756, 1799], [1801, 1801, 1841, 1841, 2217], [2219, 2219, 2261, 2261, 2587], [2589, 2589, 2619, 2619, 2862], [2864, 2864, 2901, 2901, 3815], [3817, 3817, 3873, 3873, 4502]]}
{"id": "WtjXWy", "name": "Flowing fBM noise", "author": "hackpoetic", "description": "Playing with concepts from https://thebookofshaders.com/13/", "tags": ["noise"], "likes": 4, "viewed": 386, "published": "Public API", "date": "1566972055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 0.3;\n\nfloat cnoise(vec2 p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy * 2.;\n\t\n    float amp = 1.;\n    float freq = 2.;\n    float v = 0.;\n    for (int i = 0; i < 2; i++) {\n        v += amp * cnoise(freq * st + cnoise(st + vec2(-iTime, iTime) * speed));\n        st *= 2.;\n        amp *= .5;\n    }\n    \n    v = abs(v);\n    \n    // Output to screen\n    fragColor = vec4(vec3(v),1.0);\n}\n\n\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 106, 106, 457], [460, 901, 922, 922, 971], [973, 973, 995, 995, 1032], [1034, 1034, 1062, 1062, 1114], [1116, 1116, 1135, 1135, 1175], [1177, 1201, 1223, 1223, 2265]]}
{"id": "wtjXWz", "name": "Sliced Fractal", "author": "notargs", "description": "1 dimension repeat & slice based fractal", "tags": ["raymarching", "fractal"], "likes": 4, "viewed": 212, "published": "Public", "date": "1565648514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//====================================\n// Quaternion\n//====================================\nvec4 qmul(vec4 q1, vec4 q2) {\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t);\n}\n\nvec3 rotVec(vec3 v, vec4 r) {\n\tvec4 r_c = r * vec4(-1, -1, -1, 1);\n\treturn qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\n\nvec4 qaxis(float angle, vec3 axis) {\n\tfloat sn = sin(angle * 0.5);\n\tfloat cs = cos(angle * 0.5);\n\treturn vec4(axis * sn, cs);\n}\n\n//====================================\n// Distance functions\n//====================================\nfloat dist(vec3 pos)\n{\n    float d = 2.0 - length(pos.xy);\n    float scale = 1.0;\n    \n    for (int i = 0; i < 10; ++i)\n    {\n        vec3 p = mod(pos, 8.0) - 4.0;\n    \td = max(d, ((sin(iTime + float(i) * 0.3) * 1.5 + 1.0) - length(p.x)) / scale);\n        vec4 rot = qaxis(0.8, normalize(vec3(1, 1, 1)));\n        rot = qmul(rot, qaxis(iTime * 0.003 + float(i), vec3(0, 0, 1)));\n    \tpos = rotVec(pos, rot);\n        pos *= 1.2;\n        scale *= 1.2;\n    }\n    return d;\n}\n\n//====================================\n// Normal\n//====================================\nvec3 calcNormal(vec3 pos)\n{\n    vec2 ep = vec2(0.01, 0);\n    float d0 = dist(pos);\n    return normalize(vec3(\n        d0 - dist(pos - ep.xyy),\n        d0 - dist(pos - ep.yxy),\n        d0 - dist(pos - ep.yyx)\n    ));\n}\n\n//====================================\n// Color\n//====================================\nvec3 calcColor(vec2 uv)\n{\n    vec4 rot = qaxis(sin(iTime) * 0.1, vec3(1, 0, 0));\n    rot = qmul(rot, qaxis(sin(iTime * 0.8) * 0.1, vec3(0, 1, 0)));\n    rot = qmul(rot, qaxis(iTime * 0.5, vec3(0, 0, 1)));\n    vec3 lightDir = rotVec(normalize(vec3(1, 1, -1)), rot);\n    vec3 pos = vec3(0, 0, mod(iTime, 100.0) * 10.0);\n    vec3 dir = rotVec(normalize(vec3(uv, 1)), rot);\n    \n    for (int i = 0; i < 128; ++i)\n    {\n        float d = dist(pos);\n        if (d < 0.001)\n        {\n            vec3 albedo = vec3(1, 1, 0.5);\n            vec3 norm = calcNormal(pos);\n            float atten = max(0.0, dot(norm, lightDir));\n            float fog = float(i) / 128.0;\n            return mix(atten * albedo, vec3(1.0, 1.0, 1.0), fog);\n        }\n        pos += d * dir;\n    }\n    \n    return vec3(1, 1, 1);\n}\n\n//====================================\n// Entry point\n//====================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    fragColor = vec4(calcColor(uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 121, 121, 234], [236, 236, 265, 265, 348], [350, 350, 386, 386, 477], [479, 579, 601, 601, 1049], [1051, 1139, 1166, 1166, 1356], [1358, 1445, 1470, 1470, 2242], [2244, 2337, 2394, 2394, 2504]]}
{"id": "wtjXz1", "name": "IFS Practice 001", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 4, "viewed": 114, "published": "Public", "date": "1565111014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nmat2 genRot(float v){\n\treturn mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\nvec3 cellMod(vec3 p,vec3 c){\n    p.z = mod(p.z + c.z / 2.,c.z) - c.z/2.;\n\tp.x = mod(p.x + c.x / 2.,c.x) - c.x/2.;\n    p.y = mod(p.y + c.y / 2.,c.y) - c.y/2.;\n    return p;\n}\n\nfloat cube(vec3 p, vec3 o){\n\treturn max(\n    \tabs(p.x - o.x),\n        max(abs(p.y - o.y),\n            abs(p.z - o.z))\n    );\n}\n\nfloat map(vec3 p){\n\tfloat base = 100000.;\n    for(int i = 0; i < 5; i++){\n        base = min(base,max(cube(p,vec3(0.))-0.5,-(length(p)-0.6) ));\n    \tp.x = abs(p.x);\n        p.z = abs(p.z);\n        p.y = abs(p.y);\n        p.xy *= genRot(PI / 12.);        \n        p.yz *= genRot(PI / 12.);\n        p.zx *= genRot(PI / 12.);\n\n        p = (p - vec3(0.4)) * 2.0;\n    }\n    \n    return base;\n\n}\n\nconst float EPS = 0.001;\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\nvec4 trace (vec3 o, vec3 r){\n\tfloat t = 0.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 128; ++i){\n        p = o + r * t;\n        float d = map(p);\n        t += d * 0.15;\n    }\n    return vec4(getNormal(p),t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 R = iResolution,\n    r = normalize(vec3((2.*U - R.xy )/  R.y,1.2)),\n    o = vec3((1.5+ 0.5 * sin(iTime)) *sin(iTime),0.,(1.5+ 0.5 * sin(iTime))*-cos(iTime));\n    r.xz *= genRot(iTime);\n    vec4 data = trace(o,r);\n    vec3 n = vec3(data.xyz);\n    float t = data.w;\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    float tmp = sqrt(dot(n,r));\nvec3 fc = mix(vec3(0.5 - data.x,0.5 -data.y,0.5-data.z),vec3(0.),1.0 - fog);\n    //fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 90], [91, 91, 117, 117, 300], [301, 301, 329, 329, 474], [476, 476, 503, 503, 602], [604, 604, 622, 622, 993], [1020, 1020, 1044, 1044, 1296], [1298, 1298, 1326, 1326, 1526], [1529, 1529, 1578, 1628, 2132]]}
{"id": "wtjXz3", "name": "LiveCodingPractice007(1h)", "author": "Hirai_worthless", "description": "test", "tags": ["raymarching"], "likes": 3, "viewed": 93, "published": "Public", "date": "1566665409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159265;\nfloat sTime(float scale){\n\tfloat a = floor(iTime * scale);\n    float b = smoothstep(0.,1.,fract(iTime * scale));\n    return a + b;\n}\nmat2 genRot(float v){\n\t return mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec3 modC(vec3 p,vec3 b){\n\tp = (fract(p / b + 0.5)-0.5) * b;\n    return p;\n}\n\nfloat maxEx(vec3 p){\n\treturn max(p.x,max(p.y,p.z));\n}\n\nfloat map(vec3 p){\n    //p.xy = abs(p.xy);\n    float tmp = 2.;\n    p.xy += tmp/2.;\n    p = modC(p,vec3(tmp));\n    vec3 q = p;\n\tfloat sp = length(p) - 0.4;\n    sp = min(sp,length(p.yz) - 0.1);\n    sp = min(sp,length(p.xz) - 0.1);\n    sp = min(sp,length(p.xy) - 0.1);\n    \n    q.xy *= genRot(PI/4.);\n    q.xz *= genRot(iTime);\n    float cb = maxEx(abs(q)) - 0.5;\n    cb = max(cb, -(max(abs(q.x),abs(q.y)) - 0.25));\n    cb = max(cb, -(max(abs(q.x),abs(q.z)) - 0.25));\n    cb = max(cb, -(max(abs(q.z),abs(q.y)) - 0.25));\n\n    return mix(sp,cb,sin(fract(sTime(0.5)) * PI));\n}\nvec3 getNormal(vec3 p){\n\tvec3 x= dFdx(p);\n    vec3 y = dFdy(p);\n    return normalize(cross(x,y));\n}\n\nvec4 trace(vec3 o,vec3 r){\n    float t = 0.;\n    for(int i = 0; i < 96; i++){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    vec3 p = o + r * t;\n    vec3 n = getNormal(p);\n    return vec4(n,t);\n}\n\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    r.xz *= genRot(PI / 12.);\n    r.yz *= genRot(PI / 12.);\n\n    r.xy *= genRot(cos(sTime(0.125) * PI) * 0.75 * PI);\n    return r;\n}\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-2.5 + iTime * 4.);\n    return c;\n}\n\nvec3 getColor(vec3 o,vec3 r,vec4 d){\n\tfloat t = d.w;\n    vec3 n = d.xyz;\n    float a = dot(r,n);\n    vec3 bc = vec3(1. - a *0.75);\n    vec3 cc;\n    float at = atan(r.y/r.x) * 2.;\n    cc.x = sin(sTime(1.) + at);\n    cc.y = sin(sTime(1.) + at + PI  *2. / 3.);\n    cc.z = sin(sTime(1.) + at + PI * 4. / 3.);\n    cc = cc * 0.5 + 0.5;\n    vec3 p = o + r * t;\n    cc = fract((length(p.z) + iTime) / 2.) < 0.75 ? cc : vec3(1.);\n    bc *= cc * 1.5;\n\n    float fog = 1./(1. + t * t * 0.05);\n    bc = mix(bc,vec3(0.),1.-fog);\n    return vec3(bc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.x;\n\tvec3 o = cam();\n    vec3 r = ray(uv,1. * sin(iTime * 0.25));\n    vec4 d = trace(o,r);\n    // Time varying pixel color\n    vec3 col = getColor(o,r,d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 48, 48, 155], [156, 156, 177, 177, 224], [225, 225, 250, 250, 301], [303, 303, 323, 323, 356], [358, 358, 376, 400, 928], [929, 929, 952, 952, 1028], [1030, 1030, 1056, 1056, 1261], [1263, 1263, 1289, 1289, 1455], [1456, 1456, 1467, 1467, 1524], [1526, 1526, 1562, 1562, 2064], [2066, 2066, 2123, 2173, 2448]]}
{"id": "wtjXzW", "name": "maybeeeeee", "author": "lennyjpg", "description": "eeeeeee", "tags": ["eeeee"], "likes": 2, "viewed": 74, "published": "Public", "date": "1565272856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 u = fract(uv.xy*5.);\n    vec2 s = fract(uv.xy*10.+0.5);\n\n    u-=0.5;\n    vec2 g = iTime*0.2+floor(uv*5.);\n\n    float r = .7;\n    float angle = PI*0.25+floor(rand(floor(g))*5.)*PI*.5;      \n    u.x+=sin(angle)*r;\n    u.y+=cos(angle)*r;\n  \n    float d = length(u);\n \tfloat k = smoothstep(d,d*2.0,0.5);\n    k =fract(d*angle/11.1 - iTime*sin(angle*123.4)*0.1);\n    \n    k -= step(length(s-0.5),0.02);\n    k= floor(k+0.5);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 50, 50, 122], [124, 124, 181, 181, 677]]}
{"id": "WtlXDf", "name": "Tamby Infinite balls", "author": "TambakoJaguar", "description": "I don't know why, but I got a hard time figuring out how to combine the diffuse color, reflection and fog. But I think now I got it right.\nNothing special, but still funny.\nUse mouse to move around.", "tags": ["reflection", "mouse", "fog", "balls", "animation", "mod", "infinite", "fresnel"], "likes": 5, "viewed": 128, "published": "Public", "date": "1564945924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Golf Ball\" by Emmanuel Keller aka Tambako - August 2017\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float dist;\n};\n    \nLamp lamps[3];\n\n//#define testmode;\n\nvec3 campos = vec3(0., 0., 9.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 4.7;\n\nconst vec3 ambientColor = vec3(0.1);\nconst float ambientint = 0.16;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\nconst float normdelta = 0.0001;\nconst float maxdist = 100.;\n\nconst float fogdens = 0.012;\nconst float sr = 1.;\n#ifdef testmode\nconst float gridDist = 3.2;\nconst int nblamps = 1;\n#else\nconst float gridDist = 2.2;\nconst int nblamps = 3;\n#endif\n\nconst int nbref = 3;\nconst float ior = 4.2;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvec3 posr;\n\nfloat angle;\nfloat angle2;\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat hash2(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\nvec3 rotateVec2(vec3 posr, vec2 angle)\n{\n    posr = vec3(posr.x, posr.y*cos(angle.y) + posr.z*sin(angle.y), posr.y*sin(angle.y) - posr.z*cos(angle.y));\n    posr = vec3(posr.x*cos(angle.x) + posr.z*sin(angle.x), posr.y, posr.x*sin(angle.x) - posr.z*cos(angle.x)); \n    \n    return posr;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 posr2 = mod(pos + vec3(gridDist), gridDist*2.) - vec3(gridDist);\n    vec3 posr3 = floor(0.5/gridDist*(pos + vec3(gridDist))); \n    \n    return length(posr2) - sr*(1. + 0.3*cos(iTime*2.7 + 0.55*posr3.x + 0.55*posr3.y + 0.55*posr3.z));\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.8;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 130; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist;\n  \t}\n        \n  \treturn vec2(t, dist);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    #ifdef testmode\n    return vec3(0.7);\n    #else\n    posr = floor(0.5/gridDist*(pos + vec3(gridDist)));    \n    return vec3(hash2(posr), hash2(posr + vec3(15., 7., 9.)), hash2(posr + vec3(25., 17., 49.)));\n    #endif\n}\n\nvec3 getSkyColor(vec3 ray)\n{  \n    vec3 col;\n    col.r = 0.55*clamp(0.2-ray.z, 0., 1.);\n    col.g = 0.8*clamp(0.4-ray.z, 0., 1.);\n    col.b = clamp(1.-ray.z, 0., 1.);\n    \n    col = mix (col, vec3(1.), 0.02*pow(max(0., dot(ray, vec3(0.2, 0.2, -1.))), 120.));\n    \n    return col;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tpos-= campos;\n    \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<nblamps; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n       col = getSkyColor(ray);\n    \n  return RenderData(col, pos, norm, tx);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   #ifdef testmode\n   return 1.;\n   #else\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n   #endif\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-2., 4.5, 1.), vec3(1., 1., 1.), 4.8, 0.08);\n  lamps[1] = Lamp(vec3(9., -2.5, 4.), vec3(0.77, 0.87, 1.0), 5.1, 0.1);\n  lamps[2] = Lamp(vec3(-9., -5., -4.), vec3(1.0, 0.6, 0.5), 3.6, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n    \n  float dist = traceinf.dist;     \n    \n  vec3 refray;\n  float rf = fresnel(ray, traceinf.norm, ior);\n    \n  float fogdens2 = fogdens*(0.7 + 2.3*noise(ray*8. + vec3(0.4*iTime)));\n   \n  float fogd = clamp(exp(-pow(fogdens2*dist, 2.)), 0., 1.);\n  vec3 ray0 = ray;\n    \n  col = mix(getSkyColor(ray), traceinf.col, fogd*(1. - rf));\n  //col = traceinf.col;\n  \n for (int r=0; r<nbref+1; r++)\n  {\n      if (traceinf.dist<=maxdist)\n      {\n         refray = reflect(ray, traceinf.norm);\n         if (r<nbref)\n         {\n             RenderData traceinf_ref = trace0(traceinf.pos, refray);\n             rf*= fresnel(ray, traceinf.norm, ior);\n             \n             float fogd2 = clamp(exp(-pow(fogdens2*traceinf_ref.dist, 2.)), 0., 1.);             \n             col = vec3(mix(col, mix(getSkyColor(refray), traceinf_ref.col, fogd*fogd2), rf*fogd));\n             fogd*= fogd2;\n             \n             traceinf = traceinf_ref;\n             ray = refray;\n         }\n         else\n         {\n            rf*= fresnel(ray, traceinf.norm, ior);\n            col = mix(col, getSkyColor(refray), rf*fogd);\n         }\n      }\n  }\n    \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;    \n    \n   campos = rotateVec2(campos, vec2(5.*iMouse2.x/iResolution.x, 3.1*iMouse2.y/iResolution.y + 1.6));\n   camdir = camtarget - campos;   \n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlXDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[900, 1095, 1117, 1117, 1152], [1154, 1154, 1175, 1175, 1270], [1272, 1272, 1293, 1320, 1699], [1701, 1701, 1741, 1741, 1988], [1990, 1990, 2011, 2011, 2256], [2258, 2258, 2306, 2306, 2569], [2571, 2617, 2652, 2652, 2892], [2894, 2894, 2931, 2931, 3153], [3155, 3155, 3183, 3183, 3436], [3438, 3438, 3512, 3512, 3871], [3873, 3873, 3937, 3937, 4098], [4100, 4156, 4220, 4220, 4473], [4475, 4475, 4515, 4515, 4984], [4986, 5103, 5149, 5149, 5404], [5406, 5406, 5435, 5435, 7037], [7039, 7039, 7094, 7094, 7761]]}
{"id": "wtlXWS", "name": "psychedelic voxel tornade", "author": "takumifukasawa", "description": "psychedelic tornade box", "tags": ["raymarching", "tunnel", "wireframe", "color", "voxel", "palette", "psychedelic", "box"], "likes": 9, "viewed": 209, "published": "Public", "date": "1566466662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// # refs\n// ## repeat, mod, pmod\n// - https://qiita.com/kaneta1992/items/21149c78159bd27e0860#ifs%E3%81%AB%E3%82%88%E3%82%8B%E8%A4%87%E9%9B%91%E3%81%AA%E5%BD%A2%E7%8A%B6\n// - https://qiita.com/edo_m18/items/8c20c9c80d44e8b1dfe4#_reference-7c25132332209c2cd12e\n// - https://gam0022.net/blog/2017/03/02/raymarching-fold/\n// ## collor pallete\n// - https://www.shadertoy.com/view/ll2GD3\n// ## material mechanism\n// - https://www.shadertoy.com/view/ldlcRf\n// ## distance functions, fog ... \n// - http://www.iquilezles.org/www/index.htm\n//------------------------------------------------------------------------\n\nprecision highp float;\n\n#define EPS .0001\n#define PI 3.1415\n#define PI2 PI * 2.\n#define repeat(p, o) mod(p, o) - o * .5\n#define saturate(a) clamp(a, 0., 1.)\n\n// ref: https://www.shadertoy.com/view/ldlcRf\n#define TEST_MAT_LESS (a, b) a < (b + .1)\n#define TEST_MAT_GREATER (a, b) a > (b - .1)\n\nconst float stopThreshold = .0001;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \tfloat dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};  \n\n// init lights\nLight directionalLight;    \nLight pointLight;\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// ref: https://www.shadertoy.com/view/WllSDM\nfloat n3(vec3 p) {\n\tvec3 r = vec3(1, 99, 999);\n\tvec4 s = dot(floor(p), r) + vec4(0., r.yz, r.y + r.z);\n\tp = smoothstep(0., 1., fract(p));\n\tvec4 a = mix(fract(sin(s) * 5555.), fract(sin(s + 1.) * 5555.), p.x);\n\tvec2 b = mix(a.xz, a.yw, p.y);\n\treturn mix(b.x, b.y, p.z);\n}\n    \n// ref: https://www.shadertoy.com/view/ll2GD3\n// t: 0-1, a: contrast, b: brightness, c: times, d: offset\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\n// d1 subtract to d2\nfloat opSub(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat sdWireBox(vec3 p, float s, float b) {\n    float d = 0.;\n    float o = s + .5;\n    float i = s - b;\n    d = opSub(\n        sdBox(p, vec3(o, i, i)),\n        sdBox(p, vec3(s))\n    );\n    d = opSub(\n        sdBox(p, vec3(i, o, i)),\n\t\td\n    );\n    d = opSub(\n        sdBox(p, vec3(i, i, o)),\n\t\td\n    );\n        \n    return d;\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\nvec2 tunnel(vec3 p) {    \n    float d = 0.;\n    vec3 _p = p;\n    vec3 q = p;\n    float m = 0.;\n    \n    float scale = 2.6;\n    float scalePower = .6;\n    vec3 size = vec3(1.1);\n    \n    float repeatNum = 9.;\n\n    vec3 id = floor(_p / repeatNum);\n    \n    float openSpeed = mod(iTime * 1.8 + PI2 * .8, PI2);\n    \n    float border = .15 + sin(openSpeed) * .11;\n    \n    d = 100000.;\n    \n    vec2 obj = vec2(d, 1.);\n\n    _p.z = repeat(_p.z, .8);\n    \n\t_p.xy = pmod(_p.xy, 5.);\n\n    for(int i = 0; i < 2; i++) {\n        _p.y -= size.y;\n\n        p.xz *= rot(.08);\n        p.xy *= rot(mod(iTime * .8, PI2));\n        \n        float currentDist = 0.;\n        currentDist = sdWireBox(p, .22 * size.y, border * size.y);\n        \n\t\tvec2 currentObj = vec2(currentDist, float(i) + 1.);\n        m = minMat(obj, currentObj).y;\n        obj.x = min(obj.x, currentObj.x);\n        obj.y = m;\n\t\t\n        scale *= scalePower;\n        \n        p = _p;\n        size *= scale;\n    }\n    \n    return vec2(obj.x, m);\n}\n\n\nvec3 opTwist(vec3 p) {\n    float k = .75;\n    vec3 q = p;\n    q.xy *= rot(mod(k * p.z + iTime * .35, PI2));\n    return q;\n}\n\n\nvec2 scene(vec3 p) {\n    vec3 move = vec3(0., 0., -iTime) * 1.8;\n    vec2 d = vec2(0.);\n    vec3 _p = p + move;\n    _p = opTwist(_p);\n    d = tunnel(_p);\n    \n    return d;\n}\n\nmat3 camera(vec3 o, vec3 t, vec3 u) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, u);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \tvec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 64.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nfloat calcRim(float NoL, float NoE, float EoL, float eyeCoef, float lightCoef) {\n    float rimEyeCoef = pow(saturate(1. - saturate(NoE)), eyeCoef);\n    float rimLightCoef = pow(EoL, lightCoef);\n    float rim = saturate(rimEyeCoef * rimLightCoef);\n    return rim;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n    float NoL = dot(surface.normal, normalize(light.position));\n    float EoL = dot(\n        normalize(cameraPos - surface.position),\n        normalize(light.position - surface.position)\n    );\n    float NoE = dot(\n    \tnormalize(cameraPos - surface.position),\n        surface.normal\n    );\n    \n  \tfloat diffuseCoef = saturate(NoL);\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity;    \n    diffuse += calcRim(NoL, NoE, EoL, 4., 32.) * light.intensity * light.color;\n    \n    // specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.color * light.intensity);  \n    \n  \tlight.diffuse = diffuse;\n  \tlight.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n\tvec3 lightDir = normalize(light.position - surface.position);\n    float attenuation = saturate(1. / pow(distance(light.position, surface.position), 2.));\n    \n    float NoL = saturate(dot(surface.normal, lightDir));\n    float EoL = dot(\n        normalize(cameraPos - surface.position),\n        lightDir\n    );\n    float NoE = dot(\n    \tnormalize(cameraPos - surface.position),\n        surface.normal\n    );\n\n    float diffuseCoef = NoL;\n    vec3 diffuse = diffuseCoef * attenuation * light.color * light.intensity;\n    diffuse += calcRim(NoL, NoE, EoL, 4., 32.) * light.intensity * attenuation * light.color;    \n    \n    float specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n    vec3 specular = vec3(specularCoef * attenuation * light.color * light.intensity);\n        \n    light.diffuse = diffuse;\n    light.specular = specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos, vec3 rd) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n    calcDirectionalLight(directionalLight, surface, cameraPos);\n\tcalcPointLight(pointLight, surface, cameraPos);\n\n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;;\n    \n  \tvec3 ambient = vec3(1.) * .1;\n\n  \tcolor = surface.baseColor * (diffuse + specular + ambient);  \n  \n  \treturn color;\n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n  \tfloat fogAmount = 1. - exp(-distance * b);\n  \treturn mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 move = vec3(0., 0., -iTime) * 0.;\n    vec3 ro = vec3(cos(iTime * 1.9) * .03, sin(iTime * 1.6 + .4) * .05, -4.) + move;\n    vec3 target = vec3(cos(iTime * .9 + .2) * .3, sin(iTime * .5) * .3, -8.) + move/* + vec3(mouse * 1., 0.)*/;\n    \n    \n    float fov = 1.2;\n    \n    vec3 up = vec3(0., 1., 0.);\n    vec3 rd = camera(ro, target, up) * normalize(vec3(uv, fov));\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    vec2 result = vec2(0.);\n    for(int i = 0; i < 99; i++) {\n    \tresult = scene(ro + rd * depth);\n        dist = result.x;\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += result.x;\n    }   \n    \n    vec3 color = vec3(0.);\n   \n    vec3 position = ro + rd * depth;\n    vec3 normal = getNormal(position, .001);\n    \n    Surface surface;\n    surface.depth = depth;\n    surface.dist = dist;\n    surface.position = position;\n    surface.normal = normal;\n    surface.material = result.y;\n    \n\tvec3 sceneColor = vec3(0.);\n    \n    vec3 bgColor = vec3(.08,  .05, .09);\n \n\tdirectionalLight.position = vec3(0., 0., 1.);\n\tdirectionalLight.intensity = .5;\n\tdirectionalLight.color = vec3(.8, .8, 1.);\n\n\tpointLight.position = vec3(0., 0., -4.2) + move;\n\tpointLight.intensity = .4;\n\tpointLight.color = vec3(.8, .8, 1.);\n    \n    if(dist >= stopThreshold) {\n\t    // no hit\n        sceneColor = bgColor;\n    } else {\n\t    // hit\n\t    surface.baseColor = palette(\n            /*surface.position.x / 10.\n                + surface.position.y / 10.\n\t            + */(surface.position.z - iTime * 1.4) / 1.2,\n        \tvec3(.9),\n        \tvec3(.6),\n        \tvec3(.2),\n        \tvec3(.4, .9, 1.)    \n    \t);\n        sceneColor = lighting(surface, ro, rd);           \n    }\n\n    // fog\n    sceneColor = fog(sceneColor, depth, bgColor, .2);\n\t// vignet\n    sceneColor *= smoothstep(1.6, .35, length(uv.xy));\n    \n    fragColor = vec4(sceneColor, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1331, 1377, 1408, 1408, 1443], [1445, 1491, 1509, 1509, 1761], [1767, 1872, 1927, 1927, 1976], [1978, 1978, 1997, 1997, 2060], [2062, 2062, 2091, 2091, 2187], [2189, 2189, 2222, 2222, 2247], [2249, 2270, 2303, 2303, 2327], [2329, 2329, 2368, 2368, 2435], [2437, 2437, 2480, 2480, 2765], [2767, 2767, 2795, 2795, 2910], [2912, 2912, 2933, 2933, 3905], [3908, 3908, 3930, 3930, 4031], [4034, 4034, 4054, 4054, 4208], [4210, 4210, 4247, 4247, 4393], [4395, 4395, 4430, 4430, 4667], [4669, 4669, 4760, 4760, 5076], [5078, 5078, 5158, 5158, 5342], [5344, 5344, 5423, 5437, 6179], [6181, 6181, 6254, 6254, 7133], [7135, 7135, 7192, 7192, 7664], [7666, 7666, 7728, 7728, 7819], [7821, 7821, 7876, 7876, 9958]]}
{"id": "wtSSDz", "name": "Text Morph", "author": "xavierseb", "description": "Morph a string into another\nThe same idea could be extended to morph an entire page of text.", "tags": ["text", "font", "morph", "hardwriting"], "likes": 11, "viewed": 408, "published": "Public API", "date": "1565573163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// handwriting morphing, Xavierseb 2019\n\n// bezier control points coordinates (x0,x1,x2,x3) and (y0,y1,y2,y3)\n// font char is drawn by bezier spline with control points at (x0,y0),(x1,y1),(x2,y2),(x3,y3)\n// todo: add flip/rotate/mirror/skewitalic\n// vec4( start_point, control_point_1, control_point_2, end_point)\n#define a0_x vec4(.75,-1.32,-1.44,.75)\n#define a0_y vec4(.77,1.95,-2.28,-.59)\n#define a1_x vec4(.75,1.05,.32,1.)\n#define a1_y vec4(-.59,1.82,.78,-1.)\n#define b0_x vec4(-1.,.3,-1.66,-.8)\n#define b0_y vec4(.2,3.3,5.,-1.)\n#define b1_x vec4(-1.,.6,2.,-.8)\n#define b1_y vec4(.2,2.6,-1.6,-1.)\n#define c0_x vec4(.8,-.5,-2.1,.94)\n#define c0_y vec4(.8,1.8,-1.8,-.8)\n#define c1_x vec4(.7,-.5,-2.1,.94)\n#define c1_y vec4(.8,1.8,-1.8,-.8)\n#define d0_x vec4(.64,-.8,-1.8,.74)\n#define d0_y vec4(.78,1.9,-1.7,-.86)\n#define d1_x vec4(.74,1.3,-.63,1.)\n#define d1_y vec4(-.43,4.8,3.8,0.)\n#define e0_x vec4(-.8,2.8,-.65,-.8)\n#define e0_y vec4(0.,-.27,2.3,-.1)\n#define e1_x vec4(-.8,-.82,-.92,1.)\n#define e1_y vec4(-.1,-.32,-1.2,-1.)\n#define f0_x vec4(-.44,2.1,-1.,0.)\n#define f0_y vec4(.44,4.4,4.,-2.4)\n#define f1_x vec4(0.,.6,-1.24,.62)\n#define f1_y vec4(-2.4,1.28,.56,.6)\n#define g0_x vec4(.9,-.4,-2.3,.84)\n#define g0_y vec4(.34,2.4,-1.8,-.99)\n#define g1_x vec4(.9,1.,-1.,-.9)\n#define g1_y vec4(0.,-4.7,-3.5,-2.9)\n#define h0_x vec4(-1.,.9,-1.1,-.75)\n#define h0_y vec4(.43,4.5,3.4,-.5)\n#define h1_x vec4(-.75,-.24,.78,.94)\n#define h1_y vec4(-1.,3.7,-1.35,-1.)\n#define i0_x vec4(0.,-.14,-1.19,.64)\n#define i0_y vec4(.8,-.48,-1.07,-1.)\n#define i1_x vec4(-.05,.43,-.34,.07)\n#define i1_y vec4(2.88,2.71,2.67,2.86)\n#define j0_x vec4(0.,-.3,-1.,-.8)\n#define j0_y vec4(.5,-5.19,-1.7,-2.5)\n#define j1_x vec4(-.05,.43,-.34,.03)\n#define j1_y vec4(2.88,2.71,2.67,2.96)\n#define k0_x vec4(-.94,.58,-1.1,-.94)\n#define k0_y vec4(.6,4.35,3.6,-.7)\n#define k1_x vec4(.4,-2.4,.3,.8)\n#define k1_y vec4(.8,0.,0.,-1.)\n#define l0_x vec4(-.4,1.,.3,-.17)\n#define l0_y vec4(-.5,1.2,3.8,2.8)\n#define l1_x vec4(-.17,-.8,.38,.84)\n#define l1_y vec4(2.8,1.8,-1.,-.5)\n#define m0_x vec4(-.9,-.9,-.33,0.)\n#define m0_y vec4(-1.,.912,1.6,-.7)\n#define m1_x vec4(0.,.33,.9,.9)\n#define m1_y vec4(-.7,1.6,.912,-1.)\n#define n0_x vec4(-1.07,-.64,-.9,-.76)\n#define n0_y vec4(.35,.93,.85,-1.)\n#define n1_x vec4(-.75,-.9,.7,.94)\n#define n1_y vec4(-1.,.85,1.9,-1.)\n#define o0_x vec4(0.,-1.1,-1.1,0.)\n#define o0_y vec4(1.,.82,-.8,-1.)\n#define o1_x vec4(0.,1.1,1.1,0.)\n#define o1_y vec4(-1.,-.8,.82,1.)\n#define p0_x vec4(-1,-.43,-.58,-.73)\n#define p0_y vec4(.43,1.5,-1.9,-3.)\n#define p1_x vec4(-.7,.83,1.75,-.7)\n#define p1_y vec4(.8,1.9,-1.75,-.8)\n#define q0_x vec4(.7,-.83,-1.75,0.)\n#define q0_y vec4(.8,1.9,-1.75,-.8)\n#define q1_x vec4(.7,-.5,-.54,.93)\n#define q1_y vec4(.26,-2.7,-4.76,-2.5)\n#define r0_x vec4(-.88,-.28,-.43,-.5)\n#define r0_y vec4(.86,1.5,-.67,-1.)\n#define r1_x vec4(-.5,-.54,.22,.9)\n#define r1_y vec4(-1.,1.,1.,.8)\n#define s0_x vec4(.78,-.7,-1.5,0.)\n#define s0_y vec4(.88,1.34,.55,0.)\n#define s1_x vec4(0.,1.5,.67,-.9)\n#define s1_y vec4(0.,-.55,-1.35,-.8)\n#define t0_x vec4(-.55,.35,-1.37,.76)\n#define t0_y vec4(3.,1.16,-1.1,-1.)\n#define t1_x vec4(-1.,-.7,-1.4,.9)\n#define t1_y vec4(1.64,1.54,1.7,1.7)\n#define u0_x vec4(-.9,-1.1,1.,.72)\n#define u0_y vec4(.9,-1.6,-1.7,.9)\n#define u1_x vec4(.72,.7,1.,1.4)\n#define u1_y vec4(.9,-1.6,-1.,-.77)\n#define v0_x vec4(-1.,-.83,-.236,0.)\n#define v0_y vec4(.88,1.5,-.73,-1.)\n#define v1_x vec4(0.,1.55,-.25,1.)\n#define v1_y vec4(-1.,1.8,.9,.65)\n#define w0_x vec4(-.9,-1.2,-.33,0.)\n#define w0_y vec4(1.,-.912,-1.6,.7)\n#define w1_x vec4(0.,.33,.9,.9)\n#define w1_y vec4(.7,-1.6,-.912,1.)\n#define x0_x vec4(.83,.25,-.3,-1.)\n#define x0_y vec4(.95,.6,-.5,-1.)\n#define x1_x vec4(-.9,.48,-.43,1.)\n#define x1_y vec4(.87,.35,-.5,-1.)\n#define y0_x vec4(-.9,-.2,.9,.9)\n#define y0_y vec4(.9,-2.9,0.,.9)\n#define y1_x vec4(.9,-.37,-1.,-.9)\n#define y1_y vec4(.2,-4.7,-3.5,-2.9)\n#define z0_x vec4(-.9,1.1,1.3,0.)\n#define z0_y vec4(.9,.9,1.5,0.)\n#define z1_x vec4(0.,-1.3,-1.1,.9)\n#define z1_y vec4(0.,-1.5,-.9,-.9)\n\n#define love0_x vec4(0.,-.45,-2.,0.)*1.2\n#define love0_y vec4(.58,1.4,1.,-1.)*1.2\n#define love1_x vec4(0.,2.,.45,0.)*1.2\n#define love1_y vec4(-1.,1.,1.4,.58)*1.2\n#define qu0_x vec4(-.66,2.74,-.3,-.05)\n#define qu0_y vec4(2.9,3.35,1.6,.58)\n#define qu1_x vec4(-.05,.43,-.34,.03)\n#define qu1_y vec4(-.42,-.59,-.63,-.44)\n\n// include scale and translate of raw chars which are by default \n#define draw(a,b,c,d) a,b,c,d\n\n// combine x and y coordinates of 1st and 2nd curves needed to draw the char\n#define A draw(a0_x,a0_y,a1_x,a1_y),\n#define B draw(b0_x,b0_y,b1_x,b1_y),\n#define C draw(c0_x,c0_y,c1_x,c1_y),\n#define D draw(d0_x,d0_y,d1_x,d1_y),\n#define E draw(e0_x,e0_y,e1_x,e1_y),\n#define F draw(f0_x,f0_y,f1_x,f1_y),\n#define G draw(g0_x,g0_y,g1_x,g1_y),\n#define H draw(h0_x,h0_y,h1_x,h1_y),\n#define I draw(i0_x,i0_y,i1_x,i1_y),\n#define J draw(j0_x,j0_y,j1_x,j1_y),\n#define K draw(k0_x,k0_y,k1_x,k1_y),\n#define L draw(l0_x,l0_y,l1_x,l1_y),\n#define M draw(m0_x,m0_y,m1_x,m1_y),\n#define N draw(n0_x,n0_y,n1_x,n1_y),\n#define O draw(o0_x,o0_y,o1_x,o1_y),\n#define P draw(p0_x,p0_y,p1_x,p1_y),\n#define Q draw(q0_x,q0_y,q1_x,q1_y),\n#define R draw(r0_x,r0_y,r1_x,r1_y),\n#define S draw(s0_x,s0_y,s1_x,s1_y),\n#define T draw(t0_x,t0_y,t1_x,t1_y),\n#define U draw(u0_x,u0_y,u1_x,u1_y),\n#define V draw(v0_x,v0_y,v1_x,v1_y),\n#define W draw(w0_x,w0_y,w1_x,w1_y),\n#define X draw(x0_x,x0_y,x1_x,x1_y),\n#define Y draw(y0_x,y0_y,y1_x,y1_y),\n#define Z draw(z0_x,z0_y,z1_x,z1_y),\n#define _ draw(vec4(0),vec4(0),vec4(0),vec4(0)),\n#define QU draw(qu0_x,qu0_y,qu1_x,qu1_y),\n#define S_ draw(s0_x,s0_y*3.,s1_x,s1_y*3.),\n#define LL draw(love0_x,love0_y,love1_x,love1_y),\n#define SP draw(vec4(0.),vec4(10.),vec4(0.),vec4(10.)),\n#define F_ draw(vec4(-1.,-.75,-.5,0.),vec4(-3.,-2.8,-2.8,-3.),vec4(0.,.25,.75,1.),vec4(-3.,-3.1,-3.2,-3.)),\n#define G_ draw(vec4(-1.,-.75,-.5,0.),vec4(-3.,-3.,-3.,-3.),vec4(0.,.25,.75,1.),vec4(-3.,-3.,-3.,-3.)),\n#define XX draw(vec4(-1.4,-1.4,1.4,1.4),vec4(5.,6.,6.,5.),vec4(-1.4,-1.4,1.4,1.4),vec4(-5.,-6.,-6.,-5.)),\n#define END draw(vec4(0.),vec4(10.),vec4(0.),vec4(10.))\n\n// randomizing to emulate messy handwriting\n#define rnd(p) vec4(.22*fract(sin(p/1.1)*100000.0),.582*fract(sin(p/1.2)*100000.0),.582*fract(sin(p/1.3)*100000.0),.2*fract(sin(p/1.4)*100000.0))\n#define rnd1(p) vec4(.2*fract(sin(p/1.5)*100000.0),.5842*fract(sin(p/1.6)*100000.0),.5842*fract(sin(p/1.7)*100000.0),.2*fract(sin(p/1.8)*100000.0))\n\n// 2 bezier curves for each character, \n// e.g. for the letter a, \n// x coords of control points are vec4(.75,-1.32,-1.44,.75) = x-coords of curve first part of 'a', vec4(.77,1.95,-2.28,-.59) = x-coords of second curve to draw 'a'\n// y coords are vec4(.75,1.05,.32,1.), vec4(-.59,1.82,.78,-1.), ditto\n// note: combining mismatched letters can make other interesting shapes.\n// number of chars\n\n#define mat(t) mat4(cos(t),sin(t),0.,0.,-sin(t),cos(t),0.,0.,0.,0.,cos(t),sin(t),0.,0.,-sin(t),cos(t))\n\n#define LINES\n//#define DOTS\n\n#define speed 30\n// STEP .05 - .1\n#define STEP .07\n//#define widthInChars 10\n//#define iNumLines 5\n#define widthInChars 8\n#define iNumLines 7\nvec4 chars[] = vec4[ widthInChars * iNumLines *4 +4 ] ( \n    \n//  SP SP SP SP SP SP SP SP SP SP\n//  SP M O R P H SP SP SP SP\n//  SP M O R P H I N G SP \n//  SP T H E S E LL LL LL SP\n//  SP W O R D S SP LL SP SP\n    \n    M  O  R  P  H  I  N  G\n    M  E  L  T  I  N  G  LL\n    G_ G_ G_ G_ G_ G_ G_ LL\n    F_ F_ F_ F_ F_ F_ F_ SP\n    E  X  P  L  O  D  E  SP\n    XX XX XX XX XX XX XX SP\n    XX XX XX XX XX XX XX SP\n   \n    END\t\t\n);\n\nvec4 getPos(float t)\n{    \n    float t1 = 1.-t;   \n    return vec4(t1*t1*t1, 3.*t1*t1*t, 3.*t1*t*t, t*t*t);\n}\n\n#define THI .079\n\n#ifdef LINES\nfloat doSomething(int icharPos, int nextLine, vec2 p, float m) {\n    if( icharPos >=32*4 && icharPos<40*4) m =pow(m,.4);\n    mat4 My =         \n        transpose( mat4(\n        mix(chars[icharPos  ],chars[nextLine  ],m),\n        mix(chars[icharPos+1],chars[nextLine+1],m),\n   \t\tmix(chars[icharPos+2],chars[nextLine+2],m),\n        mix(chars[icharPos+3],chars[nextLine+3],m) ));\n    if( icharPos ==60||icharPos ==92) My *= (1.+.25*sin(6.28*sin(clamp(5.*m,0.,1.57))));\n    if( icharPos==4) My = mat(12.56*m)*My;\n    float d=10.;\n    for(float i1=0.; i1<1.-STEP; i1+=STEP) {\n        vec4 h0 = My*getPos(i1    );\n        vec4 h1 = My*getPos(i1+STEP);\n        float h = distance(h0.xy,h1.xy);\n        d = min(d,distance(p, h0.xy ));   \n        d = min(d,distance(p, h1.xy ));   \n        if(distance(p,h0.xy)<h+THI && distance(p,h1.xy)<h+THI) {\n            if(h1.x==h0.x) d=abs(p.y-h0.y);\n            else {\n            \tfloat f=(h1.y-h0.y)/(h1.x-h0.x);\n            \td = min(d, abs((p.y-h0.y-f*(p.x-h0.x))) / sqrt(1.+f*f));\n            }\n        }\n        h = distance(h0.zw,h1.zw);\n        d = min(d,distance(p, h0.zw ));   \n        d = min(d,distance(p, h1.zw ));   \n        if(distance(p,h0.zw)<h+THI && distance(p,h1.zw)<h+THI) {\n            if(h1.z==h0.z) d=abs(p.y-h0.w);\n            else {\n            \tfloat f=(h1.w-h0.w)/(h1.z-h0.z);\n            \td = min(d, abs((p.y-h0.w-f*(p.x-h0.z))) / sqrt(1.+f*f));\n            }\n        }        \n    }\n    return d;\n}  \n\n#else\n//DOTS\nfloat doSomething(int icharPos, int nextLine, vec2 p, float m) {\n    if( icharPos >=32*4 && icharPos<40*4) m =pow(m,.4);\n    mat4 My =         \n        transpose( mat4(\n        mix(chars[icharPos  ],chars[nextLine  ],m),\n        mix(chars[icharPos+1],chars[nextLine+1],m),\n   \t\tmix(chars[icharPos+2],chars[nextLine+2],m),\n        mix(chars[icharPos+3],chars[nextLine+3],m) ));\n    if( icharPos ==60||icharPos ==92) My *= (1.+.25*sin(6.28*sin(clamp(5.*m,0.,1.57))));\n    if( icharPos==4) My = mat(12.56*m)*My;\n    float d=10.;\n    for(float i1=0.0; i1<1.0; i1+=0.1) {\n        vec4 h0 = My*getPos(i1   );//,p.x);\n        vec4 h1 = My*getPos(i1+.1);\n        \n        d = min(d,distance(p, h0.xy ));   \n        // try to spread out dots\n        vec2 yd = h1.xy - h0.xy;\n        float y = length(yd)*10.;\n        yd /= y;        //yd = normalize(yd)/10.;\n        for(; y>0.; y--,h0.xy+=yd) \n            //if (d>.01) // uncomment when using thicker text\n                d=min(d,distance(p, h0.xy));\n        \n        d = min(d,distance(p, h0.zw ));   \n        yd = h1.zw - h0.zw;\n        y = length(yd)*10.;\n        yd /= y;\n       \tfor(; y>0.; y--, h0.zw+=yd)\n    \t    //if (d>.01) \n                d=min(d,distance(p, h0.zw));\n    }\n    return d;\n}  \n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   // if(iFrameRate<30.) discard;\n\n    const int numCharsX4 = chars.length() -4;\n    float fr = float((iFrame*speed)/10)/200.;\n    float m = fract(fr);\n   \n    int curLine = int(fr) % iNumLines;//(numCharsX4/(4*widthInChars));// (fr/A)%numLines;\n    vec2 p=((2.*fragCoord.xy-iResolution.xy)/iResolution.x +vec2(1.,0.))*float(widthInChars);\n    int xsav = int(p.x/2.);\n    p.x = mod(p.x,2.)-1.;\n    \n    int icharPos = ( xsav + curLine*widthInChars )*4;\n    int nextLine = icharPos+widthInChars*4;\n    if(nextLine>=numCharsX4) nextLine-=numCharsX4;\n    \n    float d = min(10., doSomething(icharPos,nextLine, p, m));\n         \n#define IMPROVED_DRAWING\n#ifdef IMPROVED_DRAWING\n\t#define ADJ_CHAR vec2(2.,0.)\n    if(xsav<widthInChars-1) \n        d = min(d, doSomething(icharPos+4, nextLine+4, p -ADJ_CHAR, m));\n       \n    if(xsav>0) \n        d = min(d, doSomething(icharPos-4, nextLine-4, p +ADJ_CHAR, m));\n#endif\n   \n\t//vec3 col = vec3(smoothstep(d,.1,.18));\n\tvec3 col = vec3((smoothstep(d,.06,.165)) + (1. - (smoothstep(d,.04,.06))));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6992, 7511, 7533, 7533, 7620], [10383, 10383, 10439, 10473, 11502]]}
{"id": "WtSSR1", "name": "skrolliparty 2019 invi amiga efx", "author": "visy", "description": "skrolliparty 2019 invi amiga efx full rez", "tags": ["amigascanlineeffect"], "likes": 3, "viewed": 101, "published": "Public", "date": "1564938644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int max_iterations = 16;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.0001;\nconst float clip_far = 10.0;\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec2 translate(vec2 pos, vec2 offset){\n\treturn pos - offset;\n}\n\nfloat circle(vec2 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat time = 0.0;\nvec2 screen_size;\nvec2 texcoord;\n\nfloat scene(vec2 pos) {\n\tfloat dist = 0.61+cos((time)*0.5)*0.6;\n\tfloat xr = 0.2;\n\tfloat yr = 0.4;\n\tfloat speed = (time)*0.4+pos.x+pos.y;\n\tfor (float i = 0.0; i < 16.0; i+=1.0) {\n\t\tvec2 circlePos = translate(pos, vec2(cos(i*0.1*speed)*xr, sin(i*0.1*speed)*yr));\n\t\tfloat scenedist = circle(circlePos*screen_size*0.0015, 0.1-i*0.005);\n\t\tdist = min(scenedist,dist);\n\t}\n\treturn 3.0-dist*screen_size.x*0.1;\n}\n\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat dist( vec3 p ) {\n    float d = sdBox( p, vec3(0.5) );\n    return d;\n}\n\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3(grad_step, 0.0, 0.0);\n\tconst vec3 dy = vec3(0.0, grad_step, 0.0);\n\tconst vec3 dz = vec3(0.0, 0.0, grad_step);\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist( pos + dx ) - dist(pos - dx),\n\t\t\tdist( pos + dy ) - dist(pos - dy),\n\t\t\tdist( pos + dz ) - dist(pos - dz)\t\t\t\n\t\t)\n\t);\n}\n\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    float d = 10000.0;\n    float dt = 0.0;\n    for ( int i = 0; i < 128; i++ ) {\n        vec3 v = o + dir * t;\n        d = dist( v );\n        if ( d < 0.001 ) {\n            break;\n        }\n        dt = min( abs(d), 0.1 );\n        t += dt;\n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    if ( d >= 0.001 ) {\n        return false;\n    }\n    \n    t -= dt;\n    for ( int i = 0; i < 4; i++ ) {\n        dt *= 0.5;\n        \n        vec3 v = o + dir * ( t + dt );\n        if ( dist( v ) >= 0.001 ) {\n            t += dt;\n        }\n    }\n    \n    depth = t;\n    n = normalize( gradient( o + dir * t ) );\n    return true;\n    \n    return true;\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvec4 colormap_hsv2rgb(float h, float s, float v) {\n\tfloat r = v;\n\tfloat g = v;\n\tfloat b = v;\n\tif (s > 0.0) {\n\t\th *= 6.0;\n\t\tint i = int(h);\n\t\tfloat f = h - float(i);\n\t\tif (i == 1) {\n\t\t\tr *= 1.0 - s * f;\n\t\t\tb *= 1.0 - s;\n\t\t} else if (i == 2) {\n\t\t\tr *= 1.0 - s;\n\t\t\tb *= 1.0 - s * (1.0 - f);\n\t\t} else if (i == 3) {\n\t\t\tr *= 1.0 - s;\n\t\t\tg *= 1.0 - s * f;\n\t\t} else if (i == 4) {\n\t\t\tr *= 1.0 - s * (1.0 - f);\n\t\t\tg *= 1.0 - s;\n\t\t} else if (i == 5) {\n\t\t\tg *= 1.0 - s;\n\t\t\tb *= 1.0 - s * f;\n\t\t} else {\n\t\t\tg *= 1.0 - s * (1.0 - f);\n\t\t\tb *= 1.0 - s;\n\t\t}\n\t}\n\treturn vec4(r, g, b, 1.0);\n}\n\nvec4 colormap(float x) {\n\tif (x < 0.0) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else if (1.0 < x) {\n\t\treturn vec4(0.0, 0.0, 0.0, 1.0);\n\t} else {\n\t\tfloat h = clamp(-9.42274071356572E-01 * x + 8.74326827903982E-01, 0.0, 1.0);\n\t\tfloat s = 1.0;\n\t\tfloat v = clamp(4.90125513855204E+00 * x + 9.18879034690780E-03, 0.0, 1.0);\n\t\treturn colormap_hsv2rgb(h, s, v);\n\t}\n}\n\nvec4 kuutio( in vec2 uv )\n{\n\tfloat zz = 35.;\n\t\n    float vv = sin(time*0.4);\n\tif (vv < 0.0) vv = 0.;\n\tzz+=vv*cos(time+sin(time*0.7*distance(texcoord.xy*0.1,vec2(0.5,0.5))))*8.;\n\tvec3 dir = ray_dir(zz, screen_size.xy, texcoord.xy*screen_size.xy );\n\t\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\tmat3 rot = rotationXY(vec2((time)*0.75,(time)*0.5));\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n    float depth = clip_far;\n\n    vec3 n = vec3( 0.0 );\n\tif ( !ray_marching( eye, dir, depth, n ) ) {\n        return vec4(1.0,1.0,1.0,0.0);\n\t}\n\t    \n    vec3 color = vec3(1.0-abs(cos((texcoord.y*screen_size.y*cos(time)*1.2*eye.xyz*cos(time*0.2*texcoord.y)*0.65)*0.01+abs(cos(depth*5.+time)*2.)*(0.05+sin(time*0.5)*0.03)*0.5)));\n\tcolor = clamp(color,0.0,1.0);\n    return vec4( pow( colormap(((color.x+color.y+color.z)/3.)*0.4).rgb+color, vec3(1.0/2.2) ), 1.0 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.xy -= 0.5;\n    \n    time = iTime+30.;\n    screen_size = iResolution.xy;\n    texcoord = fragCoord/iResolution.xy;\n\n\tfloat dist = scene(uv);\n\tvec4 col = vec4(cos(time*0.05)*100.5-dist, 10.5-dist, 1.8-dist, 1)*0.5;\n\tvec4 bg = 2.0-vec4(atan(uv.y*uv.x*32.0-(time)*0.5)-rand(uv*(time)*0.05))*4.;\n\tvec4 bg2 = vec4(1.0+0.7*cos(uv.y*uv.x*32.0-time*0.5)-rand(uv*(time)*0.0000005))*1.0;\n\n\tbg = -0.5*min(bg,-bg2);\n\tcol = min(col, bg*vec4(1.2,0.6+cos((time)*0.25+col.b)*0.2,1.2,1.0));\n\n\tvec4 k = kuutio(uv);\n\tif (k.a == 1.0) col = k; \n\n\tfragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 237, 237, 261], [263, 263, 300, 300, 332], [386, 386, 409, 409, 788], [790, 790, 810, 810, 879], [882, 882, 913, 913, 1000], [1001, 1001, 1023, 1023, 1076], [1078, 1078, 1105, 1105, 1391], [1393, 1393, 1465, 1465, 2141], [2143, 2143, 2191, 2191, 2367], [2369, 2369, 2400, 2400, 2556], [2559, 2559, 2609, 2609, 3131], [3133, 3133, 3157, 3157, 3491], [3493, 3493, 3520, 3520, 4331], [4335, 4335, 4393, 4393, 4980]]}
{"id": "wtSSRG", "name": "These are some planets", "author": "Yusef28", "description": "Based on solar system diagrams and having fun", "tags": ["2d", "circles", "planets", "solarsystem"], "likes": 6, "viewed": 145, "published": "Public", "date": "1566300822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define planetNum 15.\n\nfloat rnd(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.45262)))*43256.53);\n}\nmat2 rot(float a)\n{\n \treturn mat2 (cos(a), -sin(a), sin(a), cos(a));   \n}\n//unused\nfloat square(vec2 p, float ss, float b)\n{\n\tp = abs(p);\n\tfloat sq = max(p.x, p.y)-b; \n    return sq;\n}\n \nfloat S(vec2 p, float r, float i)\n{    \nfloat ss = 0.03;\n    //shift so it's not directly under\n        float rr = rnd(vec2(i, i+10.))*8.;\n        \n        float x = sin(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+4904.));\n        float y = cos(2.+iTime/8.*rr+rr);\n    \n    vec2 shift = 0.09*vec2(x, y)*i/10.;\n    float c = length(p+shift);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}    \n//rim lighting circle\nfloat R(vec2 p, float r, float i)\n{    \nfloat ss = 0.003;\n    //shift so it appears to be boucing off one side\n    float rr = rnd(vec2(i, i+10.))*8.;\n        \n        float x = sin(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+4904.));\n        float y = cos(2.+iTime/8.*rr+rr);\n    \n    vec2 shift = vec2(0.004)*vec2(x, y);   \n    float c = length(p-shift);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n} \n//used for the black inner circle\nfloat R2(vec2 p, float r)\n{    \nfloat ss = 0.003; \n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}   \n//circle used for both gold and red\nfloat circle(vec2 p, float r)\n{\n\tfloat ss = 0.004;\n    float c = length(p);\n    return 1.0-smoothstep(r-ss, r+ss, c);\n}\n\n//for gold rim texture\nfloat SIN(vec2 p, float r)\n{\n    \nfloat ss = 0.009;\n    float c = length(p);\n    return abs(sin(c*250.))*(1.0-smoothstep(r-ss, r+ss,c));\n}\n//unused\nfloat H(vec2 p, float r)\n{    \nfloat ss = 0.1;\n    float c = length(p);\n    return 1.0-c;//1.0-smoothstep(r-ss, r+ss, c);\n}\n\n//orbit lines\nfloat Nring(vec2 p, float r, float s)\n{\n    float ss = 0.007;\n     \n    \n    float c = length(p);\n    float c1 = 1.0-smoothstep(r-ss, r+ss, c);\n    float c2 = 1.0-smoothstep(r-ss, r+ss+s, c);\n return c2-c1;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st2 = uv;\n    uv = uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n\n    uv*=2.;\n    vec2 noMoveuv = uv;\n\n    //background color\n    vec3 col = vec3(0.9, 0.9, 0.8);\n    //init x shift\n    float x = 0.;\n    //init y shift\n    float y = 0.;\n    //init radius\n    float r = 0.5;\n    float n = 60.;\n    //num of circles (number of times through the loop)\n    float num = planetNum;//mod(n-ceil(iTime), n);//rnd(vec2(floor(iTime)))*100.+10.;\n    //some background movement\n    //uv.y+=sin(iTime)/50.;\n    //gold\n    vec3 gold  = vec3(215., 154., 15.)/255.;\n    //shading texture for the gold\n    float tx = vec3(texture(iChannel0, uv*rot(iTime/8.)/2.)).x+0.7;\n        \n    //texture for the red\n    float tx1 = vec3(texture(iChannel1, uv/2.)).x+0.3;\n\n    //background texture\n    float tx2 = vec3(texture(iChannel2, noMoveuv/2.)).x+0.3;\n\t//using background texture\n    col-=tx2/9.;    \n    //how spread out the circles are\n    float th = 2.+1.*abs(sin(iTime));\n        \n    // Time varying ring color\n    vec3 ringcolor = vec3(abs(sin(iTime/12.+0.9))+0.1, abs(cos(iTime/2.+0.5)), abs(fract(iTime/3.)-0.5)+0.2);//vec3(0.42, 0., 0.);\n    \n    //For loop for the lines. I tried to do this in the second loop but the \n    //lines of later calls overlapped planets of previous calls\n    for(float i = 0.0 ; i<num ; i++){\n    \t\n        col = mix(col, vec3(0.2)*tx, Nring(uv, i/num*2., 0.01));\n\n    }\n    for(float i = 0.0 ; i<num ; i++){\n        //circle shifed based on random offet based on index of for loop\n        float rr = rnd(vec2(i, i+10.))*8.;\n        \n        x = i*sin(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+4904.));\n        y = i*cos(2.+iTime/8.*rr+rr);//rnd(vec2(i, i+234.));\n        //radius changed based on for loop index\n        \n        r = rnd(vec2(i, i+10.))/2.*i/num*1.2+0.01;//*i/num*2. scales based on i so far circles are bigeer, as if it funnels down\n    \t//r = *i/num/2.; this would be complete05y non random scaling by just the distance from center (the loop num)\n        \n        \n        //uv = uv*rot(iTime/32.);\n        //shift and separationg for each circle\n        vec2 st=uv+vec2(x, y)/num*2.;\n    \t\n        tx1 = vec3(texture(iChannel1, st/2.)).x+0.3;\n    \t\n\n        //shadow circle\n        col = mix(col, vec3(0.0), S(st, r, i));\n       //rim lighting circle\n        col = mix(col, gold+0.4, R(st, r+0.005, i));\n\t\t//gold outer circle\n    \tcol = mix(col, gold, circle(st, r));\n      \t//sin gradient on outer circle\n        col-=SIN(st, r)/4.;\n        //another ring around the inner circle\n        col = mix(col, vec3(0.1)*tx1, R2(st,\n                                                      //radius made smaller by random offse based on for loop index\n                                                      r-0.08*rnd(vec2(i))));\n        \n        //colored inner circle                                   \n    \tcol = mix(col, ringcolor*tx1-vec3(.4, 0., 0.0)*(sin(i)+1.)/4., circle(st,\n                                                      //radius made smaller by random offse based on for loop index\n                                                      r-0.1*rnd(vec2(i))));\n    \t\n        \n\n    }\n    //vignette\n    float a = 0.9;\n    //col += max(0.1/pow(length(uv)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n     ///col += max(0.1/pow(length(uv)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    //col += (max(0.1/pow(length(uv)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n    col*= exp(1.0-length(uv)+0.2)/2.+0.3;\n    \n    \n    st2 *=  1.0 - st2.yx;\n    float vig = st2.x*st2.y*15.;\n    vig = pow(vig, 0.15);\n    //output\n    \n   // col = vec3(fbm(uv));// vec3(SINcircle(uv, 0.5));\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4ls3zs", "previewfilepath": "https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 109], [110, 110, 129, 129, 183], [184, 193, 234, 234, 294], [297, 297, 332, 332, 672], [677, 699, 734, 734, 1089], [1091, 1125, 1152, 1152, 1244], [1248, 1284, 1315, 1315, 1403], [1405, 1428, 1456, 1456, 1566], [1567, 1576, 1602, 1602, 1699], [1701, 1715, 1754, 1754, 1926], [1928, 1928, 1985, 2035, 5865]]}
{"id": "WtSSRR", "name": "Cold Amoebas", "author": "Mipmap", "description": "This is a tweak of the excellent and mesmerizing 'Flow of cells', with a cool palette and a few other variations.\n\n\n\n", "tags": ["2d", "animation", "curve", "organic", "cell", "art", "cold"], "likes": 1, "viewed": 310, "published": "Public API", "date": "1564706055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweak of sben's 'Flow of cells' (https://www.shadertoy.com/view/MlsGWX)\n#define FIELD 35.0\n#define HEIGHT 0.7\n#define ITERATION 2.\n#define TONE vec4(0.1,0.2,0.3,0)\n#define SPEED 0.4\n\nfloat eq(vec2 p,float t){\n\tfloat x = sin( p.y +cos(t+p.x*.2) ) * cos(p.x-t);\n\tx *= acos(x);\n\treturn - x * abs(x-.5) * p.x/p.y;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n\tvec4 X=O;\n\tvec2  p = FIELD*(U / iResolution.xy  +.5);\n\tfloat t = iTime*SPEED,i,\n         hs = 20.*(HEIGHT+cos(t)*.1),\n\t      x = eq(p,t), y = p.y-x;\n    \n\tfor(float i=0.; i<ITERATION; ++i)\n\t\tp.x *= 2.,\n        X = x + vec4(0, eq(p,t+i+1.), eq(p,t+i+2.) ,0),\n        x = X.z += X.y,\n        O += TONE / abs(y-X-hs);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 186, 211, 211, 314], [316, 316, 354, 354, 672]]}
{"id": "wtSSRW", "name": "korotkoe", "author": "foran", "description": "korotkoe", "tags": ["korotkoe"], "likes": 8, "viewed": 547, "published": "Public", "date": "1565167890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Zerothehero of Topopiccione\n// 25/jul/2012\n//@zerothehero: better formulas, visually improved\n// mod by mojovideotech\n// ======================================\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float di = 0.5772156649;\nconst float dh = 0.69314718;\nconst float twpi = 6.2831853;\n\t\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n \n{\n\tfloat t = iTime*12.;\n\tfloat tt = iTime*0.005;\n\tvec2 p = ((fragCoord.xy / iResolution.xy )-0.5)*27.;\n\tp.x *= iResolution.x/iResolution.y;\n\tfloat a=0.,b=0.,c=0.,d=0.,e=0.;\n\tfor (int i=-4; i<4; i++) {\n\t\tp = rotate2d(tt*-twpi)*p;\n\t\tfloat x = (p.x*di-p.y*dh*0.125);\n\t\tfloat y = (p.x*di*0.125+p.y*dh);\n\t\tc = (sin(x+t*(float(i))/18.0)+b+y+4.0);\n\t\td = (cos(y+t*(float(i))/20.0)+x+a+3.0);\n\t\te = (sin(y+t*(float(i))/17.5)+x-e+1.0);\n\t\ta -= .25/(c*c);\n\t\tb += .5/(d*d);\n\t\te += .125;\n\t}\n\tfragColor = vec4(log(-e+a+b-1.)/8.-0.2,log(-e-a-b-1.)/8.-0.2,log(e-a+b-1.)/5.-0.1, 1.0) ;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 302, 330, 330, 416], [417, 417, 473, 473, 1041]]}
{"id": "WtSSWD", "name": "Trippy ray marching", "author": "Feniks", "description": "movethe mouse to change parameters", "tags": ["fractal", "trippy", "march"], "likes": 2, "viewed": 79, "published": "Public", "date": "1565834730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n trippy; based on https://www.shadertoy.com/view/lt33z7\n\n */\n\nconst int MAX_MARCHING_STEPS = 10000; // decrease this if ur gpu cant handle it\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0; // decreasing this is also probably a good idea\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    \n    float distortion = iMouse.y / iResolution.y;\n    float x_mod = 4. + abs(p.x * 0.5 * distortion);\n    float y_mod = 4.  + abs(p.y * 0.5 * distortion) ;//+ p.y * p.y * 0.01;\n    float z_mod = 4.  + abs(p.z * 0.5 * distortion);//+ p.x * p.x * 0.01;\n    p = vec3(mod(p.x * p.x * 0.00 + p.x ,x_mod) - x_mod / 2., mod(p.y,y_mod) - y_mod / 2. , mod(p.z * p.z * 0.00 +p.z,z_mod) - z_mod / 2.);\n    vec3 f1 = vec3(0.,0.,0.5);\n    vec3 f2 = vec3(0.,0.,-0.5);\n    //return max(length(p - f1), length(p - f2)) -0.6;\n    \n    //return length(vec3(mod(p.x, 0.3), mod(p.y, 0.1), mod(p.z, 0.5))) + length(p) - 0.5;\n    \n    float amp = iMouse.x / iResolution.x / 6.0;\n    float shift = amp / 2.;\n    \n    float wd = mix(length(vec3(mod(p.x, amp) - shift, mod(p.y, amp)- shift, mod(p.z, amp)- shift)) , 0.0, abs(length(p) - 0.5)/ 10.0) + length(p) - 0.5; // sqrt(p.x * p.x + p.y * p.y + p.z*p.z)\n\tfloat ssd = length(p - vec3(0.1, 0.1, 0.1)) - 0.5;\n    return max(wd, ssd);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    \n    float rotAng = iTime / 10. - 0.*0.5 *3.141596;\n    return normalize(vec3(xy, -z) * mat3(cos(rotAng), 0.,sin(rotAng),0.,1.,0.,-sin(rotAng),0.,cos(rotAng)));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6.0*sin(iTime ), 0., 6.0*cos(iTime ));\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 373, 398, 398, 1365], [1367, 1607, 1641, 1641, 1678], [1680, 2101, 2192, 2192, 2498], [2513, 2767, 2832, 2832, 3093], [3095, 3184, 3213, 3213, 3523], [3525, 4017, 4157, 4157, 4747], [4749, 5119, 5204, 5204, 6004], [6007, 6007, 6064, 6064, 6759]]}
{"id": "wtSSWh", "name": "One function Perlin noise ", "author": "Artleet", "description": "Perlin noise as one function", "tags": ["noise", "perlin"], "likes": 9, "viewed": 222, "published": "Public", "date": "1565715504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n(vec2 u){\n    vec4 d=vec4(.106,5.574,7.728,3.994),q=u.xyxy,p=floor(q);\n    ++p.zw;\n    q-=p;\n    p=fract(p*d.xyxy);\n    d=p+d.wzwz;\n\td=p.xxzz*d.ywyw+p.ywyw*d.xxzz;\n    p=fract((p.xxzz+d)*(p.ywyw+d));\n    p=cos(p*=iTime+d)*q.xxzz+sin(p)*q.ywyw;\n    q*=q*(3.-2.*q);\n    //q=smoothstep(0.1,.9,q);\n    p=mix(p,p.zwzw,q.x);\n    return mix(p.x,p.y,q.y);\n}\nvoid mainImage(out vec4 o, in vec2 u){\n\to=vec4(n(u*7./iResolution.y)*.5+.5);\n}\n/*size hack (doesn't work on Safari and Edge)\n#define mainImage(o,u)\\\n\to=vec4(n(u*7./iResolution.y)*.5+.5)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 356], [357, 357, 395, 395, 435]]}
{"id": "WtSSWz", "name": "Theta", "author": "jahnertz", "description": "Playing around with uv transformations.", "tags": ["fisheye", "geometry"], "likes": 0, "viewed": 58, "published": "Public", "date": "1565517697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.14159265\n#endif\n\n#ifndef deg2rad\n#define deg2rad (PI/180.0)\n#endif\n\n\nconst vec4 cross_color = vec4(0.008,0.018,0.270,1.000);\n\n// Transformations\nvec2 rotate( vec2 uv, float degree ){\n  float theta = -degree * deg2rad;\n  return vec2( cos(theta) * uv.x - sin(theta) * uv.y,\n\t\t\t   sin(theta) * uv.x + cos(theta) * uv.y\n\t\t\t   );\n }\n\nvec2 blind_offset( vec2 uv, vec2 offset, float width ){\n  //vec2 fragCoord.xy = uv * iResolution;\n  if ( mod( uv.t * iResolution.t / width, 2.0 ) > 1.0 ) {\n\tuv *= offset;\n\t}\n  return uv;\n  }\n\nvec2 tile( vec2 uv, float tiles ){\n  return fract( uv * vec2( tiles ) - vec2( 0.5 ) );\n  }\n\n// Shapes\nvec4 draw_rect(float width, float height, vec2 uv, vec4 color) {\n  vec4 canvas = vec4(0.0);\n  if ( -width < uv.s && uv.s < width  ) {\n\tif ( -height < uv.t && uv.t < height ) {\n\t  canvas = color;\n\t  }\n    }\n  return canvas;\n  }\n\nvec4 draw_cross( float width, float height, vec2 uv, vec4 color) {\n  vec4 canvas = vec4(0.0);\n  vec4 rect1 = draw_rect( width, height / 2.0, uv, color );\n  vec4 rect2 = draw_rect( width, height / 2.0, rotate( uv, 90.0 ), color );\n  canvas = mix(rect1,rect2,rect2.a);\n  return canvas;\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord/iResolution.xy;\n  st -= vec2 (0.5);\n  st.x *= iResolution.x/iResolution.y;\n  st *= vec2( abs(cos(length( st ) * cos(iTime / 10.0) * 10.0)) ); //multiply by distance from center\n  st = rotate( st, iTime * 10.0 );\n  st = blind_offset( st, vec2( 0.01, 0.01), sqrt(length(st) - 0.25) * 10.0);\n  st = tile( st, 3.0 );\n  vec4 color = vec4( length(st)/2.0, ( 1.0 - length(st - vec2(0.5)) + (sin(iTime)-0.5)/2.0) * 0.7, 0.5, 1.0 );\n  st -= vec2 (0.5, 0.5);\n  st = rotate( st, iTime * -30.0 );\n  vec4 cros = draw_rect( 0.05 * (sin(iTime / 10.0) + 1.0), 0.5, st, cross_color);\n  color = mix( color, cros, cros.a );\n  fragColor = color;\n  }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 215, 252, 252, 397], [399, 399, 454, 496, 589], [591, 591, 625, 625, 681], [683, 693, 757, 757, 919], [921, 921, 987, 987, 1208], [1210, 1210, 1267, 1267, 1919]]}
{"id": "wtSSzt", "name": "kojdj_RaymarchingTest3", "author": "kojdj0811", "description": "Raymarching Test3", "tags": ["raymarching"], "likes": 1, "viewed": 76, "published": "Public", "date": "1566749400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846264338327950288\n#define SETP_MAX 100\n\n#define NEAR 0.01\n#define FAR 1000.0\n\n#define OFFSET_TO_NORMAL 0.001\n\n\n\nvec3 Background (vec2 uv) {\n    return vec3(0.0, 0.0, 0.0);\n    \n    uv.x -= iTime * 0.5 + sin(iTime * 0.2);\n    uv.y -= iTime * 0.1 + sin(iTime * 0.7);\n    \n\tfloat offsetR = sin(iTime * 2.0 + PI * 0.0);\n    float offsetG = sin(iTime * 2.0 + PI * 0.33333333) ;\n    float offsetB = sin(iTime * 2.0 + PI * 0.66666666) ;\n\n    vec3 col = vec3(abs(sin(uv.x * 50.0)) * offsetR,\n                    abs(sin(uv.x * 50.0 + PI * 0.33333333)) * offsetG,\n                    abs(sin(uv.x * 50.0 + PI * 0.66666666)) * offsetB) * 0.5 ;\n    \n    col += vec3(abs(sin(uv.y * 50.0)) ,\n                abs(sin(uv.y * 50.0 + PI * 0.33333333)),\n                abs(sin(uv.y * 50.0 + PI * 0.66666666))) * 0.5;\n    \n    return col;\n}\n\n\n\nfloat DstSphere (vec3 currentStep, vec3 origin, float radius) {\n\treturn length(origin - currentStep) - radius;\n}\n\n\nfloat DstPlane (vec3 currentStep, float height) {\n\treturn currentStep.y - height;\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\n\n\nfloat SmoothSubtraction (float a, float b, float u) {\n    float v = clamp(0.5 - 0.5 * (a + b) / u, 0.0, 1.0);\n\treturn mix(b, -a, v) + u * v * (1.0 - v);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n\nfloat World (vec3 currentStep) {\n    \n    float world = 0.0;\n\n    \n    \n    \n    float sphere0 = DstSphere (currentStep , vec3(-0.6, 0.3, 1.2 + 0.4 * sin(iTime * 1.1)), 0.6);\n    float sphere1 = DstSphere (currentStep , vec3(-0.6, 0.3, 2.5), 1.8);\n\n    float plane = DstPlane(currentStep, -0.8);\n\n    \n\n\n    float brick0 = sdRoundBox(currentStep + vec3(-1.9 + sin(iTime * 1.5), -0.5, -0.5), vec3(0.5, 0.5, 0.01), 0.2);\n\n\n    \n    \n    \n    world = SmoothSubtraction(sphere0, sphere1, 0.5);\n    world = min(plane, world);\n\n    //world = min(brick0, world);\n    world = smin(brick0, world, 1.1);\n\n\n\n    world = min(world, 1.0);\n\n    return world;\n}\n\n\n\nvec3 raymarching (vec3 origin, vec3 dir) {\n\tfloat dist = 0.0;\n    int currentStepCount = 0;\n\n    while(true) {\n        float world = World(origin + dir * dist);\n        dist += world;\n        \n        \n        if(dist >  FAR)\n            return vec3(0.0, 0.0, 0.0);\n        \n        if(world < NEAR || currentStepCount > SETP_MAX)\n            break;\n        \n        currentStepCount++;\n    }\n    \n    return dir * dist;\n}\n\n\nfloat GetShadow (vec3 origin, vec3 lightPos) {\n    vec3 dir = normalize(origin - lightPos);\n    return distance(raymarching(lightPos, dir), origin) < NEAR ? 1.0 : 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    \n    vec3 cameraPos = vec3(0.0, 0.0, -0.6);\n    vec3 cameraDir = vec3(0.0, 0.0, 0.0);\n    vec3 screen = vec3(uv, 0.0);\n    vec3 dir = normalize(screen - cameraPos);\n\n    \n    vec3 world0 = raymarching(cameraPos, dir);\n    vec3 depth = vec3(1.0, 1.0, 1.0) * distance(cameraPos, world0);\n\n    vec2 offsetToNormal = vec2(OFFSET_TO_NORMAL, 0);\n\tvec3 normal0 = normalize(\n        vec3(\n            World(world0 + offsetToNormal.xyy) - World(world0 - offsetToNormal.xyy),\n            World(world0 + offsetToNormal.yxy) - World(world0 - offsetToNormal.yxy),\n            World(world0 + offsetToNormal.yyx) - World(world0 - offsetToNormal.yyx)\n        )\n    );\n    \n    \n    \n    vec3 light0_pos = vec3(-2.0, 1.0, 2.0);\n    vec3 light0_color = vec3(1.0, 2.0, 1.0);\n\tfloat light0_intensity = 0.1;\n    \n    \n    \n    vec3 light1_pos = vec3(2.0, 1.0, 2.0);\n    vec3 light1_color = vec3(1.0, 1.0, 2.2);\n\tfloat light1_intensity = 0.3;\n\n    vec3 light2_pos = vec3(0.0, 1.0, 1.0);\n    vec3 light2_color = vec3(2.0, 1.0, 1.0);\n\tfloat light2_intensity = 0.3;\n    \n    \n    col = light0_intensity * light0_color * dot(normal0, normalize(light0_pos - world0));\n    col += light1_intensity * light1_color * dot(normal0, normalize(light1_pos - world0));\n    col += light2_intensity * light1_color * dot(normal0, normalize(light2_pos - world0));\n\n    //col = GetShadow(world0, light0_pos) == 0.0 ? col : vec3(0.0, 0.0, 0.0);\n    //col = clamp(col, 0.0, 1.0);\n\n    \n    \n    \n    //test\n    //col = vec3(world0);\n    col = depth / 6.0;\n    //col = vec3(normal0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 170, 170, 853], [857, 857, 920, 920, 969], [972, 972, 1021, 1021, 1055], [1059, 1059, 1104, 1104, 1195], [1197, 1197, 1228, 1228, 1315], [1321, 1321, 1374, 1374, 1475], [1477, 1477, 1518, 1518, 1611], [1613, 1613, 1658, 1658, 1805], [1808, 1808, 1840, 1840, 2454], [2458, 2458, 2500, 2500, 2880], [2883, 2883, 2929, 2929, 3052], [3056, 3056, 3113, 3113, 4828]]}
{"id": "wtSXD1", "name": "Vaporwave__0001", "author": "dreamur", "description": "Technically not the first vaporwave-esque scene I've tried, but I digress", "tags": ["skyline", "cityscape", "vaporwave"], "likes": 5, "viewed": 322, "published": "Public", "date": "1566698737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nstruct sceneObject\n{\n    float shadowBackLayer;\n    float buildingBackLayer;\n    float shadowFrontLayer;\n    float buildingFrontLayer;\n    float windowsBackLayer;\n\tfloat wReflectBackLayer;\n    float windowsFrontLayer;\n\tfloat wReflectFrontLayer;\n\n    float vaporGrid;\n};\n\nfloat random (in float x) { return fract(sin(x) * 1e4); }\nfloat random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\n\n// credit to @patriciogv from The Book of Shaders\n// https://thebookofshaders.com/edit.php#10/ikeda-04.frag\nfloat DeFrag(in vec2 _st)\n{\n\tvec2 tmpSpace = (_st / 2.0) - vec2(0.08, -0.09);\n    vec2 grid = vec2(100.0,50.);\n    tmpSpace *= grid;\n\n    vec2 ipos = floor(tmpSpace);\n\n    vec2 vel = floor(vec2(1.0));\n\n    float totalCells = grid.x * grid.y;\n    float t = mod(48.989 * max(grid.x, grid.y), totalCells);\n    vec2 head = vec2(mod(t, grid.x), floor(t / grid.x));\n\n    vec2 offset = vec2(0.0, 0.0);\n\n    float color = 1.0;\n    color *= step(grid.y - head.y, ipos.y);\n    color = clamp(color, 0.0, 1.0);\n    \n    color *= random(floor(tmpSpace + vel));    \n    color *= random( floor( 1.0 - color * sin( (iTime * color) / 3.0) ) );\n\n    color *= step(0.075, fract(tmpSpace.x + vel.x)) * step(0.2, fract(tmpSpace.y + vel.y));\n        \n\treturn color;\n}\n\nvec2 rotate( in vec2 _st, in float angle )\n{\n\treturn mat2( cos(angle * PI), -sin(angle * PI),\n                 sin(angle * PI), cos(angle * PI) ) * _st;\n}\n\nfloat rect( in vec2 _st, in vec2 xCoords, in vec2 yCoords)\n{\n    vec2 bl = step( vec2(xCoords.x, yCoords.x), _st );\n    vec2 tr = step( vec2(xCoords.y, yCoords.y), 1.0 - _st );\n\n\treturn bl.x * bl.y * tr.x * tr.y;\n}\n\nfloat vaporGrid(in vec2 _st)\n{\n    float vaporGrid     = 0.0;\n    vec2 lineDirection  = vec2(cos(PI), sin(PI));\n\n    vec2 tmpSpace       = _st;\n\n    if(tmpSpace.y < 1.0)\n        tmpSpace.y = mod(0.58 + tmpSpace.y, 1.0);\n    else tmpSpace.y = 1.0;\n        vaporGrid +=\n            1.0 - rect( (tmpSpace * vec2(0.35, 0.9)) - vec2(-0.2, -0.489), vec2(0.00001), vec2(0.490));\n\n    tmpSpace = _st - vec2(0.0, -0.025);\n    if(tmpSpace.y < 0.45)\n    {\n        float yVal \t= cos( (_st.y * 0.775) - 3.15 );     \n    \tfloat speed = ( iTime / (4.97 - yVal)) ;\n        tmpSpace.y \t= mod( speed * 0.94 + tmpSpace.y, 0.09);\n    }\n    else tmpSpace.y = 1.0;\n    vaporGrid *=\n        1.0 - rect( tmpSpace * vec2(0.35, 1.0) + vec2(0.2, 0.4925), vec2(0.00001), vec2(0.4985));\n\n    tmpSpace = 1.0 * _st;\n    tmpSpace -= vec2(0.85, -0.059);\n\n    for(int i = -6; i <= 6; i++)\n    {\n        float offsetAdjustMent = ( float(i)  / 8.5);\n\n        vec2 ts         = tmpSpace + vec2(clamp(0.45 - offsetAdjustMent, -90.0, 90.0), 0.0);\n        ts              -= 0.5;\n        ts              = rotate(ts, float(i) / 15.75);\n        ts              += 0.5;\n        float rectDF    = rect( ts + vec2(0.0, 0.5), vec2(0.4975), vec2(0.000001));\n        vaporGrid       = vaporGrid - (vaporGrid * rectDF);\n    }\n\n    return vaporGrid;\n}\n\n// by Inigo Quilez @iq \n// more info can be found here: http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + min( max(d.x, d.y), 0.0 );\n}\n\nfloat skyline(in vec2 _st, in float _inner_stretch, in float _outer_stretch, in float _shadow_factor)\n{\n    float rnd   \t= random(floor(_st.xx * 9.0 + vec2(_shadow_factor, _shadow_factor) ));\n    vec2 ra     \t= vec2(2.0, _inner_stretch + rnd);\n\n    return sign( sdBox(_st, ra + vec2(0.0, _shadow_factor / 5.0)) );\n}\n\nvec3 calculateFinalColor(sceneObject _scene, vec2 _st)\n{\n    vec3 color         = vec3(0.0);\n    vec3 gradient      = vec3(0.0);\n    float tmpDF        = 0.0;\n    \n    //************************** sky ******************     \n    if(_st.y >= 0.43) \t{ color \t= mix(vec3(0.0, 0.0, 0.7), vec3(0.0, 0.0, 0.0), _st.y - 0.10); }\n    else \t\t\t\t{ color \t= mix( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.7), _st.y + 0.15); }\n    \n\t//************************** back-layer ******************\n    tmpDF\t\t\t   = _scene.shadowBackLayer;\n    color\t\t\t   = mix(vec3(0.153, 0.153, 1.0), color, tmpDF);\n    gradient = vec3(0.0);\n     \n    if(_st.y < 0.43)\n    {\n        tmpDF\t\t   = abs( 0.025 - ( _st.y *  1.5) );\n        gradient       = mix(gradient, vec3(0.0, 0.0, 0.7), tmpDF);\n    }\n    color              = mix(gradient, color, _scene.buildingBackLayer);\n      \n\ttmpDF\t\t\t   =  1.0 - ( _scene.windowsBackLayer *  (1.0 - _scene.buildingBackLayer) );    \n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\n\tcolor              = mix(vec3(0.475, 0.325, 0.141), color, tmpDF);\n    \n    tmpDF              = 1.0 - (_scene.wReflectBackLayer - (_scene.buildingBackLayer * _scene.wReflectBackLayer));\n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\t\t\n\tcolor              = mix(vec3(0.0, 0.0, 0.4), color, tmpDF); \n    \n    //************************** front-layer ******************   \n    color\t\t\t   = mix(vec3(0.153, 0.153, 1.0), color, _scene.shadowFrontLayer);    \n    gradient\t\t   = vec3(0.0);\n    \n    \n    if(_st.y >= 0.43)\n    {\n        tmpDF\t\t   =  5.875 - ( _st.y *  2.325) - 0.6;\n        gradient       = mix(vec3(0.251, 0.356, 0.054), vec3(0.0), tmpDF);\n    }\n    else\n    {\n        tmpDF\t\t   = 0.5 - ( _st.y *  1.5) - 0.6;\n        gradient       = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.7), tmpDF);\n    }\n    color              = mix(gradient, color, _scene.buildingFrontLayer);\n    \n    tmpDF\t\t\t   =  1.0 - ( _scene.windowsFrontLayer *  (1.0 - _scene.buildingFrontLayer)  );    \n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\n    color              = mix(vec3(0.424, 0.565, 0.137), color, tmpDF);\n    \n    tmpDF              = 1.0 - (_scene.wReflectFrontLayer - (_scene.buildingFrontLayer * _scene.wReflectFrontLayer));\n\tcolor              = mix(vec3(0.0, 0.0, 0.0), color, tmpDF);\n    color              = mix(vec3(0.0, 0.0, 0.9), color, tmpDF);\n\n    //************************** grid ******************   \n    vec2 tmpCoord      = (gl_FragCoord.xy / iResolution.xy).y + vec2(0.0, -0.275);\n    gradient           = mix(vec3(0.0, 0.0, 0.75), vec3(0.0, 0.8, 0.7), tmpCoord.y * 7.0);\n    color              = mix(gradient, color, _scene.vaporGrid);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sceneObject scene;\n    vec3 color  = vec3(0.0, 0.0, 0.306);\n\n    vec2 st   = (fragCoord.xy / iResolution.xy);\n    st.x      *= iResolution.x / iResolution.y;\n    \n\n    vec2 buildingLocalSpace     = st * vec2(2.0, 2.35) - vec2(1.770 + sin(iTime / 4.0) / 6.0, 1.0);\t\n    scene.buildingBackLayer\t\t= skyline(buildingLocalSpace, 0.175, 0.8, 0.0);\n    scene.shadowBackLayer    \t= skyline(buildingLocalSpace, 0.176, 0.775, 0.075);\n    \n    buildingLocalSpace     \t\t= st * vec2(1.0, 2.82) - vec2(1.77 + sin(iTime / 4.0) / 5.85, 1.0);\n    scene.buildingFrontLayer    = skyline(buildingLocalSpace, 0.453, 0.875, 0.0);  \n    scene.shadowFrontLayer    \t= skyline(buildingLocalSpace, 0.453, 0.875, 0.05);\n\n    scene.vaporGrid             = vaporGrid(st - vec2(sin(iTime / 4.0) / 5.85, 0.0) );\n\n    vec2 defragSpace            = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    scene.windowsBackLayer      = DeFrag(defragSpace - vec2(-0.5 + sin(iTime / 4.0) / 6.0, 0.0));\n    scene.wReflectBackLayer     = DeFrag(defragSpace * vec2(1.0, -1.0) - vec2(-0.5 + sin(iTime / 4.0) / 6.0, 0.27));\n    \n    scene.windowsFrontLayer     = DeFrag(defragSpace - vec2(-1.77 + sin(iTime / 4.0) / 3.0, 0.0));\n    scene.wReflectFrontLayer    = DeFrag(defragSpace * vec2(1.0, -1.0) - vec2(-1.77 + sin(iTime / 4.0) / 3.0, 0.27));\n\n    fragColor = vec4( calculateFinalColor(scene, st), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 333, 333, 363], [364, 364, 392, 392, 465], [467, 575, 602, 602, 1320], [1322, 1322, 1366, 1366, 1476], [1478, 1478, 1538, 1538, 1692], [1694, 1694, 1724, 1724, 2996], [2998, 3129, 3166, 3166, 3257], [3259, 3259, 3362, 3362, 3574], [3576, 3576, 3632, 3632, 6274], [6276, 6276, 6333, 6333, 7728]]}
{"id": "wtSXR3", "name": "Vertical Sin Wave", "author": "draco_nite", "description": "I hope this is the beginning of something interesting I have in mind.", "tags": ["beginner"], "likes": 1, "viewed": 248, "published": "Public API", "date": "1566551971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t .005 // thickness as % of screen\n\nfloat clampSinTime(float x)\n{\n    return (sin(iTime + x) + 1.) / 2.;\n}\n\nfloat drawLine(float line, float limit)\n{\n    return step(line, limit + t) * step(limit - t, line);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float horzMov = clampSinTime(0.) * .1 + .4;\n    float vertSinCurve = uv.x - clampSinTime(uv.y * 7.5) * .1;\n    \n    float l = drawLine(horzMov, vertSinCurve);\n   \n    // Output to screen\n    fragColor = vec4(l);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 73, 114], [116, 116, 157, 157, 217], [219, 219, 276, 326, 589]]}
{"id": "WtSXRG", "name": "Pasta Spirograph", "author": "mosaic", "description": "The XOR function is from https://www.shadertoy.com/view/Xsc3WX  \nThis gave each rounded square some 3d shading, and a slight shadow on the layer below it.", "tags": ["2d"], "likes": 1, "viewed": 92, "published": "Public", "date": "1566276675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat csg_nand (float a, float b) {\n    return -max(a,b);\n}\n\n// join two NANDs together\nfloat csg_not (float x) {\n    return csg_nand(x, x);\n}\n\n// NOT(NAND(A,B))\nfloat csg_and (float a, float b) {\n    float o = csg_nand(a, b);\n    return csg_nand(o, o);\n}\n\n// aka A AND NOT B, NOT(NAND(A,NOT(B)))\nfloat csg_sub (float a, float b) {\n    float o = csg_nand(a, csg_nand(b, b));\n    return csg_nand(o, o);\n}\n\n// NAND(NOT(A),NOT(B))\nfloat csg_or (float a, float b) {\n    return csg_nand(\n        csg_nand(a,a),\n        csg_nand(b,b));\n}\n\n// NAND(NAND(A,NAND(A,B)),NAND(B,NAND(A,B)))\nfloat csg_xor (float a, float b) {\n    float o = csg_nand(a, b);\n    return csg_nand(\n        csg_nand(a, o),\n        csg_nand(b, o));\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p) - b;\n    return   abs(min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r)-r/3.;\n}\n\nfloat loop( in vec2 p, in vec2 b, in float r )\n{\n    float s = 0.0;\n    \n    for(float i = -8.0;i<7.0;i+=1.0)\n    {\n                \n        s=min(s,sdRoundBox(p*rotate2d(i*iTime/8.),b,r/i));\n        s=csg_xor(s,sdRoundBox(p*rotate2d(i*iTime/8.),b,r/i));\n            }\n\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec2 ra = vec2(0.5,.5);// + 0.3*cos( iTime + vec2(0.0,1.57) + 0.0 );\n\n\tfloat d = loop( p, ra, .2);\n\n    vec3 col = vec3(1.0) -pow(d,.1);//*vec3(0.1,0.4,0.7);\n    //vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\t//col *= 1.0 - exp(-2.0*abs(d));\n\t//col *= 0.8 + 0.2*cos(120.0*d);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\t//fragColor = mix(vec4(col,1.0),vec4(.9,.8,.0,.0),.4);\n    fragColor =vec4(1.)-(vec4(col,1.0))+vec4(.2,.2,.0,.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 60], [62, 89, 114, 114, 143], [145, 163, 197, 197, 256], [258, 298, 332, 332, 404], [406, 429, 462, 462, 532], [534, 579, 613, 613, 715], [717, 717, 745, 745, 831], [833, 833, 888, 888, 986], [988, 988, 1036, 1036, 1273], [1275, 1275, 1332, 1332, 1858]]}
{"id": "wtSXRh", "name": "fractNova", "author": "foran", "description": "fractNova", "tags": ["fractnova"], "likes": 6, "viewed": 107, "published": "Public", "date": "1564989981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// Fractal Soup - @P_Malin\n\nvec2 CircleInversion(vec2 vPos, vec2 vOrigin, float fRadius)\n{\n\tvec2 vOP = vPos - vOrigin;\n\n\tvOrigin = vOrigin - vOP * fRadius * fRadius / dot(vOP, vOP);\n\n\n        vOrigin.x += sin(vOrigin.x * 0.001) / cos(vOrigin.y * 0.001);\n        vOrigin.y += sin(vOrigin.x * 0.001) * cos(vOrigin.y * 0.001);\n\n        return vOrigin;\n}\n\nfloat Parabola( float x, float n )\n{\n\treturn pow( 3.0*x*(1.0-x), n );\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n//void main(void)\n{\n\tvec2 vPos = fragCoord.xy / iResolution.xy;\n\tvPos = vPos - 0.5;\n\n\tvPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 vScale = vec2(1.2);\n\tvec2 vOffset = vec2( sin(iTime * 0.123), atan(iTime * 0.0567));\n\n\tfloat l = 0.0;\n\tfloat minl = 10000.0;\n\n\tfor(int i=0; i<48; i++)\n\t{\n\t\tvPos.x = abs(vPos.x);\n\t\tvPos = vPos * vScale + vOffset;\n\n\t\tvPos = CircleInversion(vPos, vec2(0.5, 0.5), 0.9);\n\n\t\tl = length(vPos*vPos);\n\t\tminl = min(l, minl);\n\t}\n\n\n\tfloat t = 2.1 + iTime * 0.035;\n\tvec3 vBaseColour = normalize(vec3(sin(t * 1.790), sin(t * 1.345), sin(t * 1.123)) * 0.5 + 0.5);\n\n\t//vBaseColour = vec3(1.0, 0.15, 0.05);\n\n\tfloat fBrightness = 11.0;\n\n\tvec3 vColour = vBaseColour * l * l * fBrightness;\n\n\tminl = Parabola(minl, 5.0);\n\n\tvColour *= minl + 0.14;\n\n\tvColour = 1.0 - exp(-vColour);\n\tfragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 76, 138, 138, 398], [400, 400, 436, 436, 471], [472, 472, 544, 544, 1351]]}
{"id": "WtSXRK", "name": "Pasta Graph", "author": "mosaic", "description": "Linguine Spaghetti Fettuccine\nPause and drag mouse to recompose\nNo rays were marched in the making of this shader\n", "tags": ["2d"], "likes": 3, "viewed": 100, "published": "Public", "date": "1566342594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// To merge all pasta layers in to one, comment out line 35\n// To reverse the order of the pasta layers, replace line 30 with line 31\n\nfloat csg_nand (float a, float b) {\n    return -max(a,b);\n}\n\n// aka A AND NOT B, NOT(NAND(A,NOT(B)))\nfloat csg_sub (float a, float b) {\n    float o = csg_nand(a, csg_nand(b, b));\n    return csg_nand(o, o);\n}\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p) - b;\n    return   abs(min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r)-r/3.;\n}\n\nfloat loop( in vec2 p, in vec2 b, in float r )\n{\n    float s = 0.0;\n    \n    for(float i = 1.0;i<30.0;i+=1.0)\n    //for(float i = 30.0;i>1.0;i-=1.0)  // To reverse the order of the pasta layers, replace line above with this line   \n        \n    {\n        float m=sdRoundBox(p*rotate2d(i*iTime/50.+iMouse.x/8000.*i),i*b,r);  \n        s=min(s,m); // comment out this line to merge all layers in to one \n        s=csg_sub(s,m);\n            }\n\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec2 width_height = vec2(0.05,.05);// + 0.3*cos( iTime + vec2(0.0,1.57) + 0.0 );\n\n\tfloat d = loop( p, width_height, .1);\n\n    vec3 col = vec3(1.0) -pow(d,.1);//*vec3(0.1,0.4,0.7);\n    //vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\t//col *= 1.0 - exp(-2.0*abs(d));\n\t//col *= 0.8 + 0.2*cos(120.0*d);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\t//fragColor = mix(vec4(col,1.0),vec4(.9,.8,.0,.0),.4);\n    fragColor =vec4(1.)-(vec4(col,1.0))+vec4(.2,.2,.0,.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 170, 170, 194], [196, 236, 270, 270, 342], [345, 345, 373, 373, 459], [461, 461, 516, 516, 614], [616, 616, 664, 664, 1071], [1073, 1073, 1130, 1130, 1678]]}
{"id": "wtSXWc", "name": "Colors from Hexagons", "author": "gressettd", "description": "Playing with coloring hexagonal grid.", "tags": ["grid", "color", "hexagon"], "likes": 3, "viewed": 82, "published": "Public", "date": "1567286584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SQRT3 = 1.7320508075688772935274463415059; \nvec3 TRI30_60_90 = vec3(1.0, SQRT3, 2.0);\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\n\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\n// from http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat HexagonDistance(vec2 p, float r)\n{\n\tconst vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n\tp = abs(p);\n\tp -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n\tp -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n\treturn length(p)*sign(p.y);\n}\n\n\n// http://glslsandbox.com/e#43182.0\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 HexagonGridId(vec2 p, float scale)\n{\n    p *= scale;\n    \n    vec4 center = floor(\n        vec4(p, \n             p - vec2(0.5, 1.0)) / TRI30_60_90.xyxy) + 0.5;\n    \n    vec4 h = vec4(p - center.xy*TRI30_60_90.xy, p - (center.zw + 0.5)*TRI30_60_90.xy);\n    return \n        dot(h.xy, h.xy) < dot(h.zw, h.zw) ? \n        \tvec4(h.xy, center.xy) \n          : vec4(h.zw, center.zw + 9.73);\n\n}\n\n\nvec4 ComputeHexagonGridPattern(vec2 p, float scale, float ccScale)\n{\n    vec4 h = HexagonGridId(p, scale);\n    float hexScale = 1.0/scale;\n    \n    float edgeDistance =  HexagonDistance(h.xy,hexScale);\n    float topo = fract(edgeDistance * ccScale);\n    \n    \n    return vec4(edgeDistance, topo, h.z, h.w);\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= float(iResolution.y) / float(iResolution.x);\n    uv += vec2(cos(iTime*0.2) + iTime*0.1,iTime * 0.05);\n\n    vec4 cc = ComputeHexagonGridPattern(uv, 10.0, 10.0* (1.0 + 0.5*cos(iTime)));\n    \n    /*\n    vec4 bias = vec4(0.350,0.906,0.689,1.0);\n    vec4 scale = vec4(0.772,0.114,0.263,1.0);\n    vec4 freq = vec4(0.077,0.368,1.016,1.0);\n    vec4 phase = vec4(3.859,3.252,5.857,1.0);\n    */\n    \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n\n\n\tvec4 color;\n   \tcolor=ComputeWaveGradientRGB(Random2D(cc.zw), bias, scale, freq, phase);\n    color*=ComputeWaveGradientRGB(abs(cos(cc.x + cc.w + mod(iTime,10.0))), bias, scale, freq, phase);\n    color*=ComputeWaveGradientRGB(cc.y,bias,scale,freq,phase);\n    \n    \n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n        \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 127, 127, 163], [165, 165, 194, 194, 247], [251, 251, 275, 275, 490], [492, 575, 615, 615, 794], [797, 1058, 1099, 1099, 1448], [1451, 1451, 1519, 1519, 1759], [1761, 1761, 1845, 1845, 1949], [1961, 1961, 2018, 2068, 3029]]}
{"id": "WtSXzD", "name": "Test anti alias", "author": "edapx", "description": "I am trying to understand this antialias technique (on the upper part of the screen) used the first time by eiffie in a shader that unfortunately got lost (https://www.shadertoy.com/view/XsSXDt). It is used also here https://www.shadertoy.com/view/MdBSDt ", "tags": ["raymarching", "antialias"], "likes": 4, "viewed": 710, "published": "Public", "date": "1565165030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// AA technique from:\n// https://www.shadertoy.com/view/MdBSDt\n// https://www.shadertoy.com/view/4llGWM\n\n\nconst int MAX_MARCHING_STEPS = 64;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.00;\nconst float PI = 3.14159265359;\n\nfloat clampeddot(vec3 a, vec3 b){\n    return max(0.,dot(a, b));\n}\n\nvec3 lightDirection = vec3(1.0, 1.0, 1.0);\n\nvec2 rotate(vec2 pos, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n} \n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(vec3 pos){\n    pos.xy = rotate(pos.xy, sin(iTime) * PI/2. * 0.03);\n    float offset = 0.7;\n    float sph = sphere(pos, 15.);\n    // just a sphere\n    //return sph;\n\n    // domain repetition, more edges, antialias more visible\n    pos = opRep(pos, vec3(offset, offset, offset));\n\n    // test boxes\n    return sdBox(pos, vec3(0.1, 0.1, 0.1));\n\n    // test spheres\n    //return sphere(pos, .2);\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.2;\n    return clamp( clampeddot(normal, lightDirection) * ambient + ambient, 0.0, 1.0 );\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return clamp( pow(clampeddot(h, normal), specularityCoef), 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getColor(vec3 eye, vec3 dir,float dist){\n        vec3 collision = (eye += (dist*0.995) * dir );\n        vec3 normal = computeNormal(collision);\n        float diffLight = diffuse(normal);\n        float specLight = specular(normal, dir);\n\n        return (diffLight + specLight ) * vec3(0.2392, 0.8118, 0.9529);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(3.5, 3.0, 15.5);\n    vec3 ta = vec3( -0.5, -0.9, 0.5 );\n    mat3 camera = setCamera( eye, ta, 0.0 );\n    float fov = 0.2;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n\n    // bg\n    vec3 color = vec3(0.6784, 0.4118, 0.1059);\n\n    float depth = NEAR_CLIP;\n    float dist = EPSILON;\n    \n   // ANTIALIAS VARIABLES\n    float pix = 4.0/iResolution.x; // the size of a pixel\n    float od = dist;\n    float w = 1.8; // what is this variable for? It is a threshold, but why 1.8 and why w?\n    float s = 0.0; // what is this variable for?\n    vec4 stack = vec4(-1.0); // here 4 distance values are stored.\n    bool grab = true;\n    // END ANTIALIAS VARIABLES\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        dist = map(eye + depth * dir);\n        // ??\n        if (w > 1.0 && (od + dist < s)) {\n            s -= w*s;\n            w = 1.0;\n        } else {\n            // ??\n            s = dist * w;\n        \tif (dist <= od) grab = true;\n        \telse if (grab && stack.w < 0. && od < pix*(depth-od)) {\n                // stack.w contains now the new distance\n            \tstack.w = depth-od;\n                // the stack variable get updated and the new distance is pushed in\n                stack = stack.wxyz; \n            \tgrab = false;\n        \t}\n        \tif (dist < EPSILON || depth > FAR_CLIP) break;\n        }\n        od = dist;\n        depth += s; \n    }\n\n    if (dist < EPSILON) color = getColor(eye, dir, depth);\n\n    // AA just on the top part of the screen, to see the difference with non AA\n    if (uv.y > 0.) {\n        for (int i = 0; i < 4; ++i) {\n            // if the stored distance is less than 0, abort the loop.\n            if (stack[i] < 0.0) break;\n            // get the color for the collected distance stack[i]\n            // mix it with the color obtained in the previous loop iteration\n            dist = map(eye + stack[i]*dir);\n            color = mix(getColor(eye, dir, stack[i]), color, clamp(dist/(pix*stack[i]), 0.0, 1.0));\n        }\n    }\n    // separation line\n    if (uv.y < 0. && uv.y> -0.01) color = vec3(0.);\n    //vec3 debug = vec3(s);\n    //vec3 debug = vec3(od);\n    //gl_FragColor = vec4(clamp(debug,0.0,1.0) , 1.0);\n    \n    fragColor = vec4(clamp(color,0.0,1.0) , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 264, 297, 297, 329], [375, 375, 410, 410, 500], [503, 503, 533, 533, 624], [626, 626, 663, 663, 698], [700, 700, 729, 729, 758], [760, 760, 780, 780, 1163], [1165, 1165, 1194, 1194, 1408], [1410, 1410, 1437, 1437, 1550], [1552, 1552, 1590, 1590, 1737], [1739, 1739, 1790, 1790, 1979], [1981, 1981, 2026, 2026, 2296], [2298, 2298, 2355, 2355, 4706]]}
{"id": "WtSXzz", "name": "gerstner test", "author": "dagbrynildsentholander", "description": "gerstner test", "tags": ["raymarching", "gerstner"], "likes": 19, "viewed": 570, "published": "Public API", "date": "1564737184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\n\tprecision mediump float;\n#endif\n\n// resolution in pixels\nuniform vec2 resolution;\n\n//affine transformation matrix of eye in camera space\nuniform mat4 eye;\n\nfloat pi = 3.14159;\n\nvec3 lightdir = vec3(1,-.4,1);\nvec3 lightcol = vec3(1, .85, .8);\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*16.+p.y*6463.)*200.);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 id = floor(p*10.);\n    vec2 ld = fract(p*10.);\n    \n    ld = ld*ld*(3.-2.*ld);\n    \n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n    \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return bt;\n}\n\nfloat wave(vec3 p, float a, float wavelength, vec2 dir) \n{\ndir = normalize(dir) ;\nfloat k = 2.*pi/wavelength;\nfloat c = sqrt(9.8 / k);\nfloat f = k*(dot(dir, p.xz) -(iTime*c));\n\nreturn a*sin(f-2.*a*cos(f));\n} \n\nfloat map(vec3 p)\n{\n   float base = 0.;\n   base += wave(p,0.8, 40., vec2(1,1) );\n   base += wave(p, 0.6, 30., vec2(0.8,1)); \n   base += wave(p, 0.08, 20., vec2(1,.8));\n    base += wave(p, 0.08, 10., vec2(.9,.9));\n     base += wave(p, 0.03, 5., vec2(1,.9));\n    base += wave(p, 0.04, 8., vec2(1,.9));\n    base += .015*sin((p.x+p.z*.5) *1.);\n   base += .01*sin((p.z+p.x*.5) *2.);\n   base +=.003*sin((p.x+.8+p.z)*3.);\n   return base -p.y;\n}\n\nvec3 getNormal(vec3 position) {\n    vec3 e = vec3(0.03,0.0,0.0);\n\n    return -normalize(vec3(\n       map(position + e.xyz) - map(position - e.xyz),\n       map(position + e.yxz) - map(position - e.yxz),\n       map(position + e.yzx) - map(position - e.yzx)));\n} \n\nvec2 ray(vec3 ro, vec3 rd, float dt, float mind, float maxd) \n{\n   float i = mind;\n   //float wi = 0.;\n   float lastVal = 0.;\n   //float lastValW = 0.;\n   vec3 p = ro+rd*i;\n   \n   while(i < maxd) \n   {\n      float val = map(p);\n      //float valW = waterHeight(p);\n      if(val>0.0 )\n         return vec2(i-(abs(val)/(abs(val)+abs(lastVal)))*dt, 0.);\n         \n      i += dt;\n      //if(waterHeight(p)>0.0) \n         //wi+=dt;\n      p = ro + rd*i;\n      dt *= 1.02;\n      lastVal = val;\n      //lastValW = valW;\n   } \n   return vec2(80., 0.);\n} \n\nvec3 drawSky(vec3 ro, vec3 rd) \n{\n   vec3 base = mix(vec3(.75,.5,.55),vec3(.6,.62,.8),rd.y*2.);\n   base += vec3(.9,.3,.2)*clamp(pow(1.-rd.y, 3.)*dot(rd,-normalize(lightdir)),0.,1.);\n   float sunDot = clamp(dot(rd, -normalize(lightdir)), 0. ,1. );\n   base +=.2*sunDot*vec3(.8,.5,.45);\n   base +=.4*pow(sunDot,25.)*lightcol;\n   base += .5*pow(sunDot, 64.)*lightcol;\n   base += 10.*pow(sunDot, 512.)*lightcol;\n   base -=.3*pow(valueNoise(rd.xz/rd.y/30.), 5.) *clamp(rd.y*5.,0.,1.);\n   base -=.7*pow(valueNoise(rd.xz/rd.y/40.), 3.) *clamp(rd.y*5.,0.,1.);\n   return base;\n} \n\nvec3 drawWater(vec3 ro, vec3 rd, float d, float ud) \n{\n   vec3 p = ro + rd*d;\n   vec3 normal = getNormal(p);\n   vec3 reflCol = drawSky(p, reflect(rd, normal) );\n   vec3 base = mix(reflCol, mix(vec3(.15,.2,.4)*.5, vec3(.4,.7,.8), clamp((p.y/1.5+.5) * dot(-rd, lightdir) ,0.,1.)) ,pow(dot(rd, -normal),1.));\n  \n   return base;\n}\n\nvec3 drawLand(vec3 ro, vec3 rd, float d) \n{\n   vec3 p = ro + rd*d;\n   vec3 normal = getNormal(p);\n   vec3 reflCol = drawSky(p, reflect(rd, normal) );\n   vec3 base = vec3((dot(normal, -lightdir)+1.)/2.);\n  \n   return base;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\t vec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 eyep = vec3(sin(iMouse.x/iResolution.x*2.), iMouse.y/iResolution.y, cos(iMouse.x/iResolution.x*2.))*10.;//eye[3].xyz;\n  vec3 up = normalize(vec3(0, 1, 0));//eye[1].xyz;\n  vec3 forward = normalize(-eyep);//normalize(vec3(sin(iMouse.x/250.), 0, cos(iMouse.x/250.)));//eye[2].xyz;\n  vec3 right = -cross(forward, up);//eye[0].xyz;\n\n  //ray.direction = normalize(eye * vec4(uv.x,uv.y,-1.,1.)).xyz\n  vec3 rd = normalize(forward + ((right * uv.x) + (up * uv.y)));\n  vec3 ro = eyep;\n\n  vec2 rayResult = ray(ro, rd, 0.2, 0.5, 80.);\n  vec3 finalColor = mix(drawWater(ro, rd, rayResult.x, rayResult.y) , drawSky(ro, rd), pow(rayResult.x/80., 4.) ) ;\n  fragColor = vec4(finalColor.xyz, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 257, 278, 278, 327], [329, 329, 355, 355, 721], [723, 723, 781, 781, 930], [933, 933, 952, 952, 1370], [1372, 1372, 1403, 1403, 1631], [1634, 1634, 1697, 1697, 2178], [2181, 2181, 2214, 2214, 2749], [2752, 2752, 2806, 2806, 3078], [3080, 3080, 3123, 3123, 3303], [3305, 3305, 3361, 3361, 4149]]}
{"id": "XlycWK", "name": "The End of the Road", "author": "dreamur", "description": "Never finished this. Figured I might as well share what little has been done.", "tags": ["road", "sidewalk", "hopscotch"], "likes": 3, "viewed": 57, "published": "Public", "date": "1566671607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nvec2 perspective_project( in vec2 _st )\n{\n    float pct = 0.0;\n\t_st += vec2(-1.0, 0.0);\t\t\t\t\t\t// perspective\n    pct  = smoothstep( -2.5, 1.5, -_st.y );\t\n    _st /= pct; \n    \n    return _st;\n}\n\nfloat rect( in vec2 _st, in vec2 w, in vec2 h )\n{\n    vec2 bl = step( vec2(w.x, h.x),_st);       // bottom-left\n\tvec2 tr = step( vec2(w.y, h.y),1.0 - _st);   // top-right\n\treturn bl.x * bl.y * tr.x * tr.y;\n}\n\nfloat circle( in vec2 _st, in float radius, in float inner, in float outer )\n{\n\tvec2 dist = _st - vec2(0.5);\n    return 1.0 - smoothstep( radius * inner, radius * outer, dot(dist, dist) * 4.0 );  \n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat tk_baha(in vec2 st, in float c) {\n    float amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(st.x * frequency);\n    float t = 0.01 * (-iTime * 150.0);\n    y += sin(st.x + t * c)*2.5;\n    y *= amplitude * 0.06;\n    \n    return y;\n}\n\n// 2D Noise from Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 rotate( in vec2 _st, in float angle ) {\n\treturn mat2( cos(angle * PI), -sin(angle * PI),\n                 sin(angle * PI), cos(angle * PI) ) * _st;    \n}\n\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n// from \"The Book of Shaders\"\n//  Chapter 9: Patterns\n//  https://thebookofshaders.com/09/\nvec2 brickTile(vec2 _st, float _zoom) {\n    _st *= _zoom;\n    _st.x += step(1., mod(_st.y,2.0)) * 0.5;\n    return fract(_st);\n}\n\n// based off of lines() from \"The Book of Shaders\"\n//  https://thebookofshaders.com/edit.php#11/wood.frag\nfloat grafitti(in vec2 pos, float b) {\n    float scale = 10.0;\n    pos *= scale;    \n    return smoothstep(0.0, 1.25 + b * 0.5, abs((sin(pos.x*3.1415)+b*2.2)) * 0.25);\n}\n\n// https://thebookofshaders.com/06/\n// Also...\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ) { \n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat decay(in vec2 st, in float coef_x, in float coef_y)\n{\n    vec2 scalar = vec2(2.5 + noise(st * coef_x), 2.5 + noise(st * coef_y));\n    vec2 shift = vec2(2.6 + noise(st), -6.95 + noise(st) );\n    return rect( (rotate(st, 0.33) * scalar - shift), vec2(0.01), vec2(0.05) );\n}\n\nfloat hopscotch(in vec2 st)\n{\n    float pct = 0.0, res = 0.0;\n    for(int i = 0; i < 6; i++)\n    {\n        if(res == 0.6)\n        {\n            pct += rect( st - vec2(res, 0.1), vec2(0.4), vec2(0.4) );\n            pct -= rect( st - vec2(res, 0.1), vec2(0.415), vec2(0.415) );\n            pct += rect( st - vec2(res, -0.1), vec2(0.4), vec2(0.4) );\n            pct -= rect( st - vec2(res, -0.1), vec2(0.415), vec2(0.415) );    \n        }\n        else\n        {\n            pct += rect( st - vec2(res, 0.0), vec2(0.4), vec2(0.4) );\n            pct -= rect( st - vec2(res, 0.0), vec2(0.415), vec2(0.415) );\n        }\n\n        res += 0.2;\n    }\n    \n    return pct;\n}\n\nfloat seams(in vec2 st)\n{\n    float pct = 0.0, res = 0.0;\n    for(int i = 0; i < 5; i++)\n    {\n        pct += rect( (st * vec2(85.0, 7.75)) + vec2(14.5 - res, -0.6), vec2(0.175), vec2(0.05) );\n        res += 60.0 + clamp(float(i), 0.0, 1.0);\n    }\n    \n    st = perspective_project(st);\n    \n    res = 0.0;\n    for(int i = 0; i < 6; i++)\n    {\n        pct += rect( (st * vec2(60.0, 2.0)) + vec2(185.0 - res, -0.6), vec2(0.175), vec2(0.05) );\n        res += 70.0;\n    }\n    res = 0.0;\n    for(int i = 0; i < 5; i++)\n    {\n        pct += rect( (st * vec2(60.0, 1.0)) + vec2(140.0 - res, 1.35), vec2(0.175), vec2(0.05) );\n        res += 70.0;\n    }\n    \n    return pct;\n}\n    \nfloat lamp_shadow(in vec2 _st)\n{\n    float res = 0.0, pct = 0.0;\n    res = step(0.5, mod(iTime, 2.0) * mod(iTime, 3.5));\n    pct = rect( (_st * vec2(3.2, 0.35)) - vec2(4.65, 0.0945), vec2(0.2), vec2(0.05) ); \n\n    //tmp2_2 = tmp2;\t\t\t\t\t\t\t\t\t// perspective (for shadow bits)\n    _st = perspective_project(_st);\n    \n    pct += rect( (_st * vec2(2.0, 7.0)) + vec2(-1.55, -3.6), vec2(0.2), vec2(0.05));\n    pct += rect( (_st * vec2(1.2, 7.0)) - vec2(0.7, 2.70), vec2(0.2), vec2(0.05));\n    pct += rect( (_st * vec2(3.0, 4.35)) - vec2(2.70, 2.5), vec2(0.2), vec2(0.05));\n    \n    return pct * res;\n}\n\nfloat lamp(in vec2 _st)\n{\n    float pct = 0.0;\n    pct = rect( (_st * vec2(1.75, 12.0)) + vec2(-2.35, -2.7), vec2(0.2), vec2(0.05) );\n    pct += rect( (_st * vec2(2.5, 12.0)) + vec2(-3.58, -3.5), vec2(0.2), vec2(0.05) );\n    pct += rect( (_st * vec2(4.1, 0.35)) + vec2(-6.2, -0.078), vec2(0.2), vec2(0.05) );\n    return pct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n\n    st  \t-= 0.5;\n    st.x \t*= iResolution.x / iResolution.y;\n    st \t+= 0.5;\n    \n    float pct = 0.0, res = 0.0;\n    vec2 tmp2;\n    vec3 col = vec3(0.0, 0.059, 0.286), tmp3;\t\n    \n    tmp2 = st * 2.0 - 1.0;\n    tmp2 += vec2(1.0, 0.5);\n   \t\n    // brick wall + inlay\n    vec2 tmp2_2 = tmp2;\n    pct = rect( (tmp2_2 * vec2(0.25, 0.5)) + vec2(0.25, 0.0), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.765, 0.898, 0.831), pct );\n    tmp2_2 /= vec2(2.15,0.65) / 1.5;\n    tmp2_2 = brickTile(tmp2_2 - vec2(0.0, -0.08), 5.0);\n    pct *= rect(tmp2_2, vec2(0.0125), vec2(0.0375));\n    col = mix( col, vec3(0.427, 0.0, 0.0), pct );\n    \n    // grafitti 1  \n    tmp2_2 = tmp2;\n    tmp2_2 += tk_baha(tmp2, 4.1);\t\t// wind animation (for grafitti)\n    tmp2_2 -= tk_baha(tmp2_2, 4.1) / 2.0; \n    tmp3 = hsb2rgb(vec3(tmp2_2.x * 0.2 - 0.29, 1.0, tmp2_2.y)); \n    \n    tmp2_2 = vec2(0.85) - tmp2_2;\n    float r = length(tmp2_2)*2.0;\n    float a = atan(tmp2_2.y,tmp2_2.x);\n    float f = cos(a * 3.0);\n    \n    pct = circle(tmp2 - vec2(1.35, 0.5), noise(tmp2_2.yx * r - tmp2_2.y + a * a - f), 1.0, 2.00); \n    col = mix(col, tmp3, pct);\n    \n    // road\n\tfloat rd = rect( (tmp2 * vec2(0.25, 2.20)) + vec2(0.25, 0.76), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.039, 0.039, 0.039), rd );\n    \n    // sidewalk\n    pct = rect( (tmp2 * vec2(0.25, 2.80)) + vec2(0.25, -0.20), vec2(0.01), vec2(0.05) );\n    pct += rect( (tmp2 * vec2(0.25, 2.80)) + vec2(0.25, 1.85), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.345), pct );\n    pct = rect( (tmp2 * vec2(0.25, 8.0)) + vec2(0.25, -0.65), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.184), pct );\n       \n    // street lamp + shadow    \n    col = mix( col, vec3(0.0), lamp_shadow(tmp2));    \n    col = mix( col, vec3(0.075, 0.063, 0.0), lamp(tmp2) );   \n        \n    // lamp glow\n    res = step(0.5, mod(iTime, 2.0) * mod(iTime, 3.5));\n    pct\t= circle(tmp2 - vec2(1.25, 1.2), res, -2.65, 2.00);\n    col\t= mix(col, vec3(3.5), pct);\n    \n    tmp2_2 = tmp2;\n    \n    \n    tmp2 = perspective_project(tmp2); \n       \n    \n    // road-stripes\t\n    pct = 0.0;\n    res = 0.0;\n    pct += rect( (tmp2 * vec2(0.125, 14.0)) + vec2(0.5 - res, 2.2), vec2(0.01), vec2(0.05) );\n    pct += rect( (tmp2 * vec2(0.125, 14.0)) + vec2(0.5 - res, 3.4), vec2(0.01), vec2(0.05) );\n    col = mix( col, vec3(0.592, 0.765, 0.0), pct );\n    \n    // sidewalk seams    \n    col = mix( col, vec3(0.0), seams(tmp2_2) );\n    col = mix( col, vec3(0.0), 0.8 );\n    \n    \n    // starfield\n    pct = rd;\n    pct = decay(tmp2_2, 48.0, 32.0);\n    res = decay(tmp2_2 * vec2(1.0, 1.0) - vec2(0.15, 0.25), 10.0, 10.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(1.0, 1.0) - vec2(0.15, 0.25), 10.0, 10.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.7, 0.7) - vec2(-0.4, -0.25), 10.0, 10.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.35, 0.4) - vec2(-1.45, -0.10), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.35, 0.4) - vec2(-1.35, 0.1), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.56, 0.56) - vec2(-0.85, 0.25), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.75, 0.75) - vec2(-0.4, 0.35), 28.0, 94.0);\n    pct += res - pct * res;\n    res = decay(tmp2_2 * vec2(0.75, 0.75) - vec2(-0.50, 0.0), 10.0, 10.0);\n    pct += res - pct * res;\n    pct *= rd;\n    col = mix( col, vec3(0.0, 0.0, 0.421), pct);\n      \n    tmp2_2.x = random(tmp2 * 3512.0);\n    tmp2_2.y = random(tmp2 * 8461.0);\n    tmp2_2.x = pow(tmp2_2.x, 21.0);\n    tmp2_2.y = pow(tmp2_2.y, 16.0);\n       \n    pct *= tmp2_2.x * tmp2_2.y * sin((tmp2.x - 21.0 - (iTime / 3.85) + cos(tmp2.y * 14.0 + 31.0)) * 13.0);\n    col += pct;\n    \n    \n    \n    tmp2 += tk_baha(tmp2, 4.78);\t\t// wind animation\n    tmp2 -= tk_baha(tmp2, 2.78) / 1.5;   \t\n    \n    // hop scotch\n    tmp2 = (tmp2 * vec2(0.5, 1.1)) - vec2(-1.8, 0.10);    \n    col = mix(col, vec3(0.2), hopscotch(tmp2));\n    \n    // wind\n    tmp2_2 = vec2(st * 1.5 + vec2(3.0 - iTime * 2.5, 4.0));\n    pct = noise(tmp2_2);\n    col += vec3(pct) / 3.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlycWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 93, 93, 244], [246, 246, 295, 295, 453], [455, 455, 533, 533, 653], [655, 655, 682, 682, 799], [801, 801, 840, 840, 1048], [1050, 1133, 1159, 1159, 1492], [1494, 1494, 1538, 1538, 1652], [1654, 1654, 1682, 1682, 1764], [1766, 1857, 1896, 1896, 1984], [1986, 2092, 2130, 2130, 2261], [2263, 2384, 2411, 2411, 2572], [2574, 2574, 2633, 2633, 2851], [2853, 2853, 2882, 2882, 3515], [3517, 3517, 3542, 3542, 4185], [4191, 4191, 4223, 4223, 4784], [4786, 4786, 4811, 4811, 5112], [5114, 5114, 5171, 5171, 9348]]}
