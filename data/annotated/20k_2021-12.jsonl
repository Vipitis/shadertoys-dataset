{"id": "7dl3Rj", "name": "009_Oscillation_3", "author": "francislarge", "description": "P", "tags": ["playground"], "likes": 2, "viewed": 12, "published": "Public", "date": "1639366698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct FWave\n{\n    float AngleRange; //x axis range of graph\n    float Amplitude;  //y axis range of graph\n    float YOffset;\n    vec4 Color;\n};\n\nstruct FLight\n{\n    float Intensity;\n    vec4  Color;\n    vec2 Position;\n};\n\n\nfloat GetY(FWave Wave, float CurrentAngle_X);\nvec2 CalculateSlope(vec2 Point1, vec2 Point2);\nvec2 CalculateNormal(vec2 Slope);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    FWave Wave;\n    Wave.AngleRange = acos(-1.0) / 2.0 ;\n    Wave.Amplitude  = 0.5;\n    Wave.YOffset    = 0.0;\n    Wave.Color      = vec4(0.2, 0.9, 0.6, 1.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float AspectRatio = iResolution.x/iResolution.y;\n    \n    uv.x  = uv.x * 2.0 - 1.0;\n    uv.x *= AspectRatio;\n    \n    float XShift = iTime;\n    float CurrentAngle = (uv.x + XShift) * Wave.AngleRange;\n    float CurrentY  = GetY(Wave, CurrentAngle);\n    \n    vec2 CurrentPoint = vec2(uv.x, CurrentY); //FOR LATER\n    \n    CurrentY = (CurrentY + 1.0) / 2.0; //convert to 0 to 1 so we can easily select the pixels within range\n        \n    float Output_Based_On_Current_Y =  uv.y / CurrentY;\n    \n    Output_Based_On_Current_Y = min(Output_Based_On_Current_Y, 1.0);\n    \n    float PushToEdge  = 15.0;\n\n    Output_Based_On_Current_Y = pow(Output_Based_On_Current_Y, PushToEdge);\n    \n    //Invert and get a line output instead\n    Output_Based_On_Current_Y = (1.0 - Output_Based_On_Current_Y) * Output_Based_On_Current_Y;\n    \n    Output_Based_On_Current_Y = clamp(Output_Based_On_Current_Y * 5.0, 0.0, 1.0);\n    \n    //Calculate surface normal\n    uv.x  = (fragCoord.x - 0.1) / iResolution.x; \n    uv.x  = uv.x * 2.0 - 1.0; \n    uv.x *= AspectRatio;\n    \n    float PreviousAngle = (uv.x + XShift) * Wave.AngleRange;\n    float PreviousY = GetY(Wave, PreviousAngle);\n    vec2  PreviousPoint = vec2(uv.x, PreviousY);\n    \n    vec2 Normal = CalculateNormal( CalculateSlope(  CurrentPoint, PreviousPoint ) );\n    \n    //Calculate light\n    FLight Light;\n    Light.Intensity = 1.0;\n    Light.Position  = vec2(0.0, .80);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); //from shadertoy\n    Light.Color  = vec4(0.4, 0.7, .9, 1);\n    \n    float CircleRadius = 0.15;\n    uv = fragCoord/iResolution.xy; uv = uv * 2.0 - 1.0; uv.x *= AspectRatio;\n    float Circle = max( CircleRadius - distance(uv, Light.Position), 0.0) / CircleRadius;\n    Circle = Circle / 0.4;\n    Circle = clamp(Circle, 0.0, 1.0);\n        \n    float I = dot( Light.Position - CurrentPoint, Normal) * Light.Intensity;\n    I = max(I, 0.0);\n    \n    //Final output\n    vec4 FinalOutput = Output_Based_On_Current_Y * I * Light.Color;\n    vec4 LightShape = Circle * Light.Color * Light.Intensity ;\n     \n    FinalOutput = mix(FinalOutput, LightShape, 0.6);\n    \n    fragColor = ( FinalOutput );\n   \n}\n\nfloat GetY(FWave Wave, float CurrentAngle_X)\n{\n    return Wave.Amplitude * cos(CurrentAngle_X) + Wave.YOffset;\n}\n\nvec2 CalculateSlope(vec2 Point1, vec2 Point2)\n{\n    return Point1 - Point2;\n}\n\nvec2 CalculateNormal(vec2 Slope)\n{\n    Slope = normalize(Slope);\n    \n    return vec2( -Slope.y, Slope.x);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 409, 409, 2781], [2783, 2783, 2829, 2829, 2895], [2897, 2897, 2944, 2944, 2974], [2976, 2976, 3010, 3010, 3084]]}
{"id": "7l3SRB", "name": "[TDF2021] Reflecting Crystals", "author": "Kamoshika", "description": "25 minutes live coding @Tokyo Demo Fest 2021 Shader Showdown Semifinals\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/", "tags": ["raymarching", "reflection", "livecoding", "gyroid"], "likes": 10, "viewed": 261, "published": "Public", "date": "1639315106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Watch the recording of the live coding on YouTube.\n// https://youtu.be/bp37xTVNRrM?t=6125\n\n#define time iTime\n#define saturate(x) clamp(x,0.,1.)\n#define rotpi4(v) v=vec2(v.x+v.y,-v.x+v.y)/sqrt(2.)\nconst float pi=acos(-1.);\n\nmat2 rot(float a){\n  float s=sin(a),c=cos(a);\n  return mat2(c,s,-s,c);\n}\n\n#define odd(x) step(1.,mod(x,2.))\nfloat sqWave(float x){\n  float i=floor(x);\n  float s=.1;\n  return mix(odd(i),odd(i+1.),smoothstep(.5-s,.5+s,fract(x)));\n}\n\nfloat smin(float a,float b,float k){\n  float h=max(k-abs(a-b),0.);\n  return min(a,b)-h*h*.25/k;\n}\n\nvec3 pos;\nfloat map(vec3 p){\n  float d;\n  //d=length(p)-.3;\n  vec3 q=p;\n  q.y=.7-abs(q.y);\n  \n  d=q.y;\n  q.zx=fract(q.zx)-.5;\n  \n  vec2 dq=mix(vec2(-.2),vec2(.27,.1),sqWave(time*.15));\n  float a=1.;\n  for(int i=0;i<5;i++){\n    vec3 v=q;\n    v.zx=abs(v.zx);\n    if(v.z>v.x)v.zx=v.xz;\n    d=min(d,max(v.x-.1,(v.x*2.+v.y)/sqrt(5.)-.3)/a);\n    q.zx=abs(q.zx);\n    rotpi4(q.xz);\n    q.xy-=dq;\n    rotpi4(q.yx);\n    \n    q*=2.;\n    a*=2.;\n  }\n  \n  q=p-pos;\n  float t=length(q)-.3;\n  q*=15.;\n  q.xy*=rot(time*1.3);\n  q.yz*=rot(time*1.7);\n  t=max(t,(abs(dot(sin(q),cos(q.yzx)))-.2)/15.);\n  \n  d=smin(d,t,.3);\n  \n  return d;\n}\n\nvec3 calcN(vec3 p){\n  vec2 e=vec2(.001,0);\n  return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n  map(p+e.yxy)-map(p-e.yxy),\n  map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvec3 hsv(float h,float s,float v){\n  vec3 res=fract(h+vec3(0,2,1)/3.)*6.-3.;\n  res=saturate(abs(res)-1.);\n  res=(res-1.)*s+1.;\n  res*=v;\n  return res;\n}\n\nvec3 march(inout vec3 rp,inout vec3 rd,inout vec3 ra,inout bool hit){\n  vec3 col=vec3(0);\n  float d,t=0.;\n  hit=false;\n  for(int i=0;i<100;i++){\n    d=map(rp+rd*t);\n    if(abs(d)<.0001){\n      hit=true;\n      break;\n    }\n    t+=d;\n  }\n  rp+=t*rd;\n  \n  vec3 ld=normalize(-rp);\n  \n  vec3 n=calcN(rp);\n  vec3 ref=reflect(rd,n);\n \n  float diff=max(dot(ld,n),0.);\n  float spec=pow(max(dot(reflect(ld,n),rd),0.),20.);\n  float fog=exp(-t*t*.2);\n  \n  d=length(rp-pos)-.3;\n  float mat=smoothstep(.01,.1,d);\n  float phase=length(rp)*4.-time*2.;\n  vec3 al=hsv(floor(phase/pi)*pi*.4,.8,1.);\n  al=mix(vec3(.9),al,mat);\n  float f0=mix(.01,.8,mat);\n  float m=mix(.01,.9,mat);\n  float fs=f0+(1.-f0)*pow(1.-dot(ref,n),5.);\n  float lp=3./abs(sin(phase));\n  \n  col+=al*diff*(1.-m)*lp;\n  col+=al*spec*m*lp;\n  col=mix(vec3(0),col,fog);\n  \n  col*=ra;\n  ra*=al*fs*fog;\n  \n  rp+=.01*n;\n  rd=ref;\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1)*.5;\n  pos=sin(vec3(13,0,7)*time*.1);\n  \n  vec3 col=vec3(0);\n  \n  vec3 ro=vec3(0,-.3,1.9);\n  ro.zx*=rot(time*.1);\n  \n  vec3 rd=normalize(vec3(uv,-2));\n  rd.zx*=rot(time*.1);\n  \n  vec3 ra=vec3(1);\n  bool hit=false;\n  \n  col+=march(ro,rd,ra,hit);\n  if(hit)col+=march(ro,rd,ra,hit);\n  if(hit)col+=march(ro,rd,ra,hit);\n  \n  col=pow(col,vec3(1./2.2));\n  \n  fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3SRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 227, 245, 245, 299], [335, 335, 357, 357, 456], [458, 458, 494, 494, 555], [567, 567, 585, 585, 1174], [1176, 1176, 1195, 1195, 1331], [1333, 1333, 1367, 1367, 1485], [1487, 1487, 1556, 1556, 2378], [2380, 2380, 2437, 2437, 2958]]}
{"id": "7l3SRr", "name": "Something  gaz_235", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 16, "viewed": 117, "published": "Public", "date": "1638586261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define M(p)vec2(asin(sin(atan(p.x,p.y)*6.))/8.,1)*length(p)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    for(float i=0.,g=0.,e,t=iTime;++i<99.;){\n        p=g*d-vec3(2,2,9);\n        p=R(p,\n            normalize(R(vec3(1,2,3),vec3(.577),t*.3))\n            ,t*.2);\n        for(int j=0;j++<4;){\n            p.xy=M(p.xy);\n            p.y-=3.2+sin(t*.2)*.6;\n            p.yz=M(p.yz);\n            p.z-=6.5;\n        }\n        g+=e=dot(sqrt(p*p+.005),normalize(vec3(1.6,2.1,.9)))-1.;\n        O.xyz+=mix(vec3(1),H(length(p)*3.),.3)*.015*exp(-3.*i*i*e);\n    }\n    O*=O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3SRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 203, 203, 742]]}
{"id": "7l3SWH", "name": "Phantom Raymarching 01", "author": "spenceryonce", "description": "This looked so much fun to play around with, I couldn't help but try to make something with it. \n\nhttps://cineshader.com/view/ttKGDt", "tags": ["raymarching", "ifs", "phantommode"], "likes": 5, "viewed": 73, "published": "Public", "date": "1639006823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n*sin(iTime*0.01);\n    return p*(rot(-a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 32.)-16.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, sin(iTime)*0.1);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(0., 1.0, 0.0);//sin(iTime) in x for spin\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    float acc = 0.;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 60; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.014);\n        float a = exp(-dist*7.0);\n        if (mod(length(pos)+22.0*iTime, 30.0) < 2.0) {\n            a *= 1.6;\n            acc2 += a;\n        }\n        acc += fract(a*1.2);\n        t += dist * 0.7;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.007, acc * 0.013+ acc2*0.006);\n    fragColor = vec4(col, 1.0 - t * .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3SWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 107], [165, 165, 193, 193, 317], [319, 319, 348, 348, 439], [441, 441, 463, 463, 653], [655, 655, 685, 685, 858], [860, 860, 917, 917, 1797]]}
{"id": "7l3XR2", "name": "Circles Moire patterns ", "author": "ersteller", "description": "Concept from book of shaders and modified a little. ", "tags": ["subpixelmoirepatterncirclestar"], "likes": 1, "viewed": 85, "published": "Public API", "date": "1639400863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://thebookofshaders.com/07/\n// Distance fields\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // normalize \n  vec2 st = fragCoord.xy/iResolution.xy;\n  \n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // account for aspect ratio\n  st.x *= iResolution.x/iResolution.y;\n    \n  // Make the distance field\n  d = length( abs(st) -0.75 );\n\n  // Visualize the distance field\n  fragColor = vec4(vec3(fract(d*10.0 * iTime)),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3XR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 117, 117, 500]]}
{"id": "7lcSWn", "name": "Truchet Experiment 023", "author": "byt3_m3chanic", "description": "a very lazy way to dither stuff / fun UI editable version using dat.gui - [url]https://codepen.io/pjkarlik/pen/QWqKvbV[/url]", "tags": ["raymarching", "truchet", "tiles"], "likes": 19, "viewed": 151, "published": "Public API", "date": "1639309582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define PI          3.14159265358\n#define PI2         6.28318530718\n#define MIN_DIST    .0001\n#define MAX_DIST    50.\n\n// globals & const\nvec3 hit,hitPoint;\nvec4 gtile,stile;\nmat2 flip;\n\nconst vec3 colorA = vec3(0.890,0.722,0.110);\nconst vec3 colorB = vec3(0.039,0.322,0.741);\nconst vec3 colorC = vec3(0.831,0.125,0.047);\n// cell size\nconst float size = 2.75;\nconst float hlf = size/2.;\n// grid size\nconst vec2  grid = vec2(5,2);\n// tube size\nconst float thick = .85/size;\n// floor tile scale\nconst vec3 bs = vec3(hlf*.95);\n// random hash - in a steady state\nfloat u_hash = 0.12482938;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.yz*=flip;\n    vec3 q = p;\n\n    vec2 id = floor((q.xz + hlf)/size)-grid;\n\n    q.xz = q.xz-size*clamp(round(q.xz/size),-grid,grid);\n    vec3 fq = q;\n\n    float ht = .75+.75*sin(p.x*.3+T*.8);\n    q.y-=ht;\n    float hs = hash21(id+u_hash);\n    if(hs>.5) q.z*=-1.;\n\n    vec2 d2 = vec2(length(q.xz-hlf), length(q.xz+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q.xz-hlf) : vec2(q.xz+hlf);\n    vec3 tq = vec3(gx.x,q.y,gx.y);\n\n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = 1e5;\n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf,.25,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf))-thick,trh);\n    }else if(rhs>.7){\n        //if(fract(xhs+id.x)>.75) q.zx*=rot(1.5707);\n        float qy = .15+.15*sin((q.z+.5)*size);\n        float qx = .15+.15*sin((q.x+.5)*size);\n        trh = cap(q-vec3(0,.25+qy,0),hlf,thick);\n        trh = min(cap(q.zyx-vec3(0,.25-qx,0),hlf,thick),trh);\n    } else{\n        trh = trs(tq-vec3(0,.25,0),vec2(hlf,thick));\n\n    }\n    \n    float brh=trh;\n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        gtile.xyz = vec3(id,1.);\n        gtile.w=mt;\n        res = vec2(trh,mt);\n        hit = tq;\n    } \n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.4,thick*1.1);\n    bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.4,thick*1.1),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,.25,hlf),thick*.34,thick*1.45);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,.25,hlf),thick*.34,thick*1.45),crt);\n    \n    bls=max(crt,-bls);\n    \n    if(bls<res.x) {\n       res = vec2(bls,1.);\n       hit = q;\n    } \n    \n    float flr = box(fq+vec3(0,2,0),vec3(bs.x,.05,bs.xy));\n    flr=max(flr,-brh);\n    if(flr<res.x) {\n       res = vec2(flr,7.);\n       gtile.xyz = vec3(id,0.);\n       gtile.w=6.;\n       hit = fq;\n    } \n    \n    return res;\n}\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nfloat stripes(vec3 p){\n    vec2 uv = p.xz;\n    uv*=rot(.785);\n    vec2 ff = floor(uv);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    float h = mix(1.,.0,f);\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    uv = floor(uv*(216.*R.x/R.y))/(126.*R.x/R.y);\n\n    u_hash+=floor(T*.3);\n    vec3 ro = vec3(0, -1.5, 12.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse //\n    float x = M.z < 0. || M.xy==vec2(0) ? 0.0 : (M.y/R.y*2.-1.)*PI;\n    float y = M.z > 0. ? (M.x/R.x * 2. - 1.) * PI : T*.1;\n    mat2 rx =rot(-.65);\n    mat2 ry =rot(y);\n    flip=rot(x);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0);\n    float m = 0.;\n    float d = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<128;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.75: ray.x *.95;\n        m  = ray.y;\n    } \n\n    \n    float alpha = 1.;\n    if(d<MAX_DIST)\n    {\n    \n        hitPoint = hit;\n        alpha *=1e-5;\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(0,15,-5.);\n        vec3 l = normalize(lpos);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n        float shdw = 1.0;\n        float t=.001;\n        for( int i =1; i<20; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n\n        vec3 h = vec3(.0);\n        float diff = clamp(dot(n,l),0. , 1.);\n        if(m==1.) {h=vec3(.43);}\n        if(m==2.) {h=colorB;}\n        if(m==3.) {h=colorC;}\n        if(m==4.) {h=colorA;}\n        if(m==5.) {h=vec3(.075);}\n        if(m==7.) {h=mix(colorB*.3,colorB*.1,stripes(hitPoint));}\n        \n        h = mix(h,h*shdw,.15);\n        if(diff<.3) h=clamp(h*.5,vec3(0),vec3(1));\n        if(diff<.4&&(mod(F.x,4.)==mod(F.y,4.))) h*=.3;\n        if(shdw<.5&&(mod(F.x,2.)==mod(F.y,2.))) h*=.2;\n        if(spec>.25) h=clamp(h*1.15,vec3(0),vec3(1));\n        if(spec>.5&&(mod(F.x,2.)==mod(F.y,2.))) h=clamp(h*1.5,vec3(0),vec3(1));\n        C = h;\n    }\n    float mask = smoothstep(.1,.7,length(uv)-.5);\n    vec3 clr = mix(colorA,colorA*.05 ,mask );\n    \n    uv*=rot(.785);\n    vec2 ff = floor(uv*8.);\n    float f = clamp(mod(ff.x,2.)*1.-.5,0.,1.);\n    clr = mix(clr*.5,clr*.2,f);\n    C = mix(C,clr,alpha);\n    if(C.r<.2&&C.g<.2&&C.b<.2) C = hash21(uv)>.5 ? C+.005 : C;\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[610, 673, 691, 691, 735], [736, 736, 757, 757, 813], [815, 815, 840, 840, 925], [926, 926, 960, 960, 1065], [1068, 1068, 1094, 1094, 1163], [1165, 1165, 1182, 1182, 3158], [3159, 3242, 3272, 3272, 3511], [3513, 3513, 3535, 3535, 3690], [3692, 3692, 3733, 3733, 6061]]}
{"id": "7lcXD7", "name": "Saturday abstract logo", "author": "mrange", "description": "CC0 : Saturday abstract logo\nTinkering with recreating an abstract logo.\nNot perfect but good enough for my standard.\nInspired by: https://www.logomoose.com/featured/abstract-logo/", "tags": ["logo"], "likes": 11, "viewed": 126, "published": "Public API", "date": "1639225871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 : Saturday abstract logo\n//  Tinkering with recreating an abstract logo.\n//  Not perfect but good enough for my standard.\n//  Inspired by: https://www.logomoose.com/featured/abstract-logo/\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0 - exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2  p1 = p-vec2(logo_off, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_off, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 clogo(vec2 p, out float d) {\n  p *= ROT(TAU*TIME/60.0);\n\n  float sgn = sign(p.y);\n  p *= sgn;\n\n  vec4 s0 = figure_8(p);\n  vec4 s1 = figure_8(p*ROT(PI/4.0));\n  vec4 s2 = figure_8(p-vec2(-0.5, 0.0));\n  vec4 s3 = figure_8((p*ROT(5.0*PI/4.0)));\n  \n  // This is very hackish to get it to look reasonable\n  \n  const float off = -PI;\n  s1.z -= off;\n  s3.z -= off;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n  s = merge(s, s3);\n\n  d = s.w;\n  return vec4(vec3(1.0)*s.x, s.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col  = vec3(1.0);\n  float d;\n  vec4 ccol = clogo(p, d);\n  \n  col = mix(col, vec3(.25), exp(-9.0*max(d+0.025, 0.0)));\n  col = mix(col, ccol.xyz, ccol.w);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 506, 526, 526, 546], [548, 646, 682, 682, 792], [794, 794, 825, 825, 851], [853, 853, 877, 877, 976], [978, 978, 1008, 1008, 1246], [1248, 1248, 1271, 1271, 1842], [1844, 1844, 1877, 1877, 2332], [2334, 2421, 2457, 2501, 2772], [2774, 2774, 2829, 2829, 3181]]}
{"id": "7lcXDH", "name": "for loop", "author": "cghow", "description": "practice of for loop", "tags": ["forloop"], "likes": 1, "viewed": 13, "published": "Public", "date": "1639021184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nuv -= .5;\nuv.x*= iResolution.x/iResolution.y;\n//uv*= uv.x*10.;\nvec3 col = vec3(0);\nfor(float i=0.; i<.5; i+=.01){\nuv.x+= clamp(sin(2.*iTime*.01)*.1,-.5,.5)*.15;\nuv.y+= clamp(cos(iTime+i*5.)*.1,-.5,.5)*.15;\nfloat d = length(uv);\nfloat s = step(d,i*.5)*.01;\ncol+=s;\n}\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 448]]}
{"id": "7lcXDr", "name": "circular wave", "author": "hahnzhu", "description": "simple marker point animation", "tags": ["smoothsteppolarcoordinate"], "likes": 5, "viewed": 30, "published": "Public", "date": "1638963372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 toCenter = uv - vec2(0.5*ratio, 0.5);\n    float progress = fract(iTime*.5-0.2);\n    float progress2 = smoothstep(iTime*5., 0., 1.);\n    float radius = length(toCenter);\n    \n    float opacityInner = smoothstep(0., 0.2, progress);\n    float opacityInner2 = smoothstep(.52, .2, progress);\n    \n    float opacityOuter = smoothstep(0., 0.2, progress-0.2);\n    float opacityOuter2 = smoothstep(.52, .2, progress-0.2);\n   \n    float len = smoothstep(0., progress, radius);\n    float col = pow(len, 1.5) * smoothstep(1., .99, len);\n    \n    float len2 = smoothstep(0., progress-.2, radius);\n    float col2 = pow(len2, 1.5) * smoothstep(1., .99, len2);\n    \n    float circle1 = col * opacityInner * opacityInner2;\n    float circle2 = col2 * opacityOuter * opacityOuter2;\n    float centerDot = 1.-smoothstep(progress2*.07, progress2*.08, radius);\n    float highlight = 1.-smoothstep(progress2*.015, progress2*.02, length(toCenter+vec2(.01,-.01)));\n    \n    vec3 circleColor = vec3(1., 0.612, 0.325);\n    vec3 dotColor1 = vec3(1., .729, .18);\n    vec3 dotColor2 = vec3(.98, .541, .118);\n    vec3 dotColor = mix(dotColor1, dotColor2, smoothstep(.55, .45, uv.y));\n\n    float opacity = 0.7;\n    vec3 wave = vec3(circle1 + circle2)*circleColor*opacity;\n    vec3 dott = vec3(centerDot)*dotColor;\n    vec3 highl = vec3(highlight)*0.3;\n\n    fragColor = vec4(wave + dott + highl, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1549]]}
{"id": "7lcXRB", "name": "sinY", "author": "thodd_riction", "description": "exercise", "tags": ["learning"], "likes": 1, "viewed": 20, "published": "Public", "date": "1639318468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur)\n{\n\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    \n    float band1 = Band(uv.x, left, right, blur); \n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2;\n}\n\nfloat remap01(float a, float b, float t){ // si t = a, a = 0; la distance entre a et b =1; de a à b = de  à ;\n    return (t-a) / (b-a);                 // t-a = 0, (t=a) = (a-a = 0);\n                                          // si t = 0, t-a/t-a = un chiffre divisé par lui même = 1\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a,b,t) * (d-c) +c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x = abs(uv.y);\n    float t = iTime;\n    float x = uv.x;\n    float m = cos(t+x*1.)*0.1;\n    float y = uv.y+m;\n    float d = length(uv);\n    float c = 0.;\n    float blur = remap(0., .1, .01, .35, x);\n    blur *= blur;\n    c = Rect(vec2(x,y), 0., 1., -.02, .02, blur);\n    float a = Rect(vec2(x,y+.2), 0., 1., -.02, .02, blur);\n    float b = Rect(vec2(x,y-.2), 0., 1., -.02, .02, blur);\n\n    vec3 col = vec3(1., 0., 0.)*c+a+b;\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 199], [201, 201, 284, 284, 419], [421, 421, 462, 532, 709], [711, 711, 768, 768, 813], [815, 815, 872, 872, 1436]]}
{"id": "7lcXz2", "name": "signed distance Glow shader", "author": "trinketMage", "description": "Glow shader implementation from https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm", "tags": ["glow", "signeddistance"], "likes": 1, "viewed": 37, "published": "Public", "date": "1639406250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 rad = vec2(0.8,cos(iTime) * 0.2);\n\tfloat d = sdBox( p, rad );\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n\tcol.r += exp(-3.0*abs(d));\n    col = mix( col, vec3(1.0, 0.5, 0.5), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 118], [120, 120, 177, 177, 494]]}
{"id": "7lcXzM", "name": "Flat parallax sea", "author": "cxm", "description": "Retro parallax web design.\n", "tags": ["cineshader"], "likes": 1, "viewed": 133, "published": "Public API", "date": "1638845088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float makeLightFlat( in vec2 uv ){\n    \n    float f = mod( ( ( 1. - ( uv.x - .5 ) * 1. ) / ( 1. - ( uv.y - .5 ) ) ), .25 );\n    \n    return smoothstep( 1., 1., f * 6. );\n}\n\n\nvec2 orib( float rad, in float time, in vec2 res ){\n\n    float f = max( res.x / res.y, 1. );\n    \n    vec2 orib = vec2( cos( time ) * rad, sin( time ) * rad * f );\n    \n    return orib;\n}\n\nfloat wave( vec2 itr, vec2 o, float waveHeight, float xx, float yy, in vec2 uv ){\n    vec2 bUv = uv;\n    \n    \n    for( float i = 1.; i < 50.; i++ ){\n       bUv.y += ( waveHeight ) * ( sin( ( bUv.x + itr.x + o.x + xx ) * 5. + .5 * i * .5 ) );\n    }\n    \n    bUv.y = 1. - ( .1, bUv.y - yy + itr.y + o.y );\n    bUv.y = smoothstep( 1., 1., bUv.y );\n    \n    return bUv.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 bUv = fragCoord/iResolution.xy;\n    \n    vec3 c1 = vec3( .19, .38, .5 );\n    vec3 c2 = vec3( .2, .43, .6 );\n    vec3 c3 = vec3( .55, .78, .93 );\n    \n    vec3 clh = vec3( .51, .32, .08 );\n    \n    vec2 iteractive = ( iMouse.xy / iResolution.xy + vec2( .5, -.5 ) ) * .3;\n\n    // Time varying pixel color\n    vec3 bg = mix( vec3( .2, .43, .6 ), vec3( .55, .78, .93 ), uv.y );\n    vec3 col = vec3( 0. );\n    \n    float sun = distance( vec2( 1., 1. - .8 / ( iResolution.x / iResolution.y ) ) , vec2( uv.x , uv.y / ( iResolution.x / iResolution.y ) ) );\n    sun = 1. - smoothstep( .2, .2, sun );\n    \n    vec3 sunCol = vec3( .89, .4, .1 );\n    \n    //col += linear;\n    vec2 o = orib( .06, iTime * 1.5, iResolution.xy );\n    vec2 o2 = orib( .04, iTime * 2., iResolution.xy );\n    vec2 o3 = orib( .03, iTime * 1.9, iResolution.xy );\n    \n\n    // vec3 linear = mix( c1, c2, mod( bUv.y, .3 ) );\n    \n    \n    float w1 = wave( iteractive * 1.1, o, .08, -2., .3, bUv );\n    \n    float w2 = wave( iteractive * 1.2, o2, .05, 2.5, .25, bUv );\n    \n    float w3 = wave( iteractive * 1.3, o3, .11, 4., .2, bUv );\n    \n    // item positions\n    \n    col = mix(\n        mix(\n            mix(\n\n                mix(\n                    mix(\n                        bg, \n                        vec3( 1. ),\n                        makeLightFlat( uv )\n                    ),\n                    sunCol,\n                    sun\n                ),\n                c1,\n                w1\n            ),\n            c2,\n            w2\n        ),\n        c3,\n        w3\n    );\n    \n    // \n\n\n    // Output to screen\n    fragColor = vec4( col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 171], [174, 174, 225, 225, 361], [363, 363, 444, 444, 733], [736, 736, 793, 843, 2526]]}
{"id": "7ldXRB", "name": "Matt Parker Squircle", "author": "OlafDoschke", "description": "Animation of squircles as defined by Matt Parker in https://www.youtube.com/watch?v=gjtTcyWL0NA&t=624s\nwith exponent rising over time.", "tags": ["2d", "circle", "square", "squircle"], "likes": 1, "viewed": 13, "published": "Public", "date": "1639361553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat Squircle(vec2 uv, float r, float n, float blur)\n{\n    float c = pow(abs(uv.x),n)+pow(abs(uv.y),n);\n    \n    return smoothstep(r+blur,r-blur,c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.*(2.*fragCoord/iResolution.xy-vec2(1.));\n    \n    // Aspect ratio fix\n    uv.x *=iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    fragColor = vec4(Squircle(uv, 1., iTime/2., .02));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 57, 57, 153], [156, 156, 213, 264, 480]]}
{"id": "7ldXz8", "name": "undulate ", "author": "do", "description": "animation shader", "tags": ["animation"], "likes": 3, "viewed": 33, "published": "Public", "date": "1638736059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//undulate\n//2021\n//do\n\nconst float PI   =  radians(180.0); \nconst int seed = 3434;\n\nfloat hash(float p) {\n    uvec2 n = uint(int(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat hash(vec2 p) {\n    uvec2 n = uvec2(ivec2(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat n3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(hash(  n +   0.0) , \n                       hash(   n +   1.0)  ,f.x),\n                   mix(hash(  n + 157.0) ,  \n                       hash(   n + 158.0)   ,f.x),f.y),\n               mix(mix(hash(  n + 113.0) ,\n                       hash(   n + 114.0)   ,f.x),\n                   mix(hash(  n + 270.0) ,\n                       hash(   n + 271.0)   ,f.x),f.y),f.z);\n}\n\nfloat f3(vec3 x,float hurst) {\n    float s = 0.;\n    float h = exp2(-hurst);\n    float f = 1.;\n    float a = .5;\n\n    for(int i = 0; i < 5; i++) {\n\n        s += a * n3(f * x);  \n        f *= 2.;\n        a *= h;\n    }\n    return s;\n}\n\nvec3 fmCol(float t,vec3 a,vec3 b,vec3 c,vec3 d) {\n    return a + b * cos( (PI*2.0) * (c * t + d));\n}\n\nfloat easeInOut4(float t) {\n    if((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nfloat easeOut3(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\nmat2 rot2(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat sphere(vec3 p,float r) { \n    return length(p) - r;\n}\n\nfloat plane(vec3 p,vec4 n) {\n   return dot(p,n.xyz) + n.w;\n}\n\nfloat box(vec3 p,vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 scene(vec3 p) {\n\n    vec2 res = vec2(1.,0.);\n\n    float d = 0.;     \n    float s = .9;\n\n    float t = iTime;  \n    \n    vec3 q = p;\n    vec3 l = p;\n\n    p.xz *= rot2(easeOut3(t*s*.06)*0.00015);\n    q.yx *= rot2(.5*cos(easeInOut4(t*s)*0.005));\n\n    d = mix(sphere(p,0.25),box(q,vec3(1.)),\n    sin(s*t)*0.5+0.5); \n\n    d += n3(p+n3(p)*0.25+t*s)*0.25; \n\n    res = opu(res,vec2(d,2.));\n    float pl = plane(l+vec3(0.,1.5,0.),vec4(0.,1.,1.,1.));\n\n    res = opu(res,vec2(pl,1.));\n  \n  return res;\n\n}\n\nvec2 rayScene(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = 1.;\n    float e = 16.;  \n\n    for(int i = 0; i < 155; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(abs(dist.x) < 0.0001 || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 100; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,235. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < 0.01 ||t > 5.) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.,-1.) * 0.0001;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 rayCamDir(vec2 uv,vec3 camPosition,vec3 camTarget,float fPersp) {\n\n     vec3 camForward = normalize(camTarget - camPosition);\n     vec3 camRight = normalize(cross(vec3(0.0,1.0,0.0),camForward));\n     vec3 camUp = normalize(cross(camForward,camRight));\n\n     vec3 vDir = normalize(uv.x * camRight + uv.y * \n     camUp + camForward * fPersp);  \n\n     return vDir;\n}\n\nvec3 render(vec3 ro,vec3 rd) {\n \nvec2 d = rayScene(ro, rd);\n\nvec3 col = vec3(1.) - max(rd.y,0.);\n\nif(d.y >= 0.) { \n\nvec3 p = ro + rd * d.x;\nvec3 n = calcNormal(p);\nvec3 l = normalize(vec3(0.,10.,10.));\n\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\nfloat amb = sqrt(clamp(0.5 + 0.5 * n.y,0.0,1.0));\nfloat dif = clamp(dot(n,l),0.0,1.0);\n\nfloat spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n* dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\nfloat fre = pow(clamp(1. + dot(n,rd),0.0,1.0),2.0);\nfloat ref = smoothstep(-.2,.2,r.y);\n\nvec3 linear = vec3(0.);\n\ndif *= shadow(p,l);\nref *= shadow(p,r);\n\nlinear += dif * vec3(1.);\nlinear += amb * vec3(.05,0.01,0.01);\nlinear += ref * vec3(0.004,0.005,0.11);\nlinear += fre * vec3(0.04,0.12,0.005);\n\nif(d.y == 2.) {\n\n    float nl = f3(p+f3(p,sin(p.y)),hash(122.)); \n\n    col += fmCol(p.y + nl,vec3(hash(112.),hash(33.),hash(21.)),\n                          vec3(hash(12.),hash(105.),hash(156.)), \n                          vec3(hash(32.),hash(123.),hash(25.)),                                  vec3(hash(10.),hash(15.),hash(27.)));  \n}\n\ncol = col * linear;\ncol += 5. * spe * vec3(0.0001);\n\n} \n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n \nvec3 color = vec3(0.);\n\nvec3 cam_tar = vec3(0.);\nvec3 cam_pos = vec3(0.,1.,4.);\n\nvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;  \n\nvec3 dir = rayCamDir(uv,cam_pos,cam_tar,2.); \ncolor = render(cam_pos,dir);  \nfragColor = vec4(color,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 106, 106, 265], [267, 267, 287, 287, 449], [451, 451, 469, 469, 992], [994, 994, 1024, 1024, 1226], [1228, 1228, 1277, 1277, 1328], [1330, 1330, 1357, 1357, 1486], [1488, 1488, 1513, 1513, 1555], [1557, 1557, 1577, 1577, 1655], [1657, 1657, 1684, 1684, 1722], [1725, 1725, 1755, 1755, 1784], [1786, 1786, 1814, 1814, 1846], [1848, 1848, 1874, 1874, 1965], [1967, 1967, 1987, 1987, 2465], [2467, 2467, 2499, 2499, 2839], [2841, 2841, 2873, 2873, 3284], [3286, 3286, 3311, 3311, 3619], [3621, 3621, 3691, 3691, 3989], [3991, 3991, 4021, 4021, 5145], [5147, 5147, 5201, 5201, 5454]]}
{"id": "7lGGzc", "name": "chroma collapse", "author": "medium_fi", "description": "yet another color mixer", "tags": ["procedural"], "likes": 6, "viewed": 143, "published": "Public API", "date": "1638739283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (iTime + 50.4)/ 14.;\n    float p = 0.4;\n    float c = 0.7;\n    float radius = 0.15;\n\n    // inside out\n    vec2 xy = fragCoord/min(iResolution.xy.x, iResolution.xy.y) - 0.5;\n    xy = 1. * (xy - 0.3 * vec2(cos(t*5.), sin(t*5.)));\n    vec2 uv = vec2(sqrt(xy.x * xy.x + xy.y * xy.y), atan(xy.y, xy.x));\n    float r = uv.x;\n    float inside = float(r < radius);\n    uv.x  = (1. -inside) * (r-radius) + (inside) * (radius / r - 1.);\n    uv.y  = (1. -inside) * uv.y + (inside) * -uv.y;\n    \n    // fold it\n    for (int i=0; i < 3; i++) {\n        uv = uv + t * 5. + cos(sin(t*7.) * uv.x * uv.y);\n        uv = 3. * cos(uv) * cos(uv);\n    }\n \n    // glow it\n    uv = p * floor(c * uv) / c + (1.- p) * uv * r;\n    fragColor = vec4(0.5 * cos(uv) + 0.5, 0.5 * sin(uv.x) + 0.5, 1.0);\n\n    float b = max((1. - inside) * cos(r/1.5),  0.);\n    b = b + exp(-20. * abs(r - radius));\n    fragColor = fragColor * vec4(b, b, b, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 990]]}
{"id": "7ltSRr", "name": "hypnotoad", "author": "nobear", "description": "Spinny circle that transmits my will to viewers", "tags": ["color", "circle", "lollipop", "toad"], "likes": 2, "viewed": 43, "published": "Public", "date": "1638648314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RADIUS = 10.0 * sin(iTime / 4.0);\n    float RADIUS2 = 64.0;\n    float RATE = 2.0 / RADIUS;\n    \n    vec2 origin = vec2(iResolution.x / 2.0, iResolution.y / 2.0) + (RADIUS2 * vec2(cos(RATE * iTime), sin(RATE * iTime)));\n    \n    vec2 dMouse = origin - fragCoord.xy;\n    float brightness = 1.0 - (length(dMouse) / RADIUS);\n    \n    \n    // Output to screen\n    fragColor = vec4(sin(brightness), cos(brightness), sin(iTime + brightness), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 510]]}
{"id": "7ltSzj", "name": "Jellybean Rain", "author": "maxoo", "description": "It's raining jellybeans", "tags": ["rain"], "likes": 8, "viewed": 153, "published": "Public", "date": "1639425899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float x) {\n    return fract(sin(x)*1e5);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    return mix(rand(i), rand(i + 1.0), smoothstep(0.0, 1.0, f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n    \n    uv.x *= 155.0;\n    \n    vec2 i =  floor(uv);\n    \n    uv.y *= max(6.5 * rand(i.x + 1.0), 0.02);\n    \n    float odd = step(1.0, mod(i.x, 2.0));\n    float even = 1.0 - odd;\n    \n    uv.y += odd * pow(iTime, 0.52) * rand(i.x) * 5.0;\n    uv.y += even * pow(iTime, 0.66) * rand(i.x) * 5.0;\n    uv.y += iTime * 0.4;\n    uv = fract(uv);\n    \n    float b = uv.x - uv.y + 0.3;\n    \n    color = vec3(noise(i.x + 1000.0) * b, noise(i.x + 30000.0 * 0.4) * b, noise(i.x) * b);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltSzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 53], [55, 55, 77, 77, 192], [194, 194, 251, 301, 907]]}
{"id": "7ltSzS", "name": "Smiley from The Art of Code", "author": "thodd_riction", "description": "tuto ", "tags": ["tuto"], "likes": 3, "viewed": 40, "published": "Public", "date": "1639350532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t){\n    return sat((t-a) / (b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return sat((t-a) / (b-a))*(d-c) +c;\n}\n\nvec2 within(vec2 uv, vec4 rect){\n    return (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile){\n\n    float offs = mix(.2, 0., smile);\n    uv.y += offs;\n\n    float y = uv.y;\n    uv -= .5;\n    uv.y += uv.x*.9-.02;\n    uv.x -= .2;\n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    float d1= length(uv);\n    float s1 = S(.5, .5-blur, d1);\n    float d2 = length(uv-vec2(.05, -.2)*.4);\n    float s2 = S(.53, .57-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(.7, .8, y) *.75;\n    colMask*= S(.6, .9, browMask);\n    vec4 browCol = vec4(.4, .2, .2, 1.);\n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile){\n    uv -=.5;\n    uv.x *= side;\n    \n    float d = length(uv);\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5);\n    col.a = S(.5, .48, d);\n\n    col.rgb *= 1. - S(.37, .42, d)*sat(uv.y-uv.x*side);\n    \n    float e = length(uv-m*.5);\n\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, e));\n\n    irisCol.rgb *= 1. + S(.3, .05, e); \n    \n    float irisMask = S(.28, .26, e);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n\n    float g = length(uv-m*.8);\n    \n    float pupilSize = mix(.4, .16, smile);\n    float pupilMask = S(pupilSize, pupilSize*.85, g);\n    pupilMask*=irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask);\n    \n    float t = iTime*5.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-smile);\n    \n    uv+= offs;\n    float highlight = S(.1, .09, length(uv-vec2(-.1, .1)));\n    highlight += S(.07, .05, length(uv-vec2(.12, -.07)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    col.a = S(.42, .4, d);\n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile){\n    \n    uv-=.5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *=1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    \n    uv.x *= mix(2., 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.42, .4, d);\n    \n    vec2 tUv = uv;\n    tUv.y += abs(uv.x)*.5;\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.)*S(.45, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv){\n\n    vec4 col = vec4(.9, .65, .1, 1.);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));\n    \n    float highlight = S(.41, .405, d);\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= S(.13, .15, length(uv-vec2(.21, .1)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    \n    \n    d = length(uv-vec2(.25, -.15));\n    float cheek = S(.25, .01, d);\n    cheek *= S(.2, .1, d);\n    col.rgb = mix(col.rgb, vec3(1., .5, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile){\n\n    vec4 col = vec4(0.);\n    \n    float side = sign(uv.x);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.4, .3, -.1)), smile);\n    vec4 brow = Brow(within(uv, vec4(.03, .2, .3, .35)), smile); \n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    col = mix(col, brow, brow.a);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy /iResolution.xy;\n    m -= .5;\n    \n    \n    uv -= m*(.25-dot(uv, uv));\n    float smile = cos(iTime)*.5+.5;\n    \n    fragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 113, 113, 146], [148, 148, 205, 205, 247], [249, 249, 281, 281, 326], [328, 328, 360, 360, 923], [925, 925, 976, 976, 2001], [2003, 2003, 2036, 2036, 2554], [2556, 2556, 2575, 2575, 3238], [3240, 3240, 3282, 3282, 3758], [3760, 3760, 3817, 3817, 4095]]}
{"id": "7ltXDM", "name": "Fractal 93 gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 10, "viewed": 83, "published": "Public", "date": "1639261212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B (1.-fract(t*2.))\n#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,s,e,g=0.,t=iTime;\n    for(;i++<99.;){\n        p=d*g;\n        p.z-=-t*2.5;\n        p=R(p,vec3(.577),clamp(sin(t/4.)*6.,-.5,.5)+.7);\n        p=asin(sin(p/2.))*3.; \n        vec4 q=vec4(p,.5);\n        s=2.;\n        for(int i=0;i++<8;){\n            q=abs(q);\n            q=q.x<q.y?q.zwxy:q.zwyx;\n            s*=e=9./min(dot(q,q),6.);\n            q=q*e-vec4(5.,2.+B,4.+B,8.);\n        }\n        g+=e=abs(length(q.zw)/s)+.001;\n        c+=mix(vec3(1),H(log(s)*.2),.8)*2e-4/e;   \n    }  \n    c*=c*c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 171, 171, 773]]}
{"id": "7ltXR7", "name": "Voronoi (Borders Around Point A]", "author": "Yusef28", "description": "It seems in this case that IQ's voronoi edges method makes more sense than Tomkh's. If we want to find borders so we can find the nearest intersection, we actually need to find all the borders around pointA, NOT around the uv (or in this case the ro).", "tags": ["2d", "voronoi", "commented", "borders", "edges", "comments", "traversal"], "likes": 8, "viewed": 155, "published": "Public API", "date": "1638902881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n\n=============================================================\n\nAn important discorvery I made, assuming I am understanding\ntomkh's and Iq's work is that actually:\n\nIt seems in this case that IQ's method makes \nmore sense than tomkh's. If we want to find borders \nso we can find the nearest intersection, we actually \nneed to find all the borders around pointA, NOT around \nthe uv (or in this case the ro).\n\nThis way we are garanteed that the edges will be \nthe ones that fully enclose the cell.\n    \nIf you check for borders around ro, you will get borders\nclose to ro for the 3x3 loop which may not find the borders\nin the direction ro+rd*t is even going. So you would then need \na 5x5 loop to do that which is super slow.\n\n==========================================================\n\nHere is a voronoi traversal algorithm I came up with.\nThere are a few hacks involved:\n\n1. When I check edges for a hit I actually check a 5x5 neighborhood\nbecause otherwise the way I do things there are times when not all\nthe correct edges are drawn.\n\n2. The weirdest thing. I find I can't use a constant value \n(such as ray origin) as an input to this algorithm. It has to \nbe moving even a little bit so I jitter with sin(iTime)*0.001\n\nNo idea why. A mouse position will work find and give me the edges, \nbut a set value like vec2(1.,0.) will not. \n\nEDIT: The jitter can be a constant value, we just need to \nbe a tiny bit off from pointA when we checkk pointB for some reason.\nso eps = 0.001 wo\n\n*/\n\n//I used this visual to create \"Border Skipping\"\n//where we don't check every border\n//https://www.shadertoy.com/view/7tcSDn\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n}\n\n/***************************************************\n\nHere is the actual voronoi border finding algorithm\nusing IQ's method of search for point Bs around PointA.\nThis is more effective in the case where you have a single\ncell that you want to find all the borders around.\n\nUsing just a given point in the cell (like a mouse position)\nwould lead to you finding all the borders closest to the \nmoust position. When we only look for 9 borders (3x3 double for loop)\nwe risk getting some of the wrong borders.\n\nWhen we instead check for borders around the \"pointA\"\nthat we found from the first voronoi loop, we get all the \ncorrect borders!\n\n*************************************************** */\n\n\nvec4 voronoiLine(vec2 uv, vec2 m, inout vec3 col){\n\n    vec2 st = fract(m);\n    vec2 stFL = floor(m);\n    vec2 d = vec2(10.);\n    vec2 pointA;\n    vec2 pointB;\n\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n            vec2 id = vec2(i,j);\n            vec2 rndShift = rnd2(stFL+id);\n            vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n            vec2 testA = stFL + coords;\n            float c = length(coords.xy - st);\n            \n            if(c < d.x){\n                d.x = c;\n                pointA = testA;\n                \n                }\n             }\n          }\n    col = mix(col,vec3(1.,1.,0.),\n                      clamp( point(uv-pointA, 0.1), 0., 1.));\n                      \n    //we want to find the next point from pointA to get \n    //correct edges. Like in IQ's article\n    st = fract(pointA);\n    stFL = floor(pointA+sin(iTime)*0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){   \n        \n            vec2 id = vec2(i,j);\n            vec2 rndShift = rnd2(stFL+id);\n            vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n            vec2 testB = coords+stFL;\n            \n            //check edge\n            \n            if(length(testB-pointA) > 0.001){\n                vec2 edgePoint = (pointA+testB) / 2.;\n                \n                col = mix(col,vec3(0.,0.,1.),\n                      clamp( point(uv-edgePoint, 0.1), 0., 1.));\n                \n                vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n                vec2 edgeSideA = edgePoint - perp;\n                vec2 edgeSideB = edgePoint + perp;\n                \n                col = mix(col, vec3(1.), \n                          line(uv, edgeSideA, edgeSideB, 0.04));\n            }\n        }\n    }\n    \n    return vec4(pointA, d);\n}\n\n///////////////////////////////////////////\n\n//Another voronoi function just for the cell the mouse is in...\n\n//////////////////////////////////////////\n\nvec2 voronoiMouseID(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) ;\n        vec2 testB = coords + stFL;\n        \n        float c = length(coords.xy- st);\n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n            \n            }\n        }\n    }\n\n    return vec2(d);\n}\n\n\n///////////////////////////////////////////\n\n//voronoi edge function just for coloring\n\n//////////////////////////////////////////\nvec4 voronoi(vec2 uv, inout vec2 pos){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    pos = stFL;\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n            pos = stFL+id;\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);\n        \n        if(length(A-coords) > 0.00){\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,0.5+0.5*sin(pow(B*100.,vec2(1./2.))));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float globalScale = 4.;\n    uv*=globalScale ;\n    vec2 pos;\n    vec4 voronoXY = voronoi(uv,pos);\n    \n    \n    //====================START OF FANCY COLORING====================\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    col.zy *= rot(.1);\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n\n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.),pos).x-voronoi(uv+vec2(eps,0.),pos).x,\n                  voronoi(uv-vec2(eps,0.).yx,pos).x-voronoi(uv+vec2(eps,0.).yx,pos).x,\n                  voronoi(uv-vec2(eps,0.),pos).z\n                  -voronoi(uv+vec2(eps,0.).yy,pos).z\n \n                  );\n         n = normalize(n);\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.)/2., smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n    //====================END OF FANCY COLORING====================\n    \n  \n    \n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    if(iMouse.z < 0.5){ m = vec2(0.);}\n    \n    \n    //call voronoi to get the mouse id. This could be\n    //probably done in one of the other voronoi calls\n    vec2 vMouse = voronoiMouseID(m*globalScale );\n    //color the cell black that the mouse is currently in \n    //if the mouse is pressed, otherwise it will be the (0.,0.) point.\n    if(vMouse.y==voronoXY.y)col = \n                vec3(0.,0.0,0.)\n                    *smoothstep(0.9,0.99,voronoXY.z);\n   \n                    \n                    \n                    \n   vec3 lines = vec3(0.);\n   //calling voronoiLine to color \"lines\".\n   //super messy code here and the return isn't used\n   vec4 not_used = voronoiLine(uv,m*globalScale,lines);\n\n    col /= 1.88;\n    //col = mix(col, vec3(1.,0.,0.), lines);\n    col = mix(col, vec3(1.), lines);\n    col= pow(col, vec3(1.4));\n   // col = tx0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1875, 2236, 2255, 2255, 2389], [2391, 2391, 2409, 2409, 2472], [2474, 2474, 2514, 2514, 2590], [2592, 2592, 2622, 2622, 2671], [2673, 2673, 2702, 2702, 2765], [2767, 2767, 2811, 2811, 2953], [2955, 3649, 3699, 3699, 5507], [5619, 5663, 5692, 5692, 6303], [6394, 6437, 6475, 6475, 7649], [7651, 7651, 7708, 7758, 10288]]}
{"id": "7lV3W3", "name": "islandshapes3d", "author": "Del", "description": "same as the 2d version...", "tags": ["sdf", "bezier", "island", "extrude"], "likes": 6, "viewed": 135, "published": "Public API", "date": "1638468367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// island 3d (extrude) - added the colouring from the 2d version + 3 islands\n//\n// This is basically a fork of the Original SDF Quadratic Bézier Shape here: https://www.shadertoy.com/view/ftdGDB\n// slightly modified to produce random Island shapes from a vec2 seed value.\n// Golf anyone? :)\n\n// Author: Thomas Stehle\n// Title: SDF Quadratic Bézier Shape\n//\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Signed distance function for a shape made out of quadratic\n// Bézier curves in the tradition of iq's series such as this\n// one: https://www.shadertoy.com/view/MlKcDD.\n//\n// The only real contribution of this shader is that it postpones\n// the call to the costly Bézier SDF up until the point it has\n// identified the closest segment of the control polygon.\n// So instead of iterating over all Bézier curves, we iterate\n// over the line segments of the control polygon and identify the\n// closest segment. We then call the Bézier SDF for this segment\n// only. This approach is correct since quadratic Bézier curves\n// are always contained in the triangle formed by its three\n// control points.\n// Constants\nconst int CAPACITY = 8; // Control polygon capacity\nconst float INF   = 1.0 / 0.0;\nconst float SQRT3 = 1.732050807568877;\n\n// Cross-product of two 2D vectors\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\n\n// Clamp a value to [0, 1]\nfloat saturate(in float a) {\n    return clamp(a, 0.0, 1.0);\n}\nvec3 saturate(in vec3 a) {\n    return clamp(a, 0.0, 1.0);\n}\n\n// Minimum of the absolute of two values\nfloat abs_min(float a, float b) {\n    return abs(a) < abs(b) ? a : b;\n}\n\n// SDF for a line segment\nfloat sdf_line(in vec2 p, in vec2 a, in vec2 b) {\n    float h = saturate(dot(p - a, b - a) /\n                       dot(b - a, b - a));\n    return length(p - a - h * (b - a));\n}\n\n// Like the SDF for a line but partitioning space into positive and negative\nfloat sdf_line_partition(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = saturate(dot(pa, ba) / dot(ba, ba));\n    vec2 k = pa - h * ba;\n    vec2 n = vec2(ba.y, -ba.x);\n    return (dot(k,n) >= 0.0) ? length(k) : -length(k);\n}\n\n// Signed distance to a quadratic Bézier curve\n// Mostly identical to https://www.shadertoy.com/view/MlKcDD\n// with some additions to combat degenerate cases.\nfloat sdf_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    const float EPSILON = 1e-3;\n    const float ONE_THIRD = 1.0 / 3.0;\n\n    // Handle cases where points coincide\n    bool abEqual = all(equal(A, B));\n    bool bcEqual = all(equal(B, C));\n    bool acEqual = all(equal(A, C));\n    \n    if (abEqual && bcEqual) {\n        return distance(pos, A);\n    } else if (abEqual || acEqual) {\n        return sdf_line_partition(pos, B, C);\n    } else if (bcEqual) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    // Handle colinear points\n    if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < EPSILON) {\n        return sdf_line_partition(pos, A, C);\n    }\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) * ONE_THIRD;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if (h >= 0.0) {\n        // One root\n        h = sqrt(h);\n        vec2 x = 0.5 * (vec2(h, -h) - q);\n        vec2 uv = sign(x) * pow(abs(x), vec2(ONE_THIRD));\n        float t = saturate(uv.x + uv.y - kx) + EPSILON;\n        vec2 q = d + (c + b*t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0*b*t, q);\n    } else {\n        // Three roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0)) * ONE_THIRD;\n        float m = cos(v);\n        float n = sin(v) * SQRT3;\n        vec3 t = saturate(vec3(m+m,-n-m,n-m)*z-kx) + EPSILON;\n        vec2 qx = d + (c+b*t.x)*t.x;\n        float dx = dot(qx, qx);\n        float sx = cross2(c+2.0*b*t.x, qx);\n        vec2 qy = d + (c+b*t.y)*t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c+2.0*b*t.y, qy);\n        res = (dx < dy) ? dx : dy;\n        sgn = (dx < dy) ? sx : sy;\n    }\n    \n    return sign(sgn) * sqrt(res);\n}\n\n// Signed distance to a segment of a control polygon\nfloat sdf_control_segment(in vec2 p, in vec2 A, in vec2 B, in vec2 C) {\n    return abs_min(sdf_line(p, A, B), sdf_line(p, B, C));\n}\n\n\n// Signed distance to a quadratic Bezier shape made from a given control polygon\nfloat sdf_bezier_shape(in vec2 p, in vec2 controlPoly[CAPACITY])\n{\n    // Determine closest segment in control polygon\n    vec2 closest[3];\n    \n    // Signed distance to a control polygon\n    // Identifies and returns distance to the closest segment.\n    // Cycle through segments and track the closest\n    float d = INF;\n    float ds = 0.0;\n\n    // First n-2 segments\n    vec2 c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    vec2 prev = c;\n    for (int i = 1; i < CAPACITY - 1; ++i) {\n        prev = c;\n        c = 0.5 * (controlPoly[i] + controlPoly[i+1]);\n        ds = sdf_control_segment(p, prev, controlPoly[i], c);\n        if (abs(ds) < abs(d)) {\n            closest[0] = prev;\n            closest[1] = controlPoly[i];\n            closest[2] = c;\n            d = ds;\n        }\n    }\n\n    // Last-but-one segment\n    prev = c;\n    c = 0.5 * (controlPoly[CAPACITY-1] + controlPoly[0]);\n    ds = sdf_control_segment(p, prev, controlPoly[CAPACITY-1], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[CAPACITY-1];\n        closest[2] = c;\n        d = ds;\n    }\n\n    // Last segment\n    prev = c;\n    c = 0.5 * (controlPoly[0] + controlPoly[1]);\n    ds = sdf_control_segment(p, prev, controlPoly[0], c);\n    if (abs(ds) < abs(d)) {\n        closest[0] = prev;\n        closest[1] = controlPoly[0];\n        closest[2] = c;\n        d = ds;\n    }\n    // d = distance to outer control polygon\n    // Refine by determining actual distance to curve of closest segment\n    return sdf_bezier(p, closest[0], closest[1], closest[2]);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdIsland(vec2 p,vec2 seed)\n{\n    // Control polygon shape\n    vec2 controlPoints[CAPACITY];\n    \n    float tt1 = seed.x;\n    float tt2 = seed.y;\n    for (int i=0;i<8;i++)\n    {\n        float a = ((-6.28)/8.0) * float(i);\n        float x = sin(a)*1.4;\n        float y = cos(a);\n        vec2 pos = vec2(x,y);\n        vec2 hash = hash2(pos+vec2(tt1*0.15,tt1*0.35));\n        hash = 0.5+sin(tt2+sin(hash*151.45))*0.5;\n        float rad = 0.65+(hash.x*0.6);\n        rad -= hash.y*0.55;\n        controlPoints[i] = vec2(x,y)*rad;\n    }\n    // Distance to shape\n    return sdf_bezier_shape(p, controlPoints);\n}\n\nfloat opExtrusion( in vec3 p, float dd, in float h )\n{\n    float d = dd;\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec3 GetWater(vec2 p)\n{\n    const vec3 col = vec3(0.02,.3,.55);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    vec4 d = vec4(iDate*.22);\n    d.xy = p;\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    float v = pow(min(min(v1,v2),v3), 7.)*15.;\n    return col+vec3(v,v,v);\n}\n\nfloat basemat;\n\nvec3 GetCol(float mat,vec3 pos)\n{\n    if (mat<=1.0)\n    {\n        float sandline = abs(sin(fract(22.0*(pos.z+sin(pos.x*6.0)*0.02))));\n        sandline = (1.0-step(sandline,0.5))*0.05;\n        vec3 sandcol =  vec3(0.9,0.85,0.2);  \n        return sandcol+=sandcol*sandline;    \n    }\n    else if (mat<=2.0)\n    {\n        float grassline = 0.5+sin(fract(5.0*(pos.x-pos.z*1.2))*6.28)*0.5;\n        grassline = smoothstep(0.35,0.65,grassline)*0.4;\n        vec3 grasscol = vec3(0.05,0.6,0.05);\n        return grasscol += grasscol*grassline;\n    }\n    return GetWater(pos.xz);\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 seed = vec2(floor(iTime*0.25),fract(iTime*0.2)*6.28);\n    float dd1 = sdIsland(pos.xz,seed);\n    \n    float height = 0.05;\n    float d1 = opExtrusion(pos,dd1,height)-0.04;\n\n    height = 0.025;\n    float d2 = opExtrusion(pos+vec3(0.0,0.1,0.0),dd1-0.2,height)-0.02;\n    \n    basemat = 0.5;\n    if (d2>d1)\n      basemat = 1.5;\n    d1 = smin(d1,d2,0.05);\n    \n    float wd = pos.y+0.15;\n    \n    if (wd<d1)\n        basemat=2.5;\n    \n    d1 = smin(d1,wd,0.25);\n    \n    return d1;\n}\n\n\n    \n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n#define ZERO (min(iFrame,0))\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n//        n += e*map(pos+0.0005*e);\n        n += e*map(pos+0.05*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n    \n    \n#define AA 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n        float an =0.0;//0.25*iTime;\n    float hh = mix(0.75,1.5, 0.5+sin(iTime)*0.5);\n    \n\tvec3 ro = vec3( 3.*cos(an), hh, 3.*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 20.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        vec3 col = vec3(0.4,0.5,0.9);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            vec3 basecol = GetCol(basemat,pos);\n            col = vec3(0.1,0.1,0.1)*amb + basecol*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3W3.jpg", "access": "shaders20k", "license": "mit", "functions": [[2243, 2278, 2314, 2314, 2346], [2348, 2375, 2403, 2403, 2436], [2437, 2437, 2463, 2463, 2496], [2498, 2539, 2572, 2572, 2610], [2612, 2638, 2687, 2687, 2815], [2817, 2894, 2953, 2953, 3161], [3163, 3323, 3387, 3387, 5305], [5307, 5360, 5431, 5431, 5491], [5494, 5575, 5641, 5693, 7142], [7144, 7144, 7166, 7197, 7287], [7289, 7289, 7351, 7351, 7393], [7395, 7417, 7458, 7458, 7547], [7549, 7549, 7583, 7612, 8156], [8158, 8158, 8212, 8212, 8325], [8327, 8327, 8350, 8350, 8756], [8774, 8774, 8807, 8807, 9344], [9346, 9346, 9372, 9372, 9859], [9867, 9961, 9993, 9993, 10595], [10620, 10620, 10677, 10701, 12328]]}
{"id": "7lV3Wt", "name": "Spiral Gallery", "author": "SnoopethDuckDuck", "description": "It's nothing special but I like how it looks", "tags": ["e"], "likes": 11, "viewed": 165, "published": "Public API", "date": "1638548918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv -= 0.2 * vec2(cos(0.2 * iTime), sin(0.2 * iTime));\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n\n    float sc = 12. + 1. * cos(10. * uv.x + iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float v = h21(ipos);\n    float t = 11. * v + iTime;\n    vec2 p = cos(t) * 0.2 * vec2(cos(2. * v * t), sin(2. * (1.-v) * t));\n    float d = mlength(fpos - p);\n    float k = 0.5 + 0.4 * cos(t);\n    float s = smoothstep(-k,k, 0.25 + 0.25 * thc(4., 20. * v + iTime) - d);\n    s *= 2. * s;\n    vec3 col = step(d, 0.45) * pal(1. * mlength(uv) + 0.08 * fract(s + atan(fpos.y, fpos.x)/pi + t) - 0.2 * t, vec3(0.6), vec3(0.6), vec3(1.), 0.22 * (1. + cos(ceil(4. * v) * s + t)) * vec3(0.,0.33,0.66));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lV3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 1508]]}
{"id": "7lyGDK", "name": "Open Space", "author": "ivatronx", "description": "The Place The Singularity ", "tags": ["spiral", "space", "liquid", "trigonometry"], "likes": 3, "viewed": 28, "published": "Public", "date": "1638325329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932;\n\nfloat atanM(float y, float x){\n    if(x >= 0.){\n        return atan(y/x)/pi/2.+.75;\n    }\n    return (pi+2.*atan(y/x))/4./pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    int amount = 2;\n    float width = 2.5;\n    float speed = 0.05;\n    float speed2 = 0.075;\n    float speed3 = 0.10;\n    vec3 color1 = vec3(2.0, 2.6, 2.9);\n    vec3 color2 = vec3(-0.1, 0.0, 0.1);\n    vec3 color12 = vec3(1.0, 2.5, 2.0);\n    vec3 color22 = vec3(-0.11, 0.11, 0.11);\n    vec3 color13 = vec3(2.3, 2.9, 2.0);\n    vec3 color23 = vec3(-0.01, 0.01, 0.01);\n    \n\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col;\n    vec3 col2;\n    vec3 col3;\n    float d = length(uv);\n    float d2 = length(uv)/50.;\n    float d3 = length(uv)/80.0;\n    d -= iTime*speed;\n    d2 -= iTime*speed2;\n    d3 -= iTime*speed3;\n\n    float mascara = smoothstep(R.y/2.+width*2., R.y/2.-width*2., (length(uv)));\n    float mascara2 = smoothstep(R.y/2.+width*2., R.y/2.-width*2., tan(tan(length(uv.x*30.) + length(uv.y/-30.))));\n    \n    col = vec3(tan(tan(2.*pi*atanM(uv.y, uv.x)+d*width)*float(amount))+1.)/2.;\n    col2 = vec3(cos(tan(4.*pi*atanM(uv.y, uv.x)+d2*width)*float(amount))+1.)/2.;\n    col3 = vec3(cos(tan(2.*pi*atanM(uv.y, uv.x)+d3*width)*float(amount))+1.)/2.;\n    col = color1+col2*(color2-color1);\n    col *= mascara;\n    col2 = color23+col3*(color13-color22);\n    col2 *= mascara2;\n    col3 = color22+col2*(color12-color23);\n    col3 *= mascara2;\n    fragColor = vec4(col-col2-col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 165], [167, 167, 224, 224, 1533]]}
{"id": "7st3Rn", "name": "Natural light", "author": "Vinicius_Jesus", "description": "Test with natural light", "tags": ["light"], "likes": 5, "viewed": 44, "published": "Public", "date": "1639068016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 500\n\nfloat sdSphere(in vec3 pos, float rad){\n    float d = length(pos)-rad;\n    return d;\n}\n\nfloat distBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin(in float a, in float b, float k){\n    float h = max(k - abs(a-b), 0.);\n    return min(a,b) - h*h/(k*4.);\n}\n\nfloat smax(in float a, in float b, float k){\n    float h = max(k - abs(a-b), 0.);\n    return max(a,b) + h*h/(k*4.);\n}\n\n//in progress\nfloat grassFloor(vec3 p) {\n\treturn p.y+(texture(iChannel0,p.xz*0.05).xyz+texture(iChannel0,p.xz*0.008).xyz).x*1.5;\n}\n\nvec2 getDist(in vec3 pos, float aTime){\n    \n    // ground\n    float d = pos.y;\n    \n    vec2 res = vec2(d, 1.);\n    \n    vec3 cen = vec3(0.5, 0.9, 0.);\n    d = sdSphere(pos-cen, .35);\n    if(d<res.x) res = vec2(d, 2.);\n    \n    cen.x *= -1.;\n    d = min(d, distBox(pos-cen, vec3(0.3, 0.3, 0.3)));\n    if(d<res.x) res = vec2(d, 3.);\n    \n    return res;\n}\n\nvec2 map(in vec3 pos, float time) {\n    vec2 d = getDist(pos, time);\n    \n    float d2 = pos.y - (-.25);\n    \n    return (d2<d.x) ? vec2(d2, 1.) : d;\n}\n\nvec3 calcNormal(in vec3 pos, float time) {\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(map(pos+e.xyy, time).x-map(pos-e.xyy, time).x,\n                          map(pos+e.yxy, time).x-map(pos-e.yxy, time).x,\n                          map(pos+e.yyx, time).x-map(pos-e.yyx, time).x));\n} \n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float time) {\n    vec2 res = vec2(-1.,-1.);\n    \n    float tmin = .5;\n    float tmax = 20.;\n    \n    float t = tmin;\n    for(int i=0; i<MAX_STEPS && t<tmax; i++) {\n    \n        vec3 pos = ro + rd * t; \n        vec2 h = map(pos, time);\n        \n        if(abs(h.x)<(.001*t)) {\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }  \n    \n    return res;\n}\n\nfloat calcSoftshadow(in vec3 ro, vec3 rd, float time){\n    float res = 1.0;\n    \n    float tmax = 12.0;\n    float tp = (3.4-ro.y)/rd.y;\n    \n    if( tp>0.0 ) tmax = min( tmax, tp );  \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, 1.) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, float time) {\n    \n    float occ = 0.;\n    float sca = 1.;\n    \n    for(int i=0; i<5; i++) {\n        float h = .01 +.11 * float(i)/4.;\n        vec3 opos = pos + h * nor;\n        float d = map(opos, time).x;\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2.*occ, 0., 1.);\n}\n\nvec3 render(in vec3 ro, vec3 rd, float time) {\n    \n    //sky\n    vec3 col = vec3(0.5, .8, .9) - max(rd.y, 0.)*.5;\n    \n    vec2 res = rayMarch(ro, rd, time);\n    \n    if (res.y > 0.) {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, time);\n        vec3 ref = reflect(rd, nor);\n        \n        vec3 mat = vec3(0.);\n        \n        if(res.y<1.5) //floor material\n        {\n            mat += .2*vec3(.11, .2,.04);\n            \n        } else if(res.y<2.5) // sphere\n        {\n            mat = vec3(.2, .1, .02);\n            \n        } else if(res.y<3.5) // boc\n        {\n            mat = vec3(.2, .1, .02);\n        }\n        \n        //see normal\n        //col = vec3(nor)*.5+.5;\n        \n        //simple lighting\n        //vec3  light_pos = normalize( vec3(0.0, 0.35, 0.5) );\n        //float light = clamp(dot( nor, light_pos ), 0.0, 1.0 );\n        \n        //col = vec3(light);//*.5+.5;\n        \n        // lighting 2 \n        float occ = calcOcclusion(pos, nor, time);\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3 sun_dir = normalize( vec3(cos(time) * .08, 0.4, sin(time)) );\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0 );\n        float sun_sha = step(rayMarch( pos+0.001*nor, sun_dir,time ).y, 0.);\n        \n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0 );\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0 );\n        \n        float sky_ref = smoothstep(0., .3, ref.y);\n\n        col = mat*vec3(10.0,6.0,3.0)*sun_dif*sun_sha;\n        col += mat*vec3(.4, .7, 1.)*sky_dif*occ;\n        col += mat*vec3(.40,1.0,.40)*bou_dif*occ;\n        col += mat*vec3(.2,.6,.5)*fre*8.*(.5+.5*sky_dif*occ);\n        \n        col += sky_ref*.05*vec3(.4, .7, 1.)*sky_dif*occ;\n    \n    }\n    \n    return col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    \n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.);\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 offset = -.5+vec2(float(m), float(n))/float(AA);\n        \n        vec2 p = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        time *= .9;\n\n        //camera\n        float an = 10.*iMouse.x/iResolution.x;\n        float cd = .0;//.9*sin(time);\n        vec3 ta = vec3(.0, .9, .2+cd);\n        vec3 ro = ta + vec3(1.5*sin(an),.0,1.5*cos(an));\n\n        mat3 cam = setCamera(ro, ta, 0.);\n\n        vec3 rd = cam * normalize(vec3(p, 1.8));\n\n        vec3 col = render(ro, rd, time);\n\n        //gama correction\n        col = pow(col, vec3(.4545));\n        \n        tot += col;\n    }\n    \n    tot /= float(AA*AA);\n\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7st3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 62, 62, 109], [111, 111, 142, 142, 223], [225, 225, 269, 269, 342], [344, 344, 388, 388, 461], [463, 477, 503, 503, 593], [595, 595, 634, 653, 950], [952, 952, 987, 987, 1103], [1105, 1105, 1147, 1147, 1401], [1404, 1404, 1455, 1455, 1827], [1829, 1829, 1883, 1883, 2281], [2283, 2283, 2342, 2342, 2628], [2630, 2630, 2676, 2691, 4476], [4478, 4478, 4528, 4528, 4707], [4723, 4723, 4780, 4780, 5603]]}
{"id": "7t3SDM", "name": "Tetragrammaton", "author": "4eckme", "description": "https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%82%D1%80%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%D1%82%D0%BE%D0%BD#/media/%D0%A4%D0%B0%D0%B9%D0%BB:Tetragrammaton_Sefardi.jpg", "tags": ["tetragrammaton"], "likes": 26, "viewed": 1891, "published": "Public", "date": "1639209584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c,in vec2 oo){\nvec2 R=iResolution.xy;float n=(min(R.x,R.y))/320.0;oo/=n;oo-=R/n/2.0;\nvec2 o = oo;float y=floor(o.y/2.0);float x=floor(o.x/2.0);\nfloat r=(x*x+y*y)-iTime;float r2=sqrt(x*x+y*y);\nc=(vec4(ceil(sin(r))+mod(y,2.0))+vec4(ceil(cos(r))+mod(x,2.0)))*(vec4(ceil(sin(r2))+mod(y,2.0))+vec4(ceil(cos(r2))+mod(x,2.0)));\nif(c.x<0.0) c=vec4(1); if (c.x>1.0) c=vec4(1);\nif(abs(x)>64.0||abs(y)>64.0) c=vec4(1);\nif(abs(x)>56.0)c-=mod(x,2.0)*mod(y,2.0);\nif (abs(y-x)>72.0&&abs(y-x)<90.0)c-=mod(x,2.0)*mod(y,2.0);\nif(abs(y)>56.0)c-=mod(x,2.0)*mod(y,2.0);\nif (abs(y+x)>72.0&&abs(y+x)<90.0)c-=mod(x,2.0)*mod(y,2.0);\nif(r2<49.0&&r2>38.0)c-=mod(x,2.0)*mod(y,2.0);\nx=float(int(x)/2);y=float(int(y)/2);float r3=pow(x,2.0)+pow(y,2.0);\nfloat r0=(float(int(o.x+256.0)/2))*(float(int(o.x+256.0)/2))+(float(int(o.y+256.0)/2))*(float(int(o.y+256.0)/2))-iTime;\nif((y)>33.0&&(y)<37.0&&abs(x)<37.0) {c+=vec4(ceil(sin(r0+1.0)*4.0));if(mod(o.x,12.0)<=4.0)c=vec4(1);}\nif((y)<-33.0&&(y)>-37.0&&abs(x)<37.0) {c+=vec4(ceil(sin(r0+2.0)*4.0));if(mod(o.x,12.0)<=4.0)c=vec4(1);}\nif((x)>33.0&&(x)<37.0&&abs(y)<37.0) {c+=vec4(ceil(sin(r0+3.0)*4.0));if(mod(o.y,12.0)<=4.0)c=vec4(1);}\nif((x)<-33.0&&(x)>-37.0&&abs(y)<37.0) {c+=vec4(ceil(sin(r0+4.0)*4.0));if(mod(o.y,12.0)<=4.0)c=vec4(1);}\nif(abs(x)>=33.0&&abs(y)>=33.0&&abs(x)<38.0&&abs(y)<38.0)c=vec4(1);\nif(abs(x)>=34.0&&abs(y)>=34.0&&abs(x)<37.0&&abs(y)<37.0)c=vec4(mod(floor(o.x/2.0),2.0)*mod(floor(o.y/2.0),2.0));\nx*=2.0;y*=2.0;if(abs(x)>75.0||abs(y)>75.0)c=vec4(0);\nif(r2<=48.0&&r2>=46.0)c=vec4(1);\nif(r2<=42.0&&r2>=40.0)c=vec4(1);\nif(r2<=38.0&&r2>=35.0)c=vec4(1);\nif(abs(x)==74.0&&(y)<=74.0&&(y)>=-74.0)c=vec4(1);\nif(abs(y)==74.0&&(x)<=74.0&&(x)>=-74.0)c=vec4(1);\nx=floor((x+26.0)/4.0);\ny=float(int(y)/4);\ny-=4.0;r=(x*x+y*y)-iTime;\nvec2 ok=o;o=vec2(int(o.x)/2,int(o.y)/2)*2.0;\nif(o.x<172.0-o.y&&o.x>154.0-o.y&&abs(o.x)<112.0&&abs(o.y)<114.0&&oo.x>0.0&&oo.y>0.0){ \n    r2=(o.x*o.x+o.y*o.y)/2.0+iTime;\n    if(c.x<0.0)c=vec4(0);\n    if(c.x>1.0)c=vec4(1.0);\n    c+=float(int(mod(floor((o.x+o.y)/8.0),8.0)*mod(floor((o.x-o.y+iTime*8.0)/4.0),4.0)==0.0));\n}else if(o.x>-170.0-o.y&&o.x<-150.0-o.y&&abs(o.x)<110.0&&(o.y)>-112.0&&o.x<0.0&&o.y<0.0){\n    r2=(o.x*o.x+o.y*o.y)/2.0+iTime;\n    if(c.x<0.0)c=vec4(0);\n    if(c.x>1.0)c=vec4(1.0);\n    c+=float(int(mod(floor((o.x+o.y)/8.0),8.0)*mod(floor((o.x-o.y+iTime*8.0)/4.0),4.0)==0.0));\n}else if(o.x<170.0+o.y&&o.x>150.0+o.y&&abs(o.x)<112.0&&abs(o.y)<112.0&&abs(o.x)<120.0&&o.y<0.0&&o.x>0.0){\n    r2=(o.x*o.x+o.y*o.y)/2.0+iTime;\n    if(c.x<0.0)c=vec4(0);\n    if(c.x>1.0)c=vec4(1.0);\n    c+=float(int(mod(floor((o.x-o.y)/8.0),8.0)*mod(floor((o.x+o.y+(iTime)*8.0)/4.0),4.0)==0.0));\n}else if(o.x>-170.0+o.y&&o.x<-152.0+o.y&&(o.x)>-112.0&&abs(o.y)<114.0){\n    r2=(o.x*o.x+o.y*o.y)/2.0+iTime;\n    if(c.x<0.0)c=vec4(0);\n    if(c.x>1.0)c=vec4(1.0);\n    c+=float(int(mod(floor((o.x-o.y)/8.0),8.0)*mod(floor((o.x+o.y+iTime*8.0)/4.0),4.0)==0.0));\n}  o=ok;if((o.x)>-38.0&&o.x<40.0&&abs(o.y)<14.0){\n    c*=vec4(ceil(sin(r)*4.0));\n    if(c.x<0.0)c=vec4(0);\n    if(c.x>1.0)c=vec4(1.0);\n    c +=mod(floor(o.x/2.0),2.0)*mod(floor(o.y/2.0),2.0);\n} if(r2<47.0&&r2>41.0){\n        r2=(o.x*o.x+o.y*o.y)/1024.0;\n        c*=vec4(ceil(sin(r2)*256.0));\n        if(c.x<0.0)c=vec4(0);\n        if(c.x>1.0)c=vec4(1.0);\n        c +=float(mod(degrees(atan(o.y,o.x))+180.0-iTime*8.0,8.0)<2.0);\n    }if(c.x>1.0)c=vec4(1);\n     if((o.y)>=116.0&&(o.y)<=120.0&&abs(o.x)<118.0)c=vec4(1);\n     if((o.y)<=-114.0&&(o.y)>=-118.0&&abs(o.x)<118.0)c=vec4(1);\n     if((o.x)>=116.0&&(o.x)<=120.0&&abs(o.y)<118.0)c=vec4(1);\n     if((o.x)<=-114.0&&(o.x)>=-118.0&&abs(o.y)<118.0)c=vec4(1);\n     if((o.y)>=126.0&&(o.y)<=130.0&&abs(o.x)<128.0)c=vec4(1);\n     if((o.y)<=-124.0&&(o.y)>=-128.0&&abs(o.x)<128.0)c=vec4(1);\n     if((o.x)>=126.0&&(o.x)<=130.0&&abs(o.y)<128.0)c=vec4(1);\n     if((o.x)<=-124.0&&(o.x)>=-128.0&&abs(o.y)<128.0)c=vec4(1);\n     if(abs(o.y)<112.0&&abs(o.y)>100.0&&abs(o.x)<50.0&&o.x<46.0)c-=vec4(mod(floor(o.x/2.0),2.0)*mod(floor(o.y/2.0),2.0));\n     if(o.y<110.0&&(abs(o.y)<112.0||o.y>-112.0&&o.y<0.0)&&abs(o.x)<112.1){\n         if(abs(float(int(o.x)/2+int(o.y)/2-76))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2+int(o.y)/2+74))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2-int(o.y)/2-75))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2-int(o.y)/2+75))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2+int(o.y)/2-86))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2+int(o.y)/2+84))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2-int(o.y)/2-85))<1.0)c=vec4(1);\n         if(abs(float(int(o.x)/2-int(o.y)/2+85))<1.0)c=vec4(1);\n     }if(ok.y<=108.0&&ok.y>=104.0&&abs(o.x)<40.0)c=vec4(1);\n     if(ok.y>=-106.0&&ok.y<=-102.0&&abs(o.x)<40.0)c=vec4(1);\n     if(ok.y<=114.0&&ok.y>=112.0&&abs(o.x)<60.0&&o.x<64.0)c=vec4(1);\n     if(ok.y>=-112.0&&ok.y<=-110.0&&abs(o.x)<60.0&&o.x<64.0)c=vec4(1);\n     if((o.x)>-134.0&&(o.x)<-132.0&&abs(o.y)<140.0)c=vec4(1);\n     if((o.x)<136.0&&(o.x)>134.0&&abs(o.y)<140.0)c=vec4(1);\n     if((o.y)>-134.0&&(o.y)<-132.0&&abs(o.x)<140.0)c=vec4(1);\n     if((o.y)<136.0&&(o.y)>134.0&&abs(o.x)<140.0)c=vec4(1);\n     if(o.x>146.0&&o.x<150.0&&abs(o.y)<150.0)c=vec4(1);\n     if(o.x<-144.0&&o.x>-148.0&&abs(o.y)<148.0)c=vec4(1);\n     if(o.y>146.0&&o.y<150.0&&abs(o.x)<148.0)c=vec4(1);\n     if(o.y<-144.0&&o.y>-148.0&&abs(o.x)<148.0)c=vec4(1);\n     if(x<0.0&&abs(o.y)<62.0&&abs(o.y)>40.0&&abs(o.x)<112.0&&abs(o.x)>110.0)c=vec4(1);\n     if(x>0.0&&abs(o.y)<62.0&&abs(o.y)>40.0&&o.x<114.0&&o.x>112.0)c=vec4(1);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 5484]]}
{"id": "7t3SRH", "name": "Simple Circle [-1, 1]", "author": "mileslacey", "description": "A simple circle using [-1, 1] cartesian coordinates and correct aspect ratio.", "tags": ["circle"], "likes": 1, "viewed": 20, "published": "Public", "date": "1638688901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec4 circle(in vec2 pos, in float radius, in vec4 color, in vec2 uv)\n{\n\tfloat amInPoint = length(pos - uv) / radius;\n\treturn color * (1.f-step(1.f, amInPoint));\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.f);\n\tvec2 uv = aspect * (vec2(2.f) * (fragCoord.xy / iResolution.xy) - vec2(1.f));\n\n    // Time varying pixel color\n    vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t// Circle\n\tvec4 circle0 = circle(vec2(0.f, 0.f), 0.75f, vec4(color, 1.f), uv);\n\t\n\t// Blend the two\n\tfragColor = circle0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 72, 72, 164], [170, 170, 227, 227, 583]]}
{"id": "7t3SRN", "name": "Sliced harmonics [241 chars]", "author": "hnh", "description": "Depth-illusion of some deformed grid. \nBased on the previous [url]https://www.shadertoy.com/view/slV3Rz[\\url].", "tags": ["2d", "grid", "onetweet", "golf"], "likes": 1, "viewed": 64, "published": "Public API", "date": "1639396491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on the previous https://www.shadertoy.com/view/slV3Rz\n// by squeezing out some more geometric variety. It produces\n// a minimalistic depth illusion of some sliced iso-surfaces.\n// Thanks to XOR for substancial golfing support in the base\n// version and general teachings from FabriceNeyret2 and Shane.\n\n\nvoid mainImage(out vec4 O, vec2 p){\n    float a = iTime*.1;\n    p = p/iResolution.y*4. + sin(a+vec2(8,0))*20.;  // camera\n    p *= sin(cos(p+a))*.2;  // deform\n\n    vec2 s = floor(p + (p.x + p.y)*.4);  // tilted grid, depth illusion\n    s = .6 - step(p -= s - (s.x + s.y)*.21, p.yx)*.4;\n    s *= exp(.5-8.*length(p*p-s));\n    \n    O = s.x*8. + s.y*vec4(.02,.5,2.5,1);  // colors\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 313, 348, 348, 693]]}
{"id": "7t3SW8", "name": "Shuffle box", "author": "tdhooper", "description": "Just some more noodling with dispersion", "tags": ["refraction", "dispersion"], "likes": 94, "viewed": 1589, "published": "Public API", "date": "1638990293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 10.;\n    const float MAX_BOUNCE = 5.;\n#else\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 5.;\n#endif\n\n//#define ALTERNATIVE\n//#define ALTERNATIVE2\n\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdLine( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\n\nfloat time;\n\nfloat invertg;\n\nfloat sin3(vec3 v) {\n    return sin(v.x) * sin(v.y) * sin(v.z);\n}\n\nvec2 map(vec3 p) {\n\n    float scl = 1.3;\n    p /= scl;\n\n    pR(p.yz, .2 * PI);\n    pR(p.xz, -.25 * PI);\n    \n    float flr = p.y+.5;\n    \n    #ifdef ALTERNATIVE\n    p += sin(p * 08. + (time * vec3(-1,-1,-1) + vec3(0,.5,.75)) * PI * 2.) * .1;\n    #else \n    p += sin(p * 08. + time * vec3(1,3,2) * PI * 2. + vec3(0,.5,3)) * .1;\n    #endif\n    // p += sin(p * 07. + (time * vec3(-1,1,1) + vec3(0)) * PI * 2.) * .1;\n\n    vec3 p2 = p;\n    \n    p += sin3(p * 80.) * .0015;\n    \n    float b = length(p) - .66;\n    b = fBox(p, vec3(.5 - .01)) - .01;\n    \n    float d3 = 1e12;\n    float rr = .0025;\n    p2 = abs(p2);\n    p2 = vec3(vmin(p2.xz), p2.y, vmax(p2.xz));\n    d3 = min(d3, sdLine(p2.xzy - vec3(.5,.7,.5), .2, rr));\n    d3 = max(d3, -vmax(p*vec3(1,-1,-1)));\n\n    #ifdef ALTERNATIVE\n    float e = .1;\n    p.x += sin(p.x * 04. + (time * -1. + .0) * PI * 2.) * e;\n    p.z += sin(p.z * 04. + (time * -1. + sign(p.x) * .25 + .25) * PI * 2.) * e;\n    p.y += sin(p.y * 04. + (time * -1. + sign(p.z) * .25) * PI * 2.) * e;\n    #else\n    p += sin(p * 06. + time * vec3(-3,2,1) * PI * 2. * 1. + vec3(.1,.5,.6)) * .1;\n    #endif\n\n    b = smax(b, -vmin(abs(p)) + .0125, .01);\n\n    float d2 = b + .1;\n    \n    float d = max(b, -d2 + .01);\n    \n    d *= invertg;\n    \n    d2 = max(d2+.001, b);\n    \n    float id = 1.;\n    \n    if (d2 < d) \n    {\n        id = 3.;\n        d = d2;\n    }\n    \n    #ifndef ALTERNATIVE2\n    if (d3 < d) {\n        d = d3;\n        id = 4.;\n    }\n    #endif\n   \n    d *= scl;\n    return vec2(d, id);\n}\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.86,.8,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n    invertg = invert;\n\n    for (float i = 0.; i < 800.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x;\n        steps += 1.;\n        res = candidate;\n        if (dist < .00005) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\n// Hex tiling, FabriceNeyret2\n// https://www.shadertoy.com/view/4dKXR3\nfloat hex(vec2 U) { \n    \n    U *= mat2(1,-1./1.73, 0,2./1.73) *5.;      // conversion to\n    vec3 g = vec3(U,1.-U.x-U.y), g2,           // hexagonal coordinates\n        id = floor(g);                         // cell id\n\n    g = fract(g);                              // diamond coords\n    if (length(g)>1.) g = 1.-g;                // barycentric coords\n    g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    // length(g2)     = distance to center  \n    return length(1.-g2);\n\n}\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef ALTERNATIVE\n    float duration = 4.;\n    #else\n    float duration = 8.;\n    #endif\n    time = mod(iTime / duration + .1, 1.);\n    //time= 0.;\n    \n    envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    #ifdef ALTERNATIVE2\n    uv /= 3.;\n    #endif\n    \n    #ifdef ALTERNATIVE\n    float h = hex(uv.yx * 1.08 + time * vec2(.1,.172) * -2.);\n    #else\n    float h = hex(uv.yx * 1.08 + time * vec2(.1,.172) * 2.);\n    #endif\n    h -= .03;\n    h /= length(fwidth(uv * 10.));\n    h = 1. - saturate(h);\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n\n    vec3 bgCol = BGCOL * .08 * .5;\n    vec3 bgCol2 = bgCol * .3;\n    bgCol = mix(bgCol, bgCol2, h);\n\n    invert = 1.;\n    maxDist = 15.; \n    \n    float fl = 20.;\n    \n\tcamOrigin = vec3(0,0,9.5 * fl);\n   \tcamDir = normalize(vec3(uv * .168, -fl));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist * fl, .6);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n\t\tfloat rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n        vec3 nor;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, 1.2, .6);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n            \n            if ( res.y == 4.) {\n                break;\n            }\n            \n            nor = normal(p);            \n            ref = reflect(rayDir, nor);\n            \n            if (res.y > 1.) {\n                break;\n            }\n\n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n\n            // refract\n            float ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n            \n        }\n        \n        if (res.y > 1.) {\n            sam = vec3(0);\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n            vec3 cc = res.y == 2. ? vec3(1) : vec3(.033);\n            rayDir = refract(rayDir, nor, 1./1.3);\n            sam += env(p, rayDir) * cc;\n        }\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE;\n            break;\n        }\n        \n        if (res.y < 2.) {\n            sam += env(p, rayDir);\n        }\n\n        vec3 extinction = vec3(.5,.5,.5) * .0;\n        extinction = 1. / (1. + (extinction * extinctionDist));\t\n        col += sam * extinction * spectrum(-wavelength+.25);\n\t}\n    \n    col /= MAX_DISPERSE;\n\n    if (bounceCount == 0. && res.y == 0.) {\n        col = bgCol;\n    }\n\n    if (res.y == 4.) {\n        col = bgCol2;\n    }\n    \n    col = pow(col, vec3(1.19)) * 2.5;\n    \n    col = tonemap2(col);\n        \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3SW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 338, 370, 370, 415], [417, 417, 456, 456, 548], [550, 550, 570, 570, 595], [597, 597, 617, 617, 642], [644, 644, 664, 664, 699], [701, 701, 721, 721, 756], [758, 758, 786, 786, 867], [869, 869, 897, 897, 978], [980, 980, 1022, 1022, 1081], [1083, 1148, 1216, 1216, 1259], [1261, 1261, 1285, 1285, 1383], [1386, 1548, 1568, 1568, 1613], [1615, 1615, 1633, 1633, 3126], [3128, 3289, 3386, 3386, 3681], [3705, 3705, 3743, 3743, 4113], [4115, 4115, 4151, 4151, 4390], [4554, 4618, 4646, 4646, 4849], [4926, 4926, 5009, 5009, 5589], [5591, 5591, 5622, 5622, 5880], [5882, 5882, 5932, 5932, 6075], [6077, 6148, 6167, 6167, 6646], [6648, 6710, 6740, 6740, 6907], [6909, 6909, 6966, 6966, 11207]]}
{"id": "7t3Szj", "name": "Stomper", "author": "dr2", "description": "A stomper's job is never done...", "tags": ["randomness", "kinematics"], "likes": 17, "viewed": 145, "published": "Public API", "date": "1639392925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Stomper\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2f (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit, pStomp;\nvec2 pAct, pActP;\nfloat tCur, dstFar, boxSz, tCyc, tPhs;\nint idObj;\nint idPlat = 1, idBallR = 2, idBallM = 3, idStomp = 4, idTube = 5, idGrnd = 6;\nconst float pi = 3.1415927;\n\nstruct TbCon {\n  vec3 pLo, pHi;\n  vec2 aLimCs, tRotCs[2], pRotCs[2];\n  float chLen, chDist, ang, rad;\n};\nTbCon tbCon;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, a;\n  dMin = dstFar;\n  q = p;\n  db = PrBox2Df (q.xz, vec2 (boxSz));\n  d = max (PrBoxDf (q, vec3 (vec2 (boxSz + 0.5), 0.5).xzy), - max (db,\n     PrCylDf (vec3 (fract (q.xz) - 0.5, q.y - 0.5), 0.4, 0.8)));\n  DMINQ (idPlat);\n  d = max (db, - PrBox2Df (q.xz - pAct, vec2 (0.5)));\n  q.xz = fract (q.xz) - 0.5;\n  d = max (PrSphDf (vec3 (q.xz, q.y - 0.15).xzy, 0.4), d);\n  DMINQ (idBallR);\n  q = p;\n  q.xz -= pAct;\n  q.y -= 0.15;\n  if (tPhs < 0.8) q.y -= 0.4 * (1. - cos (10. * pi * tCyc));\n  d = PrSphDf (q, 0.4);\n  DMINQ (idBallM);\n  q = p;\n  q -= pStomp;\n  d = min (PrCylDf (q.xzy, 0.35, 0.05), max (PrCapsDf (q.xzy, 0.1, 0.3), - q.y));\n  DMINQ (idStomp);\n  q = p;\n  q.xz -= tbCon.pLo.xz;\n  d = PrCylDf (q.xzy, 0.4, 0.5);\n  DMINQ (idPlat);\n  q.y -= 0.5;\n  d = max (PrCapsDf (q.xzy, 0.1, 0.3), - q.y);\n  DMINQ (idTube);\n  d = min (PrSphDf (p - tbCon.pLo, 0.1), PrSphDf (p - tbCon.pHi, 0.1));\n  DMINQ (idTube);\n  q = p - tbCon.pLo;\n  q.xz = Rot2Cs (q.xz, tbCon.tRotCs[0]);\n  q.yz = Rot2Cs (q.yz, tbCon.tRotCs[1]) - vec2 (tbCon.chLen, tbCon.chDist);\n  a = fract ((256. / tbCon.ang) * atan (q.y, - q.z) / (2. * pi));\n  d = max (dot (vec2 (abs (q.y), - q.z), tbCon.aLimCs), length (vec2 (length (q.yz) -\n     tbCon.rad, q.x)) - (0.1 - 0.015 * smoothstep (0.15, 0.35, 0.5 - abs (0.5 - a))));\n  DMINQ (idTube);\n  q = p;\n  d = max (q.y - 0.4, - db);\n  DMINQ (idGrnd);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjT;\n  return 0.5 + 0.5 * sh;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid SetConf ()\n{\n  vec3 vp;\n  float tubeLen;\n  boxSz = 4.;\n  tCyc = tCur / 2. + 1.;\n  tPhs = fract (tCyc);\n  pAct = floor (boxSz * (2. * Hashv2f (1.11 + 17.33 * floor (tCyc)) - 1.)) + 0.5;\n  pActP = floor (boxSz * (2. * Hashv2f (1.11 + 17.33 * floor (tCyc - 1.)) - 1.)) + 0.5;\n  if (tPhs < 0.8) {\n    pStomp.xz = mix (pActP, pAct, tPhs / 0.8);\n    pStomp.y = 1.7;\n  } else {\n    pStomp.xz = pAct;\n    pStomp.y = mix (0.5, 2., max (2. * abs (tPhs - 0.9) / 0.1 - 1., 0.));\n  }\n  tbCon.pLo = vec3 (1.5 * boxSz, 0.9, 0.);\n  tbCon.pHi = pStomp;\n  tbCon.pHi.y += 0.4;\n  vp = tbCon.pHi - tbCon.pLo;\n  tbCon.chLen = 0.5 * length (vp);\n  tbCon.tRotCs[0] = sin (atan (vp.x, vp.z) + vec2 (0.5 * pi, 0.));\n  tbCon.tRotCs[1] = sin (- asin (length (vp.xz) / length (vp)) + vec2 (0.5 * pi, 0.));\n  tubeLen = 1.4 * boxSz;\n  tbCon.ang = SecSolve (tbCon.chLen / tubeLen);\n  tbCon.chDist = tbCon.chLen / tan (tbCon.ang);\n  tbCon.rad = length (vec2 (tbCon.chDist, tbCon.chLen));\n  tbCon.aLimCs = sin (- tbCon.ang + vec2 (0.5 * pi, 0.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  SetConf ();\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idPlat) {\n      col4 = vec4 (0.5, 0.2, 0., 0.2);\n    } else if (idObj == idGrnd) {\n      col4 = vec4 (0.5, 0.2, 0., 0.2) * (0.8 + 0.2 * Fbm2 (4. * ro.xz));\n    } else if (idObj == idBallR) {\n      col4 = vec4 (0., 1., 0., 0.2);\n      if (PrBox2Df (ro.xz - pActP, vec2 (0.5)) < 0.) col4 = mix (vec4 (1., 0., 0., 0.2) *\n         (0.7 + 0.3 * sin (16. * pi * tCur)), col4, smoothstep (0.2, 0.6, tPhs));\n    } else if (idObj == idBallM) {\n      col4 = vec4 (1., 0., 0., 0.2);\n      if (tPhs > 0.9) col4 = vec4 (0.7, 0.5, 0., 0.2);\n    } else if (idObj == idStomp) {\n      col4 = mix (vec4 (1., 1., 1., 0.2), vec4 (0., 0., 1., -1.),\n         smoothstep (0., 0.02, length (qHit.xz) - 0.25));\n    } else if (idObj == idTube) {\n      col4 = vec4 (1., 1., 1., 0.2);\n    }\n    if (idObj == idBallR || idObj == idBallM) col4 *= 0.7 + 0.3 * smoothstep (0., 0.02,\n       abs (length (qHit.xz) - 0.2) - 0.02);\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (idObj == idTube) nDotL *= nDotL;\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n      col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n      col *= 1. - 0.9 * smoothstep (0.2, 0.3, length (ro.xz) / dstFar);\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.13 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -30.);\n  zmFac = 5.5;\n  dstFar = 60.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3Szj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 905, 927, 927, 2330], [2332, 2332, 2365, 2365, 2549], [2551, 2551, 2572, 2572, 2827], [2829, 2829, 2866, 2866, 3145], [3179, 3179, 3205, 3233, 3621], [3623, 3623, 3640, 3640, 4642], [4644, 4644, 4679, 4679, 6261], [6305, 6305, 6361, 6361, 7362], [7364, 7364, 7396, 7396, 7496], [7498, 7498, 7531, 7531, 7620], [7622, 7622, 7655, 7655, 7682], [7684, 7684, 7726, 7726, 7777], [7779, 7779, 7822, 7822, 7886], [7888, 7888, 7924, 7924, 8130], [8132, 8132, 8162, 8162, 8275], [8277, 8277, 8308, 8308, 8372], [8406, 8406, 8430, 8430, 8483], [8485, 8485, 8509, 8509, 8621], [8623, 8623, 8648, 8648, 8834], [8836, 8836, 8857, 8857, 9012]]}
{"id": "7t3Xzr", "name": "SnakePortal", "author": "Del", "description": "just some green stuff", "tags": ["sin", "pattern", "polar"], "likes": 9, "viewed": 132, "published": "Public API", "date": "1638595250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// green stuff - Del 04/12/2021\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n} \nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec3 col1 = vec3(0.01,0.03,0.01);\n    vec3 col2 = vec3(0.5,0.9,0.3);\n    vec2 uv = (p.xy - 0.5 * iResolution.xy) / iResolution.y;\n\nuv *= rotate(fract(iTime*0.01)*6.28);\n    \n    float dd2 = length(uv);\n    float dd1 = smoothstep(0.0,0.3,dd2);\n\n    //if (abs(uv.x)>0.2)\n        col2 *= 1.0-abs(uv.x*0.75);\n        col1 *= 1.0-abs(uv.x*0.75);\n\n    float dnoise = 15.0*(dd1);\n    //uv *= rotate(-dnoise*0.05);\n    \n    float dns = 0.5+sin(iTime*.45)*0.5;\n    dnoise = mix(dnoise,0.0,dns);\n    \n    float oo = 0.5+sin(dnoise+uv.y+uv.x*12.0+iTime*0.5)*0.5;\n    uv = smoothRot(uv,6.0,0.085,16.0,.075*oo);\n    vec2 d = uv*5.0;\n    d.x += fract(iTime);\n    float v1=length(0.5-fract(d.xy))+0.58;\n    d = (uv*1.75);\t\t\t// zoom\n    float v2=length(0.5-fract(d.yy))-0.1525;\t\t// border\n    v1 *= 1.2-v2*v1;\n    v1 = smoothstep(0.1,0.9,v1);\n    vec3 col = mix(col2,col1,v1)*dd1;\n    k = vec4(col*4.75,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3Xzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 88, 88, 255], [257, 257, 279, 279, 346], [348, 348, 384, 384, 1283]]}
{"id": "7tcSDn", "name": "Voronoi [Border Skipping]", "author": "Yusef28", "description": "In this version I am reducing the number of border intersection tests by approximately half for each step. I discard any borders created with cells that are outside a given angle from the ray direction since it can't hit those. \nit's like +20 fps! lol", "tags": ["2d", "voronoi", "commented", "borders", "edges", "comments", "traversal"], "likes": 13, "viewed": 154, "published": "Public API", "date": "1638937885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n5. My first attempt at a voronoi traversal with comments\n   https://www.shadertoy.com/view/NltSRM\n=============================================================\n\nA new thing I thought of. We don't need to check 9 borders\n(I mean since that's how I've been doing it), because we know\nthe direction of the rd and we know that we check cells roughly at\nspecific angles on the cartesian grid based on the for i for j loop.\nso we can take the dot product of each id and the rd and if that\nangle is greater than 180 degrees we can skip the whole calculation\nincluding the intersection because the ray isn't moving in that\ndirection. \n\nMy only issue is that the border segments I am testing against\nare a set length and that leads to the rare case where a segment\ngets intersected with that shouldn't. Increasing the test angle \n(by reducing \"TEST_ANGLE\") from 0. to -0.1 or even -0.3 should get rid\nof this.\n\nSo the maximum gain is x2 since for every step we do only 4 intersections\ninstead of 8.\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\n\n///////////////////////////////////////////////////////////////\n//\n// TEST_ANGLE is the angle between the rd and the id that\n// we check. So if rd is (1.,0.) and the current for loop id\n// is (-1.,0.) that border will be in close to the opposite\n// direction of the rd so we don't need to check for an intersection\n// with that border!\n//\n// 0. fails in only one spot as far as I could tell. \n// So anything more that 180 degrees\n// from the rd's direction doesn't need to be checked\n// 0.3 is max and you get some issues already there\n//\n////////////////////////////////////////////////////////////////\n\n//to be safe I went -0.1\n#define TEST_ANGLE -0.1\n\n//a method for finding the intersection between\n//two rays. Not effienct but very memorable.\nfloat seg_seg(vec2 ro1, vec2 rd1, vec2 A, vec2 B){\n    vec2 ro2 = A;\n    vec2 rd2 = normalize(B-A);\n    float maxABLange = length(B-A);\n    \n    vec2 perp = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perp) - dot(ro2,perp))/dot(rd2,perp);\n    perp = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perp) - dot(ro1,perp))/dot(rd1,perp);\n    return t >= 0. && s >= 0.? t : 100.;\n}\n\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n/***************************************************\n\nHere is the actual voronoi traversal algorithm\n\n*************************************************** */\nfloat voronoiEdgeHit(vec2 uv, vec2 ro, vec2 rd, inout vec3 line_color){\n\n    vec2 st = fract(ro);\n    vec2 stFL = floor(ro);\n    vec2 d = vec2(10.);\n\n    vec2 pointA;\n    vec2 pointB;\n\n\n    float minT = 100.;\n    float t;\n\n    \n    //in this loop we are just looking for the closest point\n    //to the curent ro. It's a standard voronoi but instead of uv\n    //for every pixel we just have ro (the same value) being looked at\n    //every pixel (you wont see \"ro\" here because of what I did above.\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testA = stFL + coords;\n        float c = length(coords.xy - st);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            pointA = testA;\n            \n            }\n        }\n    }    \n    \n    //In this loop I am finding every edge based on Iq's article\n    //meaning I get a new st an stFLoor based on pointA\n    //and find borders around pointA based on that.\n    \n    //so for each edge I check to see where it intersects \n    //with the ray based on ro and rd. We look at 25 edges\n    //around our pointA and the edge that we hit first (minimum t value)\n    //is what we hit so we return that t value and traverse that amount\n    //along the ray.\n    \n    //get a new st and stFL based on the point in this cell that\n    //we've found. This way we are garanteed that the edges will be \n    //the ones that fully enclose the cell!\n    st = fract(pointA);\n    stFL = floor(pointA+0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        //and I almost forgot to normalize!!!\n        if(dot(normalize(vec2(i,j)),rd) > TEST_ANGLE){\n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testB = stFL + coords;\n        \n        float distAB = length(testB-pointA);\n        if( distAB > 0.001 && distAB < 2.){\n            vec2 edgePoint =(pointA+testB)/2.;\n            vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n            vec2 edgeSideA = edgePoint - perp*0.7;\n            vec2 edgeSideB = edgePoint + perp*0.7;\n            //Check where we intersect the current found edge\n            minT = min(minT, seg_seg(ro,rd,edgeSideA,edgeSideB));\n            line_color = mix(line_color,vec3(0.,0.9,1.),0.8*line(uv,edgeSideA,edgeSideB,0.05));\n            //faster version\n            //minT = min(minT, seg_seg_new(ro,rd,edgeSideA,edgeSideB));\n           }\n           \n       }\n      }\n    }\n    return minT;\n}\n\n\n\n\n//Basic Voronoi for coloring\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float globalScale = 4.;\n    uv*=globalScale ;\n\n    //get a voronoi for coloring cells an edges\n    vec4 voronoXY = voronoi(uv);\n    \n    //set basic color for all voronoi cells\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    //col.zy *= rot(.1);\n\n    //add some color to the eddges of the voronoi\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.), smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    col = col.xxx;\n   //define ro, rd, and set default rotation of rd\n   vec2 ro = vec2(0.,0.);\n   vec2 rd = vec2(1.,0.);\n   rd *= rot(iTime/2.);\n   \n   //adust mouse\n   vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n   //rotate ray based on mouse if mouse press\n   if(iMouse.z > 0.5){rd = normalize(m.xy+ro);}\n   \n   //draw Ray\n   col = mix(col, vec3(1.,0.5,0.), line(uv, ro, ro + rd*30., 0.04));\n\n   //Draw RO\n   col = mix(col, vec3(.0,.4,.9),point(uv-ro,0.1));\n   \n   //t value for traversing\n   float t;\n   \n   /****************************************************\n\n                  THIS IS THE MAIN EVENT\n   \n   ****************************************************/\n   \n    \n    //we can do 40 x 8 seg-seg intersections without getting slow.\n    //I do 15 to be nice lol\n   for(float i = 0.; i < 15.; i++){\n       t = voronoiEdgeHit(uv,ro,rd,col);\n       ro += rd*t*1.001;\n       col = mix(col, vec3(1.0,.0,.0),point(uv-ro,0.1));\n       col = mix(col, vec3(1.0,.0,.0),\n           ring(uv-ro,0.24+sin(iTime*4.+i/10.)*0.07));\n   }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2273, 2366, 2416, 2416, 2740], [2743, 2743, 2762, 2762, 2896], [2898, 2898, 2916, 2916, 2979], [2981, 2981, 3021, 3021, 3097], [3099, 3099, 3129, 3129, 3178], [3180, 3180, 3209, 3209, 3272], [3274, 3274, 3318, 3318, 3464], [3466, 3623, 3694, 3694, 6396], [6401, 6430, 6452, 6452, 7679], [7681, 7681, 7738, 7788, 9471]]}
{"id": "7tcSR8", "name": "Box SDF - Trippy Animation", "author": "spenceryonce", "description": "Been learning how box SDF's distance function works recently. Here is a first version with me just learning how to play with them. ", "tags": ["math", "sdf", "fun", "animation", "box", "trippy", "trigonomotry"], "likes": 2, "viewed": 25, "published": "Public", "date": "1638683703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 radius = 0.3+vec2(0.5,0.5)*cos(iTime*0.8+vec2(0.3,0.8));\n\n\tfloat d = sdBox( uv, radius);\n    vec3 col = vec3(fract(d*5.0*cos(iTime)*1.2)/4.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    col.r *= 0.5;\n    col.g *= 1.9;\n    col.b *= 1.5;\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 121], [123, 123, 180, 180, 538]]}
{"id": "7tcSRS", "name": "Infy (rainbow)", "author": "avin", "description": "rgb spinner like animation", "tags": ["meta", "rgb", "rainbow", "hue", "infinity", "spinner", "loader"], "likes": 9, "viewed": 146, "published": "Public API", "date": "1639307345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x; \n          \n    float t = iTime*5.;\n    \n    vec3 rd = vec3(0.);\n    \n    for(float i=0.; i< 30.;i+=.8){\n    \n        float tt = t + sqrt(100. - i)*2.0;        \n        vec2 m = vec2(cos(tt), sin(2. * tt) / 3.5)*.3;\n        \n        float ift = i*.0015;\n        float d = smoothstep(.06 - ift, .00 - ift,  length(uv + m));\n        \n        rd = rd + d * hue(-tt*.33).rgb;       \n    }\n    \n   \n    fragColor = vec4(vec3(rd), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 635]]}
{"id": "7tcXRB", "name": "movingLight", "author": "newJasper", "description": "movingLight", "tags": ["2d"], "likes": 1, "viewed": 17, "published": "Public", "date": "1639318392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n         coord.x += sin(iTime) + cos(iTime * 2.1);\n         coord.y += cos(iTime) + sin(iTime * 1.6);\n    float color = 0.0;\n\n    color += 0.1 * (abs(sin(iTime)) + 0.1) / length(coord);\n\n    // Output to screen\n    fragColor = vec4(color,color,color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 457]]}
{"id": "7tcXRn", "name": "eindacor_perlinfun", "author": "Eindacor_DS", "description": "It's fun with perlin noise, you dolt!", "tags": ["perlin"], "likes": 3, "viewed": 147, "published": "Public API", "date": "1638577661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define INVERT true\n\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    float rotation = sin(iTime * .15 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\n\nfloat getPerlinValue(vec2 uv, float gridDimension, bool hideLines) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n\n    if (hideLines || xLerp < revealMargin) {\n        return abs(val);\n    } else {\n        float marginLerp = (xLerp - revealMargin) / (1. - revealMargin);\n        float distFromCenterMargin = abs(.5 - marginLerp);\n        float marginSmooth = smoothstep(0.499, .5, distFromCenterMargin);\n        return mix(clamp(val, 0., 1.), abs(val), marginSmooth);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n\n    float timeScale = .08;\n    \n    uv += vec2(sin(iTime * timeScale), iTime * timeScale);\n    \n    vec3 background = vec3(0.2, 0., 0.);\n    vec3 color1 = vec3(1., 0.75, .25);\n    vec3 color2 = vec3(1.);\n    vec3 color3 = vec3(2.5);\n    \n    float gridSize = .15;\n    \n    float perlinVal1 = pow(getPerlinValue(uv, gridSize, false), .15);\n    float perlinVal2 = log(getPerlinValue(uv, gridSize, false)) / 4.;\n    float perlinVal3 = pow(getPerlinValue(uv, gridSize * 5., true), 2.);\n    \n    vec3 color = mix(mix(mix(background, color1, perlinVal1), color2, perlinVal2), color3, perlinVal3 * .7);\n    \n    if (INVERT) {\n        fragColor = vec4(1. - clamp(color.r, 0., 1.), 1. - clamp(color.g, 0., 1.), 1. - clamp(color.b, 0., 1.), 1.);\n    } else {\n        fragColor = vec4(vec3(color), 1.);\n    }\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 89, 109, 109, 175], [177, 177, 211, 211, 480], [482, 482, 562, 562, 682], [684, 684, 729, 729, 833], [835, 835, 908, 908, 1168], [1171, 1171, 1239, 1239, 2903], [2905, 2905, 2962, 2962, 3900]]}
{"id": "7tcXzS", "name": "[TDF2021] Mystery of Life", "author": "Kamoshika", "description": "25 minutes live coding @Tokyo Demo Fest 2021 Shader Showdown Quaterfinals\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/", "tags": ["livecoding"], "likes": 16, "viewed": 275, "published": "Public", "date": "1639313759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Watch the recording of the live coding on YouTube.\n// https://youtu.be/2s9KfMn1J9M?t=10273\n\n#define time iTime\n#define hash(x) fract(sin(x)*1532.2672)\n#define saturate(x) clamp(x,0.,1.)\n#define ease(x,s) smoothstep(.5-s,.5+s,fract(x))\nconst float pi2=acos(-1.)*2.;\nconst float cs=.25;\n\nvec2 hash22(vec2 p){\n  vec2 v=vec2(dot(p,vec2(1.5263,1.1632)),dot(p,vec2(1.8273,1.3162)));\n  //return hash(v)*2-1;\n  float t=time*cs;\n  return sin(hash(v)*pi2+(floor(t)+ease(t,.1))*5.);\n}\n\nfloat p2d(vec2 p){\n  vec2 i=floor(p);\n  vec2 f=fract(p);\n  vec2 b=vec2(1,0);\n  vec2 u=f*f*(3.-2.*f);\n  return mix(mix(dot(f-b.yy,hash22(i+b.yy)),dot(f-b.xy,hash22(i+b.xy)),u.x),\n             mix(dot(f-b.yx,hash22(i+b.yx)),dot(f-b.xx,hash22(i+b.xx)),u.x),\n             u.y);\n}\n\nfloat fbm(vec2 p){\n  float ac=0.,a=1.;\n  for(int i=0;i<5;i++){\n    ac+=p2d(p*a)/a;\n    a*=2.;\n  }\n  return saturate(ac);\n}\n\nvec3 hsv(float h,float s,float v){\n  vec3 res=fract(h+vec3(0,2,1)/3.)*6.-3.;\n  res=saturate(abs(res)-1.);\n  res=(res-1.)*s+1.;\n  res*=v;\n  return res;\n}\n\nmat2 rot(float a){\n  float s=sin(a),c=cos(a);\n  return mat2(c,s,-s,c);\n}\n\n#define odd(x) step(1.,mod(x,2.))\nfloat sqWave(float x){\n  float i=floor(x);\n  return mix(odd(i),odd(i+1.),ease(x,.05));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1)*.5;\n  vec3 col=vec3(0);\n  \n  uv*=.3+sqWave(time*.2)*.7;\n  uv-=sin(vec2(.5,.7)*time*.5)*.5;\n  uv*=rot(time*.2);\n  \n  float cp=time;\n  for(int i=0;i<20;i++){\n    float L=1.-fract(cp)+float(i);\n    float id=floor(cp)+float(i);\n    vec2 p=uv/atan(.001,L)*.001;\n    float c1=saturate(sin(fbm(p*.5+hash(id)*500.)*20.));\n    c1+=pow(sin((time*cs-.25)*pi2)*.5+.5,30.)*.4;\n    float a=hash(id*1.1)*pi2;\n    vec2 v=vec2(cos(a),sin(a))*.5;\n    float c2=saturate(sin(fbm(p*.25+hash(id*1.2)*500.+time*v)*20.));\n    float c=c1+pow(c1*c2,5.)*8.;\n    float L2=dot(p,p)*10.+L*L;\n    col+=hsv(hash(id*1.3),.8,c)*exp(-L2*.01);\n  }\n  \n  float l=2.;\n  col=col/(1.+col)*(1.+col/l/l);\n  //col=hsv(uv.y,.5,.5);\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 289, 309, 309, 476], [478, 478, 496, 496, 753], [755, 755, 773, 773, 877], [879, 879, 913, 913, 1031], [1033, 1033, 1051, 1051, 1105], [1141, 1141, 1163, 1163, 1229], [1231, 1231, 1288, 1288, 2146]]}
{"id": "7tdSRn", "name": "noise thingy thing", "author": "SnoopethDuckDuck", "description": "e?", "tags": ["e"], "likes": 6, "viewed": 160, "published": "Public API", "date": "1638639460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat superDuperNoise(vec2 uv) {\n    float f = 0.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n        \n\treturn 0.5 + 0.5*f;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    \n   \n    float sc = 132.;\n    vec2 ipos = floor(sc * uv)/sc;\n    vec2 fpos = fract(sc * uv) - 0.5;\n \n    ipos *= 1.5 + 0.5 * thc(4., 4. * length(ipos) - iTime);\n \n    float a = atan(ipos.y, ipos.x);\n    float r = length(ipos);\n \n\n\tfloat f = superDuperNoise(0.8 * ipos);\n\t\n \n    float t = f * 5. + 0.3 * iTime;\n    ipos += vec2(cos(t), sin(t));\n    \n\tipos = mix(ipos, ouv, 0.5 + 0.5 * thc(1., 20. * r + a - iTime + 4. * f));\n    \n    f = superDuperNoise(ipos);\n\n   \n    float k = 0.1;\n    //f = smoothstep(-k, k ,0.35 + 0.25 * cos(length(uv) * 3.3 + atan(uv.y, uv.x) + 20. * f - iTime) - f);\n    f *= 3.5 * f * f;\n    f *= step(length(fpos), 0.6 * f);\n    //f *= smoothstep(-0.02, 0.02, -f * 0.1 + 0.5 - length(ouv));\n    \n    vec3 col = 1.4 * f *  pal(0.1 * iTime + 0.15 * f + 0.1 * t, vec3(1.), vec3(1.), vec3(1.), 0.5 * vec3(0.,0.33,0.66));\n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdSRn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1357, 2089, 2118, 2118, 2159], [2161, 2161, 2218, 2218, 2333], [2335, 2335, 2361, 2361, 2840], [2842, 2842, 2874, 2874, 3116], [3118, 3118, 3186, 3186, 3229], [3231, 3283, 3340, 3340, 4306]]}
{"id": "7tdXz8", "name": "Foggy Hills", "author": "do", "description": "fog", "tags": ["scatter"], "likes": 5, "viewed": 70, "published": "Public", "date": "1638735747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Foggy Hills\n//2021\n//do\n\nconst int seed = 12434;\n#define EPS .0001\n\nfloat hash(float p) {\n    return fract(sin(p) * 4358.5453);\n}\n\nfloat hash(vec2 p) {\n   return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*4358.5353);\n}\n\nvec2 mod289(vec2 p) { return p - floor(p * (1. / 289.)) * 289.; }\nvec3 mod289(vec3 p) { return p - floor(p * (1. / 289.)) * 289.; }\nvec3 permute(vec3 p) { return mod289(((p * 34.) + 1.) * p); } \n\nfloat ns2(vec2 p) {\n\n    const float k1 = (3. - sqrt(3.))/6.;\n    const float k2 = .5 * (sqrt(3.) -1.);\n    const float k3 = -.5773;\n    const float k4 = 1./41.;\n\n    const vec4 c = vec4(k1,k2,k3,k4);\n    \n    vec2 i = floor(p + dot(p,c.yy));\n    vec2 x0 = p - i + dot(i,c.xx);\n  \n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.,0.) : vec2(0.,1.);\n    vec4 x12 = x0.xyxy + c.xxzz;\n    x12.xy -= i1;\n\n    i = mod289(i);\n    \n    vec3 p1 = permute(permute(i.y + vec3(0.,i1.y,1.))\n        + i.x + vec3(0.,i1.x,1.));\n  \n    p1 = permute(mod289(p1 + vec3(float(seed))));\n\n    vec3 m = max(.5 - \n    vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.);\n    m = m * m; \n    m = m * m;\n\n    vec3 x = fract(p1 * c.www) - 1.;\n    vec3 h = abs(x) - .5;\n    vec3 ox = floor(x + .5);\n    vec3 a0 = x - ox; \n    m *= 1.792842 - 0.853734 * (a0 * a0 + h * h);\n     \n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130. * dot(m,g);\n}\n\nfloat f(vec2 x) {\n\n    float f = 0.;\n\n    for(int i = 1; i < 8; i++) {\n\n    float e = pow(2.,float(i));\n    float s = (1./e);\n    f += ns2(x*e)*s;   \n    }    \n\n    return f * .5 + .5;\n}\n\nfloat f2(vec3 p) {\n    float h = f(p.xz);\n    return h;\n}\n\nvec3 fmCol(float t,vec3 a,vec3 b,vec3 c,vec3 d) {\n    \n    return a + b * cos( (radians(180.)*2.0) * (c * t + d));\n}\n\nmat2 rot(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nvec2 scene(vec3 p) {\n\n    vec2 res = vec2(1.,0.);\n\n    vec3 q = p;    \n    vec2 l = vec2(p.y-f(p.xz+.5)*.25,45.);\n\n    res = l;\n    return res;\n\n}\n\nvec2 rayScene(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = 0.;\n    float e = 100.;  \n\n    for(int i = 0; i < 164; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(dist.x < EPS || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nvec3 scatter(vec3 col,float distance,float density,vec3 rd,vec3 ld) {\n    float fog  = 1. - exp(-distance * density);\n    float light = max(dot(rd,ld),0.);\n    vec3 fog_col = mix(vec3(.5,.6,.7),vec3(.6,.5,.1),pow(light,8.));\n    return mix(col,fog_col,fog);\n}\n\nvec3 calcNormal(vec3 p,float d) {\n    vec3 e = vec3(EPS*d,0.,0.);\n    return normalize(vec3(f2(p-e.xyy)-f2(p+e.xyy),\n                     2.*e.x,\n                     vec3(f2(p-e.yxx)-f2(p+e.yxx))));  \n    \n}\n\nvec3 rayCamDir(vec2 uv,vec3 camPosition,vec3 camTarget,float fPersp) {\n\n     vec3 camForward = normalize(camTarget - camPosition);\n     vec3 camRight = normalize(cross(vec3(0.0,1.0,0.0),camForward));\n     vec3 camUp = normalize(cross(camForward,camRight));\n\n\n     vec3 vDir = normalize(uv.x * camRight + \n                 uv.y * camUp + camForward * fPersp);  \n\n     return vDir;\n}\n\nvec3 render(vec3 ro,vec3 rd) {\n \nvec2 d = rayScene(ro, rd);\n\nvec3 col = vec3(1.);\n\nif(d.y >= 0.) {\n\nvec3 p = ro + rd * d.x;\nvec3 n = calcNormal(p,d.x);\nvec3 l = normalize(vec3(-2.,.05,-5.5));\n     l.xz *= rot(-2.5+sin(iTime*.05)-3.3);\n\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\nfloat amb = sqrt(clamp(0.5 + 0.5 * n.y,0.0,1.0));\nfloat dif = clamp(dot(n,l),0.0,1.0);\n\nfloat spe = pow(clamp(dot(n,h),0.0,1.0),16.) * dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\nfloat ind = clamp(dot(n,normalize(h*vec3(-1.,0.,1.))),0.,1.);\n\nfloat fre = pow(clamp(1. + dot(n,rd),0.0,1.0),2.0);\nfloat ref = smoothstep(-.2,.2,r.y);\nvec3 linear = vec3(0.);\n\nlinear += .005* dif * vec3(.25);\nlinear += .001* amb * vec3(0.02,0.4,0.1);\n\ncol = col * linear * spe * ind;\n\nvec3 c = scatter(col,.5,d.x*d.x,rd,l);\ncol = mix(col,vec3(1.)+c*12.,1.-exp(-.25*d.x*d.x*d.x));\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n \nvec3 color = vec3(0.);\n\nvec3 cam_tar = vec3(0.);\nvec3 cam_pos = vec3(0.,.25,1.);\n\nvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y; \n\nvec3 dir = rayCamDir(uv,cam_pos,cam_tar,1.); \ncolor = render(cam_pos,dir);  \ncolor = pow(color,vec3(.4545));      \nfragColor = vec4(color,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 91, 91, 131], [133, 133, 153, 153, 219], [221, 221, 242, 242, 286], [287, 287, 308, 308, 352], [353, 353, 375, 375, 414], [417, 417, 436, 436, 1392], [1394, 1394, 1411, 1411, 1580], [1582, 1582, 1600, 1600, 1639], [1641, 1641, 1690, 1690, 1757], [1759, 1759, 1778, 1778, 1857], [1859, 1859, 1879, 1879, 2005], [2007, 2007, 2039, 2039, 2372], [2374, 2374, 2443, 2443, 2633], [2635, 2635, 2668, 2668, 2843], [2845, 2845, 2915, 2915, 3226], [3228, 3228, 3258, 3258, 4106], [4108, 4108, 4162, 4162, 4459]]}
{"id": "7tK3Wd", "name": "Time Gem", "author": "ruojake", "description": "A spinning cube, with a twist. A number of temporal modulations by scene depth, to be precise.", "tags": ["3d", "raytracing", "abstract"], "likes": 1, "viewed": 85, "published": "Public API", "date": "1638754568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Time Gem by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define LUM_COEFFS vec3(.2126, .7152, .0722)\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float a)\n{\n  return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\n// https://iquilezles.org/www/articles/intersectors/intersectors.htm\n// axis aligned box centered at the origin, extruded by radius r\nfloat rbi(vec3 ro, vec3 rd, float r)\n{\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * (r + 1.);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.)\n        return -1.;\n    float t = tN;\n    \n    vec3 pos = ro + rd * t;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    pos -= 1.;\n    pos = max(pos.xyz, pos.yzx);\n    if(min(min(pos.x, pos.y), pos.z) < 0.) \n        return t;\n        \n    vec3 oc = ro - 1.;\n    vec3 dd = rd * rd;\n    vec3 oo = oc * oc;\n    vec3 od = oc * rd;\n    float ra2 = r * r;\n\n    t = 1e20;        \n\n    // corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b * b - c;\n        if(h > 0.) t = -b - sqrt(h);\n    }\n    // edge X\n    {\n        float a = dd.y + dd.z;\n        float b = od.y + od.z;\n        float c = oo.y + oo.z - ra2;\n        float h = b * b - a * c;\n        if(h > 0.)\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.x + rd.x * h) < 1.)\n                t = h;\n        }\n    }\n    // edge Y\n    {\n        float a = dd.z + dd.x;\n        float b = od.z + od.x;\n        float c = oo.z + oo.x - ra2;\n        float h = b * b - a * c;\n        if(h > 0.)\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.y + rd.y * h) < 1.)\n                t = h;\n        }\n    }\n    // edge Z\n    {\n        float a = dd.x + dd.y;\n        float b = od.x + od.y;\n        float c = oo.x + oo.y - ra2;\n        float h = b * b - a * c;\n        if( h > 0. )\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.z + rd.z * h) < 1.)\n                t = h;\n        }\n    }\n\n    if( t > 1e19 ) t = -1.;\n    \n    return t;\n}\n\nvec4 render(vec3 ro, vec3 rd, float time)\n{\n    ro.xz *= -rot(time * .5);\n    ro.yx *= -rot(time * .4);\n    \n    rd.xz *= -rot(time * .5);\n    rd.yx *= -rot(time * .4);\n    \n    float t = rbi(ro, rd, .1);\n    if (t < 0.)\n        t = 100.;\n    vec3 p = ro + rd * t;\n    \n    return vec4(p, t);\n}\n\nvec3 normal(vec3 p, float t)\n{\n\treturn sign(p) * normalize(max(abs(p) - 1., 0.));\n}\n\nvec3 dither(vec2 p)\n{\n    float r = dot(vec3(p,float(iFrame % 60)), vec3(7., 11., 9.) / 13.);\n    return fract(vec3(r, r + .3334, r + .6667)) * 2. - 1.;\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, LUM_COEFFS);\n}\n\nvec3 color(float t)\n{\n    vec3 c = vec3(.4,.7,.01);\n    c *= LUM_COEFFS;\n    c = c * 2. - 1.;\n    c = erot(c, normalize(vec3(1, 1, 1)), -t) * .5 + .5;\n    c /= LUM_COEFFS;\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = normalize(vec3(uv, 1.3));\n    \n    float t = iTime;\n    vec4 p = vec4(0);\n    for(int i = 0; i < 6; ++i)\n    {\n        ro -= rd * .3;\n        p = render(ro, rd, t);\n        t += p.w * (.5 + .5 * sin(iTime * .02));\n        if (p.w > 10.)\n            break;\n    }\n    \n    ro.xz *= -rot(t * .5);\n    ro.yx *= -rot(t * .4);\n    \n    rd.xz *= -rot(t * .5);\n    rd.yx *= -rot(t * .4);\n    \n    vec3 n = normal(p.xyz, t);\n    vec3 ld = normalize(vec3(1,0,1));\n    \n    ld.xz *= -rot(t * .5);\n    ld.yx *= -rot(t * .4);\n    \n    float l = dot(n, ld) * .5 + .5;\n    float spec = pow(dot(ld, reflect(rd, n)) * .5 + .5, 40.);\n    vec3 col = mix(color(iTime * .01) * l, vec3(l * 5.), l * l);\n    col += spec * 5.;\n    if (length(p.xyz) > 8.)\n        col = vec3(.85);\n\n    // reinhard tonemapping\n    float lumC = lum(col);\n    col *= (1. + lumC / 25.) / (1. + lumC);\n    \n    // saturation\n    col = mix(vec3(lum(col)), col, 1.5);\n    \n    // gamma\n    col = pow(col, vec3(1./2.2));\n    \n    // vignette\n    col *= smoothstep(1.5, .5, length(fragCoord - iResolution.xy * .5) / iResolution.y);\n    \n    // dithering\n    col += dither(fragCoord) / 256. - 1. / 512.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3Wd.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[0, 155, 174, 174, 250], [252, 252, 289, 289, 357], [359, 493, 531, 531, 2344], [2346, 2346, 2389, 2389, 2640], [2642, 2642, 2672, 2672, 2725], [2727, 2727, 2748, 2748, 2881], [2883, 2883, 2902, 2902, 2935], [2937, 2937, 2958, 2958, 3124], [3126, 3126, 3181, 3181, 4482]]}
{"id": "7tK3WG", "name": "Water sim 01", "author": "JCash", "description": "Testing simple 2D animation ideas for water", "tags": ["water"], "likes": 6, "viewed": 80, "published": "Public", "date": "1638519173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795*2.0\n#define M_TWO_PI (M_PI*2.0)\n\nint CHECKER_SIZE=64;\nfloat WAVE_FREQUENCY=10.0;\nfloat WAVE_AMPLITUDE=0.003;\nvec2 WAVE_DIR=vec2(1,1);\nfloat STRENGTH=0.8;\n\n// Placeholder until using an actual texture\nvec3 uvToColor(vec2 uv)\n{\n    int ux = int(uv.x) / CHECKER_SIZE;\n    int uy = int(uv.y) / CHECKER_SIZE;\n    bool fill = (ux & 1) != (uy & 1);\n    return fill ? vec3(0.4,0.8,0.9)*0.8 : vec3(0.1,0.4,0.5);\n}\n\n\n// You should replace this hash by one that you like and meets\n// your needs. This one is here just as example and should not\n// be used in production.\nvec2 g( vec2 n ) { return sin(n.x*n.y*vec2(12,17)+vec2(1,2)); }\n//vec2 g( vec2 n ) { return sin(n.x*n.y+vec2(0,1.571)); } // if you want the gradients to lay on a circle\n\nfloat noise(vec2 p)\n{\n    const float kF = 2.0;  // make 6 to see worms\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\nfloat fbm(vec2 uv)\n{\n    uv *= 2.0;\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float noise = fbm(uv);\n    float c = cos((noise + iTime/WAVE_FREQUENCY) * M_TWO_PI);\n    vec2 offset = normalize(WAVE_DIR) * c * WAVE_AMPLITUDE;\n    vec3 col = uvToColor((uv+offset) * iResolution.xy);\n\n    float s = clamp((c*0.5 + 0.5) * STRENGTH, 0.0, 1.0);\n    s = s*s*s;\n    //fragColor = vec4(mix(col, col+vec3(1,1,1), s),1.0);\n    fragColor = vec4(col*(0.8) + vec3(1,1,1) * s, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tK3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 247, 272, 272, 451], [454, 606, 624, 624, 669], [670, 777, 798, 798, 1138], [1140, 1140, 1160, 1160, 1407], [1409, 1409, 1466, 1516, 1955]]}
{"id": "7tKGDW", "name": "closed fractional julia: c = -2", "author": "incription", "description": "(MOVE MOUSE TO SET S) this is the fractional julia for c = -2. The fractional iterate M[s] has a closed form. For other values of C there is no known closed form, and it is likely that there is none. Set the escape radius to 2 to see the regular julia.", "tags": ["fractal", "julia", "fractional"], "likes": 10, "viewed": 107, "published": "Public API", "date": "1639182866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ONE vec2(1., 0.)\n#define TWO vec2(2., 0.)\n\nfloat dot2(vec2 a) { return a.x * a.x + a.y * a.y; }\nvec2 c(float x){return vec2(x, 0.);}\nvec2 c_mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 c_div(vec2 a, vec2 b) {\n    return c_mul(a.yx,b.xy).yx/dot2(b);\n}\nvec2 c_exp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\nvec2 c_ln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\nvec2 c_pow(in vec2 a, in vec2 b) {\n    return c_exp(c_mul(c_ln(a), b));   \n}\nvec2 c_sqrt(vec2 a) {\n    return c_pow(a, c(.5));\n}\nvec2 c_cosh(vec2 a) {\n    return c_div( c_exp(a) + c_exp(-a), TWO);\n}\nvec2 c_acosh(vec2 z) {\n  return c_ln(z+c_mul(c_sqrt(z+vec2(1,0)),c_sqrt(z-vec2(1,0))));\n}\n\nvec2 Mint(vec2 x) { return c_mul(x, x) - TWO; }\n\nvec2 M(vec2 x, vec2 s) {\n    //float rt = 1.4142;\n    //vec2 sum = vec2(0);\n    //float[10] m = float[10](1., rt, -rt, rt - 2., 1., -rt, 1.-3./rt, rt-4., rt, -2.-rt);\n    //for(int i=0;i<5;i++){\n    //    float mult = m[i*2];\n    //    float power = m[i*2+1];\n    //    sum += c_mul( c(mult), c_pow( x, c(power)));\n    //}\n    //return sum;\n    //return c_mul(x, x) - c(2.);\n    //return c_mul( TWO, c_cosh( c_mul( TWO, c_acosh( c_div( x, TWO )))));\n    return c_mul( TWO, c_cosh( c_mul( c_pow(TWO, s), c_acosh( c_div( x, TWO )))));\n}\n\nfloat Miter(vec2 x, vec2 s, int iter) {\n    vec2 z = x; int i;\n    for(i=0;i<iter;i++) {\n        if(dot2(z) > 2000.) break; //iTime*100. -> ~2000 or 4.\n        z = M(z, s);\n    }\n    return float(i)/float(iter);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv *= iMouse.x/iResolution.x;\n    vec2 z = uv.xy * 4.;\n    vec2 s = 4. * (iMouse.xy/iResolution.xy - .5);\n    if (iMouse.xy==vec2(0)) s = vec2(.35-iTime/80., -2.63-iTime/60.);\n    int i = 100;\n    float iter = Miter(z, s, i);\n    \n    fragColor = vec4(vec3(iter), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 71, 71, 103], [104, 104, 120, 120, 140], [141, 141, 169, 169, 222], [223, 223, 251, 251, 293], [294, 294, 317, 317, 406], [407, 407, 429, 429, 500], [501, 501, 535, 535, 577], [578, 578, 599, 599, 629], [630, 630, 651, 651, 699], [700, 700, 722, 722, 789], [791, 791, 810, 810, 838], [840, 840, 864, 1289, 1374], [1376, 1376, 1415, 1415, 1589], [1591, 1591, 1648, 1698, 2062]]}
{"id": "7ttSW7", "name": "Fractal 95 gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 25, "viewed": 192, "published": "Public", "date": "1639263275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B (1.-fract(t*2.))\n#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,s,e,g=0.,t=iTime;\n\tfor(;i++<99.;)\n    {\n        p=g*d;;\n        p.z-=3.;\n        p=R(p,vec3(.577),t*.3);\n        s=3.;\n        for(int i=0;i++<8;p*=e)\n            p=vec3(1,3.+sin(t)*.3,2)-abs(p-vec3(1,2,1.5+sin(t)*.2)),\n            s*=e=9./clamp(dot(p,p),.8,9.);\n        g+=e=abs(p.y/s-.001)+1e-3;\n        c+=mix(vec3(1),H(length(p*.2+.5)),.6)*.0015/i/e;  \n    }\n    c*=c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 171, 171, 656]]}
{"id": "7ttSW8", "name": "Debris", "author": "_pwd_", "description": "Feels like debris in watery motion. Click to turn around. ", "tags": ["raymarching", "deformation", "cells"], "likes": 7, "viewed": 104, "published": "Public", "date": "1639057044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//////////////////////////////////////////////////////////////////////////////////////\n//\n// Based on @glkt´s \"Alien Core\"\n// https://www.shadertoy.com/view/4tcXRr\n//\n//\n// -> adding my 50 cents...\n//\n//////////////////////////////////////////////////////////////////////////////////////\n\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat noise(vec3 p){\n    \n    float t = iTime;\n    vec3 np = normalize(p);\n    \n    // kind of bi-planar mapping\n    float a = texture(iChannel0,t/20.+np.xy).x;      \n    float b = texture(iChannel0,t/20.+.77+np.yz).x;\n    \n    a = mix(a,.5,abs(np.x));\n    b = mix(b,.5,abs(np.z));\n    \n    float noise = a+b-.4;    \n    noise = mix(noise,.5,abs(np.y)/2.);\n        \n    return noise;\n}\n\n\nvec3 cellpos;\nvec3 signvec;\nvec3 subpos;\nfloat fsign;\n\nfloat cells(vec3 pos) {\n\n    cellpos=pos-floor(pos);\n\n    signvec=2.0*step(0.5,cellpos)-1.0;\n    fsign=signvec.x*signvec.y*signvec.z;\n\n    subpos=abs(abs(cellpos-0.5)-0.25);\n\n    return fsign*(max(max(subpos.x,subpos.y),subpos.z)-0.25);\n}\n\n\n\nfloat map(vec3 p){\n    \n    float d = (-.5*length(p)+1.5)+.5 + cells(p)*5.15;    \n    float m = .75; float s = .23;    \n    \n    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/1.)-.07 ) + cells(p)*0.21, m + sin(iTime) * 0.01);\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(1.*uv.x,1.*uv.y,2.5));\n        \n    vec3 color = vec3(0.);    \n    const int rayCount = 2048;\n    \n    // Raymarching\n    float t = 0.;\n    for (int r = 1; r <= rayCount; r++)\n    {\n        // Ray Position\n        vec3 p = vec3(0,0,-3.) + ray * t;        \n        \n        // Rotation \n       \tp = rotateY(p, iMouse.x/iResolution.x * 2.* 3.14);  \n        p = rotateY(p,iTime/3.);\n        \n        // Deformation \n    \tfloat mask = max(0.,(1.-length(p/3.)));\n    \tp = rotateY(p,mask*sin(iTime/2.)*1.2);        \n        p.y += sin(iTime+p.x)*mask*.5;\n        p.z += sin(iTime+p.x)*mask*1.5;\n        p *= 1.1+(sin(iTime/2.)*mask*.3);\n\n        // distance\n        float d =  map(p);   \n        \n        //color\n        if(d<0.01 || r == rayCount )\n        {                 \n            \n            float iter = float(r) / float(rayCount);\n            float ao = (1.-iter);\n            ao*=ao;\n            ao = 1.-ao;\n                        \n            float mask = max(0.,(.2-length(p/2.)));                       \n            color += 2.*vec3(.1,.5,.2) * max(0.,(noise(p)*14.-12.6)) * mask;            \n            color += vec3(.1,.5,.6) * ao * 6.;            \n            color += vec3(.17,.2,.84)*(t/18.);\n                        \n            break;          \n        }\n        \n        t +=  d *.1;        \n    }\n    \n    // vignetting effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx; \n    float vig = uv.x*uv.y * 20.0;    \n    vig = pow(vig, 0.25);        \n    color *= vig;\n    \n    //color adjustement\n    color.y *= 1.8;\n    color.x *= 1.5;\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 292, 322, 322, 443], [445, 445, 486, 486, 579], [582, 582, 602, 602, 967], [1025, 1025, 1048, 1048, 1263], [1267, 1267, 1285, 1285, 1508], [1511, 1511, 1568, 1568, 3366]]}
{"id": "7ttXRn", "name": "kyu190a", "author": "soma_arc", "description": "SDF to render kyu190a", "tags": ["3d"], "likes": 8, "viewed": 122, "published": "Public API", "date": "1639040907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst vec3 BLACK = vec3(0);\nconst vec3 LIGHT_POS = vec3(100, 100, 100);\nconst vec3 LIGHT_DIR = normalize(LIGHT_POS);\nconst float AMBIENT_FACTOR = 0.1;\nconst int OBJ_PLANE = 0;\n\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 deGamma(vec3 rgb){\n  return vec3((min(pow(rgb.r, 2.2), 1.)),\n              (min(pow(rgb.g, 2.2), 1.)),\n              (min(pow(rgb.b, 2.2), 1.)));\n}\n\nmat3 getRotationX(float rotationDegrees) {\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(1, 0, 0,\n                0, cosTheta, -sinTheta,\n                0, sinTheta, cosTheta);\n}\n\nmat3 getRotationY(float rotationDegrees){\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(cosTheta, 0, sinTheta,\n                0, 1, 0,\n                -sinTheta, 0, cosTheta);\n}\n\nmat3 getRotationZ(float rotationDegrees){\n    float thetaRad = radians(rotationDegrees);\n    float cosTheta = cos(thetaRad);\n    float sinTheta = sin(thetaRad);\n    return mat3(cosTheta, -sinTheta, 0,\n                sinTheta, cosTheta, 0,\n                0, 0, 1);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat distSphere(vec3 p, vec4 sphere){\n\treturn distance(p, sphere.xyz) - sphere.w;\n}\n\nfloat distPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat distEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat distTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat distCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nconst int OBJ_KYU_BODY = 1;\nconst int OBJ_KYU_EYE = 2;\nconst int OBJ_KYU_BROW = 3;\nconst int OBJ_KYU_MOUTH = 4;\nconst int OBJ_KYU_CHEEK = 5;\nconst int OBJ_KYU_ARM = 6;\nconst int OBJ_KYU_TAIL = 7;\n\nvec2 distKyuBrow(vec3 p) {\n    mat3 r1 = getRotationX(135.) * getRotationY(-70.) * getRotationZ(-30.);\n    mat3 r2 = getRotationX(135.) * getRotationY(70.) * getRotationZ(30.);\n    vec3 t1 = vec3(130, -260, -180);\n    vec3 t2 = vec3(-130, -260, -180);\n    return opUnion(vec2(distVerticalCapsule(r1 * (p + t1), 100., 20.),\n                   OBJ_KYU_BROW),\n                   vec2(distVerticalCapsule(r2 * (p + t2), 100., 20.),\n                   OBJ_KYU_BROW));\n}\n\nvec2 distKyuEye(vec3 p) {\n    mat3 r1 = getRotationX(40.) * getRotationZ(15.);\n    mat3 r2 = getRotationX(40.) * getRotationZ(-15.);\n    vec3 t1 = vec3(120, -200, -280);\n    vec3 t2 = vec3(-120, -200, -280);\n    return opUnion(vec2(distTorus(r1 * (p + t1), vec2(50, 20)),\n                   OBJ_KYU_EYE),\n                   vec2(distTorus(r2 * (p + t2), vec2(50, 20)),\n                   OBJ_KYU_EYE));\n}\n\nvec2 distKyuMouth(vec3 p){\n    mat3 r = getRotationX(30.) * getRotationZ(180.);\n    vec3 t1 = vec3(120 -70, -120, -350);\n    vec3 t2 = vec3(10  -70, -120, -350);\n    float an = radians(90.);\n    return opUnion(vec2(distCappedTorus(r * (p + t1), vec2(sin(an),cos(an)), 50., 20.),\n                        OBJ_KYU_MOUTH),\n                   vec2(distCappedTorus(r * (p + t2), vec2(sin(an),cos(an)), 50., 20.),\n                        OBJ_KYU_MOUTH));\n}\n\nvec2 distKyuCheek(vec3 p ) {\n    mat3 r1 = getRotationX(130.) * getRotationY(-40.) * getRotationZ(-20.);\n    mat3 r2 = getRotationX(130.) * getRotationY(40.) * getRotationZ(20.);\n    vec3 t1 = vec3(-260, -140, -280);\n    vec3 t2 = vec3(260, -140, -280);\n    return opUnion(vec2(distVerticalCapsule(r1 * (p + t1), 100., 20.),\n                   OBJ_KYU_BROW),\n                   vec2(distVerticalCapsule(r2 * (p + t2), 100., 20.),\n                   OBJ_KYU_BROW));\n}\n\nvec2 distKyuArm(vec3 p){\n    return opUnion(vec2(distEllipsoid(p + vec3(400, 0, -100),\n                                      vec3(100, 100, 200)),\n                   OBJ_KYU_ARM),\n                   vec2(distEllipsoid(p + vec3(-400, 0, -100),\n                                      vec3(100, 100, 200)),\n                   OBJ_KYU_ARM));\n}\n\nvec2 distKyuTail(vec3 p){\n    return vec2(distEllipsoid(p + vec3(0, 0, 500), \n                              vec3(200, 100, 200)),\n                OBJ_KYU_TAIL);\n}\n\nvec2 distKyu190a(vec3 p) {\n    vec2 d = vec2(distEllipsoid(p, vec3(500, 300, 400)), OBJ_KYU_BODY);\n    d = opUnion(d, distKyuEye(p));\n    d = opUnion(d, distKyuBrow(p));\n    d = opUnion(d, distKyuMouth(p));\n    d = opUnion(d, distKyuCheek(p));\n    d = opUnion(d, distKyuArm(p));\n    d = opUnion(d, distKyuTail(p));\n    return d;\n}\n\nvec3 getMatKyu190a(int objId) {\n    if(objId == OBJ_KYU_BODY){\n        return vec3(1);\n    } else if(objId == OBJ_KYU_EYE) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_BROW) {\n        return vec3(0);\n    } else if (objId== OBJ_KYU_MOUTH) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_CHEEK) {\n        return vec3(0);\n    } else if(objId == OBJ_KYU_ARM) {\n        return vec3(1);\n    } else if(objId == OBJ_KYU_TAIL) {\n        return vec3(1);\n    }\n}\n\nvec2 distFunc(vec3 p, float time) {\n\tvec2 d = vec2(distPlane(p, vec4(0, 1, 0, 300)), OBJ_PLANE);\n    d = opUnion(d, distKyu190a(p + vec3(0,-200. + -400. * sin(iTime) * sin(iTime), 0)));\n    return d;\n}\n\nconst vec2 NORMAL_COEFF = vec2(1., 0.);\nvec3 computeNormal(const vec3 p, const float t){\n  return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy, t).x - distFunc(p - NORMAL_COEFF.xyy, t).x,\n                        distFunc(p + NORMAL_COEFF.yxy, t).x - distFunc(p - NORMAL_COEFF.yxy, t).x,\n                        distFunc(p + NORMAL_COEFF.yyx, t).x - distFunc(p - NORMAL_COEFF.yyx, t).x));\n}\n\nconst int MAX_MARCH = 500;\nint march (vec3 rayOrg, vec3 rayDir, float time, inout float minDist,\n           float maxDist,\n           inout vec3 intersection, inout vec3 normal) {\n    vec3 rayPos = rayOrg + minDist * rayDir;\n    vec2 dist = vec2(-1);\n    float rayLength = 0.;\n    for(int i = 0 ; i < MAX_MARCH ; i++){\n        if(rayLength > maxDist) return -1;\n        dist = distFunc(rayPos, time);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < EPSILON){\n            int objId = int(dist.y);\n            intersection = rayPos;\n            normal = computeNormal(intersection, time);\n            minDist = rayLength;\n            return objId;\n        }\n    }\n    return -1;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nvec3 getMatColor(int objId, vec3 normal, vec3 intersection){\n    if(objId == OBJ_PLANE){\n        vec2 p = fract(intersection.xz / iChannelResolution[0].xy);\n        vec3 col = deGamma(texture(iChannel0, p).rgb);\n        return mix(col, vec3(0.7, 0.8, 1.), 0.); \n    }else if(objId != -1){\n        return getMatKyu190a(objId);\n    }\n\treturn BLACK;\n}\n\nvec3 sky(vec3 rayDir){\n\treturn clamp(vec3(.7, .8, 1.) + exp(dot(rayDir, LIGHT_DIR))*0.1, 0.0, 1.0);\n}\n\nfloat computeShadowFactor (vec3 rayOrg, vec3 rayDir,\n                           float mint, float maxt, float k) {\n    float shadowFactor = 1.0;\n    for(float t = mint ; t < maxt ;){\n        float d = distFunc(rayOrg + rayDir * t, 0.).x;\n        if(d < EPSILON) break;\n\n        shadowFactor = min(shadowFactor, k * d / t);\n        t += d;\n    }\n    return clamp(shadowFactor, 0.0, 1.0);\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(clamp(dot(reflect(e,n),l),0.0, 1.),s);\n}\n\n// p: center of the plane\n// n: normal of the plane\nbool intersectPlane(vec3 p, vec3 n, \n                    vec3 rayOrigin, vec3 rayDir,\n                     inout float minDist,\n                    inout vec3 intersection, inout vec3 normal){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < minDist){\n\t\tintersection = rayOrigin + t * rayDir;\n        normal = n;\n        minDist = t;\n        return true;\n    }\n    return false;\n}\n\n\nbool intersectSphere(vec3 sphereCenter, float radius, \n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphereCenter;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - radius * radius;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphereCenter);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n\n    float t = 999999.;\n    vec3 intersection, normal;\n    int objId = -1;\n    float t0, t1;\n    bool hitPlane = false;\n    \n    bool hitBox = intersectBox(eye, ray, \n                               vec3(-700, 0, -800), \n                               vec3(700, 900, 500),\n                               t0, t1);\n    if(hitBox){\n        objId = march(eye, ray, time, t0, t1,\n                      intersection, normal);\n    }\n    if(objId < 1){\n        hitPlane = intersectPlane(vec3(0, -100, 0), \n                                  vec3(0, 1, 0), \n                                  eye, ray, t,\n                       intersection, normal);\n        if(hitPlane) objId = OBJ_PLANE;\n    } else {\n        t = t0;\n    }\n    if(objId != -1){\n        vec3 matColor = BLACK;\n        matColor = getMatColor(objId, normal, intersection);\n        float k = computeShadowFactor(intersection + normal, LIGHT_DIR,\n                                      0., 1000., 5.);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        l += k * diffuse + ambient;\n    } else {\n        l = sky(ray);\n    }\n\n    l = mix( sky(ray), l, exp( -0.000000009*t * t ) );\n\n  \treturn l;\n}\n\n\nconst vec3 target = vec3(0, 300, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 5.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 eye = vec3(900. * sin(iTime) , 1000., \n                    900. * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 130, 130, 411], [729, 729, 758, 758, 935], [937, 937, 960, 960, 1089], [1091, 1091, 1133, 1133, 1359], [1361, 1361, 1402, 1402, 1628], [1630, 1630, 1671, 1671, 1897], [1899, 1899, 1931, 1931, 1966], [1968, 1968, 2006, 2006, 2052], [2054, 2054, 2087, 2087, 2121], [2123, 2123, 2169, 2169, 2258], [2260, 2260, 2295, 2295, 2360], [2362, 2362, 2417, 2417, 2476], [2478, 2478, 2550, 2550, 2684], [2883, 2883, 2909, 2909, 3347], [3349, 3349, 3374, 3374, 3753], [3755, 3755, 3781, 3781, 4204], [4206, 4206, 4234, 4234, 4672], [4674, 4674, 4698, 4698, 5012], [5014, 5014, 5039, 5039, 5176], [5178, 5178, 5204, 5204, 5508], [5510, 5510, 5541, 5541, 5982], [5984, 5984, 6019, 6019, 6185], [6227, 6227, 6275, 6275, 6576], [6605, 6605, 6757, 6757, 7303], [7305, 7305, 7457, 7457, 7817], [7819, 7819, 7879, 7879, 8167], [8169, 8169, 8191, 8191, 8270], [8272, 8272, 8386, 8386, 8660], [8662, 8662, 8708, 8708, 8768], [8770, 8822, 9014, 9014, 9279], [9282, 9282, 9495, 9495, 9945], [9947, 9947, 10068, 10068, 10834], [10837, 10837, 10884, 10884, 12130], [12257, 12257, 12313, 12313, 12847]]}
{"id": "7ty3zc", "name": "spqr: tube 3", "author": "Fahrenheitrequited", "description": "a", "tags": ["a"], "likes": 4, "viewed": 124, "published": "Public API", "date": "1638433961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n//float gid;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat getId(float t) {\n   return fract(sin(t * 478.129) * 992.421);\n}\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\nfloat m1(vec2 uv) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv *= rot(i * a *2.);\n   \n    uv = abs(uv); \n    uv -= vec2(2,7);\n    uv = -abs(uv);\n   \n    \n    float x1 =  box(uv, vec2(1,1));\n    float x2 =  box(uv + vec2(2,11), vec2(1.,5.));\n    float x3 =  box(uv + vec2(14,14), vec2(.1,53.));\n    vec2 q = replim(uv, 10., vec2(11,2));\n    float x4 =  box(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash21 (vec2 uv) {\n  return (fract(sin(uv.x * 1913.7361) + uv.y) * 4440.321);\n\n}\n\nfloat a = 3.141592;\nfloat glow = 0.;\nfloat m2(vec2 uv,float id) {\n\n\n  float dom = 20.;\n\n  uv = mod(uv,dom) - dom/2.;  \n\n \n  vec2 uv2 = uv;\n  float q = 1.4 ;\n  \n  float z = 10000.;\n  vec2 off = vec2(58,20);\n\n  for (float i = 0.; i <5.; i++) {\n    off *= rot(i/4.);\n   \n    uv.x *= q;\n\n    uv *= rot(a/2.);\n    \n    float a1 = m1(uv  + off );\n\n    z = min(z,a1) ;\n  }\n  vec2 arm = vec2(24);\n  arm *= rot(iTime * 7.1);\n  float u = length(uv2  + arm) -2.;\n  \n  //glow += .01/(.02 + pow(u,4.5));\n \n  return z/1.4;\n}\n\n\n\n\n\nfloat k1(vec2 p, float f1) {\n    vec2 pa = p;\n\n    float pi = 3.141592;\n    float z = 100000.;\n    for ( float j = 0.; j < 5.; j++) {\n        p = p.x > p.y ? p : p.yx;\n        for ( float i=0.; i < 3.; i++) {\n           //p = replim(p,6., vec2(0,50.));\n\n           p.x = abs(p.x) - 30. * f1 * f1;\n           float a= box(p,vec2(3,51) );\n           z = min(z,a);\n           vec2 pa = replim(pa,25., vec2(2. + f1));\n           float y = box(pa, vec2(8. ));\n           z = min(z,y);\n           p *= 1.12 + f1/3. ;\n           p += vec2(-46,0);\n           p *= rot(pi/2.);\n      \n        }\n    }\n \n    float c = box(pa, vec2(10,100));\n    \n   return min(z,c) ;\n \n}\nfloat pi = 3.141592;\nfloat k2(vec2 p, float f1){\n\n    float z = 10000.;\n    vec2 offset = vec2(200.,0) + vec2(45) * f1;\n   \n    for ( float i =1.; i < 3.; i++ ) {\n        //p = replim(p,8., vec2(0,10.));\n        float a = k1(p * 1.2 +vec2(0,70.) - vec2(17,29)  * 2.3, f1);\n        float b = k1(p + vec2(70,60) - vec2(50), f1);\n        float c = k1(p * 1.5+vec2(80,11), f1);\n\n        float d = a;//min(a,min(b,c));\n        z = min(z,d);\n        z = max(z, -b);\n        z = min(z,c);\n        p *= 1.5;\n        \n        offset *= rot(pi/(2.));\n        p += offset / pow(.3 + f1 * 3.,i );\n        p *= rot((pi/2.));\n       \n        \n    }\n     \n       \n       return z;\n}\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nconst float domain_width = 290.;\nconst float domain_height = 27.;//77.;\nvec3 domain = vec3(domain_width,domain_height,domain_width) ;\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\n\nfloat decal(vec3 p, vec3 domain) {\n\n// ink\n  // return m2(uv);\n  //vec2 q = kifs(p + pow(kifs(p),vec2(1. + sin(iTime))*.5+.5) );\n  \n  \n  vec3 id = floor(p/domain);\n  float f1 = fract(hash31(id) + tick(iTime * .13 ));\n  \n  p = mod(p,domain) - domain/2.;\n  //float one =  k1(kifs(p * f1 + kifs(p * f1)), f1);\n  //float one =  k1(kifs(p + kifs(p) + kifs(kifs(p))), f1);\n  //float one = k1(kifs(p + kifs(p)),f1);\n  float one = k2(p.xz,f1);\n  float two = box(p.xz, vec2(300.));\n  float final = max(one,two);\n  return final;\n}\n\n\n\n\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\nvec3 s;\nint matter = 0;\n\nvec3 probe;\nfloat map(vec3 p) {\n\n// geo\n \n\n  // tunell\n  float minimum = 6.74;\n  float seper = .74;\n  \n  float hole1 = -cyl(p.xy,minimum + 0. * seper);\n  float wall1 = cyl(p.xy, minimum + .2 * seper);\n  float tunnel1 = max(hole1,wall1);\n  \n  \n  float hole2 = -cyl(p.xy,minimum + 8. * seper);\n  float wall2 = cyl(p.xy, minimum + 8.2 * seper);\n  float tunnel2 = max(hole2,wall2);\n  \n  float hole3 = -cyl(p.xy,minimum + 16. * seper);\n  float wall3 = cyl(p.xy, minimum + 16.2 * seper);\n  float tunnel3 = max(hole3,wall3);\n  \n  \n  float tunnel = min(min(tunnel1, tunnel2),tunnel3);\n  \n  matter = 1;\n  return tunnel;\n  \n  /*\n  float ball = sph(p - probe, 1.);\n\n \n  float final = min(ball,tunnel);\n  \n  if ( tunnel == final) {\n      matter = 1;\n  }\n  if ( ball == final) {\n      matter =2;\n  }\n  return final;\n  */\n\n \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    \n    \n    for( float t=mint; t<maxt; )\n    {\n        \n        float h = map(ro + rd*t);\n        //h = abs(h);\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\n\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nfloat intersect(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n\n       float granularity = 20. ;\\\n       \n       float z = decal(p  * granularity, domain );\n       if (  z < 4.5) {\n          d = .1;\n       } else {\n         shad=0.0;\n         break;\n       }\n    }\n   \n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\nvec3 vollight ( vec3 lightpos, vec3 s, vec3 r, vec2 uv, float limit) {\n\n  float rand=rnd(uv);\n  \n  \n  const int volsteps=120; //50\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>limit) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = intersect(lp, lv, ldistvol, 10, 0.01);\n    atcol += 5./(0.01+(pow(ldistvol,2.))) * shadvol;\n   \n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n  return atcol;\n}\n\\\n\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float time = iTime;\n\n  // nav\n  \n   float tt = iTime * .35;\n  \n   vec3 source = \n       lattice(tt + 53.1) * 39.3 ;\n  \n   vec3 target = \n        lattice(tt+1.) * 19.;\n        \n        \n   source.z += tt * 20.;\n   target.z += tt * 20.;\n   \n   probe =  vec3(0,0, sin(iTime * .91 + 1.5) * 74. + source.z);\n   \n\n \n  vec3 cz=normalize(target-source);\n\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n  //r.xy *= rot(sin(tick(iTime))*.2);\n\n  vec3 p=source;\n  //float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  \n  \n  // march\n  float granularity = 20. ;\n  bool hit = false;\n  float i ;\n  float z;\n  float res = 1.;\n  for( z=0.; z < 1000.; ++z) {\n    i = z;\n    d=map(p);\n    d = abs(d);\n    if(d<0.01) {\n    \n       \n      i = decal(p  * granularity, domain );\n     \n      if (matter == 1) { \n          if (i > 4.5) {\n            d = .1;\n          } else {\n            hit = true;\n            break;\n          }\n      } else {\n           hit = true;\n            break;\n       \n      \n      }\n    }\n    if ( dd > 10000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n\n  vec3 col = vec3(1.);\n  \n  i = decal(p  * granularity, domain );\n  \n  if ( matter == 1) {\n      if ( i > 0.0 && i < 3.0) {\n          col = vec3(0);\n      }\n\n      if ( i > -12.0 && i < 0.0) {\n          col = vec3(.1,.1,.5)*.3;\n        \n      }\n  }\n  if ( matter == 2) {\n      col = vec3(.8,.4,.2);\n  }\n    if ( matter == 3) {\n      col = vec3(1);\n  }\n \n\n \n \n //vec3 atcol = vollight(probe, source , r, uv, dd);\n //col += atcol * .5;\n \n \n \n \n //vec3 atcol = vollight(probe, s, r, uv, dd);\n //col += atcol * .1;\n \n  // sky\n  if (! hit ) {\n\n  \n    float per = dot(r, normalize(vec3(0,2,2)))  * .5 + .5;\n    per = pow(per,2.);\n   \n    col =   mix(  vec3(.5), vec3 (.5) *.1, per);\n    \n  }\n  \n  fragColor = vec4(col, 1);\n\n}\n\n\n  \n\n\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n\n\n\n/*\n float diff = max(0.0,dot(n,light)*0.5+0.5);\n  float fren = pow(1.+dot(n,r),2.);\n  float sss = sss(p,r,4.) * 2.;\n  float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n  float shad = shadow(p, normalize(-light), .1, length(light-p));\n  float fog =  pow(i/1000.,2.);\n  \n  col -= diff * .1;\n  //col += fren;\n  //col += sss;\n  //col += spec;\n  //col *= shad;\n  //col = mix(col, vec3(0), fog);\n  */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ty3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 295, 314, 314, 383], [385, 385, 407, 407, 454], [456, 456, 485, 485, 533], [536, 536, 583, 583, 629], [631, 631, 650, 650, 1209], [1211, 1211, 1253, 1253, 1360], [1362, 1362, 1386, 1386, 1448], [1487, 1487, 1515, 1515, 1960], [1966, 1966, 1994, 1994, 2625], [2647, 2647, 2674, 2674, 3293], [3333, 3333, 3356, 3356, 3471], [3538, 3607, 3630, 3630, 3708], [3710, 3710, 3744, 3838, 4230], [4236, 4236, 4263, 4263, 4331], [4333, 4333, 4361, 4361, 4385], [4386, 4386, 4415, 4415, 4502], [4505, 4505, 4533, 4533, 4559], [4561, 4561, 4589, 4589, 4622], [4625, 4625, 4672, 4672, 4718], [4722, 4722, 4763, 4763, 4931], [4934, 4934, 4955, 4955, 5246], [5248, 5248, 5267, 5267, 5375], [5377, 5377, 5416, 5416, 5493], [5495, 5495, 5531, 5531, 5609], [5611, 5611, 5631, 5631, 5725], [5728, 5728, 5752, 5752, 5807], [5811, 5811, 5832, 5832, 5881], [5883, 5883, 5908, 5908, 6377], [6415, 6415, 6434, 6457, 7215], [7217, 7217, 7281, 7281, 7563], [7566, 7566, 7585, 7585, 7704], [7706, 7706, 7747, 7747, 7793], [7795, 7795, 7831, 7831, 7876], [7878, 7878, 7898, 7898, 7941], [7943, 7943, 7962, 7962, 8041], [8045, 8045, 8065, 8065, 8249], [8251, 8251, 8324, 8324, 8573], [8577, 8577, 8653, 8653, 9073], [9076, 9076, 9146, 9146, 9727], [9733, 9733, 9791, 9791, 11838], [11848, 11848, 11884, 11884, 12224]]}
{"id": "7tyGWK", "name": "Folded Darkness", "author": "creikey", "description": "More tweaks ", "tags": ["folding"], "likes": 3, "viewed": 56, "published": "Public", "date": "1638317280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Based on:\n// KIFS City by leon denise 2021/11/22\n// example of how to go to fractal city\n// which is a cubic kaleidoscopic shape carving volume\n// using code from Inigo Quilez, LJ, Fabrice Neyret and many others\n// licensed under hippie love conspiracy\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nfloat map (vec3 p)\n{\n  p = sin(p) + 0.8;\n  float scene = 500.;\n  float t = iTime/5.0;\n  float falloff = 5.0;\n  for (float index = 0.; index < 10.; ++index)\n  {\n    p.xz *= rot(t/falloff);\n    p.yz *= rot(t/falloff);\n    p = abs(p)-0.3*falloff;\n    p *= 0.98;\n    scene = max(-0.5, min(scene, max(p.x, max(p.y, p.z))));\n    falloff /= 1.85;\n  }\n  return -scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.*(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 pos = vec3(iTime, 0.0, 0.0);\n  vec3 ray = normalize(vec3(uv, 1));\n  ray.xz *= rot(iTime/3.0);\n  float shade = 0.;\n  const float count = 20.;\n  for (float index = count; index > 0.; index -= 1.0)\n  {\n    float dist = map(pos);\n    if (dist < 0.001)\n    {\n      shade = index/count + 0.1;\n      break;\n    }\n    pos += ray * dist;\n  }\n  fragColor = vec4(shade);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyGWK.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[2, 259, 279, 279, 324], [326, 326, 346, 346, 688], [690, 690, 747, 747, 1180]]}
{"id": "fl3SDN", "name": "Tracing Quadrics", "author": "mrboggieman", "description": "Ray tracing quadrics generically, based on the paper ' Ray Tracing Arbitrary Objects on the GPU' by A. Wood et al. Make full screen and enjoy smooth shapes :)", "tags": ["quadrics", "raytrace"], "likes": 23, "viewed": 139, "published": "Public API", "date": "1639089852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ray Tracing Quadric shapes (with box constraint)\n// based on the paper: Ray Tracing Arbitrary Objects on the GPU, A. Wood et al\nconst mat4 cylinder = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, -0.25\n);\n\nconst mat4 sphere = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, 4.0, 0.0, 0.0,\n    0.0, 0.0, 4.0, 0.0,\n    0.0, 0.0, 0.0, -1.0\n);\n\nconst mat4 ellipticParaboloid = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, 4.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0\n);\n\nconst mat4 hyperbolicParaboloid = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, -4.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0\n);\n\nconst mat4 circularCone = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, -4.0, 0.0, 0.0,\n    0.0, 0.0, 4.0, 0.0,\n    0.0, 0.0, 0.0, 0.0\n);\n\nconst mat4 quadraticPlane = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 1.0, 0.0, 0.0\n);\n\nconst mat4 hyperbolicPlane = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 2.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 2.0, 0.0, 0.0\n);\n\nconst mat4 intersectingPlanes = mat4(\n    0.0, 1.0, 0.0, 0.0,\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0\n);\n\nconst float EPSILON = 0.000001;\n\nconst int samples = 4; //per x,y per fragment\n\nbool getPointAtTime(in float t, in vec4 ro, in vec4 rd, out vec3 point) {\n    if (t < 0.0) {\n        return false;\n    }\n\n    point = ro.xyz + t * rd.xyz;\n    \n    //constrain to a box\n    return all(greaterThanEqual(point, vec3(-0.5 - EPSILON))) && all(lessThanEqual(point, vec3(0.5 + EPSILON)));\n}\n\n//adapted from https://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool intersectBox(in vec4 ro, in vec4 rd, out vec4 outPos)\n{\n    vec3 m = 1.0/rd.xyz;\n    vec3 n = m*ro.xyz;\n    vec3 k = abs(m);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return false; // no intersection\n    outPos = ro + rd * tN;\n    return true;\n}\n\nbool intersectQuadric(in mat4 shape, in vec4 ro, in vec4 rd, out vec3 point) {\n    vec4 rda = shape * rd;\n    vec4 roa = shape * ro;\n    \n    //quadratic equation\n    float a = dot(rd, rda);\n    float b = dot(ro, rda) + dot(rd, roa);\n    float c = dot(ro, roa);\n    \n    if (abs(a) < EPSILON) {\n        if (abs(b) < EPSILON) {\n            return getPointAtTime(c, ro, rd, point);\n        }\n        \n        return getPointAtTime(-c/b, ro, rd, point);\n    }\n\n    float square = b*b - 4.0*a*c;\n\n    if (square < EPSILON) {\n        return false; //no hit\n    }\n\n    float temp = sqrt(square);\n    float denom = 2.0 * a;\n\n    float t1 = (-b - temp) / denom;\n    float t2 = (-b + temp) / denom;\n    \n    //draw both sides but pick the closest point\n    vec3 p1 = vec3(0.0);\n    vec3 p2 = vec3(0.0);\n\n    bool hasP1 = getPointAtTime(t1, ro, rd, p1);\n    bool hasP2 = getPointAtTime(t2, ro, rd, p2);\n    \n    if (!hasP1) {\n        point = p2;\n        return hasP2;\n    }\n    \n    if (!hasP2) {\n        point = p1;\n        return true;\n    }\n\n    if (t1 < t2) {\n        point = p1;\n    } else {\n        point = p2;\n    }\n\n    return true;\n}\n\nvec3 drawQuadric(in mat4 shape, in vec4 ro, in vec4 rd) {\n    vec3 collPoint = vec3(0.0);\n    \n    //intersect the bounding box first and use the intersected origin for solving the quadric\n    //idea from mla: https://www.shadertoy.com/view/wdlBR2\n    if (intersectBox(ro, rd, ro) && intersectQuadric(shape, ro, rd, collPoint)) {\n        //some simple fake shading for now\n        return normalize((shape * vec4(collPoint, 1.0)).xyz) / 2.0 + 0.5;\n    } else {\n        //otherwise return black for now\n        return vec3(0.0);\n    }\n}\n\n//utils\nmat4 rotateX(in float rads) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rads), -sin(rads), 0.0,\n        0.0, sin(rads), cos(rads), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(in float rads) {\n\treturn mat4(\n        cos(rads), 0.0, sin(rads), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rads), 0.0, cos(rads), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //camera\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0 - 1.0, 1.0);\n    rayTarget.y /= aspectRatio;\n    vec3 rayPosition = vec3(0.0, 0.0, -10.0);\n    \n    vec2 rayStep = (1.0 / iResolution.xy) / float(samples);\n    \n    //rotate all of the objects\n    float rotAmount = iTime;\n    mat4 rotMatrix = rotateX(rotAmount) * rotateY(rotAmount * 0.5);\n    \n    vec3 result = vec3(0.0);\n    \n    for (int y=0; y<samples; y++) {\n        for (int x=0; x<samples; x++) {\n            vec3 rayDir = normalize(rayTarget + vec3(rayStep * vec2(x, y), 0.0) - rayPosition);\n            vec4 newDir = vec4(rayDir, 0.0) * rotMatrix;\n\n            //quadrics\n            vec3 pixel = vec3(0.0);\n\n            pixel += drawQuadric(cylinder, vec4(rayPosition - vec3(-3.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(sphere, vec4(rayPosition - vec3(-1.5, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(ellipticParaboloid, vec4(rayPosition - vec3(0.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(hyperbolicParaboloid, vec4(rayPosition - vec3(1.5, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(circularCone, vec4(rayPosition - vec3(3.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(quadraticPlane, vec4(rayPosition - vec3(-2.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(hyperbolicPlane, vec4(rayPosition - vec3(0.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(intersectingPlanes, vec4(rayPosition - vec3(2.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n        \n            result += clamp(pixel, 0.0, 1.0);\n        }\n    }\n    \n    fragColor = vec4(result / float(samples * samples), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3SDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1255, 1279, 1352, 1352, 1578], [1580, 1661, 1721, 1721, 2032], [2034, 2034, 2112, 2112, 3166], [3168, 3168, 3225, 3225, 3702], [3704, 3712, 3741, 3741, 3903], [3905, 3905, 3934, 3934, 4093], [4095, 4095, 4150, 4163, 5977]]}
{"id": "flcSz4", "name": "Jellyfish <3", "author": "lechuga", "description": "^^", "tags": ["raymarching", "random", "fish"], "likes": 8, "viewed": 103, "published": "Public", "date": "1638803171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TEX 1 // cambiar a 0 para desactivar la textura\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi acos(-1.)\nfloat t;\n\nfloat[10] acum;\n\n// https://www.shadertoy.com/view/3tcGDs\n// Alkama <3\nfloat noise(vec2 p){\n  return .211*texture(iChannel0, sin(t*.45)+t*.56+p*.05).r + \n        .641625*texture(iChannel0, cos(-t*.65)-t*.45+p*.05).r +\n        .519*texture(iChannel0, sin(t*.7)+t*.1+p*.06).r;\n}\n#define h(d) fract(sin(d*56.6)*67.)\nfloat c(float t){\n  return mix(h(floor(t)),h(floor(t+1.)),pow(smoothstep(0., 1., fract(t)), 20.));\n}\nfloat tt;\nfloat st(vec3 p, vec2 s){return length(vec2(length(p.xy)-s.x, p.z))-s.y;}\nfloat sb(vec3 p, vec3 s){\n  p=abs(p)-s;\n  return length(max(p,0.)) + min(0.,max(max(p.x, p.y),p.z)) - 4.;\n  }\nfloat smin(float a, float b, float k){\n  float h= max(0., k-abs(a-b));\n  return min(a,b)-h*h*k*.25;\n}\n\nvec2 m1(vec3 p){\n  float ss = sin(tt+p.y*.45);\n  mat2 aa2= rot(radians(pi*24.));\n  p.xy *= aa2;\n  vec3 p1=p;\n  vec2 dt=vec2(1.),dh;\n  mat2 aa  = rot(p1.y*.0471+t);\n  p1.xz*=aa;\n  p1=abs(abs(p1)-2.)-1.-sin(tt+p.y*.41)*.5;\n  p-=vec3(0., 4., 0.);\n  dt = vec2(length(p)-sin(p.y*.15+tt)*4.455-15.5-ss*.25, 0.);\n  acum[0]+=.1/(.1+dt.x*dt.x);\n  dh = vec2(length(p1.xz)-3.-ss, 1.);\n  dt.x = max(dt.x,-(length(p-vec3(0., -15., 0.))-15.-ss));\n  dh.x = p.y > dh.x ? p.y : dh.x;\n  dh.x = smin(dh.x, dt.x,1.);\n  return vec2(dh.x,0.);\n}\nvec2 m2(vec3 p){\n  \n  vec3 p1=p;\n  #if TEX == 1\n      float fl = 20.+p1.y+noise(p.xz);\n  #else\n      float fl = 20.+p1.y;\n  #endif\n  vec2 dt,dh=m1(p);\n  dt = vec2(fl, 1.);\n  \n  vec3 p2 = p;\n  p2.y -= 50.;\n  p2.x -= tt*5.;\n  float ss = 20.;\n  vec2 gid = (floor(p2.xz/ss-.5));\n  p2.xz = (fract(p2.xz/ss-.5)-.5)*ss;\n  float a = fract(sin(dot(gid, gid.yx*vec2(22.5,30.22))*52.));\n  p2.yz*=rot(pi*a*.65);\n  p2.yz*=rot(a-3.458*pi*.56);\n  p2.xy*=rot(a+2.7656*pi*.657);\n  p2.xz*=rot(a+2.6715*pi*.56);\n  float cc = sb(p2, vec3(3.)*a*a+10.);\n  vec3 p3 = p;\n  p3.x-=tt*5.;\n  p3.xz=(fract(p3.xz/ss-.5)-.5)*ss;\n  p3-=vec3(0.,42.,0.);\n  p3.xz*=rot(.454);\n  float cc2 = length(p3+vec3(0., 3., 0.))-8.;\n  dt.x = min(cc, dt.x);\n  dt.x = max(.1-cc2, dt.x);\n  dt.x *= .55;\n  return dh.x < dt.x ? dh:dt;\n}\n\nvec2 m3(vec3 p){\n  vec2 dt,dh=m2(p);\n  vec2 ss = vec2(120.,70.);\n  p.xz=p.xz-70.;\n  p.xz -= tt*7.;\n  p.xz=(fract(p.xz/ss-.5)-.5)*ss;\n  p.xy *= rot(2.5);\n  dt=vec2(length(p.xz)-10.,3.);\n  dt.x = max(dt.x, p.y-1.);\n  acum[1] += .35/(5.+dt.x*dt.x);\n  return dh;\n}\n\nvec2 m(vec3 p){\n  vec2 dt,dh=m3(p);\n  p.yz = abs(p.yz)-1.;\n  p.x -= sin(p.x*.45+t*20.);\n  p.xz *= rot(-1.);\n  p.x -= 0.5;\n  p.y -= 5.;\n  p.yx *= rot(p.z*.245);\n  p.y += sin(p.z*.145+t*10.)*2.25-1.25;\n  p.x += sin(p.z*.167+t*10.)*2.12-1.12;\n  \n  p.xy = abs(p.xy)-2.;\n  \n  dt = vec2(length(p.xy)-.1,4.);\n  acum[2] += .1/(.1+dt.x*dt.x);\n  dt.x*=.55;\n  dh.x = smin(dt.x,dh.x,.25);\n  return dh;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  t= mod(iTime, 100.)*.75;\n  tt= c(t)+t*8.;\n\t\n  vec2 uv = ((fragCoord/iResolution.xy)-0.5) / vec2(iResolution.y / iResolution.x, 1);\n  uv*=2.;\n  float ph = .135+.135;\n  uv.y -= cos(sin(t*.45+uv.x*.645)*2.25-.25+t*.245)*ph + sin(cos(t*.25+uv.y*.435)*2.25-.25+t*.256)*ph;\n  vec3 s = vec3(0.01, 10.01,-80.);\n  mat2 aa = rot(sin(t*.125)*pi*2.);\n  s.xz*=aa;\n  vec3 p = s;\n  vec3 cz = normalize(vec3(0.,-1.,0.)-s);\n  vec3 cx = normalize(cross(cz,vec3(0., -1., 0.)));\n  vec3 cy = normalize(cross(cx,cz));\n  vec3 r = mat3(cx,cy,cz)*normalize(vec3(uv, 1.));\n  vec3 co = vec3(0.144);\n  vec2 dt,dh,e=vec2(.01,0.);\n  float i;\n  vec3 n, l = normalize(vec3(-1., -2.,-3.));\n  l.xz *= aa;\n  for(i = 0.;i < 64.; i++){\n    dt = m(p);\n    dh.x = dt.x;\n    if(abs(dh.x) < .001){\n      n = normalize(m(p).x - vec3(m(p-e.xyy).x, m(p-e.yxy).x,m(p-e.yyx).x));\n      float dif = max(0., dot(l, n));\n      float sp = pow(max(.0,dot(reflect(-l,n), -r)), 50.);\n      float fr = pow(1.+dot(l,n),4.);\n      co = vec3(dif + sp )*min(.45,fr);\n      if(dt.y == 0.){\n          r=reflect(r, n)*.1;\n          p+=5.;\n      }\n      if(dt.y == 1. ){\n          r=refract(r, n,.65)*.11;\n          p+=20.;\n      }\n    }\n    if(dh.y > 150.) break;\n    dh.y += dh.x;\n    p+=dh.x*r;\n  }\n  vec3 COL_M = vec3(0.434)*.025;\n  vec3 COL_L = vec3(0.3, 0.0853, 0.75)*2.;\n  vec3 COL_LL = vec3(.1, .1, .73);\n  \n  co += acum[0]*COL_M*.31;\n  co += acum[1]*COL_L*.91;\n  co += acum[2]*COL_LL;\n  co += pow((i/100.),.4545)*vec3(0.34,0.1,0.96)*.63595;\n  co = pow(co, vec3(.453434));\n  \n  co *= 1.-max(0., length(p-s)/40.)*(1.-vec3(.34, .15, 0.75)*.86);\n\tfragColor = sqrt(vec4(co, 1.));\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 209, 229, 229, 414], [451, 451, 468, 468, 551], [562, 562, 587, 587, 635], [636, 636, 661, 661, 745], [746, 746, 784, 784, 847], [849, 849, 865, 865, 1371], [1372, 1372, 1388, 1388, 2157], [2159, 2159, 2175, 2175, 2419], [2421, 2421, 2436, 2436, 2812], [2813, 2813, 2870, 2870, 4496]]}
{"id": "flG3Dt", "name": "Norms", "author": "J_S_Guy", "description": "Peeooow, time to turn off that darned screen and go outside! (Or fiddle around with norms)", "tags": ["mathematics", "norm"], "likes": 2, "viewed": 34, "published": "Public", "date": "1638495903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://en.wikipedia.org/wiki/Norm_(mathematics)#p-norm\n\n//xy scaling factors\n#define a .7\n#define b 1.\n\n//\n#define p 2.\n#define value 1.\n\n//transition width parameter\n#define w .10\n\nfloat unrooted_norm(vec2 x, vec2 scale, float exponent)\n{\n    return scale.x*pow(abs(x.x), exponent) + scale.y*pow(abs(x.y), exponent);\n}\n\nvoid mainImage( out vec4 O, in vec2 U)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = U -.5*R; uv /= .5*R.y;\n    float t = iTime;\n    t = mod(t, 3.);\n    \n    float col = smoothstep(value+w,value-w,unrooted_norm(uv, vec2(a,b), .15/t)); //tv switch off effect\n    //float col = smoothstep(value+w,value-w,unrooted_norm(uv, vec2(a,b), p));\n    \n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,1.), .5));  //astroid\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,1.), 1.));  //square\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,1.), 2.));  //circle\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,1.), 4.));  //\n\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,-1.), .5));  //\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,-1.), 1.));  //\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,-1.), 2.));  //hyperbola\n    //float col = smoothstep(1.+w,1.-w,unrooted_norm(uv, vec2(1.,-1.), 4.));  //\n    O = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flG3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 185, 242, 242, 322], [324, 324, 364, 364, 1358]]}
{"id": "flK3Wc", "name": "Clowns in Parameter Space", "author": "SafetySkull", "description": "Found a secret clown meeting in the parameters of my attempt at a magnetic pendulum.", "tags": ["fractal", "hsv", "magnet", "clown"], "likes": 4, "viewed": 98, "published": "Public", "date": "1638458592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n\n#define G 1.0\n#define MU 1.0\n\n#define AA 4\n\n#define DT 1.0\n#define MIN_DIST 0.1\n#define NUM_BODIES 8\n#define ITER 200\n\n// Clowns in parameter space:\n/*\n#define PI 3.1415926536\n\n#define G 1.0\n#define MU 1.0\n\n#define AA 4\n\n#define DT 1.0\n#define MIN_DIST 0.1\n#define NUM_BODIES 8\n#define ITER 200\n*/\n\nvec3 hsv2rgb_smooth( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float pixel_width = 2.0/iResolution.y;\n    float scale = 2.0;\n    uv *= scale;\n    pixel_width *= scale;\n    \n    vec2[NUM_BODIES] bodies;\n    for (int i = 0; i < NUM_BODIES; i++) {\n        bodies[i] = vec2(cos(2.0*PI*float(i)/float(NUM_BODIES)), sin(2.0*PI*float(i)/float(NUM_BODIES)));\n    }\n    vec3 col = vec3(0.0);\n    for (int nx = 0; nx < AA; nx++) {\n        for (int ny = 0; ny < AA; ny++) {\n        \n            vec2 pos = uv + pixel_width*vec2(nx,ny)/float(AA);\n            vec2 vel = vec2(0.0);\n            vec2 acc = vec2(0.0);\n            \n            float dist;\n            int dist_i;\n            for (int i = 0; i < ITER; i++) {\n                dist = 2.0*scale;\n                dist_i = -1;\n                bool tooClose = false;\n                for (int bod = 0; bod < NUM_BODIES; bod++) {\n                    vec2 body = bodies[bod];\n                    vec2 r = (body-pos);\n                    float r_ = length(r);\n                    if (r_<dist) {\n                        dist = r_;\n                        dist_i = bod;\n                    }\n                    if (dist<MIN_DIST) {\n                        tooClose = true;\n                        break;\n                    }\n                    acc += -G*r/pow(r_,3.0);\n                }\n                if(tooClose) break;\n                acc -= vel*MU;\n                \n                vel += DT*acc;\n                pos += DT*acc;\n            }\n            col += hsv2rgb_smooth(vec3(fract(float(dist_i)/float(NUM_BODIES)+0.2*iTime),1.0-0.2*dist,1.0));\n        }\n    }\n    col /= float(AA*AA);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flK3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 324, 358, 358, 536], [538, 538, 595, 645, 2342]]}
{"id": "fltSWn", "name": "Kleurstaal", "author": "davidar", "description": "Animation of a piece from Bram Vanhaeren's Kleurstaal series:\n\n[url]https://www.behance.net/gallery/53570349/Kleurstaal[/url]", "tags": ["color", "palette", "colour", "geometric"], "likes": 9, "viewed": 130, "published": "Public API", "date": "1638959800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rgb(r,g,b) pow(vec3(r,g,b) / 255., vec3(2.2));\n#define mx(a,b,v) mix(a, b, smoothstep(-texel, texel, v))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texel = 1. / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.) / 2.;\n    \n    vec3 pink = rgb(255, 147, 249);\n    vec3 purple = rgb(32, 16, 63);\n    vec3 red = rgb(249, 14, 29);\n    vec3 skyblue = rgb(184, 229, 250);\n    vec3 deepblue = rgb(49, 108, 244);\n    vec3 white = rgb(240, 238, 249);\n    \n    float r1 = 0.2 + 0.02 * cos(iTime);\n    float r2 = 0.3 + 0.03 * cos(1.2 * iTime + 1.);\n    float r3 = 0.18 + 0.02 * cos(1.2 * iTime + 2.);\n    float r4 = 0.15 + 0.01 * cos(3. * iTime);\n    \n    float t1 = 1. + 0.1 * cos(0.5 * iTime);\n    float t2 = 0.6 + 0.05 * cos(0.3 * iTime);\n    float t3 = -0.6 + 0.05 * cos(0.2 * iTime + 1.);\n    float t4 = 0. + 0.1 * cos(0.6 * iTime + 2.);\n\n    vec3 col = mx(\n        mx(\n            mx(\n                mx(white, skyblue, length(uv - vec2(0.75,0.25)) - r1),\n                mx(\n                    mx(purple, deepblue, length(uv - vec2(0.75,0.25)) - r1),\n                    mx(white, purple, length(uv - vec2(0.75,0.25)) - r1),\n                    length(uv - 0.5) - r2),\n                uv.y - uv.x - t3),\n            mx(\n                mx(\n                    mx(purple, red, length(uv - 0.5) - r3),\n                    skyblue,\n                    length(uv - 0.5) - r2),\n                mx(purple, deepblue, length(uv - vec2(0,1)) - r4),\n                uv.y - uv.x - t2),\n            uv.y - uv.x - t4),\n        mx(\n            mx(\n                mx(red, white, length(uv - vec2(0.75,0.25)) - r1),\n                mx(pink, purple, length(uv - vec2(0.75,0.25)) - r1),\n                length(uv - 0.5) - r2),\n            mx(\n                mx(\n                    mx(skyblue, purple, length(uv - 0.5) - r3),\n                    pink,\n                    length(uv - 0.5) - r2),\n                mx(red, skyblue, length(uv - vec2(0,1)) - r4),\n                uv.y - uv.x - t2),\n            uv.y - uv.x - t4),\n        uv.x + uv.y - t1);\n\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 171, 171, 2172]]}
{"id": "fltXz4", "name": "SnowFlake rnd", "author": "Emil", "description": "simple snowflake", "tags": ["2d", "snowflake", "snow", "flake"], "likes": 13, "viewed": 106, "published": "Public", "date": "1638802231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec3 i){\n\treturn fract(sin(dot(i.xyz,vec3(41595.34636,861.15646,268.489)))*968423.156);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    uv.y += iTime*0.4;\n    uv = (uv*4.0);\n    \n    vec2 cells = (uv+23.) - fract(uv);\n    cells *= 0.08;\n    \n    float rnd_x = random(vec3(0.685136, cells)); // iMouse.x*0.01\n    float rnd_y = random(vec3(cells, 3451.5)); // iMouse.y*0.01\n    \n    uv = fract(uv)-0.5;\n    \n    uv *= 1.67;\n    float rnd = (rnd_x+rnd_y);\n    uv += vec2(sin(iTime+rnd*40.0), sin(iTime+rnd*70.0))*0.25;\n    uv += vec2(sin(iTime*1.74+rnd*60.0), sin(iTime*2.74+rnd*60.0))*0.15;\n    \n    float luv = length(uv)*2.0;\n\n    float PI = 3.1415926537;\n    float radial = atan(uv.x, uv.y)/PI;\n    radial = atan(uv.x, uv.y)/PI + iTime * (rnd - 1.0) * 0.8;\n    radial = fract(radial*3.0);\n    radial = abs(radial-0.5);\n    float n_radial = radial*luv; // normalized radial\n    \n    float flake = texture(iChannel0, vec2(rnd_x, 0.0) + 0.26*vec2(n_radial, luv)).r;\n    flake = mix(flake, texture(iChannel0, vec2(0.0, rnd_y) + 0.4*vec2(n_radial*0.7, luv)).r, 0.5);\n    float edge = smoothstep(0.4, 1.0, luv);\n    flake *= 1.0-min(radial*0.5 + edge, 1.0);\n    flake = smoothstep(0.4, 0.7, flake);\n    flake += smoothstep(0.02, 0.0, n_radial) * (0.6-edge);\n    float result = min(radial*1.0, 1.0) + luv;\n    result = smoothstep(0.0, 0.3, flake);\n    //result = cells;\n    \n    fragColor = vec4(result, result, result,1.0);\n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 103], [105, 105, 162, 162, 1521]]}
{"id": "flVGDc", "name": "fork -bars", "author": "jorge2017a2", "description": "//http://hintz.bplaced.net/en/2013/webgl/bars/", "tags": ["bars", "fork"], "likes": 2, "viewed": 81, "published": "Public API", "date": "1638458974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fork -bars\n//http://hintz.bplaced.net/en/2013/webgl/bars/\n//modificado por jorge2017a2\nvec2 position;\nvec4 color;\nfloat barsize = 0.215;\nfloat barsangle ;\n\nvec4 bar(float pos, float r, float g, float b)\n{\treturn max(0.0, 1.0 - abs(pos - position.y) / barsize) * vec4(r, g, b, 1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float c, s;\n    mat2 R;\n\n     c = cos(iTime/2.0);\n     s = sin(iTime/2.0);\n     R = mat2(c,-s,s,-c);\n     barsangle = 200.0*sin(iTime*0.001);\n    position = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.xx;\n\tposition = 2.0*position*R;\n    \n    float t1=mod(iTime,4.0);\n    float t2=mod(iTime,8.0);\n    \n    if (t1<t2)\n        uv=position;\n    \n    vec4 col =vec4(0.0);\n    float t = iTime*0.5;\n    \n    uv.x+=0.2;\n    col+= bar(uv.x-0.1, 1.0, 0.0, 0.0);\n    col+= bar(uv.x-0.3, 0.0, 1.0, 0.0);\n    col+= bar(uv.x-0.6, 1.0, 1.0, 0.0);\n    col+= bar(uv.x-0.9, 0.0, 0.0, 1.0);\n    col+= bar(uv.x-1.15, 0.0, 1.0, 1.0);\n    col+= bar(uv.x-1.35, 1.0, 0.0, 1.0);\n    col=pow(col,vec4(0.454545));\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 206, 206, 285], [287, 287, 344, 394, 1178]]}
{"id": "flyGWt", "name": "rotation lava lamp", "author": "wnu", "description": "rotation based lava lamp", "tags": ["rotation"], "likes": 4, "viewed": 53, "published": "Public", "date": "1638488098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvec2 rot(vec2 uv,float a,vec2 origin){\n    \n    vec2 p = (uv - origin);\n    \n    float c = cos(a);\n    float s = sin(a);\n    \n\treturn mat2(c,-s,s,c)*p + origin;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 2\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define NUM_OCTAVES2 2\n\nfloat fbms ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES2; ++i) {\n        v += a * snoise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= R.x/R.y;\n    \n    uv *= 1.;\n    \n    float sc = 5.;\n    \n    //uv.x += iTime/10.;\n    \n    float ys = smoothstep(0.7,0.5,uv.y);\n    \n    float a = (fbm(uv*sc + vec2(0.,-iTime))*2. - 1.);\n    a = snoise(uv*2.+ vec2(0.,-iTime))/1.5;\n    a = (fbms(uv*sc + vec2(0.,-iTime)));\n    \n    uv = rot(uv,a,vec2(uv - fbms(uv)));\n\n    float l = smoothstep(0.49,0.51,uv.y);\n\n    vec3 col = vec3(l);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 63, 63, 187], [189, 189, 217, 217, 325], [327, 405, 432, 432, 814], [839, 839, 865, 865, 1202], [1204, 1204, 1225, 1225, 1272], [1273, 1273, 1294, 1294, 1341], [1342, 1342, 1364, 1364, 1399], [1401, 1401, 1423, 1476, 3173], [3199, 3199, 3226, 3226, 3565], [3567, 3567, 3624, 3674, 4198]]}
{"id": "ft3XD8", "name": "kusa (kaze)", "author": "gyabo", "description": "Kusa to kaze. 草風。", "tags": ["raymarching", "glsl"], "likes": 6, "viewed": 97, "published": "Public", "date": "1638981768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//2021 gyabo //https://www.shadertoy.com/view/ft3XD8\n#define time iTime\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n//#define KUSAKAZE\n\nfloat box(vec3 p) {\n    p.xz *= rot(time);\n    p.zy *= rot(time);\n    p = abs(p) - 0.02;\n\treturn max(p.x, max(p.y, p.z));\n}\n\nfloat tm;\n\nfloat map(vec3 p) {\n    vec3 tmp = p;\n    p = p.xzy;\n#ifdef KUSAKAZE\n    float t  = box(p - mix(vec3(0.450000, 0.100000, 0), vec3(0.150000, 0.150000, 0), tm));\n    t = min(t, box(p - mix(vec3(0.450000, 0.150000, 0), vec3(0.300000, 0.150000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.200000, 0), vec3(0.650000, 0.150000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.050000, 0.250000, 0), vec3(0.850000, 0.150000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.100000, 0.250000, 0), vec3(0.150000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.150000, 0.250000, 0), vec3(0.250000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.250000, 0), vec3(0.300000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.250000, 0.250000, 0), vec3(0.350000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.250000, 0), vec3(0.400000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.350000, 0.250000, 0), vec3(0.450000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.400000, 0.250000, 0), vec3(0.650000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.250000, 0), vec3(0.800000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.500000, 0.250000, 0), vec3(0.850000, 0.200000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.550000, 0.250000, 0), vec3(0.150000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.250000, 0), vec3(0.450000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.650000, 0.250000, 0), vec3(0.500000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.250000, 0), vec3(0.550000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.750000, 0.250000, 0), vec3(0.600000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.800000, 0.250000, 0), vec3(0.650000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.850000, 0.250000, 0), vec3(0.750000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.300000, 0), vec3(0.850000, 0.250000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.800000, 0.300000, 0), vec3(0.200000, 0.300000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.350000, 0), vec3(0.450000, 0.300000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.350000, 0), vec3(0.600000, 0.300000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.350000, 0), vec3(0.750000, 0.300000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.400000, 0), vec3(0.850000, 0.300000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.250000, 0.400000, 0), vec3(0.200000, 0.350000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.400000, 0), vec3(0.450000, 0.350000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.350000, 0.400000, 0), vec3(0.750000, 0.350000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.400000, 0.400000, 0), vec3(0.200000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.400000, 0), vec3(0.300000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.500000, 0.400000, 0), vec3(0.350000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.550000, 0.400000, 0), vec3(0.400000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.400000, 0), vec3(0.450000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.650000, 0.400000, 0), vec3(0.500000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.400000, 0), vec3(0.550000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.450000, 0), vec3(0.600000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.450000, 0), vec3(0.700000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.500000, 0), vec3(0.200000, 0.450000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.500000, 0), vec3(0.300000, 0.450000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.550000, 0), vec3(0.450000, 0.450000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.250000, 0.550000, 0), vec3(0.600000, 0.450000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.550000, 0), vec3(0.700000, 0.450000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.350000, 0.550000, 0), vec3(0.200000, 0.500000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.400000, 0.550000, 0), vec3(0.300000, 0.500000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.550000, 0), vec3(0.450000, 0.500000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.500000, 0.550000, 0), vec3(0.600000, 0.500000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.550000, 0.550000, 0), vec3(0.700000, 0.500000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.550000, 0), vec3(0.200000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.650000, 0.550000, 0), vec3(0.300000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.550000, 0), vec3(0.350000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.600000, 0), vec3(0.400000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.600000, 0), vec3(0.450000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.650000, 0), vec3(0.500000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.250000, 0.650000, 0), vec3(0.550000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.650000, 0), vec3(0.600000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.350000, 0.650000, 0), vec3(0.700000, 0.550000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.400000, 0.650000, 0), vec3(0.200000, 0.600000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.650000, 0), vec3(0.450000, 0.600000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.500000, 0.650000, 0), vec3(0.700000, 0.600000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.550000, 0.650000, 0), vec3(0.200000, 0.650000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.650000, 0), vec3(0.300000, 0.650000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.650000, 0.650000, 0), vec3(0.350000, 0.650000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.650000, 0), vec3(0.400000, 0.650000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.750000, 0.650000, 0), vec3(0.450000, 0.650000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.700000, 0), vec3(0.700000, 0.650000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.700000, 0), vec3(0.200000, 0.700000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.750000, 0), vec3(0.500000, 0.700000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.750000, 0), vec3(0.550000, 0.700000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.050000, 0.800000, 0), vec3(0.600000, 0.700000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.100000, 0.800000, 0), vec3(0.700000, 0.700000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.150000, 0.800000, 0), vec3(0.200000, 0.750000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.200000, 0.800000, 0), vec3(0.550000, 0.750000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.250000, 0.800000, 0), vec3(0.700000, 0.750000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.800000, 0), vec3(0.200000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.350000, 0.800000, 0), vec3(0.250000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.400000, 0.800000, 0), vec3(0.300000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.450000, 0.800000, 0), vec3(0.350000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.500000, 0.800000, 0), vec3(0.400000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.550000, 0.800000, 0), vec3(0.450000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.800000, 0), vec3(0.500000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.650000, 0.800000, 0), vec3(0.550000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.700000, 0.800000, 0), vec3(0.600000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.750000, 0.800000, 0), vec3(0.650000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.800000, 0.800000, 0), vec3(0.700000, 0.800000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.850000, 0.800000, 0), vec3(0.400000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.850000, 0), vec3(0.450000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.850000, 0), vec3(0.500000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.800000, 0.850000, 0), vec3(0.550000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.300000, 0.900000, 0), vec3(0.600000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.350000, 0.900000, 0), vec3(0.700000, 0.400000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.600000, 0.900000, 0), vec3(0.200000, 0.450000, 0), tm)));\n    t = min(t, box(p - mix(vec3(0.650000, 0.900000, 0), vec3(0.300000, 0.450000, 0), tm)));\n#else //KUSAKAZE\n    float t  = box(p - vec3(0.450000, 0.100000, 0));\n    t = min(t, box(p - vec3(0.450000, 0.150000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.200000, 0)));\n    t = min(t, box(p - vec3(0.050000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.100000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.150000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.250000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.350000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.400000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.500000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.550000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.650000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.750000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.800000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.850000, 0.250000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.300000, 0)));\n    t = min(t, box(p - vec3(0.800000, 0.300000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.350000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.350000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.350000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.250000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.350000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.400000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.500000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.550000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.650000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.400000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.450000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.450000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.500000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.500000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.250000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.350000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.400000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.500000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.550000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.650000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.550000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.600000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.600000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.250000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.350000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.400000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.500000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.550000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.650000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.750000, 0.650000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.700000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.700000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.750000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.750000, 0)));\n    t = min(t, box(p - vec3(0.050000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.100000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.150000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.200000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.250000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.350000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.400000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.450000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.500000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.550000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.650000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.700000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.750000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.800000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.850000, 0.800000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.850000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.850000, 0)));\n    t = min(t, box(p - vec3(0.800000, 0.850000, 0)));\n    t = min(t, box(p - vec3(0.300000, 0.900000, 0)));\n    t = min(t, box(p - vec3(0.350000, 0.900000, 0)));\n    t = min(t, box(p - vec3(0.600000, 0.900000, 0)));\n    t = min(t, box(p - vec3(0.650000, 0.900000, 0)));\n#endif //KUSAKAZE\n    p = tmp;\n    t = min(t, 0.01 + dot(p, vec3(0, 1, 0)));\n\treturn t;\n}\n\nvec3 getnor(vec3 p) {\n    float t = map(p);\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(vec3(\n        t - map(p + d.xyy),\n        t - map(p + d.yxy),\n        t - map(p + d.yyx)));\n        \n}\n\nfloat getao(float eps, vec3 N, vec3 p) {\n    return map(p + -N * eps) / eps;\n}\n\nvec4 getcol( vec2 fragCoord ) {\n\tvec2 uv = (2.0 *  fragCoord.xy - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec3 dir = normalize(vec3(uv + vec2(cos(time * 4.2), sin(time * 3.3)) * 0.02, 1.0));\n    vec3 pos = vec3(0.45, 0.5, 0.25);\n    dir.yz *= rot(1.2);\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 7; i++)\n\t\tt += map(dir * t + pos);\n    vec3 ip = dir * t + pos;\n    vec3 N = getnor(ip);\n    float ao = getao(0.05, N, ip) + getao(0.02, N, ip) + getao(0.01, N, ip);\n    vec3 L = normalize(vec3(1,-2,3));\n    float D = max(0.0, dot(L, N));\n#ifdef KUSAKAZE\n    vec3 b = mix(vec3(1,7.0 - tm * 3.0,2), vec3(7,2,3) + vec3(0,0,tm * 10.0), D);\n#else //KUSAKAZE\n    vec3 b = mix(vec3(1,7.0,2), vec3(7,2,3), D);\n#endif //KUSAKAZE\n    vec3 ret = t * b * ao * 0.03;\n    return vec4(ret, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tm = clamp(sin(time * 0.5) * 1.25, -1.0, 1.0) * 0.5 + 0.5;\n\tfragColor = getcol(fragCoord );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 146, 165, 165, 269], [282, 282, 301, 301, 14033], [14035, 14035, 14056, 14056, 14233], [14235, 14235, 14275, 14275, 14313], [14315, 14315, 14346, 14346, 15102], [15104, 15104, 15161, 15161, 15259]]}
{"id": "ft3XR2", "name": "Sphube", "author": "OlafDoschke", "description": "Generalization of Sphere with distance metric |x|^n+|y|^n+|z|^n with sphere for n=2, cube for n infinity\ncavalier projection: 0.5 * z is added to x and y;\n\nfor n fixed to 2.0 a factor 0.2 looks more like a sphere but then the cube looks too flat.", "tags": ["cube", "sphere", "sphube", "cavalier"], "likes": 1, "viewed": 69, "published": "Public", "date": "1639384072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sphube(vec3 uvf, float r, float n, float blur)\n{\n    float c = pow(abs(uvf.x),n)+pow(abs(uvf.y),n)+pow(abs(uvf.z),n);\n    \n    return smoothstep(r+blur,r-blur,c);\n}\n\n\nvec4 samplePixel(vec3 uvf) {\n    // Put all your actual drawing code in here\n    float c= Sphube(uvf,1.,iTime,.05);\n    \n    return vec4(c*(uvf.y+1.)/2.);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    vec4 sum = vec4(0.);\n    \n    for (int f=-1010; f<1010; f++) {\n        float z = float(f)/1000.;\n        \n        vec3 pos3d = vec3(pos.x-.2*z, pos.y-.2*z, z);\n        \n        vec4 sp = samplePixel(pos3d);\n        \n        if (length(sp)>length(sum))\n        sum = sp;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    \n    uv = 3.*(uv-.5)*aspect;\n    \n    fragColor = superSamplePixel(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 170], [173, 173, 201, 249, 329], [331, 331, 364, 364, 667], [669, 669, 726, 726, 904]]}
{"id": "ft3XRH", "name": "solid angle reflection", "author": "do", "description": "na", "tags": ["solidanglereflect"], "likes": 4, "viewed": 76, "published": "Public", "date": "1638677632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\n//solid angle reflection\n//2021\n//do\n\n#define AA 2\n#define EPS 0.001\n\nfloat h11(float p) {\n    return fract(sin(p)*float(43758.5453));\n}\n\nfloat checkerboard(vec3 p,float h) {\n    vec3 q = floor(p*h);\n    return mod(q.x+q.z,2.);\n}\n\nfloat expStep(float x,float k) {\n    return exp((x*k)-k);\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nvec3 rayCamDir(vec2 uv,vec3 ro,vec3 ta,float fov) {\n\n     vec3 f = normalize(ta - ro);\n     vec3 r = normalize(cross(vec3(0.0,1.0,0.0),f));\n     vec3 u = normalize(cross(f,r));\n\n     vec3 d = normalize(uv.x * r\n     + uv.y * u + f * fov);  \n\n     return d;\n}\n\nfloat easeOut3(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\nfloat sphere(vec3 p,float r) { \n    return length(p) - r;\n}\n\nfloat capsule(vec3 p,vec3 a,vec3 b,float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa - ba * h) - r;\n} \n\nfloat prism(vec3 p,vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y,  \n    max(q.x * 0.866025 + p.y * 0.5,-p.y) - h.x * 0.5); \n}\n\nfloat torus(vec3 p,vec2 t) {\n    vec2 q = vec2(length(vec2(p.x,p.z)) - t.x,p.y);\n    return length(q) - t.y; \n}\n\nfloat cylinder(vec3 p,float h,float r) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat tetrahedron(vec3 p,float h) {\n     vec3 q = abs(p);\n     float y = p.y;\n     float d1 = q.z-max(y,0.);\n     float d2 = max(q.x*.5+y*.5,0.)-min(h,h+y);\n     return length(max(vec2(d1,d2),.005)) + min(max(d1,d2),0.);\n}\n\nfloat octahedron(vec3 p,float s) {\n    p = abs(p);\n\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n\n    if(3.0 * p.x < m) {\n       q = vec3(p.x,p.y,p.z);  \n    } else if(3.0 * p.y < m) {\n       q = vec3(p.y,p.z,p.x); \n    } else if(3.0 * p.z < m) { \n       q = vec3(p.z,p.x,p.y);\n    } else { \n       return m * 0.57735027;\n    }\n\n    float k = clamp(0.5 *(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z - k)); \n}\n\nfloat box(vec3 p,vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sa(vec3 p,vec2 c,float ra) {\n    vec2 q = vec2(length(p.xy),p.z);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q,c),0.,ra));\n    return max(l,m * sign(q.x * c.y - q.y * c.x));\n}\n\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\nvec3 q = p;\n\nfloat b;\nb = box(q-vec3(3.,1.,-6.),vec3(1.));\nres = opu(res,vec2(b,2.));\n\nres = opu(res,vec2(sphere(q-vec3(-6.,2.,3.),2.),39.453));\n\nres = opu(res,vec2(\ncapsule(q-vec3(-7.,.5,.9)\n,vec3(-2.,3.,-1.),vec3(0.),.5),225.9));\n\nres = opu(res,vec2(torus(q.yzx-vec3(1.5,-3.5,-5.5),vec2(1.,.5)),12.6));\nres = opu(res,vec2(tetrahedron(q-vec3(-3.,.1,-5.),.75),75.67));\nres = opu(res,vec2(octahedron(q-vec3(-.75,1.,-5.1),1.),100.1));\nres = opu(res,vec2(cylinder(q-vec3(-5.,1.,-1.),.5,.25),64.364));\nres = opu(res,vec2(prism(q-vec3(-5.5,1.,-2.),vec2(1.,.25)),124.5));\n\np.xz *= rot(-.5+easeOut3(sin(.5*t)*.25)+1.25);\nvec3 n = p;\nn.zy *= rot(-2.5);\n\nfloat sc = sa(n,vec2(.6,.8),1.);\nres = opu(res,vec2(sc,5.));\n\nres = opu(res,vec2(p.y,1.));\n\nreturn res;\n\n\n}\n\nvec2 trace(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = 0.;\n    float e = 16.;  \n\n    for(int i = 0; i < 75; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(dist.x < EPS || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 125; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,100. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < .01 || t > 10.) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * EPS;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 render(inout vec3 ro,inout vec3 rd,inout vec3 ref) {\n\n    vec2 d = trace(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = calcNormal(p);\n    vec3 linear = vec3(0.);\n    vec3 r = reflect(rd,n); \n    float amb = sqrt(clamp(.5+.5*n.x,0.,1.));\n    float fre = pow(clamp(1.+dot(n,rd),0.,1.),2.);\n    vec3 bcol = vec3(1.3);\n    vec3 col = bcol * max(1.,rd.y);\n\n    vec3 l = normalize(vec3(25.,3.,-35.));\n\n    float rad = dot(rd,l);\n    col += col * vec3(.5,.7,.5) * expStep(rad,100.);\n    col += col * vec3(.5,.1,.15) * expStep(rad,125.);\n    col += col * vec3(.1,.5,.05) * expStep(rad,25.);\n    col += col * vec3(.15) * expStep(rad,35.);\n\n    vec3 h = normalize(l - rd);  \n    float dif = clamp(dot(n,l),0.0,1.0);\n    float spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n    * dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\n    if(d.y >= 0.) {\n        \n        col = .5+.5*sin(2.*d.y+vec3(6.*h11(5.),2.,3.));\n\n        dif *= shadow(p,l);\n\n        linear += dif * vec3(1.9);\n        linear += amb * vec3(0.5);\n        linear += fre * vec3(.25,.1,.03);\n        linear += spe * vec3(0.04,0.05,.05);\n\n        if(d.y == 5.) {\n            col = vec3(.5);\n            ref = vec3(.5);\n            //rd = r;                 \n        }\n\n        if(d.y == 1.) {\n            col = vec3(checkerboard(p,1.))*vec3(1.,.5,.25);\n            ref = vec3(.5);\n        }\n\n        rd = r;\n\n        col = col * linear;\n        col = mix(col,bcol,1.-exp(-.001*d.x*d.x*d.x));\n\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) { \nvec3 color = vec3(0.);\n\nvec3 ta = vec3(0.);\nvec3 ro = vec3(-2.,2.,-1.3);\n\nfor(int k = 0; k < AA; k++ ) {\n   for(int l = 0; l < AA; l++) {\n   \n       vec2 o = vec2(float(k),float(l)) / float(AA) * .5;\n       vec2 uv = (2.* (fragCoord.xy+o) - \n       iResolution.xy)/iResolution.y;\n\n       vec3 rd = rayCamDir(uv,ro,ta,2.); \n       vec3 ref = vec3(0.);\n       vec3 col = render(ro,rd,ref);       \n       vec3 c = vec3(.5);\n       col += c * render(ro,rd,ref);\n       col = pow(col,vec3(.4545));\n       color += col;\n   }\n}\n   \n   color /= float(AA*AA);\n   fragColor = vec4(color,1.0);\n \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 87, 107, 107, 153], [155, 155, 191, 191, 246], [248, 248, 280, 280, 307], [309, 309, 336, 336, 374], [377, 377, 396, 396, 474], [476, 476, 527, 527, 734], [736, 736, 761, 761, 803], [805, 805, 835, 835, 864], [866, 866, 911, 911, 1043], [1046, 1046, 1074, 1074, 1181], [1183, 1183, 1211, 1211, 1294], [1296, 1296, 1336, 1336, 1445], [1447, 1447, 1482, 1482, 1669], [1671, 1671, 1705, 1705, 2095], [2097, 2097, 2123, 2123, 2214], [2216, 2216, 2250, 2250, 2423], [2425, 2425, 2445, 2445, 3227], [3229, 3229, 3258, 3258, 3589], [3591, 3591, 3623, 3623, 4035], [4037, 4037, 4062, 4062, 4369], [4371, 4371, 4428, 4428, 5842], [5844, 5844, 5898, 5898, 6487]]}
{"id": "ft3XRl", "name": "Cube 4D", "author": "romeosoft", "description": "4D Cube", "tags": ["4d", "4dcube"], "likes": 1, "viewed": 36, "published": "Public", "date": "1639579910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// colors\nconst vec3 \n    c1 = vec3(0.8, 0.5, 0.0),\n\tc2 = vec3(.0, .0,.8);\n\n// light direction\nvec3 light = vec3(-1.414 / 2.,-1.414 / 2.,0.);   \n\nconst float PI = 3.1415926;\n//--------------------------------------------------------------\n// Cross4 computes the four-dimensional cross product of the three vectors\n// U, V and W, in that order. It returns the resulting four-vector.\nvec4 cross4D(vec4 U, vec4 V, vec4 W)\n{\n    vec4 result;\n    float A, B, C, D, E, F;       // Intermediate Values\n\n    // Calculate intermediate values.\n\n    A = (V.x * W.y) - (V.y * W.x);\n    B = (V.x * W.z) - (V.z * W.x);\n    C = (V.x * W.w) - (V.w * W.x);\n    D = (V.y * W.z) - (V.z * W.y);\n    E = (V.y * W.w) - (V.w * W.y);\n    F = (V.z * W.w) - (V.w * W.z);\n\n    // Calculate the result-vector components.\n\n    result.x = (U.y * F) - (U.z * E) + (U.w * D);\n    result.y = -(U.x * F) + (U.z * C) - (U.w * B);\n    result.z = (U.x * E) - (U.y * C) + (U.w * A);\n    result.w = -(U.x * D) + (U.y * B) - (U.z * A);\n\n    return result;\n}\nmat4 rotXY(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,st,0.0,0.0,\n        -st,ct,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n\nmat4 rotYZ(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,st,0.0,\n        0.0,-st,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotXZ(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,-st,0.0,\n        0.0,1.0,0.0,0.0,\n        st,0.0,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotXW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,0.0,st,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        -st,0.0,0.0,ct\n    );\n}\n\nmat4 rotYW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,0.0,-st,\n        0.0,0.0,1.0,0.0,\n        0.0,st,0.0,ct\n    );\n}\n\nmat4 rotZW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,ct,-st,\n        0.0,0.0,st,ct\n    );\n}\n\n// geom\nfloat box(vec4 p, vec4 o, float r)\n{\n    if(    (p.x > o.x - r && p.x < o.x + r)\n         &&(p.y > o.y - r && p.y < o.y + r)\n         &&(p.z > o.z - r && p.z < o.z + r)\n         &&(p.w > o.w - r && p.w < o.w + r)\n        )\n        return -1.;\n    return 0.;\n}\n\nfloat udBox( vec4 p, vec4 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// render\nvec3 shade(vec4 p, float v)\n{\n    vec3 cor = mix(c2, c1, 0.5 + 0.5 * sin(p.x*p.y*p.z*50. + 25. * p.w));\n    \n    return mix(cor, vec3(0.1), dot(p.xyz, light));\n}\n\n// camera dirction\nvoid calc4matrix(\n    vec4 From, vec4 To, vec4 Up, vec4 Over,\n    out vec4 Wa, out vec4 Wb, out vec4 Wc, out vec4 Wd\n)\n{\n    // Get the normalized Wd column-vector.\n    Wd = To - From;\n    Wd=normalize(Wd);\n\n    // Calculate the normalized Wa column-vector.\n    Wa = cross4D(Up, Over, Wd);\n    Wa=normalize(Wa);\n\n    // Calculate the normalized Wb column-vector.\n    Wb = cross4D(Over, Wd, Wa);\n    Wb=normalize(Wb);\n\n    // Calculate the Wc column-vector.\n    Wc = cross4D(Wd, Wa, Wb);\n    Wc=normalize(Wc);\n}\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -(iMouse.x / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * PI * 2.0;\n    \n\tvec4 cam = vec4(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        0.5,\n        eyer * sin(eyea) * sin(eyef));\n    float ang = iTime * 0.25;\n    cam = cam * (rotXY(iTime * 0.25) * rotZW(iTime * 0.5 + PI / 1.5)); // DOUBLE ROTATION\n    \n    vec4 front, left;\n    vec4 to = vec4(0.0);\n    vec4 up = vec4(0.0, 1.0, 0.0, 0.0);\n    vec4 over = vec4(0.0, 0.0, 0.0, 1.0);\n    calc4matrix(\n        cam, to, up, over, \n        left, up, over, front);\n    \n    vec4 v = normalize(front*1.5 - left*pp.x - up*pp.y);\n    \n    vec4 p = cam;\n    float dt = 0.01;\n    vec3 cor = vec3(0.0);\n    \n    for(int i = 0; i < 250; i ++)\n    {\n       float f = box(p, vec4(0.0,0.0,0.0,0.0),0.5);\n        if(f < 0.0)\n        {\n            cor = shade(p, f);\n            break;\n        }\n        p += v*dt;\n    }\n    \n    fragColor = vec4(cor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 382, 420, 420, 1017], [1018, 1018, 1039, 1039, 1207], [1209, 1209, 1230, 1230, 1398], [1408, 1408, 1429, 1429, 1597], [1607, 1607, 1628, 1628, 1796], [1798, 1798, 1819, 1819, 1987], [1989, 1989, 2010, 2010, 2178], [2180, 2188, 2224, 2224, 2447], [2449, 2449, 2489, 2489, 2531], [2533, 2543, 2572, 2572, 2704], [2706, 2725, 2845, 2889, 3235], [3236, 3301, 3358, 3358, 4420]]}
{"id": "ft3Xz2", "name": "Singapore Flag", "author": "Rockyee", "description": "learned from Martijn Steinrucken aka The Art of Code/BigWIngs", "tags": ["flag", "singapore", "singaporean"], "likes": 3, "viewed": 26, "published": "Public", "date": "1639387035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 WHITE = vec3(1);\nvec3 RED = vec3(200, 34, 52) / 255.;\n\nfloat Circle(vec2 uv, vec2 p, float r)\n{\n    float d = length(uv - p);\n    float w = min(fwidth(d), .05);\n    return smoothstep(r, r-w, d);\n}\n\nfloat Star(vec2 uv, float size)\n{\n    uv.x = abs(uv.x);\n    \n    float a = 6.28 / 5.;\n    float d1 = dot(uv, vec2(sin(a), cos(a)));\n    a = 3. * 6.28 /5.;\n    float d2 = dot(uv, vec2(sin(a), cos(a)));\n    a = 2. * 6.28 /5.;\n    float d3 = dot(uv, vec2(sin(a), cos(a)));\n    float d4 = uv.y;\n    \n    float d = min(max(d1, d2), max(d3, d4));\n    float w = min(fwidth(d), .05);    \n    return smoothstep(w, -w, d - size);\n}\n\nvec2 Remap(vec2 p, float b, float t, float l, float r)\n{\n    return vec2((p.x - l) / (r - l), (p.y - b) / (t - b));\n}\n\nvec3 Flag(vec2 uv)\n{\n    float w = fwidth(uv.y);\n    float d = smoothstep(.5, .5 - w, uv.y);    \n    \n    vec2 st = Remap(uv, .5, 1., .065, .35);\n    float circle1 = Circle(st, vec2(.45, .5), .35);\n    float circle2 = Circle(st, vec2(.55, .5), .32);\n    d += max(circle1- circle2, 0.);\n    \n    st = Remap(uv, .5, 1., .08, .45);\n    st -= .5;\n    float r = 0.177;\n    float size = 0.028;    \n    d += Star(st - vec2(0., 1.) * r, size);\n    float a = 6.28 / 5.;\n    d += Star(st - vec2(sin(a), cos(a)) * r, size);\n    a = 2. * 6.28 / 5.;\n    d += Star(st - vec2(sin(a), cos(a)) * r, size);\n    a = 3. * 6.28 / 5.;\n    d += Star(st - vec2(sin(a), cos(a)) * r, size);\n    a = 4. * 6.28 / 5.;\n    d += Star(st - vec2(sin(a), cos(a)) * r, size);\n        \n    vec3 col = mix(RED, WHITE, d);\n    col *= smoothstep(w, 0., abs(uv.y - .5) - .5 + w);    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t =  uv.x * 8. - 1.8 * iTime + uv.y * 2.8;\n    uv.y += sin(t) * .055;\n    vec3 col = Flag(uv);    \n    col *= .7 + cos(t) * .3;    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3Xz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 100, 100, 201], [203, 203, 236, 236, 624], [626, 626, 682, 682, 743], [745, 745, 765, 765, 1606], [1608, 1608, 1665, 1665, 1880]]}
{"id": "ft3XzM", "name": "Painting with maths", "author": "gubebra", "description": "Simple shader that gives an effect of painting. https://gubebra.itch.io/", "tags": ["cineshader"], "likes": 7, "viewed": 270, "published": "Public API", "date": "1638816978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    for (float i = 2.0; i < 13.0; i++)\n    {\n        uv.x += 0.4 / i * cos(i * 2.0 * uv.y + iTime) * cos(i * 1.5 * uv.y + iTime);\n        uv.y += 0.4 / i * cos(i * 2.0 * uv.x + iTime);\n    }\n    \n    vec3 col = cos(iTime / 4.0 - uv.xyx);\n    if (col.r > 0.0) col.r = 1.0;\n    if (col.g > 0.0) col.g = 1.0;\n    if (col.b > 0.0) col.b = 1.0;\n    \n    col.b = col.g;\n    \n    if (col.r > 0.99 && col.g > 0.99 && col.b > 0.99) \n        col = vec3(0.0, 0.0, 0.0);\n    \n    // alpha for cineshader\n    float alpha = 0.0;\n    if (col.g > 0.0 || col.r > 0.0) alpha = 0.6;\n    \n    fragColor = vec4(col, alpha);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Painting with maths\",\n\t\"description\": \"Simple shader that gives an effect of painting. https://gubebra.itch.io/\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3XzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 751]]}
{"id": "ftcSR8", "name": "Wavyy", "author": "TestCoder", "description": "wavy", "tags": ["wavy"], "likes": 2, "viewed": 16, "published": "Public", "date": "1638734693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float waveLine(vec2 uv, float waveThickness, float waveFrequency) {\n    return waveThickness / distance(\n        .5,\n        uv.y + sin(uv.x * waveFrequency) / waveFrequency\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec2 color = vec2(waveLine(uv, .05, 50.) * sin(iTime));\n\n    // Output to screen\n    fragColor = vec4(color, sin(color.x),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 67, 67, 182], [184, 184, 241, 291, 497]]}
{"id": "ftcXDM", "name": "mmm objkt", "author": "lennyjpg", "description": "[url]https://hicetnunc.art/objkt/581738[/url]\n[url]https://ipfs.io/ipfs/QmdbqnNZcr1mzePBnKzF8RZRnC2cgWEUJ1t6XoHJ2sr4uX[/url]", "tags": ["round", "blob", "loop", "mono"], "likes": 3, "viewed": 95, "published": "Public API", "date": "1639229662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(vec2 p, vec2 res){\n    p = mod(p,res.y);\n    float d = length(p-res.y*.5);\n    return smoothstep(d,d+1.5/iResolution.y, res.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 res = vec2(.25, .5);\n    vec2 u = uv;\n    u.y += sin(u.x * 7.7) * .05 * uv.y;\n    u.y += cos(u.x * 4.2) * .05;\n    u.y = abs(u.y - .5);\n    u.x = sin(uv.x * 3.) * .5;\n    u.x += mod(u.y, res.x);\n    u.x -= u.y + iTime * .14;\n    u.x += sin(u.y * .1) * .5;\n    float mmm = grid(u, res);\n    fragColor = vec4(mmm);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 140], [142, 142, 199, 199, 564]]}
{"id": "ftcXRs", "name": "Carpets slide-show", "author": "bunyk", "description": "Show different patterns", "tags": ["2d"], "likes": 0, "viewed": 43, "published": "Public", "date": "1639559015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ---------- Jet colormap -----------------------------\n// https://www.shadertoy.com/view/3tlGD4\n// float u0 = 0.0;\nconst vec3 color0 = vec3(0.0, 0.0, 0.5625); // blue\nconst float u1 = 1.0/9.0;\nconst vec3 color1 = vec3(0.0, 0.0, 1.0); // blue\nconst float u2 = 23.0/63.0;\nconst vec3 color2 = vec3(0.0, 1.0, 1.0); // cyan\nconst float u3 = 13.0/21.0;\nconst vec3 color3 = vec3(1.0, 1.0, 0.0); // yellow\nconst float u4 = 47.0/63.0;\nconst vec3 color4 = vec3(1.0, 0.5, 0.0); // orange\nconst float u5 = 55.0/63.0;\nconst vec3 color5 = vec3(1.0, 0.0, 0.0); // red\n// float u6 = 1.0;\nconst vec3 color6 = vec3(0.5, 0.0, 0.0); // red\n\n// rescaling function\n#define rescale(u, v, x) (x - u)/(v - u)\n\nvec3 jetLinear(float t)\n{\n\treturn\n        + mix(color0, color1, rescale(0.0, u1, t))\n        + (mix(color1, color2, rescale(u1, u2, t)) - mix(color0, color1, rescale(0.0, u1, t))) * step(u1, t)\n        + (mix(color2, color3, rescale(u2, u3, t)) - mix(color1, color2, rescale(u1, u2, t))) * step(u2, t)\n        + (mix(color3, color4, rescale(u3, u4, t)) - mix(color2, color3, rescale(u2, u3, t))) * step(u3, t)\n        + (mix(color4, color5, rescale(u4, u5, t)) - mix(color3, color4, rescale(u3, u4, t))) * step(u4, t)\n        + (mix(color5, color6, rescale(u5, 1.0, t)) - mix(color4, color5, rescale(u4, u5, t))) * step(u5, t)\n        ;\n}\n// end of colormap -------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 20.0;\n    vec2 pos = vec2(cos(t), sin(t)) * 5.0;\n    \n    // make height of picture equal to 100 \"pixels\"\n    vec2 uv = trunc((fragCoord/iResolution.y + pos) * 100.0);\n\n    float n = trunc(iTime + 15.0);\n    if (mod(n, 5.0) == 0.0) {\n        n += 1.0;\n    }\n    // (x^2 + y^2) mod n mod 5\n    // https://commons.wikimedia.org/wiki/File:Remainder-pattern1.png\n    float val = mod(mod(dot(uv, uv), n), 5.0) / 5.0;\n    \n    vec3 col = jetLinear(val);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 687, 712, 712, 1325], [1326, 1396, 1453, 1453, 1957]]}
{"id": "ftcXWn", "name": "Trippy Circles - Plotted Graph", "author": "spenceryonce", "description": "Simple Circles plotted on a simulated graph with uv modulation.", "tags": ["circles", "simple", "graph", "trippy", "plot", "xy"], "likes": 1, "viewed": 30, "published": "Public", "date": "1638907880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Spencer Yonce\n// Title: Trippy Circles\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat PI = 3.14159255858;\n\n\nfloat S(float a, float b, float c){\n    return smoothstep(a,b,c);\n}\n\nfloat plot(vec2 uv, float y){\n    float blur = 0.572;\n    return S(-0.02*blur,0.02*blur,uv.x-y)-\n        S(0.02*blur,-0.02*blur,uv.x-y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //normalize our uvs\n    vec2 uv = fragCoord.xy/iResolution.y-vec2(1.,0.5);\n\n    //change our coordinate space\n    uv.xy *= 5.204;\n    uv.x += 1.0-sin(iTime*0.5);\n    uv.y += -1.0*cos(iTime*0.5)-1.0;\n\n    //function for a circle\n    float y = uv.x*uv.x+uv.y*uv.y;\n\n    vec3 col = vec3(0.);\n\n    //plot 3 circles\n    float pct = plot(uv, y);\n    float pct2 = plot(uv+vec2(-0.420,-0.030), y*fract(y*0.816)*sin(iTime));\n    float pct3 = plot(uv+vec2(0.750,0.810), y*3.*cos(iTime*0.5)*fract(y*.3));\n\n    //add our circles to the final color\n    //col += vec3(pct,0.,0.);\n    //col += vec3(0.,pct2,0.);\n    //col -= vec3(0.,0.,pct3);\n\n    col += vec3(pct,pct2,-pct3);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 125, 160, 160, 192], [194, 194, 223, 223, 332], [334, 334, 389, 413, 1090]]}
{"id": "ftdSR4", "name": "simplex_noise + FBM", "author": "luolin", "description": "test simplex noise + FBM", "tags": ["noise"], "likes": 0, "viewed": 90, "published": "Public API", "date": "1639105160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nvec2 grad_simplex(int hash, float x, float y)\n{\n\tvec2 p = vec2(x, y);\n\tvec2 g0 = normalize(vec2(-1., 1.));\n\tvec2 g1 = normalize(vec2(1., 1.));\n\tvec2 g2 = normalize(vec2(-1., -1.));\n\tvec2 g3 = normalize(vec2(1., -1.));\n\n\tvec2 g4 = normalize(vec2(1., 0.5));\n\tvec2 g5 = normalize(vec2(-0.5, 1.));\n\tvec2 g6 = normalize(vec2(-1., -0.5));\n\tvec2 g7 = normalize(vec2(-1., -0.5));\n\n\tint h = hash & 7;\n\tif (h == 0) return g0;\n\telse if (h == 1) return g1;\n\telse if (h == 2) return g2;\n\telse if (h == 3) return g3;\n\telse if (h == 4) return g4;\n\telse if (h == 5) return g5;\n\telse if (h == 6) return g6;\n\telse if (h == 7) return g7;\n\n\treturn vec2(0., 0.);\n}\n\nvec2 hash22(vec2 vec)\n{\n\t\tint p[256] = int[256](\n\t\t\t\t\t\t151,160,137,91,90,15,                 \n\t\t\t\t\t\t131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,  \n\t\t\t\t\t\t190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n\t\t\t\t\t\t88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n\t\t\t\t\t\t77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n\t\t\t\t\t\t102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n\t\t\t\t\t\t135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n\t\t\t\t\t\t5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n\t\t\t\t\t\t223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n\t\t\t\t\t\t129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n\t\t\t\t\t\t251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n\t\t\t\t\t\t49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n\t\t\t\t\t\t138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n\t\t\t\t\t\t);\n\n\tfloat x  = vec.x;\n\tfloat y = vec.y;\n\n\tint xi = int(x) & 255;\n\tint yi = int(y) & 255;\n\tfloat xf = fract(x);\n\tfloat yf = fract(y);\n\tint aaa = p[p[    xi ]+    yi ];\n\treturn grad_simplex (aaa, xf  , yf);\n\n}\n\nfloat simplex_noise(vec2 vec)\n{\n\t\n    const float F = 0.366025404; // (sqrt(3)-1)/2;\n    const float G = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(vec + (vec.x + vec.y) * F);//P点变形后成超立方体后的立方体所在的索引号\n\n    vec2 a = vec - (i - (i.x + i.y) * G);//变形前输入点到(0, 0)点的距离向量\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - o + G;//变形前输入点到(1, 0)点或(0, 1)点的距离向量\n    vec2 c = a - 1.0 + 2.0 * G;//变形前输入点到(1, 1)点的距离向量\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\n    return dot(vec3 (70.0, 70.0, 70.0), n);\n}\n\n\nfloat fbm(vec2 st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // 进行旋转\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    // 进行分形的迭代\n\n    for (int i = 0; i < 3; ++i) {\n        v+= a * simplex_noise(st);\n        st =  st * 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\n#define shadow vec3(0.101961,0.619608,0.666667)\n#define hightlight vec3(0.666667,0.666667,0.498039)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n        vec2 st = fragCoord/iResolution.xy;\n        st *= 5.;\n\n\tvec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(fbm(st + 0.20 * iTime) + st + 0.20 * iTime);\n    q.y = fbm(fbm(st + 0.30 * iTime) + st + 0.30 * iTime);\n\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * iTime);\n    r.y = fbm(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * iTime);   \n\n    float f = fbm(st + r);\n\n    color = mix(shadow,\n                hightlight,\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n                \n    vec2 qq = vec2( fbm( st + vec2(0.0,0.0) ),\n                   fbm( st + vec2(5.2,1.3) ) );\n\n    vec2 rr = vec2( fbm( st + 4.0*qq + vec2(1.7,9.2) ),\n                   fbm( st + 4.0*q + vec2(8.3,2.8) ) );\n\n    f = fbm( st + 4.0*rr );\n    \n    float radom = fbm( st + fbm(st +fbm(st + 0.2*iTime)));\n\n    vec3 col = mix(shadow, vec3(1.,1., 1.), radom);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 50, 50, 646], [648, 648, 671, 671, 1949], [1951, 1951, 1982, 1982, 2727], [2730, 2730, 2750, 2750, 3084], [3187, 3187, 3244, 3294, 4413]]}
{"id": "ftdSRf", "name": "Water cave 1", "author": "TFoucour", "description": "Water cave test", "tags": ["raytracing"], "likes": 5, "viewed": 69, "published": "Public", "date": "1639502531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sunDirection vec3(-7., 5., 5.)\n\nfloat tun(vec3 p){\n    float noise = texture(iChannel0, p.xy).r;\n    return cos(p.x*.8)*.6 + cos(p.y*.5)*1.5 + cos(p.z+noise)*1.4;\n}\n\nfloat plan(vec3 p){\n    return p.y+.4;\n}\n\nfloat map(vec3 p){\n    float d;\n    \n    d = tun(p);\n    \n    return d;\n}\n\n\nvec3 spNormal(vec3 p){\n    vec2 e = vec2(1., -1.) * .0005;\n    float r = 1.;\n    return normalize(\n    e.xyy * map(p + e.xyy) +\n    e.yyx * map(p + e.yyx) +\n    e.yxy * map(p + e.yxy) +\n    e.xxx * map(p + e.xxx));\n}\n\nfloat raymarch(vec3 ro, vec3 rd){\n    float depth = .01;\n    \n    for(int i=0; i<255; i++){\n        float d = map( ro + depth*rd );\n\n        \n        depth += d;\n        if(d < 0.001 || depth > 100.) break;\n    }\n    \n    return depth;\n}\n\nvec3 getCamRayDir(vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 2.));\n    \n    return rd;\n}\n\n\nvec3 shade(vec3 ro, vec3 rd, vec3 p, vec3 n){\n    vec3 col = vec3(1.);\n    \n    vec3 ligthDirection = normalize(sunDirection - p);\n    vec3 diffuse = vec3(clamp(dot(n, ligthDirection), 0.2, 1.));\n    vec3 amb = vec3(.1, .2, .3);\n    \n    if(map(p) == tun(p)){\n        col = vec3(.3, .7, 1.);\n    }\n    \n    return col*(diffuse+amb);\n}\n\nvec3 reflexion(vec3 ray, vec3 rd, vec3 normal){\n    vec3 col;\n    \n    vec3 newOr = ray;\n    vec3 newDir = reflect(rd, normal);\n\n    float r = raymarch(newOr, newDir);\n    vec3 newRay = newOr + newDir*r;\n    vec3 newN = spNormal(newRay);\n\n    vec3 newCol = shade(newOr, newDir, newRay, newN);\n    col = mix(col, newCol, .5);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0., 1., -5.+iTime);\n    vec3 rd = getCamRayDir(fragCoord);\n\n    // Time varying pixel color\n    float r = raymarch(ro, rd);\n    \n    vec3 ray = ro+rd*r;\n    vec3 n = spNormal(ray);\n    vec3 col = shade(ro, rd, ray, n);\n    \n    \n    col+=reflexion(ray, rd, n);\n    \n    col *= exp(-0.04 * r);\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 58, 58, 172], [174, 174, 193, 193, 214], [216, 216, 234, 234, 289], [292, 292, 314, 314, 508], [510, 510, 543, 543, 747], [749, 749, 783, 783, 946], [949, 949, 994, 994, 1283], [1285, 1285, 1332, 1332, 1632], [1635, 1635, 1692, 1742, 2254]]}
{"id": "ftdSRj", "name": "Something  gaz 236", "author": "gaz", "description": "4d", "tags": ["4d"], "likes": 5, "viewed": 72, "published": "Public", "date": "1639408257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    for(float i=0.,g=0.,e,t=iTime;++i<99.;){\n        p=g*d;\n        p.z-=4.;\n        p=R(p,normalize(vec3(1,2,3)),t*1.2);\n        vec4 q=vec4(p,sin(t)*.7);\n        q.xyw=R(q.xyw,vec3(0,1,0),t);\n        g+=e=length(vec2(length(q.xy)-1.,length(q.wz)-1.5))-.3;\n        O.xyz+=mix(vec3(1),H(atan(q.y,q.x)),.7)*.012*exp(-i*i*e);\n    }\n    O*=O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 563]]}
{"id": "ftdSWH", "name": "Bricks-01", "author": "xlat", "description": "very simple", "tags": ["fragmentshader"], "likes": 1, "viewed": 23, "published": "Public", "date": "1639044291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///----------------------------------------------------------------------------|\n/// XLAT\n/// www.cyberforum.ru\n///----------------------------------------------------------------------------:\n\nconst vec3  GRAY = vec3(0.3, 0.3, 0.3);\nconst vec3  RED  = vec3(0.5, 0.0, 0.0);\n\nconst float W = 0.12; /// The length of the brick.\nconst float H = 0.06; /// Brick height.\nconst float S = 0.01; /// Seam thickness.\n\nbool is_seam(vec2 coord)\n{\n    if(mod(coord.y          , H + S) < S ) return true;\n    if(mod(coord.y / (H + S), 2.   ) < 1.) return mod(coord.x       , W + S) < S;\n                                           return mod(coord.x + W/2., W + S) < S;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy + vec2(iTime/40., 0.);\n\n    if(is_seam(uv)) fragColor = vec4(GRAY, 1.0);\n    else            fragColor = vec4(RED , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 409, 435, 435, 657], [659, 659, 716, 716, 879]]}
{"id": "ftdXD7", "name": "More abstract saturday", "author": "mrange", "description": "More abstract saturday\nInspired by: https://www.logomoose.com/featured/abstract-logo/", "tags": ["2d"], "likes": 18, "viewed": 132, "published": "Public API", "date": "1639245808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CCO: More abstract saturday\n\n// Inspired by: https://www.logomoose.com/featured/abstract-logo/\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0 - exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float aa = iz*2.0/RESOLUTION.y;\n  float  n = modPolar(p, 3.0);\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  \n  s1.z -= PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  return vec4(vec3(1.0)*s.x, s.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col  = vec3(1.0);\n  float d;\n  float a = TAU*TIME/240.0;\n  p += 10.0*vec2(sin(a), sin(sqrt(0.5)*a));\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  float hd = hex(hp.yx, 0.5);\n  hd = abs(hd) - 2.0*aa;\n  vec4 ccol = clogo(hp, 0.66, d);\n  col = mix(col, vec3(0.25), exp(-9.0*max(d+0.025, 0.0)));\n  col = mix(col, vec3(0.0), smoothstep(aa, -aa, hd));\n  col = mix(col, ccol.xyz, ccol.w);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 448, 468, 468, 488], [490, 588, 624, 624, 734], [736, 736, 767, 767, 793], [795, 913, 941, 941, 1125], [1127, 1228, 1256, 1355, 1682], [1684, 1684, 1708, 1708, 1807], [1809, 1809, 1839, 1839, 2077], [2079, 2165, 2214, 2214, 2616], [2618, 2618, 2651, 2651, 3189], [3191, 3191, 3229, 3229, 3501], [3503, 3503, 3523, 3523, 3551], [3553, 3553, 3595, 3595, 3951], [3953, 4040, 4076, 4120, 4391], [4393, 4393, 4448, 4448, 5026]]}
{"id": "ftdXR2", "name": "Black hole shader", "author": "TheNekaFugu", "description": "This is a real black hole color, few people know that the color of the accretion disk of a black hole is blue.", "tags": ["blackhole"], "likes": 5, "viewed": 129, "published": "Public", "date": "1639417113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// NekaFugu Black Hole sim/\n\nconst float pi = 3.14;\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = fragCoord.xy/iResolution.xy;\n\tpp = -1.0 + 3.0*pp;\n\tpp.x *= iResolution.x/iResolution.y;\n\n\tvec3 lookAt = vec3(0.0, -0.31, 0.0);\n    \n    float eyer = 3.0; \n    float eyea = (iMouse.x / iResolution.x) * pi * 2.0;\n    float eyea2 = ((iMouse.y / iResolution.y)-0.94) * pi * 4.0;\n    \n\tvec3 ro = vec3(\n        eyer * cos(eyea) * sin(eyea2),\n       eyer * cos(eyea2),\n        eyer * sin(eyea) * sin(eyea2));\n    \n    \n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.1)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd = normalize(front*1.5 + left*pp.x + up*pp.y); \n    \n    \n    vec3 bh = vec3(0.0,0.0,0.0);\n    float bhr = 0.1;\n    float bhmass = 4.0;\n   \tbhmass *= 0.001;\n    \n    vec3 p = ro;\n    vec3 pv = rd;\n    float dt = 0.02;\n    \n    vec3 col = vec3(0.0);\n    \n    float noncaptured = 1.0;\n    \n    vec3 c1 = vec3(0.5,0.46,2);\n    vec3 c2 = vec3(1.0,0.8,0.6);\n    \n    \n    for(float t=0.0;t<1.0;t+=0.005)\n    {\n        p += pv * dt * noncaptured;\n        vec3 bhv = bh - p;\n        float r = dot(bhv,bhv);\n        pv += normalize(bhv) * ((bhmass) / r);\n        \n        noncaptured = smoothstep(0.0, 0.666, sdSphere(p-bh,bhr));\n        float dr = length(bhv.xz);\n        float da = atan(bhv.x,bhv.z);\n        vec2 ra = vec2(dr,da * (0.01 + (dr - bhr)*0.005) + 5.0 * pi + iTime*2.0 );\n        ra *= vec2(10.0,10.0);\n        \n        vec3 dcol = mix(c2,c1,pow(length(bhv)-bhr,1.0)) * max(0.0,texture(iChannel1,ra*vec2(0.1,0.5)).r+0.05) * (4.0 / ((0.001+(length(bhv) - bhr)*50.0) ));\n        \n        col += max(vec3(0.0),dcol * smoothstep(0.0, 1.0, -sdTorus( (p * vec3(1.0,25.0,1.0)) - bh, vec2(0.9,0.99))) * noncaptured);\n\n        col += vec3(1.0,1,2) * (0.8/vec3(dot(bhv,bhv))) * 0.0033 * noncaptured;\n        \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdXR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 88, 88, 112], [114, 114, 156, 156, 255], [257, 257, 290, 290, 355], [357, 357, 414, 414, 2236]]}
{"id": "ftGGDV", "name": "Particle Wave II", "author": "ivatronx", "description": "Galaxy Particle Wave", "tags": ["galaxytrigonometry"], "likes": 1, "viewed": 33, "published": "Public", "date": "1638317288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932;\n\nfloat atanM(float y, float x){\n    if(x >= 0.){\n        return atan(y/x)/pi/2.+.75;\n    }\n    return (pi+2.*atan(y/x))/4./pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    int amount = 2;\n    float width = 2.5;\n    float speed = 0.05;\n    float speed2 = -0.075;\n    float speed3 = 0.10;\n    vec3 color1 = vec3(1.0, 1.5, 2.0);\n    vec3 color2 = vec3(-0.1, 0.0, 0.1);\n    vec3 color12 = vec3(1.0, 2.5, 2.0);\n    vec3 color22 = vec3(-0.11, 0.11, 0.11);\n    vec3 color13 = vec3(2.0, 2.5, 2.0);\n    vec3 color23 = vec3(-0.01, 0.01, 0.01);\n    \n\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col;\n    vec3 col2;\n    vec3 col3;\n    float d = length(uv);\n    float d2 = length(uv)/50.;\n    float d3 = length(uv)/75.0;\n    d -= iTime*speed;\n    d2 -= iTime*speed2;\n    d3 -= iTime*speed3;\n\n    float mascara = smoothstep(R.y/2.+width*4., R.y/2.-width*4., acos(tan(length(uv.x*30.) / length(uv.y/-30.))));\n    float mascara2 = smoothstep(R.y/2.+width*4., R.y/2.-width*4., (length(uv.x/8.) * length(uv.y/-8.)));\n    float mascara3 = smoothstep(R.y/2.+width*4., R.y/2.-width*4., (length(uv.x) + length(uv.y)));\n    \n    col = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d*width)*float(amount))+1.)/2.;\n    col2 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d2*width)*float(amount))+1.)/2.;\n    col3 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d3*width)*float(amount))+1.)/2.;\n    col = color1+col*(color2-color1);\n    col *= mascara2;\n    col2 = color23+col3*(color13-color23);\n    col2 *= mascara;\n    col3 = color22+col3*(color12-color22);\n    col3 *= mascara3;\n    fragColor = vec4(col-col2-col3,1.0);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 165], [167, 167, 224, 224, 1651]]}
{"id": "ftKGDt", "name": "pipe inside", "author": "4eckme", "description": "...", "tags": ["hole", "pipe", "noodles"], "likes": 4, "viewed": 66, "published": "Public", "date": "1638534895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 xy, float a) {\n  return vec2(xy.x*cos(a)-xy.y*sin(a),xy.x*sin(a)+xy.y*cos(a));\n}\nvoid mainImage( out vec4 c, in vec2 o )\n{\n    vec2 uv = o-iResolution.xy/2.0;\n    uv=rotate(uv,-iTime/4.0);\n    float R=sqrt(iResolution.x*iResolution.x+iResolution.y*iResolution.y);\n    float r=sqrt(uv.x*uv.x+uv.y*uv.y);float t = iTime;\n    float a = degrees(atan(uv.y,uv.x));\n    float cc = (mod(+float(iFrame)-r,12.0)+mod(a-r/8.0,12.0)-12.0);\n    vec4 color=vec4(cc>1.0);\n    //if (mod(a-r/8.0,72.0)<=12.0)color*=vec4(0,0,1,0);\n    //else if (mod(a-r/8.0,72.0)<=24.0) color*=vec4(0,1,0,0);\n    //else if (mod(a-r/8.0,72.0)<=36.0&&color.x+color.y+color.z>=0.0) color*=vec4(1,1,0,0);\n    //else if(mod(a-r/8.0,72.0)<=48.0) color*=vec4(1,0,0,0);\n    //else if(mod(a-r/8.0,72.0)<=60.0) color*=vec4(0,1,1,0);\n    //else if(mod(a-r/8.0,72.0)<=72.0) color*=vec4(1,0,1,0);\n    c = color*float(r/iResolution.y*2.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 97], [98, 98, 139, 139, 910]]}
{"id": "ftKGW3", "name": "Standing Wave", "author": "Spi3lot", "description": "Standing Wave", "tags": ["wave", "sine", "standing"], "likes": 2, "viewed": 29, "published": "Public", "date": "1638467502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEP false\n#define ADD false\n#define FREQ 12.5663706144\n\nfloat normalizedSin(float x)\n{\n    return 0.5 * (1.0 + sin(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sin1 = normalizedSin(FREQ * (iTime + uv.x));\n    float sin2 = normalizedSin(FREQ * (-iTime + uv.x));\n    \n    vec3 col = vec3(\n        STEP ? ( \n            ADD ?\n                step(0.5 * (sin1 + sin2), uv.y) :\n                sin1 < sin2 ?\n                    smoothstep(sin1, sin2, uv.y) :\n                    smoothstep(sin2, sin1, uv.y)\n        ) : step(0.1, abs(uv.y - 0.5 * (sin1 + sin2)))\n    );\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 95, 95, 130], [132, 132, 189, 189, 684]]}
{"id": "ftKGWK", "name": "logistic map prng", "author": "callistabee", "description": "simple dynamic prng based on the logistic map\n(https://en.wikipedia.org/wiki/Logistic_map)\n\nplay around with the seed to get different images but don't set it too high or low\nalso feel free to play around with the n map", "tags": ["chaos", "prng", "logisticmap"], "likes": 1, "viewed": 41, "published": "Public", "date": "1638348864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// analytic solution to the logistic map for r=4\n// https://en.wikipedia.org/wiki/Logistic_map#Solution_when_r_=_4\nfloat logisticR4(float n, float theta) {\n    return pow(sin(pow(2.0, n) * theta * radians(180.0)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // transform to viewport coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // put a nice number here but don't make it too small or too big \n    float seed = 11.3;\n    \n    // put your fav (x,y) -> n function here\n    float n = pow(sin(uv.x), sin(uv.y));\n\n    // compute logistic map at current position and time\n    float v = logisticR4(n, exp(seed)+iTime);\n\n    // render\n    fragColor = vec4(v,v,v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 155, 155, 221], [223, 223, 280, 324, 705]]}
{"id": "fttSR8", "name": "Forkscape", "author": "dr2", "description": "Hills covered with bending reflective forks (why?)", "tags": ["reflection", "landscape", "fork"], "likes": 13, "viewed": 179, "published": "Public API", "date": "1638703203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Forkscape\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nstruct Arc {\n  vec2 cs;\n  float chDist, rad, ang;\n};\nArc arcc[3];\n\nstruct GrStat {\n  vec3 rPos;\n  float sAng, fSize;\n  Arc arc;\n};\nGrStat gst;\n\nvec4 dateCur;\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, hgSize;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.732051;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{ // (from \"Desert Reflections 2\")\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nfloat GrndHtN (vec2 p)\n{\n  return GrndHt (p) + 0.04 * Fbm2 (8. * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHtN (p.xz) - vec2 (GrndHtN (p.xz + e.xy),\n     GrndHtN (p.xz + e.yx)), e.x)).xzy;\n}\n\nvoid SetGrdConf ()\n{\n  vec4 h;\n  vec2 p;\n  int j;\n  p = HexToPix (gId * hgSize);\n  h = Hashv4v2 (17.1 * gId + 0.3);\n  gst.rPos.xz = 0.2 * hgSize * sin (2. * pi * h.x + vec2 (0.5 * pi, 0.));\n  gst.rPos.y = GrndHt (HexToPix (gId * hgSize) + gst.rPos.xz);\n  gst.sAng = 0.1 * (h.z - 0.5) * tCur;\n  j = int (mod (2. * gId + gId.yx, 3.));\n  if (j == 0) gst.arc = arcc[0];\n  else if (j == 1) gst.arc = arcc[1];\n  else gst.arc = arcc[2];\n  gst.fSize = 0.8 + 0.2 * h.w;\n  if (abs (p.x) < 0.5 * sqrt3 * hgSize || h.y < 0.2) gst.fSize = 0.;\n}\n\n#define F(x) (sin (x) / x - b)\n\nfloat SecSolve (float b)\n{  // (from \"Bucking Bronco\")\n  vec3 t;\n  vec2 f;\n  float x;\n  if (b < 0.95) {\n    t.yz = vec2 (0.7, 1.2);\n    f = vec2 (F(t.y), F(t.z));\n    for (int nIt = 0; nIt < 4; nIt ++) {\n      t.x = (t.z * f.x - t.y * f.y) / (f.x - f.y);\n      t.zy = t.yx;\n      f = vec2 (F(t.x), f.x);\n    }\n    x = t.x;\n  } else if (b < 1.) {\n    x = sqrt (10. * (1. - sqrt (1. - 1.2 * (1. - b))));\n  } else {\n    x = 0.;\n  }\n  return x;\n}\n\nvoid ArcConf ()\n{\n  float segRot, chLen;\n  for (int k = 0; k < 3; k ++) {\n    segRot = 0.99 * pi * (0.5 + 0.5 * sin ((1. + 0.1 * float (k)) * 0.5 * tCur));\n    chLen = length (vec2 (2. * sin (0.5 * segRot), 1.));\n    arcc[k].ang = max (1e-4, SecSolve (chLen / sqrt(5.)));\n    arcc[k].chDist = chLen / tan (arcc[k].ang);\n    arcc[k].rad = sqrt (arcc[k].chDist * arcc[k].chDist + chLen * chLen);\n    arcc[k].cs = sin (- arcc[k].ang + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rr, sk, bLen[2];\n  dMin = dstFar;\n  if (gst.fSize > 0.) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= gst.rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.5, 2.);\n    DMINQ (1);\n    p.y -= 1.;\n    dMin /= gst.fSize;\n    p /= gst.fSize;\n    bLen[0] = 1.;\n    bLen[1] = 1.;\n    rr = gst.arc.rad * gst.arc.cs.y;\n    p.y -= 1.;\n    p.xz = Rot2D (p.xz, gst.sAng);\n    p.xy = vec2 (- p.y, p.x) - vec2 (1.5 * rr - bLen[1], gst.arc.chDist - gst.arc.rad);\n    for (int k = 0; k < 2; k ++) {\n      sk = sign (float (k) - 0.5);\n      q = p;\n      q.y *= - sk;\n      q.xy -= vec2 (rr * (sk - 0.5), - gst.arc.chDist);\n      d = max (max (PrRoundBox2Df (vec2 (length (q.xy) - gst.arc.rad, abs (q.z) - 0.27),\n         vec2 (0., 0.18), 0.07), dot (vec2 (abs (q.x), q.y), gst.arc.cs)), - sk * q.x);\n      DMINQ (2);\n      q.xy -= vec2 (- bLen[k] * sk, gst.arc.rad);\n      d = PrRoundBoxDf (vec3 (q.xy, abs (q.z) - 0.27), vec3 (bLen[k], 0., 0.18), 0.07);\n      if (k == 1) d = SmoothMax (SmoothMin (d, PrRoundBoxDf (q - vec3 (-0.1 * bLen[1], 0., 0.),\n         vec3 (0.9 * bLen[1], 0.05, 0.5), 0.05), 0.1), - max (PrCaps2Df (vec2 (mod (q.z + 0.15, 0.3) -\n         0.15, q.x + 0.5), 0.08, 1.), abs (q.z) - 0.5), 0.03);\n      else d = SmoothMin (d, PrRoundBoxDf (q - vec3 (0.1 * bLen[0], 0., 0.),\n         vec3 (0.9 * bLen[0], 0.05, 0.6), 0.1), 0.1);\n      DMINQ (2);\n    }\n    dMin *= gst.fSize;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.01;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.4, 0.4, 0.7), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dFac, dMin, f, sh;\n  bool isRef;\n  ArcConf ();\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  isRef = false;\n  if (dstObj < min (dstGrnd, dstFar) && idObj == 2) {\n    isRef = true;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n  }\n  dMin = min (dstObj, dstGrnd);\n  if (dMin < dstFar) {\n    dFac = 1. - smoothstep (0.35, 0.5, dMin / dstFar);\n    ro += dMin * rd;\n    if (dstObj < dstGrnd) {\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        vn = VaryNf (8. * qHit, vn, 4. * dFac);\n        col = vec3 (0.8);\n      } else if (idObj == 2) {\n        col = vec3 (0.8, 0.8, 1.);\n      }\n      col *= 0.7 + 0.3 * dFac;\n    } else {\n      vn = GrndNf (ro);\n      col = 0.9 * mix (vec3 (0.7, 0.9, 0.5), vec3 (0.8, 1., 0.5), smoothstep (3., 4., ro.y)) *\n         (1. - 0.3 * dFac * Fbm2 (2. * ro.xz));\n      if (dFac > 0.) {\n        gId = PixToHex (ro.xz / hgSize);\n        SetGrdConf ();\n        if (gst.fSize > 0.) col *= 0.8 + 0.2 * smoothstep (0.5, 0.8, length (ro.xz -\n           HexToPix (gId * hgSize) - gst.rPos.xz));\n      }\n    }\n    sh = 1. - 0.5 * smoothstep (0.3, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.)));\n    col *= 0.2 + 0.1 * max (0., vn.y) + 0.7 * sh * max (0., dot (vn, sunDir));\n    if (isRef) col = vec3 (1., 0.9, 0.8) * mix (col, vec3 (1.), 0.1);\n    col = mix (col, SkyBg (rd), pow (dMin / dstFar, 4.));\n  } else if (rd.y < 0.) {\n    col = SkyBg (rd);\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, t, hSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 10., 2400.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.01 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.2 * pi * sin (0.03 * pi * tCur);\n  }\n  hgSize = 8.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  hSum = 0.;\n  for (float k = 0.; k < 5.; k ++) hSum += GrndHt (vec2 (0., t + 0.7 * (k - 1.)));\n  ro = vec3 (0.1, 4. * gr.hFac + hSum / 5., t);\n  sunDir = normalize (vec3 (-1., 1., -1.));\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec4 (0., cHashVA2.xy, cHashVA2.x + cHashVA2.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttSR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1111, 1134, 1167, 1423], [1425, 1425, 1459, 1459, 1939], [1941, 1941, 1965, 1965, 2014], [2016, 2016, 2038, 2038, 2185], [2187, 2187, 2207, 2207, 2718], [2752, 2752, 2778, 2806, 3194], [3196, 3196, 3213, 3213, 3655], [3657, 3657, 3679, 3679, 5115], [5117, 5117, 5150, 5150, 6324], [6326, 6326, 6347, 6347, 6602], [6604, 6604, 6626, 6626, 6739], [6741, 6741, 6773, 6773, 7103], [7105, 7105, 7140, 7140, 8781], [8783, 8783, 8839, 8839, 9792], [9794, 9794, 9836, 9836, 9887], [9889, 9889, 9935, 9935, 9982], [9984, 9984, 10031, 10031, 10078], [10080, 10080, 10124, 10124, 10184], [10186, 10186, 10210, 10210, 10440], [10442, 10442, 10466, 10466, 10526], [10528, 10528, 10573, 10573, 10665], [10667, 10667, 10712, 10712, 10750], [10752, 10752, 10774, 10774, 10812], [10814, 10814, 10844, 10844, 10957], [10959, 10959, 10995, 10995, 11201], [11235, 11235, 11259, 11259, 11371], [11373, 11373, 11397, 11397, 11534], [11536, 11536, 11561, 11561, 11747], [11749, 11749, 11770, 11770, 11925], [11927, 11927, 11956, 11956, 12168], [12170, 12170, 12209, 12209, 12461]]}
{"id": "Nd3SDH", "name": "spiral spiral", "author": "HaleyHalcyon", "description": "a", "tags": ["spiral"], "likes": 5, "viewed": 71, "published": "Public", "date": "1638334436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define SCALE_ANGLE 12.\n#define SCALE_DIST 1.\n#define TILE_X 0.\n#define TILE_Y 1.\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\nfloat spiral(float x) {\n    return step( 0.5, 1. - abs(1. - 2. * fract(x)));\n}\n\nvec3 colorize(float x) {\n    return mix(\n        HEX(0xc02030),\n        mix(\n            HEX(0xffd010),\n            mix(\n                HEX(0x30a040),\n                HEX(0x2060a0),\n                step(0.75, x)\n            ),\n            step(0.5, x)\n        ),\n        step(0.25, x)\n    );\n}\n\nvec2 rotate(vec2 uv, float rotateBy) {\n    return vec2(\n        uv.x * cos(rotateBy) + uv.y * sin(rotateBy),\n        -uv.x * sin(rotateBy) + uv.y * cos(rotateBy)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 2.0);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // use log distance for perspective/tunnel effect\n    float dist = log(uv.x * uv.x + uv.y * uv.y);\n    float angle = atan(uv.y, uv.x) / TAU;\n    \n    // arrow texture\n    float distS = dist * SCALE_DIST + 0.1 * cos(time * TAU);\n    float distSign = sign(mod(distS, 2.) - 1.);\n    vec2 uv_ = fract(vec2(\n        distS,\n        angle * SCALE_ANGLE + time * 3. * distSign\n    )) - 0.5;\n    \n    float smallDist = log(uv_.x*uv_.x+uv_.y*uv_.y);\n    float smallSpirals = spiral(\n        time * 3. * distSign +\n        smallDist * 0.5 +\n        (atan(uv_.y, uv_.x) / TAU) * -1.\n    );\n    \n    // spiral\n    float spiral = fract(\n        time * 1. +\n        cos(-time * TAU + 1.1) * 0.02 +\n        dist * 0.2 +\n        angle * 1.\n    );\n    \n    // blend\n    vec3 col = colorize(spiral) * (0.5 + 0.8 * smallSpirals);\n    col *= step(smallDist, -1.5);\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3SDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 203, 203, 258], [260, 260, 284, 284, 554], [556, 556, 594, 594, 726], [728, 728, 785, 813, 1886]]}
{"id": "Nl3XD4", "name": "Fork tv noise tshepang 009", "author": "tshepang", "description": "tv noise shader with chromatic aberration\n\n\n\n", "tags": ["noise", "tv", "shader"], "likes": 1, "viewed": 66, "published": "Public API", "date": "1639078322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define noiselevel 0.4\n#define rgbshiftlevel 0.01\n#define ghostreflectionlevel 0.03\n#define bypass false\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float randomValue = rand(vec2(uv.x+sin(iTime), uv.y+cos(iTime)));\n    float rgbShift = sin(iTime+randomValue)*rgbshiftlevel;\n    \n    if(randomValue > 0.95-ghostreflectionlevel)\n    \tuv.x+=sin(iTime/5.0)*0.5;\n   \n    uv.y += (cos(iTime*randomValue)+0.5) * (randomValue*0.01);\n    \n    float colorr = texture(iChannel0, vec2(uv.x+rgbShift, uv.y)).r;\n    float colorg = texture(iChannel0, vec2(uv.x, uv.y)).g;\n    float colorb = texture(iChannel0, vec2(uv.x-rgbShift, uv.y)).b;\n    \n  \tvec4 movieColor = vec4(colorr,colorg,colorb, 1.0);\n    vec4 noiseColor = vec4(randomValue,randomValue,randomValue,1.0);\n \n    if(randomValue > 0.55-ghostreflectionlevel)\n    \tnoiseColor = abs(noiseColor - 0.2);\n \n    if(bypass)\n        fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy); \n    else\n      \tfragColor = mix(movieColor, noiseColor, noiselevel);  \n    \n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 127, 127, 199], [201, 201, 258, 258, 1173]]}
{"id": "Nl3XD8", "name": "2.5D sphere 2", "author": "SnoopethDuckDuck", "description": "bit of a mess,\nbasically cut out 1 section of equation from here:\nhttps://math.stackexchange.com/questions/1353065/function-that-graphs-repeating-upper-halves-of-circles\n...then copy + paste + rotated a few times", "tags": ["e"], "likes": 13, "viewed": 172, "published": "Public API", "date": "1638984225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvec2 rot(vec2 uv, float a) {\n    //float s = 2. + cos(a + iTime);\n    //mat2 m = mat2(thc(s,a), ths(s,a), -ths(s,a), thc(s,a));\n\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return m * uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv2 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float r = 0.3;\n    float s = 0.;\n    \n    // not consistently using this (given up on keeping things tidy)\n    float time = 0.3 * iTime;\n       \n    for (float i = 0.; i<20.; i++ ) {\n        float n = i / 8. * pi ;\n        vec2 uv = rot(uv2, i * 10. + iTime * (0.1 + i / 40.));\n        \n        //--\n        vec2 p = vec2(r * cos(iTime) * cos(4. * uv.y), 0.);\n\n        float k = 0.5 * thc(1., iTime) + 3.;\n   \n\n        float y = k * uv.y;\n    \n        float m = 0.08;\n        float se = smoothstep(-m, m, 1. - y) * smoothstep(-m, m, y + 1.);\n        //--\n        \n        \n        // circle equation\n        float a = mod(y + 1., 2.) - 1.;  \n        float b = pow(a, 2.);\n        float c = cos(n + time) * sqrt(1. - b);\n        float c2 = cos(pi + n + time) * sqrt(1. - b);\n\n        float d = abs(uv.x - 1./k * c);//abs(uv.x - 0.4 * cos(iTime) * cos(10. * uv.y));\n        float d2 = abs(uv.x - 1./k * c2);\n   \n       \n        float k2 = 0.4 + 0.4 * thc(2., 0.1 * i + 4. * uv.y + time);\n        \n        k2 = 0.4 + 4. * pow(cos(10. * i + uv.y - time), 11.);\n        k2 *= 0.2;//0.3 + 0.1 * cos(time + 10. * i);\n       \n        float s1 = smoothstep(-k2, k2,        \n        -d + 0.012 * (1. - 0.5 * thc(4., 20. * uv.y - 10. * n - 8. * time)) );\n        s1 -= smoothstep(-0.01,0.01, -d + 0.005 * (1. - 0.5 * thc(4., 20. * uv.y - 10. * n - 8. * time)) );\n        s1 *= 3. * s1 * s1 * se;\n          \n        float s2 = smoothstep(-k2, k2,        \n        -d2 + 0.012 * (1. - 0.5 * thc(4., 20. * uv.y - 10. *  n - 8. * time)));\n        s2 -= smoothstep(-0.01,0.01, -d2 + 0.005 * (1. - 0.5 * thc(4., 20. * uv.y - 10. *  n - 8. * time)));\n        s2 *= 3. * s2 * s2 * se; // 3. * s1 * s2 * se;\n        \n        s += (s1 + s2) * 0.5 * (1. + thc(4., i + 4. * time));\n    }\n    \n    s = clamp(s, 0., 1.);\n    vec3 col = vec3(s);\n    col += .25 * s * pal(2. * s + 0.1 * iTime, vec3(1.), vec3(1.), vec3(1.), 0.5 * vec3(0.,0.33,0.66));\n    col += vec3(0.025,0.,0.05);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 608, 707, 781], [783, 783, 840, 840, 2918]]}
{"id": "Nl3XRB", "name": "TDF2021 ShaderShowdown Semifinal", "author": "phi16", "description": "2\n\nsorry for too heavy shader\n\n[url]https://youtu.be/bp37xTVNRrM?t=8428[/url]", "tags": ["shadershowdown"], "likes": 19, "viewed": 421, "published": "Public", "date": "1639299510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LOOP 40\n// original is 100\n\n#define LOOP2 2\n// original is 8\n\nfloat time = 0.;\n\nfloat rand(vec2 p) {\n  return fract(sin(dot(p,vec2(1,1.001)))*10000.);\n}\n\nvec3 trace(float x, out vec3 t) {\n  int u = int(floor(x));\n  float f = fract(x);\n  vec3 o0 = vec3(rand(vec2(u+0,0))-0.5, rand(vec2(u+0,1))-0.5, u+0) * vec3(40,20,60);\n  vec3 t0 = vec3(rand(vec2(u+0,2))-0.5, rand(vec2(u+0,3))-0.5, 1) * vec3(40,40,15)* 8.;\n  vec3 o1 = vec3(rand(vec2(u+1,0))-0.5, rand(vec2(u+1,1))-0.5, u+1) * vec3(40,20,60);\n  vec3 t1 = vec3(rand(vec2(u+1,2))-0.5, rand(vec2(u+1,3))-0.5, 1) * vec3(40,40,15) * 8.;\n  vec3 o = mix(o0,o1,6.*pow(f,5.) - 15.*pow(f,4.) + 10.*pow(f,3.));\n  o += t0 * pow(1.-f,3.) * f;\n  o -= t1 * pow(f,3.) * (1.-f);\n  t = (o1-o0) * (30.*pow(f,4.) - 60.*pow(f,3.) + 30.*pow(f,2.));\n  t += t0 * (-3.*pow(1.-f,2.) * f + pow(1.-f,3.));\n  t -= t1 * (3.*pow(f,2.)*(1.-f) - pow(f,3.));\n  return o;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b) {\n  vec3 pa=p-a,ba=b-a;\n  float h = clamp(dot(pa, ba)/dot(ba,ba),0.,1.);\n  return length(pa-ba*h);\n}\n\nfloat map(vec3 o) {\n  float x = floor(time*4.)/4.;\n  vec3 T;\n  vec3 p = trace(x,T);\n  for(int i=-1;i<LOOP2;i++) {\n    x += 1./4.;\n    vec3 q = trace(x,T);\n    if(capsule(o,p,q) < rand(vec2(x,0)) * 4. + 1.5) return 0.;\n    p = q;\n  }\n  if(rand(o.xz) < 0.1 || rand(o.xy) < 0.01 || rand(o.yz) < 0.01) return 1.;\n  return 0.;\n}\n\n\nfloat vao(vec2 s, float c) {\n  return (s.x+s.y+max(c,s.x*s.y))/3.;\n}\n\nfloat ao(vec3 ii, vec3 ir, vec3 tw) {\n  vec3 tu = tw.yzx;\n  vec3 tv = tw.zxy;\n  vec4 s = vec4(map(ii-tu),map(ii-tv),map(ii+tu),map(ii+tv));\n\n  vec4 c = vec4(map(ii-tu-tv),map(ii-tu+tv),map(ii+tu-tv),map(ii+tu+tv));\n  float v = mix(mix(vao(s.xy, c.x),vao(s.xw, c.y),dot(ir,tv)+0.5),\n  mix(vao(s.zy, c.z),vao(s.zw, c.w),dot(ir,tv)+0.5),dot(ir,tu)+0.5);\n  return 1.-pow(v,2.)*0.5;\n  \n}\nbool castf(vec3 o, vec3 d, out vec3 ii, out vec3 ir, out vec3 tw) {\n  vec3 u = floor(o);\n  vec3 s = sign(d);\n  d = abs(d);\n  vec3 r = (o-u-0.5)*s+0.5;\n  for(int i=0;i<LOOP;i++) {\n    if(map(u) > 0.5) {\n      ii = u;\n      ir = (r-0.5)*s;\n      return true;\n    }\n    vec3 l = (1.-r)/d;\n    vec3 m = step(l,l.yzx) * step(l,l.zxy);\n    tw = -s*m;\n    r += d*length(l*m) - m;\n    u += m*s;\n  }\n  return false;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\ntime = iTime*160./120.;\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y /iResolution.x, 1);\ntime +=( rand(uv*1000.+time)*0.01 + fract(fragCoord.x/2.) * 0.04 + fract(fragCoord.y/2.) * 0.02) *0.5;\n  vec3 c = vec3(0);\n  \n  vec3 T;\n  vec3 o = trace(time,T);\n  vec3 d = vec3(uv,1.+dot(uv,uv)*0.5);\n  trace(time+0.1,T);\n  T = normalize(T);\n  vec3 B = normalize(cross(T,vec3(0,1,0)));\n  vec3 N = cross(B,T);\n  d = d.x*B + d.y*N + d.z*T;\n  vec3 ii,ir,tw;\n  if(castf(o,d,ii,ir,tw) || true) {\n    vec3 pos = ii+ir+0.5;\n    vec3 normal = sign(ir)*normalize(pow(abs(ir),vec3(10)));\n    c = vec3(1);\n    c *= ao(ii+tw,ir,tw);\n    c  *= exp(-pow(distance(pos,o),2.)*0.001);\n    \n    vec3 pl = trace(time+0.4, T);\n    vec3 sd = normalize(pl-pos);\n    float ra = max(0.,dot(normal, sd)) / pow(distance(pl,pos), 0.5);\n    castf(pos-d*0.01, sd, ii,ir,tw);\n    if(distance(pos,ii+ir+0.5) < distance(pl,pos)) ra *= 0.0;\n    \n    if(distance(o,pl) < distance(o,pos)) ra += 0.1 / distance(pl, o+dot(pl-o,d)*d) * 9.;\n    \n    pl = trace(time+0.15 + (cos(time*3.1415926535)*0.5+0.5)*0.2, T);\n    sd = normalize(pl-pos);\n    float ga = max(0.,dot(normal, sd)) / pow(distance(pl,pos), 0.2);\n    if(distance(pos,ii+ir+0.5) < distance(pl,pos)) ga *= 0.0;\n    ga *= cos(ii.z+ir.z+0.5)*0.5+0.5;\n    if(distance(o,pl) < distance(o,pos)) ga += 0.1 / distance(pl, o+dot(pl-o,d)*d) * 2.;\n    \n    float rim = pow(1.-max(0.,dot(normal,normalize(o-pos))), 2.);\n   c *= (ga*vec3(1,0,0.5) + ra*vec3(0,0.5,1)+rim*vec3(0.5,0.25,0.75)*0.1) * 8.;\n  }\n  \n // now I have completed all things I prepared beforreeeee\n  \n   // what should i do\n  c *=cos(dot(uv,uv));\n\tfragColor = vec4(c,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 88, 108, 108, 160], [162, 162, 195, 195, 898], [900, 900, 939, 939, 1038], [1040, 1040, 1059, 1059, 1363], [1366, 1366, 1394, 1394, 1434], [1436, 1436, 1473, 1473, 1818], [1819, 1819, 1886, 1886, 2230], [2233, 2233, 2290, 2290, 4001]]}
{"id": "Nl3XRr", "name": "Green ball", "author": "makipl", "description": "Random playing", "tags": ["raymarching"], "likes": 1, "viewed": 87, "published": "Public API", "date": "1638568524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ray(in vec3 ro, in vec3 rd)\n{\n//float e=0.0000001;\n//h=0.2-rd.y; //plane\n\nfloat t=0.0;\nfloat h=0.;\nfor(int i=0; i<32; i++)\n{\nh=length(ro+rd*t)-0.70;\nh=max(h, -h+cos((ro+rd*t).y*64.)*+sin((ro+rd*t).x*128.)*sin(iTime));\nif(abs(h)<(0.005))\n{ return t;}\nt+=h;\n}\nreturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (16.0*fragCoord.xy +iResolution.xy)/iResolution.y;\n\n    \n    \n    float col =1.0;\n    \n    \n    //uv.v = 1.0-uv.v;\n    \n    uv = (2.0*fragCoord.xy -iResolution.xy)/iResolution.y;\n    vec3 ta = vec3(0.51,1.00,0.0);\n    vec3 ro = vec3(0.0,0,-1.3);\n    \n    vec3 rd = normalize(vec3(uv,2.));\n    \n    \n    \n    vec3 ot = vec3(0.0);\n    float h = ray(ro,rd);\n    ot=mix(vec3(sin(h)),vec3(cos(h),sin(h),cos(h)),h);\n\n    fragColor = vec4(ot.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3XRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 78, 277], [279, 279, 336, 336, 793]]}
{"id": "NlcSR7", "name": "copy_star", "author": "pc6270", "description": "star from https://www.shadertoy.com/view/4tyfWy", "tags": ["star"], "likes": 8, "viewed": 146, "published": "Public API", "date": "1638820142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n    fragColor = vec4(cheap_star(uv,anim) * vec3(0.35,0.2,0.15), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 185], [187, 187, 244, 244, 511]]}
{"id": "NlcSRB", "name": "Mandala flowers", "author": "mrange", "description": "CCO: Mandala flowers\nSmoooth kaleidoscope + abstract shape + colors\n", "tags": ["2s", "mandala"], "likes": 20, "viewed": 201, "published": "Public API", "date": "1639299234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CCO: Mandala flowers\n//  Smoooth kaleidoscope + abstract shape + colors\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract (sin(a)*43758.5453123);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0-exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float aa = iz*2.0/RESOLUTION.y;\n  float  n = modPolar(p, 3.0);\n\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  s1.z += -PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  vec3 hsv = vec3(fract(s.z/PI+TIME*0.5), 0.9, 1.0);\n  return vec4(hsv2rgb(hsv)*s.x, s.y);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n\n  float d;\n  float a = TAU*TIME/300.0;\n  p += 10.0*vec2(sin(a), sin(sqrt(0.5)*a));\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  float hd = hex(hp.yx, 0.5);\n  hd = abs(hd) - 2.0*aa;\n  vec2 cp = hp;\n  float h = hash(np);\n  float hh = fract(137.0*h);\n  float sm = mix(mix(0.025, 0.25, hh), 0.025, h);\n  float rep = 2.0*floor(mix(8.0, 30.0, h));\n  float cn = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(TIME*0.2+TAU*h);\n  \n  vec4 ccol = clogo(cp, 0.6, d);\n  vec3 gcol = hsv2rgb(vec3(h, 0.8, 4.0));\n  vec3 col  = vec3(0.0);\n  col += gcol*exp(-50.0*max(d, 0.0));\n  col = mix(col, vec3(0.2), smoothstep(aa, -aa, hd));\n  col = mix(col, ccol.xyz, ccol.w);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 352, 372, 372, 455], [457, 609, 631, 631, 777], [778, 1205, 1225, 1225, 1245], [1247, 1345, 1381, 1381, 1491], [1493, 1493, 1524, 1524, 1550], [1552, 1670, 1698, 1698, 1882], [1884, 1985, 2013, 2112, 2439], [2441, 2527, 2576, 2576, 2978], [2980, 3067, 3103, 3147, 3418], [3420, 3520, 3559, 3559, 3644], [3646, 3734, 3773, 3773, 3802], [3804, 3892, 3922, 3922, 3949], [3951, 4037, 4082, 4082, 4236], [4238, 4326, 4348, 4348, 4392], [4394, 4482, 4503, 4503, 4548], [4550, 4638, 4699, 4699, 4912], [4914, 4914, 4938, 4938, 5037], [5039, 5039, 5069, 5069, 5305], [5307, 5307, 5340, 5340, 5878], [5880, 5880, 5918, 5918, 6190], [6192, 6192, 6212, 6212, 6240], [6242, 6242, 6284, 6284, 6695], [6697, 6697, 6726, 6726, 7419], [7421, 7421, 7476, 7476, 7665]]}
{"id": "NlcSRj", "name": "Mouse Offset Mandelbrot", "author": "JennySchub", "description": "this was originially made as a phone wallpaper (instead of mouse position, it uses the gyroscope)", "tags": ["fractal", "mouse", "mandelbrot"], "likes": 13, "viewed": 197, "published": "Public API", "date": "1639372153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n#define AA 2.\n\nvec3 colMap(float v) {\n v=mod(v, PI+1.3)-.8;\n return vec3(\n  sin(sin(v-.6)),\n  sin(sin(v)),\n  sin(sin(v+.8))\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float aaFract = 1./AA;\n  for(float aa=0.; aa<1.; aa+=aaFract){\n      for(float bb=0.; bb<1.; bb+=aaFract){\n          vec2 uv =  ( (fragCoord.yx + vec2(aa,bb) ) -.5* iResolution.yx ) / iResolution.x;\n          uv*=(-cos(iTime*.1)+1.3)*.28;\n          uv+=vec2(.1,.65);\n\n          vec2 c =uv;\n          vec2 z=c;\n          float l=0.;\n          float sum=length(z);\n          vec2 newZ;\n          for(int i=0;i<40;i++){\n           c+=(iMouse.yx/iResolution.yx  -.5)*-.01*float(i);\n            newZ=vec2(-z.y*z.y+z.x*z.x, 2.*z.x*z.y)+c;\n            sum+=length(newZ-z);\n            z=newZ;\n            l=length(z);\n            if(l>2.) break;\n          }\n          vec2 dir=z-c;\n          vec3 col = vec3(dir, .0);\n\n          uv.x=mod((atan(dir.y,dir.x)/PI*.5+.5)*6.+(iTime+sin(iTime)*.9)*4., 1.);\n          uv.y=mod(length(dir*.5),1.);\n\n          col=colMap(sum*.2-l*.1+iTime*.1).gbr;\n\n          fragColor += vec4(col.grb, 1.0) * aaFract*aaFract;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 60, 60, 153], [155, 155, 212, 212, 1176]]}
{"id": "NlcSRl", "name": "Non-primitive Bravais Transition", "author": "crowemagnon", "description": "An animated non-primitive bravais lattice showing a transition from a square to a hexagon", "tags": ["nonprimitivebravaislattice"], "likes": 5, "viewed": 90, "published": "Public", "date": "1639542277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PERIOD 16.\n\n// Line function taken from our lord and savior IQ\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/(dot(ba,ba)),0.0, 1.0);\n    return pa-ba*h;\n}\nfloat sdLineLength( in vec2 p, in vec2 a, in vec2 b)\n{\n    return length(sdLine(p,a,b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float pi_time = iTime*2.*PI/10.0;\n\n\n    // This turns our square lattice to a hexagonal lattice\n    float x0 =  0.25 + 0.25/2. + 0.5*0.2499*max(-1., min(1., 3.0*sin(4.*pi_time)));\n    // float x1 = 0.75 - 0.2499*sin(4.*pi_time);\n    float x1 = 1.0 - x0;\n\n    /* If I were going strictly bravais motivated here, only x0 would be necessary.\n     * \"i\"  -> \"invariant\" to say these points are static, not parametized\n     * The idea here is to take the rhombus lattice (a bravais lattice) and turn it \n     * to a hexagonal lattice (non bravais)\n     */ \n    vec2 r0 = vec2(x0, 0.5);\n    vec2 r0_i = vec2(0.0, 0.5);\n    vec2 r1 = vec2(x1, 0.0);\n    vec2 r1_i = vec2(1.0, 0.0);\n    vec2 r2 = vec2(x1, 1.0);\n    vec2 r2_i = vec2(1.0, 1.0);\n\n    // Capture frag coord into convenient UV variable, transform!\n    float zoom = (1.0 - 0.07*pow(sin(pi_time), 2.));\n    float aspect = iResolution.x/iResolution.y;\n    vec2 drift = vec2(iTime*0.0001, 0.1*sin(pi_time));\n    vec2 uv = zoom\n        *PERIOD*(fragCoord.xy/iResolution.xy - 0.5 + drift);\n\n    uv.x*=aspect;\n\n    // Index and fract feed into each other - index is used to know if this is odd or even\n    // and whether the cell should be offset or not\n    // First, find out if we should be offset or not\n    vec2 indexUVProto = floor(uv);\n    vec2 columnOffset = + vec2(0., mod(indexUVProto,2.0)/2.0);\n\n    vec2 indexUV = floor(uv + columnOffset);\n    vec2 fractUV = fract(uv + columnOffset); \n\n\n    // Correct indexUV accounting for which cell we're in. By far the most finicky part\n    // first calclute shortest vector to line\n    // \"bottom\" line\n    vec2 sd_1 = sdLine(fractUV , r0, r1);\n    // \"top\" line\n    vec2 sd_2 = sdLine(fractUV , r0, r2);\n\n\n    /* Make some \"debug colors\" so that we can see which area we're tageting\n     */\n\n    // black out the area we want to target\n    float sd_1_debug_intensity = 1.0 - max(\n        // First line, give angled section\n        0.5 + 0.5*sign(sd_1.x),\n        // Sign of sd_2, gives halfway point\n        0.5 + 0.5*sign(sd_2.y)\n    );\n    vec3 sd_1_debug_color = vec3(\n        sd_1_debug_intensity\n    );\n\n    // black out the area we want to target\n    float sd_2_debug_intensity = 1.0 - max(\n        // First line, give angled section\n        0.5 + 0.5*sign(sd_2.x),\n        // Sign of sd_2, gives halfway point\n        0.5 + 0.5*sign(-sd_1.y)\n    );\n    vec3 sd_2_debug_color = vec3(\n        sd_2_debug_intensity\n    );\n\n    // Reduce index by one if we're \"to the left\"\n    indexUV.x -= max(sd_1_debug_intensity, sd_2_debug_intensity);\n    // Up in y if we're \"to the left above\"\n    indexUV.y += sd_2_debug_intensity * (0.5 - 0.5*sign(columnOffset.y - 0.25));\n    // Down in y if we're \"to the left below\"\n    indexUV.y -= sd_1_debug_intensity * (0.5 + 0.5*sign(columnOffset.y - 0.25));\n\n    /* We draw the cell walls with the shortest distance function of the point\n     * to the line which is finally put into the smoothstep function\n     */\n\n    // 2 angled lines\n    float intensity = min(sdLineLength(fractUV, r0, r1) ,sdLineLength(fractUV, r0, r2));\n    // First, middle horizontal line\n    intensity = min(intensity, sdLineLength(fractUV, r0_i, r0));\n    // Botom hirozontal line\n    intensity = min(intensity, sdLineLength(fractUV, r1_i, r1));\n    // Top hirozontal line\n    intensity = min(intensity, sdLineLength(fractUV, r2_i, r2));\n\n\n    float edge = 0.0;\n    float margin = 0.045*zoom; \n\n    // Turn distance field to line\n    intensity = 1.0 - smoothstep(\n        edge + margin,\n        edge + 0.0,\n        intensity\n    );\n\n\n    vec3 cell_color = vec3(\n        0.5 + 0.5*sin(indexUV.y + 2.*pi_time)*sin(indexUV.y + 6.*pi_time),\n        0.5 + 0.5*cos(indexUV.y/2. + 2.*pi_time),\n        1.0\n    );\n\n    vec3 color_mix = mix(\n        vec3(0.), \n        cell_color, \n        intensity\n    );\n\n    fragColor = vec4(color_mix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 171, 218, 218, 324], [325, 325, 379, 379, 415], [417, 417, 472, 472, 4328]]}
{"id": "NlcXR8", "name": "screenburnsmooth", "author": "Del", "description": "playing with these trails! it looks like my old plasma tv!! (smooth, remix)", "tags": ["sin", "pattern", "trig"], "likes": 10, "viewed": 146, "published": "Public API", "date": "1638669845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'screenburn' smooth remix - Del 05/12/2021\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d)\n{\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n} \n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    float xoff = sin(uv.y*25.0)*0.16;\n     xoff *= smoothstep(0.0,1.0,0.5+sin(length(uv)+iTime*0.3)*0.5);\n    uv.x+=xoff;\n    uv.y *= 2.;\n    uv.x = uv.x*16.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.5;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(18.0,5.0,s);\t\t\t// trail length\n    //float trail = 5.0;\n    float yv = fract(uv.y + t*s + o) * (trail*1.5);\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec2 uv = (p.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dd0 = length(uv);\n    float dd1 = smoothstep(0.0,0.3,dd0);\n    uv *= rotate(fract(0.6+iTime*-0.01)*6.28);\n//    uv = smoothRot(uv,8.0,0.05,0.0,-0.1);\n      uv = smoothRot(uv,4.0,0.35,16.0,0.05);\n        \n    if (iMouse.z<0.5)\n        uv *= 0.5;\n    float drop = vDrop(uv.yx,iTime*0.5);\n    vec3 linecol1 = vec3(0.75,0.45,0.325)*1.5;\n    vec3 linecol2 = vec3(0.4,0.75,0.325)*1.5;\n    vec3 linecol = mix(linecol1,linecol2,0.5+sin(iTime*0.2+dd0*.7)*0.5);\n    \n    vec3 backcol = vec3(0.01,0.04,0.1);\n    vec3 col = mix(backcol,linecol,drop)*dd1;\n    k = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 103, 103, 270], [272, 272, 294, 294, 361], [383, 383, 413, 413, 1027], [1029, 1029, 1065, 1065, 1704]]}
{"id": "NldSzM", "name": "Gold Edifices", "author": "dr2", "description": "Auric architecture", "tags": ["wave", "hexagon", "building"], "likes": 38, "viewed": 248, "published": "Public API", "date": "1638868361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gold Edifices\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Auric architecture (based on \"Edible Edifices\")\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, ltDir;\nvec2 gId, trkF, trkA, bldCs;\nfloat tCur, dstFar, hgSize, wavHt, emFrac, grRad, pR, pA, bldTp, rc;\nint idObj;\nbool isOcc, isSh;\nconst float pi = 3.1415927, sqrt2 = 1.41421, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CasBldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, a;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  qq = q;\n  q.xy -= vec2 (-5., 1.2);\n  d = PrRoundBoxDf (q, vec3 (0.15, 1.2 + rc, 5.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 1.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  d = max (d, - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.6, 0.)), vec2 (0.6, 0.4), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 5.;\n  q.y -= 0.2;\n  d = min (PrCylAnDf (q.xzy, 0.45, 0.05, 1.2 + 0.2), PrCylDf (q.xzy, 0.4, 1.2));\n  dMin = min (dMin, d);\n  q = qq;\n  q.xy -= vec2 (-2., 2.);\n  d = max (max (q.y - 1.8 - 0.3 * q.x, - q.x), - p.y);\n  dMin = min (dMin, d);\n  d = PrRoundBoxDf (q, vec3 (0.15, 2.2 + rc, 2.) - rc, rc);\n  d = max (d, - PrRoundBox2Df (vec2 (q.y - 2.2, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.2, 0.1), rc));\n  dMin = min (dMin, d);\n  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.xzy, 0.3, 2.3);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat TwrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 3.5 - rc;\n  d = PrRoundBoxDf (q, vec3 (vec2 (1.3) * (1. - 0.05 * q.y), 3.5).xzy - rc, rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-4., -1.);\n  d = min (d, PrRoundCylDf (q.xzy, 0.8 * (1. - 0.05 * q.y) - rc, rc, 2.5 - rc));\n  q.x -= 1.7;\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y - 0.8 + 0.2 * q.x * q.x).xzy, vec3 (2., 0.4, 0.1), rc));\n  q.z = abs (q.z);\n  q -= vec3 (-2.5, -1., 1.1);\n  d = min (d, PrRoundCylDf (q.xzy, 0.7 * (1. - 0.05 * q.y)- rc, rc, 1.5 - rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PyrBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = max (max (abs (q.y) - 2., - q.x + q.y), min (0.4 - abs (abs (q.z) - 0.6), (q.y - q.x + 0.18 -\n     abs (mod (q.x + q.y - 0.02, 0.4) - 0.2) / sqrt2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.2;\n  d = PrCylAnDf (q.xzy, 0.5, 0.05, 0.2);\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat TajBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (5.8, 0.1, 5.8) - rc, rc);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * (pA - 0.5) + 0.5) / 8.));\n  q.xy -= vec2 (-3.5, 2.);\n  d = abs (q.y) - 2.;\n  q.y = mod (q.y + 0.4, 2.) - 1.;\n  q.z = abs (q.z) - 0.6;\n  d = max (d, max (- q.x, - max (PrCapsDf ((q - vec3 (0., -0.5, 0.)).xzy, 0.4, 1.), - q.y - 0.2)));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * (pA - 0.5) + 0.5) / 4.));\n  q.z = abs (q.z);\n  q -= vec3 (-5., 3.1, 5.);\n  d = PrCylDf (q.xzy, 0.3 - 0.1 * q.y / 3., 3.);\n  dMin = min (dMin, d);\n  q.y -= 3.2;\n  d = PrSphDf (q, 0.3);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 4.6;\n  d = PrSphDf (q, 2.);\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PisBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ht, dh, a, ai, nf, na;\n  nf = 8.;\n  na = 12.;\n  ht = 3.5;\n  q = p;\n  d = PrCylDf (q.xzy, 3., 0.05);\n  dMin = min (dMin, d);\n  q.xz = Rot2D (q.xz, pi / 4.);\n  q.y -= ht + 0.05;\n  q.xy = Rot2D (q.xy, 0.025 * pi);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  d = PrCylDf (q.xzy, 1., ht);\n  dh = abs (q.y) - ht * (1. + 1. / (4. * nf));\n  q.y = mod (q.y + ht / nf, 2. * ht / nf) - ht / nf;\n  d = min (d, max (dh, PrRoundCylDf (q.xzy, 1.2 - rc, rc, ht / (4. * nf) - rc)));\n  ai = floor (na * (a - 0.5) + 0.5) / na;\n  q.xz = Rot2D (q.xz, 2. * pi * ai);\n  q.y = abs (q.y) - ht / nf;\n  d = max (d, - PrRoundBoxDf (vec3 (length (q.xz) - 1., q.y, 2. * pi * (abs (a - ai - 0.5) - 0.5 / na)),\n     vec3 (0.2, 0.55 * ht / nf, 0.12) - rc, rc));\n  q.x -= -1.05;\n  d = min (d, max (dh, PrCylDf (q.xzy, 0.08, ht / nf)));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 0.4;\n  d = PrRoundBox2Df (vec2 (pR - 6.5, abs (q.y) - 0.4), vec2 (0.25, 0.01), rc);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (64. * (pA - 0.5) + 0.5) / 64.));\n  q.x = abs (q.x + 6.5) - 0.15;\n  d = min (d, PrCylDf (q.xzy, 0.08, 0.4));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat FrtBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * (pA - 0.5) + 0.5) / 5.));\n  q.xy -= vec2 (-2., 1.4);\n  d = max (max (- q.x, abs (q.y) - 1.4), - PrRoundBoxDf (vec3 (q.x, abs (q.y) - 0.5,\n     mod (q.z + 0.5, 1.) - 0.5), vec3 (0.1, 0.2, 0.15), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x - 2., q.y - 1.4 - 0.3 * q.x), vec2 (2.2, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.xy -= vec2 (-3.5, -0.6);\n  d = max (max (abs (q.x) - 0.4, abs (q.y) - 0.8),\n     - PrRoundBox2Df (vec2 (q.yz - vec2 (-0.2, 0.)), vec2 (0.4, 0.3), rc));\n  d = min (d, PrRoundBox2Df (vec2 (q.x, q.y - 0.9 + 0.4 * abs (q.x)), vec2 (0.6, 0.06) - rc, rc));\n  dMin = min (dMin, d);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 5.5 * tan (pi / 5.);\n  d = PrCylDf (q.xzy, 0.8, 1.1);\n  r = 0.2 * length (q.xz);\n  q.y -= 1.4 - r;\n  d = min (d, PrCylDf (q.xzy, 1.1, 0.3 - r));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat WvnBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rs, s, h, f, yy;\n  h = 2.5;\n  rs = 0.15;\n  q = p;\n  q.y -= h + rs;\n  f = q.y / h - 1.;\n  yy = abs (q.y) - h;\n  d = max (pR - 2.3 - 0.7 * f * f, yy);\n  q.xz *= 1.4 + 0.4 * f;\n  q.xz = vec2 (20. * pA, length (q.xz) - 10. / pi);\n  d = min (d, length (vec2 (yy, q.z)) - 2. * rs);\n  s = 0.4 * rs * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z + s)),\n     length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt2, q.z - s))) - rs, yy));\n  dMin = min (dMin, d);\n  return 0.5 * dMin;\n}\n\nfloat PstBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, s, ss;\n  s = 1.7;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    q.xz = abs (q.xz) - 0.75 * s;\n    ss = s * s;\n    q.xz = mix (q.xz, q.zx, step (q.x, q.z));\n    d = min (PrRoundBoxDf (q - vec3 (0., 0.6 * ss - rc, 0.), s * vec3 (0.3, 0.6 * s, 0.3) - rc, rc),\n       PrCylDf ((q - vec3 (0., 1.45 * ss - rc, 0.)).xzy, 0.12 * s, 0.25 * ss));\n    dMin = min (dMin, d);\n    s *= 0.85;\n  }\n  return 0.9 * dMin;\n}\n\nfloat BrgBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 0.1 + 0.01 * sin (8. * pi * pR);\n  d = max (abs (abs (pR - 5.2) - 1.4) - 0.4, abs (q.y) - 0.1);\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 1.5;\n  d = min (PrCylDf (q.xzy, 2.5, 1.5),\n     PrCylDf (vec3 (q.xz, q.y - (2.2 - 0.25 * pR + 0.1 * sin (32. * pi * pA))), 2.8, 0.07));\n  q.y -= 2.16;\n  d = min (d, PrCylDf (q.xzy, 0.5, 0.22));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * (pA - 0.5) + 0.5) / 3.));\n  d = max (d, - PrRoundBoxDf (q - vec3 (-2.5, 0.8, 0.), vec3 (0.7, 0.8, 0.7), rc));\n  dMin = min (dMin, d);\n  q.x += 5.2;\n  q.y -= 0.5 - 0.2 * q.x * q.x;\n  d = PrBoxDf (q, vec3 (1.6, 0.1, 0.6));\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.3, 0.5);\n  d = min (d, PrRoundBoxDf (q, vec3 (1.6, 0.3, 0.1) - rc, rc));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat PanBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 1.8;\n  q = p;\n  d = PrRoundBoxDf (q, vec3 (4.9, 1.6, 2.9) - rc, rc);\n  q.y = abs (q.y) - 1.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (5.4, 0.1, 3.4) - rc, rc));\n  q = p;\n  q.y -= -1.7;\n  d = min (d, PrRoundBoxDf (q, vec3 (6., 0.1, 4.) - rc, rc));\n  dMin = min (dMin, d);\n  q = p;\n  q.y -= 2.2;\n  d = PrCylDf (q.xzy, 1.7, 0.75);\n  q.y -= 0.75;\n  d = min (d, max (max (PrSphDf (q, 2.), - q.y), 0.2 - pR));\n  dMin = min (dMin, d);\n  q = p;\n  q.xz = mod (q.xz + 0.5, 1.) - 0.5;\n  d = max (PrCylDf (q.xzy, 0.2, 1.5), max (abs (p.x) - 5.5, abs (p.z) - 3.5));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * (pA - 0.5) + 0.5) / 16.));\n  q.xy -= vec2 (-1.85, 2.2);\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.75));\n  dMin = min (dMin, d);\n  return 0.9 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p.xz -= HexToPix (gId * hgSize);\n  dMin = dstFar;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  q.y -= wavHt - 0.05;\n  d = SmoothMax (abs (q.x) - 0.48 * sqrt3 * hgSize, q.y, 0.05);\n  DMINQ (1);\n  if (isOcc) {\n    q = p;\n    q.xz = Rot2Cs (q.xz, bldCs);\n    q.y -= wavHt + 0.35;\n    pR = length (q.xz);\n    pA = ((pR > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5;\n    rc = 0.05;\n    if (! isSh) d = PrCylDf ((q - vec3 (0., 3.8, 0.)).xzy, 8.21, 3.8);\n    if (isSh || d < 0.1) {\n      if (bldTp <= 4.) {\n        if      (bldTp == 1.) d = CasBldgDf (q, dMin);\n        else if (bldTp == 2.) d = TwrBldgDf (q, dMin);\n        else if (bldTp == 3.) d = PyrBldgDf (q, dMin);\n        else /*if (bldTp == 4.)*/ d = TajBldgDf (q, dMin);\n      } else if (bldTp <= 7.) {\n        if      (bldTp == 5.) d = PisBldgDf (q, dMin);\n        else if (bldTp == 6.) d = FrtBldgDf (q, dMin);\n        else /*if (bldTp == 7.)*/ d = WvnBldgDf (q, dMin);\n      } else /*if (bldTp <= 10.)*/ {\n        if      (bldTp == 8.) d = PstBldgDf (q, dMin);\n        else if (bldTp == 9.) d = BrgBldgDf (q, dMin);\n        else if (bldTp == 10.) d = PanBldgDf (q, dMin);\n      }\n      DMINQ (2);\n    } else dMin = min (dMin, d);\n    q.y -= -0.2;\n    d = PrRoundCylDf (q.xzy, 8.2 - rc, rc, 0.15 - rc);\n    DMINQ (3);\n  }\n  return dMin;\n}\n\nvoid SetGrObjConf ()\n{\n  vec2 p, u, fRand;\n  p = HexToPix (gId * hgSize);\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.4 * sin (0.2 * 2. * pi * p)) +\n     0.1 * tCur, 1.) - 0.5;\n  wavHt = dot (exp (-100. * u * u), vec2 (1.));\n  fRand = Hashv2v2 (gId * vec2 (37.31, 43.11) + 27.11);\n  isOcc = (fRand.y > emFrac);\n  if (isOcc) {\n    bldTp = 1. + floor (10. * (fRand.y - emFrac) / (1. - emFrac));\n    bldCs = sin (2. * pi * fRand.x + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  int idObjT;\n  isSh = true;\n  idObjT = idObj;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 2. * hgSize) break;\n  }\n  idObj = idObjT;\n  isSh = false;\n  return 0.8 + 0.2 * sh;\n}\n\nfloat BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0., 0.1, 0.3), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  f = Maxv3 (col);\n  return f * sqrt (f);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, vnn;\n  vec2 vf;\n  float dstObj, nDotL, sh, glit;\n  bgCol = BgCol (rd) * vec3 (1., 1., 0.3);\n  emFrac = 0.02;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrObjConf ();\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == 1) {\n      if (vn.y > 0.5) {\n        col4 = vec4 (0.2, 0.4, 0.2, 0.1) * (0.8 + 0.2 * Fbm2 (ro.xz));\n        if (isOcc) col4 = mix (vec4 (0.4, 0.3, 0., 0.1), col4,\n           smoothstep (8.2, 8.25, length (ro.xz - HexToPix (gId * hgSize))));\n        vf = vec2 (4., 1.);\n      } else col4 = vec4 (0.1, 0.3, 0.1, 0.) * (0.9 + 0.1 * sin (4. * pi * qHit.y));\n    } else if (idObj == 2) {\n      col4 = vec4 (0.7, 0.7, 0.1, 0.2);\n      vf = vec2 (512., 8.);\n    } else if (idObj == 3) {\n      col4 = vec4 (0.5, 0.4, 0.1, 0.1);\n      vf = vec2 (8., 0.5);\n    }\n    if (vf.y > 0.) {\n      vnn = VaryNf (vf.x * qHit, vn, vf.y);\n      if (idObj != 2) vn = vnn;\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 2) nDotL *= nDotL;\n    sh = (idObj != 2) ? ObjSShadow (ro + 0.1 * vn, ltDir) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    if (idObj == 2) {\n      col = mix (col, BgCol (reflect (rd, vn)) * vec3 (1., 1., 0.3), 0.3);\n      glit = 32. * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), vnn)), 8.);\n      col += vec3 (1., 1., 0.8) * glit;\n    }\n    col = mix (col, bgCol, smoothstep (0.5, 1., dstObj / dstFar));\n  } else col = (0.1 + 0.9 * step (-0.1, rd.y)) * bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), dot (trkA.yx, cos (trkF * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), dot (trkF * trkA.yx, - sin (trkF * t)), 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, vFly;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  tCur = mod (tCur, 1200.);\n  hgSize = 11.;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.2 * pi * mPtr.y;\n  } else {\n    az += 0.2 * pi * sin (0.02 * pi * tCur);\n  }\n  trkF = 0.2 * vec2 (0.1, 0.17);\n  trkA = 2. * vec2 (1.25, 0.45);\n  vFly = 3.;\n  ro = TrackPath (vFly * tCur);\n  ro.xy += vec2 (3.5, 30.);\n  vd = normalize (TrackVel (vFly * tCur));\n  el += asin (vd.y);\n  az += atan (vd.x, vd.z);\n  el = clamp (el, -0.25 * pi, -0.12 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.;\n  dstFar = 500.;\n  ltDir = vuMat * normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 1292, 1330, 1330, 2294], [2296, 2296, 2334, 2334, 2934], [2936, 2936, 2974, 2974, 3394], [3396, 3396, 3434, 3434, 4201], [4203, 4203, 4241, 4241, 5386], [5388, 5388, 5426, 5426, 6331], [6333, 6333, 6371, 6371, 6934], [6936, 6936, 6974, 6974, 7477], [7479, 7479, 7517, 7517, 8320], [8322, 8322, 8360, 8360, 9142], [9144, 9144, 9166, 9166, 10549], [10551, 10551, 10573, 10573, 11019], [11021, 11021, 11054, 11054, 12129], [12131, 12131, 12152, 12152, 12409], [12411, 12411, 12448, 12448, 12940], [12942, 12942, 12965, 12965, 13392], [13394, 13394, 13429, 13429, 15188], [15190, 15190, 15216, 15216, 15296], [15298, 15298, 15323, 15323, 15420], [15422, 15422, 15478, 15478, 16916], [16918, 16918, 16950, 16950, 17050], [17052, 17052, 17098, 17098, 17145], [17147, 17147, 17194, 17194, 17241], [17243, 17243, 17276, 17276, 17303], [17305, 17305, 17347, 17347, 17398], [17400, 17400, 17453, 17453, 17514], [17516, 17516, 17573, 17573, 17649], [17651, 17651, 17694, 17694, 17758], [17760, 17760, 17784, 17784, 18014], [18016, 18016, 18040, 18040, 18100], [18102, 18102, 18124, 18124, 18162], [18164, 18164, 18186, 18186, 18224], [18226, 18226, 18271, 18271, 18363], [18365, 18365, 18410, 18410, 18448], [18450, 18450, 18486, 18486, 18692], [18693, 18693, 18723, 18723, 18836], [18838, 18838, 18869, 18869, 18933], [18967, 18967, 18991, 18991, 19103], [19105, 19105, 19130, 19130, 19316], [19318, 19318, 19339, 19339, 19494], [19496, 19496, 19525, 19525, 19737], [19739, 19739, 19778, 19778, 20030]]}
{"id": "NldSzr", "name": "Thindal twitch logo", "author": "mrange", "description": "License: CC0, author: Mårten Rånge\nInspired by: https://www.twitch.tv/thindal\nNet of stars very obviously inspired by BigWings - The Universe Within:\n https://www.shadertoy.com/view/lscczl\n", "tags": ["2d", "twitch"], "likes": 13, "viewed": 155, "published": "Public API", "date": "1638625776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: CC0, author: Mårten Rånge\n//  Inspired by: https://www.twitch.tv/thindal\n//  Net of stars very obviously inspired by BigWings - The Universe Within:\n//   https://www.shadertoy.com/view/lscczl\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define TTIME           (TAU*TIME)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n#define LINECOL(x,y)    lineCol(aa, z, np, cp, cps[x], cps[y]);\n\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 baseLogoCol = HSV2RGB(vec3(0.715, 0.333, 0.8));\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length(pa - ba*h);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 cellPos(vec2 np) {\n  vec2 hp = hash(np);\n  return 0.3*vec2(sin(hp*TIME));   \n}\n\nvec3 lineCol(float aa, float z, vec2 np, vec2 cp, vec2 p0, vec2 p1) {\n  float l = length(p0 - p1);\n  float d = segment(cp, p0, p1)-1.5*aa/z;\n\n  float cd = min(length(cp-p0), length(cp-p1));\n\n  float v = 2.0*exp(-1.75*l)*exp(-15.*max(d, 0.0));\n  float s = 1.0-tanh_approx(v);\n  vec3 hsv = vec3(0.715, s, v);\n\n  return hsv2rgb(hsv);\n}\n\nfloat plane(vec2 p, vec2 n, float m) {\n  return dot(p, n) + m;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat polygon4(vec2[4] v, vec2 p) {\n  const int N = 4;\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=N-1; i<N; j=i, ++i) {\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n    bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if( all(c) || all(not(c)) ) s*=-1.0;  \n  }\n  return s*sqrt(d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat isosceles(vec2 p, vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n               vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dthindal(vec2 p) {\n  vec2 p0 = -p.yx;\n  vec2 q0 = vec2(0.57, 0.96);\n\n  vec2 p1 = -p.yx;\n  vec2 q1 = vec2(0.31, 0.575);\n\n  if (p.y > 0.0) {\n    q0 = vec2(0.524, 0.88);\n    q1 = vec2(0.29, 0.5);\n  }\n\n  p0.y += 0.59;\n  p1.y += 0.35;\n\n  const vec2 p2[] = vec2[](vec2(-0.62, 0.075), vec2(-0.035, 0.075), vec2(-0.035, -0.075), vec2(-0.365, -0.075));\n\n  float d0 = isosceles(p0, q0);\n  float d1 = isosceles(p1, q1);\n  float d2 = polygon4(p2, p);\n  float d3 = plane(p, normalize(vec2(1.0, 1.7)), -0.055);\n\n  d0 = max(d0, -d1);\n  if (p.y > 0.0) {\n    d0 = max(d0, -d3);\n  }\n  \n  float d = d0;\n  d = min(d, d2);\n  \n  return d;\n}\n\nvec4 gridColor(vec2 p) {\n  float z = 0.2;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = vec3(0.0);\n  p /= z;\n  vec2 cp = fract(p) - 0.5;\n  vec2 np = floor(p);\n\n  vec2 cps[9];\n  int idx = 0;\n\n  for (float y = -1.0; y <= 1.0; ++y) {\n    for (float x = -1.0; x <= 1.0; ++x) {\n      vec2 off = vec2(x, y);\n      cps[idx++] = cellPos(np+off) + off;\n    }\n  }\n\n  col += LINECOL(4, 0);\n  col += LINECOL(4, 1);\n  col += LINECOL(4, 2);\n  col += LINECOL(4, 3);\n\n  col += LINECOL(4, 5);\n  col += LINECOL(4, 6);\n  col += LINECOL(4, 7);\n  col += LINECOL(4, 8);\n\n  col += LINECOL(1, 3);\n  col += LINECOL(1, 5);\n  col += LINECOL(7, 3);\n  col += LINECOL(7, 5);\n\n  float i = col.x+col.y+col.z;\n\n  return vec4(col, tanh_approx(i));\n}\n\nvec3 thindal(vec3 col, vec2 p, vec2 q) {\n  const float zi = 1.1;\n  vec2 op = p;\n  float aa = 2.0/RESOLUTION.y;\n\n  float fade = 0.9*mix(0.9, 1.0, PCOS(0.25*TTIME+10.0*q.x));\n\n  vec2 pi = p;\n  const float period = 10.0;\n  const float coff = PI;\n  float ptime = (1.0/period)*TIME;\n  float mtime = mod(ptime, 2.0);\n  float ntime = floor(ptime/2.0);\n  float anim = min(1.0, mtime)*step(1.0, ptime); \n  float h = hash(ntime+123.4);\n  float s = floor(h*5.0);\n  float off = 0.6*p.x+p.y;\n  if (s == 1.0) {\n    off = p.x+p.y*p.y;\n  }  else if (s == 2.0) {\n    off = p.x+p.y*p.y*p.y;\n  } else if (s == 3.0) {\n    off = p.x*p.y+p.y*p.x;\n  } else if (s == 4.0) {\n    off = p.x+p.y*p.x;\n  }\n\n  off += -2.0/3.0+PI*anim;\n  float angle = off+mix(coff*0.42, -coff*0.42 , fade);\n  float split = angle+coff;\n  int _nsplit = int(mod1(split, 1.0*coff));\n\n  pi /= zi;\n  float di  = dthindal(pi);\n  float dii = abs(di-0.0125) - 0.0025;\n  di = min(di, dii);\n  di *= zi;\n  \n  float dg = di;\n\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).xzy*0.85;\n\n  float gmix = pow(abs(cos(angle)), 8.0);\n  float gmix2 = abs(1.0/tanh_approx(split))*0.5;\n\n  dg = abs(dg-0.025);\n  float glow = exp(-10.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow)*gmix2;\n  col -= 0.5*exp(-10.0*max(di+0.1, 0.0));\n  col = mix(col, vec3(mix(baseLogoCol, sqrt(glowCol*0.5), gmix)), smoothstep(-aa, aa, -di));\n  col += 0.5*smoothstep(0.5, 0.45, abs(anim-0.5))*glowCol*glow*gmix;\n\n  return col;\n}\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h);\n\n  return gridColor(p);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return vec3(0.0);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.;\n  const int furthest = 4;\n  const int fadeFrom = max(furthest-3, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.3;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col *= smoothstep(3.0, 6.0, TIME);\n  col = thindal(col, p, q);\n  col *= smoothstep(0.0, 10.0*q.y, TIME);\n  col = postProcess(col, q);\n \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSzr.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 607, 629, 629, 775], [1130, 1190, 1230, 1230, 1389], [1391, 1451, 1491, 1491, 1533], [1535, 1595, 1617, 1617, 1665], [1667, 1727, 1746, 1746, 1869], [1871, 1957, 1996, 1996, 2121], [2123, 2241, 2280, 2280, 2389], [2391, 2451, 2479, 2545, 2621], [2623, 2623, 2646, 2646, 2706], [2708, 2708, 2777, 2777, 3040], [3042, 3042, 3080, 3080, 3106], [3108, 3226, 3261, 3261, 3636], [3638, 3756, 3789, 3789, 4082], [4084, 4084, 4108, 4108, 4708], [4710, 4710, 4734, 4734, 5424], [5426, 5426, 5466, 5466, 6898], [6900, 6921, 6943, 6943, 7077], [7079, 7158, 7181, 7181, 7256], [7258, 7328, 7352, 7352, 7431], [7433, 7433, 7501, 7501, 7655], [7657, 7657, 7690, 7690, 7712], [7714, 7714, 7770, 7770, 9311], [9313, 9400, 9436, 9436, 9669], [9671, 9671, 9700, 9700, 10000], [10002, 10002, 10057, 10057, 10354]]}
{"id": "NldXDM", "name": "Triangle Image Effect", "author": "Daizuukee", "description": "Here i have created a shader that splits the grid into infinite triangles that move around, to continue i would like to add subtriangles to the project as i believe that it would add a lot of life to the image.", "tags": ["grid", "triangles", "colors", "imageprocessing", "random", "imageeffect", "interpolation", "colormixing"], "likes": 16, "viewed": 197, "published": "Public API", "date": "1639234592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPARAMETERS FEEL FREE TO CHANGE\n*/\n\n//Difference between triangles -> 0 - 1\n#define multiplier 0.71\n//Amount of traingles on X axis\n#define zoom 20.\n\n//position of the camera (can be an animation, dont place below 0)\n#define position vec2(85,483);\n\n//Lighting\n//strength of the lights\n#define normals 0.25\n//Direction of the light\n#define light vec2(2,1)\n\n//Uncomment to use iCHannel0 as source for colors\n//#define colFromImage\n\n//colors (can be animated)\n//only apply when colFromImage is undefined\n#define color0 vec3(1.0, 0.0, 1.0)\n#define color1 vec3(0.2157, 0.0, 1.0)\n#define color2 vec3(0.502, 0.9686, 1.0)\n#define color3 vec3(0.702, 0.4235, 0.2353)\n#define BG vec3(1,1,1)\n//Strength of the colors to be aplied to the BG\n#define strength 0.71\n\n\n/*\nCODE BEGINS HERE\n*/\n\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n//const uint k = 1103515245U;  // GLIB C\nconst uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\nvec3 hash(uvec3 x)\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU)) * 2. - 1.;\n}\n\n\n\n\n\n#define lerp(from,to,x) (((to)-(from))*(x)+(from))\n#define map(from,to,fromX,toX,x) lerp((from),(to),((x)-(fromX))/((toX)-(fromX)))\n#define zFunc iTime\n//Gets the vertice at x,y with z time having passed\n//only value that is animated is z\nvec3 getVertice(vec3 pos) {\n    //give every tiangle a different time offset\n    float t = pos.z+hash(uvec3(pos.xy + 748.,0)).x;\n    //interpolate between current and next triangle position\n    vec3 a = hash(uvec3(pos.xy,floor(t))) * multiplier * 0.5 + 0.5;\n    vec3 b = hash(uvec3(pos.xy,ceil(t))) * multiplier * 0.5 + 0.5;\n    //make normals stronger\n    a.z *= normals;\n    b.z *= normals;\n    return lerp(a,b,fract(t));\n}\n\n//Gets the triangle that p will be in\n//x -> x quad\n//y -> y quad\n//z -> upper or lower triangle\n/*\nEach quad looks like this\neach + can be moved freely\n\n+----+\n|\\   |\n| \\  |\n|  \\ |\n|   \\|\n+----+\n\n*/\n\nuvec3 bindToTris(vec2 p) {\n    //current grid Tile\n    ivec2 floorP = ivec2(p);\n    //relative Position to Tile\n    vec2 modP = p-vec2(floorP);\n    //time\n    float z = zFunc;\n    //check in which quad we are relative to the middle of the current grid Tile\n    vec2 mid = getVertice(vec3(floorP,z)).xy;\n    ivec2 nextOffset = ivec2(mid.x < modP.x,mid.y < modP.y) * 2 - 1;\n\n    //check in which quad we are by looking if we are above/below and to the right/left of line between the dots\n    //that make up the current quad\n    vec2 yOff = getVertice(vec3(floorP.x, floorP.y + nextOffset.y, z)).xy;\n    vec2 xOff = getVertice(vec3(floorP.x + nextOffset.x, floorP.y, z)).xy;\n    float yLine = map(mid.x,yOff.x,mid.y,yOff.y+float(nextOffset.y),modP.y);\n    float xLine = map(mid.y,xOff.y,mid.x,xOff.x+float(nextOffset.x),modP.x);\n\n    ivec2 quad = ivec2(modP.x > yLine, modP.y > xLine);\n    \n    //check wether we are in the upper or lower triangle of the current quad\n    vec2 dOff0 = getVertice(vec3(floorP + quad + ivec2(-1, 0), z)).xy;\n    vec2 dOff1 = getVertice(vec3(floorP + quad + ivec2( 0,-1), z)).xy;\n\n    float dLine = map(dOff0.y+1.,dOff1.y,dOff0.x,dOff1.x+1.,modP.x+1.-float(quad.x))-1.+float(quad.y);\n    \n    //return the data for further use (mostly unusable as is)\n    return uvec3(quad+floorP,modP.y > dLine);\n}\n\n//returns the middle of the triangle given the data from bindToTris() and the height gradient\n\nvec4 getTriangle(uvec3 data) {\n    float z = zFunc;\n    int up = int(data.z);\n    //get all the different vertices\n    vec3 p1 = getVertice(vec3(vec2(data.xy)+vec2(0,-1),z)) + vec3(0,-1, 0);\n    vec3 p2 = getVertice(vec3(vec2(data.xy)+vec2(-1,0),z)) + vec3(-1, 0, 0);\n    vec3 p3 = getVertice(vec3(vec2(data.xy)+vec2(up-1,up-1),z)) + vec3(up-1,up-1,0);\n\n    //gradient from p1 to the other corners\n    vec3 gradient0 = p1-p2;\n    vec3 gradient1 = p1-p3;\n    vec3 g = cross(gradient0,gradient1);\n    //amount you need to move x and y to add 1 to z\n    g.xyz /= g.z;\n    \n    return vec4(((p1.xy+p2.xy+p3.xy)/3.)+vec2(data.xy),g.xy);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv=fragCoord/iResolution.xx;\n    uv *= zoom;\n    uv += position;\n    \n    //standardize everything\n    vec3 interpCol0 = color0;\n    vec3 interpCol1 = color1;\n    vec3 interpCol2 = color2;\n    vec3 interpCol3 = color3;\n    //get triangle under current pixel and immediately turn into usable data\n    vec4 Triangle = getTriangle(bindToTris(uv));\n    Triangle.xy -= position;\n    Triangle.xy /= zoom;\n\n    vec3 cur;\n\n#ifdef colFromImage\n    cur = texture(iChannel0,Triangle.xy).xyz;\n#else\n    //interpolate the colors\n    float l0 = clamp((1.-distance(Triangle.xy,vec2(0,0)))*strength,0.,1.);\n    float l1 = clamp((1.-distance(Triangle.xy,vec2(0,1)))*strength,0.,1.);\n    float l2 = clamp((1.-distance(Triangle.xy,vec2(1,0)))*strength,0.,1.);\n    float l3 = clamp((1.-distance(Triangle.xy,vec2(1,1)))*strength,0.,1.);\n    cur = lerp(BG,interpCol0,l0);\n    cur = lerp(cur,interpCol1,l1);\n    cur = lerp(cur,interpCol2,l2);\n    cur = lerp(cur,interpCol3,l3);\n#endif\n    //calculate lighting through dot product between lighting normal and triangle normal\n    cur *= dot(Triangle.zw,normalize(light))/2.+1.;\n\n    fragColor = vec4(cur,1);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[858, 1007, 1027, 1027, 1165], [1323, 1410, 1437, 1486, 1835], [1837, 2038, 2064, 2088, 3363], [3365, 3460, 3490, 3490, 4093], [4095, 4095, 4149, 4149, 5293]]}
{"id": "NldXRX", "name": "Colorful carpet", "author": "bunyk", "description": "Weird effects of rasterization I would say, + Jet colormap", "tags": ["2d"], "likes": 1, "viewed": 35, "published": "Public", "date": "1639499596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ---------- Jet colormap -----------------------------\n// https://www.shadertoy.com/view/3tlGD4\n// float u0 = 0.0;\nconst vec3 color0 = vec3(0.0, 0.0, 0.5625); // blue\nconst float u1 = 1.0/9.0;\nconst vec3 color1 = vec3(0.0, 0.0, 1.0); // blue\nconst float u2 = 23.0/63.0;\nconst vec3 color2 = vec3(0.0, 1.0, 1.0); // cyan\nconst float u3 = 13.0/21.0;\nconst vec3 color3 = vec3(1.0, 1.0, 0.0); // yellow\nconst float u4 = 47.0/63.0;\nconst vec3 color4 = vec3(1.0, 0.5, 0.0); // orange\nconst float u5 = 55.0/63.0;\nconst vec3 color5 = vec3(1.0, 0.0, 0.0); // red\n// float u6 = 1.0;\nconst vec3 color6 = vec3(0.5, 0.0, 0.0); // red\n\n// rescaling function\n#define rescale(u, v, x) (x - u)/(v - u)\n\nvec3 jetLinear(float t)\n{\n\treturn\n        + mix(color0, color1, rescale(0.0, u1, t))\n        + (mix(color1, color2, rescale(u1, u2, t)) - mix(color0, color1, rescale(0.0, u1, t))) * step(u1, t)\n        + (mix(color2, color3, rescale(u2, u3, t)) - mix(color1, color2, rescale(u1, u2, t))) * step(u2, t)\n        + (mix(color3, color4, rescale(u3, u4, t)) - mix(color2, color3, rescale(u2, u3, t))) * step(u3, t)\n        + (mix(color4, color5, rescale(u4, u5, t)) - mix(color3, color4, rescale(u3, u4, t))) * step(u4, t)\n        + (mix(color5, color6, rescale(u5, 1.0, t)) - mix(color4, color5, rescale(u4, u5, t))) * step(u5, t)\n        ;\n}\n// end of colormap -------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 20.0;\n    vec2 pos = vec2(cos(t), sin(t)) * 5.0;\n    \n    // make uv.y consist of 100 \"pixels\"\n    vec2 uv = trunc((fragCoord/iResolution.y + pos) * 100.0);\n\n    // (x^2 + y^2) mod 73 mod 5\n    // https://commons.wikimedia.org/wiki/File:Remainder-pattern1.png\n    float val = mod(mod(dot(uv, uv), 73.0), 5.0) / 5.0;\n    \n    vec3 col = jetLinear(val);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 687, 712, 712, 1325], [1326, 1396, 1453, 1453, 1861]]}
{"id": "NlKGWt", "name": "thing29379284793", "author": "AnonN10", "description": "convex combination", "tags": ["voronoi"], "likes": 4, "viewed": 34, "published": "Public", "date": "1638528561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932\n#define NUM_POINTS 16\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    const float pw = 16.0;\n    \n    vec2 points[NUM_POINTS];\n    vec3 colors[NUM_POINTS];\n    for(int i = 0; i < NUM_POINTS; ++i)\n    {\n        //[-1; 1]\n        points[i] = vec2(\n            cos(iTime*2.0*PI*0.1*rand(vec2(float(i+1)*0.5574, float(i+1)*0.6425))),\n            sin(iTime*2.0*PI*0.1*rand(vec2(float(i+1)*0.8464, float(i+1)*0.8345)))\n        );\n        //[0; 1]\n        points[i] = points[i]*0.5+0.5;\n        \n        colors[i] = vec3(\n            rand(vec2(float(i+1)*0.1251, float(i+1)*0.2605)),\n            rand(vec2(float(i+1)*0.8681, float(i+1)*0.6385)),\n            rand(vec2(float(i+1)*0.9663, float(i+1)*0.4395))\n        );\n    }\n\n    float nf = 0.0;\n    for(int i = 0; i < NUM_POINTS; ++i)\n    {\n        float dist = length(points[i] - uv);\n        dist = 1.0/dist;\n        dist = pow(dist, pw);\n        nf += dist;\n    }\n    nf = 1.0/nf;\n    \n    for(int i = 0; i < NUM_POINTS; ++i)\n    {\n        float dist = length(points[i] - uv);\n        if(dist < 0.01f)\n        {\n            col = vec3(1.0f);\n            break;\n        }\n        dist = 1.0/dist;\n        dist = pow(dist, pw);\n        col += colors[i]*dist*nf;\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 73, 73, 143], [145, 145, 202, 202, 1513]]}
{"id": "NltSRM", "name": "Voronoi Traversal [comments]", "author": "Yusef28", "description": "It seems in this case that IQ's voronoit edges method makes more sense than Tomkh's. If we want to find borders so we can find the nearest intersection, we actually need to find all the borders around pointA, NOT around the uv (or in this case the ro).", "tags": ["2d", "voronoi", "commented", "borders", "edges", "comments", "traversal"], "likes": 10, "viewed": 172, "published": "Public API", "date": "1638902173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n\n=============================================================\n\nAn important discorvery I made, assuming I am understanding\ntomkh's and Iq's work correctly is that actually:\n\nIQ's method makes more sense than tomkh's here. \nIf we want to find borders \nso we can find the nearest intersection, we actually \nneed to find all the borders around pointA, NOT around \nthe uv (or in this case the ro).\n\nThis way we are garanteed that the edges will be \nthe ones that fully enclose the cell.\n    \nIf you check for borders around ro, you will get borders\nclose to ro for the 3x3 loop which may not find the borders\nin the direction ro+rd*t is even going. So you would then need \na 5x5 loop to do that which is super slow.\n\n==========================================================\n\nHere is a voronoi traversal algorithm I came up with.\nThere are a few hacks involved:\n\n1. When I check edges for a hit I actually check a 5x5 neighborhood\nbecause otherwise the way I do things there are times when not all\nthe correct edges are drawn.\n\n2. The weirdest thing. I find I can't use a constant value \n(such as ray origin) as an input to this algorithm. It has to \nbe moving even a little bit so I jitter with sin(iTime)*0.001\n\nNo idea why. A mouse position will work find and give me the edges, \nbut a set value like vec2(1.,0.) will not. \n\nEDIT: The jitter can be a constant value, we just need to \nbe a tiny bit off from pointA when we checkk pointB for some reason.\n\n*/\n\n/*/////////////////////////////////////////\n\n                  UPDATE\n                  \n    I found a way to make voronoi traversal close to x2 faster!\n    https://www.shadertoy.com/view/7tcSDn\n        \n\n\n////////////////////////////////////////*/\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\n//a method for finding the intersection between\n//two rays. Not effienct but very memorable.\nfloat seg_seg(vec2 ro1, vec2 rd1, vec2 A, vec2 B){\n    vec2 ro2 = A;\n    vec2 rd2 = normalize(B-A);\n    float maxABLange = length(B-A);\n    \n    vec2 perp = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perp) - dot(ro2,perp))/dot(rd2,perp);\n    perp = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perp) - dot(ro1,perp))/dot(rd1,perp);\n    return t >= 0. && s >= 0.? t : 100.;\n}\n\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n/***************************************************\n\nHere is the actual voronoi traversal algorithm\n\n*************************************************** */\nfloat voronoiEdgeHit(vec2 uv, vec2 ro, vec2 rd){\n\n    vec2 st = fract(ro);\n    vec2 stFL = floor(ro);\n    vec2 d = vec2(10.);\n\n    vec2 pointA;\n    vec2 pointB;\n\n\n    float minT = 100.;\n    float t;\n\n    \n    //in this loop we are just looking for the closest point\n    //to the curent ro. It's a standard voronoi but instead of uv\n    //for every pixel we just have ro (the same value) being looked at\n    //every pixel (you wont see \"ro\" here because of what I did above.\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testA = stFL + coords;\n        float c = length(coords.xy - st);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            pointA = testA;\n            \n            }\n        }\n    }    \n    \n    //In this loop I am finding every edge based on Iq's article\n    //meaning I get a new st an stFLoor based on pointA\n    //and find borders around pointA based on that.\n    \n    //so for each edge I check to see where it intersects \n    //with the ray based on ro and rd. We look at 25 edges\n    //around our pointA and the edge that we hit first (minimum t value)\n    //is what we hit so we return that t value and traverse that amount\n    //along the ray.\n    \n    //get a new st and stFL based on the point in this cell that\n    //we've found. This way we are garanteed that the edges will be \n    //the ones that fully enclose the cell!\n    st = fract(pointA);\n    stFL = floor(pointA+0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testB = stFL + coords;\n        \n        float distAB = length(testB-pointA);\n        if( distAB > 0.001 && distAB < 2.){\n            vec2 edgePoint =(pointA+testB)/2.;\n            vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n            vec2 edgeSideA = edgePoint - perp;\n            vec2 edgeSideB = edgePoint + perp;\n          \n          \n          //Check where we intersect the current found edge\n          minT = min(minT, seg_seg(ro,rd,edgeSideA,edgeSideB));\n          //faster version\n          //minT = min(minT, seg_seg_new(ro,rd,edgeSideA,edgeSideB));\n         \n        }\n      }\n    }\n    return minT;\n}\n\n\n\n\n//Basic Voronoi for coloring\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float globalScale = 4.;\n    uv*=globalScale ;\n\n    //get a voronoi for coloring cells an edges\n    vec4 voronoXY = voronoi(uv);\n    \n    //set basic color for all voronoi cells\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    //col.zy *= rot(.1);\n\n    //add some color to the eddges of the voronoi\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.), smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n   //define ro, rd, and set default rotation of rd\n   vec2 ro = vec2(0.,0.);\n   vec2 rd = vec2(1.,0.);\n   rd *= rot(iTime/2.);\n   \n   //adust mouse\n   vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n   //rotate ray based on mouse if mouse press\n   if(iMouse.z > 0.5){rd = normalize(m.xy+ro);}\n   \n   //draw Ray\n   col = mix(col, vec3(1.), line(uv, ro, ro + rd*30., 0.04));\n\n   //Draw RO\n   col = mix(col, vec3(.0,.4,.9),point(uv-ro,0.1));\n   \n   //t value for traversing\n   float t;\n   \n   /****************************************************\n\n                  THIS IS THE MAIN EVENT\n   \n   ****************************************************/\n   \n\n    //we can do 40 x 8 seg-seg intersections without getting slow.\n   for(float i = 0.; i < 15.; i++){\n       t = voronoiEdgeHit(uv,ro,rd);\n       ro += rd*t*1.001;\n       col = mix(col, vec3(1.0,.0,.0),point(uv-ro,0.1));\n       col = mix(col, vec3(1.0,.0,.0),\n           ring(uv-ro,0.24+sin(iTime*4.+i/10.)*0.07));\n   }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2330, 2423, 2473, 2473, 2797], [2800, 2800, 2819, 2819, 2953], [2955, 2955, 2973, 2973, 3036], [3038, 3038, 3078, 3078, 3154], [3156, 3156, 3186, 3186, 3235], [3237, 3237, 3266, 3266, 3329], [3331, 3331, 3375, 3375, 3521], [3523, 3680, 3728, 3728, 6225], [6230, 6259, 6281, 6281, 7508], [7510, 7510, 7567, 7617, 9242]]}
{"id": "NltSRS", "name": "[TDF2021] Reconnection", "author": "Kamoshika", "description": "@Tokyo Demo Fest 2021 GLSL Compo\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/", "tags": ["raymarching", "truchet"], "likes": 14, "viewed": 99, "published": "Public", "date": "1639322785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution.xy\n#define gl_FragColor fragColor\n#define gl_FragCoord fragCoord\n\n#define hash(x) fract(sin(x)*43758.5453)\n#define X(col) if(h<.5){\\\n\t\tq=vec2(q.y,-q.x);\\\n\t}\\\n\th=hash(h);\\\n\tif(h<.5){\\\n\t\tq=abs(q);\\\n\t\tcol+=smoothstep(.1,0.,min(q.x,q.y));\\\n\t}else{\\\n\t\tif(q.y<-q.x){\\\n\t\t\tq.xy=-q.yx;\\\n\t\t}\\\n\t\tq-=.5;\\\n\t\tcol+=smoothstep(.1,0.,abs(length(q)-.5));\\\n\t}\n\nconst float pi2=acos(-1.)*2.;\n\nfloat hash21(vec2 p){\n\treturn hash(dot(p ,vec2(12.9898,78.233)));\n}\n\nvoid rot3d(inout vec3 v,float a,vec3 ax){\n\tax=normalize(ax);\n\tv=mix(dot(ax,v)*ax,v,cos(a))-sin(a)*cross(ax,v);\n}\n\nmat2 rot(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat2(c,s,-s,c);\n}\n\nconst float radius=.15;\nconst float floorHeight=-.12;\nfloat lightTime=0.;\nfloat map(vec3 p){\n\tfloat d,d1,d2;\n\tfloat h=hash21(floor(p.zx));\n\t\n\tvec3 q=p;\n\tq.zx=fract(q.zx)-.5;\n\tif(h<.5){\n\t\tq.zx=vec2(q.x,-q.z);\n\t}\n\t\n\tvec3 q1=q;\n\tq.x=abs(q.x);\n\td1=length(q.xy)-radius;\n\tfloat grad=48.*radius*q.x*(q.x-.5);\n\tfloat tmp=length(vec2(abs(q.y-(q.x*q.x*(q.x-.75)*32.+2.)*radius)/sqrt(1.+grad*grad),q.z))-radius;\n\td1=min(d1,tmp);\n\t\t\n\tq=q1;\n\tif(q.x<-q.z){\n\t\tq.zx=-q.xz;\n\t}\n\tq.zx-=.5;\n\td2=length(vec2(length(q.zx)-.5,q.y))-radius;\n\n\tfloat a=1.;\n\tfloat ac=0.;\n\tfor(int i=0;i<5;i++){\n\t\tq=(p+hash(float(i))*500.)*a;\n\t\tq+=sin(q*1.7)*2.;\n\t\tq=sin(q);\n\t\tac+=q.x*q.y*q.z/a*.07;\n\t\ta*=2.;\n\t}\n\th=hash(h);\n\tlightTime=time+h*pi2;\n\td=mix(d1,d2,smoothstep(-.5,.5,sin(lightTime)));\n\td+=ac;\n\t\n\tfloat df=p.y-floorHeight;\n\td=min(d,df);\n\td=mix(d,df,smoothstep(-.2,.2,-sin(time*.3)));\n\t\n\treturn d;\n}\n\nvec3 calcN(vec3 p){\n\tvec2 e=vec2(.001,0);\n\treturn normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n\t\t\t      map(p+e.yxy)-map(p-e.yxy),\n\t\t\t      map(p+e.yyx)-map(p-e.yyx)\n\t\t\t      ));\n}\n\nvec3 getC(vec3 p){\n\tvec3 col=vec3(0);\n\tif(p.y>floorHeight+.01){\n\t\tcol+=vec3(.9,.7,.3);\t\t\n\t\treturn col;\n\t}\n\t\n\tvec2 q=p.zx*5.;\n\tfloat h=hash21(floor(q)*1.1523);\n\tq=fract(q)-.5;\n\t\n\tvec3 c1=vec3(0);\n\tvec2 q1=q;\n\tX(c1)\n\t\t\n\tvec3 c2=vec3(0);\n\tq=q1;\n\th=hash(h);\n\tX(c2);\n\t\n\tcol=mix(c1,c2,smoothstep(-.5,.5,sin(lightTime)));\n\t\n\tq=p.zx*.5;\n\tq=fract(q)-.5;\n\tif(q.x*q.y>0.){\n\t\tcol=1.-col;\n\t}\n\tcol=clamp(col,.05,.95);\n\tfloat red=smoothstep(.51,.49,abs(sin(lightTime)));\n\tcol+=vec3(1,0,0)*red*100.;\n\t\n\treturn col;\n}\n\nfloat shadow(vec3 rp,vec3 rd){\n\tfloat d;\n\tfloat h=.001;\n\tfloat res=1.;\n\tfloat c=.2;\n\tfor(int i=0;i<30;i++){\n\t\td=map(rp+rd*h);\n\t\tif(d<.001){\n\t\t\treturn c;\n\t\t}\n\t\tres=min(res,16.*d/h);\n\t\th+=d;\n\t}\n\treturn mix(c,1.,res);\n}\n\nfloat fs(float f0,float c){\n\treturn f0+(1.-f0)*pow(1.-c,5.);\n}\n\nvec3 march(inout vec3 rp,inout vec3 rd,inout bool hit,inout vec3 ra,int itr){\n\tvec3 col=vec3(0);\n\tfloat t=0.;\n\thit=false;\n\t\n\tfor(int i=0;i<100;i++){\n\t\tif(i>=itr||t>30.){\n\t\t\tbreak;\n\t\t}\n\t\tfloat d=map(rp+rd*t);\n\t\tif(abs(d)<.0001){\n\t\t\thit=true;\n\t\t\tbreak;\n\t\t}\n\t\tt+=d*.9;\n\t}\n\trp+=rd*t;\n\t\n\tvec3 ld=normalize(vec3(-3,3,-1));\n\tvec3 al=getC(rp);\n\tvec3 n=calcN(rp);\n\tvec3 ref=reflect(rd,n);\n\tfloat diff=max(dot(ld,n),0.);\n\tfloat spec=pow(max(dot(reflect(ld,n),rd),0.),20.);\n\tfloat fog=exp(-t*t*.005);\n\tfloat sh=shadow(rp+.01*n,ld);\n\tfloat f0=0.8;\n\tfloat lp=10.;\n\tfloat m=0.9;\n\tcol+=al*diff*sh*(1.-m)*lp;\n\tcol+=al*spec*sh*m*lp;\n\tcol=mix(vec3(1),col,fog);\n\t\n\tcol*=ra;\n\tra*=al*fs(f0,dot(ref,n))*fog;\n\t\n\trp+=.01*n;\n\trd=ref;\n\t\n\treturn col;\n}\n\nvec3 acesFilm(vec3 x) {\n\tconst float a = 2.51;\n\tconst float b = 0.03;\n\tconst float c = 2.43;\n\tconst float d = 0.59;\n\tconst float e = 0.14;\n\treturn clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0., 1.);\n}\n\n#define ihash(x,n) floor(hash(x)*float(n))\nfloat in1d(float x,int n){\n  float i=floor(x);\n  float s=.1;\n  float u=smoothstep(.5-s,.5+s,fract(x));\n  return mix(ihash(i,n),ihash(i+1.,n),u);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=(gl_FragCoord.xy*2.-resolution)/min(resolution.x,resolution.y);\n\tvec3 col=vec3(0);\n\t\n\tvec3 cp=vec3(0,1.,-time);\n\tvec3 rd=normalize(vec3(uv,-2.+dot(uv,uv)*.3));\n\t\n\tcp.x+=in1d(cp.z*.33-550.5,10);\n\tcp.y+=in1d(cp.z*.39-61.,5);\n\t\n\trot3d(rd,cp.y*.3,vec3(1,0,0));\n\t\n\tvec3 rp=cp;\n\tvec3 ra=vec3(1);\n\tbool hit=false;\n\tcol+=march(rp,rd,hit,ra,100);\n\tif(hit){\n\t\tcol+=march(rp,rd,hit,ra,30);\n\t}\n\tif(hit){\n\t\tcol+=march(rp,rd,hit,ra,30);\n\t}\n\t\n\tcol=acesFilm(col);\n\tcol=pow(col,vec3(1./2.2));\n\t\n\tgl_FragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 423, 444, 444, 490], [492, 492, 533, 533, 604], [606, 606, 624, 624, 676], [752, 752, 770, 770, 1542], [1544, 1544, 1563, 1563, 1721], [1723, 1723, 1741, 1741, 2223], [2225, 2225, 2255, 2255, 2441], [2443, 2443, 2470, 2470, 2505], [2507, 2507, 2584, 2584, 3232], [3234, 3234, 3257, 3257, 3440], [3485, 3485, 3511, 3511, 3631], [3633, 3633, 3689, 3689, 4207]]}
{"id": "NltSW8", "name": "for loop 1", "author": "cghow", "description": "practice of for loop", "tags": ["forloop"], "likes": 1, "viewed": 17, "published": "Public", "date": "1639022343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"for loop\" by cghow. https://shadertoy.com/view/7lcXDH\n// 2021-12-09 03:51:48\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nuv -= .5;\nuv.x*= iResolution.x/iResolution.y;\n//uv*= uv.x*10.;\nvec3 col1 = vec3(0);\nfor(float i=0.; i<.5; i+=.01){\nuv.x+= clamp(sin(2.*iTime*.01)*.1,-.5,.5)*.15;\nuv.y+= clamp(cos(iTime+i*5.)*.1,-.5,.5)*.15;\nfloat d = length(uv);\nfloat s = step(d,i)*.01;\ncol1+=s;\n}\nvec3 col2 = vec3(0);\nfor(float i=0.; i<.5; i+=.01){\nuv.x-= clamp(sin(2.*iTime*.01)*.1,-.5,.5)*.15;\nuv.y-= clamp(cos(iTime+i*5.)*.1,-.5,.5)*.15;\nfloat d = length(uv);\nfloat s = step(d,i-.02)*.01;\ncol2+=s;\n}\nvec3 color = vec3(sin(iTime),cos(iTime*.9),sin(iTime*.8));\nvec3 col = col1+col2;\ncol = smoothstep(.0,5.,col)*10.;\ncol*=color;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 149, 199, 870]]}
{"id": "NltXzr", "name": "Voxel Cube", "author": "akohdr", "description": "Dropped out of recent extended round of golf: https://www.shadertoy.com/view/ftcXz  \nInteresting bit for me was building matrix transform from derivative components (sin, cos, -sin)\n", "tags": ["voxel"], "likes": 5, "viewed": 91, "published": "Public", "date": "1638628745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 o, vec2 F) \n{\n     float d = 0., e, \n           t = iMouse.z>0. ? iMouse.y*.003 : 2.2*sin(iTime); // osc or mouse rotate\n     \n     vec3 p = iResolution, c,\n          g = vec3((F-vec2(.47,.5)*p.xy) / p.y , 1),    // center coord\n          u = vec3(-2.57,-1,.57),                       // phase offsets\n          s = cos(t+u)         //  effectively derivatives (sin, cos, -sin)\n              *u.zyz; \n       \n          u = s.yxz;\n          u -= (1.+s.y) / 3.;\n  \n    mat3  R = mat3(u.xzy, \n                   u.yxz,\n                   u.zyx)\n              +.02;             // fixes irritating disconnected corner voxel\n                   \n    p = (40./p)*R;              // ray cast starting point\n    \n    for(int i=8; i < 700; i+=8) {\n    \n//        u = floor(p) + vec3(bvec3(i&1,i&2,i&4));  // optimizes out with stride +=8\n        u = floor(p);\n        c = abs( u * R);\n\n        e = .5;\n//        if(all(lessThan(c,vec3(9))))\n        if(!any(greaterThan(c,vec3(9))))\n        {\n            c = abs( p - u);\n            e = max(max(c.x,c.y),c.z) - .8;\n        }\n        \n        d = min(d, e);\n\n//        if(i%8<1)                                 // again optimizes out stride +=8\n          p -= d++ * g * R;\n    }\n    \n    o = vec4(abs(R * p).z);\n    o *= vec4(6,8,4,0)/1e2;                         // add little colour\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltXzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 128, 165, 165, 1477]]}
{"id": "NlV3Dt", "name": "DoF shadows ( fake 3D )", "author": "FabriceNeyret2", "description": "blurry shadow of a spring (fake 3D)\n\nmouse controls camera.", "tags": ["dof", "shadows", "depthoffield", "fake3d", "short"], "likes": 29, "viewed": 242, "published": "Public API", "date": "1638549098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n#define P       vec3(cos(t),sin(t),.2*t)           // helicoid\n#define proj(P) P * mat2x3(cos(a),0,-sin(a),0,1,0) // projection\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float d = 9.,z,_z,Z=1.1, t, l,_l, \n          a = length(iMouse.xy)>10. ? 6.3*iMouse.x/iResolution.x : iTime;\n    vec3 p = vec3(sin(a),0,cos(a));\n    vec2 R = iResolution.xy, B, A, \n         U = ( 3.*u - R ) / R.y -.4;\n    O-=O;     \n    Z = 99.;   // --- compute dist to wall. analytic estimate instead ?\n    for( t = -8.; t < 8.; t+=.02) Z = min(Z,dot(p,P));\n    Z = -Z + .05;\n    for( t=-8.,A = proj(P); t < 8.; t+=.02) { // --- draw shadow projection\n        B = A, A = proj(P);\n        z = ( Z + dot(p,P) )/9.; \n        l = line(U,B,A);\n   //  _l = line(U-.2,B,A); if ( _l < d ) d=_l, _z=z; // if draw shape\n        l /= z;// O = max(O,  .2*exp(-.5*l*l) / sqrt(6.28*z*z) );\n                  O += .006 * exp(-.5*l*l) / sqrt(6.28*z*z);\n    }\n\n    O = 1.-O;\n  //O = mix( clamp(O,0.,1.), vec4(0,cos(50.*d),0,0), smoothstep(5./R.y,0.,d-.02) ); // show shape\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlV3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 140], [271, 271, 309, 309, 1173]]}
{"id": "NlyGDK", "name": "SH lighting*visibility", "author": "tepSHATOY", "description": "SH lighting multiply with visibility", "tags": ["lighting", "spherical", "harmonics", "sh", "visibility", "zh"], "likes": 2, "viewed": 29, "published": "Public", "date": "1638353158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Experiment with SH product\n\n///////////////////////////////////////////////////////////////////////\n// Constants\n///////////////////////////////////////////////////////////////////////\nconst float kInf        = 1e16f; // some random max distance..\nconst float kPi         = 3.14159265358979323846264338327950288;\nconst vec3  kWorldUp    = vec3(0.0, 1.0, 0.0);\n\nconst int kGeomType_Sphere = 0;\nconst int kGeomType_Cylinder = 1;\n\n///////////////////////////////////////////////////////////////////////\n// Types\n///////////////////////////////////////////////////////////////////////\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n\tvec3  center;\n\tfloat radius;\n};\n\nstruct Cylinder\n{\n    vec3 a;\n    vec3 b;\n    float radius;\n};\n\nstruct HitRecord\n{\n    int geomType;\n    vec3 p;\n    vec3 t;\n    vec3 b;\n    vec3 n;\n};\n\nstruct Scene\n{\n    Sphere sphere;\n    Cylinder cylinder;\n};\n\n///////////////////////////////////////////////////////////////////////\n// Utils\n///////////////////////////////////////////////////////////////////////\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 LinearToGammaSrgb( vec3 linColor )\n{    \n\tlinColor.r = ( linColor.r <= 0.0031308 ) ? ( 12.92 * linColor.r ) : ( 1.055 * pow( linColor.r, 1.0f/2.4 ) - 0.055 );\n    linColor.g = ( linColor.g <= 0.0031308 ) ? ( 12.92 * linColor.g ) : ( 1.055 * pow( linColor.g, 1.0f/2.4 ) - 0.055 );\n\tlinColor.b = ( linColor.b <= 0.0031308 ) ? ( 12.92 * linColor.b ) : ( 1.055 * pow( linColor.b, 1.0f/2.4 ) - 0.055 );\n    return linColor;\n}\n\n// rotate z to d\n// https://www.iquilezles.org/www/articles/noacos/noacos.htm\nmat3x3 rotationAlign( vec3 d, vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = (1.0f-c)/(1.0001f-c*c);\n\n    return mat3x3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n///////////////////////////////////////////////////////////////////////\n// Intersection\n///////////////////////////////////////////////////////////////////////\nfloat RaySphereIntersect(Ray r, Sphere sphere, float tmin)\n{\n    vec3 oc = r.origin - sphere.center;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(oc, r.dir);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n    float discriminant = b * b - 4.0 * a*c;\n\n    if (discriminant > 0.0)\n    {\n        float t = (-b - sqrt(discriminant)) / (2.0 * a);\n        if (tmin < t)\n            return t;\n    }    \n    return -1.0;\n}\n\n// cylinder defined by extremes pa and pb, and radious ra\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\n///////////////////////////////////////////////////////////////////////\n// SH Math (Z-Up)\n///////////////////////////////////////////////////////////////////////\nstruct SH3\n{\n    float data[9];\n};\n\nstruct SH3Color\n{\n    SH3 r;\n    SH3 g;\n    SH3 b;\n};\n\nvoid SH3Scale(inout SH3 sh, float scale)\n{\n    for (int i=0; i<9; i++)\n        sh.data[i] *= scale;       \n}\n\nfloat SH3Dot(SH3 coeffs, SH3 dir)\n{\n    float result = 0.0;\n    for( int i = 0; i < 9; i++ )\n        result += coeffs.data[i] * dir.data[i];\n    return result;\n}\n\nSH3 SH3Evaluate(vec3 xyz)\n{\n    SH3 result;\n    float fX = xyz.x;\n    float fY = xyz.y;\n    float fZ = xyz.z;\n    \n\tfloat fC0, fC1, fS0, fS1, fTmpA, fTmpB, fTmpC;\n\tfloat fZ2 = fZ * fZ;\n\n\tresult.data[0] = 0.2820947917738781;\n\tresult.data[2] = 0.4886025119029199 * fZ;\n\tresult.data[6] = 0.9461746957575601 * fZ2 + -0.3153915652525201;\n\tfC0 = fX;\n\tfS0 = fY;\n\n\tfTmpA = -0.48860251190292;\n\tresult.data[3] = fTmpA * fC0;\n\tresult.data[1] = fTmpA * fS0;\n\tfTmpB = -1.092548430592079 * fZ;\n\tresult.data[7] = fTmpB * fC0;\n\tresult.data[5] = fTmpB * fS0;\n\tfC1 = fX * fC0 - fY * fS0;\n\tfS1 = fX * fS0 + fY * fC0;\n\n\tfTmpC = 0.5462742152960395;\n\tresult.data[8] = fTmpC * fC1;\n\tresult.data[4] = fTmpC * fS1;\n    \n    return result;\n}\n\nvec3 toSHSpace(vec3 dir)\n{\n    return dir.xzy;\n}\n\nvec3 fromSHSpace(vec3 dir)\n{\n    return dir.xzy;\n}\n\nSH3 SH3ProjectCone(float alpha)\n{\n    float cosAlpha = cos(alpha);\n    float sinAlpha = sin(alpha);\n    float sinAlphaSqr = sqr(sinAlpha);\n    \n    SH3 sh;\n    \n    // DC\n    sh.data[0] = 1.77245 * (1.0 - cosAlpha);    \n    // Linear\n    sh.data[1] = 0.0;\n    sh.data[2] = 1.53499 * sinAlphaSqr;\n    sh.data[3] = 0.0;\n    // Quadratic\n    sh.data[4] = 0.0;\n    sh.data[5] = 0.0;\n    sh.data[6] = 1.98166 * cosAlpha * sinAlphaSqr;\n    sh.data[7] = 0.0;\n    sh.data[8] = 0.0;\n    return sh;\n}\n\nSH3 SH3ProjectSmoothCone(float alpha)\n{\n    alpha = max(alpha, radians(0.5));\n    \n    float alpha3 = alpha*alpha*alpha;\n    float sinAlpha = sin(alpha);\n    float cosAlpha = cos(alpha);\n    float cosAlpha2 = cosAlpha * cosAlpha;\n    float cosAlpha3 = cosAlpha2 * cosAlpha;\n    \n    SH3 sh;\n    // DC\n    sh.data[0] = ((alpha3 + 6.0 * alpha - 12.0 * sinAlpha + 6.0 * alpha * cosAlpha) * 1.77245) / alpha3;\n    // Linear\n    sh.data[1] = 0.0;\n    sh.data[2] = ((alpha3 - 3.0 * cosAlpha * sinAlpha + 3.0 * alpha * cosAlpha2) * 3.06998) / (4.0 * alpha3);\n    sh.data[3] = 0.0;\n    // Quadractic\n    sh.data[4] = 0.0;\n    sh.data[5] = 0.0;\n    sh.data[6] = ((-6.0*alpha - 2.0*cosAlpha2*sinAlpha - 9.0*alpha*cosAlpha + 14.0*sinAlpha + 3.0*alpha*cosAlpha3) * 3.96333) / (9.0 * alpha3);\n    sh.data[7] = 0.0;\n    sh.data[8] = 0.0;\n    return sh;\n}\n\n// Performs the SH triple product r = a * b\n// From John Snyder (appendix A8)\n//\nSH3 SH3Product(SH3 a, SH3 b)\n{\n    SH3 r;\n\n    float  ta, tb, t;\n\n    const float C0 = 0.282094792935999980;\n    const float C1 = -0.126156626101000010;\n    const float C2 = 0.218509686119999990;\n    const float C3 = 0.252313259986999990;\n    const float C4 = 0.180223751576000010;\n    const float C5 = 0.156078347226000000;\n    const float C6 = 0.090111875786499998;\n\n    // [0,0]: 0,\n    r.data[0] = C0*a.data[0]*b.data[0];\n\n    // [1,1]: 0,6,8,\n    ta = C0*a.data[0]+C1*a.data[6]-C2*a.data[8];\n    tb = C0*b.data[0]+C1*b.data[6]-C2*b.data[8];\n    r.data[1] = ta*b.data[1]+tb*a.data[1];\n    t = a.data[1]*b.data[1];\n    r.data[0] += C0*t;\n    r.data[6] = C1*t;\n    r.data[8] = -C2*t;\n\n    // [1,2]: 5,\n    ta = C2*a.data[5];\n    tb = C2*b.data[5];\n    r.data[1] += ta*b.data[2]+tb*a.data[2];\n    r.data[2] = ta*b.data[1]+tb*a.data[1];\n    t = a.data[1]*b.data[2]+a.data[2]*b.data[1];\n    r.data[5] = C2*t;\n\n    // [1,3]: 4,\n    ta = C2*a.data[4];\n    tb = C2*b.data[4];\n    r.data[1] += ta*b.data[3]+tb*a.data[3];\n    r.data[3] = ta*b.data[1]+tb*a.data[1];\n    t = a.data[1]*b.data[3]+a.data[3]*b.data[1];\n    r.data[4] = C2*t;\n\n    // [2,2]: 0,6,\n    ta = C0*a.data[0]+C3*a.data[6];\n    tb = C0*b.data[0]+C3*b.data[6];\n    r.data[2] += ta*b.data[2]+tb*a.data[2];\n    t = a.data[2]*b.data[2];\n    r.data[0] += C0*t;\n    r.data[6] += C3*t;\n\n    // [2,3]: 7,\n    ta = C2*a.data[7];\n    tb = C2*b.data[7];\n    r.data[2] += ta*b.data[3]+tb*a.data[3];\n    r.data[3] += ta*b.data[2]+tb*a.data[2];\n    t = a.data[2]*b.data[3]+a.data[3]*b.data[2];\n    r.data[7] = C2*t;\n\n    // [3,3]: 0,6,8,\n    ta = C0*a.data[0]+C1*a.data[6]+C2*a.data[8];\n    tb = C0*b.data[0]+C1*b.data[6]+C2*b.data[8];\n    r.data[3] += ta*b.data[3]+tb*a.data[3];\n    t = a.data[3]*b.data[3];\n    r.data[0] += C0*t;\n    r.data[6] += C1*t;\n    r.data[8] += C2*t;\n\n    // [4,4]: 0,6,\n    ta = C0*a.data[0]-C4*a.data[6];\n    tb = C0*b.data[0]-C4*b.data[6];\n    r.data[4] += ta*b.data[4]+tb*a.data[4];\n    t = a.data[4]*b.data[4];\n    r.data[0] += C0*t;\n    r.data[6] -= C4*t;\n\n    // [4,5]: 7,\n    ta = C5*a.data[7];\n    tb = C5*b.data[7];\n    r.data[4] += ta*b.data[5]+tb*a.data[5];\n    r.data[5] += ta*b.data[4]+tb*a.data[4];\n    t = a.data[4]*b.data[5]+a.data[5]*b.data[4];\n    r.data[7] += C5*t;\n\n    // [5,5]: 0,6,8,\n    ta = C0*a.data[0]+C6*a.data[6]-C5*a.data[8];\n    tb = C0*b.data[0]+C6*b.data[6]-C5*b.data[8];\n    r.data[5] += ta*b.data[5]+tb*a.data[5];\n    t = a.data[5]*b.data[5];\n    r.data[0] += C0*t;\n    r.data[6] += C6*t;\n    r.data[8] -= C5*t;\n\n    // [6,6]: 0,6,\n    ta = C0*a.data[0];\n    tb = C0*b.data[0];\n    r.data[6] += ta*b.data[6]+tb*a.data[6];\n    t = a.data[6]*b.data[6];\n    r.data[0] += C0*t;\n    r.data[6] += C4*t;\n\n    // [7,7]: 0,6,8,\n    ta = C0*a.data[0]+C6*a.data[6]+C5*a.data[8];\n    tb = C0*b.data[0]+C6*b.data[6]+C5*b.data[8];\n    r.data[7] += ta*b.data[7]+tb*a.data[7];\n    t = a.data[7]*b.data[7];\n    r.data[0] += C0*t;\n    r.data[6] += C6*t;\n    r.data[8] += C5*t;\n\n    // [8,8]: 0,6,\n    ta = C0*a.data[0]-C4*a.data[6];\n    tb = C0*b.data[0]-C4*b.data[6];\n    r.data[8] += ta*b.data[8]+tb*a.data[8];\n    t = a.data[8]*b.data[8];\n    r.data[0] += C0*t;\n    r.data[6] -= C4*t;\n    // entry count=13\n    // **multiplications count=120**\n    // **addition count=74**\n    return r;\n}\n\n// http://filmicworlds.com/blog/simple-and-fast-spherical-harmonic-rotation/\nSH3 SH3Rotate(SH3 src, mat3x3 mat)\n{\n\tfloat m00 = mat[0][0];\n\tfloat m01 = mat[0][1];\n\tfloat m02 = mat[0][2];\n\tfloat m10 = mat[1][0];\n\tfloat m11 = mat[1][1];\n\tfloat m12 = mat[1][2];\n\tfloat m20 = mat[2][0];\n\tfloat m21 = mat[2][1];\n\tfloat m22 = mat[2][2];\n\n\tconst float s_c3 = 0.94617469575; // (3*sqrt(5))/(4*sqrt(pi))\n\tconst float s_c4 = -0.31539156525;// (-sqrt(5))/(4*sqrt(pi))\n\tconst float s_c5 = 0.54627421529; // (sqrt(15))/(4*sqrt(pi))\n\n\tconst float s_c_scale = 1.0/0.91529123286551084;\n\tconst float s_c_scale_inv = 0.91529123286551084;\n\n\tconst float s_rc2 = 1.5853309190550713*s_c_scale;\n\tconst float s_c4_div_c3 = s_c4/s_c3;\n\tconst float s_c4_div_c3_x2 = (s_c4/s_c3)*2.0;\n\n\tconst float s_scale_dst2 = s_c3 * s_c_scale_inv;\n\tconst float s_scale_dst4 = s_c5 * s_c_scale_inv;\n\n\tSH3 dst;\n\n\tdst.data[0] = src.data[0];\n\n\t// 9 multiplies\n\tdst.data[1] = ( m11) * src.data[1] + (-m12) * src.data[2] + ( m10) * src.data[3];\n\tdst.data[2] = (-m21) * src.data[1] + ( m22) * src.data[2] + (-m20) * src.data[3];\n\tdst.data[3] = ( m01) * src.data[1] + (-m02) * src.data[2] + ( m00) * src.data[3];\n\n\t// 48 multiplies\n\t// Sparse matrix multiply\n\tfloat sh0 =  src.data[4+3] + src.data[4+4] + src.data[4+4] - src.data[4+1];\n\tfloat sh1 =  src.data[4+0] + s_rc2*src.data[4+2] +  src.data[4+3] + src.data[4+4];\n\tfloat sh2 =  src.data[4+0];\n\tfloat sh3 = -src.data[4+3];\n\tfloat sh4 = -src.data[4+1];\n\n\t// Rotations.  R0 and R1 just use the raw matrix columns\n\tfloat r2x = m00 + m01;\n\tfloat r2y = m10 + m11;\n\tfloat r2z = m20 + m21;\n\n\tfloat r3x = m00 + m02;\n\tfloat r3y = m10 + m12;\n\tfloat r3z = m20 + m22;\n\n\tfloat r4x = m01 + m02;\n\tfloat r4y = m11 + m12;\n\tfloat r4z = m21 + m22;\n\n\t// dense matrix multiplication one column at a time\n\t\n\t// column 0\n\tfloat sh0_x = sh0 * m00;\n\tfloat sh0_y = sh0 * m10;\n\tfloat d0 = sh0_x * m10;\n\tfloat d1 = sh0_y * m20;\n\tfloat d2 = sh0 * (m20 * m20 + s_c4_div_c3);\n\tfloat d3 = sh0_x * m20;\n\tfloat d4 = sh0_x * m00 - sh0_y * m10;\n\t\n\t// column 1\n\tfloat sh1_x = sh1 * m02;\n\tfloat sh1_y = sh1 * m12;\n\td0 += sh1_x * m12;\n\td1 += sh1_y * m22;\n\td2 += sh1 * (m22 * m22 + s_c4_div_c3);\n\td3 += sh1_x * m22;\n\td4 += sh1_x * m02 - sh1_y * m12;\n\t\n\t// column 2\n\tfloat sh2_x = sh2 * r2x;\n\tfloat sh2_y = sh2 * r2y;\n\td0 += sh2_x * r2y;\n\td1 += sh2_y * r2z;\n\td2 += sh2 * (r2z * r2z + s_c4_div_c3_x2);\n\td3 += sh2_x * r2z;\n\td4 += sh2_x * r2x - sh2_y * r2y;\n\n\t// column 3\n\tfloat sh3_x = sh3 * r3x;\n\tfloat sh3_y = sh3 * r3y;\n\td0 += sh3_x * r3y;\n\td1 += sh3_y * r3z;\n\td2 += sh3 * (r3z * r3z + s_c4_div_c3_x2);\n\td3 += sh3_x * r3z;\n\td4 += sh3_x * r3x - sh3_y * r3y;\n\n\t// column 4\n\tfloat sh4_x = sh4 * r4x;\n\tfloat sh4_y = sh4 * r4y;\n\td0 += sh4_x * r4y;\n\td1 += sh4_y * r4z;\n\td2 += sh4 * (r4z * r4z + s_c4_div_c3_x2);\n\td3 += sh4_x * r4z;\n\td4 += sh4_x * r4x - sh4_y * r4y;\n\n\t// extra multipliers\n\tdst.data[4+0] = d0;\n\tdst.data[4+1] = -d1;\n\tdst.data[4+2] = d2 * s_scale_dst2;\n\tdst.data[4+3] = -d3;\n\tdst.data[4+4] = d4 * s_scale_dst4;\n\n\treturn dst;\n}\n\nSH3 ScaleSHBands(SH3 sh, float dcScale, float linearScale, float quadraticScale)\n{\n    SH3 result = sh;\n    \n    result.data[0] *= dcScale;\n    \n    result.data[1] *= linearScale;\n    result.data[2] *= linearScale;\n    result.data[3] *= linearScale;\n    \n    result.data[4] *= quadraticScale;\n    result.data[5] *= quadraticScale;\n    result.data[6] *= quadraticScale;\n    result.data[7] *= quadraticScale;\n    result.data[8] *= quadraticScale;\n    \n    return result;\n}\n\nSH3 RotateZH(SH3 sh, vec3 d)\n{    \n    float dcScale = sh.data[0] * 3.54491;\n    float linearScale = sh.data[2] * 2.04665;\n    float quadraticScale = sh.data[6] * 1.58533;\n    \n    return ScaleSHBands(SH3Evaluate(d), dcScale, linearScale, quadraticScale);\n}\n\nSH3 ConvolveCos(SH3 sh)\n{\n    float dcScale = 1.0 * kPi;\n    float linearScale = 2.0 / 3.0 * kPi;\n    float quadraticScale = 1.0 / 4.0 * kPi;\n    return ScaleSHBands(sh, dcScale, linearScale, quadraticScale);\n}\n\nSH3Color ConvolveCos(SH3Color sh)\n{\n    float dcScale = 1.0 * kPi;\n    float linearScale = 2.0 / 3.0 * kPi;\n    float quadraticScale = 1.0 / 4.0 * kPi;\n    \n    SH3Color result;\n    result.r = ScaleSHBands(sh.r, dcScale, linearScale, quadraticScale);\n    result.g = ScaleSHBands(sh.g, dcScale, linearScale, quadraticScale);    \n    result.b = ScaleSHBands(sh.b, dcScale, linearScale, quadraticScale);\n    return result;\n}\n\nSH3Color GetRadianceSH()\n{\n    SH3Color shColor;\n    \n    shColor.r.data[0] = 0.22351;\n    shColor.r.data[1] = 0.00609654;\n    shColor.r.data[2] = -0.146317;\n    shColor.r.data[3] = 0.0640137;\n    shColor.r.data[4] = 0.0;\n    shColor.r.data[5] = 0.0039353;\n    shColor.r.data[6] = 0.0078706;\n    shColor.r.data[7] = -0.0157412;\n    shColor.r.data[8] = -0.0039353;\n\n    shColor.g.data[0] = 0.13647;\n    shColor.g.data[1] = 0.00372241;\n    shColor.g.data[2] = -0.0781706;\n    shColor.g.data[3] = 0.0297793;\n    shColor.g.data[4] = 0.00480561;\n    shColor.g.data[5] = -0.00720841;\n    shColor.g.data[6] = 0.0024028;\n    shColor.g.data[7] = -0.00720841;\n    shColor.g.data[8] = -0.00961121;\n\n    shColor.b.data[0] = 0.17163;\n    shColor.b.data[1] = 0.00234072;\n    shColor.b.data[2] = -0.0936289;\n    shColor.b.data[3] = 0.0374516;\n    shColor.b.data[4] = 0.00604372;\n    shColor.b.data[5] = -0.00906558;\n    shColor.b.data[6] = 0.00302186;\n    shColor.b.data[7] = -0.00906558;\n    shColor.b.data[8] = -0.0120874;    \n    \n    return shColor;\n}\n\n///////////////////////////////////////////////////////////////////////\n// Scene\n///////////////////////////////////////////////////////////////////////\nvec3 GetBentCone()\n{\n    // define this in SH space\n    float theta = iTime * 0.2;//(sin(iTime * 0.1) * 0.5 + 0.5) * kPi;\n    float phi = -iTime * 1.5; //sqr(cos(iTime * 0.5)) * kPi;\n    \n    vec3 dir;\n    dir.x = sin(theta) * cos(phi);\n    dir.y = sin(theta) * sin(phi);\n    dir.z = cos(theta);\n    \n    return dir;\n/*\n    return normalize(vec3((sin(iTime)*0.5 + 0.5)*2.0, 0, 1));\n*/\n}\n\nScene Scene_Setup()\n{\n    vec3 objCenter = vec3(0, 2, 0);\n    Scene scene;\n\n    scene.sphere.center = objCenter;\n\tscene.sphere.radius = 1.3;\n\n    // bent cone dir\n    vec3 bentConeDir = GetBentCone();\n    float bentConeLength = 1.8;\n    \n    scene.cylinder.a = objCenter;\n    scene.cylinder.b = scene.cylinder.a + bentConeDir * bentConeLength;\n    scene.cylinder.radius = 0.05;   \n    \n    return scene;\n}\n\nbool Scene_RayTrace(Scene scene, Ray r, inout HitRecord hitRecord)\n{\n    float xmin = kInf;\n    \n    // for each Sphere s\n\tSphere s = scene.sphere;\n    {\n        float x = RaySphereIntersect(r, s, 0.0);\n        if (x > 0.0 && x < xmin)\n        {\n            xmin = x;\n            \n            vec3 p = r.origin + x * r.dir;\n            vec3 n = normalize(p - s.center);\n            vec3 t = normalize(cross(kWorldUp, n));\n            vec3 b = normalize(cross(n, t));\n            n = normalize(cross(t, b));\n            hitRecord.geomType = kGeomType_Sphere;\n            hitRecord.p = p;\n            hitRecord.t = t;\n            hitRecord.b = b;\n            hitRecord.n = n;\n        }\n    }\n    \n    // for each Cylinder c\n    Cylinder c = scene.cylinder;\n    {                \n        vec4 cylResult = cylIntersect(r.origin, r.dir, c.a, c.b, c.radius);\n        if (cylResult.x > 0.0 && cylResult.x < xmin)\n        {\n            xmin = cylResult.x;\n        \n            vec3 p = r.origin + xmin * r.dir;\n            hitRecord.geomType = kGeomType_Cylinder;\n            hitRecord.p = p;\n        }    \n    }\n    \n    \n    return (xmin < kInf);\n}\n\n///////////////////////////////////////////////////////////////////////\n// Closest Hit Shader\n///////////////////////////////////////////////////////////////////////\nvec3 ClosestHit(HitRecord hitRecord, Scene scene)\n{\n    // bent cone dir visualization\n    if (hitRecord.geomType == kGeomType_Cylinder)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    \n    vec3 n = hitRecord.n;\n    \n    SH3 dirEval = SH3Evaluate(n);\n    \n    vec3 bentConeDir = GetBentCone();\n    \n    // visibility\n    float alpha = radians(60.0);//(cos(iTime) * 0.5 + 0.5) * kPi;// * 0.5;\n    SH3 shVis = SH3ProjectCone(alpha);    \n    //SH3 shVis = ProjectSmoothCone(alpha);\n    \n    // rotate visibility to direction of bentCone\n    shVis = RotateZH(shVis, bentConeDir);\n    //shVis = SH3Rotate(shVis, rotationAlign(bentConeDir, vec3(0,0,1)));\n\n    // radiance    \n    SH3Color shRadiance = GetRadianceSH();\n    \n    SH3Color shMaskedRadiance;\n    shMaskedRadiance.r = SH3Product(shRadiance.r, shVis);\n    shMaskedRadiance.g = SH3Product(shRadiance.g, shVis);\n    shMaskedRadiance.b = SH3Product(shRadiance.b, shVis);\n    \n    // irradiance\n    SH3Color shIrrad = ConvolveCos(shMaskedRadiance);        \n    \n    vec3 result;\n    result.r = max(SH3Dot(dirEval, shIrrad.r), 0.0);\n    result.g = max(SH3Dot(dirEval, shIrrad.g), 0.0);\n    result.b = max(SH3Dot(dirEval, shIrrad.b), 0.0);\n    \n    return result;\n}\n\nRay Ray_Setup(vec2 screenCoord)\n{\n\tvec2 uv = screenCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n        \n    Ray r;\n    r.origin = vec3(0.0);\n    r.dir = toSHSpace(normalize(vec3(uv.x, uv.y, 1.0))); // this is in SH space\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray r = Ray_Setup(fragCoord);       \n\n    Scene scene = Scene_Setup();\n\n    // default is sky color\n    vec3 radiance = vec3(0.392, 0.584, 0.929);\n    \n    HitRecord hitRecord;\n    if (Scene_RayTrace(scene, r, hitRecord))\n    {        \n\t\tradiance = ClosestHit(hitRecord, scene);\n        \n        // so we can see better\n        //radiance *= 3.0;\n\t}\n    \n    fragColor.rgb = LinearToGammaSrgb(radiance);\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[896, 1049, 1069, 1069, 1087], [1089, 1089, 1114, 1114, 1147], [1149, 1149, 1190, 1190, 1574], [1576, 1654, 1694, 1694, 2019], [2021, 2181, 2241, 2241, 2616], [2618, 2676, 2755, 2755, 3402], [3404, 3657, 3699, 3699, 3765], [3767, 3767, 3802, 3802, 3928], [3930, 3930, 3957, 3957, 4645], [4647, 4647, 4673, 4673, 4695], [4697, 4697, 4725, 4725, 4747], [4749, 4749, 4782, 4782, 5239], [5241, 5241, 5280, 5280, 6081], [6083, 6164, 6194, 6194, 9448], [9450, 9527, 9563, 9563, 12451], [12453, 12453, 12535, 12535, 12923], [12925, 12925, 12955, 12955, 13182], [13184, 13184, 13209, 13209, 13394], [13396, 13396, 13431, 13431, 13817], [13819, 13819, 13845, 13845, 14859], [14861, 15014, 15034, 15065, 15400], [15402, 15402, 15423, 15423, 15807], [15809, 15809, 15877, 15877, 16951], [16953, 17119, 17170, 17205, 18337], [18339, 18339, 18372, 18372, 18610], [18612, 18612, 18667, 18667, 19100]]}
{"id": "NlyGWt", "name": "planet construction", "author": "wnu", "description": "form a planet ", "tags": ["rotation"], "likes": 6, "viewed": 60, "published": "Public", "date": "1638489013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvec2 rot(vec2 uv,float a,vec2 origin){\n    \n    vec2 p = (uv - origin);\n    \n    float c = cos(a);\n    float s = sin(a);\n    \n\treturn mat2(c,-s,s,c)*p + origin;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 2\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define NUM_OCTAVES2 2\n\nfloat fbms ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES2; ++i) {\n        v += a * snoise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= R.x/R.y;\n    \n    uv *= 2.*iTime/10.;\n    \n    float sc = 5.;\n    \n    //uv.x += iTime/10.;\n    \n    float ys = smoothstep(0.7,0.5,uv.y);\n    \n    float a = (fbm(uv*sc + vec2(0.,-iTime))*2. - 1.);\n    a = snoise(uv*2.+ vec2(0.,-iTime))/1.5;\n    a = (fbms(uv*sc));\n    \n    uv = rot(uv,a,vec2(uv - fbms(uv)));\n\n    float l = smoothstep(0.49,0.51,uv.y);\n    l = smoothstep(0.49,0.51,length(uv/iTime*10.));\n\n    vec3 col = vec3(l);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 63, 63, 187], [189, 189, 217, 217, 325], [327, 405, 432, 432, 814], [839, 839, 865, 865, 1202], [1204, 1204, 1225, 1225, 1272], [1273, 1273, 1294, 1294, 1341], [1342, 1342, 1364, 1364, 1399], [1401, 1401, 1423, 1476, 3173], [3199, 3199, 3226, 3226, 3565], [3567, 3567, 3624, 3674, 4257]]}
{"id": "NsVGWc", "name": "ball explosion", "author": "JennySchub", "description": "this has some 90s dancemusic CD logo vibes", "tags": ["circle"], "likes": 11, "viewed": 146, "published": "Public API", "date": "1639372001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592652\nfloat circle(vec2 uv, vec2 c, float r){\n    return smoothstep(r, r+2./iResolution.x, length(uv-c));\n}\n\nfloat unsmoothstep(float mn, float mx, float x) {\n    x-=mn;\n    x/=mx-mn;\n    return x + (x - (x * x * (3.0 - 2.0 * x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tim = -iTime*.1;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - .5);\n    uv.x*=iResolution.x/iResolution.y;\n\n    float angl = atan(uv.y, uv.x);\n    \n    float adir=-angl+PI*.5;\n    // -angl+PI*.5\n    \n    vec3 col = vec3(1.);\n    float iCount=12.;\n    for(float i=0.; i<iCount; i++){\n        float dir = floor(adir/(PI/3.)+.5)*(PI/3.);\n        \n        if(mod(i+.1, 2.)<.5){\n            // todo\n            dir = floor((adir-PI/6.)/(PI/3.)+.5)*(PI/3.) + PI/6.;\n        }\n        float timMod1 = mod(-tim+i*(1./iCount), 1.);\n        timMod1 = unsmoothstep(0.,.8,pow(smoothstep(0.,1.,timMod1),.8));\n        float circ = circle(\n            uv, \n            vec2(sin(dir)*timMod1, cos(dir)*timMod1), \n            cos(timMod1*6.-PI*.65)*.1\n        );\n        \n        col *= circ;\n        \n    \n    }\n    \n    col*=circle(uv, vec2(0.), sin(iTime)*.04+.038);\n    \n    // Output to screen\n    fragColor = vec4(col*-1.+1.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 62, 62, 124], [126, 126, 175, 175, 250], [252, 252, 309, 309, 1287]]}
{"id": "Nt3Szr", "name": "Weird guy on grass", "author": "makipl", "description": "I have no single idea what's going on here but whatever", "tags": ["fbm"], "likes": 3, "viewed": 37, "published": "Public", "date": "1638569272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAY_COUNT 32\n#define EPS 0.01\n#define time iTime\n\nfloat DrawGround(in vec3 ro, in vec3 rd)\n{\nfloat t=0.0;\nfor(int i = 0; i<RAY_COUNT;i++)\n{\nfloat h= length(ro+rd*t)-0.2;\nif(h< (EPS * t))\n    break;\nt+=h;\n}\nreturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.0,0.0,-0.5);\n    vec3 rd = vec3(uv, 2.0);\n    \n    float ground, cubeTest;\n    ground = DrawGround(ro,rd);\n    uv.y = 1.0-uv.y;\n    rd = vec3(uv, 1.0);\n    float ground2 = DrawGround(ro,rd);\n    vec3 col = texture(iChannel0,uv*4.0).xyz;\n    col = vec3(0.0,col.x*0.7,0.0);\n    col += vec3(0.0, texture(iChannel0,vec2(uv.x+sin(time)*.04,uv.y+cos(time)*.04)).x*abs(sin(time*0.2))*0.4,0.0);\n    col = min(col,vec3(ground-ground2));\n    uv.y = 0.9-uv.y;\n    rd=vec3(vec2(uv.x-0.2,uv.y),1.0);\n    col = max(vec3(step(length(ro+rd)-0.2,0.318)),col);\n    rd=vec3(vec2(uv.x-0.1-abs(sin(time)*0.19), uv.y-cos(time)*0.04),1.0);\n    col = min(vec3(step(1.0-length(ro+rd)-0.15,0.347)),col);\n    \nrd=vec3(vec2(uv.x+0.3,uv.y),1.0);\n     col = max(vec3(step(length(ro+rd)-0.2,0.318)),col);\n    rd=vec3(vec2(uv.x+0.4-abs(sin(time+0.5)*0.19), uv.y-cos(time)*0.04),1.0);\n    col = min(vec3(step(1.0-length(ro+rd)-0.15,0.347)),col);\n    rd=vec3(vec2(uv.x*0.65,uv.y*1.8+0.8),1.0);\n    col=max(vec3(step(length(ro+rd)-0.05,0.5)),col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3Szr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 100, 100, 225], [227, 227, 284, 284, 1438]]}
{"id": "NtcSRB", "name": "[TDF2021] Microbes Plaid", "author": "shiomusubi", "description": "Something like a microbes and a plaid.\nThis shader submitted to Tokyo Demo Fest 2021, GLSL Graphics Compo.", "tags": ["2d", "fbm", "tdf2021"], "likes": 1, "viewed": 16, "published": "Public", "date": "1639299043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n \n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n \n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n \n    vec2 u = f * f * (3.0 - 2.0 * f);\n \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n \n#define NUM_OCTAVES 5\n \nfloat fbm ( in vec2 _st) {\n    float v = 0.;\n    float a = .5;\n    vec2 shift = vec2(100.);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5),\n                    -sin(.5), cos(.5));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= .5;\n    }\n    return v;\n}\n \nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(123.,456.)),dot(p,vec2(789.,158.))))*12345.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n\t\n    vec3 color = vec3(0.0);\n    vec2 rand = random2(vec2(0.));\n    float zoom = sin(rand.x+iTime*.2);\n    st -= vec2(zoom);\n    st *= sin(iTime/8.)*10.;\n    \n   \n    mat2 rot = mat2(cos(iTime*.2+rand.x), sin(rand.y+iTime*.3),\n                    -sin(rand.y+iTime*.5), cos(rand.x+iTime*.4));\n    \n    st *= rot;\n    \n    vec2 gv = floor(st);\n    vec2 id = fract(st);\n    \n    float m_dist = 1.;  // minimum distance\n \n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n \n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(gv + neighbor);\n\t\n\t    // Animate the point\n            point = .5 + .5*sin(iTime + 6.3*point);\n \n\t    // Vector between the pixel and the point\n            vec2 diff = neighbor + point - id;\n \n            // Distance to the point\n            float dist = length(diff);\n \n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n    \n    color += m_dist;\n \n    // Draw cell center\n    color += 1.-step(-.4, m_dist);\n \n    vec2 q = vec2(0.);\n    q.x = fbm(gv);\n    q.y = fbm( gv + vec2(1.));\n \n    vec2 r = vec2(0.);\n    r.x = fbm( gv + q + vec2(1.7,9.2)+ 0.15*m_dist );\n    r.y = fbm( gv + q + vec2(8.3,2.8)+ 0.15*m_dist);\n \n    float f = fbm(gv+r);\n \n    color += mix(vec3(.8,.9,.5),\n                vec3(.6,0.7,.5),\n                clamp((f*f)*4.,.0,1.));\n \n    color = mix(color,\n                vec3(.9,.3,0.3),\n                clamp(length(q),0.,1.));\n \n    color = mix(color,\n                vec3(0.8,1.0,.5),\n                clamp(length(r.x),0.0,1.0));\n \n    fragColor = vec4((f*f*f+1.2*f*f+.6*f)*color,1.);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [139, 217, 244, 244, 629], [656, 656, 682, 682, 1010], [1013, 1013, 1037, 1037, 1122], [1125, 1125, 1180, 1180, 2977]]}
{"id": "NtcSRl", "name": "Terrain Shader", "author": "creator4", "description": "Terrain Shader", "tags": ["df", "terrains"], "likes": 2, "viewed": 24, "published": "Public", "date": "1639557214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nRaymarched Terrain Fragment Shader made by Creator4\nHeavily inspired by Iq's work (Thank you!!!)\nhis website is at https://iquilezles.org/www/index.htm and I would\nNOT have gotten this working if it wasn't for his tutorials\n*/\n\n\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.0\n#define GAMMA 2.2\n\nmat3 cameraMatrix(vec3 lookFrom, vec3 lookAt, float roll) {\n    \n    vec3 w = normalize(lookAt - lookFrom);\n    vec3 u = normalize(cross(w, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n\n\n}\n\nfloat unionOp(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(0.4242, 438);\n\treturn fract(sin(p)*2434.1351);\n}\n\nfloat getClosestObj(vec3 p) { //sdf map for all objects in the scene\n    vec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    //float planeDist = heightMap(p.xz);\n    \n    //float d = min(sphereDist, planeDist);\n    return p.y;\n    \n}\n\nfloat noise( in vec2 p ) { //simplex noise function taken from https://www.shadertoy.com/view/Msf3WH\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(500.0) );\n    \n}\n\n\n\nfloat heightMap(vec2 grid) { //FBM mountain\n\n    grid *= 0.05;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.;\n    int numOctaves = 5;\n    float octVal = 0.5000;\n    for(int i = 0; i < numOctaves; i++) {\n        f += octVal*noise(grid);\n        grid = m*grid;\n        octVal = octVal * 0.5;\n    }\n    \n    f = 0.5 + 0.5*f;\n    f *= smoothstep(0.0, 0.005, abs(grid.x-0.6));\n\n    return max(f, 0.0);\n    \n    //return sin(grid.x)*sin(grid.y);\n    \n}\n\n\nbool rayMarch(vec3 rayOrigin, vec3 rayDir, inout float dist) {\n    float increment = 0.01;\n    float lh = 0.;\n    float ly = 0.;\n    for (float d = MIN_DIST; d < MAX_DIST; d += increment) {\n        vec3 pos = rayOrigin + rayDir*d;\n        float height = heightMap(pos.xz);\n        if(pos.y < height) {\n            dist = d - increment + increment * (lh - ly)/(pos.y-ly-height+lh);\n            return true;\n        }\n        increment = 0.01*d;\n        lh = height;\n        ly = pos.y;\n    \n    }\n    return false;\n}\n\nvec3 computeNormal(vec3 p) {\n    float e = 0.0001; //epsilon, tiny increment\n    float xNew = heightMap(vec2(p.x - e,p.z)) - heightMap(vec2(p.x + e, p.z));\n    float yNew = 2.*e;\n    float zNew = heightMap(vec2(p.x, p.z - e)) - heightMap(vec2(p.x, p.z + e));\n    return normalize(vec3(xNew, yNew, zNew));\n}\n\nfloat computeSoftShadows(vec3 pos, vec3 lightPos) {\n    float k = 1.;\n    float res = 1.;\n    float ph = 1e20;\n    for(float t = MIN_DIST; t < MAX_DIST;) {\n        vec3 lightVector = pos + lightPos*t;\n        float h = heightMap(lightVector.xz);\n        if(h < 0.001) return 0.0;\n        float y = h*h/(2.*ph);\n        float dist = sqrt(h*h-y*y);\n        res = min(res, k*dist/max(0.,t-y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 computeLighting(vec3 pos, vec3 normal) {\n    vec3 sun = vec3(500., 100., 40.);\n    //vec3 lightVal = normalize(lightPos - pos);\n    \n    vec3 lightVal = normalize(sun);\n    float l = clamp(dot(normal, lightVal), 0., 1.);\n    //float l = computeSoftShadows(pos, lightVal);\n    \n    vec3 lightColor = vec3(l, l, l);\n    vec3 ambient = vec3(0.7, 0.9, 1.0)/2.;\n    lightColor = clamp(lightColor + ambient, 0., 1.);\n    \n    \n    \n    return lightColor * GAMMA;\n}\n\n\n\nvec3 computeTerrainColor(vec3 rayOrigin, vec3 rayDir, float dist) { \n    vec3 c = vec3(0);\n    vec3 fog = vec3(dist/75.);\n    //c = vec3(0., 0.5, 1.);\n    vec3 pos = rayOrigin + rayDir*dist;\n    vec3 normal = computeNormal(pos);\n    \n    vec3 lightIntensity = computeLighting(pos, normal);\n    \n    vec3 grass = vec3(0.1, 1.0, 0.1);\n    vec3 dirt = vec3(0.44, 0.31, 0.22);\n    vec3 snow = vec3(1);\n    vec3 water = vec3(0.2, 0.5, 1.0);\n    vec3 waterBorder = vec3(0.0, 0.8, 1.0);\n    \n    vec3 surfaceCol = grass;\n    //surfaceCol = texture(iChannel0, 0.5*pos.xz).xyz*0.5*vec3(1);\n    //surfaceCol = vec3(incX, incY, incZ);\n    surfaceCol = mix(surfaceCol, dirt, min(pos.y/1.5-0.3 + 0.7, 1.));\n    if(pos.y >= -0.002 && pos.y <= 0.01) surfaceCol = water;\n    //if(pos.y >= 0.001 && pos.y <= 0.012) surfaceCol = waterBorder;\n    surfaceCol = mix(surfaceCol, snow, clamp(pos.y*2.-2.5, 0., 1.));\n    //}\n    \n    \n    \n    c = surfaceCol * lightIntensity;\n    \n    \n    c = mix(c, fog, 0.5);\n    return c;\n\n}\n\nvec3 computeSkyColor(vec2 fragCoord) {\n   vec2 gradient = fragCoord.xy / iResolution.xy;\n   vec3 skyCol = vec3(-gradient.y+1.3, -gradient.y+1.5, 1.); \n\n\n\n   return skyCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy -0.5*iResolution.xy) / (iResolution.y);\n    //uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    //vec3 col = vec3(abs(uv.x), abs(uv.y), 0);\n    \n    vec3 col = vec3(0);\n    \n    vec3 rayOrigin = vec3(0, 2.50, -iTime);\n    vec3 lookAt = vec3(0,2.4,-iTime - 1.);\n    vec3 rayDir = normalize(cameraMatrix(rayOrigin, lookAt, sin(iTime/3.)/10.) * vec3(uv.xy, 1.));\n    //rayDir = normalize(vec3(uv.xy, 1));\n    float d = 0.;\n    if(rayMarch(rayOrigin, rayDir, d)) {\n        col = computeTerrainColor(rayOrigin, rayDir, d);\n    } else {\n        col = computeSkyColor(fragCoord);\n    }\n\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 298, 357, 357, 536], [538, 538, 573, 573, 599], [601, 601, 622, 622, 681], [683, 683, 712, 751, 945], [947, 947, 973, 1047, 1532], [1536, 1536, 1564, 1579, 1993], [1996, 1996, 2058, 2058, 2511], [2513, 2513, 2541, 2541, 2819], [2821, 2821, 2872, 2872, 3267], [3269, 3269, 3314, 3314, 3732], [3736, 3736, 3803, 3803, 4741], [4743, 4743, 4781, 4781, 4916], [4919, 4919, 4976, 4976, 5644]]}
{"id": "NtcSz8", "name": "Using Random Methods.SV", "author": "turtlelover891", "description": "My second attempt at making random\n(this time with help) en.wikipedia.org/wiki/List_of_random_number_generators", "tags": ["random"], "likes": 2, "viewed": 37, "published": "Public", "date": "1639597929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//middle square method\nfloat msm(float seed, float r){\n    float l = 0.;\n    float temp = seed;\n    while(temp >= 1.){\n        temp /= 10.;\n        l += 1.;}\n\n    float l2 = l*2.;\n    if((sqrt(10.)*seed) < pow(10., l))l2 -= 1.;\n    float l3 = ceil((l2-l)/2.);\n\n    for(float i=0.;i<r;i++){\n        if(seed == 0.)\n        return 0.;\n        seed *= seed;\n        seed = floor(seed/pow(10., l3))-floor(seed/pow(10., l3+l))*pow(10., l);    \n    }return seed/pow(10., l);\n}\n\n//linear congruential generator\nfloat lcg(float m, float a, float c, float seed, float r){\n    for(float i=0.;i<r;i++){\n        seed = mod(a*seed+c, m);\n    }return seed/m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord;\n    vec3 col = vec3(0.);\n    \n    float lcgmask = lcg(uv.x, uv.y, 1., t, 100.);\n    float msmmask = msm(uv.x, t);\n    col += mix(lcgmask, msmmask, clamp((uv.y/R.y-.5)*10., 0., 1.));\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 54, 54, 469], [471, 503, 561, 561, 645], [647, 647, 703, 703, 999]]}
{"id": "NtcSzs", "name": "Spinning round", "author": "ololeecn", "description": "a loading  animation of  a small project. Special thanks to  @FabriceNeyret2 for his prefect recommendations.", "tags": ["rotation"], "likes": 0, "viewed": 32, "published": "Public", "date": "1639560824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define TEST \nprecision highp float;\n#define RANGE 0.02\n#define NUMBER 8\n#define RADIUS 0.76\n#define MAX_R 0.2\n#define SPEED -5.0\n#define PI 3.14159265358979\n\nfloat sdCircle(vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat symmetricFunc(int i){\n    return float(min(NUMBER-i,i))*RANGE;\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);//background\n#ifdef TEST\n     col = mix( vec3(1.0,0.0,0.0),col, smoothstep(0.0,0.01,abs(sdCircle(p,RADIUS))) );\n#endif \n    float part = 2.0*PI/float(NUMBER);\n    for(int i=0;i<NUMBER;i++){\n      float rad = part*(float(NUMBER)*0.25-float(i)) +iTime*SPEED;\n      float d = sdCircle(p-RADIUS*vec2(cos(rad),sin(rad)),MAX_R-symmetricFunc(i));\n      col = mix(vec3(1.0),col,smoothstep(0.0,0.01,d) );\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 161, 195, 195, 223], [225, 225, 252, 252, 295], [298, 298, 354, 354, 873]]}
{"id": "NtdSD7", "name": "Footwear Design 007", "author": "yasuo", "description": "tried to experiment with the wavy upper and fractal textures", "tags": ["footwear"], "likes": 3, "viewed": 105, "published": "Public API", "date": "1639242483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    p.z+=sin(p.x*150.0)*0.01;\n    p.x = mod(p.x,0.06)-0.03;\n    p.z = mod(p.z,0.08)-0.04;\n    p.xy*=Rot(radians(90.));\n    p.y*=1.5;\n    float d2 = sdCappedCylinder(p-vec3(0.19,0.0,0.0),0.2,0.035)*0.6;\n    \n\n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.035,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.xz*=0.96;\n    p.yz*=Rot(radians(-3.0));\n    d2 = baseOutsole(p-vec3(0.0,0.03,0.0),0.005);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP2 = p;\n    p.x+=cos(p.y*160.0)*0.006;\n    p.y+=cos(p.x*160.0)*0.006;\n    vec3 prevP = p;\n\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(13.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.18),0.03,0.2)-0.025;\n    d = opSmoothUnion(d, d2,0.07);\n\n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09)*0.6;\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-12.0));\n    p.x*=1.2;\n    p.y*=1.2;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.35,-0.125),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.04);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.1),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.075;\n    //p.z+=0.1;\n    float d = outsole(p);\n    p.yz*=Rot(radians(-3.0));\n    float d2 = upper(p-vec3(0.0,0.02,0.0));\n    d =  opSmoothUnion(d,d2,0.035);\n    \n    vec2 model = vec2(d,MATERIAL);\n\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat fractalBlock(vec2 p){\n    p*=0.7;\n    p*=Rot(radians(10.0+iTime*-30.));\n    vec2 prevP = p;\n    float d = B(p,vec2(0.01));\n    \n    p.x = abs(p.x);\n    p.x-=0.04;\n    float d2 = B(p,vec2(0.007));\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p.y = abs(p.y);\n    p.y-=0.04;\n    d2 = B(p,vec2(0.007));\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p = abs(p);\n    p-=0.06;\n    d2 = min(length(p)-0.005,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 evaTex(vec2 uv, vec3 col, vec3 fcol){\n    float d = fractalBlock(uv);\n    float depth = 7.;\n    for(float i = 0.; i<depth; i++){\n        uv*= 1.0+i*0.03;\n        uv*=Rot(radians(i*10.0+iTime*5.));\n        uv = abs(uv);\n        uv-=0.05+i*0.02;\n        float d2 = fractalBlock(uv);\n        d = min(d,d2);\n    }\n    \n    col = mix(col,fcol,S(uv,d,0.0));\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,mix(vec3(0.2,0.3,0.7),vec3(0.9,0.1,0.5),p.z)*evaTex(p.xz+p.yy,col,vec3(0.0,0.8,0.6)*2.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.1);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-5.0+iTime*20.0));\n        \n        //ro.yz *= Rot(radians(120.0));\n        //ro.xz *= Rot(radians(45.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n        col = evaTex(uv,col,mix(vec3(0.2,0.3,0.7),vec3(0.9,0.1,0.5),uv.y));\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 390, 415, 415, 434], [435, 435, 460, 460, 479], [480, 480, 532, 532, 632], [634, 746, 771, 771, 1116], [1118, 1118, 1154, 1154, 1196], [1198, 1273, 1306, 1306, 1371], [1373, 1448, 1500, 1500, 1607], [1609, 1684, 1715, 1715, 1802], [1804, 1879, 1916, 1916, 1999], [2001, 2076, 2135, 2135, 2448], [2450, 2450, 2499, 2499, 2572], [2574, 2574, 2609, 2609, 3017], [3019, 3019, 3041, 3041, 3985], [3988, 3988, 4012, 4012, 4879], [4881, 4881, 4901, 4901, 5690], [5692, 5692, 5714, 5714, 6000], [6002, 6002, 6060, 6060, 6327], [6329, 6329, 6353, 6353, 6554], [6556, 6556, 6598, 6598, 6793], [6795, 6836, 6885, 6885, 7179], [7181, 7181, 7238, 7238, 7857], [7859, 7859, 7881, 7881, 7971], [7973, 7973, 8000, 8000, 8427], [8429, 8429, 8471, 8471, 8808], [8810, 8810, 8869, 8869, 9046], [9048, 9048, 9105, 9105, 10225]]}
{"id": "NtdXRj", "name": "Happy holidays 2021", "author": "nebbul", "description": "Happy holidays!", "tags": ["christmas", "tree", "2021", "holidays", "hohoho"], "likes": 14, "viewed": 153, "published": "Public", "date": "1639414392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// used this as base:\n// https://www.shadertoy.com/view/Xds3zN\n//\n// original license:\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define PI 3.141592\n\n//------------------------------------------------------------------\n// snow from:\n// https://www.shadertoy.com/view/MscXD7\n#define _SnowflakeAmount 200\t// Number of snowflakes\n#define _BlizardFactor 0.1\t\t// Fury of the storm !\nfloat rnd(float x)\n{\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));\n}\n\nfloat drawCircle(vec2 uv, vec2 center, float radius)\n{\n    return 1.0 - smoothstep(0.0, radius, length(uv - center));\n}\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 Rotate2dVector(vec2 v, vec2 a) {\n\treturn vec2(a.x*v.x - a.y*v.y, a.y*v.x + a.x*v.y);\n}\nvec2 GetVector(vec2 v, float angle) {\n    float rad = angle * PI / 180.0;\n    vec2 a = vec2(cos(rad),sin(rad)); // how much to rotate vector, rotate as a circle\n    vec2 v_rot = Rotate2dVector(v, a);\n    return v_rot;\n}\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    if( sdBox( pos-vec3(0.0,2,-1.0),vec3(0.35,2,2.5) ) < res.x )\n    {\n        // trunk and tree\n        res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.2,0), vec2(0.1,0.9),0.3 ), 1.5 ) );\n        res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.35,0), vec2(0.65,0.6),0.2 ), 2.5 ) );\n        res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,0), vec2(0.45,0.5),0.2 ), 2.5 ) );\n        res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.55,0), vec2(0.35,0.5),0.2 ), 2.5 ) );\n        res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.65,0), vec2(0.25,0.45),0.2 ), 2.5 ) );\n        res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.75,0), vec2(0.15,0.4),0.2 ), 2.5 ) );\n        \n        // balls\n        vec2 p = vec2(0.0, 0.16);\n        float h = 0.19;\n        float s = 0.0;\n        float spin = 45.0;\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.031 ), 3.1 ) );\n        p = GetVector(p, 90.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.027 ), 3.2 ) );\n        p = GetVector(p, 90.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.024 ), 3.3 ) );\n        p = GetVector(p, 90.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.024 ), 3.5 ) );\n        \n        p = GetVector(vec2(0.0, 0.125), spin);\n        h = 0.29;\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.034 ), 3.6 ) );\n        p = GetVector(p, 90.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.026 ), 3.7 ) );\n        p = GetVector(p, 90.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.029 ), 3.8 ) );\n        p = GetVector(p, 90.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.029 ), 3.9 ) );\n        \n        p = GetVector(vec2(0.0, 0.09), spin*2.0);\n        h = 0.40;\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.027 ), 3.15 ) );\n        p = GetVector(p, 120.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.025 ), 3.25 ) );\n        p = GetVector(p, 120.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.032 ), 3.35 ) );\n        \n        p = GetVector(vec2(0.0, 0.06), spin*3.0);\n        h = 0.50;\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.033 ), 3.45 ) );\n        p = GetVector(p, 120.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.024 ), 3.55 ) );\n        p = GetVector(p, 120.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.027 ), 3.65 ) );\n        \n        p = GetVector(vec2(0.0, 0.04), spin*4.0);\n        h = 0.6;\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.029 ), 3.75 ) );\n        p = GetVector(p, 120.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.024 ), 3.85 ) );\n        p = GetVector(p, 120.0);\n        res = opU( res, vec2( sdSphere(     pos-vec3(p.x, h, p.y), 0.022 ), 3.95 ) );\n        \n        // top star\n        res = opU( res, vec2( sdOctahedron( pos-vec3(0.0,0.74,0.0), 0.06 ), 4.1 ) );\n        \n        // presents\n        res = opU( res, vec2( sdBox(         pos-vec3( 0.2, 0.05, 0.0), vec3(0.05,0.05,0.05) ), 3.42 ) );\n        res = opU( res, vec2( sdBox(         pos-vec3( 0.0, 0.05, 0.2), vec3(0.05,0.05,0.05) ), 3.12 ) );\n        res = opU( res, vec2( sdBox(         pos-vec3( -0.2, 0.05, 0.0), vec3(0.05,0.05,0.05) ), 3.33 ) );\n        res = opU( res, vec2( sdBox(         pos-vec3( 0.0, 0.05, -0.2), vec3(0.05,0.05,0.05) ), 3.79 ) );\n    }\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        //col = 0.1 + 0.3*sin( m * 2.0 + vec3(0.0,1.0,2.0) );\n        //col = 0.1 + 0.3 * sin( m * 2.0 + vec3(0.0,1.0,2.0) );\n        if( m > 0.0 && m < 2.0) col = vec3(0.1,0.05,0.0); //trunk\n        if( m > 2.0 && m < 3.0) col = vec3(0,0.3,0); //tree segments\n        if( m > 3.0 && m < 4.0) col = pal( (m - 3.0) * PI * 2.0, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n        if( m > 4.0 && m < 5.0) col = vec3(1.,0.5,0.0); //star\n        \n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    //vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    //vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    vec3 ta = vec3( 0., 0.23, -0. );\n    vec3 ro = ta + vec3( 4.5*cos(0.05*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.05*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 8.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n        // snow\n        vec2 uv_snow = fragCoord.xy / iResolution.x;\n\n        vec4 snowMask = vec4(0.0, 0.0, 0.0, 0.0);\n        float j;\n\n        for(int i=0; i<_SnowflakeAmount; i++)\n        {\n            j = float(i);\n            float speed = 0.3+rnd(cos(j))*(0.7+0.5*cos(j/(float(_SnowflakeAmount)*0.25)));\n            vec2 center = vec2((0.25-uv_snow.y)*_BlizardFactor+rnd(j)+0.1*cos(iTime+sin(j)), mod(sin(j)-speed*(iTime*1.5*(0.1+_BlizardFactor)), 0.65));\n            snowMask += vec4(0.09*drawCircle(uv_snow,center, 0.001+speed*0.012));\n        }\n        \n        col += snowMask.rgb;\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdXRj.jpg", "access": "shaders20k", "license": "mit", "functions": [[1693, 1921, 1941, 1941, 2039], [2041, 2041, 2095, 2095, 2160], [2162, 2231, 2256, 2256, 2275], [2276, 2276, 2301, 2301, 2320], [2321, 2321, 2357, 2357, 2385], [2387, 2387, 2422, 2422, 2448], [2450, 2450, 2481, 2481, 2572], [2574, 2586, 2633, 2633, 2978], [2980, 2980, 3017, 3017, 3611], [3613, 3683, 3713, 3713, 3746], [3848, 3918, 3955, 3955, 4009], [4010, 4010, 4047, 4047, 4229], [4230, 4230, 4255, 4255, 7855], [7857, 7925, 7976, 7976, 8181], [8183, 8183, 8223, 8223, 9033], [9035, 9097, 9175, 9198, 9585], [9587, 9651, 9683, 9683, 10253], [10255, 10255, 10297, 10297, 10606], [10608, 10684, 10748, 10769, 11002], [11003, 11003, 11071, 11071, 11114], [11116, 11116, 11181, 11200, 14189], [14191, 14191, 14243, 14243, 14420], [14422, 14422, 14479, 14479, 16604]]}
{"id": "NtdXRn", "name": "Voronoi-ed-Voronoi", "author": "Del", "description": "test", "tags": ["voronoi"], "likes": 24, "viewed": 183, "published": "Public API", "date": "1638598092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// wat?\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 GetWater(vec2 p)\n{\n    const vec3 col = vec3(0.02,.3,.55);\n    const mat3 _m = mat3(-2.0,-1.0,2.0, 3.0,-2.0,1.0, 1.0,2.0,2.0);\n    vec4 d = vec4(iDate*.122);\n    d.xy = p;\n    d.xyw *=_m*.5;\n    float v1 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.4;\n    float v2 = length(.5-fract(d.xyw));\n    d.xyw *=_m*.3;\n    float v3 = length(.5-fract(d.xyw));\n    float v = pow(min(min(v1,v2),v3), 5.)*15.;\n    return col+vec3(v,v,v);\n}\n\n// Voronoi (IQ) - slightly modified to return get the ID etc.\nvec4 VoronoiGrid( in vec2 x, out vec2 id )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    \n    id = (n+mg)+vec2(0.5); // ID is n+mg\n    return vec4(md, length(mr), mr);\n}\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= rotate(fract(iTime*0.025)*6.28);\n    vec2 id;\n    float scale = 24.0+(5.0*sin(iTime));\n    vec4 grid = VoronoiGrid(uv*scale,id);\n    uv = id/scale;\n    \n    uv.xy += iTime*0.01;\n\n    float dd = smoothstep(0.0,0.25,(grid.x));\n\n\tfragColor = vec4( GetWater(uv)*dd, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 31, 62, 152], [154, 154, 177, 177, 584], [586, 648, 692, 692, 1525], [1526, 1526, 1548, 1548, 1615], [1621, 1621, 1678, 1678, 2028]]}
{"id": "NtdXWH", "name": "Seizure Warning", "author": "Wykes", "description": "First test with shaping functions. Works best when projected on a big wall.", "tags": ["function", "shaping"], "likes": 0, "viewed": 67, "published": "Public API", "date": "1639047791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.7, pct, st.y) -\n          smoothstep( pct, pct+0.684, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv*2.0 - 1.0) * 1.184 ;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float time = iTime;\n    m -= 100.0*sin(time);\n\n    float y = 0.0;\n    y = (((sin( uv.y*m.x / 0.334 ) + uv.x / -2.224) + fract( uv.x*m.y / -0.282 )) + fract( uv.x / uv.y )) * m.x;\n\n    vec3 color = vec3(y);\n\n    float pct = plot(uv,y);\n\n    // Time varying pixel color\n    vec3 col = vec3(pct);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 181, 231, 702]]}
{"id": "NtG3DV", "name": "Grid Segments fork", "author": "SnoopethDuckDuck", "description": "I don't like this + artifact at 0 angle", "tags": ["e"], "likes": 11, "viewed": 215, "published": "Public API", "date": "1638317533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 thc(float a, vec3 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat h21 (float a, float b, float sc) {\n    a = mod(a, sc); b = mod(b, sc);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pnt(vec2 ipos, float sc) {\n    float h = h21(ipos.x, ipos.y, sc);\n    float t = iTime + 10. * h;\n    float k = 1.5 +  h;\n    return 0.4 * vec2(thc(4. * (1.-h), 100. + k * t), \n                      ths(4. * h, 100. + (1.-k) * t));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos(6.28318*(c*t+d) );\n}\n\n// idk what to call this\nvec2 func(float t) {\n    return vec2(.5 + .5 * cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    vec2 ouv = uv;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy)/ iResolution.y;\n    //uv += 2. + 0.04 * iTime;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv); \n    uv = vec2(4. * a/pi, log(r) - 0.1 * iTime);\n    \n    float c = 100.;\n    // cant scale dynamically because sc used in h21 (bad)\n    float sc = 5.;// + 1./length(ouv-ms);\n    vec2 fpos = fract(sc * uv) - 0.;\n    vec2 ipos = floor(sc * uv) + 0.5;    \n    \n    // Generate values for each corner of uv (sloppy)\n    float l  = h21(ipos.x + 1., ipos.y,      c * sc);\n    float t  = h21(ipos.x,      ipos.y + 1., c * sc);\n    float tl = h21(ipos.x + 1., ipos.y + 1., c * sc);\n    float id = h21(ipos.x,      ipos.y,      c * sc);\n\n    // Smooth fpos completely, so v noise looks better\n    vec2 sfpos = fpos * fpos * (3. - 2. * fpos);\n    \n    // Smooth the grid uvs so different uvs meet continuously on the edges\n    //fpos = mix(fpos, fpos * fpos * (3. - 2. * fpos), 0.5 * thc(4., iTime));\n    \n    // Box lerp between the corner values to get a radius value for this pixel\n    float v = l  * sfpos.x      * (1.-sfpos.y)\n     \t    + t  * (1.-sfpos.x) * sfpos.y\n     \t    + tl * sfpos.x      * sfpos.y\n      \t    + id * (1.-sfpos.x) * (1.-sfpos.y);\n    \n    // shift fpos correctly\n    fpos -= 0.5;\n    \n    // moving points for each cell\n    vec2 p = pnt(ipos, sc);\n\n    vec2 pl = -vec2(1.,0.) + pnt(ipos - vec2(1.,0.), sc);\n    vec2 pr =  vec2(1.,0.) + pnt(ipos + vec2(1.,0.), sc);\n    vec2 pt = -vec2(0.,1.) + pnt(ipos - vec2(0.,1.), sc);\n    vec2 pb =  vec2(0.,1.) + pnt(ipos + vec2(0.,1.), sc);\n    \n    // used to change intensity of each segment\n    float rl = h21(vec2((ipos.x - 1.) * ipos.x, ipos.y));\n    float rr = h21(vec2((ipos.x + 1.) * ipos.x, ipos.y));\n    float rt = h21(vec2(ipos.x, (ipos.y - 1.) * ipos.y));\n    float rb = h21(vec2(ipos.x, (ipos.y + 1.) * ipos.y));   \n    \n    // draw half of each segment for each cell\n    float dl = sdSegment(fpos, p, pl);\n    float dr = sdSegment(fpos, p, pr);\n    float dt = sdSegment(fpos, p, pt);\n    float db = sdSegment(fpos, p, pb);\n        \n    // Outline line segments, scale with v\n    // (m = thickness of line, n = thickness of outline)  \n    float m = 0.05 + 0.07 * v;\n    float ml = m + 0.1 * cos(length(p - pl));\n    float mr = m + 0.1 * cos(length(pr - p));\n    float mt = m + 0.1 * cos(length(p - pt));\n    float mb = m + 0.1 * cos(length(pb - p));\n    float mm = 0.1;\n    ml = min(ml, mm);mr = min(mr, mm);mt = min(mt, mm);mb = min(mb, mm);\n      \n    float n = 0.18;\n    float sl = rl * (step(0.,ml - dl)-step(0., n * ml - dl));\n    float sr = rr * (step(0.,mr - dr)-step(0., n * mr - dr));\n    float st = rt * (step(0.,mt - dt)-step(0., n * mt - dt));\n    float sb = rb * (step(0.,mb - db)-step(0., n * mb - db));\n    \n    /*\n    float n2 = 0.08 * h21(uv);  \n    float sl = rl * (smoothstep(-n2,n2,ml - dl)-smoothstep(-n2,n2, n * ml - dl));\n    float sr = rr * (smoothstep(-n2,n2,mr - dr)-smoothstep(-n2,n2, n * mr - dr));\n    float st = rt * (smoothstep(-n2,n2,mt - dt)-smoothstep(-n2,n2, n * mt - dt));\n    float sb = rb * (smoothstep(-n2,n2,mb - db)-smoothstep(-n2,n2, n * mb - db));\n    //*/\n    float s = max(max(sl, sr), max(st, sb));\n    \n    // Segment colors\n    vec3 col = 1. * s + s * pal(0.5 * v + r * 0.5 - 0.3 * iTime, vec3(0.), vec3(1.), vec3(1.),  \n                  2. * r * cos(s + 0.15 * iTime) * vec3(0.,0.33,0.66));\n\n    col = clamp(8. * pow(length(ouv), 2.) * col, vec3(0.), col);\n    \n    fragColor = vec4(col, 1.); //vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 254, 254, 329], [331, 331, 371, 371, 486], [488, 488, 540, 540, 659], [661, 661, 692, 692, 898], [900, 900, 968, 968, 1012], [1014, 1039, 1059, 1059, 1096], [1098, 1098, 1155, 1155, 4727]]}
{"id": "NtG3Wt", "name": "Cowblob", "author": "Jabo", "description": "Moo. The lavalamp of cows. 2D wallpaper inspired by Gateway computer mousepads.", "tags": ["metaball"], "likes": 0, "viewed": 34, "published": "Public API", "date": "1638488593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/lt3BW2\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat meta(vec2 p, float r)\n{\n\t//return r / dot(p, p);\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat blob(vec2 p, float t)\n{\n    float smoothness = 0.2 + cos(0.03 * t) * 0.1;\n    vec2 offset = vec2(sin(0.1 * t) * 0.1, cos(0.1 * t) * 0.1);\n    float d = meta(p, 0.3 + cos(0.2 * t) * 0.05);\n    offset = vec2(0.1 + sin(0.3 * t) * 0.1, -0.15 + cos(0.07 * t) * 0.1);\n    d = opSmoothUnion(d, meta(p+offset, 0.32), smoothness);\n    offset = vec2(0.05 - sin(0.2 * t) * 0.05, 0.05 + cos(0.05 * t) * 0.05);\n    d = opSmoothUnion(d, meta(p+offset, 0.3), smoothness);\n    return d;\n}\n\nvec3 mysample(vec2 uv, float t) {\n    // speed me up by increasing\n    t *= 1.0;\n\n    // top right\n    float d = blob(uv - vec2(0.8, 0.3), t); \n    d = opSmoothUnion(d, blob(uv - vec2(0.9, 0.4), t-2.0), 0.3);\n    \n    // top left\n    d = opSmoothUnion(d, blob(uv - vec2(-0.6, 0.65), 1.1 * t-1.0), 0.1); \n    d = opSmoothUnion(d, blob(uv - vec2(-0.8, 0.75), 1.1 * t+2.0), 0.3);\n    \n    // bottom left\n    d = opSmoothUnion(d, blob(uv * vec2(0.5, 1.0) - vec2(-0.25, -0.6), 0.9 * t+5.0), 0.1);\n    d = opSmoothUnion(d, blob(uv * vec2(0.8, 1.1) - vec2(-0.6, -0.7), 0.9 * t-4.0), 0.3);\n    d = opSmoothUnion(d, blob(uv - vec2(0.1, -0.7), 0.8 * t-3.0), 0.3);\n    \n    // border effect\n    d = opSmoothUnion(d, -sdBox(uv, vec2(0.95, 0.55)), 0.15);\n    \n    \n    if(iMouse.z > 0.001) {\n        // non AA original\n        vec3 col = vec3(min(\n            step(0.000001, d),\n            smoothstep(-0.5, 0.2, d)\n        ));\n        return col;\n    }\n    \n    // AA smoothstep\n    float e = 0.99/iResolution.y;\n    float c = smoothstep(-e,e, d);\n    c = min(c, smoothstep(-0.5, 0.2, d));\n    return vec3(c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;    \n    // shift to 0.0 center\n    uv -= 0.5;\n    // squish for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    // pixel color\n    vec3 col = mysample(uv, iTime);\n\n    // Output to screen\n    fragColor = pow(vec4(col, 1.0), vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtG3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 93, 93, 169], [171, 171, 200, 225, 251], [253, 253, 290, 290, 370], [372, 372, 401, 401, 850], [852, 852, 885, 918, 1951], [1953, 1953, 2010, 2060, 2362]]}
{"id": "NtGGWt", "name": "Noise Blur ", "author": "SnoopethDuckDuck", "description": "a bit dizzying but the effects interesting", "tags": ["e"], "likes": 7, "viewed": 140, "published": "Public API", "date": "1638490627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float sc = 32.;\n    \n    uv *= 1.5;\n    uv.x += cos(0.01 * uv.y + 0.5 * iTime) * thc(12., -0.3 * iTime + 0.1 * h21(uv));// + thc(1., 6. * length(uv) - iTime);\n    uv.y += sin(0.01 * uv.x + 0.5 * iTime) * ths(12., -0.3 * iTime + 0.1 * h21(uv));\n    \n    vec2 ipos = floor(sc * uv)/sc + 0.;\n    \n    float a = atan(ipos.y, ipos.x);\n    float r = length(ipos);\n    r = log(r) + 0.4 * thc(3.,4. * r + iTime);\n\n    float sc2 = 3. + 2. * cos(3. * a + iTime);\n    \n    \n    float val = 5. * r + a + iTime;\n    vec2 fpos = fract(vec2(thc(1., val), ths(1.,val)) + sc2 * ipos) - 0.5;\n    \n    float d = length(fract(thc(4.,a + iTime) * fpos) - 0.5);\n    float rd = 1. + thc(1., a + 4. * r - iTime);\n    float k = 0.4;\n    float s = 1.-smoothstep(-k,k,rd-d);  \n    //s -= step(d, 0.2 * rd);\n    s = clamp(4. * s * s, 0., 1.);\n    \n    fpos = fract(sc * uv) - 0.5;\n    \n    d = mlength(fpos);\n    rd = min(0.45, 0.1 * thc(40., r + 1.5 * h21(ipos) + iTime) + 0.4 * s);\n    rd *= step(0.11, rd);\n    float s2 = step(d, rd) - smoothstep(-0.5,0.5, rd -d);\n    s2 = clamp(5. * s2 * s2, 0., 1.);\n    s *= 2. * pow(1.-length(uv),4.);\n    vec3 col = s2 * pal(s +10.* h21(ipos) + iTime, vec3(1.), vec3(1.), vec3(1.), vec3(0.,0.33,0.66));\n    \n\n\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 191, 191, 232], [234, 234, 261, 261, 302], [304, 304, 372, 372, 415], [417, 417, 437, 437, 512], [514, 514, 538, 538, 578], [580, 580, 637, 637, 1990]]}
{"id": "NttSzB", "name": "Random sunday shader", "author": "mrange", "description": "Random sunday shader", "tags": ["colors", "abstract", "planes"], "likes": 15, "viewed": 152, "published": "Public API", "date": "1639337451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0: Random sunday shader\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n#define BPM         125.0\n\n//#define CRT_EFFECT\n\nconst float planeDist = 1.0-0.825;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n  float ndbuffer = dbuffer/sph.w;\n  vec3  rc = (ro - sph.xyz)/sph.w;\n\n  float b = dot(rd,rc);\n  float c = dot(rc,rc) - 1.0;\n  float h = b*b - c;\n  if( h<0.0 ) return 0.0;\n  h = sqrt( h );\n  float t1 = -b - h;\n  float t2 = -b + h;\n\n  if( t2<0.0 || t1>ndbuffer ) return 0.0;\n  t1 = max( t1, 0.0 );\n  t2 = min( t2, ndbuffer );\n\n  float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n  float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n  return (i2-i1)*(3.0/4.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract(sin(a)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n#ifdef CRT_EFFECT  \n  col *= 1.5*smoothstep(-2.0, 1.0, sin(0.5*PI*q.y*RESOLUTION.y));\n#endif  \n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0-exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float aa, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float  n = modPolar(p, 3.0);\n\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  s1.z += -PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  vec3 hsv = vec3(fract(s.z/PI+TIME*0.5), 0.9, 1.0);\n  return vec4(hsv2rgb(hsv)*s.x, s.y);\n}\n\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.15*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float hn = hash(n);\n  float hn0 = hn;\n  float hn1 = fract(137.0*hn);\n  float z = mix(0.1, 0.3, hn0);\n  \n  float pd = length(ro - pp);\n  aa *= mix(1.0, 15.0, smoothstep(planeDist*4.0, 0.0, pd));\n\n  vec2 p = (pp-off*1.0*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(mix(0.125, 0.66, hn1)*TIME);\n  p /= z;\n  aa /= z;\n  float d;\n  float a = TAU*TIME/300.0;\n\n  float cd = hex(p.yx, 0.5);\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  vec2 cp = hp;\n  float h = hash(np);\n  float hh = fract(137.0*h);\n  float sm = mix(mix(0.025, 0.25, hh), 0.025, h);\n  float rep = 2.0*floor(mix(8.0, 30.0, h));\n  float cn = 0.0; \n  cn = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(TIME*0.2+TAU*h);\n  \n  vec4 ccol = clogo(cp, aa, 0.6, d);\n  vec3 gcol = hsv2rgb(vec3(h, 0.8, 4.0));\n  vec3 col  = vec3(0.0);\n  float g = exp(-40.0*max(d, 0.0));\n  col += gcol*g;\n  col = mix(col, ccol.xyz, ccol.w);\n\n  float t0 = smoothstep(aa, -aa, d);\n  float t1 = smoothstep(aa, -aa, -cd);\n  float t2 = 2.0*g;\n  float t = t1*tanh_approx(t0 +t2);\n  \n//  return vec4(col, tanh_approx(t+g));\n  return vec4(col, t);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  const float rdd_per   = 5.0;\n  //float rdd = (2.0+1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  //float rdd = 2.0;\n  float rdd =  (1.75+0.75*pow(lp,1.5)*tanh_approx(lp+0.9*PCOS(rdd_per*p.x)*PCOS(rdd_per*p.y)));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 8;\n  const int fadeFrom = max(furthest-6, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  float maxpd = 0.0;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n//      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut*fadeIn;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3  glowCol   = hsv2rgb(vec3(fract(dot(p, p)-0.25*TIME), 0.66, 1.0));\n  vec3  glowDown  = 2.5*glowCol;\n  vec3  glowUp    = 5.0*glowCol;\n  \n  float beat = smoothstep(0.5, 1.0, sin(BPM*TIME*TAU/60.0));\n  \n  float glowRadius = mix(0.4, 0.5, beat);\n  vec3 pp    = ro + rd*planeDist*float(furthest-1);\n  vec3 off   = offset(pp.z);\n  float sd   = sphered(ro, rd, vec4(off, glowRadius), mix(1E6, maxpd, acol.w));\n  vec3 bcol  = mix(glowDown, glowUp, beat);\n  vec3 gcol  = tanh(sd*bcol);\n  skyCol += gcol;\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = planeDist*TIME*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 519, 541, 541, 687], [982, 1042, 1082, 1082, 1241], [1243, 1303, 1343, 1343, 1385], [1387, 1473, 1512, 1512, 1637], [1639, 1639, 1670, 1670, 1695], [1697, 1697, 1728, 1728, 1754], [1756, 1831, 1889, 1889, 2338], [2340, 2440, 2479, 2479, 2564], [2566, 2654, 2693, 2693, 2722], [2724, 2784, 2812, 2878, 2954], [2956, 3016, 3038, 3038, 3086], [3088, 3148, 3168, 3168, 3250], [3252, 3339, 3375, 3375, 3703], [3838, 3838, 3858, 3858, 3878], [3880, 3978, 4014, 4014, 4124], [4126, 4244, 4272, 4272, 4456], [4458, 4559, 4587, 4686, 5013], [5015, 5101, 5150, 5150, 5552], [5554, 5642, 5672, 5672, 5699], [5701, 5787, 5832, 5832, 5986], [5989, 6077, 6099, 6099, 6143], [6145, 6233, 6254, 6254, 6299], [6301, 6389, 6450, 6450, 6663], [6665, 6665, 6689, 6689, 6788], [6790, 6790, 6820, 6820, 7056], [7058, 7058, 7091, 7091, 7629], [7631, 7631, 7669, 7669, 7941], [7943, 7943, 7963, 7963, 7991], [7993, 7993, 8045, 8045, 8422], [8425, 8425, 8447, 8447, 8580], [8582, 8582, 8605, 8605, 8680], [8682, 8682, 8706, 8706, 8783], [8785, 8785, 8853, 8853, 9914], [9916, 9916, 9949, 9949, 9989], [9991, 9991, 10047, 10047, 12306], [12308, 12308, 12337, 12337, 12652], [12654, 12654, 12709, 12709, 12935]]}
{"id": "NtV3WK", "name": "mirror city", "author": "snflwrfld", "description": "used this wonderful tutorial to avoid glitching towers : https://www.youtube.com/watch?v=I8fmkLK1OKg\n\nbtw if you kow how i can avoid these flickering lights, i'd like to get some help !\n", "tags": ["raymarching"], "likes": 13, "viewed": 189, "published": "Public", "date": "1638353111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct hit{float dist;int mat;};\n\nfloat norminf3(vec3 p){return max(abs(p.x),max(abs(p.y),abs(p.z)));}\nfloat norminf2(vec2 p){return max(abs(p.x),abs(p.y));}\nmat4 viewMatrix(vec3 eye,vec3 center,vec3 up){\n    // Based on gluLookAt man page\n    vec3 f=normalize(center-eye);\n    vec3 s=normalize(cross(f,up));\n    vec3 u=cross(s,f);\n    return mat4(\n        vec4(s,0.),\n        vec4(u,0.),\n        vec4(-f,0.),\n        vec4(0.,0.,0.,1)\n    );\n}\nfloat hash21(vec2 p){\n    return fract(sin(dot(p,vec2(41.558,36.55))+27.1));\n}\nfloat hash31(vec3 p){\n    return fract(sin(dot(p,vec3(3.5225,8.142,7.356))+4.));\n}\nvec2 edge(vec2 p){\n    if(abs(p.x)>abs(p.y))return vec2((p.x<0.)?-1.:1.,0.);\n    else return vec2(0.,(p.y<0.)?-1.:1.);\n}\n\n// Ray tracing\n#define MAX_STEPS 250\n#define EPSILON.001\n#define MIN_DIST 0.\n#define MAX_DIST 1000.\n\nfloat towerSDF(vec3 p,float width,float height){\n    vec2 p2=vec2(norminf2(p.xz),p.y);\n    p2.x-=width;\n    p2.y-=height;\n    return length(max(p2,0.))+min(0.,max(p2.x,p2.y));\n}\nhit scene(vec3 p){\n    //Scene's SDF\n    hit res;\n    p.x-=iTime;\n    p.z-=.5;\n    \n    vec3 fp;fp.xz=fract(p.xz)-.5;fp.y=p.y+2.8;\n    vec3 ip;ip=floor(p);\n    vec3 neighbor;neighbor.xz=fp.xz-edge(fp.xz);neighbor.y=fp.y;\n    \n    float width=.45;\n    float max_height=2.;\n    float me=towerSDF(fp,width,max_height*hash21(ip.xz));\n    float next=towerSDF(neighbor,width,max_height);\n    \n    vec3 fp2=fp;fp2.y=-fp.y+5.6;\n    vec3 neighbor2=neighbor;neighbor.y*=-1.;\n    float me2=towerSDF(fp2,width,max_height*hash21(ip.zx+vec2(.1,.5)));\n    float next2=towerSDF(neighbor,width,max_height);\n    \n    res.dist=me;\n    res.dist=min(min(me,next),min(me2,next2));\n    \n    res.mat=1;\n    return res;\n}\n\nhit trace(vec3 cam,vec3 dir,float start,float end){\n    hit res;\n    \n    float depth=start;int mat=0;\n    for(int i=0;i<MAX_STEPS;i++){\n        hit p=scene(cam+depth*dir);\n        if(p.dist<EPSILON){\n            res.dist=depth;res.mat=p.mat;\n            return res;\n        }\n        depth+=p.dist;\n        if(p.dist>=end){\n            res.dist=end;res.mat=0;\n            return res;\n        }\n    }\n    res.dist=end;res.mat=0;\n    return res;\n}\n\nvec3 estimateNormal(vec3 p){\n    return normalize(vec3(scene(vec3(p.x+EPSILON,p.y,p.z)).dist-scene(vec3(p.x-EPSILON,p.y,p.z)).dist,scene(vec3(p.x,p.y+EPSILON,p.z)).dist-scene(vec3(p.x,p.y-EPSILON,p.z)).dist,scene(vec3(p.x,p.y,p.z+EPSILON)).dist-scene(vec3(p.x,p.y,p.z-EPSILON)).dist));\n}\n\nvec3 backgroundColor=vec3(.15);\nvec3 displayColor(vec3 cam,vec3 dir,vec2 st){\n    vec3 color;vec3 p;int material_id;hit obj;\n    \n    obj=trace(cam,dir,MIN_DIST,MAX_DIST);\n    p=cam+obj.dist*dir;\n    material_id=obj.mat;\n    \n    vec3 bg=mix(vec3(.1294,.298,.3725),vec3(.3882,.2392,.3608),(st.x+1.)/2.);\n    if(material_id==0){\n        color=bg;\n    }else if(material_id==1){\n        vec3 p2=p;\n        p2.x-=iTime;\n        p2.y/=2.5;\n        vec3 color=(1.-abs(estimateNormal(p).y)>EPSILON)?mix(vec3(0.),vec3(.9843,.9922,.3882),smoothstep(.9997,.9999,hash31(floor(p2*56.)))):vec3(0.);\n        return mix(bg,color,2.5*pow(1./(obj.dist*obj.dist),.6));\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment\n    vec2 st=fragCoord.xy/iResolution.xy;\n    st=st*2.-1.;\n    st.x*=iResolution.x/iResolution.y;\n    float t=iTime;\n    \n    // ray tracing\n    //vec3 cam=vec3(cos(t),0.,sin(t))*7.+vec3(0.,2.,0.);\n    vec3 cam=vec3(5.,0.,0.);\n    vec3 dir=normalize(vec3(st,-1.1));\n    mat4 view=viewMatrix(cam,vec3(0.),vec3(0.,1.,0.));\n    dir=(view*vec4(dir,0.)).xyz;\n    \n    // shading\n    vec3 color=displayColor(cam,dir,st);\n    \n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 57, 57, 102], [103, 103, 126, 126, 157], [158, 158, 204, 239, 443], [444, 444, 465, 465, 522], [523, 523, 544, 544, 605], [606, 606, 624, 624, 726], [728, 829, 877, 877, 1006], [1007, 1007, 1025, 1043, 1703], [1705, 1705, 1756, 1756, 2151], [2153, 2153, 2181, 2181, 2440], [2474, 2474, 2519, 2519, 3123], [3125, 3125, 3182, 3198, 3649]]}
{"id": "NtV3WV", "name": "little wolf-lobito", "author": "jorge2017a2", "description": "little wolf-lobito", "tags": ["2d", "draw", "littlewolf", "lobito"], "likes": 8, "viewed": 109, "published": "Public API", "date": "1638372228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a2\n//little wolf-lobito-1-dic-2021\n//referencia\n//https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n//#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n//#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S(d,b) smoothstep(8.*antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(6.*antialiasing(0.85),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{   vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 HacerOjos(vec2 p, vec3 colOut, vec3 colIn)\n{   float d1= sdCircle( p-vec2(0.0,-1.70),0.07 );\n    float d2=sdBox(p-vec2(0.1,-1.9), vec2(0.15,0.005) );\n    colOut= DrawFig(colIn, colOut,d1);\n    colOut= DrawFig(colIn, colOut,d2);\n    return colOut;\n}\n\nvec3 HacerOreja(vec2 p, float ang, vec3 colOut, vec3 colIn)\n{ ///Oreja\n   p= rotatev2(p,ang);\n   float r1=0.25;\n   float r2=0.0001;\n   float h=0.3;\n   float d5= sdTrapezoid(p-vec2(0.5,1.0),r1,r2,h);\n   colOut= DrawFigBorde(colIn, colOut,d5); \n    return colOut;\n}\n   \n\nvec3 HacerRostro2d(vec2 p, vec3 col)\n{    vec2 p0=p;  \n    //oreja der\n    col= HacerOreja(p,radians(45.0),col, vec3(0.7));\n    col= HacerOreja(p*1.2-vec2(0.15,0.0),radians(45.0),col, vec3(0.2));\n    //oreja izq\n    p.x+=0.9;\n    p.y-=0.15;\n    col= HacerOreja(p,radians(15.0),col, vec3(0.7));\n    col= HacerOreja(p*1.2-vec2(0.12,0.0),radians(15.0),col, vec3(0.2)); //izq\n    p=p0;\n    \n    //Cuello\n    float d6= sdBox(p-vec2(0.0,-1.4), vec2(0.2,0.8) );\n   col= DrawFigBorde(vec3(0.4), col,d6);\n   \n    //cabeza\n   p= rotatev2(p,radians(25.0));\n   float d1=sdCircle(p*vec2(0.8,1.6)-vec2(0.0,0.0), 1.0 );\n   col= DrawFigBorde(vec3(0.5), col,d1);\n   p=p0;\n      \n   float angN=10.*sin(iTime);\n   //nariz 1 y boca\n   float r1,r2,h;\n   r1=0.3;\n   r2=0.3;\n   h=1.0;\n   p= rotatev2(p,radians(220.0+angN));\n   float d2=sdUnevenCapsule(p-vec2(0.1,0.4),r1,r2,h);\n   float d3=sdUnevenCapsule(p-vec2(-0.2,0.4),r1,r2,h);\n   col= DrawFigBorde(vec3(0.6), col,d3); //boca\n   col= DrawFigBorde(vec3(0.4), col,d2); //nariz\n   \n   //nariz 2\n   p=p0;\n   p= rotatev2(p,radians(220.0+angN));\n   float d4=sdCircle(p*vec2(0.6,1.2)-vec2(0.05,1.85), 0.15);\n   col= DrawFig(vec3(0.0), col,d4); //nariz 2\n   p=p0;\n   p= rotatev2(p-vec2(-1.1,-1.15),radians(220.0));\n   col= HacerOjos(p-vec2(0.3,0.05),col, vec3(0.1));\n   col= HacerOjos(vec2(-p.x,p.y)-vec2(0.5,-0.1),col, vec3(0.1));\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=2.0;\n    uv*=esc;\n    vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.5/esc;\n    col= HacerRostro2d(uv-vec2(0.0,0.8),col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtV3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[463, 494, 530, 530, 575], [580, 624, 671, 671, 698], [699, 699, 742, 742, 769], [770, 770, 818, 818, 846], [852, 852, 914, 914, 1111], [1113, 1113, 1194, 1194, 1324], [1326, 1326, 1383, 1383, 1454], [1456, 1456, 1490, 1490, 1585], [1587, 1587, 1612, 1612, 1631], [1632, 1632, 1657, 1657, 1676], [1678, 1678, 1715, 1715, 1789], [1791, 1791, 1826, 1826, 1849], [1851, 1851, 1903, 1903, 2019], [2021, 2021, 2083, 2083, 2320], [2322, 2322, 2387, 2387, 2695], [2697, 2697, 2746, 2746, 2950], [2952, 2952, 3013, 3022, 3215], [3221, 3221, 3259, 3259, 4593], [4595, 4595, 4652, 4652, 4926]]}
{"id": "NtVGWy", "name": "Oblique Slices", "author": "panna_pudi", "description": "(ಠ o ಠ)¤=[]:::::>", "tags": ["slice", "conetracing", "cut"], "likes": 20, "viewed": 186, "published": "Public", "date": "1638421097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Desert Bloom by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane,\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Inspired by wblut's work.\n//\n// cmarangu/CM2 nails this down with precise control where is the\n// untransformed space and should be rotated/slices. I'm just sneaky\n// avoiding problems with a least amount of artifacts.\n// https://www.shadertoy.com/view/tddGzf\n//\n// Cone tracing and effects took from TekF's shader. Would like to\n// see explanation with graphics and pictures what they are doing v-v\n// https://www.shadertoy.com/view/MsBGWm\n\nconst vec3 EPS = vec3(0., 0.01, 0.0001);\nconst float PI = acos(-1.);\nconst float TAU = 2.0 * PI;\n\n// https://jbaker.graphics/writings/DEC.html\nfloat sd_dodecahedron(vec3 p, float radius) {\n    const float phi = 1.61803398875;\n    const vec3 n = normalize(vec3(phi, 1, 0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a, b), c) - n.x) * radius;\n}\nfloat sd_icosahedron(vec3 p, float radius){\n    const float q = 2.61803398875;\n    const vec3 n1 = normalize(vec3(q, 1, 0));\n    const vec3 n2 = vec3(0.57735026919);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a, b), c) - n1.x, d) * radius;\n}\nfloat sd_icosahestar(vec3 p){\n    float radius = 1.5;\n    return min(sd_dodecahedron(p, radius), sd_icosahedron(p.zyx, radius));\n}\n\nconst int NUM_CUTS = 5;\nvec3 CUT_DIR[NUM_CUTS];\nfloat CUT_WIDTH[NUM_CUTS];\nfloat CUT_OFFSET[NUM_CUTS];\n\nvoid setup_cuts() {\n    CUT_DIR[0] = normalize(vec3(0., 1., 0.9));\n    CUT_DIR[1] = normalize(vec3(1., 0., 0.));\n    CUT_DIR[2] = normalize(vec3(0., 0.6, 0.));\n    CUT_DIR[3] = normalize(vec3(-1., 0.5, 0.1));\n    CUT_DIR[4] = normalize(vec3(-1., 1., 0.));\n\n    CUT_WIDTH[0] = 0.3;\n    CUT_WIDTH[1] = 0.2;\n    CUT_WIDTH[2] = 0.4;\n    CUT_WIDTH[3] = 0.2;\n    CUT_WIDTH[4] = 0.6;\n\n    CUT_OFFSET[0] = 0.5;\n    CUT_OFFSET[1] = -0.2;\n    CUT_OFFSET[2] = 0.3;\n    CUT_OFFSET[3] = -0.4;\n    CUT_OFFSET[4] = 0.;\n}\n\nstruct Cut {\n    vec3 off;\n    float d;\n    float sign;\n};\n\nCut op_cut(vec3 p, vec3 n, float w, float width) {\n    float dt = dot(p, n) - w;\n    float dcut = abs(dt) - width;\n    float s = sign(dt);\n    return Cut(width * n * s, dcut, s);\n}\n\nCut merge_cuts(Cut a, Cut b) {\n    // Sign computing is not right as expected,\n    // but I didn't stumble on this problem yet\n    return Cut(a.off + b.off, min(a.d, b.d), a.sign * b.sign);\n}\n\nCut dummy_cut() {\n    return Cut(vec3(0.), 9999., 1.);\n}\n\n// https://suricrasia.online/demoscene/functions/ blackle is a qt >:3c\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + cross(ax, p) * sin(ro);\n}\n\nfloat back_out(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (f * f - f * 0.8 * sin(f * PI));\n}\n\nfloat map(vec3 p) {\n    float time = mod(iTime / 14., 1.);\n    float dist = 999.;\n\n    float trig_wave = min(time, 1. - time);\n    float saddle = 4. * trig_wave - 0.5;\n\n    Cut cut = dummy_cut();\n    for (int i = NUM_CUTS - 1; i >= 0; --i) {\n        float harm = saddle * float(NUM_CUTS) - float(i);\n        float delay = 0.4;\n        float release = clamp((harm - delay) / (1. - delay), 0., 1.);\n        release = 0.50 - 0.5 * cos(release);\n        if (release == 0.) continue;\n\n        Cut current_cut =\n            op_cut(p, CUT_DIR[i], CUT_OFFSET[i], CUT_WIDTH[i] * release);\n        cut = merge_cuts(cut, current_cut);\n        // Adjust position in the direction of cut\n        p -= current_cut.off;\n\n        // Rotate space on the last cut\n        int last_cut = NUM_CUTS - 1;\n        if (i == last_cut) {\n            float rot_dir = current_cut.sign;\n            p = erot(p, CUT_DIR[last_cut],\n                     rot_dir * back_out(release) * PI);\n        }\n    }\n\n    dist = sd_icosahestar(p);\n    dist = max(dist, -cut.d);\n\n    return dist;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 20; i++) {\n        float d = map(ro + t * rd);\n        if (abs(d) < 0.0001 || t > 20.) break;\n        t += d;\n    }\n    return t;\n}\n\nmat3 get_camera(vec3 eye, vec3 at) {\n    vec3 zaxis = normalize(at - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvec3 get_normal(vec3 p, float r) {\n    mat3 k = mat3(p, p, p) - mat3(r);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nvec3 sky2(vec3 rd) {\n    vec3 col = vec3(0.);\n    col+=smoothstep(0.2,1.5,dot(rd, normalize(vec3(0.,-1.,0.)))) * 0.1*vec3(0.67843,0.67451,0.709);\n    col+=smoothstep(.2,1.0, dot(rd, normalize(vec3(0,1,-3)))) * 0.2 * vec3(0.3647,0.2902,0.63137);\n    col+=smoothstep(-0.4,0.4, dot(rd, normalize(vec3(0.9,0.2,0.6)))) * 0.2 * vec3(0.1,0.4,0.3);\n    col+=smoothstep(-0.4,0.4, dot(rd + vec3(0.0,0.7,0.0), normalize(vec3(0.0,-0.2,0.0)))) *\n           vec3(0.1, 0.0, 0.3) * 0.1;\n    return col;\n}\n\n// Thanks al-ro\nvec3 sky(vec3 rd){\n    return mix(0.12 * vec3(0.75, 0.5, 1.0),\n                0.4 * vec3(0.25, 0.5, 1.0), 0.5 + 0.5 * normalize(rd).y);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(iResolution.x / iResolution.y, 1.);\n    float time = iTime;\n\n    setup_cuts();\n\n    vec3 target = vec3 (0., 0., 0.);\n    float an = TAU * time / 20. + PI;\n    vec3 ro = target + 2.8 * vec3(cos(an), .8, sin(an));\n    mat3 cam = get_camera(ro, target);\n    float zoom = 1.;\n    vec3 rd = cam * vec3(uv, zoom);\n\n    float cone_radius = .7071 / (iResolution.y * zoom);\n\n    float coverage = -1.0;\n    vec3 cover_dir = vec3(0.);\n\n    const float aperture = .025;\n    const float focus = 1.9;\n\n    vec3 col = vec3(0.);\n\n    float t = 0.;\n    for (int i = 0; i < 25; ++i) {\n        float radius = t * cone_radius + aperture * abs(t - focus);\n        vec3 pos = ro + t * rd;\n        float dist = map(pos);\n\n        if (dist < radius) {\n            vec3 normal = get_normal(pos, radius);\n\n            vec3 albedo = vec3(.15);\n            vec3 refl_col = vec3(0.);\n            // if the normal not looking outside of the sphere\n            // so it's inner plane and should be colored\n            if (dot(pos, normal) < 0.5) {\n                albedo = vec3(3.5, 0.0, 0.0);\n                \n                vec3 rd = reflect(rd, normal);\n                float t = trace(ro + normal * 0.02, rd);\n                vec3 nro = ro + rd * t;\n                vec3 new_norm = get_normal(nro, radius);\n                refl_col = vec3(.95, 0., 0.) *\n                           (dot(new_norm, normalize(ro)) * 0.5 + 0.5);\n\n            }\n\n            vec3 ambient =\n                vec3(.1) * smoothstep(.7, 2.0, length(pos.xz) + abs(pos.y));\n            vec3 directional =\n                3.0 * vec3(1, .1, .13) *\n                max(dot(normal, normalize(vec3(-2, -2, -1))), .0);\n            directional *=\n                smoothstep(.5, 1.5, dot(pos, normalize(vec3(1, 1, -1))));\n\n            float f = 1.0 - abs(dot(normal, rd));\n            float fresnel = f*f*f*f*f;\n            fresnel = mix(.03, 1.0, fresnel);\n\n            vec3 reflection = sky(reflect(rd, normal));\n\n            vec3 sample_color = mix(albedo * (ambient + directional),\n                                    reflection, vec3(fresnel));\n            sample_color += refl_col;\n\n            // bottom light\n            {\n                float dif = 0.02 * clamp(0.5 - 0.5 * normal.y, 0., 1.);\n                sample_color += dif;\n            }\n\n            float new_coverage = -dist / radius;\n            vec3 new_coverage_dir = normalize(normal - dot(normal, rd) * rd);\n\n            new_coverage +=\n                (1.0 + coverage) * (.5 - .5 * dot(new_coverage_dir, cover_dir));\n            new_coverage = min(new_coverage, 1.0);\n\n            if (new_coverage > coverage) {\n                col += sample_color * (new_coverage - coverage) * .5;\n\n                cover_dir =\n                    normalize(mix(new_coverage_dir, cover_dir,\n                                  (coverage + 1.0) / (new_coverage + 1.0)));\n                coverage = new_coverage;\n            }\n        }\n        t += max(dist, radius );\n        if (dist < -radius || coverage > 1.0)\n            break;\n    }\n    col += (1.0 - coverage) * .5 * sky(rd);\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    col = clamp(col, 0., 1.);\n    \n    // Gamme correction\n    col = pow(col, vec3(0.4545));\n    \n    // Dithering\n    col += sin(fragCoord.x * 114.0) * sin(fragCoord.y * 251.9) / 512.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVGWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[832, 877, 922, 922, 1168], [1169, 1169, 1212, 1212, 1539], [1540, 1540, 1569, 1569, 1670], [1776, 1776, 1795, 1795, 2281], [2343, 2343, 2393, 2393, 2523], [2525, 2525, 2555, 2651, 2716], [2718, 2718, 2735, 2735, 2774], [2776, 2847, 2885, 2885, 2957], [2959, 2959, 2984, 2984, 3055], [3057, 3057, 3076, 3076, 4110], [4112, 4112, 4143, 4143, 4317], [4319, 4319, 4355, 4355, 4531], [4533, 4533, 4567, 4567, 4683], [4685, 4685, 4705, 4705, 5173], [5175, 5191, 5209, 5209, 5329], [5331, 5409, 5431, 5431, 5519], [5521, 5521, 5578, 5578, 9027]]}
{"id": "sdKGz3", "name": "fire Sun", "author": "pc6270", "description": "color adjust from https://www.shadertoy.com/view/ltBfDt", "tags": ["fire"], "likes": 6, "viewed": 131, "published": "Public API", "date": "1638819950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\n\nfloat random (in vec2 p) { \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1. - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat light(in vec2 pos,in float size,in float radius,in float inner_fade,in float outer_fade){\n\tfloat len = length(pos/size);\n\treturn pow(clamp((1.0 - pow( clamp(len-radius,0.0,1.0) , 1.0/inner_fade)),0.0,1.0),1.0/outer_fade);\n}\n\n\nfloat flare(in float angle,in float alpha,in float time){\n\tfloat t = time;\n    float n = noise(vec2(t+0.5+abs(angle)+pow(alpha,0.6),t-abs(angle)+pow(alpha+0.1,0.6))*7.0);\n   //\tn = 1.0;\n    float split = (15.0+sin(t*2.0+n*4.0+angle*20.0+alpha*1.0*n)*(.3+.5+alpha*.6*n));\n   \n    float rotate = sin(angle*20.0 + sin(angle*15.0+alpha*4.0+t*30.0+n*5.0+alpha*4.0))*(.5 + alpha*1.5);\n   \n    float g = pow((2.0+sin(split+n*1.5*alpha+rotate)*1.4)*n*4.0,n*(1.5-0.8*alpha));\n\t\n    g *= alpha * alpha * alpha * .5;\n\tg += alpha*.7 + g * g * g;\n\treturn g;\n}\n\n#define SIZE 2.8\n#define RADIUS 0.07\n#define INNER_FADE .85\n#define OUTER_FADE 0.02\n#define SPEED .1\n#define BORDER 0.19\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/iResolution.y;\n\tfloat f = .0;\n    float f2 = .0;\n    float t = iTime * SPEED;\n\tfloat alpha = light(uv,SIZE,RADIUS,INNER_FADE,OUTER_FADE);\n\tfloat angle = atan(uv.x,uv.y);\n    float n = noise(vec2(uv.x*20.+iTime,uv.y*20.+iTime));\n   \n\tfloat l = length(uv);\n\tif(l < BORDER){\n        t *= .8;\n        alpha = (1. - pow(((BORDER - l)/BORDER),0.22)*0.7);\n        alpha = clamp(alpha-light(uv,0.2,0.0,1.3,.5)*.55,.0,1.);\n        f = flare(angle*1.0,alpha,-t*.5+alpha);\n        f2 = flare(angle*1.0,alpha*1.2,((-t+alpha*.5+0.38134)));\n\n\t}else if(alpha < 0.1){\n\t\tf = alpha;\n\t}else{\n\t\tf = flare(angle,alpha,t)*1.3;\n\t}\n\tfragColor = vec4(vec3(f*1.5+f2*f2,f*alpha*0.5+f2*f2*.5,f*alpha*0.0+f2*(sin(angle-t*.5)*.0)),.5);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 173], [175, 175, 202, 202, 584], [586, 586, 681, 681, 815], [818, 818, 875, 875, 1364], [1488, 1488, 1543, 1543, 2303]]}
{"id": "sl3SRn", "name": "Intersection rays/segments", "author": "Yusef28", "description": "I stumbled on way more elegant and shorter easier to remember way to calculate ray-ray or even segment-segment intersections.\nhttps://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282", "tags": ["intersection"], "likes": 8, "viewed": 132, "published": "Public API", "date": "1638574597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Line Segment Intersection                        //\n// Sources: http://paulbourke.net/geometry                 //\n// Listening to: Andromida - Hellscape (FULL ALBUM STREAM) //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n/*\nI found a way method of finding intersections between two\nsegments in a plane. \nby found I mean I found it on stackexchange\n\nhttps://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282\n\nThe previous method I had (in the source of this fork) \nrequires way more calculation and if you want something you\ncan whip out of you back pocket in a pinch that isn't the \nthing you'll want.\n\nThis is way cooler.\n\nyou have teh intersection of two rays expressed as:\n\nro1 + rd1*t = ro2 + rd2*s (where s and t are the distances)\n\nYou can just eliminate one by taking the dot product\nof every vector in this equation by a vector perpendicular\nto one of either rd1 or rd2!\n\nBecause dot(rd1,perp_rd1) will be 0, \nyou eliminate that term including the t!\n\nBeautiful!\n\nWe just need to remember to repeat this for s so we can make\nsure we have a valid intersection (s and t both betwen the \nend ranges of the segments. Or in the case of rays, just >= 0)\n\n*/\n#define line1Col vec3(1.,.2,.5)\n#define line2Col vec3(1.,.3,.3)\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  BACKGROUND GRID DESIGN             //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=10.;\n    //graph background\n    vec3 col = vec3(0.1);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    \n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    \n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    \n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////  LINE INTERSECTION CALCULATIONS     //\n      //                                   //\n      /////////////////////////////////////\n      \n    //Line Points\n    vec2 A1 = vec2(-3.4+sin(iTime),-2.4+sin(iTime+0.5));\n    vec2 B1 = vec2(3.4+sin(iTime+4.),3.4+sin(iTime+2.));\n    vec2 ro1 = A1;\n    vec2 rd1 = normalize(B1-A1);\n    float maxLength1 = length(B1-A1);\n    \n    vec2 A2 = vec2(-3.3+sin(iTime+1.4),-3.6+sin(iTime+3.));\n    vec2 B2 = vec2(2.3+sin(iTime+0.2),3.1+sin(iTime+0.3))*10.;\n    vec2 ro2 = A2;\n    vec2 rd2 = normalize(B2-A2);\n    float maxLength2 = length(B2-A2);\n    //we know that teh intersection of two rays is\n    // ro1+rd1*t = ro2+rd2*s\n    // There is a really elegant solution for this\n    // use dot everything by a perpendicualr vector\n    // to rd1 and its unknown will cancel out.\n    vec2 perpRD1 = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perpRD1) - dot(ro2,perpRD1)) / dot(rd2,perpRD1);\n    \n    //we just need to repeat for the other side to check\n    //validity for both rays\n    \n    vec2 perpRD2 = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perpRD2) - dot(ro1,perpRD2)) / dot(rd1,perpRD2);\n    \n    //when valid, either s or t will lead to the samer\n    // intersection point\n    \n    vec2 validPoint = ro1 + rd1*t;\n    \n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n        \n    //line 1\n    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));\n    col = mix(col, vec3(1.,.2,.5), f);//0.5\n    \n    //line 2\n    f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A2, B2, uv)));\n    col = mix(col, vec3(1.,.3,.3), f);\n    \n    \n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);\n    col = mix(col, line1Col, f);\n    //segment end points line 1\n    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);\n    col = mix(col, line1Col, f);\n    \n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-A2)-0.02);\n    col = mix(col, line2Col, f);\n    //segment end points line 2\n    f = 1.-smoothstep(0.03,0.08,length(uv-B2)-0.02);\n    col = mix(col, line2Col, f);\n    \n    \n    // if s and t are both between 0. and maxLength they are\n    // valid for both the linear interpolations we need.\n    // so show the intersection point.\n    if(s >= 0. && t >= 0. && t <= maxLength1 && s <= maxLength2){\n    \n    //intersection\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-validPoint)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-validPoint)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    \n   }\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n     \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}\n", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3SRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 1677, 1718, 1718, 1920], [1922, 1922, 1979, 2031, 6771]]}
{"id": "sl3XDM", "name": "[TDF2021] phonometer probe", "author": "gyabo", "description": "I wrote a shadercode in 25 minutes at the TokyoDemoFest2021 party, enjoy! ;-)\nNote : Please click pause and play to iChannel0 if got the no sound.\n", "tags": ["raymarching", "livecoding"], "likes": 8, "viewed": 67, "published": "Public", "date": "1639211030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TDF2021 ShaderShowDown q-f : gyabo\n//Ports to ShaderToy. original as follows,\n//https://gist.github.com/kumaashi/eee4971857e6dd7a541d8dc455ebf2eb\n//https://twitter.com/gyabo/status/1469569058811293696\n#define time iTime\n#define v2Resolution iResolution\n#define gl_FragCoord fragCoord\n#define texFFTSmoothed iChannel0\n#define fragColor out_color\n\nvec4 plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n\treturn vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvec4 getf(vec2 uv) {\n  uv = abs(uv * 0.15);\n  //float m0 = texture(texFFTSmoothed, uv.x).x * 5.0; //Bonzomatic\n  //float m1 = texture(texFFTSmoothed, uv.y).x * 5.0;  //Bonzomatic\n  float m0 = texture(texFFTSmoothed, uv.xy * 2.0).x * 0.5;\n  float m1 = texture(texFFTSmoothed, uv.yx * 2.0).x * 0.5;\n  return vec4(\n  m0 * m1,\n  m0 - m1,\n  m0 + m1, 1.0) * 2.0;\n}\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec2 rot(vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return vec2(\n  p.x * c - p.y * s,\n  p.x * s + p.y * c);\n}\n\nfloat map(vec3 p) {\n  float t = length(mod(p, 2.0) - 1.0) - 0.45;\n  float h = length(getf(mod(p.xz * 0.2, 1.0)).xyz) * 0.5;\n  t = min(t, (h + 1.0) - dot(abs(p), vec3(0, 1, 0)));\n  t = min(t, length(mod(p.xz, 2.0) - 1.0) - 0.1);\n  t = min(t, length(mod(p.zy, 2.0) - 1.0) - 0.1);\n  t = min(t, length(mod(p.xy, 2.0) - 1.0) - 0.1);\n  vec3 ap = p;\n  float bd = box(mod(ap, 2.0) - 1.0, vec3(0.4));\n  t = max(-bd, t);\n \n  return t;\n}\n\nvec3 getnor(vec3 p) {\n  float t = map(p);\n  vec2 d = vec2(0.001, 0.0);\n  return normalize(vec3(\n    t - map(p + d.xyy),\n    t - map(p + d.yxy),\n    t - map(p + d.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  vec2 auv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  auv = auv * 2.0 - 1.0;\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  vec3 dir = normalize(vec3(uv, 1.0));\n  dir.xz = rot(dir.xz, time * 0.01);\n  //dir.zy = rot(dir.zy, time * 0.03);\n  \n  vec3 pos = vec3(0, 0, time);\n  float t = 0.0;\n  for(int i = 0 ; i < 100; i++) {\n    t += map(pos + dir * t) * 0.75;\n  }\n\n  vec3 ip = pos + dir * t;  \n  vec3 N = normalize(getnor(ip));\n  vec3 V = normalize(ip);\n  vec3 L = normalize(vec3(1,2,3));\n  vec3 H = normalize(N + V);\n  float D = max(0.0, dot(N, L));\n  float S = max(0.0, pow(dot(H, N), 64.0));\n \n  vec3 fog = vec3(2,2,3) * t * 0.02;\n  float vvvv = 1.0 - dot(auv * 0.4, auv);\n  out_color = vec4(map(ip + 0.5));\n  out_color *= D;\n  out_color *= S;\n  out_color.xyz += fog;\n  out_color += getf(uv) * 0.5;\n  out_color *= vvvv;\n}\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3XDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 348, 381, 381, 544], [546, 546, 566, 566, 904], [906, 906, 933, 933, 987], [989, 989, 1016, 1016, 1116], [1118, 1118, 1137, 1137, 1544], [1546, 1546, 1567, 1567, 1717], [1719, 1719, 1776, 1776, 2731]]}
{"id": "sl3XRn", "name": "Segments - intersection", "author": "iq", "description": "Intersecting two line segments. Performance improvement and math simplification of [url]https://www.shadertoy.com/view/sl3SRn[/url]", "tags": ["2d", "line", "intersection", "segment"], "likes": 26, "viewed": 361, "published": "Public API", "date": "1638577123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersecting two line segments.\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    float d = cro(b2-a2,b1-a1);\n    float s = cro(a1-a2,b1-a1) / d;\n    float t = cro(a1-a2,b2-a2) / d;\n    point = a1 + (b1-a1)*t; // or point = a2 + (b2-a2)*s;\n    return s>=0.0 && t>=0.0 && t<=1.0 && s<=1.0;\n}\n\n/*\n// same math as above, alternative writing by mla (see comments)\nbool intersect( vec2 a1, vec2 b1, vec2 a2, vec2 b2, out vec2 point )\n{\n    vec2 st = inverse(mat2(b1-a1,a2-b2))*(a2-a1);\n    point = a1 + (b1-a1)*st.x;\n    return s>=0.0 && t>=0.0 && t<=1.0 && s<=1.0;\n    // alternative range test with single comparison\n    // st = abs(st-0.5); return max(st.x,st.y)<0.5;\n}\n*/\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/(dot(ba,ba)),0.0, 1.0);\n    return length(pa-ba*h);\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // animate\n    vec2 a1 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.1+vec2(0.0,0.5)));\n    vec2 b1 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.2+vec2(5.0,2.0)));\n    vec2 a2 = vec2(-2.0+vec2(1.5,1.0)*sin(iTime*1.3+vec2(3.0,1.0)));\n    vec2 b2 = vec2( 2.0+vec2(1.5,1.0)*sin(iTime*1.4+vec2(1.5,4.5)));\n\n    // NDC coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // background\n    vec3 col = vec3(0.15) - 0.04*length(p);\n\n    p *= 3.5;\n        \n    // segment 1\n    {\n    float    d = sdLine(p,a1,b1)-0.02;\n    d = min( d,  sdDisk(p,a1,0.06) );\n    d = min( d,  sdDisk(p,b1,0.06) );\n    col = mix(col, vec3(0.0,0.7,0.7), smoothstep(0.01,0.0,d) );\n    }\n    \n    // segment 2\n    {\n    float    d = sdLine(p,a2,b2)-0.02;\n    d = min( d,  sdDisk(p,a2,0.06) );\n    d = min( d,  sdDisk(p,b2,0.06) );\n    col = mix(col, vec3(0.2,0.5,1.0), smoothstep(0.01,0.0,d) );\n    }\n\n    // intersection\n    vec2 pos;\n    if( intersect(a1, b1, a2, b2, pos) )\n    {\n        float d = sdDisk(p,pos,0.03);\n        d = min( d, abs(d-0.2) ) - 0.01; // onion, see https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n        col = mix(col, vec3(1.0,0.7,0.0), smoothstep(0.01,0.0,d));\n    }    \n\n    // cheap dither (color banding removal)\n    col += (1.0/512.0)*sin(fragCoord.x*2.0+13.0*fragCoord.y);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3XRn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1114, 1149, 1149, 1177], [1179, 1179, 1249, 1249, 1462], [1844, 1919, 1967, 1967, 2081], [2083, 2158, 2208, 2208, 2236], [2238, 2238, 2295, 2310, 3645]]}
{"id": "sl3XWM", "name": "[TDF2021] Lightning Tunnel", "author": "gam0022", "description": "Shader showdown quarter-final at Tokyo Demo Fest 2021 coded in 25 minutes.\n\nhttps://twitter.com/gam0022/status/1469562828831195140", "tags": ["3d", "raymarching", "volume", "livecoding"], "likes": 15, "viewed": 172, "published": "Public", "date": "1639208190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original Bonzomatic Shader\n// https://gist.github.com/gam0022/6332d497d886bdf9d3dbd714b88d852c\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid U(inout vec4 m, float d, float a, float b, float c) {\n    if (d < m.x) m = vec4(d, a, b, c);\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvec4 map(vec3 p) {\n    vec3 pos = p;\n    p = mod(p, 1.) - 0.5;\n    vec4 m = vec4(1, 1, 1, 1);\n\n    float s = 1.;\n    for (int i = 0; i < 5; i++) {\n        p = abs(p) - 0.5;\n        rot(p.xy, -0.5);\n        p = abs(p) - 0.4 + 0. * cos(TAU * time / 4.);\n        rot(p.yz, -0.1);\n\n        float a = 1.4;\n        p *= a;\n        s *= a;\n    }\n\n    U(m, sdBox(p, vec3(0.5, 0.05, 0.05)) / s, 1., 1., 0.);\n    U(m, sdBox(p, vec3(0.5 + 0.5 * (cos(TAU * time / 4.)), 0.06, 0.05)) / s, 0., 0.1, 0.5);\n    U(m, sdBox(p, vec3(0.2, 0.6, 0.1)) / s, 0., saturate(cos(TAU * (time + pos.z / 8.))), -0.5);\n\n    return m;\n}\n\nvec3 fbm(vec3 p) { return sin(p) + sin(p * 2.) / 2. + sin(p * 4.) / 4.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec2 m;\n    m.x = atan(uv.x / uv.y) / 3.14;\n    m.y = 1. / length(uv) * .2;\n    float d = m.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 0, time);\n    vec3 ray = vec3(uv, 1.1 + cos(TAU * time / 8.));\n    ray += 0.1 * fbm(vec3(1, 2, 3) + TAU * time / 4.);\n    // rot(ray.xy, time);\n    // rot(ray.yz, time);\n    ray = normalize(ray);\n\n    float t = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + ray * t;\n        vec4 m = map(p);\n        float d = m.x;\n        if (m.y == 1.) {\n            t += d;\n            if (d < 0.001) {\n                col += 0.005 * float(i);\n                break;\n            }\n        } else {\n            t += abs(d) * 0.5 + 0.01;\n            col += saturate(0.001 * vec3(1. + m.w, 1, 1. - m.w) * m.z / abs(d));\n        }\n    }\n\n    col = mix(vec3(0), col, exp(-0.7 * t));\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3XWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 199, 228, 228, 321], [323, 323, 381, 381, 422], [424, 424, 457, 457, 503], [505, 505, 523, 523, 1109], [1111, 1111, 1129, 1129, 1184], [1186, 1186, 1243, 1243, 2246]]}
{"id": "sl3Xz8", "name": "yonatan's spooky towers", "author": "darrellprograms", "description": "Exploring and making notes on one of @zozuar's twigl shaders. I made the towers grow over time hoping to get a clearer idea of how the fractal ray marching works, but I find it quite visually appealing.", "tags": ["raymarching", "test", "de"], "likes": 3, "viewed": 107, "published": "Public", "date": "1638686814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Original code (line breaks added):\n// float i,s,e,m;vec3 d,w,q,p;d=FC.rgb/r.y-1.;\n// for(w+=4.;i++<2e2;e=clamp(length(p)/s-m/s,w.y-m,.2)+i/1e6)\n// {i>1e2?d/=d,o:o+=exp(-e*5e3);s=2.;p=w+=d*e;p.xz*=rotate2D(t*.2);\n// p-=q=round(p);p.y=w.y-(m=fsnoise(q.zx)*4.);for(int j;j++<9;p.y-=m)\n// s/=e=min(dot(p,p),.4)+.1,p=abs(p)/e-.2;}o*=e/20.;\n//\n// Twitter: https://twitter.com/zozuar/status/1467319312067219456\n// twigl: bit.ly/3Gjl1OR\n//\n// seems to descend through @gaziya5 https://twitter.com/gaziya5/status/1360236394929561607\n// from @pabloandrioli's shadertoy.com/view/4lX3Rj\n//\n// it is based on kaliset fractals\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// http://www.fractalforums.com/3d-fractal-generation/kaliset-3d-fractal-used-as-coloring-and-bump-mapping-for-de-systems/\n//\n// ...with the ray marching method of Distance Estimation (DE)\n// https://inst.eecs.berkeley.edu/~cs184/sp12/assignments/Archive/HW6/Fractal%20Renderer.htm friendly intro\n// http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/ guide with examples\n//\n// ray marching is a form of ray casting which uses variable step sizes based on how open the space is, which saves steps\n// while preserving accuracy and enables various effects\n//\n// here the ray does something like zeno's paradox approaching the surface without touching it\n\n//\n// I've done a little rearranging and replacing constants with named variables, but I mostly wanted to just open this up and\n// comment it to understand what's happening, without making it too hard to see how each piece relates to the original\n// ultra-compact twigl code\n//\n// I think it's hard to understand code without changing it\n// suggestion: start by finding where to restore the original behavior, then see what interesting differences you can cause\n//\n\n\n//from the twigl library https://github.com/doxas/twigl\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fsnoise(vec2 c){ //fast smooth noise\n    return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//myclamp fixes a bug in the original, which depends on clamp() working this way\n//clamp() has undefined behavior if minval > maxval\n// but this will always clamp to maxval if minval > maxval\nfloat myclamp(float x, float minval, float maxval){\n    return min(max(x,minval),maxval);\n    //return max(min(x,maxval),minval); // debug code for producing unwanted results of clamp() on some platforms\n    //return clamp(x, minval, maxval); // original calculation with undefined behavior\n}\n\nvec3 render(vec2 uv){\n    float i, //iterator\n     s, //scale factor\n     e, //ray marching step size / distance estimate\n     m; // height of tower (affects shape)\n    vec3 d, //direction of ray\n     w, //position of tip of ray\n     q, //tile of ray tip\n     p; //position of ray tip within tile\n    d=vec3(uv,0)-1.0; //set ray direction\n    //d/=length(d); //seems like the direction vector should be normalized, but you can't have it all in ultrashort code\n    vec3 o;\n    \n    bool original=false; //make this true to see the original behavior of @zozuar's code\n    bool badpixel=false; //for debugging tests\n    \n    float tallest= original ? 4. : .4+iTime*0.1; //I like the look when the towers grow, it doesn't have to be a static scene\n    float rotspeed= original ? .2 : .01; //it's easier to study when it's slow\n    float mainloops=200.;\n    int iterations= original ? 9 : 14 ; //nicer with a bit higher number\n    \n    if(original) w+=tallest; //move ray starting position up and away from the center of rotation to fly around\n    else w=vec3(0.,tallest,0.); //move up with tower growth, but sit at the xz origin and pivot to look around\n    while(i<mainloops){\n        i+=1.;\n        if(i>mainloops/2.){ //when halfway through fixed-length ray marching loop, switch to shadows\n            d=vec3(1.,1.,1.);\n            //d/=length(d);\n        }else{\n            o+=exp(-e*5000.); //the larger the step size, the less brightness is added, and a fixed number of steps is taken\n            //the ray is marched to more distant objects through more unimpeded long steps\n        }\n        s=2.0; //initialize the scale factor for this loop\n        w+=d*e; //advance ray\n        p=w; //start dividing position into tile coordinates, and position within tile\n        p.xz*=rotate2D(iTime*rotspeed); //rotate the world, not the camera\n        q=round(p); p-=q; //get the tile and position within tile\n        m=abs(fsnoise(q.zx))*tallest;//height / shapeseed of towers from smooth noise function\n        //\n        //here's where the magic happens: the fractal math to calculate a distance estimate to\n        // the geometry and use it to produce the next ray marching step distance\n        //\n        if(1==0){ //convenience branch for quickly trying modified behavior\n            //branch to mess with\n            //iterations= 9; //convenience assignment, doesn't need to be in the loop\n            p.y=w.y-m; //comment out for repeating vertical tiles\n            p=abs(p);\n            for(int j; j<iterations; j++){\n                const float a=.4, b=.2; //these seem to be arbitrary tuning factors under .5 and .25\n                e=min(length(p)*length(p),a)+(.5-a);\n                //e=.5; //boxes lol\n                //e=.48; //boxes of boxes\n                //e=.6; //broken\n                s/=e; p/=e;\n                p=abs(p - vec3(b,m+b,b));\n            }\n            e=(length(p)-m)/s;\n            e=myclamp(e,w.y-m,.2)+i/1e6;\n        }else{\n            //branch to keep original behavior\n            p.y=w.y-m;\n            for(int j; j++<iterations; p.y-=m){\n                s/=e=min(dot(p,p),.4)+.1; //e is getting used as a temporary variable\n                //e is always between .1 and .5, so scale factor s will be increased 2X to 10X per iteration\n                p=abs(p)/e-.2; //the magnitude of p is likewise increased, but then it is reduced\n            }\n            e=myclamp((length(p)/s)-(m/s),w.y-m,.2)+i/1e6;\n        }\n        //notes:\n        //e is back to its main purpose as step size\n        //if(e<0.) badpixel=true; // debugging: it'll be green if e ever goes negative\n    }\n    if(!original){ //debugging code, enabling or disabling shouldn't change anything unless the soften shadows is uncommented\n        if(e<0.1){ //e should either be negligible or slightly over .2 without doing this\n            e=0.;\n            e=.1; //soften shadows\n        }else{\n            e=.2;\n        }\n    }\n    //e=.2; // uncomment to deactivate shadows\n    o*=e/20.+ (original ? .0 : .001) ; //intensity correction and shadow rendering, based on shadow ray final step size (did the ray hit anything?)\n    if(o.r>1.0){ //badcolor debugging code (helped to figure out the clamp bug)\n        o=vec3(1.,0.,0.);\n    }\n    if(o.r<0.0){\n        o=vec3(0.,0.,1.);\n    }\n    if(badpixel){\n        o=vec3(0.,1.,0.);\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int aa=0; //anti-aliasing through super-sampling, will average aa^2 samples, if 2 or more\n    //because there's a lot of fine detail and edges, it looks a lot nicer with anti-aliasing\n    if(aa<2){\n        vec2 uv = fragCoord/iResolution.xy;\n        vec3 o=render(uv);\n        // Output to screen\n        fragColor = vec4(o,1.0);\n    }else{\n        vec3 osum;\n        for(int i=0; i<aa; i++){\n            for(int j=0; j<aa; j++){\n                vec2 uv = (fragCoord+vec2(i,j)/float(aa))/iResolution.xy;\n                osum+=render(uv);\n            }\n        }\n        // Output to screen\n        fragColor = vec4(osum/float(aa*aa),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3Xz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1868, 1924, 1947, 1947, 1999], [2001, 2001, 2023, 2043, 2112], [2114, 2306, 2357, 2357, 2598], [2600, 2600, 2621, 2621, 6959], [6961, 6961, 7018, 7018, 7669]]}
{"id": "slcSRM", "name": "Watercolor Vignette", "author": "FroggerGuy", "description": "A Simple effect I created =D", "tags": ["watercolornoisevingettesimple"], "likes": 6, "viewed": 108, "published": "Public API", "date": "1638834216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n\nfloat simp(vec2 uv) {\n    uv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    f = 0.2 + 0.8*f;\n    return f;\n}\n\n\nvec4 bumpFromDepth(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = simp(uv);\n    \n  vec2 dxy = height - vec2(\n      simp(uv + vec2(step.x, 0.)), \n      simp(uv + vec2(0., step.y))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\nvec4 bumpFromTex(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = simp(uv);\n    \n  vec2 dxy = height - vec2(\n      length(texture(iChannel0, uv + vec2(step.x, 0.))), \n      length(texture(iChannel0, uv + vec2(0., step.y)))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 offset = bumpFromDepth(uv + vec2(floor(iTime*4.0)/4.0), iResolution.xy, .1)/80.0;\n    \n\n    // Output to screen\n                 texture(iChannel0, uv + offset.xy)*0.4;\n     \n                 \n    fragColor = (texture(iChannel0, uv + offset.xy)*0.4) + (texture(iChannel0, uv)*0.6);\n    fragColor += length(bumpFromDepth(uv, iResolution.xy, .1))*0.25;\n    fragColor += smoothstep(-0.4, 0.0, sdRoundedBox((uv + offset.xy) - vec2(0.5), vec2(0.65), vec4(0.25)));\n    \n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 208], [210, 210, 236, 236, 715], [718, 718, 739, 739, 988], [991, 991, 1050, 1050, 1292], [1294, 1294, 1351, 1351, 1637], [1640, 1640, 1695, 1695, 1852], [1854, 1854, 1911, 1961, 2476]]}
{"id": "slcSRS", "name": "cyclics 15  ( 194 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "2tweets", "short", "cyclic"], "likes": 12, "viewed": 127, "published": "Public API", "date": "1639310654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**  // 212 chars  ( see golfing below )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y /.1; \n    float t = mod(iTime,2.),\n    \n          z = t < 1.           ? exp2(fract(iTime))     // phase1: expend\n            : mod(U.x,2.) > 1. ? U.y -=  (2.-t)/.1 , 1. // phase2: insert fall\n            :                       2. ;\n    U.x = fract(U.x/z) * z - .5;                        // lateral expend\n    \n    O = 1.- (length(U)-.47) *R.yyyy/30.;                // draw discs\n    \n}\n/**/\n\n\n\n\n\n/**/ // 194:  -7 by Xor\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U += U - (O.xy=iResolution.xy);\n    U /= O.y * .1;\n    float t = mod(iTime,2.);\n    U.x = mod( U,  t  < 1.          ? exp2(fract(t))\n                 : mod(U.x,2.) > 1. ? U.y -=  20.-t/.1, 1.\n                 :                    2. \n             ).x - .5;\n    \n    O = (.55-length(U)) * O.yyyy/30.;\n}\n/**/\n\n\n\n\n\n/** // 201: -9 chars by Greg, Xor \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( U+U - (O.xy=iResolution.xy) ) / O.y / .1; \n    float t = mod(iTime,2.),\n    \n          z = t < 1.           ? exp2(fract(t))       // phase1: expend\n            : mod(U.x,2.) > 1. ? U.y -=  20.-t/.1, 1. // phase2: insert fall\n            :                       2. ;\n    U.x = mod(U.x,z) - .5;                            // lateral expend\n    \n    O = 1.- (length(U)-.47) * O.yyyy/30.;             // draw discs\n    \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 568, 606, 606, 912]]}
{"id": "slcXRB", "name": "sinX", "author": "thodd_riction", "description": "exercise", "tags": ["learning"], "likes": 1, "viewed": 22, "published": "Public", "date": "1639318423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur)\n{\n\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    \n    float band1 = Band(uv.x, left, right, blur); \n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2;\n}\n\nfloat remap01(float a, float b, float t){ // si t = a, a = 0; la distance entre a et b =1; de a à b = de  à ;\n    return (t-a) / (b-a);                 // t-a = 0, (t=a) = (a-a = 0);\n                                          // si t = 0, t-a/t-a = un chiffre divisé par lui même = 1\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a,b,t) * (d-c) +c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x = abs(uv.x);\n    float t = iTime;\n    float x = uv.x;\n    float m = cos(t+x*1.)*0.1;\n    float y = uv.y+m;\n    float d = length(uv);\n    float c = 0.;\n    float blur = remap(0., .1, .01, .35, x);\n    blur *= blur;\n    c = Rect(vec2(x,y), 0., 1., -.02, .02, blur);\n    float a = Rect(vec2(x,y+.2), 0., 1., -.02, .02, blur);\n    float b = Rect(vec2(x,y-.2), 0., 1., -.02, .02, blur);\n\n    vec3 col = vec3(1., 0., 0.)*(c+a+b);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 199], [201, 201, 284, 284, 419], [421, 421, 462, 532, 709], [711, 711, 768, 768, 813], [815, 815, 872, 872, 1438]]}
{"id": "slcXRj", "name": "Pixel Aurora Borealis", "author": "_Chae4ek_", "description": "Beautiful pixel northern lights in the polar coordinate system", "tags": ["noise", "perlin", "pixel", "spiral", "stars", "polar"], "likes": 5, "viewed": 96, "published": "Public API", "date": "1639391814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n\nfloat rand(in float x) {\n  return fract(sin(x) * 1e4);\n}\n\nfloat rand(in vec2 st) {\n  vec2 r = fract(sin(st) * 2.7644437);\n  return fract(r.y * 276.44437 + r.x);\n}\n\nvec3 rand(in vec3 s) {\n  float t = 4096.0 * sin(dot(s, vec3(17.0, 31.0, 11.0)));\n  return vec3(fract(512.0 * t), fract(64.0 * t), fract(8.0 * t)) - 0.5;\n}\n\n// simplex perlin noise\nfloat snoise(in vec3 p) {\n  vec3 s = floor(p + dot(p, vec3(0.33333333333)));\n  vec3 x = p - s + dot(s, vec3(0.16666666667));\n\n  vec3 e = step(0.0, x - x.yzx);\n  vec3 i1 = e * (1.0 - e.zxy);\n  vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n  vec3 x1 = x - i1 + 0.16666666667;\n  vec3 x2 = x - i2 + 0.33333333333;\n  vec3 x3 = x - 0.5;\n\n  vec4 w = vec4(dot(x, x), dot(x1, x1), dot(x2, x2), dot(x3, x3));\n  w = max(0.6 - w, 0.0);\n  w = pow(w, vec4(4.0));\n  w *= vec4(dot(rand(s), x), dot(rand(s + i1), x1), dot(rand(s + i2), x2), dot(rand(s + 1.0), x3));\n\n  return dot(w, vec4(30.0, 50.0, 30.0, 40.0));\n}\n\nvec2 rot(in vec2 st, in float angle) {\n  float c = cos(angle), s = sin(angle);\n  return mat2(c, -s, s, c) * st;\n}\n\nfloat alfa0(in float r_, in float r, in float theta) {\n  // tan(alfa) = y'/x' = (r'*sin(theta) + r*cos(theta)) / (r'*cos(theta) - r*sin(theta))\n  float s = sin(theta), c = cos(theta);\n  return atan(r_ * s + r * c, r_ * c - r * s);\n}\n\nfloat borealis_green1(in vec2 st, in float step2) {\n  const float a = 100.0;\n  float r = length(st);\n  float theta = atan(st.y, st.x);\n\n  float f_ = a / r;                                 // the equation with respect to theta\n  float n_ = trunc((f_ - theta) / PI2) * PI2 + PI;  // periodic N\n  float r_ = -a / ((theta + n_) * (theta + n_));    // r' = -a / theta^2\n  float alfa = alfa0(r_, r, theta);\n  r += 4.0 * cos(rot(st, alfa).x - iTime) + rand(r) * 2.0;\n  // recalc:\n  float f = a / r;                                // the equation with respect to theta\n  float n = trunc((f - theta) / PI2) * PI2 + PI;  // periodic N\n  float func = a / (theta + n);                   // the equation with respect to r\n\n  return smoothstep(0.0, step2, abs(r - func));\n}\n\nfloat borealis_green2(in vec2 st, in float step2) {\n  st.x = -st.x;\n  const float a = 1.55;\n  float r = length(st);\n  float theta = atan(st.y, st.x);\n\n  float f_ = log(r) / log(a);                       // the equation with respect to theta\n  float n_ = trunc((f_ - theta) / PI2) * PI2 + PI;  // periodic N\n  float r_ = pow(a, theta + n_) * log(a);           // r' = pow(a, theta) * log(a)\n  float alfa = alfa0(r_, r, theta);\n  r += 4.0 * cos(rot(st, alfa).x + iTime) + rand(r) * 2.0;\n  // recalc:\n  float f = log(r) / log(a);                      // the equation with respect to theta\n  float n = trunc((f - theta) / PI2) * PI2 + PI;  // periodic N\n  float func = pow(a, theta + n);                 // the equation with respect to r\n\n  return smoothstep(0.0, step2, abs(r - func));\n}\n\nfloat borealis_blue(in vec2 st, in float step2) {\n  const float a = 100.0;\n  float r = length(st);\n  float theta = atan(st.y, st.x);\n\n  float f_ = a / r;                                 // the equation with respect to theta\n  float n_ = trunc((f_ - theta) / PI2) * PI2 + PI;  // periodic N\n  float r_ = -a / ((theta + n_) * (theta + n_));    // r' = -a / theta^2\n  float alfa = alfa0(r_, r, theta);\n  r += 4.0 * cos(rot(st, alfa).y + iTime) + rand(r) * 2.0;  // it's weird, but pretty good\n  // recalc:\n  float f = a / r;                                // the equation with respect to theta\n  float n = trunc((f - theta) / PI2) * PI2 + PI;  // periodic N\n  float func = a / (theta + n);                   // the equation with respect to r\n\n  return smoothstep(0.0, step2, abs(r - func));\n}\n\nfloat particles(in vec2 st, in float step1) {\n  float r = rand(floor(st));\n  return smoothstep(step1, 1.0, r) * max(0.0, sin(r * 34433.0 + 2.0 * iTime));\n}\n\nvec3 color;\nconst vec3 GREEN = vec3(0.0, 1.0, 0.1647);\nconst vec3 GREEN2 = vec3(0.0039, 0.2275, 0.1216);\nconst vec3 GREEN3 = vec3(0.0275, 0.2118, 0.098);\nconst vec3 BLUE = vec3(0.0039, 0.0196, 0.0667);\nconst vec3 BLUE2 = vec3(0.0, 0.1451, 0.3608);\nconst vec3 BLUE3 = vec3(0.4039, 0.5294, 0.7137);\nconst vec3 BLUE4 = vec3(0.0863, 0.1451, 0.2);\n\nfloat christmas_tree(in vec2 st) {\n  const float a = 0.4;\n  float x = st.x - 9.0, y = st.y + 31.0;\n  float f = 0.27 * cos(3.2 * y * a + abs(x * a)) * (y * a - 15.0) - 2.4 * abs(x * a) -\n            0.46 * (y * a + abs(y * a)) + 5.0 * (y * a - abs(y * a - 2.0));\n\n  if (abs(f) < 6.0) color += GREEN3 * particles(st, 0.3);  // extra particles around\n  return step(f, -4.0);\n}\n\n#define scale 100.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  st *= scale;\n\n  // alignment\n  vec2 st2 = vec2(st.x - 15.0, st.y - 2.0 * rand(floor(st.x)));\n  st2 = floor(st2);\n  st2.y = st2.y * 1.2 - 35.0;\n  st2.x -= 17.0;\n  st2 = rot(st2, 4.5);\n\n  // background\n  color = BLUE * max(st.y * -0.09, 1.0);\n\n  // green 1\n  color += GREEN2 * (1.0 - borealis_green1(st2, 1.0));\n  color += GREEN * (1.0 - borealis_green1(st2, 6.0));\n  color += BLUE * (1.0 - borealis_green1(st2, 14.0));\n\n  // green 2\n  vec2 st4 = rot(st2, -PI);\n  st4.x += -10.0;\n  st4.y += 5.0;\n  color += GREEN2 * (1.0 - borealis_green2(st4, 2.0));\n  color += GREEN * (1.0 - borealis_green2(st4, 7.5));\n  color += BLUE * (1.0 - borealis_green2(st4, 16.0));\n\n  // blue\n  st2 = rot(st2, -0.6);\n  st2 *= 0.5;\n  color += BLUE * (1.0 - borealis_blue(st2, 1.0));\n  color += BLUE * (1.0 - borealis_blue(st2, 3.0));\n  color += BLUE * (1.0 - borealis_blue(st2, 6.0));\n\n  // particles and snow\n  vec2 st3 = st;\n  st3.y += 0.1 * iTime * (3.0 + 15.0 * rand(floor(st3.x)));\n  st2.y += 0.1 * iTime * (3.0 + 15.0 * rand(floor(st2.x)));\n  color += BLUE2 * particles(st2, 0.995);\n  color += BLUE3 * particles(st3, 0.992);\n\n  st = floor(st);\n  color *= christmas_tree(st);\n\n  // cliffs\n  float x2 = st.x * 0.09 + 1.0;\n  if (x2 < 0.0 || x2 > 3.4) {\n    float threshold = snoise(vec3(x2, x2, 10.0)) * 30.0 - 15.0;\n    if (st.y < threshold + 2.0 * rand(st)) color = BLUE4 * particles(st, 0.0);\n    if (st.y < threshold - 1.0) color = vec3(0.0);\n  }\n  float x1 = st.x * 0.01;\n  if (st.y < snoise(vec3(x1, x1, 10.0)) * 26.0 - 20.0) color = vec3(0.0);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 76, 76, 108], [110, 110, 134, 134, 214], [216, 216, 238, 238, 370], [372, 396, 421, 421, 984], [986, 986, 1024, 1024, 1099], [1101, 1101, 1155, 1244, 1333], [1335, 1335, 1386, 1386, 2094], [2096, 2096, 2147, 2147, 2880], [2882, 2882, 2931, 2931, 3671], [3673, 3673, 3718, 3718, 3828], [4174, 4174, 4208, 4208, 4547], [4570, 4570, 4625, 4625, 6254]]}
{"id": "slcXW8", "name": "Synthwave canyon", "author": "mrange", "description": "Synthwave landscape", "tags": ["planemarching"], "likes": 27, "viewed": 336, "published": "Public API", "date": "1638993692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 - Synthwave canyon\n#define RESOLUTION    iResolution\n#define TIME          iTime\n#define PI            3.141592654\n\n//#define CRT_EFFECT\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract(sin(a)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n#ifdef CRT_EFFECT  \n  col *= 1.5*smoothstep(-2.0, 1.0, sin(0.5*PI*q.y*RESOLUTION.y));\n#endif  \n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// Value noise: https://iquilezles.org/www/articles/morenoise/morenoise.htm\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n//  vec2 u = f;\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\n\n// FBM: https://iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm(vec2 p) {\n  const float aa = 0.35;\n  const float pp = 2.2-0.4;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return sum;\n}\n\nfloat height(vec2 p) {\n  return fbm(p)*smoothstep(0.0, 1.25+0.25*sin(0.5*p.y), abs(p.x))-0.35;\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.05*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*2.0*vec3(1.0, 1.0, 0.0)).xy;\n\n  float he = height(vec2(p.x, pp.z));\n\n  float d = p.y-he;\n  float t = smoothstep(aa, -aa, d);\n\n  vec3 hsv = vec3(fract(0.7+0.125*sin(0.6*pp.z)), 0.5, smoothstep(aa, -aa, abs(d)-aa));\n  float g = exp(-90.*max(abs(d), 0.0));\n  hsv.z += g;\n  hsv.z += (he*he-pp.y-0.125)*0.5;\n  vec3 col = hsv2rgb(hsv);\n  \n  return vec4(col, tanh_approx(t+g));\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n  return d;\n}\n\nfloat df(vec2 p) {\n  const vec2 off = vec2(0.0, -10.0+0.5);\n  const vec2 coff = vec2(0);\n  const float si = 5.0;\n  const float sc = 25.0;\n  float ds = sun(p/sc)*sc;\n  float d = ds;\n  return d;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float aa = 2.0/RESOLUTION.y;\n\n  vec2 p = rd.xy*2.0;\n  p.y -= 0.25;\n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp((0.85 - p.y)*0.75, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  float ss = smoothstep(-1.05, 0.0, p.y);\n  vec3 glow = mix(vec3(1.0, 0.7, 0.6).zyx, glareCol, ss);\n \n  float s = 15.0;\n  float d = df(p*s)/s;\n  float db = abs(d) - 0.0025;\n \n  vec3 col = vec3(1.0, 0.0, 1.0)*0.125;\n  vec3 corona = 0.65*glow*exp(-2.5*d)*ss;\n  col += corona;\n  col = mix(col, sunCol*ss, smoothstep(-aa, aa, -d));\n  col = mix(col, glow*1.55, smoothstep(-aa, aa, -db));\n\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n//  float rdd = (2.0-1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.5;\n  const int furthest = 24;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    vec3 pp = ro + rd*pd;\n    \n    if (pp.y < 1.25 && pd > 0.0 && acol.w < cutOff) {\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.25;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, q);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 297, 319, 319, 465], [760, 820, 860, 860, 1019], [1021, 1081, 1121, 1121, 1163], [1165, 1251, 1290, 1290, 1415], [1417, 1417, 1448, 1448, 1473], [1475, 1475, 1506, 1506, 1532], [1534, 1634, 1673, 1673, 1758], [1760, 1848, 1887, 1887, 1916], [1918, 1978, 2006, 2072, 2148], [2150, 2210, 2232, 2232, 2280], [2282, 2342, 2362, 2362, 2444], [2446, 2533, 2569, 2569, 2897], [2899, 2975, 2997, 2997, 3347], [3349, 3405, 3424, 3424, 3624], [3626, 3626, 3648, 3648, 3722], [3724, 3724, 3746, 3746, 3879], [3881, 3881, 3904, 3904, 3979], [3981, 3981, 4005, 4005, 4082], [4084, 4084, 4152, 4152, 4609], [4611, 4611, 4630, 4630, 4860], [4862, 4862, 4880, 4880, 5056], [5058, 5058, 5091, 5091, 5691], [5693, 5693, 5749, 5749, 7378], [7380, 7380, 7409, 7409, 7710], [7712, 7712, 7767, 7767, 8008]]}
{"id": "sldSRj", "name": "negative light", "author": "Mots_Doux", "description": "My very first shader, basic tests aside.\nNot much to say, it’s just basic stuff bundled in one shader.\n\nComments and criticism are welcomed, for I am an absolute beginner.", "tags": ["grid", "negative"], "likes": 1, "viewed": 87, "published": "Public API", "date": "1639422956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shader is licensed under the Creative Commons Zero 1.0 License\n// https://creativecommons.org/publicdomain/zero/1.0/legalcode\n// It means you can do anything you want, it’s pretty much Public Domain\n\n#define TAU 6.28318530718\n\nfloat square(float x) {\n    return x * x;\n}\n\n// function to draw the grid\n// has a lot of parameters but allows avoiding some code duplication\nvec4 grid(vec2 uv, float cellSize, vec3 color1, vec3 color2, float ratio) {\n    if ((mod(uv.x * ratio, cellSize) <= cellSize/2.0 && mod(uv.y, cellSize) <= cellSize/2.0) || (mod(uv.x * ratio, cellSize) >= cellSize/2.0 && mod(uv.y, cellSize) >= cellSize/2.0)) {\n        return vec4(color1, 1.0);\n    } else {\n        return vec4(color2, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates of the pixel\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // duration of the animation in seconds\n    float duration = 5.0;\n    \n    // colors of the grid\n    vec3 color1 = vec3(1.0, 1.0, 1.0);\n    vec3 color2 = vec3(0.0, 0.436, 1.0);\n\n    // ratio of the display surface so we have a proper circle and not an ellipse\n    float ratio = iResolution.x / iResolution.y;\n    \n    // center of the circle, moves with time\n    // this is a very simple movement only for me to explore the iTime parameter and the cos function\n    vec2 center = vec2(cos(TAU / duration * iTime) * 0.2 + 0.5, cos(TAU / duration * iTime) * 0.2 + 0.5);\n    \n    // radius of our circle\n    float radius = 0.3;\n    \n    // size of each cell of the grid\n    float cellSize = 0.5;\n    \n    // circle equation, true if the pixel is inside the circle\n    // (pixel.x - center.x)^2 + (pixel.y - center.y)^2 <= radius^2\n    // pixels in the circle get an inverted color\n    /*if (square(uv.x * ratio - center.x) + square(uv.y - center.y) <= square(radius)) {\n        fragColor = 1.0 - grid(uv, cellSize, color1, color2, ratio);\n    } else {\n        fragColor = grid(uv, cellSize, color1, color2, ratio);\n    }*/\n    \n    // change suggested by hamtarodeluxe, replace the commented lines above + removes aliasing\n    vec4 col = grid(uv, cellSize, color1, color2, ratio);\n    float squareRadius = square(radius);\n    // returns smooth Hermite interpolation between 0 and 1 when\n    // squareRadius < square(uv.x * ratio - center.x) + square(uv.y - center.y) < squareRadius + 0.005\n    float t = smoothstep(squareRadius, squareRadius + 0.005, square(uv.x * ratio - center.x) + square(uv.y - center.y));\n    // mix is simply a lerp function\n    fragColor = mix(1.-col, col, t);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldSRj.jpg", "access": "shaders20k", "license": "cc-sampling-plus-1.0", "functions": [[0, 237, 260, 260, 280], [282, 380, 455, 455, 728], [730, 730, 787, 819, 2556]]}
{"id": "sldXDM", "name": "Fractal 94 gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 14, "viewed": 121, "published": "Public", "date": "1639261798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B (1.-fract(t*2.))\n#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 p,r=iResolution,c=vec3(0),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,s,e,g=0.,t=iTime;\n\tfor(;i++<99.;)\n    {\n        p=g*d;;\n        p.z-=-t*2.;\n        p=R(p,vec3(.577),clamp(sin(t/4.)*6.,-.5,.5)+.6);\n        p=asin(sin(p));\n        vec4 q=vec4(p,0);\n        s=2.;\n        for(int i=0;i++<4;){\n            q=abs(q);\n            q=q.x<q.y?q.zwxy:q.zwyx;\n            s*=e=11./clamp(dot(q,q),.2,9.);\n            q=q*e-vec4(6);\n        }\n        g+=e=abs(length(q.y)/s)+.002;\n        c+=mix(vec3(1),H(log(s)*.3+.5),.5)*8e-5/e;  \n    }\n    c*=c*c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 171, 171, 758]]}
{"id": "sldXW8", "name": "blinky christmas ornament", "author": "irisdogg", "description": "Shader based off on: https://darkeclipz.github.io/fractals/", "tags": ["tutorial"], "likes": 3, "viewed": 57, "published": "Public", "date": "1639067653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define foldAmount 4\n\n// snow function from https://www.shadertoy.com/view/XtBfzw\nfloat Snow(vec2 uv,float scale)\n{\n\tfloat w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\n\tuv+=iTime/scale;uv.y+=iTime*2./scale;uv.x+=sin(uv.y+iTime*.5)/scale;\n\tuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n    \treturn k*w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // center the origin\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 1.5;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float angle = (5./6.) * 3.1514;\n    \n    \n    uv.x = abs(uv.x);\n    uv.y += tan(angle) * .5;\n    \n    vec2 n = vec2(sin(angle), cos(angle));\n    float d = dot(uv-vec2(.5, 0), n);\n    uv -= n*max(0., d)*2.;\n    \n    n = vec2(sin((2./3.)* 3.1415), cos((2./3.)* 3.1415));\n    float scale = 1.;\n    \n    // re center it\n    uv.x += 0.5;\n    for (int i = 0; i < foldAmount; i++)\n    {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        // mirror around the center\n        uv.x = abs(uv.x);\n\n        // expand the line\n        uv.x -= .5;\n\n        // mirror\n        uv -= n*min(0., dot(uv, n))*2.;\n       \n    }\n     \n    // create line segment\n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    col += smoothstep(1./iResolution.y, .0, d/scale);\n    uv /= scale;\n    col.rg /= uv;\n    \n    float speed = 5.;\n    \n    col.rg *= vec2(tan(iTime * speed) / 2.0, cos(iTime * speed) / 4.0);\n    \n    float c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\n\tc+=Snow(uv,105.)*.3;\n\tc+=Snow(uv,104.)*.5;\n\tc+=Snow(uv,113.)*.8;\n\tc+=Snow(uv,12.);\n\n    col += c;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldXW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 82, 115, 115, 449], [451, 451, 508, 534, 1804]]}
{"id": "sldXzj", "name": "[TDF 2021]ローポリ", "author": "totetmatt", "description": "My compo for TokyoDemoFest 2021 GLSL competition \n", "tags": ["lowpoly", "tdf2021"], "likes": 22, "viewed": 329, "published": "Public API", "date": "1639425977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n//東京\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n}\nfloat box3(vec3 p,vec3 b){\n    vec3 q =abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat tokyo(vec3 p){\n\tp*=2.;\n\tvec3 op = p;\n\tp.x -=6.;\n\tfloat d = box3(p-vec3(0.,4.,0.),vec3(5.,1.,1.));\n\tfloat q = min(d,box3(p-vec3(0.,0.,0.),vec3(4.,3.,1.)));\n\tq = max(q,-min(d,box3(p-vec3(0.,0.,0.),vec3(3.,2.,2.))));\n\td = min(d,q);\n\td =min(d,box3(p,vec3(4.,1.,1.)));\n\td = min(d,box3(p,vec3(1.,7.,1.)));\n\tp.y-=-5.;\n\tp.x = abs(p.x)-2.;\n\tp.xy*=rot(-.885);\n\td = min(d,box3(p,vec3(1.,2.5,1.)));\n\t\n\tp =op;\n\tp.x+=6.;\n\tfloat d2 = box3(p-vec3(0.,4.,0.),vec3(5.,1.,1.));\n\tfloat q2 = min(d2,box3(p-vec3(0.,0.,0.),vec3(4.,3.,1.)));\n\tq2 = max(q2,-min(d2,box3(p-vec3(0.,0.,0.),vec3(3.,2.,2.))));\n\td2 = min(d2,q2);\n\t\n\td2 = min(d2,box3(p-vec3(0.,5.,0.),vec3(1.,2.,1.)));\n\td2 = min(d2,box3(p-vec3(0.,-5.,0.),vec3(1.,2.,1.)));\n\td2 = min(d2,box3(p-vec3(1,-6.5,0.),vec3(2.,.5,1.)));\n\tp.y-=-4.;\n\tp.x = abs(p.x)-2.;\n\tp.xy*=rot(-.885);\n\td2 = min(d2,box3(p,vec3(.5,2.5,1.)));\t\n\t\n\td= min(d2,d);\n\treturn d/2.;\n}\nfloat diam(vec3 p,float s){\n\t p = abs(p);\n\t return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\n\nvec3 op;\nfloat di(vec3 p){\n    float q = 0.;\n    vec4 pp = vec4(p,1.1);\n    const float cc = 2.;\n    for(float i=1.; i<=cc ;i++){\n      q += (asin(sin(pp.x))+acos(cos(pp.z)))/pp.a;\n      pp*=1.1;\n      pp.xyz +=vec3(1.1,2.,3.);\n      pp.xyz = abs(pp.xyz);\n      pp.xz *=rot(-.785*i+i);\n      \n    }\n    return q/(cc+pp.a);\n\n}\nvec2 sdf(vec3 p){\nvec3 tp = p;\n\t\n   op = p;\n\n    vec2 h;\n    p.xy *=rot(p.z*.1);\n    p.y= -abs(p.y)+(3.+asin(sin(iTime+p.z*.1))*.5);\n    \n    h.x = length(p+1.)-.1;\n    p.y +=2.+di(p);\n    h.x = min(h.x, box(p.xy,vec2(6.1,.5) ) );\n\th.x *=.65;\n    h.y = 1.;\n\t\n    vec2 t;\n\n    tp.xz*=rot(pow(fract(iTime*.3),.125)*3.14);\n    tp.xy*=rot(pow(fract(iTime*.3+.5),.125)*3.14);\n    t.x = mix(diam(tp,2.5),box3(tp,vec3(1.1)),asin(sin(floor(iTime)+pow(fract(iTime),.5)))*.3+.2);\n\tt.x =mix(t.x , tokyo(-tp),clamp(sin(iTime),-.5,.5)+.5);\n\t tp = op;\n    vec4 ttp = vec4(tp,1.);\n\tttp.yz*=rot(iTime*.01);\n    for(float i=0.;i<=6.;i++){\n        ttp*=1.3;\n        ttp.xyz = abs(ttp.xzy)-11.;\n        ttp.xz*=rot(-.785+i);\n\t    ttp.xy*=rot(i);\n        t.x = min(t.x,box3(ttp.xyz,vec3(.5))/ttp.a);\n    }\n\t\n    t.y = 2.;\n    h = t.x < h.x ? t:h;\n    return h;\n    \n}\n#define q(s) s*sdf(p+s).x\n#define ao(rp,n,k) clamp(sdf(rp+n*k).x/k,.0,1.)\n#define gao(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7))\nvec3 norm(vec3 p,float e){vec2 nv=vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvec3 pal(float t){return .5+vec3(.5,.2,.1)*cos(6.28*(vec3(1.,.5,.6)*t+vec3(.0,.1,.2)));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(12.,-0.1+iMouse.y*.01,-6.+iMouse.x*.01);\n    vec3 rt = vec3(0.);\n    vec3 z = normalize(rt-ro);\n    vec3 x = (cross(z,vec3(0.,-1.,.0)));\n    vec3 y = (cross(z,x));\n    \n    vec3 rp = ro;\n    vec3 rd = normalize(mat3(x,y,z)*vec3(uv,.9));\n    vec3 light = mat3(x,y,z)*vec3(-2.,-1.,-4.);\n    vec3 col = vec3(.1);\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        if(length(rp) > 50.) break;\n        if(d.x <.001){\n        \n            vec3 n = norm(rp,.019);\n            vec3 nn = norm(rp,.02+abs(sin(iTime+rp.z*.2))*.01);\n                           float dif = dot(normalize(light-rp),n);\n                           float spc = max(0.,dot(normalize(rp-ro),reflect(normalize(-light),n)));\n                           spc = pow(spc,32.);\n\t\tfloat fr = pow(1.-dot(-rd,n),4.);\n                col = vec3(.1)+vec3(.15,.5,.7)*dif+spc*.75;\n                float l = length(n-nn);\n                float s = step(.01,l);\n                col = max(vec3(0.),mix(col-s,col*s, floor(rp.z*.1-.3+di(rp.zzz*.1)*.2)*(gao(rp,n)/3.)*.75+.5));\n                col = pow(col,vec3(.8));\n\t\tif(d.y ==1.) {col *=smoothstep(10.5,.0,op.z);col += -fr+s*pal(op.z*.1+iTime)*smoothstep(-.1,.1,op.z);}\n                break;\n           \n            \n        }\n        rp +=rd*d.x;\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 12, 30, 30, 77], [78, 78, 103, 103, 185], [186, 186, 212, 212, 302], [303, 303, 323, 323, 1191], [1192, 1192, 1219, 1219, 1277], [1288, 1288, 1305, 1305, 1604], [1605, 1605, 1622, 1622, 2452], [2583, 2583, 2609, 2609, 2687], [2688, 2688, 2706, 2706, 2776], [2779, 2779, 2836, 2886, 4296]]}
{"id": "slG3WV", "name": "Wave Square", "author": "ivatronx", "description": "Trigonometry", "tags": ["spiral", "square"], "likes": 2, "viewed": 34, "published": "Public", "date": "1638409301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932;\n\nfloat atanM(float y, float x){\n    if(x >= 0.){\n        return atan(y/x)/pi/2.+.75;\n    }\n    return (pi+2.*atan(y/x))/4./pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    int amount = 2;\n    float width = 2.5;\n    float speed = 0.05;\n    float speed2 = 0.075;\n    float speed3 = 0.10;\n    vec3 color1 = vec3(1.0, 1.5, 2.0);\n    vec3 color2 = vec3(-0.1, 0.0, 0.1);\n    vec3 color12 = vec3(1.0, 2.5, 2.0);\n    vec3 color22 = vec3(-0.11, 0.11, 0.11);\n    vec3 color13 = vec3(2.0, 2.5, 2.0);\n    vec3 color23 = vec3(-0.01, 0.01, 0.01);\n    \n\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord-R/2.;\n    vec3 col;\n    vec3 col2;\n    vec3 col3;\n    float d = length(uv);\n    float d2 = length(uv)/-50.;\n    float d3 = length(uv)/-75.0;\n    d -= iTime*speed;\n    d2 -= iTime*speed2;\n    d3 -= iTime*speed3;\n\n    float mascara = smoothstep(R.y/2.+width*4., R.y/2.-width*4., sin(length((uv*2.*pi + iTime))));\n    float mascara2 = smoothstep(R.y/2.+width*4., R.y/2.-width*4., length(uv.x) + length(uv.y));\n    \n    col = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d*width)*float(amount))+1.);\n    col2 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d2*width)*float(amount))-1.);\n    col3 = vec3(sin((2.*pi*atanM(uv.y, uv.x)+d3*width)*float(amount))+1.);\n    col = color1+col*(color2-color1);\n    col *= mascara2-mascara/2./pi;\n    col2 = color23+col3*(color13-color23);\n    col2 *= mascara2;\n    col3 = color22+col3*(color12-color22);\n    col3 *= mascara2;\n    fragColor = vec4(col-col2-col3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slG3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 165], [167, 167, 224, 224, 1531]]}
{"id": "slK3Dt", "name": "Flat plane ride", "author": "bunyk", "description": "Learning GLSL", "tags": ["plane", "lowpoly"], "likes": 2, "viewed": 56, "published": "Public", "date": "1638550598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst vec3 CAM_START_POS = vec3(0, 0, -3.0);\nconst vec3 CAM_DIR = vec3(0, 0, 1.0);\nconst float focal_length = 1.0;\n\nconst vec3 red = vec3(1.0, 0.0, 0.0);\nconst vec3 green = vec3(0.0, 1.0, 0.0);\nconst vec3 black = vec3(0.0);\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Direction;\n};\n\nRay getCamRay(in vec3 origin, in vec2 uv, in float aspect_ratio) {\n    float viewport_height = 2.0;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 horizontal = vec3(viewport_width, 0, 0);\n    vec3 vertical = vec3(0, viewport_height, 0);\n    vec3 lower_left_corner = origin - horizontal/2.0 - vertical/2.0 + vec3(0, 0, focal_length);\n\n    return Ray(origin, normalize(lower_left_corner + uv.x * horizontal + uv.y*vertical - origin));\n}\n\n\nfloat hit_sphere(in vec3 center, in float radius, in Ray r) {\n    vec3 oc = r.Origin - center;\n    float a = dot(r.Direction, r.Direction);\n    float b = 2.0 * dot(oc, r.Direction);\n    float c = dot(oc, oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nfloat hit_hplane(in float h, in Ray r) {\n    if (r.Direction.y == 0.0) {\n        return -1.0;\n    }\n    return (h - r.Origin.y) / r.Direction.y;\n}\n\nvec3 at(in Ray r, float t) {\n    return r.Origin + r.Direction * t;\n}\n\n\nvec3 rayColor(in Ray r) {\n    float t = hit_sphere(vec3(0,0, -1), 0.5, r);\n    if (t > 0.0) {\n        vec3 N = normalize(at(r, t) - vec3(0,0,-1));\n        return vec3(dot(N, vec3(0.0, 1.0, 0.0)));\n    } \n    t = hit_hplane(-0.5, r);\n    if (t > 0.0) {\n        vec3 hp = at(r, t);\n        float x = mod(hp.x, 1.0);\n        float y = mod(hp.z, 1.0);\n        if((x < 0.05) || (y < 0.05)) {\n            return green;\n        }\n        return black;\n    }\n    vec3 unit_direction = normalize(r.Direction);\n    t = 0.5*(unit_direction.y + 1.0);\n    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n\n}\n\nconst float SUBPIXELS = 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 camPos = CAM_START_POS + iTime * CAM_DIR;\n    \n    vec3 col;\n    \n    for(float i = 0.0; i < SUBPIXELS; i++) {\n        for(float j = 0.0; j < SUBPIXELS; j++) {\n            vec2 subpixel_uv = vec2(i, j) / iResolution.xy / SUBPIXELS;\n            Ray ray = getCamRay(camPos, uv + subpixel_uv, iResolution.x / iResolution.y);\n            col += rayColor(ray);\n        }\n    }\n    col /= SUBPIXELS*SUBPIXELS;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 347, 347, 737], [740, 740, 801, 801, 1129], [1131, 1131, 1171, 1171, 1277], [1279, 1279, 1307, 1307, 1348], [1351, 1351, 1376, 1376, 1956], [1989, 1989, 2046, 2100, 2616]]}
{"id": "slK3WK", "name": "Animated 3D cellular noise", "author": "guitio2002", "description": "Animated 3D cellular noise.", "tags": ["animatedcellularnoise"], "likes": 4, "viewed": 57, "published": "Public", "date": "1638380874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// setup copied from: https://www.shadertoy.com/view/XsXfRH\n\n\nvec2 worley(in vec4 P)  // animated 3D cellular noise\n{\n    vec3 p;\n    vec3 Pi = floor(P.xyz);\n    vec3 Pf = fract(P.xyz);\n    float F1 = 1.0, F2 = 1.0;\n    for(p.z = -1.0; p.z <= 1.0; ++p.z)\n        for(p.y = -1.0; p.y <= 1.0; ++p.y)\n            for(p.x = -1.0; p.x <= 1.0; ++p.x)\n            {\n                vec3 Pn = Pi + p;\n                Pn = fract(sin(vec3(dot(Pn, vec3(127.1, 311.7, 251.3)),\n                                    dot(Pn, vec3(269.5, 183.3, 478.5)),\n                                    dot(Pn, vec3(307.3, 284.9, 154.1)))) * 43758.5453);\n                Pn = 0.5 * sin(P.w + 6.2831 * Pn) + 0.5;\n                float d = length(p + Pn - Pf);\n                if(d < F1)\n                {\n                    F2 = F1;\n                    F1 = d;\n                }\n                else if(d < F2)\n                    F2 = d;\n            }\n    return vec2(F1, F2);\n}\n\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\n        vec2  n = worley( vec4(6.0*pos,iTime) );\n        float f = (p.x < 0.0 ? n.x : n.y - n.x);\n\n        f *= f * occ;\n\n\t\tcol = mix( vec3(f), vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\n    col  = sqrt( col );\n    col *= smoothstep( 0.006, 0.008, abs(p.x) );\n\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slK3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 117, 117, 949], [952, 1443, 1498, 1498, 2941]]}
{"id": "sltSzj", "name": "Black hole / eclipse 2", "author": "Betalord", "description": "Another variation of a black hole, this time with a single octave of 2D perlin noise which makes things much faster (my phone can render it without a problem).", "tags": ["eclipse", "blackhole"], "likes": 4, "viewed": 93, "published": "Public", "date": "1639424758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Betalord\n//\n// Noise functions taken from https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl (MIT licence)\n// Plasma effect based on this code: https://www.shadertoy.com/view/MlyGzW\n// Tone mapping code taken from: https://github.com/dmnsgn/glsl-tone-map\n//\n// The part of the code that is mine is in public domain.\n\n#define NOISE_PERIOD 16. // needs to be an integer value\n#define PI 3.14159265359\n#define TAU 6.2831853071\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat fbm_periodic(vec2 pos, int octaves, float persistence, vec2 period) {\n\tfloat total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n\tfor(int i = 0; i < octaves; ++i) {\n\t\ttotal += pnoise(pos * frequency, period) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= persistence;\n\t\tfrequency *= 2.;\n\t}\n\treturn total / maxValue;\n}\n\nvec3 plasma(vec2 uv, float r) {\n\tfloat len = length(uv);\n\t\n\tfloat light = 0.1 / abs(len-r) * r; // we multiply by 'r' to scale it correctly when 'r' changes\n\t\n    if (len < r)\n        light *= len/r * 0.3; // cut the inner part out (the constant determines how much glow do we allow to bleed over to the inside of the black hole - note that we could just multiply by some constant and omit len/r part altogether)\n    \n\tlight = pow(light, 0.7); // add some more power to it\n\tlight *= smoothstep(3.5*r, 1.5*r, len); // limit the light range\n    \n\treturn light * vec3(0.9, 0.65, 0.5)/*Color it a bit*/;\n}\n\n// ### TONE MAPPING CODE ###\n//\n// Uchimura 2017, \"HDR theory and practice\"\n// Math: https://www.desmos.com/calculator/gslcdxvipg\n// Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n// (code found here: https://github.com/dmnsgn/glsl-tone-map)\nvec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n  float l0 = ((P - m) * l) / a;\n  float L0 = m - m / a;\n  float L1 = m + (1.0 - m) / a;\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = (a * P) / (P - S1);\n  float CP = -C2 / P;\n\n  vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\n  vec3 w2 = vec3(step(m + l0, x));\n  vec3 w1 = vec3(1.0 - w0 - w2);\n\n  vec3 T = vec3(m * pow(x / m, vec3(c)) + b);\n  vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\n  vec3 L = vec3(m + a * (x - m));\n\n  return T * w0 + L * w1 + S * w2;\n}\nvec3 uchimura(vec3 x) {\n  const float P = 1.0;  // max display brightness\n  const float a = 1.0;  // contrast\n  const float m = 0.22; // linear section start\n  const float l = 0.4;  // linear section length\n  const float c = 1.33; // black\n  const float b = 0.0;  // pedestal\n\n  return uchimura(x, P, a, m, l, c, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float BlackHoleRadius = 1.0;\n\n    // first do the rays:\n    \n    float radius = 1.6; // circle radius\n    float time = iTime * 0.15;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 5.2; // scale it a bit\n    vec3 col = vec3(1.0, 0.9, 0.7); // resulting color\n    \n    // polar coordinates:\n    float r = length(uv) / radius; // radial coordinate\n    float phi = atan(uv.y, uv.x); // angular coordinate\n    \n   \tfloat a = fbm_periodic(vec2((phi + PI)/TAU * NOISE_PERIOD, time), 1, 0.5, vec2(NOISE_PERIOD, 100.)); // we don't really need periodicy in Y direction, but anyway, we just put some random number\n\ta = (a + 1.0) * 0.5; // map it to [0..1]\n\ta *= .7; // scale it a bit\n    a = pow(a, 1.6); // \"sharpen\" it up a bit\n    \n    col *= smoothstep(a+0.81 * BlackHoleRadius, a * BlackHoleRadius, r); // creates the rays\n    \n    // add underneath glow:\n\tcol *= pow(1./pow(r / BlackHoleRadius, 1.2) * .8, 3.) * vec3(1.0, 0.8, 0.7)/*glow color*/;\n    \n    // cut out the inner area to create the black hole:\n    col *= smoothstep(BlackHoleRadius, BlackHoleRadius + 0.04/*antialiasing*/, length(uv));\n\n    // finally do the plasma:\n    col += plasma(uv, BlackHoleRadius);\n    \n    // do some tone mapping (optional):\n    col = uchimura(col);\n    \n    // Output to screen\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltSzj.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 459, 480, 480, 529], [530, 530, 552, 552, 590], [591, 591, 619, 619, 671], [672, 672, 691, 691, 731], [733, 775, 807, 807, 1922], [1924, 1924, 1999, 1999, 2260], [2262, 2262, 2293, 2293, 2863], [2865, 3131, 3208, 3208, 3684], [3685, 3685, 3708, 3708, 4003], [4005, 4005, 4062, 4062, 5394]]}
{"id": "sltSzS", "name": "QuasiRandomR2", "author": "Del", "description": "just a quick test of the r2 sequence to see how it looks...", "tags": ["quasirandom", "r2"], "likes": 2, "viewed": 73, "published": "Public API", "date": "1639349532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// quasirandom test - from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n#define NPOINTS 500.0\n#define DOTSIZE 0.01\n\n// r2 as a function\nvec2 quasi(float n)\n{\n    float g = 1.32471795;\n    float a1 = 1.0/g;\n    float a2 = 1.0/(g*g);\n    float x = fract((a1*n));//float x = mod((0.5+a1*n),1.0);\n    float y = fract((a2*n));//float y = mod((0.5+a2*n),1.0);\n    return vec2(x,y);\n}\nconst vec2 quasi2 = vec2(.754877,.569840);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zoomval = 1.25 + (sin(iTime)*0.5);\n    vec3 col = vec3(0.05,0.2,0.05);\n    // btw, never do this :)\n    for (float i=0.0;i<NPOINTS;i+=1.0)\n    {\n        //vec2 pos = quasi(i+1.0);          // R2 func\n        vec2 pos = fract(quasi2*(i+1.0));   // R2 inline\n        pos = (pos-0.5)*(zoomval);\n        float d = length(pos-uv)-(DOTSIZE*zoomval);\n        col.r += step(d,0.0)*0.4;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 174, 195, 195, 415], [460, 460, 517, 517, 1015]]}
{"id": "slVGWV", "name": "Multibrots", "author": "tungster24", "description": "multibrots, made using polar forms", "tags": ["fractal", "mandelbrot", "multibrot"], "likes": 2, "viewed": 99, "published": "Public API", "date": "1638387756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r(in vec2 z) {return sqrt(z.x*z.x+z.y*z.y);}\nfloat theta(in vec2 z) {return atan(z.y,z.x);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.x/iResolution.y*2.0-1.0*iResolution.x/iResolution.y,fragCoord.y/iResolution.y*2.0-1.0);\n    vec2 z = vec2(0.0,0.0);\n    float t = iTime;\n    bool inside=true;int iter = 0;\n    for (int i = 0;i<100;i++){\n        z = vec2(cos(t*theta(z))*pow(r(z),t)+p.x,sin(t*theta(z))*pow(r(z),t)+p.y);\n        if (r(z) >= 2.0) {inside = false;break;}\n        iter++;\n    }\n    \n    vec3 col;\n    if (inside == true) col = vec3(0.0,0.0,0.0);\n    else col = vec3(float(iter)/40.0,float(iter)/30.0,float(iter)/20.0);\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 50], [51, 51, 75, 75, 97], [99, 99, 156, 156, 715]]}
{"id": "slyGDd", "name": "voronoi graph", "author": "nelsonkuang", "description": "voronoi graph", "tags": ["voronoi"], "likes": 4, "viewed": 75, "published": "Public", "date": "1638523391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n——如何分割网格？\nuv坐标默认是在0到1之间，如果我们把uv乘以一个系数，这样在0到1之间的图形就会重复生成网格。\na. 把uv乘以5，把坐标等比放大5倍：uv *= 5.0\nb. 使用fract()函数单位化变量，使之在0.0到1.0之间：vec2 f_uv = fract(uv)\nc. 使用floor()函数对uv取整，就知道是在哪个网格了：vec2 i_uv = floor(uv)\n\n——计算最短距离\n如何计算像素点到相邻网格中随机离散点的距离？从网格坐标来说，就是x坐标从-1(左)到1(右)，y坐标从 -1(下)到1(上)，一共9 个网格的3x3区域可以用两个 for 循环遍历：\n\n*/\n\n// Referenced Information:\n// Created by inigo quilez - iq/2013  \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://gameinstitute.qq.com/community/detail/122097\n\n// 随机方法  \nvec2 hash(vec2 p) {\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return fract(sin(p) * 18.5453);\n}\n\n// return distance, and cell id  \nvec2 voronoi(in vec2 x) {\n  vec2 n = floor(x);              // cell(n)  \n  vec2 f = fract(x);              // 当前像素在 cell space 的坐标  \n  vec3 m = vec3(8.);               // 影响每个 cell 的大小，影响背景颜色  \n   // 遍历相邻的 9 个 cell  \n  for(int j = -1; j <= 1; j++) {\n    for(int i = -1; i <= 1; i++) {\n      vec2 g = vec2(float(i), float(j));  // 临近的 cell id offset  \n      // n+g 临近的 cell(n+g) 的随机像素坐标 o (cell space)  \n      vec2 o = hash(n + g);   // 影响 cell 的颜色  \n      // ❤  \n      vec2 r = g - f + (0.5 + 0.5 * sin(iTime + 6.2831 * o));  \n      // vec2  r = g - f + o;     // cell(n+g)[o] - cell(n)[f]   \n      // ❤  \n      float d = dot(r, r);  \n\n      m.x = min(m.x, d);\n    }\n  }\n  return vec2(sqrt(m.x), m.y + m.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy; // 归一化坐标\n  uv -= .5; // -1 to 1\n  uv.x *= iResolution.x / iResolution.y; // aspect ratio\n\n  // computer voronoi patterm  \n  vec2 c = voronoi((14.0 + 6.0 * sin(0.2 * iTime)) * uv);  \n\n  fragColor = vec4(c.x, c.x, c.x, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyGDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[857, 875, 894, 894, 998], [1000, 1034, 1059, 1059, 1839], [1841, 1841, 1896, 1896, 2171]]}
{"id": "ssdGRM", "name": "Test 314", "author": "SpencerKuan", "description": "Simple ray-marching scene with (bad) reflections and shadows. ", "tags": ["raymarching"], "likes": 2, "viewed": 41, "published": "Public", "date": "1638342368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nMy first shadertoy program :)\n\nThe code is not new, but from a project\nI wrote on Khan Academy.\n\n*/\n\n#define eps 0.01\n#define pi 3.1415926\n        \nprecision lowp float;\nuniform float u_time;\n\nvec3 cam = vec3(0, 100, -700);\nvec3 lightPos = vec3(500, 1000, 300);\n\n//sdBox from Inigo Quilez's article on distance functions\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdf( vec3 p )\n{\n    p = vec3(mod(p.x, 400.) - 200., p.y, mod(p.z, 400.) - 200.);\n\n    float bottom = p.y;\n    float sphere = length(p + vec3(0, -120, 0)) - 150.;\n    float box = box(p + vec3(0, -120, 0), vec3(120, 120, 120)) - 1.0;\n\n    return min(max(-sphere, box), bottom);\n}\n\nvec3 getNormal(vec3 ray)\n{\n    float sdfr1 = sdf(ray);\n    \n    float xn = sdf(vec3(ray.x + eps, ray.y, ray.z)) - sdfr1;\n    float yn = sdf(vec3(ray.x, ray.y + eps, ray.z)) - sdfr1;\n    float zn = sdf(vec3(ray.x, ray.y, ray.z + eps)) - sdfr1;\n\n    return normalize(vec3(xn, yn, zn));\n}\n\nvec3 getColor(vec3 ray)\n{\n    bool checkerX = floor(mod(ray.x, 800.) / 400.) == 1.0;\n    bool checkerY = floor(mod(ray.z, 800.) / 400.) == 1.0;\n    bool checker = checkerX ^^ checkerY;\n\n    if(checker ^^ (ray.y < 1.0)){\n        return vec3(0.6, 0.5, 0.9);\n    }\n    return vec3(0, 1, 1);\n}\n\nvec3 raymarch(inout vec3 ray, vec3 dir)\n{\n    for(int i = 0; i < 100; i++) { \n        float dist = sdf(ray + dir);\n\n        if(dist < eps){\n            return getColor(ray);\n        }\n\n        ray += dir * dist;\n    }\n\n    return vec3(0, 0, 0);\n}\n\nfloat shadowmarch(vec3 ray, vec3 light)\n{\n    for(int i = 0; i < 100; i++) { \n        float dist = sdf(ray);\n\n        if(dist < eps){\n            return 0.1;\n        }\n\n        ray += light * dist;\n    }\n\n    return 1.0;\n}\n\nvec3 bounceMarch(vec3 ray, vec3 dir)\n{\n    vec3 col = vec3(0, 0, 0);\n    float traveled = 0.0;\n\n    for(int i = 0; i < 100; i++) { \n        float dist = sdf(ray);\n        traveled += dist;\n\n        if(dist < eps){\n            vec3 normal = getNormal(ray);\n            ray -= dir * 0.1;\n            dir = reflect(dir, normal);\n\n            col += getColor(ray) / max(traveled * 0.02, 1.0);\n        }\n\n        ray += dir * dist;\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float inc = abs(mod(iTime * 0.001, 50.) - 25.);\n\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec3 dir = normalize(vec3(uv, -1));\n    vec3 ray = vec3(sin(iTime) * 10.0, 100.0, cos(iTime) * 10.0);\n    \n    vec3 col = raymarch(ray, dir) + bounceMarch(ray, dir);\n\n    vec3 light = normalize(lightPos - ray);\n\n    vec3 norm = getNormal(ray);\n\n    float shadow = shadowmarch(ray, light);\n\n    float dif = max(dot(light, norm), 0.0);\n\n    float spec = max(dot(reflect(light, norm), dir), 0.0);\n    spec = pow(spec, 32.0);\n\n    float fog = clamp(200.0 / length(ray), 0.0, 1.0);\n\n    float shading = shadow * (dif + spec) + 0.2;\n\n    fragColor = vec4((col * shading) * fog, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 325, 351, 351, 442], [445, 445, 466, 466, 728], [730, 730, 756, 756, 1015], [1017, 1017, 1042, 1042, 1306], [1308, 1308, 1349, 1349, 1554], [1556, 1556, 1597, 1597, 1778], [1780, 1780, 1818, 1818, 2231], [2234, 2234, 2291, 2291, 2971]]}
{"id": "st3SW4", "name": "[SIG15] sig-n-sine, impr. mblur", "author": "Hatchling", "description": "improvised some psychedelic nonsense... getting 2001 and enter the void vibes\n\nEDIT: improved motion blur using blue noise", "tags": ["procedural", "2d", "psychedelic"], "likes": 4, "viewed": 111, "published": "Public API", "date": "1639088887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nfloat sigmoid(float x){\n \treturn x/(1.+abs(x));   \n}\n\nfloat iter(vec2 p, vec4 a, vec4 wt, vec4 ws, float t, float m, float stereo){\n    float wp = .2;\n    vec4 phase = vec4(mod(t, wp), mod(t+wp*.25, wp), mod(t+wp*.5, wp), mod(t+wp*.75, wp))/wp;\n    float zoom = 1./(1.+.5*(p.x*p.x+p.y*p.y));\n    vec4 scale = zoom*pow(vec4(2.), -4.*phase);\n    vec4 ms = .5-.5*cos(2.*pi*phase);\n    vec4 pan = stereo/scale*(1.-phase)*(1.-phase);\n    vec4 v = ms*sin( wt*(t+m) + (m+ws*scale)*((p.x+pan) * cos((t+m)*a) + p.y * sin((t+m)*a)));\n    return sigmoid(v.x+v.y+v.z+v.w+m);\n}\n\nvec3 scene(float gt, vec2 uv, vec4 a0, vec4 wt0, vec4 ws0, float blur){\n    gt *= 2.;\n    //time modulation\n    float tm = mod(.0411*gt, 1.);\n    tm = sin(2.*pi*tm*tm);\n    float t = (.04*gt + .05*tm);\n    \n    float stereo = 1.*(sigmoid(2.*(sin(1.325*t*cos(.5*t))+sin(-.7*t*sin(.77*t)))));//+sin(-17.*t)+sin(10.*t))));\n    //t = 0.;\n    //also apply spatial offset\n    uv+= .5*sin(.33*t)*vec2(cos(t), sin(t));\n    \n    //wildly iterate and divide\n    float p0 = iter(uv, a0, wt0, ws0, t, 0., stereo);\n    \n   \tfloat p1 = iter(uv, a0, wt0, ws0, t, p0, stereo);\n    \n    float p2 = sigmoid(p0/(p1+blur));\n    \n    float p3 = iter(uv, a0, wt0, ws0, t, p2, stereo);\n    \n    float p4 = sigmoid(p3/(p2+blur));\n    \n    float p5 = iter(uv, a0, wt0, ws0, t, p4, stereo);\n    \n    float p6 = sigmoid(p4/(p5+blur));\n    \n    float p7 = iter(uv, a0, wt0, ws0, t, p6, stereo);\n    \n    float p8 = sigmoid(p4/(p2+blur));\n    \n    float p9 = sigmoid(p8/(p7+blur));\n    \n    float p10 = iter(uv, a0, wt0, ws0, t, p8, stereo);\n    \n    float p11 = iter(uv, a0, wt0, ws0, t, p9, stereo);\n    \n    float p12 = sigmoid(p11/(p10+blur));\n    \n    float p13 = iter(uv, a0, wt0, ws0, t, p12, stereo);\n    \n    //colors\n    vec3 accent_color = vec3(1.,0.2,0.);//vec3(0.99,0.5,0.2);\n    /*float r = sigmoid(-1.+2.*p0+p1-max(1.*p3,0.)+p5+p7+p10+p11+p13);\n    float g = sigmoid(-1.+2.*p0-max(1.*p1,0.)-max(2.*p3,0.)-max(2.*p5,0.)+p7+p10+p11+p13);\n    float b = sigmoid(0.+1.5*p0+p1+p3+-max(2.*p5,0.)+p7+p10+p11+p13);\n    */\n    float r = sigmoid(p0+p1+p5+p7+p10+p11+p13);\n    float g = sigmoid(p0-p1+p3+p7+p10+p11);\n    float b = sigmoid(p0+p1+p3+p5+p11+p13);\n    \n    \n    vec3 c = max(vec3(0.), .4+.6*vec3(r,g,b));\n    \n    float eps = .4;\n    float canary = min(abs(p1), abs(p2));\n    canary = min(canary, abs(p5));\n    //canary = min(canary, abs(p6));\n    canary = min(canary, abs(p7));\n    canary = min(canary, abs(p10));\n    float m = max(0.,eps-canary)/eps;\n    m = sigmoid((m-.5)*700./(1.+10.*blur))*.5+.5;\n    //m = m*m*m*m*m*m*m*m*m*m;\n    vec3 m3 = m*(1.-accent_color);\n    c *= .8*(1.-m3)+.3;//mix(c, vec3(0.), m);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = min(iResolution.x, iResolution.y);\n   \tvec2 uv = (2.*fragCoord.xy - vec2(iResolution.xy)) / s;\n    \n    float blur = .5*(uv.x*uv.x+uv.y*uv.y);\n    \n    //angular, spatial and temporal frequencies\n    vec4 a0 = pi*vec4(.1, -.11, .111, -.1111); \n    vec4 wt0 = 2.*pi*vec4(.3);//.3333, .333, .33, .3);\n    vec4 ws0 = 2.5*vec4(11., 13., 11., 5.);\n\n    vec2 blueNoiseUV = fragCoord.xy / iChannelResolution[0].xy;\n    \n    float blueNoise = texture(iChannel0, blueNoiseUV).r / 9.;\n    \n\n    //aa and motion blur\n    float mb = iTimeDelta*1.;\n    float t = 1100.+iTime + blueNoise*mb;\n    vec3 c = scene(t, uv, a0, wt0, ws0, blur)\n        + scene(t-mb*(1./9.), uv+(1.+blur)*vec2(.66/s, 0.), a0, wt0, ws0, blur)\n        + scene(t-mb*(2./9.), uv+(1.+blur)*vec2(-.66/s, 0.), a0, wt0, ws0, blur)\n        + scene(t-mb*(3./9.), uv+(1.+blur)*vec2(0., .66/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(4./9.), uv+(1.+blur)*vec2(0., -.66/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(5./9.), uv+(1.+blur)*vec2(.5/s, .5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(6./9.), uv+(1.+blur)*vec2(-.5/s, .5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(7./9.), uv+(1.+blur)*vec2(-.5/s, -.5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*(8./9.), uv+(1.+blur)*vec2(.5/s, -.5/s), a0, wt0, ws0, blur)\n\n        ;\n    c/=9.;\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3SW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 79], [81, 81, 158, 158, 591], [593, 593, 664, 664, 2715], [2717, 2717, 2774, 2774, 4120]]}
{"id": "st3SWn", "name": "Bezier SDF 7.0", "author": "CasanovaI", "description": "Distancia a una curva de Bezier cuadrática. Inspirado por videos de Íñigo Quilez", "tags": ["sdf"], "likes": 2, "viewed": 75, "published": "Public", "date": "1639592649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//SDF of a quadratic Bezier curve\n\nfloat tSDF(vec2 p, float t, vec2 A, vec2 B, vec2 C){ //distancia a curva basada en t\n    vec2 S;\n    S += (t*t - 2.*t + 1.) * A;\n    S += (-2.*t*t + 2.*t) * B;\n    S += (t*t) * C;\n    \n    return length(S-p);\n}\n\nfloat cubicNewton(float g, float a, float b, float c, float d){ //método de newton para encontrar raíces, g es la primera estimación\n    float m = 1.;\n    \n    for(int i = 0; i < 200; i++){//límite de precisión\n        float func = a*(g*g*g) + b*(g*g) + c*(g) + d; //función evaluada\n        float der = 3.*a*(g*g) + 2.*b*(g) + c;        //derivada evaluada\n        \n        if(der == 0.0){\n            g += 0.1;//evitar dividir entre 0\n        }else{\n            m = -func/der;\n            g += m;\n        }\n    }\n    return g;\n}\n\nfloat SDF(vec2 p, vec2 A, vec2 B, vec2 C){ //Función final\n\n    //Coeficientes para la función de distancia basada en t\n    vec2 alpha = -A + 2.*B - C;\n    vec2 beta = 2.*A -2.*B;\n    vec2 gamma = -A + p;\n    \n    //coeficientes de la segunda función de distancia\n    float a = alpha.x * alpha.x + alpha.y * alpha.y; \n    float b = 2. * (alpha.x * beta.x + alpha.y * beta.y);\n    float c = 2. * (alpha.x * gamma.x + alpha.y * gamma.y) + beta.x * beta.x + beta.y * beta.y;\n    float d = 2. * (beta.x * gamma.x + beta.y * gamma.y);\n    float e = gamma.x * gamma.x + gamma.y * gamma.y;\n    \n    //primera aproximación de la raíz para el método de newton\n    float discr = 36.*b*b - 4.*24.*a*c;\n    if(discr > 0.0){\n        discr = sqrt(discr);\n    }\n    float pE = -(12.*b)/(24.*a);\n    float dE = 4.*a*pE*pE*pE + 3.*b*pE*pE + 2.*c*pE + d; \n    \n    float fGuess0 = pE - discr - 10.1;\n    float fGuess1 = pE + discr + 10.1;\n    \n    \n    float dist = min( tSDF(p, clamp(cubicNewton(fGuess0, 4. * a, 3. * b, 2. * c, d), 0.0, 1.0), A, B, C),\n                      tSDF(p, clamp(cubicNewton(fGuess1, 4. * a, 3. * b, 2. * c, d), 0.0, 1.0), A, B, C));//las fallas parecen estar en el método de newton\n\n    \n    return dist;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //puntos que definen la curva\n    vec2 A = vec2(0.5*cos(0.88*iTime), 0.4*sin(iTime));\n    vec2 B = vec2(0.7*cos(1.02*iTime), -0.4*sin(0.31*iTime));\n    vec2 C = vec2(0.6*sin(0.7*iTime), -0.4*sin(0.4*iTime));\n\n    // coordenadas normalizadas de 0 a 1 en x y lo corespondiente en y\n    vec2 u = fragCoord/iResolution.xy;\n    u.x *= iResolution.x/iResolution.y;\n    u -= vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n    vec2 p = u;\n    \n    \n    float dist = SDF(p, A, B, C);\n    dist -= 0.04;\n    \n    //coloreado\n    vec3 col = vec3(0.70, 0.38, 0.05);\n    if(dist < 0.0){\n        col = vec3 (0.15, 0.4, 0.63);\n        float th = 0.03;\n        float m = mod(dist + 0.5 * th, 2.0 * th);// bodge + 0.5 th\n        float ramp = (0.5/th * m) * (2.0 * -smoothstep(th, th, m) + 1.0) + smoothstep(th, th, m) * 1.0;\n        float blur = 0.02;\n        col *= 0.7 + 0.3 * smoothstep(0.25 - blur, 0.25 + blur, ramp);\n        \n    }else{\n        float th = 0.03;\n        float m = mod(dist + 0.5 * th, 2.0 * th);// bodge + 0.5 * th\n        float ramp = (0.5/th * m) * (2.0 * -smoothstep(th, th, m) + 1.0) + smoothstep(th, th, m) * 1.0;\n        float blur = 0.03;\n        col *= 0.7 + 0.3 * smoothstep(0.25 - blur, 0.25 + blur, ramp);\n    }\n    float inter = 0.005;\n    if(abs(dist) < inter){\n        col = mix(vec3(1), col, abs(dist)/inter);\n    }\n    if(length(A-p) < 0.02){\n        col = mix(vec3(1), col, length(A-p)/0.1);\n    }\n    if(length(B-p) < 0.02){\n        col = mix(vec3(1), col, length(B-p)/0.1);\n    }\n    if(length(C-p) < 0.02){\n        col = mix(vec3(1), col, length(C-p)/0.1);\n    }\n    \n    // Output\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3SWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 87, 119, 245], [247, 247, 310, 382, 783], [785, 785, 827, 906, 2009], [2013, 2013, 2070, 2104, 3713]]}
{"id": "st3XDr", "name": "WaveSurf", "author": "csterea", "description": "Wave ray tracing", "tags": ["waveraytracing"], "likes": 2, "viewed": 28, "published": "Public", "date": "1639214533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define M_INV_SQRT2 0.7071067811865475244008443621048490\n\n#define SURFACE_WIDTH_XY 40.0f\n#define SURFACE_HEIGHT_Z 1.0f\n\n#define SURFACE_DISPLACEMENT_Z 50.0f\n\n\nmat3 RotX(in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,  -s,\n        0.0,   s,   c);\n}\nmat3 RotY(in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat3(\n    \tc,   0.0,   s,\n        0.0, 1.0, 0.0,\n        -s,  0.0,   c);\n}\nmat3 RotZ(in float angleRad)\n{\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat3(\n    \tc,    -s, 0.0,\n    \ts,     c, 0.0,\n    \t0.0, 0.0, 1.0);\n}\n\n// plane = (normal, distToOrigin)\n// Plane from normal, point and additional distance to origin.\nvec4 PlaneFromNormDir(vec3 n, float additionalDist) {\n    return vec4(n, additionalDist);\n}\nfloat DistToPlane(vec3 p, vec4 plane) {\n    return dot(p, plane.xyz) - plane.w;\n}\nfloat RayIntersectPlane(vec3 rayO, vec3 rayD, vec4 plane) \n{\n    float t = dot(rayD, plane.xyz);\n    if(t == 0.0)\n        return 0.0;\n    return (plane.w - dot(plane.xyz, rayO)) / t;\n}\n\nbool RayIntersectBox(\n    vec3 rayO, vec3 rayD, // Normalized ray direction\n    vec3 boxExt,\n    out vec3 out_point1, out vec3 out_point2,\n\tout float out_rayDist1, out float out_rayDist2)\n{\n\tvec3 ox = vec3(1, 0, 0);\n    vec3 oy = vec3(0, 1, 0);\n    vec3 oz = vec3(0, 0, 1);\n        \n    int intersCount = 0;\n    \n    vec4 boxPlanes[6];\n    boxPlanes[0] = PlaneFromNormDir(-ox, boxExt.x);\n    boxPlanes[1] = PlaneFromNormDir(ox, boxExt.x);\n    boxPlanes[2] = PlaneFromNormDir(-oy, boxExt.y);\n    boxPlanes[3] = PlaneFromNormDir(oy, boxExt.y);\n    boxPlanes[4] = PlaneFromNormDir(-oz, boxExt.z); \n    boxPlanes[5] = PlaneFromNormDir(oz, boxExt.z);\n    \n    for(int i=0; i<6; ++i)\n    {\n        vec4 crtPlane = boxPlanes[i];\n        \n        float crtRayDist = RayIntersectPlane(rayO, rayD, crtPlane);\n        vec3 crtIntersPt = rayO + rayD * crtRayDist;\n        \n        bool intersContained = true;\n        for(int j=0; j<6; ++j)\n        {\n            if(i != j && DistToPlane(crtIntersPt, boxPlanes[j]) > 0.0)\n            {\n                intersContained = false;\n                break;\n            }\n        }\n        \n        if(intersContained)\n        {\n            ++intersCount;\n            if(intersCount == 1)\n            {\n                out_rayDist1 = crtRayDist;\n                out_point1 = crtIntersPt;\n            }\n            else \n            {\n                out_rayDist2 = crtRayDist;\n                out_point2 = crtIntersPt;\n                // We reached two intersection points, stop searching.\n                break;\n            }\n        }\n    }\n    \n    return intersCount == 2;\n}\n\nfloat SurfaceZ(float x, float y, float phase)\n{\n    return SURFACE_HEIGHT_Z * sin(phase + sqrt(x*x + y*y));\n}\n\nfloat SurfaceFunc(vec3 v, float phase)\n{\n    return SurfaceZ(v.x, v.y, phase) - v.z;\n}\n\nvec3 SurfaceNormal(vec3 v, float phase)\n{\n    float a2 = v.x*v.x + v.y*v.y;\n    if(a2 == 0.0)\n    {\n        return normalize(vec3(1.0, 1.0, 0.0));\n    }\n    \n    float a = sqrt(a2);\n    float c = cos(phase + a);\n    float d = SURFACE_HEIGHT_Z * c / a;\n    \n    float dzdx = d * v.x;\n    float dzdy = d * v.y;\n    \n    return normalize(vec3(-dzdx, -dzdy, 1.0));\n}\n\nbool RayIntersectSurface(\n    vec3 ray, // Normalized ray direction\n    vec3 surfaceCenter, mat3 surfaceRot, \n    out vec3 out_position, out vec3 out_normal, out vec2 out_uv)\n{\n    // Surface-local ray.\n    vec3 localRay0 = -surfaceRot * surfaceCenter;\n    vec3 localRayD = surfaceRot * ray;\n    \n    vec3 surfaceBoxExt = vec3(SURFACE_WIDTH_XY, SURFACE_WIDTH_XY, SURFACE_HEIGHT_Z);\n    \n    vec3 boxPoint1, boxPoint2;\n    float boxRayDist1, boxRayDist2;\n    if(!RayIntersectBox(\n        localRay0, localRayD, // Normalized ray direction\n        surfaceBoxExt,\n        boxPoint1, boxPoint2,\n        boxRayDist1, boxRayDist2))\n    {\n        return false;\n    }\n    \n    float phase = iTime * 2.0;    \n\n    float zDist1 = SurfaceFunc(boxPoint1, phase);\n    float zDist2 = SurfaceFunc(boxPoint2, phase);\n    \n    float crtRayDist;\n    float crtRayStep;\n    if(boxRayDist1 < boxRayDist2)\n    {\n        crtRayDist = boxRayDist1;\n        crtRayStep = zDist1;\n    }\n    else\n    {\n        crtRayDist = boxRayDist2;\n        crtRayStep = zDist2;\n    }\n    \n    vec3 crtRayPoint;\n\n    const float tol = 0.01;\n    for(int i=0; i<30; ++i)\n    {\n        float nextRayDist = crtRayDist + crtRayStep;\n        crtRayPoint = localRay0 + localRayD * nextRayDist;\n        float crtDeviationZ = SurfaceFunc(crtRayPoint, phase);\n        \n        if(abs(crtDeviationZ) < tol)\n        {\n            break;\n        }\n        \n        if(crtDeviationZ < 0.0f)\n        {\n            crtRayStep *= 0.5f;\n        }\n        else \n        {\n            crtRayStep = crtDeviationZ;\n            crtRayDist = nextRayDist;\n        }\n    }\n    \n    out_position = crtRayPoint * surfaceRot + surfaceCenter;\n    out_normal = SurfaceNormal(crtRayPoint, phase) * surfaceRot;\n    out_uv = 0.1 * vec2(crtRayPoint[0], crtRayPoint[1]);\n    \n    return true;\n}\n\nvec3 GetCombinedNormal(vec3 baseNormal, vec2 uv, sampler2D normalMap, float normalMapIntensity)\n{\n    float normalMapDensity = 2.0;\n    \n    vec2 normalMapValue = texture(normalMap, normalMapDensity * uv).xy;\n    vec2 ldudv = dFdx(normalMapValue) + dFdy(normalMapValue);\n    //vec3 ldudv = vec3(normalMapValue, 0.0);\n\n    vec3 dudv = vec3(ldudv, 0.0) - baseNormal * dot(ldudv, baseNormal.xy);\n    float lenDudv = length(dudv);\n    if(lenDudv != 0.0)\n    \tdudv /= lenDudv;\n    dudv *= length(ldudv);\n    \n    return normalize(baseNormal + normalMapIntensity * dudv);\n}\n\nvec3 GetLightingColor(\n    vec3 matColor, \n    vec3 position, vec3 baseNormal, float normalMapIntensity,\n\tvec2 uv, sampler2D baseTexture, sampler2D normalMap)\n{\n    vec3 lightPos = normalize(vec3(0.0, 0.0, -10.0));\n    \n    vec3 lightDir = normalize(position - lightPos);\n\n    vec3 normal = (normalMapIntensity != 0.0\n        ? GetCombinedNormal(baseNormal, uv, normalMap, normalMapIntensity)\n        : baseNormal);\n\n    float reflection = abs(dot(normal, lightDir));\n\n    // Apply Phong shading of the 3rd degree.\n    reflection *= reflection * reflection;\n    \n    return 0.5 * (matColor + texture(baseTexture, uv).xyz) \n        * reflection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 matColor = vec3(0.99, 0.99, 0.99);    \n  \n    vec3 surfaceCenter = vec3(0, 0, SURFACE_DISPLACEMENT_Z);\n    float surfaceNormalMapIntensity = 1.0;\n    \n    mat3 rot = mat3(\n        1.0, 0.0, 0.0, \n        0.0, 1.0, 0.0, \n        0.0, 0.0, 1.0);\n    vec2 uvm = vec2(\n        1.8 - 4.0 * iMouse.x / iResolution.x,\n        1.8 - 4.0 * iMouse.y / iResolution.y);\n    \n\t// Perform the animations.\n    rot *= RotX(-uvm.y);\n    rot *= RotY(uvm.x);\n\n    // Create a 3D rendering ray from the user point of view to a 3D point containing the current pixel.\n    float aspect = iResolution.x / iResolution.y;\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    vec3 renderRayDir = normalize(vec3(\n        aspect * (fragCoord.x/(0.5 * iResolution.x) - 1.0),\n        fragCoord.y/(0.5 * iResolution.y) - 1.0,\n        1.5));\n        \n    // Get the intersection point with the surface.\n    vec3 position, normal;\n    vec2 uv;\n    bool isIntersecting = RayIntersectSurface(\n        renderRayDir, \n        surfaceCenter, rot, \n        position, normal, uv);\n\n    // Get the lighting colors.\n    vec3 col = vec3(0,0,0);\n    if(isIntersecting)\n    {\n        col = GetLightingColor(\n            matColor, \n            position, normal, surfaceNormalMapIntensity, \n            uv, iChannel0, iChannel1);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3XDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 236, 236, 373], [374, 374, 404, 404, 538], [539, 539, 569, 569, 697], [699, 796, 849, 849, 887], [888, 888, 927, 927, 969], [970, 970, 1030, 1030, 1154], [1156, 1156, 1345, 1345, 2764], [2766, 2766, 2813, 2813, 2875], [2877, 2877, 2917, 2917, 2963], [2965, 2965, 3006, 3006, 3327], [3329, 3329, 3505, 3531, 5144], [5146, 5146, 5243, 5243, 5713], [5715, 5715, 5875, 5875, 6361], [6363, 6363, 6420, 6420, 7769]]}
{"id": "st3XRS", "name": "[TDF21]Footwear concept demo", "author": "yasuo", "description": "TDF2021", "tags": ["tdf2021"], "likes": 6, "viewed": 78, "published": "Public API", "date": "1639308310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define MATERIAL_UPPER 0\n#define MATERIAL_OUTSOLE 1\n#define MATERIAL_EFFECT 2\n#define SCENE0 3.0\n#define SCENE1 10.0\n#define SCENE2 20.0\n#define SCENE3 30.0\n#define SCENE_LENGTH 38.0\n\nfloat getSceneTime(){\n    return mod(iTime,SCENE_LENGTH);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 combine(vec2 val1, vec2 val2  ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nvec2 smoothCombine(vec2 val1, vec2 val2, float k ){\n    if(val1.x < val2.x){\n        val1.x = opSmoothUnion(val1.x,val2.x,k);\n        return val1;\n    }\n    val2.x = opSmoothUnion(val1.x,val2.x,k);\n    return val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSimpleCylinder(vec3 p, float r, float h){\n    float d = length(p.xz)-r;\n    d = max(abs(p.y)-h,d);\n    return d;\n}\n\n// =========== 3D Model ===========\n\nfloat baseOutsole(vec3 p, float h){\n    vec3 prevP = p;\n    \n    p.xz*=Rot(radians(17.0));\n    p.z*=0.4;\n    p.x*=0.57;\n    p.x+=0.03;\n    p.z-=0.07;\n    \n    float d =sdSimpleCylinder(p,0.1,h);\n    \n    p = prevP;\n    p.xy*=Rot(radians(90.0));\n    p.y*=1.5;\n    p.z*=1.2;\n    float d2 = sdCappedCylinder(p-vec3(0.0,0.0,-0.25),h,0.2);\n    d = opSmoothUnion(d, d2,0.13);\n    \n    p = prevP;\n    d = max(abs(p.y)-h,d);\n    \n    return (d)*0.6;\n}\n\nfloat outsole(vec3 p){\n    p.z*=0.9;\n    vec3 prevP = p;\n    \n    float d = baseOutsole(p-vec3(0.0,0.02,0.),0.06);\n    \n    // wave traction pattern\n    float scene = getSceneTime();\n    if(scene<SCENE0){\n        p.z+=scene*0.1;\n    }\n    p.z+=sin(p.x*80.0)*0.01;\n    p.z = mod(p.z,0.09)-0.045;\n    float d2 = sdBox(p,vec3(0.2,0.03,0.03));\n    \n\n    d = max(d,d2);\n    p = prevP;\n    d2 = baseOutsole(p-vec3(0.0,0.025,0.0),0.035);\n    d = min(d,d2);\n    \n    p = prevP;\n    float a  = radians(4.0);\n    p.y-=0.06;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    a  = radians(-8.0);\n    p.y+=0.07;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    a  = radians(10.0);\n    p.y+=0.08;\n    mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.xz*=0.95;\n    p.y+=sin(p.x*50.0)*0.01;\n    d2 = baseOutsole(p-vec3(0.0,0.017,0.),0.002);\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat upperBase(vec3 p){\n    p.z*=0.9;\n    vec3 prevP2 = p;\n    p.z+=sin(p.x*300.0)*0.005;\n    p.x+=cos(p.y*70.0)*0.005;\n    vec3 prevP = p;\n\n    //p.x*=1.;\n    p.z*=0.8;\n    \n    float d =sdCappedCone(p-vec3(0.0,0.18,-0.15),0.13,0.15,0.06);\n    \n    p = prevP;\n    p.xz*=Rot(radians(15.0));\n    p.yz*=Rot(radians(-6.0));\n    p.x*=1.2;\n    p.z*=0.8;\n    \n    float d2 = sdEllipsoid(p-vec3(-0.05,0.1,0.14),vec3(0.2,0.08,0.2));\n    d = opSmoothUnion(d,d2,0.1);//0.1\n    \n    p = prevP;\n    p.xz*=Rot(radians(0.0));\n    p.x*=1.1;\n    p.z*=0.8;\n    p.yz*=Rot(radians(-35.0));\n\n    d2 = sdEllipsoid(p-vec3(0.0,0.21,-0.1),vec3(0.1,0.04,0.15));\n\n    d = opSmoothUnion(d,d2,0.17);//0.15\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(18.0));\n    p.y*=1.5;\n    p.z*=1.0;\n    d2 = sdCappedCylinder(p-vec3(-0.1,0.0,-0.2),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    p = prevP2;\n    p.xy*=Rot(radians(90.0));\n    p.xz*=Rot(radians(15.0));\n    p.y*=1.3;\n    p.z*=0.99;\n    d2 = sdCappedCylinder(p-vec3(-0.04,0.0,-0.22),0.001,0.2);\n    d = opSmoothUnion(d, d2,0.07);\n    \n    return d;\n}\n\nfloat upper(vec3 p){\n    vec3 prevP = p;\n    float d = upperBase(p);\n    p.x*=1.5;\n    p.y*=1.1;\n    p.z*=1.12;\n    \n    float d2 = upperBase(p-vec3(0.0,0.02,0.0));\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    p.x*=1.6;\n    p.z*=0.7;\n    \n    d2 =sdCappedCone(p-vec3(-0.01,0.25,-0.1),0.14,0.14,0.09);\n    d = max(-d2,d);\n    \n    p = prevP;\n    float a  = radians(8.0);\n    p.y-=0.31;\n    float mask = dot(p.yz,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(-15.0));\n    p.x*=1.2;\n    p.y*=1.1;\n    p.z*=0.65;\n    d2 = sdTorus(p-vec3(-0.005,0.31,-0.145),vec2(0.1,0.02));\n    \n    d = opSmoothUnion(d,d2,0.05);\n    \n    p = prevP;\n    p.x*=1.4;\n    p.z*=0.75;\n    d2 =sdSimpleCylinder(p-vec3(-0.005,0.35,-0.115),0.1,0.2);\n    d = max(-d2,d);\n    \n    return d*0.8;\n}\n\nvec2 GetDist(vec3 p) {\n    //p+=noise3d(p*600.0)*0.0002;\n    vec3 prevP = p;\n    \n    p.y+=0.125;\n   \n    float d = outsole(p);\n    float d2 = upper(p-vec3(0.0,0.0,0.0));\n    \n    vec2 model = vec2(d2,MATERIAL_UPPER);\n    vec2 model2 = vec2(d,MATERIAL_OUTSOLE);\n    \n    float scene = getSceneTime();\n    if(scene>=SCENE3){\n        p.xz*=Rot(radians(iTime*50.0));\n        d = sdTorus(p,vec2(0.45,0.005));\n        d = max(-(abs(p.x)-0.455),d);\n\n        p = prevP;\n        p.y+=0.125;\n        p.xy*=Rot(radians((iTime*-50.0)));\n        p.yz*=Rot(radians(90.0));\n        d2 = sdTorus(p,vec2(0.45,0.005));\n        d2 = max(-(abs(p.x)-0.455),d2);\n\n        vec2 model3 = vec2(min(d,d2),MATERIAL_EFFECT);\n        return combine(smoothCombine(model,model2,0.03),model3);\n    }\n    return smoothCombine(model,model2,0.03);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.1)*diff*occ;\n    diffCol += col*vec3(1.0,0.95,1.0)*skyDiff*occ;\n    diffCol += col*vec3(1.0,0.9,0.85)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 evaTex(vec2 uv, vec3 col){\n    uv.y+=iTime*0.1;\n    vec2 prevUV = uv;\n    uv*=30.0;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    gv.y*=n;\n    \n    gv.x+=cos(uv.y*5.0)*0.2+sin(uv.y*2.0)*0.05;\n    float d = length(gv)-0.5*abs(n);\n    if(n<0.5){\n        col = mix(col,vec3(1.3),S(d,0.0));\n    }\n    \n    return col;\n}\n\nvec3 upperTex(vec2 uv, vec3 col){\n    vec2 prevUV = uv;\n    uv.y*=0.3;\n    uv.x*=1.5;\n    uv.x+=cos(uv.y*100.0)*0.01+sin(uv.y*80.0)*0.02;\n    float d = -uv.x+0.13;\n    col = mix(col,vec3(1.5,1.4,1.4),S(d,0.0));\n\n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL_UPPER){\n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.6,0.6)*evaTex(p.xz+p.yy,col)*upperTex(p.yz,col));\n    }\n     if(mat == MATERIAL_OUTSOLE){\n        col = diffuseMaterial(n,rd,p,vec3(0.9));\n    }\n    if(mat == MATERIAL_EFFECT){\n        col = diffuseMaterial(n,rd,p,vec3(1.2,1.2,1.2));\n    }\n    return col;\n}\n\n// =========== UI part ===========\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat dTri(vec2 p, vec2 s){\n    p*=-1.0;\n    return Tri(p,s,radians(30.0));\n}\n\nfloat animationMask(vec2 p, float speed){\n    float t = mod(iTime*speed,360.0);\n    float rad = radians(t);\n    float d = sdPie(p,vec2(sin(rad),cos(rad)),0.15);\n    return d;\n}\n\nfloat charT(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    \n    float mask = sdBox(p-vec2(0.031,-0.031),vec2(0.071));\n    d = max(-mask,d);\n    \n    p*=Rot(radians(45.0));\n    p.x+=0.075;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charD(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = sdRoundedBox(p,vec2(size),vec4(0.05,0.05,0,0));\n    float d2 = sdRoundedBox(p,vec2(0.04,0.04),vec4(0.025,0.025,0,0));\n    d = max(-d2,d);\n    p*=Rot(radians(45.0));\n    p.x+=0.04;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    \n    if(animate == 1){\n        float mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    \n    return d;\n}\n\nfloat charF(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    p = prevP;\n    float mask = sdBox(p-vec2(0.06,0.025),vec2(0.1,0.015));\n    d = max(-mask,d);\n    \n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat drawTDFLogo(vec2 p, int animate, float speed){\n    float d = charT(p-vec2(-0.13,0.0),animate,speed);\n    float d2 = charD(p-vec2(-0.05,0.0),animate,speed);\n    d = min(d,d2);\n    d2 = charF(p-vec2(0.17,0.0),animate,speed);\n    \n    return min(d,d2);\n}\n\nfloat drawTDFLogoPararell(vec2 p, int animate, float speed){\n    float d = charT(p-vec2(-0.13,0.0),animate,speed);\n    float d2 = charD(p-vec2(-0.05,0.0),animate,speed*0.5);\n    d = min(d,d2);\n    d2 = charF(p-vec2(0.17,0.0),animate,speed*0.75);\n    \n    return min(d,d2);\n}\n\nvec3 drawHUD(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.215);\n    p*=Rot(radians(45.0));\n    float d = B(p,vec2(0.001,0.005));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-iTime*10.0));\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.21);\n    p*=Rot(radians(45.0));    \n    d = B(p,vec2(0.001,0.015));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*20.0));\n    d = abs(length(p)-0.32)-0.005;\n    d = max(-B(p,vec2(1.0,0.2)),d);\n\n    p = mod(p,0.005)-0.0025;\n    d = max(-B(p,vec2(0.003)),d);\n\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(sin(iTime*1.0)*45.0));\n    p = DF(p,1.0);\n    p = abs(p);\n    p -= vec2(0.24);\n    p*=Rot(radians(45.0));   \n    d = dTri(p,vec2(0.015));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawUI(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=3.5;\n    p = abs(p);\n    p.x -=2.7;\n    p.y -=1.3;\n    p*=Rot(radians(-90.0));\n    \n    float d = drawTDFLogo(p,1,0.0);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    p = prevP;\n    p*=0.8;\n    \n    float scene = getSceneTime();\n    if((scene>=SCENE0 && scene<SCENE1)||(scene>=SCENE2 && scene<SCENE3)){\n        col = drawHUD(p,col);\n    }\n    return col;\n}\n\nvec3 startSceneBg(vec2 p, vec3 col){\n    p = mod(p,0.2)-0.1;\n    float d = B(p,vec2(0.00001,0.01));\n    float d2 = B(p,vec2(0.01,0.00001));\n    d = min(d,d2);\n    col = mix(col,vec3(0.9,0.9,0.1)*0.5,S(d,0.0));\n    \n    return col;\n}\n\nvec3 endSceneBg(vec2 p, vec3 col){\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    float n = Hash21(id);\n\n    gv*=0.3;\n    float d = charT(gv,1,100.0);    \n    if(n>=0.4 && n<0.7){\n        d = charD(gv,1,120.0*n);\n    } else if(n>=0.7){\n        d = charF(gv,1,140.0*n);\n    }\n    \n    col = mix(col,vec3(0.9,0.9,0.1),S(d,0.0));\n    \n    return col;\n}\n\nvec3 postEffect(vec2 p, vec3 col){\n    p*=8.0;\n\n    float y = fract(p.y)-0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = Hash21(id);\n    \n    p.y = y;\n    \n    float d = B(p,vec2(cos(iTime*n*20.0)*100.0*n*n,sin(iTime*n*20.0)*100.0*n*n));\n    col = mix(col,vec3(0.9,0.9,0.1)*0.75,S(d,0.0));\n    return col;\n}\n\nvec3 logoAnimationBg(vec2 p, vec3 col){\n    float brightness = 0.2;\n    vec2 prevP = p;\n    p.x+=iTime*0.1;\n    p.x = mod(p.x,0.54)-0.27;\n    p.y = mod(p.y,0.45)-0.225;\n    float d = drawTDFLogoPararell(p,1,100.0);\n    col = mix(col,vec3(0.9,0.9,0.1)*brightness,S(d,0.0));\n    p = prevP;\n    p.x-=iTime*0.1;\n    p.y+=0.225;\n    p.x = mod(p.x,0.54)-0.27;\n    p.y = mod(p.y,0.45)-0.225;\n    d = drawTDFLogoPararell(p,1,120.0);\n    col = mix(col,vec3(0.9,0.9,0.1)*brightness,S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    float scene = getSceneTime();\n    \n    if(scene>=SCENE1 && scene<SCENE2){\n        uv.y+=scene*0.1;\n        uv*=2.4;\n        uv = fract(uv)-0.5;\n    } else if(scene>=SCENE3){\n        uv.y+=scene*0.1;\n        uv*=1.4;\n        uv.y = fract(uv.y)-0.5;\n    }\n    \n    vec2 m = iMouse.xy/iResolution.xy -.3;\n    \n    float cz = 0.85;\n    if(scene>=SCENE0 && scene<=SCENE1){\n        cz = 1.;\n    }  else if(scene>=SCENE1 && scene<=SCENE2){\n        cz = 1.2;\n    } else if(scene>=SCENE2){\n        cz = 1.0;\n    }\n    \n    vec3 ro = vec3(0, 0, cz);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    if(scene<SCENE0){\n        ro.yz *= Rot(radians(90.0));\n        ro.xz *= Rot(radians(-90.0));\n    } else {\n        if(scene>=SCENE1 && scene<SCENE2){\n            ro.yz *= Rot(radians(-35.0));\n            ro.xz *= Rot(radians(-5.0+scene*20.0));\n        } else if(scene>=SCENE2 && scene<SCENE3){\n            ro.yz *= Rot(radians(30.0));\n            ro.xz *= Rot(radians(-5.0+scene*20.0));\n        } else if(scene>=SCENE3){\n           \n            ro.xz *= Rot(radians(-25.0+scene*20.0));\n            ro.yz *= Rot(radians(85.0));\n           \n        } else {\n            ro.xz *= Rot(radians(-5.0+scene*20.0));\n        }\n       \n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        //col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        //col = upperTex(uv,col);\n        uv = prevUV;\n        \n        col = vec3(0.0);\n        \n        uv.y+=scene*0.1;\n        uv*=0.5;\n        \n        if(scene<SCENE0){\n            uv = prevUV;\n            uv.y+=scene*0.1;\n            col = startSceneBg(uv,col);\n        }\n\n        if(scene>=SCENE0 && scene<SCENE1){\n            uv.y = mod(uv.y,0.4)-0.2;\n            float ld = drawTDFLogo(uv-vec2(0.0,0.08),0,0.0);\n            col = mix(col,vec3(0.9,0.9,0.1)*0.25,S(ld,0.0));\n            ld = drawTDFLogo(uv,0,0.0);\n            col = mix(col,vec3(0.9,0.9,0.1)*0.5,S(ld,0.0));\n            ld = drawTDFLogo(uv-vec2(0.0,-0.08),0,0.0);\n            col = mix(col,vec3(0.9,0.9,0.1),S(ld,0.0));\n        }\n        \n        uv = prevUV;\n        if(scene>=SCENE2 && scene<SCENE3){\n                uv.xy *= Rot(radians(sin(scene*.3)*20.0));\n                float d2 = abs(uv.y);\n                float k = 0.5 / d2;\n                uv = uv * k + vec2(0, k);\n                uv-=iTime*0.5;\n                col = endSceneBg(uv,col);\n                col*=d2*2.0;\n        }\n\n        if(scene>=SCENE3){\n            col = logoAnimationBg(uv,col);\n        }\n    }\n    \n    // UI\n    //float ld = drawTDFLogo(uv,1,60.0);\n    if(scene<SCENE0){\n        uv = prevUV;\n        float ld = drawTDFLogo(uv,0,0.0);\n        col = mix(col,vec3(0.9,0.9,0.1),S(ld,0.0));\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    uv = prevUV;\n    col = drawUI(uv,col);\n    \n    if(scene>=SCENE0-0.2 && scene<SCENE0+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>=SCENE1-0.2 && scene<SCENE1+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>=SCENE2-0.2 && scene<SCENE2+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>=SCENE3-0.1 && scene<SCENE3+0.1){\n        col = postEffect(uv,col);\n    } else if(scene>SCENE_LENGTH-0.2 || scene<0.1){\n        col = postEffect(uv,col);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3XRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 823, 844, 844, 882], [884, 884, 906, 906, 996], [998, 1073, 1098, 1098, 1117], [1118, 1118, 1143, 1143, 1162], [1163, 1163, 1215, 1215, 1315], [1317, 1429, 1454, 1454, 1799], [1801, 1801, 1838, 1838, 1880], [1882, 1882, 1933, 1933, 2098], [2100, 2175, 2208, 2208, 2273], [2275, 2350, 2402, 2402, 2509], [2511, 2586, 2617, 2617, 2704], [2706, 2781, 2818, 2818, 2901], [2903, 2978, 3037, 3037, 3350], [3352, 3352, 3401, 3401, 3474], [3476, 3513, 3548, 3548, 3956], [3958, 3958, 3980, 3980, 4937], [4939, 4939, 4963, 4963, 6049], [6051, 6051, 6071, 6071, 6858], [6860, 6860, 6882, 6916, 7675], [7677, 7677, 7722, 7722, 7991], [7993, 7993, 8017, 8017, 8218], [8220, 8220, 8262, 8262, 8457], [8459, 8500, 8549, 8549, 8840], [8842, 8842, 8899, 8899, 9446], [9448, 9448, 9479, 9479, 9816], [9818, 9818, 9851, 9851, 10047], [10049, 10049, 10108, 10108, 10445], [10483, 10562, 10599, 10599, 10679], [10681, 10760, 10815, 10815, 10972], [10974, 11053, 11102, 11102, 11270], [11272, 11272, 11299, 11299, 11349], [11351, 11351, 11392, 11392, 11527], [11529, 11529, 11576, 11576, 12023], [12025, 12025, 12072, 12072, 12494], [12496, 12496, 12543, 12543, 12878], [12880, 12880, 12932, 12932, 13137], [13139, 13139, 13199, 13199, 13413], [13415, 13415, 13446, 13446, 14346], [14348, 14348, 14378, 14378, 14763], [14765, 14765, 14801, 14801, 14997], [14999, 14999, 15033, 15033, 15362], [15364, 15364, 15398, 15398, 15694], [15696, 15696, 15735, 15735, 16201], [16203, 16203, 16260, 16260, 19909]]}
{"id": "st3XzB", "name": "rotate_shape", "author": "newJasper", "description": "rotate", "tags": ["2d"], "likes": 0, "viewed": 73, "published": "Public API", "date": "1639319555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rectshape(vec2 position, vec2 scale){\n\tscale = vec2(0.5) - scale * 0.7;\n\tvec2 shaper = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shaper *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n\treturn shaper.x * shaper.y; \n}\n\nmat2 rotate(float angle){\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord/iResolution.y;\n\n    vec3 color = vec3(0.0);\n\n\tcoord -= vec2(0.5);\n    coord = (fragCoord - .5* iResolution.xy ) /iResolution.y;\n\tcoord = rotate(0.3*sin(iTime))*coord ;\n\tcoord += vec2(0.5);\n\n\tcolor += vec3(rectshape(coord, vec2(0.3, 0.3)));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3XzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 270], [272, 272, 297, 297, 362], [364, 364, 421, 471, 798]]}
{"id": "stcSRB", "name": "[TDF2021] Butterflies in the Sky", "author": "Kamoshika", "description": "25 minutes live coding @Tokyo Demo Fest 2021 Shader Showdown Final\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/", "tags": ["cloud", "livecoding", "butterflies", "butterfly"], "likes": 27, "viewed": 392, "published": "Public", "date": "1639316022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Watch the recording of the live coding on YouTube.\n// https://youtu.be/bp37xTVNRrM?t=16035\n\n#define time iTime\n#define hash(x) fract(sin(x)*1763.2632)\n#define saturate(x) clamp(x,0.,1.)\nconst float pi=acos(-1.);\nconst float pi2=acos(-1.)*2.;\nconst float N=50.;\n\nmat2 rot(float a){\n  float s=sin(a),c=cos(a);\n  return mat2(c,s,-s,c);\n}\n\nfloat rt=1e5;\nvec3 rn;\nfloat rid;\nvec2 ruv;\nvoid intersect(vec3 ro,vec3 rd,vec3 ce,mat2 M,float id,float s){\n  M[0][1]*=s;\n  M[1][0]*=s;\n  vec3 n=vec3(vec2(0,1)*M,0);\n  float t=dot(ce-ro,n)/dot(rd,n);\n  if(t<0.||t>rt)return;\n  vec3 q=ro+t*rd-ce;\n  q.yx*=M;\n  if(q.x*s<0.)return;\n  vec2 p=q.xz;\n  \n  p.x=abs(p.x)*.8;\n  if(p.x>sin(p.y*50.)*.025+.4+p.y*.4)return;\n  if(p.y<0.)p*=1.5;\n  p.y=abs(p.y);\n  if(length(p)>sin(atan(p.y,p.x)*2.)+smoothstep(.1,0.,p.y)*.3)return;\n  if(dot(rd,n)>0.)n*=-1.;\n  \n  rt=t;\n  rn=n;\n  rid=id;\n  ruv=q.xz;\n}\n\nvec3 hsv(float h,float s,float v){\n  vec3 res=fract(h+vec3(0,2,1)/3.)*6.-3.;\n  res=saturate(abs(res)-1.);\n  res=(res-1.)*s+1.;\n  res*=v;\n  return res;\n}\n\nfloat n3d(vec3 p){\n  vec3 i=floor(p);\n  vec3 f=fract(p);\n  vec3 b=vec3(13,193,9);\n  vec4 h=vec4(0,b.yz,b.y+b.z)+dot(i,b);\n  f=f*f*(3.-2.*f);\n  h=mix(hash(h),hash(h+b.x),f.x);\n  h.xy=mix(h.xz,h.yw,f.y);\n  return mix(h.x,h.y,f.z);\n}\n\nfloat fbm(vec3 p){\n  float ac=0.,a=1.;\n  for(int i=0;i<5;i++){\n    ac+=n3d(p*a)/a;\n    a*=2.;\n  }\n  return ac-.5;\n}\n  \nfloat density(vec3 p){\n  return saturate(fbm(p*.5)-p.y*.03-.7);\n}\n\n#define odd(x) step(1.,mod(x,2.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1)*.5;\n  vec3 col=vec3(0);\n  \n  float cam=odd(time*.2);\n  float L=4.+odd(time*.4-1.)*4.;\n  vec3 ro=vec3(0,0,time);\n  ro.xy=mix(vec2(0,L),vec2(L*.5,0),cam);\n  vec3 rd=normalize(vec3(uv,-2));\n  rd=mix(vec3(-rd.x,rd.z,rd.y),vec3(rd.z,rd.y,-rd.x),cam);\n  //rd=vec3(-rd.x,rd.z,rd.y);\n  \n  for(float i=0.;i<N;i++){\n    float T=i/N+time*.1;\n    float id=i/N+floor(T);\n    vec3 ce=vec3(0,0,ro.z+fract(T)*14.-7.);\n    mat2 M=rot(sin(T*50.+hash(id)*pi2));\n    ce.xy+=hash(vec2(1.1,1.2)*id)*6.-3.;\n    ce.xy+=sin(vec2(5,7)*time*.2+hash(id*1.3)*pi2);\n    \n    intersect(ro,rd,ce,M,id,1.);\n    intersect(ro,rd,ce,M,id,-1.);\n  }\n  \n  /*vec2 p=uv;\n  \n  p.x=abs(p.x)*.8;\n  if(p.x>sin(p.y*50)*.025+.4+p.y*.4)return;\n  if(p.y<0)p*=1.5;\n  p.y=abs(p.y);\n  if(length(p)>sin(atan(p.y,p.x)*2)+smoothstep(.1,0.,p.y)*.3)return;*/\n  \n  vec3 ld=normalize(vec3(-5,2,-2));\n  \n  if(rt<100.){\n    float h=hash(rid);\n    ruv.x=abs(ruv.x);\n    float w=fbm(vec3(ruv,hash(rid*1.2)*500.));\n    h+=fbm(vec3(ruv+w*5.,hash(rid*1.1)*500.))*.3;\n    col+=hsv(h,.8,fract(h*5.+hash(rid*1.3)));\n    col*=smoothstep(-1.,-.93,sin(atan(ruv.y,ruv.x)*40.));\n    rn.x+=fbm(vec3(ruv*10.,hash(rid*1.3)*500.));\n    rn=normalize(rn);                                       // Added.\n    float diff=max(dot(ld,rn),0.);\n    float spec=pow(max(dot(reflect(ld,rn),rd),0.),20.);\n    float m=.6;\n    float lp=5.;\n    \n    col*=diff*(1.-m)*lp+spec*m*lp+.3;\n  }else{\n    col+=vec3(.5,.6,.9)*.1;\n    col=mix(col,vec3(1),pow(max(dot(ld,rd),0.),100.)*2.);\n  }\n  \n  vec3 rp=ro;\n  float tra=1.,rs=1.,t=0.,den,ac=0.;\n  for(int i=0;i<20;i++){\n    if(t>rt)break;\n    den=density(rp+t*rd);\n    ac+=tra*den;\n    tra*=1.-den;\n    if(tra<.001)break;\n    t+=rs;\n  }\n  col+=ac;\n  \n  col=pow(col,vec3(1./2.2));\n  \n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 265, 283, 283, 337], [383, 383, 447, 447, 874], [876, 876, 910, 910, 1028], [1030, 1030, 1048, 1048, 1260], [1262, 1262, 1280, 1280, 1377], [1381, 1381, 1403, 1403, 1446], [1482, 1482, 1539, 1539, 3442]]}
{"id": "stcSW7", "name": "20211127_TDF2021-SS-Quarter", "author": "0b5vr", "description": "kill me (see L132)\n\nShader Showdown @ TokyoDemoFest 2021. Coded in 25 minutes.\n\nThe intended one: https://www.shadertoy.com/view/stcXRs\n\nhttps://tokyodemofest.jp/\n", "tags": ["3d", "pathtracing", "quadtree"], "likes": 13, "viewed": 188, "published": "Public", "date": "1639213453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fs(i) (fract(sin((i)*114.514)*1919.810))\n#define lofi(i,j) (floor((i)/(j))*(j))\n\nconst float PI=acos(-1.);\nconst float TAU=PI*2.;\n\nfloat time;\nfloat seed;\n\nfloat random(){\n  seed=fs(seed);\n  return seed;\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.99?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nvec3 sampleLambert(vec3 n){\n  float phi16=TAU*random();\n  float ct=sqrt(random());\n  float st=sqrt(1.0-ct*ct);\n  return orthBas(n)*vec3(\n    cos(phi16)*st,\n    sin(phi16)*st,\n    ct\n  );\n}\n\nvec4 ibox(vec3 ro,vec3 rd,vec3 s){\n  vec3 src=ro/rd;\n  vec3 dst=abs(s/rd);\n  vec3 fv=-src-dst;\n  vec3 bv=-src+dst;\n  float f=max(max(fv.x,fv.y),fv.z);\n  float b=min(min(bv.x,bv.y),bv.z);\n  if(f<0.||b<f){return vec4(1E2);}\n  vec3 n=-sign(rd)*step(fv.zxy,fv)*step(fv.yzx,fv);\n  return vec4(n,f);\n}\n\nstruct QTR{\n  vec3 cell;\n  vec3 size;\n  float len;\n  bool hole;\n};\n\nQTR qt(vec3 ro,vec3 rd){\n  QTR r;\n  r.size=vec3(1,1E3,1);\n  for(int i=0;i<4;i++){\n    r.size/=2.;\n    r.cell=lofi(ro+rd*1E-2*r.size,r.size)+r.size/2.;\n    float d1=fs(dot(vec3(.2,1.4,-2.),r.cell));\n    r.hole=(\n      r.cell.y>0.\n      || d1>.8\n    );\n    if(r.hole){break;}\n    float d2=fs(dot(vec3(4,5,6),r.cell));\n    if(d2>.5){break;}\n  }\n  \n  \n  vec3 src=(ro-r.cell)/rd;\n  vec3 dst=abs(r.size/2./rd);\n  vec3 bv=-src+dst;\n  float b=min(min(bv.x,bv.y),bv.z);\n  r.len=b;\n  \n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n  \n  time=iTime;\n  seed=texture(iChannel0,uv*8.).x;\n  seed+=fract(time);\n  \n  vec3 col=vec3(0);\n  vec3 colRem=vec3(1);\n  \n  p.xy*=r2d(.4);\n  \n  vec3 co=vec3(0,1,2);\n  co.zx*=r2d(.2*time);\n  vec3 ct=vec3(.2,-1,0);\n  vec3 cz=normalize(co-ct);\n  \n  vec3 ro=co;\n  vec3 ro0=ro;\n  vec3 rd=orthBas(cz)*normalize(vec3(p,-2));\n  vec3 rd0=rd;\n  \n  bool shouldInit=true;\n  float samples=0.;\n  \n  for(int i=0;i<99;i++){\n    if(shouldInit){\n      shouldInit=false;\n      ro=ro0;\n      rd=rd0;\n      colRem=vec3(1);\n      samples++;\n    }\n    \n    QTR qtr=qt(ro,rd);\n    \n    vec4 isect=vec4(1E2);\n    vec3 off=vec3(0);\n    if(!qtr.hole){\n      off.y-=1.;\n      float d1=fs(dot(qtr.cell,vec3(.2,.8,.6)));\n      off.y-=sin(d1*6.+time);\n      vec3 size=vec3(qtr.size/2.-.02);\n      isect=ibox(ro-qtr.cell-off,rd,size);\n    }\n    \n    if(isect.w<1E2){\n      ro+=rd*qtr.len; // fuck fuck fuck fuck fuck fuck fuck fuck fuck fuck\n      // intended: ro+=rd*isect.w;\n\n      if((ro-off).y>-1.*qtr.size.x){\n        col+=colRem*5.;\n        colRem*=0.;\n      }\n\n      vec3 N=isect.xyz;\n      colRem*=.3;\n     \n      rd=mix(\n        sampleLambert(N),\n        reflect(rd,N),\n        .5\n      );\n    }else{\n      ro+=rd*qtr.len;\n    }\n    \n    if(colRem.x<.01){\n      shouldInit=true;\n    }\n  }\n  \n  col/=samples;\n  col*=1.0-length(p)*.3;\n  col=vec3(\n    smoothstep(.1,.9,col.x),\n    smoothstep(.0,1.,col.y),\n    smoothstep(-.1,1.1,col.z)\n  );\n\n  fragColor = vec4(col,1);\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 179, 179, 213], [215, 215, 236, 236, 368], [370, 370, 388, 388, 435], [437, 437, 464, 464, 625], [627, 627, 661, 661, 922], [992, 992, 1016, 1016, 1480], [1482, 1482, 1539, 1539, 3115]]}
{"id": "stcXD7", "name": "Isometric Grid Height Map", "author": "Shane", "description": "Rendering some overlapping hexagons on an isometric grid to produce a height map of extruded blocks.", "tags": ["2d", "grid", "hexagon", "heightmap", "vector", "isometric", "block"], "likes": 48, "viewed": 443, "published": "Public API", "date": "1639406773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Isometric Grid Height Map\n    -------------------------\n    \n    Rendering some overlapping hexagons in an isometric grid fashion \n    to produce a height map of extruded blocks. Isometric grid \n    renderings are certainly not new, but they're fun and simple to \n    code.\n    \n    I had a few versions of this lying around for ages, but wasn't \n    inspired to do anything with them until Bitless posted his really \n    cool \"Cyberspace data warehouse\" example. He put isometric height\n    maps on the faces of isometric cubes, which the isometric design \n    crowd have probably done before, but it was new to me. For anyone \n    who hasn't seen it, the link is below.\n    \n    A lot of people are familiar with the isometric height map concept, \n    but for anyone who isn't, you render cubes (or an extruded version) \n    in back to front order in a diamond pattern, or corresponding \n    patterns to cover the amount of overlap. In this case, I'm rendering \n    seven cells in a hexagon pattern.\n    \n    Just to mix things up a little and break the visual monotony, I\n    rendered columns of differing width and offset them a bit. Other \n    that that, there's not a lot to it.\n    \n    By the way, rendering in this way is fun, novel and fast, but there \n    are way better 3D methods that will achieve the same.  I've attached \n    a link to a  much simpler version of this for anyone interested in \n    the process, or code golfing an isometric heightmap, maze, etc. :)\n    \n    \n    \n    Inspired by the following:\n    \n    // Very cool, and unique.\n    Cyberspace data warehouse - bitless\n    https://www.shadertoy.com/view/NlK3Wt\n    \n    // Here's a more sophisticated example. It requires more\n    // work, but is based on a similar concept.\n    Isometric City 2.5D - knarkowicz\n    https://www.shadertoy.com/view/MljXzz\n    \n    // A less interesting, but easier to understand, verion:\n    Isometric Height Map - Shane\n    https://www.shadertoy.com/view/flcSzX\n    \n*/\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Using two hexagons to creat an extruded box of varying height.\n// I hacked in some logic to make it happen, but there might be\n// more efficient ways. Either way, it works, so it'll do.\nfloat dist(vec2 p, float h, float sz){\n\n    //return length(p);\n    \n     // The vertical height component of the hexagon. We're taking\n    // a little off to get rid of artifacts.\n    float szD = sz/.8660254 - .015;\n    \n    // Height factor. More height looks more interesting, but too much\n    // sends the blocks out of the cell range and causes artifacts.\n    const float hFact = .75;\n    \n    // Moving the blocks down a bit to maximize the range. I've hack a \n    // number in, but you could probably calculate something.\n    p.y -= -.1;\n    \n    \n    // I should be rendering three calculated polygons consisting of\n    // the top and two sides, but that requires more effort and GPU\n    // power, so I've merely merged a base hexagon and a hexagon on\n    // top that moves in the Y direction according to the height,\n    // which is good enough for this example.\n    vec2 q = abs(p);\n    float hxB = max(q.y*.8660254 + q.x*.5, q.x);\n    \n    q = abs(p - vec2(0, szD - h)*hFact);\n    float hxH = max(q.y*.8660254 + q.x*.5, q.x);\n\n    // If the block is less that the size of a hexagon, you need the\n    // maximum overlay of the two. If it's above the height of the\n    // base hexagon, fuse the two together... It took me while to \n    // figure that out, but it works.\n    float d = max(hxB, hxH);\n    if(h - szD<0.) d = min(hxB, hxH);\n    return d;\n    \n}\n\n// If you're rendering triangles, hexagons, isometric grids, etc, the number\n// 1.732 (sqrt(3)) will come up all the time.\nconst vec2 s = vec2(1.7320508, 1);\n\n// Hexagon grid.\nvec4 getGrid(vec2 p){\n\n    // Finding the local coordinates and ID of the nearest hexagon center.\n    vec4 ip = floor(vec4(p/s, p/s + .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw - .5);\n   \n}\n\nfloat height(vec2 p){\n\n    //float rnd = hash21(p);\n    //return smoothstep(.5, .95, sin(rnd*6.2831 + iTime)*.5 + .5);\n    float tm = mod(iTime/1.5, 6.2831);\n    float h = dot(sin(p*.73/1.25 - cos(p.yx*.97/1.25 - tm)*2.3), vec2(.25)) + .5;\n    p *= 2.;\n    float h2 = dot(sin(p*.73/1.25 - cos(p.yx*.97/1.25 - tm*2.)*2.3), vec2(.25)) + .5;\n    h = mix(h, h2, .333);\n    return smoothstep(0., 1., h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // Aspect correct coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 16.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = uv*sc + s*iTime/3.;\n    // Including rotation for a side wall perpective.\n    //vec2 p = rot2(-3.14159/2.)*uv*vec2(-1, 1)*sc + s.yx*iTime/4.;\n    \n    \n    // Scene field calculations.\n    \n    // Light direction. Shining down and to the left.\n    vec2 ld = normalize(s);\n    \n  \n   \n    // Rendering in a diamond grouping. Top first, the two below that, and the bottom.\n    //vec2[4] cntr = vec2[4](vec2(0, .5), vec2(-.5, 0), vec2(.5, 0), vec2(0, -.5));\n    \n    \n    // Rendering in a seven cell grouping, and taking rendering order in account:\n    // Top cell first, then the two below, the one below those, two more below\n    // that and the one on the bottom.\n    vec2[7] cntr = vec2[7](vec2(0, .5), vec2(-.5, 0), vec2(.5, 0), vec2(0, -.5),\n                           vec2(-.5, -.5), vec2(.5, -.5), vec2(0, -1));    \n    \n    float obj[7], objSh[7], side[7], side2[7], top[7], hgt[7];\n    vec4[7] p4I;\n\n    \n    // The block width. The maximum is s.y/2. (.8660254) and will produce a packed \n    // grid with no gaps. However, due to overlap, the height needs to be reduced.\n    float sz = .7;\n    vec2 szOffs = sz/s.yx;\n    \n    // Object shadow.\n    float objShad = 1e5;\n    \n    for(int i = min(0, iFrame); i<7; i++){\n   \n        // Obtain the hexagon and ID for this position. I could probably \n        // streamline the process, but this will do.\n        vec4 p4 = getGrid(p + cntr[i]*s);\n        // Random 2D offset.\n        vec2 offs = vec2(hash21(p4.zw + .1), hash21(p4.zw + .2)) - .5;\n        // Random size.\n        sz = .7*(hash21(p4.zw + .3)*.35 + .65);\n        szOffs = sz/s.yx; \n        // Position based height. \n        float h = height(p4.zw*s);\n        vec2 q = p4.xy - cntr[i]*s - offs*vec2(.2, .2); \n        \n        // The extruded column object, which is just two overlayed \n        // hexagons in disguise.\n        obj[i] = dist(q, h, sz) - sz;\n        \n        /*\n        // Failed experiment with different tops.\n        float bx = -1e5;\n        if(hash21(p4.zw + .23)<.5){\n           bx = max(abs(q.x) - sz, \n                    abs(q.y - (sz/.8660254 - .015 - h)*.75 - .15) - sz*.5);\n        }\n        */\n        \n        // Using the column object above and some simple CSG to construt \n        // the top and sides.\n        float sd1 = dist(q - vec2(-1)*szOffs, h, sz) - sz;\n        float sd2 = dist(q - vec2(1, -1)*szOffs, h, sz) - sz;\n        side[i] = max(obj[i], sd1);\n        side2[i] = max(obj[i], sd2);\n        top[i] = max(obj[i], -min(sd1, sd2));\n        \n        // Failed experiment with different tops.\n        //top[i] = max(top[i] - .05, bx);  \n        \n        // The shadow of the column object.\n        objSh[i] = dist(q - ld*.5*sz, h, sz) - sz;\n        \n        // Saving the height, and hexagon cell information.\n        hgt[i] = h;\n        p4I[i] = p4;\n        \n        // The shadow is laid down first on the background, so can be\n        // calculated here.\n        objShad = min(objShad,  objSh[i]);\n \n    }\n     \n  \n\n    \n    // Initiate the scene color to the background.\n    vec3 col = vec3(.3, .25, .2);\n    \n \n    // Rendering the object shadows onto the background. \n    col = mix(col, vec3(.05, .05, .1), (1. - smoothstep(0., sf*2., objShad))*.4);\n     \n   \n    // Loop through all seven object cells and rendering the objects.\n    for(int i = min(0, iFrame); i<7; i++){\n        \n        // Dark glow around the objects for more fake AO.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., obj[i]))*.35);\n        \n        // Unique position-based cell ID.\n        vec2 id = p4I[i].zw;\n        \n        \n        // Coloring -- Mildly inspired by the colors in Shadertoy's in-house\n        // \"Rock Tiles\" texture.\n        float rnd = hash21(id);\n        float fn = dot(sin(id*s/3.5/1.5 - cos(id.yx*s/2.3/1.5)*2.), vec2(.25)) + .5;\n        fn = smoothstep(.1, .9, fn);  \n        vec3 oCol = .6 + .4*cos(6.2831*mix(fn, rnd, .65)/3. + vec3(0, 1, 2)/1.65);  \n        oCol = mix(oCol, oCol.xzy, fn*(hash21(id + .3)*.25 + .25));\n        if(hash21(id + .27)<.33) oCol = oCol*.6;\n        if(hash21(id + .37)<.66) oCol = min(oCol*1.4, 1.);\n        /*\n        // Load in the \"Rock Tiles\" texture for a comparison.\n        vec3 tx = texture(iChannel0, id*s/sc/1.5).xyz; tx *= tx;\n        tx = smoothstep(-.05, .7, tx);\n        vec3 oCol = tx*1.5;\n        */\n       \n        // Using the height for some extra shadowing.\n        float shad = 1. - hgt[i]*.5;\n        \n       \n        // The top of the extruded box.\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i])); // Edge, or stroke.\n        //col = mix(col, oCol*ao*2., 1. - smoothstep(0., sf, top[i] + .04)); \n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i] + .1)); \n        col = mix(col, oCol*shad, 1. - smoothstep(0., sf, top[i] + .04)); // Main.\n        // Render dark holes on random faces to break up the monotony.\n        if(hash21(id + .34)<.5){\n        //if(mod(p4I[i].z + p4I[i].w, 2.)<.5){ // Checkered option.\n            col = mix(col, vec3(0), 1. - smoothstep(0., sf, top[i] + .22)); \n            col = mix(col, oCol*shad/3., 1. - smoothstep(0., sf, top[i] + .265)); \n        }         \n\n        \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, side[i])); // Edge, or stroke.\n        //col = mix(col, vec3(.25, .5, .75)*shad, 1. - smoothstep(0., sf, side[i] + .04));\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, side[i] + .1));      \n        col = mix(col, oCol*vec3(.25, .5, .75)*shad, 1. - smoothstep(0., sf, side[i] + .04)); // Main.\n        \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, side2[i])); // Edge, or strke.\n        //col = mix(col, vec3(2, .75, .5)*shad, 1. - smoothstep(0., sf, side2[i] + .04)); // Edge, or stroke.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, side2[i] + .1)); // Edge, or strke.       \n        col = mix(col, oCol*vec3(2, .75, .5)*shad, 1. - smoothstep(0., sf, side2[i] + .04)); // Main.\n    \n   \n    }\n   \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n \n    // Rough gamma correction, and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1994, 2027, 2049, 2049, 2107], [2110, 2138, 2159, 2159, 2222], [2225, 2414, 2452, 2594, 3780], [3941, 3958, 3979, 4055, 4245], [4247, 4247, 4268, 4365, 4647], [4649, 4649, 4705, 4742, 11131]]}
{"id": "stcXR7", "name": "Balanced Entropy", "author": "scry", "description": "https://youtu.be/DJ-6s62WcMo", "tags": ["3d", "raymarched", "psychedelic", "trippy"], "likes": 14, "viewed": 311, "published": "Public API", "date": "1638850552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define deg (3.14159/180.)\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//rgb2hsv2rgb from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//from https://www.shadertoy.com/view/ttBXRG\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    f = (f<0.5)?a:1.0-a;\n    \n    return i+f;\n}\n\n\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,(w)));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n#define logo 1\nvec3 slogo(vec2 uv, float ar) {\n    if (logo == 0) {\n        return vec3(0.);\n    }\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls;\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+ptime,0,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\n//iq sdbox and sdvertcalcapsule functions :)\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat abx(float a,float b) {\n    return abs(abs(a)-b)-b;\n}\n\nfloat dty(vec3 p, vec3 s) {\n    float ls = s.x;\n    float lr = s.y;\n    //p.zy *= r2d((3.14159/180.)*-sin(iTime+p.y*20));\n    //p.xy *= r2d((3.14159/180.)*iTime);\n    float d = sdBox(p+vec3(0.,0,0.),vec3(lr*1.));\n    //float d = sdVerticalCapsule(p+vec3(0.,ls/2,0.),ls,lr);\n    //float d = length(p)-0.001;\n    //d = length(p)-0.014;\n    return d;\n}\n\nvec4 fr(vec3 p) {\n    //p.z = 0.;\n    //float pfd = 0.95;\n    //p = (fract((p*pfd))-0.5)/pfd;\n    //p.xz *= r2d((3.14159/180.)*-90);\n    float st = iTime*0.2;\n    float sm = sin(st*10.)*0.5+0.5;\n    //sm = 0.;\n    //sm += sin(st*2.)*0.25;\n    //sm *= 1.;\n    float lp = length(p);\n    //sm += sin(st*1)*0.125;\n    //float lr = -0.001-sin(lp*20.+iTime)*0.0015;\n    float lr = 0.13;\n    float ls = 0.5;\n    //p *= 2.;\n    //ls += spectrum1.y*16.;\n    lr += 0.001;\n    float d = 10000.;\n    float u = 1.;\n\n    float lsm = 0.495;\n    vec3 dp = p;\n\n    float rt = iTime*2.;\n\n    float pd = 0.185;\n    //float pm = 1.-(sin(iTime)*0.5+0.5);\n    float pm = 1.;\n    //p *=  2.;\n    float tm = iTime;\n    tm *= 0.1;\n    float ia = -1.;\n    float pdm = sin(iTime*1.1+lp*dp.z*29.)*0.5+0.5;\n    pdm *= 0.2;\n    pdm += 0.3;\n    pdm = 0.5;\n    //p += sin(p*20.+iTime)/24.;\n    float lss = 2.8;\n    st += sin(st*2.)*0.25+sin(st*3.)*0.25;\n    int sps = 7;\n    vec3 rp = p;\n    //rp.xy *= r2d(deg*90*floor(iTime*8.));\n    //rp.xz *= r2d(deg*90*floor(iTime*20.3));\n    //sps += int(rp.x*15.);\n    //sps += (sin(iTime)*0.5+0.5)*10.; \n    sps = clamp(sps,1,18);\n    //lr = deg*15.;\n   lr = 0.2;\n   float ad = (sin(iTime*0.4+lp*29.)*0.5+0.5);\n    \n    for (int i=0;i<sps;i++) {\n    d = min(d,dty(p,vec3(ls,lr,0.)));\n    //d -= sin(d*80.)*0.005;\n    //p += sin(d*200.)*0.001;\n    \n    //d = min(d,dty(p.yxz,vec3(ls,lr,0.)));\n    //d = min(d,dty(p.xzy,vec3(ls,lr,0.)));\n    //p.x += 0.1;\n    ia += 1.;\n    //lr *= 2.9;\n    lr *= .5;\n    //lr += 0.000002;\n    //lr = sin(lr+iTime*0.1)*0.1+0.1;\n    //lr += 0.01;\n    //lr *= ia+0.0003;\n    pd *= u;\n    \n    p.yz *= r2d((3.14159/180.)*-45.);\n    p.zy = abs(p.zy);\n    //p.x = abs(p.x)-0.09;\n    \n    p.yz *= r2d((3.14159/180.)*+45.);\n    \n    p.xy *= r2d((3.14159/180.)*-45.);\n\n    p.xy = abs(p.xy)-pd;\n\n    pd *= pdm;\n    //pd *= sin(iTime*0.1+dp.z*2.)*0.5+0.5;\n\n    p.xy *= r2d((3.14159/180.)*+45.);\n    \n    //p = abs(p)-0.02;\n    \n    ls *= lsm;\n    ls += 0.002;\n    \n    }\n    //d += sin(p.z*200.)*0.001;\n    //p += iTime*0.1;\n    //dp.xy *= r2d((iTime*0.1));\n    //dp.xz *= r2d((iTime*0.3));\n    //p = fract(p*0.5)/0.5;\n    d = min(d,dty(p,vec3(ls,lr,0.)));\n    //p *= sin(p*10.)*0.5;\n    d += (sin(p.y*90.+iTime+dp.x*5.)*0.5+0.5)*0.1;\n    d += (sin(p.y*30.+iTime*0.2+dp.x*2.)*0.5+0.5)*0.1;\n    //d -= (sin(dp.y*7.+iTime*0.2)*0.5+0.5)*0.05;\n    d *= 0.5;\n    //d = min(d,dty(p.yxz,vec3(ls,lr,0.)));\n    //d = min(d,dty(p.xzy,vec3(ls,lr,0.)));\n\n    return vec4(p,d*0.5);\n}\n\n\nvec4 map(vec3 p) {\n    //p += 1.;\n    //p.xy *= r2d(1.);\n    //p.xz *= r2d(1.);\n    \n   \n    //p.xy += 2.;\n    //\n    vec3 c = p;\n    p.z -= 1.;\n    \n    //vec3 c = p;\n    float cd = 12.*(sin(iTime*0.002+5.)*0.5+0.5);\n    //c.z = (fract(c.z*cd))/cd;\n    float rt = iTime*0.1;\n    //p.xy *= r2d((3.14159/180.)*-45*iTime*9.);\n    //p = abs(p);\n    //p = abs(p+0.5);\n    p.yz *= r2d(deg*35.264);\n    p.xz *= r2d(-deg*90.);\n    //p.z += 0.5;\n    //p = abs(p)-0.5;\n    float pfd = 0.9;\n    //p = (fract((p-0.25)*pfd)-0.5)/pfd;\n    //p.xz *= r2d(.75);\n    //p += 0.89;\n    p.xy *= r2d(sin(rt*0.5)*0.5);\n    p.yz *= r2d(rt);\n\n    \n    float d = length(p)-3.;\n    //float env = d;\n    //float env = mix(d,sdBox(p,vec3(1.966)),0.001+sin(p.x*13.)*0.001);\n    float env = mix(d,sdBox(p,vec3(1.966)),0.002);\n    //p.xz *= r2d(-rt);\n    //p.z += iTime;\n    \n    //float pz = p.z;\n    vec4 frd = fr(p);\n    //d = sdf(p);\n    \n    //d = abs(d)-0.0008;\n    \n    \n    d = frd.w;\n    d = min(d,-env);\n    //float dl = (sin(iTime)*0.5+0.5)*0.1;\n    //d = abs(d+0.01)-0.01;\n    float dl = 0.001;\n    d = abs(d+dl)-dl;\n    //d = mix(d,(length(p)-0.28)*0.7,0.9);\n   // d = min(d,sdBox(p,vec3(0.3)));\n    c.z *= 2.;\n    d = max(d, -(length(c)-0.5));\n    //d = max(d, -(length(c)-01.2));\n    \n    return vec4(p,d);\n}\n\nvec3 calcNorm(vec3 p) {\n    //float eps = 0.01*(sin(p.z*0.1)*0.5+0.5);\n    float eps = 0.0008;\n    vec2 h = vec2(eps,0.);\n    return normalize(vec3(map(p-h.xyy).w-map(p+h.xyy).w,\n                          map(p-h.yxy).w-map(p+h.yxy).w,\n                          map(p-h.yyx).w-map(p+h.yyx).w));\n}\n\nfloat edges(vec3 p) {\n    float eps = 0.001;\n    //return calcNorm(p)\n    vec3 n1 = calcNorm(p*(1.-eps));\n    vec3 n2 = calcNorm(p*(1.));\n    return clamp(abs((n1.x+n1.y+n1.z)-(n2.x+n2.y+n2.z)),0.,1.);\n    //return (map(p+(eps)).w-map(p-(eps)).w)*18.;\n}\n\n\n#define render 0\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    int steps = 130;\n    //steps = int(steps*(sin(iTime)*0.5+0.5));\n    if (render == 1) {\n        steps = 150;\n    }\n    float d = 130.;\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        //ro += calcNormL(p)*0.02;\n        //ro += lens(p).xyz*0.2;\n        float dS = map(p).w;\n        dO += dS*(d/float(steps));\n        //dO += dS*(100./float(steps))*(dO+2.)*0.15;\n        ii += 0.5*d/float(steps);\n        if (dO > 1000. || dS < 0.00009) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\nvec3 color(vec3 p, vec2 d) {\n    return vec3(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = fragCoord.xy / iResolution.xy;\n    \n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    //uv.x *= ar;\n    \n    uv -= 0.5;\n    uv.x *= ar;\n    float c= length(uv);\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,0);\n    //ro.z = -2.;\n    vec3 rd = normalize(vec3(uv,1.));\n    \n        vec3 bak = texture(iChannel0, tv).rgb;\n    float rn = noise(vec2(noise(fract(rd.xy*220.+iTime*0.01)*90.)*100.));\n    //if (rn > 0.2) {\n    //if (1 == 1) {\n    if (rn < clamp(c*.7,0.,1.0)+0.3 && render != 0) {\n        col = bak;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec4 mp = map(p);\n    vec3 n = calcNorm(p);\n    float lp = length(p);\n    \n    vec3 na = n;\n    //vec3\n\n    \n    vec2 dd = d;\n    float ga = 1.;\n    float time = iTime;\n    vec4 m = mp;\n    vec4 mr = mp;\n    vec3 b = vec3(0.);\n    float e = edges(p);\n    //e = clamp(e,0.,0.1)*8;\n    //col += d.x*ga*0.1;\n    //col += n*ga*0.1+d.y*ga*0.05;\n    //col += d.x*.1;\n    \n    for(int i=0;i<2;i++) {\n        if (d.x > 1000.) {\n            //col *= 0.;\n            ga = 0.;\n        }\n        //col += d.y*0.02*ga;\n        col += hsv2rgb(vec3(d.x+iTime*0.01,d.y*0.015,d.y*0.02*ga));\n        //col += (abs(e)*30.-0.3)*ga;\n        //col += n+d.y*0.1-2.;\n        //col += (n+d.y*0.1-2.+d.x*0.1)*ga;\n        //col += abs((n*1.8+d.y*0.05-2.+d.x*0.1))*ga;\n        //col += n*d.y*ga*0.01;\n        //col += n*ga;\n        //col += n*ga*d.x;\n        //col += vec3(d.x*0.1)*ga;\n        //col += d.x*ga*0.1;\n        //col += n*ga*0.1+d.y*ga*0.05;\n        ga *= .3;\n        //ga -= 0.2;\n        //ga *= 0.2;\n        ro = p-n*0.002;\n        rd = reflect(rd,n);\n        d = RM(ro,rd);\n        //b += d.x*0.02*ga;\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        e = edges(p);\n        mr = map(p);\n        //col += d.x*.1;\n        \n        //col += n*ga*0.1+d.y*ga*0.25;\n    }\n    //col += d.y*ga*0.01;\n    //col += e;\n    col += hsv2rgb(vec3(d.x,d.y*0.015,d.y*0.02*ga));\n    //col *= 0.6;\n    col = rgb2hsv(col);\n    col.x += 0.7;\n    //col.x += iTime;\n    col.y *= 1.2;\n    col.z -= dd.x*0.15;\n    col = hsv2rgb(col);\n    vec2 ttv = tv;\n    ttv -= 0.5;\n    //ttv *= 0.99;\n    ttv += 0.5;\n\n    col += slogo(ttv,ar)*.6;\n    vec2 ux = uv;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 46, 46, 95], [97, 251, 273, 273, 604], [606, 665, 687, 687, 856], [857, 870, 897, 897, 1014], [1016, 1103, 1129, 1129, 1646], [1648, 1693, 1736, 1736, 1886], [1889, 1889, 1916, 1916, 2275], [2291, 2291, 2322, 2322, 3238], [3240, 3285, 3316, 3316, 3403], [3405, 3405, 3458, 3458, 3517], [3519, 3519, 3547, 3547, 3577], [3579, 3579, 3606, 3606, 3928], [3930, 3930, 3947, 4062, 6431], [6434, 6434, 6452, 6547, 7726], [7728, 7728, 7751, 7798, 8024], [8026, 8026, 8047, 8047, 8279], [8299, 8299, 8326, 8326, 8883], [8885, 8885, 8913, 8913, 8935], [8937, 8937, 8992, 8992, 11337]]}
{"id": "stcXRS", "name": "warpLines_sin()", "author": "newJasper", "description": "warpLines, wave", "tags": ["2d"], "likes": 0, "viewed": 18, "published": "Public", "date": "1639310569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    \n    \n    float color = 0.0;\n\n    color += sin(coord.x * 50.0 + cos(iTime + coord.y * 10.0 + sin(coord.x * 50.0 + iTime * 2.0))) * 2.0;\n    color += cos(coord.x * 20.0 + sin(iTime + coord.y * 10.0 + cos(coord.x * 50.0 + iTime * 2.0))) * 2.0;\n    color += sin(coord.x * 30.0 + cos(iTime + coord.y * 10.0 + sin(coord.x * 50.0 + iTime * 2.0))) * 2.0;\n    color += cos(coord.x * 10.0 + sin(iTime + coord.y * 10.0 + cos(coord.x * 50.0 + iTime * 2.0))) * 2.0;\n\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(color + coord.y, color + coord.x, color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 748]]}
{"id": "stcXzs", "name": "retro cityscape by graphtoy", "author": "yasuo", "description": "reference:\nhttps://www.youtube.com/watch?v=lVYksrvNe28\n", "tags": ["graphtoy"], "likes": 19, "viewed": 158, "published": "Public API", "date": "1639585204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p.x)-s.x,abs(p.y)-s.y)\n\nfloat hash(vec2 p){\n    vec2 rand = fract(sin(p*123.456)*567.89);\n    rand += dot(rand,rand*34.56);\n    return fract(rand.x*rand.y);\n}\n\nfloat starLayer(vec2 p){\n    p.x += iTime*0.1;\n    p*=12.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = hash(id);\n    \n    vec2 size = vec2(0.0);\n    float x = 0.0;\n    if(n<0.1){\n        size = vec2(0.025,0.2);\n        uv.x-=0.2;\n        uv.y-=0.2;\n    } else if(n>=0.1 && n<0.4){\n        size = vec2(0.02,0.15);\n        uv.x+=0.3;\n        uv.y+=0.2;\n    }\n    return min(B(uv,size),B(uv,vec2(size.y,size.x)));\n}\n\nfloat buildingWindowBase(vec2 p, float scale){\n    p*=scale;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    vec2 size = vec2(0.25);\n    return B(uv,size);\n}\n\nfloat buildingWindow(vec2 p, float scale){\n    p*=scale;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    float n = hash(id);\n    \n    vec2 size = vec2(0.0);\n    if(n<0.5){\n        size = vec2(0.25);\n    }\n    return B(uv,size);\n}\n\nvec3 buildingMaterial(vec2 p, vec3 col, float scale){\n    float d = buildingWindowBase(p,scale);\n    col = mix(col,vec3(0.3),S(d,0.0));\n    d = buildingWindow(p,scale);\n    col = mix(col,vec3(0.8),S(d,0.0));\n    return col;\n}\n\nfloat birds(vec2 p){\n    p.x+=iTime*0.2;\n    p.x = mod(p.x,0.8)-0.4;\n    p.y-=0.45;\n    float d = B(p,vec2(0.04,0.006));\n    p.x+=0.01;\n    p.y-=0.01+sin(iTime*5.0)*0.006;\n    float d2 = B(p,vec2(0.02,0.006));\n    return min(d,d2);\n}\n\nfloat cloud(vec2 p){\n    float d = B(p,vec2(0.06,0.003));\n    p.y+=0.011;\n    d = min(B(p,vec2(0.1,0.003)),d);\n    p.y+=0.011;\n    d = min(B(p,vec2(0.28,0.003)),d);\n    p.y+=0.011;\n    p.x = abs(p.x);\n    p.x-=0.13;\n    d = min(B(p,vec2(0.09,0.003)),d);\n    p.y+=0.011;\n    d = min(B(p,vec2(0.05,0.003)),d);\n    return d;\n}\n\nvec3 car(vec2 p, vec3 col){\n    p*=7.0;\n    vec2 prevP = p;\n    \n    p = prevP;\n    p.y+=0.13;\n    p.y*=7.0;\n    float d = length(p)-0.4;\n    col = mix(col,vec3(0.3),S(d,-0.2));    \n    \n    p = prevP;\n    d = B(p,vec2(0.3,0.08));\n    float a = radians(45.);\n    p = abs(p);\n    p-=vec2(0.3,0.05);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x = abs(p.x)-0.15;\n    p.y+=0.05;\n    d = max(-(length(p)-0.09),d);    \n    \n    col = mix(col,vec3(0.7,0.6,0.1),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.16;\n    d = B(p,vec2(0.19,0.08));\n    a = radians(20.);\n    p.x = abs(p.x);\n    p.x-=0.14;\n    p.y-=0.05;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    col = mix(col,vec3(0.7,0.6,0.1),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.16;\n    d = B(p,vec2(0.15,0.06));\n    a = radians(20.);\n    p.x = abs(p.x);\n    p.x-=0.11;\n    p.y-=0.06;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    d = max(-(abs(p.x)-0.012),d);\n    col = mix(col,vec3(0.6,0.8,0.9),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.15;\n    p.y+=0.05;\n    d = length(p)-0.08;\n    col = mix(col,vec3(0.),S(d,0.0));\n    d = length(p)-0.06;\n    col = mix(col,vec3(0.7),S(d,0.0));\n    \n    return col;\n}\n\nvec3 missile(vec2 p, vec3 col, vec3 col2){\n    vec2 prevP = p;\n    p = prevP;\n    p -= vec2(0.06,-0.02);\n    float d = B(p,vec2(0.07,0.015));\n    d = min(length(p-vec2(-0.07,0.0))-0.015,d);\n    \n    p.x -= 0.03;\n    p.y = abs(p.y);\n    p.y-=0.02;\n    float d2 = B(p,vec2(0.03,0.02));\n    float a = radians(-40.0);\n    d2 = max(-dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d2,d);\n    col = mix(col,col2,S(d,0.0));\n    return col;\n}\n\nvec3 chopper(vec2 p, vec3 col){\n    p*=Rot(radians(-10.0));\n    p*=1.7;\n    p.y+=sin(iTime*3.0)*0.02;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.22,0.1));\n    float a = radians(-70.);\n    p.y-=0.09;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(70.);\n    p.y+=0.13;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(45.);\n    p.x-=0.26;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(-50.);\n    p.x-=0.3;\n    p.y-=0.06;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    p.x-=0.35;\n    p.y-=0.015;\n    d = min(B(p,vec2(0.15,0.025)),d);\n    \n    p = prevP;\n    p.y-=0.015;\n    p.y = abs(p.y);\n    p.x-=0.49;\n    p.y-=0.06;\n    \n    p*=Rot(radians(10.0));\n    a = radians(-10.);\n    \n    d = min(max(-dot(p-vec2(-0.01,0.0),vec2(cos(a),sin(a))),B(p,vec2(0.02,0.05))),d);\n    \n    col = mix(col,vec3(0.3,0.5,0.3),S(d,0.0));\n    \n    p = prevP;\n    p.x+=0.08;\n    p.y-=0.05;\n    d = B(p,vec2(0.1,0.05));\n    a = radians(-70.);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    a = radians(-70.);\n    d = max(dot(p-vec2(0.00,-0.05),vec2(cos(a),sin(a))),d);\n    \n    col = mix(col,vec3(0.6,0.8,0.9),S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x)-0.06;\n    p.y+=0.13;\n    d = B(p,vec2(0.006,0.03));\n    p.y+=0.03;\n    d = min(B(p,vec2(0.07,0.006)),d);\n    col = mix(col,vec3(0.3,0.5,0.5),S(d,0.0));\n    \n    p = prevP;\n    p.x-=0.1;\n    p.y-=0.14;\n    d = B(p,vec2(0.01,0.05));\n    p.y-=0.02;\n    d = min(B(p,vec2(0.3+sin(iTime*10.0)*0.25,0.01)),d);\n    \n    col = mix(col,vec3(0.3,0.5,0.5),S(d,0.0));\n    \n    p = prevP;\n    col = missile(p-vec2(0.01,-0.01),col,vec3(0.2,0.4,0.4)*0.3);\n    col = missile(p,col,vec3(0.2,0.4,0.4));\n    \n    \n    return col;\n}\n\nvec3 streetLight(vec2 p, vec3 col){\n    p*=2.0;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.005,0.1));\n    col = mix(col,vec3(0.7,0.3,0.2),S(d,0.0));\n    \n    p*=Rot(radians(45.));\n    p.x+=0.068;\n    p.y-=0.115;\n    d = B(p,vec2(0.005,0.05));\n    col = mix(col,vec3(0.7,0.3,0.2),S(d,0.0));\n    \n    p = prevP;\n    \n    p*=Rot(radians(45.));\n    p.x+=0.058;\n    p.y-=0.115;\n    d = B(p,vec2(0.005,0.025));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    vec3 col = mix(vec3(0.5,0.3,0.7),vec3(0.3,0.3,0.5),uv.y+0.3);\n    \n    float t = iTime;\n    \n    // The following code should be `sqrt(8^2-x^2)`, but it does not work for me, so I used the normal circle distance function.\n    float d = length(uv-vec2(0.0,-0.15))-0.6;\n    uv.y-=iTime*0.05;\n    uv.y = mod(uv.y,0.05)-0.025;\n    d = max(-B(uv,vec2(10.0,0.01)),d);\n    col = mix(col,mix(vec3(0.7,0.5,0.6),vec3(0.7,0.1,0.5),prevUV.y+0.2),S(d,0.0));    \n    \n    // star\n    uv = prevUV;\n    d = starLayer(uv);\n    col = mix(col,vec3(0.6,0.4,0.5),S(max(-uv.y+0.25,d),0.0));  \n    \n    // clouds\n    uv = prevUV;\n    uv.x-=iTime*0.05;\n    uv.x = mod(uv.x,1.6)-0.8;\n    uv.y-=0.45;\n    d = cloud(uv);\n    col = mix(col,vec3(0.6,0.2,0.3),S(d,0.0)); \n    \n    // birds\n    uv = prevUV;\n    d = birds(uv);\n    col = mix(col,vec3(0.0),S(d,0.0)); \n    \n    // buildings1\n    uv*=6.0;\n    d = -0.7+1.5*sin(floor((uv.x*2.5)+t)*4321.);\n    uv.y += d;\n    col = mix(col,vec3(0.15),S(uv.y,0.0));\n    \n    // buildings2\n    uv = prevUV;\n    uv*=6.0;\n    d = -0.7+1.*sin(floor((uv.x*1.5)+(t*1.5))*2121.);\n    uv.y += d;\n    uv.x+=iTime+0.22;\n    col = mix(col,buildingMaterial(uv,vec3(0.2),8.5),S(uv.y,0.0));\n    \n    // buildings3\n    uv = prevUV;\n    uv.x+=iTime*0.3;\n    uv*=1.2;\n    uv.y+=0.1;\n    uv.x = mod(uv.x,0.6)-0.3;\n    d = B(uv,vec2(0.1,0.16));\n    float a = radians(30.0);\n    uv.x = abs(uv.x);\n    uv.y-=0.3;\n    d = max(dot(uv,vec2(cos(a),sin(a))),d);\n    col = mix(col,buildingMaterial(uv,vec3(0.05),60.),S(d,0.0));\n    uv.x = abs(uv.x)-0.05;\n    uv.y+=0.13;\n    d = B(uv,vec2(0.01,0.01));\n    col = mix(col,vec3(0.5,0.0,0.0),S(d,0.0));\n\n    uv = prevUV;\n    uv.x+=iTime*0.3;\n    uv*=1.2;\n    uv.y+=0.1;\n    uv.x-=0.3;\n    uv.x = mod(uv.x,0.6)-0.3;\n    d = B(uv,vec2(0.1,0.22));\n    uv.x = abs(uv.x);\n    uv.y-=0.36;\n    d = max(dot(uv,vec2(cos(a),sin(a))),d);\n    col = mix(col,buildingMaterial(uv,vec3(0.05),80.),S(d,0.0));\n    \n    \n    // road\n    uv = prevUV;\n    col = mix(col,vec3(0.3),S(uv.y+0.2,0.0));\n    col = mix(col,vec3(0.4),S(uv.y+0.25,0.0));\n    col = mix(col,vec3(0.5),S(uv.y+0.45,0.0));\n    \n    uv.x+=iTime*0.3;\n    uv.x = mod(uv.x,0.4)-0.2;\n    uv.y+=0.34;\n    d = B(uv,vec2(0.1,0.002));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    // street rights\n    uv = prevUV;\n    uv.x+=iTime*0.28;\n    uv.x = mod(uv.x,0.4)-0.2;\n    uv.y+=0.18;\n    col = streetLight(uv,col);\n    \n    // cars\n    uv = prevUV;\n    uv.x+=iTime*0.4;\n    uv.x = mod(uv.x,0.15)-0.075;\n    uv.y+=0.28;\n    col = car(uv,col);\n    \n    uv = prevUV;\n    uv.x-=iTime*0.2-0.075;\n    uv.x = mod(uv.x,0.15)-0.075;\n    uv.y+=0.4;\n    col = car(uv,col);\n    \n    // street rights\n    uv = prevUV;\n    uv.x+=iTime*0.28;\n    uv.x = mod(uv.x,0.4)-0.2;\n    uv.y+=0.43;\n    col = streetLight(uv,col);    \n    \n    // chopper\n    uv = prevUV;\n    uv.x+=iTime*0.6-0.6;\n    uv.x = mod(uv.x,2.6)-1.3;\n    uv.y-=0.2;\n    col = chopper(uv,col);\n    \n    // test codes\n    uv = prevUV;\n    //col = streetLight(uv,col);\n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4(col, 1.0)+(hash(uv*iTime*0.1))*0.13;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 224, 224, 339], [341, 341, 365, 365, 776], [778, 778, 824, 824, 943], [945, 945, 987, 987, 1182], [1184, 1184, 1237, 1237, 1409], [1411, 1411, 1431, 1431, 1644], [1646, 1646, 1666, 1666, 1969], [1971, 1971, 1998, 1998, 3172], [3174, 3174, 3216, 3216, 3604], [3606, 3606, 3637, 3637, 5361], [5363, 5363, 5398, 5398, 5831], [5833, 5833, 5890, 5890, 9090]]}
{"id": "stdXz8", "name": "Sphere Fractal", "author": "do", "description": "fractal", "tags": ["fractal"], "likes": 3, "viewed": 54, "published": "Public", "date": "1638735521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//sphere fractal\n//2021\n//do\n\nmat2 rot2(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nmat3 camOrthographic(vec3 ro,vec3 ta,float r) {\n     \n     vec3 w = normalize(ta - ro); \n     vec3 p = vec3(sin(r),cos(r),0.);           \n     vec3 u = normalize(cross(w,p)); \n     vec3 v = normalize(cross(u,w));\n\n     return mat3(u,v,w); \n} \n\nfloat smou(float d1,float d2,float k) {\n\n    float h = clamp(0.5 + 0.5 * (d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 p,float r) { \n    return length(p)-r;\n}\n\nfloat scene(vec3 p) {\n\n    float d = 0.;     \n    float r = 8.;  \n    \n    d = sphere(p,r);\n\n    for(int i = 0; i < 3; i++) {\n\n        p.xz *= rot2(radians(180.)/2. * iTime * 0.01);\n        p.zy *= rot2(radians(180.));\n        p.xy *= rot2(radians(180.)*2. - 1.);\n\n        p = abs(p) - r * 0.5;\n        r /= 3.;\n  \n        d = smou(d,sphere(p,r),0.1);\n\n    }\n\n    return d;\n\n}\n\nfloat calcAO(vec3 p,vec3 n) {\n\n    float o = 0.;\n    float s = 1.;\n\n    for(int i = 0; i < 15; i++) {\n \n        float h = .01 + .125 * float(i) / 4.; \n        float d = scene(p + h * n);  \n        o += (h-d) * s;\n        s *= .9;\n        if(o > .33) break;\n    \n     }\n     return clamp(1. - 3. * o ,0.0,1.0) * (.5+.5*n.y);   \n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * 0.0001;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)) +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)) +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)) + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x))\n\n    ));\n    \n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\nvec3 color = vec3(0.);\nvec3 ro = vec3(10.,5.,25.);\nvec3 ta = vec3(0.0);\n\nvec3 n;\nvec3 l = normalize(vec3(10.));\nvec3 linear = vec3(0.); \n\nvec2 uv = (2. * (fragCoord.xy) -\niResolution.xy) / iResolution.y; \n\nmat3 cm = camOrthographic(ro,ta,0.);\n\nvec3 rd = cm * normalize(vec3(uv.xy,2.));\n\nfloat dist = 0.;\n\n    for(int i = 0; i < 250; i++) {\n\n         vec3 p = ro + rd * dist;\n         float d = scene(p);\n\n         if(d < 0.001) {\n\n             n = calcNormal(p);\n \n             float amb = clamp(0.5+0.5*n.y,0.,1.);\n\n             float dif = clamp(dot(\n             n,l),0.,1.);\n\n             linear += dif * vec3(float(i)/100.,0.,0.); \n             linear += amb * vec3(0.5);\n             float ao = calcAO(p*1.1,n);\n             color += linear*ao;\n\n             break;\n           \n         }\n         dist += d;\n         color = vec3(1.,\n         smoothstep(-1.,1.,rd.x),smoothstep(-1.,1.,rd.y));\n    }\n\nfragColor = vec4(pow(color,vec3(0.4545)),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 50, 50, 129], [131, 131, 178, 178, 372], [375, 375, 414, 414, 514], [516, 516, 546, 546, 573], [575, 575, 596, 596, 951], [953, 953, 982, 982, 1281], [1283, 1283, 1308, 1308, 1610], [1612, 1612, 1666, 1666, 2624]]}
{"id": "stGGDt", "name": "Voronoi Ubung #4", "author": "Yusef28", "description": "more in comments", "tags": ["voronoi"], "likes": 12, "viewed": 101, "published": "Public API", "date": "1638506162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n2. tomkh's drawing helped it click: \n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    //dot(AB,P-P3) = 0\n    //dot(AB,P-AB*t)\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n//we are in \"not world/object space\" \n//because we use length on vectors from vec2(0,0.)\n//to get distances\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n    \n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = rnd2(stFL+id).y;\n            A = coords;\n            }\n        }\n    }\n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.15 );\n            }\n        }\n    }\n\n    return vec4(mind,B);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 light = vec3(1.,0.,2.);\n    vec3 ldir = normalize(vec3(0.)-light);\n    \n    vec3 light2 = vec3(2.,1.,1.);\n    vec3 ldir2 = normalize(vec3(0.)-light2);\n    \n    // Time varying pixel color\n    //vec3(0.1,1.4,2.)\n    uv*=6.;\n    vec4 voronoXY = voronoi(uv);\n    //float edges = smoothstep(0.00,0.01,abs(voronoXY.x-voronoXY.z));\n    vec3 col = 0.5+0.5*sin(vec3(1., 2., 3.)/1.2+ voronoXY.y*pi*200.);\n    col.zy *= rot(.1);\n    \n    col = mix(col, vec3(voronoXY.y,0., voronoXY.y)/4., smoothstep(0.08,0.05,voronoXY.x));\n  //  col += sin(voronoXY.x*40.);\n    //col += vec3(fract(voronoXY.x*8.));\n    //col = mix(col, vec3(0.), smoothstep(0.14,0.13,voronoXY.z));\n   //col = mix(col, vec3(1.), smoothstep(0.05,0.,voronoXY.z));\n    col -= sin(voronoXY.z*90.)/10.;\n    //col = mix(col, vec3(0.), 1.-smoothstep(0.5,0.4,voronoXY.x*1.));\n    col = mix(col, vec3(.9,0.6,0.0), smoothstep(0.3,.5,voronoXY.z)*0.3 );\n    // Output to screen\n    \n    vec3 n = vec3(\n                  voronoi(uv-vec2(eps,0.)).x-voronoi(uv+vec2(eps,0.)).x,\n                  voronoi(uv-vec2(eps,0.).yx).x-voronoi(uv+vec2(eps,0.).yx).x,\n                  voronoi(uv-vec2(eps,0.)).z-voronoi(uv+vec2(eps,0.)).z\n                  );\n         n = normalize(n);//smoothstep(vec3(-1.),vec3(1.),;\n         \n    float diff = max(dot(ldir,n),0.);\n    \n    float spec = pow( max(\n                 dot( reflect(-ldir,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff*0.6+vec3(0.9,0.5,0.1)*spec;\n    \n    \n    \n    float diff2 = max(dot(ldir,n),0.);\n    \n    float spec2 = pow( max(\n                 dot( reflect(-ldir2,n),vec3(0.,0.,1.)),0.),5.);\n    col += diff2*0.8+vec3(0.1,0.5,0.9)*spec2;\n    \n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.)/2., smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    \n    col /= 1.5;\n    col= pow(col, vec3(1.4));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 529, 548, 548, 682], [684, 684, 702, 702, 765], [767, 767, 807, 807, 883], [885, 885, 915, 915, 964], [966, 966, 995, 995, 1058], [1060, 1060, 1104, 1104, 1294], [1296, 1404, 1426, 1426, 2627], [2629, 2629, 2686, 2736, 4753]]}
{"id": "stGGWK", "name": "Folding Space", "author": "creikey", "description": "Based off of https://www.shadertoy.com/view/ftG3D1", "tags": ["space", "folding"], "likes": 5, "viewed": 59, "published": "Public", "date": "1638316375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Based on:\n// KIFS City by leon denise 2021/11/22\n// example of how to go to fractal city\n// which is a cubic kaleidoscopic shape carving volume\n// using code from Inigo Quilez, LJ, Fabrice Neyret and many others\n// licensed under hippie love conspiracy\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nfloat map (vec3 p)\n{\n  float scene = 100.;\n  float t = iTime/5.0;\n  float falloff = 5.0;\n  for (float index = 0.; index < 7.; ++index)\n  {\n    p.xz *= rot(t/falloff);\n    p.yz *= rot(t/falloff);\n    p = abs(p)-0.3*falloff;\n    p *= 0.98;\n    scene = min(scene, max(p.x, max(p.y, p.z)));\n    falloff /= 1.85;\n  }\n  return -scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.*(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 pos = vec3(0);\n  vec3 ray = normalize(vec3(uv * rot(iTime/5.0), 1));\n  float shade = 0.;\n  const float count = 20.;\n  for (float index = count; index > 0.; index -= 1.0)\n  {\n    float dist = map(pos);\n    if (dist < 0.001)\n    {\n      shade = index/count + 0.1;\n      break;\n    }\n    pos += ray * dist;\n  }\n  //fragColor = vec4(1.0 - pow(shade, 0.9));\n  fragColor = vec4(shade*0.7, shade*0.7, shade, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGGWK.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[2, 259, 279, 279, 324], [326, 326, 346, 346, 656], [658, 658, 715, 715, 1195]]}
{"id": "stKGDc", "name": "tiny voxels", "author": "flockaroo", "description": "...originally done in twigl.app (266 chars there)\n[url]https://twitter.com/flockaroo/status/1466494447525539843[/url]", "tags": ["voxel", "golfing", "tinycode"], "likes": 21, "viewed": 305, "published": "Public API", "date": "1638480142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// tiny voxels\n//\n// ...not quite as minimal as on twigl (266 chars)\n// https://twitter.com/flockaroo/status/1466494447525539843\n//\n\n/*\nvoid mainImage( out vec4 o, in vec2 F )\n{\n#define C(p) max(c=abs(p),max(c.y,c.z)).x\n#define L(N) for(int i=0;i<N;i++){\n// had to trick a bit on the rotation - only diagonal rotation (full blown up rotate/axis func is quite big)\n   //vec3 e=cos(iTime-vec3(0,1.6,-1.6));e.yz/=sqrt(3.); mat3 R=mat3(e,e.zxy,e.yzx)+(1.-e.x)/3.;\n   float e=cos(iTime),a=sin(iTime)*.58; mat3 R=mat3(e,a,-a,-a,e,a,a,-a,e)+(1.-e)/3.;\n   vec3 p=R*vec3(0,0,40),v=R*vec3(F/iResolution.y-.5,1),m,c,d;\n   L(99)\n       d.x=9.;\n       L(8)\n           m=floor(p)+vec3(i&1,i/2&1,i/4&1);\n           d=min(d,C(R*m)>9.?.5:C(p-m)-.4);\n       }\n       p-=d.x*v;\n   }\n   o=abs(p*R).zzzz*.07;\n}\n*/\n\n// fabrice's breakdown - minus another 6 chars (vec3 d now float (prev e))\n#define C(p) max(c = abs(p), max(c.y, c.z)).x//\n#define L for(int i=0; i++ < \n\nvoid mainImage(out vec4 o, vec2 F) \n{\n    float d = cos(iTime), a = sin(iTime) * .58;\n    mat3 R = mat3(d, a, -a, -a, d, a, a, -a, d) + (1. - d) / 3.;\n    vec3 p = R * vec3(0, 0, 40), \n    v = R * vec3(F / iResolution.y - .5, 1), m, c;\n    L 99; p -= d * v ) {\n        d = 9.;\n        L 8; d = min(d, C(R * m) > 9. ? .5 : C(p - m) - .4) ) \n          m = floor(p) + vec3(i&1,i/2&1,i/4&1);\n    }\n\n    //o += abs(p * R).z * .07 - o;\n    o = abs(p * R).zzzz * .07;\n    // bit longer, but i also like this one - gives some central gradent on the depth field\n    //o += abs(dot(p,v)) * .07 - o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKGDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[933, 1087, 1124, 1124, 1677]]}
{"id": "sttSDH", "name": "fractal animation 001", "author": "yasuo", "description": "fractal animation", "tags": ["fractal"], "likes": 13, "viewed": 220, "published": "Public API", "date": "1639066129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .0001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\n#define ZERO (min(iFrame,0))\n\nvec3 directions[5] = vec3[](vec3(0,-1.,0),vec3(1.,0,0),vec3(-1.,0,0),vec3(0,0,1.),vec3(0,0,-1.));\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat childBlock(vec3 p){\n    float childScale = 0.1;\n    float d = B3D(p,vec3(childScale));\n    childScale*=0.5;\n    int index = 0;\n    for(float i = 0.; i<5.0; i++){\n        vec3 dir = (directions[index]*0.1);\n        \n        vec3 pos = p+(dir+(dir*0.5));\n       \n        float d2 = B3D(pos,vec3(childScale));\n        d = min(d,d2);\n        index++;\n    }\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p*=3.0;\n    float d = childBlock(p);\n    float depth = 5.;\n    int index = 0;\n    for(float i = 0.; i<depth; i++){\n        p*= 1.0+i*0.1;\n        p*=matRotateX(radians(i*10.0+iTime*20.1))*matRotateZ(radians(i*20.0+iTime*32.2));\n        p = abs(p);\n        p-=0.2+i*0.01;\n        float d2 = childBlock(p);\n        d = min(d,d2);\n        index++;\n    }\n    p = prevP;\n    d = min(d,p.y+0.8);\n    vec2 model = vec2(d*0.2,0);\n\n    \n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n\n\n    return diffuseMaterial(n,rd,p,0.5 + 0.5*sin(iTime+p.xyz+vec3(0,2,3))*cos(iTime+p.xyz+vec3(0,2,3)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy -.3;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(iMouse.z>0.){\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(-15.0+iTime*20.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);\n    }\n    \n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 715, 742, 742, 796], [798, 798, 823, 823, 1172], [1174, 1174, 1196, 1196, 1673], [1675, 1675, 1733, 1733, 2000], [2002, 2002, 2026, 2026, 2227], [2229, 2229, 2271, 2271, 2466], [2468, 2509, 2558, 2558, 2849], [2851, 2851, 2908, 2908, 3527], [3529, 3529, 3551, 3551, 3641], [3643, 3643, 3702, 3702, 3810], [3812, 3812, 3869, 3869, 4815]]}
{"id": "sttSDn", "name": "2.5D \"sphere\"", "author": "SnoopethDuckDuck", "description": "equations aren't quite correct but distortion makes it look more sphere-like", "tags": ["e"], "likes": 26, "viewed": 242, "published": "Public API", "date": "1638976572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nconst float num = 32.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float r = 0.35 + 0.13 * thc(3.5, 8. * length(uv) - 1.5 * iTime);\n    //float r = 0.35 + 0.13 * thc(3.5, iTime + 10. * h21(uv));\n    vec2 p;\n    float s = 0.;\n    for (float i = 0.; i < num; i++) {\n        p = vec2(r * sin(pi * i / num) * cos(i + iTime), -r + 2. * r * i / num);\n        vec2 uv2 = uv;\n\n        float d = 4. * length(uv2 - p);\n        float R = r * sin(pi * i / num);\n        float k = 0.1 + 0. * cos(10. * i + iTime) + 0.2 * R;\n        s += smoothstep(-k, k, 0.5 * R * (1. + sin(i + iTime))-d);\n        s += step(d, 0.4 * R * (1. + sin(i + iTime))) - step(d, 0.35 * R * (1. + sin(i + iTime)));\n        s *= 0.99 * (1. - 0.22 * length(uv));\n       // s += 0.28 * max(s,smoothstep(-0.2,0.5, 0.5 * R * (1. + sin(i + iTime))-d));\n    }\n    \n    vec3 col = vec3(s);\n    col = s * pal(s, vec3(1.), vec3(1.), vec3(1.), length(uv) + 0.35 * vec3(0.,0.33,0.66));\n    col += vec3(0.025,0.,0.05);\n   // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 49, 49, 90], [92, 92, 121, 121, 162], [164, 164, 232, 232, 275], [277, 277, 297, 297, 372], [398, 398, 455, 455, 1477]]}
{"id": "sttSW7", "name": "Jump + Run", "author": "lennyjpg", "description": "Click to run.", "tags": ["circles", "loop", "dots", "white", "black"], "likes": 4, "viewed": 76, "published": "Public API", "date": "1639278447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n  return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 u = 10. * fragCoord / iResolution.y - .05;\nfloat rnd = random(floor(u));\nu = fract(u);\nbool rev = iMouse.z < 0.;\nfloat a = (rev ? 0. : 2.9) - sin(iTime * 4.0 + rnd*5.5)*1.8;\nvec2 r = u + vec2(sin(a),cos(a)) * .3;\nfloat c = length(r - .5);\nfloat z = smoothstep(c, c *1.1 , .2);\nfragColor = vec4(rev ? z : 1. - z);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 94], [95, 95, 151, 151, 471]]}
{"id": "sttSz4", "name": "Chess Set in BW. 430 chars", "author": "Artleet", "description": "Chess set. The part of some inner jam, final version. There are a board and a complete set of chess.", "tags": ["raymarching", "golf", "golfing"], "likes": 10, "viewed": 270, "published": "Public", "date": "1638811341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//some further compression is possible\n//chess figures are stylized and abstract so do not judge too strict :)\n//Thanks to Fabrice (https://www.shadertoy.com/user/FabriceNeyret2) for all those cool hints in the comments\n//Thanks to Xor (https://www.shadertoy.com/user/Xor) for all crazy tricks in the comments\n//Thanks to iapafoto (https://www.shadertoy.com/user/iapafoto) for his tips\n//Please read comments to appreciate all participants\n\n/**/ //[430] Ipafoto update with Fabrice's integrated loop and some math changing\n\n#define M(a,b) min(abs(a-abs(b)),\nvoid mainImage(out vec4 o, vec2 F)\n{\n    for(float k=2.,s=k,d=k,i=k,y;++i<5e2 && s>.01;) {\n        vec3 f,z,p = vec3(d*F*k/iResolution.x,20)-d;\n        y = p.y += 8.;\n        p.xz*=mat2(cos(iTime/k-vec4(0,11,8,0)));\n        f=floor(p/k);\n        o=vec4(y>.1?p.z>k:int(f+f.z)%2!=0)/k+9./i;\n        d+=s=min( ( min(z=abs(p),8.1)!=z?--o,k:z.z>6.?\n                      z-=k,\n                      M(28.,s=f.x*8.+y+k)\n                      M(6.,s/k)\n                      M(4.,.4-s)\n                      M(s,4.)\n                      -.4+M(y/k,.2)\n                      k)))))\n                      :M(y,1.)y/k-.2)\n                ) + length(vec2(z.z-5.,--p-f*k))-.4, y)/6.;\n        }\n}\n\n\n\n/** //[442] Xor and Ipafoto update\n\n#define M(a,b) min(abs(a-abs(b)),\nvoid mainImage(out vec4 o, vec2 F)\n{\n    float k=2.,s=k,d=k,i=k,y;\n    for(vec3 p,f,z;\n      ++i<5e2 && s>1e-3;\n      p=vec3(0,8,20)-vec3(d-d*F*k/iResolution.x,d),\n      p.xz*=mat2(cos(iTime/k-vec4(0,11,33,0))),\n      f=floor(p/k),\n      y=p.y,\n      o=vec4(y>.1?p.z>k:int(f+f.z)%2!=0)/k+20./i,\n      d+=s=min( ( min(z=abs(p),8.1)!=z?--o,k:z.z>6.?\n                      z-=k,\n                      M(28.,s=f.x*8.+y+k)\n                      M(6.,s/k)\n                      M(4.,.4-s)\n                      M(s,4.)\n                      -.4+M(y/k,.3)\n                      k)))))\n                      :M(y,1.)+y/k-.3)\n                ) + length(vec2(z.z-5.,--p-f*k))-.4, y)/9. \n      );\n}\n\n/** //[450] version from Ipafoto (alternative geometry)\n\n#define M(a,b) min(abs(a-abs(b)),\nvoid mainImage(out vec4 o, vec2 F)\n{\n    float k=2.,s=k,d=k,i=k,y;\n    for(vec3 p,R=iResolution,f,z;\n      ++i<5e2 && s>1e-3;\n      p=d*vec3(F*k-R.xy,R)/R.x+vec3(0,4,-20),\n      p.xz*=mat2(cos(iTime/k-vec4(0,11,33,0))),\n      f=floor(p/k),\n      y=p.y,\n      o=vec4(y>.1?p.z>k:int(f+f.z)%2!=0)/k+20./i,\n      d+=s=min( ( min(z=abs(p),8.1)!=z?--o,k:z.z>6.?\n                      z-=k,\n                      M(28.,s=f.x*8.+y+k)\n                      M(6.,s/k)\n                      M(4.,.4-s)\n                      M(s,4.)\n                      -.4+M(y/k,.3)\n                      k)))))\n                      :M(y,1.)+y/k-.3)\n                ) + length(vec2(z.z-5.,--p-f*k))-.4, y)/9. \n      );\n}\n\n/** //[452] Last version with original angle and geometry:\n\n#define M(a,b) min(abs(a-abs(b)) -.5,\nvoid mainImage(out vec4 o, vec2 F)\n{\n    float k=2.,s=k,d=k,i=k,y;\n    for(vec3 p,R=iResolution,f,z;\n      ++i<5e2 && s>1e-3;\n      p=vec3(0,4,20)-d*vec3(R.xy-F*k,R)/R.x,\n      p.xz*=mat2(cos(iTime/k+vec4(0,11,33,0))),\n      f=floor(p/k),\n      y=p.y,\n      o=vec4(y>.1?p.z>k:int(f+f.z)%2!=0)/k+20./i,\n      d+=s=min( ( min(z=abs(p),8.1)!=z?--o,k:z.z>6.?\n                      z-=k,\n                      M(28.,s=f.x*8.+y+k)\n                      M(6.,s/k)\n                      M(4.,.5-s)\n                      M(s,4.)\n                      -.5+M(y/k,.2)\n                      k)))))*.8\n                      :M(y,1.)+y/k-.7)\n                ) + length(vec2(z.z-5.,--p-f*k)), y)/9. \n      );\n}\n\n\n/** //[514] Original:\n\n#define M(a,b) max(h-abs(a-abs(b))+0.\nvoid mainImage(out vec4 o, vec2 F)\n{\n    float c,s,d,i,e=.5,h=e,y,z,t=iTime*h,u=cos(t),v=sin(t);\n    for(vec3 p,R=iResolution,f;\n      ++i<5e2&&e>1e-3;\n      p=d*normalize(vec3(F/h-R.xy,R))+vec3(v,5,-20),p.xz*=mat2(u,v,-v,u),\n      f=floor(p*h),\n      y=p.y,z=abs(p.z),\n      c=y>.01?p.z>h?h:0.:mod(dot(vec2(1),f.xz),2.)*h,\n      s=abs(p.x)>8.1||y>4.||z>8.1?c=-2.:z>6.?\n          M(y*h,.2)+h,\n          M(14.,s=f.x*4.+y),\n          M(3.,s*h),\n          M(2.,h-s),\n          M(s,2.)*(z-=7.),\n          -h)))))*.8\n          :M(y,1.)*(z-=5.),.7-y*h),\n        d+=e=min(y,length(vec2(p.x-=f.x/h+1.,z))-s)*.15\n      );\n    o+=20./i+c;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 558, 594, 594, 1241]]}
{"id": "sttSzr", "name": "screenburn", "author": "Del", "description": "these trails look like my old plasma tv!!", "tags": ["voronoi", "sin", "pattern", "trig"], "likes": 12, "viewed": 136, "published": "Public API", "date": "1638654584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'screenburn' - Del 04/12/2021\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n// Voronoi (IQ) - slightly modified to return get the ID etc.\nvec4 VoronoiGrid( in vec2 x, out vec2 id )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    \n    id = (n+mg)+vec2(0.5); // ID is n+mg\n    return vec4(md, length(mr), mr);\n}\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d)\n{\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n} \n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    if (iMouse.z>0.5)\n        uv.y *= 12.0;\n    else\n        uv.y *= 2.;\n    uv.x = uv.x*16.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.5;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(18.0,5.0,s);\t\t\t// trail length\n    //float trail = 5.0;\n    float yv = fract(uv.y + t*s + o) * (trail*1.5);\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage(out vec4 k, vec2 p)\n{\n    vec2 uv = (p.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dd0 = length(uv);\n    float dd1 = smoothstep(0.0,0.3,dd0);\n    uv *= rotate(fract(0.6+iTime*-0.01)*6.28);\n    vec2 id;\n    float scale = 64.0;\n    vec4 grid = VoronoiGrid(uv*scale,id);\n    uv = id/scale;\n\n//    uv = smoothRot(uv,8.0,0.05,0.0,-0.1);\n      uv = smoothRot(uv,4.0,0.35,16.0,0.05);\n        \n    uv *= 0.5;\n    float drop = vDrop(uv.yx,iTime*0.5);\n    vec3 linecol1 = vec3(0.185,0.395,0.5)*2.5;\n    vec3 linecol2 = vec3(0.8,0.75,0.325)*1.5;\n    \n    vec3 linecol = mix(linecol1,linecol2,0.5+sin(iTime*0.2+dd0*0.7)*0.5);\n    \n    vec3 backcol = vec3(0.01,0.04,0.1);\n    vec3 col = mix(backcol,linecol,drop)*dd1;\n    k = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 56, 87, 177], [178, 240, 284, 284, 1117], [1119, 1119, 1175, 1175, 1342], [1344, 1344, 1366, 1366, 1433], [1455, 1455, 1485, 1485, 2034], [2036, 2036, 2072, 2072, 2790]]}
{"id": "sttSzS", "name": "Interregio", "author": "lennyjpg", "description": "a", "tags": ["asdfa"], "likes": 4, "viewed": 89, "published": "Public API", "date": "1639375634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { \nreturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\nvec2 ip = floor(p);\nvec2 u = fract(p);\nu = u*u*(3.0-2.0*u);\nfloat res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\nreturn res*res;\n}\n\n\nfloat wave(vec2 p, float i){\n float medium = noise((p + i * .77 ) * vec2(7. , .1)),\n small = noise((p + i * .33) * vec2(17.57 , .1)),\n large = noise((p + i * .56) * vec2(.052 , .5));\nfloat offset = large - medium * .78 - small * .1;\nfloat a = p.y + offset * .5;\na *= 1.5;\na -= .2;\nfloat b = .7 - i * .05;\nif(mod(i, 2.) > .5){\n   a = 1. - a;\n}\n return step(a,b);\n}\n\nvec3 colors[8] = vec3[]( \n    vec3( 1.0, 0.2, 0.0 ),\n    vec3( 0.1, 0.2, 0.3 ),\n    vec3( 0.1, 0.1, 0.0 ),\n    vec3(0.137,0.137,0.122),\n    vec3( 1.0, 1.0, 0.9 ),\n    vec3( 0.4, 0.2, 1.0 ),\n    vec3(0.953,0.325,0.514),\n    vec3( 1.0, 0.1, 0.2 ));\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.y;\nuv.x*=0.5;\nvec2 u = uv;\nfloat t = iTime * 0.2;\nvec2 m = iMouse.xy/iResolution.xy;\nu.x += m.x * 10.0;\nvec3 color = colors[5];\nfor(float i = 1.0; i < 14.0; i++){\n   float speed = noise(vec2(i*0.23,0.0));\n   speed = i*0.1;\n   vec2 v = u.xy;\n   v.x += speed * t;\n   float e = wave(v, i);\n   color = mix(color, colors[int(mod(i-1., 8.0))],  e);\n}\nfragColor = vec4(color , 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 108, 108, 314], [317, 317, 345, 345, 680], [934, 934, 991, 991, 1401]]}
{"id": "stVGDK", "name": " Alien landscape", "author": "AnicetN", "description": "INSA Lyon 3IF SI\n\nMove camera using mouse", "tags": ["noise", "reflection", "waves", "water", "planet", "daylightcycle"], "likes": 4, "viewed": 97, "published": "Public", "date": "1638382925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TURBULENCES //////////////////////////////////////////////////////////////////////////\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2 i = floor( p + (p.x+p.y)*K1 );\n        \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridged(in vec2 p) {\n    //r(p) = 2(0.5 −|0.5 −n(p)|)\n    return 2.*(0.5 - abs(0.5 - noise(p)));\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave, in bool useRidged) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        if (useRidged) {\n            res = res+amplitude*ridged(f*p);\n        } else {\n            res = res+amplitude*noise(f*p);\n        }\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\n// TRANSFORMATIONS //////////////////////////////////////////////////////////////////////\n\n// Rotation matrix around the X axis.\nmat3 xRotationMat(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 yRotationMat(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 zRotationMat(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// UTILITAIRES //////////////////////////////////////////////////////////////////////\n\nvec2 identifyMin(float a, float b, float c) {\n    float m = min(min(a, b), c);\n    if (m == a) return vec2(m, 0.);\n    if (m == b) return vec2(m, 1.);\n    if (m == c) return vec2(m, 2.);\n}\n\nvec2 identifyMin(float a, float b, float c, float d) {\n    vec2 im = identifyMin(a, b, c);\n    if (min(im.x, d) == d) return vec2(d, 3.);\n    return im;\n}\n\n// RAY MARCHING //////////////////////////////////////////////////////////////////////\n\n//// SETTINGS\n\nconst int Steps = 1000;\nconst float Epsilon = 0.001;\nconst float T=1.;\n\nconst float rA=5.0;\nconst float rB=200.0; \n\nconst float PI = 3.14;\n\nfloat time() {\n    return iTime+10.;\n}\n\n//// SDFs\n\nvec3 camPos() {\n    return vec3(-10., 8., 0.);\n}\n\nfloat sdfRelief(vec3 p) {\n    return p.y - turbulence(p.xz+vec2(120.), 5.5, 0.02, 0.38, 9, true);\n}\n\nfloat sdfMer(vec3 p) {\n    float level = -0.0;\n    return p.y - level - (\n        turbulence(p.xz+vec2(time()*0.8), 0.01, 1., 0.2, 1, false) +\n        turbulence(p.xz+vec2(10.)+vec2(time(), -time()), 0.01, 1., 0.2, 1, false)\n    );\n}\n\nfloat sdfSky(float dO) {\n    return rB - dO;\n}\n\nvec3 sunPos() {\n    return zRotationMat(time()/20. * 2. * PI)/*yRotationMat(time() * 2. * PI) \n        * zRotationMat(0.4*PI)*/\n        * vec3(0., rB, 0.) + camPos();\n}\n\nfloat sdfSun(vec3 p) {\n    return distance(p, sunPos()) - 5.;\n}\n\nvec2 object(vec3 p, float dO) {\n    return identifyMin(\n        sdfRelief(p),\n        sdfMer(p),\n        sdfSky(dO),\n        sdfSun(p)\n    );\n} \n\nvec3 objectNormal(vec3 p, float dO) {\n   float eps = Epsilon;\n   vec3 n;\n   float v = object(p, dO).x;\n   n.x = object(vec3(p.x+eps, p.y, p.z), dO+eps).x - v;\n   n.y = object(vec3(p.x, p.y+eps, p.z), dO+eps).x - v;\n   n.z = object(vec3(p.x, p.y, p.z+eps), dO+eps).x - v;\n   return normalize(n);\n}\n\nvec2 Trace(vec3 ro, vec3 rd)\n{\n    float id = 10.;\n    float dO = rA;\n    int s;\n\n    for(s = 0; s < Steps; s++) {\n       vec3 p = ro+dO*rd;\n\n       vec2 obj = object(p, dO);\n       float ds = obj.x;\n       id = obj.y;\n\n       dO += ds*T;\n\n       if (ds < Epsilon) {\n           break;\n       }\n\n       if (dO > rB) break;\n    }\n\n    return vec2(dO, id);\n}\n\nfloat sunOscilator() {\n    // 1. at midnight -> 0. at noon\n    return 0.5+cos(time()/20.*2.*PI)*0.5;\n}\n\nvec3 lightColor() {\n    vec3 zenithColor = vec3(1., 0.95, 0.9);\n    vec3 coucherColor = vec3(0.7, 0.3, 0.5);\n    vec3 moonlightColor = vec3(0.2, 0.2, 0.25);\n    return mix(mix(\n        moonlightColor,\n        coucherColor,\n        smoothstep(0.45, 0.55, sunOscilator())\n    ),\n        zenithColor,\n        smoothstep(0.5, 0.85, sunOscilator())\n    );\n}\n\nvoid phong(vec3 p, vec3 n, inout vec3 c, float reflectAmount) {\n    vec3 cws = c;\n    vec3 pL = p + vec3(0., 0.1, 0.);\n    vec3 rd = normalize(sunPos() - pL);\n\n    float obstacle = Trace(pL, rd).y;\n    vec3 shadowColor = vec3(0.078, 0.047, 0.109);\n    if (obstacle == 1. || obstacle == 0.) {\n        cws = mix( // OMBRE PAR BLOCAGE\n            cws,\n            shadowColor,\n            0.95\n        );\n    } else {\n        cws = mix( // OMBRE PAR DOT PRODUCT\n            cws,\n            shadowColor,\n            1.-clamp(dot(n, rd), 0.05, 1.)\n        );\n        \n        cws = mix( // REFLECTION DE PHONG\n            cws,\n            lightColor(),\n            smoothstep(0.995, 1., dot(n, rd))*reflectAmount\n        );\n    }\n    \n    c = mix(c, cws, smoothstep(0.4, 0.6, sunOscilator()));\n}\n\nvec3 shadeSky(vec3 p, vec3 rd, float dO) {\n    vec3 c = mix(mix(\n        vec3(0.8, 0.9, 0.99), // ATHMOSPHERE\n        vec3(0.45, 0.78, 1.),\n        smoothstep(10., 50., p.y)\n    ),\n        lightColor()*4., // SUN\n        smoothstep(-0.2, 2., 1.-dot(rd, p-sunPos()))\n    );\n    \n    c *= lightColor();\n    \n    // STARS\n    vec3 n = normalize(p - camPos());\n    float a1 = mix(\n        0.,\n        turbulence(n.xz*100., 1.4, 0.5, 0.6, 1, false),\n        smoothstep(0., 60., distance(camPos().y, p.y))\n    );\n    vec3 cws = mix(\n        c,\n        vec3(0.9, 0.9, 0.85),\n        smoothstep(0.8, 1.9, a1)\n        *(1.-smoothstep(0.5, 0.85, sunOscilator()))\n    );\n    \n    // PLANET\n    if(rd.z > 0.9 ){\n        float rand = turbulence(p.xy, 3., 0.05, 1., 4, false);\n        vec3 pColor = vec3(0.5,0.3,0.4);\n        c = mix(mix(\n            c,\n            pColor * vec3(0.8, 0.8, 0.9),\n            smoothstep(-0.5, 0.3, rd.x+rd.y)\n        ),\n            pColor,\n            smoothstep(0., 1., rd.x+rd.y)\n        );\n    } else {\n        c = cws;\n    }\n    \n    // CLOUDS\n\n    return c;\n}\n\nvoid shadeFog(vec3 p, float dO, inout vec3 c) {\n    c = mix( // BOTTOM FOG\n        c,\n        vec3(0.45, 0.78, 1.)*lightColor(),\n        (1.-smoothstep(-1., 3., p.y))*0.3\n    );\n    \n    c = mix( // DISTANCE FOG\n        c,\n        vec3(0.807, 0.917, 0.992)*lightColor(),\n        smoothstep(rB*0.5, rB*0.9, dO)*0.3\n    );\n}\n\nvec3 shadeRelief(vec3 p, vec3 n, float dO) {\n    float rand = turbulence(p.xz, 3., 0.5, 0.5, 10, false);\n    float randY = p.y+(rand/40.);\n    \n    vec3 c = mix(mix(mix(mix(\n        vec3(0.55,0.52,0.48), // DIRT\n        vec3(0.35, 0.5, 0.45), // GRASS\n        smoothstep(0.1, 0.5, randY)\n        * smoothstep(0.7, 0.9, dot(n, vec3(0., 1., 0.)))\n    ),\n       vec3(0.45, 0.55, 0.5), // GRASS 2\n       smoothstep(0.5, 1., randY)\n       * smoothstep(0.8, 0.95, dot(n, vec3(0., 1., 0.)))\n    ),\n       vec3(0.8,0.8,0.85), // SNOW\n       smoothstep(3., 3.6, randY)\n       * smoothstep(0.85, 1., dot(n, vec3(0., 1., 0.)))\n    ),\n       vec3(0.7,0.7,0.6), // BEACH\n       -smoothstep(0.1, 0.2, randY)\n    );\n\n    float crbNiv = smoothstep(0.9, 1., sin(p.y*20.))/(dO*0.1);\n    c = mix(\n        c,\n        vec3(0.3, 0.3, 0.2),\n        crbNiv\n    );\n\n    phong(p, n, c, 0.05);\n    c *= lightColor();\n    \n    return c;\n}\n\nvec3 reflection(vec3 p, vec3 n, vec3 incRd) {\n    vec3 rd = normalize(reflect(incRd, n));\n    vec3 pL = p + rd*0.001;\n\n    vec2 traceResult = Trace(pL, rd);\n    float dO = traceResult.x;\n    float id = traceResult.y;\n    if (id == 1.) {\n        return vec3(0.0,0.29,0.52);\n    }\n\n    vec3 rayFinalPos = pL+dO*rd;\n    n = objectNormal(rayFinalPos, dO);\n    \n    vec3 reflC;\n    if (id == 3.) {\n        reflC = shadeSky(rayFinalPos, rd, dO);\n    } else if (id == 2.) {\n        reflC = shadeSky(rayFinalPos, rd, dO);\n    } else {\n        reflC = shadeRelief(rayFinalPos, n, dO);\n    }\n    \n    shadeFog(rayFinalPos, dO, reflC);\n\n    return reflC;\n}\n\nvec3 shadeSea(vec3 p, vec3 n, vec3 rd) {\n    vec3 c = reflection(p, n, rd);\n    \n    float sdfRelief = sdfRelief(p);\n    \n    // DEEP WATERS\n    c = mix(c, vec3(0., 0., 0.1), sdfRelief*0.04);\n    \n    // COASTAL WATERS\n    float coastDistAtt = clamp(1.-sdfRelief*2., 0., 1.);\n    float coastWaves = smoothstep(0., 1., sin(coastDistAtt*15.-time()*3.));\n    c = mix(\n        c,\n        vec3(1.),\n        coastDistAtt*coastWaves\n    );\n\n    phong(p, n, c, 0.6);\n    c *= lightColor();\n    \n    return c;\n}\n\nvec3 Shade(vec3 p, vec3 n, vec3 rd, float dO, float id)\n{\n    vec3 c;\n    if (id == 3.) {\n        c = shadeSky(p, rd, dO);\n    } else if (id == 2.) {\n        c = shadeSky(p, rd, dO);\n    } else if (id == 1.){\n        c = shadeSea(p, n, rd);\n    } else {\n        c = shadeRelief(p, n, dO);\n    }\n    \n    shadeFog(p, dO, c);\n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 mouse = iMouse / iResolution.x;\n\n    vec3 camPos = camPos();\n    float camAngleY = -0.15*PI+mouse.x*-2.*PI;\n    float camAngleX = ((mouse.y)*1.2*PI) - 0.3*PI;\n\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = vec3(aspectRatio*pixel.x, pixel.y, 1.5);\n\n    ro = camPos;\n    rd = (yRotationMat(camAngleY) * xRotationMat(camAngleX) * rd);\n    rd = normalize(rd);\n\n    vec2 traceResult = Trace(ro, rd);\n    float dO = traceResult.x;\n    float id = traceResult.y;\n\n    vec3 rayFinalPos = ro+dO*rd;\n    vec3 n = objectNormal(rayFinalPos, dO);\n    vec3 rgb = Shade(rayFinalPos, n, rd, dO, id);\n\n    fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 111, 111, 232], [234, 234, 258, 258, 735], [737, 737, 762, 799, 844], [846, 846, 968, 968, 1276], [1369, 1407, 1439, 1439, 1586], [1588, 1626, 1658, 1658, 1805], [1807, 1845, 1877, 1877, 2024], [2026, 2113, 2158, 2158, 2301], [2303, 2303, 2357, 2357, 2457], [2547, 2702, 2716, 2716, 2740], [2742, 2753, 2768, 2768, 2801], [2803, 2803, 2828, 2828, 2902], [2904, 2904, 2926, 2926, 3137], [3139, 3139, 3163, 3163, 3185], [3187, 3187, 3202, 3202, 3355], [3357, 3357, 3379, 3379, 3420], [3422, 3422, 3453, 3453, 3565], [3568, 3568, 3605, 3605, 3864], [3866, 3866, 3896, 3896, 4221], [4223, 4223, 4245, 4281, 4325], [4327, 4327, 4346, 4346, 4679], [4681, 4681, 4744, 4744, 5472], [5474, 5474, 5516, 5516, 6556], [6558, 6558, 6605, 6605, 6880], [6882, 6882, 6926, 6926, 7792], [7794, 7794, 7839, 7839, 8439], [8441, 8441, 8481, 8481, 8943], [8945, 8945, 9002, 9002, 9285], [9287, 9287, 9342, 9342, 10083]]}
{"id": "stVGW3", "name": "moire flower", "author": "4eckme", "description": "moire pattern", "tags": ["2d", "flower", "moire"], "likes": 2, "viewed": 49, "published": "Public", "date": "1638465332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 c, float a) {\n  return vec2(c.x*cos(a)-c.y*sin(a),c.x*sin(a)+c.y*cos(a));\n}\nvoid mainImage( out vec4 c, in vec2 coord )\n{\n    vec2 coo = coord-(iResolution.xy / vec2(2.0));\n    vec2 co = coord-(iResolution.xy / vec2(2.0));\n    coord = coord -(iResolution.xy / vec2(2.0));\n    coord=rotate(coord,-iTime/2.0-abs(coord.x/2.0)-abs(coord.y/2.0)-abs(abs(coord.x-coord.y)/2.0)+-abs(abs(coord.x+coord.y)/2.0));\n    float x = float(coord.x);\n    float y = float(coord.y);\n    float r = (sqrt(x*x+y*y));\n    float a=degrees(atan(y,x))+180.0;\n    float R=r+sin(a/11.44)*float((r)/3.5);\n    c=vec4(0);\n    if (R<100.0)c=vec4(1,0.8,0,1);\n    R=r-sin(a/11.44)*float(int(r));\n    if (R<66.0)c=vec4(0.5,0.05,0,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 92], [93, 93, 138, 138, 716]]}
{"id": "styGD3", "name": "Learning to Plot", "author": "sbrown2", "description": "just me plotting functions in shader, book of shaders", "tags": ["plotting"], "likes": 1, "viewed": 33, "published": "Public", "date": "1638417193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//plot takes a uv y point and a y defined using f(x) and we return their distance\nfloat plot(float space_y, float point_y){\n    return (smoothstep(space_y-.03,space_y,point_y)-smoothstep(space_y,space_y+.03,point_y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    uv*=iResolution.x/iResolution.y;\n    float x = uv.x;\n    float y = pow(x,2.);\n    float x2 = uv.x;\n    float y2 = sin(x);\n    //if x = y (or if pixel matches plot) color\n    float f = plot(uv.y,y);\n    float f2 = plot(uv.y,y2);\n    // Time varying pixel color\n    vec3 col = .5+0.5*cos(uv.xyx+mod(iTime,3.)*vec3(0,2,4));\n    col+=vec3(f);\n    col+=vec3(f2);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 123, 123, 219], [220, 220, 277, 327, 806]]}
{"id": "tljXDG", "name": "modulous", "author": "derive_by", "description": "in the mornin", "tags": ["duff"], "likes": 1, "viewed": 27, "published": "Public", "date": "1638974109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy*2.0;\n    fragColor = vec4(vec3(mod(iTime*iTime, p.x*p.y)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 161]]}
{"id": "tllyD7", "name": "RayMarching study2", "author": "photonic", "description": "study", "tags": ["study"], "likes": 1, "viewed": 30, "published": "Public", "date": "1639549169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p) {\n    p.y += sin(iTime * 2.) / 20.;\n    float sphere = length(p) - 0.25;\n    float plane = p.y + .35;\n    //return min(sphere,plane);\n\treturn sphere;\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx) ) );\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i=0;i<100;i++)\n    {\n    \tvec3 pos = ro +dO*rd;\n        float dS = map(pos);\n        if (dS < 0.001)\n            break;\n        dO += dS;\n        if (dO > 20.0)\n            break;\n    }\n    if (dO > 20.0 ) dO = -1.0;\n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float dist = length(uv / 2.0);\n    vec3 col = mix(vec3(.03), vec3(0.0), dist * 1.4);\n\n       //CAMERA\n    float an = -iMouse.x/iResolution.x * 10.;\n\tvec3 ro = vec3(1.0*sin(an), 0.0, 1.0*cos(an));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );  \n    \n    float dO = castRay(ro, rd);\n    if ( dO > 0.0) \n    {\n        vec3 pos = ro + dO*rd;\n        vec3 nor = getNormal(pos);\n        vec3 mate = vec3(0.5);\n        \n        vec3 sun_dir = normalize( vec3(0.0, 1.0,0.0) );\n        float sun_dif = clamp( 0.5+0.5*dot(nor, sun_dir), 0.0, 1.0);\n        vec3 sun_col = vec3(7.0, 4.5, 3.0) / 5.0;\n        \n        vec3 sky_dir = normalize( vec3(-1.0, -1.0, 0.0) );\n        float sky_dif = clamp(  dot(nor, sky_dir), 0.0, 1.0);\n        vec3 sky_col = vec3(0.3, 0.4,0.6);\n        \n        vec3 bounce_dir = normalize( vec3(1.0, -1.0, 0.0));\n\t\tfloat bounce_dif = clamp( 0.5 +0.5*dot(nor, bounce_dir), 0.0, 1.0);        \n        \n        float shadow = step(castRay(pos+nor*0.001, sun_dir), 0.0); \n        \n        col = mate*sun_dif * 2.0;\n        col += mate*sky_dif*vec3(0.0, 0.3, 0.5) / 1.0;\n\t\t//col = mate*sun_col*sun_dif*shadow;\n        //col += mate*sky_col*sky_dif;\n        //col += mate*bounce_dif*vec3(.8,0.3,0.1);\n    }\n    float zDepth = length(dO);\n\t//col += zDepth / 4.0;\n    \n    col = pow( col, vec3(.4545) );\n    \n \n    \n        fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 169], [171, 171, 195, 195, 389], [391, 391, 424, 424, 691], [693, 693, 750, 750, 2401]]}
{"id": "WllyzS", "name": "StripesWithSimplexNoise", "author": "allllll3n", "description": "Simple Striples With Simplex Noise", "tags": ["2d", "noise"], "likes": 3, "viewed": 36, "published": "Public", "date": "1638627642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Simplex Noise Code Implement by Inigo Quilez\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// -----------------------------------------------\n\n\nfloat Band(float t, float start, float end,float blur){\n    float step1=smoothstep(start-blur,start+blur,t);\n    float step2=smoothstep(end+blur,end-blur,t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv,float left,float right,float bottom,float top,float blur){\n \tfloat band1=Band(uv.x,left,right,blur);\n    float band2=Band(uv.y,bottom,top,blur);\n    \n    return band1*band2;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col=vec3(0.);\n    float TimeAdjustment=0.5;\n\n    //Parameters Here\n    float BandAmount=20.0;\n    float BandOffset=1./BandAmount;\n    float NoiseSpeed=0.5;\n    float NoiseStrength1=50.0f;\n    float NoiseStrength2=NoiseStrength1*0.1f;\n    float NoiseTiling1=1000.0f;\n    float NoiseTiling2=NoiseTiling1*0.1f;\n    \n    float NoiseWave1=noise(vec2(iTime*NoiseSpeed*NoiseTiling1,uv.y*0.01*NoiseTiling1))*NoiseStrength1;\n    float NoiseWave2=noise(vec2(iTime*NoiseSpeed*NoiseTiling2,uv.y*0.01*NoiseTiling2))*NoiseStrength2;\n    float NoiseWaveY=NoiseWave1*NoiseWave2/iResolution.y;\n    uv.x+=NoiseWaveY;\n    \n    float Mask=0.0f;\n    float OffsetMask1=0.0f;\n    float OffsetMask2=0.0f;\n    for(int i=0;i<int(BandAmount);i++){\n        float TimeOffset=BandOffset*float(i);\n        float BandWidth=0.2*pow(length((TimeOffset-0.5)),3.0);\n        float FracTime=(fract(iTime*TimeAdjustment+TimeOffset)*2.-1.);    \n        Mask+=Band(uv.x,-BandWidth+FracTime,BandWidth+FracTime,0.01);\n        OffsetMask1+=Band(uv.x+0.01f,-BandWidth+FracTime+0.01,BandWidth+FracTime+0.02,0.01);\n        OffsetMask2+=Band(uv.x-0.01f,-BandWidth+FracTime-0.02,BandWidth+FracTime-0.01,0.01);\n    }\n    \n    \n    \n    //float mask=Band(uv.x,-BandWidth+FracTime,BandWidth+FracTime,0.01);\n    \n    //float mask=Rect(uv,-.1,.1,-.1,.1,.01);\n\n    \n    col=vec3(1.,0.,0.)*Mask+vec3(0.,1.,0.)*OffsetMask1+vec3(0.,0.,1.)*OffsetMask2;\n    //col=vec3(uv.x,uv.y,0.0f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllyzS.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1192, 1249, 1249, 1364], [1366, 1366, 1392, 1392, 1871], [1873, 1926, 1981, 1981, 2114], [2116, 2116, 2193, 2193, 2315], [2317, 2317, 2374, 2424, 4011]]}
{"id": "wsGczK", "name": "Black_Hole", "author": "irisdogg", "description": "test shader to make a black hole like effect", "tags": ["space", "stars", "blackhole"], "likes": 5, "viewed": 76, "published": "Public", "date": "1639053668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on a tutorial: https://www.youtube.com/watch?v=rvDo9LvfoVE\n\n#define NUM_LAYERS 4.0\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0.0, 1.0)\n\nmat2 Rot(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, s, -s, c);\n}\n\n// Star and Starfield inspired by this tutorial https://www.shadertoy.com/view/tlyGW3\nfloat Star(vec2 uv, float flare) {\n    float dist = length(uv);\n    float m = 0.05 / dist;\n    \n    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n    m += rays * flare;\n  \tuv *= Rot(3.1415/4.0);\n    rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));\n    m += rays * 0.3 * flare;\n    \n    // smooth out the flare\n    m *= smoothstep(1.0, 0.2, dist);\n    return m;\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    \n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            \n            vec2 offset = vec2(x,y);\n        \t\n            float rand = Hash21(id + offset); // random between 0 and 1\n            float size = fract(rand * 345.32);\n            float star = Star(gv - offset - vec2(rand, fract(rand*34.0)) + 0.5, smoothstep(0.9, 1.0, size));\n        \tvec3 color = sin(vec3(0.2, 0.3, 0.9) * fract(rand * 2565.2)*2.) * 0.5 + 0.5;\n            star *= sin(iTime * 1.0 + rand * 6.2831) * 0.5 + 1.0;\n            col += star * size * color;\n        }\n    } \n\treturn col;    \n}\n\nvec4 BlackHole(vec2 uv) {\n    \n    vec4 col = vec4(0.0);\n    \n    vec4 circle2 = vec4(0.0);\n    \n    float radius = 4.0;\n    \n    float d = length(uv);\n    d /= 2.0;\n    \n    // Make the circle smooth\n    col.rgb = mix(col.rgb, vec3(1.0), S(0.0, 1.0, d)); \n\n    // don't color the pixels that are outside of the circle\n    // to make the \n    if(length(uv) > radius)\n    {\n        col.rgb = vec3(0.0);\n    }\n    \n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 M = (iMouse.xy - iResolution.xy*0.5) / iResolution.y; // on click move mouse around\n    // To zoom out I can multiple the uv by a larger number\n    uv *= 14.0;\n    \n    float t = iTime* 0.01;\n    uv += M * 4.0;\n    uv *= Rot(t);\n    //if( gv.x > 0.48 || gv.y > 0.48) col.r = 1.0;\n    vec4 col = vec4(0.0);\n    \n    for(float i = 0.0; i< 1.0; i+=1.0/NUM_LAYERS)\n    {\n        float depth = fract(i+t);\n        float scale = mix( 5., 0.5, depth);\n        float fade = depth * smoothstep(1.0, 0.9, depth);\n        col += vec4(StarLayer(uv * scale+i*43.2) * fade, 0);\n    }\n    \n    col -= BlackHole(uv);\n    \n    \n    float effectRadius = 0.5;\n    float effectAngle = 2.5 * 3.14159;\n    \n    float len = length(uv * vec2(iResolution.x / iResolution.y, 1.));\n    float angle = atan(uv.y, uv.x) + effectAngle * smoothstep(effectRadius, 0., len);\n    float radius = length(uv);\n    //vec4 test = texture(iChannel0, vec2(radius * cos(angle), radius * sin(angle)) + center);\n    /*\n    vec2 center = iMouse.xy / iResolution.xy;\n    center = center == vec2(0., 0.) ? vec2(.5, .5) : center;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - center;\n\t*/\n    //col += test;\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 166, 189, 189, 278], [280, 366, 400, 400, 739], [741, 741, 763, 763, 866], [868, 868, 893, 893, 1572], [1574, 1574, 1599, 1599, 2004], [2007, 2007, 2064, 2114, 3378]]}
{"id": "wtcBWf", "name": "Shader a day 1", "author": "MinimilisticBits", "description": "day 1", "tags": ["fractal", "abstract"], "likes": 7, "viewed": 121, "published": "Public API", "date": "1638856095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 a, float c){\nfloat l = length(a);\na/=l;\nfloat ang = (a.y<0.)?acos(a.x):2.*3.14159 - acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\nfloat DE(vec3 p0){\nvec4 p = vec4(p0, 1.);\nfor(int i = 0; i < 20; i++){\n\np*=5.2 + sin(iTime)*1.4;\np.xyz = mod(p.xyz-1.5, 3.)-1.5;\np.xyz -= vec3(0.4,0.2,0.1)*0.5;\np/=dot(p.xyz,p.xyz);\n}\n\nreturn length(p.xyz)/p.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 a = vec3(0.2,0.5,0.3);\n    vec3 b = vec3(0.6,0.2,0.1);\n    vec3 c = vec3(0.2,0.1,0.4);\n    vec3 d = vec3(0.9,0.5,0.5);\n    vec3 color = a + b*cos(6.28318*(c*uv.y+d + iTime));\n   \n   \n   \n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n   \n    uv = abs(uv);\n    uv = rot(uv, iTime*0.4);\n   \n    uv *= 10.;\n    float dist = DE((mod(vec3(uv.x, uv.y,1.), 12.)-6.)/20.)*20.;\n    vec3 col;\n    //if(dist < 0.01){\n    //col = vec3(1.);  \n   // }\n   col+=dist*0.9;\n    col-=color;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 157], [159, 159, 177, 177, 371], [373, 373, 430, 480, 1071]]}
{"id": "XtyGRm", "name": "Dragon ball 1 star", "author": "Shirooo", "description": "Dragon ball", "tags": ["dragonball"], "likes": 5, "viewed": 53, "published": "Public", "date": "1638540134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvec2 rotate(vec2 p, float a)\n{\n    return mat2( cos(a), -sin(a), sin(a), cos(a) ) * p;\n}\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n\n    return f/0.90;\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0; \n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r = length(uv);\n    \n    //bckg\n    vec3 col = mix(vec3(1.,0.2,0.0), vec3(0.7,0.15,0.0), fbm((uv+iTime*0.3)*.5));\n    \n    \n    //dark red border\n    float t = smoothstep(0.8, 0.82, r);\n    col = mix(vec3(0.8, 0.,0.), col, t);\n    \n    //yellow\n    t = smoothstep(0.79, 0.8, r);\n    vec3 noisedCol = mix(vec3(0.9,0.85,0.5), vec3(1.,0.9,0.5), fbm(uv));\n    col = mix(noisedCol, col, t);\n    \n    //orange shadow\n    t = smoothstep(0.75, 0.79, r);\n    col = mix(vec3(0.85,0.37,0.0), col, t);\n    \n    //yellow highlight\n    if(r<0.79)\n    {\n        float offsetedR = length(uv+vec2(0.2,-0.15));\n        t = smoothstep(0.4, 1.5, offsetedR);\n        t *= fbm(uv*0.3+vec2(iTime*0.5))*3.4; \n        col = mix(vec3(0.98,0.9,0.2), col, t);\n    }\n    \n    //star\n    noisedCol = mix(vec3(0.95,0.5,0.2), vec3(1.,0.5,0.2), fbm(uv*4.+vec2(0.2,0.7)));\n    col = mix(col, noisedCol, smoothstep(0.1,0.,sdStar5(uv*vec2(8.,8.5)-vec2(0.,0.4), 2., .4)));\n    \n    //white highlights\n    vec2 h1uv = ((uv+vec2(0.55-pow(uv.y,2.)*0.7,0.14))*vec2(1.7-uv.y*2.0,0.65));\n    float offsetedR = length(h1uv);\n    t = smoothstep(0.3, 0.25, offsetedR + fbm((uv+vec2(2.))*3.)*0.1);\n    col = mix(col, vec3(1., 1., 0.9), t);\n    \n    h1uv = ((uv+vec2(0.35,-0.3))*vec2(10.,5.));\n    offsetedR = length(h1uv);\n    t = smoothstep(0.3, 0.1, offsetedR + fbm((uv+vec2(2.))*40.)*0.1);\n    col = mix(col, vec3(1., 1., 0.9), t);\n    \n    h1uv = ((uv+vec2(0.25,-0.45))*vec2(2.,4.));\n    offsetedR = length(h1uv);\n    t = smoothstep(0.3, 0.2, offsetedR + fbm((uv+1.)*7.)*0.2);\n    col = mix(col, vec3(1., 1., 0.9), t);\n    \n    vec2 rotuv = rotate(uv+vec2(-0.32,0.67), 0.49);\n    h1uv = rotuv*vec2(1.8,9.);\n    offsetedR = length(h1uv);\n    t = smoothstep(0.24, 0.2, offsetedR + fbm((uv+2.)*10.)*0.1);\n    col = mix(col, vec3(1., 1., 0.9), t);\n    \n    rotuv = rotate(uv+vec2(-0.53,0.52), 0.76);\n    h1uv = rotuv*vec2(1.6,9.);\n    offsetedR = length(h1uv);\n    t = smoothstep(0.24, 0.2, offsetedR + fbm((uv+2.)*10.)*0.1);\n    col = mix(col, vec3(1., 1., 0.9), t);\n    \n    \n    col = pow(col,vec3(2.2));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 81, 81, 139], [142, 142, 165, 165, 204], [206, 206, 232, 232, 453], [455, 455, 476, 476, 647], [649, 649, 700, 700, 1078], [1082, 1082, 1139, 1139, 3354]]}
