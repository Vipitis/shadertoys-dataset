{"id": "4d3SRN", "name": "Plasma cube", "author": "patu", "description": "Simple plasma cube. ", "tags": ["cube", "plasma", "rm"], "likes": 19, "viewed": 1613, "date": "1457830061", "time_retrieved": "2024-06-20T18:32:57.782310", "image_code": "// ShaderToy extension for Chrome:\n// http://bit.ly/shadertoy-plugin\n\nconst vec3 BOX = vec3(1.0);\nconst float PI = 3.14159265;\nconst vec3 e = vec3(0.02,0,0);\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x ,max(d.y, d.z)), 0.0) +\n         length(max(d, 0.0));\n}\n\nmat3 rotationZ(float k) {\n    return mat3( // rotationZ matrix;\n        vec3(cos(k), -sin(k), 0.0),\n        vec3(sin(k), cos(k), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );  \n}\n    \n    \nmat3 rotationX (float k) {\n    return  mat3( // rotationX matrix;\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(k * 1.2), -sin(k * 1.2)),\n        vec3(0.0, sin(k * 1.2), cos(k * 1.2))        \n    ); \n}\n\nvec4 cubePlasma (vec2 coord, vec3 p) {\n    \n    float \n        k = iTime * 3.0,\n        as = 4.78207464329,\n    \tfd = 12.18910931609,\n    \tas1 = 2.839499561581 / 24.0 + sin(k) * 0.02,\n    \tfd2 = 2.188989119604,\n    \tps = -5.624243766069,\n    \tps2 = 9.393007904291,\n    \tp1 = sin(k / ps) * 4.0,\n    \tp2 = sin(k / fd) * 3.0,\n    \tt3 = sin(k / fd2) + cos(as1),\n        t4 = sin(k / ps);    \n    \n    coord.x = floor(coord.x * 16.0) / 16.0;\n    coord.y = floor(coord.y * 16.0) / 16.0;\n    \n    float x = sin(p1 + coord.x) * sin(p2 + coord.y) + sin(t3 + coord.x) * sin(t4 + coord.y) * -p.x;\n    \n    float r = (0.87 + sin((x / as1 ) / 8.0) + sin(x / as1)) / 2.0;\n    float g = (0.42 + sin(x / as1)) / 2.0; \n    float b = (0.77 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n\n    if (\n        coord.y <= -0.9 || coord.y >= 0.9 ||\n        coord.x <= -0.9 || coord.x >= 0.9    \n    ) { \n        r += 2.;  \n        b += 2.; \n        g += 2.; \n    }\n    \n  \n    vec4 color = vec4(vec3(r, g, b) * 2.0, 1.0);\n     \n    return color;\n    \n}\n\nvec4 boxmap( in vec3 p, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = cubePlasma(p.yz, p);\n\tvec4 y = cubePlasma(p.zx, p);\n\tvec4 z = cubePlasma(p.xy, p);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n    return vec2(sdBox(p, vec3(1.)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n  \tconst float maxd = 20.0; //Max depth\n  \t\n    vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n    vec2 ovPos = vPos;\n    \n    vec2 d = vec2(0.5, 0.0);    \n    \n    fragColor = vec4(0.0);\n    \n  \tvec3 c, p, N, vuv, vrp, prp;    \n        \n    float \n        k = iTime,\n    \tf = 1.0, // ray start\n    \tmx,\n        my;\n    \n    k = iTime * 1.7;\n\n    float glow = 0.0;\n\n    vPos.x += sin(vPos.y * 2. + k) / 48.;\n\t\n    // Camera setup.\n    vuv = vec3(0, -1., 0.); \n    prp = vec3(3.\n        //sin(k) * 6.3,\n        //sin(k) * 5.2,\n        //cos(k) * 6.\n    ); //cam position\n    \n    vrp = vec3(0);\n     \n    // Camera setup.\n    \n    vec3 vpn = normalize(vrp - prp);\n    vec3 u = normalize(cross(vuv, vpn));\n    vec3 v = cross(vpn, u);\n    vec3 vcv = (prp + vpn);\n    vec3 scrCoord = vcv + vPos.x * u * iResolution.x / iResolution.y + vPos.y * v;\n    vec3 scp = normalize(scrCoord - prp);\n\n    // Raymarching.\n    float minDist = 140.;\n    for (int i = 0; i < 32; i++) {\t\n      \n        if ((abs(d.x) < .01) || (f > maxd)) break;\n   \n        f += d.x;\n        p = prp + scp * f;    \n        p = p * rotationZ(k) * rotationX(k);\n        d = distance_to_obj(p);\n        if (i < 6) {\n        \tminDist = min(minDist, d.x * 7.);\n        }\n        //minDist += min(minDist, d.x * 3.) / 2.;\n        if (i < 6) glow = pow( 1. / minDist, 0.8);\n    }  \n  \n    if (f < maxd){\n\n        if (d.y == 1.0) c = boxmap( p, 34.0 ).xyz;\n      \n        vec3 n = vec3(\n            d.x - distance_to_obj(p - e.xyy).x,\n            d.x - distance_to_obj(p - e.yxy).x,\n            d.x - distance_to_obj(p - e.yyx).x\n        );\n    \n        N = normalize(n);\n\t\tvec3 L = vec3(8.5 , 1.0, 8.0 );\n        float b = abs(dot(N, normalize(prp - p + L)));\n\t\t\n        fragColor += vec4(max((b * c + pow(b, 64.0)) * (1.0 - f *.01), 0.0), 1.0);\n        \n        \n  \t} else {\n        \n        fragColor = vec4(vec3(normalize(scp) / 2.), 0.) + glow;\n    }\n}\t \n \t\t\t\t    ", "image_inputs": [{"id": "lsXGz2", "previewfilepath": "https://soundcloud.com/decrunch/aceman-munch-your-lunch", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/decrunch/aceman-munch-your-lunch", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3SRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4d3XRH", "name": "Eye of the world", "author": "Mr_E", "description": "A random adaption from https://www.shadertoy.com/view/MlfSWX which was written by dr2.\n", "tags": ["eye", "shapes", "adaption"], "likes": 2, "viewed": 481, "date": "1457540409", "time_retrieved": "2024-06-20T18:32:58.248752", "image_code": "// A random adaption from https://www.shadertoy.com/view/MlfSWX which was written by dr2.\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\n\n\nfloat tCur, qStep;\nvec3 vuPos;\nconst float mScale = 2.8;\nconst float dstFar = 30.;\n\nfloat MBoxDf (vec3 p)\n{\n  vec4 q, q0;\n  const int nIter = 30;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q *= mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.);\n    q += q0;\n  }\n  return length (q.xyz) / abs (q.w);\n}\n\nfloat ObjDf (vec3 p)\n{\n  return max (MBoxDf (p), - PrCapsDf (p - vuPos, 0.2, 0.5));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const int nStep = 50;\n  float d, h, s;\n  d = 0.;\n  s = 0.;\n  for (int j = 0; j < nStep; j ++) {\n    h = ObjDf (ro + d * rd);\n    d += h;\n    ++ s;\n    if (h < 0.08 || d > dstFar) break;\n  }\n  qStep = s / float (nStep);\n  return d;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltDir, col, vn;\n  float dstHit;\n  dstHit = ObjRay (ro, rd);\n  ltDir = normalize (vec3 (0.2, 1., -0.2));\n  col = vec3 (clamp (0.5 + 1.5 * rd.y, 0., 1.));\n  if (dstHit < dstFar) {\n    ro += dstHit * rd;\n    vn = ObjNf (ro);\n    col = vec3(1, 1, 1);\n    col = col * (0.3 +\n       0.7 * max (dot (vn, ltDir), 0.)) +\n       0.3 * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n    col = clamp (col, 0., 1.);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vuPos = vec3 (0., 0., -5.5 + mod (.05 * tCur + .3, 9.));\n  fragColor = vec4 (ShowScene (vuPos, normalize (vec3 (uv, 5.))), -2.1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d3XRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSDN", "name": "falling by TAZADUM", "author": "bysse", "description": "Released at Revision 2016\nPlaced 5th in the PC 4k intro compo\n\nhttp://www.pouet.net/prod.php?which=67174", "tags": ["raymarching", "4k"], "likes": 5, "viewed": 542, "date": "1459279078", "time_retrieved": "2024-06-20T18:32:59.830817", "image_code": "/**\n\t\"falling\" by TAZADUM\n\n\tReleased at Revision 2016\n\tPlaced 5th in the PC 4k intro compo\n\n\t.gfx    klovman\n\t.synth  druttis\n\t.music  druttis\n\n\tAdjusted the shader for WebGL. It's optimized for size, so it's a bit obfuscated...\n\tI've moved the camera a bit closer to the water in this version which shows\n\tof the water a bit more otherwise it's straight from the intro.\n\tAs you can see I stand on the shoulders of giants :)\n\n\tBig thanks to iq for all resources on raymarching and to everyone who publishes \n\tshaders on this site!\n**/\n\nconst float i_MAXD = 15000.0;\n\n#if 1\n\t// low-end gfx\n\t#define CLOUD_STEPS 60\n\t#define RAYMARCH_STEPS 60\n#else\n\t// high-end gfx\n\t#define CLOUD_STEPS 100\n\t#define RAYMARCH_STEPS 100\n#endif\n\nvec3 eps = vec3(.02, 0., 0.);\n\nvec3 waterColor_2 = vec3(0.01, 0.1, 0.15);\nvec3 sunColor = vec3(.99, .94, .9);\nvec3 attenuation = vec3(.3, .03, .01);\nvec3 sun = vec3(0.38, 0.531, -0.758);\nvec2 cloud = vec2(2501., 3400.);\n\nfloat globalDistance = 0.;\nvec3 sunAmount = vec3(0.);\nbool above;\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n\tvec3 q = abs(p);\n\treturn max(q.y-h.y,max(0.866025*q.x + 0.5*p.z,-p.z)-.5*h.x);\n}\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec3 x ) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + 57.0*p.y + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.0,  0.8,  0.6,\n              -0.8,  0.3, -0.4,\n              -0.6, -0.4,  0.6 );\n\nfloat fbm(vec3 p, float d) {\n\tfloat v  = 0.500*noise( p ); p = m*p*2.1 + d;\n          v += 0.210*noise( p ); p = m*p*2.2 + d;\n    \t  v += 0.120*noise( p ); p = m*p*2.3 + d;\n    \t  v += 0.063*noise( p );\n\treturn v;\n}\n\nvec4 cloudField(vec3 p) {\n\treturn vec4(1, 1, 1, smoothstep(0., 1., pow(fbm(.001 * p + vec3(2, 4.2, 0), 0.),2.) - .3));\n}\n\nfloat waterHeight(vec3 q) {\n\tfloat d = .2*iTime;\n\tvec3 p = .15*q + d;\n\tp.y = 0.;\n\treturn .5*fbm(p, d) + 0.0025*noise( 32.*p ) \n\t\t+ .5*sin(.1*q.z + 5.*d + 0.01*q.x) + .05*sin(.44*q.z + d);\n}\n\nvec4 traceClouds(vec3 rp, vec3 rd) {\n\tvec4 color = vec4(0.);\n\tvec2 interval = (cloud - rp.y) / rd.y;\n\tfloat inc = (interval.y - interval.x) / float(CLOUD_STEPS);\n\tfloat aa = clamp(20000./(interval.x + globalDistance), 0., 1.);\n\t\n\tfor(int i=0;i<CLOUD_STEPS;i++) {\n\t\tif (color.w < 1.) {\n\t\t\tvec3 p = rp + interval.x*rd;\n\t\t\tvec4 c = cloudField(p);\n\t\n\t\t\tvec4 shade = cloudField(p + 400.*sun);\n\t\t\tc.xyz *= 1. - .25*smoothstep(0., 1., 10. * shade.w); \n\t\t\tc.xyz *= 1. - .0001*(cloud.y-p.y);\n\t\t\t\n\t\t\tc.w *= aa;\n\t\t\tc.xyz *= c.w;\n\t\t\tcolor += c * (1.-color.w);\n\t\t\t\n\t\t\tinterval.x += inc;\n\t\t}\n\t}\n\tvec3 sky = mix(vec3(0.8, 0.9, 1.2), vec3(0.08, 0.25, 0.5), .45+rd.y);\n\tcolor.xyz = mix(sky, color.xyz/(0.01+color.w), color.a*aa);\n\treturn color;\n}\n\nvec2 field(vec3 q, float d, int nowater) {\n\tvec2 h = vec2(i_MAXD * float(nowater));\n\n\tif (nowater < 1) {\n\t\tfloat k = smoothstep(0., 1., 200. / d);\n\t\th.x = q.y \n\t\t\t+ noise( 0.01*vec3(q.x, 0., q.z) + iTime )\n\t\t\t+ (1. - k)*.1*noise( 0.1*vec3(q.x, 0., q.z))\t\t// FLICKERY\n\t\t\t;\n\n\t\th.x = abs(h.x + (k>0.01?k*waterHeight(q):0.));\n\t\th.y = .5;\n\t}\n\n\n\tfloat y = 8. + .5*sin(iTime);\n\tif (dot(q,q) < 4e6) {\n\t\tfloat a = noise(20.*floor((vec3(q.x, 0., q.z))/128.));\n\t\ty += 200. * smoothstep(0., 1., a) - 3.;\n\t\tq.xz = mod(q.xz, vec2(128.)) - 64.;\n\t}\n\n\tfloat e = min(\n\t\tmax(sdTriPrism(q + vec3(0, y, 0), vec2(20, 11)), -sdTriPrism(q + vec3(5, y, -5), vec2(10, 12))),\n\t\tsdTriPrism(q + vec3(5.5, y+.5*sin(4.+iTime), -5.5), vec2(5, 11))\n\t\t);\t\t\t\n\t\n\treturn e<h.x?vec2(e, 1.5):h; \n}\n\nvec3 normal(vec3 p, float d, float f) {\n\treturn normalize(vec3(\n\t\tfield(p+f*eps.xyz, d, 0).x - field(p-f*eps.xyz, d, 0).x,\n\t\tfield(p+f*eps.yxz, d, 0).x - field(p-f*eps.yzx, d, 0).x,\n\t\tfield(p+f*eps.yzx, d, 0).x - field(p-f*eps.yzx, d, 0).x\n\t\t));\n}\n\n\nvec3 intersect(vec3 ro, vec3 rd, int nowater) {\n\tvec3 hit = vec3(0., .1, 0.);\n\t// hit.x = position\n\t// hit.y = step size\n\t// hit.z = material\n\tfor( int i=0; i<RAYMARCH_STEPS; i++ ) { // Lower for speed\n\t\tif (abs(hit.y) > eps.x && hit.x < i_MAXD) {\n\t\t\thit.x += hit.y;\n\t\t\thit.yz = field(ro + rd * hit.x, hit.x, nowater);\n\t\t}\n\t}\t\n\tif (nowater < 1 && (hit.x > i_MAXD || hit.y > 1.)) {\n\t\thit.x = -ro.y / rd.y;\n\t\thit.y = 10.;\n\t\thit.z = .5;\n\t}\n    return hit;\n}\n\nvec3 colorOfObject(float d) {\n\treturn vec3(2., 2., .8)*(.1 + d); // INLINE?\n}\n\nvec3 colorOfWater(vec3 h, vec3 ro, vec3 rd) {\n\tvec4 traceResults = vec4(0);\n\n\tvec3 hit = ro + (h.x - 0.05) * rd;\n\tvec3 n = normal(hit, h.x, 1.);\n\n\tfloat side = above ? 1. : -1.;\n\tfloat D = max(0.,dot(sun, n)*side);\n\tglobalDistance += h.x;\n\n\t// Material in h.z \n\tif (h.z > 1.) {\n\t\treturn mix(waterColor_2, colorOfObject(D), above?1.:exp(-0.0002*pow(h.x,1.6)));\n\t} \n\n\tvec3 R = reflect(rd, n);\n\tvec3 H = normalize(sun - rd);\n\n\t// reflective indices\n\tfloat index = above ? .75 : 1.33;\n\tfloat d = abs(dot(rd, n));\n\tfloat det = 1. - index * index * (1. - d*d); // if this is < 0, then it's total reflection \n\n\tvec3 reflection = waterColor_2 * (1. - max(0.,-R.y)), // Add 'diffuse' lightning under water if schlick > 0.01\n\t\ttransmission = waterColor_2; // total reflection\n\n\tif (det > 0.) {\n\t\t// calculate transmission\n\t\tvec3 T = normalize(index*rd + (index*d - sqrt(det))*side*n);\n\n\t\tvec3 tHit = intersect(hit, T, 1);\n\t\tif (tHit.z > 1. && tHit.x < i_MAXD) {\n\t\t\tvec3 uwhit = hit + T*tHit.x;\n\t\t\ttransmission = colorOfObject(max(0., dot(sun, normal(uwhit, tHit.x, 1.)))) * exp(0.5*attenuation*uwhit.y); // reduce attenuation because it looks good\n\t\t} else {\n\t\t\ttransmission = vec3(0.0, 0.01, 0.05);\n\t\t\tif (!above) {\n\t\t\t\ttraceResults = traceClouds(hit, T);\n\t\t\t\ttransmission = traceResults.xyz + (1. - traceResults.a) * sunAmount;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate Schlick's approximation to the Fresnel factor\n\t// this is the same no matter on which side of the surface you are\n\tfloat schlick = 0.02 + (1. - 0.02) * pow(1. - d, 2.);\n\t\n\tif (schlick > 0.01) {\n\t\t// calculatee reflection\n\t\tvec3 rHit = intersect(hit, R, 1); // raymarch without the water function\n\t\tif (rHit.z > .1 && rHit.x < i_MAXD && dot(R, vec3(0,1,0)) > 0.05) {\n\t\t\treflection = mix(\n\t\t\t\t\t\twaterColor_2, \n\t\t\t\t\t\tcolorOfObject(max(0., dot(sun, normal(hit + R*rHit.x, rHit.x, 1.)))), \n\t\t\t\t\t\tabove ? 1. : exp(-0.0002*pow(h.x + rHit.x,1.6))\n\t\t\t\t\t\t);\n\t\t} else if (above) {\n\t\t\ttraceResults = traceClouds(hit, R);\n\t\t\treflection = .75 * traceResults.xyz\n\t\t\t\t+ (1.-traceResults.w)\n\t\t\t\t\t* (sunColor + (1.0 - sunColor)\n\t\t\t\t\t\t* pow(1.0 - max(0., dot(sun, H)), 5.))\n\t\t\t\t\t* pow(max(0., dot(n, H)), 64.)\n\t\t\t\t\t* D\n\t\t\t\t\t* (12. - 0.008*ro.y);\n\t\t}\n\t}\n\n\treturn schlick * reflection + (1. - schlick) * transmission;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1. + 2. * fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y; \t\n\n\tfloat s0  = 2. * smoothstep(0., 1., (iTime -  0.)*.04);\n\tfloat s25 = smoothstep(0., 1., (iTime - 25.)*.08);\n\tfloat s40 = smoothstep(0., 1., (iTime - 35.)*.06);\n\tfloat s45 = smoothstep(0., 1., (iTime - 45.)*.12);\n\t\n\tfloat h1 = clamp(iTime - 25., 0., 10.);\n\t\n\tvec2 look = vec2(\n\t\t// left-right\n\t\t1.20 + s0\n\t\t- .35 * sin(3.14*s40)\n\t\t,\n\t\t// up-down\n\t\t0.75 - .30*s0\n\t\t-.30*(smoothstep(0., 1., (iTime - 20.)*.10) - s25)\n\t\t+ .25 * sin(3.14*smoothstep(0., 1., (iTime - 35.)*.20))\n\t\t- .3 * s40 + .3 * s45*s45\n\t\t+ .5 * smoothstep(0., 1., (iTime - 55.) * .1)\n\t);\n\t\n\tvec3 cp = vec3(\n\t\t// x\n\t\t440.*s40 -128.\n\t\t , \n\t\t// y\n\t\t111. \n\t\t- 125.*s25\n\t\t+ 5. * clamp(iTime-35., 0., 5.)\n\t\t+   80.*s40\n\t\t-   80.*s45\t\n\t\t- 100. * clamp(iTime - 54.8, 0., .3) - 10. * clamp(iTime - 55.1, 0., 15.)\n\t\t, \n\t\t// z\n\t\t5178.\n\t\t- 500.*h1 + 10.*h1*h1\n\t\t- 1038.*s40\n\t\t);\n\n\tvec3 cd = normalize(vec3(sin(look.x), look.y, cos(look.x)));\n\tvec3 side = cross(cd, vec3(0, -1., 0.));\n\tvec3 rd = normalize(cd + .5*(uv.x*side + uv.y*cross(cd, side)));\n\n\tfloat wh = waterHeight(cp);\n\tvec3 color = waterColor_2;\n\tvec3 result = intersect(cp, rd, 0);\n\tvec4 tr = vec4(0);\n\n\tabove = cp.y >= wh;\n\n\tfloat sunSpecular = max(0.,dot(sun, rd));\n\tsunAmount = sunColor * min(4.0 * pow(sunSpecular, 2048.0) + pow(sunSpecular, 32.0), 1.0);\n\n\tif (result.x > 0.) {\n\t\tcolor = colorOfWater(result, cp, rd);\n\t} else if (above) {\n\t\ttr = traceClouds(cp, rd);\n\t\tcolor = tr.xyz;\n\t}\n\n\tif (above && sunSpecular > 0.0) {\n\t\tvec2 sunPos = vec2(dot(sun, side), sun.y);\n\t\tvec2 pos = uv - sunPos;\n\t\tpos = pos * length(pos);\n\t\tsunColor *= .1 * pow(sunSpecular, 6.0);\n\t\tcolor += sunColor * 25.0 * pow(max(0., 1.0-2.0*length(sunPos*2.0 + pos)), 10.0) * vec3(1.0, .4, .2);\n\t\tcolor += sunColor * 10.0 * pow(max(0., 1.0-length(sunPos*5.0 + mix(pos, uv, -2.1))), 4.0);\n\t}\n\n\tcolor = above ? color + sunAmount * (1.-tr.a) : color * exp(-attenuation*(wh - cp.y)) * min(1.+ rd.y, 1.);\n\t\n\tcolor +=    smoothstep(0., 1., 1.-.1*iTime);\t\t// FADE IN\n\tcolor *= 1.-smoothstep(0., 1., .2*iTime-12.3);\t// FADE OUT\n\t\t\n\t// gamma + contrast\n\tcolor = pow( min(color, 1.), vec3(0.44) );\n\tfragColor = vec4(color*color*(3.0-2.0*color), 0.);\n}\n", "image_inputs": [{"id": "XdXGzX", "previewfilepath": "https://soundcloud.com/druttis/falling", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/druttis/falling", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSRN", "name": "YUV YPbPr YCoCg", "author": "paniq", "description": "reference implementation for YUV colorspaces. cylinder demos the YCoCg color space, with chroma radius clamped to bicone of safe values in RGB cube. Drag mouse to see slices.", "tags": ["yuv", "srgb", "ycbcr", "ypbpr", "yccbccrc", "ycocg", "ycgco"], "likes": 16, "viewed": 1526, "date": "1457846769", "time_retrieved": "2024-06-20T18:32:59.830817", "image_code": "// undefine to see full mapped range\n#define CLAMP_BICONE\n\n// define for chroma normalization (when biconic clamping is disabled)\n//#define NORM_CHROMA\n\n//----------------------------------------------------------------------------\n\n// YUV, generic conversion\n// ranges: Y=0..1, U=-uvmax.x..uvmax.x, V=-uvmax.x..uvmax.x\n\nvec3 yuv_rgb (vec3 yuv, vec2 wbwr, vec2 uvmax) {\n    vec2 br = yuv.x + yuv.yz * (1.0 - wbwr) / uvmax;\n\tfloat g = (yuv.x - dot(wbwr, br)) / (1.0 - wbwr.x - wbwr.y);\n\treturn vec3(br.y, g, br.x);\n}\n\nvec3 rgb_yuv (vec3 rgb, vec2 wbwr, vec2 uvmax) {\n\tfloat y = wbwr.y*rgb.r + (1.0 - wbwr.x - wbwr.y)*rgb.g + wbwr.x*rgb.b;\n    return vec3(y, uvmax * (rgb.br - y) / (1.0 - wbwr));\n}\n\n//----------------------------------------------------------------------------\n\n// YUV, HDTV, gamma compressed, ITU-R BT.709\n// ranges: Y=0..1, U=-0.436..0.436, V=-0.615..0.615\n\nvec3 yuv_rgb (vec3 yuv) {\n    return yuv_rgb(yuv, vec2(0.0722, 0.2126), vec2(0.436, 0.615));\n}\n\nvec3 rgb_yuv (vec3 rgb) {\n    return rgb_yuv(rgb, vec2(0.0722, 0.2126), vec2(0.436, 0.615));\n}\n\n//----------------------------------------------------------------------------\n\n// Y*b*r, generic conversion\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\nvec3 ypbpr_rgb (vec3 ybr, vec2 kbkr) {\n    return yuv_rgb(ybr, kbkr, vec2(0.5));\n}\n    \nvec3 rgb_ypbpr (vec3 rgb, vec2 kbkr) {\n    return rgb_yuv(rgb, kbkr, vec2(0.5));\n}\n\n//----------------------------------------------------------------------------\n\n// YPbPr, analog, gamma compressed, HDTV\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\n// YPbPr to RGB, after ITU-R BT.709\nvec3 ypbpr_rgb (vec3 ypbpr) {\n    return ypbpr_rgb(ypbpr, vec2(0.0722, 0.2126));\n}\n\n// RGB to YPbPr, after ITU-R BT.709\nvec3 rgb_ypbpr (vec3 rgb) {\n    return rgb_ypbpr(rgb, vec2(0.0722, 0.2126));\n}\n\n//----------------------------------------------------------------------------\n\n// YPbPr, analog, gamma compressed, VGA, TV\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\n// YPbPr to RGB, after ITU-R BT.601\nvec3 ypbpr_rgb_bt601 (vec3 ypbpr) {\n    return ypbpr_rgb(ypbpr, vec2(0.114, 0.299));\n}\n\n// RGB to YPbPr, after ITU-R BT.601\nvec3 rgb_ypbpr_bt601 (vec3 rgb) {\n    return rgb_ypbpr(rgb, vec2(0.114, 0.299));\n}\n\n//----------------------------------------------------------------------------\n\n// in the original implementation, the factors and offsets are\n// ypbpr * (219, 224, 224) + (16, 128, 128)\n\n// YPbPr to YCbCr (analog to digital)\nvec3 ypbpr_ycbcr (vec3 ypbpr) {\n\treturn ypbpr * vec3(0.85546875,0.875,0.875) + vec3(0.0625, 0.5, 0.5);\n}\n\n// YCbCr to YPbPr (digital to analog)\nvec3 ycbcr_ypbpr (vec3 ycbcr) {\n\treturn (ycbcr - vec3(0.0625, 0.5, 0.5)) / vec3(0.85546875,0.875,0.875);\n}\n\n//----------------------------------------------------------------------------\n\n// YCbCr, digital, gamma compressed\n// ranges: Y=0..1, b=0..1, r=0..1\n\n// YCbCr to RGB (generic)\nvec3 ycbcr_rgb(vec3 ycbcr, vec2 kbkr) {\n    return ypbpr_rgb(ycbcr_ypbpr(ycbcr), kbkr);\n}\n// RGB to YCbCr (generic)\nvec3 rgb_ycbcr(vec3 rgb, vec2 kbkr) {\n    return ypbpr_ycbcr(rgb_ypbpr(rgb, kbkr));\n}\n// YCbCr to RGB\nvec3 ycbcr_rgb(vec3 ycbcr) {\n    return ypbpr_rgb(ycbcr_ypbpr(ycbcr));\n}\n// RGB to YCbCr\nvec3 rgb_ycbcr(vec3 rgb) {\n    return ypbpr_ycbcr(rgb_ypbpr(rgb));\n}\n\n//----------------------------------------------------------------------------\n\n// ITU-R BT.2020:\n// YcCbcCrc, linear\n// ranges: Y=0..1, b=-0.5..0.5, r=-0.5..0.5\n\n// YcCbcCrc to RGB\nvec3 yccbccrc_rgb(vec3 yccbccrc) {\n\treturn ypbpr_rgb(yccbccrc, vec2(0.0593, 0.2627));\n}\n\n// RGB to YcCbcCrc\nvec3 rgb_yccbccrc(vec3 rgb) {\n\treturn rgb_ypbpr(rgb, vec2(0.0593, 0.2627));\n}\n\n//----------------------------------------------------------------------------\n\n// YCoCg\n// ranges: Y=0..1, Co=-0.5..0.5, Cg=-0.5..0.5\n\nvec3 ycocg_rgb (vec3 ycocg) {\n    vec2 br = vec2(-ycocg.y,ycocg.y) - ycocg.z;\n    return ycocg.x + vec3(br.y, ycocg.z, br.x);\n}\n\nvec3 rgb_ycocg (vec3 rgb) {\n    float tmp = 0.5*(rgb.r + rgb.b);\n    float y = rgb.g + tmp;\n    float Cg = rgb.g - tmp;\n    float Co = rgb.r - rgb.b;\n    return vec3(y, Co, Cg) * 0.5;\n}\n\n//----------------------------------------------------------------------------\n\nvec3 yccbccrc_norm(vec3 ypbpr) {\n    vec3 p = yccbccrc_rgb(ypbpr);\n   \tvec3 ro = yccbccrc_rgb(vec3(ypbpr.x, 0.0, 0.0));\n    vec3 rd = normalize(p - ro);\n    vec3 m = 1./rd;\n    vec3 b = 0.5*abs(m)-m*(ro - 0.5);\n    float tF = min(min(b.x,b.y),b.z);\n    p = ro + rd * tF * max(abs(ypbpr.y),abs(ypbpr.z)) * 2.0;\n\treturn rgb_yccbccrc(p); \n}\n\nvec3 ycocg_norm(vec3 ycocg) {\n    vec3 p = ycocg_rgb(ycocg);\n   \tvec3 ro = ycocg_rgb(vec3(ycocg.x, 0.0, 0.0));\n    vec3 rd = normalize(p - ro);\n    vec3 m = 1./rd;\n    vec3 b = 0.5*abs(m)-m*(ro - 0.5);\n    float tF = min(min(b.x,b.y),b.z);\n    p = ro + rd * tF * max(abs(ycocg.y),abs(ycocg.z)) * 2.0;\n\treturn rgb_ycocg(p); \n}\n\n//----------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}\n\nfloat srgb_linear(float x) {\n    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));\n}\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));\n}\n\n//----------------------------------------------------------------------------\n\n// from https://www.shadertoy.com/view/4s23DR\nbool cylinder(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 0.25;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t// top, bottom\n\tvec2 zcap = vec2(0.5, -0.5);\n\tvec2 cap = (zcap - org.z) / dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 0.0 && far > near;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool huecylinder(vec3 ro, vec3 rd, vec3 p, float cap, float rscale, out vec3 uv) {\n    ro = ro.xzy;\n    rd = rd.xzy;\n    cap = max(cap, 0.0001);\n    ro -= p;\n    ro.z += 0.5;\n    ro.z /= cap;\n    rd.z /= cap;\n    ro.z -= 0.5;\n    \n    float near, far;\n    if (cylinder(ro, rd, near, far)) {\n        vec3 p = ro + rd * near;\n        \n        uv.x = (p.z + 0.5) * cap;\n        uv.x = srgb_linear(uv.x);\n        uv.yz = p.xy * rscale;\n#ifdef CLAMP_BICONE\n        float r = (1.0-abs(uv.x-0.5)*2.0) * 0.7071;\n        //float r = (1.0-abs(uv.x-0.5)*2.0) * 0.53235;\n        uv.yz *= r;\n#else\n        //uv.yz *= 1.1681404025202;\n#endif\n        uv = clamp(uv, vec3(0.0,-0.5,-0.5), vec3(1.0,0.5,0.5));\n        \n        return true;\n    }    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ms = iMouse.xy / iResolution.xy;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pd = uv * 2.0 - 1.0;\n    pd.x *= iResolution.x / iResolution.y;\n    \n    float a = iTime * 0.5;\n    vec3 ro = vec3(cos(a), 1.0, sin(a)) * 3.0;\n    mat3 m = calcLookAtMatrix(ro, vec3(0.0), 0.0);\n    vec3 rd = normalize(m * vec3(pd.xy,5.0));\n    \n    float cap = (iMouse.z > 0.5)?clamp(ms.y*2.0-0.5,0.0,1.0):(sin(iTime)*0.5+0.5);\n    float rscale = 1.0; //(iMouse.z > 0.5)?ms.x*2.0:1.0;\n    \n    vec3 color = vec3(0.0);\n    float near, far;\n    vec3 yuv;\n    if (huecylinder(ro, rd, vec3(0.0, 0.0, 0.0), cap, rscale, yuv)) {\n        vec3 p = ro + rd * near;\n#ifdef NORM_CHROMA\n        yuv = ycocg_norm(yuv);\n#endif\n        color = ycocg_rgb(yuv);\n        vec3 c = abs(color - 0.5);\n        if (max(c.r,max(c.g,c.b)) > 0.501)\n            color = vec3(0.5);\n    }\n \n#if 0\n    for (int i = 0; i < 10; ++i) {\n    \tcolor = rgb_ycocg(color);\n    \tcolor = ycocg_rgb(color);\n    }\n#endif\n    \n    color = linear_srgb(color);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSWH", "name": "Cracker Car (the close up)", "author": "zackpudil", "description": "It's a sequel...https://www.shadertoy.com/view/4sdXzr. With mouse controls.", "tags": ["raymarching", "distancefields"], "likes": 4, "viewed": 220, "date": "1458965909", "time_retrieved": "2024-06-20T18:32:59.836975", "image_code": "float hash(float n) {\n    return fract(sin(n)*43758.54523123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float n = i.x + i.y*57.0;\n    \n    return mix(\n        mix(hash(n), hash(n + 1.), f.x),\n        mix(hash(n + 57.), hash(n + 58.), f.x),\n        f.y);\n}\n\nfloat neLength(vec2 p, float l) {\n    return pow(\n       \tpow(abs(p.x), l) + pow(abs(p.y), l),\n        1.0/l);\n}\n\nfloat dCircleTorus(vec3 p, vec3 c, vec2 s) {\n    vec3 pc = p - c;\n    \n    vec2 d = vec2(length(pc.xy) - s.x, pc.z);\n    return neLength(d, 8.) - s.y;\n}\n\nfloat dSphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\nfloat dSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot2(ba), 0.0, 1.0);\n    \n    return length(pa - ba*h) - r;\n}\n\nfloat terrain(vec2 p) {\n    return 2.0*noise(0.5*p.xy);\n}\n\nstruct Car {\n    vec3 p;\n    vec3 wheels[4];\n};\n\nCar car;\n\nvoid initCar() {\n    vec3 carp = vec3(5.*iTime, 1, 0);\n    car.p = carp;\n    \n    for(int i = 0; i < 4; i++) {\n        vec3 w = carp - vec3(sign(float(i) - 1.5)*1.5, 0, sign(i == 0 ? 1. : float(i) - 2.5)*2.5);\n    \tw.y = 0.7 -  terrain(w.xz);\n        car.wheels[i] = w;\n    }\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p) {\n    float h = terrain(p.xz);\n    vec2 pl = vec2(p.y + h, 0.0);\n    \n    float wd = 20.0;\n    float rd = 20.0;\n    \n    vec3 ofh = vec3(.5, 0, 0);\n    vec3 ofv = vec3(0, .5, 0);\n    rotate(ofh.xy, -5.*iTime);\n    rotate(ofv.xy, -5.*iTime);\n    \n    for(int i = 0; i < 4; i++) {\n        wd = min(wd, dCircleTorus(p, car.wheels[i], vec2(.5, .1)));\n        \n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] + ofh, 0.05));\n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] - ofh, 0.05));\n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] + ofv, 0.05));\n        wd = min(wd, dSegment(p, car.wheels[i], car.wheels[i] - ofv, 0.05));\n    }\n    \n    float cd = 20.0;\n    \n    vec3 c1 = mix(car.wheels[0], car.wheels[1], .5);\n    c1.y += .80;\n    vec3 c11 = mix(c1, car.wheels[0] + vec3(0, .80, 0), .75);\n    vec3 c12 = mix(c1, car.wheels[1] + vec3(0, .80, 0), .75);\n                   \n    vec3 c2 = mix(car.wheels[2], car.wheels[3], .5);\n    c2.y += .80;\n    vec3 c21 = mix(c2, car.wheels[2] + vec3(0, .80, 0), .75);\n    vec3 c22 = mix(c2, car.wheels[3] + vec3(0, .80, 0), .75);\n    \n\twd = min(wd, dSegment(p, car.wheels[0], c11, 0.1));\n    wd = min(wd, dSphere(p, c11, 0.2));\n    wd = min(wd, dSegment(p, c11, c1, 0.1));\n    wd = min(wd, dSegment(p, c1, c12, 0.1));\n    wd = min(wd, dSphere(p, c12, 0.2));\n    wd = min(wd, dSegment(p, c12, car.wheels[1], 0.1));\n    \n   \twd = min(wd, dSegment(p, car.wheels[2], c21, 0.1));\n    wd = min(wd, dSphere(p, c21, 0.2));\n    wd = min(wd, dSegment(p, c21, c2, 0.1));\n    wd = min(wd, dSegment(p, c2, c22, 0.1));\n    wd = min(wd, dSphere(p, c22, 0.2));\n    wd = min(wd, dSegment(p, c22, car.wheels[3], 0.1));\n    \n\tvec3 c = mix(c1, c2, .5);\n\tp.y -= .5;\n    p.y *= 1.5;\n    vec3 cp = p - c;\n\n\n    float bd = 20.0;\n    bd = min(bd, dSegment(p*vec3(1, 1.2, 1) - vec3(0, 0.2, 0), c1, c2, 1.3));\n                 \n\tvec2 w = vec2(wd, 1.0);\n    vec2 b = vec2(bd, 2.0);\n    \n    return opU(pl, opU(w, b));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float td = 0.0;\n    float mid = -1.0;\n    \n    for(int i = 0; i < 64; i++) {\n        vec2 s = map(ro + rd*td);\n        if(abs(s.x) < 0.001 || td >= 50.0) break;\n        \n        td += s.x*0.75;\n        mid = s.y;\n    }\n    \n    if(td >= 50.0) mid = -1.0;\n    return vec2(td, mid);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n\t);\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    float td = 0.2;\n    float res = 1.0;\n    \n    for(int i = 0; i < 30; i++) {\n        float h = map(p + l*td).x;\n        td += h*.5;\n        res = min(res, 2.0*h/td);\n        if(abs(h) < .0001 || td > 10.) break;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd) {\n    vec3 n = normal(p);\n    vec3 l = normalize(lp);\n    vec3 r = reflect(rd, n);\n    \n    float amb = clamp(0.7 + 0.3*n.y, 0., 1.);\n    float dif = clamp(dot(l, n), 0., 1.);\n    float spe = pow(clamp(dot(r, l), 0., 1.0), 16.);\n    float fre = pow(clamp(1. + dot(n, rd), 0., 1.0), 2.);\n    float dom = smoothstep(-.1, .2, r.y);\n    \n    dif *= shadow(p, l);\n    \n    vec3 lin = vec3(0);\n    \n    lin += .5*amb;\n    lin += dif*vec3(1, .97, .85);\n    lin += 2.0*spe*vec3(1, .87, 1)*dif;\n    lin += 2.0*fre*vec3(1)*dif;\n    lin += 0.3*dom*vec3(1);\n    \n    return lin;\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 rl = vec3(0, 1, 0);\n    vec3 f = normalize(l - e);\n    vec3 r = cross(rl, f);\n    vec3 u = cross(f, r);\n    \n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    initCar();\n    \n    float s = 0.01*iMouse.x;\n    vec3 ro = car.p + 8.0*vec3(cos(s), 0.5, -sin(s));\n    vec3 rd = camera(ro, car.p)*normalize(vec3(uv, 2.0));\n    \n    vec3 col = vec3(.34, .54, .89);\n\tcol *= mix(0.6, 1.0, uv.y);\n    \n    vec2 i = intersect(ro, rd);\n    vec3 p = ro + rd*i.x;\n    \n    if(i.y == 0.0) col = vec3(.75, 0, .85)*.5;\n    if(i.y == 1.0) col = vec3(.7, .4, .5)*.1; \n    if(i.y == 2.0) col = vec3(.95, .34, 0)*.5;\n    \n    if(i.y != -1.0) col *= lighting(p, vec3(0, 2, -1), rd);\n    \n    col = pow(col, vec3(.454545));\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcSz4", "name": "spectrum #1", "author": "davin", "description": "color", "tags": ["color"], "likes": 1, "viewed": 101, "date": "1457823607", "time_retrieved": "2024-06-20T18:32:59.836975", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\nvec2 uv = fragCoord.xy / iResolution.xy;\n    highp float pi = 3.14159265;\n    fragColor = vec4(0.5 + sin(iTime*30.0 + (uv.x + uv.y) * 27.0 + 2.0*pi/3.0)/2.0,\n                     0.5 + sin(iTime*30.0 + (uv.x + uv.y) * 27.0 + 2.0 * 2.0 * pi / 3.0)/2.0,\n                     0.5 + sin(iTime*30.0 + (uv.x + uv.y) * 27.0)/2.0,\n                     0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dcXWH", "name": "Life Spirit", "author": "JoNil", "description": " ", "tags": ["noise"], "likes": 7, "viewed": 147, "date": "1458936780", "time_retrieved": "2024-06-20T18:33:00.291342", "image_code": "#define PI 3.14159265359\n\nfloat hash(in vec2 p, float scale)\n{\n    return fract(sin(mod(p.x, scale)*17.31758341 + p.y*39.786792357 - 7.5312) * 43758.236237153);\n}\n\n// iqnoise adapted from voronoise (Perlin noise)\n// this version uses radial symmetry\nfloat iqnoise(float radius, float angle, float angle_scale)\n{\n    angle *= angle_scale;\n    \n    vec2 p = floor(vec2(angle, radius));\n    vec2 f = fract(vec2(angle, radius));\n    \n    float va = 0.0;\n    float wt = 0.0;\n    \n    for (int j = -1; j <= 2; j++) {\n        for (int i = -1; i <= 2; i++) {\n            \n            if (i+j>3 || i+j<-1) {\n                continue;\n            }\n            if (i-j>2 || i-j<-2) {\n                continue;\n            }\n            \n            vec2 g = vec2(float(i),float(j));\n            float o = hash(p + g, angle_scale);\n            vec2 r = g - f ;\n            float d = dot(r,r);\n            float ww =  1.0 - smoothstep(0.0, 1.4142, sqrt(d));\n            va += o*ww;\n            wt += ww;\n        }\n    }\n    \n    return 2.0*va/wt - 1.0;\n}\n\n\nvec3 core(vec2 p, float r)\n{\n    float final1 = iqnoise(30.0*p.x*pow(r, 0.55)- 0.5*iTime, p.y*pow(r, 0.55), 30.0) * 4.0;\n    float final2 = iqnoise(30.0*p.x*pow(r, 0.6)- 0.5*iTime, p.y*pow(r, 0.6), 30.0) * 4.0;\n    float final3 = iqnoise(30.0*p.x*pow(r, 0.65)- 0.5*iTime, p.y*pow(r, 0.65), 30.0) * 4.0;\n    \n    return mix(vec3(final1, final2, final3), vec3(0.0, 0.0, 0.0), clamp(r, 0.0, 1.0));\n}\n\nvec3 edge(float r, float phi)\n{\n    float radial1 = iqnoise(10.0 * r - 0.3*iTime, phi + 0.01*sin(19.5 * r - iTime), 80.0) * 4.0;\n    float final1 = mix(radial1, 0.0, 1.0 - r);\n    \n    float radial2 = iqnoise(10.0 * r - 0.3*iTime, phi + 0.01*sin(20.0 * r - iTime), 80.0) * 4.0;\n    float final2 = mix(radial2, 0.0, 1.0 - r);\n    \n    float radial3 = iqnoise(10.0 * r - 0.3*iTime, phi + 0.01*sin(20.5 * r - iTime), 80.0) * 4.0;\n    float final3 = mix(radial3, 0.0, 1.0 - r);\n\n    vec3 color = vec3(final1, final2, final3);\n    \n    return mix(color, vec3(0.0, 0.0, 0.0), clamp(r*r*r, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = (uv - 0.5) * 2.0 * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float r = sqrt(dot(p, p));\n    float phi = atan(p.x, p.y) / (2.0 * PI);\n    \n    vec3 edge_color = edge(r, phi);\n    vec3 core_color = core(p, r);\n    \n        \n    fragColor = vec4(mix(edge_color, core_color, clamp(1.0 - (atan(80.0*(r - 0.55 - 0.03*sin(iTime))) / PI + 0.5), 0.0, 1.0)), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dcXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddXW4", "name": "Noise 3D Fly Through", "author": "revers", "description": "Flying through 3D noise.", "tags": ["blobs", "tunnel", "noise3d"], "likes": 129, "viewed": 9003, "date": "1459359372", "time_retrieved": "2024-06-20T18:33:01.497504", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader, as always, uses a lot of code (raymarching, noise and lighting) credited to iq \n * [ https://www.shadertoy.com/view/Xds3zN ]. \n * Camera path is based on Shane's \"Subterranean Fly-Through\" [ https://www.shadertoy.com/view/XlXXWj ].\n * Additional specular lighting trick is based on \"Wet stone\" by TDM [ https://www.shadertoy.com/view/ldSSzV ].\n * Thanks for sharing great code guys!\n * \n * The shader was created and exported from Synthclipse [ http://synthclipse.sourceforge.net/ ].\n */\nconst float FOV = 0.4;\nconst float MarchDumping = 0.7579;\nconst float Far = 38.925;\nconst int MaxSteps = 128;\nconst float CameraSpeed = 4.5099998;\nconst float TunnelSmoothFactor = 2.0;\nconst float TunnelRadius = 0.85660005;\nconst float TunnelFreqA = 0.18003;\nconst float TunnelFreqB = 0.25;\nconst float TunnelAmpA = 3.6230998;\nconst float TunnelAmpB = 2.4324;\nconst float NoiseIsoline = 0.319;\nconst float NoiseScale = 2.9980001;\nconst vec3 Color = vec3(0.085, 0.658, 1.0);\n\n#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise(p);\n\n\treturn f;\n}\n\n// by iq. http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// From \"Subterranean Fly-Through\" by Shane https://www.shadertoy.com/view/XlXXWj\nvec2 path(float z) {\n\treturn vec2(TunnelAmpA * sin(z * TunnelFreqA), TunnelAmpB * cos(z * TunnelFreqB));\n}\n\nfloat noiseDist(vec3 p) {\n\tp = p / NoiseScale;\n\treturn (fbm(p) - NoiseIsoline) * NoiseScale;\n}\n\nvec2 map(vec3 p) {\n\tfloat d = noiseDist(p);\n\tfloat d2 = length(p.xy - path(p.z)) - TunnelRadius;\n\td = smax(d, -d2, TunnelSmoothFactor);\n\n\tvec2 res = vec2(d, M_NOISE);\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = M_NONE;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = M_NONE;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\t// material\n\t\tcol = Color + sin(t * 0.8) * 0.3;\n\t\tcol += 0.3 * sin(vec3(0.15, 0.02, 0.10) * iTime * 6.0);\n\n\t\t// lighitng\n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = -rd;\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);\n\t\tbrdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\t// Additional specular lighting trick,\n\t\t// taken from \"Wet stone\" by TDM\n\t\t// https://www.shadertoy.com/view/ldSSzV\n\t\tnor = normalize(nor - normalize(pos) * 0.2);\n\t\tref = reflect(rd, nor);\n\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\t\tbrdf += 2.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\tbrdf += 0.40 * amb * vec3(0.50, 0.70, 1.00) * occ;\n\t\tbrdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n\t\tcol = col * brdf;\n\n\t\tcol = mix(col, vec3(0.0), 1.0 - exp(-0.005 * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 rotationZ(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\n\treturn mat3(ca, sa, 0.0, -sa, ca, 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tcoord *= FOV;\n\n    float t = iTime * CameraSpeed + 4.0 * 60.0;\n    vec3 ro = vec3(path(t), t);\n\n    t += 0.5;\n    vec3 target = vec3(path(t), t);\n    vec3 dir = normalize(target - ro);\n    vec3 up = vec3(-0.9309864, -0.33987653, 0.1332234) * rotationZ(iTime * 0.05);\n    vec3 upOrtho = normalize(up - dot(dir, up) * dir);\n    vec3 right = normalize(cross(dir, upOrtho));\n\n    vec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ddXzN", "name": "test rays", "author": "divinus", "description": "test rays", "tags": ["rays"], "likes": 53, "viewed": 2423, "date": "1458055236", "time_retrieved": "2024-06-20T18:33:02.225004", "image_code": "vec4 lookup(sampler2D src, float x, float y)\n{\n\treturn texture(src, vec2(x / iResolution.x, y / iResolution.y));\n}\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n{\n\tvec2 sourceToCoord = coord - raySource;\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n\t\n\treturn clamp(\n\t\t(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed)) +\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed)),\n\t\t0.0, 1.0) *\n\t\tclamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);\n}\n\nfloat bubbleStrength(vec2 startPos, vec2 waveOffset, float radius, float speed, vec2 coord)\n{\n\tvec2 curPos = vec2(\n\t\tmod(startPos.x + waveOffset.x * 0.5, iResolution.x + radius * 2.0) - radius,\n\t\tmod(waveOffset.y - iTime * speed, iResolution.y + radius * 2.0) - radius);\n\treturn 1.0 - smoothstep(0.0, radius, length(coord - curPos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\tvec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\t\n\t// Calculate the lookup transformation offset for the current fragment\n\tfloat offsetX = (0.1112 * iResolution.x * cos(1.44125 * (iTime + uv.y))) + (26.77311 * iTime);\n\tfloat offsetY = (0.08447 * iResolution.y * sin(2.14331 * (iTime + uv.x)));\n\t\n\t// Use parallax transformed lookup on the texture layers\n\tvec4 tex1 = lookup(iChannel0, coord.x + offsetX, coord.y + offsetY);\n\tvec4 tex2 = lookup(iChannel1, coord.x * 2.0 + offsetX * 1.6, coord.y * 2.0 + offsetY * 1.5);\n\tvec4 tex3 = lookup(iChannel2, coord.x * 3.0 + offsetX * 1.3, coord.y * 3.0 + offsetY * 1.2);\n\tvec4 tex4 = lookup(iChannel3, coord.x * 0.5 + offsetX * 0.8, coord.y * 0.5 + offsetY * 0.9);\n\t\n\t// Set the parameters of the sun rays\n\tvec2 rayPos1 = vec2(iResolution.x * 0.7, iResolution.y * -0.4);\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\tfloat raySeedA1 = 36.2214;\n\tfloat raySeedB1 = 21.11349;\n\tfloat raySpeed1 = 1.5;\n\t\n\tvec2 rayPos2 = vec2(iResolution.x * 0.8, iResolution.y * -0.6);\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\tfloat raySeedA2 = 22.39910;\n\tfloat raySeedB2 = 18.0234;\n\tfloat raySpeed2 = 1.1;\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n\tvec4 rays1 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1);\n\t \n\tvec4 rays2 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2);\n\t\n\t\n\t// Calculate the colours contribution of each bubble on the current fragment.\n\tfloat bubbleScale = iResolution.x / 600.0;\n\t\n\tvec4 bubble1 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(0.0, 0.0), vec2(offsetX * 0.2312, 0.0), 20.0 * bubbleScale, 60.0, coord);\n\t\n\tvec4 bubble2 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(40.0, 400.0), vec2(offsetX * -0.06871, offsetY * 0.301), 7.0 * bubbleScale, 25.0, coord);\n\t\n\tvec4 bubble3 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(300.0, 70.0), vec2(offsetX * 0.19832, offsetY * 0.1351), 14.0 * bubbleScale, 45.0, coord);\n\t\n\tvec4 bubble4 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(500.0, 280.0), vec2(offsetX * -0.0993, offsetY * -0.2654), 12.0 * bubbleScale, 32.0, coord);\n\t\n\tvec4 bubble5 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(400.0, 140.0), vec2(offsetX * 0.2231, offsetY * 0.0111), 10.0 * bubbleScale, 28.0, coord);\n\t\n\tvec4 bubble6 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(200.0, 360.0), vec2(offsetX * 0.0693, offsetY * -0.3567), 5.0 * bubbleScale, 12.0, coord);\n\t\n\tvec4 bubble7 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(0.0, 0.0), vec2(offsetX * -0.32301, offsetY * 0.2349), 16.0 * bubbleScale, 51.0, coord);\n\t\n\tvec4 bubble8 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(130.0, 23.0), vec2(offsetX * 0.1393, offsetY * -0.4013), 8.0 * bubbleScale, 24.0, coord);\n\t\t\n\t\n\t// Blend all of the elements together.\n\t// This deliberately saturates the colour in places.\n\tfragColor = \n\t\ttex1 * 0.45 +\n\t\ttex2 * 0.25 +\n\t\ttex3 * 0.15 +\n\t\ttex4 * 0.1 +\n\t\trays1 * 0.5 +\n\t\trays2 * 0.4 +\n\t\tbubble1 * 0.25 +\n\t\tbubble2 * 0.1 +\n\t\tbubble3 * 0.18 +\n\t\tbubble4 * 0.13 +\n\t\tbubble5 * 0.15 +\n\t\tbubble6 * 0.05 +\n\t\tbubble7 * 0.12 +\n\t\tbubble8 * 0.11;\n\t\n\t// Uncomment this line if you want to see just the rays:\n\t//fragColor = rays1 * 0.5 + rays2 * 0.5;\n\t\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\t// Give the whole thing a blue-green tinge as well.\n\tfloat brightness = 1.0 - (coord.y / iResolution.y);\n\tfragColor.x *= 0.2 + (brightness * 0.8);\n\tfragColor.y *= 0.3 + (brightness * 0.7);\n\tfragColor.z *= 0.4 + (brightness * 0.6);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ddXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dG3Dd", "name": "Playing with cubes II", "author": "ManuManu", "description": "Same as previous \"Playing with cubes\" shader, but this one with bending the space...\nProbably as looking the previous one under acids...", "tags": ["raymarching", "cubes", "bendingspace"], "likes": 3, "viewed": 621, "date": "1456961246", "time_retrieved": "2024-06-20T18:33:02.230943", "image_code": "\n\n//#define CURVE_WORLD\n\n#define FISH_EYE1 0\n#define FISH_EYE2 0\n#define FISH_EYE3 1\n\n\n#define NB_ITER 256\n#define FAR \t200.\n\n#define PI 3.14159265\n\n\nvec3 skyColor( vec2 uv)\n{\n    return vec3(.0);\n\tvec3 colEdge \t= vec3(.1, .5, .3);\n\tvec3 colCenter  = vec3(.0);\n\treturn mix (colEdge, colCenter, 1.-length(uv ) / .9);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n\treturn max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\n\nvec3 rotationPos( vec3 pos, float angle )\n{\n    angle = mod(angle, 2.*PI);\n    float c=cos(angle);\n    float s=sin(angle);\n    mat3 m = mat3( 1., 0., 0.,\n                   0.,  c,  s,\n                   0., -s,  c );\n    return m*pos;\n}\n\nfloat cubeDist( vec3 pos, float radius)\n{\n    return Mylength( pos ) - radius;\n}\n\nfloat timeBorner( float t, float t1, float t2)\n{\n    return step( t1, t ) * ( 1.-step( t2, t ));\n}\n\n// 25 seconds\nvec3 intro( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    pos.z += 65.;\n    \n    if ( t > 10.)\n    {\n        if ( t > 20.)\n            pos.z -= 65.;\n        else\n            pos.z -= mix( .0, 65., (t-10.)/10.);\n    }       \n            \n    pos = rotationPos(pos, PI*3.*cos(.3*t));\n \n    return pos;\n}\n// 50 seconds\nvec3 firstPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    float s = .0;\n    float upperlimit =  30.*timeBorner(t, 0., 5.)+\n        \t\t\t\t20.*timeBorner(t, 5., 10.)+\n        \t\t\t\t10.*timeBorner(t, 10., 15.)+\n        \t\t\t\t03.*timeBorner(t, 15., 49.);\n    float upperlimity = 30.*timeBorner(t, 20., 23.)+\n        \t\t\t\t10.*timeBorner(t, 23., 27.)+\n        \t\t\t\t03.*timeBorner(t, 27., 42.);\n    float sint = 3.*sin( 2.*t / PI );\n    float dist = mod(2.*sint, upperlimit);\n    float disty = mod(2.*t, upperlimity);\n    float i2 = mod( i, upperlimit);\n    float j2 = mod( j, upperlimity);\n    s = PI*t * (1.-step( dist, i2) ) * step( dist, i2 +1.);\n    if ( t > 20.)\n    \ts+=PI*t * (1.-step( disty, j2) ) * step( disty, j2 +1.);\n \tpos = rotationPos( pos, s );\n    return pos;\n}\n// 40 seconds\nvec3 secondPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    i-= 18.;\n    j-= 17.;\n\n    float s = .0;\n    const float upperlimit = 100.;\n    float dist = mod(5.*t, upperlimit); \n    s =PI*t * (1.-step( dist, i*i+j*j) );\n    if (t > 20.)\n    \tcol = mix(col1, col2, (1.-step( dist, i*i+j*j) ));\n \tpos = rotationPos( pos, s );\n    return pos;\n}\n// 70 seconds\nvec3 thirdPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    i-= 18.;\n    j-= 17.;\n    \n\tif ( t > 35.)\n    {\n        pos.z -= mix( .0, 120., (t-35.)/35.);\n    }\n    \n    float i2 = mod( i + 15., 30.)-15.;\n    float j2 = mod( j + 15., 30.)-15.;\n\n\n    float s = .0;\n    float dist = 60. + 40.*cos(5.*t);\n    col = mix(col1, col2, (1.-step( dist, i2*i2+j2*j2) ));\n    \n\ts += sin(t+j)*sin(t+j)\t\t\t\t\t\t   * timeBorner(t, .0, 5.);\n    s += (5.*i + 8.*j + iTime) \t\t\t   * timeBorner(t, 5., 10.);\n    s += sin(t+j)*sin(t+j) * sin(t+i)*sin(t+i)\t   * timeBorner(t, 10., 15.);\n    s += sin(t + i - j )\t\t\t\t\t\t   * timeBorner(t, 15., 20.);\n    s += sin( .01*(i*i) - 5.*iTime)\t\t   * timeBorner(t, 20., 25.);\n    s += sin( .01*(j*j) - 5.*iTime)\t\t   * timeBorner(t, 25., 30.);\n    s += sin( .01*(i*i+j*j) - 2.*iTime)\t   * timeBorner(t, 30., 35.);\n \tpos = rotationPos( pos, s );\n\n    return pos;\n}\nvec3 fourthPart( float t, vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    \n    i-= 18.;\n    j-= 17.;\n    \n    pos.z -= mix( 0., 120., 1.-t/40.);\n    \n    float i2 = mod( i + 15., 30.)-15.;\n    float j2 = mod( j + 15., 30.)-15.;\n\n\n    float s = .0;\n    float dist = 60. + 40.*cos(5.*t);\n    float val1 = .5 + .5*sin( 5.*i + 8.*j + 20.* t);\n    float val2 = .5 + .5*sin( .01*(i*i+j*j) - 2.*iTime);\n    float val = mix( val1, val2, mod( t, 20.) / 20. );\n    if ( t > 20.)\n    \tval = mix( val1, val2, mod( t, 20.) );\n    col = mix(col1, col2, val);\n    \n    \n\ts += sin(t+j)*sin(t+j)\t\t\t\t\t\t   * timeBorner(t, .0, 5.);\n    s += (5.*i + 8.*j + iTime) \t\t\t   * timeBorner(t, 5., 10.);\n    s += sin(t+j)*sin(t+j) * sin(t+i)*sin(t+i)\t   * timeBorner(t, 10., 15.);\n    s += sin(t + i - j )\t\t\t\t\t\t   * timeBorner(t, 15., 20.);\n    s += sin( .01*(i*i) - 5.*iTime)\t\t   * timeBorner(t, 20., 25.);\n    s += sin( .01*(j*j) - 5.*iTime)\t\t   * timeBorner(t, 25., 30.);\n    s += sin( .01*(i*i+j*j) - 2.*iTime)\t   * timeBorner(t, 30., 35.);\n \tpos = rotationPos( pos, s );\n\n    return pos;\n}\n\nvec3 choreo( vec3 pos, float i, float j, inout vec3 col)\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    col = col1;\n\n    float t;\n    vec3 p;\n    \n    // for tests :\n    //t = mod(iTime, 40.);\n\t//p = fourthPart(t, pos, i, j, col);\n    \n  \n\tt = mod(iTime, 250.);\n    if ( t < 25.)\n        p = intro( t, pos, i, j, col);\n\telse if ( t < 75.)\n\t\tp = firstPart( t-25., pos, i, j, col);\n\telse if ( t < 115.)\n\t\tp = secondPart( t-75., pos, i, j, col);\n\telse if ( t < 185.)\n\t\tp = thirdPart( t-115., pos, i, j, col);\n    else if ( t < 225.)\n\t\tp = fourthPart( t-185., pos, i, j, col);\n\telse\n        p = intro( 250.-t, pos, i, j, col);\n    return p;\n}\n\nvec4 cubes(vec3 pos )\n{\n    vec3 col1 = vec3(.8, .0, .1 );\n    vec3 col2 = vec3(.3, .8, .6 );\n    pos.z -= 70.;\n\n    const float repVal = 2.;\n\n    //indexes :\n\tfloat i = float( int ( (pos.x+2.) / 4. ) );\n    float j = float( int ( (pos.y+2.) / 4.) );\n\n    \n    // repetition :\n    pos = vec3( mod( pos.x + repVal, 2.*repVal) - repVal,\n                mod( pos.y + repVal, 2.*repVal) - repVal,\n                pos.z);\n    \n    vec3 col;\n    pos = choreo( pos, i, j, col );\n    float dist = cubeDist( pos, 1.);\n    return vec4( col, dist);\n}\n\nvec4 map( vec3 pos)\n{\n\treturn cubes(pos);\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -= .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t//uv.x += cos( 10.*uv.y)*1.;\n    float time = iTime;\n\n#if FISH_EYE1\n\tfloat fish_eye =  -length(uv)*1.+ .2*sin(time);\n#elif FISH_EYE2\n\tfloat fish_eye = sin(5.*uv.x + time*1.) + sin(5.*uv.y+time*.5) + 1.;\n#elif FISH_EYE3\n\tfloat fish_eye1 =  -length(uv)*1.+ .2*sin(time);\n\tfloat fish_eye2 = sin(5.*uv.x + time*1.) + sin(5.*uv.y+time*.5) + 1.;\n\tfloat fish_eye = mix( fish_eye1, fish_eye2, .5+.5*sin(time) );\n#else\n\tfloat fish_eye =  0.;\n#endif\n\tvec3 dir = vec3( uv, 1.0 + fish_eye);\n\tdir = normalize(dir);\n\t\n#ifdef CURVE_WORLD\n\tvec3 pos = vec3( 20.*sin(time), 8.1, 20.*cos(time));\n#else\n    vec3 pos = vec3( 70.0, 70.0, .0);\n#endif // CURVE_WORLD\n\t\n\tfloat nbIterF = 0.;\n\tvec4 result;\n\tfor (int i =0; i < NB_ITER; i++)\n\t{\n\t\tresult = map( pos );\n\t\tpos += result.w * dir;\n\t\tif ( (pos.z > FAR) || (abs(result.w) < .001)) \n            break;\n\t\tnbIterF += 1.0;\n#ifdef CURVE_WORLD\n\t\tdir.xy=rot(dir.xy,result.w*0.021);\n\t\tdir.yz=rot(dir.yz,result.w*0.01);\n\t\tdir.zx=rot(dir.zx,result.w*0.01);\n#endif // CURVE_WORLD\n    }\n\tvec3 col = result.xyz;\n\tif ( pos.z> FAR ) \n\t{\n\t\tcol = skyColor(uv);\n\t}\n\telse\n\t{\n\t\tvec3 lightPos = vec3(1.* sin(3.*iTime) + 100., 8.5, 1.*cos(3.*iTime)  - 200. );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .0, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\tn = normalize(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos))+.2;\n\t\tcol *= vec3(lambert);\n\t\t\n\t\n\t\t// specular : \n\t\tvec3 h = normalize( -dir + light2Pos);\n\t\tfloat spec = max( 0., dot( n, h ) );\n\t\tcol += vec3(pow( spec, 32.));\n\t}\n\tfragColor= vec4( col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dG3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dGGWt", "name": "Conservative Raymarching", "author": "paniq", "description": "Establishing an approximate conservative interior and exterior limit of a SDF contour, as required by processes like anti-aliasing and resolution refinement.", "tags": ["raymarching", "antialiasing", "silhouette", "conservative", "refinement"], "likes": 36, "viewed": 2573, "date": "1456896559", "time_retrieved": "2024-06-20T18:33:03.600768", "image_code": "\n// thanks to Sebastian Aaltonen for dropping the final clue that\n// finally enabled me to fix this implementation\n\n#define MAX_STEPS 50\n\n// undef to disable hole, then parameter s.w not needed\n// #define CONVEX\n\n// sdUberprim with precomputed constants\nfloat sdUnterprim(vec3 p, vec4 s, vec3 r, vec2 ba, float sz2) {\n    vec3 d = abs(p) - s.xyz;\n    float q = length(max(d.xy, 0.0)) + min(0.0,max(d.x,d.y)) - r.x;\n    // hole support: without this line, all results are convex\n#ifndef CONVEX    \n    q = abs(q) - s.w;\n#endif\n    \n    vec2 pa = vec2(q, p.z - s.z);\n    vec2 diag = pa - vec2(r.z,sz2) * clamp(dot(pa,ba), 0.0, 1.0);\n    vec2 h0 = vec2(max(q - r.z,0.0),p.z + s.z);\n    vec2 h1 = vec2(max(q,0.0),p.z - s.z);\n    \n    return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n        * sign(max(dot(pa,vec2(-ba.y, ba.x)), d.z)) - r.y;\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nfloat sdUberprim(vec3 p, vec4 s, vec3 r) {\n    // these operations can be precomputed\n    s.xy -= r.x;\n#ifdef CONVEX  \n    r.x -= r.y;\n#else\n    r.x -= s.w;\n    s.w -= r.y;\n#endif\n    s.z -= r.y;\n    vec2 ba = vec2(r.z, -2.0*s.z);\n    return sdUnterprim(p, s, r, ba/dot(ba,ba), ba.y);\n}\n\n// example parameters\n#define SHAPE_COUNT 9.0\nvoid getfactor (int i, out vec4 s, out vec3 r) {\n    //i = 4;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec3(0.0);\n    } else if (i == 1) { // cylinder\n        s = vec4(1.0);\n        r = vec3(1.0,0.0,0.0);\n    } else if (i == 2) { // cone\n        s = vec4(0.0,0.0,1.0,1.0);\n        r = vec3(0.0,0.0,1.0);\n\t} else if (i == 3) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 4) { // sphere\n        s = vec4(1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 5) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 6) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 7) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(1.0,0.1,0.0);\n    } else if (i == 8) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(0.1,0.1,0.0);\n\t}\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat doobject (vec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec3 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdUberprim(p.zyx, mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nfloat doModel( vec3 p ) {\n    float k = iTime*0.5;\n    float d = doobject(p - vec3(0.0,0.0,-0.5), k);\n    float d2 = doobject(p - vec3(0.0,0.0,0.5), k + 1.0);\n    if (interior)\n    \td = min(d, d2);\n   \telse\n    \td = smin(d, d2, 0.4);\n    \n    return d;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = max(pixel.y,pixel.x) / sqrt(2.0);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        steps = i;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;\n\t    float h = doModel( ro+rd*t );\n        t = (t + h)*A;\n    \tif((h <= limit) || (t > maxd)) {\n            break;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;    \n    \n    interior = false;\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n\n    float K = 8.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 hresolution = floor((iResolution.xy + (K - 1.0)) / K);\n    vec2 hfragCoord = floor(uv * hresolution) + 0.5;\n    interior = false;\n    vec3 pos_inner;\n    int steps_inner;\n    bool hit_inner = dorender(dist_inner, steps_inner, pos_inner, hfragCoord, hresolution, -1.0);\n    interior = false;\n    vec3 pos_outer;\n    int steps_outer;\n    bool hit_outer = dorender(dist_outer, steps_outer, pos_outer, hfragCoord, hresolution, 1.0);\n    \n    fragColor = vec4(vec3(0.0),1.0);\n#if 1\n    if (hit_outer) {\n        if (hit_inner) {\n            if (hit) {\n\t        \tvec3 nor = calcNormal(pos);\n            \tfragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n            } else {\n                // must not happen\n                fragColor = vec4(vec3(1.0),1.0);\n            }\n        } else if (hit)\n            fragColor.g = 1.0;\t\n        else\n        \tfragColor.r = 1.0;\n\t} else if (hit) {\n        // must not happen\n        fragColor = vec4(vec3(1.0),1.0);\n    }\n    \n    #if 1\n    if (hit) {\n        // outer shell always closer than surface\n        if (dist < dist_outer)\n            fragColor = vec4(1.0,0.7,0.0,1.0);\n       \t// inner shell always contained within surface\n        else if (hit_inner && (dist_inner < dist))\n            fragColor = vec4(1.0,0.7,1.0,1.0);\n    }\n    #endif\n#else\n    vec3 c0 = normhue(float(steps_outer)/float(MAX_STEPS));\n    vec3 c1 = normhue(float(steps_inner)/float(MAX_STEPS));\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    \n    fragColor = vec4((c0 + c1 + c2)/3.0,1.0);\n#endif\n}", "image_inputs": [{"id": "4dX3zn", "previewfilepath": "/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dVGDt", "name": "Approx Analytic Area Light", "author": "neoragex2002", "description": "modified from 1) dys129's demo (https://www.shadertoy.com/view/4tXSR4)  and be updated to 2) pascal's recent approx method (http://pascal.lecocq.home.free.fr/publications/lecocq_i3D2016_specularAreaLighting.pdf)", "tags": ["arealight"], "likes": 33, "viewed": 1273, "date": "1457108226", "time_retrieved": "2024-06-20T18:33:05.619098", "image_code": "#define PI 3.14159265359\n\n#define MAT_ID_LIGHT 3.\n#define saturate(a) clamp(a, 0.,1.)\n\n/*\nSet USE_APPROX to 0 to use reference solution (Arvo 1995)\nSet USE_APPROX to 1 to use Siggraph 2015: Accurate Analytic Approximations for Real-Time Specular Area Lighting\n*/\n#define USE_APPROX 1\n\n//0 - for triangle area light\n//1 - for quad area light\n#define AREA_LIGHT_TYPE 1\n\nvec3 lightClr = vec3(0.7, 0.0, 0.0);\n\n//------------------------------------------------------------\n//approx method\n#define PEARSON_VII 1\n\n//specular power\n#define ODD 0\nconst int N = 100;\n\n//------------------------------------------------------------\n#if AREA_LIGHT_TYPE==0\n#define NUM_VERTS 3\nvec3 get_arr(int i)\n{\n\t//right hand+Y up\n\tif (i == 0) return vec3(0.1, 0.01, 0.01);\n\tif (i == 1) return vec3(-0.5, 2.0, 0.02);\n\tif (i == 2) return vec3(0.5, 2.0, 0.03);\n\n\treturn vec3(0.);\n}\n#elif AREA_LIGHT_TYPE==1\n#define NUM_VERTS 6\nvec3 get_arr(int i)\n{\n\t//right hand+Y up\n\tif (i == 0) return vec3(1.0, 0.1, 0.0);\n\tif (i == 1) return vec3(-1.0, 0.1, 0.0);\n\tif (i == 2) return vec3(-1.0, 2.0, 0.0);\n\n\tif (i == 5) return vec3(-1.0, 2.0, 0.0);\n\tif (i == 3) return vec3(1.0, 2.0, 0.0);\n\tif (i == 4) return vec3(1.0, 0.1, 0.0);\n\n\treturn vec3(0.);\n}\n#endif\n\n\nfloat plane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sphere(vec3 ro, float r)\n{\n\treturn length(ro) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n\tvec3 ba = b - a; vec3 pa = p - a;\n\tvec3 cb = c - b; vec3 pb = p - b;\n\tvec3 ac = a - c; vec3 pc = p - c;\n\tvec3 nor = cross(ba, ac);\n\n\treturn sqrt(\n\t\t(sign(dot(cross(ba, nor), pa)) +\n\t\tsign(dot(cross(cb, nor), pb)) +\n\t\tsign(dot(cross(ac, nor), pc)) < 2.0)\n\t\t?\n\t\tmin(min(\n\t\tdot2(ba*clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),\n\t\tdot2(cb*clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),\n\t\tdot2(ac*clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc))\n\t\t:\n\t\tdot(nor, pa)*dot(nor, pa) / dot2(nor));\n}\n\nvec2 scene(vec3 ro)\n{\n\tvec2 polygon = vec2(1000.0, 0.);\n\n\tfor (int i = 0; i < NUM_VERTS; i += 3)\n\t{\n\t\tpolygon = opU(polygon, vec2(udTriangle(ro, get_arr(i), get_arr(i + 1), get_arr(i + 2)), MAT_ID_LIGHT));\n\t}\n\tvec2 pl0 = vec2(plane(ro), 0.0);\n\n\treturn opU(polygon, pl0);\n}\n\nvec4 getMaterial(float mat_id)\n{\n\tif (mat_id == 0.0) return vec4(1.0, 1.0, 1.0, 0.0);\n\telse if (mat_id == 1.0) return vec4(0.0, 1.0, 0.0, 0.0);\n\telse if (mat_id == 2.0) return vec4(1.0, 0.0, 0.0, 0.0);\n\telse if (mat_id == MAT_ID_LIGHT) return vec4(1.0, 1.0, 1.0, 0.0);\n\treturn vec4(0.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec3 eps = vec3(0.01, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tscene(pos + eps.xyy).x - scene(pos - eps.xyy).x,\n\t\tscene(pos + eps.yxy).x - scene(pos - eps.yxy).x,\n\t\tscene(pos + eps.yyx).x - scene(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\n\nfloat cosine_sine_power_integral_sum(float theta, float cos_theta, float sin_theta,\n\tint n, float a, float b)\n{\n\tfloat f = a*a + b*b;\n\tfloat g = a*cos_theta + b*sin_theta;\n\tfloat gsq = g*g;\n\tfloat asq = a*a;\n\tfloat h = a*sin_theta - b*cos_theta;\n\tfloat T, Tsum;\n\tfloat l, l2;\n\tint start;\n\n\t/* initial conditions for recurrence */\n\t//if (n&1) {\n\t/*T = h+b;\n\tl = gsq*h;\n\tl2 = b*asq;\n\tstart = 1;*/\n\t/*} else { */\n\n\tT = theta;\n\tl = g*h;\n\tl2 = b*a;\n\tstart = 0;\n\t//}\n\n\tTsum = T;\n\tfor (int i = 2; i <= N - 1; i += 2)\n\t{\n\t\tT = (l + l2 + f*(float(i) - 1.)*T) / float(i);\n\t\tl *= gsq;\n\t\tl2 *= asq;\n\t\tTsum += T;\n\t}\n\treturn Tsum;\n}\n\nfloat P(float theta, float a)\n{\n\treturn 1.0 / (1.0 + a * theta * theta);\n}\n\n#if PEARSON_VII==1\nfloat L(float theta, float b)\n{\n\tfloat ret = 1. / (1. + b * theta * theta);\n\treturn ret * ret;\n}\n#endif\n\nfloat I_org(float theta, float c, float n) //eq.(6)\n{\n\tfloat cCos = c * cos(theta);\n\n#if ODD==1\n\treturn (pow(cCos, n + 2.) - cCos) / (cCos * cCos - 1.);\n#else\n\treturn (pow(cCos, n + 2.) - 1.0) / (cCos * cCos - 1.);\n#endif\t\n}\n\nfloat evaluateXW(float c, float n)\n{\n#if ODD==1\n\treturn PI / 3. * pow(1. - pow(c - c / n, 2.), 0.5);\n#else\n\treturn PI / 4. * pow(1. - pow(c - c / (n - 1.), 2.5), 0.45);\n#endif\n}\n\nfloat shd_edge_contribution_approx(vec3 v0, vec3 v1, vec3 n, int e)\n{\n\tfloat f;\n\tfloat cos_theta, sin_theta;\n\tvec3 q = cross(v0, v1); //ni\n\tsin_theta = length(q);\n\tq = normalize(q);\n\tcos_theta = dot(v0, v1);\n\n\tif (e == 1) {\n\t\tf = acos(cos_theta);\n\t}\n\telse {\n\t\tvec3 w;\n\t\tfloat theta;\n\t\ttheta = acos(cos_theta);\n\t\tw = cross(q, v0); //ti\n\n\t\tfloat a = dot(v0, n);\n\t\tfloat b = dot(w, n);\n\t\tfloat x = theta; //arc length\n\t\tfloat delta = atan(b, a);\n\t\tfloat c = sqrt(a*a + b*b);\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat xw = evaluateXW(c, float(N));\n\n\t\t//-------------------------------------------------------------------------------------------\n#if ODD==1\n\t\tfloat Imin = 0.;\n\t\tfloat Imax = (pow(c, float(N) + 2.) - c) / (c*c - 1.);\n#else\n\t\tfloat Imin = 1.;\n\t\tfloat Imax = (pow(c, float(N) + 2.) - 1.) / (c*c - 1.);\n#endif\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat Io = I_org(xw, c, float(N)); //I(xw)\n\n\t\t//-------------------------------------------------------------------------------------------       \n\t\tfloat yw = (Io - Imin) / (Imax - Imin);\n\t\tfloat A = (1. - yw - 4. * xw * xw / (PI * PI)) / (yw * xw * xw);\n\n\t\t//DEBUG snippet:\n\t\t//float A = 1. / (xw*xw) - 8. / (PI*PI); //for even\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat integral_1 = 1. / sqrt(A) * atan(sqrt(A) * x, (1. - A * delta * (x - delta)));\n\n#if PEARSON_VII==1\n\t\tfloat B = A / 2.;\n\t\tfloat integral_2 = x / (2. * (B + x*x)) + atan(x, sqrt(B)) / (2. * sqrt(B));\n\n\t\t//DEBUG snippet:\n\t\t//float xw0 = PI/4.; //how to decide?\n\t\t//float xtail = xw + 0.3946 * xw0 * (1. - pow(1. - xw/xw0, 12.));       \n\t\t//float alpha = (L(xtail,B) - I_org(xtail, c, float(N))) / (L(xtail, B) - P(xtail, A));\n\n\t\tfloat alpha = 0.9; //hardcoded for now...may be incorrect, but visually ok...\n#endif\n\n\t\t//-------------------------------------------------------------------------------------------\n\t\tfloat Pmin = P(PI / 2., A);\n\t\tfloat Pmax = P(0., A);\n\t\tfloat s1 = (Imax - Imin) / (Pmax - Pmin);\n\t\tfloat t1 = Imin - s1 * Pmin;\n\n#if PEARSON_VII==1\t\n\t\tfloat LPmin = L(PI / 2., B);\n\t\tfloat LPmax = L(0., B);\n\t\tfloat s2 = (Imax - Imin) / (LPmax - LPmin);\n\t\tfloat t2 = Imin - s2 * LPmin;\n#endif\n\n#if PEARSON_VII==1\t\t\n\t\tf = alpha * (s1*integral_1 + t1*x) + (1. - alpha) * (s2*integral_2 + t2*x);\n#else\n\t\tf = s1*integral_1 + t1*x;\n#endif\t\n\n\t\tf = max(theta, f);\n\t}\n\n\treturn f*dot(q, n);\n}\n\nfloat shd_edge_contribution(vec3 v0, vec3 v1, vec3 n, int e)\n{\n\tfloat f;\n\tfloat cos_theta, sin_theta;\n\tvec3 q = cross(v0, v1); //ni\n\tsin_theta = length(q);\n\tq = normalize(q);\n\tcos_theta = dot(v0, v1);\n\n\tif (e == 1) {\n\t\tf = acos(cos_theta);\n\t}\n\telse {\n\t\tvec3 w;\n\t\tfloat theta;\n\t\ttheta = acos(cos_theta);\n\t\tw = cross(q, v0);\n\t\tf = cosine_sine_power_integral_sum(theta, cos_theta, sin_theta, e - 1, dot(v0, n), dot(w, n));\n\t}\n\treturn f * dot(q, n);\n}\n\n\n\nvoid seg_plane_intersection(vec3 v0, vec3 v1, vec3 n, out vec3 q)\n{\n\tvec3 vd;\n\tfloat t;\n\tvd = v1 - v0;\n\tt = -dot(v0, n) / (dot(vd, n));\n\tq = v0 + t * vd;\n}\n\nfloat shd_polygonal(vec3 p, vec3 n, bool spc)\n{\n\tint i, i1;\n\tint J = 0;\n\tfloat sum = 0.;\n\tvec3 ui0, ui1; /* unnormalized vertices of edge */\n\tvec3 vi0, vi1; /* unit-length vector vertices of edge */\n\tint belowi0 = 1, belowi1 = 1; /* flag for whether last vertex was below points \"horizon\" */\n\t/* find first vertex above horizon */\n\tfor (int j = 0; j < NUM_VERTS; j++) {\n\t\tvec3 u;\n\t\tu = get_arr(j) - p;\n\t\tif (dot(u, n) >= 0.0) {\n\t\t\tui0 = u;\n\t\t\tvi0 = u;\n\t\t\tvi0 = normalize(vi0);\n\t\t\tbelowi0 = 0;\n\t\t\tJ = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (J >= NUM_VERTS) return 0.;\n\n\ti1 = J;\n\tfor (int i = 0; i < NUM_VERTS; i++)\n\t{\n\t\ti1++;\n\t\tif (i1 >= NUM_VERTS) i1 = 0;\n\n\t\tui1 = get_arr(i1) - p;\n\t\tbelowi1 = int(dot(ui1, n) < 0.);\n\n\t\tif (belowi1 == 0) {\n\t\t\tvi1 = ui1;\n\t\t\tvi1 = normalize(vi1);\n\t\t}\n\n\t\tif (belowi0 != 0 && belowi1 == 0) {\n\t\t\tvec3 vinter;\n\t\t\tseg_plane_intersection(ui0, ui1, n, vinter);\n\t\t\tvinter = normalize(vinter + 0.01);\n\t\t\tsum += shd_edge_contribution(vi0, vinter, n, 1);\n\t\t\tvi0 = vinter;\n\t\t}\n\t\telse if (belowi0 == 0 && belowi1 != 0) {\n\t\t\tseg_plane_intersection(ui0, ui1, n, vi1);\n\t\t\tvi1 = normalize(vi1);\n\t\t}\n\t\tint K = spc ? N : 1;\n#if USE_APPROX\n\t\tif (belowi0 == 0 || belowi1 == 0) sum += shd_edge_contribution_approx(vi0, vi1, n, K);\n#else\n\t\tif (belowi0 == 0 || belowi1 == 0) sum += shd_edge_contribution(vi0, vi1, n, K);\n#endif\n\n\t\tui0 = ui1;\n\t\tvi0 = vi1;\n\t\tbelowi0 = belowi1;\n\t}\n\n\tif (sum < 0.) sum = -sum;\n\n\treturn sum / (2.0 * PI);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t// vec2 mo = -1.0 + 2.0 * iMouse.xy/iResolution.xy;\n\n\n\tvec3 ro = vec3(6.0 * sin(iTime), 2.2, 6.0 * cos(iTime));\n\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\n\n\tfloat t = 1.0;\n\tvec4 clr = vec4(0.0);\n\tfor (int i = 0; i < 64; i++)\n\t{\n\t\tvec2 hit = scene(ro + t*rd);\n\t\tfloat eps = 0.001;\n\t\tif (hit.x < eps)\n\t\t{\n\t\t\tvec4 mat = getMaterial(hit.y);\n\t\t\tif (hit.y == MAT_ID_LIGHT)\n\t\t\t{\n\t\t\t\tclr.rgb = lightClr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tvec3 nrm = calcNormal(pos);\n\t\t\tvec3 rfl = reflect(rd, nrm);\n\t\t\tvec3 test_out;\n\t\t\tfloat diff = shd_polygonal(pos, nrm, false);\n\n\n\t\t\tfloat spc = saturate(shd_polygonal(pos, rfl, true));\n\t\t\tclr.rgb = lightClr * (diff + spc) * mat.rgb;\n\t\t\tbreak;\n\t\t}\n\n\t\tt += max(hit.x, 0.001);\n\t}\n\n\tclr.rgb = pow(clr.rgb, vec3(1.0 / 2.2));\n\n\tfragColor = clr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dVGRK", "name": "Fish simulator 2016", "author": "jcolman", "description": "A fish... maybe thre will be more! Work in progress", "tags": ["3d", "fish"], "likes": 11, "viewed": 354, "date": "1457555478", "time_retrieved": "2024-06-20T18:33:06.964752", "image_code": "//------------------------------------------------------------------------\n// Jason Colman Feb 2016\n// Fish simulator 2016\n//------------------------------------------------------------------------\n\n#define PI 3.141592653589793\n\n// Initial value of t in ray equation p0 + t (p1 - p0)\n#define START_T 0.001\n\n// Once ray reaches this length, it won't hit anything in \n//  the scene.\n#define TOO_FAR 10.0\n\n// If distance from point to a surface is <= this, we are \n//  close enough to say we have hit it.\n#define CLOSE_ENOUGH 0.01\n\n// Max number of iterations in ray marching loop, will be\n//  interesting to find realistic value for this. Depends on\n//  number of objects in scene, no?\n// From a quick experiment, more than 100 makes no difference\n//  visually, for this example.\n#define MAX_ITERS 200\n\n#define LIGHT_DIR normalize(vec3(1.0, 0.8, 0.1))\n\n#define SPEED 1.0\n\n#define SMOOTH 0.1\n#define TAILW 0.07 * .3\n#define SCALE_SIZE 40.\n\n#define MAT_FISH  0\n#define MAT_EYE   1\n#define MAT_PUPIL 2\n\n//------------------------------------------------------------------------\n// From http://iquilezles.org/www/articles/smin/smin.htm\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//------------------------------------------------------------------------\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//------------------------------------------------------------------------\nfloat fishDist(vec3 pos)\n{\n    // Wriggle\n    float s = sin(iTime * 8. + pos.x);    \n    pos.z += s * .3;\n    \n    float bfin = max(\n        sdEllipsoid(pos + vec3(0.2, .4, 0), vec3(.3, 0.25, TAILW)),\n        sdEllipsoid(pos + vec3(0.1, .7, 0), vec3(.3, 0.3, 0.5)) );\n\n    float tfin = max(\n        sdEllipsoid(pos + vec3(-.3, -.75, 0), vec3(.5, 0.3, TAILW)),\n        sdEllipsoid(pos + vec3(0.1, -.65, 0), vec3(.4, 0.4, 0.5)) );\n    \n    float tail = max(\n        sdEllipsoid(pos + vec3(1.2, -0.55, 0), vec3(.6, 0.4, TAILW)),\n        sdEllipsoid(pos + vec3(1.5, -0.35, 0), vec3(.6, 0.45, 0.5)) );\n        \n    // Bottom tail\n//    tail = min(tail, max(\n//        sdEllipsoid(pos + vec3(1.2, 0.55, 0), vec3(.6, 0.4, TAILW)),\n//        sdEllipsoid(pos + vec3(1.5, 0.35, 0), vec3(.6, 0.45, 0.5))));\n        \n    float body = sdEllipsoid(pos + vec3(.1, 0, 0), vec3(.9, 0.4, 0.2));\n    \n    // Head\n    body = min(body,\n        sdEllipsoid(pos + vec3(-.5, 0, 0), vec3(.45, 0.3, 0.22)));\n               \n    // Mouth\n    body = max(body, \n        -sdEllipsoid(pos + vec3(-1., .1, 0), vec3(2., 0.1, 0.13)));\n\n    // No fins\n    return smin(tail, body, SMOOTH);\n    \n    return smin(tail, smin(min(bfin, tfin), body, SMOOTH), SMOOTH);    \n}\n\n//------------------------------------------------------------------------\nvec3 rotateY(vec3 pos, float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    return vec3(pos.x * c - pos.z * s, pos.y, pos.z * c + pos.x * s);\n}\n\n//------------------------------------------------------------------------\nvec3 fishpos(vec3 pos)\n{\n    float d = 4.;\n    \n    pos.y += sin(iTime * .6);\n    \n    pos.x += d * -sin(iTime);\n    pos.z += d * cos(iTime);\n\n    vec3 fpos = rotateY(pos, -iTime);   \n    return fpos;\n}\n\n//------------------------------------------------------------------------\nvec2 calcDist(vec3 pos)\n{\n    // Move fish around\n    \n    vec3 fpos = fishpos(pos);\n    float d = fishDist(fpos);\n    \n    //float d2 = fishDist(fpos + vec3(1., 1., 1.));\n    return vec2(d, 0);\n}\n\n//------------------------------------------------------------------------\nvec3 calcNormalAtPoint(vec3 pos) \n{\n    float d = 0.001;\n    vec2 u = vec2(1.0, 0.0);\n    return normalize(\n        vec3(\n            calcDist(pos + u.xyy * d).x - calcDist(pos - u.xyy * d).x,\n            calcDist(pos + u.yxy * d).x - calcDist(pos - u.yxy * d).x,\n            calcDist(pos + u.yyx * d).x - calcDist(pos - u.yyx * d).x\n        )\n    );\n}\n\n//------------------------------------------------------------------------\nvec3 render(vec3 eyePos, vec3 rayDir)\n{\n    vec3 bg = vec3(0.1, 0.2, 0.2);\n    \n    // t is distance along ray so far \n    float t = START_T;\n    \n    vec2 distMat = vec2(0.0, 0.0);\n    \n    // Repeatedly find the closest distance to an object in the\n    //  scene, and add this to t. \n    for( int i = 0; i < MAX_ITERS; i++ ) \n    {\n        // Distance to closest object and its material ID\n        distMat = calcDist(eyePos + rayDir * t);\n        float dist = distMat.x; // x-component is the distance\n\n        if (dist > TOO_FAR)\n            return bg; // ray has hit nothing, and never will \n        \n        if (dist <= CLOSE_ENOUGH)\n            break; // ray has hit something\n\n        t += dist * 0.9; // advance by this distance and keep marching\n    }\n\n    // Final pos, which is on surface of an object in the scene\n    vec3 pos = eyePos + rayDir * t;    \n    vec3 fpos = fishpos(pos);\n    \n    vec3 normal = calcNormalAtPoint(pos);\n    \n    // Calc diffuse lighting, and add a constant for ambient\n    float nDotL = min(max(0., dot(normal, LIGHT_DIR)) + 0.5, 1.0);\n\n    // Create red/white colour bands\n    float s = sin((fpos.x - .5) * 2.);\n    float c = cos(fpos.y * 1.);\n    float r =  c * c + s * s;\n    s = s * .5 + .5;\n    c = c * .5 + .5;\n    vec3 col = vec3(c, c * s, c * r * s * s); \n    // Shows basic colours\n    //return col;\n    \n    s = sin(fpos.x * SCALE_SIZE);\n    c = cos(fpos.y * SCALE_SIZE);\n    r = (s + c) * .7;\n    r *= r; \n    // Basic scales pattern\n    //return vec3(r);  \n    \n    s = clamp(0., 1., sin(fpos.z * 13.));\n    c = clamp(0., 1., cos(iTime * fpos.y * 11. + fpos.z * 2.));\n\n    //return vec3(s + c); // show mask\n    r *= (s + c);\n\n    // Basic scales pattern modulated by larger scrolling pattern,\n    //  giving shimmering effect\n    //return vec3(r);\n\n    // Just apply to the top half of the fish\n    r *= smoothstep(-.1, 1., fpos.y);\n    \n    // Make sure r is in range 0..1\n    r = clamp(r, 0., 1.);\n    //return vec3(r);\n\n    // Final colour is combination of colour bands and shimmering\n    //  scales effect\n    return vec3(nDotL * col ) + r * nDotL + vec3(0, 0, fpos.y * 0.1);\n}\n\n//------------------------------------------------------------------------\n// camera matrix\nmat3 getCameraMatrix( vec3 camFow ) \n{\n    vec3 forward = normalize( camFow );\n    vec3 up = normalize( vec3( 0.0, 0., 1.0 ) );\n    vec3 right = normalize( cross( up, forward ) );\n    \n    mat3 mat = mat3( right, up, forward );\n        \n    return mat;\n}\n\n//------------------------------------------------------------------------\nfloat lilypad(vec2 uv)\n{\n    float t = iTime * 0.004;\n    vec2 lilypos = 0.6 * vec2(cos(t), sin(t)); \n    vec2 d = vec2(uv - lilypos);\n    float dist = dot(d, d);\n    if (atan(d.x, d.y) + dist * 1.9 > 2.6)\n        return 999.;\n    if (dist > 0.03)\n        dist += sin(atan(d.x, d.y) * 80.) * 0.001;\n    return dist;\n}\n\n//------------------------------------------------------------------------\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get this pixel coord in range (-1..1)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    // Rotate camera in time with track curve, so we look at train\n    float deltaRot = -10.;//iMouse.x * 0.1; //iTime; //PI - sin(iTime * 1.05) * PI;\n\n    float D = 2.0;\n    float y = 12.0; //iMouse.y + 1.0; //cos(iTime * 0.2) + 2.0;\n    float z = -1.0; //iTime * SPEED;\n//    vec3 camPos = vec3( -D * cos(deltaRot), y, z + -D * sin(deltaRot) );\n    vec3 camPos = vec3(0, y, 0);\n//    vec3 camFow = vec3( 1.0 * cos(deltaRot), -40.0, 1.0 * sin(deltaRot) );\n    vec3 camFow = vec3(0, -1.0, 0);\n    mat3 camMat = getCameraMatrix( camFow );\n    \n    float viewRatio = iResolution.y / iResolution.x;\n    uv.y *= viewRatio;\n\n    vec3 rayDir = camMat * normalize( vec3( uv, viewRatio * 1.5 ) );\n    \n    // Get colour for pixel\n    vec3 colour = render(camPos, rayDir);\n    \n    float d = lilypad(uv);\n    if (d < .04)\n    {\n        colour = 0.7 * vec3(d * 20., .7, .25);\n    }\n    \n    fragColor = vec4(colour, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVGRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dy3Wt", "name": "sinusoida", "author": "malendziak", "description": "Sinusoida going left", "tags": ["sinus"], "likes": 0, "viewed": 117, "date": "1456921504", "time_retrieved": "2024-06-20T18:33:06.964752", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x -= iResolution.x/2.0 - iTime*1000.0;\n    fragCoord.y -= iResolution.y/2.0;\n   \tfragCoord.x /= iResolution.y/10.0;\n   \tfragCoord.y /= iResolution.y/10.0;\n    if ( abs(sin(fragCoord.x)-fragCoord.y) < 0.04 ) fragColor = vec4(1.0,1.0,1.0,1.0);\n    else fragColor = vec4(0.0,0.0,0.0,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dy3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dyGWt", "name": "Space Glowing", "author": "tholzer", "description": "Hmmm, what should I say... switch to full screen mode and lean back!", "tags": ["3d", "antialiasing", "space", "raytrace", "glowing", "satiny"], "likes": 19, "viewed": 542, "date": "1456901017", "time_retrieved": "2024-06-20T18:33:06.964752", "image_code": "//---------------------------------------------------------\n// SpaceGlowing.glsl  by Antony Holzer           2016-03-02\n// original:  https://www.shadertoy.com/view/MtX3Ws\n// see also:  https://www.shadertoy.com/view/Mlj3zW\n// simplified edit: Robert 25.11.2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// tags:      raytrace, 3d, space, antialiasing, glowing, satiny\n//---------------------------------------------------------\n\nvec3 roty (vec3 pos, float angle)\n{\n    float sa = sin(angle), ca = cos(angle);\n    return mat3(ca,0,-sa, 0,1,0, sa,0,ca) * pos;\n}\n\nfloat map (in vec3 p)\n{\n\tvec3 c = p;\n\tfloat res = 0.0;\n\tfor (int i=0; i < 4; i++)\n\t{\n\t\tp = abs(p) / dot(p,p) -0.7;\n\t\tp.yz = vec2(p.y*p.y-p.z*p.z, 2.*p.y*p.z);\n\t\tres += exp(-20.0 * abs(dot(p,c)));\n\t}\n\treturn res * 0.4;\n}\n\nvec3 raymarch (vec3 ro, vec3 rd)\n{\n\tfloat t = 5.0;\n\tfloat c = 0.0;\n\tvec3 col = vec3(0.0);\n\tfor (int i=0; i < 6; i++)\n\t{\n\t\tt += exp(c * -2.0) * 0.02;\n\t\tc = map(t * rd + ro);\n\t\tcol= vec3(8.0*c*c, c, 6.0*c*c*c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c*c*c, 2.0*c*c, c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c, 18.0*c*c*c, c*c)*0.16 + col *0.96;\n/*      // blue\n\t\tcol= vec3(c*c, c, 6.0*c*c*c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c*c*c, 2.0*c*c, 8.0*c) *0.16 + col *0.96;\n\t\tcol= vec3(c, 18.0*c*c*c, 8.0*c*c)*0.16 + col *0.96;\n*/\n\t}\n\treturn col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 p = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n  vec3 ro = roty(vec3(3.), iTime*0.2 + iMouse.x / iResolution.x);\n  vec3 uu = normalize(cross(ro, vec3(1.0, 0.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ro));\n  vec3 rd = normalize(p.x*uu + p.y*vv - ro*0.5);\n  fragColor.rgb = log(raymarch(ro,rd) + 1.0)*0.5;\n  fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dyGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3SWN", "name": "Diffuse basic subtraction", "author": "andro", "description": "Built for some one on the max msp forums.", "tags": ["raymarchingsubtraction"], "likes": 0, "viewed": 160, "date": "1459254969", "time_retrieved": "2024-06-20T18:33:08.777089", "image_code": "//mercury functions \n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n//mercury definitions\nfloat d;\nfloat r = 0.5;//default 0.3\nfloat n = 4.0;//default 0.4\n\n//for modulo\nfloat size = 4.0;\n\tfloat c = 0.0;\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n\n/*\n * # Raymarched distance-field renderer tutorial\n * # Part 1: Basic Distance Field & Raymarching\n *\n * ```\n * Author:  Sbastien Pierre   http://sebastienpierre.ca   @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is meant to show how to implement a raymarching distance field\n * shader-based renderer. It is based on the work of Inigo Quilezles (\"iq\"), whose\n * amazing code can be see all around on Shadertoy.com.\n *\n * Before editing/reading this shader, you should learn about distance fields and\n * raymarching, in particular [DIST] and [RAY] mentioned below. This tutorial's code\n * is based on the [TRI] code by `iq`.\n *\n * References:\n *\n * - [DIST] http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n * - [TRI]  https://www.shadertoy.com/view/4sXXRN\n * - [RAY]  http://www.iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n*/\n\n/**\n  * sdSphere is the distance field-based sphere equation as described\n  * by iq in [DIST]\n*/\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\n\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n\nvoid pR(inout vec2 p, float a) //This rotates the vectors around vec 2 eg .pxz\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n\n\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0.0 ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\n\n/**\n  * The map function is where you can register the distance field functions\n  * for all the \"objects\" in your scene. It is fairly simple to do union, interection\n  * difference, and repeats, as explained in [DIST]\n*/\nfloat map( vec3 p )//where the magic happens, all changes to the distance functions have to be placed here\n{\n    pR(p.yz,sin(iTime)*PI/2.0);//This rotates around the p.xz axis passes through\n    \n    float box1 = fBox(p,vec3(abs(sin(iTime))));//this is the cube//remove sin for static function\n    pR(p.yx,sin(iTime)*PI);//This rotates around the p.xz axis passes through\n\tfloat circle1 = fDisc( p, 1.5)-0.001;//this is the circle\n      \n\t\n    //return circle1;\n    //return fOpDifferenceChamfer (circle1,box1 ,1.0);\n    return max(circle1,-box1);//the max function cuts out the form from another\n   // return fOpIntersectionChamfer( circle1,box1,0.0);\n    \n}\n\n\n\nvec3 fNormal(vec3 intersection, float lastDistance)//generates normals\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize((vec3(map(intersection + epsilon.xyy),\n    map(intersection + epsilon.yxy),\n    map(intersection + epsilon.yyx)) - lastDistance) / epsilon.x);\n}\n\n\n\t// `maxd` is the maximum distance after which we'll stop the\n    // raymarching. This means that if we haven't interesected\n    // with anything after 10.0 world units of iteration, we'll stop.\n    const float maxd = 20.0;\n\n\n/**\n  * The `intersect` function is the main raymarching algorithm. It takes\n  * the ray origin `ro` and the ray step (or delta) `rd`. `rd` will be\n  * repeatedly added to `ro` until the `map` function (which determines\n  * the distance between the given point and the union of all objects\n  * in the scene) returns a value that is close to 0 (meaning the current\n  * point is almost on the scene object's envelope.\n  *\n  * Note that if `rd` is not normalized, the steps will increase or\n  * decrease as the intersection algorithm go.\n*/\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 normal )//This part of the raymarching setup, don't change for now\n{\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<50; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.0 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n\t    h = map( ro+rd*t );\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\t\n    normal = fNormal(ro + rd * t, h);//calculates normals for lighting\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel, meaning it\n    // is between [0,0] and [1,1]\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    \n    // If you do `p=q`, you will see that the origin is to the bottom left \n    // of the screen. With this simple expression, we adjust the viewpoint\n    // in the space and center the origin in the preview screen.\n    //\n    // vec2 p = q;              // [1] Origin is at the bottom-left of the screen\n    // vec2 p = 2.0 * q;        // [2] We scale by 1/2 by multiplying q\n    vec2 p = 2.0 * q - 1.0;     // [3] We scale by 1/2 and then center the origin on screen\n    // vec2 p = -0.5 + q;       // [4] Alternatively, we can center without scaling\n    \n    // NOTE: I'm not very familiar with the shader API, but from the above we can deduce\n    // that 1.0 means [1.0, 1.0] for a vect2, 2.0 means [2.0, 2.0], etc.\n    \n    // `iResolution.x/isResolution.y` is the aspect ratio, by default it is 512/288~=1.7777.\n    // If you uncomment the following line the image will appear as squashed.\n    p.x *= iResolution.x/iResolution.y;  \n    \n    // The `ro` value specifies the origin of the camera's center in the virtual space.\n    // You can tweak the X and Y values to shift the origin, or the Z value to\n    // adjust the distance to the sphere (here it is 2.0 to the sphere's center).\n\tvec3 ro = vec3(0.0,0.0, 6.0 );\n    \n    // The `rd` value specifies the  direction of the current pixel (on the projection\n    // plane) in the 3D space The notation vec3(p,-1.0) is equivalent to vec3(p.x,p.y,-1.0) as\n    // `p` is a vec2. -1.0 for z means it is pointing forward, and the normalization ensures\n    // that `rd` can be used as a step for raymarching.\n    vec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // The `col` vector holds the color that will be rendered on the screen, ie. the main\n    // output of the shader. As the alpha channel will be set to 1.0, we only need the\n    // three components RGB, hence the use of a vec3.\n\tvec3 col = vec3(0.0);\n\n    // We call the `interect` function with `ro` as the ray origin and `rd` as the \n    // point from which the raymarching step/delta will be calculated. Intersect is the\n    // main raymatching function.\n    vec3 normal;\n    float t = intersect(ro,rd,normal);\n    \n        // Here we do the simplest possible shading, which is based on the distance between\n        // the ray and the sphere. if `t == 0`, it means the sphere's envelope is intersecting\n        // with the current pixel, otherwise t will be the distance between the current pixel\n        // and the sphere's envelope. \n        //\n  \t\t// NOTE: I'm not sure exactly why we need to substract t from 2.0 and not 1.0. I would\n        // assume that because the projection plane is at -1.0 (as set by `rd.z`) and that the\n        // sphere is at the origin with a 1.0 radius that there t would be osciallating between\n        // 0 (closest) and 1.0 (farthest). If you try changing rd to the following expression:\n        //\n        // vec3 rd = normalize( vec3(p,-2.0) );\n        //\n        // You will only make the sphere closer, but the values for `t` will remain the same\n        // (the shading will remain). However, if you change the value of `ro` to the following:\n        //\n        // vec3 ro = vec3(0.0, 0.0, 2.5 );\n        //\n        // not only will the sphere shrink on the projection, but `t` will also increase. It is\n        // not clear to me yet why that is.\n        float d = clamp(t / maxd, 0.0, 1.0);\n    \tvec3 fog_color = vec3(0.2, 0.1, 0.3);\n    \tvec3 obj_color = vec3(1.0, 1.0, 1.0);\n    vec3 light_direction = normalize(vec3(sin(iTime), 1.0, 0.0));\n    float diffuse = clamp(dot(normal, light_direction) * 0.5 + 0.5, 0.0, 1.0);\n        \n    \tcol = mix(obj_color * diffuse, fog_color, d);\n    \t\n\t// We assign the color we've just computed.\n    fragColor = vec4(col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3SWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3XDN", "name": "Wobbly Blobs", "author": "akohdr", "description": "First shader messing around finding a coding style I can live with.", "tags": ["2d"], "likes": 0, "viewed": 101, "date": "1459280902", "time_retrieved": "2024-06-20T18:33:09.589308", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Mucking around with shader coding style (TODO: doc further somewhere else)\n// (consider style/eng. tradeoffs for speed/efficiency/readability/maintainability/reuse)\n\n// SHADER CODE is currently source code CUT/PASTE REUSE \n//     (BTW I like it that way :) )\n\n// Mapping to Shadertoy env.  (TODO: develop cross IDE hosting abstraction)\n// Shorter names for compact formulas and code  (shadertoy maintains char count ex whitespace)\n#define iR iResolution\n#define iT iTime\n\n// Design time parameterized constructs (almost assembler ops)\n#define Q(q) if(q) return;\n#define M(a,b) mod(a,b)\n#define FM(a,b) floor(mod(a,b))\n#define LFM(a,b,c) length(floor(mod(a,b))-c)\n#define DIST(a,b) length(a-b)\n#define QPROX(a,b,r) DIST(a,b)<r\n\n// Second order constucts\n/* TODO: need a nice (auto)doc format that plays nice in shader IDEs\n\nGRID - lattice 2D grid\n w - width\n h - height\n dx - dWidth/dT\n dy - dHeight/dT\n fx - step func f(x)\n fy - step func f(y)\n s - scale\n o - offset\n */\n// Base define\n#define _GRID(w,h,dx,dy,fx,fy,s,o) s.xy*vec2((.5+fx(iT*dx,w))/w,(.5+fy(iT*dy,h))/h)-o\n\n// introduce implicit defaults\n#define GRID_STEP(w,h,dx,dy,s,o) _GRID(w,h,dx,dy,FM,FM,s,o)\n\n// vectorized (struct) params (can't overload macros)  consider cost vecs/scalars\n#define GRID(r,d,fx,fy,s,o) _GRID(r.x,r.y,d.x,d.y,fx,fy,s,o)\n\n// abstract oscillators\n#define AOSC(fn,a,f,p,t) float(a*fn(f*t+p))\n#define OSCV(fn,v,t) (AOSC(fn,v.x,v.y,v.z,t))\n#define MUL_V3(a,b) vec3(a.x*b.x,a.y*b.y,a.z*b.z)\n#define ROSCV(fn,v,r,t) vec2(OSCV(fn,MUL_V3(v,r),t), OSCV(fn,v,t))\n#define S2ROSC(v,r) ROSCV(sin,v,r,iT)\n#define SC2OSCV(a,b) vec2(OSCV(sin,a,iT), OSCV(cos,b,iT))\n#define SC2OSC(fn1,a1,f1,fn2,a2,f2) vec2(AOSC(fn1,a1,f1,0.,iT), AOSC(fn2,a2,f2,0.,iT))\n\n// human meaning in anything intended to be user facing\n#define BOB(amp,freq) AOSC(sin,amp,freq,0.,iT)\n#define SAW(amp,freq) vec2(BOB(amp,freq))\n\n// Synonyms for static constructs\n#define DISK QPROX\n\n// Testing Funcs (user facing so again try to have human recognizable vars)\n#define qDISK(pt, center, radius) Q(DISK(pt, center, radius))\n#define qSEAHOLES(pt,dim,d) Q(LFM(pt,dim,d)<d)\n\n// GOTCHA!!!\n// order of introduction can introduce unwanted pattern matches \n// (i.e reversing SCALEXYZ and SCALEXY causes issues)\n// always introduce most explicit form first or avoid names that overlap\n\n// Design Time formula for constants\n#define UV(p,r) p/r.xy\n#define SCALEXYZ(a,b,r) r.xyz/vec3(a,b,c)\n#define SCALEXY(a,b,r) r.xy/vec2(a,b)\n#define SCALE SCALEXY\n\n#define GRID_DIM_XYZ SCALEXYZ\n#define GRID_DIM_XY SCALEXY\n\n// Runtime singleton constants\n// consider lifecycle of a 'constant' and it's cost\n//   inline vec3(...) assumes compiler catches constant and deals accordingly\n//   consider where the constant comes from code stream or various numa streams\nvec2 G3 = vec2(3),\n     Z2 = vec2(0);\nvec3 Z3 = vec3(0);\nvec4 Z4 = vec4(0);\n\n/*\n * mainImage entry point - returns a colour given a screen coordinate\n * (cVoxel extends this idea to 3D refer other shaders)\n *\n * Consists of ordered list of 'elements' of the shader scene\n * qXXX functions can match and return leaving fc in state previously set\n * order of testing of qXXX functions critical to performance \n * refer distance fields and Samet literature\n *\n * constants and metric calculated as required prior to use in qXXX tests\n *\n */\n#define VISIBLE\nvoid mainImage( out vec4 fc, in vec2 fp )\n{\n    // schedule heavy lifting early (assuming modern tech can sched. multi-cycle ops)\n    float sT = sin(iT), cT = cos(iT);\n    \n    // standard env constants (use reserved var names in #define???  mixed feelings)\n    vec2 uv = UV(fp,iR),      // texture mapping\n         s = SCALE(3.,2.,iR); // scale\n    \n    // spacetime based coloring can potentially reveal order of eval\n    fc = vec4(0.5+0.5*cos(iT),uv,1.0);\n    \n    // coloured disks with parameterized movement\n    float r = iR.y/16.,        // reuse disk radius calc\n    b = BOB(BOB(10.,2.),50.);  // we can nest #define akin to Mathematica tag funcs\n    \n#ifdef VISIBLE\n    // (in order from bottom left counter-clockwise)\n    qDISK(fp,GRID(G3,vec2(-1,3),FM,M,s,vec2(b,0)), r)\n    qDISK(fp,GRID(G3,vec2(3,1), M,FM,s,vec2(1.6*s.x,0)+vec2(b,b)), r)\n    qDISK(fp,GRID(G3,vec2(1,-3),FM,M,s,vec2(1.6*s.x,s.y)), r)\n    qDISK(fp,GRID(G3,vec2(-3,1),M,FM,s,vec2(0,s.y+SAW(8.,50.))), r)\n#endif\n    \n#ifdef VISIBLE\n    // a few that move in circles\n    vec2 ctr = iR.xy/2.;\n    qDISK(fp,ctr+S2ROSC(vec3(100.,5.,3.14),vec3(-1.,1.,.5)), r)\n    qDISK(fp,ctr+SC2OSCV(vec3(250.,1,0.),vec3(150.,1.,0.)), r)\n    qDISK(fp,ctr+SC2OSC(cos,150.,10.,sin,150.,10.), r)\n#endif\n    \n    fc = vec4(.1,.8,.1,1.);\n    qSEAHOLES(fp,GRID_DIM_XY(15,10,iR),iR.x/54.)\n    \n    // default to texture from a background image \n    // (should be abbey road close enough)\n    fc = texture(iChannel0,uv);\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3XDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3XWN", "name": "raymarch sampler 2d displace 01", "author": "andro", "description": "PAARDEN !", "tags": ["raymarchdisplace"], "likes": 1, "viewed": 188, "date": "1459283589", "time_retrieved": "2024-06-20T18:33:11.607636", "image_code": "//mercury functions \n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n//mercury definitions\nfloat d;\nfloat r = 0.5;//default 0.3\nfloat n = 4.0;//default 0.4\n\n//for modulo\nfloat size = 4.0;\n\tfloat c = 0.0;\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n\n/*\n * # Raymarched distance-field renderer tutorial\n * # Part 1: Basic Distance Field & Raymarching\n *\n * ```\n * Author:  Sbastien Pierre   http://sebastienpierre.ca   @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is meant to show how to implement a raymarching distance field\n * shader-based renderer. It is based on the work of Inigo Quilezles (\"iq\"), whose\n * amazing code can be see all around on Shadertoy.com.\n *\n * Before editing/reading this shader, you should learn about distance fields and\n * raymarching, in particular [DIST] and [RAY] mentioned below. This tutorial's code\n * is based on the [TRI] code by `iq`.\n *\n * References:\n *\n * - [DIST] http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n * - [TRI]  https://www.shadertoy.com/view/4sXXRN\n * - [RAY]  http://www.iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n*/\n\n/**\n  * sdSphere is the distance field-based sphere equation as described\n  * by iq in [DIST]\n*/\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\n\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n\nvoid pR(inout vec2 p, float a) //This rotates the vectors around vec 2 eg .pxz\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin//floor !\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n/**\n  * The map function is where you can register the distance field functions\n  * for all the \"objects\" in your scene. It is fairly simple to do union, interection\n  * difference, and repeats, as explained in [DIST]\n*/\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////\n////////////////////////////////////////////////////////////////\nfloat map( vec3 p )//where the magic happens, all changes to the distance functions have to be placed here\n{\n    pR(p.yz,sin(iTime)*PI/2.0);//This rotates around the p.xz axis passes through\n     vec3 tex1 = texture( iChannel0,0.2* p.xy ).xyz;\n    \n     vec3 tex2 = texture( iChannel1, 0.15*p.xy ).xyz;//backup\n   \n    //vec4 textureProj(sampler2D sampler, vec3 coord )\n   \tvec3 posmod1 = p + vec3(sin(iTime),sin(iTime),0.0);\n    //vec3 posmod2 = p + vec3(2.0*sin(iTime),cos(iTime),0.0);\n    float box1 = fBox(p+tex1,vec3(2.0,2.0,0.1));//this is the cube//remove sin for static function\n    pR(p.xy,sin(iTime)*PI);//This rotates around the p.xz axis passes through\n    pR(p.yz,sin(iTime)*PI);//This rotates around the p.xz axis passes through\n    float box2 = fBox(posmod1+tex2,vec3(0.5,0.5,2.25));//this is the cube//remove sin for static function\n    float torus1 = fTorus(p+tex2, 0.45,  1.5+abs(sin(iTime)));\n    //float torus2 = fTorus(p, 0.25,  0.5+abs(cos(iTime)));\n    \n    \n   // float box3= fBox(posmod2,vec3(1.0,0.25,1.5));//this is the cube//remove sin for static function\n    //pR(p.yx,sin(iTime)*PI);//This rotates around the p.xz axis passes through\n    pR(p.yx,45.0);//This rotates around the p.xz axis passes through\n\t\n  \n\t\n  \n    float texadd1 =tex1.x +tex2.x;//woops needs floats, texture to float ?\n     float texadd2 =tex1.y +tex2.y;//woops needs floats, texture to float ?\n     float texadd3 =tex1.z +tex2.z;//woops needs floats, texture to float ?\n    float texmod1 = texadd1*texadd2 *texadd3*8.0;//duh needs to be float\n    \n   \n   float result1 = fOpUnionRound(box1, torus1, abs(sin(iTime)));\n    pR(p.xy,sin(iTime)*PI/2.0);//This rotates around the p.xz axis passes through\n    float result2 = fOpUnionRound(result1,box2, 0.5);\n   \n   // float result3 = fOpGroove(result2, torus2, 0.25, 0.5);\n    return result2;\n    //return box1;\n    \n   \n    \n    \n}\n\n\n\nvec3 fNormal(vec3 intersection, float lastDistance)//generates normals\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize((vec3(map(intersection + epsilon.xyy),\n    map(intersection + epsilon.yxy),\n    map(intersection + epsilon.yyx)) - lastDistance) / epsilon.x);\n}\n\n\n\t// `maxd` is the maximum distance after which we'll stop the\n    // raymarching. This means that if we haven't interesected\n    // with anything after 10.0 world units of iteration, we'll stop.\n    const float maxd = 20.0;\n\n\n/**\n  * The `intersect` function is the main raymarching algorithm. It takes\n  * the ray origin `ro` and the ray step (or delta) `rd`. `rd` will be\n  * repeatedly added to `ro` until the `map` function (which determines\n  * the distance between the given point and the union of all objects\n  * in the scene) returns a value that is close to 0 (meaning the current\n  * point is almost on the scene object's envelope.\n  *\n  * Note that if `rd` is not normalized, the steps will increase or\n  * decrease as the intersection algorithm go.\n*/\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 normal )//This part of the raymarching setup, don't change for now\n{\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<50; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.0 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n\t    h = map( ro+rd*t );\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\t\n    normal = fNormal(ro + rd * t, h);//calculates normals for lighting\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel, meaning it\n    // is between [0,0] and [1,1]\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    \n    // If you do `p=q`, you will see that the origin is to the bottom left \n    // of the screen. With this simple expression, we adjust the viewpoint\n    // in the space and center the origin in the preview screen.\n    //\n    // vec2 p = q;              // [1] Origin is at the bottom-left of the screen\n    // vec2 p = 2.0 * q;        // [2] We scale by 1/2 by multiplying q\n    vec2 p = 2.0 * q - 1.0;     // [3] We scale by 1/2 and then center the origin on screen\n    // vec2 p = -0.5 + q;       // [4] Alternatively, we can center without scaling\n    \n    // NOTE: I'm not very familiar with the shader API, but from the above we can deduce\n    // that 1.0 means [1.0, 1.0] for a vect2, 2.0 means [2.0, 2.0], etc.\n    \n    // `iResolution.x/isResolution.y` is the aspect ratio, by default it is 512/288~=1.7777.\n    // If you uncomment the following line the image will appear as squashed.\n    p.x *= iResolution.x/iResolution.y;  \n    \n    // The `ro` value specifies the origin of the camera's center in the virtual space.\n    // You can tweak the X and Y values to shift the origin, or the Z value to\n    // adjust the distance to the sphere (here it is 2.0 to the sphere's center).\n\tvec3 ro = vec3(0.0,0.0, 6.0 );\n    \n    // The `rd` value specifies the  direction of the current pixel (on the projection\n    // plane) in the 3D space The notation vec3(p,-1.0) is equivalent to vec3(p.x,p.y,-1.0) as\n    // `p` is a vec2. -1.0 for z means it is pointing forward, and the normalization ensures\n    // that `rd` can be used as a step for raymarching.\n    vec3 rd = normalize( vec3(p,-2.0) );\n\t\n    // The `col` vector holds the color that will be rendered on the screen, ie. the main\n    // output of the shader. As the alpha channel will be set to 1.0, we only need the\n    // three components RGB, hence the use of a vec3.\n\tvec3 col = vec3(0.0);\n\n    // We call the `interect` function with `ro` as the ray origin and `rd` as the \n    // point from which the raymarching step/delta will be calculated. Intersect is the\n    // main raymatching function.\n    vec3 normal;\n    float t = intersect(ro,rd,normal);\n    \n        // Here we do the simplest possible shading, which is based on the distance between\n        // the ray and the sphere. if `t == 0`, it means the sphere's envelope is intersecting\n        // with the current pixel, otherwise t will be the distance between the current pixel\n        // and the sphere's envelope. \n        //\n  \t\t// NOTE: I'm not sure exactly why we need to substract t from 2.0 and not 1.0. I would\n        // assume that because the projection plane is at -1.0 (as set by `rd.z`) and that the\n        // sphere is at the origin with a 1.0 radius that there t would be osciallating between\n        // 0 (closest) and 1.0 (farthest). If you try changing rd to the following expression:\n        //\n        // vec3 rd = normalize( vec3(p,-2.0) );\n        //\n        // You will only make the sphere closer, but the values for `t` will remain the same\n        // (the shading will remain). However, if you change the value of `ro` to the following:\n        //\n        // vec3 ro = vec3(0.0, 0.0, 2.5 );\n        //\n        // not only will the sphere shrink on the projection, but `t` will also increase. It is\n        // not clear to me yet why that is.\n        float d = clamp(t / maxd, 0.0, 1.0);\n    \tvec3 fog_color = vec3(0.2, 0.1, 0.3);\n    \tvec3 obj_color = vec3(1.0, 1.0, 1.0);\n    vec3 light_direction = normalize(vec3(sin(iTime), 1.0, 0.0));\n    float diffuse = clamp(dot(normal, light_direction) * 0.5 + 0.5, 0.0, 1.0);\n        \n    \tcol = mix(obj_color * diffuse, fog_color, d);\n    \t\n\t// We assign the color we've just computed.\n    fragColor = vec4(col, 1.0 );\n}\n\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3XWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4s3Xz8", "name": "PinkWaves", "author": "UNDERDOGKID91", "description": "PINK WAVEs", "tags": ["pink"], "likes": 12, "viewed": 282, "date": "1457531116", "time_retrieved": "2024-06-20T18:33:11.607636", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat range(float val, float mi, float ma) {\n    return val * (ma - mi) + mi;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat t = iTime / 5.;\n    \n\t// main code, *original shader by: 'Plasma' by Viktor Korsun (2011)\n\tfloat x = p.x;\n\tfloat y = p.y;\n    \n\tfloat mov0 = x+y+cos(sin(t)*2.0)*100.+sin(x/100.)*1000.;\n\tfloat mov1 = y / 0.3 +  t;\n\tfloat mov2 = x / 0.2;\n    \n    float c1 = abs(sin(mov1+t)/2.+mov2/2.-mov1-mov2+t);\n    float c2 = abs(sin(c1+sin(mov0/1000.+t)+sin(y/40.+t)+sin((x+y)/100.)*3.));\n\tfloat c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));\n    \n    vec3 col = hsv2rgb(vec3(range(c2, 0.85, 0.95), range(c3, 0.5, 0.55), range(c3, 1., 0.75)));\n    \n    \n\tfragColor = vec4(col, 1.);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3Xz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scSRH", "name": "A different 3D grid", "author": "Mr_E", "description": "I made a mistake on one of my previous programs, and this looked vaguely cool so YAY! ", "tags": ["3d", "grid", "different", "helpfulmistake"], "likes": 0, "viewed": 509, "date": "1457539827", "time_retrieved": "2024-06-20T18:33:11.607636", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(0.,0.,0.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(0.,0.,0.)),\n            sdBox(p,vec3(0.,.0,.0)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d2, d1, d2);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n    vec3 q = opRep(p,vec3(10.0,10.0,10.0));\n    return vec2(\n       \tsdCrossedGrid(q)\n    );\n}\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    //return vec3(0.6,0.6,0.8);\n    return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(sin(iTime/6.)*30.4,cos(iTime/2.)*40.0,20.0);\n\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(1,1,1);\n\n    //camera lookat\n    vec3 vrp=vec3(1,1,1);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*1.0+vPos.y*v*1.0;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.04,0,0.8);\n    const float maxd=200.0;\n    vec2 d=vec2(1.02,1.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) { // Change i value to 256 for 3D-ness and 2 for coolness\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x*0.8;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        \n        float b=dot(N,normalize(prp-p));\n\t\tvec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    \txy.y = 1.0 - xy.y;\n    \t\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\t\tvec4 texColor = texture(iChannel0,xy,b);//Get the pixel at xy from iChannel0\n        fragColor = vec4(b);\n        \n        //fragColor = vec4(b, 0.1, b, cos(iTime/2.));//Set the screen pixel to that color\n    } else {\n    fragColor=vec4(0,0,0,1);\n    }\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scSRN", "name": "Shader Lesson #5, animation", "author": "hubbe", "description": "Demonstrates simple shapes, transparency, translation, rotation and time-based movement.", "tags": ["educational"], "likes": 5, "viewed": 354, "date": "1457839218", "time_retrieved": "2024-06-20T18:33:12.116685", "image_code": "// Scroll down to the scene function to find things to modify.\n\n// Input is a position, output is color, forming red bars.\nvec4 red_bars(vec2 pos) {\n   \treturn vec4(cos(pos.x * 30.0), 0,0,1);\n}\n\n// If input position is inside a square, return a green color,\n// otherwise return a transparent color.\nvec4 square(vec2 pos) {\n    if (abs(pos.x) < 0.1 && abs(pos.y) < 0.1) {\n        return vec4(0,1,0,1);\n    } else {\n        return vec4(0,0,0,0); // transparent\n    }\n}\n\n// If input position is inside a circle, return a semitransparent\n// blue color, otherwise return a completely transparent color.\nvec4 circle(vec2 pos) {\n    if (length(pos) < 0.08) {\n        return vec4(0, 0, 1, 0.5); // semitransparent\n    } else {\n        return vec4(0,0,0,0);\n    }\n}\n\n// Rotate the position around 0,0.\nvec2 rotate(vec2 pos, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n}\n\n// Move the position adding 0.1 to x.\nvec2 translate(vec2 pos) {\n    return pos + vec2(0.1, 0.0);\n}\n\n// Input is position, return the color.\nvec4 scene(vec2 pos) {\n    vec2 square_pos = pos;\n    vec2 bar_pos = pos;\n    vec2 circle_pos = pos;\n\n    // Uncomment any combination of the translate and rotate lines below.\n        \n    // square_pos = translate(square_pos);\n    square_pos = rotate(square_pos, -iTime);\n    // square_pos = translate(square_pos);\n    \n    // bar_pos = translate(bar_pos);\n    bar_pos = rotate(bar_pos, iTime);\n    //bar_pos = translate(bar_pos);\n\n    // circle_pos = translate(circle_pos);\n    circle_pos = rotate(circle_pos, iTime * 2.0);\n    circle_pos = translate(circle_pos);\n    circle_pos = translate(circle_pos);\n\n    // Now call the shape functions.\n    vec4 s = square(square_pos);\n    vec4 c = circle(circle_pos);\n    vec4 b = red_bars(bar_pos);\n\n    // Can you make the square bigger?\n    \n        \n    // Blend the colors together based on transparency.\n    vec4 ret = b;\n    ret = mix(ret, c, c.w);\n    ret = mix(ret, s, s.w);\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n    fragColor = scene(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scSWn", "name": "Bright blackhole", "author": "cooler", "description": "This is modified version of https://www.shadertoy.com/view/4lf3Rj<br/><br/>I started playing with that code and just after some tweaks got inspired by Interstellar <img src=\"/img/emoticonLaugh.png\"/>.", "tags": ["sun", "planet", "blackhole"], "likes": 12, "viewed": 1128, "date": "1458569527", "time_retrieved": "2024-06-20T18:33:12.595580", "image_code": "//It is modified version of https://www.shadertoy.com/view/4lf3Rj -> author Kali\n//:)\n\n\n\n// rendering params\nconst float sphsize=.7; // planet size\nconst float dist=.77; // distance for glow and distortion\nconst float perturb=0.55; // distortion amount of the flow around the planet\nconst float displacement=0.50; // hot air effect\nconst float windspeed=.1; // speed of wind flow\nconst float steps=110.; // number of steps for the volumetric rendering\nconst float stepsize=.025; \nconst float brightness=.56;\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\nconst float fade=.005; //fade by distance\nconst float glow=2.0; // glow amount, mainly on hit side\n\n\n// fractal params\nconst int iterations=13; \nconst float fractparam=.7;\nconst vec3 offset=vec3(1.5,2.,-1.5);\n\n\nfloat wind(vec3 p) \n{\n\tfloat d=max(0.0,dist-max(0.,length(p)-sphsize)/sphsize)/dist; // for distortion and glow area\n\tfloat x=max(0.8,p.x*0.5); // to increase glow on left side\n    \n\tp.y*=1.+max(0.2,-p.x-sphsize*0.70)*10.; // left side distortion (cheesy)\n\tp-=d*normalize(p)*perturb; // spheric distortion of flow\n\tp+=vec3(iTime*windspeed,0.5,0.5); // flow movement\n\tp=abs(fract((p+offset)*.1)-.5); // tile folding \n\tfor (int i=0; i<iterations; i++) \n    {  \n\t\tp=abs(p)/dot(p,p)-fractparam; // the magic formula for the hot flow\n\t}\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; // return the result with glow applied\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get ray dir\t\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\n\tvec3 dir=vec3(uv,1.);\n\tdir.x*=iResolution.x/iResolution.y;\n\tvec3 from=vec3(0.,0.,-2.+texture(iChannel0,uv*.5+iTime).x*stepsize); //from+dither\n    \n\n    // volumetric rendering\n\tfloat v=0., l=-0.0001, t=iTime*windspeed*.2;\n\tfor (float r=10.;r<steps;r++)\n    {\n\t\tvec3 p=from+r*dir*stepsize;\n\t\tfloat tx=texture(iChannel0,uv*.2+vec2(t,0.)).x*displacement; // hot air effect\n        v+=min(10.,wind(p))*max(0.,1.-r*fade); \n\n    }\n   \n    v/=steps; v*=brightness; // average values and apply bright factor\n\tvec3 col=vec3(v*1.25,v*v,v*v*v)+l*planetcolor; // set color\n\tcol*=1.-length(pow(abs(uv),vec2(5.)))*14.; // vignette (kind of)\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Msl3Rj", "previewfilepath": "https://soundcloud.com/izinsiz/inter-dooark-hans-zimmer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/izinsiz/inter-dooark-hans-zimmer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scSz4", "name": "Shader Lesson #2, functions", "author": "hubbe", "description": "Function plotter, demonstrates a bunch of the builtin functions.", "tags": ["educational"], "likes": 16, "viewed": 1603, "date": "1457825772", "time_retrieved": "2024-06-20T18:33:12.595580", "image_code": "// Plot a function, and a background grid.\n\nhighp float pi = 3.14159265;\n\n// Fom -2 to 2\nhighp float scale = 4.0;\n\n// This is the function that we want to plot.\nfloat f(highp float x) {\n    // Uncomment one line at a time to see what the function does.\n    \n    // return x;\n    // return x - 1.0;\n    // return x *x;\n    // return min(x, 0.0);\n    // return max(x, 0.0);\n    // return sqrt(x);\n    // return abs(x);\n    // return sign(x);\n    // return floor(x);\n    // return fract(x);\n    // return clamp(x, -1.0, 1.0);\n    // return step(1.0, x);\n    // return mod(x, 1.0);\n    // return 1.0/x;\n    // return sin(pi * x);\n    // return cos(pi * x);\n    // return log(x);\n    // return exp(x);\n    return sin(sin(iTime) * 10.0 + sin(x) * 3.0 * x);\n}\n\n// Transform an vec2 onscreen coordinate (0.0-1.0) to a coordinate that\n// we want to plot the function for. (+/- scale*2)\nvec2 p2v(vec2 pos) {\n    pos -= vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n    pos *= scale;\n    return pos;\n}\n\n// Evaluate the function, return 1 if we're above the line.\nfloat t(vec2 pos) {\n    pos = p2v(pos);\n    if(f(pos.x) > pos.y) {\n        return 1.0;\n    } else {\n        return 0.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    int cnt = 0;\n    int max_cnt = 0;\n    // 81-point subsampling\n    for (float x = -1.0; x <= 1.0; x += 0.25) {\n        for (float y = -1.0; y <= 1.0; y += 0.25) {\n            max_cnt ++;\n            if (1.0 == t((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt ++;\n        }\n    }\n    if (cnt > max_cnt / 2) cnt = max_cnt - cnt;\n    \n    float color = float(cnt) * 2.0 / float(max_cnt);\n\tfloat bg = 0.0;\n    vec2 v = p2v(uv);\n\tif (abs(v.x) < scale/iResolution.x || abs(v.y) < scale/iResolution.y) {\n      bg = 0.0;\n    } else {\n\t    vec2 grid = step(mod(v, vec2(2.0, 2.0)), vec2(1.0, 1.0));\n    \tif (grid.x == grid.y) {\n          bg = 0.3;\n        } else {\n          bg = 0.4;\n        }\n    }\n    color = mix(bg, 1.0, color); \n    fragColor = vec4(color, color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scXRr", "name": "trailing", "author": "jpweiyi", "description": "only test trailing.", "tags": ["2dtrailingwithoutbuffer"], "likes": 0, "viewed": 188, "date": "1457284006", "time_retrieved": "2024-06-20T18:33:12.595580", "image_code": "vec2 rotation(vec2 p, float angle)\n{\n    float rad = radians(angle);\n    return vec2(p.x*cos(rad)+p.y*sin(rad) -cos(rad*0.3)*0.4, \n                -p.x*sin(rad)+p.y*cos(rad) + sin(1.-rad)*.2);\n}\n\n\nfloat line(vec2 p, vec2 a, vec2 b, float w)\n{\n     vec2 a2b = b - a;\n     vec2 a2p = p - a;     \n     \n     //  proj(a2p,a2b)  dot(a2p,a2b) / length(a2b)\n     // a2b\n     // proj(a2p,a2b)/length(a2b)  dot(a2p,a2b)/dot(a2b,a2b)\n     \n     float h = clamp( dot(a2p,a2b)/dot(a2b,a2b), 0.0, 1.0 );\n     vec2 p1 = mix( a, b, h );\n     if( length( p1 - p ) <= w )\n         return 1.0;\n     \n     return 0.0;\n}\n\nconst vec4 black_color = vec4(0.3, 0.3, 0.3, 1.0);\nconst vec4 axis_color = vec4(0.0, 0.0, 1.0, 1.0);\n\n\nvoid animation(inout vec4 color,vec2 uv)\n{\n    vec4 newColor = color;\n    const float loop = 40.0;\n    float time = iTime - 1.0;\n    for(float i = 0.0; i < loop; ++i)\n    {// \n\t\tif(line(rotation(uv, (time+i*0.1)* 70.0), \n                \t\t  vec2(0.5,0.0), \n                          vec2(0.5, 0.0), \n                          smoothstep(0.0, 0.2, i/loop*0.2)*0.2\n                          /*0.2*/) > 0.0)\n    \t{\n        \tnewColor = mix(color, vec4(1.0, 0.0, 0.0, 1.0), smoothstep(0.0,loop,i));\n    \t}\n    }\n    \n    color = newColor; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // \n    vec4 color = black_color;\n    \n    // \n    if(line(uv, vec2(-2.0, 0.0), vec2(2.0, 0.0), 0.01) > 0.0 ||\n      \tline(uv, vec2(0.0, -2.0), vec2(0.0, 2.0), 0.01) > 0.0){\n        color = axis_color;\n    }\n    \n\tanimation(color, uv);\n    \n   \tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scXz7", "name": "Ferris Wheel 2", "author": "wjbgrafx", "description": "Another amusement park ride, based on Shane's \"Raymarched Reflections\" code.", "tags": ["3d", "raymarch", "modeling"], "likes": 15, "viewed": 795, "date": "1458260895", "time_retrieved": "2024-06-20T18:33:16.826115", "image_code": "/*\n\t\"Ferris Wheel 2\" by wjbgrafx\n\t\n\tBased on\n\tRaymarched Reflections   Uploaded by Shane in 2015-Nov-17\n\thttps://www.shadertoy.com/view/4dt3zn\n\t\n\tAdditional sources:\n\t------------------\t\n\tGardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n\thttps://www.shadertoy.com/view/lll3z4\n\n\tHG_SDF GLSL Library for building signed distance bounds by MERCURY\n\thttp://mercury.sexy/hg_sdf\n\n\tCamera rotation matrix function\n\tFrom\t\"Simple test/port of Mercury's SDF library to WebGL\"\n\thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PI_16\t\t\t\t\t0.19634954084936207740391521145497\n\n#define FAR                     80.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_DIST\t\t\t\t40.0\n#define CAM_POS                 vec3( 0.0, 5.0, -CAM_DIST )\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT                 vec3( 0.0, 5.0, 0.0 )\n#define LIGHT_POS               vec3( 0.0, 20.0, -10.0 )\n#define LIGHT_ATTEN\t\t\t\t0.003\n\n\n//------------------------------------------------------------------------------\n// Function declarations\n//----------------------\nmat4 createCamRotMatrix();\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID );\nvec3 skyColor( vec2 pix );\nvec3 rotateZ(vec3 p, float a);\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin);\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius);\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r);\nfloat fBox(vec3 p, vec3 b);\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist);\n\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map(vec3 p)\n{    \n\t\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( fPlane( p, vec3( 0.0, 1.0, 0.0 ), 0.0 ), objID );    \n\t\n\t// Tower, ground beam, braces, and axle.\n\t//--------------------------------------\n\tvec3 p2 = p;\t\n\t// Mirror across x-axis.\n\tpMirror( p2.z, 0.0 );\n\t\n\tobjID = 2.0;\t\n\tvec2 tower = vec2( \n\t      fBox( p2 - vec3( 0.0, 3.6, 1.5 ), vec3( 0.15, 3.6, 0.15 ) ), objID ); \n\t\n\tvec2 groundBeam = vec2(\n\t\t    fBox( p2 - vec3( 0.0, 0.2, 1.5 ), vec3( 5.0, 0.2, 0.3 ) ), objID );\n\t\t\n\tvec2 brace1 = vec2(\n\tfCapsule( p2, vec3( 4.5, 0.0, 1.5 ), vec3( 0.0, 6.0, 1.5 ), 0.1 ), objID );\t\n\t\t\n\tvec2 brace2 = vec2(\n\tfCapsule( p2, vec3( -4.5, 0.0, 1.5 ), vec3( 0.0, 6.0, 1.5 ), 0.1 ), objID );\t\n\t\t\n\tvec2 crossBeam = vec2(\n\t\t    fBox( p - vec3( 0.0, 0.2, 0.0 ), vec3( 0.3, 0.2, 2.0 ) ), objID );\t\n\t\n\tvec2 axle = vec2(\n\tfCapsule( p, vec3( 0.0, 7.0, 1.5 ), vec3( 0.0, 7.0, -1.5 ), 0.2 ), objID );\t    \n\t\n\t// Hoops and arms.\n\t//----------------\n\tvec3 p1 = p;\n\t\n\t// Rotate hoops. Translate hoop center to origin and back, so hoops rotate\n\t// around their own center.\n\tfloat hoopRotVal = iTime * -0.5;\n\tp1.y -= 7.0;\n\tp1 = rotateZ( p1, hoopRotVal );\n\tp1.y += 7.0;\n\t\n\t// Mirror across x-axis.\n\tpMirror( p1.z, 0.0 );\t\n\t\n\tobjID = 2.0;\n\t// Swizzle y and z planes to make tori stand upright in x-y plane.\n\tvec2 outerHoop = vec2( \n\t               fTorus( p1.xzy - vec3( 0.0, 1.0, 7.0 ), 0.1, 5.0 ), objID );\n\n\tvec2 innerHoop = vec2( \n\t              fTorus( p1.xzy - vec3( 0.0, 1.0, 7.0 ), 0.05, 4.0 ), objID );\n\t\n\tvec2 axleHoop = vec2( \n\t             fTorus( p1.xzy - vec3( 0.0, 1.0, 7.0 ), 0.05, 0.25 ), objID );\n\t\n\t//---------------------------------------------------\n\n\tvec2 arm1 = vec2(\n  \t\tfCapsule( p1, vec3( -5.0, 7.0, 1.0 ), vec3( 5.0, 7.0, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\tvec2 arm2 = vec2(\n  \t\tfCapsule( p1, vec3( 0.0, 2.0, 1.0 ), vec3( 0.0, 12.0, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\tvec2 arm3 = vec2(\n  \t\tfCapsule( p1, vec3( -3.4, 3.5, 1.0 ), vec3( 3.4, 10.5, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\tvec2 arm4 = vec2(\n  \t\tfCapsule( p1, vec3( -3.4, 10.5, 1.0 ), vec3( 3.4, 3.5, 1.0 ), 0.05 ), \n  \t\t\t                                                           objID );\n\t//---------------------------------------------------\n\t// Seat 1\n\t// ------\n\tvec3 p3 = p;\n\t// Rotate with the hoops.\n\tp3.y -= 7.0;\n\tp3 = rotateZ( p3, hoopRotVal );\n\tp3.y += 7.0;\n\t// Rotate around its own z-axis to keep it upright.\n\tp3 -= vec3( -5.0, 7.0, 0.0 );\n\tp3 = rotateZ( p3, -hoopRotVal );\n\tp3 += vec3( -5.0, 7.0, 0.0 );\n\t\t\n\tobjID = 3.0;\n\tvec2 seat1 = vec2(\n\t\tfBox( p3 - vec3( -5.0, 7.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat1CutA = vec2(\n\t\tfBox( p3 - vec3( -5.1, 7.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat1 = max( seat1, -seat1CutA );\n\t\n\tvec2 seat1CutB = vec2(\n\t\tfBox( p3 - vec3( -5.7, 7.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat1 = max( seat1, -seat1CutB );\n\t\n\t// Seat 2\n\t// ------\n\tvec3 p4 = p;\n\t// Rotate with the hoops.\n\tp4.y -= 7.0;\n\tp4 = rotateZ( p4, hoopRotVal );\n\tp4.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp4 -= vec3( -3.4, 10.5, 0.0 );\n\tp4 = rotateZ( p4, -hoopRotVal );\n\tp4 += vec3( -3.4, 10.5, 0.0 );\n\t\t\n\tobjID = 4.0;\n\tvec2 seat2 = vec2(\n\t\tfBox( p4 - vec3( -3.4, 10.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat2CutA = vec2(\n\t\tfBox( p4 - vec3( -3.5, 11.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat2 = max( seat2, -seat2CutA );\n\t\n\tvec2 seat2CutB = vec2(\n\t\tfBox( p4 - vec3( -4.1, 10.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat2 = max( seat2, -seat2CutB );\n\t\n\t// Seat 3\n\t// ------\n\tvec3 p5 = p;\n\t// Rotate with the hoops.\n\tp5.y -= 7.0;\n\tp5 = rotateZ( p5, hoopRotVal );\n\tp5.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp5 -= vec3( 0.0, 12.0, 0.0 );\n\tp5 = rotateZ( p5, -hoopRotVal );\n\tp5 += vec3( 0.0, 12.0, 0.0 );\n\t\t\n\tobjID = 5.0;\n\tvec2 seat3 = vec2(\n\t\tfBox( p5 - vec3( 0.0, 12.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat3CutA = vec2(\n\t\tfBox( p5 - vec3( -0.1, 12.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat3 = max( seat3, -seat3CutA );\n\t\n\tvec2 seat3CutB = vec2(\n\t\tfBox( p5 - vec3( -0.7, 12.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat3 = max( seat3, -seat3CutB );\n\t\n\t// Seat 4\n\t// ------\n\tvec3 p6 = p;\n\t// Rotate with the hoops.\n\tp6.y -= 7.0;\n\tp6 = rotateZ( p6, hoopRotVal );\n\tp6.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp6 -= vec3( 3.4, 10.5, 0.0 );\n\tp6 = rotateZ( p6, -hoopRotVal );\n\tp6 += vec3( 3.4, 10.5, 0.0 );\n\t\t\n\tobjID = 6.0;\n\tvec2 seat4 = vec2(\n\t\tfBox( p6 - vec3( 3.4, 10.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat4CutA = vec2(\n\t\tfBox( p6 - vec3( 3.3, 11.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat4 = max( seat4, -seat4CutA );\n\t\n\tvec2 seat4CutB = vec2(\n\t\tfBox( p6 - vec3( 2.7, 10.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat4 = max( seat4, -seat4CutB );\n\t\n\t// Seat 5\n\t// ------\n\tvec3 p7 = p;\n\t// Rotate with the hoops.\n\tp7.y -= 7.0;\n\tp7 = rotateZ( p7, hoopRotVal );\n\tp7.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp7 -= vec3( 5.0, 7.0, 0.0 );\n\tp7 = rotateZ( p7, -hoopRotVal );\n\tp7 += vec3( 5.0, 7.0, 0.0 );\n\t\t\n\tobjID = 7.0;\n\tvec2 seat5 = vec2(\n\t\tfBox( p7 - vec3( 5.0, 7.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat5CutA = vec2(\n\t\tfBox( p7 - vec3( 4.9, 7.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat5 = max( seat5, -seat5CutA );\n\t\n\tvec2 seat5CutB = vec2(\n\t\tfBox( p7 - vec3( 4.3, 7.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat5 = max( seat5, -seat5CutB );\n\t\n\t// Seat 6\n\t// ------\n\tvec3 p8 = p;\n\t// Rotate with the hoops.\n\tp8.y -= 7.0;\n\tp8 = rotateZ( p8, hoopRotVal );\n\tp8.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp8 -= vec3( 3.4, 3.5, 0.0 );\n\tp8 = rotateZ( p8, -hoopRotVal );\n\tp8 += vec3( 3.4, 3.5, 0.0 );\n\t\t\n\tobjID = 8.0;\n\tvec2 seat6 = vec2(\n\t\tfBox( p8 - vec3( 3.4, 3.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat6CutA = vec2(\n\t\tfBox( p8 - vec3( 3.3, 4.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat6 = max( seat6, -seat6CutA );\n\t\n\tvec2 seat6CutB = vec2(\n\t\tfBox( p8 - vec3( 2.7, 3.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat6 = max( seat6, -seat6CutB );\n\t\n\t// Seat 7\n\t// ------\n\tvec3 p9 = p;\n\t// Rotate with the hoops.\n\tp9.y -= 7.0;\n\tp9 = rotateZ( p9, hoopRotVal );\n\tp9.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp9 -= vec3( 0.0, 2.0, 0.0 );\n\tp9 = rotateZ( p9, -hoopRotVal );\n\tp9 += vec3( 0.0, 2.0, 0.0 );\n\t\t\n\tobjID = 9.0;\n\tvec2 seat7 = vec2(\n\t\tfBox( p9 - vec3( 0.0, 2.0, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat7CutA = vec2(\n\t\tfBox( p9 - vec3( -0.1, 2.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat7 = max( seat7, -seat7CutA );\n\t\n\tvec2 seat7CutB = vec2(\n\t\tfBox( p9 - vec3( -0.7, 2.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat7 = max( seat7, -seat7CutB );\n\t\n\t// Seat 8\n\t// ------\n\tvec3 p10 = p;\n\t// Rotate with the hoops.\n\tp10.y -= 7.0;\n\tp10 = rotateZ( p10, hoopRotVal );\n\tp10.y += 7.0;\n\t// Rotate around its own z-axis.\n\tp10 -= vec3( -3.4, 3.5, 0.0 );\n\tp10 = rotateZ( p10, -hoopRotVal );\n\tp10 += vec3( -3.4, 3.5, 0.0 );\n\t\t\n\tobjID = 10.0;\n\tvec2 seat8 = vec2(\n\t\tfBox( p10 - vec3( -3.4, 3.5, 0.0 ), vec3( 0.5, 0.75, 0.75 ) ), objID );\n\t\n\tvec2 seat8CutA = vec2(\n\t\tfBox( p10 - vec3( -3.5, 4.1, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\n\tseat8 = max( seat8, -seat8CutA );\n\t\n\tvec2 seat8CutB = vec2(\n\t\tfBox( p10 - vec3( -4.1, 3.6, 0.0 ), vec3( 0.5, 0.75, 0.8 ) ), objID );\n\t\t\t\t\t\t\n\tseat8 = max( seat8, -seat8CutB );\n\t\n\t//---------------------------------------------------\n\t\n\tvec2 closest = ground.s < groundBeam.s ? ground : groundBeam;\n\tclosest = closest.s < brace1.s ? closest : brace1;\n\tclosest = closest.s < brace2.s ? closest : brace2;\n\tclosest = closest.s < crossBeam.s ? closest : crossBeam;\n\t\n\tclosest = closest.s < outerHoop.s ? closest : outerHoop;\n\tclosest = closest.s < innerHoop.s ? closest : innerHoop;\n\tclosest = closest.s < axleHoop.s ? closest : axleHoop;\n\tclosest = closest.s < tower.s ? closest : tower;\n\tclosest = closest.s < arm1.s ? closest : arm1;\n\tclosest = closest.s < arm2.s ? closest : arm2;\n\tclosest = closest.s < arm3.s ? closest : arm3;\n\tclosest = closest.s < arm4.s ? closest : arm4;\n\tclosest = closest.s < axle.s ? closest : axle;\n\t\n\tclosest = closest.s < seat1.s ? closest : seat1;\n\tclosest = closest.s < seat2.s ? closest : seat2;\n\tclosest = closest.s < seat3.s ? closest : seat3;\n\tclosest = closest.s < seat4.s ? closest : seat4;\n\tclosest = closest.s < seat5.s ? closest : seat5;\n\tclosest = closest.s < seat6.s ? closest : seat6;\n\tclosest = closest.s < seat7.s ? closest : seat7;\n\tclosest = closest.s < seat8.s ? closest : seat8;\n\t\n\t//---------------------------------------------------\n\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID )\n{    \n    vec3 col = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tcol = vec3( 0.0, 1.0, 0.0 );\n\t}\n\telse if ( objNum == 2.0 )\n\t{\n\t\tcol = vec3( 0.95, 0.95, 1.0 );\n\t}\n\telse if ( objNum == 3.0 )\t// seat 1\n\t{\n\t\tcol = vec3( 1.0, 0.0, 0.0 );\n\t}\n\telse if ( objNum == 4.0 )\n\t{\n\t\tcol = vec3( 1.0, 0.5, 0.0 );\n\t}\n\telse if ( objNum == 5.0 )\t// seat 3\n\t{\n\t\tcol = vec3( 1.0, 1.0, 0.0 );\n\t}\n\telse if ( objNum == 6.0 )\n\t{\n\t\tcol = vec3( 0.5, 1.0, 0.0 );\n\t}\n\telse if ( objNum == 7.0 )\t// seat 5\n\t{\n\t\tcol = vec3( 0.0, 1.0, 1.0 );\n\t}\n\telse if ( objNum == 8.0 )\n\t{\n\t\tcol = vec3( 0.0, 0.0, 1.0 );\n\t}\n\telse if ( objNum == 9.0 )\t// seat 7\n\t{\n\t\tcol = vec3( 0.5, 0.0, 1.0 );\n\t}\n\telse if ( objNum == 10.0 )\n\t{\n\t\tcol = vec3( 1.0, 0.0, 0.5 );\n\t}\n\t    \n    return col;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// For Gardner Cos Clouds skyColor()\n\tvec2 st = fragCoord;\n\tst.x *= 0.5;\n\tst.x += sin( iTime * 0.1 ) * 0.5;\n\tst.y *= 0.75;\n\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = LIGHT_POS;\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = skyColor( st );\n\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( FAR * 0.8, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID ) * 0.45;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4( clamp( sceneColor, 0.0, 1.0 ), 1.0 );\n    \n}\n\n//------------------------------------------------------------------------------\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// \thttps://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = iTime * 0.2;\n\t}\n\telse\n\t{\n\t\tang = ( iMouse.x - iResolution.x * 0.5 ) * rotRange;\n\t}\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n    if( iMouse.z < 1.0 ) \n    {\n\t\tang = 0.25 * ( sin( iTime * 0.1 ) + 1.0 ) + PI_16;\n\t}\n\telse\n\t{\n\t\tang = ( 0.4825 * iMouse.y - iResolution.y * 0.5 ) * rotRange + PI_16; \n\t}\n\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n        dist += min( h, stepDist * 2.0 ); \n        \n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // Add 0.5 to the final shade value, which lightens the shadow a bit. \n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID )\n                                                               \n{    \n    // Light direction vector.\n    vec3 lDir = LIGHT_POS - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    vec3 objCol = getObjectColor( sp, distID );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + vec3( 1.0, 0.6, 0.2 ) *\n                                                          spec * 2.0 ) * atten;\n   \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n// SKY COLOR\n// ---------\n// https://www.shadertoy.com/view/lll3z4\n// Gardner Cos Clouds  Uploaded by fab on 2014-Dec-24\n/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n */\n \nvec3 skyColor( vec2 pix )\n{\n\tconst int nTerms = 10;\n\t\n\tfloat zoom = 1.0,\n          cloudDensity = 0.0,\n          amplitude = 0.45,\n          xphase = 0.9 * iTime,\n          yphase = 0.7,\n          xfreq = 2.0 * PI * 0.023,\n          yfreq = 2.0 * PI * 0.021,\n    \n          offset = 0.5,\n          xoffset = 37.0,\n          yoffzet = 523.0,\n    \n          x = pix.x,\n          y = pix.y,\n\t      scale = 1.0 / iResolution.x * 60.0 * 1.0 / zoom;\n\n    x = x * scale + offset + iTime * 1.5;\n    y = y * scale + offset - iTime / 2.3;\n    \n    for ( int i = 0; i < nTerms; i++ )\n    {\n        float fx = amplitude * ( offset + cos( xfreq * ( x + xphase ) ) );\n        float fy = amplitude * ( offset + cos( yfreq * ( y + yphase ) ) );\n        cloudDensity += fx * fy;\n        xphase = PI * 0.5 * 0.9 * cos( yfreq * y );\n        yphase = PI * 0.5 * 1.1 * cos( xfreq * x );\n        amplitude *= 0.602;\n        xfreq *= 1.9 + float( i ) * .01;\n        yfreq *= 2.2 - float( i ) * 0.08;\n    }\n\n    return mix( vec3(0.4, 0.6, 0.9 ), vec3( 1.0 ), cloudDensity );   \n}\n\n// end skyColor()\n\n//------------------------------------------------------------------------------\n\n// ROTATE Z\n// --------\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//------------------------------------------------------------------------------\n// The code below is excerpted from:\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdSzN", "name": "Custom Noise", "author": "pixartist", "description": "A combination of two widely used noise algorithms, with a custom seed algorithm. No idea about the mathematical value of this, but I have used it for quite long path-tracing implementations and it proved to produce nearly zero randomization artefacts.", "tags": ["noise", "random", "gaussian", "artefacts", "randomize"], "likes": 9, "viewed": 804, "date": "1458043591", "time_retrieved": "2024-06-20T18:33:16.965568", "image_code": "\nfloat seed = 0.0;\nvoid init(vec2 uv)\n{\n    seed = (uv.y + iTime * 0.523413187) * sqrt(uv.x * 0.77777777 * iTime);\n}\n\nfloat rand(vec2 s) \n{ \n    float n = fract(sin(seed+=1.0)*43758.5453123);\n    return fract(n + fract(sin(dot(vec2(n * s.y, s.x)*0.123,vec2(12.9898,78.233))) * 43758.5453));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    init(uv);\n    \n\tfragColor = vec4(rand(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdSzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdXRn", "name": "Magnectic Mouse Effect", "author": "vamoss", "description": "Original Work http://netgrind.tumblr.com/post/82030732540/spinbow", "tags": ["line", "angle", "magnectic", "pointing"], "likes": 10, "viewed": 232, "date": "1457367986", "time_retrieved": "2024-06-20T18:33:16.965568", "image_code": "/*\nOriginal Work\nhttp://netgrind.tumblr.com/post/82030732540/spinbow\n*/\n\n#define PI 3.141592653589\n#define TWO_PI 6.28318530718\n\n//  Function from Iigo Quiles \n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat line(vec2 uv, vec2 origin, vec2 destiny, float radius){\n    destiny -= origin;\n\tfloat color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );\n    return smoothstep(color-0.05,color+0.05, radius);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //tile\n    vec2 frequency = vec2(32.0, 18.0);\n    vec2 index = floor(frequency * uv)/frequency;\n    vec2 uvTiled = fract(frequency * uv);\n\t\n    //line\n    float lineWidth = 0.15;\n    float lineLenght = 0.3;\n    vec2 origin = index;\n    vec2 dest=iMouse.xy/iResolution.xy-0.5/frequency;\n    \n    //thumbnail mouseover\n    if(iMouse.x==0.0){\n        float ratio = iResolution.y/iResolution.x;\n    \tdest.x = (cos(iTime*3.0)*0.4)*ratio+0.5;\n    \tdest.y = sin(iTime*3.0)*0.4+0.5;\n    }\n    \n    float angle = atan((dest.y-origin.y),(dest.x-origin.x));\n    \n    //line width in relation with distance\n    float distance = 1.-distance(origin, dest);\n    \n    //pulsate\n    //distance += (sin(3.0*iTime+l*20.0)+1.0)/4.0;\n    \n    lineWidth *= distance;\n    \n    //make line go to both direction around center\n    origin = vec2(cos(angle)*lineLenght,sin(angle)*lineLenght)+0.5;\n    dest = vec2(cos(angle)*-lineLenght,sin(angle)*-lineLenght)+0.5;\n    \n    //animate colors\n    //angle+=iTime*4.0;\n    \n\tvec3 color = line(uvTiled, origin, dest, lineWidth) * hsb2rgb(vec3(angle/TWO_PI,0.3,1.0));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdXzr", "name": "Cracker cars", "author": "zackpudil", "description": "A universe of cracker cars ~ 1 hrs", "tags": ["raymarching", "distancefields"], "likes": 5, "viewed": 283, "date": "1457398381", "time_retrieved": "2024-06-20T18:33:16.965568", "image_code": "float dBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n \nfloat dCylinder(vec3 p, vec2 c) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n \nvoid rotate(inout vec2 p, float a, float f) {\n\tp = mat2(a*cos(f), a*sin(f), -a*sin(f), a*cos(f))*p;\n}\n \nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n \nvec2 scene(vec3 p, bool db) {\n\trotate(p.zy, 1.0, db ? -iTime : iTime);\n\tp.y = abs(p.y) - 3.15 - 0.02*sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z);\n\tvec2 d1 = vec2(dBox(p, vec3(0.3, 0.1, 0.5)), 1.0);\n \n\trotate(p.xz, 1.0, 3.14/2.0);\n\trotate(p.zy, 1.0, 3.14/2.0);\n\t\n\tp.x = abs(p.x) - 0.4;\n\tp.y = abs(p.y) - 0.3;\n\t\n\tvec2 d2 = vec2(dCylinder(p, vec2(0.2, 0.03)), 2.0);\n\t\n\treturn opU(d1, d2);\n}\n \nvec2 map(vec3 p) {\n    vec2 chk = mod(p.xz + 4.0, 16.0) - 8.0;\n\tp.xz = mod(p.xz + 4.0, 8.0) - 4.0;\n    bool db = chk.x*chk.y < 0.0;\n\tvec2 w = vec2(length(p) - 3.0 + 0.05*sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z), 0.0);\n\tvec2 s1 = scene(p, db);\n\tp = p.yzx;\n\tvec2 s2 = scene(p, db);\n\tp = p.yzx;\n\tvec2 s3 = scene(p, db);\n\t\n\tvec2 s = opU(s1, opU(s2, s3));\n\t\n\treturn opU(w, s);\n}\n \nvec2 intersect(vec3 ro, vec3 rd) {\n\tfloat mid = 0.0;\n\tfloat td = 0.0;\n\t\n\tfor(int i = 0; i < 128; i++) {\n\t\tvec2 s = map(ro + rd*td);\n\t\tif(s.x == 0.0) break;\n\t\ttd += s.x;\n\t\tmid = s.y;\n\t}\n\t\n\tif(td > 50.0) mid = -1.0;\n\treturn vec2(td, mid);\n}\n \nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.01, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy).x - map(p - h.xyy).x,\n\t\tmap(p + h.yxy).x - map(p - h.yxy).x,\n\t\tmap(p + h.yyx).x - map(p - h.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n \nfloat shadow(vec3 p, vec3 lig) {\n\tfloat res = 1.0;\n\tfloat td = 0.02;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tfloat h = map(p + lig*td).x;\n\t\ttd += h;\n\t\tres = min(res, 8.0*h/td);\n\t\tif(h == 0.0 || td > 10.0) break;\n\t}\n\t\n\treturn clamp(res, 0.0, 1.0);\n}\n \nvec3 lighting(vec3 p, vec3 l, vec3 rd) {\n\tvec3 lig = normalize(l);\n\tvec3 n = normal(p);\n\tvec3 ref = reflect(n, rd);\n\t\n\tfloat amb = clamp(0.7, 0.0, 1.0);\n\tfloat dif = clamp(dot(n, lig), 0.0, 1.0);\n\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 152.0);\n\t\n\tdif *= shadow(p, lig);\n\t\n\tvec3 lin = vec3(0);\n\t\n\tlin += 0.3*amb*vec3(1);\n\tlin += 0.8*dif*vec3(1.0, .97, .85);\n\tlin += spe*vec3(1.0, .97, .56)*dif;\n\t\n\treturn lin;\n}\n \nmat3 camera(vec3 e, vec3 la) {\n\tvec3 roll = vec3(0, 1, 0);\n\tvec3 f = normalize(la - e);\n\tvec3 r = normalize(cross(roll, f));\n\tvec3 u = normalize(cross(f, r));\n\t\n\treturn mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0+2.0*(fragCoord/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\t\n \n\tvec3 la = 4.0*vec3(cos(iTime*0.3), 0, -sin(iTime*0.3));\n\tvec3 ro = 3.0*vec3(1, 3.0, 0);\n\tvec3 rd = camera(ro, la)*normalize(vec3(uv, 2.0));\n \n\tvec3 l = 3.0*vec3(cos(iTime*0.2), 1.0, -sin(iTime));\n    \n    vec3 col = vec3(.34, .54, .89);\n\tcol *= mix(0.6, 1.0, uv.y);\n\tvec2 i = intersect(ro, rd);\n\t\n\tif(i.y > -1.0) {\n\t\tvec3 p = ro + rd*i.x;\n\t\tif(i.y == 0.0) col = vec3(.75, 0, .85);\n\t\tif(i.y == 1.0) col = vec3(.95, .34, 0);\n\t\tif(i.y == 2.0) col = vec3(.7, .4, .5);\n\t\tcol *= lighting(p, l, rd);\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdXzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sKGWt", "name": "Sky and Ground", "author": "morgan3d", "description": "Very fast environment for bringing up renderers without external data. Sky is based on elevated by iq.  Mouse to rotate.\n\nUsed in my Minmal OpenGL example http://g3d.cs.williams.edu/websvn/listing.php?repname=g3d&path=%2FG3D10%2Fsamples%2FminimalOpenGL%", "tags": ["sky"], "likes": 29, "viewed": 1175, "date": "1457105767", "time_retrieved": "2024-06-20T18:33:17.608128", "image_code": "// License: BSD\n// by Morgan McGuire, @CasualEffects\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    float f = 0.5000 * noise(p); p = m2 * p * 2.02;\n    f += 0.2500 * noise(p); p = m2 * p * 2.03;\n    f += 0.1250 * noise(p); p = m2 * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\nvec3 render(in vec3 light, in vec3 ro, in vec3 rd, in float resolution) {\n    vec3 col;\n    \n    if (rd.y < 0.0) {\n        // Hit ground plane y = 0 at this distance       \n    \tfloat t = -ro.y / rd.y;\n        \n        // Convert the hit point to a texture coordinate at meter scale\n        vec2 P = ro.xz + t * rd.xz;\n        vec2 Q = floor(P);\n        P = mod(P, 1.0);\n\n\n        // Apply procedural grid texture\n        const float gridLineWidth = 0.1;\n        \n        float res = clamp(2048.0 / resolution, 1.0, 3.0);\n        P = 1.0 - abs(P - 0.5) * 2.0;\n        float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(t + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n \n        float shade = mix(hash(100.0 + Q * 0.1) * 0.4, 0.3, min(t * t * 0.001, 1.0)) + 0.6;\n        col = vec3(pow(d, \n                       clamp(150.0 / (pow(max(t - 2.0, 0.1), res) + 1.0), 0.1, 15.0)\n                  )) * shade + 0.1;\n        \n    } else {        \n        // Sky with haze\t\t\n        col = vec3(0.3, 0.55, 0.8) * (1.0 - 0.8 * rd.y) * 0.9;\n        \n        // Sun\n        float sundot = clamp(dot(rd, light), 0.0, 1.0);\n        col += 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 8.0);\n        col += 0.75 * vec3(1.0, 0.8, 0.5) * pow(sundot, 64.0);\n\n        // Clouds\n        col = mix(col, vec3(1.0, 0.95, 1.0), 0.5 * \n                  smoothstep(0.5, 0.8, fbm((ro.xz + rd.xz * (250000.0 - ro.y) / rd.y) * 0.000008)));\n    }\n\t\n    // Horizon/atmospheric perspective\n    col = mix(col, vec3(0.7, 0.75, 0.8), pow(1.0 - max(abs(rd.y), 0.0), 8.0));\n    \n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tconst float verticalFieldOfView = 50.0 * 3.1415927 / 180.0;\n\n    vec3 cameraOrigin = vec3(-iTime, sin(iTime) + 2.1, 0.0);\n    float yaw = 2.0 * iMouse.x/iResolution.x;\n    float pitch = -2.0 * (iMouse.y / iResolution.y - 0.5);\n \n    if (iMouse.x == 0.0) {\n        // Shadertoy starting position\n        yaw = 1.0; pitch = 0.0;\n    }\n    \n    vec3 ro = cameraOrigin;\n    vec3 rd = normalize(vec3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y * 0.5 / -tan(verticalFieldOfView * 0.5)));\n    \n    mat3 yawMatrix = mat3(cos(yaw), 0.0, -sin(yaw),\n                  0.0, 1.0, 0.0,\n                  sin(yaw), 0.0, cos(yaw));\n    \n    mat3 pitchMatrix = mat3(1.0, 0.0, 0.0,\n                  0.0, cos(pitch), sin(pitch),\n                  0.0, -sin(pitch), cos(pitch));\n\n    rd = yawMatrix * pitchMatrix * rd;\n\n    vec3 light = normalize(vec3(-0.8,0.3,-0.3));\n\n    vec3 col = render(light, ro, rd, iResolution.y);\n \n    // Gamma encode\n\tcol = pow(col, vec3(0.4545));\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "bsd-new", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ssSW8", "name": "Julia's Horizon", "author": "cafe", "description": "Julia's Horizon", "tags": ["juliashorizon"], "likes": 2, "viewed": 94, "date": "1456830179", "time_retrieved": "2024-06-20T18:33:17.608128", "image_code": "vec3 warp(vec3 p){\n\tp=abs(p)/dot(p,p);\n\treturn p;\t\n}\n\nfloat dist(vec3 p){\n    float time = sin(iTime*3.14159*0.1)*6.-1.;\n\tfor(int i=0 ; i<30 ; i++)\n\t\tp=warp(p)-vec3(0.43,0.28,0.31)+time*0.005-0.01;\n\treturn length(p*5.);\t\n}\n\nfloat intersect(vec3 ro, vec3 rd){\n\n\tfloat d=1000000.,\n\t\t  t=0.001;\n\t\n\tfor(int i=0 ; i<50 ; i++){\n\t\tfloat td=dist(ro+t*rd);\n\t\td=min(d+t*1.,td);\n\t\tt+=0.001;\n\t}\n\treturn d;\n}\n\nvec3 shade(vec2 uv){\n\t\n\tvec3 ro=vec3(-0.21,0.203,-0.25);\n\tvec3 rd=normalize(vec3(uv,-1.));\n\t\n\tfloat d = intersect(ro,rd);\n\td=exp(-exp(-d*2.2)*40.);\n\t//d=sin(d*12.+1.)*0.5+0.5;\n\t\n\treturn vec3(d)*vec3(3.,1.35,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ssSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSWr", "name": "goo somethings", "author": "MacSlow", "description": "Still trying to learn... distorting and twisting space is so much fun! Sadly this ruins the consistency of the distance-fields in most cases, thus artefacts show up in the shadows and at object silhouettes. To counter that, I've reduced the step-size :/", "tags": ["raymarching", "noise"], "likes": 6, "viewed": 430, "date": "1458819436", "time_retrieved": "2024-06-20T18:33:19.723407", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2016 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool VISUALIZE_DEPTH = false;\nconst int MAX_STEPS = 128;\nconst float LARGE_STEP = .5;   // these should be 1.6 and 1.0 usually, but deforming\nconst float SMALL_STEP = .25;  // and bending some objects require smaller steps :/\n\nfloat hash (float f)\n{\n\treturn fract (sin (f) * 45734.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\nmat3 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 ( c, .0, -s),\n                     vec3 (.0, 1,  .0),\n                     vec3 ( s, .0,  c));\n\n    return mat;\n}\n\nmat3 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (  c,  -s, 0.0),\n                     vec3 (  s,   c, 0.0),\n                     vec3 (0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat fbm (vec3 p)\n{\n\tmat3 m1 = mat3 (rotZ (23.4));\n\tmat3 m2 = mat3 (rotZ (45.5));\n\tmat3 m3 = mat3 (rotZ (77.8));\n\n    float result = .0;\n    result = 0.5 * noise3d (p);\n    p *= m1 * 2.02;\n    result += 0.25 * noise3d (p);\n    p *= m2 * 2.03;\n    result += 0.125 * noise3d (p);\n    p *= m3 * 2.04;\n    result += 0.0625 * noise3d (p);\n    result /= 0.9375;\n\n    return result;\n}\n\nfloat sphere (vec3 p, float size)\n{\n\treturn length (p) - size;\n}\n\nfloat box (vec3 p, float size)\n{\n\treturn length (max (abs (p) - vec3 (size), .0)) - .2*size;\n}\n\nfloat plane (vec3 p)\n{\n    return p.y + .25;\n}\n\nfloat opRepeat (inout float v, float w)\n{\n    float halfSize = w / 2.;\n    v = mod(v + halfSize, w) - halfSize;\n\n    return .0;\n}\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad * p.y);\n    float s = sin (rad * p.y);\n    mat2  m = mat2 (c, -s, s, c);\n    p = vec3 (m * p.xy, p.z);\n    return .0;\n}\n\nfloat opRepeat2 (inout vec2 v, float w)\n{\n    float halfSize = w / 2.;\n    v = mod(v + vec2 (halfSize), vec2 (w)) - vec2 (halfSize);\n\n    return .0;\n}\n\nfloat displace (vec3 p, int flag)\n{\n    float result = 1.;\n\n    if (flag == 0) {\n        result = .75 * fbm (.75 * (.5 + .25 * cos (iTime)) * p);\n    } else if (flag == 1) {\n        result =  sin (2. * p.x) * cos (2. * p.y) * sin (2. * p.z);\n    } else if (flag == 2) {\n        result = (.5 + .5 * (1. + cos (iTime))) * fbm (p);\n    }\n\n    return result;\n}\n\nvec2 map (vec3 p)\n{\n\t// this let's an index loop through 0, 1, 2 for selecting the object to draw\n    int object = int (floor (3. * (1. + sin (.25 * iTime)) / 2.));\n\n    float dt = .0;\n    float dp = .0;\n\tvec3 w = vec3 (.0);\n\tvec2 d1 = vec2 (.0);\n\tmat3 m = rotY (20. * iTime) * rotZ (-20. * iTime);\n\n    // floor\n    vec2 d2 = vec2 (plane (p), 2.);\n\n    if (object == 0) {\n        // redish cube\n        w = m * vec3 (p + vec3 (.0, -1.5, .0));\n        dt = box (w, 1.125);\n        dp = displace (w, object);\n        d1 = vec2 (dt + dp, 1.);\n    } else if (object == 1) {\n        // blue thingy\n        w = -m * (p + vec3 (.0, -1.5, .0));\n        opBend (w, 42.5 * cos (iTime));\n        dt = sphere (w, 1.);\n        dp = displace (w, object);\n        d1 = vec2 (dt + dp, 3.);\n    } else if (object == 2) {\n        // green blob\n        w = p + vec3 (.0, -1.5, .0);\n        dt = sphere (w, 1.);\n        dp = displace (w, object);\n        d1 = vec2 (dt + dp, 4.);\n    }\n\n    // only the nearest survives :)\n    if (d2.x < d1.x) {\n        d1 = d2;\n    }\n\n\treturn d1;\n}\n\nvec3 normal (vec3 p)\n{\n\tvec3 n;\n    vec2 e = vec2 (.001, .0);\n    n.x = map (p + e.xyy).x - map (p - e.xyy).x;\n    n.y = map (p + e.yxy).x - map (p - e.yxy).x;\n    n.z = map (p + e.yyx).x - map (p - e.yyx).x;\n    return normalize (n);\n}\n\n\nvec3 march (vec3 ro, vec3 rd)\n{\n    float pixelSize = 1. / iResolution.x;\n    bool forceHit = true;\n    float infinity = 10000000.0;\n    float t_min = .0000001;\n    float t_max = 1000.0;\n    float t = t_min;\n    vec3 candidate = vec3 (t_min, .0, .0);\n    vec3 candidate_error = vec3 (infinity, .0, .0);\n    float w = LARGE_STEP;\n    float lastd = .0;\n    float stepSize = .0;\n    float sign = map (ro).x < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n\t{\n        float signedd = sign * map (ro + rd * t).x;\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = SMALL_STEP;\n        } else {\n            stepSize = signedd * w;\n        }\n\n\t\tlastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error.x) {\n            candidate_error.x = error;\n            candidate.x = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n        \tbreak;\n\t\t}\n\n        candidate_error.y = map (ro + rd * t).y;\n        candidate.y = candidate_error.y;\n\n        candidate_error.z = float (i);\n        candidate.z = candidate_error.z;\n\n        t += stepSize;\n \n\t}\n\n    if ((t > t_max || candidate_error.x > pixelSize) && !forceHit) {\n        return vec3 (infinity, .0, .0);\n    }\n\n\treturn candidate;\n}\n\nfloat shadow (vec3 ro, vec3 rd)\n{\n    float result = 1.;\n    float t = .1;\n    for (int i = 0; i < 32; i++) {\n        float h = map (ro + t * rd).x;\n        if (h < 0.00001) return .0;\n        result = min (result, 8. * h/t);\n        t += h;\n    }\n\n    return result;\n}\n\nvec3 boxMaterial (vec3 pos)\n{\n\tvec3 col = vec3 (1., .0, .0);\n    float f = fbm (5. * pos);\n    col = mix (col, vec3 (1., .5, .25), f);\n\n    return col;\n}\n\nvec3 floorMaterial (vec3 pos)\n{\n    vec3 col = vec3 (.6, .5, .3);\n    float f = fbm (pos * vec3 (6., .0, .5));\n    col = mix (col, vec3 (.3, .2, .1), f);\n    f = smoothstep (.6, 1., fbm (48. * pos));\n    col = mix (col, vec3 (.2, .2, .15), f);\n\n    return col;\n}\n\nvec3 blobMaterial (vec3 pos)\n{\n\treturn vec3 (.2, .75, .1);\n}\n\nvec3 thingMaterial (vec3 pos)\n{\n\treturn vec3 (.0, .2, .8);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspect = vec2 (iResolution.x/ iResolution.y, 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = vec2 (-1. + 2. * uv) * aspect;\n\n    vec3 ro = 3.5 * vec3 (cos (.2 * iTime), 1.25, sin (.2 * iTime));\n    vec3 ww = normalize (vec3 (.0, 1., .0) - ro);\n    vec3 uu = normalize (cross (vec3 (.0, 1., .0), ww));\n    vec3 vv = normalize (cross (ww, uu));\n    vec3 rd = normalize (p.x * uu + p.y * vv + 1.5 * ww);\n\n    // \"look\" into the world\n    vec3 t = march (ro, rd);\n\n    // base infinity-color (when nothing was \"seen\")\n    vec3 col = vec3 (.8);\n\n    // otherwise do all the lighting- and material-calculations\n    if (t.y > .5) {\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = normal (pos);\n        vec3 lig = normalize (vec3 (1., .8, .6));\n        vec3 blig = normalize (vec3 (-lig.x, lig.y, -lig.z));\n        vec3 ref = normalize (reflect (rd, nor));\n\n        float con = 1.;\n        float amb = .5 + .5 * nor.y;\n        float diff = max (dot (nor, lig), .0);\n        float bac = max (.2 + .8 * dot (nor, blig), .0);\n        float sha = shadow (pos, lig);\n        float spe = pow (clamp (dot (ref, lig), .0, 1.), 8.);\n        float rim = pow (1. + dot (nor, rd), 2.5);\n\n        col  = con  * vec3 (.1, .15, .2);\n        col += amb  * vec3 (.1, .15, .2);\n        col += diff * vec3 (1., .97, .85) * sha;\n        col += spe * vec3 (.9, .9, .9);\n        col += bac;\n\n        // either display ray-marching depth or materials\n        if (VISUALIZE_DEPTH) {\n\t        col *= vec3 (1. - t.z / float (MAX_STEPS));\n        } else {\n            if (t.y == 1.) {\n                col *= boxMaterial (pos);\n            } else if (t.y == 2.) {\n                col *= floorMaterial (pos);\n            } else if (t.y == 3.) {\n                col *= thingMaterial (pos);\n            } else if (t.y == 4.) {\n                col *= blobMaterial (pos);\n            }\n        }\n\n        col += .6 * rim * amb;\n        col += .6 * spe * sha * amb;\n\n        // color-correction\n        col = .1 * col + .9 * sqrt (col);\n        col *= vec3 (.9, .8, .7);\n    }\n\n    // put slight vignette over image\n    col *= .2 + .8 * pow (16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .2);\n\n    // after all this work, put the final color to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stSz4", "name": "edge fork", "author": "penna", "description": "forked", "tags": ["forkedge"], "likes": 1, "viewed": 114, "date": "1457993662", "time_retrieved": "2024-06-20T18:33:19.953687", "image_code": "// Bump up the iterations!\n// More iterations means more detail + aliasing\n#define ITERATIONS 20\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float mouseDown = step(.05, iMouse.z);\n    float scale = mix(1., .4, mouseDown);\n    vec2 look = (iMouse.xy / iResolution.xy - .5) * 3. * mouseDown;\n    \n    float time = iTime * 2. + 15.;\n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord.xy / res - vec2(.5) + look;\n    uv *= vec2(res.x / res.y, 1.) * 4. * scale;\n    \n    float len = dot(uv, uv) * .3 - .4;\n    \n    vec3 z = sin(time * vec3(.23, .19, .17));\n    for (int i = 0; i < ITERATIONS; i++) {\n        z += cos(z.zxy + uv.yxy * float(i) * len);\n    }\n    \n    float val = z.r * .06 + .3;\n    val -= smoothstep(.1, -.3, len) * 1.5 + len * .3 - .4;\n    fragColor = vec4(0.1, 0.0, 0.6, 0.8) * vec4(vec3(max(val, .1)), 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXXz4", "name": "perlinmeh", "author": "cafe", "description": "Absolutely terrible perlin implementation, don't look at it.\n\nMay cause:\n- Headache or pain behind or above the eye\n- Nausea/Vomiting\n- Loss of consciousness\n- Numbness, weakness or paralysis of one side of the face", "tags": ["ohgodmyeyes"], "likes": 3, "viewed": 110, "date": "1456829756", "time_retrieved": "2024-06-20T18:33:20.323365", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,8.233))) * 43758.5453);\n}\n\nfloat interp(float a, float b, float x){\n\tx=smoothstep(0.,1.,x);\n\treturn a*(1.-x)+b*x;\n}\n\nfloat snoise(vec2 p,float mul){\n\t\n\t//float mul=10.;\n\t\n\tvec2 i = fract(p*mul);\n\t\n\tvec2 p1 = floor(p*mul),\n\t\t p2 = floor(p1+vec2(1.,0.)),\n\t\t p3 = floor(p1+vec2(0.,1.)),\n\t\t p4 = floor(p1+vec2(1.,1.));\n\t\n\tfloat v11 = rand(p1),\n\t\t  v12 = rand(p2),\n\t\t  v21 = rand(p3),\n\t\t  v22 = rand(p4);\n\n\tfloat v1 = interp(v11,v12,i.x),\n\t\t  v2 = interp(v21,v22,i.x),\n\t\t  v  = interp(v1,v2,i.y);\n\t\n\treturn v;\n}\n\nfloat perlin(vec2 p){\n\t\n\tfloat v =  snoise(p+iTime/256.,2. )/2. +\n\t\t\t   snoise(p+sin(iTime/128.),4. )/4. +\n\t\t\t   snoise(p+cos(iTime/64.),8. )/8. +\n\t\t\t   snoise(p+iTime/32.,16.)/16.+\n\t\t\t   snoise(p+iTime/16.,32.)/32.+\n\t\t\t   snoise(p+iTime/32.,64.)/128.;;\n\t\n\treturn v;\t\n}\n\nfloat hnormal(mat2 v, float inc){\n\t\n\tvec2 sl=vec2(mix(v[0][1],v[1][1],0.5)-mix(v[0][0],v[1][0],0.5),\n\t\t\t\t mix(v[1][0],v[1][1],0.5)-mix(v[0][0],v[0][1],0.5));\n\t\n\tvec3 n = normalize(vec3(-sl.x,-sl.y,inc));\n\t\n\treturn 1.-pow(length(sl),1.)*20.;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat ratio = iResolution.x/iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - vec2(ratio/2.,0.5))*2.;\n\t\n\t//vec3 color = vec3(perlin(uv+iTime/32.));\n\t\n\tfloat inc=0.01;\n\t\n\tvec3 color = vec3(hnormal(mat2(perlin(uv+vec2(-inc, inc)),\n\t\t\t\t\t\t\t       perlin(uv+vec2( inc, inc)),\n\t\t\t\t\t\t\t       perlin(uv+vec2(-inc,-inc)),\n\t\t\t\t\t\t\t       perlin(uv+vec2( inc,-inc))),inc));\n\t\n\tcolor.r=2.-abs(color.r-0.5)*10.;\n\tcolor.g=1.-abs(color.g-0.5)*10.;\n\tfloat stripes=8.;\n\tcolor.b=mod(color.b,1./stripes)*stripes*(color.b-0.5)*5.;\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sy3Wd", "name": "Convex Cone Tracing", "author": "paniq", "description": "Robust and fast conservative estimation of contours and surface limits of convex bodies using Newton-Raphson and a modification of the distance function to f(t) - t*C = 0, where C is the conic aperture.", "tags": ["convex", "newton", "silhouette", "conservative", "raphson"], "likes": 15, "viewed": 1426, "date": "1456955706", "time_retrieved": "2024-06-20T18:33:22.063080", "image_code": "\n#define MAX_STEPS 20\n\n#define DAValue vec4\n\nstruct DAVec3 {\n    DAValue x;\n    DAValue y;\n    DAValue z;\n};\n\nDAVec3 da_domain(vec3 p) {\n\treturn DAVec3(\n        DAValue(1.0,0.0,0.0,p.x),\n        DAValue(0.0,1.0,0.0,p.y),\n        DAValue(0.0,0.0,1.0,p.z));\n}\n\nDAValue da_const(float a) {\n    return DAValue(0.0,0.0,0.0,a);\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?x:1.0/x;\n}\n\nDAValue da_sub(DAValue a, DAValue b) {\n    return a - b;\n}\nDAValue da_sub(DAValue a, float b) {\n    return DAValue(a.xyz, a.w - b);\n}\nDAValue da_sub(float a, DAValue b) {\n    return DAValue(-b.xyz, a - b.w);\n}\n\nDAValue da_add(DAValue a, DAValue b) {\n    return a + b;\n}\nDAValue da_add(DAValue a, float b) {\n    return DAValue(a.xyz, a.w + b);\n}\nDAValue da_add(float a, DAValue b) {\n    return DAValue(b.xyz, a + b.w);\n}\n\nDAValue da_mul(DAValue a, DAValue b) {\n    return DAValue(a.xyz * b.w + a.w * b.xyz, a.w * b.w);\n}\nDAValue da_mul(DAValue a, float b) {\n    return a * b;\n}\nDAValue da_mul(float a, DAValue b) {\n    return a * b;\n}\n\nDAValue da_div(DAValue a, DAValue b) {\n    return DAValue((a.xyz * b.w - a.w * b.xyz) / (b.w * b.w), a.w / b.w);\n}\nDAValue da_div(DAValue a, float b) {\n    return a / b;\n}\nDAValue da_div(float a, DAValue b) {\n    return DAValue((-a * b.xyz) / (b.w * b.w), a / b.w);\n}\n\nDAValue da_min(DAValue a, DAValue b) {\n    return (a.w <= b.w)?a:b;\n}\nDAValue da_min(DAValue a, float b) {\n    return (a.w <= b)?a:da_const(b);\n}\nDAValue da_min(float a, DAValue b) {\n    return (a < b.w)?da_const(a):b;\n}\n\nDAValue da_max(DAValue a, DAValue b) {\n    return (a.w >= b.w)?a:b;\n}\nDAValue da_max(DAValue a, float b) {\n    return (a.w >= b)?a:da_const(b);\n}\nDAValue da_max(float a, DAValue b) {\n    return (a > b.w)?da_const(a):b;\n}\n\nDAValue da_pow2 (DAValue a) {\n    return DAValue(2.0 * a.w * a.xyz, a.w * a.w);\n}\n\nDAValue da_sqrt (DAValue a) {\n    float q = sqrt(a.w);\n    return DAValue(0.5 * a.xyz * safeinv(q), q);\n}\n        \nDAValue da_abs(DAValue a) {\n    return DAValue(a.xyz * sign(a.w), abs(a.w));\n}\nDAValue da_sin(DAValue a) {\n    return DAValue(a.xyz * cos(a.w), sin(a.w));\n}\nDAValue da_cos(DAValue a) {\n    return DAValue(-a.xyz * sin(a.w), cos(a.w));\n}\nDAValue da_log(DAValue a) {\n    return DAValue(a.xyz / a.w, log(a.w));\n}\nDAValue da_exp(DAValue a) {\n    float w = exp(a.w);\n    return DAValue(a.xyz * w, w);\n}\n\n\nDAValue da_length(DAValue x,DAValue y) {\n    float q = length(vec2(x.w,y.w));\n    return DAValue((x.xyz * x.w + y.xyz * y.w) * safeinv(q), q);\n}\nDAValue da_length(DAValue x,DAValue y,DAValue z) {\n    float q = length(vec3(x.w,y.w,z.w));\n    return DAValue((x.xyz * x.w + y.xyz * y.w + z.xyz * z.w) * safeinv(q), q);\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius\nDAValue sdSuperprim(DAVec3 p, vec4 s, vec2 r) {\n    DAValue dx = da_sub(da_abs(p.x),s.x);\n    DAValue dy = da_sub(da_abs(p.y),s.y);\n    DAValue dz = da_sub(da_abs(p.z),s.z);\n    DAValue q = \n        da_add(\n            da_length(\n                da_max(da_add(dx, r.x), 0.0),\n                da_max(da_add(dy, r.x), 0.0)),\n            da_min(-r.x,da_max(dx,dy)));\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s, out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nDAValue doobject (DAVec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec2 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdSuperprim(DAVec3(p.z, p.y, p.x), mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nDAValue doModel( DAVec3 p ) {\n    float k = iTime*0.5;\n    DAValue d = doobject(p, k);\n    return d;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\t//float precis = 0.86602540378444 * max(pixel.y,pixel.x);        // precission of the intersection\n    float precis = 0.70710678118655 * max(pixel.y,pixel.x);        // precission of the intersection\n    DAValue h;\n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    \n    for( int i=0; i<MAX_STEPS; i++ )          // max number of raymarching iterations is 90\n    {\n        steps = i;\n        DAValue dt = DAValue(1.0,0.0,0.0,t);\n        DAValue px = da_add(ro.x, da_mul(rd.x, dt));\n        DAValue py = da_add(ro.y, da_mul(rd.y, dt));\n        DAValue pz = da_add(ro.z, da_mul(rd.z, dt));\n\t    h = doModel(DAVec3(px,py,pz));\n        // apply conic shearing\n        h = da_sub(h, da_mul(dt, bias*precis));\n        // compute step size towards root\n        float st = abs(h.w) / max(-h.x,0.0);        \n        t += st;\n    \tif((abs(h.w) <= 1e-6) || (t > maxd)) {\n            break;\n        }\n    }\n    \n    if (abs(h.w) <= 1e-3)\n\t\tres = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    DAValue d = doModel(da_domain(pos));\n    return d.xyz;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    float dist;\n    float dist_inner;\n    float dist_outer;\n    \n    interior = false;\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n    \n    float K = 16.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 hresolution = floor((iResolution.xy + (K - 1.0)) / K);\n    vec2 hfragCoord = floor(uv * hresolution) + 0.5;\n    interior = false;\n    vec3 pos_inner;\n    int steps_inner;\n    bool hit_inner = dorender(dist_inner, steps_inner, pos_inner, hfragCoord, hresolution, -1.0);\n    interior = false;\n    vec3 pos_outer;\n    int steps_outer;\n    bool hit_outer = dorender(dist_outer, steps_outer, pos_outer, hfragCoord, hresolution, 1.0);\n    \n    fragColor = vec4(vec3(0.0),1.0);\n    if (hit_outer) {\n        if (hit_inner) {\n            if (hit) {\n\t        \tvec3 nor = calcNormal(pos);\n            \tfragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n            } else {\n                // must not happen\n                fragColor = vec4(vec3(1.0),1.0);\n            }\n        } else if (hit)\n            fragColor.g = 1.0;\t\n        else\n        \tfragColor.r = 1.0;\n\t} else if (hit) {\n        // must not happen\n        fragColor = vec4(vec3(1.0),1.0);\n    }\n\n    if (hit) {\n        // outer shell always closer than surface\n        if (dist < dist_outer)\n            fragColor = vec4(1.0,0.7,0.0,1.0);\n       \t// inner shell always contained within surface\n        else if (hit_inner && (dist_inner < dist))\n            fragColor = vec4(1.0,0.7,1.0,1.0);\n    }\n    //fragColor = vec4(normhue(dist_inner - dist),1.0);\n}", "image_inputs": [{"id": "4dX3zn", "previewfilepath": "/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3XRr", "name": "Dirty Water", "author": "Bers", "description": "A \"sunset dome\" I made a while ago recycled to test water reflections.", "tags": ["sunset", "water", "pbr"], "likes": 30, "viewed": 2032, "date": "1457309810", "time_retrieved": "2024-06-20T18:33:27.111962", "image_code": "// Author : Sbastien Brub\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// For this shader, a \"sunset dome\" I made a while ago was recycled to test Image-Based Lighting\n// PBR materials (water reflection). Not much effort was invested in the wave movement (sines), the focus\n// was rather on shimmering/reflection.\n//\n// Still a lot of room for improvement, most notably:\n//  -IBL PBR Material is expensive\n//  -Sampling pattern artifacts\n//  -Rocky formation look like bad CG from the '80s :). I need to improve my generative\n//   modeling skills.\n//  -Water surface lighting missing over reflexions.\n//  -Sky dome does not look good in some angles. Need to work on this too.\n//  -Fog, lens flares, etc.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Constants / enums\nconst float BUMP_MAP_UV_SCALE = 0.020;\nconst float MAX_DIST = 2000.0;\nconst float PI = 3.14159;\nconst vec3 LColor = vec3(1,0.95,0.7)*0.25;\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_SKY       = 2;\nconst int MATERIALID_STONE     = 3;\nconst int MATERIALID_WATER     = 4;\nconst int MATERIALID_B         = 5;\nconst int MATERIALID_C         = 6;\nconst int MATERIALID_D         = 7;\nconst int DEBUG_RAYLEN  = 0;\nconst int DEBUG_GEODIST = 1;\nconst int DEBUG_NORMAL  = 2;\nconst int DEBUG_MATUVW  = 3;\nconst int DEBUG_MATID   = 4;\nconst int DEBUG_ALPHA   = 5;\nconst float fWaterVariation = 0.35;\nconst float fMinWaterHeight = 0.0;\n\n//----------------------\n// Camera\nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 o; }; //Right, Up, Direction, origin\nCam    CAM_animate(vec2 uv, float fTime);\nvec3   CAM_getRay(Cam cam, vec2 uv);\n\n//----------------------\n// sampling functions\nfloat SAMPLER_trilinear(vec3 p); //Volumetric function\nvec3 SAMPLER_triplanarChannel1(vec3 p, vec3 n); //Surface triplanar projection\nvec3 NOISE_roughnessMap(vec3 p, float rayLen);\n\n// color conversion\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//----------------------\n// Analytic Intersections\nfloat RAYCAST_plane(vec3 o, vec3 d, vec3 po, vec3 pn)\n{\n    return dot(po-o,pn)/dot(d,pn); \n}\nfloat RAYCAST_floor(vec3 ro, vec3 rd)\n{\n\tfloat t = RAYCAST_plane(ro,rd,vec3(0,0,0),vec3(0,1,0));\n    return (t<0.0)?MAX_DIST:t;\n}\n\nfloat RAYCAST_sphere(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 dn = d;\n    dn = normalize(dn);\n\tfloat a = RAYCAST_plane(o,d,c,normalize(d));\n    vec3 p1 = o+a*d;\n    vec3 vp1c = p1-c;\n    float dc2 = dot(vp1c,vp1c);//norm2\n    float r2 = r*r;\n    if( dc2 < r2)\n    {\n        //float fDepth2 = sqrt(r2-dc2);\n        return a+sqrt(r2-dc2);\n\t}\n    return -1.;\n}\n\nvec3 SKY_grad(float h, float fTime)\n{\n    //Gradient values sampled from a reference image.\n    const vec3 r1 = vec3(195./255.,43./255.,6./255.);\n\tconst vec3 r2 = vec3(228./255.,132./255.,28./255.);\n\tconst vec3 bg1 = vec3(168./255.,139./255.,83./255.);\n\tconst vec3 bl1 = vec3(86./255.,120./255.,147./255.);\n\tconst vec3 bl2 = vec3(96./255.,130./255.,158./255.);\n\tconst vec3 bl3 = vec3(96./255.,130./255.,218./255.);\n    \n    h = h-h*0.25*sin(fTime);\n    vec3 c;\n    if(h<0.25)\n        c = mix(r1,r2,4.*h);\n    else if(h<0.5)\n        c = mix(r2,bg1,4.*(h-0.25));\n    else\n    \tc = mix(bg1,bl2,2.*(h-0.5));\n    \n    float light = 1.0+0.25*sin(fTime);\n    return mix(c,bl3,0.25+0.25*sin(fTime))*light;\n}\n\nvec3 SKY_main(vec3 p, float fTime, bool addSun)\n{\n    vec3 sunPos = vec3(0.,sin(fTime),cos(fTime));\n    fTime = -1.95;\n    \n    p = normalize(p);\n    vec3 nSunPos = normalize(sunPos);\n        \n    //Pseudo - Rayleight scattering (daylight blue)\n    float anlgePosSun_FromOrigin = acos(dot(p,nSunPos));\n    anlgePosSun_FromOrigin = clamp(anlgePosSun_FromOrigin,0.,PI);\n    float posAngle = asin(p.y);\n    \n    float fAtmosphereThickness = 2.0;\n    float fTraversalDistance = 0.35*cos(sqrt(clamp(12.3*posAngle,0.0,100.0))-0.8)+0.65;\n    \n    float dayV = 0.25+0.666*(0.3+fTraversalDistance)*(dot(p,nSunPos)+1.0)/2.0;\n    float dayS = 0.9-fTraversalDistance/1.60;\n    float dayH = mix(0.61,0.65,p.y);\n    \n    vec3 day = hsv2rgb(vec3(dayH,dayS,dayV));\n    vec3 gradS = SKY_grad(0.75-0.75*dot(p,nSunPos)*clamp(1.0-3.0*p.y,0.0,1.0)*fTraversalDistance,fTime);\n    vec3 gradF = (gradS+day)/2.0;\n    \n    if(addSun)\n    {\n\t\t//1/x for rapid rise close from d=0\n\t\t//2^abs(x) for soft long range ramp down\n        float d = length(sunPos-p)*10.;\n    \tfloat I = 0.015/abs(d)+pow(2.,-abs(d*2.))*0.4;\n    \tvec3 c = vec3(255./255.,213./255.,73./255.);\n\t    gradF += c*I*2.0;\n    }\n        \n    //Distribute the excess R light on other components\n    if(gradF.x > 1.0)\n        gradF = gradF + vec3(0,(gradF.x-1.0)/1.5,(gradF.x-1.0)/0.75);\n   \treturn gradF;\n}\n\n//------------------------------------------------------\n// Water stuff\n//------------------------------------------------------\n#define remap_01(a) (0.5+0.5*a)\nfloat WATER_height(vec2 p,float fTime)\n{\n    const float HF_I = 0.005;\n    const float HF_F1 = 6.01;\n    const float HF_F2 = 7.27;\n    fTime = -fTime;\n    return fMinWaterHeight+fWaterVariation*(0.495+0.495*sin(length(p-vec2(12,-5))+fTime*1.5)\n               /* +0.15+0.15*sin(3.0*length(p-vec2(3,-12))+sin((iTime/10.0)*0.05+2.0)*iTime*-1.)*/\n                +HF_I*remap_01(sin(HF_F1*(length(p-vec2(2.5,-2.5))+fTime))))\n                +HF_I*remap_01(sin(HF_F2*(length(p-vec2(5,-25))+fTime)));\n}\nfloat WATER_heightLF(vec2 p,float fTime)\n{\n    fTime = -fTime;\n    return fMinWaterHeight+fWaterVariation*(0.495*remap_01(sin(length(p-vec2(0,0))+fTime*1.5)));\n}\nvec3 WATER_normal(vec3 p,float fTime)\n{\n    float eps = 0.1;\n    float h = WATER_height(p.xz,fTime);\n    vec3 px = p+vec3(eps,0,0);\n    vec3 pz = p+vec3(0,0,eps);\n    vec3 vx = vec3(eps,WATER_height(px.xz,fTime)-h,0  );\n    vec3 vz = vec3(  0,WATER_height(pz.xz,fTime)-h,eps);\n    vec3 n = normalize(cross(vz,vx));\n    return mix(n,vec3(0,1,0),clamp(abs(p.z)/75.0,0.,1.));\n}\nvec3 WATER_intersec(vec3 o, vec3 d, float fTime)\n{   \n    //Initialize at average water height.\n    float avgWaterHeight = fMinWaterHeight+fWaterVariation*0.5;\n    float t = RAYCAST_plane(o,d,vec3(0,avgWaterHeight,0),vec3(0,1,0));\n    if(t<0.0)\n        return vec3(MAX_DIST);\n    vec3 p = o+t*d; \n    float rLen = 1.0/abs(d.y);\n    for(int i=0; i < 10; ++i)\n    {\n        float h = WATER_heightLF(p.xz, fTime);\n        float dist = p.y-h;\n        p += d*dist;\n        if(abs(dist)<0.001) //refine until acceptable.\n            break;\n    }\n    return p;\n}\n\n//------------------------------------------------------\n// Geometry stuff\n//------------------------------------------------------\n\nfloat DF_cube( vec3 p, vec3 size );\nfloat DF_sphere( vec3 p, float rad );\nfloat DF_merge( float d1, float d2 );\nfloat DF_smoothMerge( float d1, float d2, float d3, float k );\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nstruct DF_out\n{\n    float d;\n    int matID;\n};\n\n//::DF_composition\nDF_out DF_composition( in vec3 pos, const bool addNoise )\n{\n    const float noiseStrength = 0.3;\n    const float isoContour = 0.2;\n    const float xRepeatDist = 7.0;\n    float repeatedX = (fract(pos.x/xRepeatDist+0.5)-0.5)*xRepeatDist;\n    float randomSeed = pos.x-repeatedX;\n    if(abs(pos.x) < xRepeatDist*1.5)\n    \tpos.x = repeatedX+((pos.x<xRepeatDist/2.0)?0.:1.);\n    \n    //Rotation matrix\n    const mat3 rx45 = mat3(1.000,+0.000,0.000,\n\t                       0.000,+0.707,0.707,\n\t                       0.000,-0.707,0.707);\n    const mat3 rz45 = mat3(+0.707,0.707,0.000,\n\t                       -0.707,0.707,0.000,\n\t                       +0.000,0.000,1.000);\n    const mat3 rxrz45 = rx45*rz45; //Computed at compile time.\n    \n    vec3 pos_rx_rz = rxrz45*pos;\n\tfloat sd_water  = 10000.0;\n    vec3 objectCenter = vec3(0,1,abs(pos.x)/4.0);\n    pos-=objectCenter;\n    \n    vec3 randomPos = vec3(2.5*sin(randomSeed*8.3),6.0,2.5*sin(randomSeed*2.2));\n    float randomRad = float(0.95+0.25*sin(randomSeed*8.3));\n    \n    //Explanation: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    float sd_cube = DF_cube(pos_rx_rz-rxrz45*randomPos, vec3(1,1,1)*0.9 );\n    float sd_cylA = sdCappedCylinder(pos-vec3(0,3.5,0),vec2(randomRad*1.25+0.2*sin(0.5*pos.y-1.9),2.1));\n    float sd_cylB = sdCappedCylinder(pos,              vec2(0.6,4.1));\n\tfloat sd_sphere = DF_sphere(pos    -vec3(0.0,1.1,1.0), 0.1 );\n    float dMin = DF_smoothMerge(sd_cylA,sd_cube,sd_cylB, 1.3);\n    dMin = min(sd_water,dMin);\n    \n    DF_out dfOut;\n    dfOut.d = dMin-isoContour;\n    dfOut.matID = MATERIALID_STONE;\n    \n    if(addNoise)\n    {\n    \tfloat mainFreq = 0.005;\n\t\tpos *= mainFreq;\n    \tfloat distNoiseA = 0.500*(-0.5+SAMPLER_trilinear(1.00*pos*vec3(1.0,5.0,1.0)));\n    \tfloat distNoiseB = 0.250*(-0.5+SAMPLER_trilinear(2.01*pos*vec3(0.8,2.0,1.2)+distNoiseA*0.02));\n    \tfloat distNoise = noiseStrength*(distNoiseA+distNoiseB);\n        dfOut.d = dMin-isoContour+distNoise;\n    }\n    \n    return dfOut;\n}\n\nvec3 DF_gradient( in vec3 p )\n{\n\tconst float eps = 0.01;\n\tvec3 grad = vec3(DF_composition(p+vec3(eps,0,0),true).d-DF_composition(p-vec3(eps,0,0),true).d,\n                     DF_composition(p+vec3(0,eps,0),true).d-DF_composition(p-vec3(0,eps,0),true).d,\n                     DF_composition(p+vec3(0,0,eps),true).d-DF_composition(p-vec3(0,0,eps),true).d);\n\treturn grad;\n}\n\nstruct rayMarchOut\n{\n\tfloat rayLen;\n    float geoDist;\n    vec3 hitPos;\n    bool bReflect;\n};\n\n//::RAYMARCH_reflect\nrayMarchOut RAYMARCH_reflect( vec3 o, vec3 dir, float reflectLen, vec3 reflectDir )\n{\n    rayMarchOut rmOut;\n        \n    //Learned from Inigo Quilez DF ray marching :\n    //http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n    float tmax = 100.0;\n\tfloat precis = 0.0001;\n    float t = 0.1;\n    float dist = MAX_DIST;\n    rmOut.bReflect = false;\n    vec3 p = vec3(0);\n    for( int i=0; i<40; i++ )\n    {\n        p = o+dir*t;\n\t    dist = DF_composition( o+dir*t,true).d;\n        //This here allows the bouncing on water surface in a single ray marching loop\n        if(t>reflectLen && !rmOut.bReflect)\n        {\n            o=o+reflectLen*dir;\n            dir = reflectDir;\n            t=0.0;\n            rmOut.bReflect = true;\n        }\n        \n        if( abs(dist)<precis || t>tmax ) break;\n        t += dist;\n    }\n    \n    rmOut.rayLen = (t<tmax&&dist<0.1)?t:MAX_DIST;\n    rmOut.geoDist = dist;    \n    rmOut.hitPos = p;\n    return rmOut;\n}\n\nstruct TraceData\n{\n    float rayLen;\n    vec3  rayDir;\n    float geoDist;\n    vec3  normal;\n    int   matID;\n    bool  bReflect;\n    float fReflectDist;\n    vec3  vReflectNormal;\n};\n\nTraceData new_TraceData()\n{\n    TraceData td;\n    td.rayLen = 0.;\n    td.rayDir = vec3(0);\n    td.geoDist = 0.;\n    td.normal = vec3(0);\n    td.matID = MATERIALID_NONE;\n    td.bReflect = false;\n    td.fReflectDist = 0.0;\n    return td;\n}\n\nvec3 MAT_distanceFieldIsolines(vec2 uv);\n\nvec3 horizonColor(vec3 o, vec3 d, float fTime, bool addSun)\n{\n    float fSphereRad = 200.0;\n    vec3 spherePos = vec3(0,0,0);\n    float b = RAYCAST_sphere(o,d,spherePos,fSphereRad);\n    vec3 ph = o+b*d;\n    return SKY_main(ph/fSphereRad,fTime,addSun);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01, bool addSun)\n{\n    return pow(horizonColor(vec3(0), sampleDir, 0.10, addSun),vec3(2.2));\n}\n\n#define saturate(a) clamp(a,0.0,1.0)\nvec3 MAT_integrateHemisphere(vec3 normal)\n{\n    //FIXME : Invalid for surfaces facing up.\n    vec3 up = vec3(0,1,0.00);\n    vec3 right = normalize(cross(up,normal));\n    up = cross(normal,right);\n\n    vec3 sampledColour = vec3(0,0,0);\n    float index = 0.;\n    float phi = 0.;\n    const int nMERIDIANS = 3;\n    const int nPARALLELS = 3;\n    for(int i = 0; i < nMERIDIANS; ++i)\n    {\n        float theta = 0.0;\n        for(int j=0; j < nPARALLELS; ++j)\n        {\n            vec3 temp = cos(phi) * right + sin(phi) * up;\n            vec3 sampleVector = cos(theta) * normal + sin(theta) * temp;\n            vec3 linearGammaColor = PBR_HDRCubemap(sampleVector,0.0, false);\n            //<FIXME HACK : reduce lightness when the vector direction is down>\n\t\t\tlinearGammaColor *= saturate(1.0-dot(sampleVector+vec3(0,-0.3,0),vec3(0,-1,0)));\n            sampledColour += linearGammaColor * \n                                      cos(theta) * sin(theta);\n            index ++;\n            theta += 0.5*PI/float(nPARALLELS);\n        }\n        phi += 2.0*PI/float(nMERIDIANS);\n    }\n\n    return vec3( PI * sampledColour / index);\n}\n\nconst float F_DIELECTRIC_WATER   = 1.33; //@550nm\n\n//#define saturate(a) clamp(a,0.0,1.0)\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, vec3 ior_n, vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    //<http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n    \n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n     //<Distribution Term>\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D_ABL = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D_ABL = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t//</Distribution>\n    \n    //<Fresnel Term>\n    vec3 F;\n    if(metallic)//(TODO: Fix binary condition with a material layering strategy).\n    {\n        //<Source : http://sirkan.iit.bme.hu/~szirmay/fresnel.pdf p.3 above fig 5>\n        float cos_theta = 1.0-NdotV;//REVIEWME : NdotV or NdotL ?\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t                 /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n        //</http://sirkan.iit.bme.hu/~szirmay/fresnel.pdf p.3 above fig 5>\n    }\n    else\n    {\n        //Fresnel Schlick Dielectric formula\n        vec3 F0 = abs ((1.0 - ior_n) / (1.0 + ior_n));\n  \t\tF = F0 + (1.-F0) * pow( 1. - VdotH, 5.);\n    }\n    //</Fresnel>\n    \n    //<Geometric term>\n    //<Source : Real Shading in Unreal Engine 4 2013 Siggraph Presentation>\n    //https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; //Schlick model (IBL) : Disney's modification to reduce hotness (ABL)\n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    //</Real Shading in Unreal Engine 4 2013 Siggraph Presentations>\n    //</Geometric term>\n    \n    //Two flavors of the PBR equation seen pretty much everywhere (IBL/ABL).\n    //Note : Distribution (D) is externalized from IBL version, see source link.\n    //Personal addition : This parameter softens up the transition at grazing angles (otherwise too sharp IMHO).\n    float softTr = 0.1; // Valid range : [0.001-0.25]. Will reduce reflexivity on edges if too high.\n    //Personal addition : This parameter limits the reflexivity loss at 90deg viewing angle (black spot in the middle?).\n    float angleLim = 0.15; // Valid range : [0-0.75] (Above 1.0, become very mirror-like and diverges from a physically plausible result)\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr)); //IBL\n    else\n        return D_ABL*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\t//ABL\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 rotateAround( vec3 u, float t )\n{\n    //From wikipedia\n    float c = cos(t);\n    float s = sin(t);\n    //  _        _   _           _     _                    _ \n    // |_px py pz_| | m11 m21 m31 |   | px*m11+py*m21+pz*m31 |\n    //              | m12 m22 m32 | = | px*m12+py*m22+pz*m32 |\n    //              |_m13 m23 m33_|   |_px*m13+py*m23+pz*m33_|\n    return mat3(  c+u.x*u.x*(1.-c),     u.x*u.y*(1.-c)-u.z*s, u.x*u.z*(1.-c)+u.y*s,\n\t              u.y*u.x*(1.-c)+u.z*s, c+u.y*u.y*(1.-c),     u.y*u.z*(1.-c)-u.x*s,\n\t              u.z*u.x*(1.-c)-u.y*s, u.z*u.y*(1.-c)+u.x*s, c+u.z*u.z*(1.-c) );\n}\n\n#define MOD3 vec3(.1031,.11369,.13787)\nvec2 hash22(vec2 p) //From DaveHoskin's hash without sine\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec3 PBR_jitterSample(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    //Importance sampling section:\n    //<http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n\tfloat phi = 2.0*3.14159*e2;\n\t//<http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    \n    //FIXME : Invalid for surfaces facing up.\n\tvec3 up = vec3(0,1,0); //arbitrary\n\tvec3 tAxis = cross(up,sampleDir);\n\tmat3 m1 = rotateAround(normalize(tAxis),range);\n\tmat3 m2 = rotateAround(normalize(sampleDir), phi);\n        \n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k )\n{\n    vec3 vCenter = reflect(-V,N);\n    \n    //<Randomized Samples>\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    const int iter_rdm = 5;\n    const float w_rdm = 1.0/float(iter_rdm);\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < iter_rdm; ++i)\n    {\n        //Random jitter\n        //There is a scaling issue here, where scaling impacts noise precision.\n        vec2 jitter = hash22(fIdx*100.0+vCenter.xy*100.0+fract(iTime)*0.001);\n    \tfloat range = 0.;    \n        vec3 sampleDir = PBR_jitterSample(vCenter, roughness, jitter.x*randomness_range, jitter.y, range);\n        vec3 sampleColor = PBR_HDRCubemap(sampleDir,range/0.29,true);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*w_rdm;\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    //</Randomized Samples>\n    \n    //<Fixed Samples : less physically correct, but more stable>\n    //https://www.shadertoy.com/view/4dt3Dj\n    fIdx = 0.0;\n    const int iter_fixed = 15;\n    const float w_fixed = 1.0/float(iter_fixed);\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < iter_fixed; ++i)\n    {\n        //Stable pseudo-random jitter (to improve stability with low sample count)\n        //Beware here! second component controls the sampling pattern \"swirl\", and it must be choosen \n        //             so that samples do not align by doing complete 360deg cycles at each iteration.\n        vec2 jitter = vec2( clamp(w_fixed*fIdx,0.0,0.50),\n                            fract(w_fixed*fIdx*1.25)+3.14*fIdx);\n        float range = 0.;\n        vec3 sampleDir = PBR_jitterSample(vCenter, roughness, jitter.x, jitter.y, range);\n        vec3 sampleColor = PBR_HDRCubemap(sampleDir,range/0.29,true);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic,true)*w_fixed;\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    //</Fixed Samples>\n    \n    return (totalRandom*float(iter_rdm)+totalFixed*float(iter_fixed))/(float(iter_rdm)+float(iter_fixed));\n}\n\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    //(45deg: sin/cos = 1:1)\n    float minAperture = 1.0; \n    float t = 0.0;\n    float dist = MAX_DIST;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance\n        float dist = DF_composition( p, false ).d;\n        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        \n        t += dist;\n    }\n    \n    //The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture/coneWidth); //Range = [0.0-1.0] : 0 = shadow, 1 = fully lit.\n}\n\nfloat RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)\n{\n    //Variation of : https://www.shadertoy.com/view/Xds3zN\n    //Interesting reads:\n    //https://docs.unrealengine.com/latest/INT/Engine/Rendering/LightingAndShadows/DistanceFieldAmbientOcclusion/index.html#howdoesitwork?\n    //Implementation notes:\n    //-Doubling step size at each iteration\n    //-Allowing negative distance field values to contribute\n    //-Not reducing effect with distance (specific to this application)\n    float MaxOcclusion = 0.0;\n    float TotalOcclusion = 0.0;\n    const int nSAMPLES = 4;\n    float stepSize = 0.11/float(nSAMPLES);\n    for( int i=0; i<nSAMPLES; i++ )\n    {\n        float t = 0.01 + stepSize;\n        //Double distance each iteration (only valid for small sample count, e.g. 4)\n        stepSize = stepSize*2.0;\n        float dist = DF_composition( o+N*t, true ).d-isoSurfaceValue;\n        //Occlusion factor inferred from the difference between the \n        //distance covered along the ray, and the distance from other surrounding geometry.\n        float occlusion = saturate(t-dist);\n        TotalOcclusion += occlusion;//Not reducing contribution on each iteration\n        MaxOcclusion += t;\n    }\n    \n    return saturate(1.0-TotalOcclusion/(MaxOcclusion));\n}\n\nfloat MAT_processRoughness(float fRoughness, vec3 matColor, TraceData traceData, vec3 pos, vec3 N)\n{\n    if(traceData.matID==MATERIALID_WATER)\n    {\n        float fClamp = iMouse.y/iResolution.x;\n    \tfRoughness = clamp((fRoughness)*1.0,fClamp,3.0)-fClamp; \n    \tfRoughness *= 0.25;\n        //distance fade\n        fRoughness *= (1.0-saturate(traceData.rayLen/95.0));\n        fRoughness += 0.15*saturate(traceData.rayLen/25.0);\n    }\n    else if(traceData.matID==MATERIALID_STONE)\n    {\n        float heightFromWater = pos.y-(fMinWaterHeight+fWaterVariation);\n        float texRoughness = 0.05+smoothstep(0.3,0.6,matColor.g);\n        float inRoughness = smoothstep(0.3,0.7,fRoughness);\n\t\tfRoughness = (texRoughness+inRoughness)*0.5;\n        \n        fRoughness += 0.3*heightFromWater;\n        fRoughness *= (0.2+0.8*inRoughness);\n        fRoughness -= 0.6*(1.0-dot(N,vec3(0,1,0)));\n    }\n    return fRoughness;\n}\n\nvec3 MAT_getRoughnessPos(const int matID, vec3 surfacePos )\n{\n    vec3 lookupPos = vec3(0);\n    if(matID==MATERIALID_WATER)\n    {\n        lookupPos = vec3(surfacePos.xz*0.35-0.2*iTime,0).xzy;\n    }\n    else if(matID==MATERIALID_STONE)\n    {\n        lookupPos = vec3(surfacePos.xyz*0.2);\n    }\n    return lookupPos;\n}\n\n//::MAT_apply\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    //Water reflection case : replace the material\n    if(traceData.bReflect && traceData.fReflectDist < 1000.0)\n    {\n        vec3 dReflect = reflect(traceData.rayDir,traceData.normal);\n        traceData.rayLen = traceData.fReflectDist;\n        traceData.normal = traceData.vReflectNormal;\n        pos  = pos+traceData.fReflectDist*dReflect;\n        traceData.matID = MATERIALID_STONE;\n    }\n    \n    //L should bind with light position\n    vec3 L = normalize(vec3(0,0.2,1));\n    vec3 N = traceData.normal;\n    vec3 V = normalize(-traceData.rayDir);\n    float dfss = (traceData.matID==MATERIALID_SKY)?1.0:RAYMARCH_DFSS( pos+L*0.01, L, 0.2);\n    \n    //<Material parameters>\n    vec3 vDiff = vec3(0);\n    float dfao = 1.0;\n    vec3 matColor = vec3(1);\n    float LI = 1.0;\n\tif(traceData.matID==MATERIALID_WATER)\n    {\n        LI = 0.5;\n        //distance stabilization\n        N = mix(N,vec3(0,1,0),0.9*saturate(traceData.rayLen/25.0));\n    }\n    else if(traceData.matID==MATERIALID_STONE)\n    {\n        LI = 2.0;\n        matColor = SAMPLER_triplanarChannel1(pos*0.5,traceData.normal);\n            \n        vDiff = matColor*MAT_integrateHemisphere(N);\n        dfao = RAYMARCH_DFAO( pos, N, 0.02);\n        vDiff *= (0.5+0.25*dfss);\n    }\n    //<Material parameters>\n    \n    vec3 roughness_lookupPos = MAT_getRoughnessPos(traceData.matID,pos);\n    vec3 tex = NOISE_roughnessMap(roughness_lookupPos*306., traceData.rayLen);\n    float fRoughness = (tex.x+tex.y+tex.z)/3.0;\n    fRoughness = MAT_processRoughness(fRoughness, matColor, traceData, pos, N);\n    \n    //Single light & Image based lighting\n    vec3 I_L = PBR_Equation(V, L, N, fRoughness*0.5, vec3(1)*F_DIELECTRIC_WATER, vec3(0), false, false);\n    vec3 I_IBL = PBR_visitSamples(V, N, fRoughness, false, vec3(1)*F_DIELECTRIC_WATER, vec3(0));\n    \n    if(traceData.matID==MATERIALID_STONE)\n    {\n        if(traceData.bReflect)\n        {\n            LI *= 0.05;\n\t\t}\n    }\n    \n    vec3 col = matColor*dfss*(LColor*I_L)\n            +  LI*matColor*I_IBL*(0.5+0.5*dfss) //Remove half the Image-Based lighting in the shadow.\n            +  vDiff;\n    col *= dfao;\n    \n    if(traceData.matID==MATERIALID_STONE)\n    {\n        if(traceData.bReflect)\n        {\n            col *= 0.6;\n\t\t}\n    }\n    \n    if(traceData.matID==MATERIALID_WATER)\n    {\n        //<normal-based edge antialiasing>\n        //When the normal direction \n        vec3 backgroundColor = PBR_HDRCubemap(traceData.rayDir, 0.0,true).xyz;\n        float aaAmount = 0.02;\n        if(dot(N,traceData.rayDir) > -aaAmount)\n        {\n            float smoothFactor = 1.0-clamp(-dot(N,traceData.rayDir)/(aaAmount), 0.0, 1.0);\n            col.rgb = mix(col.rgb, backgroundColor, smoothFactor);\n        }\n        //</normal-based edge antialiasing>\n    }\n    else if(traceData.matID==MATERIALID_SKY)\n    {\n        return PBR_HDRCubemap(traceData.rayDir, 0.0,true).xyzz;\n    }\n    \n    return vec4(col,1);\n}\n\nTraceData TRACE_getFront(const in TraceData tDataA, const in TraceData tDataB)\n{\n    if(tDataA.rayLen<tDataB.rayLen)\n    {\n        return tDataA;\n    }\n    else\n    {\n        return tDataB;\n    }\n}\n\n//o=origin, d = direction\n//::TRACE_geometry\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    TraceData skyInfo;\n    skyInfo.rayLen  = MAX_DIST-1.0;\n    skyInfo.rayDir  = d;\n\tskyInfo.geoDist = 0.0;\n\tskyInfo.normal  = -d; //Shere center\n\tskyInfo.matID   = MATERIALID_SKY;\n    \n    TraceData waterInfo;\n    vec3 pWater = WATER_intersec(o, d, iTime);\n    waterInfo.rayDir  = d;\n    waterInfo.rayLen  = length(pWater-o);\n    waterInfo.geoDist = 0.0;//waterHeight(;\n    waterInfo.normal  = WATER_normal(pWater,iTime);\n    waterInfo.matID   = MATERIALID_WATER;\n    waterInfo.bReflect = false;\n\n    vec3 dReflect = reflect(waterInfo.rayDir,waterInfo.normal);\n\trayMarchOut rmOut = RAYMARCH_reflect( o, d, waterInfo.rayLen, dReflect );\n    vec3 dfHitPosition = rmOut.hitPos;\n\tvec3 DF_normal = normalize(DF_gradient(dfHitPosition));\n    \n    if(rmOut.bReflect)\n    {\n        waterInfo.bReflect = true;\n        waterInfo.fReflectDist = rmOut.rayLen;\n        waterInfo.vReflectNormal = DF_normal;\n        return TRACE_getFront(skyInfo,waterInfo);\n    }\n    else\n    {\n        TraceData terrainInfo;\n    \tterrainInfo.rayDir     = d;\n    \tterrainInfo.rayLen     = rmOut.rayLen;\n    \tterrainInfo.geoDist    = rmOut.geoDist;\n    \tterrainInfo.normal     = normalize(DF_gradient(dfHitPosition));\n    \tterrainInfo.matID = MATERIALID_STONE;\n        return TRACE_getFront(TRACE_getFront(skyInfo,terrainInfo),waterInfo);\n    }\n}\n\nvec3 TRACE_debug(TraceData traceData, int elemID)\n{\n    if(elemID==DEBUG_RAYLEN)  return vec3(log(traceData.rayLen)*0.1);\n    if(elemID==DEBUG_GEODIST) return vec3(traceData.geoDist);\n    if(elemID==DEBUG_NORMAL)  return traceData.normal;\n    if(elemID==DEBUG_MATID)   return traceData.matID==MATERIALID_WATER?vec3(1):\n                                     vec3(traceData.matID==MATERIALID_FLOOR?1:0,\n                                          traceData.matID==MATERIALID_B?1:0,\n                                          traceData.matID==MATERIALID_SKY?1:0);\n    return vec3(0);\n}\n\nvec3 POST_ProcessFX(vec3 c, vec2 uv)\n{\n    //Vignetting\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    //Gamma\n    c = pow(c,vec3(0.4545));\n    return c;\n}\n\n//::main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    \n    //[Insert supersampling logic here]\n    Cam cam = CAM_animate(uv,iTime);\n    vec3 d = CAM_getRay(cam,uv);\n    \n    vec3 c = vec3(0);\n    TraceData geometryTraceData = TRACE_geometry(cam.o, d);\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_RAYLEN); return; //OK\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_GEODIST); return; //OK\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_NORMAL); return; //OK\n    //fragColor.rgb = TRACE_debug(geometryTraceData, DEBUG_MATID); return; //OK\n    \n    vec3 ptGeo = cam.o+d*geometryTraceData.rayLen;\n    c = MAT_apply(ptGeo,geometryTraceData).rgb;\n    \n    //No supersampling required for most PostProcessFX.\n    c = POST_ProcessFX(c,uv);\n    \n    fragColor = vec4(c,1.0);\n}\n\n//----------------------\n// Camera\n//::CAM\nCam CAM_lookAt(vec3 at, float fPitch, float dst, float rot) \n{ \n    Cam cam;\n    cam.D = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.U = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.R = cross(cam.D,cam.U); cam.o = at-cam.D*dst;\n    return cam;\n}\nCam CAM_mouseLookAt(vec3 at, float dst)\n{\n    vec2 res = iResolution.xy; vec2 spdXY = vec2(15.1416,4.0);\n    float fMvtX = (iMouse.x/res.x)-0.535;\n    if(fMvtX>0.3) dst *= (1.0+(fMvtX-0.3)/0.03);\n    else if(fMvtX<-0.3) dst *= (1.0-(fMvtX+0.3)/(-0.2));\n\t//fMvtX += iTime*0.0250;//Auto turn\n    return CAM_lookAt(at,spdXY.y*((/*iMouse.y*/0.40)-0.5),dst,spdXY.x*fMvtX);\n}\nCam CAM_animate(vec2 uv, float fTime)\n{\n    float targetDistance = 12.5;\n    vec3 cam_tgt = vec3(-0.2,2,-0.1);\n    Cam cam = CAM_lookAt(cam_tgt, -0.05, targetDistance, 1.3+0.1*sin(iTime*0.1));\n    if(iMouse.z > 0.0) //Mouse button down : user control\n    {\n    \tcam = CAM_mouseLookAt(cam_tgt, targetDistance);\n    }\n    return cam;\n}\n\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv *= 1.6;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\nvec3 SAMPLER_triplanarChannel1(vec3 p, vec3 n)\n{\n    //Idea from http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n    //Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*texture(iChannel1,p.zy).xyz\n            +abs(n.y)*texture(iChannel1,p.zx).xyz\n            +abs(n.z)*texture(iChannel1,p.xy).xyz)/fTotal;\n}\nfloat SAMPLER_trilinear(vec3 p)\n{\n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    p *= TEXTURE_RES;   //Computation in pixel space (1 unit = 1 pixel)\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec3 t = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    t = (3.0 - 2.0 * t) * t * t; //interpolant easing function : linear->cubic\n    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)/TEXTURE_RES,-100.0).xy; //Note : +0.5 to fall right on pixel center\n    return mix( layer1_layer2.x, layer1_layer2.y, t.y ); //Layer interpolation (trilinear/volumetric)\n}\nvec4 SAMPLER_trilinearWithDerivative(vec3 p)\n{\n    //To be honest, this is rather complex for the benefit it provides. Could have used something much simpler\n    //for the roughness texture.\n\n    //See : http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n\tconst float TEXTURE_RES = 256.0; //Noise texture resolution\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)\n    //(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.\n\t//Note : shift is different from g to b layer (but it also works)\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES;\n    vec2 c1 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).rg;\n    vec2 c2 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).rg; //+x\n    vec2 c3 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).rg; //+z\n    vec2 c4 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).rg; //+x+z\n    vec3 x = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    vec3 x2 = x*x;\n    vec3 t = (6.*x2-15.0*x+10.)*x*x2; //Ease function : 6x^5-15x^4+10^3\n        \n    //Lower quad corners\n    float a = c1.x; //(x+0,y+0,z+0)\n    float b = c2.x; //(x+1,y+0,z+0)\n    float c = c3.x; //(x+0,y+1,z+0)\n    float d = c4.x; //(x+1,y+1,z+0)\n    //Upper quad corners\n    float e = c1.y; //(x+0,y+0,z+1)\n    float f = c2.y; //(x+1,y+0,z+1)\n    float g = c3.y; //(x+0,y+1,z+1)\n    float h = c4.y; //(x+1,y+1,z+1)\n    \n    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    //Derivative scaling (depends on texture lookup).\n    //There is definitely a pattern here.\n\t//This could be factorized/optimized but I fear it would make it cryptic.\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    //Ease-in ease-out derivative : (6x^5-2x^3)' = 6x-6x^2\n    vec3 d_xyz = (30.*x2-60.*x+30.)*x2;\n    \n    return vec4(value,\n\t            d_xyz.x*sx, //Derivative x scaling\n                d_xyz.y*sy,\n                d_xyz.z*sz);\n}\n//:NOISE_roughnessMap\nvec3 NOISE_roughnessMap(vec3 p, float rayLen)\n{\n    float f = iTime;\n    const mat3 R1  = mat3(0.500, 0.000, -.866,\n\t                     0.000, 1.000, 0.000,\n                          .866, 0.000, 0.500);\n    const mat3 R2  = mat3(1.000, 0.000, 0.000,\n\t                      0.000, 0.500, -.866,\n                          0.000,  .866, 0.500);\n    const mat3 R = R1*R2;\n    p *= BUMP_MAP_UV_SCALE;\n    p = R1*p;\n    vec4 v1 = SAMPLER_trilinearWithDerivative(p);\n    p = R1*p*2.021;\n    vec4 v2 = SAMPLER_trilinearWithDerivative(p);\n    p = R1*p*2.021+1.204*v1.xyz;\n    vec4 v3 = SAMPLER_trilinearWithDerivative(p);\n    p = R1*p*2.021+0.704*v2.xyz;\n    vec4 v4 = SAMPLER_trilinearWithDerivative(p);\n    \n    return (v1+0.5*(v2+0.25)\n\t          +0.4*(v3+0.25)\n\t          +0.6*(v4+0.25)).yzw;\n}\n\nfloat DF_sphere( vec3 p, float size )\n{\n\treturn length(p)-size;    \n}\n\nfloat DF_cube( vec3 p, vec3 size )\n{\n    vec3 dEdge = abs(p)-size; //distance to cube edge, along each axis\n    float internalDist = max(dEdge.x,max(dEdge.y,dEdge.z)); \n    float externalDist = length(max(dEdge,vec3(0))); \n    return externalDist+min(internalDist,0.0);\n}\n\nfloat DF_merge( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat DF_smoothMerge( float d1, float d2, float d3, float k )\n{\n    return -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3))/k;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3XRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3Xzr", "name": "The Edge of Time", "author": "TrueBoolean", "description": "Enjoy the journey.", "tags": ["raymarching"], "likes": 2, "viewed": 117, "date": "1457322145", "time_retrieved": "2024-06-20T18:33:27.111962", "image_code": "\nfloat map(vec3 p){\n    p.z=fract(p.z)*2.0-1.0;\n \treturn length(p.xz)+length(p.xy)-0.5-length(p.y)-length(p.z)-sin(length(p));   \n}\n\nfloat trace(vec3 origin,vec3 ray){\n    float t=0.0;\n    for (int i=0;i<32;i++){\n        vec3 position=origin+ray*t;\n        \n        float d=map(position);\n        \n        t+=d*0.5;\n        \n    }\n    \n    return t;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv=uv*2.0-1.0;\n    \n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ray=normalize(vec3(uv,0.1));\n    \n    float theta=iTime;\n    ray.xy*=mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    theta=iTime/2.5;\n    ray.xz*=mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    \n    vec3 origin=vec3(0.0,0.0,iTime);\n    \n    float t=trace(origin, ray);\n    \n    float fog= 1.0/(1.0+t*t*0.01);\n    \n    vec3 fc=vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3Xzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcSDn", "name": "Feels Like We Only Go Backwards", "author": "s23b", "description": "inspired by: [url=https://www.youtube.com/watch?v=wycjnCCgUes]Tame Impala - Feels Like We Only Go Backwards[/url]", "tags": ["shapes", "tube", "minimal"], "likes": 17, "viewed": 649, "date": "1458824375", "time_retrieved": "2024-06-20T18:33:27.372403", "image_code": "#define TAU 6.28318530718\n\nvec4 blend(vec4 c1, vec4 c2) {\n    return vec4(mix(c1.rgb, c2.rgb, c2.a), max(c1.a, c2.a)); \n}\n\n// antialiasing trick as suggested by Fabrice\nfloat aa(float value, float degree) {\n    return clamp(20. * degree * degree * sin((value + 1.) * TAU / 2.), 0., 1.);\n}\n\nvec4 shape(vec2 uv, float offset, float points) {\n    uv.y = -uv.y;\n    float l = length(uv);\n    vec2 tube = vec2(\n        fract((atan(uv.x, uv.y) / TAU + .5) * points),\n        1. / l);\n    tube.y /= cos((tube.x - .5) * TAU / points);\n    tube.y += offset;\n    float dist = (tube.y - offset) / 10.;\n\treturn vec4(vec3(aa(tube.y * 3., l) + smoothstep(0.1, .8,dist)), float(mod(tube.y, 20.) < 9.));\n}\n\nvec4 tube(vec2 uv, float offset) {\n    float l = length(uv);\n\treturn vec4(vec3(aa(4. / l + offset, l) + 1. - smoothstep(0.2, .5, l)), 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 R = iResolution.xy,\n\tuv = (2.*fragCoord - R) / R.y;\n    \n    float offset = iTime - 10.;\n    \n    // hash the number of points in the shape of the next sequence\n    float numPoints = 3. + floor(mod(sin(floor((offset + 10.) / 20.) * 123.456) * 123., 4.));\n    \n    vec4 c0 = tube(uv, offset * 2.);\n    vec4 c1 = shape(uv, -offset, numPoints);\n    \n    fragColor = blend(c0, c1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcSR7", "name": "Sunset Breaking Wave", "author": "hsiangyun", "description": "Modeling the breaking wave.", "tags": ["wave", "sunset", "cloud", "water", "ocean", "sky", "breakingwave"], "likes": 51, "viewed": 2019, "date": "1458713180", "time_retrieved": "2024-06-20T18:33:32.021308", "image_code": "// Created by Hsiang Yun, 2016 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n/**********************************************\n\nModeling the breaking wave based on Seascape & Cloud\n\nReferences: \n\tSeascape : https://www.shadertoy.com/view/Ms2SD1\n   \tCloud: https://www.shadertoy.com/view/XslGRr\n\n\n***********************************************/\n\n\n/************************************\n\t\t\tConstants\n************************************/\n#define RENDER_SKY\n#define RENDER_OCEAN\n#define RENDER_SPRAY\n\n// WaterBomb may cause crashes on Chrome/AMD (but works well on Firefox/AMD)\n#define RENDER_WATERBOMB   \n\nconst float PI = 3.1415926;\nconst float PI2 = PI *2.0; \n\nvec3 sundir = normalize(vec3 ( -1.0,0.1,0.0));\nvec3 haloclr1 = vec3(254.,201.,59.)/255.;\nvec3 haloclr2 = vec3(253.,158.,45.)/255.;\n\n\n\n/************************************\n\t\t Math \n************************************/\n\nvec2 rot (vec2 p, float a) \n{ float s = sin(a); float c = cos(a); return mat2(c,s,-s,c) * p; }\n\n\n// by iq\nfloat noise(in vec3 v)\n{\n\tvec3 p = floor(v);\n    vec3 f = fract(v);\n\tf = f*f*(3.-2.*f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n} \n\nvec3 random3f( vec3 p )\n{\n\treturn textureLod( iChannel0, (p.xy + vec2(3.0,1.0)*p.z+0.5)/256.0, 0.0 ).xyz;\n}\n\n// by iq\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n    return vec3( sqrt( res ), abs(id) );\n}\n\n/************************************\n\t\tsun & sky & clouds\n************************************/\n\nfloat grow( float x, float bias, float k ) \n{\n    return 1.0- exp(-abs(x-bias)*k);\n}\nfloat fbmCloud ( vec3 p ) \n{\n    float a = 0.5;\n    p *= 0.5;\n    p.x += iTime*0.5;\n    p.y += iTime*0.2;\n    float f = 1.0;\n    float v = 0.0;\n    for ( int i = 0 ; i < 5 ; ++i)\n    {\n        v += a* noise ( p*f ) ;\n        a *= 0.5 ;\n        f *= 2.;\n    }\n    v = max(0.0, v - 0.5);\n    return v;\n}\n\nfloat calcDomeRay( vec3 ro, vec3 rd, out vec3 domePos)\n{\n    float r = 500.0; // skydome radius\n    float h = 30.0;   // sky height \n    vec3 o = ro ;\t\t\n    vec3 p = o;  p.y -= r - h; // p : skydome center;\n    float a = dot(rd,rd);\n    vec3 op = 2.0*o-p;\n    float b = dot(op, rd);\n    float c = dot(op,op) - r*r;\n    float bac = b*b-a*c;\n    float t = -1.0;\n    if ( bac > 0.0 )\n    {\n        t = (-b +sqrt(bac)) / a;\n    }\n    if ( t < 0.0 ) t = -1.0;\n    domePos = ro + rd*t;\n    return t;\n}\n\nvec3 renderCloud ( vec3 ro, vec3 rd, vec3 bg)\n{\n    float sundot = clamp(dot(sundir, rd),0.,1.);\n    vec3 halo1 = haloclr1 * pow ( sundot, 50.0);\n    vec3 halo2 = haloclr2 * pow ( sundot, 20.0);\n   \t// cloud\n    vec4 sum = vec4(bg, 0.0);\n    vec3 domePos;\n    float domeT;\n    if ( rd.y > -0.1 )\n    {\n        float domeT = calcDomeRay(ro,rd,domePos);\n    \tif ( domeT > -0.5 ) \n    \t{\n        \tfloat t = 0.0;\n            for ( int i = 0 ;i < 4 ; ++i)\n            {\n                vec3 pos = domePos + rd * t ;\n                float ratio = 0.2;\n                float d1 = fbmCloud ( pos*ratio);;\n                float d2 = fbmCloud ( (pos*ratio + sundir*1.0 ) ) ;\n               \n                float dif = clamp(d1-d2,0.0,1.0);\n                // diff lighting\n                vec4 clr = vec4(vec3(0.3),0.0) + vec4(haloclr2 *dif *5.0, d1);\n                clr.rgb += halo2*5.0 + halo1 *2.0 ;\t\t\t\t// hack\n                clr.w *=  exp ( -distance(domePos, ro)*.025);\t// hack\n                clr.rgb = clr.rgb * clr.a;\n                sum = sum + clr * ( 1.0-sum.a);\n                \n                t += 1.0;\n            }\n        }\n    }\n    return sum.rgb;\n}\n\nvec3 renderAtmosphere (vec3 rd)\n{\n    vec3 atm = vec3(0.0);\n    float ry = max(0.0,rd.y);\n    atm.r = mix(0.25, 0., grow(ry, 0.0, 5.0));\n  \tatm.g = mix(0.06,0., grow(ry, 0.1, 0.5));\n   \tatm.b = mix(0.,0.3, grow(ry, 0., 0.5));\n    return atm;\n}\n\nvec3 renderSky( vec3 rd)\n{\n    // sun \n    float sundot = clamp(dot(sundir, rd),0.,1.);\n    vec3 core = vec3(1.) * pow(sundot,250.0);\n   \n    vec3 halo1 = haloclr1 * pow ( sundot, 50.0);\n    vec3 halo2 = haloclr2 * pow ( sundot, 20.0);\n    vec3 sun = core + halo1 *0.5 + halo2 *0.9 ;\n  \n    // atm \n    vec3 atm = renderAtmosphere ( rd);\n    return sun + atm;\n}\n\n\nvec3 renderSkyCloudDome ( vec3 ro, vec3 rd )\n{\n\tvec3 sky = renderSky(rd);\n    vec3 cloud = renderCloud( ro, rd, sky );\n    return cloud;\n}\n\n\n\n/************************************\n\t\t\t\tOcean \n************************************/\n\n// by TDM\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv.xyx + uv.xyy);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat sea_height( vec3 p)\n{\n    float freq = 0.4;\n    float amp = 0.1;\n    float choppy = 5.0;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    float sea_time = iTime * 0.8;\n    float d, h = 0.0;    \n    for(int i = 0; i < 3; i++) {        \n    \td = sea_octave((uv+sea_time)*freq,choppy);\n    \td += sea_octave((uv-sea_time)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return h;\n}\n\n\n/************************************\n\t\t   Breaking Wave \n************************************/\n\nfloat impulse (float x, float c, float w)\n{\n    float d = abs(x-c);\n    if ( d > w ) return 0.0;\n    return 1.0 - smoothstep(0.0,1.0, d/w);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hfWave ( float x, vec3 kSpike )\n{\n    float cos_h = kSpike.x * ( cos ( PI * x  ) *0.5 +0.5 ) ;\n    float spike_h = kSpike.y *pow(abs(1.0-abs(x)), 5.5* kSpike.z ) ;\n    return cos_h + spike_h;\n}\n\nvec2 dfWave ( vec3 q, vec2 o, float kRot, vec3 kSpike)\n{  \n    vec2 p = q.xy;\n    if ( dot(p,p) > 1.0) return vec2(p.y,1.0);\n    float r = length(p); \n    p = rot ( p-o, kRot * 0.5 *PI *r  ) + o;\n    \n    // (height, distance to center)\n    return  vec2(p.y - (hfWave(p.x, kSpike) ),p.x);    \n}\n\nvec2 calcLip (vec2 o, float kRot, vec3 kSpike) \n{\n    vec2 lip = vec2(0.0, hfWave(0.0, kSpike )); \n    float r = length(lip);\n    return rot ( lip -o , -kRot * 0.5 *PI * r ) + o; \n}\n\nvoid bwaveParams ( float t, float life, out vec2 o, out vec3 kSpike, out float kRot )\n{\n \tt *= 5.0 * life; \n    o = vec2(0.0); // rotation pivot\n    if ( t < 1.0 ) // forming\n    {\n        kSpike = vec3(0.2*t, 0.0,1.0);\n        kRot = 0.0;\n    }\n    else if ( t < 2.0 ) // breaking \n    {\n        t = t - 1.0;\n        kSpike = vec3(0.2, 0.8*pow(t,1.5),1.0);\n\t    kRot = pow(t,0.5);\n    }\n    else if ( t < 5.0 ) // fallback\n    {        \n        t = t - 2.0; t /= 3.0;\n        o = vec2(-.8,-1.) *t;\n        float t2 = 1.0- t;\n        kSpike = vec3(0.2*t2, 0.8*t2, t2) ;\n\t    kRot = 0.9 + 0.1*(1.0-t);\n        if ( t > 0.5 ) kRot = 0.95 * (1.0- ( t -0.5) *2.0); \n    }\n}\n\nvec2 calcLipAnim ( vec2 ph ) \n{\n    vec2 o; vec3 kSpike; float kRot;\n    bwaveParams ( ph.x, ph.y, o, kSpike, kRot);\n    return calcLip ( o, kRot, kSpike  );\n}\n\nvec3 dfWaveAnim ( vec3 q, float sea_h, vec2 phase )\n{\n\t// height-based wave \n    q.y -= sea_h;\n    // breaking wave \n    vec2 o; vec3 kSpike; float kRot;\n    float spikePhase = 1.0;\n    \n    bwaveParams ( phase.x, phase.y, o, kSpike, kRot);    \n    vec2 d1 = dfWave(q, o, kRot*spikePhase, kSpike*spikePhase);\n    vec2 d2 = dfWave(q, o, 0.0, vec3(kSpike.x*spikePhase,.0,.0));\n    float d = mix( max ( d1.x,d2.x), min(d1.x,d2.x), smoothstep(-1.0,1.0, q.x ) ) ;    \n    float ws = d1.y;\n    // cylinder is for accelerating ray tracing\n    q.y *= 2.5;\n    float bound = sdCylinder(q.xzy,vec2(1.5,4.0));\n    \n    return vec3(d, ws, bound);\n}\nconst float WaveTimeMax = 6.0;\nconst vec3 WaveOffset = vec3(2.8,0.0,0.0);\n\nfloat getWaveTime()\n{\n   // return mod(iTime + 2.5,WaveTimeMax);\n    return iTime;\n}\n\n// todo try composing linear piecewise function \n// and use modf() to periodilize it \n///\n\nconst float d1 = 4.0;\nconst float d2 = 2.0;\nconst float d3 = 3.0;\nconst float totalPhaseTime = d1 + d2 + d3;\n\nvec3 getPhaseDispInX(float t)\n{\n   /*\n       life ph = 0 -> no wave, 1 -> full wave\n\n       (1) (2)   (3) \n\t      /\\\n\t     /  \\\n        /    \\________\n\n       (1) wave forming ( moving forward)  [6 sec\n       (2) wave disappearing ( movng forward)  [6 sec\n       (3) wave roll back to origin [3 sec( moving back hiddenly to make animation periodically)\n\n    */    \n    \n    float px; // phase x\n    float dx; // disp x \n    float d1 = 4.0;\n    float d2 = 2.0;\n    float d3 = 3.0;\n    float t1 = d1;\n    float t2 = t1 + d2;\n    float t3 = t2 + d3;\n\n    float tmod = mod(t, totalPhaseTime ) ;\n    if ( tmod <= t1 )\n    {\n        px = tmod / d1 ;\n        dx = tmod;\n    }\n    else if ( tmod <= t2)\n    {\n        px =  1.0 - (tmod - t1) / d2 ;\n        dx = tmod;\n    }\n    else if ( tmod <= t3)\n    {\n        px = 0.0;\n        dx = mix( t2, 0.0 , (tmod - t2) / d3 ); \n    }\n    //px = 1.0;\n    return vec3(px,dx*0.8, t3);\n    \n}\n\nvec2 getPhase(vec3 p, float t)\n{\n    float w = 10.0;  // wave front length \n    vec3 params = getPhaseDispInX(t);\n    \n    // make wavefront have different phases along z-dir \n    //float zt = mod(t, WaveTimeMax*2.0);\n\tfloat zt = mod(t, params.z) *1.5;\n    \n    float zDirPh = clamp(p.z + zt, 0.0, w) / w ; \n    \n    float xDirPh = params.x;\n \n    //float lifePh =  clamp(sin(t / WaveTimeMax * PI * 0.3), 0.0, 0.5) *2.0 ;\n    \n    \n    return vec2(zDirPh, xDirPh);\n}\n\nvoid waveFrontDistort( inout vec3 p, float inSign )   \n{\n    // scale wave height\n    p.y *= 0.65;\n    \n    // distort wave front line \n    p.x -= inSign * (sin(2.0*p.z)*0.2 + cos(10.0*p.z)* 0.05);\n    \n    // offset \n    p += inSign * WaveOffset;\n    \n}\n\nvoid waveMoveForward( inout vec3 p, in float t, float inSign)\n{\n    float shake = max(0.0,sin(t / WaveTimeMax * PI*0.5))*3.0;\n    \n    float xDisp = getPhaseDispInX(t).y;\n    p.x -= inSign * xDisp ;  // moving for1ward\n   \n}\n\nvec3 getLipPos (in vec3 p, out vec2 phase) // p should be on the straight line\n{\n    vec3 lip = vec3(0.0);\n    float t = getWaveTime();\n    waveFrontDistort(lip, -1.0);\n    waveMoveForward(lip, t, -1.0f);\n    \n   \tphase = getPhase(p,t) ;\n    \n    lip.xy  += calcLipAnim ( phase ) ;\n    \n    return lip;\n}\n\n// ws : wave coordinate s :   0 : center, -1 : backface, \n// bd : wave bounding cylinder\n// ph : wave phase\n// return : ( d, ws, bd, ph ) ;\n\n\nconst float kSeaHeight = 1.0;\nvec4 mapWave(vec3 p, out vec2 ph )\n{\n    float t = getWaveTime();\n    \n    waveFrontDistort(p, 1.0);\n    \n   \tph = getPhase(p,t) ;\n    \n   \tfloat sea_h = sea_height ( p ) *  kSeaHeight;\n    \n    waveMoveForward( p, t, 1.0 );\n  \n    vec3 df = dfWaveAnim ( p,sea_h, ph);\n    return vec4(df.x, df.y, df.z, ph); \n}\n\nvec4 mapWave(vec3 p )\n{\n    vec2 ph;\n    return mapWave(p, ph);\n}\n\nfloat mapWaveCheap(vec3 p)\n{\n    float t = getWaveTime();\n   \twaveFrontDistort(p, 1.0);\n   \tvec2 ph = getPhase(p,t) ;\n    // skip sea height field \n   \tfloat sea_h = 0.0;\n    waveMoveForward( p, t, 1.0 );\n    vec3 df = dfWaveAnim ( p,sea_h, ph);\n    return df.z;\n}\n\nvec3 normalWave( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    mapWave(pos+eps.xyy).x - mapWave(pos-eps.xyy).x,\n\t    mapWave(pos+eps.yxy).x - mapWave(pos-eps.yxy).x,\n\t    mapWave(pos+eps.yyx).x - mapWave(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat traceWaveBound ( in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0 ;\n    float tmax = 50.0;\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float d = 0.0;\n\n    for( int i=0; i<16; i++ )\n    {\n\t    d = mapWaveCheap( ro+rd*t );\n    \n        if( d <precis || t>tmax ) break;   \n       \tt += d ;\n    }\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\n\nvec4 traceWave( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0 ;\n    float tmax = 50.0;\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float d = 0.0;\n    float ws = 0.0; // wave coordinates\n    vec2 ph = vec2(0,0); // wave phase\n    float bd = 0.0; // wave bounding cylinder df\n    \n    float tb = traceWaveBound(ro,rd);\n    \n    // the distance field of breaking wave is distorted severely, \n    // so we need more iterations and smaller marching steps \n    for( int i=0; i<128; i++ )\n    {\n\t    vec4 hit = mapWave( ro+rd*t, ph );\n        d = hit.x; ws = hit.y; bd = hit.z;\n        \n        if( d <precis || t>tmax ) break;\n        #if 0\n        t += (bd > 0.0 )? d *0.3 : d*0.1;\n        #else\n        if ( tb > -0.5) \n           t += ( bd > 0.0 )? d *0.5 : d *0.1;\n\t    else\n           t += d;\n        #endif \n    }\n\n    if( t>tmax ) t=-1.0;\n    return vec4( t, ws, ph.x, ph.y );\n}\n\nvec3 renderOcean ( vec3 p, vec3 nml, vec3 lig, vec3 rd, float d, float ws, vec2 phase, vec3 sky)\n{ \n    vec3 ligclr = haloclr1 *0.1;\n    vec3 rfl = reflect ( rd, nml ) ;\n    float dif = clamp( dot(nml,lig), 0.0, 1.0);\n    float spe = pow(clamp( dot(rfl,lig), 0.0, 1.0), 16.0);\n    float fre = pow(clamp(1.0+dot(nml,rd),0.0,1.0), 5.0 ) ;\n    float fre2 = pow(clamp(1.0+dot(nml,rd),0.0,1.0), 3.0) *0.7;\n    float ligdot = pow(clamp(dot(rfl,sundir),0.0,1.0),50.0);\n    float t = phase.x;\n    \n    vec3 sss = sky * pow(1.0- clamp(abs(ws),0.0,1.0), 8.0 )  ;\n    float k = pow(impulse(t, 0.8, 1.0),1.5);\n    sss = sss * smoothstep(1.0,0.5, t) * k;\n    sss *= phase.y;\n\n    vec3 rflclr = (renderSky ( rfl ) *0.2) +  (ligdot * haloclr1 *2.0) ;\n    vec3 rfrclr = (dif + spe + fre ) * ligclr * vec3(0.0,0.25,0.3) + sss;\n        \n\tvec3 ocean = mix(rfrclr, rflclr, fre2);\n  \tvec3 fog = sky;\n    return mix( ocean, fog , 1.0-exp( -0.002*d*d ) );\n}\n\n\n\n/************************************\n\t\t\tLip Spray\n************************************/\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat fbmSpray ( in vec3 p)\n{\n    float ret = 0.0;\n    float amp = 1.0;\n    float frq = 1.0;\n    p.y -= iTime*2.0;\n    p.x -= iTime*1.0;\n    ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.7; amp *= 0.51;\n    ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.0; amp *= 0.49;    \n    ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.0; amp *= 0.49;    \n    //ret +=  abs(amp * noise((p*frq ))) ; frq *= 2.0; amp *= 0.49;    \n    return ret;\n}\n\nfloat sdSprayBound ( vec3 p ) \n{\n    float w = 0.3;\n    float h = 1.0;\n    \n \tvec3 bias = vec3(fbmSpray( p+vec3(128.0,17.0,13.0)),\n                     fbmSpray(p),\n                     fbmSpray(p+vec3(17.0,37.0,43.0)));    \n\n    vec2 phase;\n    vec3 lip = getLipPos (p,phase);\n\tfloat k = p.y-lip.y; \n    lip.y += 0.15;\n    p -= lip;\n    p.y -= h - 0.05 ;\n    p += bias * smoothstep(0.0,2.0,k)*2.; \n    \n    return sdBox ( p, vec3 ( w, h, 10.0));\n}\n\n\nfloat sprayVol ( vec3 p)\n{\n    if ( sdSprayBound(p) < 0.0 ) \n    {\n        float d = smoothstep ( 1.0,0.0, abs(p.z));\n        vec2 phase;\n        \n        vec3 lip = getLipPos (p, phase);\n        float zPhase = phase.x;\n        \n        lip.y += 0.2;\n        float lipk = smoothstep(0.1,1.0,lip.y);\n        // the closer the lip, the denser the fog\n        float k = exp( -abs(p.y - lip.y) *5.0);\n        float v = mix(0.0,20.0,k) ;\n        \n        zPhase = clamp(zPhase,0.0,1.0) * phase.y;\n        \n        // around the breaking phase        \n        float s = smoothstep( 1.0,0.0, abs(zPhase - 0.38));\n      \n        s = pow (s , 40.0);\n       \n        float opa = v * s ;\n      \n       \treturn opa;\n \n    }\n    return 0.0;\n    \n}\n\nfloat traceSprayVol ( vec3 ro, vec3 rd, float depth)\n{\n    const int nSteps = 8;\n    float dt = depth / float(nSteps);\n    float t = 0.0;\n    float opa = 0.0;\n    float sum = 0.0;\n    for ( int i = 0 ;i < nSteps ; ++i)\n    {\n        float d = sprayVol ( ro + rd *t ) ;\n       \tsum += -t *d* dt;\n        t += dt;\n    }\n    opa = 1.0 - exp(sum);\n    return opa;\n}\n\nfloat traceSpray( vec3 ro, vec3 rd )\n{\n    const float eps = 0.05;\n    const float tmin = 0.0;\n    const float tmax = 100.0;\n    float t = tmin;\n    float d = tmax;\n    const int steps = 16;\n    for ( int i = 0 ; i < steps ; ++i)\n    {\n        d = sdSprayBound(ro + t * rd);\n        if ( d < eps || t > tmax) break;\n        t += d * mix ( 0.5, 1.0, float(i)/float(steps));\n        \n    }    \n    if ( t < tmax) return t;\n    return -1.0;\n}\n\nvec3 renderSpray (in vec3 ro, in vec3 rd , float spray_t, float ocean_t)\n{\n    vec3 clr = vec3(0.0);\n    float t = spray_t;\n    if ( t > -0.5)\n    {\n        vec3 fp = ro + rd *t ;\n        vec3 ro2 = fp + rd* 5.0;\n        float t2 = traceSpray ( ro2 , -rd ) ;\n        \n        // the spray is above the ocean\n        t2 = t + 5.0 -t2;        \n        //float depth = 5.0-t2;\n        \n        vec3 bp = ro + rd *t2;\n        if ( ocean_t < t2 && ocean_t > -0.5) \n        {\n\t\t\tbp = ro + rd * ocean_t;\n        }\n        \n        float depth = length( fp -bp);\n        \n        if ( t2 > -0.5)\n        {\n\t        float op = traceSprayVol ( ro+rd*t, rd, depth);\n        \tclr = vec3(op);\n        }\n    }\n    return clr;\n}\n\n/************************************\n\t\t\tWater Bomb\n************************************/\n\n\n\nfloat fbm ( vec3 p)\n{\n    float f;    \n\tvec3 q = p;                       - vec3(0.0,1.0,0.0)*iTime;;\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.25000*noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.06250*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;\n    f += 0.03125*noise( q );    \n    return f;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat waterBombZBegin()\n{\n    return 3.2 - mod(getWaveTime(), totalPhaseTime);\n}\n\nfloat sdWaterBomb ( vec3 p)\n{\n    // align with the lip\n    vec2 phase;\n    vec3 lip = getLipPos (p,phase); \n    lip.y = max(lip.y,0.0);\n\tp -= lip;   \n    float pz = waterBombZBegin(); // begin explosion\n        \n    // distort\n    float len = 8.0;\n    float r =  0.8* sqrt(smoothstep(len+pz, pz, p.z));\n    p.y -= 0.5;\n    vec3 q = p;\n    q.x += iTime*2.0;\n    r -= voronoi ( q * 2.0 ).x *0.3;\n    p.y += fbm(q) *0.5;\n    \n    return sdCapsule (p, vec3(0.0,0.0,pz), vec3(0.0,0.0,len + pz), r * phase.y * phase.y);\n\n}\n\nfloat sdWaterBombCheap ( vec3 p)\n{\n    // align with the lip\n    vec2 phase;\n    vec3 lip = getLipPos (p,phase); \n\tp -= lip;    \n\n     // distort \n    float len = 8.0 * phase.y;\n    float r = 1. *.8;\n    p.y -= 0.5;\n    vec3 q = p;\n    q.x += iTime*2.0;\n    // r -= voronoi ( q * 2.0 ).x *0.3;\n    p.y += fbm(q) *0.5;\n    p.x += pow ( clamp(p.y,0.0,1.0),2.0)*1.0;\n    \n    float pz = waterBombZBegin() ;\n    \n    return sdCapsule (p, vec3(0.0,0.0,pz), vec3(0.0,0.0,len + pz), r );\n}\n\n\nfloat waterBombVol ( vec3 o)\n{\n    return smoothstep(1.5,0.0,o.y)*20.0;  \n}\n\nvec3 waterBombNormal( in vec3 p )\n{\n\tvec3 e = vec3( 0.001, 0.0, 0.0 );\n\tvec3 n = vec3(sdWaterBombCheap(p+e.xyy) - sdWaterBombCheap(p-e.xyy),\n                  sdWaterBombCheap(p+e.yxy) - sdWaterBombCheap(p-e.yxy), \n                  sdWaterBombCheap(p+e.yyx) - sdWaterBombCheap(p-e.yyx) );\n\treturn normalize(n);\n}\nvec4 traceWaterBombVol ( vec3 ro, vec3 rd, float depth)\n{\n    \n    const int nSteps = 4;\n    float dt = depth / float(nSteps);\n    float t = 0.0;\n    vec3 clr = vec3(0.0);\n    float sigma = 0.0;\n    \n    for ( int i = 0 ;i < nSteps ; ++i)\n    {\n        vec3 p = ro + rd * t ;\n        float d = waterBombVol ( p ) ;\n        sigma += -t * d * dt ;\n        t += dt;\n    }\n    \n    float opacity = 1.0 - exp(sigma);\n    vec3 sunlgt = normalize(vec3(1.0));\n\tvec3 n = waterBombNormal ( ro ) ;\n    float nl = clamp ( dot(n,sunlgt),0.0,1.0);\n    opacity = mix ( opacity * nl , opacity, 0.8);\n    \n    float pre = fbm (100.0*(ro + vec3(0.0,-iTime*2.0,0.0)))*2.0;\n    pre -= fbm ( 1.0*(ro + vec3(0.0,-iTime*1.0,0.0)));\n    \n    float splash =  mix( pre, 1.0, opacity);\n    splash = clamp ( splash - 0.1, 0.0,1.0) *1.2;    \n    opacity *= splash;\n        \n    return vec4(vec3(opacity), opacity);\n}\n\nfloat traceWaterBomb( vec3 ro, vec3 rd )\n{\n    const float eps = 0.01;\n    const float tmin = 0.0;\n    const float tmax = 100.0;\n    float t = tmin;\n    float d = tmax;\n    const int steps = 128;\n    // trace surface \n    for ( int i = 0 ; i < steps ; ++i)\n    {\n        d = sdWaterBomb(ro + t * rd);\n        if ( d < eps || t > tmax) break; \n        t += d * mix ( 0.5, 1.0, float(i)/float(steps));\n    }    \n    if ( t < tmax) return t;\n    return -1.0;\n}\n\nvec4 renderWaterBomb (in vec3 ro, in vec3 rd, in float ocean_t )\n{\n    vec4 clr = vec4(0.0);\n    float t = traceWaterBomb(ro,rd) ;\n    if ( t > -0.5)\n    {\n        vec3 fp = ro + rd *t ;\n        vec3 ro2 = fp + rd*10.0;\n        float t2 = traceWaterBomb ( ro2 , -rd ) ;\n        t2 = t + 10.0 - t2;\n        vec3 bp = ro + rd *t2;\n        \n        if ( t2 > ocean_t && ocean_t > 0.0 )\n        {\n            bp = ro + rd * ocean_t;\n        }\n        float depth = length( fp -bp);\n        \n        \n        if ( t2 > -0.5)\n        {\n\t        clr = traceWaterBombVol ( ro+rd*t, rd, depth);\n            //clr = vec4(1.0);\n        }\n    }\n    return clr;\n}\n\n\n\n\n/************************************\n\t\t\tRender\n************************************/\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 clr = vec3(0.0);\n    \n    #ifdef RENDER_SKY\n    \tclr = renderSkyCloudDome(ro,rd);\n    #endif \n    \n    float ot = -0.5;\n    float ws = 0.0;  \n    vec2 ph = vec2(0.0);\n    float t = 0.0;\n    \n    #ifdef RENDER_OCEAN    \n    {\n        vec4 hit = traceWave(ro,rd);\n        ot = hit.x;\n\t\tws = hit.y;\n        ph = hit.zw;\n    \tif( ot > -0.5 )\n    \t{\n        \tvec3 pos = ro + ot *rd;\n            vec3 nor = normalWave( pos );\n            clr = renderOcean (pos, nor, sundir, rd, ot, ws, ph, clr );   \n        }\n    }\n    #endif\n    \n    #ifdef RENDER_SPRAY\n    t = traceSpray( ro, rd) ;\n    if ( t > -0.5 && (t < ot || ot <0.0))\n    {\n        vec3 tho = renderSpray ( ro, rd, t, ot);\n        //  don't render the lip spary in front of the breaking wave\n        if ( ws < 0.0 || ws >= 1.0) \n        {            \n            clr = mix(clr, vec3(0.5)+haloclr1, tho) ;\n\t    }\n    }\n\t#endif\n\n    #ifdef RENDER_WATERBOMB\n    t = traceWaterBomb ( ro, rd ) ;\n    if ( t > -0.5 && (t < ot || ot < 0.0) )\n    {\n        vec4 col4 = renderWaterBomb(ro,rd, ot);\n        clr = mix ( clr, vec3(0.15)+haloclr1, min(col4.a,1.0));\n        \n    }\n    #endif\n    \n    return clr;\n\t\n}\n\n\nmat3 camera( in vec3 pos, in vec3 lookat, float roll)\n{\n    vec3 z = normalize(lookat- pos);\n    vec3 x = vec3(sin(roll),cos(roll),0.0);  x = cross( z, x ) ;\n    vec3 y = cross(x,z);\n    return mat3(x, y, z ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 off = vec3(0.0,0.0,0.0);\n    float my = 0.6;\n    float mx = 0.95;\n    if ( iMouse.z > 0.0 )\n    {\n     \tmy = mix(0.35,0.75, mo.y);\n    \tmx = mix(0.9, 1.0,  mo.x);\n    }\n\tvec3 ro = off + vec3( -0.5+3.5*cos(PI2 *mx), 0.0 + 2.0*my, 0.5 + 3.5*sin(PI2 *mx) );\n\tvec3 ta = off + vec3( 0.0, 1.0,0.0 );\n    mat3 ca = camera( ro, ta, 0.0 );\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    vec3 col = render( ro, rd );\n\tcol = pow( col, vec3(0.4545) );\n    fragColor=vec4( col, 1.0 );\n}\n\n\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddSW8", "name": "Animated Coloured Worley", "author": "irealex", "description": "Flashing colored Worley noise!\nMade by Alexandra Vicente and Irene Bouzon for our second PGATR assignment.\nComputer Graphics, Virtual Reality and Videogames University Master. URJC.", "tags": ["worley", "cellular", "neon", "voronoise", "cellmap"], "likes": 12, "viewed": 551, "date": "1459173973", "time_retrieved": "2024-06-20T18:33:32.633524", "image_code": "//=================================================================================================\n// Use arrow keys to move your ball and pick the dots, go for a high score!\n// Spacebar resets the game if you lose\n// Have fun and try to reach 20 points! :D\n// \n// Made by Alexandra Vicente and Irene Bouzon for our PGATR second assignment\n// MIGJRV 2015/2016. URJC.\n//\n// Reference shaders (try them!):\n// > https://www.shadertoy.com/view/MddGzf\n// > https://www.shadertoy.com/view/XsdGDX\n//=================================================================================================\n\n#define ANIMATE\n#define SCALE 25.0\n#define MOV_FACTOR 8.0\n#define TEX_SIZE 256.0\n\nvec2 hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\nfloat euclideanDist2(vec2 v)\n{\n    return dot(v,v);\n}\n\nvec2 animateCell1(vec2 noise)\n{\n \tnoise = sin(iTime+MOV_FACTOR*noise);\n    return 0.5*noise + 0.5; //NORMALIZE \n}\n\nvec2 cellNoise(vec2 point )\n{\n    float d = 1e30, daux;\n    vec2 v, vaux;\n    vec2 o, offset;\n    vec2 noise;    \n    \n    // 1st Worley pass (Inside cells)\n    vec2 pi = floor(point); // Integer part of the point\n    vec2 pf = fract(point); // Decimal part of the point\n\n    for( int i=-1; i<=1; i++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        {\n            offset = vec2(i,j); \n            noise = hash2( pi + offset ); // noise for the int point+offset\n            #ifdef ANIMATE\n           \t \tnoise = animateCell1(noise); // lets animate the cells!\n            #endif\t\n            vaux = offset + noise - pf;\n            float daux = euclideanDist2(vaux); // Compute square distance from the point to this cell\n\n            if( daux<d )\n            {\n                d = daux; // keep min distance\n                v = vaux; // keep v of the cell with min dist\n                o = offset; // keep offset of the cell with min dist\n            }\n        }\n    }\n\n    // 2nd Worley pass (cell borders) \n    d=1e30;\n    for( int i=-2; i<=2; i++ )\n    {\n        for( int j=-2; j<=2; j++ )\n        {\n            offset = o + vec2(i,j); // Get global offset (Old offset + new (borders) offset)\n            noise = hash2( pi + offset ); // Get the noise for the int point + global offset\n            #ifdef ANIMATE\n            \tnoise = animateCell1(noise); // lets move these cells!\n            #endif\t\n            vaux = offset + noise - pf; \n\t\t\t\n            daux = dot( 0.5*(v+vaux), normalize(vaux-v)); // Compute square distance\n            d = min(d,daux); // Keep the minimun distance\n        }\n    }\n\t// Return the minimun distance and a lineal combination of the noise for coloring purposes\n    // Adding a sin that depends on the time we get the turning on and off effect of the texture\n    return vec2(d*2.0*(0.5*sin(iTime*1.6)+0.9),8.0*noise.x+5.0*noise.y);\n}\n\n// Returns a periodic color for the given value\nvec3 cellColor(float c)\n{\n    float r = 0.5*sin(c*0.7)+0.5;\n    float g = 0.5*cos(c*0.6)+0.5;\n    float b = 0.5*sin(c*c*0.1)+0.5;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xx;\n\t\n    vec2 c = cellNoise( SCALE*p ); // Get float cell noise\n    vec3 col = vec3(c.x,c.x,c.x); // Gray scale cell noise\n\t\n    col = c.x*cellColor(c.y); // Get the cell color\n    // Get the border color\n    col = mix( col, col - vec3(0.5), smoothstep( 0.2, 0.3, c.x ) ); // 1.0-c.x\n    col *= 2.0;    \n\t\n    fragColor = vec4(col,1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddSWn", "name": "Spinning Dots", "author": "vamoss", "description": "original work: http://i.kinja-img.com/gawker-media/image/upload/s--vx1bMLlR--/c_fit,fl_progressive,q_80,w_636/ed1njkgybuifepqy5jzn.gif", "tags": ["dots", "spinning"], "likes": 11, "viewed": 240, "date": "1458933791", "time_retrieved": "2024-06-20T18:33:32.966808", "image_code": "// a variant of FabriceNeyret's https://www.shadertoy.com/view/Xs33Wn\n// original work: http://i.kinja-img.com/gawker-media/image/upload/s--vx1bMLlR--/c_fit,fl_progressive,q_80,w_636/ed1njkgybuifepqy5jzn.gif\n\n\nfloat zoom = 11.;\nfloat qtd = 11.;\nfloat increaseRate = 4.;\n\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\nvec2 invtrans(vec2 v, float rot) {\n    v.x = ceil(v.y);\n    v.x += rot;\n    v.x *= TWO_PI;\n    v = v.y*sin(v.x+vec2(HALF_PI,0));\n    return v;\n}\n\nfloat circ(vec2 v, vec2 pos) {\n    const float maxQtd = 80.;\n    float curMax = ceil(v.x*increaseRate);\n    float circle = 1.;\n    float radius = 0.25+curMax/(increaseRate*100.);\n    float rot = -2./(v.x*2.);\n    if(iMouse.z>0.){\n\t    rot *= iMouse.x/iResolution.x*10.0;\n    }else{\n\t    rot *= iTime/4.;\n    }\n    for(float i=0.; i<maxQtd; i++){\n    \tif(i==curMax) break;\n    \tvec2 circlePos = pos-invtrans(floor(v+1.0)-vec2(0,.5), (rot+i/curMax));\n        circle*=smoothstep(radius-0.1,radius,length(circlePos));\n    }\n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = zoom * (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec2 pos = uv;\n    uv.y = length(uv);\n    uv.x = ceil(uv.y);\n    \n    //qtd\n    uv = mod(uv,qtd);\n    \n    vec4 color = vec4(0.14, 0.5, 0.58, 1.0);\n    \n    //lines\n    //color = mix(vec4(1), color, smoothstep(.0, .1, abs(fract(uv.y)-.5)));\n    \n    //circles\n    color = mix(vec4(1), color, circ(uv, pos));\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddXDr", "name": "Deathly Hallows", "author": "Hanley", "description": "Symbol of Harry Potter and the Deathly Hallows.", "tags": ["loop"], "likes": 7, "viewed": 132, "date": "1458876525", "time_retrieved": "2024-06-20T18:33:33.748767", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\n// function PolygonDF (in pos, number of corners)\n    // return distance field\n\nfloat polygonDistanceField(in vec2 pixelPos, in int N) {\n    // N = number of corners\n    float a = atan(pixelPos.y, pixelPos.x) + PI/2.; // angle\n    float r = TWO_PI/float(N); // ~?\n\n    // shapping function that modulates the distances\n    float distanceField = cos(floor(0.5 + a/r) * r - a) * length(pixelPos);\n\n    return distanceField;\n}\n\nfloat stretchedPolygon(in vec2 st, in float r, in int N, in float stretch_n) {\n    float d; // distance field\n\n    // Triangle Outer\n    float stretchAmount = mix(1., 30., stretch_n);\n    float outerRadius = mix(r+0.01, r+0.05, stretch_n);\n    float outerMidRadius = mix(r+0.005, r-0.05, stretch_n);\n\n    vec2 st_stretched = st.xy;\n    st_stretched.x *= stretchAmount;\n    d = polygonDistanceField(st_stretched, N);\n\n    float triangleOuter = smoothstep(outerRadius, outerMidRadius, d);\n\n    return triangleOuter;\n}\n\n/**\n    Linear Mapping function from processing.\n*/\nfloat map(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\nfloat mapAndCap(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    float v = ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n    v = max( min(ostart,ostop), v);\n    v = min( max(ostart,ostop), v);\n    return v;\n}\n\n/**\n    float r - polygon radius\n    int N - polygon corners\n    float stretch_n - stretch amount, from 0. to 1.\n*/\nfloat stretchedPolygonOutline(in vec2 st, in float r, in int N, in float stretch_n) {\n    float d; // distance field\n\n    // Triangle Outer\n    float triangleOuter = stretchedPolygon(st, r, N, stretch_n);\n\n    // Triangle Inner // ~ could be factored in as stretchedPolygon in future\n    float innerStretchAmount = mix(1., 60., stretch_n);\n    float innerMidRadius = mix(r-0.005, r-0.05, stretch_n);\n    float innerRadius = mix(r-0.01, r-0.1, stretch_n);\n\n    vec2 st_stretchedInner = st.xy;\n    st_stretchedInner.x *= innerStretchAmount;\n    d = polygonDistanceField(st_stretchedInner, N);\n\n    float triangleInner = smoothstep(innerMidRadius, innerRadius, d);\n\n    // Triangle Outline\n    float triangleOutline = triangleOuter - triangleInner;\n\n    return triangleOutline;\n}\n\n/**\n    returns smallest absoluate angular difference - return value ranges from 0.0 to +. \n*/\nfloat minAngularDifference(in float angleA, in float angleB) {\n    // Ensure input angles are - to \n    angleA = mod(angleA, TWO_PI);\n    if (angleA>PI) angleA -= TWO_PI;\n    if (angleA<PI) angleA += TWO_PI;\n    angleB = mod(angleB, TWO_PI);\n    if (angleB>PI) angleB -= TWO_PI;\n    if (angleB<PI) angleB += TWO_PI;\n\n    // Calculate angular difference\n    float angularDiff = abs(angleA - angleB);\n    angularDiff = min(angularDiff, TWO_PI - angularDiff);\n    return angularDiff;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n  \tvec2 u_mouse = iMouse.xy;\n  \tvec2 u_resolution = iResolution.xy;\n    \n    vec2 st = fragCoord.xy/u_resolution.xy; // pixel_n\n    st.x -= 0.2; // UPDATE: Centreing Tip from jackdavenport\n    st.x *= u_resolution.x / u_resolution.y; // quick aspect ratio fix\n    float t = u_time;\n\n    vec2 mouse_n = u_mouse.xy / u_resolution;\n    \n    // remap space from [0.,1.] to [-1.,1.]\n    st = st * 2.-1.;\n\n    // TIMELINE\n    float timeline = mod(t*.3, 1.);\n    // float shapeEntry = mapAndCap(pow(timeline, 2.), 0., 0.4, 0., 1.);// mix(0., 1., timeline*2.0);\n    float cirEntryProgress = mapAndCap(pow(timeline, 2.), 0., 0.25, 0., 1.);;\n    float triEntryProgress = mapAndCap(pow(timeline, 1.), 0.15, 0.9, 0., 1.);\n    float stretchProgress = mapAndCap(timeline, 0.75, 1.0, 0., 1.);\n    float exitFade = mapAndCap(pow(timeline, .35), 0.7, 1.0, 1., 0.);\n\n    // STRETCH\n    float stretchAmount = pow(stretchProgress, 4.);\n\n    // OUTLINES\n    float triangleOutline = stretchedPolygonOutline(st, 0.3, 3, stretchAmount);\n    float circleOutline = stretchedPolygonOutline(st, 0.3, 100, stretchAmount);\n    float midStroke = stretchedPolygon(st, 0.3, 3, 1.);\n\n    // LIGHT MASK\n    float curAngle = atan(st.y, st.x); // ranges [-,+]\n    float targetAngle;\n    float angularDiff;\n    float edge0, edge1;\n    float outlineFade;\n\n    // CIRCLE    \n    targetAngle = mix(0., TWO_PI, cirEntryProgress) + PI*.5; \n    angularDiff = minAngularDifference(curAngle, targetAngle);\n    edge0 = mix(0., PI, cirEntryProgress);\n    edge1 = mix(1., PI, cirEntryProgress*PI);\n    circleOutline *= 1. - smoothstep(edge0, edge1, angularDiff);\n    outlineFade = mix(0., 1., cirEntryProgress*10.);\n    circleOutline *= outlineFade;\n\n    // TRIANGLE\n    targetAngle = mix(0., TWO_PI, triEntryProgress) + PI*.5; \n    angularDiff = minAngularDifference(curAngle, targetAngle);\n    edge0 = mix(0., PI, triEntryProgress);\n    edge1 = mix(0., PI*PI*.75, triEntryProgress);\n    outlineFade = mix(0., 1., triEntryProgress*5.);\n    triangleOutline *= 1.-smoothstep(edge0, edge1, angularDiff);\n    triangleOutline *= outlineFade;\n\n    // Brightness\n    float b = (triangleOutline + circleOutline)*exitFade + midStroke;\n    vec3 color = vec3(b);\n    \n    fragColor = vec4(color, 1.0);\n    \n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddXRr", "name": "iq's school of terrain", "author": "revers", "description": "This shader is based on iq's brilliant [url=https://www.shadertoy.com/view/MdX3Rr]Elevated[/url], but I've used my own terrain heightmap (without derivatives), added water and own version of clouds. I've also tried to use own texture patterns. ", "tags": ["terrain"], "likes": 9, "viewed": 647, "date": "1457474918", "time_retrieved": "2024-06-20T18:33:36.312713", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader is based on iq's brilliant \"Elevated\" (https://www.shadertoy.com/view/MdX3Rr), \n * but I've used my own terrain heightmap (without derivatives), added water and own version of clouds.\n * I've also tried to use own texture patterns. \n * The rest of code is created by iq. Notably: hash and noise functions, raymarching, great outdoors lighting\n * (see also http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm )\n * \n * It is great pleasure to learn from the best. Thanks for sharing your code, iq!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\nconst vec3 LightDir = vec3(0.15037532, -0.31434754, -0.93732226);\nconst float MarchDumping = 0.39999998;\nconst float Far = 864.20496;\nconst int MaxSteps = 156;\nconst vec2 PulseSize = vec2(431.0138, 311.53772);\nconst float PulseHeight = 111.24439;\nconst float PulseProbability = 0.6;\nconst float MaxTerrainMul = 60.88;\nconst float MinTerrainMul = 0.0;\nconst float TerrainPower = 0.85950005;\nconst float TerrainHeightMul = 1.838;\nconst float WaterLevel = -9.119999;\nconst float WaterWaveHeight = 0.24681002;\nconst float WaterMaxVisibleDepth = 12.8991;\nconst vec3 WaterColor = vec3(0.007843138, 0.0627451, 0.09019608);\nconst float NormalFactor = 0.399;\n\n#define TIME_SHIFT 30.0\n\n#define M_NONE -1.0\n#define M_TERRAIN 1.0\n#define M_WATER 3.0\n\nvec3 lig = vec3(0.0, -1.0, 0.0);\nfloat TerrainParam = 0.0;\n\nfloat hash(vec2 n) {\n\treturn fract(sin(dot(n, vec2(1.0, 113.0))) * 43758.5453123);\n}\n\n/**\n * From \"Hash-without-Sine\" by Dave Hoskins\n * https://www.shadertoy.com/view/4djSRW\n */\nvec2 hash22(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n\tp += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\tvec2 a = vec2(0.0, 0.0);\n\tvec2 b = vec2(1.0, 0.0);\n\tvec2 c = vec2(0.0, 1.0);\n\tvec2 d = vec2(1.0, 1.0);\n\n\tfloat n0 = hash(i + a);\n\tfloat n1 = hash(i + b);\n\tfloat n2 = hash(i + c);\n\tfloat n3 = hash(i + d);\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\n\treturn mix(ix0, ix1, u.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n/**\n * http://iquilezles.org/www/articles/functions/functions.htm\n */\nfloat cubicPulse(float w, float x) {\n\tx = abs(x);\n\tif (x > w)\n\t\treturn 0.0;\n\tx /= w;\n\treturn 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nfloat pulse(vec2 p) {\n\tvec2 q = mod(p, 2.0 * PulseSize) - PulseSize;\n\tvec2 id = floor(p / (2.0 * PulseSize));\n\n\tvec2 r2 = hash22(id);\n\tfloat r = step(PulseProbability, r2.x) * step(PulseProbability, r2.y);\n\n\tfloat h = cubicPulse(PulseSize.x, q.x) * cubicPulse(PulseSize.y, q.y) * PulseHeight;\n\treturn mix(h, 0.0, r);\n}\n\nfloat fbmL(vec2 p, float baseAmplitude) {\n\tfloat f = 0.0;\n\tfloat a = baseAmplitude;\n\tfor (int i = 0; i < 2; i++) {\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\nfloat fbmM(vec2 p, float baseAmplitude) {\n\tfloat f = 0.0;\n\tfloat a = baseAmplitude;\n\tfor (int i = 0; i < 4; i++) {\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\nfloat fbmH(vec2 p, float baseAmplitude) {\n\tfloat f = 0.0;\n\tfloat a = baseAmplitude;\n\tfor (int i = 0; i < 7; i++) {\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\nfloat hole(vec2 p) {\n\tfloat f = noise(p);\n\tp *= 2.01;\n\tf += 0.5 * noise(p);\n\tp *= 2.02;\n\tf += 0.25 * noise(p);\n\tp *= 2.00;\n\tf += 0.125 * noise(p);\n\n\treturn f;\n}\n\nfloat terrainL(vec2 p) {\n\tvec2 g = vec2(0.01, 0.012);\n\tvec2 q = p * g;\n\n\tfloat a = 0.5;\n\tfloat f0 = noise(q);\n\ta *= 0.5;\n\tq *= 2.0;\n\n\tfloat f = fbmL(q, a);\n\tfloat t = smoothstep(0.5, 1.0, TerrainParam);\n\tf = pow(f, TerrainPower + t * 2.0);\n\n\tfloat k = smoothstep(TerrainParam, 1.0, f0);\n\tfloat res = mix(f * MinTerrainMul, f * MaxTerrainMul, k) * TerrainHeightMul;\n\n\tfloat m = smoothstep(0.0, 0.4, k);\n\tres = mix(res - hole(q) * 12.0, res, m);\n\n\tres += pulse(p) * fbmM(p * 0.01 + 452.15, 0.5);\n\treturn res;\n}\n\nfloat terrainM(vec2 p) {\n\tvec2 g = vec2(0.01, 0.012);\n\tvec2 q = p * g;\n\n\tfloat a = 0.5;\n\tfloat f0 = noise(q);\n\ta *= 0.5;\n\tq *= 2.0;\n\n\tfloat f = fbmM(q, a);\n\tfloat t = smoothstep(0.5, 1.0, TerrainParam);\n\tf = pow(f, TerrainPower + t * 2.0);\n\n\tfloat k = smoothstep(TerrainParam, 1.0, f0);\n\tfloat res = mix(f * MinTerrainMul, f * MaxTerrainMul, k) * TerrainHeightMul;\n\n\tfloat m = smoothstep(0.0, 0.4, k);\n\tres = mix(res - hole(q) * 12.0, res, m);\n\n\tres += pulse(p) * fbmM(p * 0.01 + 452.15, 0.5);\n\treturn res;\n}\n\nfloat terrainH(vec2 p) {\n\tvec2 g = vec2(0.01, 0.012);\n\tvec2 q = p * g;\n\n\tfloat a = 0.5;\n\tfloat f0 = noise(q);\n\ta *= 0.5;\n\tq *= 2.0;\n\n\tfloat f = fbmH(q, a);\n\tfloat t = smoothstep(0.5, 1.0, TerrainParam);\n\tf = pow(f, TerrainPower + t * 2.0);\n\n\tfloat k = smoothstep(TerrainParam, 1.0, f0);\n\tfloat res = mix(f * MinTerrainMul, f * MaxTerrainMul, k) * TerrainHeightMul;\n\n\tfloat m = smoothstep(0.0, 0.4, k);\n\tres = mix(res - hole(q) * 12.0, res, m);\n\n\tres += pulse(p) * fbmH(p * 0.01 + 333452.15, 0.5);\n\treturn res;\n}\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(p.y - terrainM(p.xz), M_TERRAIN);\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = -1.0;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tfloat t = 0.1;\n\tvec2 eps = vec2(0.02 * t, 0.0);\n\n\treturn normalize(\n\t\t\tvec3(terrainH(pos.xz - eps.xy) - terrainH(pos.xz + eps.xy),\n\t\t\t\t\t2.0 * eps.x,\n\t\t\t\t\tterrainH(pos.xz - eps.yx) - terrainH(pos.xz + eps.yx)));\n}\n\n#define lodbias -100.0\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n) {\n\tvec4 x = texture(sam, p.yz, lodbias);\n\tvec4 y = texture(sam, p.zx, lodbias);\n\tvec4 z = texture(sam, p.xy, lodbias);\n\treturn x * abs(n.x) + y * abs(n.y) + z * abs(n.z);\n}\n\nfloat water(vec2 q) {\n\tfloat f;\n\tf = 0.5000 * noise(q);\n\tq = q * 2.02;\n\tf += 0.2500 * noise(q);\n\tq -= iTime * 0.3;\n\tq = q * 2.03;\n\tf += 0.1250 * noise(q);\n\tq -= iTime * 2.0;\n\tq = q * 2.01;\n\tf += 0.0625 * noise(q);\n\n\treturn f * WaterWaveHeight;\n}\n\nvec3 waterBottomColor(vec3 ro, vec3 rd, float t) {\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\tvec3 bn = -1.0 + 2.0 * texcube(iChannel0, pos * 0.3, nor).xyz;\n\tnor = normalize(nor + 0.2 * bn);\n\n\tvec3 col = vec3(0.009);\n\tfloat hh = smoothstep(0.0, 10.0, pos.y);\n\n\tcol += 2.0 * vec3(0.722, 0.396, 0.165)\n\t\t\t* texcube(iChannel1, pos * vec3(0.1, 0.3, 0.1), nor).rgb;\n\n\tfloat dif = max(dot(nor, lig), 0.0);\n\treturn dif * col * 0.5;\n}\n\nfloat clouds(vec3 ro, vec3 rd) {\n\tvec2 uv = rd.xz / rd.y;\n\tuv *= 70.0;\n\n\tuv *= vec2(3.0, 3.0) * 0.005;\n\tvec2 st = uv;\n\n\tuv.x += iTime * 0.2;\n\n\tfloat f = 0.5 * noise(uv);\n\tuv *= 2.04;\n\tf += 0.25 * noise(uv);\n\tuv *= 2.01;\n\tf += 0.125 * noise(uv);\n\tfloat res = f;\n\tres = smoothstep(0.4, 1.0, res);\n\n\tst += vec2(12.0, 34.5);\n\tst.x += iTime * 0.3;\n\tfloat g = 0.5 * noise(st);\n\tst *= 2.00;\n\tg += 0.25 * noise(st);\n\tst *= 2.03;\n\tg += 0.125 * noise(st);\n\tst *= 2.04;\n\tg += 0.0625 * noise(st);\n\n\tres += 0.5 * smoothstep(0.5, 0.9, g);\n\n\treturn res * 0.8;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n\tfloat sundot = max(0.0, dot(rd, lig));\n\tvec3 col = vec3(0.396, 0.678, 0.878) * (0.9 - 0.9 * rd.y) * 1.5;\n\tcol += pow(sundot, 120.0) * vec3(1.0, 0.937, 0.71) * 0.75;\n\n\tcol = mix(col, vec3(2.0), clouds(ro, rd) * rd.y);\n\treturn col;\n}\n\n#define OFFSET 10.0\n#define GROUND_LEVEL_MIN (-20.0 + OFFSET)\n#define GROUND_LEVEL_MAX (-5.0 + OFFSET)\n\n#define GRASS_LEVEL_MIN (-5.0 + OFFSET)\n#define GRASS_LEVEL_MAX (25.0 + OFFSET)\n\n#define SNOW_LEVEL_MIN (20.0 + OFFSET)\n#define SNOW_LEVEL_MAX (60.0 + OFFSET)\n\nvec3 terrainColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor) {\n\tvec3 col = vec3(0.009);\n\n\tvec3 rock = 1.0 * vec3(0.5)\n\t\t\t* texcube(iChannel1, pos * vec3(0.1, 0.4, 0.1) * 0.2, nor).rgb;\n\tfloat rockFactor = (1.0 - nor.y);\n\tcol += mix(rock, vec3(0.01), rockFactor);\n\n\tfloat r = texture(iChannel0, pos.xz * 0.1).r;\n\n\tvec3 ground = 0.1 * vec3(0.7, 0.4, 0.2);\n\tfloat k = texture(iChannel0, pos.xz * 0.0005).r * 10.0;\n\tfloat groundFactor = (1.0 - smoothstep(GROUND_LEVEL_MIN, GROUND_LEVEL_MAX, pos.y - k));\n\tcol = mix(col, ground, groundFactor);\n\n\tvec3 grass = 0.4 * mix(vec3(0.04, 0.3, 0.0), vec3(0.0, 0.1, 0.0),\n\t\t\tsmoothstep(0.0, 0.5, texcube(iChannel2, pos * 0.04 + r, nor).r));\n\tfloat grassFactor = (0.6 + 0.4 * r) * groundFactor;\n\tcol = mix(col, grass, grassFactor);\n\n\tgrass = vec3(0.02, 0.06, 0.0);\n\tgrassFactor = smoothstep(NormalFactor, 1.0, nor.y)\n\t\t\t* (1.0 - smoothstep(GRASS_LEVEL_MIN, GRASS_LEVEL_MAX, pos.y))\n\t\t\t* (1.0 - groundFactor);\n\tcol = mix(col, grass, grassFactor);\n\n\tvec3 snow = vec3(1.0);\n\tfloat snowFactor = smoothstep(SNOW_LEVEL_MIN, SNOW_LEVEL_MAX, pos.y)\n\t\t\t* smoothstep(0.1, 1.0, nor.y);\n\tcol = mix(col, snow, snowFactor);\n\n\treturn col;\n}\n\nvec3 doLighting(vec3 rd, vec3 pos, vec3 nor) {\n\tvec3 ref = reflect(rd, nor);\n\n\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0,\n\t\t\t1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n\n\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\tdom *= softshadow(pos, ref, 0.02, 2.5);\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);\n\tbrdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\tbrdf += 0.30 * amb * vec3(0.50, 0.70, 1.00);\n\tbrdf += 0.40 * dom * vec3(0.50, 0.70, 1.00);\n\tbrdf += 0.30 * bac * vec3(0.25, 0.25, 0.25);\n\tbrdf += 0.20 * fre * vec3(1.00, 1.00, 1.00);\n\tbrdf += 0.02;\n\n\treturn brdf;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.0);\n\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tfloat wt = (WaterLevel - ro.y) / rd.y;\n\n\tbool isWater = false;\n\tfloat waterBlendFactor = 1.0;\n\tvec3 bottomColor = vec3(0.0);\n\n\tif (wt > 0.0 && wt < t) {\n\t\t// water\n\t\tfloat k = (t - wt) / WaterMaxVisibleDepth;\n\t\twaterBlendFactor = min(k * k, 1.0);\n\t\tvec3 pos = ro + wt * rd;\n\n\t\tvec2 e = vec2(wt * 0.05, 0.0);\n\t\tvec2 p = pos.xz * 2.0;\n\t\tfloat x0 = water(p);\n\t\tvec2 grad = vec2(water(p + e.xy) - x0,\n\t\t\t\t\t\t water(p + e.yx) - x0) / e.x;\n\n\t\tvec3 nor = normalize(vec3(grad.x, 1.0, grad.y));\n\t\tbottomColor = waterBottomColor(ro, rd, t);\n\n\t\trd = reflect(rd, nor);\n\t\tro = pos + rd * 0.2;\n\n\t\tres = castRay(ro, rd);\n\t\tt = res.x;\n\t\tm = res.y;\n\n\t\tisWater = true;\n\t}\n\n\tif (m > M_NONE) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\tcol = terrainColor(ro, rd, pos, nor);\n\t\tvec3 brdf = doLighting(rd, pos, nor);\n\n\t\tcol = col * brdf;\n\n\t\tif (isWater) {\n\t\t\tcol += bottomColor * (1.0 - waterBlendFactor);\n\t\t\tcol += WaterColor * 0.5;\n\t\t}\n\t\t// fog\n\t\tcol = mix(col, vec3(0.5), 1.0 - exp(-0.000001 * t * t));\n\t} else {\n\t\tcol = skyColor(ro, rd);\n\t\tif (isWater) {\n\t\t\tcol += bottomColor * (1.0 - waterBlendFactor);\n\t\t\tcol += WaterColor * 0.1;\n\n\t\t}\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nvec3 camPath(float time) {\n\ttime *= 2.0;\n\treturn 1100.0 * vec3(cos(0.0 + 0.23 * time), 0.0, cos(1.5 + 0.21 * time));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lig = normalize(-LightDir);\n    TerrainParam = (sin(iTime * 0.2 + TIME_SHIFT) * 0.5 + 0.5);\n    \n    vec2 q = fragCoord / iResolution.xy;\n\tvec2 xy = -1.0 + 2.0 * q;\n\tvec2 s = xy * vec2(iResolution.x / iResolution.y, 1.0);\n\n\tfloat time = iTime * 0.15 + 0.3 + TIME_SHIFT + 4.0 * iMouse.x / iResolution.x;\n\n\tvec3 ro = camPath(time);\n\tvec3 ta = camPath(time + 3.0);\n\tro.y = terrainL(ro.xz) + 11.0;\n\tta.y = ro.y - 20.0;\n\tfloat cameraRoll = 0.2 * cos(0.1 * time);\n\n\t// camera2world transform\n\tmat3 cam = setCamera(ro, ta, cameraRoll);\n\n\t// camera ray\n\tvec3 rd = cam * normalize(vec3(s.xy, 1.5));\n\tvec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n    col += 0.07;\n    // vignette\n\t//col *= 0.25 + 0.75 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.07);\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldK3Dc", "name": "Square Circle Dance", "author": "vamoss", "description": "Original work http://49.media.tumblr.com/0913449568032fe45a5310854426eb2e/tumblr_nmjnksPbul1tcuj64o1_400.gif", "tags": ["circle", "illusion", "square", "dance", "rythm"], "likes": 23, "viewed": 351, "date": "1456887338", "time_retrieved": "2024-06-20T18:33:36.312713", "image_code": "/*\nOriginal work\nhttp://49.media.tumblr.com/0913449568032fe45a5310854426eb2e/tumblr_nmjnksPbul1tcuj64o1_400.gif\n*/\n\n#define PI 3.14159265359\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\tfloat angle = atan(dist.y, dist.x);\n    if(angle<-PI/2.0) return 0.0;\n    else if(angle>0.0 && angle<PI/2.0) return 0.0;\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat easeInOutExpo(float t, float b, float c, float d) {\n\tt /= d/2.0;\n\tif (t < 1.0) return c/2.0 * pow( 2.0, 10.0 * (t - 1.0) ) + b;\n\tt--;\n\treturn c/2.0 * ( -pow( 2.0, -10.0 * t) + 2.0 ) + b;\n}\n\nfloat easeInOutQuad(float t, float b, float c, float d) {\n\tt /= d/2.0;\n\tif (t < 1.0) return c/2.0*t*t + b;\n\tt--;\n\treturn -c/2.0 * (t*(t-2.0) - 1.0) + b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 zoom = vec2(8.0, 8.0);\n    vec2 index = floor(zoom * uv)/zoom;\n    uv *= zoom;\n    \n    \n    float behavior = 0.0;    \n    uv.x += step(1., mod(uv.y,2.0));\n    behavior = step(1., mod(uv.x,2.0));\n    \n    float totalColors = 8.0;\n    float cIndex = floor((index.x+index.y)*totalColors);\n    cIndex = mod(cIndex, totalColors);\n    vec3 color = vec3(0.0);\n    if(cIndex==0.0) color = vec3(0.92, 0.35, 0.20);\n    else if(cIndex==1.0) color = vec3(0.50, 0.77, 0.25);\n    else if(cIndex==2.0) color = vec3(0.00, 0.63, 0.58);\n    else if(cIndex==3.0) color = vec3(0.08, 0.45, 0.73);\n    else if(cIndex==4.0) color = vec3(0.38, 0.18, 0.55);\n    else if(cIndex==5.0) color = vec3(0.76, 0.13, 0.52);\n    else if(cIndex==6.0) color = vec3(0.91, 0.13, 0.36);\n    else if(cIndex==7.0) color = vec3(0.96, 0.71, 0.17);\n    \n    uv = fract(uv);\n    \n    //crazy result\n    //uv /= 2.0;\n    \n    float frame = iTime/3.0;\n    if(iMouse.x>0.0) frame *= 5.0 * (iMouse.x / iResolution.x);//velocity\n        \n    float loop = fract(frame);\n    \n    float freq = 0.0;\n        \n    float angle = 0.0;\n    if(behavior==0.0) {\n        if(loop<0.5)\n        \tangle = PI/2.0*easeInOutExpo(loop*2.0, 0.0, 1.0, 1.0);\n        else\n        \tangle = PI/2.0+PI/2.0*easeInOutExpo((loop-0.5)*2.0, 0.0, 1.0, 1.0);\n    }else{\n        angle = PI/2.0*easeInOutQuad((sin(frame*PI*4.0)+1.0)/2.0, 0.0, 1.0, 1.0);\n    }\n    \n    uv -= vec2(0.5);\n    uv = rotate2d( angle ) * uv;\n    uv += vec2(0.5);\n    \n    vec3 circ = vec3(circle(uv,1.0));\n    \n    color *= circ;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldK3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldK3W3", "name": "Heaven Forest", "author": "Unix", "description": "Shader Heaven Forest used in Secret Society Hoodlum Demo... Enjoy ;-)\nSecret Society : http://www.pouet.net/prod.php?which=65399", "tags": ["tree", "forest", "secret", "heaven", "hoodlum", "unix", "society"], "likes": 44, "viewed": 1004, "date": "1456825278", "time_retrieved": "2024-06-20T18:33:37.621748", "image_code": "// Created by David Lovera - Unix/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Shader used in SecretSociety Demo\n// Originally from Xyptonjtroz by Dave Hoskins + nimitz (twitter: @stormoid)\n\n#define ITR 100\n#define FAR 80.\n#define time iTime\n#define MOD3 vec3(.16532,.17369,.15787)\n#define SUN_COLOUR  vec3(1., .65, .35)\n#define FOUR-D_NOISE\t// ...Or this\n\n \nfloat height(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    h -= sin(h*10.0)*.1;\n    return h;\n}\n\nfloat camHeight(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    return h;\n}\n\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat smin( float a, float b)\n{\n\tconst float k = 2.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\nfloat tri(in float x){return abs(fract(x)-.5);}\n\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nfloat vine(vec3 p, in float c, in float h)\n{\n    p.y += sin(p.z*.1625+1.3)*8.5-.5;\n    p.x += cos(p.z*.1575)*1.;\n    vec2 q = vec2(mod(p.x, c)-c/2., p.y);\n    return length(q) - h*1.4 -sin(p.z*3.+sin(p.x*7.)*0.5)*0.1;\n}\n\nvec4 quad(in vec4 p){return abs(fract(p.yzwx+p.wzxy)-.5);}\n\nfloat Noise3d(in vec3 q)\n{\n    \n    float z=1.4;\n    vec4 p = vec4(q, iTime*.5);\n\tfloat rz = 0.;\n    vec4 bp = p;\n\tfor (float i=0.; i<= 2.; i++ )\n\t{\n      vec4 dg = quad(bp);\n        p += (dg);\n\n\t\tz *= 1.5;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.w+tri(p.y+tri(p.x)))))/z;\n        \n        bp = bp.yxzw*2.0+.14;\n\t}\n\treturn rz;\n}\n\nvec2 hash22(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nfloat map(vec3 p)\n{\n    p.y += height(p.zx);    \n    vec2 hs = hash22(floor(p.zx*20.));\n    p.xz *=.42;\n    p.zx = mod(p.zx,4.)-2.;\t\t\n\tfloat d = (p.y)+0.5;    \n\tp.y -= hs.x*2.4+1.15;\n\td = smin(d, vine(p.zyx+vec3(3.2+sin(iTime)*0.5,2.1,20.1+cos(iTime)*1.0),1.,0.5) );\n\td= smin(d,box(p, vec3(0.1,8.4,.1)));\n\n    return d*1.1;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.xz -= time*7.;\n    p.y -= time*.5;\n    return (max(Noise3d(p*.008+.1)-.1,0.0)*Noise3d(p*.1))*.3;\n}\n\nfloat march(in vec3 ro, in vec3 rd, out float drift, in vec2 scUV)\n{\n\tfloat precis = 0.0001;\n    float h=precis*2.0;\n    float d = hash12(scUV);\n    drift = 0.0;\n    for( int i=0; i<ITR; i++ )\n    {\n        vec3 p = ro+rd*d;\n        if(h < precis || d > FAR) break;\n        h = map(p);\n        drift +=  fogmap(p, d);\n        d += min(h*.65 + d * .002, 8.0);\n\t }\n    drift = min(drift*0.5, 1.0);\n\treturn d;\n}\n\nvec3 normal( in vec3 pos, in float d )\n{\n\tvec2 eps = vec2( d *d* .003+.01, 0.0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat bnoise(in vec3 p)\n{\n    p.xz*=.4;\n    float n = Noise3d(p*3.)*0.8;\n    n += Noise3d(p*1.5)*0.2;\n    return n*n*.2;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    p.xz *= .4;\n    //p *= 1.0;\n    vec2 e = vec2(.01,0.);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*10./(ds));\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint)\n{\n\tfloat res = 1.0;\n    \n    float t = mint;\n    for( int i=0; i<12; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.1, 1.5 );\n    }\n    return clamp( res, 0., 1.0 );\n}\n\nvec3 Clouds(vec3 sky, vec3 rd)\n{\n    \n    rd.y = max(rd.y, 0.0);\n    float ele = rd.y;\n    float v = (200.0)/rd.y;\n\n    rd.y = v;\n    rd.xz = rd.xz * v - time*8.0;\n\trd.xz *= .00004;\n    \n\tfloat f = Noise3d(rd.xzz*3.) * Noise3d(rd.zxx*1.3)*2.5;\n    f = f*pow(ele, .5)*2.;\n  \tf = clamp(f-.15, 0.01, 1.0);\n\n    return  mix(sky, vec3(1),f );\n}\n\n\nvec3 Sky(vec3 rd, vec3 ligt)\n{\n    rd.y = max(rd.y, 0.0);    \n    vec3 sky = mix(vec3(.1, .15, .25), vec3(.8), pow(.8-rd.y, 3.0));\n    return  mix(sky, SUN_COLOUR, min(pow(max(dot(rd,ligt), 0.0), 4.5)*1.2, 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t\n\tfloat fg;\n\t\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-1.9,0.07):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(0.+smoothstep(0.,1.,tri(time*1.5)*.3)*1.1, smoothstep(0.,1.,tri(time*3.)*3.)*0.00, -time*3.5-130.0);\n    ro.y -= camHeight(ro.zx)-.5;\n    \n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-.05,0.));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\n    vec3 ligt = normalize( vec3(-1.5 +(iTime*10.0), (iTime/10.0), -.5) );\n    float rz = march(ro,rd, fg, gl_FragCoord.xy);\n\tvec3 sky = Sky(rd, ligt);\n    \n    vec3 col = sky;\n   \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos, rz);\n        float d = distance(pos,ro);\n        nor = bump(pos,nor,d);\n        float shd = (shadow(pos,ligt,.01));\n        \n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 );\n        vec3 ref = reflect(rd,nor);\n        float spe = pow(clamp( dot( ref, ligt ), 0.0, 1.0 ),5.)*2.;\n        col = vec3(.1);\n\t    col = col*dif*shd + spe*shd*SUN_COLOUR +abs(nor.y)*vec3(.1, .1, .2);\n        col = mix(col, sky, smoothstep(FAR-25.,FAR,rz));\n    }\n    else\n    {\n        col = Clouds(col, rd);\n    }\n\n    // Fog mix...\n    col = mix(col, vec3(0.96, .8, .66), fg);\n  \n    // Post...\n\tcol = min(pow(col*1.,vec3(0.7)), 1.0);\n\tcol = smoothstep(0., 1., col);\n    \n    // Borders...\n    float f = smoothstep(0.0, 3.0, iTime)*.5;\n    col *= f+f*pow(70. *q.x*q.y*(1.0-q.x)*(1.0-q.y), .2);\n\t    \n\tfragColor = vec4( col, 1.0 );\n}\n ", "image_inputs": [{"id": "Mss3zS", "previewfilepath": "https://soundcloud.com/imalogic/secret-society", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/imalogic/secret-society", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldK3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldKGDd", "name": "2D Parallax Starfield", "author": "qmuntada", "description": "Based on this shader : https://www.shadertoy.com/view/ltXSDN", "tags": ["2d", "parallax", "star", "starfield"], "likes": 41, "viewed": 2843, "date": "1457223220", "time_retrieved": "2024-06-20T18:33:37.961229", "image_code": "#define\tSPEED \t\t.1\n#define\tSTAR_NUMBER 300\n#define\tITER \t\t4\n\nvec3 col1 = vec3(155., 176., 255.) / 256.; // Coolest star color\nvec3 col2 = vec3(255., 204., 111.) / 256.; // Hottest star color\n\nfloat rand(float i){\n    return fract(sin(dot(vec2(i, i) ,vec2(32.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord / iResolution.y;\n    float res = iResolution.x / iResolution.y;\n    fragColor = vec4(0.0);\n    \n    // static far stars    \n   \tvec4 sStar = vec4(rand(uv.x * uv.y));\n    sStar *= pow(rand(uv.x * uv.y), 200.);\n    sStar.xyz *= mix(col1, col2, rand(uv.x + uv.y));\n    fragColor += sStar;\n    \n    // milky way\n    vec4 col = 0.5 - vec4(length(vec2(uv.x, 0.5) - uv));\n    col.xyz *= mix(col1, col2, 0.75);\n    fragColor += col * 2.;\n    float c = 0.;\n    float c2 = 0.;\n    vec2 rv = uv;\n    rv.x -= iTime * SPEED * 0.25;\n    for(int i=0;i<ITER;i++)\n\t\tc += (texture(iChannel0, rv * 0.25 + rand(float(i + 10) + uv.x * uv.y) * (16. / iResolution.y)) / float(ITER)).x;\n    fragColor -= c * 0.5;\n    fragColor = clamp(fragColor, 0.0, 1.0);\n    \n    // Dynamic Stars    \n    for (int i = 0; i < STAR_NUMBER; ++i){\n    \tfloat n = float(i);\n        \n        //position of the star\n        vec3 pos = vec3(rand(n) * res + (iTime + 100.0) * SPEED, rand(n + 1.) , rand(n + 2.));\n        \n        // parralax effect\n        pos.x = mod(pos.x * pos.z, res);\n        pos.y = (pos.y + rand(n + 10.)) * 0.5;\n\n        //drawing the star\n        vec4 col = vec4(pow(length(pos.xy - uv), -1.25) * 0.001 * pos.z * rand(n + 3.));\n        \n        //coloring the star\n        col.xyz *= mix(col1, col2, rand(n + 4.));\n        \n        //star flickering\n        col.xyz *= mix(rand(n + 5.), 1.0, abs(cos(iTime * rand(n + 6.) * 5.)));\n        \n        fragColor += vec4(col);\n    }\n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtSz8", "name": "What the hell is going on", "author": "TheSovietColossus", "description": "Huh", "tags": ["2d", "lambert", "phongmodel"], "likes": 0, "viewed": 165, "date": "1457717124", "time_retrieved": "2024-06-20T18:33:37.961229", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 fColor;\n                \n    vec4 L = vec4(-1.0+fragCoord.x*sin(iTime), -1.0+fragCoord.y*cos(iTime), 1.0, 1.0);\n    vec4 E = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 N = vec4(fragCoord.x, fragCoord.y, 0.8, 1.0);\n    vec4 B = normalize( L + E );    \n    \n    vec4 ambient = vec4(1.0, 0.0, 0.1, 1.0);\n    vec4 diffuseProduct = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 specularProduct = vec4(0.3,0.8,0.3,1.0);\n    float specular =  pow(max(dot(B,N), 0.0), 0.17);\n    vec4 specularity = specular*specularProduct;\n    \n    float Kd = max( dot(L, N), 0.0 );\n    vec4  diffuse = Kd*diffuseProduct;\n    \n    fColor = ambient + diffuse + specularity;\n    fColor.a = 1.0;\n\n    fragColor = fColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtSzn", "name": "flow by stream function", "author": "FabriceNeyret2", "description": "flow by stream function. see [url]https://hal.inria.fr/inria-00345903/[/url]", "tags": ["fluid", "flow", "short", "stream", "streamfunction"], "likes": 38, "viewed": 2526, "date": "1457434834", "time_retrieved": "2024-06-20T18:33:38.197698", "image_code": "// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\n\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\n\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\n\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n    \nfloat f(float d) { // interpolation function\n    float t = 1.-d/r;\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\n}\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU /= iResolution.y;\n    \n    // --- interpolate stream function : add(distance to border, stream at border)\n    float t = iTime,wf=0.,wT=0., w; \n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\n    w = wf / wT;                               // stream field\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\n    \n    // --- display\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\n\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtXD8", "name": "Thomas X3", "author": "dr2", "description": "Three little steam locomotives", "tags": ["raymarching", "train"], "likes": 8, "viewed": 641, "date": "1459166133", "time_retrieved": "2024-06-20T18:33:38.219835", "image_code": "// \"Thomas X3\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Thomas is a popular toy engine (many design changes have been made).\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrOBox2Df (vec2 p, vec2 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec4 pCar[3];\nvec3 qHit, ltDir;\nvec2 rlSize;\nfloat ti[13], dstFar, tCur, szFac, trSpd, rgHSize, trkWid, tCyc;\nint idObj, idObjGrp;\n\nconst int idEng = 1, idCabin = 2, idCoal = 3, idBase = 4, idBand = 4, idAxle = 4,\n   idRoof = 6, idWheel = 7, idSpoke = 7, idCrod = 8, idFunl = 9, idFunt = 10,\n   idStripe = 10, idLamp = 11, idCpl = 12, idGrnd = 21, idTflr = 22, idRail = 23;\nconst int dirNS = 0, dirEW = 1, dirSW = 2, dirNW = 3, dirSE = 4, dirNE = 5,\n   dirX = 6;\n\nfloat TrackDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 ip;\n  float dMin, d, db, dc, sqWid;\n  int indx, isq;\n  dMin = dstFar;\n  sqWid = 0.4999;\n  ip = floor (p.xz);\n  db = PrOBox2Df (p.xz, vec2 (2. * sqWid * rgHSize));\n  q = p;\n  q.xz = fract (q.xz) - vec2 (0.5);\n  indx = -1;\n  isq = int (2. * rgHSize * mod (ip.y + rgHSize, 2. * rgHSize) +\n     mod (ip.x + rgHSize, 2. * rgHSize));\n  if (isq == 6 || isq == 8 || isq == 20 || isq == 23 || isq == 26 ||\n     isq == 29) indx = dirNS;\n  else if (isq == 1 || isq == 13 || isq == 15 || isq == 16 || isq == 33 ||\n     isq == 34) indx = dirEW;\n  else if (isq == 35) indx = dirSW;\n  else if (isq == 2 || isq == 17) indx = dirNW;\n  else if (isq == 12 || isq == 32) indx = dirSE;\n  else if (isq == 0) indx = dirNE;\n  else if (isq == 14) indx = dirX;\n  d = dstFar;\n  if (indx >= 0 && indx <= dirX) {\n    q.y -= 0.5 * rlSize.y;\n    dc = max (db, PrBox2Df (q.xz, vec2 (sqWid)));\n    if (indx < dirX) {\n      if (indx == dirEW) q.xz = q.zx;\n      else if (indx == dirNW) q.z *= -1.;\n      else if (indx == dirSE) q.x *= -1.;\n      else if (indx == dirNE) q.xz *= -1.;\n      if (indx <= dirEW) {\n        q.z += 0.5;  q.x = abs (q.x);\n      } else {\n        q.xz += 0.5;  q.x = abs (length (q.xz) - 0.5);\n      }\n      d = max (PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.5 * rlSize.y)), dc);\n      if (d < dMin) { dMin = d;  idObj = idTflr;  qHit = q; }\n      q.xy -= vec2 (trkWid, rlSize.y);\n      d = max (PrOBox2Df (q.xy, rlSize), dc);\n      if (d < dMin) { dMin = d;  idObj = idRail;  qHit = q; }\n    } else {\n      qq = q;  q.x = abs (q.x);  q.z += 0.5;\n      d = PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.5 * rlSize.y));\n      q = qq;  q.xz = q.zx;   q.x = abs (q.x);  q.z += 0.5;\n      d = max (min (d, PrOBox2Df (q.xy, vec2 (2. * trkWid, 0.5 * rlSize.y))), dc);\n      if (d < dMin) { dMin = d;  idObj = idTflr;  qHit = q; }\n      q = qq;  q.y -= rlSize.y;  qq = q;\n      q.x = abs (q.x) - trkWid;  q.z += 0.5;\n      d = PrOBox2Df (q.xy, rlSize);\n      q = qq;  q.xz = q.zx;  q.x = abs (q.x) - trkWid;  q.z += 0.5;\n      d = min (d, PrOBox2Df (q.xy, rlSize));\n      q = qq;  q.xz = abs (q.xz) - trkWid + 1.75 * rlSize.x;\n      d = max (max (d, - min (PrBox2Df (q.xz, vec2 (trkWid, 0.75 * rlSize.x)),\n         PrBox2Df (q.xz, vec2 (0.75 * rlSize.x, trkWid)))), dc);\n      if (d < dMin) { dMin = d;  idObj = idRail;  qHit = q; }\n    }\n  }\n  return dMin;\n}\n\nfloat TrackRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = - sign (rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = TrackDf (p);\n    dHit += min (d, 0.001 + max (0., min (h.x, h.y)));\n    if (d < 0.0001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d > 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat EngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, aw, a, sx, wRad, tw;\n  wRad = 0.8;\n  tw = 214. * szFac * trkWid;\n  q = p;\n  q -= vec3 (0., -0.2, 0.5);\n  d = max (PrCapsDf (q, 1., 2.), - (q.z + 1.7));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idEng; }\n  q = p;  q.z = abs (q.z - 0.85);  q -= vec3 (0., -0.2, 1.8);\n  d = PrCylDf (q, 1.05, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBand; }\n  q = p;  q -= vec3 (0., -1.3, -0.25);\n  d = PrBoxDf (q, vec3 (1., 0.1, 3.2));\n  q = p;  q -= vec3 (0., -1.4, 3.);\n  d = min (d, PrBoxDf (q, vec3 (1.1, 0.2, 0.07)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idBase; }\n  q.x = abs (q.x);  q -= vec3 (0.6, 0., 0.1);\n  d = PrCylDf (q, 0.2, 0.1);\n  q = p;  q -= vec3 (0., -2.4, -1.75);\n  d = min (d, max (PrCylDf (q, 4., 0.65), - (q.y - 3.75)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idRoof; }\n  q = p;  q -= vec3 (0., 0.01, -1.75);\n  d = max (max (PrBoxDf (q, vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -0.2), vec3 (0.95, 1.3, 0.65))),\n     - PrBoxDf (q - vec3 (0., 0.7, 0.), vec3 (1.1, 0.4, 0.5)));\n  q.x = abs (q.x);  q -= vec3 (0.4, 1., 0.4);\n  d = max (d, - PrBoxDf (q, vec3 (0.35, 0.15, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCabin;  qHit = q; }\n  q = p;  q -= vec3 (0., -0.5, -3.15);\n  d = PrBoxDf (q, vec3 (1., 0.7, 0.3));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCoal;  qHit = q; }\n  q = p;  q -= vec3 (0., -1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCpl; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.12, -1.4, 1.1);\n  d = PrCylDf (q.zyx, wRad, 0.1);\n  aw = - trSpd * tCur / (szFac * wRad);\n  if (d < dMin) {\n    d = min (max (min (d, PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n       - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n    if (d < dMin) { dMin = d;  idObj = idObjGrp + idWheel; }\n    q = p;  q.x = abs (q.x);  q -= vec3 (tw - 0.17, -1.4, 1.1 * sign (q.z));\n    q.yz = q.yz * cos (aw) + q.zy * sin (aw) * vec2 (-1., 1.);  \n    a = floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.;\n    q.yz = q.yz * cos (2. * pi * a) + q.zy * sin (2. * pi * a) * vec2 (-1., 1.);\n    q.z += 0.5 * wRad;\n    d = PrCylDf (q, 0.05, 0.5 * wRad);\n    if (d < dMin) { dMin = d;  idObj = idObjGrp + idSpoke; }\n  }\n  q = p;  sx = sign (q.x);  q.x = abs (q.x);\n  q -= vec3 (tw + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idCrod; }\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idAxle; }\n  q = p;  q -= vec3 (0., 1.1, 2.15);  d = PrCylDf (q.xzy, 0.3, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFunl; }\n  q = p;  q -= vec3 (0., 1.5, 2.15);\n  d = max (PrCylDf (q.xzy, 0.4, 0.15), - PrCylDf (q.xzy, 0.3, 0.2));\n  q = p;  q -= vec3 (0., 0.8, 0.55);\n  d = min (d, PrCapsDf (q.xzy, 0.3, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idFunt; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, 0.85);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 1.8));\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -1.75);\n  d = min (d, PrBoxDf (q, vec3 (0.05, 0.1, 0.6)));\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -3.15);\n  d = min (d, PrBoxDf (q, vec3 (0.05, 0.1, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idStripe; }\n  q = p;  q -= vec3 (0., -0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idLamp; }\n  return dMin;\n}\n\nfloat SceneDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db;\n  dMin = dstFar;\n  db = PrOBox2Df (p.xz, vec2 (0.999 * rgHSize));\n  d = abs (p.y + 0.001) - 0.001;\n  d = max (d, db);\n  if (d < dMin) { dMin = d;  idObj = idGrnd;  qHit = p; }\n  dMin /= szFac;\n  for (int k = 0; k < 3; k ++) {\n    q = p;\n    q -= pCar[k].xyz;\n    q /= szFac;\n    d = PrCylDf (q.xzy, 4., 2.2);\n    if (d < dMin) {\n      q.xz = Rot2D (q.xz, pCar[k].w);\n      idObjGrp = (k + 1) * 256;\n      dMin = EngDf (q, dMin);\n    }\n }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat SceneRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = SceneDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = min (dMin, TrackDf (p));\n  dMin = min (dMin, SceneDf (p));\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 n)\n{\n  vec4 objCol;\n  int ig, id;\n  const vec4 cR = vec4 (1., 0., 0., 1.), cY = vec4 (1., 1., 0., 1.),\n     cG = vec4 (0., 1., 0., 1.), cB = vec4 (0., 0., 1., 1.),\n     cBlk = vec4 (0.03, 0.03, 0.03, 0.1), cLB = vec4 (0.4, 0.4, 1., 1.);\n  objCol = vec4 (0.);\n  if (idObj <= idRail) {\n    if (idObj == idGrnd) objCol = vec4 (mix (vec3 (0.4, 0.25, 0.1),\n        vec3 (0.3, 0.6, 0.3), smoothstep (0.8, 1.1, Fbm2 (5. * ro.xz))) *\n        (1. - 0.1 * Noisefv2 (30. * ro.xz)), 0.05);\n    else if (idObj == idTflr) objCol = vec4 (0.4, 0.5, 0.4, 0.1) *\n       (1. - 0.3 * Fbm2 (90. * ro.xz));\n    else if (idObj == idRail) objCol = vec4 (0.7, 0.7, 0.7, 0.5);\n  } else {\n    ig = idObj / 256;\n    id = idObj - 256 * ig;\n    if (id == idEng) objCol = (ig == 1) ? cG : ((ig == 2) ? cY : cR);\n    else if (id == idCabin) objCol = (qHit.y > -1.3) ? cLB : cB;\n    else if (id == idCoal)\n       objCol = (qHit.y > 0.3) ? ((n.y > 0.9) ? cBlk : cLB) : cB;\n    else if (id == idBase || id == idBand || id == idAxle)\n       objCol = vec4 (0.3, 0.2, 0.2, 0.3);\n    else if (id == idRoof || id == idCpl || id == idFunl && n.y <= 0.9)\n       objCol = (ig == 3) ? cG : ((ig == 1) ? cY : cR);\n    else if (id == idFunl && n.y > 0.9) objCol = cBlk;\n    else if (id == idWheel || id == idSpoke) objCol = vec4 (0.6, 0.7, 0.7, 0.5);\n    else if (id == idCrod) objCol = cY;\n    else if (id == idStripe || id == idFunt) objCol = (ig == 2) ? cG :\n       ((ig == 3) ? cY : cR);\n    else if (id == idLamp) objCol = (mod (tCur + 0.667 * float (ig), 2.) < 1.) ?\n       vec4 (1., 1., 1., -1.) : vec4 (0.6, 0.6, 0.6, -1.);\n  }\n  return objCol;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 qHitT, col, vn;\n  float dstHit, d, sh;\n  int idObjT;\n  dstHit = dstFar;\n  d = TrackRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  idObjT = idObj;\n  qHitT = qHit;\n  d = SceneRay (ro, rd);\n  if (d < dstHit) dstHit = d;\n  else {\n    idObj = idObjT;\n    qHit = qHitT;\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idTflr) vn = VaryNf (100. * ro, vn, 2.);\n    else if (idObj == idGrnd) vn = VaryNf (5. * ro, vn, 0.5);\n    objCol = ObjCol (ro, rd, vn);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      sh = ObjSShadow (ro, ltDir);\n      col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)) +\n         objCol.a * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    }\n  } else col = vec3 (0.1, 0.1, 0.2);\n  return clamp (col, 0., 1.);\n}\n\n#define SLIN(k,d) ti[k + 1] = ti[k] + d\n#define SCRV(k) ti[k + 1] = ti[k] + tc\n\nvoid TrSetup ()\n{\n  float tc;\n  tc = 0.25 * pi;\n  ti[0] = 0.;\n  SCRV(0);   SLIN(1, 1.);  SCRV(2);  SLIN(3, 4.);  SCRV(4);  SLIN(5, 2.);\n  SCRV(6);  SLIN(7, 2.);  SCRV(8);  SLIN(9, 4.);  SCRV(10);  SLIN(11, 1.);\n  tCyc = ti[12];\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r, dr;\n  float tc, a;\n  tc = 0.25 * pi;\n  t = mod (t, tCyc);\n  dr = vec2 (0.);\n  a = 99.;\n  if (t < ti[1]) {\n    r = vec2 (0., 0.);  dr.xy = vec2 (1.);  a = 0.5 * tc + 0.25 * (t - ti[0]);\n  } else if (t < ti[2]) {\n    r = vec2 (1., 0.5);  dr.x = (t - ti[1]);\n  } else if (t < ti[3]) {\n    r = vec2 (2., 0.);  dr.y = 1.;  a = 0.75 * tc + 0.25 * (t - ti[2]);\n  } else if (t < ti[4]) {\n    r = vec2 (2.5, 1.);  dr.y = (t - ti[3]);\n  } else if (t < ti[5]) {\n    r = vec2 (2., 5.);  dr.x = 1.;  a = 0.5 * tc - 0.25 * (t - ti[4]);\n  } else if (t < ti[6]) {\n    r = vec2 (3., 5.5);  dr.x = (t - ti[5]);\n  } else if (t < ti[7]) {\n    r = vec2 (5., 5.);  a = 0.25 * tc - 0.25 * (t - ti[6]);\n  } else if (t < ti[8]) {\n    r = vec2 (5.5, 5.);  dr.y = - (t - ti[7]);\n  } else if (t < ti[9]) {\n    r = vec2 (5., 2.);  dr.y = 1.;  a = 0. * tc - 0.25 * (t - ti[8]);\n  } else if (t < ti[10]) {\n    r = vec2 (5., 2.5);  dr.x = - (t - ti[9]);\n  } else if (t < ti[11]) {\n    r = vec2 (0., 2.);  dr.x = 1.;  a = 0.25 * tc + 0.25 * (t - ti[10]);\n  } else if (t < ti[12]) {\n    r = vec2 (0.5, 2.);  dr.y = - (t - ti[11]);\n  }\n  if (a != 99.) {\n    a *= 2. * pi / tc;\n    r += 0.5 * vec2 (cos (a), sin (a));\n  }\n  r += dr - rgHSize;\n  return r;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, pc;\n  vec3 ro, rd, col, u, vd;\n  vec2 canvas, uv, uvs, ori, ca, sa, vo;\n  float el, az, zmFac, t, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 40.;\n  ltDir = normalize (vec3 (1., 2., -1.));\n  rgHSize = 3.;\n  szFac = 0.07;\n  rlSize = vec2 (0.005, 0.01);\n  trkWid = 0.095;\n  trSpd = 0.8;\n  TrSetup ();\n  for (int k = 0; k < 3; k ++) {\n    t = trSpd * tCur - float (k) * tCyc / 3.;\n    pCar[k].xz = TrackPath (t);\n    pCar[k].y = 3. * rlSize.y + 0.15;\n    vo = TrackPath (t + 0.01) - pCar[k].xz;\n    pCar[k].w = atan (vo.x, vo.y);\n  }\n  if (length (uvs) < 1.5 * SmoothBump (0.2, 0.7, 0.04, mod (0.05 * tCur, 1.))) {\n    az = 0.01;\n    el = 0.1 * pi;\n    if (mPtr.z > 0.) {\n      az -= 2. * pi * mPtr.x;\n      el = clamp (el - pi * mPtr.y, 0.02 * pi, 0.45 * pi);\n    }\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., sa.y, 0., 1., 0., - sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, sa.x, 0., - sa.x, ca.x);\n    ro = vuMat * vec3 (0., 0., -15.);\n    zmFac = 8.;\n  } else {\n    t = mod (0.1 * tCur, 3.);\n    pc = (t < 1.) ? pCar[0] : ((t < 2.) ? pCar[1] : pCar[2]);\n    ro = vec3 (0., 1., -5.);\n    vd = normalize (pc.xyz - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 6.;\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldVGRz", "name": "Ajax loader", "author": "patu", "description": "Fast and short loader.", "tags": ["loader"], "likes": 3, "viewed": 407, "date": "1458240975", "time_retrieved": "2024-06-20T18:33:38.219835", "image_code": "/**\n * My chrome extension for Shadertoy:\n * \n * http://bit.ly/shadertoy-plugin \n */\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid mainImage(out vec4 C, in vec2 F) {\n\tvec2 \n        r = iResolution.xy,\n        u = F / r - .5;\n    \n    float t = iTime;\n    \n    u.x *= r.x / r.y;\n    pR(u, -t * 5. + (sin(t) * 3.+ 1.));\n        \n    C = vec4(length(u) < .2 && length(u) > .1 ? 1.- atan(u.y, u.x) * .5 : 0.);\n     \n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3SD4", "name": "Tunnel tryout 001", "author": "andro", "description": "PAARDEN", "tags": ["raymarch"], "likes": 0, "viewed": 135, "date": "1459295152", "time_retrieved": "2024-06-20T18:33:40.646260", "image_code": "//mercury functions \n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n//mercury definitions\nfloat d;\nfloat r = 0.5;//default 0.3\nfloat n = 4.0;//default 0.4\n\n//for modulo\nfloat size = 4.0;\n\tfloat c = 0.0;\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n\n/*\n * # Raymarched distance-field renderer tutorial\n * # Part 1: Basic Distance Field & Raymarching\n *\n * ```\n * Author:  Sbastien Pierre   http://sebastienpierre.ca   @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is meant to show how to implement a raymarching distance field\n * shader-based renderer. It is based on the work of Inigo Quilezles (\"iq\"), whose\n * amazing code can be see all around on Shadertoy.com.\n *\n * Before editing/reading this shader, you should learn about distance fields and\n * raymarching, in particular [DIST] and [RAY] mentioned below. This tutorial's code\n * is based on the [TRI] code by `iq`.\n *\n * References:\n *\n * - [DIST] http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n * - [TRI]  https://www.shadertoy.com/view/4sXXRN\n * - [RAY]  http://www.iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n*/\n\n/**\n  * sdSphere is the distance field-based sphere equation as described\n  * by iq in [DIST]\n*/\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\n\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n    \n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n\n\n\nvoid pR(inout vec2 p, float a) \n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\t// The sphere is positioned at the origin (0,0,0) and has a radius of `s`.\n\t// the distance between the point `p` and the envelope of the shpere is\n\t// then the distance between the point and the origin, minus the radius\n\t// of the sphere.\n\treturn length(p)-s;\n}\n\n//creates an unsigned Box\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n        \n}\n\n//Displacement\nfloat displacement(vec3 p)\n{\n   return  sin(3.0*sin(p.x+(iTime)))*sin(p.y+(iTime))\n       *sin(p.z+(iTime));\n}\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0.0 ? abs(p.y) : length(vec2(p.y, l));\n}\n\n//mod functions\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.0))* 2.0 - vec2(1.0);\n\treturn c;\n}\n\n/**\n  * The map function is where you can register the distance field functions\n  * for all the \"objects\" in your scene. It is fairly simple to do union, interection\n  * difference, and repeats, as explained in [DIST]\n*/\n////////////// /////////////////////// /////////////////// //////////////////////\nfloat map( vec3 p )//where the magic happens\n{\n    //pR(p.zx,cos(iTime)*PHI);//This rotates around the p.xz axis passes through\n    //pR(p.xz,sin(iTime*0.5));//This rotates around the p.xz axis passes through\n  \n   // pR(p.yx,1.5);//This rotates around the p.xz axis passes through\n   // pR(p.yx,sin(iTime*0.33));//This rotates around the p.xz axis passes through\n    \n    \n     pR(p.xy,PI*0.01*(PI*sin(iTime)));//This rotates around the p.xz axis passes through\n    //pR(p.yz,0.1*(PI*cos(iTime)));\n    pMod3(p, vec3 (2.0));\n    float box1 = fBox(p,vec3(1.0,0.1,0.1));\n    float box2 = fBox(p,vec3(0.1,1.0,0.2));//make diagonal crosses\n     pR(p.xz,PI*0.5);//This rotates around the p.xz axis passes through\n    vec3 movebox3 = vec3(0.0,sin(iTime),0.0);\n    float box3 = fBox(p+movebox3,vec3(1.0,0.1,0.1));//make diagonal crosses\n    \n\tfloat sphere = sdSphere(p,1.0)*0.5;\n    //pR(p.yz,1.5);//This rotates around the p.xz axis passes through\n\tfloat torus1 = fTorus(p,0.1,1.0)+displacement(p)*0.01;\n   // pR(p.yz,1.5);//This rotates around the p.xz axis passes through\n    float torus2 = fTorus(p,0.2+(sin(iTime))*0.35,0.75)+displacement(p)*0.5;\n    //float torus = fTorus(p,0.25,0.75);\n     pR(p.zy,PI*0.5*sin(iTime));//This rotates around the p.xz axis passes through\n    float disc1 =fDisc(p,1.0);//pModMirror2( p.xz, vec2(2.0));\n    \n    \n    \n    //return udRoundBox(p,vec3(1.0, 1.0, 1.0),0.05);\n    //return udRoundBox(p,vec3(abs(sin(iTime)),abs(sin(iTime))*2.0,1.0),0.05);\n      \n\t//return fOpPipe(box,torus,r*0.6);//backup\n    //return torus;\n   float unionX = fOpUnionRound(torus2, torus1, 0.5);\n    float engrave = fOpEngrave(sphere, unionX, 0.5);\n    //return engrave;\n    float union1 = fOpUnionRound(box1,box2, 0.05);\n     float union2 = fOpUnionRound(union1,box3, 0.001);\n    float union3 = fOpUnionRound(union2,disc1, 0.1);\n    float union4 = fOpEngrave( engrave , union3, 0.5);\n    float union5 = fOpUnionRound( union3 , union4, 0.5);\n    float result = union5;\n    return result;\n    //return engrave;\n}\n\n\nvec3 fNormal(vec3 intersection, float lastDistance)//generates normals\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize((vec3(map(intersection + epsilon.xyy),\n    map(intersection + epsilon.yxy),\n    map(intersection + epsilon.yyx)) - lastDistance) / epsilon.x);\n}\n\n\n\t// `maxd` is the maximum distance after which we'll stop the\n    // raymarching. This means that if we haven't interesected\n    // with anything after 10.0 world units of iteration, we'll stop.\n    const float maxd = 20.0;\n\n\n/**\n  * The `intersect` function is the main raymarching algorithm. It takes\n  * the ray origin `ro` and the ray step (or delta) `rd`. `rd` will be\n  * repeatedly added to `ro` until the `map` function (which determines\n  * the distance between the given point and the union of all objects\n  * in the scene) returns a value that is close to 0 (meaning the current\n  * point is almost on the scene object's envelope.\n  *\n  * Note that if `rd` is not normalized, the steps will increase or\n  * decrease as the intersection algorithm go.\n*/\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 normal )\n{\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<100; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.0 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n\t    h = map( ro+rd*t );\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\t\n    normal = fNormal(ro + rd * t, h);\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel, meaning it\n    // is between [0,0] and [1,1]\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    \n    // If you do `p=q`, you will see that the origin is to the bottom left \n    // of the screen. With this simple expression, we adjust the viewpoint\n    // in the space and center the origin in the preview screen.\n    //\n    // vec2 p = q;              // [1] Origin is at the bottom-left of the screen\n    // vec2 p = 2.0 * q;        // [2] We scale by 1/2 by multiplying q\n    vec2 p = 2.0 * q - 1.0;     // [3] We scale by 1/2 and then center the origin on screen\n    // vec2 p = -0.5 + q;       // [4] Alternatively, we can center without scaling\n    \n    // NOTE: I'm not very familiar with the shader API, but from the above we can deduce\n    // that 1.0 means [1.0, 1.0] for a vect2, 2.0 means [2.0, 2.0], etc.\n    \n    // `iResolution.x/isResolution.y` is the aspect ratio, by default it is 512/288~=1.7777.\n    // If you uncomment the following line the image will appear as squashed.\n    p.x *= iResolution.x/iResolution.y;  \n    \n    // The `ro` value specifies the origin of the camera's center in the virtual space.\n    // You can tweak the X and Y values to shift the origin, or the Z value to\n    // adjust the distance to the sphere (here it is 2.0 to the sphere's center).\n\t//vec3 ro = vec3(0.0,0.0, 6.0 );\n    \n    // The `rd` value specifies the  direction of the current pixel (on the projection\n    // plane) in the 3D space The notation vec3(p,-1.0) is equivalent to vec3(p.x,p.y,-1.0) as\n    // `p` is a vec2. -1.0 for z means it is pointing forward, and the normalization ensures\n    // that `rd` can be used as a step for raymarching.\n    //vec3 rd = normalize( vec3(p,-2.0) );\n\tfloat xmove = iTime;//mod(iTime,2.0*PI);\n    //camera lookat\n    vec3 ro = vec3(cos(xmove)*0.05+1.0,sin(xmove+(PI/2.0)), xmove*2.5);//has to be even number for smooth movement\n    \n    vec3 ta = vec3(sin(xmove)*0.05+1.0, sin(xmove),xmove*2.6);\n    \n    //camera tx\n    vec3 cw = normalize (ta - ro);\n    vec3 cp = vec3 (0.0, 1.0, 0.0);\n    vec3 cu = normalize ( cross(cw,cp) );\n    vec3 cv = normalize ( cross (cu,cw) );\n    vec3 rd = normalize ( p.x*cu + p.y*cv + 2.5 *cw);\n    \n    \n    // The `col` vector holds the color that will be rendered on the screen, ie. the main\n    // output of the shader. As the alpha channel will be set to 1.0, we only need the\n    // three components RGB, hence the use of a vec3.\n\tvec3 col = vec3(0.);\n\n    // We call the `interect` function with `ro` as the ray origin and `rd` as the \n    // point from which the raymarching step/delta will be calculated. Intersect is the\n    // main raymatching function.\n    vec3 normal;\n    float t = intersect(ro,rd,normal);\n    \n        // Here we do the simplest possible shading, which is based on the distance between\n        // the ray and the sphere. if `t == 0`, it means the sphere's envelope is intersecting\n        // with the current pixel, otherwise t will be the distance between the current pixel\n        // and the sphere's envelope. \n        //\n  \t\t// NOTE: I'm not sure exactly why we need to substract t from 2.0 and not 1.0. I would\n        // assume that because the projection plane is at -1.0 (as set by `rd.z`) and that the\n        // sphere is at the origin with a 1.0 radius that there t would be osciallating between\n        // 0 (closest) and 1.0 (farthest). If you try changing rd to the following expression:\n        //\n        // vec3 rd = normalize( vec3(p,-2.0) );\n        //\n        // You will only make the sphere closer, but the values for `t` will remain the same\n        // (the shading will remain). However, if you change the value of `ro` to the following:\n        //\n        // vec3 ro = vec3(0.0, 0.0, 2.5 );\n        //\n        // not only will the sphere shrink on the projection, but `t` will also increase. It is\n        // not clear to me yet why that is.\n        float d = clamp(t / maxd, 0.0, 1.0);\n    \tvec3 fog_color = vec3(0.0, 0.0, 0.0);\n    \tvec3 obj_color = vec3(1.0, 1.0, 1.0);\n    vec3 light_direction = normalize(vec3(sin(iTime), 1.0, 0.0));\n    float diffuse = clamp(dot(normal, light_direction) * 0.5 + 0.5, 0.0, 1.0);\n        \n    \tcol = mix(obj_color * diffuse, fog_color, d);\n    \t\n\t// We assign the color we've just computed.\n    fragColor = vec4(col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3SD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3SRr", "name": "LoopingSpline", "author": "Bers", "description": "A cheap, classic Catmull-Rom. Useful for object property animation (camera path, etc). The distance field itself is not the point here, although it is a nice way to visualize the resulting spline.", "tags": ["catmullrom", "looping"], "likes": 35, "viewed": 1134, "date": "1457308908", "time_retrieved": "2024-06-20T18:33:41.743456", "image_code": "// Author : Sbastien Brub\n// Created : Oct 2014\n// Modified : Jan 2016\n//\n// A quick & simple spline implementation to use in ShaderToy.\n// The spline end folds on the start, making a cyclic path.\n// Computation is reasonably cheap (<.5 ms to solve a value at time=t on my old laptop).\n// The distance field, however, is more expensive to compute (iterative process).\n//\n// Useful for object property animation (camera path, speed, position, size, color, roughness, etc).\n// The distance field itself is not the point here, albeit a nice way to visualize the resulting spline.\n//\n// Note 1 : There is no support for random array index access (only textures/resources), therefore the function\n// \"PointArray()\" was coded.\n//\n// Note 2 : Works with float, vec2, vec3, vec4. Just replace the type. Packaging multiple properties to animate into\n//          a vec4 is most probably more efficient than calling the vec2 function twice with different control points.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\nconst int POINT_COUNT = 8;\nstruct CtrlPts\n{\n    vec2 p[POINT_COUNT];\n};\nvec2 PointArray(int i, CtrlPts ctrlPts)\n{\n    if(i==0 || i==POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec2(0);\n}\n\nvec2 catmullRom(float fTime, CtrlPts ctrlPts)\n{\n    float t = fTime;\n    const float n = float(POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec2 p1 = PointArray(idxOffset,ctrlPts);\n    vec2 p2 = PointArray(idxOffset+1,ctrlPts);\n    vec2 p3 = PointArray(idxOffset+2,ctrlPts);\n    vec2 p4 = PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec2 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nvec2 debugDistanceField(vec2 uv, CtrlPts ctrlPts)\n{\n    //This is just to illustrate the resulting spline. A Spline distance field should not be computed this way.\n    //If the real intent was to show a distance field, something like this perhaps should be used:\n    //https://www.shadertoy.com/view/XsX3zf\n    const float MAX_DIST = 10000.0;\n    float bestX = 0.0;\n    \n    //Primary (rough) estimate : decent results with 2 lines per control point (faint blue lines)\n    const int iter = POINT_COUNT*2+1;\n    //const int iter = POINT_COUNT*1+1; //<-Faster\n    //const int iter = POINT_COUNT*3+1; //<-Nicer\n    float primarySegLength = 1.0/float(iter-1);\n    vec2 pA = catmullRom(0., ctrlPts);\n    float minRoughDist = MAX_DIST;\n    float x = 0.0;\n    for(int i=0; i < iter; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        \n        float d = distanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        if(d<minRoughDist)\n        {\n            bestX = x;\n            minRoughDist = d;\n        }\n         \n        x += primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    //Secondary (smooth) estimate : refine (red curve)\n    const int iter2 = 14;\n    x = max(bestX-1.25*primarySegLength,0.0); //Starting 25% back on previous seg (50% overlap total)\n    float minDist = MAX_DIST;\n    pA = catmullRom(x, ctrlPts);\n    for(int i=0; i < iter2; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        float d = distanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        \n        if(d<minDist)\n        {\n            bestX = x;\n            minDist = d;\n        }\n         \n        //Covering 1.5x primarySegLength (50% overlap with prev, next seg)\n        x += 1.5/float(iter2-1)*primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    \n    return vec2(minDist,minRoughDist);\n}\n\n//Recenters and scales in the [0-1] range.\nvec2 getUV(vec2 px)\n{\n    vec2 uv = px / iResolution.xx;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CtrlPts ctrlPts;\n\tctrlPts.p[0] = vec2(0.10,0.25);\n    ctrlPts.p[1] = vec2(0.2,0.1);\n    ctrlPts.p[2] = vec2(0.6,0.35);\n    ctrlPts.p[3] = vec2(0.4,0.1);\n    ctrlPts.p[4] = vec2(0.8,0.35);\n    ctrlPts.p[5] = vec2(0.6,0.55);\n    ctrlPts.p[6] = vec2(0.5,0.45);\n    ctrlPts.p[7] = vec2(0.3,0.49);\n    \n    if(iMouse.z > 0.1)\n        ctrlPts.p[2] = getUV(iMouse.xy);\n    vec2 uv = getUV(fragCoord.xy);\n    \n    float fTime = iTime*0.15;\n    vec2 pA = catmullRom(fract(fTime), ctrlPts);\n    vec2 pB = catmullRom(fract(fTime+0.02), ctrlPts);\n    \n    //Compute Distance field\n    vec2 dSeg = debugDistanceField(uv, ctrlPts);\n    \n    //Draw distance field background\n    vec3 c = vec3(dSeg.x*7.0+smoothstep(0.20,0.3,abs(fract(dSeg.x*20.0)-0.5)));\n    \n    //Draw the spline\n    c = mix(vec3(0,0.8,0.9),c,smoothstep(-0.005,0.0035,dSeg.y));\n    c = mix(vec3(1,0  ,0.0),c,smoothstep(0.0,0.0025,dSeg.x));\n    \n    //Draw each control point\n    float minDistP = 10000.0;\n    for(int i=0; i < POINT_COUNT; ++i)\n    {\n        vec2 ctrl_pt = PointArray(i,ctrlPts);\n        minDistP = min(length(uv-ctrl_pt),minDistP);\n    }\n    c = mix(vec3(0,0,1),c,smoothstep(0.008,0.011,minDistP));\n    \n    //Draw moving points\n    c = mix(vec3(0,0.7,0),c,smoothstep(0.008,0.011,length(uv-pA)));\n    c = mix(vec3(0,0.7,0),c,smoothstep(0.008,0.011,length(uv-pB)));\n    c = mix(vec3(1,1,1),c,smoothstep(0.004,0.006,length(uv-pB)));\n\t\n    fragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3SRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscSz8", "name": "Procedural menger", "author": "sagar_unityDev", "description": "Implementing raymarch technique.", "tags": ["procedural", "geometry"], "likes": 3, "viewed": 186, "date": "1457579686", "time_retrieved": "2024-06-20T18:33:42.676840", "image_code": "// as learned from the excellent tutorial by @uint9\n// http://9bitscience.blogspot.de/2013/07/raymarching-distance-fields_14.html\n// distance functions by iq\n\nconst int RM_STEPS = 64;\nconst float RM_TOLERANCE = 0.001;\nconst float FOCAL_LENGTH = 1.2;\nconst float NEAR = 0.01;\nconst float FAR = 50.0;\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y + 1.6;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(100.,0.1,0.1));\n  float db = sdBox(p.yzx,vec3(0.1,100.,0.1));\n  float dc = sdBox(p.zxy,vec3(0.1,0.1,100.));\n  return min(da,min(db,dc));\n}\n \n\nfloat sdf(vec3 p) {\n  float plane = sdPlane(p);\n  float d = sdBox(p, vec3(1.0));\n  //float d = sdBox(p, vec3(2.0));\n    \n   float s = 1.0;\n   for( int m=0; m<3; m++ )\n   {\n      \n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = min(r.x,r.y);\n      float db = min(r.y,r.z);\n      float dc = min(r.z,r.x);\n      float c = (max(da,max(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n  \t\n  \n  return min(d, plane);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tsdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n\t\tsdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n\t\tsdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))));\n}\n\nfloat getShadow(vec3 p0, vec3 p1, float k) {\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0 * RM_TOLERANCE;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0;\n\tfor(int i = 0; i < RM_STEPS; ++i)\n\t{\n\t\tfloat d = sdf(p0 + rd * t);\n\t\tif(d < RM_TOLERANCE)\n\t\t\treturn 0.0;\n\t\tf = min(f, k * d / t);\n\t\tt += d;\n\t\tif(t >= maxt)\n\t\t\tbreak;\n\t}\n\treturn f;\n}\n\nvoid raymarch(vec3 ro, vec3 rd, out int steps, out float t) {\n\tt = 0.0;\n    for(int j = 0; j < RM_STEPS; ++j) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if(d < RM_TOLERANCE) {\n         \tsteps = j;   \n            break;\n        }\n        t += d;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eye = vec3(0, 0.5, -5.0);\n    vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y = uv.y * iResolution.y/iResolution.x;\n    \n    vec3 ro = eye;\n    vec3 rd = normalize(cross(right, up) * FOCAL_LENGTH + right * uv.x + up * uv.y);\n\n    vec4 lightColor1 = vec4(0.8, 1.0, 1.0, 1.0);\n    vec3 lightPosition1 = vec3(\n        sin(iTime) * 2.0,\n        2.0,\n        cos(iTime) * 2.0\n    );\n    vec4 lightColor2 = vec4(1.0, 1.0, 0.8, 1.0);\n    vec3 lightPosition2 = vec3(\n        cos(iTime) * 2.0,\n        2.0,\n        sin(iTime) * 2.0\n    );\n    \n    vec4 ambientColor = vec4(vec3(0.4),1.0);\n    vec4 color = vec4(0.9); // Sky color\n    \n    // rotate camera\n\tmat3 rot = rotationXY( vec2( 0.0, mod(iTime, 6.3)) );\n\trd = rot * rd;\n\tro = rot * ro;  \n\n    float t = 0.0;\n    int i = 0;\n    raymarch(ro, rd, i , t);\n    \n    vec3 p;\n    if(t > NEAR && t < FAR) {\n    \tp = ro + rd * t;\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        \n    \tfloat lightIntensity1 = 0.0;\n        float lightIntensity2 = 0.0;\n    \tfloat shadow1 = getShadow(p, lightPosition1, 8.0);\n        float shadow2 = getShadow(p, lightPosition2, 8.0);\n        \n        if(shadow1 > 0.0) {\n            lightIntensity1 = clamp(\n                dot(getNormal(p), lightDirection1), 0.0, 1.0\n            ) * shadow1;\n        }\n        if(shadow2 > 0.0) {\n            lightIntensity2 = clamp(\n                dot(getNormal(p), lightDirection2), 0.0, 1.0\n            ) * shadow2;\n        }\n        \n        color = smoothstep(\n            vec4(0.0),\n            vec4(1.8),\n            lightColor1 * lightIntensity1 +\n           \tlightColor2 * lightIntensity2 +\n           \tambientColor * (1.0 - lightIntensity1 * lightIntensity2));\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscSzn", "name": "Analytic Derivative Viewer3D", "author": "Bers", "description": "Useful for debugging your analytic derivative. When noise is layered, scaled, and rotated, it become very difficult to make sure your resulting final analytic derivative is computed properly. Therefore this shader, to visualize it.", "tags": ["noise", "antialiasing", "derivative", "analytic"], "likes": 19, "viewed": 959, "date": "1457307637", "time_retrieved": "2024-06-20T18:33:44.137603", "image_code": "// Author : Sbastien Brub\n// Created : May 2015\n// Modified : Feb 2016\n//\n// This shader was written with the intent of easing the pain of finding and validating \n// analytic derivatives. I had decided to do this after having read an interesting article, from Inigo Quilez :\n// http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// Although deriving a function in a theorical context is not so difficult, it can still \n// quickly become an overwhelming task if you stack up multiple layers of rotated, scaled, and distorted noise.\n// How do you rotate the derivatives, do you simply rotate the gradient in the same direction as the noise function?\n// What do you do with time multiplier, is it always derived as a constant factor?\n// Do you also have to derive the bilinear / trilinear equation, or just the ease function?\n// \n// One way to check you did not do any error is to visualize the final result.\n//\n// License : Creative Commons Non-commercial (NC) license\n\n// Of course, you could also skip all that and get Matlab or Maple...\n\n//----------------------\n// Constants\nconst float LINE_WIDTH = 0.18; //From 0.0 to 1.0\nconst float AXIS_WIDTH = 0.035;\nconst float AXIS_LEN   = 0.5;\nconst float CELL_SIZE  = 2.25;\nconst int MAT_GROUND = 0;\nconst int MAT_AXIS   = 1;\nconst int MAT_SKY    = 2; \n\n//----------------------\n// Globals\nmat2 m2,m2t;\nfloat DOMAIN_SCALING   = 12.0;\n\nvec4 trilinearNoiseDerivative(vec3 p)\n{\n    p /= DOMAIN_SCALING;\n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    \n    vec2 c1 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).xy;\n    vec2 c2 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).xy; //+x\n    vec2 c3 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).xy; //+z\n    vec2 c4 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).xy; //+x+z\n    \n    vec3 x = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    vec3 t = (3.0 - 2.0 * x) * x * x;\n    \n    //Lower quad corners\n    float a = c1.x; //(x+0,y+0,z+0)\n    float b = c2.x; //(x+1,y+0,z+0)\n    float c = c3.x; //(x+0,y+1,z+0)\n    float d = c4.x; //(x+1,y+1,z+0)\n    \n    //Upper quad corners\n    float e = c1.y; //(x+0,y+0,z+1)\n    float f = c2.y; //(x+1,y+0,z+1)\n    float g = c3.y; //(x+0,y+1,z+1)\n    float h = c4.y; //(x+1,y+1,z+1)\n    \n    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    //Derivative scaling\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    //Ease-in ease-out derivative : (3x^2-2x^3)' = 6x-6x^2\n    vec3 dxyz = 6.*x*(1.-x);\n    \n    return vec4(value*DOMAIN_SCALING,\n\t            vec3(dxyz.x*sx,\n                     dxyz.y*sy,\n                     dxyz.z*sz));\n}\n\nstruct FuncValue\n{\n\tfloat height;\n    float dh_dx;\n    float dh_dz;\n};\n    \n//----------------------\n// Surface Definition\nFuncValue evalSurface(vec2 p_xz, float fTime)\n{\n    FuncValue val;\n    vec4 h_dx_dy_dz = trilinearNoiseDerivative(vec3(p_xz.x,DOMAIN_SCALING*iTime*0.2,p_xz.y));\n    val.height = h_dx_dy_dz[0];\n    val.dh_dx  = h_dx_dy_dz[1];\n    //val.dh_dy  = h_dx_dy_dz[2];\n    val.dh_dz  = h_dx_dy_dz[3];\n    return val;\n}\n\nstruct SurfaceAxis\n{\n    vec3 normal;\n    vec3 tangent;\n    vec3 binormal;\n    vec3 pos;\n};\n\nSurfaceAxis computeSurfaceVectors(vec2 p)\n{\n    vec2 rp = m2*p; //rotated point\n    FuncValue val = evalSurface(rp, iTime);\n\tvec2 dx = m2t*vec2(1,0); //rotated x+ vector\n\tvec2 dz = m2t*vec2(0,1); //rotated z+ vector\n    SurfaceAxis surfAxis;\n\tsurfAxis.tangent  = normalize(vec3(dx[0],val.dh_dx,dx[1]));\n\tsurfAxis.binormal = normalize(vec3(dz[0],val.dh_dz,dz[1]));\n    surfAxis.normal   = cross(surfAxis.binormal, surfAxis.tangent);\n\tsurfAxis.pos      = vec3(p, val.height).xzy;\n    return surfAxis;\n}\n\nvec3 textureGrid(vec2 uv, float eps)\n{\n    uv = m2*uv;\n    float Ix = smoothstep(0.5*(LINE_WIDTH-eps),0.5*(LINE_WIDTH+eps),abs(fract(uv.x)-0.5));\n    float Iy = smoothstep(0.5*(LINE_WIDTH-eps),0.5*(LINE_WIDTH+eps),abs(fract(uv.y)-0.5));\n    return vec3(Ix*Iy);\n}\n\nstruct Cell\n{\n    vec2 localSample;\n    vec2 center;\n};\n    \nCell repeat(vec2 p, vec2 cellSize)\n{\n    Cell cell;\n    cell.localSample = (fract(p/cellSize+0.5)-0.5)*cellSize;\n    cell.center = p-cell.localSample;\n    return cell;\n}\n\nfloat distanceToLineSeg3D(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    vec3 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nstruct HitInfo\n{\n    float d;\n    int matID;\n};\n    \nHitInfo map(vec3 p)\n{\n    SurfaceAxis surfInfo = computeSurfaceVectors(p.xz);\n\tfloat dSurf = dot((p-surfInfo.pos),surfInfo.normal);\n    \n    Cell probeCell = repeat(p.xz, vec2(CELL_SIZE));\n    p.xz = probeCell.localSample;\n    SurfaceAxis surfAxis = computeSurfaceVectors(probeCell.center);\n    vec3 pAxis = vec3(0,surfAxis.pos.y,0);\n        \n    float d1 = distanceToLineSeg3D(p,pAxis+surfAxis.normal *AXIS_LEN,pAxis-surfAxis.normal *AXIS_LEN)-AXIS_WIDTH;\n    float d2 = distanceToLineSeg3D(p,pAxis+surfAxis.tangent*AXIS_LEN,pAxis-surfAxis.tangent*AXIS_LEN)-AXIS_WIDTH;\n    float d3 = distanceToLineSeg3D(p,pAxis+surfAxis.binormal*AXIS_LEN,pAxis-surfAxis.binormal*AXIS_LEN)-AXIS_WIDTH;\n    float dAxis = min(min(d1,d2),d3); \n    \n    HitInfo info;\n    info.d = min(dSurf,dAxis);\n    info.matID = (dSurf<dAxis)?MAT_GROUND:MAT_AXIS;    \n    return info;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat softProjLight( vec3 o, vec3 L, vec3 N)\n{\n    float coneWidth   = 0.1;\n    float minAperture = 1.0; \n    float t = 0.001;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 p = o+L*t;\n        float dist = map( p ).d;\n        float curAperture = dist/t;\n        minAperture = min(minAperture,curAperture);\n        t += 0.05+dist;\n    }\n    return saturate(minAperture/coneWidth)*dot(L,N);\n}\n\nfloat itCount = 0.0;\nHitInfo rayMarch(vec3 o, vec3 d)\n{\n    const float tMax = 75.0;\n    float t = 0.0;\n    for(int i=0; i < 40; ++i)\n    {\n        itCount += 1.0;\n        float d = map(o+t*d).d;\n        t += d>0.?d:0.75*d;\n        if(abs(d)<0.001 || t > tMax)\n            break;\n    }\n    \n    HitInfo info = map(o+t*d);\n    info.matID = (t>tMax)?MAT_SKY:info.matID;\n    info.d = min(t,tMax);\n    return info;\n}\n\nvec3 apply_atmosphere(float travelDist, vec3 color, vec3 p)\n{\n    //From this nice article on fog:\n    //http://iquilezles.org/www/articles/fog/fog.htm\n    //or this PowerPoint from Crytek:\n\t//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17\n\tvec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));\n    float c = 15.68;\n    float b = 0.001;\n\n    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;\n    cumul_density = clamp(cumul_density,0.0,1.0);\n    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);\n    return FinalColor;\n}\n\n#define m2Transpose(m) mat2(m[0][0],m[1][0],m[0][1],m[1][1])\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n    float t = 12.+iTime*0.35;\n    DOMAIN_SCALING *= (1.0+0.8*sin(t));\n    \n    m2  = mat2(cos(t),-sin(t),sin(t),cos(t));\n\tm2t = m2Transpose(m2);\n    \n    vec3 camR = vec3(1,0,0);\n    vec3 camU = vec3(0,1,0);\n    vec3 camD = vec3(0,0,-1);\n    vec3 dir  = normalize(uv.x*camR+uv.y*camU+camD);\n\tvec3 vpos = vec3(0,evalSurface(vec2(0), t).height,0)+4.5;\n    \n    HitInfo hit = rayMarch(vpos, dir);\n    \n    vec3 p = vpos+hit.d*dir;\n    vec3 c = vec3(0);\n    if     (hit.matID == MAT_SKY    ) c = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));\n    else if(hit.matID == MAT_GROUND ) c = textureGrid(16.0*p.xz/DOMAIN_SCALING,0.1+0.0025*hit.d).xyz;\n    else if(hit.matID == MAT_AXIS )   c = vec3(1,0,0);\n    \n    if(hit.matID != MAT_SKY)\n    {\n        vec3  L = vec3(-0.31, 0.924, -0.23);\n        float I = softProjLight(p, L, computeSurfaceVectors(p.xz).normal);\n        c *= (0.25+0.75*I);\n        c = apply_atmosphere(hit.d,c,p);\n    }\n    \n    fragColor = vec4(c,1);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscXD8", "name": "afunctional iteration", "author": "Linusmartensson", "description": "Working to get something interesting going based on the flame fractal algorithm. Exceedingly slow, but quite pleasant stills.", "tags": ["2d", "fractal", "particles"], "likes": 41, "viewed": 1034, "date": "1459009624", "time_retrieved": "2024-06-20T18:33:44.137603", "image_code": "float s0;\n\nfloat rand(float f){\n  return mod(f*32151.0+13425.20,4096.0)/4096.0;   \n}\nfloat rand0(){\n  s0 = rand(s0);\n  return mod(s0*54921.0+53425.20,4096.0)/4096.0;   \n    \n}\n\nvec2 rand20(){\n    return vec2(rand0(),rand0());\n}\n\n\nfloat df(in vec2 uv, in vec2 pt, in float m){\n  return m/(0.01+0.5*(dot(uv-pt, uv-pt)));   \n}\n\nvoid f(in vec2 uv, inout vec2 pt, inout vec3 color, inout float density, in vec2 spt){\n    float m, dens;\n    vec2 jpt;\n\n    vec2 qpt = vec2(0.0);\n\n    float q;\n    vec2 c, s;\n\n    vec2 ipt = pt;\n    \n    q = (rand0()*2.0-1.0)*0.1*iTime;\n    c = vec2(1.0)*cos(q);\n    s = vec2(1.0,-1.0)*sin(q);\n    pt = vec2(pt.x*c.x+pt.y*s.y,pt.x*s.x+pt.y*c.y);\n    dens = df(uv,pt,1.0);\n    density += dens;\n    color += dens * vec3(-0.03,0.02,0.07);\n\n    \n\tm = rand0()*0.25;\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    q = iTime*0.01*(rand0()*2.0-1.0);\n    c = vec2(1.0)*cos(q);\n    s = vec2(1.0,-1.0)*sin(q);\n    qpt = m*vec2(jpt.x*c.x+jpt.y*s.y,jpt.x*s.x+jpt.y*c.y);\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(4.67,0.67,0.0) / distance(jpt,qpt);\n  \n\tm = rand0();\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*(sin(jpt.xy+iTime*rand0()*2.0-1.0));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(1.0,0.5,0.0);\n\n    m = rand0();\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*(((uv-jpt))*(rand0()*2.0-1.0));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(4.0,2.1,1.0);\n\n    m = rand0()*0.5;\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*((jpt));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(2.0,2.1,9.0);\n\n    \n    \n    m = rand0()*0.5;\n    jpt = ipt*rand20()+rand20()*2.0-1.0;\n    qpt = m*(jpt*sin(jpt*0.1+sin(iTime*0.12+jpt.xy*0.5*(rand20()-0.5))));\n    pt += qpt;\n    dens = df(uv,qpt,m)*df(jpt,qpt,m);\n    density += dens;\n    color += dens * vec3(3.0,1.30,0.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s0 = 320.0;\n    float r = 80.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy * r - 0.5*r;\n    fragColor = vec4(1.0);\n    \n    for(int i=0;i<3;++i){\n        \t\n        float density = 0.0;\n        vec3 color = vec3(0.0);\n        vec2 pt = rand20() * r - 0.5*r;\n \t\tvec2 spt = pt;      \n        for(int j=0;j<24;++j){\n            float dens=0.0;\n            vec3 col = vec3(0.0);\n            \n            f(uv, pt, col, dens, spt);\n            \n            if(j>5){\n                density += dens;\n                color += col;\n            }\n        }\n        \n        fragColor += vec4(vec3(color)/(0.1+density), 1.0);//*(iTime/(10.+float(i)+iTime));\n\n    }\n    fragColor.xyz = smoothstep(0.5,3.0,fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscXDn", "name": "Triangular Grid", "author": "seb0fh", "description": "regular triangular grid. vertices and lines settings are controllable separately.", "tags": ["2d", "triangle", "hexagon", "tiling", "hex"], "likes": 18, "viewed": 1492, "date": "1458677215", "time_retrieved": "2024-06-20T18:33:44.137603", "image_code": "/*\n\tTriangular Grid\n\t03/2016\n\tseb chevrel\n*/\n\n#define PI 3.1415926535897\n\n// triangle rotation matrices\nconst vec2 v60 = vec2( cos(PI/3.0), sin(PI/3.0));\nconst vec2 vm60 = vec2(cos(-PI/3.0), sin(-PI/3.0));\nconst mat2 rot60 = mat2(v60.x,-v60.y,v60.y,v60.x);\nconst mat2 rotm60 = mat2(vm60.x,-vm60.y,vm60.y,vm60.x);    \n\nfloat triangleGrid(vec2 p, float stepSize,float vertexSize,float lineSize) \n{\n    // equilateral triangle grid\n    vec2 fullStep= vec2( stepSize , stepSize*v60.y);\n    vec2 halfStep=fullStep/2.0;\n    vec2 grid = floor(p/fullStep);\n    vec2 offset = vec2( (mod(grid.y,2.0)==1.0) ? halfStep.x : 0. , 0.);\n   \t// tiling\n    vec2 uv = mod(p+offset,fullStep)-halfStep;\n    float d2=dot(uv,uv);\n    return vertexSize/d2 + // vertices \n    \tmax( abs(lineSize/(uv*rotm60).y), // lines -60deg\n        \t max ( abs(lineSize/(uv*rot60).y), // lines 60deg\n        \t  \t   abs(lineSize/(uv.y)) )); // h lines\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.1;\n    \n    // screen space\n\tvec2 uv = fragCoord.xy / iResolution.xx -vec2(0.5,0.5*iResolution.y/iResolution.x);  \n    \n    //uv=vec2(uv.y,-uv.x);\n    vec2 uv2 = (uv+vec2(time,time*0.3));\n    \n    vec3 color = triangleGrid(uv2,0.1,0.00005,0.001)*vec3(0,1,0);\n    \n    // output\n\tfragColor = vec4(  color ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdSDH", "name": "Sun Planet", "author": "rodolphito", "description": "Check out the raymarching part of the code, it's a new idea I had, i haven't seen it used before on this site.\nMouse X rotates, mouse Y zooms.", "tags": ["3d", "raymarching"], "likes": 6, "viewed": 275, "date": "1459222636", "time_retrieved": "2024-06-20T18:33:44.137603", "image_code": "#define STEPS 12\n#define MIN 0.005\n#define MOONS\nvec3 ry(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(ca,0.0,-sa,0.0,1.0,0.0,sa,0.0,ca);\n}\n\nvec3 rx(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(1.0,0.0,0.0,0.0,ca,-sa,0.0,sa,ca);\n}\n//return the vector to the closest point on the nearest surface.\nvec3 c(vec3 v)\n{\n    vec3 p0 = v-normalize(v);\n    #ifdef MOONS\n    vec3 moon1 = v+1.6*vec3(sin(iTime),0.0,cos(iTime));\n    vec3 p1 = moon1-normalize(moon1)*0.1;\n    vec3 moon2 = moon1+0.3*vec3(sin(iTime*5.0),0.0,-cos(iTime*5.0));\n    vec3 p2 = moon2-normalize(moon2)*0.02;\n    if (dot(p0,p0)>dot(p2,p2))p0=p2; //Moon\n    if (dot(p0,p0)>dot(p1,p1))p0=p1; //Moon\n    #endif\n    return p0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 light = normalize(vec3(-1.0,0.0,0.0));\n    vec3 suncol = vec3(4.6,1.2,0.2);\n    vec3 planetcol = vec3(0.1,0.4,0.8);\n    vec3 atmoscol = vec3(0.2,0.7,1.0);\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3 p = vec3(.0,0.0,-40.0*(mouse.y+0.6));\n\t//p = rx(p,mouse.y*8.0);\n\tp = ry(p,mouse.x*8.0-iTime*0.1);\n\tvec3 d = vec3(uv,1.0);\n\t//d = rx(d,mouse.y*8.0);\n\td = ry(d,mouse.x*8.0-iTime*0.1);\n\td = normalize(d);\n    vec3 n = vec3(0.0);\n    float color = 0.0;\n    for (int i = 0; i < STEPS; i++)\n    {\n        n = c(p);\n    \tfloat a = length(n)-MIN;\n        if (a <= 0.0) break;\n        p += d * max(a,0.0);\n    }\n    float t = length(n);\n    n = n / t;\n    float planet = min(t,1.0);\n    float atmos = (1.0-abs(dot(d,n)))*max(dot(n,light)+0.3,0.0);\n    float diffuse = (max(dot(n,light),0.0) + 0.15)*(1.0-planet);\n    float sun = planet*max(dot(d,light)-0.5,0.0)*2.0;\n    fragColor = vec4(atmos*(atmoscol+suncol*max(dot(d,light)-0.5,0.2))+diffuse*planetcol+sun*suncol, 1.0);\n    //fragColor = vec4((mix(planetcol,lightcol,planet)*mix(diffuse,sun,planet))+atmos*atmoscol, 1.0);\n    //fragColor = vec4((mix(planetcol,lightcol,sqrt(1.0-planet))) * color, 1.0);\n    //fragColor = vec4(planet);\n    //fragColor = vec4(color);\n    //fragColor = vec4(diffuse*planet);\n    //fragColor = vec4(atmos);\n    //fragColor = vec4(atmos*(atmoscol+suncol*dot(d,light)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdSDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXD8", "name": "Velocibox", "author": "zackpudil", "description": "Visuals inspired by Velocibox (http://store.steampowered.com/app/317710/).\nTunnel distance field inspired by Shane's (https://www.shadertoy.com/view/MlXSWX).\nUpdate: VR added, I cannot be held responsible for any puking that occurs :P", "tags": ["raymarching", "distancefields", "vr"], "likes": 29, "viewed": 1334, "date": "1459268313", "time_retrieved": "2024-06-20T18:33:44.143669", "image_code": "float hash(float n) {\n    return fract(sin(n)*4578.543123);\n}\n\nvec2 path(float z) {\n    vec2 a = vec2(0);\n    vec2 b = vec2(2.0*cos(z*.3), 0);\n    \n    if(iTime >= 0.0 && iTime <= 4.0){\n        if(iTime <= 3.0) return a;\n        return mix(a, b, mod(iTime, 1.0));\n    } else return b;\n}\n\nfloat gTime() {\n    float s;\n    if(iTime <= 3.0) {\n        s = 7.0;\n    } else s = 15.;\n    \n    return s*iTime;\n}\n\nfloat len(vec3 p, float l) {\n    p = pow(abs(p), vec3(l));\n    return pow(p.x + p.y + p.z, 1.0/l);\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return len(pa - ba*h, 8.0) - r;\n}\n\nfloat dObstacles(vec3 p, float diff) {\n    p.xy -= path(p.z);\n    float c = floor((p.z + diff)/(diff*2.0));\n    float rnd = hash(c);\n    p.z = mod(p.z + diff, diff*2.0) - diff;\n    \n    p.xy = p.yx;\n    float o;\n    if(iTime >= 0.0 && iTime <= 4.0) {\n        if(iTime <= 3.0) o = 4.0;\n        else o = mix(4.0, 0.0, mod(iTime, 1.0));\n    } else o = 0.0;\n    \n    p.y += path(p.z).x - o - (rnd < .5 ? 0. : 2.0);\n    return dSegment(p, vec3(5.5, 1., 0), vec3(-5.5, 1.0, 0), 0.25);   \n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec3 boxPos(vec3 p, float diff, float o) {\n    vec3 bp = vec3(0., -1.0, gTime());\n    float c = floor((p.z + diff)/diff*2.0);    \n    float rnd = hash(c);\n    \n    bp.y = 1.8*cos(sin(iTime + o)*3. + iTime + o);\n        \n    return bp;\n}\n\nvec2 map(vec3 p) {\n    // the tunnel distance estimate was taken from Shane's (https://www.shadertoy.com/view/MlXSWX)\n    vec2 tun = abs(p.xy - path(p.z))*vec2(.4, .4);\n    vec2 t = vec2(1. - max(tun.x, tun.y), 0.0);\n    \n    vec3 bp = boxPos(p, 2.5, 0.0);\n    vec3 bp2 = boxPos(p, 2.5, 0.1);\n    bp2.z += 0.5;\n    \n    bp.xy += path(bp.z);\n    bp2.xy += path(bp2.z);\n    \n    vec2 s = vec2(min(len(p - bp2, 1.0) - .3, dSegment(p, bp, bp2, .04)), 1.0);\n    \n    vec2 o = vec2(dObstacles(p, 2.5), 2.0);\n    \n    return opU(t, opU(s, o));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float td = 0.;\n    float mid = -1.;\n    float tmax = 50.;\n    \n    for(int i = 0; i < 256; i++) {\n        vec2 s = map(ro + rd*td);\n        td += s.x;\n        mid = s.y;\n        if(abs(s.x) < 0.005 || td >= tmax) break;\n    }\n    \n    if(td >= tmax) mid = -1.;\n    return vec2(td, mid);\n    \n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n\t);\n    \n    return normalize(n);\n}\n\n// iq's ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n    float r = 0.0;\n    float w = 1.0;\n    float d;\n    \n    for(float i = 1.0; i < 6.6; i++) {\n        d = i/6.0;\n        r += w*(d - map(p + n*d).x);\n        w *= .5;\n    }\n    \n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd) {\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal(p);\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten*ao(p, n);\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 rl = vec3(sin(iTime), cos(iTime), 0);\n    vec3 f = normalize(l - e);\n    vec3 r = cross(rl, f);\n    vec3 u = cross(f, r);\n    \n    return mat3(r, u, f);\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n    ro.z += gTime() - 2.0;\n    vec3 la = ro + vec3(0, 0.0, 2.0);\n    \n    rd = camera(ro, la)*rd;\n    \n    vec3 lp1 = ro + vec3(0, 0, 1);\n    vec3 lp2 = ro + vec3(0, 0, 5);\n    \n    la.xy += path(la.z);\n    ro.xy += path(ro.z);\n    \n    vec3 col = vec3(.5);\n    \n    vec2 i = intersect(ro, rd);\n    vec3 p = ro + rd*i.x;\n    \n\tif (i.y == 0.0) { \n        vec2 guv = normal(p).y == 0.0 ? p.zy : p.xz - path(p.z);\n        col = .45 + vec3(1)\n            *smoothstep(-.05, .05,abs(fract(guv.x) - .5)*2.)\n            *smoothstep(-.05, .05, abs(fract(guv.y) - .5)*2.);\n    }\n    if (i.y == 1.0) col = vec3(1, .1, 1)*.5;\n    if (i.y == 2.0) col = vec3(0, .3, 1);\n    \n    if(i.y != -1.0) col *= lighting(p, lp1, rd)+lighting(p, lp2, rd);\n    \n    col = pow(col, vec3(.454545));\n    \n\treturn vec4(col, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy / iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0, 0.0, -2);\n    vec3 rd = normalize(vec3(uv, 2.0));\n    \n    \n\tfragColor = render(ro, rd);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render(fragRayOri, fragRayDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXDn", "name": "Megashader", "author": "KhanMaytok", "description": "Taken from https://www.shadertoy.com/view/4dXGR4 to export to shaderfrog", "tags": ["waka"], "likes": 8, "viewed": 934, "date": "1458835961", "time_retrieved": "2024-06-20T18:33:44.658682", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// My apologies for the ugly code.\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdXWr", "name": "Space Jam", "author": "qleonetti", "description": "Was playing with Grapher app and wanted to turn some math into a shader", "tags": ["2d", "math", "1bit"], "likes": 3, "viewed": 581, "date": "1458854313", "time_retrieved": "2024-06-20T18:33:44.658682", "image_code": "#define RATIO_DEFORMATION 0.5\n#define SCREEN_TRANSLATE 0.5\n#define SCALE 100000000.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - SCREEN_TRANSLATE;\n    uv.y *= RATIO_DEFORMATION;\n    float c = ceil(\n        cos(uv.x*uv.y * SCALE )-\n   \t\tcos(uv.x/uv.y + iTime)\n    );\n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsGGDd", "name": "Load Custom Textures", "author": "AntoineC", "description": "A simple method to load custom image textures in Shadertoy. Read the instructions in the code. Let me know in the comments if it works on your system and browser...", "tags": ["texture", "earth", "hack"], "likes": 83, "viewed": 8918, "date": "1457224940", "time_retrieved": "2024-06-20T18:33:45.470914", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Load Custom Textures\" by Antoine Clappier - March 2015\n//\n//\tLicensed under a Creative Commons Attribution-ShareAlike 4.0 International License\n//\thttp://creativecommons.org/licenses/by-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n// Image credits:\n//  Nasa, http://visibleearth.nasa.gov/\n\n\n/*\n\nA simple method to load custom image textures in Shadertoy!\n-----------------------------------------------------------\n\nThe idea is to call directly the SetTexture function found in Shadertoy js code.\n\nHere is how to loads the three textures needed for this shader:\n - Open the javascript console of your browser:\n\t\t\t\t   Mac      /     Windows\n\tChrome:  cmd + opt + J  /  ctrl + shift J\n\tFirefox: cmd + opt + K  /  ctrl + shift K\n    IE:          na         /  F12   \n\n- Then copy the following lines in the console to load custom 2048x2048 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/88u2uo8dxdmgzxo/world2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/5rdhhnvnr5mochq/cloud2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/ojl5zoxgbdn5w5s/light2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- Or, the following lines for 1024x1024 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/0j4q7p4x0upj40q/world1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/26xr0l2ly68xgzh/cloud1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/b67udjdsw4gzf99/light1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- hit return to execute and load the textures.\n\n\nUsing your own images:\n - The first argument of gShaderToy.SetTexture() is the iChannel index from 0 to 3\n - The second argument defines the url and additional parameters of the texture.\n - Your images must be hosted on a server (such as Dropbox) that allows direct link \n   from a different domain in javascript. Otherwise, you will get an error message:\n   \"'example.com has been blocked from loading by Cross-Origin Resource Sharing policy\"\n\n*/\n\n\n\n\n#define Pi 3.14159265359\n#define d2r(a) ((a)*180.0/Pi)\n#define RGB(r,g,b) pow(vec3(float(r), float(g), float(b))/255.0, vec3(2.22))\n\n#define R0 1.0000\t// Nomralized Earth radius (6360 km)\n#define R1 1.0094\t// Atmosphere radius (6420 km) \n\nvec3 Render(in vec2 uv)\n{\n    vec3 Color = vec3(0.0);\n    float t = 1.0*iTime;\n\n    // Sun:\n    vec3 L0 = vec3(cos(0.1*t), 0.0, sin(0.1*t));\n    float cs = cos(d2r(90.0 + 23.4)), sn = sin(d2r(90.0 + 23.4));\n    vec3 LightDir = vec3(cs*L0.x + sn*L0.y, cs*L0.y - sn*L0.x, L0.z);\n\n    vec2 SunC = -5.0*LightDir.xy/LightDir.z - uv;\n    float Halo = max(0.0, dot(LightDir, normalize(vec3(uv.x, uv.y, -5.0))));\n\tfloat SunRay = pow(texture(iChannel1, vec2(0.1*t, atan(SunC.x,SunC.y))).xyz, vec3(2.22)).x;\n    float Sun = 0.05*(1.0 + SunRay)*pow(Halo, 1000.0)*smoothstep(0.85, 1.3, length(SunC+uv));\n   \n    // Sphere hit:\n    float z = 1.0 - dot(uv, uv);\n    if(z < 0.0)\n    {\n        Sun += 1.5*pow(Halo, 10000.0);\n        return Sun*RGB(255,250,230);\n    }\n    \n    // Intersection:\n    vec3 Normal     = vec3(uv.x, uv.y, sqrt(z));\n    vec3 Reflection = reflect(vec3(0.0, 0.0, 1.0), Normal);\n\n\n    // Textures:\n\tfloat U = 1.0-atan(Normal.z, Normal.x) / (2.0*Pi);\n\tfloat V = 1.0-(atan(length(Normal.xz), Normal.y)) / Pi;\n \tvec3 Ground = pow(texture(iChannel0, vec2(U-t/80.0, V)).xyz, vec3(2.22));\n\tvec3 Cloud  = pow(texture(iChannel1, vec2(U-t/75.0, V)).xyz, vec3(2.22));\n\tvec3 Cloud2 = pow(texture(iChannel1, vec2(U-t/75.0+0.001, V)).xyz, vec3(2.22));\n\tvec3 KsMap  = pow(texture(iChannel1, vec2( -t/200.0, 0.8)).xyz, vec3(2.22));\n\tvec3 Night  = pow(texture(iChannel2, vec2(U-t/80.0, V)).xyz, vec3(2.22));\n\t\n    // Shading\n\tfloat Diffuse     = max(0.0, dot(Normal, LightDir));\n\tfloat Specular    = max(0.0, dot(-Reflection, LightDir));\n    float Scatter     = 4.0*pow((sqrt(R1 - dot(uv, uv)) - Normal.z) / sqrt(R1-R0), 1.35);\n    float Extinct     = pow(1.0 - Diffuse, 4.0);\n    float Sea         = smoothstep(1.0, 0.0, 100.0*length(Ground - RGB(2,5,20)));\n    float Shadow      = 1.0 - pow(Cloud2.x, 0.2);\n    \n    vec3 Light = mix(vec3(1.0), RGB(255, 150, 40), Extinct);\n \n    Color = Shadow*(Ground + 0.8*Sea*RGB(19,35,60));\n    Color = mix(Color, vec3(1.0), 2.0*Cloud);\n    Color *= Light*Diffuse;\n    Color += 2.0*Light*Diffuse*(0.3 + 0.7*KsMap.x)*mix(0.03, 0.4, Sea)*pow(Specular, (0.8 + 0.2*KsMap.x)*mix(9.0, 200.0, Sea));\n    Color += pow(max(0.0, dot(Normal, -LightDir)), 2.0)*Night*(1.0-pow(Cloud.x, 0.2));\n    Color *= mix(vec3(1.0), RGB(255-58,255-72,255-90), 1.0*Scatter);\n    Color += 4.0*Diffuse*(1.0 + Sea)*Scatter*RGB(58,72,90);\n\n    Color += Sun*RGB(255,250,230);\n    \n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 In )\n{\n\tvec2 uv = (2.0*In.xy - iResolution.xy) / iResolution.y;\n    vec3 Color = pow(Render(1.05*uv),  vec3(0.45));\n\tfragColor = vec4(Color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsGGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsKGW3", "name": "SnowMountain", "author": "Unix", "description": "Effect used in my demo Eden... <br/>Eden : http://www.pouet.net/prod.php?which=66121", "tags": ["snow", "mountain", "eden", "hoodlum", "unix"], "likes": 21, "viewed": 481, "date": "1456823363", "time_retrieved": "2024-06-20T18:33:46.634643", "image_code": "// Created by David Lovera - Unix/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// mainly based on Kali great work...\n\n#define RAY_STEPS 100\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(1.,.97,.93)\n#define AMBIENT_COLOR vec3(.2,.5,1.0)\n\n#define SPECULAR 0.65\n#define DIFFUSE  2.0\n#define AMBIENT  0.55\n\n#define BRIGHTNESS 2.5\n#define GAMMA 1.45\n#define SATURATION .8\n\n#define detail .00004\n#define t 2.0+iTime*.2\n\nvec3  lightdir=normalize(vec3(1.1,-0.55,-1.));\nconst vec3 origin=vec3(-1.,0.2,0.);\nfloat det=0.0;\nvec3 pth1;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec4 formula(vec4 p) {\n\t\tp.xz = abs(p.xz+1.5+sin(iTime*0.1*p.z)*0.1)-abs(p.xz-1.5+sin(iTime*0.01*p.z)*0.1)-p.xz;\n\t\tp=p*2./clamp(dot(p.xz,p.xz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n\t\tp.xy*=rot(.5);\n\t    return p;\n}\n\nvec4 formula2(vec4 p) {\n\t\tp.xz = abs(p.xz+1.5+cos(iTime*0.1+p.z)*0.1)-abs(p.xz-1.5+sin(iTime*0.1+p.z)*0.1)-p.xz;\n\t\tp=p*2./clamp(dot(p.xy,p.xy),.15,1.)-vec4(0.5,0.5,0.8,0.);\n\t\tp.xy*=rot(.5);\n\t    return p;\n}\n\nfloat screen(vec3 p) {\n\tfloat d1=length(p.yz-vec2(1.25,0.))-.1;\t\n\tfloat d2=0.;\n\treturn min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+20.3)-.01));\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.z=abs(4.-mod(tpos.z,8.));\n\tvec4 p=vec4(tpos,1.5);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n\n\t// add mountain\n\tfor (int i=0; i<6; i++) {p=formula(p);}\n\tfloat fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-2.))-.5)/p.w);\n\t\n\tp=vec4(tpos,1.5);\n\ty=max(0.,.35-abs(pos.y-3.35))/.35;\n\n\t// add snow\n\tfor (int i=0; i<8; i++) {p=formula2(p);}\n\tfloat fr2=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n\n\tfloat sc=fr2;\n\tfloat d=min(sc,fr);\n\tif (abs(d-sc)<.001) hid=1.;\n\treturn vec2(d,hid);\n}\n\nvec2 colorize(vec3 p) {\n\tp.z=abs(2.-mod(p.z,4.));\n\tfloat es, l=es=0.;\n\tfloat ot=1000.;\n\tfor (int i = 0; i < 15; i++) { \n\t\tp=formula(vec4(p,0.)).xyz;\n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-10. / abs(l - pl));\n\t\t\t\tot=min(ot,abs(l-3.));\n\t}\n\treturn vec2(es,ot);\n}\n\nvec3 path(float ti) {\n\tvec3  p=vec3(-sin(ti*2.)*.1,(1.-sin(ti*.6))*.5,-cos(ti*.25)*30.)*.2;\n\treturn p;\n}\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<1. && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 13.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.1;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {\n\tfloat sh=shadow(p, lightdir);\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh*DIFFUSE;\n\tvec3 amb=max(.5,dot(dir,-n))*AMBIENT*AMBIENT_COLOR;\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,15.)*SPECULAR;\n\tvec3 col;\n\tvec2 getcol=colorize(p);\n\tif (hid>.5) {col=vec3(1.); spec=spec*spec;}\n\telse{\n\t\tfloat k=pow(getcol.x*.01,2.); \n\t\tcol=mix(vec3(k,k*k,k*k),vec3(k),.5)+.1;\n\t\tcol+=pow(max(0.,1.-getcol.y),5.)*.3;\n\t}\n\tcol=col*ao*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat glow,eglow,totdist=glow=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<30.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*50.);\n\t\t\ttotdist+=d.x; \n\t\t\tif(d.x<0.015) glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t}\n\t}\n\t\n\tfloat l=max(0.,dot(normalize(-dir),normalize(lightdir)));\n\tvec3 backg=vec3(max(0.,1.))*AMBIENT_COLOR*.5*max(0.4,l);\n\n\tif (d.x<det || totdist<3.) {\n\t\tp=p-abs(d.x-det)*dir;\n\t\tvec3 norm=normal(p);\n\t\tcol=light(p, dir, norm, d.y); \n\t\tcol = mix(col, backg, 1.0-exp(-.15*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t    vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * 1.3;\n\t\tfor (int i = 0; i < 7; i++) st = abs(st) / dot(st,st) - .9;\n\t\tcol+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 );\n\t}\n\n\tvec3 lglow=LIGHT_COLOR*pow(l,25.)*.5;\n\tcol+=glow*(.5+l*.5)*LIGHT_COLOR*.7;\n\tcol+=lglow*exp(min(30.,totdist)*.02);\n\treturn col; \n}\n\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv).x;\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 q = fragCoord.xy / iResolution.xy;\n   if (q.y < .12 || q.y >= .88) {\n\t\tfragColor=vec4(0.,0.,0.,1.);\n\t\treturn;\n\t}\n\n    lightdir.y = lightdir.y + iTime*0.01;\n\n\tpth1 = path(t+.3)+origin;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tvec3 from=origin+move(dir);\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [{"id": "lslGzB", "previewfilepath": "https://soundcloud.com/imalogic/eden-short", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/imalogic/eden-short", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKGW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslSW8", "name": "CafeRealTrace", "author": "cafe", "description": "Analytical reflections", "tags": ["caferealtrace"], "likes": 2, "viewed": 93, "date": "1456830233", "time_retrieved": "2024-06-20T18:33:46.634643", "image_code": "const float PI=3.14159;\n\n\n\n\n// Return rd\nvec3 proj(in vec2 uv, out vec3 ro){\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\tro=vec3(cos(mouse.x*PI),mouse.y,sin(mouse.x*PI))*5.;\n\t\n\tvec3 lat=vec3(mouse*0.7,0.),\n\t\t lad=normalize(lat-ro),\n\t\t up=vec3(0.,1.,0.),\n\t\t px=normalize(cross(up,lad))*1.,\n\t\t py=normalize(cross(lad,px))*1.;\n\t\n\tvec3 rd=normalize(uv.x*px+uv.y*py+lad);\n\t\n\treturn rd;\n}\n\nfloat plane(vec3 ro, vec3 rd){\n\tfloat d;\n\t\n\t// Plane position\n\tro+=vec3(0.,7.+3.*sin(iTime),0.);\n\t\n\t// Plane orientation\n\tvec3 pl = vec3(cos(iTime)*0.2,1.,0.2*sin(iTime)); \n\t\n\tpl=normalize(pl*-sign(dot(ro,pl)));\n\n\tfloat p = dot(pl,rd);\n\tif(p<0.) return -1.;\n\t\n\td=dot(-ro,pl)/p-0.0001;\n\t\n\treturn d;\t\n}\n\nfloat skybox(vec3 ro, vec3 rd){\n\tvec3 rs=abs(rd)/(vec3(10.)-ro*sign(rd));\n\treturn 1./max(rs.x,max(rs.y,rs.z));\n}\n\nfloat sphere(vec3 ro, vec3 rd){\n\tif(length(ro)<=1.) return 0.;\n\tfloat dtod=max(0.,dot(-ro,rd)); // Max to avoid sphere behind camera\n\tfloat dins=1.-dot(ro,ro)+dtod*dtod;\n\tif(dins<0.) return -1.; // No collision\n\t\n\treturn dtod-dins;\n}\n\nvec3 normal;\nbool hit;\nfloat obj=-1.;\n\nvec4 colorize(vec3 p){\n\tvec4 color=vec4(1.);\n\t\n\tvec3 light=normalize(vec3(1.,1.,-2.));\n\tfloat diff=max(0.,dot(normal,light));\n\t\n\t\n\t\n\tif(obj==0.){\n\t\tcolor.xyz=0.5*(vec3(sin(dot(p,p)*0.7)*sin(7.*dot(abs(p),vec3(1.)))*0.4+0.8)-1.)+1.;\n\t\tcolor.a=0.7;\n\t\tdiff=1.-exp(-diff*4.);\n\t\t//diff=(diff-1.)*0.8+1.;\n\t}else if(obj>0. && obj<3.){\n\t\tcolor=vec4(1.,sin(iTime*2.)*0.5+0.5,0.2,0.5);\n\t    if(obj==2.)color.xyz=color.zyx;\n\t\tdiff=1.-exp(-diff*0.6);\n\t\tdiff=(diff-1.)*0.4+1.;\n\t\t\n\t}else{\n\t\tcolor=vec4(0.,1.,0.,1.);\n\t}\n\t\n\tcolor=clamp(color,vec4(0.),vec4(1.));\n\t\n\tcolor.rgb*=diff;\n\tcolor.a*=pow(diff,0.);\n\t\n\treturn color;;\n}\n\nvec3 intersect(vec3 ro, vec3 rd){\n    \n    vec3 s1=vec3(cos(iTime),1.5,sin(iTime));\n\tvec3 s2=vec3(sin(iTime),-0.7,0.2);\n    \n\thit=false;\n\tfloat d=-2.,\n\t\t  td=0.;\n\tvec3 p=vec3(0.);\n\t\n\t// DIST ORANGE SPHERE\n\ttd=sphere(ro-s1,rd);\n\tif((!hit||td<d)&&td>=0.){\n\t\td=td;\n\t\tp=(ro-s1)+d*rd;\n\t\tnormal=normalize(p);\n\t\thit=true;\n\t\tobj=1.;\n\t}\n\t\n\t// DIST BLUE SPHERE\n\ttd=sphere(ro-s2,rd);\n\tif((!hit||td<d)&&td>=0.){\n\t\td=td;\n\t\tp=(ro-s2)+d*rd;\n\t\tnormal=normalize(p);\n\t\thit=true;\n\t\tobj=2.;\n\t}\n\t\n\t// DIST BOX\n\ttd=skybox(ro,rd);\n\tif((!hit||td<d)&&td>=0.){\n\t\td=td;\n\t\tp=ro+d*rd;\n\t\tnormal=smoothstep(-0.1,0.,abs(p)-10.)*sign(-p);\n\t\tnormal=normalize(normal);\n\t\thit=true;\n\t\tobj=0.;\n\t}\n\t\n\t// PLANE\n\ttd=plane(ro,rd);\n\tif((!hit||td<d)&&td>=0.){\n\t\td=td;\n\t\tp=ro+d*rd;\n\t\tnormal=vec3(0.,1.,0.);\n\t\thit=true;\n\t\tobj=3.;\n\t}\n\t\n\treturn p;\t\n}\n\nvec3 shade(vec2 uv){\n\tvec3 ro,\n\t     rd = proj(uv,ro),\n\t\t p;\n\t\n\tfloat td;\n\t\n    vec4 color=vec4(0.);\n\t\n\tfor(int i=0 ; i<8 ; i++){\n\t\tif(i>0){\n\t\t\tro=p;\n\t\t\trd=reflect(rd,normal);\n\t\t}\n\t\tp = intersect(ro,rd);\n\t\ttd+=length(p-ro);\n\t\tvec4 tcol=colorize(p);\n\t\tcolor.a=1.-(1.-color.a)*exp(-td*0.03);\n\t\tcolor.xyz=mix(tcol.rgb,color.rgb,color.a);\n\t\tcolor.a=(color.a-1.)*tcol.a+1.;\n\t\tif(color.a>0.99) break;\n\t}\n\t\n\t// EMPTY\n\tif(!hit) return vec3(1.,0.,1.);\n\t\n\treturn color.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = shade(uv).rgbr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstSWr", "name": "Tangent Distance Maps", "author": "hubbe", "description": "Using tangent distance map to let the ray march further with no extra cost.\n", "tags": ["raymarching"], "likes": 9, "viewed": 254, "date": "1458876744", "time_retrieved": "2024-06-20T18:33:47.313526", "image_code": "// Ball radius\n#define R 0.05\n\n// Tangent distance map.\n// \n// If \"tangent_distance\" is true, then the map is allowed to return distances greater\n// than the distance to the surface, as long as the distance returned doesn't skip out\n// the other side of an object again.\nfloat map(vec3 p, bool tangent_distance) {\n    // This makes everything below repeat infinitely.\n    p = mod(p, 0.2) - vec3(0.1);\n\n    // Distance to center of ball, squared.\n    float l2 = dot(p, p);\n    \n    if (l2 >= R*R && tangent_distance) {\n        // By returning the distance to the horizon of the ball, as seen from point p,\n        // (henchforth known as the tangent distance) we guarantee that we don't step\n        // through the ball. Unlike a regular distance map, this will often put us inside\n        // the surface, so the marching function has to handle that. However, the extra\n        // step size allows for larger viewing distances with little or no extra cost.\n        return sqrt(l2 - R*R);\n    }\n    \n    // Fall back on a regular distance map.\n    return sqrt(l2) - R;\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 50; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n\t    float distance_to_closest_object = map(position, !hit);\n\n        if (distance_to_closest_object < 0.0001) {\n        \tif (distance_to_closest_object < 0.0) {\n                // We are inside of an object. Go back to the\n                // previous position and stop using tangent distances\n                // so that we can find the surface.\n            \thit = true;\n          \t    travel_distance = last_travel_distance;\n           \t    continue;\n            }\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += distance_to_closest_object;\n    }\n    // We hit something, but then we ran out of iterations while\n    // finding the surface.\n    if (hit) return travel_distance;\n    // We walked 50 steps without hitting anything.\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -1);\n\n    // Animate\n    camera_position.z += iTime/2.0;\n    camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 1.0;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n\n\t// Direction of the sun.\n    vec3 sun_direction = normalize(vec3(0.2, 1, -1));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance == 0.0) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n\n    // Distance from surface.\n    float surface_dist = map(hit_position, false);\n    \n    // How far we step towards the sun.\n    float sun_ray_step_length = 0.005;\n    \n    // Take a small step in the direction of the light source and measure how\n    // far we are from the surface. The further away we got, the brighter this\n    // spot should be.\n    float surface_dist_nearer_sun = map(hit_position + sun_direction * sun_ray_step_length, false);\n    \n    // Calculate how much sunlight is falling on this spot (hit_position).\n    float sunlight = max(0.0, (surface_dist_nearer_sun - surface_dist) / sun_ray_step_length);\n\n    // Reduce the sunlight with distance to make it fade out far away.\n    sunlight /= (1.0 + travel_distance * travel_distance * 0.2);\n    \n    // Alternate blue and orange balls using magic.\n    float n = dot(vec3(1.0), floor(hit_position * 5.0));\n    if (mod(n, 2.0) == 0.0) {    \n    \t// Blue palette.\n    \tfragColor = vec4(sunlight * sunlight * 0.3, sunlight, sunlight * 1.5, 1.0);\n    } else {\n        // Fire palette.\n    \tfragColor = vec4(sunlight * 1.5, pow(sunlight, 2.5), pow(sunlight, 12.), 1.0);\n    }\t\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstSz4", "name": "Z-Ball", "author": "seb0fh", "description": "black sun productions present...", "tags": ["2d", "noise", "transform"], "likes": 6, "viewed": 490, "date": "1458681914", "time_retrieved": "2024-06-20T18:33:47.313526", "image_code": "vec3 textDots(vec2 p,float size,float size2,vec3 col1,vec3 col2) { return ( length(mod(p,size)-size/2.0)*size2/size >0.5) ? col1 : col2; }    \nvec3 textCheckboard(vec2 p,float size,vec3 col1,vec3 col2) { float hSize=size/2.0; return (mod(p.x,size)>hSize ^^ mod(p.y,size)>hSize) ? col1 : col2; }\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i); \n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n#define F(x) (1.0/x)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx - vec2(0.5,0.5*iResolution.y/iResolution.x);\n\t\n    // transforms\n    float angle=atan(uv.y,uv.x);\n    float dist=length(uv);\n    float t=iTime;\n    vec2 uv2 = vec2(iTime*2.0+cos(angle)*F(dist),iTime*1.0+sin(angle)*F(dist));\n    vec2 uv3 = vec2(iTime+cos(angle+iTime*0.1)/dist,sin(angle+iTime*0.1)/dist);\n    //vec2 uv4=vec2(pow(uv.x,t),pow(uv.y,t));\n    \n    // layers\n    vec3 color=\n        snoise(uv2*0.2)*vec3(0.4) // noise\n        + textDots(uv3,0.07,1.7,vec3(0,0,0),vec3(0.3,0.3,0.3)) // dots\n\t\t+ clamp(sin(iTime*2.+angle*16.0),0.0,1.0)*vec3(0.3,0.3,0.3) // rays\n        + clamp(sin(iTime*1.1+angle*36.0),0.0,1.0)*vec3(0.2,0.2,0.2) // rays\n    \t+ clamp(1.0-dist*4.0,0.0,1.0)*vec3(0.5,0.5,0.5) // glow\n    \t- (1.0-smoothstep(0.08,0.081,dist))*vec3(4,4,4) // dark circle\n        ;\n    \n    // output\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstXRr", "name": "Gold Frame", "author": "Xor", "description": "Here's my latest fractal experiment.", "tags": ["procedural", "3d", "fractal", "light", "gold"], "likes": 22, "viewed": 677, "date": "1457630011", "time_retrieved": "2024-06-20T18:33:47.319599", "image_code": "#define T iTime\n#define LIGHT vec3(cos(T)-1.,sin(T),cos(T*.5))*8.0-vec3(T*16.0,0,0)\n\nfloat MAX = 120.;\nfloat PRE = .01;\n\n//Mapping Function\nvec3 map(vec3 p, float s)\n{\n    vec3 S = vec3(8);\n    vec3 A = mod(p+s/2.0,s)-s/2.0;\n    //vec3 B = max(abs(p)-S,0.0) * sign(p-S);\n    return A;\n}\n//Main Distance Field Function\nfloat model(vec3 p)\n{   \n    float S = -1.0;\n    for(int i = 0;i<7;i++)\n    {\n        float I = exp2(float(i));\n        S = max(S,I/4.0-length(max(abs(map(p,I))-I/8.0,0.0)));\n    }\n    return S;\n}\n//Normal Function\nvec3 normal(vec3 p)\n{\n \tvec2 N = vec2(-1, 1) * PRE;\n\n \treturn normalize(model(p+N.xyy)*N.xyy+model(p+N.yxy)*N.yxy+\n                     model(p+N.yyx)*N.yyx+model(p+N.xxx)*N.xxx);\n}\n//Simple Raymarcher\nvec4 raymarch(vec3 p, vec3 d)\n{\n    float S = 0.0;\n    float T = S;\n    vec3 D = normalize(d);\n    vec3 P = p+D*S;\n    for(int i = 0;i<240;i++)\n    {\n        S = model(P);\n        T += S;\n        P += D*S;\n        if ((T>MAX) || (S<PRE)) break;\n    }\n    return vec4(P,min(T/MAX,1.0));\n}\n//Color/Material Function\nvec3 color1(vec3 p, vec3 n)\n{\n \tvec3 C = vec3(1,.8,.4);\n    vec3 D = normalize(LIGHT-p);\n    float M = model(p);\n \tfloat L = smoothstep(-.05,.05,M+model(p+D*.1));\n    \t  L *= smoothstep(-.5,.5,M+model(p+D));\n    \t  L *= smoothstep(-1.,1.,M+model(p+D*2.));\n          L *= max(dot(n,D),-.5)*.5+.5;\n    \t  L *= exp2(1.-length(LIGHT-p)/16.);\n    \n    return C*L;\n}\nvec3 color2(vec3 p, vec3 d)\n{\n    vec3 N = normal(p);\n    vec3 C = color1(p,N);    \n    \n    float A = exp2(1.-length(LIGHT-p)/16.);\n    float R = (1.-abs(dot(N,normalize(LIGHT-p))));\n    vec3 D = reflect(normalize(LIGHT-p),N);\n    return C+pow(max(dot(D,d),0.),32.)*A;\n}\n//Camera Variables\nvoid camera(out vec3 P,out vec3 D, out vec3 X, out vec3 Y, out vec3 Z)\n{\n\tfloat M = float((iMouse.x+iMouse.y)>0.);\n\tvec2 A = (.5-iMouse.xy/iResolution.xy)*vec2(6.2831,3.1416);\n    vec3 F = mix(vec3(1,0,0),vec3(cos(-A.x)*cos(A.y),sin(-A.x)*cos(A.y),sin(A.y)),M);\n\tP = vec3(-T*16.,0,0)+24.*F;\n\n\tD = -F;\n\n\tX = normalize(D);\n\tY = normalize(cross(X,vec3(0,0,1)));\n\tZ = cross(X,Y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P,D,X,Y,Z;\n    camera(P,D,X,Y,Z);\n\tvec2 UV = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    D = normalize(mat3(X,Y,Z) * vec3(1.,UV));\n    \n    vec4 M = raymarch(P,D);\n    vec3 COL = vec3(.01,.01,.01)+max(color2(M.xyz,D)*sqrt(1.-M.w),0.);\n    COL += exp2(-length(cross(D,LIGHT-P)));\n\tfragColor = vec4(COL,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstXW8", "name": "Earth fly by", "author": "marvindanig", "description": "Forked from the amazing shader by mhnewman: https://www.shadertoy.com/view/XlXGD7\n\nTODO: Implement with JavaScript. ", "tags": ["earth"], "likes": 16, "viewed": 2681, "date": "1459136647", "time_retrieved": "2024-06-20T18:33:48.016518", "image_code": "// Forked from the amazing shader by mhnewman: https://www.shadertoy.com/view/XlXGD7\n\n//\tMy first contribution to Shadertoy\n//\tI have been a big fan of this community for a while and I want to thank iq for\n//\tthis wonderful site.\n//\tHash functions from David Hoskins via https://www.shadertoy.com/view/4djSRW\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)), \n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat hash12_3(vec2 p) {\n\tfloat f = hash12(p);\n    return f * f * f;\n}\n\nfloat noise_3(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12_3(i + vec2(0.0, 1.0)), \n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5 * noise(p); p = m * p;\n    f += 0.25 * noise(p); p = m * p;\n    f += 0.125 * noise(p); p = m * p;\n    f += 0.0625 * noise(p); p = m * p;\n    f += 0.03125 * noise(p); p = m * p;\n    f += 0.015625 * noise(p);\n    return f / 0.984375;\n}\n\nvec3 getDir(vec2 screenPos) {\n    screenPos -= 0.5;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    return normalize(vec3(0.0, -1.0, -3.0)\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\n}\n\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\n    bool valid = false;\n    \n\tfloat b = dot(camera, dir);\n\tfloat c = dot(camera, camera) - 1.0;\n\tfloat h = b * b - c;\n\tif (h > 0.0) {\n        valid = true;\n        \n        vec3 p = camera + (-b - sqrt(h)) * dir;\n        pos = p.xz + iTime * vec2(0.005, 0.02);\n\t}\n\n\treturn valid;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    \n    vec3 camera = vec3(0.0, 1.2, 0.7);\n    vec3 dir = getDir(screen);\n    \n    vec3 earth = vec3(0.0, 0.0, 0.0);\n    vec2 position;\n    if (getPosition(camera, dir, position)) {\n        float geography = fbm(6.0 * position);\n\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\n        vec2 p = 40.0 * position;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast);\n        population = smoothstep(0.0, 0.02, population);\n\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\n        vec3 water = vec3(0.0, 0.05, 0.1);\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\n\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\n\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \n\n        float lightning = 0.0;\n        vec2 strike;\n        if (getPosition(camera, getDir(hash21(iTime)), strike)) {\n            vec2 diff = position - strike;\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\n        }\n        lightning *= smoothstep(0.65, 0.75, weather);\n        earth += lightning * vec3(1.0, 1.0, 1.0);\n    }\n    \n    vec3 altitude = camera - dir * dot(camera, dir);\n    float horizon = sqrt(dot(altitude, altitude));\n    \n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\n    atmosphere = mix(atmosphere, vec3(0.05, 0.1, 0.3), smoothstep(0.992, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\n\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsVGDt", "name": "Funky Distance Field", "author": "gaboose", "description": "I was just trying to make a smooth min function, but this one makes an interesting sight:\nreturn min(b,s) - .01/(b-s);", "tags": ["3d", "raymarching", "sphere", "distance", "fortunatebug"], "likes": 9, "viewed": 632, "date": "1457192086", "time_retrieved": "2024-06-20T18:33:48.440802", "image_code": "#define time iTime\n#define resolution iResolution\n\nfloat box( vec3 p ) {\n\tfloat s = sin(time);\n\tfloat c = cos(time);\n\tp -= vec3(0.,s,1.); // translate\n\tfloat xn = c * p.x - s * p.z;\n\tfloat zn = s * p.x + c * p.z;\n\tp = vec3(xn, p.y, zn); // rotate\n\treturn length(max(abs(p)-vec3(0.4),0.0));\n}\n\nfloat sphere ( vec3 p ) {\n\tp -= vec3(0.,0.,1.);\n\treturn length(p) - 0.5;\n}\n\nfloat scene(vec3 p) {\n\tfloat b = box(p);\n\tfloat s = sphere(p);\n\t\n\t//source of all the funkyness\n\treturn min(b,s) - .01/(b-s);\n\treturn min(b,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max( resolution.x, resolution.y );\n\tvec2 uv = gl_FragCoord.xy/mx;\n\t\n\t// center image\n\tuv += (1.-resolution.xy/mx)/2.;\n\t\n\t//     screen\n\t//      /|     ___\n\t//     / p    /   \\\n\t//    /  |   |     |     ^ y\n\t// eye  -0-  |     |     |\n\t//    \\  |   |     |     |\n\t//     \\ |    \\___/      o---> z\n\t//      \\|                \\\n\t//                         x\n\t//\n\t// -0- marks the origin point (0,0,0) - middle of the screen\n\t\n\tvec3 p = vec3((uv-.5)*2., 0);\n\tvec3 eye = vec3(0,0,-5); // z coord is the focal length\n\t\n\tvec3 light = normalize(vec3(1.,-1.,1));\n\t\n\tvec3 dir = normalize(p-eye); // ray direction\n\tvec3 color = vec3(scene(p)); // bg\n\t\n\tfor (int i=0; i<64; i++) {\n\t\tfloat d = scene(p);\n\t\tif (d < 0.01) {\n\t\t\tfloat dif = (scene(p-light*0.0001)-d)/0.0001; // distance derivative towards the light source\n\t\t\tcolor = vec3(0.2, 0.1, 0.01)*(dif+1.)*2.;\n\t\t\tbreak;\n\t\t} else if (d > 3.) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// march onwards the distance equal to the closest object in the scene\n\t\t// (this way we know we'll never step over an obstacle)\n\t\tp += dir*d;\n\t}\n\t\n\t//Gamma correction\n\tcolor = pow( color, vec3(1.0/2.2) );\n\t\t\n\tfragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsVGWd", "name": "Concave Cone Tracing", "author": "paniq", "description": "applying Convex Cone Tracing ( https://www.shadertoy.com/view/4sy3Wd ) but approaching the surface from the far end", "tags": ["newton", "silhouette", "conservative", "raphson", "concave"], "likes": 4, "viewed": 748, "date": "1457216695", "time_retrieved": "2024-06-20T18:33:50.216867", "image_code": "\n#define MAX_STEPS 20\n\n#define DAValue vec4\n\nstruct DAVec3 {\n    DAValue x;\n    DAValue y;\n    DAValue z;\n};\n\nDAVec3 da_domain(vec3 p) {\n\treturn DAVec3(\n        DAValue(1.0,0.0,0.0,p.x),\n        DAValue(0.0,1.0,0.0,p.y),\n        DAValue(0.0,0.0,1.0,p.z));\n}\n\nDAValue da_const(float a) {\n    return DAValue(0.0,0.0,0.0,a);\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?x:1.0/x;\n}\n\nDAValue da_sub(DAValue a, DAValue b) {\n    return a - b;\n}\nDAValue da_sub(DAValue a, float b) {\n    return DAValue(a.xyz, a.w - b);\n}\nDAValue da_sub(float a, DAValue b) {\n    return DAValue(-b.xyz, a - b.w);\n}\n\nDAValue da_add(DAValue a, DAValue b) {\n    return a + b;\n}\nDAValue da_add(DAValue a, float b) {\n    return DAValue(a.xyz, a.w + b);\n}\nDAValue da_add(float a, DAValue b) {\n    return DAValue(b.xyz, a + b.w);\n}\n\nDAValue da_mul(DAValue a, DAValue b) {\n    return DAValue(a.xyz * b.w + a.w * b.xyz, a.w * b.w);\n}\nDAValue da_mul(DAValue a, float b) {\n    return a * b;\n}\nDAValue da_mul(float a, DAValue b) {\n    return a * b;\n}\n\nDAValue da_div(DAValue a, DAValue b) {\n    return DAValue((a.xyz * b.w - a.w * b.xyz) / (b.w * b.w), a.w / b.w);\n}\nDAValue da_div(DAValue a, float b) {\n    return a / b;\n}\nDAValue da_div(float a, DAValue b) {\n    return DAValue((-a * b.xyz) / (b.w * b.w), a / b.w);\n}\n\nDAValue da_min(DAValue a, DAValue b) {\n    return (a.w <= b.w)?a:b;\n}\nDAValue da_min(DAValue a, float b) {\n    return (a.w <= b)?a:da_const(b);\n}\nDAValue da_min(float a, DAValue b) {\n    return (a < b.w)?da_const(a):b;\n}\n\nDAValue da_max(DAValue a, DAValue b) {\n    return (a.w >= b.w)?a:b;\n}\nDAValue da_max(DAValue a, float b) {\n    return (a.w >= b)?a:da_const(b);\n}\nDAValue da_max(float a, DAValue b) {\n    return (a > b.w)?da_const(a):b;\n}\n\nDAValue da_pow2 (DAValue a) {\n    return DAValue(2.0 * a.w * a.xyz, a.w * a.w);\n}\n\nDAValue da_sqrt (DAValue a) {\n    float q = sqrt(a.w);\n    return DAValue(0.5 * a.xyz * safeinv(q), q);\n}\n        \nDAValue da_abs(DAValue a) {\n    return DAValue(a.xyz * sign(a.w), abs(a.w));\n}\nDAValue da_sin(DAValue a) {\n    return DAValue(a.xyz * cos(a.w), sin(a.w));\n}\nDAValue da_cos(DAValue a) {\n    return DAValue(-a.xyz * sin(a.w), cos(a.w));\n}\nDAValue da_log(DAValue a) {\n    return DAValue(a.xyz / a.w, log(a.w));\n}\nDAValue da_exp(DAValue a) {\n    float w = exp(a.w);\n    return DAValue(a.xyz * w, w);\n}\n\n\nDAValue da_length(DAValue x,DAValue y) {\n    float q = length(vec2(x.w,y.w));\n    return DAValue((x.xyz * x.w + y.xyz * y.w) * safeinv(q), q);\n}\nDAValue da_length(DAValue x,DAValue y,DAValue z) {\n    float q = length(vec3(x.w,y.w,z.w));\n    return DAValue((x.xyz * x.w + y.xyz * y.w + z.xyz * z.w) * safeinv(q), q);\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius\nDAValue sdSuperprim(DAVec3 p, vec4 s, vec2 r) {\n    DAValue dx = da_sub(da_abs(p.x),s.x);\n    DAValue dy = da_sub(da_abs(p.y),s.y);\n    DAValue dz = da_sub(da_abs(p.z),s.z);\n    DAValue q = \n        da_add(\n            da_length(\n                da_max(da_add(dx, r.x), 0.0),\n                da_max(da_add(dy, r.x), 0.0)),\n            da_min(-r.x,da_max(dx,dy)));\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s, out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nDAValue doobject (DAVec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec2 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdSuperprim(DAVec3(p.z, p.y, p.x), mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nDAValue doModel( DAVec3 p ) {\n    float k = iTime*0.5;\n    DAValue d = doobject(p, k);\n    return d;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\t//float precis = 0.86602540378444 * max(pixel.y,pixel.x);        // precission of the intersection\n    float precis = 0.70710678118655 * max(pixel.y,pixel.x);        // precission of the intersection\n    DAValue h;\n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    \n    for( int i=0; i<MAX_STEPS; i++ )          // max number of raymarching iterations is 90\n    {\n        steps = i;\n        float rt = maxd - t;\n        DAValue dt = DAValue(-1.0,0.0,0.0,rt);\n        DAValue px = da_add(ro.x, da_mul(rd.x, dt));\n        DAValue py = da_add(ro.y, da_mul(rd.y, dt));\n        DAValue pz = da_add(ro.z, da_mul(rd.z, dt));\n\t    h = doModel(DAVec3(px,py,pz));\n        // apply conic shearing\n        h = da_sub(h, da_mul(dt, bias*precis));\n        // compute step size towards root\n        float st = abs(h.w) / max(-h.x,0.0);        \n        t += st;\n    \tif((abs(h.w) <= 1e-6) || (t > maxd)) {\n            break;\n        }\n    }\n    \n    if (abs(h.w) <= 1e-3)\n\t\tres = maxd - t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    DAValue d = doModel(da_domain(pos));\n    return d.xyz;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    float dist;\n    float dist_inner;\n    float dist_outer;\n    \n    interior = false;\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n    \n    float K = 16.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 hresolution = floor((iResolution.xy + (K - 1.0)) / K);\n    vec2 hfragCoord = floor(uv * hresolution) + 0.5;\n    interior = false;\n    vec3 pos_inner;\n    int steps_inner;\n    bool hit_inner = dorender(dist_inner, steps_inner, pos_inner, hfragCoord, hresolution, -1.0);\n    interior = false;\n    vec3 pos_outer;\n    int steps_outer;\n    bool hit_outer = dorender(dist_outer, steps_outer, pos_outer, hfragCoord, hresolution, 1.0);\n    \n    fragColor = vec4(vec3(0.0),1.0);\n    if (hit_outer) {\n        if (hit_inner) {\n            if (hit) {\n\t        \tvec3 nor = calcNormal(pos);\n            \tfragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n            } else {\n                // must not happen\n                fragColor = vec4(vec3(1.0),1.0);\n            }\n        } else if (hit)\n            fragColor.g = 1.0;\t\n        else\n        \tfragColor.r = 1.0;\n\t} else if (hit) {\n        // must not happen\n        fragColor = vec4(vec3(1.0),1.0);\n    }\n\n    if (hit) {\n        // outer shell always further than surface\n        if (dist > dist_outer)\n            fragColor = vec4(1.0,0.7,0.0,1.0);\n       \t// inner shell always contained within surface\n        else if (hit_inner && (dist_inner > dist))\n            fragColor = vec4(1.0,0.7,1.0,1.0);\n    }\n    //fragColor = vec4(normhue(dist - dist_inner),1.0);\n    //fragColor = vec4(normhue(float(steps_outer) / 10.0),1.0);\n}", "image_inputs": [{"id": "4dX3zn", "previewfilepath": "/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXXR4", "name": "neurowaves", "author": "cafe", "description": "Specular can make anything look organic. I kind of like this one.", "tags": ["nerevawv"], "likes": 4, "viewed": 129, "date": "1456830432", "time_retrieved": "2024-06-20T18:33:50.222552", "image_code": "const float PI=3.14159;\n\nvec3 shd(vec2 uv){\n\tfloat speedmod=0.5;\n\tfloat speed=(sin(iTime)/1000.+3.)*speedmod;\n\t\n\tfloat scol = abs(uv.y-sin(uv.x*5.)/4.);\n\t\n\tfloat t = scol*(sin(uv.x+iTime*speed/5.)*100.)*abs(uv.y);\n\t\n\tvec3 color = vec3(sin(t));\n\t\n\tfloat maxstripes=10.;\n\t\n\t\n\tfloat stripes=mod(iTime*speed+uv.x,maxstripes*2.)-maxstripes;\n\tstripes = abs(stripes);\n\t\t\n\tvec3 ncolor;\n\t\n\tncolor.r=-color.r;\n\tncolor.g=color.g*sin(uv.x);\n\tncolor.b=-ncolor.g;\n\t\n\tfloat sm=1.;\n\t\n\tfloat ml = smoothstep(PI*stripes+sm,PI*stripes-sm,abs(t));\n\t\n\tcolor = mix(color,ncolor,ml);\n\t//color = ncolor;\n\t\n\tfloat saturation=sin(uv.x*sin(uv.x*10.+iTime*speed+sin(uv.y*10.+sin(uv.x*15.))/4.)*10.+iTime*speed)+2.;\n\t\n\tcolor=color*saturation;\n\t\n\treturn color;\n}\n\n\nfloat heightmap(vec2 uv){\n\tvec3 c = shd(uv);\n\t//return (c.r+c.g+c.b)/2.;\n\t//return min(c.r,min(c.g,c.b));\n\treturn c.r*0.2126 + c.g*0.7152 + c.b*0.0722; //greyscale\n}\n\nvec3 normalmap(vec2 uv, float spread){\n\tvec3 color = vec3(0.);\n\t\n\tfloat depth=0.;\n\t\n\tfloat p[4];\n\tp[0] = heightmap(uv+vec2(-spread,-spread));\n\tp[1] = heightmap(uv+vec2( spread,-spread));\n\tp[2] = heightmap(uv+vec2(-spread, spread));\n\tp[3] = heightmap(uv+vec2( spread, spread));\n\t\n\tfloat xsl = (p[1]+p[3])/2.-(p[0]+p[2])/2.;\n\tfloat ysl = (p[0]+p[1])/2.-(p[2]+p[3])/2.;\n\t\n\tfloat saturate=0.5/length(vec3(xsl,ysl,depth));\n\t\n\tvec3 nor = normalize(vec3(xsl,ysl,spread))/2.;\n\t\n\tcolor.r=0.5+nor.x;\n\tcolor.g=0.5+nor.y;\n\tcolor.b=0.5+nor.z;\n\t\n\treturn vec3(color);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n\t\n\t\n\t//uv.y+=1.;\n\tuv.y*=0.8;\n\t//uv.x*=1.5;\n\tuv.y*=(uv.y*uv.y)+0.9;\n\t\t\n\n\tvec3 lvec = vec3(sin(iTime)/10.,cos(iTime*1.15)/10.,1.);\n\tlvec = normalize(lvec);\n\t\n\t\n\t\n\t//color=color*(floor(mod(uv.x,0.2+sin(iTime)+1.)*10.)*2.-1.);\n\t\n\tvec3 nrm = normalmap(uv,0.001);\n\t\n\tfloat ambient = clamp(dot(lvec,nrm),0.,1.);\n\t//ambient=pow(ambient/2.+0.5,5.);\n\tambient=pow(ambient,2.);\n\t\n\tvec3 color = shd(uv);\n\tcolor=color*ambient;\n\t//color = vec3(ambient);\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3XD4", "name": "Spline distance, polynomial opt", "author": "JohanKohler", "description": "Distance to quadratic bezier.\nUses a polynomial aproximation of cos(acos(x)/3)\nACos is a polynomial aprox on most GPU's so this should be faster.\nThe heavy lifting was done by Adrian Stephens.\n", "tags": ["splinequadraticdistance"], "likes": 12, "viewed": 210, "date": "1459292823", "time_retrieved": "2024-06-20T18:33:50.738082", "image_code": "// Distance to quadratic bezier.\n// Uses a polynomial aproximation of cos(acos(x)/3)\n// ACos is a polynomial aprox on most GPU's so this should be a bit faster.\n// The heavy lifting was done by my friend Adrian Stephens.\n\n#define COSSIN_THIRD_POLYNOMIAL\n\n\nfloat distanceSq(vec2 a, vec2 b)\n{\n    return dot(a-b,a-b);\n}\n\nfloat lengthSq(vec2 a)\n{\n    return dot(a,a);\n}\n\n\n\nvec2 cossin_third(float x ) \n{\n#ifdef COSSIN_THIRD_POLYNOMIAL\n    // polynomial aproximation of cos(acos(x)/3)\n    float c = (0.866017 +1.25203 * x + 0.431996 * x * x + 0.0161423 * x * x * x)\n        /(1.0 + 1.25325 * x + 0.312933 * x * x);\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n    \n#else\n    float c = cos(acos(x)/3.0);\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n#endif\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c )\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    \n    if(d >= 0.0) \n    {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    \n    vec2 cs = cossin_third(-sqrt(-27.0 / p3) * q / 2.0 );\n    float m = cs.x, n = cs.y * 1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n\n// Find the distance from a point to a bezier curve\nfloat dBezier(vec2 A, vec2 B, vec2 C, vec2 p )\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(solveCubic(k.x, k.y, k.z ), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = lengthSq(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, lengthSq(pos - p));\n    return sqrt(dis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dd = 10.0;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/(iResolution.y);\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/(iResolution.y),\n       \tvec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n\n\t// Define the control points of our curve\n  \tvec2 A = vec2(0.4, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C)))) ;\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n\n    dd = min(dBezier(A, B, C, p ),dd );\n\n    // Visualize the distance field using iq's orange/blue scheme\n    vec4 col = vec4(1.0);\n    if (dd < 0.0)\n        col *= 0.5;\n    fragColor = col * (1.0 - exp(-4.0*abs(dd))) * (0.8 + 0.2*cos(140.*dd));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(dd)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3XD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3XRM", "name": "Double Helix", "author": "Xor", "description": "A simple DNA double helix. Move the view with the mouse.\nUpdated 11-6-17: Added major and minor groove as suggested by [url=https://www.shadertoy.com/user/tomkh]tomkh[/url] and added multiple DNA strands in place of random spheres.", "tags": ["procedural", "3d", "dna"], "likes": 23, "viewed": 2039, "date": "1458310863", "time_retrieved": "2024-06-20T18:33:50.738082", "image_code": "vec3 LIGHT = normalize(vec3(-0.3,0.2,-0.1));\n\nfloat FULL_SIZE = 2.0;\nfloat EDGE_SIZE = 0.2;\nfloat PAIR_SIZE = 0.2;\n\nvec3 n3(vec3 n)\n{\n \treturn fract(cos(dot(n,vec3(813,12,376)))*vec3(901.81,827.46,615.79));   \n}\nvec3 model(vec3 p)\n{\n    float A = p.z/3.0+iTime*0.25;\n    vec3 R = vec3(cos(A),sin(A),0);\n    vec3 C = vec3(mod(p.xy+8.,16.)-8.+R.yx*vec2(1,-1),fract(p.z)-0.5);\n    \n    float H = min(length(C.xy+R.xy*FULL_SIZE),length(C.xy-R.xy*FULL_SIZE))*0.5-EDGE_SIZE;\n    float P = max(length(vec2(dot(C.xy,R.yx*vec2(1,-1)),C.z))-PAIR_SIZE,length(C.xy)-FULL_SIZE);\n    \n    float T = FULL_SIZE+0.01+2.*EDGE_SIZE-length(C.xy);\n    return vec3(min(H,P),T,P);  \n}\nvec3 normal(vec3 p)\n{\n \tvec2 N = vec2(-0.04, 0.04);\n\n \treturn normalize(model(p+N.xyy).x*N.xyy+model(p+N.yxy).x*N.yxy+\n                     model(p+N.yyx).x*N.yyx+model(p+N.xxx).x*N.xxx);\n}\nvec4 raymarch(vec3 p, vec3 d)\n{\n    vec4 M = vec4(p+d*2.0,0);\n \tfor(int i = 0; i<100;i++)\n    {\n        float S = model(M.xyz).x;\n    \tM += vec4(d,1) * S;\n        if (S<0.01 || M.w>50.0) break;\n    }\n    return M;\n}\nvec3 sky(vec3 d)\n{\n    float L = dot(d,LIGHT);\n \treturn vec3(0.3,0.5,0.6)-0.3*(-L*0.5+0.5)+exp2(32.0*(L-1.0));   \n}\nvec3 color(vec3 p, vec3 d)\n{\n    vec2 M = model(p).yz;\n    float A = atan(mod(p.y+8.,16.)-8.,8.-mod(p.x+8.,16.));\n    float T1 = ceil(fract(cos(floor(p.z)*274.63))-0.5);\n    float T2 = sign(fract(cos(floor(p.z-80.0)*982.51))-0.5);\n    float T3 = T2*sign(cos(p.z/3.0+iTime*0.25+A));\n\n    float L = dot(normal(p),LIGHT)*0.5+0.5;\n    float R = max(dot(reflect(d,normal(p)),LIGHT),0.0);\n    vec3 C = mix(mix(vec3(0.9-0.8*T3,0.9-0.6*T3,T3),vec3(1.0-0.6*T3,0.2+0.8*T3,0.1*T3),T1),vec3(0.2),step(0.01,M.y));\n \tC = mix(C,vec3(0.2,0.5,1.0),step(0.01,-M.x));\n    return\tC*L+pow(R,16.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 A = iMouse.xy / iResolution.xy * vec2(2,1) * 3.1416;\n    vec3 D = vec3(cos(A.x)*sin(A.y),sin(A.x)*sin(A.y),cos(A.y));\n    D = mix(vec3(1,0,0),D,ceil((A.x+A.y)/10.0));\n    vec3 P = D*12.0-vec3(0,0,iTime*2.0);\n    \n    vec3 X = normalize(-D);\n    vec3 Y = normalize(cross(X,vec3(0,0,1)));\n    vec3 Z = normalize(cross(X,Y));\n    \n\tvec2 UV = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 R = normalize(mat3(X,Y,Z) * vec3(1,UV));\n    \n    vec4 M = raymarch(P,R);\n    vec3 C = mix(color(M.xyz,R),sky(R),smoothstep(0.5,1.0,M.w/50.0));\n\tfragColor = vec4(C,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3XRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3XW4", "name": "Babbies first raymarch", "author": "EATDRINKFUCK", "description": "I'm in ur shaders, stealin' ur code.", "tags": ["raymarching"], "likes": 2, "viewed": 137, "date": "1459458052", "time_retrieved": "2024-06-20T18:33:50.753640", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\treturn max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n   return (d1.x>d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(1.0*p.y+1.0+iTime);\n    float  s = sin(1.0*p.y+1.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec2 opBlend( vec2 d1, vec2 d2 )\n{\n\tfloat diff = d1.x-d2.x;\n\tfloat diff2 = smoothstep(-0.2,0.2,diff);\n\t//diff = smoothstep(d1.x\n\treturn vec2(mix(d1.x,d2.x,diff2),mix(d1.y,d2.y,diff2));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n\n//----------------------------------------------------------------------\n\n\nvec2 map( in vec3 pos )\n{\n\n    if (iTime < 15.0)\n\t{\n        float size = 3.0;\n        pMod3(pos,vec3(size));\n        pos += vec3(0.0,0.0,0.0);\n\n\n        float sphere = sdSphere(pos,1.0);\n        float cube = sdBox(pos,vec3(((sin(iTime)+1.0)/2.0)*0.75));\n        float combine = max(sphere,cube);\n\n        vec3 posellende = pos + vec3(sin(iTime*3.0)*0.5,0.0,0.0);\n        float torus = fTorus(posellende, 0.5, 0.7);\n        float combine_JODEN = max(combine, -torus);\n\n        vec3 addiesgaskamer = pos;\n        pR(addiesgaskamer.yz,iTime);\n\n        float torusnogmeer = fTorus(addiesgaskamer, 0.2, 0.5);\n        float combine_anne = min(combine_JODEN, torusnogmeer); \n\n\n\n\n        float result = combine_anne;\n        return vec2(result,50.0);\n    }\n    \n    else if (iTime < 1030.0)\n    {\n        float sphere = sdSphere(pos,1.0);\n        float cube = sdBox(pos,vec3(((sin(iTime)+1.0)/2.0)*0.75));\n        float combine = max(sphere,cube);\n        \n        float result = combine;\n        return vec2(result,50.0);\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    vec2 res = opU( vec2( sdPlane(     pos), 100.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n\t\n\tvec2 box1 =  vec2( \t  sdBox(       opTwist(pos-vec3( 0.0,0.35+sin(iTime)*0.2, -1.0)), vec3(0.35)), 3.0);\n\t//vec2 box1 =  vec2( \t  sdBox(       pos-vec3( 0.0,0.35, -1.0), vec3(0.35)), 3.0);\n\tvec2 object2 =  vec2( sdTorus82(   pos-vec3( -0.3,0.4, -1.0), vec2(0.40,0.1) ),60.0 );\n\t\n\n\tfloat combined = fOpUnionRound(box1.x,object2.x,0.2);\n    \n\t\n\tres = opU(res,vec2(combined,40.0));\n\t\n\t#if 0\n\t\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.20,-0.1), vec3(-1.0,0.20,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\t\n\t#endif\n\n#if 0\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831 + 0.1*iTime,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y+8.0*iTime)*sin(50.0*pos.z), \n                                       65.0 ) );\n\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n#endif\n\n    return res;\n}\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += max( 0.02, dt );\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,20.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\t//col = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\tcol = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\n\t\t\n\t}\n\n\tcol *= exp( -0.01*t*t );\n\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 50.0;\n\n\t// camera\t\n\tvec3 ro = vec3( 0.0, 1.0, -3.0 );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    \n\n\t\n    vec3 col = render( ro, rd );\n\n\tcol = sqrt( col );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3XW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md3Xzn", "name": "Shadow Testings", "author": "gsitcia", "description": "A test for shadows. Use mouse to move camera.", "tags": ["shadow"], "likes": 2, "viewed": 115, "date": "1457490500", "time_retrieved": "2024-06-20T18:33:50.754638", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rpBox( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox( p, vec3(0.5, 0.5, 0.5) );\n}\n\nfloat sdPlane( vec3 p )\n{\n  // n must be normalized\n  return p.y;\n}\n\nfloat map( vec3 p ) {\n    float d1 = sdPlane( p );\n    float d2 = sdSphere( p - vec3(0.0, 0.5, 0.0), 1.0);\n    float d3 = udBox( p - vec3(-1.0, 1.0, 0.0), vec3(1.7, 2.0, 2.0) );\n    float d4 = sdSphere( p - vec3(0.0, 0.5, 0.0), 2.0);\n    return min(max(-d2, max(d3, d4)), d1);\n}\n\nfloat shadow( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    float dst = 0.0;\n    float res = 1.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.6;\n        dst += dt * 0.6;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, p) < 0.001) {\n                return res;\n            } else {\n            \treturn 0.0;\n            }\n        }\n        res = min(res, 4.0 * dt * dst / length(p - l.xyz));\n    }\n    return res * l.w;\n}\n\nfloat lights( vec3 p, vec4 l ) {\n    float dt = map( p );\n    vec3 ds;\n    ds.x = min(map( p + vec3(dt, 0.0, 0.0) ), map( p - vec3(dt, 0.0, 0.0) ));\n    ds.y = min(map( p + vec3(0.0, dt, 0.0) ), map( p - vec3(0.0, dt, 0.0) ));\n    ds.z = min(map( p + vec3(0.0, 0.0, dt) ), map( p - vec3(0.0, 0.0, dt) ));\n    ds = normalize(-1.0 * ds);\n    vec3 ld = normalize(p - l.xyz);\n    float li = dot(ds, ld);\n    return li * l.w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 id = vec3(1.0, 1.0, 1.0);\n    \n    float mindist = min(iResolution.x, iResolution.y);\n    \n    vec3 uv = vec3((gl_FragCoord.xy - iResolution.xy / 2.0) / mindist, 0.0);\n    \n    // vec3 eye = vec3((2.0 * (iMouse.xy - iResolution.xy / 2.0) / mindist) + vec2(0.0, 1.0), -2.5);\n    \n    vec3 eye = vec3(3.0 * sin(iMouse.x * 3.141592 / 360.0), (iResolution.y - iMouse.y) / 45.0 , 3.0 * cos(iMouse.x * 3.141592 / 360.0));\n    \n    float fl = 1.0;\n    \n    vec3 fo = normalize(-1.0 * eye);\n    \n    // vec3 up = normalize(vec3(0.0, 1.0, 0.0)); // 2 point perspective\n    \n    vec3 up;\n    \n    up.xz = -1.0 * fo.xz;\n    \n    up.xz *= fo.y / length(fo.xz);\n    \n    up.y = length(fo.xz); // 3 point perspective\n    \n    vec3 si = cross(up, fo);\n    \n    uv = eye + fl * fo + uv.x * si + uv.y * up;\n    \n    vec3 dr = uv - eye;\n    \n    dr = dr / length(dr);\n    \n    float dt = 0.0;\n    \n    for (int i = 0; i < 100; ++i) {\n        dt = map( uv );\n        if (dt < 0.0001) {\n            dt = float(i);\n            break;\n        }\n        uv = uv + dr * dt * 0.8;\n    }\n    \n    // reflect\n    /*\n    if (abs(uv.y) > 0.001) {\n    \tdt = map( uv );\n    \t\n    \tvec3 ds;\n    \tds.x = min(map( uv + vec3(dt, 0.0, 0.0) ), map( uv - vec3(dt, 0.0, 0.0) ));\n    \tds.y = min(map( uv + vec3(0.0, dt, 0.0) ), map( uv - vec3(0.0, dt, 0.0) ));\n    \tds.z = min(map( uv + vec3(0.0, 0.0, dt) ), map( uv - vec3(0.0, 0.0, dt) ));\n    \tds = normalize(-1.0 * ds);\n    \t\n    \tfloat kfe = 2.0 * dot(ds, -dr) / dot(ds, ds);\n    \t\n    \tdr = kfe * dr - ds;\n    \t\n    \tdt = 1.0;\n    \t\n    \tfor (int i = 0; i < 100; ++i) {\n    \t    if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n    \t}\n    }\n    \n    // vec3 dc = vec3(dt, dt, dt) / 50.0;\n   \t\n    /* if (dt == 100.0) {\n       \tdc = vec3(0.0, 1.0, 0.5);\n    } else {\n        dc = vec3(dt, dt, dt) / 50.0;\n    } */\n    \n    vec4 light = vec4(3.0 * sin(iTime * 3.141592 / 45.0), 2.0, 3.0  * cos(iTime * 3.141592 / 45.0), 1.0);\n    \n    vec3 dc = id * (shadow( uv, light ) * (lights( uv, light ) + 0.1));\n    \n    fragColor = vec4(dc, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3Xzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcSWH", "name": "24pi", "author": "vamoss", "description": "Original work: http://flotsam.sellingwaves.com/post/137845201876/24%CF%80", "tags": ["circles", "line", "spinning"], "likes": 10, "viewed": 191, "date": "1459018228", "time_retrieved": "2024-06-20T18:33:50.754638", "image_code": "// original work: http://flotsam.sellingwaves.com/post/137845201876/24%CF%80\n\nconst float zoom = 8.;\nconst float outlines = 4.;\nconst float edges = 5.0;\nconst float edgeDistance = outlines-0.5;\nconst float cropAngle = 3.7;//0-2*PI\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\nfloat circles(vec2 uv){\n    float circle = length(uv);\n    circle *= 1.-step(outlines, circle);\n    float angle = atan(uv.y, uv.x)+PI;\n    if(angle<cropAngle) return smoothstep(.05, .1, abs(fract(circle)-.5));\n    return 1.0;\n}\n\n//*\n//Vamoss version 939 chars\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = zoom * (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    //bg\n    vec3 color = vec3(0.2, 0.1, 0.25);\n    \n    //circles\n    for(float i=0.; i<edges; i++){    \n        float angle = i/edges*TWO_PI-HALF_PI;\n        vec2 pos = uv + vec2(cos(angle)*edgeDistance, sin(angle)*edgeDistance);\n    \tif(iMouse.z>0.) pos *= rotate2d(-iMouse.x/iResolution.x*10.-angle);\n        else pos *= rotate2d(-iTime-angle);\n\t    color = mix(vec3(0, 1, 0.8), color, circles(pos));\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n/**/\n/*\n//FabriceNeyret2 version 720 chars\n#define rot(a) mat2(cos(a),-sin(a), sin(a),cos(a))\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float t=iTime, a;\n    vec2 R = iResolution.xy, \n        pos, D = edgeDistance*vec2(cos(-t), sin(-t));\n    U = zoom * (U+U-R)/R.y;\n    \n    O = vec4(.2, .1, .25, 1);\n    \n    for(float i=0.; i<1.; i+=1./edges){    \n        a = i*TWO_PI - HALF_PI;\n        pos = U*rot(-t-a) + D;\n\t    O = mix(vec4(0, 1, .8,1), O, circles(pos));\n    } \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcSWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcSz7", "name": "Checkerboard Barrel Distortion", "author": "MichaelPohoreski", "description": "Checkerboard distortions from WebGL Academy", "tags": ["distortion", "checkerboard"], "likes": 3, "viewed": 185, "date": "1458318865", "time_retrieved": "2024-06-20T18:33:50.755635", "image_code": "// Reference:\n// Demo 1K Raw\n// http://www.webglacademy.com/courses.php?courses=9|12|24|21|13#13\n\n#define DISTORTION 5\n\nfloat f( vec2 p, float d )\n{\n    float t = iTime;\n    float g = \n    \n#if DISTORTION == 1 // Step 6 simple barrel distorion\n    mod(floor(    p.x*    length(p)     )+floor(    p.y*    length(p)     ),2.);\n#elif DISTORTION == 2 // Step 7 x\n    mod(floor(    p.x*pow(length(p),-3.))+floor(    p.y*    length(p)     ),2.);\n#elif DISTORTION == 3 // Step 8 x and y\n    mod(floor(    p.x*pow(length(p),-3.))+floor(    p.y*pow(length(p),-3.)),2.);\n#elif DISTORTION == 4 // Step 9 x and y animated\n    mod(floor(  t-p.x*pow(length(p),-3.))+floor(  t-p.y*pow(length(p),-3.)),2.);\n#elif DISTORTION == 5 // Step 10 x and y animated + color\n    mod(floor(d-t-p.x*pow(length(p),-3.))+floor(d-t-p.y*pow(length(p),-3.)),2.);\n#else\n    mod(floor(p.x)+floor(p.y),2.);\n#endif\n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p  = fragCoord.xy / (iResolution.xy*0.5) - vec2(1.,1.);\n        \n#if DISTORTION == 5 //  // Step 10 x and y animated + color\n    fragColor = vec4( f(p,0.), f(p,.3), f(p,.6), 1.);\n#else // monochrome\n    float g = f( p, 0. );\n    fragColor = vec4( g, g, g, 1.0 );\n#endif\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcXz8", "name": "Decal Blending", "author": "paniq", "description": "experimenting with blending a decal in linear colorspace; left side is logarithmic alpha blending (multiplicative effect). right side is linear alpha blending (additive effect). Exposure & lambert is simulated on the result, followed by a HDR mixdown.", "tags": ["linear", "alphablending", "decal", "logspace"], "likes": 6, "viewed": 1086, "date": "1457589674", "time_retrieved": "2024-06-20T18:33:50.756980", "image_code": "// attention: not an exponent, but a factor\n#define EXPOSURE 2.0\n\nfloat m; \n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 srgb2lin(vec3 color) {\n    return color * (color * (\n        color * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 lin2srgb(vec3 color) {\n    vec3 S1 = sqrt(color);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\n\nconst float whitepoint = 398.0 / 335.0 + 0.004;\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat decal(float d, float r) {\n    return smoothstep(0.0, 1.0, (r - d) / r);\n}\n\nvoid blend(inout vec3 color, vec2 p, vec2 s, float ph) {\n    float r = min(s.x, s.y);\n    float d = -sdBox(vec3(p,0.0), vec3(s-r,1.0))+r;\n    \n    d /= r * (0.1 + (sin(iTime)*0.5+0.5)*0.9);\n    \n    d = smoothstep(0.0, 1.0, d);\n    //d = clamp(d, 0.0, 1.0);\n    \n    // defined in srgb\n    vec3 albedo = min(hue2rgb(iTime * 0.01 + ph) + 0.1, 1.0);\n    albedo = mix(albedo,vec3(1.0),0.5);\n    albedo = srgb2lin(albedo);\n    \n    if (p.x < m) {\n        float eps = 0.001;\n        color = pow(color, vec3(1.0 - d)) * pow(albedo, vec3(d));\n    } else {\n        color = mix(color, albedo, d);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    m = (((iMouse.z < 0.5)?0.5:iMouse.x / iResolution.x));\n    m = m * 2.0 - 1.0;\n    m *= iResolution.x / iResolution.y;\n    \n    // defined in srgb\n    vec3 background = min(hue2rgb(iTime * 0.017 + 0.5) + 0.1, 1.0);\n    background = mix(background,vec3(1.0),0.5);\n    background = srgb2lin(background);\n    \n    vec3 color = background;\n    \n    blend(color, uv, vec2(0.5,0.9), 0.333);\n    blend(color, uv, vec2(0.9,0.5), 0.0);\n    blend(color, uv, vec2(0.30,0.30), 0.8);\n    blend(color, uv, vec2(0.25,0.25), 0.0);\n    blend(color, uv, vec2(0.20,0.20), 0.8);\n    \n    color = color*(0.2 + max(cos((uv.y-1.0)*1.57),0.0));\n    \n    color *= EXPOSURE * whitepoint;\n    \t\n    fragColor = vec4(ACESFitted(color) * min(1.0, abs(uv.x - m)*80.0),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcXz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcXzn", "name": "Geomechanical", "author": "Bers", "description": "Generative, smooth edged hexagonal prism primitive, shaded with arithmetic PBR Lights.", "tags": ["distancefield", "hexagon", "pbr"], "likes": 193, "viewed": 11680, "date": "1457308311", "time_retrieved": "2024-06-20T18:33:54.501951", "image_code": "// Author : Sebastien Berube\n// Created : March 2015\n// Modified : Jan 2016\n// \n// Composition made from a repeated hexagon prism pattern.\n// Hexagon prism distance function had to be modified to smooth out vertical edges.\n//\n// Sources:\n// Inigo Quilez\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n// For those interested in the origin of sphere tracing:\n// Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)\n// http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3825\n// Spline\n// http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Constants\nconst float PI = 3.14159;\nconst float SCALE = 1.0;\nconst float MAX_DIST = 1000.0;\nconst float FLOOR_HEIGHT  = 0.0;\nconst float X_REPEAT_DIST = 0.90*SCALE;\nconst float Z_REPEAT_DIST = 1.05*SCALE;\nconst float PRIM_HEIGHT    = 1.0;\nconst float HEX_HALF_WIDTH = 0.26*SCALE;\nconst float GEOMETRY_DISPLACEMENT = 1.00;\nfloat g_time;\n\nstruct AnimationChannels\n{\n    float material_roughness;   //[0-1 range]\n    float geometry_width;       //[0-1 range]\n    float geometry_scale;       //[0-1 range]\n    float geometry_displacement;//[0-1 range]\n\tfloat geometry_smoothness;  //[0-1 range]\n    vec3 camPos;                //[IR range]\n    vec3 camLookAt;             //[IR range]\n};\nAnimationChannels g_animationChannels;\n\n//Material ID enum\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_SKY       = 2;\nconst int MATERIALID_PLASTIC   = 3;\nconst int MATERIALID_METAL     = 4;\n\n//Debug flag enum\nconst int DEBUG_RAYLEN  = 0;\nconst int DEBUG_GEODIST = 1;\nconst int DEBUG_NORMAL  = 2;\nconst int DEBUG_MATID   = 3;\n\nfloat fDEBUG = 0.1;\n\n//Defines\n#define saturate(x) clamp(x,0.0,1.0)\n//----------------------\n// Camera\nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 o; float lens; float zoom; }; //Right, Up, Direction, origin\nCam    CAM_lookAt(vec3 target, float pitchAngleRad, float dist, float theta);\nCam    CAM_mouseLookAt(vec3 at, float dst);\nCam    CAM_animate(vec2 uv, float fTime);\nvec3   CAM_getRay(Cam cam, vec2 uv);\n\n//----------------------\n// Post Process\nvec3 POST_ProcessFX(vec3 c, vec2 uv);\n\n//----------------------\n// Analytic Intersections\nfloat RAYINTERSEC_plane(vec3 o, vec3 d, vec3 po, vec3 pn)\n{\n    return dot(po-o,pn)/dot(d,pn); \n}\n\nstruct repeatInfo\n{\n    vec3 smpl; //object-space, cyclic\n    vec3 anchor; //world space\n};\n    \n#define normalized_wave(a) (0.5*a+0.5)\nrepeatInfo DF_repeatHex(vec3 p)\n{\n    //Repetition\n    float xRepeatDist = X_REPEAT_DIST;\n    float zRepeatDist = Z_REPEAT_DIST*0.5;\n    float latticeX = (fract(p.x/xRepeatDist+0.5)-0.5)*xRepeatDist;\n    float latticeY = (fract(p.z/zRepeatDist+0.5)-0.5)*zRepeatDist;\n    vec2 anchorPosXZ = p.xz-vec2(latticeX,latticeY);\n    p.x = latticeX; //Cyclic coords.\n    p.z = latticeY;\n    \n    //Variation\n    float period = fract(g_time/30.)*3.0;\n    float theta = period*2.0*PI;\n    float overallAmplitude = normalized_wave(-cos(theta)); //Overall amplitude modulation\n    float waveAmplitude = g_animationChannels.geometry_displacement\n                         *normalized_wave(sin(anchorPosXZ.x+anchorPosXZ.y+theta*4.0));\n    float primHeight = FLOOR_HEIGHT+overallAmplitude*waveAmplitude;\n     \n    repeatInfo outData;\n    outData.anchor = vec3(anchorPosXZ[0], primHeight, anchorPosXZ[1]);\n    outData.smpl = p;\n    \n    return outData;\n}\n\n#define zclamp(a) max(a,0.0) //Clamp negative values at zero\nfloat DF_RoundedHex( vec3 p, float width, float height)\n{\n    //Modified version (smooth edges) of the exagon prism found here:\n    //http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    float smoothRadius = g_animationChannels.geometry_smoothness*0.2;\n    width -= smoothRadius*2.0;\n    \n    //Hexagon prism constructed using X,Y,Z symmetry.\n    //Only quadrant 1 needs to be solved, but the joining diagonal to quadrant IV is also\n    //required for distance blending (see db).\n    p = abs(p);\n    \n    //Hexagonal edge distances :\n    //Note : [.8666,0.5] = [sin(PI/3,cos(PI/3)] -> Hexagon edges rotation coeff (60 degrees).\n    float da = (p.x*0.866025+p.z*0.5)-width; //quadrant I diagonal edge distance\n    float db = (p.x*0.866025-p.z*0.5)-width; //quadrant IV diagonal edge distance (needed for blending)\n    float dc = p.z-width; //upper distance\n    \n    vec3 d = zclamp(vec3(da,db,dc));\n    //Note: this is not an euclidian length, therefore this operation slightly distorts our distance field.\n    //Yet, it is harmless to convergence, and does the smoothing job quite well.\n    float dw = length(d)-smoothRadius; //hexagonal part smoothness (blending at 60 deg)\n    float dh = p.y-height;\n    \n    //Now that we have xz distance(dw) and y distance (dh), we can compute the distance \n    //for the given isovalue (the smoothing radius).\n    //Note : internal distance (maxX,maxY,maxZ) is also used to genereate internal signed dist,\n    //       helping convergence when overstepping (very frequent with domain repetition).\n    float externalDistance = length(zclamp(vec2(dh,dw)))-smoothRadius; //Smoothed, unsigned\n\tfloat internalDistance = max(max(da,dc),dh); //Sharp, signed.\n    return min(externalDistance,internalDistance);\n}\n\nstruct DF_out\n{\n    float d;\n    int matID;\n    vec3 objectPos;\n};\n    \n//The distance field composition.\n//::DF_composition\nDF_out DF_composition( in vec3 pos )\n{\n    //Explanation:\n    //http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    DF_out oFloor;\n    DF_out oHexA;\n    DF_out oHexB;\n    \n    oHexA.matID = MATERIALID_PLASTIC;\n    repeatInfo infoA = DF_repeatHex(pos-vec3(0));\n\toHexA.objectPos = infoA.anchor;\n    oHexA.d = DF_RoundedHex( infoA.smpl-vec3(0,infoA.anchor.y,0),\n\t                         g_animationChannels.geometry_width*HEX_HALF_WIDTH, PRIM_HEIGHT );\n    \n    oHexB.matID = MATERIALID_PLASTIC;\n    repeatInfo infoB = DF_repeatHex(pos-vec3(X_REPEAT_DIST*0.5,0, Z_REPEAT_DIST*0.25));\n\toHexB.objectPos = infoB.anchor;\n    oHexB.d = DF_RoundedHex( infoB.smpl-vec3(0,infoB.anchor.y,0),\n\t                         g_animationChannels.geometry_width*HEX_HALF_WIDTH, PRIM_HEIGHT );\n    \n    if(oHexA.d<oHexB.d)\n        return oHexA;\n    else\n        return oHexB;\n}\n\n//The distance field gradient\nvec3 DF_gradient( in vec3 p )\n{\n    //The field gradient is the distance derivative along each axis.\n    //The surface normal follows the direction where this variation is strongest.\n\tconst float d = 0.001;\n\tvec3 grad = vec3(DF_composition(p+vec3(d,0,0)).d-DF_composition(p-vec3(d,0,0)).d,\n                     DF_composition(p+vec3(0,d,0)).d-DF_composition(p-vec3(0,d,0)).d,\n                     DF_composition(p+vec3(0,0,d)).d-DF_composition(p-vec3(0,0,d)).d);\n\treturn grad/(2.0*d);\n}\n\n#define OVERSTEP_COMPENSATION 1\n\n//o = ray origin, d = direction, t = distance travelled along ray, starting from origin\nfloat RAYMARCH_isosurface( vec3 o, vec3 d, float isoSurfaceValue)\n{\n    //Learned from Inigo Quilez DF ray marching :\n    //http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n    //Original articles (interesting read) :\n    //Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1989)\n    //http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf\n    //John C. Hart Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)\n    //http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3825 p. 5.75-5.85\n    \n    const float tolerance = 0.0001;\n    float t = 0.0;\n    float dist = MAX_DIST;\n    #if OVERSTEP_COMPENSATION\n    for( int i=0; i<30; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance*100.0 ) break;\n        t += dist;\n    }\n    \n    t -= Z_REPEAT_DIST/2.0;\n    \n    for( int i=0; i<30; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance ) break;\n        \n        t += min(dist,Z_REPEAT_DIST/5.0);\n    }\n    #else\n    for( int i=0; i<70; i++ )\n    {\n        dist = DF_composition( o+d*t ).d;\n        dist -= isoSurfaceValue;\n        \n        if( abs(dist)<tolerance ) break;\n        t += dist;\n    }\n    #endif\n    \n    return t;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    //Variation of the Distance Field Soft Shadow from : https://www.shadertoy.com/view/Xds3zN\n    //Initialize the minimum aperture (angle tan) allowable with this distance-field technique\n    //(45deg: sin/cos = 1:1)\n    float minAperture = 1.0; \n    float t = 0.0; //initial travel distance, from geometry surface (usually, pretty close)\n    float dist = 10.0;\n    for( int i=0; i<7; i++ )\n    {\n        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance\n        float dist = DF_composition( p ).d;\n        dist = min(dist,t);\n        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        //Step size : limit range (0.02-0.42)\n        t += 0.02+min(dist,0.4);\n    }\n    \n    //The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture/coneWidth); //Should never exceed [0-1]. 0 = shadow, 1 = fully lit.\n}\n\nfloat RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)\n{\n    //Variation of DFAO from : https://www.shadertoy.com/view/Xds3zN\n    //Interesting reads:\n    //https://docs.unrealengine.com/latest/INT/Engine/Rendering/LightingAndShadows/DistanceFieldAmbientOcclusion/index.html#howdoesitwork?\n    //Implementation notes:\n    //-Doubling step size at each iteration\n    //-Allowing negative distance field values to contribute, making cracks much darker\n    //-Not reducing effect with distance (specific to this application)\n    float MaxOcclusion = 0.0;\n    float TotalOcclusion = 0.0;\n    const int nSAMPLES = 4;\n    float stepSize = 0.11/float(nSAMPLES);\n    for( int i=0; i<nSAMPLES; i++ )\n    {\n        float t = 0.01 + stepSize;\n        //Double distance each iteration (only valid for small sample count, e.g. 4)\n        stepSize = stepSize*2.0;\n        float dist = DF_composition( o+N*t ).d-isoSurfaceValue;\n        //Occlusion factor inferred from the difference between the \n        //distance covered along the ray, and the distance from other surrounding geometry.\n        float occlusion = zclamp(t-dist);\n        TotalOcclusion += occlusion;//Not reducing contribution on each iteration\n        MaxOcclusion += t;\n    }\n    \n    //Here, TotalOcclusion can actually exceed MaxOcclusion, where the rays\n    //get inside the shape and grab negative occlusion values. It does look good\n    //that way IMHO (much darker in the cracks), therefore the maximum occlusion is bumped\n    //25% to allow those cracks to get darker.\n    return saturate(1.0-TotalOcclusion/(MaxOcclusion*1.25));\n}\n\nstruct TraceData\n{\n    float rayLen;  //Ray travel distance\n    vec3  rayDir;  //Ray direction\n    float geoDist; //Distance to geometry (error on final position)\n    vec3  normal;  //Geometry normal\n    vec3  objectPos; //Object position (center)\n    int   matID;     //Material ID\n};\n    \nTraceData new_TraceData()\n{\n    TraceData td;\n    td.rayLen = 0.;\n    td.rayDir = vec3(0);\n    td.geoDist = 0.;\n    td.normal = vec3(0);\n    td.objectPos = vec3(0);\n    td.matID = MATERIALID_NONE;\n    return td;\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    return mix(c,1.3*vec3(4.5,3.5,3.0),fHDR);\n}\n\n//http://refractiveindex.info/?shelf=3d&book=liquids&page=water\nconst float F_DIELECTRIC_PLASTIC = 1.49; //@550nm\nconst float F_DIELECTRIC_WATER   = 1.33; //@550nm\nconst float F_DIELECTRIC_DIAMOND = 2.42; //@550nm\n\n//ior = index of refraction\n//n = refraction index\nvec3 PBR_Fresnel_Schlick_Dielectric(vec3 n, float VdotH)\n{\n\t//<Source : https://en.wikipedia.org/wiki/Schlick%27s_approximation>\n\tvec3 F0 = abs ((1.0 - n) / (1.0 + n));\n\treturn F0 + (1.-F0) * pow( 1. - VdotH, 5.);\n    //</Source : https://en.wikipedia.org/wiki/Schlick%27s_approximation>\n}\n\nvec3 PBR_ABL_Equation(vec3 V, vec3 L, vec3 N, float roughness, float metallic, vec3 ior_n, vec3 ior_k)\n{\n    roughness = max(roughness,0.01);\n    \n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution term\n    //This D value is an approximation of the probability for a given light to bounce into the viewing vector direction.\n\t//It is not necessarily 100% mathematically/physically correct : this is still just a function which has a curve that decently\n    //matches the physical distribution.\n    //<Source: https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = (NdotH>0.)?alpha2/(PI*den*den):0.0;\n\t//</https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    \n    //Fresnel term\n    vec3 F = PBR_Fresnel_Schlick_Dielectric(ior_n, VdotH);\n    \n    //Geometric term\n    //<Source: https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    float Gk = (roughness+1.)*(roughness+1.)/8.; //<-Disney's modification for ABL\n    float Gl = max(NdotL,0.)/(NdotL*(1.0-Gk)+Gk);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-Gk)+Gk);\n    float G = Gl*Gv;\n    //</https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf p.3/59>\n    \n    //The PBR equation seen pretty much everywhere:\n    //<Source : https://seblagarde.wordpress.com/2015/07/14/siggraph-2014-moving-frostbite-to-physically-based-rendering/ p.14>\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    float softTr = 0.2; // Valid range : [0.001-0.25]. Will reduce reflexivity on edges if too high.\n    //Personal addition : This parameter softens up the transition at grazing angles (otherwise too sharp IMHO).\n    vec3 Rs = D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n    //<Source : http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx>\n    \n\treturn Rs;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec3 MAT_Plastic(TraceData traceData, vec3 cDiff, vec3 N, vec3 V, vec3 L0, vec3 L1, float dfao, float dfss0, float dfss1)\n{\n    vec3 col = vec3(0);\n    \n    float fRoughness = g_animationChannels.material_roughness;\n    \n    //Ambient directional contribution (3x):\n    //           color*directionalContribution(<normal,ambientDir>)\n    //This give a basic \"ambient\" shading, which varies with normal angle\n    vec3 cAmb  = vec3(0.26,0.24,0.23)*vec3(0.5+0.5*dot(traceData.normal,vec3(+0.08,1,+0.1)))\n               + vec3(0.25,0.25,0.30)*vec3(0.5+0.5*dot(traceData.normal,vec3(-0.28,1,-0.17)))\n               + vec3(0.19,0.25,0.30)*vec3(0.5+0.5*dot(traceData.normal,vec3(+0.28,1,-0.27)));\n    //2 x PBR lights\n    vec3 CL0  = PBR_HDRremap(vec3(1))*PBR_ABL_Equation(V,L0,traceData.normal, fRoughness, 0., vec3(F_DIELECTRIC_PLASTIC), vec3(0));\n    vec3 CL1  = PBR_HDRremap(vec3(1))*PBR_ABL_Equation(V,L1,traceData.normal, fRoughness, 0., vec3(F_DIELECTRIC_PLASTIC), vec3(0));\n    \n    col = cAmb*dfao;\n    col *= saturate(0.30+fRoughness*0.5+0.2*(dfss0+dfss1));\n    col += (dfss0+fRoughness*0.25)*CL0;\n    col += (dfss1+fRoughness*0.25)*CL1;\n    \n    return col*0.75;\n}\n\nfloat SAMPLER_trilinear(vec3 p)\n{\n    //Noise layering trick from Inigo Quilez.\n    //See this for more explanation: https://www.shadertoy.com/view/Ms3SRr\n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    p *= TEXTURE_RES;   //Computation in pixel space (1 unit = 1 pixel)\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    vec3 t = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)\n    t = (3.0 - 2.0 * t) * t * t; //interpolant easing function : linear->cubic\n    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).\n    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)/TEXTURE_RES,-100.0).xy; //Note : +0.5 to fall right on pixel center\n    return mix( layer1_layer2.x, layer1_layer2.y, t.y ); //Layer interpolation (trilinear/volumetric)\n}\n\nfloat MAT_remap_angle_probability(float x_01)\n{\n    //cos(jitter) is used to alter probabilty distribution : \n    //it remaps an evenly distributed function into another \n    //one where closer angles are more probable, and wider\n    //angles are less probable.\n    return (1.0-cos(x_01*PI/2.0));\n}\n\nvec3 MAT_addFog(float travelDist, in vec3 color, in vec3 p, in vec3 c_atmosphere)\n{\n    float a = 0.08;\n    float NORMALIZATION_TERM = log((1.+a)/a);\n    float da = travelDist/50.0;\n    da = log((da+a)/a)/NORMALIZATION_TERM;\n    vec3 FinalColor = mix(color,c_atmosphere,saturate(da));\n    return FinalColor;\n}\n\n//::MAT_apply\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    vec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*pos.y/length(pos.xz),0.,1.));\n    \n    if(traceData.matID==MATERIALID_SKY)\n    {\n        return vec4(c_atmosphere,1.0);\n    }\n    \n    vec4 col = vec4(0);\n    vec3 N = traceData.normal;\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 L0 = normalize(vec3(0.5,1.2,0.3));\n    vec3 L1 = normalize(vec3(-L0.x,L0.y,-L0.z+0.5));\n    \n    //<Jittered AO Samples around Y axis, to reduce artifacts associated with closely repeated geometry>\n    float fNoiseAmplitude = 0.4;\n    float jitter_01 = SAMPLER_trilinear(pos*10.0+g_time*50.0);\n    float t = MAT_remap_angle_probability(jitter_01)*fNoiseAmplitude;\n    vec3 Na = vec3(N.xz*mat2(cos(t),sin(t),-sin(t),cos(t)),N.y).xzy; //Rotate(t)\n    jitter_01 = SAMPLER_trilinear(5.0+pos*9.11);\n    t = MAT_remap_angle_probability(jitter_01)*fNoiseAmplitude;\n    vec3 Nb = vec3(N.xz*mat2(cos(t),-sin(t),sin(t),cos(t)),N.y).xzy; //Rotate(-t)\n    float dfaoA = RAYMARCH_DFAO( pos, Na, 0.02);\n    float dfaoB = RAYMARCH_DFAO( pos, Nb, 0.02);\n    float dfaoAveraged = 0.5*(dfaoA+dfaoB);\n    //</Jittered AO Samples>\n    \n    float dfss0 = RAYMARCH_DFSS( pos+L0*0.01, L0, 0.2);\n    float dfss1 = RAYMARCH_DFSS( pos+L1*0.01, L1, 0.2);\n    \n    if(traceData.matID==MATERIALID_PLASTIC)\n    {\n        col.rgb = MAT_Plastic(traceData, vec3(1), N, V, L0, L1, dfaoAveraged, dfss0, dfss1);\n    }\n    \n    col.rgb = MAT_addFog(traceData.rayLen*0.3, col.rgb, pos, c_atmosphere);\n    \n    return col;\n}\n\nfloat TRACE_zprime(vec3 o, vec3 d)\n{\n    float geometryCeiling = FLOOR_HEIGHT+PRIM_HEIGHT\n\t                       +g_animationChannels.geometry_displacement*GEOMETRY_DISPLACEMENT;\n    float t = RAYINTERSEC_plane(o, d, vec3(0,geometryCeiling,0), vec3(0,1,0));\n    return (t<0.0)?MAX_DIST:t;\n    return t;\n}\n\n//o=ray origin, d=ray direction\n//::TRACE_geometry\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    //Raymarching (the expensive function)\n    TraceData dfTrace;\n    float rayLen = RAYMARCH_isosurface(o,d,0.0);\n    vec3 dfHitPosition = o+rayLen*d;\n    \n    //Additional sample, to gather material ID and other info\n    //(we want that stuff coompiled out of the raymarching loop, it clutters the code and might slow things down)\n    DF_out compInfo = DF_composition( dfHitPosition );\n    rayLen += compInfo.d;\n    dfHitPosition = o+rayLen*d;\n        \n    dfTrace.rayLen     = rayLen;\n    dfTrace.matID      = compInfo.matID;\n    dfTrace.objectPos  = compInfo.objectPos;\n    dfTrace.geoDist    = compInfo.d;\n    dfTrace.rayDir     = d;\n    dfTrace.normal     = normalize(DF_gradient(dfHitPosition));\n    \n    return dfTrace;\n}\n\nvec3 TRACE_debug(TraceData traceData, int elemID)\n{\n    if(elemID==DEBUG_RAYLEN)  return vec3(log(traceData.rayLen)*0.2);\n    if(elemID==DEBUG_GEODIST) return vec3(traceData.geoDist);\n    if(elemID==DEBUG_NORMAL)  return traceData.normal;\n    if(elemID==DEBUG_MATID)   return traceData.matID==MATERIALID_PLASTIC?vec3(1):\n                                     vec3(traceData.matID==MATERIALID_FLOOR?1:0,\n                                          traceData.matID==MATERIALID_METAL?1:0,\n                                          traceData.matID==MATERIALID_SKY?1:0);\n    return vec3(0);\n}\n\nconst int SPLINE_POINT_COUNT = 8;\nstruct SPLINE_CtrlPts\n{\n    vec4 p[SPLINE_POINT_COUNT];\n};\nvec4 SPLINE_PointArray(int i, SPLINE_CtrlPts ctrlPts)\n{\n    //Just a way to get around the fact global arrays do not support random index access.\n    //(only texture/resources)\n    if(i==0 || i==SPLINE_POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==SPLINE_POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==SPLINE_POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec4(0);\n}\n\nvec4 SPLINE_catmullRom(float fTime, SPLINE_CtrlPts ctrlPts)\n{\n    float t = fract(fTime);\n    const float n = float(SPLINE_POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec4 p1 = SPLINE_PointArray(idxOffset,ctrlPts);\n    vec4 p2 = SPLINE_PointArray(idxOffset+1,ctrlPts);\n    vec4 p3 = SPLINE_PointArray(idxOffset+2,ctrlPts);\n    vec4 p4 = SPLINE_PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec4 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nvoid ANIM_main(float fTime)\n{\n    float t1 = 0.010*fTime;\n    float t2 = 0.010*fTime+0.03;\n    \n    SPLINE_CtrlPts cameraPosKeyFrames; //100 sec cycle.\n    //                    DATA: PosX,PosY,PosZ,Tilt\n    cameraPosKeyFrames.p[1] = vec4(10.0,2.70,05.0,1.90); //t=00.0s\n    cameraPosKeyFrames.p[2] = vec4(16.0,3.30,08.5,1.00); //t=12.5s\n    cameraPosKeyFrames.p[3] = vec4(20.0,6.80,05.0,2.97); //t=25.0s\n    cameraPosKeyFrames.p[4] = vec4(40.0,3.40,17.5,0.82); //t=37.5s\n    cameraPosKeyFrames.p[5] = vec4(30.0,3.10,27.5,1.97); //t=50.0s\n    cameraPosKeyFrames.p[6] = vec4(25.0,3.20,22.5,1.93); //t=62.5s\n    cameraPosKeyFrames.p[7] = vec4(15.0,3.00,24.5,1.95); //t=75.0s\n    cameraPosKeyFrames.p[0] = vec4(05.0,2.80,12.5,1.20); //t=87.5s\n    vec4 cameraPos = SPLINE_catmullRom(t1,cameraPosKeyFrames);\n    vec4 cameraDir = normalize(SPLINE_catmullRom(t2,cameraPosKeyFrames)-cameraPos);\n        \n    SPLINE_CtrlPts geometryKeyFrames; //25 sec cycle.\n    //                      DATA: round,width,roughness,displacement\n\tgeometryKeyFrames.p[1] = vec4(0.070,1.000,0.30,1.000); //t=00.0s\n    geometryKeyFrames.p[2] = vec4(0.090,0.900,0.50,0.900); //t=01.25s\n    geometryKeyFrames.p[3] = vec4(0.080,1.000,0.20,1.000); //t=02.50s\n    geometryKeyFrames.p[4] = vec4(0.150,0.970,0.50,0.990); //t=03.75s\n    geometryKeyFrames.p[5] = vec4(0.090,0.820,0.50,0.820); //t=05.00s\n    geometryKeyFrames.p[6] = vec4(0.110,0.970,0.50,0.990); //t=06.25s\n    geometryKeyFrames.p[7] = vec4(0.050,0.930,0.50,0.930); //t=07.50s\n    geometryKeyFrames.p[0] = vec4(0.120,0.950,0.50,0.980); //t=08.75s\n    vec4 geoPose = SPLINE_catmullRom(t1*25.0,geometryKeyFrames);\n    \n    g_animationChannels.camPos    = cameraPos.xyz;\n    g_animationChannels.camLookAt = cameraPos.xyz+cameraDir.xyz-vec3(0,cameraPos.w,0);\n    g_animationChannels.geometry_smoothness = geoPose[0];\n    g_animationChannels.material_roughness = 0.45;\n    g_animationChannels.geometry_width = geoPose[1];\n    g_animationChannels.geometry_displacement = GEOMETRY_DISPLACEMENT;\n}\n\nvec3 TRACE_main( vec3 o, vec3 dir, vec2 uv)\n{ \n    float fRemainingAlpha = 1.0;\n    float zStart = TRACE_zprime(o, dir);\n    vec3 pt = o+dir*zStart;\n    vec3 ptGeo = vec3(0);\n    \n    TraceData geometryTraceData;\n    if(zStart< MAX_DIST)\n    {\n        geometryTraceData = TRACE_geometry(pt, dir);\n        geometryTraceData.rayLen += zStart;\n        ptGeo = o+dir*geometryTraceData.rayLen;\n    }\n    else\n    {\n        geometryTraceData.rayLen     = MAX_DIST;\n    \tgeometryTraceData.matID      = MATERIALID_SKY;\n    \tgeometryTraceData.objectPos  = pt;\n    \tgeometryTraceData.geoDist    = 0.0;\n    \tgeometryTraceData.rayDir     = dir;\n        ptGeo = pt;\n    }\n    \n    //return TRACE_debug(geometryTraceData, DEBUG_RAYLEN);  //OK\n    //return TRACE_debug(geometryTraceData, DEBUG_GEODIST); //OK\n    //return TRACE_debug(geometryTraceData, DEBUG_NORMAL);  //OK\n    //return TRACE_debug(geometryTraceData, DEBUG_MATID);   //OK\n    \n    vec4 cFinal = MAT_apply(ptGeo,geometryTraceData);\n        \n    return cFinal.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_time = iTime+2.6; //Time offset for better preview\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    \n    float fTime = g_time+2.1;\n    ANIM_main(fTime);\n    \n    Cam cam = CAM_animate(uv,fTime);\n    vec3 d = CAM_getRay(cam,uv);\n    vec3 c = TRACE_main(cam.o, d, uv);\n    \n    //No supersampling required for most PostProcessFX.\n    c = POST_ProcessFX(c,uv);\n    \n    fragColor = vec4(c,1.0);\n}\n\nvec3 POST_ProcessFX(vec3 c, vec2 uv)\n{\n    //Vignetting\n    float lensRadius = 0.65;\n    uv /= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    //Gamma\n    c = pow(c,vec3(0.4545));\n    return c;\n}\n\n//----------------------\n// Camera\n//::CAM\nCam CAM_animate(vec2 uv, float fTime)\n{\n    Cam cam;\n    cam.o = g_animationChannels.camPos;\n    cam.D = normalize(g_animationChannels.camLookAt-cam.o);\n\tcam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = normalize(cross(cam.R,cam.D));\n    cam.lens = 1.2+0.3*sin(fTime*0.1);\n    cam.zoom = 3.0+sin(fTime*0.1)/cam.lens;\n\treturn cam;\n}\n\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv = cam.lens*uv/(cam.lens-length(uv)*length(uv));\n    uv *= cam.zoom;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcXzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddXW4", "name": "I'm in ur raymarcher, bein dumb", "author": "EATDRINKFUCK", "description": "Watch me defile your stuff.", "tags": ["raymarching"], "likes": 0, "viewed": 153, "date": "1459458156", "time_retrieved": "2024-06-20T18:33:56.696254", "image_code": "/*\na shader executes per pixel\nso every thing you see here is he function for every pixel\n\nraymarching is in principe a function that finds the closest point to any surface in the world\nthen we move our point by that distance and use the same function,\nthe function will probably be closer to an object in the world every time\nand after about 40 to 200 iterations you'll either have found an object or\nmissed them all into infinity\n\nraymarching is not raytracing, a raytracer intersects the world in 1 function\nwhen marching the 'scene' function only computes the distance to the current ray 'position'\nit does not know which direction we are moving, the main loop moves the ray instead\n\nthis is much cheaper because intersection maths are not hardware supported in a GPU\n*/\n\n// these constants are used throughout the shader, \n// they can be altered to avoid glitches or optimize the framerate,\n// their meaning can best be seen in context below\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 400\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.4\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat hash( float n ) \n{ \n    return fract(sin(n)*753.5453123);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n//--------------------------------------------------------------------------------------------------//\n//\t\t\t\t\t\t\t\t\t\t\t\tSCENE\t\t\t\t\t\t\t\t\t\t\t\t//\n//--------------------------------------------------------------------------------------------------//\n\nvec2 scene(vec3 position)\n{\n\tif (iTime < 5.0)\n\t{\n        /*\n        This function generates a distance to the given position\n        The distance is the closest point in the world to that position\n        */\n        // to move the sphere one unit forward, we must subtract that translation from the world position\n        vec3 translate = vec3(0.0, -0.5, 1.0);\n        float distance = sdBox(position - translate, vec3(0.5, 0.5, 0.5));\n        float materialID = 1.0;\n\n        translate = vec3(0.0, 0.5, 1.0);\n        // A power of raymarching is tiling, we can modify the position in any way we want\n        // leaving the shape as is, creating various results\n        // So let's tile in X with a sine wave offset in Y!\n        vec3 box_pos = position - translate;\n        // Because our sphere starts at 0 just tiling it would cut it in half, with\n        // the other half on the other side of the tile. SO instead we offset it by 0.5\n        // then tile it so it stays in tact and then do -0.5 to restore the original position.\n        // When tiling by any tile size, offset your position by half the tile size like this!\n        box_pos.x = fract(box_pos.x + 0.5) - 0.5; // fract() is mod(v, 1.0) or in mathemathical terms x % 1.0\n        box_pos.z = fmod(box_pos.z + 1.0, 1.0) - 1.0; // example without fract\n        // now let's animate the height!\n        box_pos.y += sin(position.x + iTime) * 0.35; //add time to animate, multiply by samll number to reduce amplitude\n        box_pos.y += cos(position.z + iTime);\n        float distance2 = sdBox(box_pos, vec3(0.75,0.05,0.25));\n        float materialID2 = 2.0; // the second sphere should have another colour\n\n    \t// to combine two objects we use the minimum distance\n    \tif(distance2 < distance)\n    \t{\n    \t    distance = distance2;\n        \tmaterialID = materialID2;\n    \t}\n\n    \t// we return a vec2 packing the distance and material of the closes object together\n    \treturn vec2(distance, materialID);\n    \n\t}\n    if (iTime < 10.0)\n    {\n        //Scene 2 - Accidental fractally thing\n        float size = -0.001; \n        size -= (0.0005 * iTime);\n        vec3 translate = vec3(hash(0.1),hash(0.2),hash(0.1));\n        vec3 box_pos1 = position - translate;\n        \n        pMod3(box_pos1,vec3(size));\n        \n        float cube = sdBox(box_pos1, vec3(size));\n        float materialID = 1.0;\n        \n        float distance = cube;\n        \n        return vec2(distance, materialID);\n    }\n    if (iTime < 20.0)\n    {\n        //Scene 3 - Starchild\n        float size = 3.0;\n        vec3 box_pos1 = position;    \n        \n        vec3 cell = pMod3(box_pos1,vec3(size));\n        \n        box_pos1.y += (box_pos1.x * (iTime/4.0));\n        box_pos1.x += (box_pos1.y * (iTime/4.0));\n        box_pos1.z += (box_pos1.y * (iTime/4.0));\n        \n        float cube = sdBox(box_pos1, vec3(0.25, 0.25, 0.25));\n        float materialID = 2.0;\n        \n        float distance = cube;\n        \n        return vec2(distance, materialID);\n    }\n     if (iTime < 20.5)\n    {\n        //BLACK\n        float distance = 0.0;\n        float materialID = 1.0;\n        return vec2(distance, materialID);\n    }\n     if (iTime < 28.0)\n    {\n        //Scene 4 - Intro to cubes\n        float size = 1.5;\n \n        vec3 translate = vec3(1.5,-2.0,-2.0);\n        vec3 box_pos = position - translate;\n        \n        vec3 rotation = box_pos;\n        pR(rotation.xz, (iTime / 6.0));\n        pR(rotation.yz, (iTime / 4.0));\n   \t\tpR(rotation.xy, (iTime / 3.0));\n        \n        float cube = sdBox(rotation, vec3(size));\n        float materialID = 2.0;\n        \n        float distance = cube;\n        \n        return vec2(distance, materialID);\n    }\n    if (iTime < 35.0)\n    {\n        //Scene 5 - work goddammit work (Asteroids inspired by Trevke)\n        float spacing = 4.0;\n    \tvec3 translate1 = vec3(0.5, -0.25, 0.0);\n    \tvec3 translate2 = vec3(0.2, -0.2, -0.75);\n        vec3 box_size1 = vec3(0.25, 0.25, 0.25);\n    \tvec3 box_size2 = vec3(0.02, 0.02, 0.02);\n        vec3 box_pos1 = position - translate1;\n    \tvec3 box_pos2 = position - translate2;\n        \n        vec3 cell1 = pMod3(box_pos1,vec3(spacing));\n    \tvec3 cell2 = pMod3(box_pos2, vec3(spacing - 2.0));\n        \n        box_pos1.x += hash(cell1.x * (hash(cell1.y) + (hash(cell1.z) * 1.0)));\n        box_pos1.y += hash(cell1.y * (hash(cell1.x) + (hash(cell1.y) * 2.0)));\n        box_pos1.z += hash(cell1.z * (hash(cell1.x) + (hash(cell1.x) * 1.0)));\n    \n    \tbox_pos2.x += hash(cell2.x);\n        box_pos2.y += hash(cell2.y);\n        box_pos2.z += hash(cell2.z);\n        \n        box_size1.x -= hash((cell1.y / 3.0) + cell1.x);\n        box_size1.y -= hash((cell1.z / 3.0) + cell1.y);\n        box_size1.z -= hash((cell1.x / 3.0) + cell1.z);\n    \n    \tbox_size2.x -= hash(cell2.y);\n        box_size2.y -= hash(cell2.z);\n        box_size2.z -= hash(cell2.x);\n\n        vec3 rotation1 = box_pos1;\n        pR(rotation1.xz, ((iTime / 8.0) + (cell1.z * (cell1.z * -1000.0))));\n        pR(rotation1.yz, ((iTime / 6.0) + (cell1.y * (cell1.y * -1000.0))));\n   \t\tpR(rotation1.xy, ((iTime / 5.0) + (cell1.x * (cell1.x * -1000.0))));\n    \n    \tvec3 rotation2 = box_pos2;\n        pR(rotation2.xz, ((iTime / 1.0) + ((cell2.z * (cell2.z * 4.0))) * -1.0));\n        pR(rotation2.yz, ((iTime / 2.0) + ((cell2.y * (cell2.y * 8.0))) * -1.0));\n   \t\tpR(rotation2.xy, ((iTime / 5.0) + ((cell2.x * (cell2.x * 5.0))) * -1.0));\n        \n        float cube1 = sdBox(rotation1, box_size1);\n        float materialID1 = 2.0;\n    \n    \tfloat cube2 = sdBox(rotation2, box_size2);\n        float materialID3 = 1.0;\n        \n    \tfloat distance = cube1;\n        \n    \tif(cube2 < distance)\n    \t{\n    \t    distance = cube2;\n        \tmaterialID1 = materialID3;\n    \t}\n        \n        \n        return vec2(distance, materialID1);\n    }\n    if (iTime < 45.0)\n    {\n        //Scene 6 - More asteroids inspired by Trevonicus\n        float spacing = 4.0;\n    \tvec3 translate1 = vec3(-0.5, 0.5, -0.5);\n    \tvec3 translate2 = vec3(-1.5, -0.5, -0.75);\n        vec3 box_size1 = vec3(0.25, 0.25, 0.25);\n    \tvec3 box_size2 = vec3(0.02, 0.02, 0.02);\n        vec3 box_pos1 = position - translate1;\n    \tvec3 box_pos2 = position - translate2;\n        \n        vec3 cell1 = pMod3(box_pos1,vec3(spacing));\n    \tvec3 cell2 = pMod3(box_pos2, vec3(spacing - 2.0));\n        \n        box_pos1.x += hash(cell1.x * (hash(cell1.y) + (hash(cell1.z) * 1.0)));\n        box_pos1.y += hash(cell1.y * (hash(cell1.x) + (hash(cell1.y) * 2.0)));\n        box_pos1.z += hash(cell1.z * (hash(cell1.x) + (hash(cell1.x) * 1.0)));\n    \n    \tbox_pos2.x += (hash(cell2.x) * hash(cell2.y));\n        box_pos2.y += (hash(cell2.y) * hash(cell2.z));\n        box_pos2.z += (hash(cell2.z) * hash(cell2.x));\n        \n        box_size1.x = hash((cell1.y * 2.0));\n        box_size1.y = hash((cell1.z * 2.0));\n        box_size1.z = hash((cell1.x * 2.0));\n    \n    \tbox_size2.x -= (hash(cell2.y) * 0.1);\n        box_size2.y -= (hash(cell2.z) * 0.1);\n        box_size2.z -= (hash(cell2.x) * 0.1);\n\n        vec3 rotation1 = box_pos1;\n        pR(rotation1.xz, ((iTime / 8.0) + (cell1.z * (cell1.z * -1000.0))));\n        pR(rotation1.yz, ((iTime / 6.0) + (cell1.y * (cell1.y * -1000.0))));\n   \t\tpR(rotation1.xy, ((iTime / 5.0) + (cell1.x * (cell1.x * -1000.0))));\n    \n    \tvec3 rotation2 = box_pos2;\n        pR(rotation2.xz, ((iTime / 1.0) + ((cell2.z * (cell2.x * 4.0))) * -1.0));\n        pR(rotation2.yz, ((iTime / 2.0) + ((cell2.y * (cell2.z * 8.0))) * -1.0));\n   \t\tpR(rotation2.xy, ((iTime / 5.0) + ((cell2.x * (cell2.y * 5.0))) * -1.0));\n        \n        float cube1 = sdBox(rotation1, box_size1);\n        float materialID1 = 2.0;\n    \n    \tfloat cube2 = sdBox(rotation2, box_size2);\n        float materialID3 = 1.0;\n        \n    \tfloat distance = cube1;\n        \n    \tif(cube2 < distance)\n    \t{\n    \t    distance = cube2;\n        \tmaterialID1 = materialID3;\n    \t}\n        \n        \n        return vec2(distance, materialID1);\n    }\n    if (iTime < 5000.0)\n    {\n        \n    }\n    \n    return vec2(0.0,0.0);\n}\n\n\n\n\n//--------------------------------------------------------------------------------------------------//\n//\t\t\t\t\t\t\t\t\t\t\tRENDERING\t\t\t\t\t\t\t\t\t\t\t\t//\n//--------------------------------------------------------------------------------------------------//\n\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    /*\n\tThis function iteratively analyses the scene to approximate the closest ray-hit\n\t*/\n    // We track how far we have moved so we can reconstruct the end-point later\n    float total_distance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec2 result = scene(position + direction * total_distance);\n        // If our ray is very close to a surface we assume we hit it\n        // and return it's material\n        if(result.x < EPSILON)\n        {\n            return vec2(total_distance, result.y);\n        }\n        \n        // Accumulate distance traveled\n        // The result.x contains closest distance to the world\n        // so we can be sure that if we move it that far we will not accidentally\n        // end up inside an object. Due to imprecision we do increase the distance\n        // by slightly less... it avoids normal errors especially.\n        total_distance += result.x * DISTANCE_BIAS;\n        \n        // Stop if we are headed for infinity\n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    // By default we return no material and the furthest possible distance\n    // We only reach this point if we didn't get close to a surface during the loop above\n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Given the pixel X, Y coordinate and the resolution we can get 0-1 UV space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Our rays should shoot left and right, so we move the 0-1 space and make it -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Last we deal with an aspect ratio in the window, to make sure our results are square\n    // we must correct the X coordinate by the stretching of the resolution\n    uv.x *= iResolution.x / iResolution.y;\n    // Now to conver the UV to a ray we need a camera origin, like 0,0,0; and a direction\n    // We can use the -1 to 1 UVs as ray X and Y, then we make sure the direction is length 1.0\n    // by adding a Z component. Code blow is just an example:\n    //float sqr_length = dot(uv, uv);\n    //vec3 direction = vec3(uv, sqrt(1.0 - sqr_length));\n    \n    // a shorter and easier way is to create a vec3 and normalise it, \n    // we can manually change the Z component to change the final FOV; \n    // smaller Z is bigger FOV\n    vec3 direction = normalize(vec3(uv, 2.5));\n    // if you rotate the direction with a rotatin matrix you can turn the camera too!\n    \n    vec3 camera_origin = vec3(0.0, 0.0, -2.5); // you can move the camera here\n    \n    vec2 result = raymarch(camera_origin, direction); // this raymarches the scene\n    \n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    // now let's pick a color\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n        materialColor = vec3(1.0, 0.25, 0.1);\n    }\n    if(result.y == 2.0)\n    {\n       \tmaterialColor = vec3(0.7, 0.7, 0.7);\n    }\n    \n    // We can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result.x;\n    \n    // The normals can be retrieved in a fast way\n    // by taking samples close to the end-result sample\n    // their resulting distances to the world are used to see how the surface curves in 3D\n    // This math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    // Lambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    // Wrap the lighting around\n    // https://developer.valvesoftware.com/wiki/Half_Lambert\n    diffuse = diffuse * 0.5 + 0.5;\n    // For real diffuse, use this instead (to avoid negative light)\n    //diffuse = max(0.0, diffuse);\n    \n    // Combine ambient light and diffuse lit directional light\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}\n\n/*\nNow that was pretty complex.\nI have omitted transparency and volumetric objects\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdGGDt", "name": "pendelversch", "author": "cardmechanic", "description": "sad", "tags": ["df"], "likes": 0, "viewed": 98, "date": "1457190791", "time_retrieved": "2024-06-20T18:33:56.702301", "image_code": "struct Rect {\n\tvec2 pos,\n         ext;\n    mat2 kord;\n    vec4 col;\n\n};\n\n    \nRect \n     R1 = Rect ( vec2(0.), vec2 (1.,1.), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R5 = Rect ( vec2(0.), vec2 (2.,2.), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R6 = Rect ( vec2(0.), vec2 (2.,2.), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R7 = Rect ( vec2(0.), vec2 (2.,2.), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R9 = Rect ( vec2(-1.45,0.), vec2 (.5,.5), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R10 = Rect ( vec2(-1.45,0.), vec2 (.5,.5), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R4 = Rect ( vec2(0.), vec2 (.5,.7), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n     R3 = Rect ( vec2(0., -.15), vec2 (.2,.2), mat2 (1.,0.,0.,1.), vec4 (-.2,-.2,-.2,4.)),\n     R8 = Rect ( vec2(.6*sin(iDate.a/30.*3.14),.6*cos(iDate.a/30.*3.14)), vec2 (.2,.2), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.)),\n   \t R2 = Rect ( vec2(0., -.15), vec2 (.4,.7), mat2 (1.,0.,0.,1.), vec4 (.9,.99,.80,4.));\n \t\n\n\n\nmat2 Rota (in float alpha){\n\tfloat s = sin(alpha),\n          c = cos(alpha);\n    \n   return mat2 (c, -s, s, c);\n\n}\n\n\nvoid Rotarect (in float alpha, inout Rect r_p){\n    \n    r_p.kord = Rota (alpha) * r_p.kord;\n\n\n}\n\n\n\n\nvec4 intersec (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    }\n    \t\n     if (mat.x*mat.x+mat.y*mat.y < .008)\n          return vec4(0.);\n     if (mat.x*mat.x+mat.y*mat.y < .02)\n          return reco.col + vec4(p_uv.x,p_uv.y, p_uv.y+p_uv.x,1.);\n     if (abs(mat.x) <.5*reco.ext.x && mat.y >.0 ){\n       \n\t\t\n       \t if (mat.x + mat.y <.4 && -mat.x + mat.y < .4)\n                return vec4(0.);\n         if ( mat.x + mat.y <.5 && -mat.x + mat.y < .5)\n                return reco.col + vec4(p_uv.x,p_uv.y, p_uv.y+p_uv.x,1.);}\n        return vec4(0.);\n}\n\n\nvec4 intersec2 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if (abs(mat.x) >0.5 || mat.y >1.*reco.ext.y || mat.y <0.) {\n        return vec4 (0.);\n    }\n    if (abs(mat.x) <.04*reco.ext.x && mat.y <.89*reco.ext.y && mat.y >.05*reco.ext.y)\n        return vec4 (.0);\n    if (abs(mat.x) <0.09*reco.ext.x  && mat.y < 9.*reco.ext.y && mat.y >0.){\n            return reco.col + vec4(p_uv.x,p_uv.y, p_uv.y+p_uv.x,1.);\n    }\n   \n        \n\t\n    return vec4(0.);\n\n}\n\nvec4 intersec3 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y) \n        return vec4 (0.);\n    \n           if (mat.x*mat.x + mat.y*mat.y <.002)\n          \n               return R2.col;\n    \n    return vec4(0.);\n}\n\nvec4 intersec4 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    }\n    \t\n   if (mat.x + mat.y <.23 && -mat.x + mat.y < .23)\n                return vec4(0.);\n         if ( mat.x + mat.y <.28 && -mat.x + mat.y < .28)\n                return reco.col + vec4(p_uv.x,p_uv.y, p_uv.y+p_uv.x,1.);\n        return vec4(0.);\n     \n       \t \n}\n\nvec4 intersec5 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y){\n        return vec4 (0.);\n    }\n    \t\n  \tif (abs(mat.x) <.01*reco.ext.x && mat.y >.4*reco.ext.y && mat.y < .46*reco.ext.y)\n        return reco.col;\n    if (abs(mat.x) <.01*reco.ext.x && mat.y <-.4*reco.ext.y && mat.y > -.46*reco.ext.y)\n        return reco.col ;\n     if (mat.x <.46*reco.ext.x && mat.x >.4*reco.ext.x && abs(mat.y) <.01*reco.ext.y)\n        return reco.col ;\n     if (mat.x >-.46*reco.ext.x && mat.x <-.4*reco.ext.x && abs(mat.y) <.01*reco.ext.y)\n        return reco.col ;\n       return vec4(0.); \n}\n\n\nvec4 intersec6 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if ( abs(mat.x) >.5*reco.ext.x || abs(mat.y) >.5*reco.ext.y) \n        return vec4 (0.);\n    \n    \tif (mat.x*mat.x + mat.y*mat.y >.0005)\n    \n           if (mat.x*mat.x + mat.y*mat.y <.002)\n          \n                return reco.col + vec4(p_uv.x,p_uv.y, p_uv.y+p_uv.x,1.);\n    \n    return vec4(0.);\n}\n\nvec4 intersec7 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if (abs(mat.x) >0.5 || abs(mat.y) >.5*reco.ext.y ) {\n        return vec4 (0.);\n    }\n    if (mat.x  >- 0.4*reco.ext.x && mat.x < -0.2*reco.ext.x && mat.y >.1*reco.ext.y && mat.y <.3*reco.ext.y ) \n        return vec4(0.) ;\n    if (mat.x  >- 0.4*reco.ext.x && mat.x < -0.1*reco.ext.x && mat.y <-.0*reco.ext.y && mat.y >-.5*reco.ext.y ) \n        return vec4(.5-.1*p_uv.x,.25+.1*p_uv.y,.75+.1*p_uv.x-.1*p_uv.y,.1);\n   \n\tif (mat.x  >- 0.5*reco.ext.x && mat.x < -0.1*reco.ext.x && abs(mat.y) <.4*reco.ext.y ) \n        return reco.col-vec4(mat,mat);\n   \n   if (mat.x  > -.025*reco.ext.x && mat.x < 0.075*reco.ext.x && mat.y <-.3*reco.ext.y && mat.y >-.4*reco.ext.y ) \n        return reco.col-vec4(mat,mat);\n   \n    if  (mat.x >.2625*reco.ext.x && mat.x <.3125*reco.ext.x && mat.y <.3*reco.ext.y && mat.y > -.4*reco.ext.y)\n        return vec4(0.);\n    if  (mat.x >.375*reco.ext.x && mat.x <.425*reco.ext.x && mat.y <.3*reco.ext.y && mat.y > -.4*reco.ext.y)\n        return vec4 (0.);\n    if (mat.x >.175*reco.ext.x && mat.x <.5*reco.ext.x && mat.y >-.4*reco.ext.y && mat.y < .4*reco.ext.y)\n         return reco.col-vec4(mat,mat);\n        \n\t\n    return vec4(0.);\n\n}\n\nvec4 intersec8 (in vec2 p_uv, in Rect reco){\n\tvec2 xynew = p_uv - reco.pos;\n    vec2 mat = reco.kord * xynew;\n\t\n    if (abs(mat.x) >0.5 || abs(mat.y) >.5*reco.ext.y ) {\n        return vec4 (0.);\n    }\n    if (mat.x  >- 0.4*reco.ext.x && mat.x < -0.2*reco.ext.x && mat.y >.1*reco.ext.y && mat.y <.3*reco.ext.y ) \n        return vec4(0.) ;\n    if (mat.x  >- 0.4*reco.ext.x && mat.x < -0.2*reco.ext.x && mat.y <-.0*reco.ext.y && mat.y >-.5*reco.ext.y ) \n        return vec4(0.) ;\n   \n\tif (mat.x  >- 0.5*reco.ext.x && mat.x < -0.1*reco.ext.x && abs(mat.y) <.4*reco.ext.y ) \n        return reco.col-vec4(mat,mat) ;\n   \n    if (mat.x  > -.025*reco.ext.x && mat.x < 0.075*reco.ext.x && mat.y <-.3*reco.ext.y && mat.y >-.4*reco.ext.y ) \n        return reco.col-vec4(mat,mat) ;\n   \n    if  (mat.x >.2625*reco.ext.x && mat.x <.3125*reco.ext.x && mat.y <.3*reco.ext.y && mat.y > -.4*reco.ext.y)\n        return vec4 (0.);\n    if  (mat.x >.375*reco.ext.x && mat.x <.425*reco.ext.x && mat.y <.3*reco.ext.y && mat.y > -.4*reco.ext.y)\n        return vec4 (0.);\n    if (mat.x >.175*reco.ext.x && mat.x <.5*reco.ext.x && mat.y >-.4*reco.ext.y && mat.y < .4*reco.ext.y)\n         return reco.col-vec4(mat,mat) ;\n        \n\t\n    return vec4(0.);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy-0.5)*vec2 ( iResolution.x/iResolution.y, 1.);\n\tfragColor = vec4(0.);\n    \n    float h = iDate.a/(3600.);\n    float m = iDate.a/(60.);\n    float a = sin(3.14*iTime);\n    \n    if (a < 0.){\n        Rotarect (3.14*iTime-3.14/2., R2);\n    }\n     else   Rotarect(-3.14*iTime-3.14/2.,R2);\n    \n    \n    Rotarect (-(m/30.)*3.14, R1);\n    \n        if (h < 11.){\n        Rotarect (-((h-12.)/6.)*3.14, R4);\n    }\n     else   Rotarect (-(h/6.)*3.14, R4);\n    \n  \n\n\tRotarect (3.14/3., R6);\n    Rotarect (3.14/6., R7);\n   \n    vec4 r1col;\n    if (h<11.999999){\n    r1col = intersec (uv,R1) + intersec2 (uv, R2)+ intersec3 (uv, R3)+intersec4(uv,R4)+ intersec5(uv,R5)+intersec5(uv,R6)+intersec5(uv,R7)+intersec6(uv, R8)+intersec8(uv,R10);\n    }\n    else \n    r1col = intersec (uv,R1) + intersec2 (uv, R2)+ intersec3 (uv, R3)+intersec4(uv,R4)+ intersec5(uv,R5)+intersec5(uv,R6)+intersec5(uv,R7)+intersec6(uv, R8)+intersec7(uv,R9);\n    ;\n    \n    if (r1col.a < 1.){\n        fragColor = vec4(.5-.21*uv.x,.35+.05*uv.y,.35+.2*uv.x-.1*uv.y,.1);\n    \t\n    }\n        else  \n           \n            if ( h < 11.99999){\n   fragColor = intersec (uv,R1)  + intersec2 (uv, R2) + intersec3 (uv,R3)+intersec4 (uv, R4)+intersec5(uv,R5)+intersec5(uv,R6)+intersec5(uv,R7)+intersec6(uv, R8)+intersec8(uv, R10);\n            }else\n   fragColor = intersec (uv,R1)  + intersec2 (uv, R2) + intersec3 (uv,R3)+intersec4 (uv, R4)+intersec5(uv,R5)+intersec5(uv,R6)+intersec5(uv,R7)+intersec6(uv, R8)+intersec7(uv, R9);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdK3Dd", "name": "3D Test for Round Shapes", "author": "Mr_E", "description": "This is my second 3D test, with round shapes! You can see the first one here: https://www.shadertoy.com/view/MsK3Wd", "tags": ["3d", "test", "round", "shapes"], "likes": 0, "viewed": 455, "date": "1457225708", "time_retrieved": "2024-06-20T18:33:56.702301", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(1.3,1.45,5.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(2.,5.2,2.2)),\n            sdBox(p,vec3(2.6,1.4,2.5)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d1, d2, d1);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n    vec3 q = opRep(p,vec3(10.0,10.0,10.0));\n    return vec2(\n       \tsdCrossedGrid(q)\n    );\n}\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    //return vec3(0.6,0.6,0.8);\n    return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(cos(iTime/5.)*20.0,sin(iTime/5.)*30.0,10.0);\n\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(0,1,1);\n\n    //camera lookat\n    vec3 vrp=vec3(0,1,0);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*1.0+vPos.y*v*1.0;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.04,0,0.8);\n    const float maxd=200.0;\n    vec2 d=vec2(1.02,1.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) { // Change i value to 256 for 3D-ness and 2 for coolness\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x*0.8;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        \n        float b=dot(N,normalize(prp-p));\n\t\tvec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    \txy.y = 1.0 - xy.y;\n    \t\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\t\tvec4 texColor = texture(iChannel0,xy,b);//Get the pixel at xy from iChannel0\n        fragColor = vec4(b);\n        \n        //fragColor = vec4(b, 0.1, b, cos(iTime));//Set the screen pixel to that color\n    } else {\n    //fragColor=vec4(0,0,0,1);\n    }\n}\n\n\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdK3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdK3Wd", "name": "Splitting squares", "author": "anastadunbar", "description": "Original animation by Dave Whyte http://bit.ly/21e07ol.", "tags": ["illusion", "loop", "checker", "pattern", "spinning", "splitting"], "likes": 10, "viewed": 219, "date": "1457216194", "time_retrieved": "2024-06-20T18:33:56.853639", "image_code": "#define PI 3.1415926535\n#define clamps(x) clamp(x,0.,1.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy)-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = iTime*.35;\n    \n    uv *= 13.;\n    float atans = (atan(fract(uv.x)-.5,fract(uv.y)-.5)+PI)/(PI*2.);\n    float checker = abs(floor(mod(uv.x,2.))-floor(mod(uv.y,2.))); //abs() was a quicker way for difference.\n    float rotations = (checker==1.)?fract((atans+time)*2.):fract(((1.-atans)+time)*2.);\n    float sharp = 90.;\n    sharp *= (length(fract(uv)-.5))*2.;\n    //float a = step(rotations,.5);\n    float a = clamps((rotations-.5)*sharp);\n    a += clamps(1.-((rotations)*sharp));\n    \n\tfragColor = vec4(mix(vec3(1.),vec3(0.,0.5,.9),a),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdK3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSD4", "name": "basic implicit", "author": "substack", "description": "basic implicit function shader", "tags": ["implicit"], "likes": 1, "viewed": 103, "date": "1459455586", "time_retrieved": "2024-06-20T18:33:57.314405", "image_code": "float udRoundBox (vec3 p, vec3 sizes, float round) {\n  return length(max(abs(p)-sizes,0.0))-round;\n}\n\nvec2 model(vec3 p) {\n  return vec2(udRoundBox(p, vec3(1.0,0.5,0.8), 0.2),0.0);\n}\n\nconst int steps = 20;\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n  for (int i = 0; i < steps; i++) {\n    if (latest < precis || dist > maxd) break;\n    vec2 result = model(rayOrigin + rayDir * dist);\n    latest = result.x;\n    type = result.y;\n    dist += latest;\n  }\n  if (dist < maxd) res = vec2(dist, type);\n  return res;\n}\n\nvec2 raytrace(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec2 square(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 camera(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 lighting (vec3 pos, vec3 nor, vec3 rd, float dis, vec3 mal) {\n  vec3 lin = vec3(0.0);\n  vec3  lig = normalize(vec3(1.0,0.7,0.9));\n  float dif = max(dot(nor,lig),0.0);\n  lin += dif*vec3(2);\n  lin += vec3(0.05);\n  return mal*lin;\n}\n\nvec3 calcNormal(vec3 pos) {\n  const float eps = 0.002;\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(v1*model(pos + v1*eps).x\n    + v2*model(pos + v2*eps).x\n    + v3*model(pos + v3*eps).x\n    + v4*model(pos + v4*eps).x);\n}\n\n\nvec3 camera(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = lookAt(origin, target, 0.0);\n  return camera(camMat, screenPos, lensLength);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float cameraAngle = 0.8 * iTime;\n  vec3 rayOrigin = vec3(3.5 * sin(cameraAngle), 3.0, 3.5 * cos(cameraAngle));\n  vec3 rayTarget = vec3(0, 0, 0);\n  vec2 screenPos = square(iResolution.xy);\n  float lensLength = 2.0;\n  vec3 rayDirection = camera(rayOrigin, rayTarget, screenPos, lensLength);\n  vec2 collision = raytrace(rayOrigin, rayDirection);\n  if (collision.x > -0.5) {\n    vec3 pos = rayOrigin + rayDirection * collision.x;\n    vec3 nor = calcNormal(pos);\n    vec3 mat = vec3(0.5,0.1,0.8);\n    vec3 col = lighting(pos, nor, rayDirection, collision.x, mat);\n    col = pow(clamp(col,0.0,1.0), vec3(0.45));\n    fragColor = vec4(col, 1.0);\n  } else {\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSDr", "name": "Extended Space Jam", "author": "jhfredriksen", "description": "Plasma.\nOriginally inspired by https://www.shadertoy.com/view/lsdXWr, but changed from 1-bit output to smooth results.", "tags": ["procedural", "2d", "plasma"], "likes": 2, "viewed": 531, "date": "1458922451", "time_retrieved": "2024-06-20T18:33:57.587032", "image_code": "\n//\n// This uses the same basic function as https://www.shadertoy.com/view/lsdXWr,\n// only with an added fudge-factor to hide the high-frequency components when\n// dividing by (close to) zero.\n//\n// Visualization part rewritten to give smooth results instead of 1-bit :)\n\nfloat plasma(vec2 uv, float scale, float time)\n{\n    float v = cos(uv.x*uv.y * scale) - cos(uv.x/(0.4+uv.y) + time);\n    float f = floor(v);\n    float c = ceil(v);\n    float e = min(c-v, v-f);\n \tfloat r = min(pow(e * 1.8, 0.7), 1.0);\n\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 10.;\n    float deform = 0.6;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    uv.y *= deform;\n\n    float r0 = plasma(uv, scale, iTime);\n    float r1 = plasma(uv, scale * 2., iTime*1.5 + 0.32);\n\n    // combine octaves in various ways\n    //float r = max(r0, r1);\n    float r = r0*r1;\n    //float r = r0*0.75+r1*0.25;\n\n    // attenuate borders\n    vec2 centeruv = (fragCoord.xy / iResolution.xy*2.0) - 1.0;\n    r *= 1.0 - pow(length(centeruv*centeruv)*0.8,6.0);\n\n    // tint\n\tfragColor = r*vec4(0.8, 0.7, 0.9, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtSRr", "name": "Perspective Spheres", "author": "vamoss", "description": "Original work: http://wavegrower.tumblr.com/post/119795328255/perspectives-bridge-between-this-and-that#notes", "tags": ["ray", "perspective", "rhythm"], "likes": 12, "viewed": 255, "date": "1457474488", "time_retrieved": "2024-06-20T18:33:58.484112", "image_code": "//Adapted from inigo quilez:\n//https://www.shadertoy.com/view/Xds3zN\n\n//Original work:\n//http://wavegrower.tumblr.com/post/119795328255/perspectives-bridge-between-this-and-that#notes\n\n#define PI 3.1415926\n#define TWO_PI 6.2831852\n\n//number of spheres\n#define TOTAL 30\n\n//plane shape\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n//sphere shape\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n//unify shapes\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//model the scene, return x for the shape and y for the material\nvec2 map( in vec3 pos )\n{\n    //start with the plane to receive the shadows\n    vec2 res = vec2( sdPlane(pos), 0.0 );//0.0 is the plane material\n    \n    //draw spheres\n    float sphereScale = 0.02;\n    for(int i=0; i<TOTAL; i++){\n        float index = float(i)/float(TOTAL);\n        \n        sphereScale += index*0.01;\n        \n        //position\n        vec3 spherePos = vec3( 0.0,0.9, 0.0);\n        spherePos.x += sin(iTime*10.0*float(index))*index*0.7;\n        spherePos.y += cos(iTime*10.0*float(index))*index*0.7;\n    \tspherePos.z += -float(TOTAL)*0.07+float(i)*0.15;\n        \n        res = opU( res, vec2( sdSphere(pos-spherePos, sphereScale ), 1.0 ) );//1.0 is the sphere material\n    }\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.1;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<70; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n    \n    //background color\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    //material\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n        // lighting        \n        vec3  lig = normalize( vec3(-0.7, 0.7, -0.7) );\n              \n        //spheres color\n        if( m==1.0 )\n        {\n            col = vec3(0.0,0.0,0.0);\n        }else{\n\t        //shadow\n\t        col *= softshadow( pos, lig, 0.2, 2.5 )*3.1+0.95;\n        }\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5, 1.0, 0.5);//camera rotation\n    vec3 ta = vec3( -0.0, 0.8, 0.0 );//camera target\n    \n    //control camera rotation with mouse and time\n    ro.x += 3.5*cos(0.1*time+TWO_PI*mo.x);\n    ro.y += -0.1+clamp(mo.y*TWO_PI-PI, 0.0, TWO_PI);\n    ro.z += 3.5*sin(0.1*time+TWO_PI*mo.x);\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tfragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXRr", "name": "Globby Gyroscope", "author": "zackpudil", "description": "Update: Removed goofy floor pattern. Removed reflection.  Updated to look like a spin top doing it's thang.", "tags": ["raymarching", "brokendistancefields"], "likes": 0, "viewed": 242, "date": "1457497593", "time_retrieved": "2024-06-20T18:33:58.490397", "image_code": "float neLength(vec2 p, float l) {\n    return pow(\n        pow(abs(p.x), l) + pow(abs(p.y), l)\n    \t, 1.0/l);\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat dTorus(vec3 p, vec2 t) {\n    vec2 d = vec2(length(p.xz) - t.x, p.y);\n    return length(d) - t.y;\n}\n\nfloat dCircleTorus(vec3 p, vec2 t) {\n    vec2 d = vec2(length(p.xz) - t.x, p.y);\n    return neLength(d, 8.) - t.y;\n}\n\nfloat dBoxTorus(vec3 p, vec2 t) {\n    vec2 d = vec2(neLength(p.xz, 8.) - t.x, p.y);\n    return neLength(d, 8.) - t.y;\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec2 map(vec3 p) {\n\tvec2 p1 = vec2(p.y + 2.4, 0.0);\n    p.y -= .6;\n\trotate(p.xz, iTime);\n    p.x -= 2.5;\n    rotate(p.xy, 0.3*cos(2.0*iTime));\n\n    vec2 w = vec2(dSphere(p, .70 - 0.1*sin(10.0*p.x + 5.0*iTime)*sin(10.0*p.y)*sin(10.0*p.z + 5.0*iTime)), 1.0);\n    float radius = .15 - 0.1*smoothstep(2.3, 2.4, p.y > 0. ? p.y : abs(p.y + .4));\n    vec2 sp = vec2(dSegment(p, vec3(0, 2.4, 0), vec3(0, -3.0, 0), radius), 7.0);\n    rotate(p.zy, 3.14/2.0);\n    vec2 bt = vec2(dCircleTorus(p, vec2(1, .08)), 2.0);\n    for(int i = 0; i < 4; i++) {\n        rotate(p.xy, iTime + float(i));\n        p = p/1.2;\n        vec2 bts = vec2(dCircleTorus(p, vec2(1, 0.08))*1.2, 3.0 + float(i));\n        bt = opU(bt, bts);\n    }\n    \n    return opU(p1, opU(opU(w, sp), bt));\n}\n\nvec2 spheretrace(vec3 ro, vec3 rd, float tmin, float tmax) {    \n    float td = tmin;\n    float mid = -1.0;    \n    \n    for(int i = 0; i < 256; i++) {\n        vec2 s = map(ro + rd*td);\n        \n        if(abs(s.x) < 0.001 || td > tmax) break;\n        \n        td += s.x*0.5;\n        mid = s.y;\n    } \n    \n    if(td > tmax) mid = -1.0;\n    return vec2(td, mid);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.01, 0.0);\n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n    );\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    float res = 1.0;\n    float td = 0.02;\n    \n    for(int i = 0; i < 256; i++) {\n        float h = map(p + l*td).x;\n        td += h*0.5;\n        res = min(res, 32.0*h/td);\n        if(abs(h) < 0.001 || td > 25.0) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd) {\n    vec3 lig = normalize(lp);\n    vec3 n = normal(p);\n    vec3 ref = reflect(lig, n);\n    \n    float amb = clamp(0.7 + 0.3*abs(n.y), 0.0, 1.0);\n    float dif = clamp(dot(n, lig), 0.0, 1.0);\n    float spe = pow(clamp(dot(rd, ref), 0.0, 1.0), 52.0);\n    \n    dif *= shadow(p, lig);\n    \n    vec3 lin = vec3(0);\n    \n    lin += 0.4*amb*vec3(1);\n    lin += dif*vec3(1, .97, .85);\n    lin += spe*vec3(1, .97, .54);\n    \n    return lin;\n}\n\nvec3 material(float mid, vec3 p) {\n    vec3 col = vec3(1.);\n    \n    if(mid == 0.0) {\n        vec2 a = vec2(1)*smoothstep(-0.15, 0.15, mod(p.x, 2.))*smoothstep(-0.15, 0.15, mod(p.z, 2.));\n        col = vec3(a, 1);\n    }\n    \n    if(mid == 1.0) {\n        col = vec3(.2, .8, .001);\n    }\n    \n    if(mid >= 2.0 && mid < 7.0) {\n        col = mix(\n            vec3(1, .1, .1),\n            vec3(.1, .1, 1),\n            cos(mid + iTime));\n    }\n    \n    if(mid == 7.0) col = vec3(.65);\n    \n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lp) {\n    vec2 i = spheretrace(ro, rd, 0.0, 25.0);\n    vec3 p = ro + rd*i.x;\n    vec3 m = material(i.y, p);\n    if(i.y == -1.0) return m;\n    \n    m *= lighting(p, lp, rd);\n    \n    return m;\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 rl = vec3(0, 1, 0);\n    vec3 f = normalize(l - e);\n    vec3 r = normalize(cross(rl, f));\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0+2.0*(fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float s = 0.;\n    if(iMouse.z > 0.) {\n        s = 0.01*iMouse.x;\n    } else {\n        s = 3.1;\n    }\n    \n    vec3 ro = 5.0*vec3(cos(s), 0.8, -sin(s));\n    vec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 2.0));\n    \n    vec3 lp = vec3(.75, .75, 0);\n    \n    vec3 rend = render(ro, rd, lp);\n    rend = pow(rend, vec3(.4545));\n    fragColor = vec4(rend, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtXzn", "name": "Cube Field", "author": "Mr_E", "description": "This is a test cube field, without any significant coloring. This uses the technique of Raymarching, so thanks to iq for help with that.", "tags": ["3d", "raymarching", "cube", "cubes", "field"], "likes": 5, "viewed": 843, "date": "1457452263", "time_retrieved": "2024-06-20T18:33:59.090114", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(0.,0.,0.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(0.,0.,0.)),\n            sdBox(p,vec3(2.6,2.6,2.6)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d1, d1, d1);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n\np = mod(p, 10.) - 5.; // Repeat space.\n\n// Unsigned rounded box.\n// vec3(2.) - Box dimensions, and the last term for roundness.\n\nfloat rBox = length(max(abs(p)- vec3(2.), 0.0)) - 0.2;\n\nreturn vec2(rBox, 1.);\n}\n\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    //return vec3(0.6,0.6,0.8);\n    return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(cos(iTime/5.)*20.0,sin(iTime/5.)*40.0,20.0);\n\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(0,1,1);\n\n    //camera lookat\n    vec3 vrp=vec3(0,1,0);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*1.0+vPos.y*v*1.0;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.04,0,0.8);\n    const float maxd=200.0;\n    vec2 d=vec2(1.02,1.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) { // Change i value to 256 for 3D-ness and 2 for coolness\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x*0.8;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        \n        float b=dot(N,normalize(prp-p));\n\t\tvec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    \txy.y = 1.0 - xy.y;\n    \t\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\t\tvec4 texColor = texture(iChannel0,xy,b);//Get the pixel at xy from iChannel0\n        fragColor = vec4(b);\n        \n        //fragColor = vec4(b, 0.1, b, cos(iTime));//Set the screen pixel to that color\n    } else {\n    fragColor=vec4(0,0,0,1);\n    }\n    fragColor *= 1./(1.+f*f*.001);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtXzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdV3W3", "name": "Text with border", "author": "Vertexwahn", "description": "Text with border", "tags": ["text"], "likes": 5, "viewed": 272, "date": "1456830241", "time_retrieved": "2024-06-20T18:33:59.090114", "image_code": "// from: http://stackoverflow.com/questions/35712480/how-to-draw-a-border-around-text-in-opengl\n\n#define SC 0.07 // line scale\n#define LW 0.03 // line width\n#define C1 (vec2 p){return min(l(p,\n#define C2 ),min(l(p,\n\n// line segment\nfloat l(vec2 p, float ax, float ay, float bx, float by)\n{\n    p = floor(p*500.+0.5)/500.;\n\n    vec2 a = vec2(ax,ay)*SC;\n    vec2 b = vec2(bx,by)*SC;\n    vec2 ab = b-a;return length(p-a-ab*clamp(dot(p-a,ab)/dot(ab,ab),0.0,1.0))-LW;\n}\n\nfloat A C1 1.,-8.,1.,-1.5 C2 1.,-1.5,5.,-1.5 C2 5.,-1.5,5.,-5. C2 5.,-5.,1.,-5. C2 1.,-5.,5.,-5.),l(p,5.,-5.,5.,-8.))))));}\nfloat B C1 4.,-5.,4.,-1.5 C2 4.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-8. C2 1.,-8.,5.,-8. C2 5.,-8.,5.,-5.),l(p,5.,-5.,1.,-5.))))));}\nfloat C C1 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-8.),l(p,1.,-8.,5.,-8.)));}\nfloat D C1 1.,-8.,4.,-8. C2 4.,-8.,4.5,-7.5 C2 4.5,-7.5,5.,-6.25 C2 5.,-6.25,5.,-3.75 C2 5.,-3.75,4.5,-2. C2 4.5,-2.,4.,-1.5 C2 4.,-1.5,1.,-1.5),l(p,1.,-1.5,1.,-8.))))))));}\nfloat E C1 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-5. C2 1.,-5.,3.,-5. C2 3.,-5.,1.,-5. C2 1.,-5.,1.,-8.),l(p,1.,-8.,5.,-8.))))));}\nfloat F C1 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-5. C2 1.,-5.,3.,-5. C2 3.,-5.,1.,-5.),l(p,1.,-5.,1.,-8.)))));}\nfloat G C1 5.,-2.5,5.,-1.5 C2 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-8. C2 1.,-8.,5.,-8. C2 5.,-8.,5.,-5.),l(p,5.,-5.,3.5,-5.))))));}\nfloat H C1 1.,-1.5,1.,-8. C2 1.,-8.,1.,-5. C2 1.,-5.,5.,-5. C2 5.,-5.,5.,-1.5),l(p,5.,-1.5,5.,-8.)))));}\nfloat I C1 1.5,-1.5,4.5,-1.5 C2 4.5,-1.5,3.,-1.5 C2 3.,-1.5,3.,-8. C2 3.,-8.,1.5,-8.),l(p,1.5,-8.,4.5,-8.)))));}\nfloat J C1 1.5,-8.,3.,-8. C2 3.,-8.,4.,-7. C2 4.,-7.,4.,-1.5),l(p,4.,-1.5,1.5,-1.5))));}\nfloat K C1 1.,-1.5,1.,-8. C2 1.,-8.,1.,-5. C2 1.,-5.,2.5,-5. C2 2.5,-5.,5.,-1.5 C2 5.,-1.5,2.5,-5.),l(p,2.5,-5.,5.,-8.))))));}\nfloat L C1 1.,-1.5,1.,-8.),l(p,1.,-8.,5.,-8.));}\nfloat M C1 1.,-8.,1.,-1.5 C2 1.,-1.5,3.,-4. C2 3.,-4.,5.,-1.5),l(p,5.,-1.5,5.,-8.))));}\nfloat N C1 1.,-8.,1.,-1.5 C2 1.,-1.5,5.,-8.),l(p,5.,-8.,5.,-1.5)));}\nfloat O C1 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-8. C2 1.,-8.,5.,-8.),l(p,5.,-8.,5.,-1.5))));}\nfloat P C1 1.,-8.,1.,-1.5 C2 1.,-1.5,5.,-1.5 C2 5.,-1.5,5.,-5.),l(p,5.,-5.,1.,-5.))));}\nfloat Q C1 5.,-8.,5.,-1.5 C2 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-8. C2 1.,-8.,5.,-8.),l(p,5.,-8.,3.5,-6.5)))));}\nfloat R C1 1.,-8.,1.,-1.5 C2 1.,-1.5,5.,-1.5 C2 5.,-1.5,5.,-5. C2 5.,-5.,1.,-5. C2 1.,-5.,3.5,-5.),l(p,3.5,-5.,5.,-8.))))));}\nfloat S C1 5.,-1.5,1.,-1.5 C2 1.,-1.5,1.,-5. C2 1.,-5.,5.,-5. C2 5.,-5.,5.,-8.),l(p,5.,-8.,1.,-8.)))));}\nfloat T C1 3.,-8.,3.,-1.5 C2 3.,-1.5,1.,-1.5),l(p,1.,-1.5,5.,-1.5)));}\nfloat U C1 1.,-1.5,1.,-8. C2 1.,-8.,5.,-8.),l(p,5.,-8.,5.,-1.5)));}\nfloat V C1 1.,-1.5,3.,-8.),l(p,3.,-8.,5.,-1.5));}\nfloat W C1 1.,-1.5,1.,-8. C2 1.,-8.,3.,-6. C2 3.,-6.,5.,-8.),l(p,5.,-8.,5.,-1.5))));}\nfloat X C1 1.,-1.5,5.,-8. C2 5.,-8.,3.,-4.75 C2 3.,-4.75,5.,-1.5),l(p,5.,-1.5,1.,-8.))));}\nfloat Y C1 1.,-1.5,3.,-5. C2 3.,-5.,3.,-8. C2 3.,-8.,3.,-5.),l(p,3.,-5.,5.,-1.5))));}\nfloat Z C1 1.,-1.5,5.,-1.5 C2 5.,-1.5,3.,-5. C2 3.,-5.,1.,-8.),l(p,1.,-8.,5.,-8.))));}\n\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float t = iTime;  \n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n\n    uv.x += 0.13;\n    uv.x *= abs(sin(uv.x+t*2.0)*0.5+1.0)+1.0;\n    uv.y *= abs(sin(uv.x+t*2.0)+1.0)+1.0;\n\n    vec3 col = vec3(0);\n    float d = 1.0;\n\n    d = min(d,S(uv-vec2(-2.0,0.5)));\n    d = min(d,H(uv-vec2(-1.5,0.5)));\n    d = min(d,A(uv-vec2(-1.0,0.5)));\n    d = min(d,D(uv-vec2(-0.5,0.5)));\n    d = min(d,E(uv-vec2( 0.0,0.5)));\n    d = min(d,R(uv-vec2( 0.5,0.5)));\n    d = min(d,T(uv-vec2( 1.0,0.5)));\n    d = min(d,O(uv-vec2( 1.5,0.5)));\n    d = min(d,Y(uv-vec2( 2.0,0.5)));\n\n    col = mix(vec3(1),col,smoothstep(d,d+0.01,0.0));\n\n    fragColor = vec4(vec3(1.-40.0*d),1.0);\n}\n\n#define DIST 0.005\n#define ITR 5\n#define THRESH 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float x, y;\n    vec4 neighborColor;\n    float dist_sq;\n\n    mainImage2(fragColor, fragCoord);\n\n    for (int i = 0; i < ITR; i++) {\n        x = mix(uv.x - DIST, uv.x + DIST, float(i) / float(ITR - 1));\n        for (int k = 0; k < ITR; k++) {\n            y = mix(uv.y - DIST, uv.y + DIST, float(k) / float(ITR - 1));\n            dist_sq = pow(uv.x-x, 2.0) + pow(uv.y-y, 2.0);\n            if (dist_sq < DIST * DIST) {\n                mainImage2(neighborColor, vec2(x, y) * iResolution.xy);\n                if (neighborColor.r > THRESH && fragColor.r < THRESH) {\n                    fragColor = vec4(1, 0, 0, 1);\n                } else {\n                    // fragColor = vec4(0, 1, 0, 1);\n                }\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdV3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdyGDK", "name": "Simple Dithers", "author": "Edward", "description": "Testbed for deciding which simple dither to use to remove banding in 8-bit/channel colour for this shader: [url]https://www.shadertoy.com/view/MsK3Wt[/url]\nBanding exaggerated by using 8-bit/pixel colour (configured by DEPTH vector).", "tags": ["dither"], "likes": 3, "viewed": 619, "date": "1457524293", "time_retrieved": "2024-06-20T18:33:59.429735", "image_code": "// License: http://unlicense.org/\n\n#define DEPTH vec3(3.,3.,2.)\n#define PI 3.14159265359\n#define SLOW 4.\n#define BREATHE 1.\n\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float hash(vec2 co) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shades = pow(vec3(2.),DEPTH);\n    vec3 top = shades - 1.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 c = vec3(uv.x,0.5,uv.y) - sin(BREATHE * iTime * PI/SLOW*2. + PI/2.) * length(uv - .5)/2.;\n    vec3 scaledColour = c * vec3(shades);\n    vec3 ditherOffset = vec3(0.);\n    int i = int(mod(iTime/SLOW, 5.));\n    // i == 0? No dither\n    \n    // Cheap ordered dither\n    if(i == 1) ditherOffset += vec3(fract(fragCoord.x/4.+fragCoord.y/2.)-.375);\n    \n    // Different ordered dither\n    if(i == 2) ditherOffset += vec3(mod(mod(fragCoord.x,2.)+mod(fragCoord.y,2.)*2.+2.,4.)/4.-.375);\n    \n    // Random dither\n    if(i == 3) ditherOffset += vec3(hash(fragCoord) - 0.5);\n    \n    // 3 channel random dither\n    if(i == 4) ditherOffset += vec3(hash(fragCoord), hash(fragCoord + 1000.), hash(fragCoord + 2000.)) - .5;\n\n    fragColor = max(vec4(floor(scaledColour+ditherOffset)/(vec3(top)), 1.), 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unlicense", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3XW4", "name": "Misty moon", "author": "marvindanig", "description": "Created off a fork of the main sequence star by flight404: https://www.shadertoy.com/view/4dXGR4\n\nLooks good in fullscreen mode! :-)", "tags": ["moon"], "likes": 5, "viewed": 1623, "date": "1459286391", "time_retrieved": "2024-06-20T18:33:59.956922", "image_code": "// Fork of the main sequence star by flight404: https://www.shadertoy.com/view/4dXGR4\n// Without the music of course.\n// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// My apologies for the ugly code.\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.2, 0.2, 0.2 );\n\tvec3 orangeRed\t\t= vec3( 0.2, 0.2, 0.2 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 3.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.1 - fade;\n\tfloat fVal2\t\t= 1.1 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.1 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.1 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3XW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3Xz4", "name": "Speed o' Light RayMarcher", "author": "zephmann", "description": "raymarchin'", "tags": ["raymarching"], "likes": 2, "viewed": 292, "date": "1457923791", "time_retrieved": "2024-06-20T18:34:00.520806", "image_code": "// returns distance from a point to surface of sphere\nfloat sphIntersect(vec3 p, vec3 c, float r, float d)\n{\n    vec3 tc = c;\n    \n    // uncomment for regular version\n    //d = 0.0;\n    \n    tc.x += cos( iTime * 2.3 - d );\n    tc.y += cos( iTime * 1.7 - d );\n\treturn (distance(p, tc) - r);\n}\n\n// march along ray until distance is within an epsilon or max steps is exceeded\nvec3 march(vec3 ro, vec3 rd)\n{\n    // col value to be returned\n\tvec3 col = vec3(0.);\n\t\n\tfloat t = 1.;        // current distance along ray\n\tfloat prevt = 0.;    // distance along ray at previous step\n\tfloat d = 10000000.; // distance to surface\n\tvec3 p;              // coordinates of current point on ray\n    float stepSize = 0.001;\n\t\n    int j;\n\tconst int maxSteps = 256;\n\t\n    // directional light\n\tvec3 light = (vec3(-1., -2., 1.5));\n\t\n    // sphere attributes\n\tfloat radius = 1.5;\n\tvec3 center = vec3(0.0, 0.0, 0.0);\n\t\n    // loop until steps exceeds max limit\n    // or break if our point is within epsilon distance\n\tfor(int i=0; i < maxSteps; i++)\n\t{\n\t\tprevt = t;\n\t\tp = ro + rd * t;\n\t\t\n\t\td = sphIntersect(p, center, radius, t);\n\t\t\n\t\tj = i+1;\n\t\tt += d;\n        //t += stepSize;\n\t\t\n        // check if distance is within epsilon\n\t\tif(abs(d) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    // if j is less than maxSteps then we broke out early\n\tif(j < maxSteps)\n\t{\n        // used for calculating the surface normal\n    \tvec2 delta = vec2(0.001, 0.0);\n        \n        // calc surface normal\n\t\tvec3 norm = vec3(sphIntersect(p + delta.xyy, center, radius, t) - sphIntersect(p - delta.xyy, center, radius, t),\n\t\t\t\t\t\t sphIntersect(p + delta.yxy, center, radius, t) - sphIntersect(p - delta.yxy, center, radius, t),\n\t\t\t\t\t\t sphIntersect(p + delta.yyx, center, radius, t) - sphIntersect(p - delta.yyx, center, radius, t));\n\t\t\n        // calc lambert shading\n\t\tfloat lambert = max( dot(normalize(light), normalize(norm)), 0.0 );\n\t\t\n        // multiply surface color by lambert, add ambient color\n        vec3 surfColor = vec3(0.3, 0.8, 0.9);\n\t\tcol = surfColor * lambert + vec3(0.075);\n\t\t\n        // fake ambient occulusion\n\t\tcol *= vec3(float(maxSteps-j) / float(maxSteps));\n\t}\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv - 0.5;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 cam = vec3(0.0, 0.0, 8.0);\n\tvec3 dir = normalize(-cam);\n\t\n\tvec3 v1 = cross(dir, vec3(0,1,0));\n\tvec3 v2 = cross(dir, v1);\n\t\n\tdir += v1 * uv.x;\n\tdir += v2 * uv.y;\n\t\n\tvec3 col = march(cam, dir);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3Xz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3XzM", "name": "iTime vs iDate.w", "author": "GregRostami", "description": "This shader demonstrates the difference in the precision of iGlobalTime vs iDate.w\nIf you view this shader after midnight the top and bottom will be very similar!", "tags": ["precision", "onetweet", "teach"], "likes": 7, "viewed": 1168, "date": "1458270768", "time_retrieved": "2024-06-20T18:34:00.666074", "image_code": "// This shader demonstrates the difference in the precision of iTime vs iDate.w\n// If you view this shader after midnight the top and bottom will be very similar!\nvoid mainImage(out vec4 o,vec2 i)\n{\ni/=iResolution.xy;\no = vec4 ( i.y > .5\n  ? .5+.5*sin(i.x - iTime   * 8.)    //iTime has greater precision\n  : .5+.5*sin(i.x - iDate.w * 8.));  //iDate.w displays banding because of lower precision\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3XzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms3Xzn", "name": "Camera Rail", "author": "Bers", "description": "Camera rail visualization", "tags": ["camera", "spline"], "likes": 20, "viewed": 754, "date": "1457309827", "time_retrieved": "2024-06-20T18:34:01.896626", "image_code": "// Author : Sbastien Brub\n// Created : Oct 2014\n// Modified : Jan 2016\n//\n// 2 looping splines, implemented for testing camera animation.\n// Red spline could be camera position, green one could be camera target.\n//\n// Here, processing the camera position and target is quite cheap.\n// Drawing the path, however, is not really suited for a distance field shader, and is therefore expensive.\n// (Spline segments should indeed be passed as vertices instead of being drawn the way they are here).\n//\n// License : Creative Commons Non-commercial (NC) license\n\nconst int POINT_COUNT = 8;\nstruct CtrlPts\n{\n    vec2 p[POINT_COUNT];\n};\nvec2 PointArray(int i, CtrlPts ctrlPts)\n{\n    if(i==0 || i==POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec2(0);\n}\n\nvec2 catmullRom(float fTime, CtrlPts ctrlPts)\n{\n    float t = fTime;\n    const float n = float(POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec2 p1 = PointArray(idxOffset,ctrlPts);\n    vec2 p2 = PointArray(idxOffset+1,ctrlPts);\n    vec2 p3 = PointArray(idxOffset+2,ctrlPts);\n    vec2 p4 = PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec2 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat debugDistanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nvec2 debugDistanceField(vec2 uv, CtrlPts ctrlPts)\n{\n    //This is just to illustrate the resulting spline. A Spline distance field should not be computed this way.\n    //If the real intent was to show a distance field, something like this perhaps should be used:\n    //https://www.shadertoy.com/view/XsX3zf\n    const float MAX_DIST = 10000.0;\n    float bestX = 0.0;\n    \n    //Primary (rough) estimate : decent results with 2 lines per control point (faint blue lines)\n    const int iter = POINT_COUNT*2+1;\n    //const int iter = POINT_COUNT*1+1; //<-Faster\n    //const int iter = POINT_COUNT*3+1; //<-Nicer\n    float primarySegLength = 1.0/float(iter-1);\n    vec2 pA = catmullRom(0., ctrlPts);\n    float minRoughDist = MAX_DIST;\n    float x = 0.0;\n    for(int i=0; i < iter; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        \n        float d = debugDistanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        if(d<minRoughDist)\n        {\n            bestX = x;\n            minRoughDist = d;\n        }\n         \n        x += primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    //Secondary (smooth) estimate : refine (red curve)\n    const int iter2 = 8;\n    x = max(bestX-1.01*primarySegLength,0.0); //Starting 25% back on previous seg (50% overlap total)\n    float minDist = MAX_DIST;\n    pA = catmullRom(x, ctrlPts);\n    for(int i=0; i < iter2; ++i)\n    {\n        vec2 pB = catmullRom(x, ctrlPts);\n        float d = debugDistanceToLineSeg(uv, pA, pB);\n        pA = pB;\n        \n        if(d<minDist)\n        {\n            bestX = x;\n            minDist = d;\n        }\n         \n        //Covering 1.25x primarySegLength (50% overlap with prev, next seg)\n        x += 1.25/float(iter2-1)*primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    return vec2(minDist,minRoughDist);\n}\n\nvec2 getUV(vec2 px)\n{\n    vec2 uv = px / iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CtrlPts ctrlPtsA;\n\tctrlPtsA.p[0] = vec2(0.10,0.25);\n    ctrlPtsA.p[1] = vec2(0.2,0.1);\n    ctrlPtsA.p[2] = vec2(0.6,0.35);\n    ctrlPtsA.p[3] = vec2(0.4,0.1);\n    ctrlPtsA.p[4] = vec2(0.8,0.35);\n    ctrlPtsA.p[5] = vec2(0.6,0.55);\n    ctrlPtsA.p[6] = vec2(0.5,0.45);\n    ctrlPtsA.p[7] = vec2(0.3,0.49);\n    \n    CtrlPts ctrlPtsB;\n\tctrlPtsB.p[0] = 0.95*vec2(0.146,0.241);\n    ctrlPtsB.p[1] = 0.95*vec2(0.275,0.172);\n    ctrlPtsB.p[2] = 0.95*vec2(0.472,0.222);\n    ctrlPtsB.p[3] = 0.95*vec2(0.485,0.152);\n    ctrlPtsB.p[4] = 0.95*vec2(0.764,0.367); \n    ctrlPtsB.p[5] = 0.95*vec2(0.692,0.525);\n    ctrlPtsB.p[6] = 0.95*vec2(0.531,0.509);\n    ctrlPtsB.p[7] = 0.95*vec2(0.363,0.503);\n    \n    vec2 pDebug = vec2(1,0);\n    if(iMouse.z > 0.1)\n    {\n        vec2 pMouse = getUV(iMouse.xy);\n        \n        int minIndex = 0;\n        float fMinDist = 10000.0;\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            vec2 ctrl_pt = ctrlPtsB.p[i];\n            float d = length(ctrl_pt-pMouse);\n            if(d<fMinDist)\n            {\n                minIndex = i;\n                fMinDist = d;\n                pDebug = pMouse/0.95;\n            }\n        }\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            if(minIndex==i)\n            {\n                ctrlPtsB.p[i] = pMouse;\n            }\n        }\n\t}\n    \n    vec2 uv = getUV(fragCoord.xy);\n    vec3 c = vec3(0);\n    \n    //<Draw spline A>\n    {\n        vec2 dSeg = debugDistanceField(uv, ctrlPtsA);\n        c = mix(vec3(0.7,0  ,0.0),c,smoothstep(0.0,0.0025,dSeg.x));\n        float minDistP = 10000.0;\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            vec2 ctrl_pt = PointArray(i,ctrlPtsA);\n            minDistP = min(length(uv-ctrl_pt),minDistP);\n        }\n        c = mix(vec3(1,0.6,0.6),c,smoothstep(0.004,0.006,minDistP));\n    }\n    //</Draw spline A>\n    \n\t//<Draw spline B>\n    {\n        vec2 dSeg = debugDistanceField(uv, ctrlPtsB);\n        c = mix(vec3(0.5,0.7,0),c,smoothstep(0.0,0.0025,dSeg.x));\n        float minDistP = 10000.0;\n        for(int i=0; i < POINT_COUNT; ++i)\n        {\n            vec2 ctrl_pt = PointArray(i,ctrlPtsB);\n            minDistP = min(length(uv-ctrl_pt),minDistP);\n        }\n        c = mix(vec3(0.8,1,0.6),c,smoothstep(0.004,0.006,minDistP));\n    }\n    //</Draw spline B>\n    \n    float fTime = iTime*0.15;\n    vec2 pA = catmullRom(fract(fTime), ctrlPtsA);\n    vec2 pB = catmullRom(fract(fTime+0.035), ctrlPtsB);\n    \n    //Draw moving points\n    c = mix(vec3(1,0.0,0),c,smoothstep(0.006,0.009,length(uv-pA)));\n    c = mix(vec3(0,0.7,0),c,smoothstep(0.006,0.009,length(uv-pB)));\n    \n    float dCamDir = debugDistanceToLineSeg(uv, pA, pB);\n\tc = mix(vec3(1.0,1.0,1.0),c,smoothstep(0.001,0.003,dCamDir));\n\t\n\tfragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3Xzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscSDN", "name": "Pulsing scarabs exploration", "author": "kyp", "description": "some iterations of newton's method on finding roots of a 4th degree complex polynomial - exploration version", "tags": ["fractal"], "likes": 1, "viewed": 105, "date": "1459365118", "time_retrieved": "2024-06-20T18:34:01.896626", "image_code": "#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(10.,10.)+fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n    \n    vec2 val = uv*(5.0)/(5.0+iTime);\n    for (int i=0; i < 15; i++) {\n        vec2 val2 = cx_mul(val,val);\n        vec2 val3 = cx_mul(val2,val);\n        vec2 val4 = cx_mul(val2,val2);\n        val = val - cx_div((val4 - vec2(1,0)),(4.0*val3));        \n    }\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec4 base_color;\n    float diff;\n    float tolerance = 0.1+sin(iTime)/10.0;\n    if (abs(val.x-1.0)<tolerance){\n        base_color.r = 1.0;\n        diff = abs(val.x-1.0);\n    }\n    else if (abs(val.y-1.0)<tolerance) {\n        base_color.g = 1.0;\n        diff = abs(val.y-1.0);\n    }\n    else if (abs(val.x+1.0)<tolerance) {\n        base_color.b = 1.0;\n        diff = abs(val.x+1.0);\n    }\n    else if (abs(val.y+1.0)<tolerance) {        \n        base_color.g = 1.0;\n        base_color.b = 1.0;\n        diff = abs(val.y+1.0);\n    }\n    //base_color = base_color * diff*100.0;\n    if (diff > 0.000001)\n        base_color = base_color*0.8;\n    if (diff > 0.01)\n        base_color = base_color*0.8;\n    if (diff > 0.05)\n        base_color = base_color*0.8;\n    if (diff > 0.2)\n        base_color = base_color*0.8;\n    fragColor = base_color;//vec4(val.x,val.x,val.y,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscSRr", "name": "PerspectiveReprojection", "author": "Bers", "description": "Screen space parallel lines intersection (vanishing point) is used in order to compute a world space parallelogram. One of the basic principles of automated 3D scene reconstruction. Only a screen space quad input required (3D position is inferred).", "tags": ["3d", "perspective", "reprojection", "vanishingpoint"], "likes": 45, "viewed": 1918, "date": "1457315759", "time_retrieved": "2024-06-20T18:34:04.066345", "image_code": "// Author : Sebastien Berube\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// This shader uses the vanishing point on the image plane in order to infer the world space direction of parallel lines.\n// From 4 points (2D) on the image plane, it will use projective geometry properties in order to generate 4 points (3D) world space.\n// \n// This is a very important concept for 3D scene reconstruction from 2D images.\n//\n// The one line that is important in this shader is : \"p1_to_p2 = dirVanishingPoint\", in function \"resolveAdjacentCorner()\".\n// What this means is : the 3D line starting from the camera center and going towards the vanishing point of 2 parallel lines \n//                      are all parallel with each other (as all lines directed towards this vanishing point are parallel).\n//                      Although parallel lines are nerver supposed to cross each other in reality, they however do on the \n//                      projected image plane, and this allows computation of the vanishing point intersection in 2D first,\n//                      and then inferring 3D direction by casting a ray from the camera center through this vanishing point\n//                      on the image plane.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\nconst vec2 SS1_BOTTOM_LEFT  = vec2( 0.180, 0.320);\nconst vec2 SS1_BOTTOM_RIGHT = vec2( 0.332, 0.360);\nconst vec2 SS1_TOP_RIGHT    = vec2( 0.332, 0.640);\nconst vec2 SS1_TOP_LEFT     = vec2( 0.180, 0.766);\n\nconst vec2 SS2_BOTTOM_LEFT  = vec2( 0.820, 0.343);\nconst vec2 SS2_BOTTOM_RIGHT = vec2( 0.970, 0.33);\nconst vec2 SS2_TOP_RIGHT    = vec2( 0.965, 0.745);\nconst vec2 SS2_TOP_LEFT     = vec2( 0.815, 0.675);\n    \nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 O;}; //R=Right, U=Up, D=Direction, O=Origin\nCam    CAM_lookAt(vec3 target, float pitchAngleRad, float dist, float theta);\nCam    CAM_mouseLookAt(vec3 at, float dst);\n\n//Function to cast a ray through a given coordinate (uv) on the image plane.\n//It returns the direction of a 3D Ray.\n//Note : screen center is uv=[0,0]\nvec3 ray(vec2 uv, Cam cam)\n{\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\n//Function which does the opposite of the previous function:\n//It receives a 3D world space position, then flattens it on the image plane \n//and returns its [uv] coordinates.\n//Note : screen center is uv=[0,0]\nvec2 camProj(Cam c, vec3 p)\n{\n    p = p-c.O;\n    float cZ = dot(p,c.D);\n    float cX = dot(p,c.R);\n\tfloat cY = dot(p,c.U);\n    return vec2(cX/cZ,cY/cZ);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//Utility function returning the intersection point of two 2D lines\n//[p1a,p1b] = line1\n//[p2a,p2b] = line1\nvec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)\n{\n    vec2 d1 = (p1b-p1a); //Direction Line 1\n    vec2 d2 = (p2b-p2a); //Direction Line 2\n    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere\n    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance\n    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)\n    float t = 10000000.0 ; //INFINITY! (rare parallel case)\n    if(rate != 0.0)\n\t\tt = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.\n    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.\n}\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray to the plane intersection.\n//o = ray origin\n//d = ray direction\n//po = plane origin\n//pn = plane normal\nfloat rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) \n{\n    //Same principle as lineLineIntersection() :\n    //\"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(po-o,pn)/dot(d,pn);\n}\n\nstruct screenSpaceQuad{ vec2 a; vec2 b; vec2 c; vec2 d; };\nstruct worldSpaceQuad{  vec3 a; vec3 b; vec3 c; vec3 d; };\n\n//perspectiveCam : the camera from which the points in screen space come from\n//P1 : known world space position of p1\n//p1 : screen space p1 (which is resolved, already)\n//p2 : screen space p2 (which must be adjacent to p1 - cannot be the opposite corner)\n//parallel_a : first point (screen space) in the other line parallel to (p1,p2)\n//parallel_b : second point (screen space) in the other line parallel to (p1,p2)\nvec3 resolveAdjacentCorner(in Cam perspectiveCam, vec3 P1, vec2 p1_resolved, vec2 p2_adjacent, vec2 parallel_a, vec2 parallel_b)\n{\n    //screen space intersection (vanishing point on the projection plane)\n    vec2 ssIntersec = lineLineIntersection(p1_resolved,p2_adjacent,parallel_a,parallel_b);\n    //Vanishing point direction, from camera, in world space.\n    vec3 dirVanishingPoint = ray(ssIntersec, perspectiveCam);\n    vec3 p1_to_p2 = dirVanishingPoint; //Since vanishing point is at \"infinity\", p1_to_p2 == dirVanishingPoint\n    vec3 r2 = ray(p2_adjacent, perspectiveCam);//Ray from camera to p2, in world space\n    \n    //<Line3D intersection : where p1_to_p2 crosses r2>\n    //(Note : this could probably be made simpler with a proper 3D line intersection formula)\n    //Find (rb,p1_to_p2) intersection:\n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2); //normal to the triangle formed by point p1, point p2 and the camera origin\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2); //normal to the plane which is crossed by line p1-p2 at point p2\n    float t = rayPlaneIntersec(P1,p1_to_p2,perspectiveCam.O,n_plane_p2);\n    vec3 p2_ws = P1+t*p1_to_p2;\n    //</Line3D intersection>\n    return p2_ws;\n}\n    \n//Finds each corner, one by one.\nvoid resolvePerspective(in Cam perspectiveCam, in screenSpaceQuad ssQuad, out worldSpaceQuad wsQuad)\n{\n    vec3 ra = ray(ssQuad.a, perspectiveCam); //Find the direction of the ray passing by point a in screen space.\n\t                                      //For the sake of simplicity, screenspace [uv.x,uv.y] = worldspace [x,y]. Z = depth.\n    //Let's place point a in an arbitrary position along the ray ra. \n    //It does not matter at which distance exactly, as it is the relationship between\n    //the corners that is important. The first corner distance simply defines the scaling of the 3D scene.\n    wsQuad.a = perspectiveCam.O + 5.5*ra; //5.5 = arbitrary scaling. Projective geometry does not preserve world space scaling.\n    wsQuad.b = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.b, ssQuad.c, ssQuad.d);\n    wsQuad.c = resolveAdjacentCorner(perspectiveCam, wsQuad.b, ssQuad.b, ssQuad.c, ssQuad.a, ssQuad.d);\n    wsQuad.d = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.d, ssQuad.b, ssQuad.c);\n}\n\nvec3 apply_atmosphere(float travelDist, in vec3 color, in vec3 p)\n{\n    //From this nice article on fog:\n    //http://iquilezles.org/www/articles/fog/fog.htm\n    //or this PowerPoint from Crytek:\n\t//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17\n\tvec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));\n    float c = 1.08;\n    float b = 0.06;\n\n    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;\n    cumul_density = clamp(cumul_density,0.0,1.0);\n    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);\n    return FinalColor;\n}\n\nvec3 alphaBlend(vec3 c1, vec3 c2, float alpha)\n{\n    return mix(c1,c2,clamp(alpha,0.0,1.0));\n}\n\nvec2 pixel2uv(vec2 px, bool bRecenter, bool bUniformSpace)\n{\n    if(bRecenter)\n    {\n        px.xy-=iResolution.xy*0.5;\n\t}\n    \n    vec2 resolution = bUniformSpace?iResolution.xx:iResolution.xy;\n    vec2 uv = px.xy / resolution;\n    return uv;\n}\n\nvec3 drawPoint(vec2 uv, vec2 point, vec3 cBack, vec3 cPoint, float radius, float fZoom)\n{\n    radius /= fZoom;\n    float distPt = length(uv-point);\n    float alphaPt = 1.0-smoothstep(radius-.003/fZoom,radius,distPt);\n    return alphaBlend(cBack,cPoint,alphaPt);\n}\n\nvec3 drawLine(vec2 uv, vec2 pa, vec2 pb, vec3 cBack, vec3 cLine, float radius, float fZoom)\n{\n    radius /= fZoom;\n    float distLine = distanceToLineSeg(uv,pa,pb);\n    float alphaLine = 1.0-smoothstep(radius-.003/fZoom,radius,distLine);\n    return alphaBlend(cBack,cLine,alphaLine);\n}\n\n//wsQuad.a = origin (lower left corner)\n//wsQuad.a,b,c,d = CCW point order.\nvec2 findParallelogramUV(vec3 o, vec3 d, worldSpaceQuad wsQuad)\n{\n    //Note : This is tricky because axis are not orthogonal.\n    vec3 uvX_ref = wsQuad.b-wsQuad.a; //horitonal axis\n    vec3 uvY_ref = wsQuad.d-wsQuad.a; //vertical axis\n    vec3 quadN = cross(uvY_ref,uvX_ref);\n    float t = rayPlaneIntersec(o, d, wsQuad.a, quadN);\n        \n    vec3 p = o+t*d;\n    vec3 X0_N = cross(uvY_ref,quadN);\n    vec3 Y0_N = cross(uvX_ref,quadN);\n    \n    //Vertical component : find the point where plane X0 is crossed\n    float t_x0 = rayPlaneIntersec(p, uvX_ref, wsQuad.a, X0_N);\n    vec3 pY = p+t_x0*uvX_ref-wsQuad.a;\n    //Horizontal component : find the point where plane Y0 is crossed\n    float t_y0 = rayPlaneIntersec(p, uvY_ref, wsQuad.a, Y0_N);\n    vec3 pX = p+t_y0*uvY_ref-wsQuad.a;\n    \n    //All is left to find is the relative length ot pX, pY compared to each axis reference\n    return vec2(dot(pX,uvX_ref)/dot(uvX_ref,uvX_ref),\n\t            dot(pY,uvY_ref)/dot(uvY_ref,uvY_ref));\n}\n\nvec3 drawPerspectiveScene(Cam perspectiveCam, vec2 uv, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, vec3 cBackground, float fZoom)\n{\n    vec3 cScene = cBackground;\n    cScene = texture(iChannel0,uv+0.5).xyz;\n    \n\tfloat fLineWidth = 0.0025;\n    cScene = drawLine(uv, ssQuad.a, ssQuad.b, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.b, ssQuad.c, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.c, ssQuad.d, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.d, ssQuad.a, cScene, vec3(0), fLineWidth, fZoom);\n    \n    float fPointRad = 0.006;\n    cScene = drawPoint(uv, ssQuad.a, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.b, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.c, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.d, cScene, vec3(0,1,0), fPointRad, fZoom);\n    \n    //Show results\n    fPointRad = 0.004;\n    vec2 aDebug = camProj(perspectiveCam,wsQuad.a);\n    vec2 bDebug = camProj(perspectiveCam,wsQuad.b);\n    vec2 cDebug = camProj(perspectiveCam,wsQuad.c);\n    vec2 dDebug = camProj(perspectiveCam,wsQuad.d);\n    cScene = drawPoint(uv, aDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, bDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, cDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, dDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    \n    return cScene;\n}\n\nCam setupPerspectiveCamera()\n{\n    Cam cam;\n    cam.O = vec3(0,0,0);\n    cam.R = vec3(1,0,0);\n    cam.U = vec3(0,1,0);\n    cam.D = vec3(0,0,-1);\n    return cam;\n}\n\nscreenSpaceQuad setupPerspectiveQuad(vec2 mouse_uv)\n{\n    screenSpaceQuad ssQuad;\n    \n    //Arbitrary screen-space parallelograms.\n    if(fract(iTime/4.0)> 0.5)\n    {\n        ssQuad.a = SS1_BOTTOM_LEFT-0.5;\n    \tssQuad.b = SS1_BOTTOM_RIGHT-0.5;\n    \tssQuad.c = SS1_TOP_RIGHT-0.5;\n    \tssQuad.d = SS1_TOP_LEFT-0.5;\n    }\n    else\n    {\n     \tssQuad.a = SS2_BOTTOM_LEFT-0.5;\n    \tssQuad.b = SS2_BOTTOM_RIGHT-0.5;\n    \tssQuad.c = SS2_TOP_RIGHT-0.5;\n    \tssQuad.d = SS2_TOP_LEFT-0.5;   \n    }\n    \n    if(iMouse.z > 0.0 && mouse_uv.x < 0.5 && mouse_uv.y < 0.5) //if mouse btn down\n    {\n\t\tssQuad.d = mouse_uv;\n    }\n    \n    return ssQuad;\n}\n\nvec2 inversePerspective_uv(Cam perspectiveCam, vec2 uv_01, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad )\n{\n    vec3 x_ws = wsQuad.b-wsQuad.a;\n    vec3 y_ws = wsQuad.d-wsQuad.a;\n    vec3 p_ws = wsQuad.a+uv_01.x*x_ws + uv_01.y*y_ws;\n    vec2 puv = camProj(perspectiveCam,p_ws);\n\treturn puv;\n}\n\nCam setupSceneCamera()\n{\n    float targetDistance = 10.5;\n    vec3 cam_tgt = vec3(0,0,-3.0);\n    Cam cam = CAM_lookAt(cam_tgt, -0.2, targetDistance, -0.75+iTime*0.1);\n    if(iMouse.xz != vec2(0.0,0.0) && ( iMouse.x > iResolution.x/4.0 || iMouse.y > iResolution.y/4.0) ) //Mouse button down : user control\n    {\n    \tcam = CAM_mouseLookAt(cam_tgt, targetDistance);\n    }\n    return cam;\n}\n\nvec3 draw3DScene(Cam perspectiveCam, Cam sceneCam, vec2 uv, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad)\n{\n    vec3 o = sceneCam.O;\n    vec3 d = ray(uv,sceneCam);\n    \n    vec3 cScene = vec3(0);\n    \n    float t = rayPlaneIntersec(o,d, vec3(0,-1.0,0), vec3(0,1,0));\n    if(t<0.0)\n    {\n        t = 1000.0;\n        cScene = apply_atmosphere(t,vec3(1),o+t*d);\n    }\n    else\n    {\n\t\tvec3 pFloor = o+t*d;\n    \tvec3 cFloor = texture(iChannel1,pFloor.xz*0.25).xyz;\n    \tcScene = apply_atmosphere(t,cFloor,pFloor);\n    }\n    \n    float fZoom = 3.0*iResolution.x/1920.;\n    vec2 aDebug = camProj(sceneCam,wsQuad.a);\n    vec2 bDebug = camProj(sceneCam,wsQuad.b);\n    vec2 cDebug = camProj(sceneCam,wsQuad.c);\n    vec2 dDebug = camProj(sceneCam,wsQuad.d);\n    vec2 oDebug = camProj(sceneCam,perspectiveCam.O);\n    cScene = drawPoint(uv,aDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,bDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,cDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,dDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,oDebug,cScene,vec3(0,0,1),0.005, fZoom);\n    cScene = drawLine(uv,aDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,bDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,cDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,dDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,aDebug,bDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,bDebug,cDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,cDebug,dDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,dDebug,aDebug,cScene,vec3(0),0.0025, fZoom);\n    \n    //Projection Plane (camera near plane)\n    float tImage = rayPlaneIntersec(o,d, perspectiveCam.O+normalize(perspectiveCam.D), perspectiveCam.D);\n    if(tImage>0.0) //tImage < 0 when the ray never intersects the floor plane (intersection happens behind camera)\n    {\n        vec3 pImage = o+tImage*d;\n        vec2 uv = camProj(perspectiveCam,pImage);\n        \n        if(abs(uv.x)<0.5 && abs(uv.y)<0.5*iResolution.y/iResolution.x)\n        {\n            vec3 cPersp = drawPerspectiveScene(perspectiveCam, uv, ssQuad, wsQuad, vec3(0.55), fZoom*0.1);\n            cScene = alphaBlend(cScene,cPersp,0.5);\n        }\n    }\n    \n    //\n    vec3 nQuad = cross((wsQuad.b-wsQuad.a),(wsQuad.d-wsQuad.a));\n    float tQuad = rayPlaneIntersec(o,d, wsQuad.a, nQuad);\n    if(tQuad>0.0) //tQuad < 0 when the ray never intersects the floor plane (intersection happens behind camera)\n    {\n        vec2 uv = findParallelogramUV(o,d,wsQuad);\n        if(uv.x>0.0 && uv.x<1.0 &&\n           uv.y>0.0 && uv.y<1.0 )\n        {\n            vec2 tuv = inversePerspective_uv(perspectiveCam, uv, ssQuad, wsQuad);\n        \tvec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*0.25);\n            cScene = alphaBlend(cScene,cTest,0.5);\n        }\n    }\n    \n    return cScene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float perspectiveImageSize = 0.25;\n    float fZoom = 3.0*iResolution.x/1920.;\n    \n    vec2 perspective_uv = pixel2uv(fragCoord/perspectiveImageSize, true, true);\n    vec2 perspective_mouse_uv = pixel2uv(iMouse.xy/perspectiveImageSize, true, true);\n\t\n    worldSpaceQuad wsQuad;\n    screenSpaceQuad ssQuad = setupPerspectiveQuad(perspective_mouse_uv);\n    Cam perspectiveCam = setupPerspectiveCamera();\n    resolvePerspective(perspectiveCam,ssQuad,wsQuad);\n    \n    //Perspective view\n    if(fragCoord.x<iResolution.x*perspectiveImageSize && fragCoord.y<iResolution.y*perspectiveImageSize)\n    {\n        vec3 cPerspective = drawPerspectiveScene(perspectiveCam, perspective_uv, ssQuad, wsQuad, vec3(0.55), fZoom*perspectiveImageSize);\n        fragColor = vec4(cPerspective,1.0);\n    }\n    //Inverse view\n    else if(fragCoord.x>iResolution.x*(1.0-perspectiveImageSize) && fragCoord.y<iResolution.y*perspectiveImageSize)\n    {\n        vec2 fragCoordLocal = vec2( fragCoord.x-iResolution.x*(1.0-perspectiveImageSize),fragCoord.y);\n        vec2 inverse_perspective_uv = pixel2uv(fragCoordLocal/perspectiveImageSize, false, false);\n        \n        vec2 tuv = inversePerspective_uv(perspectiveCam, inverse_perspective_uv, ssQuad, wsQuad);\n        vec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*perspectiveImageSize);\n        fragColor = vec4(cTest,1.0);\n    }\n    //3D Scene\n    else\n    {\n        vec2 uvScene = pixel2uv(fragCoord, true, true);\n\t    Cam sceneCam = setupSceneCamera();\n\t    vec3 cScene = draw3DScene(perspectiveCam, sceneCam, uvScene, wsQuad, ssQuad);\n        fragColor = vec4(cScene,1.0);\n    }\n}\n\nCam CAM_lookAt(vec3 at, float fPitch, float dst, float rot) \n{ \n    Cam cam;\n    cam.D = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.U = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.R = cross(cam.D,cam.U); cam.O = at-cam.D*dst;\n    return cam;\n}\nCam CAM_mouseLookAt(vec3 at, float dst)\n{\n    vec2 res = iResolution.xy; vec2 spdXY = vec2(15.1416,4.0);\n    float fMvtX = (iMouse.x/res.x)-0.535;\n    if(fMvtX>0.3) dst *= (1.0+(fMvtX-0.3)/0.03);\n    else if(fMvtX<-0.3) dst *= (1.0-(fMvtX+0.3)/(-0.2));\n\tfMvtX += iTime*0.0150;//Auto turn\n    return CAM_lookAt(at,spdXY.y*((iMouse.y/res.y)-0.5),dst,spdXY.x*fMvtX);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscSW8", "name": "Crosses", "author": "anastadunbar", "description": "Original animation by Dave Whyte http://bit.ly/1RrlZYP. Took long because I was too stupid to find out x/(1+x).", "tags": ["2d", "simple", "blackandwhite", "droste", "loop", "trippy", "falling", "hypnotizing", "gif", "zooming"], "likes": 10, "viewed": 633, "date": "1458962392", "time_retrieved": "2024-06-20T18:34:04.066345", "image_code": "vec2 rotate(float angle,vec2 position)\n{\n    mat2 matrix = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    return position*matrix;\n}\nfloat logn(float a,float b) { return log(a)/log(b); }\n#define clamps(x) clamp(x,0.,1.)\nfloat texture1(vec2 uv2,vec2 uv,float in_scale,float id) {\n    float c = 0.;\n    //(uv2.y*2.)/(1.-in_scale); (1.-in_scale)/2.;\n    uv2 -= .5;\n    float thickness = in_scale/(1.+in_scale); float sharpness = 4000.;\n    c = ((min(abs(uv2.x),abs(uv2.y))*2.)-thickness)*sharpness;\n    if (mod(id,2.) == 0.) {\n      c = -(((min(abs(uv2.y+uv2.x),abs(uv2.y-uv2.x))*2.)-thickness)*sharpness);  \n    }\n    c = clamps(c);\n    return c;\n}\nfloat texture2(vec2 uv, float time) {\n    uv = rotate(time,uv);\n    float fracttime = mod(time,2.);\n    float in_scale = .07; //How deep?\n    vec2 zuv = uv*pow(in_scale,fracttime); //Zooming\n    float d = (max(abs(zuv.x),abs(zuv.y))*2.); //Square dist\n    float id = floor(logn(d,in_scale));\n    vec2 uv2 = (zuv/pow(in_scale,id))+.5;\n    return texture1(uv2,uv,in_scale,id);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime*.5;\n    vec2 uv = (fragCoord.xy/iResolution.xy)-.5;\n    uv.x /= iResolution.y/iResolution.x;\n    float c = 0.;\n    #define LOOPS 8.\n    for (float i = 0.; i < LOOPS; i++) {\n        c += texture2(uv+(vec2(cos(i),sin(i))*.0005),time-(i*.003));\n    }\n    fragColor = vec4(vec3(c/LOOPS),1.);\n}\n\n//in_scale = 0.999 is same as ((uv/d)+1.)/2.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscSz8", "name": "Sphere Smooth movement", "author": "sagar_unityDev", "description": "Showcases smooth movement of spheres through each other.", "tags": ["raymarching", "geometry"], "likes": 3, "viewed": 293, "date": "1457581275", "time_retrieved": "2024-06-20T18:34:04.927022", "image_code": "// as learned from the excellent tutorial by @uint9\n// http://9bitscience.blogspot.de/2013/07/raymarching-distance-fields_14.html\n// distance functions by iq\n\nconst int RM_STEPS = 64;\nconst float RM_TOLERANCE = 0.001;\nconst float FOCAL_LENGTH = 1.2;\nconst float NEAR = 0.01;\nconst float FAR = 5.0;\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y + 0.1;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(100.,0.1,0.1));\n  float db = sdBox(p.yzx,vec3(0.1,100.,0.1));\n  float dc = sdBox(p.zxy,vec3(0.1,0.1,100.));\n  return smin(da,smin(db,dc, 64.), 64.);\n}\n \n\nfloat sdf(vec3 p) {\n  //p.x = mod(p.x, 0.5) - 0.25;\n  //p.z = mod(p.z, 1.0) - 0.5;\n  float sphere = sdSphere(p, 0.1);\n  float plane = sdPlane(p);\n  float offset = mod(iTime,4.0) <= 2.0 ? mix(0.5, -0.5, mod(iTime,2.0)*0.5) : mix(-0.5, 0.5, mod(iTime,2.0)*0.5);\n  float sphere1 = sdSphere(vec3(p.x+offset, p.y, p.z), 0.1);\n  //sphere = min(1., sdCross(p));\n  sphere = smin(sphere, sphere1, 32.);\n  return min(sphere, plane);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tsdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n\t\tsdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n\t\tsdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))));\n}\n\nfloat getShadow(vec3 p0, vec3 p1, float k) {\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0 * RM_TOLERANCE;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0;\n\tfor(int i = 0; i < RM_STEPS; ++i)\n\t{\n\t\tfloat d = sdf(p0 + rd * t);\n\t\tif(d < RM_TOLERANCE)\n\t\t\treturn 0.0;\n\t\tf = min(f, k * d / t);\n\t\tt += d;\n\t\tif(t >= maxt)\n\t\t\tbreak;\n\t}\n\treturn f;\n}\n\nvoid raymarch(vec3 ro, vec3 rd, out int steps, out float t) {\n\tt = 0.0;\n    for(int j = 0; j < RM_STEPS; ++j) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if(d < RM_TOLERANCE) {\n         \tsteps = j;   \n            break;\n        }\n        t += d;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eye = vec3(0, 0, -1.0);\n    vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y = uv.y * iResolution.y/iResolution.x;\n    \n    vec3 ro = eye;\n    vec3 rd = normalize(cross(right, up) * FOCAL_LENGTH + right * uv.x + up * uv.y);\n\n    vec4 lightColor1 = vec4(0.8, 1.0, 1.0, 1.0);\n    vec3 lightPosition1 = vec3(\n        sin(iTime) * 2.0,\n        2.0,\n        cos(iTime) * 2.0\n    );\n    vec4 lightColor2 = vec4(1.0, 1.0, 0.8, 1.0);\n    vec3 lightPosition2 = vec3(\n        cos(iTime) * 2.0,\n        2.0,\n        sin(iTime) * 2.0\n    );\n    \n    vec4 ambientColor = vec4(vec3(0.1),1.0);\n    vec4 color = vec4(0.9); // Sky color\n    \n    // rotate camera\n\tmat3 rot = rotationXY( vec2( 0.4, 0.0 ) );\n\trd = rot * rd;\n\tro = rot * ro;  \n\n    float t = 0.0;\n    int i = 0;\n    raymarch(ro, rd, i , t);\n    \n    vec3 p;\n    if(t > NEAR && t < FAR) {\n    \tp = ro + rd * t;\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        \n    \tfloat lightIntensity1 = 0.0;\n        float lightIntensity2 = 0.0;\n    \tfloat shadow1 = getShadow(p, lightPosition1, 8.0);\n        float shadow2 = getShadow(p, lightPosition2, 8.0);\n        \n        if(shadow1 > 0.0) {\n            lightIntensity1 = clamp(\n                dot(getNormal(p), lightDirection1), 0.0, 1.0\n            ) * shadow1;\n        }\n        if(shadow2 > 0.0) {\n            lightIntensity2 = clamp(\n                dot(getNormal(p), lightDirection2), 0.0, 1.0\n            ) * shadow2;\n        }\n        \n        color = smoothstep(\n            vec4(0.0),\n            vec4(1.8),\n            lightColor1 * lightIntensity1 +\n           \tlightColor2 * lightIntensity2 +\n           \tambientColor * (1.0 - lightIntensity1 * lightIntensity2));\n    }\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscSzn", "name": "Analytic Cube Array", "author": "Bers", "description": "An exercise with analytic (no distance field) ray-cube intersections.", "tags": ["raycast", "cube", "analytic"], "likes": 8, "viewed": 656, "date": "1457307752", "time_retrieved": "2024-06-20T18:34:05.624103", "image_code": "// Author : Sbastien Brub\n// Created : Sept 2014\n// Modified : Feb 2016\n//\n// An exercise with analytic (no distance field) ray-cube intersections.\n// \n// License : Creative Commons Non-commercial (NC) license\n\nconst float MAX_DIST = 2000.0;\nfloat CELL_SIZE = 8.0;\nstruct Cam\n{\n    vec3 R; //right\n    vec3 U; //up\n    vec3 D; //dir\n    vec3 o; //origin\n};\n    \nCam lookAt(vec3 at, float fPitch, float dst, float rot)\n{\n\tCam cam;\n    cam.D = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.U = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.R = cross(cam.D,cam.U);\n    cam.o = at-cam.D*dst;\n    return cam;\n}\n\nCam mouseLookAt(vec3 at, float dst)\n{\n    vec2 speed = vec2(3.1416,4.0);\n    vec2 mvt   = ((iMouse.xy/iResolution.xy)-0.5)*speed;\n    return lookAt(at,mvt.y,dst,mvt.x);\n}\n\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\nvec3 ray(vec2 uv, Cam cam)\n{\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\nfloat _sign(float x)\n{\n    return (x>0.)?1.:-1.;\n}\n\nvec3 rotate(vec3 p, const float yaw, const float pitch)\n{\n    p.xz = vec2( p.x*cos(yaw)+p.z*sin(yaw),\n                 p.z*cos(yaw)-p.x*sin(yaw));\n    p.yz = vec2( p.y*cos(pitch)+p.z*sin(pitch),\n                 p.z*cos(pitch)-p.y*sin(pitch));\n    return p;\n}\n\nstruct hitInfo\n{\n\tfloat dist;\n    vec2 uv;\n};\n\n//ro = ray origin\n//rd = ray direction\nhitInfo rayCubeIntersec(vec3 ro, vec3 rd, vec3 size)\n{\n    float cullingDir = all(lessThan(abs(ro),size))?1.:-1.;\n    vec3 viewSign = cullingDir*sign(rd);\n    vec3 t = (viewSign*size-ro)/rd;\n    vec2 uvx = (ro.zy+t.x*rd.zy)/size.zy; //face uv : [-1,1]\n    vec2 uvy = (ro.xz+t.y*rd.xz)/size.xz;\n    vec2 uvz = (ro.xy+t.z*rd.xy)/size.xy;\n    if(      all(lessThan(abs(uvx),vec2(1))) && t.x > 0.) return hitInfo(t.x,(uvx+1.)/2.);\n    else if( all(lessThan(abs(uvy),vec2(1))) && t.y > 0.) return hitInfo(t.y,(uvy+1.)/2.);\n    else if( all(lessThan(abs(uvz),vec2(1))) && t.z > 0.) return hitInfo(t.z,(uvz+1.)/2.);\n\treturn hitInfo(MAX_DIST,vec2(0));\n}\n\nhitInfo rayMarchArray(vec3 origin, vec3 dir)\n{\n    vec3 size = vec3(0.95,0.95,0.95);\n    float t=1.0;\n    hitInfo info;\n    for(int i=0; i < 100; ++i)\n    {\n        //Cube position\n        vec3 p = origin+t*dir;\n        vec3 cubePos = floor(p/CELL_SIZE)*CELL_SIZE+0.5*CELL_SIZE;\n        \n        //rotation values\n        float yaw = sin(iTime+cubePos.x+cubePos.y+cubePos.z);\n        float pitch = iTime/1.0+sin(iTime+cubePos.x+cubePos.y+cubePos.z);\n    \t\n        //rotated ray origin and direction\n        vec3 rd = rotate(dir,yaw,pitch);\n\t\tvec3 ro = rotate(origin-cubePos,yaw,pitch);\n        \n        //ray-cube intersection function\n        info = rayCubeIntersec(ro,rd,size);\n        \n        //check for hit : stop or continue.\n        if(info.dist<MAX_DIST)\n        \tbreak;\n        \n        //Step into the next cell.\n        t = t+CELL_SIZE; \n    }\n    return info;\n}\n\nvec3 subMain(vec2 uv)\n{\n    Cam cam = mouseLookAt(vec3(2,2.0,-12.0),5.0);\n    vec3 dir     = ray(uv,cam);\n\tvec3 origin  = vec3(1.5*sin(iTime/1.21),1.5*sin(iTime/1.00),6.4*iTime);\n    \n    hitInfo info = rayMarchArray(origin,dir);\n    \n    vec3 color = texture(iChannel0,info.uv,-2.0).xyz;\n    return mix(color,vec3(1.0,1.0,1),info.dist/400.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(subMain(uv),1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscXRH", "name": "Combustible Clouds", "author": "Shane", "description": "A daytime version of my \"Cheap Cloud Flythrough\" example.", "tags": ["noise", "cloud", "volumetric", "sinusoidal", "flythrough"], "likes": 82, "viewed": 3855, "date": "1457616278", "time_retrieved": "2024-06-20T18:34:07.345466", "image_code": "/*\n\n\tCombustible Clouds\n\t------------------\n\t\n\tThis is just a daytime version of my cheap cloud flythrough example. I'm not sure why\n\tthe clouds exist in a combustible atmosphere, or if that's even possible... but it's \n\tjust a cheap hack, so isn't meant to be taken seriously. :)\n\n\tObviously, the object of the exercise was speed, rather than quality, so it should run\n\tpretty well on even the slowest of machines. With that said, the quality is pretty good,\n\tall things considered.\n\t\n\tBased on:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n*/\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat n3D( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n/*\n// Textureless 3D Value Noise:\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n*/\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = n3D(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\n// Distance function.\nfloat map(vec3 p) {\n\n    return trigNoise3D(p*.5);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return n3D(p*.75)*.57 + n3D(p*1.875)*.28 + n3D(p*4.6875)*.15;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.1875); \n    mat2 rM = mat2(a, -a.y, a.x);\n    \n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    a = sin(vec2(1.5707963, 0) + cos(iTime*0.1875*.7)*.7);\n    rM = mat2(a, -a.y, a.x); \n    rd.xz = rd.xz*rM;\n\n    // Placing a light in front of the viewer and up a little. You could just make the \n    // light directional and be done with it, but giving it some point-like qualities \n    // makes it a little more interesting. You could also rotate it in sync with the \n    // camera, like a light beam from a flying vehicle.\n    vec3 lp = vec3(0, 1, 6);\n    //lp.xz = lp.xz*rM;\n    lp += ro;\n    \n    \n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + (hash33(rd.zyx)*0.004-0.002)); \n    // Randomizing the length also. \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.04-0.02);  \n    \n    //rd = rd*.5 + normalize(rd)*.5;    \n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    vec3 rnd = hash33(rd + 311.);\n\n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = dot(rnd, vec3(.08));\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.001*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d) * step(d, h); \n        w = (1. - td) * lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*0.1 + lDist*lDist*.03);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot(sn, ld ), 0.);\n        float spec = pow(max(dot( reflect(-ld, sn), -rd ), 0.), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        col += w*(1.+ diff*.5 + spec*.5)*atten;\n        // Optional extra: Color-based jittering. Roughens up the grey clouds that hit the camera lens.\n        col += (fract(rnd*289. + t*41.) - .5)*.02;;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += 0.2; // t += d*0.5;// These also work, but don't seem as efficient.\n\n    }\n    \n    col = max(col, 0.);\n\n    \n    // Adding a bit of a firey tinge to the cloud value.\n    col = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.2+.8);\n \n    // Using the light position to produce a blueish sky and sun. Pretty standard.\n    vec3 sky = vec3(.6, .8, 1.)*min((1.5+rd.y*.5)/2., 1.); \t\n    sky = mix(vec3(1, 1, .9), vec3(.31, .42, .53), rd.y*0.5 + 0.5);\n    \n    float sun = clamp(dot(normalize(lp-ro), rd), 0.0, 1.0);\n   \n    // Combining the clouds, sky and sun to produce the final color.\n    sky += vec3(1, .3, .05)*pow(sun, 5.)*.25; \n    sky += vec3(1, .4, .05)*pow(sun, 16.)*.35; \t\n    col = mix(col, sky, smoothstep(0., 25., t));\n \tcol += vec3(1, .6, .05)*pow(sun, 16.)*.25; \t\n \n    // Done.\n    fragColor = vec4(sqrt(min(col, 1.)), 1.0);\n    \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscXRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscXW4", "name": "tweaked spline", "author": "adrians", "description": "tweaked cubic root finder to avoid trig", "tags": ["spline"], "likes": 11, "viewed": 176, "date": "1459286622", "time_retrieved": "2024-06-20T18:34:08.266629", "image_code": "// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq, T21, and demofox\n// \n// I needed the -signed- distance to a quadratic bezier\n// curve but couldn't find any examples online that\n// were both fast and precise. This is my solution.\n//\n// v1 - Initial release\n// v2 - Faster and more robust sign computation\n//\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nvec2 cossin_third(float x) {\n    float c = (0.866017 +1.25203 * x + 0.431996 * x * x + 0.0161423 * x * x * x)\n        /(1.0 + 1.25325 * x + 0.312933 * x * x);\n    \n//    float c = (0.871828 + 1.03347 * x + 0.110724 * x*x - 0.0657648 * x*x*x)/(1.0 + 0.970619 * x);\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n#if 0\n    float v = acos(x) / 3.0;\n//  return vec2(cos(v), sin(v));\n    \n    float t = -cbrt(sqrt(x * x - 1.0) - x);\n    float c = (t + 1.0 / t) / 2.0;\n    float s = sqrt(1.0 - c * c);\n    return vec2(c, s);\n   #endif\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c, out int type)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        type = 1;\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    type = 0;\n    vec2 cs = cossin_third(-sqrt(-27.0 / p3) * q / 2.0);\n    float m = cs.x, n = cs.y * 1.732050808;\n//  float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n//  float m = cos(v), n = sin(v)*1.732050808;  \n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\nvec2 sincos(float t) {\n    return vec2(cos(t), sin(t));\n}\nvec3 solveCubic2(float a, float b, float c, out int type) {\n    float sqrt3 = 1.732050808;\n\n\tfloat\te\t= a / 3.0;\n\tfloat\tf\t= e * e - b / 3.0;\n\tfloat\tg\t= (e * b - c) / 2.0 - e * e * e;\n\tfloat\th\t= g * g - f * f * f;\n\n\tif (h < 0.0) {\n\t\t//3 real roots\n        type = 0;\n\t\tvec2\tt\t= sincos(atan(g, sqrt(-h) * sign(g)) / 3.0);\n\t\treturn (vec3(2, -1, -1) * t.x + vec3(0, -sqrt3, sqrt3) * t.y) * sqrt(f) - e;\n\t} else if (h > 0.0) {\n\t\t//1 real root, 2 imaginary (y + iz) & (y - iz)\n        type = 1;\n        float\tz = sqrt(h);\n        vec2\tx = vec2(z, -z) + g;\n\t\tvec2\tt = sign(x) * pow(abs(x), vec2(1.0/3.0));\n\t\treturn vec3(t.x + t.y - e);\n//\t\treturn vec3(1, -0.5, sqrt3/2.0) * t.x + vec3(1, -0.5, sqrt3/2.0) * t.y - vec3(e, e, 0);\n\t} else {\n\t\t//3 real and equal\n        type = 2;\n\t\treturn vec3(pow(-c, 1.0 / 3.0));\n\t}\n}\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out int type)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(solveCubic(k.x, k.y, k.z, type), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.4, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    // Get the signed distance to bezier curve\n    int\ttype;\n    d = sdBezier(A, B, C, p, type);\n    \n    // Visualize the distance field using iq's orange/blue scheme\n    vec4 col = vec4(type == 0, type == 1, type == 2, 1);\n    if (d < 0.0)\n        col *= 0.5;\n    fragColor = col * (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsdXzM", "name": "Boat drawing", "author": "gael", "description": "My first drawing with glsl. Trying to make a boat, floating on the sea....", "tags": ["2d", "drawing", "boat"], "likes": 9, "viewed": 199, "date": "1458491493", "time_retrieved": "2024-06-20T18:34:08.266629", "image_code": "// My first drawing with glsl\n// Trying to make a boat, floating on the sea....\n\nvoid rotate(inout vec2 p, float a, vec2 center) {\n    p -= center;\n    p *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    p += center;\n}\n\nfloat body(in vec2 p) {\n    // Scale and position body    \n    p.x -= 0.5;\n    p.y *= 1.8;\n    p.x *= 1.5;\n    \n    float f = 1.;\n    \n    // Shape\n    f *= smoothstep(0.3, 0.31, p.y);\n    f *= 1. - smoothstep(0.6, 0.61, p.y);\n    f *= 1. - smoothstep(0.3, 0.31, abs(p.x) - (p.y * 0.5 - 0.2));\n    \n    return f;\n}\n\nfloat pole(in vec2 p) {    \n \tfloat f = 1.;\n    \n    p.y -= 0.2;\n    p.x -= 0.5;\n    p.x *= 10.5;\n    \n    f *= 1. - smoothstep(0.1, 0.11, abs(p.x));\n    f *= step(0.0, p.y);\n    f *= 1. - smoothstep(0.6, 0.61, p.y);\n    \n    return f;\n}\n\nfloat sail1(in vec2 p) {    \n \tfloat f = 1.0;\n    \n    p.y -= 0.40;\n    p.x -= 0.512;\n    p.y *= 3.78;\n    p.x *= 1.5;\n    \n    f *= smoothstep(0., 0.01, p.x);\n    f *= smoothstep(0., 0.01, p.y);\n    f *= 1. - smoothstep(0.3, 0.31, p.x + p.y * 0.2);\n    \n    return f;\n}\n\nfloat sail2(in vec2 p) {    \n \tfloat f = 1.0;\n    \n    p.y -= 0.40;\n    p.x -= 0.488;\n    p.y *= 4.;\n    p.x *= -2.;\n    \n    f *= smoothstep(0., 0.01, p.x);\n    f *= smoothstep(0., 0.01, p.y);\n    f *= 1. - smoothstep(0.3, 0.31, p.x + p.y * 0.2);\n    \n    return f;\n}\n\nvec3 boat(in vec3 background, in vec2 p) {\n \tvec3 color = background;\n    \n    p.x *= 0.8;\n    p.x -= 0.2;\n    p.y += cos(iTime * 1.3) * 0.04;\n    rotate(p, sin(iTime) * 0.2, vec2(0.5, 0.1));\n    color = mix(color, vec3(0.26, 0.61, 0.26), pole(p));\n    color = mix(color, vec3(0.76, 0.13, 0.13) + vec3(0.2) * p.y, sail1(p));\n    color = mix(color, vec3(0.76, 0.13, 0.13) + vec3(0.2) * p.y, sail2(p));\n    color = mix(color, vec3(0.54, 0.40, 0.05), body(p));     \n    \n    return color;\n}\n\nvec3 water(in vec3 background, in vec2 p) {\n    vec3 color = vec3(0.1, 0.3, 0.5);\n    \n    p.y -= 0.13;\n    \n    float f = 1. - smoothstep(0.1, 0.11,\n                         p.y + sin(p.x * 20. + iTime * 2.)\n                         * 0.03 * cos(p.x * 5. + iTime * 2.));\n\n    color = mix(background, color, f);\n    \n    return color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    // Fix ratio\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.);    \n    \n    // Background\n    color += mix(vec3(0.58, 0.8, 1.0), vec3(0.95, 1., 0.9), sqrt(p.y) - 0.5);\n    \n    color = boat(color, p);\n    color = water(color, p);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsdXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfSR4", "name": "SPADES", "author": "cafe", "description": "SPEDES", "tags": ["spaed"], "likes": 2, "viewed": 96, "date": "1456829875", "time_retrieved": "2024-06-20T18:34:08.618280", "image_code": "float PI=3.14159;\n\nvec3 dcol=vec3(-1.);\n\nfloat sine(float x){\n\treturn pow(sin(x*PI/2.),2.);\n\treturn (sin((x-0.5)*PI)+1.)/2.;\n}\n\n// (current position, polygon center, polygon sides num, polygon \"radius\"\nfloat poly(vec2 uv, vec2 c, float s, float r){\n\tvec2 d = uv-c;\n\n\tfloat ang = atan(d.x,d.y)+PI;\n\t//ang = cos(abs(mod(ang,1./s)*s-0.5)*2.);\n\t\n\t//dcol.r=mod(ang/2.,PI/s);\n\t\n\treturn length(d)+ang/(sin(iTime)/PI+1.+1.);\n}\n\nfloat spade(vec2 uv){\n\tuv.y+=0.5;\n\tfloat ang = abs(atan(uv.x,-uv.y)/PI);\n\t\n\tfloat slices = 50.;\n\tfloat angmod = sine(mod(ang,2./slices)*slices-1.);\n\t\n\tangmod = min(angmod,length(uv)*1.5-0.4);\n\t\n\tangmod=angmod*2.+sin(iTime);\n\t\n\t\n\t\n\tfloat c = length(uv)/ang;\t\n\t\n\tfloat modu=10.*ang;\n\t\n\tc = modu*(c-1.);\n\t\n\tc = c * angmod;\n\t\n\t//float br = abs(ang*(1.-length(uv)))*20.-6.;\n\t\n\treturn c;\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n\t\n\tvec3 color = vec3(spade(uv));\n\t\n\t//For debugging purposes\n\tif(any(greaterThanEqual(dcol,vec3(0.)))) color=dcol;\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfSR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsK3D3", "name": "First try distance field", "author": "marcell", "description": "distance field", "tags": ["sphere"], "likes": 3, "viewed": 152, "date": "1456846844", "time_retrieved": "2024-06-20T18:34:08.618280", "image_code": "\nfloat plane(vec3 pos)\n{\n    return pos.y;\n}\n\nfloat sphere(vec3 p, float radius)\n{\n     return length(p) - radius;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat map(vec3 p)\n{\n    float ground = plane(p + vec3(0, 1.5, 0));\n    \n    float dom = 6.0;\n    p.x = mod(p.x, dom) - 0.5 * dom;\n    p.z = mod(p.z, dom) - 0.5 * dom;\n    \n    float _box = box(p + vec3(0.5 * sin(iTime), -0.3, 0.0), vec3(2.0, 1.0, 0.55));\n    float _sphere = sphere(p - vec3(0.5 * sin(iTime), 1.0, 0.0), 1.0);\n    _sphere = max(_box, -_sphere);\n    \n    return min(_sphere, ground);\n}\n\nconst float E = 0.001;\nvec3 get_normal(vec3 p)\n{\n    vec2 eps = vec2(0.0, E);\n    vec3 normal = normalize(vec3(\n        map(p + eps.yxx) - map(p - eps.yxx),\n        map(p + eps.xyx) - map(p - eps.xyx),\n        map(p + eps.xxy) - map(p - eps.xxy)));\n    \n    return normal;\n}\n\nfloat shadow(vec3 lp, vec3 ld)\n{\n    float t = 0.5;\n    for(int i = 0; i < 8; i++)\n    {\n        float h = map(lp + ld * t);\n        if(h < 0.1)\n        {\n            return 0.0;\n        }\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 pos = vec3(0.0, 6.0, 6.0);\n    vec3 dir = normalize(vec3(v.x, v.y, -1.0));\n    \n    vec3 light_dir = normalize(vec3(10.0 * sin(iTime), 15.0, 10.0));\n    \n    vec3 color = vec3(0.0);\n    float d;\n    \n    for(int i = 0; i < 128; i++)\n    {\n        d = map(pos);\n        if(d < E)\n        {\n            color = dot(get_normal(pos), light_dir) * vec3(0.4, 0.7, 0.4)/* * shadow(pos, light_dir)*/;\n            break;\n        }\n        pos += d * dir;\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsK3D3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MslSWr", "name": "CafeRayTracing", "author": "cafe", "description": "CafeRayTracing", "tags": ["caferaytracing"], "likes": 2, "viewed": 120, "date": "1456828978", "time_retrieved": "2024-06-20T18:34:08.618280", "image_code": "float bounce(float x, float a){\n\treturn a-abs(a-mod(x,a*2.));\n}\n\nfloat distfloor(vec3 ro, vec3 rd){\n\treturn 2./rd.y;\n}\n\nfloat distsphere(vec3 ro, vec3 rd){\n\tfloat d1 = dot(-ro,rd);\n\tfloat d2 = sqrt(dot(ro,ro)-d1*d1);\n\tfloat d3 = sqrt(1.-d2*d2);\n\treturn d2<1.?d1-d3:-1.;\n}\n\nvec3 texskybox(vec3 p){\n\tfloat md=clamp(sin(p.y+iTime),0.9,1.)*-0.1+0.1;\n\tp.xz=vec2(cos(atan(p.x,p.z)+md),sin(atan(p.x,p.z)+md))*length(p.xz);\n\treturn (vec3(0.5,0.5,0.5)+sign(p)*vec3(0.2,0.,-0.3))*smoothstep(-0.1,0.1,sin(p.x*10.)*sin(p.y*10.)*sin(p.z*10.))*smoothstep(10.,3.,length(p))*1.5+md*2.;\n}\n\n\nfloat distskybox(vec3 ro, vec3 rd){\n\t\n\tvec3 t = abs(5./rd)-ro/rd;\n\t\n\treturn min(t.x,min(t.y,t.z));\n}\n\nvec3 texsphere(vec3 p, vec3 r){\n\t\n\tfloat difindex=2.;\n\t\n\tfloat md=dot(-p,r)*(1.-1./difindex);\n\t\n\tvec3 pr=normalize(r-p*md);\n\t\n\tvec3 pp=reflect(p,pr);\n\t\n\tpp=pp;\n\t\n\tfloat d=distskybox(pp,r);\n\tfloat d2=distskybox(p,reflect(r,p));\n\tvec3 color = texskybox(pp+r*d);\n\tvec3 color2 = texskybox(p+d2*reflect(r,p));\n\t\n\tcolor += color2*(0.5+2.*color);\n\n\treturn mix(color,vec3(0.7,0.9,1.),0.2);\t\n}\n\nfloat intersect(vec3 ro, vec3 rd, out float d){\n\tfloat d1=distskybox(ro,rd);\n\tfloat d2=distsphere(ro,rd);\n\t\n\tif(d2>0.){\n\t\td=d2;\n\t\treturn 2.;\n\t}\n\t\n\tif(d1>0.){\n\t\td=d1;\n\t\treturn 1.;\n\t}\n\treturn 0.;\t\n}\n\nvec3 shade(vec2 uv){\n\t\n\tvec3 ro = vec3(cos(iTime),sin(iTime),-4.);\n\tvec3 rd = normalize(vec3(uv,1.));\n\t\n\tvec3 color=vec3(1.,0.,1.);\n\t\n\tfloat d=0.;\n\tfloat i=intersect(ro,rd,d);\n\t\n\tvec3 p=ro+d*rd;\n\t\n\tif(i==1.)\n\t\tcolor=texskybox(p);\n\tif(i==2.){\n\t\tvec3 n=normalize(d*rd+ro);\t\n\t\t//color=n/2.+vec3(0.5);\n\t\tcolor=texsphere(p,rd);\n\t\tvec3 specvec = reflect(rd,n);\n\t\tcolor+=smoothstep(0.95,0.98,dot(specvec,normalize(vec3(1.,1.,-1.)-p)))*0.8-0.02;\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MslSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MssSDn", "name": "CafeRaymarchExperiment2", "author": "cafe", "description": "CafeRaymarchExperiment2", "tags": ["caferaymarchexperiment2"], "likes": 4, "viewed": 110, "date": "1456828955", "time_retrieved": "2024-06-20T18:34:08.618280", "image_code": "const float PI=3.14159;\n\nfloat hash(float x){ return fract(sin(x)*43758.5453);}\nfloat hash(vec2 x){ return hash(hash(x.x)+x.y); }\nfloat hash(vec3 x){ return hash(hash(x.xy)*x.z); }\n\nfloat shash(vec3 x){\n\tvec3 ix=floor(x);\n\tvec3 fx=smoothstep(0.,1.,fract(x));\n\tvec3 e=vec3(1.,0.,0.);\n\t\n\t//return mix(ix,fx,0.5).x;\n\t\n\t/*\n\tvec2 r = vec2(vec4(vec2(ha1sh(ix+e.yyy),hash(ix+e.yxy)),vec2(hash(ix+e.xyy),hash(ix+e.xxy)))*fx.x),\n\t\t       (vec4(vec2(hash(ix+e.yyx),hash(ix+e.yxx)),vec2(hash(ix+e.xyx),hash(ix+e.xxx)))*fx.x)*fx.z;\n\t\n\t/*/\n\treturn\n\tmix(mix(mix(hash(ix+e.yyy),hash(ix+e.xyy),fx.x),\n\t\t\tmix(hash(ix+e.yxy),hash(ix+e.xxy),fx.x),fx.y),\n\t\tmix(mix(hash(ix+e.yyx),hash(ix+e.xyx),fx.x),\n\t\t\tmix(hash(ix+e.yxx),hash(ix+e.xxx),fx.x),fx.y),fx.z);\n\t//*/\n}\n\nfloat box(vec3 p, float d){\n\tp = abs(p)-d;\n\treturn min(max(p.x,max(p.y,p.z)),0.)+length(max(p,0.));\n}\nfloat box(vec2 p, float d){\n\treturn box(vec3(p,0.),d);\n}\nfloat crossb(vec3 p){\n\treturn min(box(p.xy,1.),min(box(p.xz,1.),box(p.yz,1.)));\n}\n\nfloat cube(vec3 p){\n\t\n\t//p=normalize(p)*dot(p,vec3(1.));\n\t\n\tfloat d = box(p,1.0);\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = 1.0 - 3.0*abs(a);\n\n      float c = crossb(r)/s;\n      d = max(d,c);\n   }\n\treturn d+0.01*sin(iTime*-3.+length(p)*10.);\n\n}\n\n\nvec3 tex(vec3 p, float mat){\n\tvec3 color;\n\t\n\t\n\t\n\tif(mat==0.){\n\t\tfloat d=5.;\n\t\tvec3 md = vec3(0.15,0.05,0.1);\n\t\tcolor=vec3(smoothstep(-0.1,0.1,sin(p.x*d)*sin(p.y*d)*sin(p.z*d)));\n\t\tcolor.r=smoothstep(0.35,0.65,color.r);\n\t\tcolor.g=smoothstep(0.45,0.55,color.b);\n\t\tcolor.b=smoothstep(0.4,0.6,color.g);\n\t\tcolor=mix(color,vec3(0.1,0.3,0.6),0.35);\n\t}\n\t\n\tif(mat==1.){\n\t\tcolor=vec3(1.5,1.1,0.8)*(sin(length(p)*10.)*0.1+0.6);\n\t}\n\t\n\treturn clamp(color,0.,1.);\n}\n\nvec2 map(vec3 p){\n\tfloat d=5.;\n\tvec2 t0=vec2(5.-max(abs(p.x),max(abs(p.y),abs(p.z))),0.);\n\tvec2 t1=vec2(cube(p),1.);\n\tif(t1.x<t0.x)t0=t1;\n\treturn t0;\n}\n\nvec3 normal(vec3 p){\n\tvec3 e=vec3(0.001,0.,0.);\n\tvec3 n=vec3(\n\t\tmap(p+e.xyy).x-map(p-e.xyy).x,\n\t\tmap(p+e.yxy).x-map(p-e.yxy).x,\n\t\tmap(p+e.yyx).x-map(p-e.yyx).x);\n\treturn normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd){\n\tconst int iter=200;\n\tconst float mint=0.0005;\n\tfloat t=0.;\n\tfor(int i=0 ; i<iter ; i++){\n\t\tvec2 h = map(ro+t*rd);\n\t\tif(h.x<mint*1.) return vec2(t,h.y);\n\t\tt+=max(mint*t,h.x);\n\t}\n\treturn vec2(-1.);\n}\n\n\nvec3 shade(vec2 uv){\n    \n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n\tvec3 ro=vec3(sin(mouse.x*PI/2.)*2.,sin(mouse.y*PI/2.)*2.,2.);\n\tro.z=cos(length(ro.xy)*PI/2.)*0.1+1.9;\n\t\n\tvec3 lat=vec3(0.,0.,0.);\n\tvec3 dir = normalize(lat-ro);\n\tvec3 axr  = normalize(cross(dir,vec3(0.,1.,0.)));\n\tvec3 axu  = normalize(cross(axr,dir));\n\tvec3 rd = normalize(uv.x*axr+uv.y*axu+dir);\n\t\n\tvec2 t = intersect(ro,rd);\n\tvec3 color=vec3(0.);\n\t\n\tif(t.y>=0.){\n\t\tvec3 p = ro+t.x*rd;\n\t\tvec3 n = normal(p);\n\t\tvec3 l = normalize(vec3(1.,1.,1.));\n\t\t\n\t\t\t\t\n\n\t\t\n\t\t\n\t\tfloat amb=0.5+0.5*n.y;\n\t\tfloat dif=pow(max(0.,dot(n,l)),3.);\n\t\tfloat brightness=(sin(length(p)*2.+iTime)+2.)/2.5;\n\t\t\n\t\tcolor  = amb*vec3(0.2);\n\t\tcolor += dif;//-hash(floor(p*10.-0.5))*(length(fract(p*10.)-0.5)*-1.+0.5);\n\t\tcolor += brightness;\n\t\tcolor *= tex(p,t.y);\n\t\t\n\t}\n\t\n\treturn vec3(color);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tfragColor = vec4(shade(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MstXWn", "name": "flow noise 2 ", "author": "FabriceNeyret2", "description": "fast and dirty implementation ( without pseudo advection )", "tags": ["flownoise"], "likes": 46, "viewed": 2335, "date": "1458806844", "time_retrieved": "2024-06-20T18:34:09.006140", "image_code": "// cd publi http://evasion.imag.fr/~Fabrice.Neyret/flownoise/index.gb.html\n//          http://mrl.nyu.edu/~perlin/flownoise-talk/\n\n// The raw principle is trivial: rotate the gradients in Perlin noise.\n// Complication: checkboard-signed direction, hierarchical rotation speed (many possibilities).\n// Not implemented here: pseudo-advection of one scale by the other.\n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat level=1.;\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float t = pow(2.,level)* .4*iTime;\n    mat2 R = mat2(cos(t),-sin(t),sin(t),cos(t));\n    if (mod(i.x+i.y,2.)==0.) R=-R;\n\n    return 2.*mix( mix( dot( hash( i + vec2(0,0) ), (f - vec2(0,0))*R ), \n                     dot( hash( i + vec2(1,0) ),-(f - vec2(1,0))*R ), u.x),\n                mix( dot( hash( i + vec2(0,1) ),-(f - vec2(0,1))*R ), \n                     dot( hash( i + vec2(1,1) ), (f - vec2(1,1))*R ), u.x), u.y);\n}\n\nfloat Mnoise(in vec2 uv ) {\n  //return noise(uv);                      // base turbulence\n  //return -1. + 2.* (1.-abs(noise(uv)));  // flame like\n    return -1. + 2.* (abs(noise(uv)));     // cloud like\n}\n\nfloat turb( in vec2 uv )\n{ \tfloat f = 0.0;\n\t\n level=1.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.2500*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.1250*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.0625*Mnoise( uv ); uv = m*uv; level++;\n\treturn f/.9375; \n}\n// -----------------------------------------------\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U / iResolution.y,\n         m = iMouse.xy /  iResolution.y;\n    if (length(m)==0.) m = vec2(.5);\n\t\n\tfloat f; \n  //f = Mnoise( 5.*uv );\n    f = turb( 5.*uv );\n\tO = vec4(.5 + .5* f);\n    O = mix(vec4(0,0,.3,1),vec4(1.3),O); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MstXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsV3Wt", "name": "Bit for bit", "author": "anastadunbar", "description": "Original animation by Dave Whyte http://bit.ly/1p6Od43. Ulam spiral function from http://glslsandbox.com/e#30868.0. Was really fast to copy.", "tags": ["2d", "simple", "loop", "trippy", "hypnotizing", "squares", "gif"], "likes": 66, "viewed": 1184, "date": "1457184326", "time_retrieved": "2024-06-20T18:34:09.006140", "image_code": "#define PI 3.1415926535\n#define clamps(x) clamp(x,0.,1.)\nvec2 rotate(float angle,vec2 position)\n{\n    mat2 matrix = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    return position*matrix;\n}\nfloat chess_dist(vec2 uv) {\n    return max(abs(uv.x),abs(uv.y));\n}\nfloat lthan(float a, float b) {\n    //return step(a,b);\n    return clamps(((b-a)*200.)+.5); //Smoother\n}\nfloat ulam_spiral(vec2 p)\n{\n\tfloat x \t= abs(p.x);\n\tfloat y\t\t= abs(p.y);\n\tbool q\t\t= x > y;\n\t\n\tx\t\t= q ? x : y;\n\ty\t\t= q ? p.x + p.y : p.x - p.y;\n\ty \t\t= abs(y) + 4. * x * x + 1.;\n\tx \t\t*= 2.;\n\t\n\treturn q ? (p.x > 0. ? y - x - x : y) : (p.y > 0. ? y - x : y + x);\t\n}\nfloat drawing(vec2 uv, float time) {\n    time = fract(time*.6);\n    uv = rotate((-time*(PI/2.))+(PI/2.),uv);\n    uv /= pow(3.,fract(time)); //Zoom in to middle square\n    uv *= 5.; //Zoom out\n    float a = 0.;\n    float s = fract(time); //Seperation time\n    for (float i = 0.; i < 9.; i++) { //3x3\n        vec2 p = vec2(mod(i,3.),floor(i/3.))-1.;\n        p += p*pow(max((s*8.)-(9.-ulam_spiral(-p)),0.),2.); //Move squares\n    \ta += lthan(chess_dist(uv-p),.5); //Draw square\n    }\n    return clamps(a);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy)-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = iTime;\n    \n\tfloat a = 0.;\n    //Motion-blur\n    #define SAMPLES 10.\n    for (float i = 0.; i < SAMPLES; i++) {\n        a += drawing(uv,time-(i*.002));\n    }\n    a /= SAMPLES;\n    \n\tfragColor = vec4(mix(vec3(0.9),vec3(0.1),a)-(length(uv)*.1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsV3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3SRM", "name": "Androids Passing", "author": "dr2", "description": "Perhaps a tunnel full of androids (mousing enabled)?", "tags": ["raymarching"], "likes": 8, "viewed": 665, "date": "1458133505", "time_retrieved": "2024-06-20T18:34:11.321480", "image_code": "// \"Androids Passing\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 sunDirMv, qHit, ltDir;\nvec2 scrnSize, wallSpc;\nfloat dstFar, dstFarMv, tCur, rAngH, rAngL, rAngA, gDisp, wDisp;\nint idObj, idObjMv;\nbool walk;\n\nvec3 BgColMv (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDirMv), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    col = mix (vec3 (0.6, 0.5, 0.3), vec3 (0.4, 0.5, 0.6), pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat ObjDfMv (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  hGap = 2.5;\n  bf = PrBox2Df (p.xz, vec2 (7. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  bFac = (ip.x == 0. && ip.y == 0.) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFarMv;\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = pp;\n  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q.y -= 1.9;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.)));\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55));\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 1; }\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 2; }\n  d = p.y + 1.;\n  if (d < dMin) { dMin = d;  idObjMv = 0;  qHit = p; }\n  return dMin;\n}\n\nfloat ObjRayMv (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDfMv (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFarMv) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNfMv (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDfMv (p + e.xxx), ObjDfMv (p + e.xyy),\n     ObjDfMv (p + e.yxy), ObjDfMv (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0.03, 0.04, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFarMv;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjColMv (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  if (idObjMv == 1) col = vec3 (0.65, 0.8, 0.2);\n  else if (idObjMv == 2) col = vec3 (0.8, 0.8, 0.);\n  else col = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.6, 0.5, 0.4),\n     (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  return col * (0.3 + 0.7 * max (dot (vn, sunDirMv), 0.)) +\n     0.3 * pow (max (0., dot (sunDirMv, reflect (rd, vn))), 64.);\n}\n\nfloat ObjSShadowMv (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 15; j ++) {\n    h = ObjDfMv (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 10. * h / d));\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 TrackPathMv (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb;\n  bool rotStep;\n  rPath = 28.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 + (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nvec3 ShowSceneMv (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, refl;\n  int idObjT;\n  dstHit = ObjRayMv (ro, rd);\n  if (dstHit < dstFarMv) {\n    ro += rd * dstHit;\n    idObjT = idObjMv;\n    vn = ObjNfMv (ro);\n    col = ObjColMv (rd, vn, dstHit);\n    idObjMv = idObjT;\n    if (idObjMv > 0) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRayMv (ro, rd);\n      if (dstHit < dstFarMv) {\n        ro += rd * dstHit;\n        c = ObjColMv (rd, ObjNfMv (ro), dstHit);\n      } else {\n        c = BgColMv (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= (0.8 + 0.2 * ObjSShadowMv (ro, sunDirMv));\n  } else {\n    col = BgColMv (ro, rd);\n  }\n  return col;\n}\n\nvec3 ScrnCol (vec2 w)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  float f;\n  w /= scrnSize.x;\n  ro = TrackPathMv (tCur);\n  vd = normalize (vec3 (0., 2., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (w, 2.));\n  return ShowSceneMv (ro, rd);\n}\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ah, szFac;\n  szFac = 1.8;\n  p.x = abs (abs (p.x) - 0.35 * wallSpc.x) - 0.175 * wallSpc.x;\n  p.z = mod (p.z + 0.8 * wallSpc.x, 1.6 * wallSpc.x) - 0.8 * wallSpc.x;\n  p.y -= -1. - 0.5 * (szFac -  1.);\n  p *= szFac;\n  dMin *= szFac;\n  q = p;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = p;\n  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = p;\n  ah = rAngH * (walk ? 1. : 0.);\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q.y -= 1.9;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.4));\n  q = p;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (p.x) : 1.));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (p.x));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55));\n  if (d < dMin) { dMin = d;  idObj = 11; }\n  q = p;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6, 0.7);\n  d = PrSphDf (q, 0.15);\n  if (d < dMin) { dMin = d;  idObj = 12; }\n  dMin /= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  d = wallSpc.x - abs (p.x);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  d = wallSpc.y + p.y;\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  d = wallSpc.y - p.y;\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  dMin = RobDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 20; j ++) {\n    h = RobDf (ro + rd * d, dstFar);\n    sh = min (sh, smoothstep (0., 1., 10. * h / d));\n    d += min (0.1, 2. * h);\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, rs;\n  float dstHit, spec, sh;\n  int idObjT;\n  bool isScrn;\n  dstFar = 250.;\n  dstHit = ObjRay (ro, rd);\n  isScrn = false;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    spec = 0.5;\n    if (idObj == 1) {\n      rs = ro;\n      rs.x = abs (rs.x) - wallSpc.x;\n      rs.z += wDisp;\n      rs.z = (mod (rs.z + 2., 4.) - 2.) * sign (rs.x);\n      if (abs (rs.z) < scrnSize.x && abs (rs.y) < scrnSize.y) {\n        col = ScrnCol (rs.zy);\n        isScrn = true;\n      } else col = vec3 (0.8, 0.4, 0.2) *\n         (0.5 + 0.5 * smoothstep (0.05, 0.1, mod (5. * ro.y, 1.)));\n    } else if (idObj == 2) col = mix (vec3 (0.3, 0.25, 0.1), vec3 (0.5, 0.45, 0.3),\n         (0.7 + 0.3 * ChqPat (ro / 1.25, dstHit)));\n    else if (idObj == 3) {\n      rs = ro;\n      rs.z += wDisp;\n      rs.z = (mod (rs.z + 2., 4.) - 2.) * sign (rs.x);\n      rs.xz /= vec2 (wallSpc.x, 2.);\n      col = vec3 (1., 1., 0.5) * (1. - 0.5 * min (1.,\n         length (pow (abs (1.2 * rs.xz), vec2 (8.)))));\n    } else if (idObj == 11) col = vec3 (0.2, 0.8, 0.2);\n    else if (idObj == 12) col = vec3 (0.8, 0.3, 0.);\n    if (! isScrn && idObj != 3) {\n      sh = 0.3 + 0.7 * ObjSShadow (ro, ltDir);\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         spec * sh * 0.6 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n    }\n  } else col = vec3 (0.);\n  col = mix (col, 0.5 * vec3 (1., 1., 0.5), smoothstep (0.7, 1., dstHit / dstFar));\n  if (! isScrn) col = pow (col, vec3 (0.7));\n  return col;\n}\n\nvoid SetState ()\n{\n  float tCyc, wkSpd;\n  wkSpd = 0.7;\n  tCyc = mod (wkSpd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    wDisp = mod (tCyc, 4.);\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (tCyc, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    wDisp = 0.;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  sunDirMv = normalize (vec3 (1., 2., 1.));\n  dstFarMv = 150.;\n  scrnSize = vec2 (1.7, 1.4);\n  wallSpc = vec2 (6., 2.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, u, vd;\n  vec2 canvas, uv;\n  float f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  SetState ();\n  ro = vec3 (0., 0., 8.); \n  if (mPtr.z > 0.) ro.xy =\n     clamp (mPtr.xy * vec2 (- canvas.x / canvas.y, 1.), - 0.9, 0.9) * wallSpc.xy;\n  vd = normalize (- ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ltDir = normalize (vec3 (0.1, 1., 0.1));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3SRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3XDr", "name": "procedural blending", "author": "FabriceNeyret2", "description": "blending procedurals sprites or patches (yes, this can exist :-) ) creates ghosting. To avoid it, blend only base  noise and deferred the non-linear transform.\nleft to right: naive blend, normalized blend,base noise blend + deferred", "tags": ["procedural", "sprite", "blend", "variance", "lagrangian", "smartblend"], "likes": 28, "viewed": 1897, "date": "1458626242", "time_retrieved": "2024-06-20T18:34:11.606565", "image_code": "// NB: trick published in https://hal.inria.fr/inria-00537472\n// for the simple blend normalization, see https://www.shadertoy.com/view/4dcSDr\n \n// procedural texture: N(U, base noise)  T(U): base noise.\n//      for fractal noise, we should store each band.\n\n#define T(U) texture(iChannel0,2.*U/4.)      // *1.3 to 2 if dark texture\n#define N(U,T) smoothstep(.1,.0,abs(sin(U.x+(T).x+.03*vec4(0,1,2,0))-.5))\n//#define N(U,T) smoothstep(.5,.0,abs(sin(30.*U.y+T.x+.3*vec4(0,1,2,0))-.5))\n//#define N(U,T) smoothstep(.5,.0,abs(sin(30.*U.y+cos(10.*U.x)+T.x+.3*vec4(0,1,2,0))-.5))\n\n//#define mean texture(iChannel0,2.*U,10.)*1.3\n#define mean .1 // estimation of mean texture after transformation\n\n\n#define K(U) smoothstep(.2, .0, length(U))      // smooth kernel\n//#define K(U) smoothstep(.13, .12, length(U))  // disk kernel\n#define rnd(i) fract(1e4*sin(i+vec2(0,73.17)))  // texture offset\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O-=O;\n    vec4 Od = O;\n    vec2 R = iResolution.xy, r=R/R.y;\n    if (abs(U.x-R.x*.33)<2. || abs(U.x-R.x*.67)<2.) { O++; return; }\n    U /= R.y;\n    float s=0., s2=0., v;\n    for (int i=0; i<15; i++)\n    {\n        vec2 V = U-rnd(vec2(i))*r + .1*cos(vec2(i)+iTime+vec2(0,1.6)); // sprite position\n        v = K(.3*V); s += v; s2 += v*v;                          // kernel and momentums\n        O  += v* N(V,T(V)); // regular evaluation of complete procedural noise before blend\n        Od += v*T(V);       // deferred: only the base noise is blended\n    }\n   \n    if     (U.x>r.x*.67) O = Od; // regular or deferred.\n    \n    if     (U.x<r.x*.33)  // normalization\n            O /= s;                          // linear blend\n    else    O = mean + (O-s*mean)/sqrt(s2);  // variance preserving blend\n \n    if     (U.x>r.x*.67) O = N(U,O); // for deferred.\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3XDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xd3XzH", "name": "Rostate", "author": "pairlapinpin", "description": "Ugly, but, hey, no ?", "tags": ["rotationtemporis"], "likes": 0, "viewed": 132, "date": "1457557859", "time_retrieved": "2024-06-20T18:34:11.606565", "image_code": "//#define ADDSIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float val = mod(iTime*uv.x*9.234325+uv.y*uv.y\n#ifdef ADDSIN\n                    +sin(uv.x/uv.y)\n#endif\n                    , 1.0);\n    fragColor = vec4(val*uv.x,val*uv.y,0.5-uv.x*uv.y/2.,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3XzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcSRH", "name": "Strict Cube Field", "author": "Mr_E", "description": "This is a strict Cube Field, unlike my last one, due to the rigidness of the edges of the sides of the cubes. This is also another test for 3 dimensional shapes.", "tags": ["3d", "test", "cube", "field", "strict"], "likes": 3, "viewed": 505, "date": "1457538368", "time_retrieved": "2024-06-20T18:34:11.606565", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(0.,0.,0.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(0.,0.,0.)),\n            sdBox(p,vec3(2.6,2.6,2.6)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d2, d1, d2);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n    vec3 q = opRep(p,vec3(10.0,10.0,10.0));\n    return vec2(\n       \tsdCrossedGrid(q)\n    );\n}\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    //return vec3(0.6,0.6,0.8);\n    return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(cos(iTime/5.)*20.0,sin(iTime/5.)*40.0,20.0);\n\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(0,1,1);\n\n    //camera lookat\n    vec3 vrp=vec3(0,1,0);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*1.0+vPos.y*v*1.0;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.04,0,0.8);\n    const float maxd=200.0;\n    vec2 d=vec2(1.02,1.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) { // Change i value to 256 for 3D-ness and 2 for coolness\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x*0.8;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        \n        float b=dot(N,normalize(prp-p));\n\t\tvec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    \txy.y = 1.0 - xy.y;\n    \t\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\t\tvec4 texColor = texture(iChannel0,xy,b);//Get the pixel at xy from iChannel0\n        fragColor = vec4(b);\n        \n        //fragColor = vec4(b, 0.1, sin(b), cos(iTime*iTime));//Set the screen pixel to that color\n    } else {\n    fragColor=vec4(0,0,0,1);\n    }\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcSRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcSRN", "name": "Dancing Sun", "author": "quad_damage", "description": "A tribute to the Burning Man festival. Soundtrack by Paul Oakenfold, Southern Sun.<br/>Based on Sun Surface shader: https://www.shadertoy.com/view/XlSSzK#<br/>Added music signal based surface texture, based on frequency sampling as seen in Cubescape", "tags": ["burningman"], "likes": 18, "viewed": 1542, "date": "1457833149", "time_retrieved": "2024-06-20T18:34:12.721373", "image_code": "// Based on Sun Surface: https://www.shadertoy.com/view/XlSSzK#\n// Based on Shanes' Fiery Spikeball https://www.shadertoy.com/view/4lBXzy (I think that his implementation is more understandable than the original :) ) \n// Relief come from Siggraph workshop by Beautypi/2015 https://www.shadertoy.com/view/MtsSRf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Audio based texture as seen in Cubescape: https://www.shadertoy.com/view/Msl3Rr\n// Minor customisations by Quad Damage on 13/03/2016\n// Dancing Sun tribute to Burning Man 2015\n// Music by Paul Oakenfold - Souther Sun: https://soundcloud.com/pauloakenfold/02-paul-oakenfold-southern-sun\n\n//#define ULTRAVIOLET\n//#define DITHERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n//\nfloat freqs[4];\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\n\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.06125)*.57 + pn(p*.125)*.28 + pn(p*.25)*.15;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat cosNoise( in vec2 p )\n{\n    return 0.3*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x*1.2,p.y) )-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 1.0 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat SunSurface( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = 0.5;\n    \n    float d2 = 0.0;\n    vec3 ipos = floor( pos );\n    float id = hash( ipos.x*1.0 + ipos.y*10.0 + ipos.z*20.0);\n    \n    for( int i=0; i<4; i++ )\n    {\n        h += s*cosNoise( q );      \n        q = m2*q*1.05; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.5*h;\n    }\n    \th += 0.4*(freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 ));\n \t\th += 0.4*(freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 ));\n        h += 0.4*(freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 ));\n        h += 0.4*(freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 ));\n    h *= 3.0;\n    \n    float d1 = pos.y - h;\n   \n    // rings\n    vec3 r1 = mod(2.3+pos+1.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float c = cos(pos.x); float s1 = 1.0;//sin(pos.x);\n    r1.xz=c*r1.xz+s1*vec2(r1.z, -r1.x);\n    d2 = sdTorus( r1.xzy, vec2(clamp(abs(pos.x/pos.z),0.7,5.0), 0.50) );\n\n    \n    return smin( d1, d2, 1.0 );\n}\n\nfloat map(vec3 p) {\n   p.z += 1.;\n   R(p.yz, -25.5);// -1.0+iMouse.y*0.003);\n   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n   return SunSurface(p) +  fpn(p*10.+iTime*25.) * 0.45;\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    freqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n   // p: position on the ray\n   // rd: direction of the ray\n   vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -22.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0.2, td=0.2, w=0.2;\n\n   // t: length of the ray\n   // d: distance function\n   float d=1., t=1.;\n   \n   // Distance threshold.\n   const float h = .2;\n    \n   // total color\n   vec3 tc = vec3(0.);\n   \n   #ifdef DITHERING\n   vec2 pos = ( fragCoord.xy / iResolution.xy );\n   vec2 seed = pos + fract(iTime);\n   //t=(1.+0.2*rand(seed));\n   #endif\n    \n   // rm loop\n   for (int i=0; i<56; i++) {\n\n      // Loop break conditions. Seems to work, but let me\n      // know if I've overlooked something.\n      if(td>(1.-1./200.) || d<0.001*t || t>40.)break;\n       \n      // evaluate distance function\n      d = map(ro+t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      //const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./60.;  // Different weight distribution.\n      td += w + 1./200.;\n\n\t  // dithering implementation come from Eiffies' https://www.shadertoy.com/view/MsBGRh\n      #ifdef DITHERING  \n      #ifdef ULTRAVIOLET\n      // enforce minimum stepsize\n      d = max(d, 0.04);\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n      #else\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(.8+0.28*rand(seed*vec2(i)));\n      // enforce minimum stepsize\n      d = max(d, 0.04);\n      #endif \n      #else\n      // enforce minimum stepsize\n      d = max(d, 0.04);        \n      #endif\n\n       \n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n    tc *= 1. /  1.1;\n   #ifdef ULTRAVIOLET\n   tc *= 1. / exp( ld * 2.82 ) * 1.05;\n   #endif\n    \n   fragColor = vec4(tc, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "lsfGz2", "previewfilepath": "https://soundcloud.com/pauloakenfold/02-paul-oakenfold-southern-sun", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/pauloakenfold/02-paul-oakenfold-southern-sun", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0 AND proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcSzH", "name": "A ray tracer", "author": "knightcrawler25", "description": "A basic raytracer with help from inigo's article: http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm", "tags": ["raytracing", "reflection", "refraction"], "likes": 19, "viewed": 2641, "date": "1457552547", "time_retrieved": "2024-06-20T18:34:13.806550", "image_code": "const int iterations = 5;\nconst float maxDist = 1000.0;\nconst vec3 amb = vec3(1.0);\nconst float eps = 1e-3;\n\nstruct Camera\n{\n\tvec3 up, right, forward;\n\tvec3 position;\n};\n\nCamera cam;\nvec4 spheres[10];\nvec4 colors[10];\nvec2 materials[10];\n\nvoid init()\n{\n    // X Y Z Radius\n    spheres[0] = vec4(      0,       0,    -1.5,    0.1);\n    spheres[1] = vec4(      0,    0.25,    -1.5,    0.1);\n    spheres[2] = vec4(      0,    -0.7,    -1.5,    0.3);\n    spheres[3] = vec4(      0,    -0.1,    -1.5,    0.3);\n    spheres[4] = vec4(      0,    -0.1,    -1.5,    0.15);\n    spheres[5] = vec4( 1001.0,       0,       0, 1000.0); \n    spheres[6] = vec4(-1001.0,       0,       0, 1000.0);\n    spheres[7] = vec4(      0,  1001.0,       0, 1000.0); \n    spheres[8] = vec4(      0, -1001.0,       0, 1000.0);\n    spheres[9] = vec4(      0,       0, -1002.0, 1000.0);\n\n    //R G B Diffuse\n    colors[0] = vec4(1.0, 0.8, 0.0,-1.0);\n    colors[1] = vec4(0.0, 0.0, 1.0,-1.0);\n    colors[2] = vec4(1.0, 1.0, 1.0, 1.0);\n    colors[3] = vec4(1.0, 1.0, 1.0, 1.0);\n    colors[4] = vec4(1.0, 0.0, 0.0, 1.0);\n    colors[5] = vec4(0.0, 1.0, 0.0, 0.7);\n    colors[6] = vec4(1.0, 0.0, 0.0, 0.7);\n    colors[7] = vec4(1.0, 1.0, 1.0, 0.7);\n    colors[8] = vec4(1.0, 1.0, 1.0, 0.7);\n    colors[9] = vec4(1.0, 1.0, 1.0, 0.7);\n\n    //Reflection Coeff, Refraction index\n    materials[0] = vec2 (0.0, 0.0);\n    materials[1] = vec2 (0.0, 0.0);\t\t\t\t\n    materials[2] = vec2 (1.0, 0.0);\t\n    materials[3] = vec2 (0.1, 0.8);\t\n    materials[4] = vec2 (0.1, 0.8);\t\n    materials[5] = vec2 (0.0, 0.0);\t\t\t\t\n    materials[6] = vec2 (0.0, 0.0);\t\t\t\t\n    materials[7] = vec2 (0.1, 0.0);\t\t\t\t\n    materials[8] = vec2 (0.1, 0.0);\t\t\t\t\n    materials[9] = vec2 (0.1, 0.0);\t\n\n    cam.up       = vec3(0.0, 1.0, 0.0);\n    cam.right    = vec3(1.0, 0.0, 0.0);\n    cam.forward  = vec3(0.0, 0.0,-1.0);\n    cam.position = vec3(0.0, 0.0,-0.2);\n}\n\nvec3 getRayDir(vec2 fragCoord)\n{\n  vec2 uv = (fragCoord.xy / iResolution.xy )*2.0 - 1.0;\n  uv.x *= iResolution.x/iResolution.y;                   \n  return normalize(uv.x * cam.right + uv.y * cam.up + cam.forward);\n}\n\n\n// The Intersection funtions and shading funcs are taken from inigo's article:\n// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm\n\nbool intersectSphere(vec3 ro, vec3 rd, vec4 sp, float tm, out float t)\n{\n    bool r = false;\n\tvec3 v = ro - sp.xyz;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - sp.w*sp.w;\n\tt = b*b-c;\n    if( t > 0.0 )\n    {\n        t = -b-sqrt(t);\n        r = (t > 0.0) && (t < tm);\n    }\n    return r;\n}\n\nfloat calcInter(vec3 ro, vec3 rd, out vec4 ob, out vec4 col,out vec2 mat)\n{\n\tfloat tm = maxDist;\n\tfloat t;\n\n\tif(intersectSphere(ro,rd,spheres[0],tm,t)) { ob = spheres[0]; col = colors[0]; tm = t; mat = materials[0]; }\n\tif(intersectSphere(ro,rd,spheres[1],tm,t)) { ob = spheres[1]; col = colors[1]; tm = t; mat = materials[1]; }\n\tif(intersectSphere(ro,rd,spheres[2],tm,t)) { ob = spheres[2]; col = colors[2]; tm = t; mat = materials[2]; }\n\tif(intersectSphere(ro,rd,spheres[3],tm,t)) { ob = spheres[3]; col = colors[3]; tm = t; mat = materials[3]; }\n\tif(intersectSphere(ro,rd,spheres[4],tm,t)) { ob = spheres[4]; col = colors[4]; tm = t; mat = materials[4]; }\n\tif(intersectSphere(ro,rd,spheres[5],tm,t)) { ob = spheres[5]; col = colors[5]; tm = t; mat = materials[5]; }\n\tif(intersectSphere(ro,rd,spheres[6],tm,t)) { ob = spheres[6]; col = colors[6]; tm = t; mat = materials[6]; }\n\tif(intersectSphere(ro,rd,spheres[7],tm,t)) { ob = spheres[7]; col = colors[7]; tm = t; mat = materials[7]; }\n\tif(intersectSphere(ro,rd,spheres[8],tm,t)) { ob = spheres[8]; col = colors[8]; tm = t; mat = materials[8]; }\n    if(intersectSphere(ro,rd,spheres[9],tm,t)) { ob = spheres[9]; col = colors[9]; tm = t; mat = materials[9]; }\n\n\treturn tm;\n}\n\nbool inShadow(vec3 ro,vec3 rd,float d)\n{\n\tfloat t;\n\tbool ret = false;\n\n\tif(intersectSphere(ro,rd,spheres[2],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[3],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[4],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[5],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[6],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[7],d,t)){ ret = true; }\n\tif(intersectSphere(ro,rd,spheres[8],d,t)){ ret = true; }\n\n\treturn ret;\n}\n\nvec3 calcShade(vec3 pt, vec4 ob, vec4 col,vec2 mat,vec3 n)\n{\n\n\tfloat dist,diff;\n\tvec3 lcol,l;\n\n\tvec3 color = vec3(0.0);\n\tvec3 ambcol = amb * (1.0-col.w) * col.rgb;\n\tvec3 scol = col.w * col.rgb;\n\n\tif(col.w > 0.0) //If its not a light\n\t{\n\t\tl = spheres[0].xyz - pt;\n\t\tdist = length(l);\n\t\tl = normalize(l);\n\t\tlcol = colors[0].rgb;\n\t\tdiff = clamp(dot(n,l),0.0,1.0);\n\t\tcolor += (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);\n\t\tif(inShadow(pt,l,dist))\n\t\t\tcolor *= 0.7;\n\n\t\tl = spheres[1].xyz - pt;\n\t\tdist = length(l);\n\t\tl = normalize(l);\n\t\tvec3 lcol = colors[1].rgb;\n\t\tdiff = clamp(dot(n,l),0.0,1.0);\n\t\tcolor += (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);\n\n\t\tif(inShadow(pt,l,dist))\n\t\t\tcolor *= 0.7;\n\t}\n\telse\n\t\tcolor = col.rgb;\n\n\treturn color;\n}\n\nfloat getFresnel(vec3 n,vec3 rd,float r0)\n{\n    float ndotv = clamp(dot(n, -rd), 0.0, 1.0);\n\treturn r0 + (1.0 - r0) * pow(1.0 - ndotv, 5.0);\n}\n\nvec3 getReflection(vec3 ro,vec3 rd)\n{\n\tvec3 color = vec3(0);\n\tvec4 ob,col;\n    vec2 mat;\n\tfloat tm = calcInter(ro,rd,ob,col,mat);\n\tif(tm < maxDist)\n\t{\n\t\tvec3 pt = ro + rd*tm;\n\t\tvec3 n = normalize(pt - ob.xyz);\n\t\tcolor = calcShade(pt,ob,col,mat,n);\n\t}\n\treturn color;\n}\n\nvoid rotObjects()\n{\n\tspheres[0].x += sin(iTime) * 0.4;\n    spheres[0].z += cos(iTime) * 0.4;\n    \n    spheres[1].x += sin(iTime) * -0.3;\n    spheres[1].z += cos(iTime) * -0.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n\tfloat fresnel,tm;\n\tvec4 ob,col;\n    vec2 mat;\n\tvec3 pt,refCol,n,refl;\n\n\tvec3 mask = vec3(1.0);\n\tvec3 color = vec3(0.0);\n\tvec3 ro = cam.position;\n\tvec3 rd = getRayDir(fragCoord);\n    \n    rotObjects();\n\t\n\tfor(int i = 0; i < iterations; i++)\n\t{\n\t\ttm = calcInter(ro,rd,ob,col,mat);\n\t\tif(tm < maxDist)\n\t\t{\n\t\t\tpt = ro + rd*tm;\n\t\t\tn = normalize(pt - ob.xyz);\n\t\t\tfresnel = getFresnel(n,rd,mat.x);\n\t\t\tmask *= fresnel;\n            \n\t\t\tif(mat.y > 0.0) // Refractive\n\t\t\t{\n\t\t\t\tro = pt - n*eps;\n\t\t\t\trefl = reflect(rd,n);\n\t\t\t\trefCol = getReflection(ro, refl);\n\t\t\t\tcolor += refCol * mask;\n\t\t\t\tmask = col.rgb * (1.0 - fresnel) * (mask / fresnel);\n\t\t\t\trd = refract(rd, n, mat.y);\n\t\t\t}\n\t\t\telse if(mat.x > 0.0) // Reflective\n\t\t\t{\n\t\t\t\tcolor += calcShade(pt,ob,col,mat,n) * (1.0 - fresnel) * mask / fresnel;\n\t\t\t\tro = pt + n*eps;\n\t\t\t\trd = reflect(rd, n);\n\t\t\t}\n\t\t\telse // Diffuse\n            {\n\t\t\t\tcolor += calcShade(pt,ob,col,mat,n) * mask/fresnel;\n                break;\n            }\n\t\t}\n\t}\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcXzH", "name": "Simple Perlin 2D ", "author": "bleedingtiger2", "description": "Simple Perlin-like noise in 2D, homemade custom algorithm. Not perfect but easy to understand for learning.", "tags": ["2d", "noise", "simple", "terrain", "perlin"], "likes": 9, "viewed": 830, "date": "1457561339", "time_retrieved": "2024-06-20T18:34:13.806550", "image_code": "#define _PerlinPrecision 8.0\n#define _PerlinOctaves 8.0\n#define _PerlinSeed 0.0\n\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\t\t\t\t\t// Final heightmap value\n    uv.x += sin(iTime*0.2)*0.4 + 3.0;\t// Used for camera movement\n    uv.y += iTime*0.1;\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta----b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|    |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc----d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    float p = perlin(uv * (0.6+cos(iTime*0.4)*0.15)); // Zoom animation\n    \n    if(p<0.4) // Water\n        fragColor = vec4(0.05, 0.75, 1.0, 1.0);\n    else if(p<0.45) // Sand\n        fragColor = vec4(0.870588, 0.721569, 0.529412, 1.0) + p*0.5;\n    else if(p<0.85) // Grass\n        fragColor = vec4(0.13333, 0.5451, 0.13333, 1.0) + p*0.25;\n    else if(p<0.999) // Rock\n        fragColor = vec4(0.5, 0.5, 0.5, 1.0) * ((p-0.75)*7.0);\n    else // Snow\n        fragColor = vec4(0.9, 0.95, 0.95, 1.0) + p*0.2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XddXR4", "name": "Shader Lesson #11, Raymarching", "author": "hubbe", "description": "Simple raymarching shader. Demonstrates one of the problems with raymarching: As the ray gets very close to objects, it uses up many iterations in the for loop walking past the those objects. Turns out that this effect can look like a cartoon shader...", "tags": ["raymarching", "educational"], "likes": 20, "viewed": 1072, "date": "1457985638", "time_retrieved": "2024-06-20T18:34:14.164147", "image_code": "// Simple distance map, returns the distance to the closest object from the position \"p\"\n// in 3d space.\nfloat map(vec3 p) {\n   // Animate\n   p.z += iTime/2.0;\n    \n   // This makes everything below repeat infinitely.\n   p = mod(p, 0.2) - vec3(0.1);\n   \n   // You can select a different shape by uncommenting lines below.\n    \n   // A ball with radius 0.05\n   return length(p) - 0.05;\n   \n   // Octagon shape.\n   // return dot(abs(p), vec3(1.0/sqrt(3.0))) - 0.05;\n\n   // Cube shape\n   // return length(p - clamp(p, vec3(-0.05), vec3(0.05)));\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    \n    for (int i = 0; i < 50; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n\t    float distance_to_closest_object = map(position);\n    \tif (distance_to_closest_object < 0.0001) {\n        \treturn travel_distance;\n    \t}\n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += distance_to_closest_object;\n    }\n    \n    // We walked 50 steps without hitting anything.\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -1);\n\n    // Not that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    vec3 ray_direction = normalize(vec3(uv, 1));\n    \n    // Cast a ray, see if we hit anything.\n    float t = ray(camera_position, ray_direction);\n    \n    // Just set the output color to the distance.\n\tfragColor = vec4(t, t, t, 0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XddXzr", "name": "Dancing floor", "author": "zackpudil", "description": "A sphere traced quivering floor.", "tags": ["raymarching", "distancefields"], "likes": 10, "viewed": 575, "date": "1457397859", "time_retrieved": "2024-06-20T18:34:14.630998", "image_code": "// created by zack pudil: https://github.com/zackpudil\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat dBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.2;\n}\n\nvec2 rep(inout vec2 p, vec2 o) {\n\tvec2 c = floor((p + o)/(o*2.0));\n\tp = mod(p + o, o*2.00) - o;\n\treturn c;\n}\n\nvec2 map(vec3 p) {\n\tp.y += 1.0;\n\tvec2 c = rep(p.xz, vec2(.7));\n\treturn vec2(dBox(p, vec3(.5, 1.0 + 0.27*cos(c.x*iTime + 1.0*c.x + 3.0*c.y), .5)), abs(c.x + c.y));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n\tfloat td = 0.0;\n\tfor(int i = 0; i < 128; i++) {\n\t\tvec2 s = map(ro + rd*td);\n\t\tif(abs(s.x) < 0.001) return vec2(td, s.y);\n\t\ttd += s.x*.5;\n\t}\n\t\n\treturn vec2(10.0, -1.0);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.01, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy).x - map(p - h.xyy).x,\n\t\tmap(p + h.yxy).x - map(p - h.yxy).x,\n\t\tmap(p + h.yyx).x - map(p - h.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n\nvec3 lighting(vec3 p, vec3 l, vec3 rd) {\n\tvec3 lig = normalize(l);\n\tvec3 n = normal(p);\n\tvec3 ref = reflect(lig, n);\n\t\n\tfloat amb = 1.0 * clamp((p.y + 0.25)*1.2, 0.0, 1.0);\n\tfloat dif = clamp(dot(n, lig), 0.0, 1.0);\n\tfloat spe = pow(clamp(dot(ref, rd), 0.0, 1.0), 52.0);\n\t\n\tvec3 lin = vec3(0);\n\t\n\tlin += amb;\n\tlin += dif*vec3(.3, .27, .25);\n\tlin += 2.0*spe*vec3(1, .97, .1)*dif;\n\t\n\treturn lin;\n}\n\nmat3 camera(vec3 e, vec3 la) {\n\tvec3 roll = vec3(0, 1, 0);\n\tvec3 f = normalize(la - e);\n\tvec3 r = normalize(cross(roll, f));\n\tvec3 u = normalize(cross(f, r));\n\t\n\treturn mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*(fragCoord/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = 5.0*vec3(cos(iTime*0.3), 1.0, -sin(iTime*0.3));\n\tvec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 2.0));\n\t\n\tvec3 l = vec3(-3.0, 4.0, 0.0);\n\t\n\tvec3 col = vec3(0);\n\tvec2 i = intersect(ro, rd);\n\t\n\tif(i.y > -1.0) {\n\t\tvec3 p = ro + rd*i.x;\n\t\tcol = mix(vec3(.0, .75, .75), vec3(.74, 0, .75), abs(cos(i.y)));\n\t\tcol *= lighting(p, l, rd);\n\t\t\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddXzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtSD4", "name": "New Shader (2)", "author": "Andre", "description": "Somebody already took the name New shader. Finally made enough characters to do this. Font is in https://www.shadertoy.com/view/4s3XDn", "tags": ["2d", "text", "font", "newshader"], "likes": 34, "viewed": 973, "date": "1459367206", "time_retrieved": "2024-06-20T18:34:14.643059", "image_code": "#define o1 GREEN _open1 GREEN\n#define c1 GREEN _close1 GREEN\n#define cm GREEN _comma GREEN\n#define line1 BLUE v_ o_ i_ d_ _ BLUE m_ a_ i_ n_ I_ m_ a_ g_ e_ o1 BLUE _ o_ u_ t_ _ v_ e_ c_ _4 BLUE _ f_ r_ a_ g_ C_ o_ l_ o_ r_ cm _ BLUE i_ n_ _ v_ e_ c_ _2 BLUE _ f_ r_ a_ g_ C_ o_ o_ r_ d_ _ c1\n#define line2 GREEN _open3 GREEN\n#define line3 _ _ _ _ BLUE v_ e_ c_ _2 BLUE _ u_ v_ _ _equal _ f_ r_ a_ g_ C_ o_ o_ r_ d_ _dot x_ y_ _ _div _ i_ R_ e_ s_ o_ l_ u_ t_ i_ o_ n_ _dot x_ y_ _dotcomma\n#define line4 _ _ _ _ f_ r_ a_ g_ C_ o_ l_ o_ r_ _ _equal _ BLUE v_ e_ c_ _4 BLUE o1 u_ v_ _comma GREEN _0 _dot _5 GREEN _add GREEN _0 _dot _5 GREEN _mul BLUE s_ i_ n_ BLUE o1 i_ G_ l_ o_ b_ a_ l_ T_ i_ m_ e_ c1 _comma _1 _dot _0 c1 _dotcomma\n#define line5 GREEN _close3 GREEN\n\n// line function, used in k, v, w, x, y, z, 1, 2, 4, 7 and ,\n// rest is drawn using (stretched) circle(g)\n\n// todo: distance fields of s,S, J { and }\n// todo before we can show shaders :)\n// \n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.25))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w;\n}\n\n//Render char if it's up\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n\n//Render char always (no effects anymore)\n//#define ch(l,w) x = min(x,l(clc(uv,cp+=w,w,ital)));\n\n//Make it a bit easier to type text\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n    \n//Space\n#define _ cp+=.5;\n\n//Markup\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.4-cur.g;\n#define BLUE cur.b = 0.5-cur.b; cur.r = 0.5-cur.r;\n\n//Next line\n#define crlf uv.y += 2.0; cp = 0.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 newShaderColor = (vec3(uv,0.5+0.5*sin(iTime))+0.5)/1.5;\n    \n    float ms = float(iMouse.w>0.);\n    float scale = 1.1-ms;// 2.0-cos(iTime*.1);\n    vec2 mouseOffs = ms*(iMouse.xy-.5*iResolution.xy)/scale;\n\tuv = (fragCoord+mouseOffs-.5*iResolution.xy) / iResolution.x * 34.0 * scale;\n    \n    //float ofs = floor(uv.x)+8.;\n    //uv.x = mod(uv.x,1.0)-.5;\n    \n    float px = 34.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.y -= 4.5;\n    uv.x += 18.;\n    \n    int lnr = 2-int(floor(uv.y/1.8));\n    uv.y = mod(uv.y,1.8)-.9;\n    \n    if (lnr==0) {line1}\n    if (lnr==1) {line2}\n    if (lnr==2) {line3}\n    if (lnr==3) {line4}\n    if (lnr==4) {line5}\n        \n\tvec3 clr = vec3(0.0);\n   \n    float weight  = 0.02+us.w*0.05;//+0.02-0.06*cos(iTime*.4+1.);\n    fragColor = vec4(mix(us.rgb,newShaderColor,smoothstep(weight-px,weight+px, x)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtSD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtSWN", "name": "Fractal Experiment 13", "author": "aiekick", "description": "based on https://www.shadertoy.com/view/4stXR7\nidea to change the C variable of the julia fractal along the y axis, and i produce that :)", "tags": ["fractal", "experiment", "13"], "likes": 6, "viewed": 705, "date": "1459384841", "time_retrieved": "2024-06-20T18:34:15.497689", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on https://www.shadertoy.com/view/4stXR7\nidea to change the C variable along the y axis, and i produce that :)\n*/\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fractus(vec3 p)\n{\n\tvec2 z = p.xz;\n    vec2 c = vec2(1,-1) * p.y * .5;\n\tfloat k = 1., h = 1.0;  \n    const float iter = 11.;\n    for (float i=0.;i<iter;i++)\n    {\n        if (i/iter > (sin(iTime*.5)*.5+.5)) break;\n\t\th *= 4.*k;\n\t\tk = dot(z,z); \n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec2 df(vec3 p)\n{\n\tfloat obj = fractus(p);\n\tvec2 res = vec2(obj, 1.);\n\n\treturn res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = iTime;\n\t\n\tvec3 rayOrg = vec3(cos(t*.2)*2.5,1.5,sin(t*.2)*2.);\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,0.2,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tvec2 s = vec2(0.01);\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 80.;\n\tfloat sMin = 0.00001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (s.x<0.0025*log(d*d/s.x/500.) || d>dMax) break;\n\t\ts = df(p);\n\t\td += s.x * (s.x>0.01?0.2:0.2);\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.00001);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\tfloat r = mod( floor(5.0*p.z) + floor(5.0*p.x), 2.0);\n        f.rgb = 0.4 + 0.1*r*vec3(1.0);\n\n        // iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.02;\n        f.rgb *= brdf;\n\n        f.rgb = mix( f.rgb, sky, 1.0-exp( -0.03*d*d ) ); \n\t}\n\telse\n\t{\n\t\tf.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdV3Wd", "name": "Zoomed out orbit trap test", "author": "asneakyfatcat", "description": "zoomed out version", "tags": ["mandelbrot", "orbit", "set", "trapping"], "likes": 1, "viewed": 162, "date": "1457127397", "time_retrieved": "2024-06-20T18:34:15.497689", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float dist = 0.;\n    uv.x = -2.+4.*uv.x;\n    uv.y = -1.+2.*uv.y;\n    uv.x += .275015;//;\n    uv.y += .0060445;//\n    //uv /= 5.;\n    vec4 col =vec4(1.);\n    vec2 z = vec2(0.0);\n    \n    int trap=0;\n    for(int i = 100; i < 400; i++){\n        if(dot(z,z)>4.){trap = i;break;}\n        dist = min( 1e20, dot(z,z))+cos(float(i)*12.+3.*iTime);\n        z = mat2(z,-z.y,z.x)*z + uv;\n    }\n    dist = sqrt(dist);\n\tfloat orb = sqrt(float(trap))/64.;\n    fragColor=vec4(0.,log(dist)*sqrt(dist)-orb-orb,log(dist)*sqrt(dist-abs(sin(iTime))),1.);\n    if(orb == 0.){fragColor = vec4(0.);}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdV3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SD4", "name": "Bandeira", "author": "guerreiro", "description": "Music visualization", "tags": ["visualization", "music", "flag", "brazil"], "likes": 2, "viewed": 568, "date": "1459226215", "time_retrieved": "2024-06-20T18:34:15.497689", "image_code": "#define TAU 6.283185307\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 position = fragCoord.xy / iResolution.xy;\n    vec2 flagPosition = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x / 22.0, iResolution.y / 16.0);\n    float ande = dot(flagPosition, vec2(1.0, 0.5)) - iTime * 2.0;\n    flagPosition += vec2(-0.2, 0.2) * sin(ande);\n    \n    float angle = atan(flagPosition.y, flagPosition.x) / TAU + 0.5;\n    \n\tfloat wave = texture(iChannel0, vec2(angle, 1.0)).x;\n\tfloat freqs = texture(iChannel0, vec2(position.x, 0.0)).x;\n    \n    vec3 color;\n    if(abs(flagPosition.x) < 10.0 && abs(flagPosition.y) < 7.0) {\n        if(length(flagPosition) < 3.0 + 1.0 * wave) {\n            float d = length(flagPosition - vec2(-2.0, -7.0));\n            color = 8.0 <= d && d < 8.5 ? vec3(1.0) : vec3(0.243, 0.251, 0.584);\n        } else if(abs(dot(flagPosition, vec2(5.3, 8.3))) < 43.99 && abs(dot(flagPosition, vec2(5.3, -8.3))) < 43.99) {\n            color = vec3(1.0, 0.8, 0.161);\n        } else {\n            color = vec3(0.0, 0.659, 0.349);\n        }\n        color *= 0.9 + 0.1 * cos(ande);\n    } else {\n        color = vec3(freqs < position.y ? 0.25 : 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SRn", "name": "Silk", "author": "TrueBoolean", "description": "Terrain marching a plasma.", "tags": ["terrainmarching"], "likes": 6, "viewed": 267, "date": "1457317096", "time_retrieved": "2024-06-20T18:34:15.909726", "image_code": "//A hight function returns our terrain based on the xz coordinate.\nfloat height(vec2 pos){\n    float x=pos.x;\n    float y=pos.y;\n    return sin(x)+sin(x+y)+sin(y)+sin(iTime+x)+5.0;\n}\nfloat height3(vec3 pos){\n return sin(pos.x)+sin(pos.y)-sin(pos.z)-3.0;   \n}\n//sin(x+y)=sloped lines.\n//sin(sqrt(x * x + y * y))= distance cirlces\n//sin(x)+sin(y)=sine hills\nfloat map(vec3 p){\n    //To double it(ie, make terrain on the ceiling, we can check the vector length\n \treturn length(p.y)-height(p.xz);  \n}\n\n//The march function takes in an origin and rays to march along.\nfloat trace(vec3 origin,vec3 ray){\n    float t=0.0;\n    //32 iterations per pixel\n    for (int i=0;i<32;i++){\n        //The position of the ray is origin+rays*t\n        vec3 position=origin+ray*t;\n        //We take this position, and check if we are inside the area that we defined with map.\n        float d=map(position);\n        \n        //We iterate t. The smaller the (0.5) value is, the less accurate the map function is.\n        t+=d*0.5;\n        \n    }\n    \n    return t;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Scale the pixels between -1 and 1 instead of 0 and 1 by default\n    uv=uv*2.0-1.0;\n    \n    //Give the correct aspect ratio.\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //If you don't normalize the ray, it pokes through the camera.\n    //A normalized vetor is a conversion to turn the vector to length 1, a unit vector.\n    //This z value(currently 1.0) determines the fov. Smaller value wuld correspond to higher fov.\n    //1.0 is fov of 90 degrees.\n    vec3 ray=normalize(vec3(uv,1.0));\n    \n    float theta=sin(iTime)/3.0+1.5;\n    ray.yz*=mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    theta=sin(iTime)/2.0+1.0;\n    ray.xz*=mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    //ray.xz*=mat2(cos(theta),-sin(theta),sin(theta),cos(theta));\n    \n    //The viewer's origin. We need to move back, otherwse we will be inside the sphere.\n    vec3 origin=vec3(iTime,0.0,iTime);\n    \n    float t=trace(origin, ray);\n    \n    float fog= 1.0/(1.0+t*t*0.005);\n    \n    \n    vec3 fc=vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SWn", "name": "Rotating Sphere test", "author": "Terah", "description": "Faking a 3d sphere with maths ", "tags": ["sphere", "fake3d"], "likes": 2, "viewed": 156, "date": "1458563478", "time_retrieved": "2024-06-20T18:34:15.909726", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float r = 250.0;\n    vec2 C = iResolution.xy / 2.0;\n    vec3 H = vec3(fragCoord, 0.0);\n    \n    \n    \n    \n    float ry = -0.3*t;\n    mat3 my = mat3(cos(ry), 0.0, -sin(ry), 0.0, 1.0, 0.0, sin(ry), 0.0, cos(ry));\n    \n    float rz = -0.25 + cos(0.1*t)/5.0;\n    mat3 mz = mat3(cos(rz), sin(rz), 0.0, -sin(rz), cos(rz), 0.0, 0.0, 0.0, 1.0);\n    \n    float rx = 0.4 + sin(0.1*t)/5.0;\n    mat3 mx = mat3(1.0, 0.0, 0.0, 0.0, cos(rx), sin(rx), 0.0, -sin(rx), cos(rx));\n    \n    mat3 m = mx * mz * my;\n    \n    H.xy = H.xy - C.xy;\n    float d = length(H.xy);\n    H.z = sqrt((r*r) - (d*d));\n    float h = sqrt((r*r) - (d*d));\n    \n    H = H * m;\n    \n    if(d<r)\n    {\n        \n        float a = atan(H.x/H.z);\n        float ad = 180.0 + ((a / M_PI) * 180.0);\n        \n        float b = asin(H.y/r);\n        float bd = 180.0 + ((b / M_PI) * 180.0);\n\n        \n        if(mod(ad, 20.0) < 0.5)\n        \tif(mod(bd, 20.0) < 0.5)\n                fragColor = vec4(h/(r*0.5), 0.0, h/(r*0.5), 1.0);\n            else\n                fragColor = vec4(0.0, 0.0, h/(r*0.5), 1.0);\n        else\n            if(mod(bd, 20.0) < 0.5)\n                fragColor = vec4(h/(r*0.5), 0.0, 0.0, 1.0);\n            else\n                fragColor = vec4(0.15*h/r ,0.15*h/r, 0.15*h/r, 1.0);\n    }\n    else\n        fragColor = vec4(0.12,0.07,0.1,1.0);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3SzM", "name": "Cornell Box of Mirrors", "author": "aaecheve", "description": "Classic cornell box + mirrors", "tags": ["raytracing", "reflection", "cornellbox"], "likes": 4, "viewed": 260, "date": "1458237589", "time_retrieved": "2024-06-20T18:34:16.927768", "image_code": "const float infinity = 1e10;\n\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  int materialIndex;\n};\n\nstruct Material {\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n  float reflectivity;\n};\n\nstruct Light {\n  vec3 position;\n  vec4 color;\n};\n\nstruct Ray {\n  vec3 position;\n  vec3 direction;\n};\n\nstruct Camera {\n  vec3 position;\n};\n\nstruct Scene {\n  vec4 ambient;\n  vec4 background;\n};\n\nconst int numberOfSpheres = 8;\nconst int numLights = 2;\nconst int numberOfMaterials = 8;\nconst int maxNumberOfReflections = 1;\n\nSphere spheres[numberOfSpheres];\nMaterial materials[numberOfMaterials];\nLight lights[numLights];\nCamera camera = Camera(vec3(0.5, 0.5, 1.5));\nScene scene = Scene(vec4(0.1,0.1,0.1,1), vec4(0,0,0,1));\n\n\n//ray-sphere intersection\nfloat intersect(Ray ray, Sphere sphere)\n{\n  //float a = 1.0;//dot(ray.direction, ray.direction); //Optimization suggested by Phi\n  float b = dot(ray.position - sphere.position, ray.direction);\n  float c = dot(ray.position - sphere.position, ray.position - sphere.position) - sphere.radius*sphere.radius;\n \n  float discr = b*b - c;// - a*c; //Optimization suggested by Phi\n  if(discr < 0.0)\n    return infinity;\n\n  discr = sqrt(discr);\n  float t0 = (-b - discr);// / a; //Optimization suggested by Phi\n  float t1 = (-b + discr); // / a; //Optimization suggested by Phi\n\n  float tMin = min(t0, t1);\n  if(tMin < 0.0)\n    return infinity;\n\n  return tMin;\n\n}\n\n//shadows\nbool isInShadow(vec3 p, Sphere sphere, Light light)\n{  \n  float lightDistance = distance(light.position, p);\n  vec3 shadowDir = normalize(light.position - p);\n  Ray shadowRay = Ray(p + 0.1 * shadowDir, shadowDir);    \n  float tShadow = intersect(shadowRay, sphere);\n  if(!isinf(tShadow) && tShadow < lightDistance)\n\treturn true;\n  \n  return false;\n}\n\nbool isInOtherSphereShadow(vec3 p, Sphere thisSphere, Light light)\n{\n\tfor(int i=0; i<numberOfSpheres; i++)\n\t{\n\t\tif(isInShadow(p, spheres[i], light))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n//blinn-phong shading\nvec4 blinnPhongShading(vec3 p, vec3 n, Sphere sphere, Material material)\n{\n  //Material material\t= materials[0];\n  vec3 v = camera.position - p;\n  v = normalize(v);\n \n  vec4 shadedColor = scene.ambient * material.diffuse;\n  for(int i=0; i<numLights; i++)\n  {\n\tvec4 lightColor = lights[i].color;\n\tif(isInOtherSphereShadow(p, sphere, lights[i]))\n\t\tlightColor = vec4(0,0,0,1);\n    vec3 l = lights[i].position - p;\n    l = normalize(l);  \n    vec3 h = v + l;\n    h = normalize(h);\n\n    shadedColor = shadedColor + lightColor * (max(0.0,dot(n,l)) * material.diffuse + pow(max(0.0,dot(n,h)), material.shininess) * material.specular);\t  \n  }\n  return shadedColor;\n}  \n\n\n\nvec4 rayTrace(Ray ray)\n{\n  vec4 accumulatedColor = vec4(0,0,0,1);\n  float frac = 1.0;\n  for(int i=0; i < maxNumberOfReflections + 1; i++)\n  {\n\t  float tMin = infinity;\n\t  int sphereMin = -1;\n      Sphere sphere = spheres[0];\n      Material material = materials[0];\n\t  for(int i=0; i<numberOfSpheres; i++)\n\t  {\t\n\t\tfloat t = intersect(ray, spheres[i]);\n\t\tif(t < tMin)\n\t\t{\n\t\t\ttMin = t;\n\t\t\tsphereMin = i;\n            sphere = spheres[i];\n            material = materials[i];\n\t\t}\n\t  }\n\n\t  if(!isinf(tMin))\n\t  {\n\t\tvec3 p = ray.position + tMin*ray.direction;\n\t\tvec3 n = normalize(p - sphere.position);\n\t\tMaterial mat = materials[0];\n\t\tvec4 localColor = blinnPhongShading(p, n, sphere, material);\n\t\taccumulatedColor += localColor * frac;\n\t\tif(mat.reflectivity > 0.0)\n\t\t{\n\t\t\tray.position = p;\n\t\t\tray.direction = normalize(reflect(ray.direction, n));\n\t\t\tfrac *= mat.reflectivity;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t  }  \n\t \n\t  accumulatedColor += scene.background * frac;\n  }\n  return accumulatedColor;\n}\n\nvoid init()\n{ \n  materials[0] = Material(vec4(0.156,0.126,0.507,1), vec4(1,1,1,1), 100.0, 0.3);   // Blue specular\n  materials[1] = Material(vec4(0.656,0.626,0.107,1), vec4(0,0,0,1), 1.0, 0.5);     // Yellow\n  materials[2] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[3] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[4] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[6] = Material(vec4(0.639, 0.06, 0.062, 1), vec4(0,0,0,1), 1.0, 0.5);   // Red\n  materials[5] = Material(vec4(0.156, 0.426, 0.107, 1), vec4(0,0,0,1), 1.0, 0.5);  // Green\n  materials[7] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  \n\n  lights[0] = Light(vec3(0.5,0.99,0.5),  vec4(0.8,0.7,0.6,1));\n  lights[1] = Light(vec3(0.5,0.99,-0.5),  vec4(0.2,0.2,0.2,1));\n\n  spheres[0] = Sphere(vec3(0.35, 0.24, -0.72), 0.2, 0); //Blue sphere\n  spheres[1] = Sphere(vec3(0.82, 0.2, -0.25), 0.19, 1); //Yellow sphere\n  spheres[2] = Sphere(vec3(0.5, 0.5, -1004), 1000.0, 2); //Back wall\n  spheres[3] = Sphere(vec3(0.5, 1001.1, -0.5), 1000.0, 2); //Ceiling\n  spheres[4] = Sphere(vec3(0.5, -1000.1, -0.5), 1000.0, 2); //Floor\n  spheres[5] = Sphere(vec3(1001.1, 0.5, -0.5), 1000.0, 4); //Right wall\n  spheres[6] = Sphere(vec3(-1000, 0.5, -0.5), 999.9, 3); //Left wall\n  spheres[7] = Sphere(vec3(0.5, 0.7, -0.5), 0.03, 2); //White sphere\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Initialize elements\n  init();\n\n  //Light movement \n  vec2 normMouse = iMouse.xy / iResolution.xy;\n  lights[0].position = vec3(normMouse.x, normMouse.y, 0.0); \n\t\t  \t\t  \n  //Object movement\n  float speed = 1.0;\n  spheres[0].position = vec3(0.5, 0.24, -0.5) + 0.3 * vec3(sin(speed*(iTime)),0.0,cos(speed*(iTime)));\n  spheres[1].position = vec3(0.5, 0.2, -0.5) + 0.23 * vec3(sin(speed*(iTime) + 10.0),0.0,cos(speed*(iTime)+ 10.0));\n  spheres[7].position = vec3(0.5, 0.7, -0.5) + 0.2 * vec3(0, sin(speed*(iTime)), 0.0);\n\t   \t\n  //Raytrace objects\n  vec2 pixelCoords = fragCoord.xy / iResolution.y;\n  vec3 pixel = vec3(pixelCoords - vec2(0.5,0), 0);\n  Ray ray = Ray(camera.position, normalize(pixel - camera.position));\n  fragColor = rayTrace(ray);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3SzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscSRn", "name": "MandelboxTest", "author": "gsitcia", "description": "A mandelbox fractal<br/><br/>Scale -1.5          Try switching the commented out lines.<br/><br/>Uses raymarching. The distance expression is (obviously) not my own\nThis should no longer be as laggy. At least my chromebook doesn't die running it.", "tags": ["raymarching", "fractal"], "likes": 2, "viewed": 164, "date": "1457242745", "time_retrieved": "2024-06-20T18:34:17.461304", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rpBox( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox( p, vec3(0.5, 0.5, 0.5) );\n}\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n    float minRadius2 = 0.5;\n    float fixedRadius2 = 1.0;\n\tif (r2 < minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2 < fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tfloat foldingLimit = 1.0;\n    z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nfloat DE(vec3 z)\n{\n\tvec3 offset = z;\n    float Scale = 2.0;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 21; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\tsphereFold(z,dr);    // Sphere Inversion\n \t\t\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat mindist = min(iResolution.x, iResolution.y);\n    \n    vec3 uv = vec3((gl_FragCoord.xy - iResolution.xy / 2.0) / mindist, 0.0);\n    \n    vec3 eye = vec3((2.0 * (iMouse.xy - iResolution.xy / 2.0) / mindist) + vec2(0.0, 5.0), iTime / 10.0 - 20.0);\n    \n    float fl = 1.0;\n    \n    vec3 fo = normalize(vec3(0.0, -1.0, 3.0));\n    \n    vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec3 si = cross(up, fo);\n    \n    uv = eye + fl * fo + uv.x * si + uv.y * up;\n    \n    vec3 dr = uv - eye;\n    \n    dr = dr / length(dr);\n    \n    float dt = 0.0;\n    \n    for (int i = 0; i < 80; ++i) {\n        dt = DE( uv );\n        if (dt < 0.0001) {\n            dt = float(i);\n            break;\n        }\n        uv = uv + dr * dt;\n    }\n   \n    fragColor = vec4(dt / 70.0, dt / 80.0, dt / 80.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscSRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscSzM", "name": "The apple", "author": "revers", "description": "This shader is my attempt to do something similar to iq's [url=https://www.shadertoy.com/view/XdfGRn]Apple[/url]. Modeling and texturing I've done by myself. Raymarching, lighting and noise are taken from iq's shaders.", "tags": ["raymarching", "apple"], "likes": 2, "viewed": 157, "date": "1458167026", "time_retrieved": "2024-06-20T18:34:19.297972", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader is my attemp to do something similar to iq's \"Apple\" ( https://www.shadertoy.com/view/XdfGRn ).\n * Modeling and texturing I've done by myself. (Of course in less optimal way than iq's original \"Apple\") \n * \n * Raymarching and lighting is taken from iq's \"Raymarching - Primitives\" ( https://www.shadertoy.com/view/Xds3zN ).\n * Noise and hash functions are also taken from some iq shader (don't rembember which).\n * Thanks for sharing your great work, iq!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\n#define ANTI_ALIASING\n#define BUMP_MAPPING\n\nconst vec3 LightDir = vec3(-0.4218155, -0.73880583, -0.5255833);\nconst float MarchDumping = 0.6103;\nconst float Far = 20.0;\nconst int MaxSteps = 128;\nconst float WoodPower = 3.2411995;\nconst float FOV = 0.4;\nconst float AppleRadius = 1.2858001;\nconst float BumpFactor = 0.049060002;\n\n#define PI 3.141592\n\n#define M_NONE -1.0\n#define M_APPLE 1.0\n#define M_FLOOR 2.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat hash(vec2 n) {\n\treturn fract(sin(dot(n, vec2(1.0, 113.0))) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\tvec2 a = vec2(0.0, 0.0);\n\tvec2 b = vec2(1.0, 0.0);\n\tvec2 c = vec2(0.0, 1.0);\n\tvec2 d = vec2(1.0, 1.0);\n\n\tfloat n0 = hash(i + a);\n\tfloat n1 = hash(i + b);\n\tfloat n2 = hash(i + c);\n\tfloat n3 = hash(i + d);\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\n\treturn mix(ix0, ix1, u.y);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nmat3 m = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf += 0.500 * noise(p);\n\tp = m * p * 2.01;\n\tf += 0.250 * noise(p);\n\tp = m * p * 2.02;\n\tf += 0.125 * noise(p);\n\tp = m * p * 2.03;\n\n\treturn f;\n}\n\nmat2 m2 = mat2(1.6, 1.2, -1.2, 1.6);\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n\n\tf += 0.500 * noise(p);\n\tp = m2 * p;\n\tf += 0.250 * noise(p);\n\tp = m2 * p;\n\tf += 0.125 * noise(p);\n\n\treturn f;\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat sdApple(vec3 p, float r) {\n\tp.y *= 0.95;\n\n\tp.xz *= 1.2;\n\n\tfloat k = 0.84 + 0.16 * smoothstep(-r, r, p.y);\n\tp.xz /= k;\n\treturn sdTorus(p, vec2((0.9 / 1.25) * r, r));\n}\n\nvec2 map(vec3 p) {\n    p.y += 1.0;\n\tvec2 res = vec2(sdPlane(p), M_FLOOR);\n\tp.y -= AppleRadius;\n    \n\n\tvec2 obj = vec2(sdApple(p, AppleRadius), M_APPLE);\n\tres = min2(res, obj);\n\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = -1.0;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 woodColor(vec2 p) {\n\tvec2 q = p;\n\tq.x += noise(q * vec2(0.05, 0.02)) * 2.0;\n\tq.y *= 0.1;\n\tfloat f = fbm(q);\n\n\tq = p + vec2(145.424, 424.1114);\n\n\tf = mix(f, 0.5, fbm(q * vec2(0.3, 0.2)) + 0.2);\n\n\tvec3 pwr = vec3(WoodPower);\n\tvec3 colLight = pow(vec3(0.84, 0.50, 0.25), pwr);\n\tvec3 colDark = pow(vec3(0.40, 0.28, 0.17), pwr);\n\tvec3 colSpot = pow(vec3(0.38, 0.24, 0.12), pwr);\n\n\tvec3 col = mix(colDark, colLight, f);\n\n\tq = p - vec2(145.424, 424.1114);\n\tf = clamp(smoothstep(0.0, 0.8, fbm(q * vec2(0.07, 0.018))) + 0.4, 0.0, 1.0);\n\tcol = mix(colSpot, col, f);\n\n\treturn col;\n}\n\nfloat lum(vec2 uv) {\n\treturn dot(woodColor(uv), vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 floorColor(vec3 pos, float t, inout vec3 nor) {\n#ifdef BUMP_MAPPING\n\t\tvec2 uv = pos.xz * 6.0;\n\t\tvec3 col = woodColor(uv);\n\n\t\t// Forward difference\n\t\tvec2 eps = vec2(t * 0.005, 0.0);\n\t\tfloat p = lum(uv);\n\t\tvec2 grad = vec2(lum(uv + eps.xy) - p, lum(uv + eps.yx) - p)\n\t\t\t\t/ (eps.xx);\n\t\tnor = normalize(vec3(grad.x, BumpFactor, grad.y));\n\n\t\treturn col;\n#else\n\t\tvec2 uv = pos.xz * 6.0;\n\t\treturn woodColor(uv);\n#endif\n}\n\nvec3 appleColor(vec3 pos, vec3 nor) {\n\t// noise\n\tfloat r = noise(pos * 1.0);\n\tvec3 col = mix(vec3(0.8, 0.0, 0.0), vec3(0.8, 0.4, 0.2), r) * 0.7;\n\n\t// stripes\n\tfloat rad2 = AppleRadius * 2.0;\n\tvec2 uv = vec2((pos.y - rad2) / rad2, atan(pos.z, pos.x) / PI + 0.5);\n\tuv.x *= 0.02;\n\tfloat rs = texture(iChannel0, uv, -100.0).r;\n\tcol = mix(vec3(0.561, 0.278, 0.141), col, 0.7 + 0.3 * rs);\n\n\t// dots\n\tfloat f = fbm(pos * 22.0);\n\tf = clamp(pow(smoothstep(0.66, 1.0, f), 0.1) * 20.0, 0.0, 1.0);\n\tcol *= 0.96 + 0.04 * vec3(0.929, 0.627, 0.427) * f;\n\n    return pow(col, vec3(1.5));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 bg = vec3(0.8, 0.9, 1.0) * (0.9 - rd.y);\n\tvec3 col = bg;\n\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tif (m > M_NONE) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\tif (m == M_APPLE) {\n\t\t\tcol = appleColor(pos, nor);\n\t\t} else if (m == M_FLOOR) {\n\t\t\tcol = floorColor(pos, t, nor);\n\t\t}\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(-LightDir);\n\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 12.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.2 * dif * vec3(1.0);\n\t\tbrdf += 0.5 * spe * vec3(1.0) * dif;\n\t\tbrdf += 0.5 * amb * vec3(1.0) * occ;\n\t\tbrdf += 0.4 * fre * vec3(1.0) * occ;\n\t\tbrdf += 0.02;\n\t\tcol = col * brdf;\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 rotateX(float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\n\treturn mat3(1.0, 0.0, 0.0, 0.0, ca, -sa, 0.0, sa, ca);\n}\n\nmat3 rotateY(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tcoord *= FOV;\n\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tif (mouse.x != 0.0 && mouse.y != 0.0) {\n\t\tmouse = mouse * 2.0 - 1.0;\n\t}\n    float t = iTime * 0.25 - mouse.x * 4.0;\n\tfloat st = sin(t);\n\n\tmat3 rot = rotateY(-t * PI * 0.32) * rotateX(mouse.y * PI * 0.25);\n\n\tvec3 ro = rot * vec3(0.0, 7.0 + 0.8 * st, 4.0 - 2.0 * st);\n\n\tvec3 dir = normalize(-ro);\n\tvec3 up = rot * vec3(0.0, 1.0, 0.0);\n\tvec3 upOrtho = normalize(up - dot(dir, up) * dir);\n\tvec3 right = normalize(cross(dir, upOrtho));\n\n#ifdef ANTI_ALIASING\n\tvec2 eps = vec2(1.0) / (iResolution.xy * 2.0);\n\tvec3 rd0 = normalize(dir + (coord.x - eps.x) * right + coord.y * upOrtho);\n\tvec3 rd1 = normalize(dir + (coord.x + eps.x) * right + coord.y * upOrtho);\n\tvec3 rd2 = normalize(dir + coord.x * right + (coord.y - eps.y) * upOrtho);\n\tvec3 rd3 = normalize(dir + coord.x * right + (coord.y + eps.y) * upOrtho);\n\n\tvec3 col = (render(ro, rd0)\n\t\t\t  + render(ro, rd1)\n\t\t\t  + render(ro, rd2)\n\t\t\t  + render(ro, rd3)) / 4.0;\n#else\n\tvec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\tvec3 col = render(ro, rd);\n#endif\n\n\tcol = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/XscSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XscXDN", "name": "(FIXED) Reflections", "author": "Neph", "description": "Tbqh honest I barely know the proper way for this.\nThanks to reinder for showing me how to remove artifacts and greatly improve the quality of the reflections!", "tags": ["3d", "reflection", "raymarch", "lighting"], "likes": 8, "viewed": 254, "date": "1459299126", "time_retrieved": "2024-06-20T18:34:19.304069", "image_code": "#define MAXITER 128\n#define MAXREFLECTIONS 2\n#define REFLECTIVITY 0.8\n#define CLIP 30.0\nvec4 map(vec3 p){\n    vec3  fcol = vec3(0.0);\n    float fdist = 0.0;\n    {\n    vec3  col = vec3(0.8, 0.2, 0.0);\n    vec3  q = vec3(fract (p.xz), p.y + 0.6)*2.0 - 1.0;\n    float dist = sin(length(q)) - 0.5;  \n    fcol = col;\n    fdist = dist;\n    }\n    {\n    vec2 lw = clamp(vec2(abs(sin(iTime*0.2))), vec2(0.7), vec2(1.0));\n    vec3  col = vec3(0.0, 0.4, 0.6);\n    p.xy += 0.5;\n    p.z -= iTime;\n    vec3  q = vec3(fract (p.xz), p.y+0.8)*2.0 - 1.0;\n    float dist = length(max(abs(q)-vec3(lw, 0.5),0.0)); \n        if (fdist > dist){\n         fcol = col;\n         fdist = dist;\n        }\n    }\n    if (fdist > 1.0){fdist = 1.0;};\n    return vec4(fcol, fdist);\n}\nvec4 march(vec3 o, vec3 r, float q){\n \tvec4 t = vec4(0.0);\n    for (int i = 0; i < MAXITER; i++){\n     \tvec3 p = o + r * t.w;\n        vec4 d = map(p);\n        if (t.w > CLIP) break;\n        t.xyz = d.xyz;\n        t.w += d.w * q;\n    }\n    return t;\n}\nvec3 getNormal( vec3 p ){\n    vec2 e = vec2(0.01, -0.01); \n    return normalize(\n        e.xyy * map(p + e.xyy).w + \n        e.yyx * map(p + e.yyx).w + \n        e.yxy * map(p + e.yxy).w + \n        e.xxx * map(p + e.xxx).w );\n}\nvec3 shade(vec3 n, vec3 pos, vec3 col){\n\tvec3 iFin = vec3(0.0);\n    {\n     vec3  lipos = vec3(sin(iTime), 1.0, iTime*0.5);\n     vec3  licol = vec3(1.0);\n     float lintensity = 2.0;\n     vec3  lidir = normalize(lipos - pos);\n     vec3  libdir = vec3(dot(n, lidir));\n     iFin += col * libdir * lintensity;\n    }\n    return iFin;\n}\nvec3 gloss(vec3 col, vec3 rd, vec3 p, vec3 nor){\n\tvec3 c = col;\n    vec3 r = rd;\n    vec3 pos = p;\n    vec3 n = nor;\n    for (int i = 0; i < MAXREFLECTIONS; i++){\n        r = reflect(n, r);\n\t\tvec4 d = march(pos + r * 0.001, r, 0.3);\n        pos = pos + r * d.w;\n        n = getNormal(pos);\n        vec3 lit = shade(n, pos, d.xyz);\n        lit = clamp(lit, 0.0, 1.0);\n        c = mix(lit, c, REFLECTIVITY);\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.5, iTime*0.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float tt = iTime*0.2;\n    rd.xz *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    rd.xy *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    vec4 d = march(ro, rd, 0.2);\n    vec3 pos = ro + rd * d.w;\n    vec3 n = getNormal(pos);\n    vec3 lit = shade (n, pos, d.xyz);\n    vec3 final = gloss(lit, rd, pos, n);\n    col = final - d.w*0.05;\n    col = n;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XscXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdSDH", "name": "Easter Eggs on Parade", "author": "hubbe", "description": "Happy Easter", "tags": ["eggs"], "likes": 4, "viewed": 148, "date": "1459112146", "time_retrieved": "2024-06-20T18:34:19.952509", "image_code": "// Ball radius\n#define R 0.07\n\nfloat map(vec3 p, bool tangent_distance) {\n    // This makes everything below repeat infinitely.\n    p = mod(p, 0.2) - vec3(0.1);\n\n    // Distance to center of ball, squared.\n    float l2 = dot(p, p);\n            \n    // Fall back on a regular distance map.\n    return (length(p)*3.0  - R + length(p + vec3(0, -0.04,0)) - R) /4.0;\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 80; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n\t    float distance_to_closest_object = map(position, !hit);\n\n        if (distance_to_closest_object < 0.0001) {\n        \tif (distance_to_closest_object < 0.0) {\n                // We are inside of an object. Go back to the\n                // previous position and stop using tangent distances\n                // so that we can find the surface.\n            \thit = true;\n          \t    travel_distance = last_travel_distance;\n           \t    continue;\n            }\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += distance_to_closest_object;\n    }\n    // We hit something, but then we ran out of iterations while\n    // finding the surface.\n    if (hit) return travel_distance;\n    // We walked 50 steps without hitting anything.\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -1);\n\n    // Animate\n    camera_position.z += iTime/2.0;\n    camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 1.0;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n\n\t// Direction of the sun.\n    vec3 sun_direction = normalize(vec3(0.2, 1, -1));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance == 0.0) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n\n    // Distance from surface.\n    float surface_dist = map(hit_position, false);\n    \n    // How far we step towards the sun.\n    float sun_ray_step_length = 0.005;\n    \n    // Take a small step in the direction of the light source and measure how\n    // far we are from the surface. The further away we got, the brighter this\n    // spot should be.\n    float surface_dist_nearer_sun = map(hit_position + sun_direction * sun_ray_step_length, false);\n    \n    // Calculate how much sunlight is falling on this spot (hit_position).\n    float sunlight = max(0.0, (surface_dist_nearer_sun - surface_dist) / sun_ray_step_length);\n\n    // Reduce the sunlight with distance to make it fade out far away.\n    sunlight /= (1.0 + travel_distance * travel_distance * 0.2);\n    \n    // Alternate blue and orange balls using magic.\n    float n = dot(vec3(1.0), floor(hit_position * 5.0));\n    if (mod(n, 2.0) == 0.0) {    \n    \t// Blue palette.\n    \tfragColor = vec4(sunlight * 1.5, sunlight * 1.5, sunlight * 1.5, 1.0);\n    } else {\n        // Fire palette.\n    \tfragColor = vec4(sunlight * 1.5, pow(sunlight, 2.5), pow(sunlight, 12.), 1.0);\n    }\t\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdSDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdSDN", "name": "RayMarching Shadows 001", "author": "andro", "description": "PAARDEN !\nBasic Raymarching system. Built with the help of  user Daedelus.", "tags": ["raymarch"], "likes": 6, "viewed": 220, "date": "1459431055", "time_retrieved": "2024-06-20T18:34:21.892064", "image_code": "////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n/*\n * # Raymarched distance-field renderer tutorial\n * # Part 1: Basic Distance Field & Raymarching\n *\n * ```\n * Author:  Sbastien Pierre   http://sebastienpierre.ca   @ssebastien\n * License: BSD License\n * ```\n *\n * This shader is meant to show how to implement a raymarching distance field\n * shader-based renderer. It is based on the work of Inigo Quilezles (\"iq\"), whose\n * amazing code can be see all around on Shadertoy.com.\n *\n * Before editing/reading this shader, you should learn about distance fields and\n * raymarching, in particular [DIST] and [RAY] mentioned below. This tutorial's code\n * is based on the [TRI] code by `iq`.\n *\n * References:\n *\n * - [DIST] http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n * - [TRI]  https://www.shadertoy.com/view/4sXXRN\n * - [RAY]  http://www.iquilezles.org/www/material/nvscene2008/nvscene2008.htm\n*/\n\n/**\n  * sdSphere is the distance field-based sphere equation as described\n  * by iq in [DIST]\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\t// The sphere is positioned at the origin (0,0,0) and has a radius of `s`.\n\t// the distance between the point `p` and the envelope of the shpere is\n\t// then the distance between the point and the origin, minus the radius\n\t// of the sphere.\n\treturn length(p)-s;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) \n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n/**\n  * The map function is where you can register the distance field functions\n  * for all the \"objects\" in your scene. It is fairly simple to do union, interection\n  * difference, and repeats, as explained in [DIST]\n*/\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) \n{\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) \n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) \n{\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) \n{\n\tvec2 u = max(vec2(r - a,r - b), vec2(0.0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\n\nconst float maxd = 100.0;//defines max distance\n\nfloat map( in vec3 p )//where the magic happens\n{\n    \n    \n    pR(p.zx,-0.45);\n     vec3 posmod1 = p+vec3(0.0,0.75,0.0);\n     float floor1 = fBox(posmod1,vec3(3.0,0.1,3.0));\n     float box2 = fBox(vec3(p.x-1.5,p.y+0.3,p.z),vec3(0.375));\n   \n    \n     pR(p.yz,sin(iTime));\n    pR(p.xz,cos(iTime));\n    float sphere1 = sdSphere(vec3(p.x+0.5,p.y,p.z), 0.5);\t\n    float box1 = fBox(vec3(p.x+0.5,p.y,p.z),vec3(0.375));\n   \n   \n   \n    \n    float result1 = max(-sphere1,box1);\n    float result2 = fOpUnionRound(floor1,result1 , 0.0); \n    float result3 = fOpUnionRound(box2,result2 , 0.0); \n    return result3;\n    //return plane1;\n\t\n}\n\n//SOFT Shadow function from IQ has to be under map.\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0 ; i < 50 ; ++i)//defines steps for shadows\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        if(t > maxt)\n            break;\n    }\n    return res;\n}\n\n\n\n//GENERATES NORMALS\nvec3 fNormal(vec3 intersection, float lastDistance)//generates normals\n{\n    vec2 epsilon = vec2(0.01, 0.0);\n    return normalize((vec3(map(intersection + epsilon.xyy),\n    map(intersection + epsilon.yxy),\n    map(intersection + epsilon.yyx)) - lastDistance) / epsilon.x);\n}\n\n/**\n  * The `intersect` function is the main raymarching algorithm. It takes\n  * the ray origin `ro` and the ray step (or delta) `rd`. `rd` will be\n  * repeatedly added to `ro` until the `map` function (which determines\n  * the distance between the given point and the union of all objects\n  * in the scene) returns a value that is close to 0 (meaning the current\n  * point is almost on the scene object's envelope.\n  *\n  * Note that if `rd` is not normalized, the steps will increase or\n  * decrease as the intersection algorithm go.\n*/\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec3 normal )//This part of the raymarching setup, don't change for now\n{\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<100; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.0 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n\t    h = map( ro+rd*t );\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\t\n    normal = fNormal(ro + rd * t, h);//calculates normals for lighting\n    return t;\n}\n/*  /// original code from IQ for softshadow\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel, meaning it\n    // is between [0,0] and [1,1]\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    \n    // If you do `p=q`, you will see that the origin is to the bottom left \n    // of the screen. With this simple expression, we adjust the viewpoint\n    // in the space and center the origin in the preview screen.\n    //\n    // vec2 p = q;              // [1] Origin is at the bottom-left of the screen\n    // vec2 p = 2.0 * q;        // [2] We scale by 1/2 by multiplying q\n    vec2 p = 2.0 * q - 1.0;     // [3] We scale by 1/2 and then center the origin on screen\n    // vec2 p = -0.5 + q;       // [4] Alternatively, we can center without scaling\n    \n    // NOTE: I'm not very familiar with the shader API, but from the above we can deduce\n    // that 1.0 means [1.0, 1.0] for a vect2, 2.0 means [2.0, 2.0], etc.\n    \n    // `iResolution.x/isResolution.y` is the aspect ratio, by default it is 512/288~=1.7777.\n    // If you uncomment the following line the image will appear as squashed.\n    p.x *= iResolution.x/iResolution.y;  \n    \n    // The `ro` value specifies the origin of the camera's center in the virtual space.\n    // You can tweak the X and Y values to shift the origin, or the Z value to\n    // adjust the distance to the sphere (here it is 2.0 to the sphere's center).\n\tvec3 ro = vec3(0.25, 0.0, 3.0 );\n   \n    // The `rd` value specifies the  direction of the current pixel (on the projection\n    // plane) in the 3D space The notation vec3(p,-1.0) is equivalent to vec3(p.x,p.y,-1.0) as\n    // `p` is a vec2. -1.0 for z means it is pointing forward, and the normalization ensures\n    // that `rd` can be used as a step for raymarching.\n    vec3 rd = normalize( vec3(p,-2.0) );//normally -1.0 Lens distortion ?\n\t\n    // The `col` vector holds the color that will be rendered on the screen, ie. the main\n    // output of the shader. As the alpha channel will be set to 1.0, we only need the\n    // three components RGB, hence the use of a vec3.\n\tvec3 col = vec3(0.0);\n\n    // We call the `interect` function with `ro` as the ray origin and `rd` as the \n    // point from which the raymarching step/delta will be calculated. Intersect is the\n    // main raymatching function.\n     vec3 normal ;\n   \n    float t = intersect(ro,rd,normal);\n   \n    vec3 pos = ro + t*rd;\n        vec3 nor = fNormal( pos,t );\n    // If t > 0.0, it means the ray cast from `ro` through `rd` has intersected with\n    // an object of the scene, in which case we'll assign a non-black color to the\n    // pixel.\n   \n        // Here we do the simplest possible shading, which is based on the distance between\n        // the ray and the sphere. if `t == 0`, it means the sphere's envelope is intersecting\n        // with the current pixel, otherwise t will be the distance between the current pixel\n        // and the sphere's envelope. \n        //\n  \t\t// NOTE: I'm not sure exactly why we need to substract t from 2.0 and not 1.0. I would\n        // assume that because the projection plane is at -1.0 (as set by `rd.z`) and that the\n        // sphere is at the origin with a 1.0 radius that there t would be osciallating between\n        // 0 (closest) and 1.0 (farthest). If you try changing rd to the following expression:\n        //\n        // vec3 rd = normalize( vec3(p,-2.0) );\n        //\n        // You will only make the sphere closer, but the values for `t` will remain the same\n        // (the shading will remain). However, if you change the value of `ro` to the following:\n        //\n        // vec3 ro = vec3(0.0, 0.0, 2.5 );\n        //\n        // not only will the sphere shrink on the projection, but `t` will also increase. It is\n        // not clear to me yet why that is.\n        //float d =  max(0.0, 2.0 - t);\n         \n         //float d =  max(0.0, 1.0-(t/1.0));\n    \tfloat d = min(1.0, t/maxd);\n        vec3 fog_color = vec3(0.5, 0.5, 0.5);\n    \tvec3 obj_color = vec3(1.0, 1.0, 1.0);\n        \n        vec3 light_direction = normalize(vec3(sin(iTime), 1.0, 0.5));\n    \t//float diffuse = clamp(dot(normal, light_direction) * 0.5 + 0.5, 0.0, 1.0);//backup\n   // normal diffuse lighting would be\n\t\tfloat diffuse = clamp(dot(normal, light_direction) , 0.0, 1.0);//improved lighting ?\n     //   float diffuse = clamp(dot(normal, light_direction) * 0.5 + 0.5, 0.0, 1.0);//old way of calculating the diffuse light\n       float shadow = softshadow (ro + rd * t, light_direction, 0.01, 5.0 , 64.0 );//last number defines shadow quality\n        \n    \tcol = mix(obj_color * diffuse *shadow, fog_color, d);\n   \n\t// We assign the color we've just computed.\n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdSRN", "name": "Cube thingy", "author": "sillsm", "description": "Spinning cube thing. Using dFdx and dFdy to compute surface normals w.r.t window coordinates.", "tags": ["raymarching", "cube"], "likes": 1, "viewed": 153, "date": "1458024531", "time_retrieved": "2024-06-20T18:34:22.407325", "image_code": "// Copyright Max Sills 2016, licensed under the MIT license.\n// Spinning cube thing, alternative to iq normal func, but rough edges.\n//\n// Quaternion rotation around axis, of angle, centered at center.\nvec3 qRotate(vec3 axis, float angle, vec3 center, vec3 point)\n{\naxis = normalize(axis);\nfloat x = axis.x * sin(angle / 2.);\nfloat y = axis.y * sin(angle / 2.);\nfloat z = axis.z * sin(angle / 2.);\nfloat w = cos(angle / 2.);\n\nmat3 rotation = mat3(1. - 2.*y*y - 2.*z*z, 2.*(x*y+w*z), 2.*(x*z-w*y),\n                     2.*(x*y-w*z), 1. - 2.*x*x - 2.*z*z, 2.*(y*z +w*x),\n                     2.*(x*z + w*y), 2.*(y*z-w*x),1. - 2.*x*x - 2.*y*y);\n     \nreturn center + (rotation * (point-center));\n}\n\n// Rounded box minus a sphere with oscilating radius.\nfloat udBox( vec3 p, vec3 b )\n{\n  p = qRotate(vec3(0,1.,1.),iTime,vec3(0.), p);\n  return max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p) - 2.-.5*abs(cos(iTime))));\n}\n\n\nvec4 trace(vec3 eye, vec3 viewportxy)\t\t\t\t// You -could- do this recursively, but itterative is simpler and safer\n{\n    vec3 p = vec3(0);\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i)\t\t\t\t// We know what direction the pixel is, and we want to know\n    {\t\n        //   the amount t must be to get to it\n        p = viewportxy + (t* normalize(viewportxy-eye));\t\t\t\t// Pick a point along the ray r at a distance t from the origin \n        //float distance = distanceFromEdge(p);   // Let d be the new distance from the circle edge, negative or positive\n        float dist = udBox(p, vec3(1,1,1));\n        //dist = distanceFromEdge(p);\n        t += dist * .9;\t\t\t\t\t// Now change the distance factor t by half the distance we currently are from edge\n    }\n    return vec4(p,t);\t\t\t\t\t\t\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio; rescale texcoords horizontally based on it\n    \n    // assuming viewing plane \n    // Image plane is at (0, 0, -2)\n    vec3 viewportxy = vec3(uv , -10.0);\t\t// Direction to the pixel (unit vector, no magnitude)\n    vec3 eye = vec3(0, 0, -15);\t\t\t// Camera origin at 0,0,-3\n    \n    vec4 tr     = trace(eye, viewportxy);\t\t\n    vec3 pos    = normalize(tr.xyz);\n    vec3 ref    = vec3(0.,0.,1.);\n    float t     = tr.w;\n    \n    // Normal computation. Nifty and without ref to distance function.\n    // But super aliased unless using rounded corners.\n    vec3 x = dFdx(tr.xyz);\n    vec3 y = dFdy(tr.xyz);\n    vec3 normal = normalize(cross(x,y));\n    \n    normal = qRotate(vec3(0.,1.,1.),iTime,vec3(0.), normal);\n    normal = abs(normal);\n\n    fragColor = 5.*(1./t)*vec4(normal,0);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsV3Wd", "name": "Pulsing Solid Circle", "author": "pairlapinpin", "description": "Circle with texture", "tags": ["circle"], "likes": 0, "viewed": 91, "date": "1457129357", "time_retrieved": "2024-06-20T18:34:22.407325", "image_code": "#define\tR\t\t0.25\n//#define\tR2\t\t(R*R)\n#define CENTER\tvec2(0.5, 0.5)\n#define PI\t\t3.1415936\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float xonyratio = iResolution.x / iResolution.y;\n    float timepulse = sin(((iTime-float(int(iTime / 4.0)*4))/4.0)*2.0*PI);\n    float timepulse2 = sin(((iTime-float(int(iTime / 8.0)*8))/8.0)*2.0*PI);\n\n    vec2 center = CENTER;\n    // moving center over time\n    center.x = center.x + timepulse*0.1;\n    center.y = center.y - timepulse2*0.1;\n    //float module = (uv.x-center.x)*(uv.x-center.x)*xonyratio*xonyratio + (uv.y-center.y)*(uv.y-center.y);\n    vec2 uvratio = (uv - center); uvratio.x = uvratio.x * xonyratio;\n    float module = length(uvratio);\n    \n    // radius pulsing over time\n    //float pulsedRadius = R2*(0.75+0.25*timepulse);\n    float pulsedRadius = R*(0.75+0.25*timepulse);\n    \n    if (module > pulsedRadius)\n    {\n        //float textureCoord = iChannel0.x;\n        vec4 textureColor = texture(iChannel0,uv);\n        fragColor = textureColor*0.1 + vec4(uv,0.5+0.5*sin(iTime),1.0)/(1.5+1.0*(1.0+cos(iTime)))*0.9;\n    }\n    else\n    {\n        vec4 textureColor = texture(iChannel1,uv);\n\t\tfragColor = textureColor*0.2 + vec4(uv,0.5+0.5*sin(iTime),1.0)*0.8;\n    }\n\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsV3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsVGDt", "name": "raymarching basic 3d objects", "author": "robertsarvas", "description": "raymarching basic 3d objects", "tags": ["raymarching", "3dobjects"], "likes": 1, "viewed": 125, "date": "1457128503", "time_retrieved": "2024-06-20T18:34:23.558840", "image_code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    //p.z = 0.1,0.15;\n    //p.y = p.y - s ;\n    //p.x = p.x - s ;\n    return length(p) - s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    \n  \n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n\n // return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n//----------------------------------------------------------------------\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.75, 0.0), 0.25 ), 46.9 ) );\n//    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n//    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.50, 2.0), vec2(0.45,0.15) ), 75.0 ) );\n//    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n//\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n//\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n//\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n//\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n//\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n//\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n//\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n//    res = opU( res, vec2( opS(\n//\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n//\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n //   res = opU( res, vec2( opS(\n//\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n//\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n//\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n//\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n//\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n//\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n//\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n//                                       65.0 ) );\n//\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n//    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n //   res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
