{"id": "4dB3DV", "name": "Perlin Noise Funnnn", "author": "steverock", "description": "Texture-less Perlin shader code taken from here: https://github.com/ashima/webgl-noise\n\nwarping ", "tags": ["perlin"], "likes": 5, "viewed": 522, "date": "1393353675", "time_retrieved": "2024-06-20T18:09:03.931077", "image_code": "\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise2d(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise3d(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n }\n\nfloat bpm = 150.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat hz = bpm*1.0/60.0;\n\t\t\n\tfloat size = min(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / size;\n\t\n\t// warp the UV - warping a lot makes it more thin-streaky\n\t// sin curve to modulate with time\n\tuv += 0.05*(sin(6.3/20.*iTime)*2.-1.)\n\t\t* vec2(snoise2d(uv*4.),snoise2d(uv*2.));\n\t\n\tfloat sweeper = sin(uv.x*6.3/1.+iTime*hz) * 0.5 + 0.5;\n\tfloat sharpness = mix(0.3, 1.2, sweeper);\n\tfragColor.rgb =\n\t\t// purple/yellow wave\n\t\tvec3(1,0.5, mix(0.5, 1.0, sweeper))\n\t\t* smoothstep(0.4, 0.5, pow(snoise3d( vec3(uv*10., iTime )),sharpness));\n\t\n\tfragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dB3DV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dj3DK", "name": "Classic RGB Plasma", "author": "fragvarken", "description": "A good old demo plasma effect, and my first submission for ShaderToy!\nNot very optimised, but it works :)\nThis is actually (derived from) the shader I use in two published apps for Android (PlasmaPro 5000 and Visualisator 5000), so enjoy!\n", "tags": ["demoplasmaeffect"], "likes": 6, "viewed": 354, "date": "1393594812", "time_retrieved": "2024-06-20T18:09:04.695240", "image_code": "/*\nAn old-school RGB plasma, built from several layers of sine functions\nBasically a straight port from my highly optimished C plasma code from way back (1996) to a shader,\nwithout any shader specific optimisations. There's probably a lot of redundant stuff in here, and other\nthings that could be optimised out like doing the fadeFix without branching etc.\n\nFeel free to optimise and let me know how you get on!\n\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n-- Fragvarken\n*/\n\nfloat stab1( float angleParam )\t\t\t// input: angle in radians, output: new angle\n{\n\treturn ( (cos( mod(angleParam,6.28318) ) + 1.0) / 2.0) * 2.0 * 3.14159;\n}\n\nfloat stab2( float angleParam )\t\t\t// input: angle in radians, output: new angle [0..2*PI]\n{\n\treturn ((sin( mod(angleParam,6.28318) ) + 1.0) / 2.0) * 2.0 * 3.14159;\n}\n\nfloat fadeFix( float angleParam )\n{\n\tif( angleParam > (2.0 * 3.14159) )\n\t{\n\t\tangleParam = (2.0 * 3.14159) - (angleParam - 2.0 * 3.14159);\n\t}\n\t\n\treturn clamp( angleParam / (2.0 * 3.14159), 0.0, 1.0 );\n}\n\n\nvec2 rotate( in vec2 vector, in float angleRad)\n{\n\tfloat cs = cos(angleRad);\n\tfloat sn = sin(angleRad);\n\n    vec2 result;\n\tresult.x = vector.x * cs - vector.y * sn;\n\tresult.y = vector.x * sn + vector.y * cs;\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t// texture variables\n\tfloat redAngle = mod(iTime*0.5,6.28318);\n\tfloat greenAngle = mod(iTime*0.4,6.28318);\n\tfloat blueAngle = mod(iTime*0.3,6.28318);\n\t\n\tfloat redMult = (sin(iTime*0.2) + 1.0) / 2.0;;\n\tfloat greenMult = (sin((iTime+3.0)*0.29) + 1.0) / 2.0;;\n\tfloat blueMult = (sin((iTime+1.5)*0.4) + 1.0) / 2.0;;\n\t\n\tvec3 color;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = rotate(uv, iTime * 0.15 + sin(uv.x*6.28318)*sin(iTime*0.3)*0.25 + sin(uv.y*6.28318)*sin(iTime*0.2)*0.25);\n\t\n\tfloat y = ((uv.y / 0.0025) / 360.0) * 3.14159;\n\tfloat x = ((uv.x / 0.0015) / 360.0) * 3.14159;\n\n\t// red\n\tfloat m_ri2 = stab1( redAngle*2.0 + y );\n\tfloat m_rj2 = stab2( stab2( redAngle + 0.0 ) + y );  \n\tfloat inner = stab2( m_ri2 + x ) + m_rj2;\t\t//[0..4*PI]\n\tcolor.r = fadeFix( inner ) * redMult;\n\n\t// green\n\tm_ri2 = stab1( greenAngle*3.0 + y );\n\tm_rj2 = stab2( stab2( greenAngle + 0.8 ) + y );  \n\tinner = stab2( m_ri2 + x ) + m_rj2;\t\t//[0..4*PI]\n\tcolor.g = fadeFix( inner ) * greenMult;\n\n\t// blue\n\tm_ri2 = stab1( blueAngle*4.0 + y );\n\tm_rj2 = stab2( stab2( blueAngle + 1.9 ) + y );  \n\tinner = stab2( m_ri2 + x ) + m_rj2;\t\t//[0..4*PI]\n\tcolor.b = fadeFix( inner ) * blueMult;\n\n\tvec3 finalcolor = color;\n\n\tfragColor = vec4( finalcolor , 1.0 );\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dj3DK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSGWV", "name": "Furry Torus", "author": "Antonalog", "description": "At last! We have achieved the computer graphics of 1989: http://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf\nMaybe realtime in 2019?  A bunch of quality sacrifices to make web GL happy. Play with the defines if you have a good rig. :)", "tags": ["noise", "raymarch", "torus", "shadow", "fur", "beer", "donut"], "likes": 31, "viewed": 753, "date": "1393417946", "time_retrieved": "2024-06-20T18:09:08.731302", "image_code": "//At last! We have achieved the computer graphics of 1989:\n//http://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf\n\n//select a fuzz!\n//#define FUZZ_TYPE 0\t\t//uniform density, not fuzzy. wuzzy?\n//#define FUZZ_TYPE 1\t\t//high freq fuzz\n//#define FUZZ_TYPE 2\t\t//lumpy fuzz\n//#define FUZZ_TYPE 3\t\t//just the falloff\n#define FUZZ_TYPE 4\t\t\t//furry fur\n\n//#define TEXTURED_LIGHT\n\n//#define POINT_LIGHT\t\n\n#define SHADOW_STEPS\t4\t\n\n//moar steps for main view = too much quality for windoze\n#define SHQ\n//#define MEDQ\n//#define YUCKQ\n\n//get rid of a few math ops for more linear noises\n#define CHEAPER_NOISES\n\n//this ray torus code is much nicer/higher quality but for some reason ANGLE does not like it!?!\n//#define IQ_RAY_TORUS\n\n#define MAIN_LOD_BIAS \t\t\t-10.\n#define MAIN_SHADOW_LOD_BIAS\t3.\n#define GROUND_SHADOW_LOD_BIAS\t3.\n\n#define SELF_SHADOW\n\n#define MAIN_TRACE\n#define SHADOW_TRACE\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord);\nvec4 Sort(vec4 n);\nvec4 RayTorus(vec3 ro, vec3 rd, float R, float r);\nfloat noise( in vec3 x, float lod_bias );\nvec2 noise2( in vec3 x, float lod_bias );\nfloat sdTorus( vec3 p, vec2 t );\nvec3 nTorus( in vec3 pos, vec2 tor );\n\n#define pi 3.1415927\n\n\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvec3 RotZ(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c,\n\t\t\t\tp.z);\n}\n\nvec4 quat_rotation( float half_angr, vec3 unitVec )\n{\n    float s, c;\n    s = sin( half_angr );\n    c = cos( half_angr );\n    return vec4( unitVec*s, c );\n}\n\nvec3 quat_times_vec(vec4 q, vec3 v)\n{\n\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\t\nfloat r=.75;\nfloat R =1.2;//(1.+sin(iTime*0.7)*r*.5);\n\n\n#define RATE\t7.\t\t\t\n\nfloat density(vec3 p, float sdf, float lod_bias)\n{\n\tfloat falloff =\tmax(-sdf/r,0.);\n\n\tfloat\td = 0.1;\n#if FUZZ_TYPE == 1\n\t//high freq fuzz\n\td = noise( p*RATE*8.123, lod_bias);\n//\td=sqrt(d);\n\td*=d;\n#endif\t\n#if FUZZ_TYPE == 2\n\t//lumpy fuzz\n\td = noise( p*RATE, lod_bias);\n\td *= noise( p*(RATE*1.17), lod_bias )-0.3;// * 0.5;\n\td *= noise( p*(RATE*4.03), lod_bias )-0.2;// * 0.25;\t\t\t\t\n\td *= noise( p*(RATE*8.11), lod_bias )-0.1;// * 0.125;\nd *= 20.;\nd = max(d,0.);\n#endif\t\n#if FUZZ_TYPE == 4\n\tp += (noise2( p*1.3, lod_bias ).yxy*2.-1.)*0.25; //ought to be a vector wibble but keep it cheap!\n//\tp -= 0.9*sdf * nTorus(p,vec2(R,r));\t\t//shoot to surface\n\tp -= 0.9*sdTorus(p,vec2(R,r)) * nTorus(p,vec2(R,r));\t//maybe slightly more correct to redo sdf post warping?\n\td = noise( p*RATE*6.123, lod_bias);\t//high freq hairs\n\td*=d;\n\td = d < .2 ? 0. : d;\t\t\t\t//clip out low alpha gunk to make hairs distinct\n\t\n#endif\n#if FUZZ_TYPE > 0\n\td *= falloff;\n#endif\t\n\treturn d * .25;\n}\n\n#ifdef POINT_LIGHT\nfloat lightT = iTime;\nvec3 lightPos = vec3(0,sin(lightT),cos(lightT))*(R) + vec3(0,R,0);\n\nvec3 TexturedLight(vec3 p)\n{\n\tvec3 d = lightPos-p;\n\tfloat falloff = 1.0 / (0.1*dot(d,d)+1.);\n#ifdef TEXTURED_LIGHT\t\n\td = RotZ( d, iTime*1.7654321 );\n\tvec3 c = texture(iChannel3,d).xyz;\n\treturn c*falloff ;\n#else\t\n\treturn vec3(falloff);\n#endif\n}\n#else\nvec3 offAxis = normalize(vec3(-.25,1,1));\nvec3 lightDir = normalize(vec3(1,2,1)); //RotY( offAxis, iTime );\n\nvec3 TexturedLight(vec3 p)\n{\n#ifdef TEXTURED_LIGHT\t\n\tmat3 m = mat3(  \n\t\tvec3(0.970142,-0.000000,0.242536),\n\t\tvec3(0.168880,0.717741,-0.675521),\n\t\tvec3(-0.174078,0.696311,0.696311));\n\tp = RotY(p,-iTime);\n\tp = m * p;\n\t\n\tvec3 L = texture(iChannel2,p.xz*.1-vec2(0.25,0.5),3.).xyz;\n\tL+=sin(iTime)*0.4+0.5;\n\tL+=0.25;\n\tL*=L;\n\tL*=L;\n\treturn L;\n#else\n\treturn vec3(1);\n#endif\t\n}\n#endif //not POINT_LIGHT\n\nvec3 Trans(float thick)\n{\n\tvec3 beer = vec3(0.793,3.955,0.453);;\n\tvec3 transmittance = exp(-beer*thick);\n\treturn transmittance;\n}\n\nvec3 difColor = vec3(0.875,0.974,0.000);\nvec3 transColor = vec3(0.205,0.000,0.405);\n\n\nfloat shmarch(vec3 p, vec3 L, float start, float end, float lod_bias)\n{\n\tfloat d = 0.;\n\t\n\tfloat dt = (end-start)*(1./float(SHADOW_STEPS));\n\t\n\tp += L * (start + 0.5* dt);\n\t\n\tfor (int i=0; i<SHADOW_STEPS; i++)\n\t{\n\t\tfloat sdf = sdTorus( p, vec2(R, r) );\n\t\n\t\td += density(p,sdf,lod_bias) * dt;\n\t\tp += L * dt;\n\t}\n\t\t\t\t\t\t\t\n\treturn d*100.;\t\t\t\t\t\t\n}\n\nfloat shamarch(vec3 P, vec3 L, vec4 interval, float lod_bias)\n{\n\tfloat d = 0.;\n\t\n\tfloat start = interval.x;\n\tfloat end\t= interval.y;\n\tfloat dt = (end-start)*(1./float(SHADOW_STEPS));\n\t\n\tvec3 p = P + L * (start + 0.5* dt);\n\t\n\tfor (int i=0; i<(SHADOW_STEPS*2); i++)\n\t{\n\t\tif (i==SHADOW_STEPS)\n\t\t{\n\t\t\tstart = interval.z;\n\t\t\tend\t= interval.w;\n\t\t\tdt = (end-start)*(1./float(SHADOW_STEPS));\n\t\n\t\t\tp = P + L * (start + 0.5* dt);\n\t\n\t\t}\n\t\t\n\t\tif (start<1e5)\n\t\t{\n\t\t\tfloat sdf = sdTorus( p, vec2(R, r) );\n\t\t\n\t\t\td += density(p,sdf,lod_bias) * dt;\n\t\t\tp += L * dt;\n\t\t}\n\t}\n\t\t\t\t\t\t\t\n\treturn d*100.;\t\t\t\t\t\t\n}\n\n\nvec4 BlendUnder(vec4 accum,vec4 col)\n{\n\tcol = clamp(col,vec4(0),vec4(1));\t\n\tcol.rgb *= col.a;\n\taccum += col*(1.0 - accum.a);\t\n\treturn accum;\n}\n\nvec4 march(vec4 accum, vec3 viewP, vec3 viewD, vec4 roots)\n{\n\t//exponential stepping\n#ifdef SHQ\n\t#define STEPS\t128\t\n\tfloat slices = 512.;\n#endif\t\n#ifdef MEDQ\n\t#define STEPS\t64\t\n\tfloat slices = 256.;\n#endif\t\n#ifdef YUCKQ\t\n\t#define STEPS\t32\t\n\tfloat slices = 128.;\n#endif\n\t\n\tfloat Far = 10.;\n\t\n\tfloat tt = roots.x;\n\tfloat end = roots.y;\n\tfloat sliceStart = log2(tt)*(slices/log2(Far));\n\tfloat sliceEnd = log2(end)*(slices/log2(Far));\n\t\t\t\n\tfloat last_tt = tt;\n\t\n\tif (tt< 1e5)\n\tfor (int i=0; i<STEPS; i++)\n\t{\t\t\t\t\t\t\t\n\t\tsliceStart += 1.;\n\t\tfloat sliceI = sliceStart;// + float(i);\t//advance an exponential step\n\t\ttt = exp2(sliceI*(log2(Far)/slices));\t//back to linear\n\n\t\tvec3 p = viewP+tt*viewD;\n\t\t\t\t\t\t\n\t\tfloat sdf = sdTorus( p, vec2(R, r) );\n\n\t\tfloat dens = density(p, sdf, MAIN_LOD_BIAS);\n\t\t\n\t\tdens *= (tt-last_tt)*100.;\t//density ought to be proportional to integral over step length?\n\t\tlast_tt = tt;\n\n#ifdef POINT_LIGHT\t\t\n\t\tvec3 lightDir = lightPos-p;\n\t\tfloat light_dist = length(lightDir);\n\t\tlightDir = normalize(lightDir);\n#endif\n\t\t\n\t\t//amount of stuff light had to go through to get here\n\t\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n#ifdef SELF_SHADOW\t\t\n\n//\t\tfloat thick = shamarch(p, lightDir, vec4(0.,shadow_roots.xyz), MAIN_SHADOW_LOD_BIAS);\n\t\t\t\n#ifdef POINT_LIGHT\t\t\n\t\tshadow_roots[0]=min(shadow_roots[0],light_dist);\n#endif\n\t\t//well this must be an exit cos we started inside\n\t\tfloat thick = shmarch(p, lightDir, 0., shadow_roots[0], MAIN_SHADOW_LOD_BIAS);\n\n\t\tif (shadow_roots[1]<1e5)\t//and there might be another segment\n\t\t{\n#ifdef POINT_LIGHT\t\t\n\t\t\tshadow_roots.yz=min(shadow_roots.yz,vec2(light_dist));\n#endif\t\t\t\n\t\t\tthick += shmarch(p, lightDir, shadow_roots[1], shadow_roots[2], MAIN_SHADOW_LOD_BIAS);\n\t\t}\n#else\n\t\tfloat thick = 0.2;//shadow_roots.x+shadow_roots.z-shadow_roots.y;\n#endif\n\t\t\n\t#if 1\t\n\t\t//surface-like reflection term falling off towards interior of torus\n\t\tvec3 n = nTorus( p, vec2(R, r) );\n\t\tfloat dif = max(dot(n,lightDir),0.);\n\t\tfloat reflective = 1.-(abs(sdf)/r);\n\t\treflective*=reflective;\n\t\treflective*=reflective;\n\t\tdif *= reflective;\n\t#endif\t\n\t\t\t\t\n\t\tvec3 transmittance = Trans(thick);\n\t\t\t\n\t\tfloat shadow = max(1.-thick,0.);\t\t\n\t//\tvec3 c = vec3(transColor+dif*difColor) * shadow;\n\t//\tvec3 c = vec3(transColor) * shadow;\n\t\t\n\t\tvec3 c = vec3(transColor+dif*difColor) * transmittance;\n\n\t#if 0\t\n\t\tfloat fy = -(R+r);\t\t\t\t//the floor\n\t\tfloat h = p.y - fy;\t\t\t\t//distance to floor\n\t\th = max(1. - (h/(1.*(R+r))),0.);\t\t//fall off\n\t\tc += vec3(max(-n.y*.05,0.0))*h;\t//downwards normals get some floor bounce\n\t#endif\n\t\t\n\t//\tvec3 c = vec3(transColor) * transmittance;\n\t\t\n\t\tc *= TexturedLight(p);\n\t\t\n\t\taccum = BlendUnder(accum,vec4(c,dens));\n\n\t\tif (accum.a > 0.99) break;\n\t\t\n\t\t//if (sliceI > sliceEnd) break; //out of exponential steps\t\n\t\tif (sliceI > sliceEnd)\n\t\t{\n\t\t\t//go to next interval\n\t\t\ttt = roots.y;\n\t\t\tend = roots.w;\n\t\t\tsliceStart = log2(tt)*(slices/log2(Far));\n\t\t\tsliceEnd = log2(end)*(slices/log2(Far));\t\n\t\t\tlast_tt = tt;\n\t\t\n\t\t\tif (tt> 1e5) break;\n\t\n\t\t}\n\t}\t\n\t\n\treturn accum;\n}\n\nfloat Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return -1.0;\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\treturn (-b-d)*oo2a; //min((-b-d)*oo2a,(-b+d)*oo2a);\n}\n\nfloat RaySphere(vec3 P, vec3 V, vec3 A, float r)\n{\n\treturn Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-r*r-(2.0*(dot(A,P))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD, fragCoord);\n\n\t//ground plane\n\tfloat floor_height = -(R+r);\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\tvec3 c = texture(iChannel0,p.xz*0.1).xyz;\n\tc = pow(c,vec3(2.2));\n\n#ifdef SHADOW_TRACE\n\n#ifdef POINT_LIGHT\t\n\tvec3 lightDir = lightPos-p;\n\tfloat lightDist = length(lightDir);\n\tlightDir = normalize(lightDir);\n#endif\t\n\t//darken by shadow ray through torus\n\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n\tfloat thick=0.;\n\t\n\tfor (int i=0; i<4; i+=2)\n\t{\n\t\tif (shadow_roots[i]<1e5)\n\t\t{\n\t\t\tvec2 sh = vec2(shadow_roots[i],shadow_roots[i+1]);\n#ifdef POINT_LIGHT\t\t\t\n\t\t\tsh = min(sh,vec2(lightDist));\n#endif\t\t\t\t\n\t\t\tthick += shmarch(p, lightDir, sh.x, sh.y, GROUND_SHADOW_LOD_BIAS);\n\t\t}\n\t}\n\n\tc *= max(lightDir.y,0.);\n\t\n\tc *= clamp(Trans(thick)+.2,0.,1.)*TexturedLight(p);\n\t\n\tfloat sdf = sdTorus( p, vec2(R, r) );\n\tc *= min(abs(sdf)+.1,1.);\t\t\t\t\t//block light/blob shadow\n\tc += transColor * max(1.-abs(sdf),0.)*.2;\t//bounce from floor\n#endif\t\n\n#ifdef MAIN_TRACE\t\t\n\t//ray marching segments of torus intersections\n\tvec4 roots = RayTorus(viewP, viewD, R, r);\n\n\tvec4 accum = vec4(0);\n\t\n#ifdef POINT_LIGHT\n\tfloat lightT = RaySphere(viewP, viewD, lightPos, 0.1);\n\tif (lightT >0.)\n\t{\n\t\tif (lightT < roots[0])\n\t\t{ \n\t\t\taccum = vec4( TexturedLight(viewP + lightT * viewD), 1.0); \n\t\t}\n\t}\t\n#endif\n\n\t\t\n//\taccum = march(accum,viewP, viewD, roots[0],roots[1]);\n//\taccum = march(accum,viewP, viewD, roots[2],roots[3]);\n\taccum = march(accum,viewP, viewD, roots);\n\t\n\t//comp over background \n\tc = BlendUnder(accum,vec4(c,1.)).xyz;\n//\tc = mix(c,accum.xyz,accum.w);\n#endif\n\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.);\n\teye = vec3(2.5,3.,-2.5) * 1.5; \t\n\teye = RotY(eye,iTime*.4);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\t//jitter to de-band\n\teye += ray * texture(iChannel1,p).x;\n}\n\nvec4 Sort( vec4 a)\n{\n\tvec4 m = vec4(min(a.xz,a.yw), max(a.xz,a.yw) );\n\tvec4 r = vec4(min(m.xz,m.yw), max(m.xz,m.yw) ); \n\ta = vec4( r.x, min(r.y,r.z),  max(r.y,r.z), r.w );\n\treturn a;\n}\n\n#define SMALL_ENOUGH 1e-4\n\n\n#ifdef IQ_RAY_TORUS\n//thanks iq!\n//https://www.shadertoy.com/view/4sBGDy\n//slight modifications to return ALL intersections\nvec4 RayTorus( in vec3 ro, in vec3 rd, float torus_R, float torus_r )\n{\n\tfloat Ra2 = torus_R*torus_R;\n\tfloat ra2 = torus_r*torus_r;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)*0.5;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) *(1.0/3.0) );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<SMALL_ENOUGH ) //this tolerance appears to be deeply annoying to tune. :(\n\t{\n\t\tif( d2<0.0 ) return vec4(1e20);\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return vec4(1e20);\n\t\td1 = sqrt( d1*0.5 );\n\t\td2 = q/d1;\n\t}\n\t\n    //----------------------------------\n\t\n\tvec4 result = vec4(1e20);\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t\n\t\tresult[0]=t1;\n\t\tresult[1]=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\tresult[2]=t1;\n\t\tresult[3]=t2;\n\t}\n\t\n\tfor (int i=0; i<4; i++) if (result[i]<0.) result[i]=1e20;\n\tresult = Sort(result);\n\treturn result;\n}\n\n#else //not IQ_RAY_TORUS buggy solver from POV Ray but keeps ANGLE happy?!!\n\n\n//https://github.com/POV-Ray/povray/blob/3.7-stable/source/backend/math/polysolv.cpp#L808\n\n#define DBL float \n\nfloat solve_cubic(float a1, float a2, float a3)\n{\n\tDBL Q, R, Q3, R2, sQ, d, an, theta;\n\tDBL A2;\n\t\n\tA2 = a1 * a1;\n\n\tQ = (A2 - 3.0 * a2) * (1./ 9.0);\n\n\t/* Modified to save some multiplications and to avoid a floating point\n\t   exception that occured with DJGPP and full optimization. [DB 8/94] */\n\n\tR = (a1 * (A2 - 4.5 * a2) + 13.5 * a3) * (1./ 27.0);\n\n\tQ3 = Q * Q * Q;\n\n\tR2 = R * R;\n\n\td = Q3 - R2;\n\n\tan = a1 * (1./3.);\n\n\tif (d >= 0.0)\n\t{\n\t\t/* Three real roots. */ //but only use the first!\n\n\t\td = R * inversesqrt(Q3);\n\n\t\ttheta = acos(d) * (1. / 3.0);\n\n\t\tsQ = -2.0 * sqrt(Q);\n\n\t\treturn sQ * cos(theta) - an;\n\t}\n\n\tsQ = pow(sqrt(R2 - Q3) + abs(R), 1.0 / 3.0);\n\n\tDBL t = sQ + Q / sQ;\n\t\n\tt = R < 0. ? t : -t;\n\treturn t - an;\n}\n\nvoid quartic_descartes(float c1, float c2, float c3, float c4, inout vec4 results)\n{\n\tDBL c12, z, p, q, q1, q2, r, d1, d2;\n\t\n\t/* Compute the cubic resolvant */\n\n\tc12 = c1 * c1;\n\tp =  -6. * c12 + 4.*c2;\n\tq =  c12 * c1 - c1 * c2 + c3;\n\tq *= 8.;\n\tr = -3. * c12 * c12 + c12 *4.*c2 - c1 * 8.*c3 + 4.*c4;\n\t\t\t\t\n\tfloat cubic_a1 = -0.5 * p;\n\tfloat cubic_a2 = -r;\n\tfloat cubic_a3 = 0.5 * r * p - 0.125 * q * q;\n\n\tz = solve_cubic(cubic_a1, cubic_a2, cubic_a3);\n\n\td1 = 2.0 * z - p;\n\n\tif (d1 < 0.0)\n\t{\n\t\tif (d1 > -SMALL_ENOUGH)\n\t\t{\n\t\t\td1 = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (d1 < SMALL_ENOUGH)\n\t{\n\t\td2 = z * z - r;\n\n\t\tif (d2 < 0.0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\td1 = sqrt(d1);\n\t\td2 = 0.5 * q * (1./ d1);\n\t}\n\n\t/* Set up useful values for the quadratic factors */\n\n\tq1 = d1 * d1;\n\tq2 = -c1;\n\n\t/* Solve the first quadratic */\n\n\tp = q1 - 4.0 * (z - d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[0] = -0.5 * (d1 + p) + q2;\n\t\tresults[1] = -0.5 * (d1 - p) + q2;\n\t}\n\n\t/* Solve the second quadratic */\n\n\tp = q1 - 4.0 * (z + d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[2] = 0.5 * (d1 + p) + q2;\n\t\tresults[3] = 0.5 * (d1 - p) + q2;\n\t}\n}\n\n//watch out, unstable on \"small\" R, r, certain planes and slight breezes!! :(\n//http://research.microsoft.com/en-us/um/people/awf/graphics/ray-torus.html\nvec4 RayTorus(vec3 A, vec3 B, float R, float r)\n{\n\t//B assumed normalized\n\t\n\tfloat aa = dot(A,A);\n\tfloat ab = dot(A,B);\n\t\t\n\t// Set up quartic in t:\n\t//\n\t//  4     3     2\n\t// t + A t + B t + C t + D = 0\n\t//\n\t\n\tfloat R2 = R*R;\n\tfloat K = aa - r*r - R2;\n\tK *= 0.5;\n\tfloat qA = ab;\n\tfloat qB = ab*ab + K + R2*B.z*B.z;\n\tfloat qC = K*ab + R2*A.z*B.z;\n\tfloat qD = K*K +  R2*(A.z*A.z - r*r);\n\n    // 4t^3 + 3At^2 + 2Bt + C\n\t//12t^2 + 6At   + 2B\n\t\n\tvec4 roots = vec4(1e10);\n\tquartic_descartes(qA,qB,qC,qD, roots);\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tif (roots[i] < 0.) \n\t\t\troots[i] = 1e10;\t\n\t}\n\t\n\troots = Sort(roots);\n\t\t\n\treturn roots;\n}\n\n#endif\n\n//iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat noise( in vec3 x, float lod_bias )\n{\t\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n#ifndef CHEAPER_NOISES\t\n\tf = f*f*(3.0-2.0*f);\t//not terribly noticeable for higher freq noises anyway\n#endif\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n#ifdef CHEAPER_NOISES\t\n\tvec2 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yx;\n#else\t\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, lod_bias ).yx;\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 noise2( in vec3 x, float lod_bias )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n#ifndef CHEAPER_NOISES\t\n\tf = f*f*(3.0-2.0*f);\n#endif\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n#ifdef CHEAPER_NOISES\t\n\tvec4 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yxwz;\n#else\n\tvec4 rg = texture( iChannel1, (uv+ 0.5)/256.0, lod_bias ).yxwz;\n#endif\t\n\treturn mix( rg.xz, rg.yw, f.z );\n}\n\n/*\n$num = hex $ARGV[0];\nprint \"vec3(\";\nfor ($i=0; $i<3; $i++)\n{\n\t$c = ($num >> ((2-$i)*8))&255;\n\t$f = $c / 255.0;\n\t$f = $f ** 2.2;\n\t$f = -log($f)/$thickness;\n\tprintf( \"%.3f\", $f);  \n\tif ($i < 2)\n\t{\n\tprint \",\";\n\t}\n}\nprint \");\";\n*/\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3zn", "previewfilepath": "/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSGWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsS3DK", "name": "00100100", "author": "mafik", "description": "Smooth interpolation between one and zero.", "tags": ["binary", "0", "one", "1", "zero", "on", "off", "io"], "likes": 7, "viewed": 399, "date": "1393440626", "time_retrieved": "2024-06-20T18:09:08.731302", "image_code": "float wave(float x, float s) {\n\treturn sin(x + mod(iTime * s, 3.1415 * 2.))/2. + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y * 2. - 1.;\n\tuv.x -= (iResolution.x - iResolution.y) / iResolution.y;\n\t\n\tfloat t = mod(iTime* 2., 3.1415 * 2.);\n\tfloat a = 0.;\n\tfor(float i = 1.; i <= 3.; ++i) {\t\n\t\ta += sin(t * (i * 2. - 1.)) / (i * 2. - 1.);\n\t}\n\ta = a * 1.15 / 2. + .5;\n\t\n\tfloat power = 2. / (1. - min(a, .98));\n\tfloat x = pow((1.+2.*a)*abs(uv.x), power);\n\tfloat y = pow(abs(uv.y), power);\n\tfloat r = iResolution.y / 2.;\n\tfloat v = pow(x+y, 1./power);\n\tfloat l = (1. - v) * r;\n\tfloat l2 = (r/2. - l*(1.-a));\n\tfloat s = clamp(min(l, l2), 0., 1.);\n\tvec4 color = vec4(1,1,1,1); // vec4(wave(uv.x,3.), wave(uv.y,5.), wave(uv.x*uv.y,7.),1.0);\n\tfragColor = color * s;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsS3DK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdB3DK", "name": "Kali3d", "author": "guil", "description": "3d pseudo Kleinian using Kali formula", "tags": ["3d", "fractal"], "likes": 7, "viewed": 317, "date": "1393541395", "time_retrieved": "2024-06-20T18:09:09.496649", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Based on https://www.shadertoy.com/view/4ds3zn by IQ\n#define igt  iTime\n\nvec4 ot; \nfloat g=1.94;//g=1.564;\n\nvec3 C =  vec3(-1.42);\nconst int MaxIter = 12;\n \nfloat zoom=1.6;//+.3*sin(.1*igt);\n\nfloat map( vec3 p )\n{\n\tfloat dr = 1.0;\n\t\n\tot = vec4(1000.0); \n  \n\tfor( int i=0; i<MaxIter;i++ )\n\t{\n        \n        \n       \n        float r2 = dot(p,p);\n        if(r2>100.)continue;\n\t\t\n        ot = min( ot, vec4(abs(p),r2) );\n\n\t\t//Scaling, inversion and translation \n          \n         \n\t\tdr= dr/r2*g;            \n\t\tp=abs(p)/r2*g+C;\n\t}\t\n\t//return .16*abs(p.x)*length(p.yz)/dr;  //Try this\n\treturn .25*length(p)/dr*log(length(p));\n\t\n}\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.;\n\tfloat precis = 0.001;\n      \n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n\tif( t>maxd ||  h<precis*(.1+t)) continue;//break;//        \n        \n        t += h;\n\t\th = map( ro+rd*t );\n    }\n\n   \tif( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n\t\n\tvec2 m = vec2(-0.5)*6.28;\n\tif( iMouse.z>0.0 )m = (iMouse.xy/iResolution.xy-.5)*6.28;\n\tm+=.5*vec2(cos(0.15*igt),cos(0.09*igt))+.3;      \n\t\n    // camera\n\n\n\tvec3 ta = vec3(0.,.2*sin(0.12*igt),0.);\n\tvec3 ro = ta- zoom*vec3( cos(m.x)*cos(m.y), sin(m.y), sin(m.x)*cos(m.y));\n\t\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.,1.,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n\n    // trace\t\n\tvec3 col = vec3(0.8,0.8,1.);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.707,0.0  );\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(ot.w*2.0,0.2,1.0), 1.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+key+.2*bac);\n\n        // material\t\t\n\t\tvec3 rgb = vec3(1.0);\n\t\t\n\t\trgb =(0.4*abs(sin(2.5+(vec3(.5*ot.w,ot.y*ot.y,2.-5.*ot.w))))+0.6*sin(vec3(-0.2,-0.6,0.8)+2.3+ot.x*22.5))*.85 + .15;\n\t\trgb.gbr=mix(rgb,rgb.bgr+vec3(0.3,0.1,-.2),0.5+.5*sin(4.5*ot.w));\n\n\n\t\t// color\n\t\tcol = mix(vec3(0.8,0.8,1.),rgb*brdf,exp(-0.08*t));\n\t}\n\n\t\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdB3DK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdBGDK", "name": "Ribbon Assault", "author": "Dave_Hoskins", "description": "Inspired by the 'Kali2 scope' - https://www.shadertoy.com/view/lsBGWK\nShould be fast full-screen for everybody. : )\nUse mouse for manual movement.", "tags": ["ribbon", "ribbonassault"], "likes": 82, "viewed": 18104, "date": "1393425463", "time_retrieved": "2024-06-20T18:09:09.496708", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/MdBGDK\n// By David Hoskins.\n\n// GregRostami's version enabled (see comments....\n\nvoid mainImage( out vec4 o,vec2 U)\n{\n    float T = iTime, f = 3., g = f, d;\n\tvec2 r = iResolution.xy, m = iMouse.xy, p, u = (U+U-r) / r.y;\n\tiMouse.z < .5\n        ? m = (vec2(sin(T*.3)*sin(T*.17) + sin(T * .3),\n          (1.-cos(T*.632))*sin(T*.131)*1.+cos(T* .3))+1.) * r : m;\n\tp = (2.+m-r) / r.y;\n\tfor( int i = 0; i < 20;i++)  \n\t\tu = vec2( u.x, -u.y ) / dot(u,u) + p,  \n\t\tu.x =  abs(u.x),  \n\t\tf = max( f, dot(u-p,u-p) ),  \n\t\tg = min( g, sin(dot(u+p,u+p))+1.);  \n\tf = abs(-log(f) / 3.5);  \n\tg = abs(-log(g) / 8.);  \n\to = min(vec4(g, g*f, f, 0), 1.);\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gTime = iTime+11.0;\n\n    float f = 3., g = 3.;\n\tvec2 res = iResolution.xy;\n\tvec2 mou = iMouse.xy;\n\tif (iMouse.z < 0.5)\n\t{\n\t\tmou = vec2(sin(gTime * .3)*sin(gTime * .17) * 1. + sin(gTime * .3),(1.0-cos(gTime * .632))*sin(gTime * .131)*1.0+cos(gTime * .3));\n\t\tmou = (mou+1.0) * res;\n\t}\n\tvec2 z = ((-res+2.0 * fragCoord.xy) / res.y);\n\tvec2 p = ((-res+2.0+mou) / res.y);\n\tfor( int i = 0; i < 20; i++) \n\t{\n\t\tfloat d = dot(z,z);\n\t\tz = (vec2( z.x, -z.y ) / d) + p; \n\t\tz.x =  abs(z.x);\n\t\tf = max( f, (dot(z-p,z-p) ));\n\t\tg = min( g, sin(dot(z+p,z+p))+1.0);\n\t}\n\tf = abs(-log(f) / 3.5);\n\tg = abs(-log(g) / 8.0);\n\tfragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsBGDK", "name": "Basic KaliSet", "author": "pfhunk", "description": "This is a nice toy to get started muddling in Shadertoy!", "tags": ["2d", "fractal", "tutorial", "kaliset"], "likes": 9, "viewed": 723, "date": "1393434585", "time_retrieved": "2024-06-20T18:09:09.931434", "image_code": "// please comment! I appreciate da input \n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// adapted from https://www.shadertoy.com/view/MdsGDr\n// check out my tutorial http://corbinpercy.com/2d-fractals-part-2-fractal-tutorial-using-shadertoy/\n// A little improv: https://www.shadertoy.com/view/MdjGRG    try it yourself!!\n\nconst int iterations=12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 z=fragCoord.xy / iResolution.xy-.5;\n\tvec2 z = fragCoord.xy / iResolution.xy*2.0 - 1.0;\n\t\n\t//fixes aspect ratio in favor of symmety\n\tz.y*=iResolution.y/iResolution.x;\n\t\t\n\t//gloobywavez\n\tz.x += sin(z.y*1.0+iTime * .2)/10.0;\n\t\n\t//zooom\n\tz*= 1.2 + sin(iTime*.45);\n\t\n\t//pan\n\tz+=vec2(sin(iTime*.2),cos(iTime*.01));\n\t\n\t//rotate\n\t//z=vec2(z.x*cos(iTime*.2)-z.y*sin(iTime*.2),z.y*cos(iTime*.2)+z.x*sin(iTime*.2));\n\t\n\t//this is our \"starting point\" try numbers between 0 and 2 for both x and y \n\tvec2 c=vec2(1.5, 1.1);\n\n\tfloat average=0.;\n\tfloat l=length(z);\n\tfloat prevl;\n\tfor (int i=0; i<iterations; i++) \n\t{\t\n\t\t//kaliset base form\n\t\tz=abs(z)/dot(z,z) -c; \n\t\t\t\t\n\t\t//this is another function that can be iterated to produce some different fractals\n\t\t//comment out the previous kaliset and experiment with values with this one!!\n\t\t//z = abs(z)/(z.x*z.y)-c;\n\n\t\tprevl=l;\n\t\tl=length(z);\n\t\n\t\taverage+=abs(l-prevl);\n\t}\n\t\n\t//get the average length based upon the amount of iterations elapsed. multiply it to adjust \"definition\"\n\taverage/=float(iterations) * 15.;\n\t\n\t//color fluctuation\n\taverage+=iTime*0.02;\n\t\n\tvec3 myColor=vec3(0.2,0.21,.62);\n\tvec3 finalColor;\t\n\t\n\t//set the colors! \n\tfinalColor.r = (fract(float(average)/myColor.r));\n\tfinalColor.g = (fract(float(average)/myColor.g));\n\tfinalColor.b = (fract(float(average)/myColor.b));\n\t\n\tfragColor = vec4(finalColor,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdS3WK", "name": "Tangled  Bezier", "author": "gaz", "description": "2d", "tags": ["2d"], "likes": 5, "viewed": 204, "date": "1393254255", "time_retrieved": "2024-06-20T18:09:09.931434", "image_code": "// http://glslsandbox.com/e#5007\nfloat cross2(vec2 a, vec2 b) {return a.x*b.y-b.x*a.y;}\n\nfloat bezDe(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n\tvec2 ap = a-p;\n\tvec2 bp = b-p;\n\tvec2 cp = c-p;\n\tfloat xac = cross2(ap,cp);\n\tfloat xba = 2.0*cross2(bp,ap);\n\tfloat xcb = 2.0*cross2(cp,bp);\n\tfloat f = xba*xcb-xac*xac;\n\tvec2 cb = c-b;\n\tvec2 ba = b-a;\n\tvec2 ca = c-a;\n\tvec2 gf = 2.0*(xba*cb+xcb*ba+xac*ca);\n\tgf = vec2(gf.y,-gf.x);\n\tvec2 pp = -f*gf/dot(gf,gf);\n\tvec2 d0p = ap-pp;\n\tfloat aa = cross2(d0p,ca);\n\tfloat bb = 2.0*cross2(ba,d0p);\n\tfloat t = (aa+bb)/(2.0*xac+xba+xcb);\n\t//t = clamp(t, 0.0, 1.0);\n\tvec2 uv = mix(mix(ap,bp,t),mix(bp,cp,t),t);\n\treturn length(uv);\n}\n\nvec4 quaternion(vec3 p, float a)\n{\n\treturn vec4(p*sin(a/2.0),cos(a/2.0));\n}\n\nvec3 qtransform(vec4 q, vec3 v)\n{\n\treturn v+2.0*cross(cross(v,q.xyz)-q.w*v,q.xyz);\n}\n\nvec4 qmult(vec4 q1 ,vec4 q2)\n{\n\tvec4 q;\n\tq.xyz = q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz);\n\tq.w = q1.w*q2.w-dot(q1.xyz,q2.xyz);  \n\treturn q;\n}\n\nvec3 perspective(vec3 p)\n{\n\tfloat l = 5.0;\n\tfloat t = l/(l-p.z);\n\treturn p*t;\t\n}\n\nvec3 hash3(float n)\n{\n\tvec3 p = vec3(dot(vec2(n+857.3, 124.8), vec2(127.1, 311.7)),\n\t\t\t\t  dot(vec2(n+572.2, 450.2), vec2(269.5, 183.3)),\n\t\t\t\t  dot(vec2(n+205.7, 381.4), vec2(760.5, 583.3)));\n\treturn (2.0*fract(sin(p)*43758.5453)-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n\tvec3 p0, p1 ,p2;\n\tvec4 q = quaternion(normalize(vec3(0.0, 1.0, 0.0)), iTime);;\n\tfloat d = 1.0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tp0 = 2.0*hash3(float(i*3));\n\t\tp1 = 0.3*hash3(float(i*3+1));\n\t\tp2 = 2.0*hash3(float(i*3+2));\n\t\tp1+=(p1-((p0+p2)*0.5));\n\t\tp0 = qtransform(q, p0);\n\t\tp1 = qtransform(q, p1);\n\t\tp2 = qtransform(q, p2);\n\t\tp0 = perspective(p0);\n\t\tp1 = perspective(p1);\n\t\tp2 = perspective(p2);\n\t\td = min(bezDe(p0.xy, p1.xy, p2.xy, p), d);\n\t}\n\td = 0.03/d;\n\tfragColor = vec4(vec3(1.0,0.4,0.1)*d, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdS3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2GDK", "name": "Kali3d2", "author": "guil", "description": "An exotic de for rendering kleinian fractals (see line 37), here a Kaliset.", "tags": ["3d", "fractal", "distanceestimation"], "likes": 12, "viewed": 402, "date": "1393601278", "time_retrieved": "2024-06-20T18:09:09.937653", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Based on https://www.shadertoy.com/view/4ds3zn by IQ\n#define igt  iTime\n\nvec4 ot; \nfloat g=1.;\n\nvec3 C =  vec3(1.05);//vec3(.7,.9,1.41);\nconst int MaxIter = 12;\n\nfloat zoom=1.2;\n\nfloat map( vec3 p )\n{\n\tfloat dr = 1.0;\n\t\n\tot = vec4(1000.0); \n\tfloat r2;\n  \n\tfor( int i=0; i<MaxIter;i++ )\n\t{\n        \n        \n       \n        r2 = dot(p,p);\n        if(r2>100.)continue;\n\t\t\n        ot = min( ot, vec4(abs(p),r2) );\n\n\t\t//Kali formula \n        p=abs(p)/r2*g-C; \n         \n\t\tdr= dr/r2*g;            \n\t\t\n\t}\t\n\treturn .1*(abs(p.x)+abs(p.y))*length(p)/dr;\n\t//return .1*(length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z)+length(p.yz)*abs(p.x))/dr;\n\t//return .15*(length(p.xz))*length(p.xy)/dr;\n\t//return .125*sqrt(r2)*log(r2)/dr;\n\t//return .1*length(p)/dr;\n\t\n}\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.;\n\tfloat precis = 0.001;\n      \n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n\tif( t>maxd ||  h<precis*(.1+t)) continue;//break;//        \n        \n        t += h;\n\t\th = map( ro+rd*t );\n    }\n\n   \tif( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n\t\n\tvec2 m = vec2(-0.5)*6.28;\n\tif( iMouse.z>0.0 )m = (iMouse.xy/iResolution.xy-.5)*6.28;\n\tm+=.5*vec2(cos(0.15*igt),cos(0.09*igt))+.3;      \n\t\n    // camera\n\n\n\tvec3 ta = vec3(0.,.2*sin(0.12*igt),0.);\n\tvec3 ro = ta- zoom*vec3( cos(m.x)*cos(m.y), sin(m.y), sin(m.x)*cos(m.y));\n\t\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.,1.,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n\n    // trace\t\n\tvec3 col = vec3(0.8,0.8,1.);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, -0.707,0.0  );\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(ot.w*2.0,0.2,1.0), 1.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+key+.2*bac);\n\n        // material\t\t\n\t\tvec3 rgb = vec3(1.0);\n\t\t\n\t\trgb =(0.4*abs(sin(2.5+(vec3(.5*ot.w,ot.y*ot.y,2.-5.*ot.w))))+1.6*sin(vec3(-0.2,-0.6,0.8)+0.+ot.x*18.))*.85 + .15;\n\t\trgb.gbr=mix(rgb,rgb.bgr+vec3(0.3,0.1,-.2),0.5+.5*sin(8.5*ot.w));\n\n\n\t\t// color\n\t\tcol = mix(vec3(0.8,0.8,1.),rgb*brdf,exp(-0.08*t));\n\t}\n\n\t\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2GDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsBGDK", "name": "Simple Pacman", "author": "asalga", "description": "Simple Pacman", "tags": ["2d"], "likes": 2, "viewed": 304, "date": "1393250429", "time_retrieved": "2024-06-20T18:09:09.937653", "image_code": "/*\n\tAndor Salga\n\t\n*/\n\n#define PI\t\t\t\t3.14159265359\n#define HALF_PI\t\t\t1.57079632679\n#define FOOD_SIZE\t\t40.0\n#define FOOD_SPEED\t\t1.0\n#define FOOD_AT_A_TIME\t2.5\n#define T\t\t\t\tiTime\n#define res\t\t\t\tiResolution\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0, 0, 0, 1);\n\t\n\tvec2 pacPos = vec2(50.-sin(iTime)*100., 0.);\n\t\n\tfloat foodSpeed = res.x * T * FOOD_SPEED;\n\tfloat theta = abs(sin(mod(T * PI * FOOD_SPEED * FOOD_AT_A_TIME, PI)))* HALF_PI / 2.0 ;\n\t\n\tvec2 p = vec2(res.xy/2. - fragCoord.xy);\n\t\t\n\t// food\n\tif( int(mod(p.x - foodSpeed - pacPos.x, res.x/FOOD_AT_A_TIME) / FOOD_SIZE) == 0 &&\n  \t    int(mod(p.y + FOOD_SIZE/2., res.y) / FOOD_SIZE) == 0 &&\n\t   \tp.x < pacPos.x){\n\t\tfragColor = vec4(1);\n\t}\n\t\n\t// pacman\n\tif( distance(fragCoord.xy + pacPos, res.xy/2.) < res.y/3.){\n\t\tvec2 p2 = res.xy/2.0 - fragCoord.xy - pacPos;\n\t\tfloat t = atan( abs(p2.y)/ -p2.x);\n\t\t\n\t\t// always draw backside\n\t\tif(p2.x > 0. || t > theta){\n\t\t\tfragColor = vec4(1, 1, 0, 1);\n\t\t}\t\n\t}\n\t\n\t// blue borders\n\tfragColor += step(fragCoord.y, 10.) * vec4(0,0,1,1);\n\tfragColor += step(res.y-fragCoord.y, 10.) * vec4(0,0,1,1);\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsS3DV", "name": "Satori", "author": "phagor", "description": "Based on an old Mac screensaver I liked back in the day. Click and drag to change the gradient used.", "tags": ["blobs", "distancefield", "metaballs", "gradient"], "likes": 28, "viewed": 1386, "date": "1393625491", "time_retrieved": "2024-06-20T18:09:09.943296", "image_code": "\nfloat k = 20.0;\nfloat field = 0.0;\nvec2 coord;\n\nvec2 center ( vec2 border , vec2 offset , vec2 vel ) {\n\tvec2 c;\n\tif ( vel.x == 0.0 && vel.y == 0.0 ) {\n\t\tc = vec2(iMouse.x, iMouse.y);\t\n\t} \n\telse {\n\t\tc = offset + vel * iTime * 0.5;\n\t\tc = mod ( c , 2. - 4. * border );\n\t\tif ( c.x > 1. - border.x ) c.x = 2. - c.x - 2. * border.x;\n\t\tif ( c.x < border.x ) c.x = 2. * border.x - c.x;\n\t\tif ( c.y > 1. - border.y ) c.y = 2. - c.y - 2. * border.y;\n\t\tif ( c.y < border.y ) c.y = 2. * border.y - c.y;\n\t}\n\treturn c;\n}\n\nvoid circle ( float r , vec3 col , vec2 offset , vec2 vel ) {\n\tvec2 pos = coord.xy / iResolution.y;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 c = center ( vec2 ( r / aspect , r ) , offset , vel );\n\tc.x *= aspect;\n\tfloat d = distance ( pos , c );\n\tfield += ( k * r ) / ( d*d );\n}\n\t\nvec3 band ( float shade, float low, float high, vec3 col1, vec3 col2 ) {\n\n\tif ( (shade >= low) && (shade <= high) ) {\n\t\tfloat delta = (shade - low) / (high - low);\n\t\tvec3 colDiff = col2 - col1;\n\t\treturn col1 + (delta * colDiff);\n\t}\n\telse\n\t\treturn vec3(0.0,0.0,0.0);\n}\n\nvec3 gradient ( float shade ) {\n\tvec3 colour = vec3( (sin(iTime/2.0)*0.25)+0.25,0.0,(cos(iTime/2.0)*0.25)+0.25);\n\t\n\tvec2 mouseScaled = iMouse.xy/iResolution.xy;\n\tvec3 col1 = vec3(mouseScaled.x, 0.0, 1.0-mouseScaled.x);\n\tvec3 col2 = vec3(1.0-mouseScaled.x, 0.0, mouseScaled.x);\n\tvec3 col3 = vec3(mouseScaled.y, 1.0-mouseScaled.y, mouseScaled.y);\n\tvec3 col4 = vec3((mouseScaled.x+mouseScaled.y)/2.0, (mouseScaled.x+mouseScaled.y)/2.0, 1.0 - (mouseScaled.x+mouseScaled.y)/2.0);\n\tvec3 col5 = vec3(mouseScaled.y, mouseScaled.y, mouseScaled.y);\n\t\n\tcolour += band ( shade, 0.0, 0.3, colour, col1 );\n\tcolour += band ( shade, 0.3, 0.6, col1, col2 );\n\tcolour += band ( shade, 0.6, 0.8, col2, col3 );\n\tcolour += band ( shade, 0.8, 0.9, col3, col4 );\n\tcolour += band ( shade, 0.9, 1.0, col4, col5 );\n\t\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    coord = fragCoord;\n    \n\tcircle ( .03 , vec3 ( 0.7 , 0.2 , 0.8 ) , vec2 ( .6 ) , vec2 ( .30 , .70 ) );\n\tcircle ( .05 , vec3 ( 0.7 , 0.9 , 0.6 ) , vec2 ( .1 ) , vec2 ( .02 , .20 ) );\n\tcircle ( .07 , vec3 ( 0.3 , 0.4 , 0.1 ) , vec2 ( .1 ) , vec2 ( .10 , .04 ) );\n\tcircle ( .10 , vec3 ( 0.2 , 0.5 , 0.1 ) , vec2 ( .3 ) , vec2 ( .10 , .20 ) );\n\tcircle ( .20 , vec3 ( 0.1 , 0.3 , 0.7 ) , vec2 ( .2 ) , vec2 ( .40 , .25 ) );\n\tcircle ( .30 , vec3 ( 0.9 , 0.4 , 0.2 ) , vec2 ( .0 ) , vec2 ( .15 , .20 ) );\n\tcircle ( .30 , vec3 ( 0.0 , 0.0 , 0.0 ) , vec2 ( .0 ),  vec2 ( 0.0, 0.0 ) );\n\t\n\tfloat shade = min ( 1.0, max ( field/256.0, 0.0 ) );\n\t\n\tfragColor = vec4( gradient(shade), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsS3DV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
